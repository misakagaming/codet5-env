{"id": 344037, "name": "Range consolidation", "source": "Translate Haskell to Java: import Data.List (intercalate, maximumBy, sort)\nimport Data.Ord (comparing)\n\n\n\nconsolidated :: [(Float, Float)] -> [(Float, Float)]\nconsolidated = foldr go [] . sort . fmap ab\n  where\n    go xy [] = [xy]\n    go xy@(x, y) abetc@((a, b) : etc)\n      | y >= b = xy : etc\n      | y >= a = (x, b) : etc\n      | otherwise = xy : abetc\n    ab (a, b)\n      | a <= b = (a, b)\n      | otherwise = (b, a)\n\n\n\ntests :: [[(Float, Float)]]\ntests =\n  [ [],\n    [(1.1, 2.2)],\n    [(6.1, 7.2), (7.2, 8.3)],\n    [(4, 3), (2, 1)],\n    [(4, 3), (2, 1), (-1, -2), (3.9, 10)],\n    [(1, 3), (-6, -1), (-4, -5), (8, 2), (-6, -6)]\n  ]\n\nmain :: IO ()\nmain =\n  putStrLn $\n    tabulated\n      \"Range consolidations:\"\n      showPairs\n      showPairs\n      consolidated\n      tests\n\n\n\ntabulated ::\n  String ->\n  (a -> String) ->\n  (b -> String) ->\n  (a -> b) ->\n  [a] ->\n  String\ntabulated s xShow fxShow f xs =\n  let w =\n        length $\n          maximumBy\n            (comparing length)\n            (xShow <$> xs)\n      rjust n c s = drop (length s) (replicate n c <> s)\n   in unlines $\n        s :\n        fmap\n          ( ((<>) . rjust w ' ' . xShow)\n              <*> ((\" -> \" <>) . fxShow . f)\n          )\n          xs\n\nshowPairs :: [(Float, Float)] -> String\nshowPairs xs\n  | null xs = \"[]\"\n  | otherwise =\n    '[' :\n    intercalate\n      \", \"\n      (showPair <$> xs)\n      <> \"]\"\n\nshowPair :: (Float, Float) -> String\nshowPair (a, b) =\n  '(' :\n  showNum a\n    <> \", \"\n    <> showNum b\n    <> \")\"\n\nshowNum :: Float -> String\nshowNum n\n  | 0 == (n - fromIntegral (round n)) = show (round n)\n  | otherwise = show n\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class RangeConsolidation {\n\n    public static void main(String[] args) {\n        displayRanges( Arrays.asList(new Range(1.1, 2.2)));\n        displayRanges( Arrays.asList(new Range(6.1, 7.2), new Range(7.2, 8.3)));\n        displayRanges( Arrays.asList(new Range(4, 3), new Range(2, 1)));\n        displayRanges( Arrays.asList(new Range(4, 3), new Range(2, 1), new Range(-1, -2), new Range(3.9, 10)));\n        displayRanges( Arrays.asList(new Range(1, 3), new Range(-6, -1), new Range(-4, -5), new Range(8, 2), new Range(-6, -6)));\n        displayRanges( Arrays.asList(new Range(1, 1), new Range(1, 1)));\n        displayRanges( Arrays.asList(new Range(1, 1), new Range(1, 2)));\n        displayRanges( Arrays.asList(new Range(1, 2), new Range(3, 4), new Range(1.5, 3.5), new Range(1.2, 2.5)));\n    }\n    \n    private static final void displayRanges(List<Range> ranges) {\n        System.out.printf(\"ranges =\u00a0%-70s, colsolidated = %s%n\", ranges, Range.consolidate(ranges));\n    }\n    \n    private static final class RangeSorter implements Comparator<Range> {\n        @Override\n        public int compare(Range o1, Range o2) {\n            return (int) (o1.left - o2.left);\n        }        \n    }\n\n    private static class Range {\n        double left;\n        double right;\n        \n        public Range(double left, double right) {\n            if ( left <= right ) {\n                this.left = left;\n                this.right = right;\n            }\n            else {\n                this.left = right;\n                this.right = left;\n            }\n        }\n        \n        public Range consolidate(Range range) {\n            \n            if ( this.right < range.left ) {\n                return null;\n            }\n            \n            if ( range.right < this.left ) {\n                return null;\n            }\n            \n            if ( this.left <= range.left && this.right >= range.right ) {\n                return this;\n            }\n            \n            if ( range.left <= this.left && range.right >= this.right ) {\n                return range;\n            }\n            \n            if ( this.left <= range.left && this.right <= range.right ) {\n                return new Range(this.left, range.right);\n            }\n            \n            if ( this.left >= range.left && this.right >= range.right ) {\n                return new Range(range.left, this.right);\n            }\n            throw new RuntimeException(\"ERROR:  Logic invalid.\");\n        }\n        \n        @Override\n        public String toString() {\n            return \"[\" + left + \", \" + right + \"]\";\n        }\n        \n        private static List<Range> consolidate(List<Range> ranges) {\n            List<Range> consolidated = new ArrayList<>();\n            \n            Collections.sort(ranges, new RangeSorter());\n            \n            for ( Range inRange : ranges ) {\n                Range r = null;\n                Range conRange = null;\n                for ( Range conRangeLoop : consolidated ) {\n                    r = inRange.consolidate(conRangeLoop);\n                    if (r != null ) {\n                        conRange = conRangeLoop;\n                        break;\n                    }\n                }\n                if ( r == null ) {\n                    consolidated.add(inRange);\n                }\n                else {\n                    consolidated.remove(conRange);\n                    consolidated.add(r);                    \n                }\n            }\n            \n            Collections.sort(consolidated, new RangeSorter());\n            \n            return consolidated;\n        }\n    }\n\n}\n"}
{"id": 344038, "name": "Pascal matrix generation", "source": "Translate Haskell to Java: import Data.List (transpose)\nimport System.Environment (getArgs)\nimport Text.Printf (printf)\n\n\npascal :: [[Int]]\npascal = iterate (\\row -> 1 : zipWith (+) row (tail row) ++ [1]) [1]\n\n\npascLow :: Int -> [[Int]]\npascLow n = zipWith (\\row i -> row ++ replicate (n-i) 0) (take n pascal) [1..]\n\n\npascUp :: Int -> [[Int]]\npascUp = transpose . pascLow\n\n\npascSym :: Int -> [[Int]]\npascSym n = take n . map (take n) . transpose $ pascal\n\n\nprintMat :: String -> [[Int]] -> IO ()\nprintMat title mat = do\n  putStrLn $ title ++ \"\\n\"\n  mapM_ (putStrLn . concatMap (printf \" %2d\")) mat\n  putStrLn \"\\n\"\n\nmain :: IO ()\nmain = do\n  ns <- fmap (map read) getArgs\n  case ns of\n    [n] -> do printMat \"Lower triangular\" $ pascLow n\n              printMat \"Upper triangular\" $ pascUp  n\n              printMat \"Symmetric\"        $ pascSym n\n    _   -> error \"Usage: pascmat <number>\"\n", "target": "import static java.lang.System.out;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.stream.*;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\n\npublic class PascalMatrix {\n    static int binomialCoef(int n, int k) {\n        int result = 1;\n        for (int i = 1; i <= k; i++)\n            result = result * (n - i + 1) / i;\n        return result;\n    }\n\n    static List<IntStream> pascal(int n, Function<Integer, IntStream> f) {\n        return range(0, n).mapToObj(i -> f.apply(i)).collect(toList());\n    }\n\n    static List<IntStream> pascalUpp(int n) {\n        return pascal(n, i -> range(0, n).map(j -> binomialCoef(j, i)));\n    }\n\n    static List<IntStream> pascalLow(int n) {\n        return pascal(n, i -> range(0, n).map(j -> binomialCoef(i, j)));\n    }\n\n    static List<IntStream> pascalSym(int n) {\n        return pascal(n, i -> range(0, n).map(j -> binomialCoef(i + j, i)));\n    }\n\n    static void print(String label, List<IntStream> result) {\n        out.println(\"\\n\" + label);\n        for (IntStream row : result) {\n            row.forEach(i -> out.printf(\"%2d \", i));\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] a) {\n        print(\"Upper: \", pascalUpp(5));\n        print(\"Lower: \", pascalLow(5));\n        print(\"Symmetric:\", pascalSym(5));\n    }\n}\n"}
{"id": 344039, "name": "Mad Libs", "source": "Translate Haskell to Java: import System.IO (stdout, hFlush)\n\nimport System.Environment (getArgs)\n\nimport qualified Data.Map as M (Map, lookup, insert, empty)\n\ngetLines :: IO [String]\ngetLines = reverse <$> getLines_ []\n  where\n    getLines_ xs = do\n      line <- getLine\n      case line of\n        [] -> return xs\n        _ -> getLines_ $ line : xs\n\nprompt :: String -> IO String\nprompt p = putStr p >> hFlush stdout >> getLine\n\ngetKeyword :: String -> Maybe String\ngetKeyword ('<':xs) = getKeyword_ xs []\n  where\n    getKeyword_ [] _ = Nothing\n    getKeyword_ (x:'>':_) acc = Just $ '<' : reverse ('>' : x : acc)\n    getKeyword_ (x:xs) acc = getKeyword_ xs $ x : acc\ngetKeyword _ = Nothing\n\nparseText :: String -> M.Map String String -> IO String\nparseText [] _ = return []\nparseText line@(l:lx) keywords =\n  case getKeyword line of\n    Nothing -> (l :) <$> parseText lx keywords\n    Just keyword -> do\n      let rest = drop (length keyword) line\n      case M.lookup keyword keywords of\n        Nothing -> do\n          newword <- prompt $ \"Enter a word for \" ++ keyword ++ \": \"\n          rest_ <- parseText rest $ M.insert keyword newword keywords\n          return $ newword ++ rest_\n        Just knownword -> do\n          rest_ <- parseText rest keywords\n          return $ knownword ++ rest_\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  nlines <-\n    case args of\n      [] -> unlines <$> getLines\n      arg:_ -> readFile arg\n  nlines_ <- parseText nlines M.empty\n  putStrLn \"\"\n  putStrLn nlines_\n", "target": "import java.util.*;\n\npublic class MadLibs {\n    \n    public static void main(String[] args){\n        Scanner input = new Scanner(System.in);\n        \n        String name, gender, noun;\n        \n        System.out.print(\"Enter a name: \");\n        name = input.next();\n        \n        System.out.print(\"He or she: \");\n        gender = input.next();\n        \n        System.out.print(\"Enter a noun: \");\n        noun = input.next();\n        \n        System.out.println(\"\\f\" + name + \" went for a walk in the park. \" + gender + \"\\nfound a \" + noun + \". \" + name + \" decided to take it home.\");\n        \n    \n    }\n}\n"}
{"id": 344040, "name": "Shortest common supersequence", "source": "Translate Haskell to Java: scs :: Eq a  => [a] -> [a] -> [a]\nscs [] ys = ys\nscs xs [] = xs\nscs xss@(x:xs) yss@(y:ys)\n  | x == y = x : scs xs ys\n  | otherwise = ws\n      where\n      us = scs xs yss\n      vs = scs xss ys\n      ws  | length us < length vs = x : us\n          | otherwise = y : vs\n\nmain = putStrLn $ scs \"abcbdab\" \"bdcaba\"\n", "target": "public class ShortestCommonSuperSequence {\n    private static boolean isEmpty(String s) {\n        return null == s || s.isEmpty();\n    }\n\n    private static String scs(String x, String y) {\n        if (isEmpty(x)) {\n            return y;\n        }\n        if (isEmpty(y)) {\n            return x;\n        }\n\n        if (x.charAt(0) == y.charAt(0)) {\n            return x.charAt(0) + scs(x.substring(1), y.substring(1));\n        }\n\n        if (scs(x, y.substring(1)).length() <= scs(x.substring(1), y).length()) {\n            return y.charAt(0) + scs(x, y.substring(1));\n        } else {\n            return x.charAt(0) + scs(x.substring(1), y);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(scs(\"abcbdab\", \"bdcaba\"));\n    }\n}\n"}
{"id": 344041, "name": "Long year", "source": "Translate Haskell to Java: import Data.Time.Calendar (fromGregorian)\nimport Data.Time.Calendar.WeekDate (toWeekDate)\n\nlongYear :: Integer -> Bool\nlongYear y =\n  let (_, w, _) = toWeekDate $ fromGregorian y 12 28\n   in 52 < w\n\nmain :: IO ()\nmain = mapM_ print $ filter longYear [2000 .. 2100]\n", "target": "import java.time.LocalDate;\nimport java.time.temporal.WeekFields;\n\npublic class LongYear {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Long years this century:%n\");\n        for (int year = 2000 ; year < 2100 ; year++ ) {\n            if ( longYear(year) ) {\n                System.out.print(year + \"  \");\n            }\n        }\n    }\n    \n    private static boolean longYear(int year) {\n        return LocalDate.of(year, 12, 28).get(WeekFields.ISO.weekOfYear()) == 53;\n    }\n\n}\n"}
{"id": 344042, "name": "Mian-Chowla sequence", "source": "Translate Haskell to Java: import Data.Set (Set, fromList, insert, member)\n\n\nmianChowlas :: Int -> [Int]\nmianChowlas =\n  reverse . snd . (iterate nextMC (fromList [2], [1]) !!) . subtract 1\n\nnextMC :: (Set Int, [Int]) -> (Set Int, [Int])\nnextMC (sumSet, mcs@(n:_)) =\n  (foldr insert sumSet ((2 * m) : fmap (m +) mcs), m : mcs)\n  where\n    valid x = not $ any (flip member sumSet . (x +)) mcs\n    m = until valid succ n\n\n\nmain :: IO ()\nmain =\n  (putStrLn . unlines)\n    [ \"First 30 terms of the Mian-Chowla series:\"\n    , show (mianChowlas 30)\n    , []\n    , \"Terms 91 to 100 of the Mian-Chowla series:\"\n    , show $ drop 90 (mianChowlas 100)\n    ]\n", "target": "import java.util.Arrays;\n\npublic class MianChowlaSequence {\n\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        System.out.println(\"First 30 terms of the Mian\u2013Chowla sequence.\");\n        mianChowla(1, 30);\n        System.out.println(\"Terms 91 through 100 of the Mian\u2013Chowla sequence.\");\n        mianChowla(91, 100);\n        long end = System.currentTimeMillis();\n        System.out.printf(\"Elapsed = %d ms%n\", (end-start));\n    }\n\n    private static void mianChowla(int minIndex, int maxIndex) {\n        int [] sums = new int[1];\n        int [] chowla = new int[maxIndex+1];\n        sums[0] = 2;\n        chowla[0] = 0;\n        chowla[1] = 1;\n        if ( minIndex == 1 ) {\n            System.out.printf(\"%d \", 1);\n        }\n        int chowlaLength = 1;\n        for ( int n = 2 ; n <= maxIndex ; n++ ) {\n\n            \n            int test = chowla[n - 1];\n            \n            int[] sumsNew = Arrays.copyOf(sums, sums.length + n);\n            int sumNewLength = sums.length;\n            int savedsSumNewLength = sumNewLength;\n            \n            \n            boolean found = false;\n            while ( ! found ) {\n                test++;\n                found = true;\n                sumNewLength = savedsSumNewLength;\n                \n                for ( int j = 0 ; j <= chowlaLength ; j++ ) {\n                    int testSum = (j == 0 ? test : chowla[j]) + test;\n                    boolean duplicate = false;\n                    \n                    \n                    for ( int k = 0 ; k < sumNewLength ; k++ ) {\n                        if ( sumsNew[k] == testSum ) {\n                            duplicate = true;\n                            break;\n                        }\n                    }\n                    if ( ! duplicate ) {\n                        \n                        sumsNew[sumNewLength] = testSum;\n                        sumNewLength++;\n                    }\n                    else {\n                        \n                        found = false;\n                        break;\n                    }\n                }\n            }\n            \n            \n            chowla[n] = test;\n            chowlaLength++;            \n            sums = sumsNew;\n            if ( n >= minIndex ) {\n                System.out.printf(\"%d %s\", chowla[n], (n==maxIndex ? \"\\n\" : \"\"));\n            }\n        }\n    }\n\n}\n"}
{"id": 344043, "name": "Water collected between towers", "source": "Translate Haskell to Java: import Data.Vector.Unboxed (Vector)\nimport qualified Data.Vector.Unboxed as V\n\nwaterCollected :: Vector Int -> Int\nwaterCollected =\n  V.sum .            \n  V.filter (> 0) .   \n  (V.zipWith (-) =<< \n   (V.zipWith min .  \n    V.scanl1 max <*> \n    V.scanr1 max))   \n\nmain :: IO ()\nmain =\n  mapM_\n    (print . waterCollected . V.fromList)\n    [ [1, 5, 3, 7, 2]\n    , [5, 3, 7, 2, 6, 4, 5, 9, 1, 2]\n    , [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1]\n    , [5, 5, 5, 5]\n    , [5, 6, 7, 8]\n    , [8, 7, 7, 6]\n    , [6, 7, 10, 7, 6]\n    ]\n", "target": "public class WaterBetweenTowers {\n    public static void main(String[] args) {\n        int i = 1;\n        int[][] tba = new int[][]{\n            new int[]{1, 5, 3, 7, 2},\n            new int[]{5, 3, 7, 2, 6, 4, 5, 9, 1, 2},\n            new int[]{2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1},\n            new int[]{5, 5, 5, 5},\n            new int[]{5, 6, 7, 8},\n            new int[]{8, 7, 7, 6},\n            new int[]{6, 7, 10, 7, 6}\n        };\n\n        for (int[] tea : tba) {\n            int rht, wu = 0, bof;\n            do {\n                for (rht = tea.length - 1; rht >= 0; rht--) {\n                    if (tea[rht] > 0) {\n                        break;\n                    }\n                }\n\n                if (rht < 0) {\n                    break;\n                }\n\n                bof = 0;\n                for (int col = 0; col <= rht; col++) {\n                    if (tea[col] > 0) {\n                        tea[col]--;\n                        bof += 1;\n                    } else if (bof > 0) {\n                        wu++;\n                    }\n                }\n                if (bof < 2) {\n                    break;\n                }\n            } while (true);\n\n            System.out.printf(\"Block %d\", i++);\n            if (wu == 0) {\n                System.out.print(\" does not hold any\");\n            } else {\n                System.out.printf(\" holds %d\", wu);\n            }\n            System.out.println(\" water units.\");\n        }\n    }\n}\n"}
{"id": 344044, "name": "FASTA format", "source": "Translate Haskell to Java: import Data.List ( groupBy )\n\nparseFasta :: FilePath -> IO ()\nparseFasta fileName = do\n  file <- readFile fileName\n  let pairedFasta = readFasta $ lines file\n  mapM_ (\\(name, code) -> putStrLn $ name ++ \": \" ++ code) pairedFasta\n\nreadFasta :: [String] -> [(String, String)]\nreadFasta = pair . map concat . groupBy (\\x y -> notName x && notName y)\n where\n  notName :: String -> Bool\n  notName = (/=) '>' . head\n\n  pair :: [String] -> [(String, String)]\n  pair []           = []\n  pair (x : y : xs) = (drop 1 x, y) : pair xs\n", "target": "import java.io.*;\nimport java.util.Scanner;\n\npublic class ReadFastaFile {\n\n    public static void main(String[] args) throws FileNotFoundException {\n\n        boolean first = true;\n\n        try (Scanner sc = new Scanner(new File(\"test.fasta\"))) {\n            while (sc.hasNextLine()) {\n                String line = sc.nextLine().trim();\n                if (line.charAt(0) == '>') {\n                    if (first)\n                        first = false;\n                    else\n                        System.out.println();\n                    System.out.printf(\"%s: \", line.substring(1));\n                } else {\n                    System.out.print(line);\n                }\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 344045, "name": "MAC vendor lookup", "source": "Translate Haskell to Java: #!/usr/bin/env stack\n\n\n\n\nimport Control.Exception (try)\nimport Control.Monad (forM_)\nimport qualified Data.ByteString.Lazy.Char8 as L8 (ByteString, unpack)\nimport Network.HTTP.Client\n  (Manager, parseRequest, httpLbs, responseStatus, responseBody,\n   newManager, defaultManagerSettings, Response, HttpException)\nimport Network.HTTP.Types.Status (statusIsSuccessful, notFound404)\nimport System.Environment (getArgs)\nimport Text.Printf (printf)\n\nfetchURL :: Manager\n         -> String\n         -> IO (Either HttpException (Response L8.ByteString))\nfetchURL mgr url = try $ do\n  req <- parseRequest url\n  httpLbs req mgr\n\nlookupMac :: Manager -> String -> IO String\nlookupMac mgr mac = do\n  eth <- fetchURL mgr $ \"http://api.macvendors.com/\" ++ mac\n  return $ case eth of\n             Left _ -> \"null\"\n             Right resp -> let body = responseBody resp\n                               status = responseStatus resp\n                           in if | status == notFound404 -> \"N/A\"\n                                 | not (statusIsSuccessful status) -> \"null\"\n                                 | otherwise -> L8.unpack body\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  mgr <- newManager defaultManagerSettings\n  forM_ args $ \\mac -> do\n    putStr $ printf \"%-17s\" mac ++ \" = \"\n    vendor <- lookupMac mgr mac\n    putStrLn vendor\n", "target": "package com.jamesdonnell.MACVendor;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n\npublic class Lookup {\n\t\n\tprivate static final String baseURL = \"http:\n\n\t\n\tpublic static void main(String[] args) {\n\t\tfor (String arguments : args)\n\t\t\tSystem.out.println(arguments + \": \" + get(arguments));\n\t}\n\n\t\n\tprivate static String get(String macAddress) {\n\t\ttry {\n\t\t\tStringBuilder result = new StringBuilder();\n\t\t\tURL url = new URL(baseURL + macAddress);\n\t\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\t\t\tconn.setRequestMethod(\"GET\");\n\t\t\tBufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n\t\t\tString line;\n\t\t\twhile ((line = rd.readLine()) != null) {\n\t\t\t\tresult.append(line);\n\t\t\t}\n\t\t\trd.close();\n\t\t\treturn result.toString();\n\t\t} catch (FileNotFoundException e) {\n\t\t\t\n\t\t\treturn \"N/A\";\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t}\n}\n"}
{"id": 344046, "name": "Magic 8-ball", "source": "Translate Haskell to Java: import           System.Random (getStdRandom, randomR)\nimport           Control.Monad (forever)\n\nanswers :: [String]\nanswers =\n  [ \"It is certain\"\n  , \"It is decidedly so\"\n  , \"Without a doubt\"\n  , \"Yes, definitely\"\n  , \"You may rely on it\"\n  , \"As I see it, yes\"\n  , \"Most likely\"\n  , \"Outlook good\"\n  , \"Signs point to yes\"\n  , \"Yes\"\n  , \"Reply hazy, try again\"\n  , \"Ask again later\"\n  , \"Better not tell you now\"\n  , \"Cannot predict now\"\n  , \"Concentrate and ask again\"\n  , \"Don't bet on it\"\n  , \"My reply is no\"\n  , \"My sources say no\"\n  , \"Outlook not so good\"\n  , \"Very doubtful\"]\n\nmain :: IO ()\nmain = do\n  putStrLn \"Hello. The Magic 8 Ball knows all. Type your question.\"\n  forever $ do\n    getLine\n    n <- getStdRandom (randomR (0, pred $ length answers))\n    putStrLn $ answers !! n\n", "target": "import java.util.Random;\nimport java.util.Scanner;\n\npublic class MagicEightBall {\n\n    public static void main(String[] args) {\n        new MagicEightBall().run();\n    }\n    \n    private static String[] ANSWERS = new String[] {\"It is certain.\", \"It is decidedly so.\", \"Without a doubt.\", \"Yes - definitely.\",\n            \"You may rely on it.\", \"As I see it, yes.\", \"Most likely.\", \"Outlook good.\", \"Yes.\", \"Signs point to yes.\",\n            \"Reply hazy, try again.\", \"Ask again later.\", \"Better not tell you now.\", \"Cannot predict now.\", \"Concentrate and ask again.\",\n            \"Don't count on it.\", \"My reply is no.\", \"My sources say no.\", \"Outlook not so good.\", \"Very doubtful. \"};\n\n    public void run() {\n        Random random = new Random();\n        System.out.printf(\"Hello.  The Magic 8 Ball knows all.  Type your question.%n%n\");\n        try ( Scanner in = new Scanner(System.in); ) {\n            System.out.printf(\"?  \");\n            while ( (in.nextLine()).length() > 0 ) {\n                System.out.printf(\"8 Ball Response:  %s%n\", ANSWERS[random.nextInt(ANSWERS.length)]);\n                System.out.printf(\"?  \");\n            }\n        }\n        System.out.printf(\"%n8 Ball Done.  Bye.\");\n    }\n}\n"}
{"id": 344047, "name": "Validate International Securities Identification Number", "source": "Translate Haskell to Java: module ISINVerification2 where\n\nimport Data.Char (isUpper, isDigit, digitToInt)\n\nverifyISIN :: String -> Bool\nverifyISIN isin =\n  correctFormat isin && mod (oddsum + multiplied_even_sum) 10 == 0\n  where\n    reverted = reverse $ convertToNumber isin\n    theOdds = fst $ collectOddandEven reverted\n    theEvens = snd $ collectOddandEven reverted\n    oddsum = sum $ map digitToInt theOdds\n    multiplied_even_sum = addUpDigits $ map ((* 2) . digitToInt) theEvens\n\ncapitalLetters :: String\ncapitalLetters = ['A','B' .. 'Z']\n\nnumbers :: String\nnumbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\ncorrectFormat :: String -> Bool\ncorrectFormat isin =\n  (length isin == 12) &&\n  all (`elem` capitalLetters) (take 2 isin) &&\n  all (\\c -> elem c capitalLetters || elem c numbers) (drop 2 $ take 11 isin) &&\n  elem (last isin) numbers\n\nconvertToNumber :: String -> String\nconvertToNumber = concatMap convert\n  where\n    convert :: Char -> String\n    convert c =\n      if isDigit c\n        then show $ digitToInt c\n        else show (fromEnum c - 55)\n\ncollectOddandEven :: String -> (String, String)\ncollectOddandEven term\n  | odd $ length term =\n    ( concat\n        [ take 1 $ drop n term\n        | n <- [0,2 .. length term - 1] ]\n    , concat\n        [ take 1 $ drop d term\n        | d <- [1,3 .. length term - 2] ])\n  | otherwise =\n    ( concat\n        [ take 1 $ drop n term\n        | n <- [0,2 .. length term - 2] ]\n    , concat\n        [ take 1 $ drop d term\n        | d <- [1,3 .. length term - 1] ])\n\naddUpDigits :: [Int] -> Int\naddUpDigits list =\n  sum $\n  map\n    (\\d ->\n        if d > 9\n          then sum $ map digitToInt $ show d\n          else d)\n    list\n\nprintSolution :: String -> IO ()\nprintSolution str = do\n  putStr $ str ++ \" is\"\n  if verifyISIN str\n    then putStrLn \" valid\"\n    else putStrLn \" not valid\"\n\nmain :: IO ()\nmain = do\n  let isinnumbers =\n        [ \"US0378331005\"\n        , \"US0373831005\"\n        , \"U50378331005\"\n        , \"US03378331005\"\n        , \"AU0000XVGZA3\"\n        , \"AU0000VXGZA3\"\n        , \"FR0000988040\"\n        ]\n  mapM_ printSolution isinnumbers\n", "target": "public class ISIN {\n \n    public static void main(String[] args) {\n        String[] isins = {\n            \"US0378331005\", \n            \"US0373831005\", \n            \"U50378331005\", \n            \"US03378331005\",\n            \"AU0000XVGZA3\", \n            \"AU0000VXGZA3\", \n            \"FR0000988040\"\n        };\n        for (String isin : isins)\n            System.out.printf(\"%s is %s\\n\", isin, ISINtest(isin) ? \"valid\" : \"not valid\");\n    }\n \n    static boolean ISINtest(String isin) {\n        isin = isin.trim().toUpperCase();\n \n        if (!isin.matches(\"^[A-Z]{2}[A-Z0-9]{9}\\\\d$\"))\n            return false;\n \n        StringBuilder sb = new StringBuilder();\n        for (char c : isin.substring(0, 12).toCharArray())\n            sb.append(Character.digit(c, 36));\n \n        return luhnTest(sb.toString());\n    }\n\n    static boolean luhnTest(String number) {\n        int s1 = 0, s2 = 0;\n        String reverse = new StringBuffer(number).reverse().toString();\n        for (int i = 0; i < reverse.length(); i++){\n            int digit = Character.digit(reverse.charAt(i), 10);\n            \n            if (i % 2 == 0){\n                s1 += digit;\n            } else { \n                s2 += 2 * digit;\n                if(digit >= 5){\n                    s2 -= 9;\n                }\n            }\n        }\n        return (s1 + s2) % 10 == 0;\n    }\n}\n"}
{"id": 344048, "name": "Cycle detection", "source": "Translate Haskell to Java: import Data.List (findIndex)\n\nfindCycle :: Eq a => [a] -> Maybe ([a], Int, Int)\nfindCycle lst =\n  do l <- findCycleLength lst\n     mu <- findIndex (uncurry (==)) $ zip lst (drop l lst)\n     let c = take l $ drop mu lst\n     return (c, l, mu)\n\nfindCycleLength :: Eq a => [a] -> Maybe Int\nfindCycleLength [] = Nothing\nfindCycleLength (x:xs) =\n  let loop _ _ _ [] = Nothing\n      loop pow lam x (y:ys)\n        | x == y     = Just lam\n        | pow == lam = loop (2*pow) 1 y ys\n        | otherwise  = loop pow (1+lam) x ys\n  in loop 1 1 x xs\n", "target": "import java.util.function.*;\nimport static java.util.stream.IntStream.*;\n\npublic class CycleDetection {\n\n    public static void main(String[] args) {\n        brent(i -> (i * i + 1) % 255, 3);\n    }\n\n    static void brent(IntUnaryOperator f, int x0) {\n        int cycleLength;\n        int hare = x0;\n        FOUND:\n        for (int power = 1; ; power *= 2) {\n            int tortoise = hare;\n            for (int i = 1; i <= power; i++) {\n                hare = f.applyAsInt(hare);\n                 if (tortoise == hare) {\n                    cycleLength = i;\n                    break FOUND;\n                }\n            }\n        }\n\n        hare = x0;\n        for (int i = 0; i < cycleLength; i++)\n            hare = f.applyAsInt(hare);\n\n        int cycleStart = 0;\n        for (int tortoise = x0; tortoise != hare; cycleStart++) {\n            tortoise = f.applyAsInt(tortoise);\n            hare = f.applyAsInt(hare);\n        }\n\n        printResult(x0, f, cycleLength, cycleStart);\n    }\n\n    static void printResult(int x0, IntUnaryOperator f, int len, int start) {\n        System.out.printf(\"Cycle length: %d%nCycle: \", len);\n        iterate(x0, f).skip(start).limit(len)\n                .forEach(n -> System.out.printf(\"%s \", n));\n    }\n}\n"}
{"id": 344049, "name": "Input_Output for pairs of numbers", "source": "Translate Haskell to Java: main = do\n    contents <- getContents\n    let numberOfLines  =  read.head.lines$ contents\n        nums  =  map (map read.words).take numberOfLines.tail.lines$ contents\n        sums  =  map sum nums\n    mapM_ print sums\n", "target": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static int doStuff(int a, int b){\n\t    int sum = a+b;\n\t    return sum;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\n\t\tint n = in.nextInt();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint a = in.nextInt();\n\t\t\tint b= in.nextInt();\n\t\t\tint result = doStuff(a, b);\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n}\n"}
{"id": 344050, "name": "ABC words", "source": "Translate Haskell to Java: import Data.List (elemIndex)\nimport Data.Maybe (isJust)\n\n\n\nisABC :: String -> Bool\nisABC s =\n  isJust $\n    residue \"bc\" 'a' s\n      >>= residue \"c\" 'b' \n      >>= elemIndex 'c'\n\nresidue :: String -> Char -> String -> Maybe String\nresidue except c = go\n  where\n    go [] = Nothing\n    go (x : xs)\n      | x `elem` except = Nothing\n      | c == x = Just xs\n      | otherwise = go xs\n\n\nmain :: IO ()\nmain =\n  readFile \"unixdict.txt\"\n    >>= mapM_ print . zip [1 ..] . filter isABC . lines\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class AbcWords {\n    public static void main(String[] args) {\n        String fileName = \"unixdict.txt\";\n        String chars = \"abc\";\n        for (int i = 0; i + 1 < args.length\n                && args[i].length() > 1\n                && args[i].charAt(0) == '-'; ++i) {\n            switch (args[i].charAt(1)) {\n            case 'f':\n                fileName = args[++i];\n                break;\n            case 'c':\n                chars = args[++i];\n                break;\n            }\n        }\n        \n        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n            String line;\n            int n = 0;\n            while ((line = reader.readLine()) != null) {\n                if (match(line, chars)) {\n                    ++n;\n                    System.out.printf(\"%3d:\u00a0%-20s\", n, line);\n                    if (n % 3 == 0)\n                        System.out.println();\n                }\n            }\n            if (n > 0 && n % 3 != 0)\n                System.out.println();\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n\n    \n    \n    private static boolean match(String word, String chars) {\n        int length = chars.length();\n        boolean[] seen = new boolean[length];\n        int wordLength = word.length();\n        for (int w = 0; w < wordLength; ++w) {\n            char ch = word.charAt(w);\n            int index = -1;\n            for (int c = 0; c < length; ++c) {\n                if (ch == chars.charAt(c) && !seen[c]) {\n                    index = c;\n                    break;\n                }\n            }\n            if (index == -1)\n                continue;\n            if (index + 1 == length)\n                return index == 0 ? true : seen[index - 1];\n            if (index > 0 && !seen[index - 1])\n                return false;\n            seen[index] = true;\n        }\n        return false;\n    }\n}\n"}
{"id": 344051, "name": "Text between", "source": "Translate Haskell to Java: import Control.Monad (join)\nimport Data.Bifunctor (bimap)\nimport Data.List (intercalate)\nimport Data.Maybe (fromMaybe)\nimport Data.Text (Text, breakOn, pack, stripPrefix, unpack)\n\n\n\ntextBetween ::\n  (Either String Text, Either String Text) ->\n  Text ->\n  Text\ntextBetween (start, end) txt =\n  fromMaybe\n    (pack [])\n    ( retain (stripPrefix <*>) snd start txt\n        >>= retain (Just .) fst end\n    )\n  where\n    retain sub part delim t =\n      either\n        (Just . const t)\n        (sub $ part . flip breakOn t)\n        delim\n\n\nmain :: IO ()\nmain = do\n  mapM_ print $\n    flip textBetween (head samples)\n      <$> take 3 delims\n  (putStrLn . unlines) $\n    zipWith\n      ( \\d t ->\n          intercalate\n            (unpack $ textBetween d t)\n            [\"\\\"\", \"\\\"\"]\n      )\n      (drop 3 delims)\n      (tail samples)\n\nsamples :: [Text]\nsamples =\n  fmap\n    pack\n    [ \"Hello Rosetta Code world\",\n      \"</div><div style=\\\"chinese\\\">\u4f60\u597d\u5417</div>\",\n      \"<text>Hello <span>Rosetta Code</span> world\"\n        <> \"</text><table style=\\\"myTable\\\">\",\n      \"<table style=\\\"myTable\\\"><tr><td>\"\n        <> \"hello world</td></tr></table>\"\n    ]\n\ndelims :: [(Either String Text, Either String Text)]\ndelims =\n  fmap\n    (join bimap wrap)\n    [ (\"Hello \", \" world\"),\n      (\"start\", \" world\"),\n      (\"Hello\", \"end\"),\n      (\"<div style=\\\"chinese\\\">\", \"</div>\"),\n      (\"<text>\", \"<table>\"),\n      (\"<text>\", \"</table>\")\n    ]\n\nwrap :: String -> Either String Text\nwrap x\n  | x `elem` [\"start\", \"end\"] = Left x\n  | otherwise = Right (pack x)\n", "target": "public class textBetween\n{\n    \n    static String textBetween(String thisText, String startString, String endString)\n    {\n    \tString returnText = \"\";\n    \tint startIndex = 0;\n    \tint endIndex = 0;\n    \t\n    \tif (startString.equals(\"start\"))\n    \t{\n    \t\tstartIndex = 0;\n    \t} else {\n\t    \tstartIndex = thisText.indexOf(startString);\n\t    \t\n\t    \tif (startIndex < 0) \n\t        {\n\t        \treturn \"\";\t        \t\n\t        } else {\n\t        \tstartIndex = startIndex + startString.length();\n\t        }\n    \t}\n        \n    \tif (endString.equals(\"end\"))\n    \t{\n    \t\tendIndex = thisText.length();\n    \t} else {\n    \t\tendIndex = thisText.indexOf(endString);\n            \n            if (endIndex <= 0) \n            {\n            \treturn \"\";\n            } else {\n\n            }\t\n    \t}\n    \t\n    \treturnText = thisText.substring(startIndex,endIndex);\n    \t\n    \treturn returnText;\n    } \n\n    \n    public static void main(String[] args)\n    {\n    \tString thisText = args[0];\n    \tString startDelimiter = args[1];\n    \tString endDelimiter = args[2];\n    \t\n    \tString returnText = \"\";\n    \treturnText = textBetween(thisText, startDelimiter, endDelimiter);\n    \t\n        System.out.println(returnText);\n\n    } \n    \n} \n"}
{"id": 344052, "name": "Two identical strings", "source": "Translate Haskell to Java: import Control.Monad (join)\nimport Data.Bits\n  ( countLeadingZeros,\n    finiteBitSize,\n    shift,\n    (.|.)\n  )\nimport Text.Printf (printf)\n\n\nnBits :: Int -> Int\nnBits = (-) . finiteBitSize <*> countLeadingZeros\n\n\nconcatSelf :: Int -> Int\nconcatSelf = (.|.) =<< shift <*> nBits\n\n\n\nidentStrInts :: [Int]\nidentStrInts = map concatSelf [1 ..]\n\nmain :: IO ()\nmain =\n  putStr $\n    unlines $\n      map (join $ printf \"%d: %b\") to1000\n  where\n    to1000 = takeWhile (<= 1000) identStrInts\n", "target": "public class TwoIdenticalStrings {\n    public static void main(String[] args) {\n        System.out.println(\"Decimal Binary\");\n        for (int i = 0; i < 1_000; i++) {\n            String binStr = Integer.toBinaryString(i);\n            if (binStr.length() % 2 == 0) {\n                int len = binStr.length() / 2;\n                if (binStr.substring(0, len).equals(binStr.substring(len))) {\n                    System.out.printf(\"%7d %s%n\", i, binStr);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 344053, "name": "Pentagram", "source": "Translate Haskell to Java: \n\n\n\n\nimport Diagrams.Prelude\nimport Diagrams.Backend.SVG.CmdLine\n\npentagram = let [a, b, c, d, e] = trailVertices $ pentagon 1\n            in [a, c, e, b, d]\n               # fromVertices\n               # closeTrail\n               # strokeTrail\n               # lw ultraThick\n               # fc springgreen\n               # lc blue\n               # bgFrame 0.2 bisque\n\nmain = mainWith (pentagram :: Diagram B)\n", "target": "import java.awt.*;\nimport java.awt.geom.Path2D;\nimport javax.swing.*;\n\npublic class Pentagram extends JPanel {\n\n    final double degrees144 = Math.toRadians(144);\n\n    public Pentagram() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n    }\n\n    private void drawPentagram(Graphics2D g, int len, int x, int y,\n            Color fill, Color stroke) {\n        double angle = 0;\n\n        Path2D p = new Path2D.Float();\n        p.moveTo(x, y);\n\n        for (int i = 0; i < 5; i++) {\n            int x2 = x + (int) (Math.cos(angle) * len);\n            int y2 = y + (int) (Math.sin(-angle) * len);\n            p.lineTo(x2, y2);\n            x = x2;\n            y = y2;\n            angle -= degrees144;\n        }\n        p.closePath();\n\n        g.setColor(fill);\n        g.fill(p);\n\n        g.setColor(stroke);\n        g.draw(p);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        g.setStroke(new BasicStroke(5, BasicStroke.CAP_ROUND, 0));\n\n        drawPentagram(g, 500, 70, 250, new Color(0x6495ED), Color.darkGray);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Pentagram\");\n            f.setResizable(false);\n            f.add(new Pentagram(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 344054, "name": "Pentagram", "source": "Translate Haskell to Java: \n\n\n\n\nimport Diagrams.Prelude\nimport Diagrams.Backend.SVG.CmdLine\n\npentagram = let [a, b, c, d, e] = trailVertices $ pentagon 1\n            in [a, c, e, b, d]\n               # fromVertices\n               # closeTrail\n               # strokeTrail\n               # lw ultraThick\n               # fc springgreen\n               # lc blue\n               # bgFrame 0.2 bisque\n\nmain = mainWith (pentagram :: Diagram B)\n", "target": "import java.awt.*;\nimport java.awt.geom.Path2D;\nimport javax.swing.*;\n\npublic class Pentagram extends JPanel {\n\n    final double degrees144 = Math.toRadians(144);\n\n    public Pentagram() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n    }\n\n    private void drawPentagram(Graphics2D g, int len, int x, int y,\n            Color fill, Color stroke) {\n        double angle = 0;\n\n        Path2D p = new Path2D.Float();\n        p.moveTo(x, y);\n\n        for (int i = 0; i < 5; i++) {\n            int x2 = x + (int) (Math.cos(angle) * len);\n            int y2 = y + (int) (Math.sin(-angle) * len);\n            p.lineTo(x2, y2);\n            x = x2;\n            y = y2;\n            angle -= degrees144;\n        }\n        p.closePath();\n\n        g.setColor(fill);\n        g.fill(p);\n\n        g.setColor(stroke);\n        g.draw(p);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        g.setStroke(new BasicStroke(5, BasicStroke.CAP_ROUND, 0));\n\n        drawPentagram(g, 500, 70, 250, new Color(0x6495ED), Color.darkGray);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Pentagram\");\n            f.setResizable(false);\n            f.add(new Pentagram(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 344055, "name": "CSV to HTML translation", "source": "Translate Haskell to Java: \nsplitOn :: Char -> String -> [String] \nsplitOn delim = foldr (\\x rest ->\n                        if x == delim then \"\" : rest\n                        else (x:head rest):tail rest) [\"\"]\n\nhtmlEscape :: String -> String\nhtmlEscape =  concatMap escapeChar\n              where escapeChar '<' = \"&lt;\"\n                    escapeChar '>' = \"&gt;\"\n                    escapeChar '&' = \"&amp;\"\n                    escapeChar '\"' = \"&quot;\" \n                    escapeChar c   = [c]\n\ntoHtmlRow :: [String] -> String\ntoHtmlRow []   = \"<tr></tr>\"\ntoHtmlRow cols = let htmlColumns = concatMap toHtmlCol cols\n                  in \"<tr>\\n\" ++ htmlColumns  ++ \"</tr>\"\n               where toHtmlCol x = \"  <td>\" ++ htmlEscape x ++ \"</td>\\n\"\n\ncsvToTable :: String -> String\ncsvToTable csv = let rows = map (splitOn ',') $ lines csv\n                     html = unlines $ map toHtmlRow rows\n                  in \"<table>\\n\" ++ html ++ \"</table>\"\n\nmain = interact csvToTable\n", "target": "\n\ngrammar csv2html;\ndialog : {System.out.println(\"<HTML><Table>\");}header body+{System.out.println(\"</Table></HTML>\");} ;\nheader : {System.out.println(\"<THEAD align=\\\"center\\\"><TR bgcolor=\\\"blue\\\">\");}row{System.out.println(\"</TR></THEAD\");};\nbody   : {System.out.println(\"<TBODY><TR>\");}row{System.out.println(\"</TR></TBODY\");};\nrow    : field ',' field '\\r'? '\\n';\nfield  : Field{System.out.println(\"<TD>\" + $Field.text.replace(\"<\",\"&lt;\").replace(\">\",\"&gt;\") + \"</TD>\");};\nField  : ~[,\\n\\r]+;\n"}
{"id": 344056, "name": "CSV to HTML translation", "source": "Translate Haskell to Java: \nsplitOn :: Char -> String -> [String] \nsplitOn delim = foldr (\\x rest ->\n                        if x == delim then \"\" : rest\n                        else (x:head rest):tail rest) [\"\"]\n\nhtmlEscape :: String -> String\nhtmlEscape =  concatMap escapeChar\n              where escapeChar '<' = \"&lt;\"\n                    escapeChar '>' = \"&gt;\"\n                    escapeChar '&' = \"&amp;\"\n                    escapeChar '\"' = \"&quot;\" \n                    escapeChar c   = [c]\n\ntoHtmlRow :: [String] -> String\ntoHtmlRow []   = \"<tr></tr>\"\ntoHtmlRow cols = let htmlColumns = concatMap toHtmlCol cols\n                  in \"<tr>\\n\" ++ htmlColumns  ++ \"</tr>\"\n               where toHtmlCol x = \"  <td>\" ++ htmlEscape x ++ \"</td>\\n\"\n\ncsvToTable :: String -> String\ncsvToTable csv = let rows = map (splitOn ',') $ lines csv\n                     html = unlines $ map toHtmlRow rows\n                  in \"<table>\\n\" ++ html ++ \"</table>\"\n\nmain = interact csvToTable\n", "target": "\n\ngrammar csv2html;\ndialog : {System.out.println(\"<HTML><Table>\");}header body+{System.out.println(\"</Table></HTML>\");} ;\nheader : {System.out.println(\"<THEAD align=\\\"center\\\"><TR bgcolor=\\\"blue\\\">\");}row{System.out.println(\"</TR></THEAD\");};\nbody   : {System.out.println(\"<TBODY><TR>\");}row{System.out.println(\"</TR></TBODY\");};\nrow    : field ',' field '\\r'? '\\n';\nfield  : Field{System.out.println(\"<TD>\" + $Field.text.replace(\"<\",\"&lt;\").replace(\">\",\"&gt;\") + \"</TD>\");};\nField  : ~[,\\n\\r]+;\n"}
{"id": 344057, "name": "Alternade words", "source": "Translate Haskell to Java: import qualified Data.Set as S\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as TIO\n\n\nalt :: T.Text -> (T.Text, T.Text)\nalt = T.foldl' (\\(l, r) c -> (r `T.snoc` c, l)) (T.empty, T.empty)\n\n\nalternades :: S.Set T.Text -> [T.Text] -> [(T.Text, (T.Text, T.Text))]\nalternades dict ws = filter (areMembers . snd) $ zip ws $ map alt ws\n  where areMembers (x, y) = S.member x dict && S.member y dict\n\nmain :: IO ()\nmain = TIO.interact $ \\txt ->\n  let words' = map T.toLower $ T.lines txt\n      dict   = S.fromList words'\n  in T.unlines $ map alterShow $ alternades dict $ filter longEnough words'\n  where longEnough = (>= 6) . T.length\n        alterShow (w, (x, y)) = T.unwords [w, x, y]\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class AlternadeWords {\n    public static void main(String[] args) {\n        try {\n            Set<String> dictionary = new TreeSet<>();\n            try (BufferedReader reader = new BufferedReader(new FileReader(\"unixdict.txt\"))) {\n                String line;\n                while ((line = reader.readLine()) != null)\n                    dictionary.add(line);\n            }\n            StringBuilder word1 = new StringBuilder();\n            StringBuilder word2 = new StringBuilder();\n            for (String word : dictionary) {\n                int length = word.length();\n                if (length < 6)\n                    continue;\n                word1.setLength(0);\n                word2.setLength(0);\n                for (int i = 0; i < length; i += 2) {\n                    word1.append(word.charAt(i));\n                    if (i + 1 < length)\n                        word2.append(word.charAt(i + 1));\n                }\n                String w1 = word1.toString();\n                String w2 = word2.toString();\n                if (dictionary.contains(w1) && dictionary.contains(w2))\n                    System.out.printf(\"%-10s%-6s%s\\n\", word, w1, w2);\n            }\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"id": 344058, "name": "Alternade words", "source": "Translate Haskell to Java: import qualified Data.Set as S\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as TIO\n\n\nalt :: T.Text -> (T.Text, T.Text)\nalt = T.foldl' (\\(l, r) c -> (r `T.snoc` c, l)) (T.empty, T.empty)\n\n\nalternades :: S.Set T.Text -> [T.Text] -> [(T.Text, (T.Text, T.Text))]\nalternades dict ws = filter (areMembers . snd) $ zip ws $ map alt ws\n  where areMembers (x, y) = S.member x dict && S.member y dict\n\nmain :: IO ()\nmain = TIO.interact $ \\txt ->\n  let words' = map T.toLower $ T.lines txt\n      dict   = S.fromList words'\n  in T.unlines $ map alterShow $ alternades dict $ filter longEnough words'\n  where longEnough = (>= 6) . T.length\n        alterShow (w, (x, y)) = T.unwords [w, x, y]\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class AlternadeWords {\n    public static void main(String[] args) {\n        try {\n            Set<String> dictionary = new TreeSet<>();\n            try (BufferedReader reader = new BufferedReader(new FileReader(\"unixdict.txt\"))) {\n                String line;\n                while ((line = reader.readLine()) != null)\n                    dictionary.add(line);\n            }\n            StringBuilder word1 = new StringBuilder();\n            StringBuilder word2 = new StringBuilder();\n            for (String word : dictionary) {\n                int length = word.length();\n                if (length < 6)\n                    continue;\n                word1.setLength(0);\n                word2.setLength(0);\n                for (int i = 0; i < length; i += 2) {\n                    word1.append(word.charAt(i));\n                    if (i + 1 < length)\n                        word2.append(word.charAt(i + 1));\n                }\n                String w1 = word1.toString();\n                String w2 = word2.toString();\n                if (dictionary.contains(w1) && dictionary.contains(w2))\n                    System.out.printf(\"%-10s%-6s%s\\n\", word, w1, w2);\n            }\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"id": 344059, "name": "Pythagorean triples", "source": "Translate Haskell to Java: pytr :: Int -> [(Bool, Int, Int, Int)]\npytr n =\n  filter\n    (\\(_, a, b, c) -> a + b + c <= n)\n    [ (prim a b c, a, b, c)\n      | a <- xs,\n        b <- drop a xs,\n        c <- drop b xs,\n        a ^ 2 + b ^ 2 == c ^ 2\n    ]\n  where\n    xs = [1 .. n]\n    prim a b _ = gcd a b == 1\n\nmain :: IO ()\nmain =\n  putStrLn $\n    \"Up to 100 there are \"\n      <> show (length xs)\n      <> \" triples, of which \"\n      <> show (length $ filter (\\(x, _, _, _) -> x) xs)\n      <> \" are primitive.\"\n  where\n    xs = pytr 100\n", "target": "import java.math.BigInteger;\nimport static java.math.BigInteger.ONE;\n\npublic class PythTrip{\n\n    public static void main(String[] args){\n        long tripCount = 0, primCount = 0;\n\n        \n        BigInteger periLimit = BigInteger.valueOf(100),\n                peri2 = periLimit.divide(BigInteger.valueOf(2)),\n                peri3 = periLimit.divide(BigInteger.valueOf(3));\n\n        for(BigInteger a = ONE; a.compareTo(peri3) < 0; a = a.add(ONE)){\n            BigInteger aa = a.multiply(a);\n            \n            for(BigInteger b = a.add(ONE);\n                    b.compareTo(peri2) < 0; b = b.add(ONE)){\n                BigInteger bb = b.multiply(b);\n                BigInteger ab = a.add(b);\n                BigInteger aabb = aa.add(bb);\n                \n                for(BigInteger c = b.add(ONE);\n                        c.compareTo(peri2) < 0; c = c.add(ONE)){\n\n                    int compare = aabb.compareTo(c.multiply(c));\n                    \n                    if(ab.add(c).compareTo(periLimit) > 0){\n                        break;\n                    }\n                    \n                    if(compare < 0){\n                        break;\n                    }else if (compare == 0){\n                        tripCount++;\n                        System.out.print(a + \", \" + b + \", \" + c);\n\n                        \n                        if(a.gcd(b).equals(ONE)){\n                            System.out.print(\" primitive\");\n                            primCount++;\n                        }\n                        System.out.println();\n                    }\n                }\n            }\n        }\n        System.out.println(\"Up to a perimeter of \" + periLimit + \", there are \"\n                + tripCount + \" triples, of which \" + primCount + \" are primitive.\");\n    }\n}\n"}
{"id": 344060, "name": "Pythagorean triples", "source": "Translate Haskell to Java: pytr :: Int -> [(Bool, Int, Int, Int)]\npytr n =\n  filter\n    (\\(_, a, b, c) -> a + b + c <= n)\n    [ (prim a b c, a, b, c)\n      | a <- xs,\n        b <- drop a xs,\n        c <- drop b xs,\n        a ^ 2 + b ^ 2 == c ^ 2\n    ]\n  where\n    xs = [1 .. n]\n    prim a b _ = gcd a b == 1\n\nmain :: IO ()\nmain =\n  putStrLn $\n    \"Up to 100 there are \"\n      <> show (length xs)\n      <> \" triples, of which \"\n      <> show (length $ filter (\\(x, _, _, _) -> x) xs)\n      <> \" are primitive.\"\n  where\n    xs = pytr 100\n", "target": "import java.math.BigInteger;\nimport static java.math.BigInteger.ONE;\n\npublic class PythTrip{\n\n    public static void main(String[] args){\n        long tripCount = 0, primCount = 0;\n\n        \n        BigInteger periLimit = BigInteger.valueOf(100),\n                peri2 = periLimit.divide(BigInteger.valueOf(2)),\n                peri3 = periLimit.divide(BigInteger.valueOf(3));\n\n        for(BigInteger a = ONE; a.compareTo(peri3) < 0; a = a.add(ONE)){\n            BigInteger aa = a.multiply(a);\n            \n            for(BigInteger b = a.add(ONE);\n                    b.compareTo(peri2) < 0; b = b.add(ONE)){\n                BigInteger bb = b.multiply(b);\n                BigInteger ab = a.add(b);\n                BigInteger aabb = aa.add(bb);\n                \n                for(BigInteger c = b.add(ONE);\n                        c.compareTo(peri2) < 0; c = c.add(ONE)){\n\n                    int compare = aabb.compareTo(c.multiply(c));\n                    \n                    if(ab.add(c).compareTo(periLimit) > 0){\n                        break;\n                    }\n                    \n                    if(compare < 0){\n                        break;\n                    }else if (compare == 0){\n                        tripCount++;\n                        System.out.print(a + \", \" + b + \", \" + c);\n\n                        \n                        if(a.gcd(b).equals(ONE)){\n                            System.out.print(\" primitive\");\n                            primCount++;\n                        }\n                        System.out.println();\n                    }\n                }\n            }\n        }\n        System.out.println(\"Up to a perimeter of \" + periLimit + \", there are \"\n                + tripCount + \" triples, of which \" + primCount + \" are primitive.\");\n    }\n}\n"}
{"id": 344061, "name": "Call a foreign-language function", "source": "Translate Haskell to Java: \n\nimport Foreign (free)\nimport Foreign.C.String (CString, withCString, peekCString)\n\n\n\nforeign import ccall unsafe \"string.h strdup\" strdup :: CString -> IO CString\n\ntestC = withCString \"Hello World!\" \n        (\\s -> \n         do s2 <- strdup s\n            s2_hs <- peekCString s2 \n            putStrLn s2_hs\n            free s2) \n", "target": "public class JNIDemo\n{\n  static\n  {  System.loadLibrary(\"JNIDemo\");  }\n  \n  public static void main(String[] args)\n  {\n    System.out.println(callStrdup(\"Hello World!\"));\n  }\n  \n  private static native String callStrdup(String s);\n}\n"}
{"id": 344062, "name": "Yellowstone sequence", "source": "Translate Haskell to Java: import Data.List (unfoldr)\n\nyellowstone :: [Integer]\nyellowstone = 1 : 2 : 3 : unfoldr (Just . f) (2, 3, [4 ..])\n  where\n    f ::\n      (Integer, Integer, [Integer]) ->\n      (Integer, (Integer, Integer, [Integer]))\n    f (p2, p1, rest) = (next, (p1, next, rest_))\n      where\n        (next, rest_) = select rest\n        select :: [Integer] -> (Integer, [Integer])\n        select (x : xs)\n          | gcd x p1 == 1 && gcd x p2 /= 1 = (x, xs)\n          | otherwise = (y, x : ys)\n          where\n            (y, ys) = select xs\n\nmain :: IO ()\nmain = print $ take 30 yellowstone\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class YellowstoneSequence {\n\n    public static void main(String[] args) {\n         System.out.printf(\"First 30 values in the yellowstone sequence:%n%s%n\", yellowstoneSequence(30));\n    }\n\n    private static List<Integer> yellowstoneSequence(int sequenceCount) {\n        List<Integer> yellowstoneList = new ArrayList<Integer>();\n        yellowstoneList.add(1);\n        yellowstoneList.add(2);\n        yellowstoneList.add(3);\n        int num = 4;\n        List<Integer> notYellowstoneList = new ArrayList<Integer>();\n        int yellowSize = 3;\n        while ( yellowSize < sequenceCount ) {\n            int found = -1;\n            for ( int index = 0 ; index < notYellowstoneList.size() ; index++ ) {\n                int test = notYellowstoneList.get(index);\n                if ( gcd(yellowstoneList.get(yellowSize-2), test) > 1 && gcd(yellowstoneList.get(yellowSize-1), test) == 1 ) {\n                    found = index;\n                    break;\n                }\n            }\n            if ( found >= 0 ) {\n                yellowstoneList.add(notYellowstoneList.remove(found));\n                yellowSize++;\n            }\n            else {\n                while ( true ) {\n                    if ( gcd(yellowstoneList.get(yellowSize-2), num) > 1 && gcd(yellowstoneList.get(yellowSize-1), num) == 1 ) {\n                        yellowstoneList.add(num);\n                        yellowSize++;\n                        num++;\n                        break;\n                    }\n                    notYellowstoneList.add(num);\n                    num++;\n                }\n            }\n        }\n        return yellowstoneList;\n    }\n        \n    private static final int gcd(int a, int b) {\n        if ( b == 0 ) {\n            return a;\n        }\n        return gcd(b, a%b);\n    }\n\n}\n"}
{"id": 344063, "name": "Yellowstone sequence", "source": "Translate Haskell to Java: import Data.List (unfoldr)\n\nyellowstone :: [Integer]\nyellowstone = 1 : 2 : 3 : unfoldr (Just . f) (2, 3, [4 ..])\n  where\n    f ::\n      (Integer, Integer, [Integer]) ->\n      (Integer, (Integer, Integer, [Integer]))\n    f (p2, p1, rest) = (next, (p1, next, rest_))\n      where\n        (next, rest_) = select rest\n        select :: [Integer] -> (Integer, [Integer])\n        select (x : xs)\n          | gcd x p1 == 1 && gcd x p2 /= 1 = (x, xs)\n          | otherwise = (y, x : ys)\n          where\n            (y, ys) = select xs\n\nmain :: IO ()\nmain = print $ take 30 yellowstone\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class YellowstoneSequence {\n\n    public static void main(String[] args) {\n         System.out.printf(\"First 30 values in the yellowstone sequence:%n%s%n\", yellowstoneSequence(30));\n    }\n\n    private static List<Integer> yellowstoneSequence(int sequenceCount) {\n        List<Integer> yellowstoneList = new ArrayList<Integer>();\n        yellowstoneList.add(1);\n        yellowstoneList.add(2);\n        yellowstoneList.add(3);\n        int num = 4;\n        List<Integer> notYellowstoneList = new ArrayList<Integer>();\n        int yellowSize = 3;\n        while ( yellowSize < sequenceCount ) {\n            int found = -1;\n            for ( int index = 0 ; index < notYellowstoneList.size() ; index++ ) {\n                int test = notYellowstoneList.get(index);\n                if ( gcd(yellowstoneList.get(yellowSize-2), test) > 1 && gcd(yellowstoneList.get(yellowSize-1), test) == 1 ) {\n                    found = index;\n                    break;\n                }\n            }\n            if ( found >= 0 ) {\n                yellowstoneList.add(notYellowstoneList.remove(found));\n                yellowSize++;\n            }\n            else {\n                while ( true ) {\n                    if ( gcd(yellowstoneList.get(yellowSize-2), num) > 1 && gcd(yellowstoneList.get(yellowSize-1), num) == 1 ) {\n                        yellowstoneList.add(num);\n                        yellowSize++;\n                        num++;\n                        break;\n                    }\n                    notYellowstoneList.add(num);\n                    num++;\n                }\n            }\n        }\n        return yellowstoneList;\n    }\n        \n    private static final int gcd(int a, int b) {\n        if ( b == 0 ) {\n            return a;\n        }\n        return gcd(b, a%b);\n    }\n\n}\n"}
{"id": 344064, "name": "Sorting algorithms_Patience sort", "source": "Translate Haskell to Java: import Control.Monad.ST\nimport Control.Monad\nimport Data.Array.ST\nimport Data.List\nimport qualified Data.Set as S\n\nnewtype Pile a = Pile [a]\n\ninstance Eq a => Eq (Pile a) where\n  Pile (x:_) == Pile (y:_) = x == y\n\ninstance Ord a => Ord (Pile a) where\n  Pile (x:_) `compare` Pile (y:_) = x `compare` y\n\npatienceSort :: Ord a => [a] -> [a]\npatienceSort = mergePiles . sortIntoPiles where\n\n  sortIntoPiles :: Ord a => [a] -> [[a]]\n  sortIntoPiles lst = runST $ do\n      piles <- newSTArray (1, length lst) []\n      let bsearchPiles x len = aux 1 len where\n            aux lo hi | lo > hi = return lo\n                      | otherwise = do\n              let mid = (lo + hi) `div` 2\n              m <- readArray piles mid\n              if head m < x then\n                aux (mid+1) hi\n              else\n                aux lo (mid-1)\n          f len x = do\n            i <- bsearchPiles x len\n            writeArray piles i . (x:) =<< readArray piles i\n            return $ if i == len+1 then len+1 else len\n      len <- foldM f 0 lst\n      e <- getElems piles\n      return $ take len e\n      where newSTArray :: Ix i => (i,i) -> e -> ST s (STArray s i e)\n            newSTArray = newArray\n\n  mergePiles :: Ord a => [[a]] -> [a]\n  mergePiles = unfoldr f . S.fromList . map Pile where\n    f pq = case S.minView pq of\n             Nothing -> Nothing\n             Just (Pile [x], pq') -> Just (x, pq')\n             Just (Pile (x:xs), pq') -> Just (x, S.insert (Pile xs) pq')\n\nmain :: IO ()\nmain = print $ patienceSort [4, 65, 2, -31, 0, 99, 83, 782, 1]\n", "target": "import java.util.*;\n\npublic class PatienceSort {\n    public static <E extends Comparable<? super E>> void sort (E[] n) {\n        List<Pile<E>> piles = new ArrayList<Pile<E>>();\n        \n        for (E x : n) {\n            Pile<E> newPile = new Pile<E>();\n            newPile.push(x);\n            int i = Collections.binarySearch(piles, newPile);\n            if (i < 0) i = ~i;\n            if (i != piles.size())\n                piles.get(i).push(x);\n            else\n                piles.add(newPile);\n        }\n \n        \n        PriorityQueue<Pile<E>> heap = new PriorityQueue<Pile<E>>(piles);\n        for (int c = 0; c < n.length; c++) {\n            Pile<E> smallPile = heap.poll();\n            n[c] = smallPile.pop();\n            if (!smallPile.isEmpty())\n                heap.offer(smallPile);\n        }\n        assert(heap.isEmpty());\n    }\n \n    private static class Pile<E extends Comparable<? super E>> extends Stack<E> implements Comparable<Pile<E>> {\n        public int compareTo(Pile<E> y) { return peek().compareTo(y.peek()); }\n    }\n\n    public static void main(String[] args) {\n\tInteger[] a = {4, 65, 2, -31, 0, 99, 83, 782, 1};\n\tsort(a);\n\tSystem.out.println(Arrays.toString(a));\n    }\n}\n"}
{"id": 344065, "name": "Extensible prime generator", "source": "Translate Haskell to Java: #!/usr/bin/env runghc\n\nimport Data.List\nimport Data.Numbers.Primes\nimport System.IO\n\nfirstNPrimes :: Integer -> [Integer]\nfirstNPrimes n = genericTake n primes\n\nprimesBetweenInclusive :: Integer -> Integer -> [Integer]\nprimesBetweenInclusive lo hi =\n  dropWhile (< lo) $ takeWhile (<= hi) primes\n\nnthPrime :: Integer -> Integer\nnthPrime n = genericIndex primes (n - 1) \n\nmain = do\n  hSetBuffering stdout NoBuffering\n  putStr \"First 20 primes: \"\n  print $ firstNPrimes 20\n  putStr \"Primes between 100 and 150: \"\n  print $ primesBetweenInclusive 100 150\n  putStr \"Number of primes between 7700 and 8000: \"\n  print $ genericLength $ primesBetweenInclusive 7700 8000\n  putStr \"The 10000th prime: \"\n  print $ nthPrime 10000\n", "target": "import java.util.*;\n\npublic class PrimeGenerator {\n    private int limit_;\n    private int index_ = 0;\n    private int increment_;\n    private int count_ = 0;\n    private List<Integer> primes_ = new ArrayList<>();\n    private BitSet sieve_ = new BitSet();\n    private int sieveLimit_ = 0;\n\n    public PrimeGenerator(int initialLimit, int increment) {\n        limit_ = nextOddNumber(initialLimit);\n        increment_ = increment;\n        primes_.add(2);\n        findPrimes(3);\n    }\n\n    public int nextPrime() {\n        if (index_ == primes_.size()) {\n            if (Integer.MAX_VALUE - increment_ < limit_)\n                return 0;\n            int start = limit_ + 2;\n            limit_ = nextOddNumber(limit_ + increment_);\n            primes_.clear();\n            findPrimes(start);\n        }\n        ++count_;\n        return primes_.get(index_++);\n    }\n\n    public int count() {\n        return count_;\n    }\n\n    private void findPrimes(int start) {\n        index_ = 0;\n        int newLimit = sqrt(limit_);\n        for (int p = 3; p * p <= newLimit; p += 2) {\n            if (sieve_.get(p/2 - 1))\n                continue;\n            int q = p * Math.max(p, nextOddNumber((sieveLimit_ + p - 1)/p));\n            for (; q <= newLimit; q += 2*p)\n                sieve_.set(q/2 - 1, true);\n        }\n        sieveLimit_ = newLimit;\n        int count = (limit_ - start)/2 + 1;\n        BitSet composite = new BitSet(count);\n        for (int p = 3; p <= newLimit; p += 2) {\n            if (sieve_.get(p/2 - 1))\n                continue;\n            int q = p * Math.max(p, nextOddNumber((start + p - 1)/p)) - start;\n            q /= 2;\n            for (; q >= 0 && q < count; q += p)\n                composite.set(q, true);\n        }\n        for (int p = 0; p < count; ++p) {\n            if (!composite.get(p))\n                primes_.add(p * 2 + start);\n        }\n    }\n\n    private static int sqrt(int n) {\n        return nextOddNumber((int)Math.sqrt(n));\n    }\n\n    private static int nextOddNumber(int n) {\n        return 1 + 2 * (n/2);\n    }\n\n    public static void main(String[] args) {\n        PrimeGenerator pgen = new PrimeGenerator(20, 200000);\n        System.out.println(\"First 20 primes:\");\n        for (int i = 0; i < 20; ++i) {\n            if (i > 0)\n                System.out.print(\", \");\n            System.out.print(pgen.nextPrime());\n        }\n        System.out.println();\n        System.out.println(\"Primes between 100 and 150:\");\n        for (int i = 0; ; ) {\n            int prime = pgen.nextPrime();\n            if (prime > 150)\n                break;\n            if (prime >= 100) {\n                if (i++ != 0)\n                    System.out.print(\", \");\n                System.out.print(prime);\n            }\n        }\n        System.out.println();\n        int count = 0;\n        for (;;) {\n            int prime = pgen.nextPrime();\n            if (prime > 8000)\n                break;\n            if (prime >= 7700)\n                ++count;\n        }\n        System.out.println(\"Number of primes between 7700 and 8000: \" + count);\n        int n = 10000;\n        for (;;) {\n            int prime = pgen.nextPrime();\n            if (prime == 0) {\n                System.out.println(\"Can't generate any more primes.\");\n                break;\n            }\n            if (pgen.count() == n) {\n                System.out.println(n + \"th prime: \" + prime);\n                n *= 10;\n            }\n        }\n    }\n}\n"}
{"id": 344066, "name": "Flipping bits game", "source": "Translate Haskell to Java: import Data.List (intersperse)\n\nimport System.Random (randomRIO)\n\nimport Data.Array (Array, (!), (//), array, bounds)\n\nimport Control.Monad (zipWithM_, replicateM, foldM, when)\n\ntype Board = Array (Char, Char) Int\n\nflp :: Int -> Int\nflp 0 = 1\nflp 1 = 0\n\nnumRows, numCols :: Board -> String\nnumRows t =\n  let ((a, _), (b, _)) = bounds t\n  in [a .. b]\n\nnumCols t =\n  let ((_, a), (_, b)) = bounds t\n  in [a .. b]\n\nflipRow, flipCol :: Board -> Char -> Board\nflipRow t r =\n  let e =\n        [ (ix, flp (t ! ix))\n        | ix <- zip (repeat r) (numCols t) ]\n  in t // e\n\nflipCol t c =\n  let e =\n        [ (ix, flp (t ! ix))\n        | ix <- zip (numRows t) (repeat c) ]\n  in t // e\n\nprintBoard :: Board -> IO ()\nprintBoard t = do\n  let rows = numRows t\n      cols = numCols t\n      f 0 = '0'\n      f 1 = '1'\n      p r xs = putStrLn $ [r, ' '] ++ intersperse ' ' (map f xs)\n  putStrLn $ \"  \" ++ intersperse ' ' cols\n  zipWithM_\n    p\n    rows\n    [ [ t ! (y, x)\n      | x <- cols ]\n    | y <- rows ]\n\n\n\nsetupGame :: Char -> Char -> IO (Board, Board)\nsetupGame sizey sizex\n                \n = do\n  let mk rc = (\\v -> (rc, v)) <$> randomRIO (0, 1)\n      rows = ['a' .. sizey]\n      cols = ['1' .. sizex]\n  goal <-\n    array (('a', '1'), (sizey, sizex)) <$>\n    mapM\n      mk\n      [ (r, c)\n      | r <- rows \n      , c <- cols ]\n  start <-\n    do let change :: Board -> Int -> IO Board\n           \n           change t 0 = flipRow t <$> randomRIO ('a', sizey)\n           \n           change t 1 = flipCol t <$> randomRIO ('1', sizex)\n       numMoves <- randomRIO (3, 15) \n       \n       moves <- replicateM numMoves $ randomRIO (0, 1)\n       \n       foldM change goal moves\n  if goal /= start \n    then return (goal, start) \n    else setupGame sizey sizex \n\nmain :: IO ()\nmain = do\n  putStrLn \"Select a board size (1 - 9).\\nPress any other key to exit.\"\n  sizec <- getChar\n  when (sizec `elem` ['1' .. '9']) $\n    do let size = read [sizec] - 1\n       (g, s) <- setupGame (['a' ..] !! size) (['1' ..] !! size)\n       turns g s 0\n  where\n    turns goal current moves = do\n      putStrLn \"\\nGoal:\"\n      printBoard goal\n      putStrLn \"\\nBoard:\"\n      printBoard current\n      when (moves > 0) $\n        putStrLn $ \"\\nYou've made \" ++ show moves ++ \" moves so far.\"\n      putStrLn $\n        \"\\nFlip a row (\" ++\n        numRows current ++ \") or a column (\" ++ numCols current ++ \")\"\n      v <- getChar\n      if v `elem` numRows current\n        then check $ flipRow current v\n        else if v `elem` numCols current\n               then check $ flipCol current v\n               else tryAgain\n      where\n        check t =\n          if t == goal\n            then putStrLn $ \"\\nYou've won in \" ++ show (moves + 1) ++ \" moves!\"\n            else turns goal t (moves + 1)\n        tryAgain = do\n          putStrLn \": Invalid row or column.\"\n          turns goal current moves\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\n\npublic class FlippingBitsGame extends JPanel {\n    final int maxLevel = 7;\n    final int minLevel = 3;\n\n    private Random rand = new Random();\n    private int[][] grid, target;\n    private Rectangle box;\n    private int n = maxLevel;\n    private boolean solved = true;\n\n    FlippingBitsGame() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n        setFont(new Font(\"SansSerif\", Font.PLAIN, 18));\n\n        box = new Rectangle(120, 90, 400, 400);\n\n        startNewGame();\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (solved) {\n                    startNewGame();\n                } else {\n                    int x = e.getX();\n                    int y = e.getY();\n\n                    if (box.contains(x, y))\n                        return;\n\n                    if (x > box.x && x < box.x + box.width) {\n                        flipCol((x - box.x) / (box.width / n));\n\n                    } else if (y > box.y && y < box.y + box.height)\n                        flipRow((y - box.y) / (box.height / n));\n\n                    if (solved(grid, target))\n                        solved = true;\n\n                    printGrid(solved ? \"Solved!\" : \"The board\", grid);\n                }\n                repaint();\n            }\n        });\n    }\n\n    void startNewGame() {\n        if (solved) {\n\n            n = (n == maxLevel) ? minLevel : n + 1;\n\n            grid = new int[n][n];\n            target = new int[n][n];\n\n            do {\n                shuffle();\n\n                for (int i = 0; i < n; i++)\n                    target[i] = Arrays.copyOf(grid[i], n);\n\n                shuffle();\n\n            } while (solved(grid, target));\n\n            solved = false;\n            printGrid(\"The target\", target);\n            printGrid(\"The board\", grid);\n        }\n    }\n\n    void printGrid(String msg, int[][] g) {\n        System.out.println(msg);\n        for (int[] row : g)\n            System.out.println(Arrays.toString(row));\n        System.out.println();\n    }\n\n    boolean solved(int[][] a, int[][] b) {\n        for (int i = 0; i < n; i++)\n            if (!Arrays.equals(a[i], b[i]))\n                return false;\n        return true;\n    }\n\n    void shuffle() {\n        for (int i = 0; i < n * n; i++) {\n            if (rand.nextBoolean())\n                flipRow(rand.nextInt(n));\n            else\n                flipCol(rand.nextInt(n));\n        }\n    }\n\n    void flipRow(int r) {\n        for (int c = 0; c < n; c++) {\n            grid[r][c] ^= 1;\n        }\n    }\n\n    void flipCol(int c) {\n        for (int[] row : grid) {\n            row[c] ^= 1;\n        }\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setColor(getForeground());\n\n        if (solved)\n            g.drawString(\"Solved! Click here to play again.\", 180, 600);\n        else\n            g.drawString(\"Click next to a row or a column to flip.\", 170, 600);\n\n        int size = box.width / n;\n\n        for (int r = 0; r < n; r++)\n            for (int c = 0; c < n; c++) {\n                g.setColor(grid[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(getBackground());\n                g.drawRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(target[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(7 + box.x + c * size, 7 + box.y + r * size, 10, 10);\n            }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Flipping Bits Game\");\n            f.setResizable(false);\n            f.add(new FlippingBitsGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 344067, "name": "Flipping bits game", "source": "Translate Haskell to Java: import Data.List (intersperse)\n\nimport System.Random (randomRIO)\n\nimport Data.Array (Array, (!), (//), array, bounds)\n\nimport Control.Monad (zipWithM_, replicateM, foldM, when)\n\ntype Board = Array (Char, Char) Int\n\nflp :: Int -> Int\nflp 0 = 1\nflp 1 = 0\n\nnumRows, numCols :: Board -> String\nnumRows t =\n  let ((a, _), (b, _)) = bounds t\n  in [a .. b]\n\nnumCols t =\n  let ((_, a), (_, b)) = bounds t\n  in [a .. b]\n\nflipRow, flipCol :: Board -> Char -> Board\nflipRow t r =\n  let e =\n        [ (ix, flp (t ! ix))\n        | ix <- zip (repeat r) (numCols t) ]\n  in t // e\n\nflipCol t c =\n  let e =\n        [ (ix, flp (t ! ix))\n        | ix <- zip (numRows t) (repeat c) ]\n  in t // e\n\nprintBoard :: Board -> IO ()\nprintBoard t = do\n  let rows = numRows t\n      cols = numCols t\n      f 0 = '0'\n      f 1 = '1'\n      p r xs = putStrLn $ [r, ' '] ++ intersperse ' ' (map f xs)\n  putStrLn $ \"  \" ++ intersperse ' ' cols\n  zipWithM_\n    p\n    rows\n    [ [ t ! (y, x)\n      | x <- cols ]\n    | y <- rows ]\n\n\n\nsetupGame :: Char -> Char -> IO (Board, Board)\nsetupGame sizey sizex\n                \n = do\n  let mk rc = (\\v -> (rc, v)) <$> randomRIO (0, 1)\n      rows = ['a' .. sizey]\n      cols = ['1' .. sizex]\n  goal <-\n    array (('a', '1'), (sizey, sizex)) <$>\n    mapM\n      mk\n      [ (r, c)\n      | r <- rows \n      , c <- cols ]\n  start <-\n    do let change :: Board -> Int -> IO Board\n           \n           change t 0 = flipRow t <$> randomRIO ('a', sizey)\n           \n           change t 1 = flipCol t <$> randomRIO ('1', sizex)\n       numMoves <- randomRIO (3, 15) \n       \n       moves <- replicateM numMoves $ randomRIO (0, 1)\n       \n       foldM change goal moves\n  if goal /= start \n    then return (goal, start) \n    else setupGame sizey sizex \n\nmain :: IO ()\nmain = do\n  putStrLn \"Select a board size (1 - 9).\\nPress any other key to exit.\"\n  sizec <- getChar\n  when (sizec `elem` ['1' .. '9']) $\n    do let size = read [sizec] - 1\n       (g, s) <- setupGame (['a' ..] !! size) (['1' ..] !! size)\n       turns g s 0\n  where\n    turns goal current moves = do\n      putStrLn \"\\nGoal:\"\n      printBoard goal\n      putStrLn \"\\nBoard:\"\n      printBoard current\n      when (moves > 0) $\n        putStrLn $ \"\\nYou've made \" ++ show moves ++ \" moves so far.\"\n      putStrLn $\n        \"\\nFlip a row (\" ++\n        numRows current ++ \") or a column (\" ++ numCols current ++ \")\"\n      v <- getChar\n      if v `elem` numRows current\n        then check $ flipRow current v\n        else if v `elem` numCols current\n               then check $ flipCol current v\n               else tryAgain\n      where\n        check t =\n          if t == goal\n            then putStrLn $ \"\\nYou've won in \" ++ show (moves + 1) ++ \" moves!\"\n            else turns goal t (moves + 1)\n        tryAgain = do\n          putStrLn \": Invalid row or column.\"\n          turns goal current moves\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\n\npublic class FlippingBitsGame extends JPanel {\n    final int maxLevel = 7;\n    final int minLevel = 3;\n\n    private Random rand = new Random();\n    private int[][] grid, target;\n    private Rectangle box;\n    private int n = maxLevel;\n    private boolean solved = true;\n\n    FlippingBitsGame() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n        setFont(new Font(\"SansSerif\", Font.PLAIN, 18));\n\n        box = new Rectangle(120, 90, 400, 400);\n\n        startNewGame();\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (solved) {\n                    startNewGame();\n                } else {\n                    int x = e.getX();\n                    int y = e.getY();\n\n                    if (box.contains(x, y))\n                        return;\n\n                    if (x > box.x && x < box.x + box.width) {\n                        flipCol((x - box.x) / (box.width / n));\n\n                    } else if (y > box.y && y < box.y + box.height)\n                        flipRow((y - box.y) / (box.height / n));\n\n                    if (solved(grid, target))\n                        solved = true;\n\n                    printGrid(solved ? \"Solved!\" : \"The board\", grid);\n                }\n                repaint();\n            }\n        });\n    }\n\n    void startNewGame() {\n        if (solved) {\n\n            n = (n == maxLevel) ? minLevel : n + 1;\n\n            grid = new int[n][n];\n            target = new int[n][n];\n\n            do {\n                shuffle();\n\n                for (int i = 0; i < n; i++)\n                    target[i] = Arrays.copyOf(grid[i], n);\n\n                shuffle();\n\n            } while (solved(grid, target));\n\n            solved = false;\n            printGrid(\"The target\", target);\n            printGrid(\"The board\", grid);\n        }\n    }\n\n    void printGrid(String msg, int[][] g) {\n        System.out.println(msg);\n        for (int[] row : g)\n            System.out.println(Arrays.toString(row));\n        System.out.println();\n    }\n\n    boolean solved(int[][] a, int[][] b) {\n        for (int i = 0; i < n; i++)\n            if (!Arrays.equals(a[i], b[i]))\n                return false;\n        return true;\n    }\n\n    void shuffle() {\n        for (int i = 0; i < n * n; i++) {\n            if (rand.nextBoolean())\n                flipRow(rand.nextInt(n));\n            else\n                flipCol(rand.nextInt(n));\n        }\n    }\n\n    void flipRow(int r) {\n        for (int c = 0; c < n; c++) {\n            grid[r][c] ^= 1;\n        }\n    }\n\n    void flipCol(int c) {\n        for (int[] row : grid) {\n            row[c] ^= 1;\n        }\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setColor(getForeground());\n\n        if (solved)\n            g.drawString(\"Solved! Click here to play again.\", 180, 600);\n        else\n            g.drawString(\"Click next to a row or a column to flip.\", 170, 600);\n\n        int size = box.width / n;\n\n        for (int r = 0; r < n; r++)\n            for (int c = 0; c < n; c++) {\n                g.setColor(grid[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(getBackground());\n                g.drawRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(target[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(7 + box.x + c * size, 7 + box.y + r * size, 10, 10);\n            }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Flipping Bits Game\");\n            f.setResizable(false);\n            f.add(new FlippingBitsGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 344068, "name": "Gray code", "source": "Translate Haskell to Java: import Data.Bits\nimport Data.Char\nimport Numeric\nimport Control.Monad\nimport Text.Printf\n \ngrayToBin :: (Integral t, Bits t) => t -> t\ngrayToBin 0 = 0\ngrayToBin g = g `xor` (grayToBin $ g `shiftR` 1)\n \nbinToGray :: (Integral t, Bits t) => t -> t\nbinToGray b = b `xor` (b `shiftR` 1)\n\nshowBinary :: (Integral t, Show t) => t -> String\nshowBinary n = showIntAtBase 2 intToDigit n \"\"\n \nshowGrayCode :: (Integral t, Bits t, PrintfArg t, Show t) => t -> IO ()\nshowGrayCode num = do\n    let bin  = showBinary num\n    let gray = showBinary (binToGray num)\n    printf \"int: %2d -> bin: %5s -> gray: %5s\\n\" num bin gray\n\nmain = forM_ [0..31::Int] showGrayCode\n", "target": "public class Gray {\n\tpublic static long grayEncode(long n){\n\t\treturn n ^ (n >>> 1);\n\t}\n\t\n\tpublic static long grayDecode(long n) {\n\t\tlong p = n;\n\t\twhile ((n >>>= 1) != 0)\n\t\t\tp ^= n;\n\t\treturn p;\n\t}\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"i\\tBinary\\tGray\\tDecoded\");\n\t\tfor(int i = -1; i < 32;i++){\n\t\t\tSystem.out.print(i +\"\\t\");\n\t\t\tSystem.out.print(Integer.toBinaryString(i) + \"\\t\");\n\t\t\tSystem.out.print(Long.toBinaryString(grayEncode(i))+ \"\\t\");\n\t\t\tSystem.out.println(grayDecode(grayEncode(i)));\n\t\t}\n\t}\n}\n"}
{"id": 344069, "name": "Gray code", "source": "Translate Haskell to Java: import Data.Bits\nimport Data.Char\nimport Numeric\nimport Control.Monad\nimport Text.Printf\n \ngrayToBin :: (Integral t, Bits t) => t -> t\ngrayToBin 0 = 0\ngrayToBin g = g `xor` (grayToBin $ g `shiftR` 1)\n \nbinToGray :: (Integral t, Bits t) => t -> t\nbinToGray b = b `xor` (b `shiftR` 1)\n\nshowBinary :: (Integral t, Show t) => t -> String\nshowBinary n = showIntAtBase 2 intToDigit n \"\"\n \nshowGrayCode :: (Integral t, Bits t, PrintfArg t, Show t) => t -> IO ()\nshowGrayCode num = do\n    let bin  = showBinary num\n    let gray = showBinary (binToGray num)\n    printf \"int: %2d -> bin: %5s -> gray: %5s\\n\" num bin gray\n\nmain = forM_ [0..31::Int] showGrayCode\n", "target": "public class Gray {\n\tpublic static long grayEncode(long n){\n\t\treturn n ^ (n >>> 1);\n\t}\n\t\n\tpublic static long grayDecode(long n) {\n\t\tlong p = n;\n\t\twhile ((n >>>= 1) != 0)\n\t\t\tp ^= n;\n\t\treturn p;\n\t}\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"i\\tBinary\\tGray\\tDecoded\");\n\t\tfor(int i = -1; i < 32;i++){\n\t\t\tSystem.out.print(i +\"\\t\");\n\t\t\tSystem.out.print(Integer.toBinaryString(i) + \"\\t\");\n\t\t\tSystem.out.print(Long.toBinaryString(grayEncode(i))+ \"\\t\");\n\t\t\tSystem.out.println(grayDecode(grayEncode(i)));\n\t\t}\n\t}\n}\n"}
{"id": 344070, "name": "Vigen\u00e8re cipher_Cryptanalysis", "source": "Translate Haskell to Java: \nimport Data.List(transpose, nub, sort, maximumBy)\nimport Data.Ord (comparing)\nimport Data.Char (ord)\nimport Data.Map (Map, fromListWith, toList, findWithDefault)\n\naverage :: Fractional a => [a] -> a\naverage as = sum as / fromIntegral (length as)\n\n\n\ncountEntries :: Ord a => [a] -> Map a Int\ncountEntries = fromListWith (+) . fmap (,1)\n\n\nbreakup :: Int -> [a] -> [[a]]\nbreakup _ [] = []\nbreakup n as = \n    let (h, r) = splitAt n as\n    in h:breakup n r\n\n\ndistribute :: [a] -> Int -> [[a]]\ndistribute as n = transpose $ breakup n as\n\n\n\ncoincidence :: (Ord a, Fractional b) => [a] -> b\ncoincidence str = \n    let charCounts = snd <$> toList (countEntries str)\n        strln = length str\n        d = fromIntegral $ strln * (strln - 1)\n        n = fromIntegral $ sum $ fmap (\\cc -> cc * (cc-1)) charCounts\n    in n / d\n\n\n\n\n\nrate :: (Ord a, Fractional b) => [[a]] -> b\nrate d =  average (fmap coincidence d) - fromIntegral (length d) / 3000.0 \n\n\ndot :: Num a => [a] -> [a] -> a\ndot v0 v1 = sum $ zipWith (*) v0 v1\n\n\n\nrotateAndDot :: Num a => [a] -> [a] -> Char -> a\nrotateAndDot v0 v1 letter = dot v0 (drop (ord letter - ord 'A') (cycle v1))  \n\n\n\ngetKeyChar :: RealFrac a => [a] -> String -> Char\ngetKeyChar expected sample =\n    let charCounts = countEntries sample\n        countInSample c = findWithDefault 0 c charCounts\n        actual = fmap (fromIntegral . countInSample) ['A'..'Z']\n    in maximumBy (comparing $ rotateAndDot expected actual) ['A'..'Z']\n\nmain = do\n    let cr = filter (/=' ') crypt\n        \n        \n        distributions = fmap (distribute cr) [1..length cr `div` 20]\n        bestDistribution = maximumBy (comparing rate) distributions\n        key = fmap (getKeyChar englishFrequencies) bestDistribution\n        alphaSum a b = ['A'..'Z'] !! ((ord b - ord a) `mod` 26)\n    mapM_ putStrLn [\"Key: \" ++ key, \"Decrypted Text: \" ++ zipWith alphaSum (cycle key) cr]\n\nenglishFrequencies = \n    [ 0.08167, 0.01492, 0.02782, 0.04253, \n      0.12702, 0.02228, 0.02015, 0.06094, \n      0.06966, 0.00153, 0.00772, 0.04025, \n      0.02406, 0.06749, 0.07507, 0.01929, \n      0.00095, 0.05987, 0.06327, 0.09056, \n      0.02758, 0.00978, 0.02360, 0.00150, \n      0.01974, 0.00074 ] \n\ncrypt = \"\\\n    \\MOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYH\\\n    \\VUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRD\\\n    \\ITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQIS\\\n    \\FGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVG\\\n    \\ALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJ\\\n    \\ILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZS\\\n    \\JLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDT\\\n    \\LPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPST\\\n    \\MTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVH\\\n    \\QGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEV\\\n    \\RVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPW\\\n    \\TTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVO\\\n    \\SFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPR\\\n    \\ZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLX\\\n    \\BUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGB\\\n    \\BXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBA\\\n    \\FWAML ZZRXJ EKAHV FASMU LVVUT TGK\\\n    \\\"\n", "target": "public class Vig{\nstatic String encodedMessage =\n    \"MOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYH VUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRD ITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQIS FGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVG ALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJ ILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZS JLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDT LPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPST MTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVH QGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEV RVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPW TTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVO SFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPR ZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLX BUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGB BXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBA FWAML ZZRXJ EKAHV FASMU LVVUT TGK\";\n \nfinal static double freq[] = {\n    0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015,\n    0.06094, 0.06966, 0.00153, 0.00772, 0.04025, 0.02406, 0.06749,\n    0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09056, 0.02758,\n    0.00978, 0.02360, 0.00150, 0.01974, 0.00074\n};\n \n\npublic static void main(String[] args) {\n    int lenghtOfEncodedMessage = encodedMessage.length();\n    char[] encoded = new char [lenghtOfEncodedMessage] ;\n    char[] key =  new char [lenghtOfEncodedMessage] ;\n\n    encodedMessage.getChars(0, lenghtOfEncodedMessage, encoded, 0);\n    int txt[] = new int[lenghtOfEncodedMessage];\n    int len = 0, j;\n\n    double fit, best_fit = 1e100;\n \n    for (j = 0; j < lenghtOfEncodedMessage; j++)\n        if (Character.isUpperCase(encoded[j]))\n            txt[len++] = encoded[j] - 'A';\n \n    for (j = 1; j < 30; j++) {\n        fit = freq_every_nth(txt, len, j, key);\n        System.out.printf(\"%f, key length: %2d \", fit, j);\n            System.out.print(key);\n        if (fit < best_fit) {\n            best_fit = fit;\n            System.out.print(\" <--- best so far\");\n        }\n        System.out.print(\"\\n\");\n\n    }\n}\n\n\n    static String decrypt(String text, final String key) {\n        String res = \"\";\n        text = text.toUpperCase();\n        for (int i = 0, j = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c < 'A' || c > 'Z') continue;\n            res += (char)((c - key.charAt(j) + 26) % 26 + 'A');\n            j = ++j % key.length();\n        }\n        return res;\n    }\n\nstatic int best_match(final double []a, final double []b) {\n    double sum = 0, fit, d, best_fit = 1e100;\n    int i, rotate, best_rotate = 0;\n    for (i = 0; i < 26; i++)\n        sum += a[i];\n    for (rotate = 0; rotate < 26; rotate++) {\n        fit = 0;\n        for (i = 0; i < 26; i++) {\n            d = a[(i + rotate) % 26] / sum - b[i];\n            fit += d * d / b[i];\n        }\n \n        if (fit < best_fit) {\n            best_fit = fit;\n            best_rotate = rotate;\n        }\n    }\n \n    return best_rotate;\n}\n \nstatic double freq_every_nth(final int []msg, int len, int interval, char[] key) {\n    double sum, d, ret;\n    double  [] accu = new double [26];\n    double  [] out = new double [26];\n    int i, j, rot;\n \n    for (j = 0; j < interval; j++) {\n        for (i = 0; i < 26; i++)\n            out[i] = 0;\n        for (i = j; i < len; i += interval)\n            out[msg[i]]++;\n\trot = best_match(out, freq);\n\ttry{\n            key[j] = (char)(rot + 'A');\n\t} catch (Exception e) {\n\t\tSystem.out.print(e.getMessage());\n\t}\n        for (i = 0; i < 26; i++)\n            accu[i] += out[(i + rot) % 26];\n    }\n \n    for (i = 0, sum = 0; i < 26; i++)\n        sum += accu[i];\n \n    for (i = 0, ret = 0; i < 26; i++) {\n        d = accu[i] / sum - freq[i];\n        ret += d * d / freq[i];\n    }\n \n    key[interval] = '\\0';\n    return ret;\n}\n \n}\n"}
{"id": 344071, "name": "File extension is in extensions list", "source": "Translate Haskell to Java: import Data.List\nimport qualified Data.Char as Ch\n\ntoLower :: String -> String \ntoLower = map Ch.toLower\n\nisExt :: String -> [String] -> Bool\nisExt filename extensions = any (`elem` (tails . toLower $ filename)) $ map toLower extensions\n", "target": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class FileExt{\n\tpublic static void main(String[] args){\n\t\tString[] tests = {\"text.txt\", \"text.TXT\", \"test.tar.gz\", \"test/test2.exe\", \"test\\\\test2.exe\", \"test\", \"a/b/c\\\\d/foo\"};\n\t\tString[] exts = {\".txt\",\".gz\",\"\",\".bat\"};\n\t\t\n\t\tSystem.out.println(\"Extensions: \" + Arrays.toString(exts) + \"\\n\");\n\t\t\n\t\tfor(String test:tests){\n\t\t\tSystem.out.println(test +\": \" + extIsIn(test, exts));\n\t\t}\n\t}\n\t\n\tpublic static boolean extIsIn(String test, String... exts){\n\t\tint lastSlash = Math.max(test.lastIndexOf('/'), test.lastIndexOf('\\\\')); \n\t\tString filename = test.substring(lastSlash + 1);\n\t\t\n\t\t\n\t\tint lastDot = filename.lastIndexOf('.') == -1 ? filename.length() : filename.lastIndexOf('.');\n\t\tString ext = filename.substring(lastDot);\n\t\t\n\t\tArrays.sort(exts);\n\t\t\n\t\treturn Arrays.binarySearch(exts, ext, new Comparator<String>() { \n\t\t\t@Override                                                \n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\treturn o1.compareToIgnoreCase(o2);\n\t\t\t}\n\t\t}) >= 0;\n\t}\n}\n"}
{"id": 344072, "name": "File extension is in extensions list", "source": "Translate Haskell to Java: import Data.List\nimport qualified Data.Char as Ch\n\ntoLower :: String -> String \ntoLower = map Ch.toLower\n\nisExt :: String -> [String] -> Bool\nisExt filename extensions = any (`elem` (tails . toLower $ filename)) $ map toLower extensions\n", "target": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class FileExt{\n\tpublic static void main(String[] args){\n\t\tString[] tests = {\"text.txt\", \"text.TXT\", \"test.tar.gz\", \"test/test2.exe\", \"test\\\\test2.exe\", \"test\", \"a/b/c\\\\d/foo\"};\n\t\tString[] exts = {\".txt\",\".gz\",\"\",\".bat\"};\n\t\t\n\t\tSystem.out.println(\"Extensions: \" + Arrays.toString(exts) + \"\\n\");\n\t\t\n\t\tfor(String test:tests){\n\t\t\tSystem.out.println(test +\": \" + extIsIn(test, exts));\n\t\t}\n\t}\n\t\n\tpublic static boolean extIsIn(String test, String... exts){\n\t\tint lastSlash = Math.max(test.lastIndexOf('/'), test.lastIndexOf('\\\\')); \n\t\tString filename = test.substring(lastSlash + 1);\n\t\t\n\t\t\n\t\tint lastDot = filename.lastIndexOf('.') == -1 ? filename.length() : filename.lastIndexOf('.');\n\t\tString ext = filename.substring(lastDot);\n\t\t\n\t\tArrays.sort(exts);\n\t\t\n\t\treturn Arrays.binarySearch(exts, ext, new Comparator<String>() { \n\t\t\t@Override                                                \n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\treturn o1.compareToIgnoreCase(o2);\n\t\t\t}\n\t\t}) >= 0;\n\t}\n}\n"}
{"id": 344073, "name": "Extreme floating point values", "source": "Translate Haskell to Java: main = do\nlet inf = 1/0\nlet minus_inf = -1/0\nlet minus_zero = -1/inf\nlet nan = 0/0\n\nputStrLn (\"Positive infinity = \"++(show inf))\nputStrLn (\"Negative infinity = \"++(show minus_inf))\nputStrLn (\"Negative zero = \"++(show minus_zero))\nputStrLn (\"Not a number = \"++(show nan))\n\n\n\nputStrLn (\"inf + 2.0 = \"++(show (inf+2.0)))\nputStrLn (\"inf - 10 = \"++(show (inf-10)))\nputStrLn (\"inf - inf = \"++(show (inf-inf)))\nputStrLn (\"inf * 0 = \"++(show (inf * 0)))\nputStrLn (\"nan + 1.0= \"++(show (nan+1.0)))\nputStrLn (\"nan + nan = \"++(show (nan + nan)))\n\n\n\nputStrLn (\"nan == nan = \"++(show (nan == nan)))\nputStrLn (\"0.0 == - 0.0 = \"++(show (0.0 == minus_zero)))\nputStrLn (\"inf == inf = \"++(show (inf == inf)))\n", "target": "public class Extreme {\n    public static void main(String[] args) {\n        double negInf = -1.0 / 0.0; \n        double inf = 1.0 / 0.0; \n        double nan = 0.0 / 0.0; \n        double negZero = -2.0 / inf;\n\n        System.out.println(\"Negative inf: \" + negInf);\n        System.out.println(\"Positive inf: \" + inf);\n        System.out.println(\"NaN: \" + nan);\n        System.out.println(\"Negative 0: \" + negZero);\n        System.out.println(\"inf + -inf: \" + (inf + negInf));\n        System.out.println(\"0 * NaN: \" + (0 * nan));\n        System.out.println(\"NaN == NaN: \" + (nan == nan));\n    }\n}\n"}
{"id": 344074, "name": "Extreme floating point values", "source": "Translate Haskell to Java: main = do\nlet inf = 1/0\nlet minus_inf = -1/0\nlet minus_zero = -1/inf\nlet nan = 0/0\n\nputStrLn (\"Positive infinity = \"++(show inf))\nputStrLn (\"Negative infinity = \"++(show minus_inf))\nputStrLn (\"Negative zero = \"++(show minus_zero))\nputStrLn (\"Not a number = \"++(show nan))\n\n\n\nputStrLn (\"inf + 2.0 = \"++(show (inf+2.0)))\nputStrLn (\"inf - 10 = \"++(show (inf-10)))\nputStrLn (\"inf - inf = \"++(show (inf-inf)))\nputStrLn (\"inf * 0 = \"++(show (inf * 0)))\nputStrLn (\"nan + 1.0= \"++(show (nan+1.0)))\nputStrLn (\"nan + nan = \"++(show (nan + nan)))\n\n\n\nputStrLn (\"nan == nan = \"++(show (nan == nan)))\nputStrLn (\"0.0 == - 0.0 = \"++(show (0.0 == minus_zero)))\nputStrLn (\"inf == inf = \"++(show (inf == inf)))\n", "target": "public class Extreme {\n    public static void main(String[] args) {\n        double negInf = -1.0 / 0.0; \n        double inf = 1.0 / 0.0; \n        double nan = 0.0 / 0.0; \n        double negZero = -2.0 / inf;\n\n        System.out.println(\"Negative inf: \" + negInf);\n        System.out.println(\"Positive inf: \" + inf);\n        System.out.println(\"NaN: \" + nan);\n        System.out.println(\"Negative 0: \" + negZero);\n        System.out.println(\"inf + -inf: \" + (inf + negInf));\n        System.out.println(\"0 * NaN: \" + (0 * nan));\n        System.out.println(\"NaN == NaN: \" + (nan == nan));\n    }\n}\n"}
{"id": 344075, "name": "Soundex", "source": "Translate Haskell to Java: import Text.PhoneticCode.Soundex\n\nmain :: IO ()\nmain =\n  mapM_ print $\n  ((,) <*> soundexSimple) <$> [\"Soundex\", \"Example\", \"Sownteks\", \"Ekzampul\"]\n", "target": "public static void main(String[] args){\n    System.out.println(soundex(\"Soundex\"));\n    System.out.println(soundex(\"Example\"));\n    System.out.println(soundex(\"Sownteks\"));\n    System.out.println(soundex(\"Ekzampul\"));\n  }\n\nprivate static String getCode(char c){\n  switch(c){\n    case 'B': case 'F': case 'P': case 'V':\n      return \"1\";\n    case 'C': case 'G': case 'J': case 'K':\n    case 'Q': case 'S': case 'X': case 'Z':\n      return \"2\";\n    case 'D': case 'T':\n      return \"3\";\n    case 'L':\n      return \"4\";\n    case 'M': case 'N':\n      return \"5\";\n    case 'R':\n      return \"6\";\n    default:\n      return \"\";\n  }\n}\n\npublic static String soundex(String s){\n  String code, previous, soundex;\n  code = s.toUpperCase().charAt(0) + \"\";\n\n  \n  previous = getCode(s.toUpperCase().charAt(0));\n\n  for(int i = 1;i < s.length();i++){\n    String current = getCode(s.toUpperCase().charAt(i));\n    if(current.length() > 0 && !current.equals(previous)){\n      code = code + current;\n    }\n    previous = current;\n  }\n  soundex = (code + \"0000\").substring(0, 4);\n  return soundex;\n}\n"}
{"id": 344076, "name": "Knuth's algorithm S", "source": "Translate Haskell to Java: import Control.Monad.Random\nimport Control.Monad.State\nimport qualified Data.Map as M\nimport System.Random\n\n\ns_of_n_creator :: Int -> a -> StateT (Int, [a]) (Rand StdGen) [a]\ns_of_n_creator n v = do\n  (i, vs) <- get\n  let i' = i + 1\n  if i' <= n\n    then do\n      let vs' = v : vs\n      put (i', vs')\n      pure vs'\n    else do\n      j <- getRandomR (1, i')\n      if j > n\n        then do\n          put (i', vs)\n          pure vs\n        else do\n          k <- getRandomR (0, n - 1)\n          let (f, (_ : b)) = splitAt k vs\n              vs' = v : f ++ b\n          put (i', vs')\n          pure vs'\n\nsample :: Int -> Rand StdGen [Int]\nsample n =\n  let s_of_n = s_of_n_creator n\n   in snd <$> execStateT (traverse s_of_n [0 .. 9 :: Int]) (0, [])\n\nincEach :: (Ord a, Num b) => M.Map a b -> [a] -> M.Map a b\nincEach m ks = foldl (\\m' k -> M.insertWith (+) k 1 m') m ks\n\nsampleInc :: Int -> M.Map Int Double -> Rand StdGen (M.Map Int Double)\nsampleInc n m = do\n  s <- sample n\n  pure $ incEach m s\n\nmain :: IO ()\nmain = do\n  let counts = M.empty :: M.Map Int Double\n      n = 100000\n  gen <- getStdGen\n  counts <- evalRandIO $ foldM (\\c _ -> sampleInc 3 c) M.empty [1 .. n]\n  print (fmap (/ n) counts)\n", "target": "import java.util.*;\n \nclass SOfN<T> {\n    private static final Random rand = new Random();\n \n    private List<T> sample;\n    private int i = 0;\n    private int n;\n\n    public SOfN(int _n) {\n        n = _n;\n        sample = new ArrayList<T>(n);\n    }\n\n    public List<T> process(T item) {\n        if (++i <= n) {\n            sample.add(item);\n        } else if (rand.nextInt(i) < n) {\n            sample.set(rand.nextInt(n), item);\n        }\n        return sample;\n    }\n}\n \npublic class AlgorithmS {\n    public static void main(String[] args) {\n        int[] bin = new int[10];\n        for (int trial = 0; trial < 100000; trial++) {\n            SOfN<Integer> s_of_n = new SOfN<Integer>(3);\n            for (int i = 0; i < 9; i++) s_of_n.process(i);\n            for (int s : s_of_n.process(9)) bin[s]++;\n        }\n        System.out.println(Arrays.toString(bin));\n    }\n}\n"}
{"id": 344077, "name": "Knuth's algorithm S", "source": "Translate Haskell to Java: import Control.Monad.Random\nimport Control.Monad.State\nimport qualified Data.Map as M\nimport System.Random\n\n\ns_of_n_creator :: Int -> a -> StateT (Int, [a]) (Rand StdGen) [a]\ns_of_n_creator n v = do\n  (i, vs) <- get\n  let i' = i + 1\n  if i' <= n\n    then do\n      let vs' = v : vs\n      put (i', vs')\n      pure vs'\n    else do\n      j <- getRandomR (1, i')\n      if j > n\n        then do\n          put (i', vs)\n          pure vs\n        else do\n          k <- getRandomR (0, n - 1)\n          let (f, (_ : b)) = splitAt k vs\n              vs' = v : f ++ b\n          put (i', vs')\n          pure vs'\n\nsample :: Int -> Rand StdGen [Int]\nsample n =\n  let s_of_n = s_of_n_creator n\n   in snd <$> execStateT (traverse s_of_n [0 .. 9 :: Int]) (0, [])\n\nincEach :: (Ord a, Num b) => M.Map a b -> [a] -> M.Map a b\nincEach m ks = foldl (\\m' k -> M.insertWith (+) k 1 m') m ks\n\nsampleInc :: Int -> M.Map Int Double -> Rand StdGen (M.Map Int Double)\nsampleInc n m = do\n  s <- sample n\n  pure $ incEach m s\n\nmain :: IO ()\nmain = do\n  let counts = M.empty :: M.Map Int Double\n      n = 100000\n  gen <- getStdGen\n  counts <- evalRandIO $ foldM (\\c _ -> sampleInc 3 c) M.empty [1 .. n]\n  print (fmap (/ n) counts)\n", "target": "import java.util.*;\n \nclass SOfN<T> {\n    private static final Random rand = new Random();\n \n    private List<T> sample;\n    private int i = 0;\n    private int n;\n\n    public SOfN(int _n) {\n        n = _n;\n        sample = new ArrayList<T>(n);\n    }\n\n    public List<T> process(T item) {\n        if (++i <= n) {\n            sample.add(item);\n        } else if (rand.nextInt(i) < n) {\n            sample.set(rand.nextInt(n), item);\n        }\n        return sample;\n    }\n}\n \npublic class AlgorithmS {\n    public static void main(String[] args) {\n        int[] bin = new int[10];\n        for (int trial = 0; trial < 100000; trial++) {\n            SOfN<Integer> s_of_n = new SOfN<Integer>(3);\n            for (int i = 0; i < 9; i++) s_of_n.process(i);\n            for (int s : s_of_n.process(9)) bin[s]++;\n        }\n        System.out.println(Arrays.toString(bin));\n    }\n}\n"}
{"id": 344078, "name": "Disarium numbers", "source": "Translate Haskell to Java: module Disarium \n   where\nimport Data.Char ( digitToInt)\n\nisDisarium :: Int -> Bool\nisDisarium n = (sum $ map (\\(c , i ) -> (digitToInt c ) ^ i )\n $ zip ( show n ) [1 , 2 ..]) == n\n\nsolution :: [Int]\nsolution = take 18 $ filter isDisarium [0, 1 ..]\n", "target": "import java.lang.Math;\n\npublic class DisariumNumbers {\n    public static boolean is_disarium(int num) {\n        int n = num;\n        int len = Integer.toString(n).length();\n        int sum = 0;\n        int i = 1;\n        while (n > 0) {\n            sum += Math.pow(n % 10, len - i + 1);\n            n /= 10;\n            i ++;\n        }\n        return sum  == num;\n    }\n\n    public static void main(String[] args) {\n        int i = 0;\n        int count = 0;\n        while (count <= 18) {\n            if (is_disarium(i)) {\n                System.out.printf(\"%d \", i);\n                count++;\n            }\n            i++;\n        }\n        System.out.printf(\"%s\", \"\\n\");\n    }\n}\n"}
{"id": 344079, "name": "Disarium numbers", "source": "Translate Haskell to Java: module Disarium \n   where\nimport Data.Char ( digitToInt)\n\nisDisarium :: Int -> Bool\nisDisarium n = (sum $ map (\\(c , i ) -> (digitToInt c ) ^ i )\n $ zip ( show n ) [1 , 2 ..]) == n\n\nsolution :: [Int]\nsolution = take 18 $ filter isDisarium [0, 1 ..]\n", "target": "import java.lang.Math;\n\npublic class DisariumNumbers {\n    public static boolean is_disarium(int num) {\n        int n = num;\n        int len = Integer.toString(n).length();\n        int sum = 0;\n        int i = 1;\n        while (n > 0) {\n            sum += Math.pow(n % 10, len - i + 1);\n            n /= 10;\n            i ++;\n        }\n        return sum  == num;\n    }\n\n    public static void main(String[] args) {\n        int i = 0;\n        int count = 0;\n        while (count <= 18) {\n            if (is_disarium(i)) {\n                System.out.printf(\"%d \", i);\n                count++;\n            }\n            i++;\n        }\n        System.out.printf(\"%s\", \"\\n\");\n    }\n}\n"}
{"id": 344080, "name": "Flow-control structures", "source": "Translate Haskell to Java: import Control.Monad\nimport Control.Monad.Trans\nimport Control.Monad.Exit\n\nmain = do\n    runExitTMaybe $ do\n        forM_ [1..5] $ \\x -> do\n            forM_ [1..5] $ \\y -> do\n                lift $ print (x, y)\n                when (x == 3 && y == 2) $\n                    exitWith ()\n    putStrLn \"Done.\"\n", "target": "switch (xx) {\n  case 1:\n  case 2:\n    \n    ...\n    break;\n  case 4:\n    \n    ...\n    break;\n  case 5:\n    \n    ...\n    break;\n  default:\n    \n    break;\n}\n\nfor (int i = 0; i < 10; ++i) {\n  ...\n  if (some_condition) { break; }\n  ...\n}\n\n_Time_: do {\n  for (int i = 0; i < 10; ++i) {\n    ...\n    if (some_condition) { break _Time_; }\n    ...\n    }\n  ...\n} while (thisCondition);\n"}
{"id": 344081, "name": "Find if a point is within a triangle", "source": "Translate Haskell to Java: type Pt a = (a, a)\n\ndata Overlapping = Inside | Outside | Boundary\n  deriving (Show, Eq)\n\ndata Triangle a = Triangle (Pt a) (Pt a) (Pt a)\n  deriving Show\n\nvertices (Triangle a b c) = [a, b, c]\n\n\n\n\ntoTriangle :: Num a => Triangle a -> Pt a -> (a, Pt a)\ntoTriangle t (x,y) = let\n  [(x0,y0), (x1,y1), (x2,y2)] = vertices t\n  s = x2*(y0-y1)+x0*(y1-y2)+x1*(-y0+y2)\n  in  ( abs s\n      , ( signum s * (x2*(-y+y0)+x0*(y-y2)+x*(-y0+y2))\n        , signum s * (x1*(y-y0)+x*(y0-y1)+x0*(-y+y1))))\n\noverlapping :: (Eq a, Ord a, Num a) =>\n  Triangle a -> Pt a -> Overlapping\noverlapping t p =  case toTriangle t p of\n  (s, (x, y))\n    | s == 0 && (x == 0 || y == 0)     -> Boundary\n    | s == 0                           -> Outside\n    | x > 0 && y > 0 && y < s - x      -> Inside\n    | (x <= s && x >= 0) &&\n      (y <= s && y >= 0) &&\n      (x == 0 || y == 0 || y == s - x) -> Boundary         \n    | otherwise                        -> Outside\n", "target": "import java.util.Objects;\n\npublic class FindTriangle {\n    private static final double EPS = 0.001;\n    private static final double EPS_SQUARE = EPS * EPS;\n\n    public static class Point {\n        private final double x, y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double getX() {\n            return x;\n        }\n\n        public double getY() {\n            return y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", x, y);\n        }\n    }\n\n    public static class Triangle {\n        private final Point p1, p2, p3;\n\n        public Triangle(Point p1, Point p2, Point p3) {\n            this.p1 = Objects.requireNonNull(p1);\n            this.p2 = Objects.requireNonNull(p2);\n            this.p3 = Objects.requireNonNull(p3);\n        }\n\n        public Point getP1() {\n            return p1;\n        }\n\n        public Point getP2() {\n            return p2;\n        }\n\n        public Point getP3() {\n            return p3;\n        }\n\n        private boolean pointInTriangleBoundingBox(Point p) {\n            var xMin = Math.min(p1.getX(), Math.min(p2.getX(), p3.getX())) - EPS;\n            var xMax = Math.max(p1.getX(), Math.max(p2.getX(), p3.getX())) + EPS;\n            var yMin = Math.min(p1.getY(), Math.min(p2.getY(), p3.getY())) - EPS;\n            var yMax = Math.max(p1.getY(), Math.max(p2.getY(), p3.getY())) + EPS;\n            return !(p.getX() < xMin || xMax < p.getX() || p.getY() < yMin || yMax < p.getY());\n        }\n\n        private static double side(Point p1, Point p2, Point p) {\n            return (p2.getY() - p1.getY()) * (p.getX() - p1.getX()) + (-p2.getX() + p1.getX()) * (p.getY() - p1.getY());\n        }\n\n        private boolean nativePointInTriangle(Point p) {\n            boolean checkSide1 = side(p1, p2, p) >= 0;\n            boolean checkSide2 = side(p2, p3, p) >= 0;\n            boolean checkSide3 = side(p3, p1, p) >= 0;\n            return checkSide1 && checkSide2 && checkSide3;\n        }\n\n        private double distanceSquarePointToSegment(Point p1, Point p2, Point p) {\n            double p1_p2_squareLength = (p2.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p2.getY() - p1.getY()) * (p2.getY() - p1.getY());\n            double dotProduct = ((p.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p2.getY() - p1.getY())) / p1_p2_squareLength;\n            if (dotProduct < 0) {\n                return (p.getX() - p1.getX()) * (p.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p.getY() - p1.getY());\n            }\n            if (dotProduct <= 1) {\n                double p_p1_squareLength = (p1.getX() - p.getX()) * (p1.getX() - p.getX()) + (p1.getY() - p.getY()) * (p1.getY() - p.getY());\n                return p_p1_squareLength - dotProduct * dotProduct * p1_p2_squareLength;\n            }\n            return (p.getX() - p2.getX()) * (p.getX() - p2.getX()) + (p.getY() - p2.getY()) * (p.getY() - p2.getY());\n        }\n\n        private boolean accuratePointInTriangle(Point p) {\n            if (!pointInTriangleBoundingBox(p)) {\n                return false;\n            }\n            if (nativePointInTriangle(p)) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p1, p2, p) <= EPS_SQUARE) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p2, p3, p) <= EPS_SQUARE) {\n                return true;\n            }\n            return distanceSquarePointToSegment(p3, p1, p) <= EPS_SQUARE;\n        }\n\n        public boolean within(Point p) {\n            Objects.requireNonNull(p);\n            return accuratePointInTriangle(p);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Triangle[%s, %s, %s]\", p1, p2, p3);\n        }\n    }\n\n    private static void test(Triangle t, Point p) {\n        System.out.println(t);\n        System.out.printf(\"Point %s is within triangle? %s\\n\", p, t.within(p));\n    }\n\n    public static void main(String[] args) {\n        var p1 = new Point(1.5, 2.4);\n        var p2 = new Point(5.1, -3.1);\n        var p3 = new Point(-3.8, 1.2);\n        var tri = new Triangle(p1, p2, p3);\n        test(tri, new Point(0, 0));\n        test(tri, new Point(0, 1));\n        test(tri, new Point(3, 1));\n        System.out.println();\n\n        p1 = new Point(1.0 / 10, 1.0 / 9);\n        p2 = new Point(100.0 / 8, 100.0 / 3);\n        p3 = new Point(100.0 / 4, 100.0 / 9);\n        tri = new Triangle(p1, p2, p3);\n        var pt = new Point(p1.getX() + (3.0 / 7) * (p2.getX() - p1.getX()), p1.getY() + (3.0 / 7) * (p2.getY() - p1.getY()));\n        test(tri, pt);\n        System.out.println();\n\n        p3 = new Point(-100.0 / 8, 100.0 / 6);\n        tri = new Triangle(p1, p2, p3);\n        test(tri, pt);\n    }\n}\n"}
{"id": 344082, "name": "Find if a point is within a triangle", "source": "Translate Haskell to Java: type Pt a = (a, a)\n\ndata Overlapping = Inside | Outside | Boundary\n  deriving (Show, Eq)\n\ndata Triangle a = Triangle (Pt a) (Pt a) (Pt a)\n  deriving Show\n\nvertices (Triangle a b c) = [a, b, c]\n\n\n\n\ntoTriangle :: Num a => Triangle a -> Pt a -> (a, Pt a)\ntoTriangle t (x,y) = let\n  [(x0,y0), (x1,y1), (x2,y2)] = vertices t\n  s = x2*(y0-y1)+x0*(y1-y2)+x1*(-y0+y2)\n  in  ( abs s\n      , ( signum s * (x2*(-y+y0)+x0*(y-y2)+x*(-y0+y2))\n        , signum s * (x1*(y-y0)+x*(y0-y1)+x0*(-y+y1))))\n\noverlapping :: (Eq a, Ord a, Num a) =>\n  Triangle a -> Pt a -> Overlapping\noverlapping t p =  case toTriangle t p of\n  (s, (x, y))\n    | s == 0 && (x == 0 || y == 0)     -> Boundary\n    | s == 0                           -> Outside\n    | x > 0 && y > 0 && y < s - x      -> Inside\n    | (x <= s && x >= 0) &&\n      (y <= s && y >= 0) &&\n      (x == 0 || y == 0 || y == s - x) -> Boundary         \n    | otherwise                        -> Outside\n", "target": "import java.util.Objects;\n\npublic class FindTriangle {\n    private static final double EPS = 0.001;\n    private static final double EPS_SQUARE = EPS * EPS;\n\n    public static class Point {\n        private final double x, y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double getX() {\n            return x;\n        }\n\n        public double getY() {\n            return y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", x, y);\n        }\n    }\n\n    public static class Triangle {\n        private final Point p1, p2, p3;\n\n        public Triangle(Point p1, Point p2, Point p3) {\n            this.p1 = Objects.requireNonNull(p1);\n            this.p2 = Objects.requireNonNull(p2);\n            this.p3 = Objects.requireNonNull(p3);\n        }\n\n        public Point getP1() {\n            return p1;\n        }\n\n        public Point getP2() {\n            return p2;\n        }\n\n        public Point getP3() {\n            return p3;\n        }\n\n        private boolean pointInTriangleBoundingBox(Point p) {\n            var xMin = Math.min(p1.getX(), Math.min(p2.getX(), p3.getX())) - EPS;\n            var xMax = Math.max(p1.getX(), Math.max(p2.getX(), p3.getX())) + EPS;\n            var yMin = Math.min(p1.getY(), Math.min(p2.getY(), p3.getY())) - EPS;\n            var yMax = Math.max(p1.getY(), Math.max(p2.getY(), p3.getY())) + EPS;\n            return !(p.getX() < xMin || xMax < p.getX() || p.getY() < yMin || yMax < p.getY());\n        }\n\n        private static double side(Point p1, Point p2, Point p) {\n            return (p2.getY() - p1.getY()) * (p.getX() - p1.getX()) + (-p2.getX() + p1.getX()) * (p.getY() - p1.getY());\n        }\n\n        private boolean nativePointInTriangle(Point p) {\n            boolean checkSide1 = side(p1, p2, p) >= 0;\n            boolean checkSide2 = side(p2, p3, p) >= 0;\n            boolean checkSide3 = side(p3, p1, p) >= 0;\n            return checkSide1 && checkSide2 && checkSide3;\n        }\n\n        private double distanceSquarePointToSegment(Point p1, Point p2, Point p) {\n            double p1_p2_squareLength = (p2.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p2.getY() - p1.getY()) * (p2.getY() - p1.getY());\n            double dotProduct = ((p.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p2.getY() - p1.getY())) / p1_p2_squareLength;\n            if (dotProduct < 0) {\n                return (p.getX() - p1.getX()) * (p.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p.getY() - p1.getY());\n            }\n            if (dotProduct <= 1) {\n                double p_p1_squareLength = (p1.getX() - p.getX()) * (p1.getX() - p.getX()) + (p1.getY() - p.getY()) * (p1.getY() - p.getY());\n                return p_p1_squareLength - dotProduct * dotProduct * p1_p2_squareLength;\n            }\n            return (p.getX() - p2.getX()) * (p.getX() - p2.getX()) + (p.getY() - p2.getY()) * (p.getY() - p2.getY());\n        }\n\n        private boolean accuratePointInTriangle(Point p) {\n            if (!pointInTriangleBoundingBox(p)) {\n                return false;\n            }\n            if (nativePointInTriangle(p)) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p1, p2, p) <= EPS_SQUARE) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p2, p3, p) <= EPS_SQUARE) {\n                return true;\n            }\n            return distanceSquarePointToSegment(p3, p1, p) <= EPS_SQUARE;\n        }\n\n        public boolean within(Point p) {\n            Objects.requireNonNull(p);\n            return accuratePointInTriangle(p);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Triangle[%s, %s, %s]\", p1, p2, p3);\n        }\n    }\n\n    private static void test(Triangle t, Point p) {\n        System.out.println(t);\n        System.out.printf(\"Point %s is within triangle? %s\\n\", p, t.within(p));\n    }\n\n    public static void main(String[] args) {\n        var p1 = new Point(1.5, 2.4);\n        var p2 = new Point(5.1, -3.1);\n        var p3 = new Point(-3.8, 1.2);\n        var tri = new Triangle(p1, p2, p3);\n        test(tri, new Point(0, 0));\n        test(tri, new Point(0, 1));\n        test(tri, new Point(3, 1));\n        System.out.println();\n\n        p1 = new Point(1.0 / 10, 1.0 / 9);\n        p2 = new Point(100.0 / 8, 100.0 / 3);\n        p3 = new Point(100.0 / 4, 100.0 / 9);\n        tri = new Triangle(p1, p2, p3);\n        var pt = new Point(p1.getX() + (3.0 / 7) * (p2.getX() - p1.getX()), p1.getY() + (3.0 / 7) * (p2.getY() - p1.getY()));\n        test(tri, pt);\n        System.out.println();\n\n        p3 = new Point(-100.0 / 8, 100.0 / 6);\n        tri = new Triangle(p1, p2, p3);\n        test(tri, pt);\n    }\n}\n"}
{"id": 344083, "name": "Return multiple values", "source": "Translate Haskell to Java:   addsub x y = (x + y, x - y)\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\n\npublic class RReturnMultipleVals {\n  public static final String K_lipsum = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\";\n  public static final Long   K_1024   = 1024L;\n  public static final String L        = \"L\";\n  public static final String R        = \"R\";\n\n  \n  public static void main(String[] args) throws NumberFormatException{\n    Long nv_;\n    String sv_;\n    switch (args.length) {\n      case 0:\n        nv_ = K_1024;\n        sv_ = K_lipsum;\n        break;\n      case 1:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = K_lipsum;\n        break;\n      case 2:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = args[1];\n        break;\n      default:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = args[1];\n        for (int ix = 2; ix < args.length; ++ix) {\n          sv_ = sv_ + \" \" + args[ix];\n        }\n        break;\n    }\n\n    RReturnMultipleVals lcl = new RReturnMultipleVals();\n\n    Pair<Long, String> rvp = lcl.getPairFromPair(nv_, sv_); \n    System.out.println(\"Results extracted from a composite object:\");\n    System.out.printf(\"%s, %s%n%n\", rvp.getLeftVal(), rvp.getRightVal());\n\n    List<Object> rvl = lcl.getPairFromList(nv_, sv_); \n    System.out.println(\"Results extracted from a Java Colections \\\"List\\\" object:\");\n    System.out.printf(\"%s, %s%n%n\", rvl.get(0), rvl.get(1));\n\n    Map<String, Object> rvm = lcl.getPairFromMap(nv_, sv_); \n    System.out.println(\"Results extracted from a Java Colections \\\"Map\\\" object:\");\n    System.out.printf(\"%s, %s%n%n\", rvm.get(L), rvm.get(R));\n  }\n  \n  \n  \n  public <T, U> Pair<T, U> getPairFromPair(T vl_, U vr_) {\n    return new Pair<T, U>(vl_, vr_);\n  }\n  \n  \n  \n  public List<Object> getPairFromList(Object nv_, Object sv_) {\n    List<Object> rset = new ArrayList<Object>();\n    rset.add(nv_);\n    rset.add(sv_);\n    return rset;\n  }\n  \n  \n  \n  public Map<String, Object> getPairFromMap(Object nv_, Object sv_) {\n    Map<String, Object> rset = new HashMap<String, Object>();\n    rset.put(L, nv_);\n    rset.put(R, sv_);\n    return rset;\n  }\n\n  \n  private static class Pair<L, R> {\n    private L leftVal;\n    private R rightVal;\n\n    public Pair(L nv_, R sv_) {\n      setLeftVal(nv_);\n      setRightVal(sv_);\n    }\n    public void setLeftVal(L nv_) {\n      leftVal = nv_;\n    }\n    public L getLeftVal() {\n      return leftVal;\n    }\n    public void setRightVal(R sv_) {\n      rightVal = sv_;\n    }\n    public R getRightVal() {\n      return rightVal;\n    }\n  }\n}\n"}
{"id": 344084, "name": "Fractran", "source": "Translate Haskell to Java: import Data.List (find)\nimport Data.Ratio (Ratio, (%), denominator)\n\nfractran :: (Integral a) => [Ratio a] -> a -> [a]\nfractran fracts n = n :\n  case find (\\f -> n `mod` denominator f == 0) fracts of\n    Nothing -> []\n    Just f -> fractran fracts $ truncate (fromIntegral n * f)\n", "target": "import java.util.Vector;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Fractran{\n\n   public static void main(String []args){ \n\n       new Fractran(\"17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1\", 2);\n   }\n   final int limit = 15;\n   \n\n   Vector<Integer> num = new Vector<>(); \n   Vector<Integer> den = new Vector<>(); \n   public Fractran(String prog, Integer val){\n      compile(prog);\n      dump();\n      exec(2);\n    }\n\n\n   void compile(String prog){\n      Pattern regexp = Pattern.compile(\"\\\\s*(\\\\d*)\\\\s*\\\\/\\\\s*(\\\\d*)\\\\s*(.*)\");\n      Matcher matcher = regexp.matcher(prog);\n      while(matcher.find()){\n         num.add(Integer.parseInt(matcher.group(1)));\n         den.add(Integer.parseInt(matcher.group(2)));\n         matcher = regexp.matcher(matcher.group(3));\n      }\n   }\n\n   void exec(Integer val){\n       int n = 0;\n       while(val != null && n<limit){\n           System.out.println(n+\": \"+val);\n           val = step(val);\n           n++;\n       }\n   }\n   Integer step(int val){\n       int i=0; \n       while(i<den.size() && val%den.get(i) != 0) i++;\n       if(i<den.size())\n           return num.get(i)*val/den.get(i);\n       return null;\n   }\n\n   void dump(){\n       for(int i=0; i<den.size(); i++)\n           System.out.print(num.get(i)+\"/\"+den.get(i)+\" \");\n       System.out.println();\n   }\n}\n"}
{"id": 344085, "name": "Substring_Top and tail", "source": "Translate Haskell to Java: \n\n\nremFirst, remLast, remBoth :: String -> String\n\nremFirst \"\" = \"\"\nremFirst cs = tail cs\n\nremLast \"\" = \"\"\nremLast cs = init cs\n\nremBoth (c:cs) = remLast cs\nremBoth  _     = \"\"\n\nmain :: IO ()\nmain = do\n  let s = \"Some string.\"  \n  mapM_ (\\f -> putStrLn . f $ s) [remFirst, remLast, remBoth]\n", "target": "String strOrig = 'brooms';\nString str1 = strOrig.substring(1, strOrig.length());\nsystem.debug(str1);\nString str2 = strOrig.substring(0, strOrig.length()-1);\nsystem.debug(str2);\nString str3 = strOrig.substring(1, strOrig.length()-1);\nsystem.debug(str3);\n\n\nString strOrig = 'brooms';\nString str1 = strOrig.replaceAll( '^.', '' );\nsystem.debug(str1);\nString str2 = strOrig.replaceAll( '.$', '' ) ;\nsystem.debug(str2);\nString str3 = strOrig.replaceAll( '^.|.$', '' );\nsystem.debug(str3);\n"}
{"id": 344086, "name": "Substring_Top and tail", "source": "Translate Haskell to Java: \n\n\nremFirst, remLast, remBoth :: String -> String\n\nremFirst \"\" = \"\"\nremFirst cs = tail cs\n\nremLast \"\" = \"\"\nremLast cs = init cs\n\nremBoth (c:cs) = remLast cs\nremBoth  _     = \"\"\n\nmain :: IO ()\nmain = do\n  let s = \"Some string.\"  \n  mapM_ (\\f -> putStrLn . f $ s) [remFirst, remLast, remBoth]\n", "target": "String strOrig = 'brooms';\nString str1 = strOrig.substring(1, strOrig.length());\nsystem.debug(str1);\nString str2 = strOrig.substring(0, strOrig.length()-1);\nsystem.debug(str2);\nString str3 = strOrig.substring(1, strOrig.length()-1);\nsystem.debug(str3);\n\n\nString strOrig = 'brooms';\nString str1 = strOrig.replaceAll( '^.', '' );\nsystem.debug(str1);\nString str2 = strOrig.replaceAll( '.$', '' ) ;\nsystem.debug(str2);\nString str3 = strOrig.replaceAll( '^.|.$', '' );\nsystem.debug(str3);\n"}
{"id": 344087, "name": "Boolean values", "source": "Translate Haskell to Java: data Bool = False | True    deriving (Eq, Ord, Enum, Read, Show, Bounded)\n", "target": "module GeorgeBoole\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Boolean f = False;\n        assert !f == True;\n\n        \n        \n        assert True.and(False) == True & False == False;\n        assert True.or(False)  == True | False == True;\n        assert True.xor(False) == True ^ False == True;\n        assert True.not() == ~True == False;\n\n        console.print($\"0==1 = {0==1}\");\n        console.print($\"!False = {!False}\");\n        }\n    }\n"}
{"id": 344088, "name": "Bitmap_Histogram", "source": "Translate Haskell to Java: module Bitmap.BW(module Bitmap.BW) where\n\nimport Bitmap\nimport Control.Monad.ST\n\nnewtype BW = BW Bool deriving (Eq, Ord)\n\ninstance Color BW where\n    luminance (BW False) = 0\n    luminance _          = 255\n    black = BW False\n    white = BW True\n    toNetpbm [] = \"\"\n    toNetpbm l = init (concatMap f line) ++ \"\\n\" ++ toNetpbm rest\n      where (line, rest) = splitAt 35 l\n            f (BW False) = \"1 \"\n            f _          = \"0 \"\n    fromNetpbm = map f\n      where f 1 = black\n            f _ = white\n    netpbmMagicNumber _ = \"P1\"\n    netpbmMaxval _ = \"\"\n\ntoBWImage :: Color c => Image s c -> ST s (Image s BW)\ntoBWImage = toBWImage' 128\n\ntoBWImage' :: Color c => Int -> Image s c -> ST s (Image s BW)\n\ntoBWImage' darkestWhite = mapImage $ f . luminance\n  where f x | x < darkestWhite = black\n            | otherwise        = white\n", "target": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic enum ImageProcessing {\n    ;\n\n    public static void main(String[] args) throws IOException {\n        BufferedImage img = ImageIO.read(new File(\"example.png\"));\n\n        BufferedImage bwimg = toBlackAndWhite(img);\n\n        ImageIO.write(bwimg, \"png\", new File(\"example-bw.png\"));\n    }\n\n    private static int luminance(int rgb) {\n        int r = (rgb >> 16) & 0xFF;\n        int g = (rgb >> 8) & 0xFF;\n        int b = rgb & 0xFF;\n        return (r + b + g) / 3;\n    }\n\n    private static BufferedImage toBlackAndWhite(BufferedImage img) {\n        int width = img.getWidth();\n        int height = img.getHeight();\n\n        int[] histo = computeHistogram(img);\n\n        int median = getMedian(width * height, histo);\n\n        BufferedImage bwimg = new BufferedImage(width, height, img.getType());\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                bwimg.setRGB(x, y, luminance(img.getRGB(x, y)) >= median ? 0xFFFFFFFF : 0xFF000000);\n            }\n        }\n        return bwimg;\n    }\n\n    private static int[] computeHistogram(BufferedImage img) {\n        int width = img.getWidth();\n        int height = img.getHeight();\n\n        int[] histo = new int[256];\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                histo[luminance(img.getRGB(x, y))]++;\n            }\n        }\n        return histo;\n    }\n\n    private static int getMedian(int total, int[] histo) {\n        int median = 0;\n        int sum = 0;\n        for (int i = 0; i < histo.length && sum + histo[i] < total / 2; i++) {\n            sum += histo[i];\n            median++;\n        }\n        return median;\n    }\n}\n"}
{"id": 344089, "name": "Plot coordinate pairs", "source": "Translate Haskell to Java: import Graphics.Gnuplot.Simple\n\npnts = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]\n\ndoPlot = plotPathStyle [ ( Title \"plotting dots\" )]\n            (PlotStyle Points (CustomStyle []))  (zip [0..] pnts)\n", "target": "  import java.awt.*;\n  import java.awt.event.*;\n  import java.awt.geom.*;\n  import javax.swing.JApplet;\n  import javax.swing.JFrame;\n  public class Plot2d extends JApplet {\n    double[] xi;\n    double[] yi;\n    public Plot2d(double[] x, double[] y) {\n        this.xi = x;\n        this.yi = y;\n    }\n    public static double max(double[] t) {\n        double maximum = t[0];   \n        for (int i = 1; i < t.length; i++) {\n            if (t[i] > maximum) {\n                maximum = t[i];  \n            }\n        }\n        return maximum;\n    }\n    public static double min(double[] t) {\n        double minimum = t[0];\n        for (int i = 1; i < t.length; i++) {\n            if (t[i] < minimum) {\n                minimum = t[i];\n            }\n        }\n        return minimum;\n    }\n    public void init() {\n        setBackground(Color.white);\n        setForeground(Color.white);\n    }\n    public void paint(Graphics g) {\n        Graphics2D g2 = (Graphics2D) g;\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        g2.setPaint(Color.black);\n        int x0 = 70;\n        int y0 = 10;\n        int xm = 670;\n        int ym = 410;\n        int xspan = xm - x0;\n        int yspan = ym - y0;\n        double xmax = max(xi);\n        double xmin = min(xi);\n        double ymax = max(yi);\n        double ymin = min(yi);\n        g2.draw(new Line2D.Double(x0, ym, xm, ym));\n        g2.draw(new Line2D.Double(x0, ym, x0, y0));\n        for (int j = 0; j < 5; j++) {\n            int interv = 4;\n            g2.drawString(\"\" + (j * (xmax - xmin) / interv + xmin), j * xspan / interv + x0 - 10, ym + 20);\n            g2.drawString(\"\" + (j * (ymax - ymin) / interv + ymin), x0 - 20 - (int) (9 * Math.log10(ymax)),\n ym - j * yspan / interv + y0 - 5);\n            g2.draw(new Line2D.Double(j * xspan / interv + x0, ym, j * xspan / interv + x0, ym + 5));\n            g2.draw(new Line2D.Double(x0 - 5, j * yspan / interv + y0, x0, j * yspan / interv + y0));\n        }\n        for (int i = 0; i < xi.length; i++) {\n            int f = (int) ((xi[i] - xmin) * xspan / (xmax - xmin));\n            int h = (int) (((ymax - ymin) - (yi[i] - ymin)) * yspan / (ymax - ymin));\n            g2.drawString(\"o\", x0 + f - 3, h + 14);\n        }\n        for (int i = 0; i < xi.length - 1; i++) {\n            int f = (int) ((xi[i] - xmin) * xspan / (xmax - xmin));\n            int f2 = (int) ((xi[i + 1] - xmin) * xspan / (xmax - xmin));\n            int h = (int) (((ymax - ymin) - (yi[i] - ymin)) * yspan / (ymax - ymin));\n            int h2 = (int) (((ymax - ymin) - (yi[i + 1] - ymin)) * yspan / (ymax - ymin));\n            g2.draw(new Line2D.Double(f + x0, h + y0, f2 + x0, h2 + y0));\n        }\n    }\n    public static void main(String args[]) {\n        JFrame f = new JFrame(\"ShapesDemo2D\");\n        f.addWindowListener(new WindowAdapter() {\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        double[] r = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n        double[] t = {2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.09};\n        JApplet applet = new Plot2d(r, t);\n        f.getContentPane().add(\"Center\", applet);\n        applet.init();\n        f.pack();\n        f.setSize(new Dimension(720, 480));\n        f.show();\n    }\n  }\n"}
{"id": 344090, "name": "Plot coordinate pairs", "source": "Translate Haskell to Java: import Graphics.Gnuplot.Simple\n\npnts = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]\n\ndoPlot = plotPathStyle [ ( Title \"plotting dots\" )]\n            (PlotStyle Points (CustomStyle []))  (zip [0..] pnts)\n", "target": "  import java.awt.*;\n  import java.awt.event.*;\n  import java.awt.geom.*;\n  import javax.swing.JApplet;\n  import javax.swing.JFrame;\n  public class Plot2d extends JApplet {\n    double[] xi;\n    double[] yi;\n    public Plot2d(double[] x, double[] y) {\n        this.xi = x;\n        this.yi = y;\n    }\n    public static double max(double[] t) {\n        double maximum = t[0];   \n        for (int i = 1; i < t.length; i++) {\n            if (t[i] > maximum) {\n                maximum = t[i];  \n            }\n        }\n        return maximum;\n    }\n    public static double min(double[] t) {\n        double minimum = t[0];\n        for (int i = 1; i < t.length; i++) {\n            if (t[i] < minimum) {\n                minimum = t[i];\n            }\n        }\n        return minimum;\n    }\n    public void init() {\n        setBackground(Color.white);\n        setForeground(Color.white);\n    }\n    public void paint(Graphics g) {\n        Graphics2D g2 = (Graphics2D) g;\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        g2.setPaint(Color.black);\n        int x0 = 70;\n        int y0 = 10;\n        int xm = 670;\n        int ym = 410;\n        int xspan = xm - x0;\n        int yspan = ym - y0;\n        double xmax = max(xi);\n        double xmin = min(xi);\n        double ymax = max(yi);\n        double ymin = min(yi);\n        g2.draw(new Line2D.Double(x0, ym, xm, ym));\n        g2.draw(new Line2D.Double(x0, ym, x0, y0));\n        for (int j = 0; j < 5; j++) {\n            int interv = 4;\n            g2.drawString(\"\" + (j * (xmax - xmin) / interv + xmin), j * xspan / interv + x0 - 10, ym + 20);\n            g2.drawString(\"\" + (j * (ymax - ymin) / interv + ymin), x0 - 20 - (int) (9 * Math.log10(ymax)),\n ym - j * yspan / interv + y0 - 5);\n            g2.draw(new Line2D.Double(j * xspan / interv + x0, ym, j * xspan / interv + x0, ym + 5));\n            g2.draw(new Line2D.Double(x0 - 5, j * yspan / interv + y0, x0, j * yspan / interv + y0));\n        }\n        for (int i = 0; i < xi.length; i++) {\n            int f = (int) ((xi[i] - xmin) * xspan / (xmax - xmin));\n            int h = (int) (((ymax - ymin) - (yi[i] - ymin)) * yspan / (ymax - ymin));\n            g2.drawString(\"o\", x0 + f - 3, h + 14);\n        }\n        for (int i = 0; i < xi.length - 1; i++) {\n            int f = (int) ((xi[i] - xmin) * xspan / (xmax - xmin));\n            int f2 = (int) ((xi[i + 1] - xmin) * xspan / (xmax - xmin));\n            int h = (int) (((ymax - ymin) - (yi[i] - ymin)) * yspan / (ymax - ymin));\n            int h2 = (int) (((ymax - ymin) - (yi[i + 1] - ymin)) * yspan / (ymax - ymin));\n            g2.draw(new Line2D.Double(f + x0, h + y0, f2 + x0, h2 + y0));\n        }\n    }\n    public static void main(String args[]) {\n        JFrame f = new JFrame(\"ShapesDemo2D\");\n        f.addWindowListener(new WindowAdapter() {\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        double[] r = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n        double[] t = {2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.09};\n        JApplet applet = new Plot2d(r, t);\n        f.getContentPane().add(\"Center\", applet);\n        applet.init();\n        f.pack();\n        f.setSize(new Dimension(720, 480));\n        f.show();\n    }\n  }\n"}
{"id": 344091, "name": "LZW compression", "source": "Translate Haskell to Java: import Data.List (elemIndex, tails)\nimport Data.Maybe (fromJust)\n\ndoLZW :: Eq a => [a] -> [a] -> [Int]\ndoLZW _ [] = []\ndoLZW as (x:xs) = lzw (return <$> as) [x] xs\n  where\n    lzw a w [] = [fromJust $ elemIndex w a]\n    lzw a w (x:xs)\n      | w_ `elem` a = lzw a w_ xs\n      | otherwise = fromJust (elemIndex w a) : lzw (a ++ [w_]) [x] xs\n      where\n        w_ = w ++ [x]\n\nundoLZW :: [a] -> [Int] -> [a]\nundoLZW _ [] = []\nundoLZW a cs =\n  cs >>=\n  (!!)\n    (foldl\n       ((.) <$> (++) <*>\n        (\\x xs -> return (((++) <$> head <*> take 1 . last) ((x !!) <$> xs))))\n       (return <$> a)\n       (take2 cs))\n\ntake2 :: [a] -> [[a]]\ntake2 xs = filter ((2 ==) . length) (take 2 <$> tails xs)\n\nmain :: IO ()\nmain = do\n  print $ doLZW ['\\0' .. '\\255'] \"TOBEORNOTTOBEORTOBEORNOT\"\n  print $\n    undoLZW\n      ['\\0' .. '\\255']\n      [84, 79, 66, 69, 79, 82, 78, 79, 84, 256, 258, 260, 265, 259, 261, 263]\n  print $\n    ((==) <*> ((.) <$> undoLZW <*> doLZW) ['\\NUL' .. '\\255'])\n      \"TOBEORNOTTOBEORTOBEORNOT\"\n", "target": "import java.util.*;\n\npublic class LZW {\n    \n    public static List<Integer> compress(String uncompressed) {\n        \n        int dictSize = 256;\n        Map<String,Integer> dictionary = new HashMap<String,Integer>();\n        for (int i = 0; i < 256; i++)\n            dictionary.put(\"\" + (char)i, i);\n        \n        String w = \"\";\n        List<Integer> result = new ArrayList<Integer>();\n        for (char c : uncompressed.toCharArray()) {\n            String wc = w + c;\n            if (dictionary.containsKey(wc))\n                w = wc;\n            else {\n                result.add(dictionary.get(w));\n                \n                dictionary.put(wc, dictSize++);\n                w = \"\" + c;\n            }\n        }\n \n        \n        if (!w.equals(\"\"))\n            result.add(dictionary.get(w));\n        return result;\n    }\n    \n    \n    public static String decompress(List<Integer> compressed) {\n        \n        int dictSize = 256;\n        Map<Integer,String> dictionary = new HashMap<Integer,String>();\n        for (int i = 0; i < 256; i++)\n            dictionary.put(i, \"\" + (char)i);\n        \n        String w = \"\" + (char)(int)compressed.remove(0);\n        StringBuffer result = new StringBuffer(w);\n        for (int k : compressed) {\n            String entry;\n            if (dictionary.containsKey(k))\n                entry = dictionary.get(k);\n            else if (k == dictSize)\n                entry = w + w.charAt(0);\n            else\n                throw new IllegalArgumentException(\"Bad compressed k: \" + k);\n            \n            result.append(entry);\n            \n            \n            dictionary.put(dictSize++, w + entry.charAt(0));\n            \n            w = entry;\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        List<Integer> compressed = compress(\"TOBEORNOTTOBEORTOBEORNOT\");\n        System.out.println(compressed);\n        String decompressed = decompress(compressed);\n        System.out.println(decompressed);\n    }\n}\n"}
{"id": 344092, "name": "Bioinformatics_base count", "source": "Translate Haskell to Java: import Data.List       (group, sort)\nimport Data.List.Split (chunksOf)\nimport Text.Printf     (printf, IsChar(..), PrintfArg(..), fmtChar, fmtPrecision, formatString)\n\ndata DNABase = A | C | G | T deriving (Show, Read, Eq, Ord)\ntype DNASequence = [DNABase]\n\ninstance IsChar DNABase where\n  toChar = head . show\n  fromChar = read . pure\n\ninstance PrintfArg DNABase where\n  formatArg x fmt = formatString (show x) (fmt { fmtChar = 's', fmtPrecision = Nothing })\n\ntest :: DNASequence\ntest = read . pure <$> concat\n  [ \"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\"\n  , \"CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\"\n  , \"AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\"\n  , \"GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\"\n  , \"CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\"\n  , \"TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\"\n  , \"TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\"\n  , \"CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\"\n  , \"TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\"\n  , \"GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\" ]\n\nchunkedDNASequence :: DNASequence -> [(Int, [DNABase])]\nchunkedDNASequence = zip [50,100..] . chunksOf 50\n\nbaseCounts :: DNASequence -> [(DNABase, Int)]\nbaseCounts = fmap ((,) . head <*> length) . group . sort\n\nmain :: IO ()\nmain = do\n  putStrLn \"Sequence:\"\n  mapM_ (uncurry (printf \"%3d: %s\\n\")) $ chunkedDNASequence test\n  putStrLn \"\\nBase Counts:\"\n  mapM_ (uncurry (printf \"%2s: %2d\\n\")) $ baseCounts test\n  putStrLn (replicate 8 '-') >> printf \" \u03a3: %d\\n\\n\" (length test)\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class orderedSequence {\n    public static void main(String[] args) {\n        Sequence gene = new Sequence(\"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\");\n        gene.runSequence();\n    }\n}\n\n\npublic class Sequence {\n    \n    private final String seq;\n    \n    public Sequence(String sq) {\n        this.seq = sq;\n    }\n    \n    \n    public void prettyPrint() {\n        System.out.println(\"Sequence:\");\n        int i = 0;\n        for ( ; i < seq.length() - 50 ; i += 50) {\n            System.out.printf(\"%5s\u00a0: %s\\n\", i + 50, seq.substring(i, i + 50));\n        }\n        System.out.printf(\"%5s\u00a0: %s\\n\", seq.length(), seq.substring(i));\n    }\n    \n    \n    public void displayCount() {\n        Map<Character, Integer> counter = new HashMap<>();\n        for (int i = 0 ; i < seq.length() ; ++i) {\n            counter.merge(seq.charAt(i), 1, Integer::sum);\n        }\n\n        System.out.println(\"Base vs. Count:\");\n        counter.forEach(\n            key, value -> System.out.printf(\"%5s\u00a0: %s\\n\", key, value));\n        System.out.printf(\"%5s: %s\\n\", \"SUM\", seq.length());\n    }\n    \n    public void runSequence() {\n        this.prettyPrint();\n        this.displayCount();\n    }\n}\n"}
{"id": 344093, "name": "Bioinformatics_base count", "source": "Translate Haskell to Java: import Data.List       (group, sort)\nimport Data.List.Split (chunksOf)\nimport Text.Printf     (printf, IsChar(..), PrintfArg(..), fmtChar, fmtPrecision, formatString)\n\ndata DNABase = A | C | G | T deriving (Show, Read, Eq, Ord)\ntype DNASequence = [DNABase]\n\ninstance IsChar DNABase where\n  toChar = head . show\n  fromChar = read . pure\n\ninstance PrintfArg DNABase where\n  formatArg x fmt = formatString (show x) (fmt { fmtChar = 's', fmtPrecision = Nothing })\n\ntest :: DNASequence\ntest = read . pure <$> concat\n  [ \"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\"\n  , \"CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\"\n  , \"AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\"\n  , \"GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\"\n  , \"CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\"\n  , \"TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\"\n  , \"TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\"\n  , \"CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\"\n  , \"TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\"\n  , \"GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\" ]\n\nchunkedDNASequence :: DNASequence -> [(Int, [DNABase])]\nchunkedDNASequence = zip [50,100..] . chunksOf 50\n\nbaseCounts :: DNASequence -> [(DNABase, Int)]\nbaseCounts = fmap ((,) . head <*> length) . group . sort\n\nmain :: IO ()\nmain = do\n  putStrLn \"Sequence:\"\n  mapM_ (uncurry (printf \"%3d: %s\\n\")) $ chunkedDNASequence test\n  putStrLn \"\\nBase Counts:\"\n  mapM_ (uncurry (printf \"%2s: %2d\\n\")) $ baseCounts test\n  putStrLn (replicate 8 '-') >> printf \" \u03a3: %d\\n\\n\" (length test)\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class orderedSequence {\n    public static void main(String[] args) {\n        Sequence gene = new Sequence(\"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\");\n        gene.runSequence();\n    }\n}\n\n\npublic class Sequence {\n    \n    private final String seq;\n    \n    public Sequence(String sq) {\n        this.seq = sq;\n    }\n    \n    \n    public void prettyPrint() {\n        System.out.println(\"Sequence:\");\n        int i = 0;\n        for ( ; i < seq.length() - 50 ; i += 50) {\n            System.out.printf(\"%5s\u00a0: %s\\n\", i + 50, seq.substring(i, i + 50));\n        }\n        System.out.printf(\"%5s\u00a0: %s\\n\", seq.length(), seq.substring(i));\n    }\n    \n    \n    public void displayCount() {\n        Map<Character, Integer> counter = new HashMap<>();\n        for (int i = 0 ; i < seq.length() ; ++i) {\n            counter.merge(seq.charAt(i), 1, Integer::sum);\n        }\n\n        System.out.println(\"Base vs. Count:\");\n        counter.forEach(\n            key, value -> System.out.printf(\"%5s\u00a0: %s\\n\", key, value));\n        System.out.printf(\"%5s: %s\\n\", \"SUM\", seq.length());\n    }\n    \n    public void runSequence() {\n        this.prettyPrint();\n        this.displayCount();\n    }\n}\n"}
{"id": 344094, "name": "Ulam spiral (for primes)", "source": "Translate Haskell to Java: import Data.List\nimport Data.Numbers.Primes\n\nulam n representation = swirl n . map representation\n", "target": "import java.util.Arrays;\n\npublic class Ulam{\n\tenum Direction{\n\t\tRIGHT, UP, LEFT, DOWN;\n\t}\n\t\n\tprivate static String[][] genUlam(int n){\n\t\treturn genUlam(n, 1);\n\t}\n\n\tprivate static String[][] genUlam(int n, int i){\n\t\tString[][] spiral = new String[n][n];\n\t\tDirection dir = Direction.RIGHT;\n\t\tint j = i;\n\t\tint y = n / 2;\n\t\tint x = (n % 2 == 0) ? y - 1 : y; \n\t\twhile(j <= ((n * n) - 1 + i)){\n\t\t\tspiral[y][x] = isPrime(j) ? String.format(\"%4d\", j) : \" ---\";\n\n\t\t\tswitch(dir){\n\t\t\tcase RIGHT:\n\t\t\t\tif(x <= (n - 1) && spiral[y - 1][x] == null && j > i) dir = Direction.UP; break;\n\t\t\tcase UP:\n\t\t\t\tif(spiral[y][x - 1] == null) dir = Direction.LEFT; break;\n\t\t\tcase LEFT:\n\t\t\t\tif(x == 0 || spiral[y + 1][x] == null) dir = Direction.DOWN; break;\n\t\t\tcase DOWN:\n\t\t\t\tif(spiral[y][x + 1] == null) dir = Direction.RIGHT; break;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(dir){\n\t\t\t\tcase RIGHT:\tx++; break;\n\t\t\t\tcase UP: \ty--; break;\n\t\t\t\tcase LEFT:\tx--; break;\n\t\t\t\tcase DOWN:\ty++; break;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\treturn spiral;\n\t}\n\t\n\tpublic static boolean isPrime(int a){\n\t\t   if(a == 2) return true;\n\t\t   if(a <= 1 || a % 2 == 0) return false;\n\t\t   long max = (long)Math.sqrt(a);\n\t\t   for(long n = 3; n <= max; n += 2){\n\t\t      if(a % n == 0) return false;\n\t\t   }\n\t\t   return true;\n\t\t}\n\t\n\tpublic static void main(String[] args){\n\t\tString[][] ulam = genUlam(9);\n\t\tfor(String[] row : ulam){\n\t\t\tSystem.out.println(Arrays.toString(row).replaceAll(\",\", \"\"));\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tfor(String[] row : ulam){\n\t\t\tSystem.out.println(Arrays.toString(row).replaceAll(\"\\\\[\\\\s+\\\\d+\", \"[  * \").replaceAll(\"\\\\s+\\\\d+\", \"   * \").replaceAll(\",\", \"\"));\n\t\t}\n\t}\n}\n"}
{"id": 344095, "name": "Fibonacci word", "source": "Translate Haskell to Java: module Main where\n\nimport Control.Monad\nimport Data.List\nimport Data.Monoid\nimport Text.Printf\n\nentropy :: (Ord a) => [a] -> Double\nentropy = sum\n        . map (\\c -> (c *) . logBase 2 $ 1.0 / c)\n        . (\\cs -> let { sc = sum cs } in map (/ sc) cs)\n        . map (fromIntegral . length)\n        . group\n        . sort\n\nfibonacci :: (Monoid m) => m -> m -> [m]\nfibonacci a b = unfoldr (\\(a,b) -> Just (a, (b, a <> b))) (a,b)\n\nmain :: IO ()\nmain = do\n    printf \"%2s %10s %17s %s\\n\" \"N\" \"length\" \"entropy\" \"word\"\n    zipWithM_ (\\i v -> let { l = length v } in printf \"%2d %10d\u00a0%.15f %s\\n\"\n                   i l (entropy v) (if l > 40 then \"...\" else v))\n              [1..38::Int]\n              (take 37 $ fibonacci \"1\" \"0\")\n", "target": "import java.util.*;\n\npublic class FWord {\n    private  String fWord0 = \"\";\n    private  String fWord1 = \"\";\n\n    private String nextFWord () {\n        final String result;\n        \n        if ( \"\".equals ( fWord1 ) )      result = \"1\";\n        else if ( \"\".equals ( fWord0 ) ) result = \"0\";\n        else                             result = fWord1 + fWord0;\n\n        fWord0 = fWord1;\n        fWord1 = result;\n\n        return result;\n    }\n\n    public static double entropy ( final String source ) {\n        final int                        length = source.length ();\n        final Map < Character, Integer > counts = new HashMap < Character, Integer > ();\n         double                     result = 0.0;\n \n        for ( int i = 0; i < length; i++ ) {\n            final char c = source.charAt ( i );\n\n            if ( counts.containsKey ( c ) ) counts.put ( c, counts.get ( c ) + 1 );\n            else                            counts.put ( c, 1 );\n        }\n\n        for ( final int count : counts.values () ) {\n            final double proportion = ( double ) count / length;\n\n            result -= proportion * ( Math.log ( proportion ) / Math.log ( 2 ) );\n        }\n\n        return result;\n    }\n\n    public static void main ( final String [] args ) {\n        final FWord fWord = new FWord ();\n\n        for ( int i = 0; i < 37;  ) {\n            final String word = fWord.nextFWord ();\n\n            System.out.printf ( \"%3d %10d %s %n\", ++i, word.length (), entropy ( word ) );\n        }\n    }\n}\n"}
{"id": 344096, "name": "Fibonacci word", "source": "Translate Haskell to Java: module Main where\n\nimport Control.Monad\nimport Data.List\nimport Data.Monoid\nimport Text.Printf\n\nentropy :: (Ord a) => [a] -> Double\nentropy = sum\n        . map (\\c -> (c *) . logBase 2 $ 1.0 / c)\n        . (\\cs -> let { sc = sum cs } in map (/ sc) cs)\n        . map (fromIntegral . length)\n        . group\n        . sort\n\nfibonacci :: (Monoid m) => m -> m -> [m]\nfibonacci a b = unfoldr (\\(a,b) -> Just (a, (b, a <> b))) (a,b)\n\nmain :: IO ()\nmain = do\n    printf \"%2s %10s %17s %s\\n\" \"N\" \"length\" \"entropy\" \"word\"\n    zipWithM_ (\\i v -> let { l = length v } in printf \"%2d %10d\u00a0%.15f %s\\n\"\n                   i l (entropy v) (if l > 40 then \"...\" else v))\n              [1..38::Int]\n              (take 37 $ fibonacci \"1\" \"0\")\n", "target": "import java.util.*;\n\npublic class FWord {\n    private  String fWord0 = \"\";\n    private  String fWord1 = \"\";\n\n    private String nextFWord () {\n        final String result;\n        \n        if ( \"\".equals ( fWord1 ) )      result = \"1\";\n        else if ( \"\".equals ( fWord0 ) ) result = \"0\";\n        else                             result = fWord1 + fWord0;\n\n        fWord0 = fWord1;\n        fWord1 = result;\n\n        return result;\n    }\n\n    public static double entropy ( final String source ) {\n        final int                        length = source.length ();\n        final Map < Character, Integer > counts = new HashMap < Character, Integer > ();\n         double                     result = 0.0;\n \n        for ( int i = 0; i < length; i++ ) {\n            final char c = source.charAt ( i );\n\n            if ( counts.containsKey ( c ) ) counts.put ( c, counts.get ( c ) + 1 );\n            else                            counts.put ( c, 1 );\n        }\n\n        for ( final int count : counts.values () ) {\n            final double proportion = ( double ) count / length;\n\n            result -= proportion * ( Math.log ( proportion ) / Math.log ( 2 ) );\n        }\n\n        return result;\n    }\n\n    public static void main ( final String [] args ) {\n        final FWord fWord = new FWord ();\n\n        for ( int i = 0; i < 37;  ) {\n            final String word = fWord.nextFWord ();\n\n            System.out.printf ( \"%3d %10d %s %n\", ++i, word.length (), entropy ( word ) );\n        }\n    }\n}\n"}
{"id": 344097, "name": "Text processing_1", "source": "Translate Haskell to Java: import Data.List\nimport Numeric\nimport Control.Arrow\nimport Control.Monad\nimport Text.Printf\nimport System.Environment\nimport Data.Function\n\ntype Date = String\ntype Value = Double\ntype Flag = Bool\n\nreadFlg :: String -> Flag\nreadFlg = (> 0).read\n\nreadNum :: String -> Value\nreadNum = fst.head.readFloat\n\ntake2 = takeWhile(not.null).unfoldr (Just.splitAt 2)\n\nparseData :: [String] -> (Date,[(Value,Flag)])\nparseData = head &&& map(readNum.head &&& readFlg.last).take2.tail\n\nsumAccs :: (Date,[(Value,Flag)]) -> (Date, ((Value,Int),[Flag]))\nsumAccs = second (((sum &&& length).concat.uncurry(zipWith(\\v f -> [v|f])) &&& snd).unzip)\n\nmaxNAseq :: [Flag] -> [(Int,Int)]\nmaxNAseq = head.groupBy((==) `on` fst).sortBy(flip compare)\n           . concat.uncurry(zipWith(\\i (r,b)->[(r,i)|not b]))\n           . first(init.scanl(+)0). unzip\n           . map ((fst &&& id).(length &&& head)). group\n\nmain = do\n    file:_ <- getArgs\n    f <- readFile file\n    let dat :: [(Date,((Value,Int),[Flag]))]\n        dat      = map (sumAccs. parseData. words).lines $ f\n        summ     = ((sum *** sum). unzip *** maxNAseq.concat). unzip $ map snd dat\n        totalFmt = \"\\nSummary\\t\\t accept: %d\\t total:\u00a0%.3f \\taverage: %6.3f\\n\\n\"\n        lineFmt  = \"%8s\\t accept: %2d\\t total: %11.3f \\taverage: %6.3f\\n\"\n        maxFmt   =  \"Maximum of %d consecutive false readings, starting on line /%s/ and ending on line /%s/\\n\"\n\n    putStrLn \"\\nSome lines:\\n\"\n    mapM_ (\\(d,((v,n),_)) -> printf lineFmt d n v (v/fromIntegral n)) $ take 4 $ drop 2200 dat \n    (\\(t,n) -> printf totalFmt  n t (t/fromIntegral n)) $ fst summ\n    mapM_ ((\\(l, d1,d2) -> printf maxFmt l d1 d2)\n              . (\\(a,b)-> (a,(fst.(dat!!).(`div`24))b,(fst.(dat!!).(`div`24))(a+b)))) $ snd summ\n", "target": "import java.io.File;\nimport java.util.*;\nimport static java.lang.System.out;\n\npublic class TextProcessing1 {\n\n    public static void main(String[] args) throws Exception {\n        Locale.setDefault(new Locale(\"en\", \"US\"));\n        Metrics metrics = new Metrics();\n\n        int dataGap = 0;\n        String gapBeginDate = null;\n        try (Scanner lines = new Scanner(new File(\"readings.txt\"))) {\n            while (lines.hasNextLine()) {\n\n                double lineTotal = 0.0;\n                int linePairs = 0;\n                int lineInvalid = 0;\n                String lineDate;\n\n                try (Scanner line = new Scanner(lines.nextLine())) {\n\n                    lineDate = line.next();\n\n                    while (line.hasNext()) {\n                        final double value = line.nextDouble();\n                        if (line.nextInt() <= 0) {\n                            if (dataGap == 0)\n                                gapBeginDate = lineDate;\n                            dataGap++;\n                            lineInvalid++;\n                            continue;\n                        }\n                        lineTotal += value;\n                        linePairs++;\n\n                        metrics.addDataGap(dataGap, gapBeginDate, lineDate);\n                        dataGap = 0;\n                    }\n                }\n                metrics.addLine(lineTotal, linePairs);\n                metrics.lineResult(lineDate, lineInvalid, linePairs, lineTotal);\n            }\n            metrics.report();\n        }\n    }\n\n    private static class Metrics {\n        private List<String[]> gapDates;\n        private int maxDataGap = -1;\n        private double total;\n        private int pairs;\n        private int lineResultCount;\n\n        void addLine(double tot, double prs) {\n            total += tot;\n            pairs += prs;\n        }\n\n        void addDataGap(int gap, String begin, String end) {\n            if (gap > 0 && gap >= maxDataGap) {\n                if (gap > maxDataGap) {\n                    maxDataGap = gap;\n                    gapDates = new ArrayList<>();\n                }\n                gapDates.add(new String[]{begin, end});\n            }\n        }\n\n        void lineResult(String date, int invalid, int prs, double tot) {\n            if (lineResultCount >= 3)\n                return;\n            out.printf(\"%10s  out: %2d  in: %2d  tot: %10.3f  avg: %10.3f%n\",\n                    date, invalid, prs, tot, (prs > 0) ? tot / prs : 0.0);\n            lineResultCount++;\n        }\n\n        void report() {\n            out.printf(\"%ntotal    = %10.3f%n\", total);\n            out.printf(\"readings = %6d%n\", pairs);\n            out.printf(\"average  = %010.3f%n\", total / pairs);\n            out.printf(\"%nmaximum run(s) of %d invalid measurements: %n\",\n                    maxDataGap);\n            for (String[] dates : gapDates)\n                out.printf(\"begins at %s and ends at %s%n\", dates[0], dates[1]);\n\n        }\n    }\n}\n"}
{"id": 344098, "name": "Death Star", "source": "Translate Haskell to Java: import Data.List (genericLength)\n\nshades = \".:!*oe%#&@\"\nn = genericLength shades\ndot a b = sum $ zipWith (*) a b\nnormalize x = (/ sqrt (x `dot` x)) <$> x\n\ndeathStar r k amb = unlines $\n  [ [ if x*x + y*y <= r*r\n      then let vec = normalize $ normal x y\n               b = (light `dot` vec) ** k + amb\n               intensity = (1 - b)*(n - 1)\n           in shades !! round ((0 `max` intensity) `min` n)\n      else ' '\n    | y <- map (/2.12) [- 2*r - 0.5 .. 2*r + 0.5]  ]\n  | x <- [ - r - 0.5 .. r + 0.5] ]\n  where\n    light = normalize [-30,-30,-50]\n    normal x y\n      | (x+r)**2 + (y+r)**2 <= r**2 = [x+r, y+r, sph2 x y]\n      | otherwise = [x, y, sph1 x y]\n    sph1 x y = sqrt (r*r - x*x - y*y)\n    sph2 x y = r - sqrt (r*r - (x+r)**2 - (y+r)**2)\n", "target": "import javafx.application.Application;\nimport javafx.event.EventHandler;\nimport javafx.geometry.Point3D;\nimport javafx.scene.Group;\nimport javafx.scene.Scene;\nimport javafx.scene.input.KeyCode;\nimport javafx.scene.input.KeyEvent;\nimport javafx.scene.shape.MeshView;\nimport javafx.scene.shape.TriangleMesh;\nimport javafx.scene.transform.Rotate;\nimport javafx.stage.Stage;\npublic class DeathStar extends Application {\n\n\tprivate static final int DIVISION = 200;\n\tfloat radius = 300;\n\n\t@Override\n\tpublic void start(Stage primaryStage) throws Exception {\n\t\tPoint3D otherSphere = new Point3D(-radius, 0, -radius * 1.5);\n\t\tfinal TriangleMesh triangleMesh = createMesh(DIVISION, radius, otherSphere);\n\t\tMeshView a = new MeshView(triangleMesh);\n\n\t\ta.setTranslateY(radius);\n\t\ta.setTranslateX(radius);\n\t\ta.setRotationAxis(Rotate.Y_AXIS);\n\t\tScene scene = new Scene(new Group(a));\n\n\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\tprimaryStage.setScene(scene);\n\t\tprimaryStage.show();\n\t}\n\n\tstatic TriangleMesh createMesh(final int division, final float radius, final Point3D centerOtherSphere) {\n\t\tRotate rotate = new Rotate(180, centerOtherSphere);\n\t\tfinal int div2 = division / 2;\n\n\t\tfinal int nPoints = division * (div2 - 1) + 2;\n\t\tfinal int nTPoints = (division + 1) * (div2 - 1) + division * 2;\n\t\tfinal int nFaces = division * (div2 - 2) * 2 + division * 2;\n\n\t\tfinal float rDiv = 1.f / division;\n\n\t\tfloat points[] = new float[nPoints * 3];\n\t\tfloat tPoints[] = new float[nTPoints * 2];\n\t\tint faces[] = new int[nFaces * 6];\n\n\t\tint pPos = 0, tPos = 0;\n\n\t\tfor (int y = 0; y < div2 - 1; ++y) {\n\t\t\tfloat va = rDiv * (y + 1 - div2 / 2) * 2 * (float) Math.PI;\n\t\t\tfloat sin_va = (float) Math.sin(va);\n\t\t\tfloat cos_va = (float) Math.cos(va);\n\n\t\t\tfloat ty = 0.5f + sin_va * 0.5f;\n\t\t\tfor (int i = 0; i < division; ++i) {\n\t\t\t\tdouble a = rDiv * i * 2 * (float) Math.PI;\n\t\t\t\tfloat hSin = (float) Math.sin(a);\n\t\t\t\tfloat hCos = (float) Math.cos(a);\n\t\t\t\tpoints[pPos + 0] = hSin * cos_va * radius;\n\t\t\t\tpoints[pPos + 2] = hCos * cos_va * radius;\n\t\t\t\tpoints[pPos + 1] = sin_va * radius;\n\n\t\t\t\tfinal Point3D point3D = new Point3D(points[pPos + 0], points[pPos + 1], points[pPos + 2]);\n\t\t\t\tdouble distance = centerOtherSphere.distance(point3D);\n\t\t\t\tif (distance <= radius) {\n\t\t\t\t\tPoint3D subtract = centerOtherSphere.subtract(point3D);\n\t\t\t\t\tPoint3D transform = rotate.transform(subtract);\n\t\t\t\t\tpoints[pPos + 0] = (float) transform.getX();\n\t\t\t\t\tpoints[pPos + 1] = (float) transform.getY();\n\t\t\t\t\tpoints[pPos + 2] = (float) transform.getZ();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\ttPoints[tPos + 0] = 1 - rDiv * i;\n\t\t\t\ttPoints[tPos + 1] = ty;\n\t\t\t\tpPos += 3;\n\t\t\t\ttPos += 2;\n\t\t\t}\n\t\t\ttPoints[tPos + 0] = 0;\n\t\t\ttPoints[tPos + 1] = ty;\n\t\t\ttPos += 2;\n\t\t}\n\n\t\tpoints[pPos + 0] = 0;\n\t\tpoints[pPos + 1] = -radius;\n\t\tpoints[pPos + 2] = 0;\n\t\tpoints[pPos + 3] = 0;\n\t\tpoints[pPos + 4] = radius;\n\t\tpoints[pPos + 5] = 0;\n\t\tpPos += 6;\n\n\t\tint pS = (div2 - 1) * division;\n\n\t\tfloat textureDelta = 1.f / 256;\n\t\tfor (int i = 0; i < division; ++i) {\n\t\t\ttPoints[tPos + 0] = rDiv * (0.5f + i);\n\t\t\ttPoints[tPos + 1] = textureDelta;\n\t\t\ttPos += 2;\n\t\t}\n\n\t\tfor (int i = 0; i < division; ++i) {\n\t\t\ttPoints[tPos + 0] = rDiv * (0.5f + i);\n\t\t\ttPoints[tPos + 1] = 1 - textureDelta;\n\t\t\ttPos += 2;\n\t\t}\n\n\t\tint fIndex = 0;\n\t\tfor (int y = 0; y < div2 - 2; ++y) {\n\t\t\tfor (int x = 0; x < division; ++x) {\n\t\t\t\tint p0 = y * division + x;\n\t\t\t\tint p1 = p0 + 1;\n\t\t\t\tint p2 = p0 + division;\n\t\t\t\tint p3 = p1 + division;\n\n\t\t\t\tint t0 = p0 + y;\n\t\t\t\tint t1 = t0 + 1;\n\t\t\t\tint t2 = t0 + division + 1;\n\t\t\t\tint t3 = t1 + division + 1;\n\n\t\t\t\t\n\t\t\t\tfaces[fIndex + 0] = p0;\n\t\t\t\tfaces[fIndex + 1] = t0;\n\t\t\t\tfaces[fIndex + 2] = p1 % division == 0 ? p1 - division : p1;\n\t\t\t\tfaces[fIndex + 3] = t1;\n\t\t\t\tfaces[fIndex + 4] = p2;\n\t\t\t\tfaces[fIndex + 5] = t2;\n\t\t\t\tfIndex += 6;\n\n\t\t\t\t\n\t\t\t\tfaces[fIndex + 0] = p3 % division == 0 ? p3 - division : p3;\n\t\t\t\tfaces[fIndex + 1] = t3;\n\t\t\t\tfaces[fIndex + 2] = p2;\n\t\t\t\tfaces[fIndex + 3] = t2;\n\t\t\t\tfaces[fIndex + 4] = p1 % division == 0 ? p1 - division : p1;\n\t\t\t\tfaces[fIndex + 5] = t1;\n\t\t\t\tfIndex += 6;\n\t\t\t}\n\t\t}\n\n\t\tint p0 = pS;\n\t\tint tB = (div2 - 1) * (division + 1);\n\t\tfor (int x = 0; x < division; ++x) {\n\t\t\tint p2 = x, p1 = x + 1, t0 = tB + x;\n\t\t\tfaces[fIndex + 0] = p0;\n\t\t\tfaces[fIndex + 1] = t0;\n\t\t\tfaces[fIndex + 2] = p1 == division ? 0 : p1;\n\t\t\tfaces[fIndex + 3] = p1;\n\t\t\tfaces[fIndex + 4] = p2;\n\t\t\tfaces[fIndex + 5] = p2;\n\t\t\tfIndex += 6;\n\t\t}\n\n\t\tp0 = p0 + 1;\n\t\ttB = tB + division;\n\t\tint pB = (div2 - 2) * division;\n\n\t\tfor (int x = 0; x < division; ++x) {\n\t\t\tint p1 = pB + x, p2 = pB + x + 1, t0 = tB + x;\n\t\t\tint t1 = (div2 - 2) * (division + 1) + x, t2 = t1 + 1;\n\t\t\tfaces[fIndex + 0] = p0;\n\t\t\tfaces[fIndex + 1] = t0;\n\t\t\tfaces[fIndex + 2] = p1;\n\t\t\tfaces[fIndex + 3] = t1;\n\t\t\tfaces[fIndex + 4] = p2 % division == 0 ? p2 - division : p2;\n\t\t\tfaces[fIndex + 5] = t2;\n\t\t\tfIndex += 6;\n\t\t}\n\n\t\tTriangleMesh m = new TriangleMesh();\n\t\tm.getPoints().setAll(points);\n\t\tm.getTexCoords().setAll(tPoints);\n\t\tm.getFaces().setAll(faces);\n\n\t\treturn m;\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tlaunch(args);\n\t}\n\n}\n"}
{"id": 344099, "name": "Draw a sphere", "source": "Translate Haskell to Java: import Graphics.Rendering.OpenGL.GL\nimport Graphics.UI.GLUT.Objects\nimport Graphics.UI.GLUT\n\nsetProjection :: IO ()\nsetProjection = do\n  matrixMode $= Projection\n  ortho (-1) 1 (-1) 1 0 (-1)\n         \ngrey1,grey9,red,white :: Color4 GLfloat\ngrey1 = Color4 0.1 0.1 0.1 1\ngrey9 = Color4 0.9 0.9 0.9 1\nred   = Color4 1   0   0   1\nwhite = Color4 1   1   1   1\n\nsetLights :: IO ()\nsetLights = do\n  let l = Light 0\n  ambient  l $= grey1\n  diffuse  l $= white\n  specular l $= white\n  position l $= Vertex4 (-4) 4 3 (0 :: GLfloat)\n  light    l $= Enabled\n  lighting   $= Enabled\n\nsetMaterial :: IO ()\nsetMaterial = do\n  materialAmbient   Front $= grey1\n  materialDiffuse   Front $= red\n  materialSpecular  Front $= grey9\n  materialShininess Front $= (32 :: GLfloat)\n\ndisplay :: IO()\ndisplay = do\n  clear [ColorBuffer]\n  renderObject Solid $ Sphere' 0.8 64 64\n  swapBuffers\n\nmain :: IO()\nmain = do\n  _ <- getArgsAndInitialize\n  _ <- createWindow \"Sphere\"\n  clearColor $= Color4 0.0 0.0 0.0 0.0\n  setProjection\n  setLights\n  setMaterial\n  displayCallback $= display\n  mainLoop\n", "target": "using System;\n\nnamespace Sphere {\n    internal class Program {\n        private const string Shades = \".:!*oe%&#@\";\n        private static readonly double[] Light = {30, 30, -50};\n\n        private static void Normalize(double[] v) {\n            double len = Math.Sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n            v[0] /= len;\n            v[1] /= len;\n            v[2] /= len;\n        }\n\n        private static double Dot(double[] x, double[] y) {\n            double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n            return d < 0 ? -d : 0;\n        }\n\n        public static void DrawSphere(double r, double k, double ambient) {\n            var vec = new double[3];\n            for(var i = (int)Math.Floor(-r); i <= (int)Math.Ceiling(r); i++) {\n                double x = i + .5;\n                for(var j = (int)Math.Floor(-2*r); j <= (int)Math.Ceiling(2*r); j++) {\n                    double y = j/2.0 + .5;\n                    if(x*x + y*y <= r*r) {\n                        vec[0] = x;\n                        vec[1] = y;\n                        vec[2] = Math.Sqrt(r*r - x*x - y*y);\n                        Normalize(vec);\n                        double b = Math.Pow(Dot(Light, vec), k) + ambient;\n                        int intensity = (b <= 0)\n                                            ? Shades.Length - 2\n                                            : (int)Math.Max((1 - b)*(Shades.Length - 1), 0);\n                        Console.Write(Shades[intensity]);\n                    }\n                    else\n                        Console.Write(' ');\n                }\n                Console.WriteLine();\n            }\n        }\n\n        private static void Main() {\n            Normalize(Light);\n            DrawSphere(6, 4, .1);\n            DrawSphere(10, 2, .4);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 344100, "name": "Draw a sphere", "source": "Translate Haskell to Java: import Graphics.Rendering.OpenGL.GL\nimport Graphics.UI.GLUT.Objects\nimport Graphics.UI.GLUT\n\nsetProjection :: IO ()\nsetProjection = do\n  matrixMode $= Projection\n  ortho (-1) 1 (-1) 1 0 (-1)\n         \ngrey1,grey9,red,white :: Color4 GLfloat\ngrey1 = Color4 0.1 0.1 0.1 1\ngrey9 = Color4 0.9 0.9 0.9 1\nred   = Color4 1   0   0   1\nwhite = Color4 1   1   1   1\n\nsetLights :: IO ()\nsetLights = do\n  let l = Light 0\n  ambient  l $= grey1\n  diffuse  l $= white\n  specular l $= white\n  position l $= Vertex4 (-4) 4 3 (0 :: GLfloat)\n  light    l $= Enabled\n  lighting   $= Enabled\n\nsetMaterial :: IO ()\nsetMaterial = do\n  materialAmbient   Front $= grey1\n  materialDiffuse   Front $= red\n  materialSpecular  Front $= grey9\n  materialShininess Front $= (32 :: GLfloat)\n\ndisplay :: IO()\ndisplay = do\n  clear [ColorBuffer]\n  renderObject Solid $ Sphere' 0.8 64 64\n  swapBuffers\n\nmain :: IO()\nmain = do\n  _ <- getArgsAndInitialize\n  _ <- createWindow \"Sphere\"\n  clearColor $= Color4 0.0 0.0 0.0 0.0\n  setProjection\n  setLights\n  setMaterial\n  displayCallback $= display\n  mainLoop\n", "target": "using System;\n\nnamespace Sphere {\n    internal class Program {\n        private const string Shades = \".:!*oe%&#@\";\n        private static readonly double[] Light = {30, 30, -50};\n\n        private static void Normalize(double[] v) {\n            double len = Math.Sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n            v[0] /= len;\n            v[1] /= len;\n            v[2] /= len;\n        }\n\n        private static double Dot(double[] x, double[] y) {\n            double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n            return d < 0 ? -d : 0;\n        }\n\n        public static void DrawSphere(double r, double k, double ambient) {\n            var vec = new double[3];\n            for(var i = (int)Math.Floor(-r); i <= (int)Math.Ceiling(r); i++) {\n                double x = i + .5;\n                for(var j = (int)Math.Floor(-2*r); j <= (int)Math.Ceiling(2*r); j++) {\n                    double y = j/2.0 + .5;\n                    if(x*x + y*y <= r*r) {\n                        vec[0] = x;\n                        vec[1] = y;\n                        vec[2] = Math.Sqrt(r*r - x*x - y*y);\n                        Normalize(vec);\n                        double b = Math.Pow(Dot(Light, vec), k) + ambient;\n                        int intensity = (b <= 0)\n                                            ? Shades.Length - 2\n                                            : (int)Math.Max((1 - b)*(Shades.Length - 1), 0);\n                        Console.Write(Shades[intensity]);\n                    }\n                    else\n                        Console.Write(' ');\n                }\n                Console.WriteLine();\n            }\n        }\n\n        private static void Main() {\n            Normalize(Light);\n            DrawSphere(6, 4, .1);\n            DrawSphere(10, 2, .4);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 344101, "name": "Thiele's interpolation formula", "source": "Translate Haskell to Java: thiele :: [Double] -> [Double] -> Double -> Double\nthiele xs ys = f rho1 (tail xs)\n  where\n    f _ [] _ = 1\n    f r@(r0:r1:r2:rs) (x:xs) v = r2 - r0 + (v - x) / f (tail r) xs v\n    rho1 = (!! 1) . (++ [0]) <$> rho\n    rho = repeat 0 : repeat 0 : ys : rnext (tail rho) xs (tail xs)\n      where\n        rnext _ _ [] = []\n        rnext r@(r0:r1:rs) x xn =\n          let z_ = zipWith\n          in z_ (+) (tail r0) (z_ (/) (z_ (-) x xn) (z_ (-) r1 (tail r1))) :\n             rnext (tail r) x (tail xn)\n\n\ninvInterp :: (Double -> Double) -> [Double] -> Double -> Double\ninvInterp f xs = thiele (map f xs) xs\n\nmain :: IO ()\nmain =\n  mapM_\n    print\n    [ 3.21 * inv_sin (sin (pi / 3.21))\n    , pi / 1.2345 * inv_cos (cos 1.2345)\n    , 7 * inv_tan (tan (pi / 7))\n    ]\n  where\n    [inv_sin, inv_cos, inv_tan] =\n      uncurry ((. div_pi) . invInterp) <$>\n      [(sin, (2, 31)), (cos, (2, 100)), (tan, (4, 1000))]\n    \n    div_pi (d, n) = (* (pi / (d * n))) <$> [0 .. n]\n", "target": "import static java.lang.Math.*;\n\npublic class Test {\n    final static int N = 32;\n    final static int N2 = (N * (N - 1) / 2);\n    final static double STEP = 0.05;\n\n    static double[] xval = new double[N];\n    static double[] t_sin = new double[N];\n    static double[] t_cos = new double[N];\n    static double[] t_tan = new double[N];\n\n    static double[] r_sin = new double[N2];\n    static double[] r_cos = new double[N2];\n    static double[] r_tan = new double[N2];\n\n    static double rho(double[] x, double[] y, double[] r, int i, int n) {\n        if (n < 0)\n            return 0;\n\n        if (n == 0)\n            return y[i];\n\n        int idx = (N - 1 - n) * (N - n) / 2 + i;\n        if (r[idx] != r[idx])\n            r[idx] = (x[i] - x[i + n])\n                    / (rho(x, y, r, i, n - 1) - rho(x, y, r, i + 1, n - 1))\n                    + rho(x, y, r, i + 1, n - 2);\n\n        return r[idx];\n    }\n\n    static double thiele(double[] x, double[] y, double[] r, double xin, int n) {\n        if (n > N - 1)\n            return 1;\n        return rho(x, y, r, 0, n) - rho(x, y, r, 0, n - 2)\n                + (xin - x[n]) / thiele(x, y, r, xin, n + 1);\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < N; i++) {\n            xval[i] = i * STEP;\n            t_sin[i] = sin(xval[i]);\n            t_cos[i] = cos(xval[i]);\n            t_tan[i] = t_sin[i] / t_cos[i];\n        }\n\n        for (int i = 0; i < N2; i++)\n            r_sin[i] = r_cos[i] = r_tan[i] = Double.NaN;\n\n        System.out.printf(\"%16.14f%n\", 6 * thiele(t_sin, xval, r_sin, 0.5, 0));\n        System.out.printf(\"%16.14f%n\", 3 * thiele(t_cos, xval, r_cos, 0.5, 0));\n        System.out.printf(\"%16.14f%n\", 4 * thiele(t_tan, xval, r_tan, 1.0, 0));\n    }\n}\n"}
{"id": 344102, "name": "Longest string challenge", "source": "Translate Haskell to Java: module Main where\n\nimport           System.Environment\n\ncmp :: String -> String -> Ordering\ncmp [] []         = EQ\ncmp [] (_:_)      = LT\ncmp (_:_) []      = GT\ncmp (_:xs) (_:ys) = cmp xs ys\n\nlongest :: String -> String\nlongest = longest' \"\" \"\" . lines\n  where\n    longest' acc l []         = acc\n    longest' [] l (x:xs)      = longest' x x xs\n    longest' acc l (x:xs) = case cmp l x of\n                                   LT -> longest' x x xs\n                                   EQ -> longest' (acc ++ '\\n':x) l xs\n                                   GT -> longest' acc l xs\n\nmain :: IO ()\nmain = do\n  (file:_) <- getArgs\n  contents <- readFile file\n  putStrLn $ longest contents\n", "target": "import java.io.File;\nimport java.util.Scanner;\n\npublic class LongestStringChallenge {\n\n    public static void main(String[] args) throws Exception {\n        String lines = \"\", longest = \"\";\n        try (Scanner sc = new Scanner(new File(\"lines.txt\"))) {\n            while(sc.hasNext()) {\n                String line = sc.nextLine();\n                if (longer(longest, line))\n                    lines = longest = line;\n                else if (!longer(line, longest))\n                    lines = lines.concat(\"\\n\").concat(line);\n            }\n        }\n        System.out.println(lines);\n    }\n\n    static boolean longer(String a, String b) {\n        try {\n            String dummy = a.substring(b.length());\n        } catch (StringIndexOutOfBoundsException e) {\n            return true;\n        }\n        return false;\n    }\n}\n"}
{"id": 344103, "name": "Hello world_Line printer", "source": "Translate Haskell to Java: import System.Process (ProcessHandle, runCommand)\n\nmain :: IO ProcessHandle\nmain = runCommand \"echo \\\"Hello World!\\\" | lpr\"\n", "target": "import java.io.FileWriter;\nimport java.io.IOException;\n \npublic class LinePrinter {\n  public static void main(String[] args) {\n    try {\n      FileWriter lp0 = new FileWriter(\"/dev/lp0\");\n      lp0.write(\"Hello World!\");\n      lp0.close();\n    } catch (IOException ioe) {\n      ioe.printStackTrace();\n    }\n  }\n}\n"}
{"id": 344104, "name": "Hello world_Line printer", "source": "Translate Haskell to Java: import System.Process (ProcessHandle, runCommand)\n\nmain :: IO ProcessHandle\nmain = runCommand \"echo \\\"Hello World!\\\" | lpr\"\n", "target": "import java.io.FileWriter;\nimport java.io.IOException;\n \npublic class LinePrinter {\n  public static void main(String[] args) {\n    try {\n      FileWriter lp0 = new FileWriter(\"/dev/lp0\");\n      lp0.write(\"Hello World!\");\n      lp0.close();\n    } catch (IOException ioe) {\n      ioe.printStackTrace();\n    }\n  }\n}\n"}
{"id": 344105, "name": "Magic squares of odd order", "source": "Translate Haskell to Java: \nimport Data.List\n\ntype Var = (Int, Int, Int, Int) \n\nmagicSum :: Int -> Int\nmagicSum x = ((x * x + 1) `div` 2) * x\n\nwrapInc :: Int -> Int -> Int\nwrapInc max x\n   | x + 1 == max    = 0\n   | otherwise       = x + 1\n\nwrapDec :: Int -> Int -> Int\nwrapDec max x\n   | x == 0    = max - 1\n   | otherwise = x - 1\n\nisZero :: [[Int]] -> Int -> Int -> Bool\nisZero m x y = m !! x !! y == 0\n\nsetAt :: (Int,Int) -> Int -> [[Int]] -> [[Int]]\nsetAt (x, y) val table\n   | (upper, current : lower) <- splitAt x table,\n     (left, this : right) <- splitAt y current\n         = upper ++ (left ++ val : right) : lower\n   | otherwise = error \"Outside\"\n\ncreate :: Int -> [[Int]]\ncreate x = replicate x $ replicate x 0\n\ncells :: [[Int]] -> Int\ncells m = x*x where x = length m\n   \nfill :: Var -> [[Int]] -> [[Int]]\nfill (sx, sy, sz, c) m\n   | c < cells m =\n      if isZero m sx sy \n      then fill ((wrapInc sz sx), (wrapDec sz sy), sz, c + 1) (setAt (sx, sy) (c + 1) m)\n      else fill ((wrapDec sz sx), (wrapInc sz(wrapInc sz sy)), sz, c) m\n   | otherwise = m\n\nmagicNumber :: Int -> [[Int]]\nmagicNumber d = transpose $ fill (d `div` 2, 0, d, 0) (create d)\n\ndisplay :: [[Int]] -> String\ndisplay (x:xs)\n   | null xs = vdisplay x\n   | otherwise = vdisplay x ++ ('\\n' : display xs)\n\nvdisplay :: [Int] -> String\nvdisplay (x:xs)\n   | null xs = show x\n   | otherwise = show x ++ \" \" ++ vdisplay xs\n\n\nmagicSquare x = do\n   putStr \"Magic Square of \"\n   putStr $ show x\n   putStr \" = \"\n   putStrLn $ show $ magicSum x\n   putStrLn $ display $ magicNumber x\n", "target": "public class MagicSquare {\n\n    public static void main(String[] args) {\n        int n = 5;\n        for (int[] row : magicSquareOdd(n)) {\n            for (int x : row)\n                System.out.format(\"%2s \", x);\n            System.out.println();\n        }\n        System.out.printf(\"\\nMagic constant: %d \", (n * n + 1) * n / 2);\n    }\n\n    public static int[][] magicSquareOdd(final int base) {\n        if (base % 2 == 0 || base < 3)\n            throw new IllegalArgumentException(\"base must be odd and > 2\");\n\n        int[][] grid = new int[base][base];\n        int r = 0, number = 0;\n        int size = base * base;\n\n        int c = base / 2;\n        while (number++ < size) {\n            grid[r][c] = number;\n            if (r == 0) {\n                if (c == base - 1) {\n                    r++;\n                } else {\n                    r = base - 1;\n                    c++;\n                }\n            } else {\n                if (c == base - 1) {\n                    r--;\n                    c = 0;\n                } else {\n                    if (grid[r - 1][c + 1] == 0) {\n                        r--;\n                        c++;\n                    } else {\n                        r++;\n                    }\n                }\n            }\n        }\n        return grid;\n    }\n}\n"}
{"id": 344106, "name": "Magic squares of odd order", "source": "Translate Haskell to Java: \nimport Data.List\n\ntype Var = (Int, Int, Int, Int) \n\nmagicSum :: Int -> Int\nmagicSum x = ((x * x + 1) `div` 2) * x\n\nwrapInc :: Int -> Int -> Int\nwrapInc max x\n   | x + 1 == max    = 0\n   | otherwise       = x + 1\n\nwrapDec :: Int -> Int -> Int\nwrapDec max x\n   | x == 0    = max - 1\n   | otherwise = x - 1\n\nisZero :: [[Int]] -> Int -> Int -> Bool\nisZero m x y = m !! x !! y == 0\n\nsetAt :: (Int,Int) -> Int -> [[Int]] -> [[Int]]\nsetAt (x, y) val table\n   | (upper, current : lower) <- splitAt x table,\n     (left, this : right) <- splitAt y current\n         = upper ++ (left ++ val : right) : lower\n   | otherwise = error \"Outside\"\n\ncreate :: Int -> [[Int]]\ncreate x = replicate x $ replicate x 0\n\ncells :: [[Int]] -> Int\ncells m = x*x where x = length m\n   \nfill :: Var -> [[Int]] -> [[Int]]\nfill (sx, sy, sz, c) m\n   | c < cells m =\n      if isZero m sx sy \n      then fill ((wrapInc sz sx), (wrapDec sz sy), sz, c + 1) (setAt (sx, sy) (c + 1) m)\n      else fill ((wrapDec sz sx), (wrapInc sz(wrapInc sz sy)), sz, c) m\n   | otherwise = m\n\nmagicNumber :: Int -> [[Int]]\nmagicNumber d = transpose $ fill (d `div` 2, 0, d, 0) (create d)\n\ndisplay :: [[Int]] -> String\ndisplay (x:xs)\n   | null xs = vdisplay x\n   | otherwise = vdisplay x ++ ('\\n' : display xs)\n\nvdisplay :: [Int] -> String\nvdisplay (x:xs)\n   | null xs = show x\n   | otherwise = show x ++ \" \" ++ vdisplay xs\n\n\nmagicSquare x = do\n   putStr \"Magic Square of \"\n   putStr $ show x\n   putStr \" = \"\n   putStrLn $ show $ magicSum x\n   putStrLn $ display $ magicNumber x\n", "target": "public class MagicSquare {\n\n    public static void main(String[] args) {\n        int n = 5;\n        for (int[] row : magicSquareOdd(n)) {\n            for (int x : row)\n                System.out.format(\"%2s \", x);\n            System.out.println();\n        }\n        System.out.printf(\"\\nMagic constant: %d \", (n * n + 1) * n / 2);\n    }\n\n    public static int[][] magicSquareOdd(final int base) {\n        if (base % 2 == 0 || base < 3)\n            throw new IllegalArgumentException(\"base must be odd and > 2\");\n\n        int[][] grid = new int[base][base];\n        int r = 0, number = 0;\n        int size = base * base;\n\n        int c = base / 2;\n        while (number++ < size) {\n            grid[r][c] = number;\n            if (r == 0) {\n                if (c == base - 1) {\n                    r++;\n                } else {\n                    r = base - 1;\n                    c++;\n                }\n            } else {\n                if (c == base - 1) {\n                    r--;\n                    c = 0;\n                } else {\n                    if (grid[r - 1][c + 1] == 0) {\n                        r--;\n                        c++;\n                    } else {\n                        r++;\n                    }\n                }\n            }\n        }\n        return grid;\n    }\n}\n"}
{"id": 344107, "name": "Sutherland-Hodgman polygon clipping", "source": "Translate Haskell to Java: module SuthHodgClip (clipTo) where\n\nimport Data.List\n\ntype   Pt a = (a, a)\ntype   Ln a = (Pt a, Pt a)\ntype Poly a = [Pt a]\n\n\npolyFrom ps = last ps : ps\n\n\nlinesFrom pps@(_:ps) = zip pps ps\n\n\n\n(.|) :: (Num a, Ord a) => Pt a -> Ln a -> Bool\n(x,y) .| ((px,py),(qx,qy)) = (qx-px)*(y-py) >= (qy-py)*(x-px)\n\n\n(><) :: Fractional a => Ln a -> Ln a -> Pt a\n((x1,y1),(x2,y2)) >< ((x3,y3),(x4,y4)) =\n    let (r,s) = (x1*y2-y1*x2, x3*y4-y3*x4)\n        (t,u,v,w) = (x1-x2, y3-y4, y1-y2, x3-x4)\n        d = t*u-v*w \n    in ((r*w-t*s)/d, (r*u-v*s)/d)\n\n\n\n\n\n(-|) :: (Fractional a, Ord a) => Ln a -> Ln a -> [Pt a]\nln@(p0, p1) -| clipLn =\n    case (p0 .| clipLn, p1 .| clipLn) of\n      (False, False) -> []\n      (False, True)  -> [isect, p1]\n      (True,  False) -> [isect]\n      (True,  True)  -> [p1]\n    where isect = ln >< clipLn\n\n\n(<|) :: (Fractional a, Ord a) => Poly a -> Ln a -> Poly a\npoly <| clipLn = polyFrom $ concatMap (-| clipLn) (linesFrom poly)\n\n\n\nclipTo :: (Fractional a, Ord a) => [Pt a] -> [Pt a] -> [Pt a]\ntargPts `clipTo` clipPts = \n    let targPoly = polyFrom targPts\n        clipLines = linesFrom (polyFrom clipPts)\n    in foldl' (<|) targPoly clipLines\n", "target": "import java.awt.*;\nimport java.awt.geom.Line2D;\nimport java.util.*;\nimport java.util.List;\nimport javax.swing.*;\n\npublic class SutherlandHodgman extends JFrame {\n\n    SutherlandHodgmanPanel panel;\n\n    public static void main(String[] args) {\n        JFrame f = new SutherlandHodgman();\n        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        f.setVisible(true);\n    }\n\n    public SutherlandHodgman() {\n        Container content = getContentPane();\n        content.setLayout(new BorderLayout());\n        panel = new SutherlandHodgmanPanel();\n        content.add(panel, BorderLayout.CENTER);\n        setTitle(\"SutherlandHodgman\");\n        pack();\n        setLocationRelativeTo(null);\n    }\n}\n\nclass SutherlandHodgmanPanel extends JPanel {\n    List<double[]> subject, clipper, result;\n\n    public SutherlandHodgmanPanel() {\n        setPreferredSize(new Dimension(600, 500));\n\n        \n        double[][] subjPoints = {{50, 150}, {200, 50}, {350, 150}, {350, 300},\n        {250, 300}, {200, 250}, {150, 350}, {100, 250}, {100, 200}};\n\n        double[][] clipPoints = {{100, 100}, {300, 100}, {300, 300}, {100, 300}};\n\n        subject = new ArrayList<>(Arrays.asList(subjPoints));\n        result  = new ArrayList<>(subject);\n        clipper = new ArrayList<>(Arrays.asList(clipPoints));\n\n        clipPolygon();\n    }\n\n    private void clipPolygon() {\n        int len = clipper.size();\n        for (int i = 0; i < len; i++) {\n\n            int len2 = result.size();\n            List<double[]> input = result;\n            result = new ArrayList<>(len2);\n\n            double[] A = clipper.get((i + len - 1) % len);\n            double[] B = clipper.get(i);\n\n            for (int j = 0; j < len2; j++) {\n\n                double[] P = input.get((j + len2 - 1) % len2);\n                double[] Q = input.get(j);\n\n                if (isInside(A, B, Q)) {\n                    if (!isInside(A, B, P))\n                        result.add(intersection(A, B, P, Q));\n                    result.add(Q);\n                } else if (isInside(A, B, P))\n                    result.add(intersection(A, B, P, Q));\n            }\n        }\n    }\n\n    private boolean isInside(double[] a, double[] b, double[] c) {\n        return (a[0] - c[0]) * (b[1] - c[1]) > (a[1] - c[1]) * (b[0] - c[0]);\n    }\n\n    private double[] intersection(double[] a, double[] b, double[] p, double[] q) {\n        double A1 = b[1] - a[1];\n        double B1 = a[0] - b[0];\n        double C1 = A1 * a[0] + B1 * a[1];\n\n        double A2 = q[1] - p[1];\n        double B2 = p[0] - q[0];\n        double C2 = A2 * p[0] + B2 * p[1];\n\n        double det = A1 * B2 - A2 * B1;\n        double x = (B2 * C1 - B1 * C2) / det;\n        double y = (A1 * C2 - A2 * C1) / det;\n\n        return new double[]{x, y};\n    }\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2 = (Graphics2D) g;\n        g2.translate(80, 60);\n        g2.setStroke(new BasicStroke(3));\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawPolygon(g2, subject, Color.blue);\n        drawPolygon(g2, clipper, Color.red);\n        drawPolygon(g2, result, Color.green);\n    }\n\n    private void drawPolygon(Graphics2D g2, List<double[]> points, Color color) {\n        g2.setColor(color);\n        int len = points.size();\n        Line2D line = new Line2D.Double();\n        for (int i = 0; i < len; i++) {\n            double[] p1 = points.get(i);\n            double[] p2 = points.get((i + 1) % len);\n            line.setLine(p1[0], p1[1], p2[0], p2[1]);\n            g2.draw(line);\n        }\n    }\n}\n"}
{"id": 344108, "name": "Sorting algorithms_Pancake sort", "source": "Translate Haskell to Java: import Data.List\nimport Control.Arrow\nimport Control.Monad\nimport Data.Maybe\n\ndblflipIt :: (Ord a) => [a] -> [a]\ndblflipIt = uncurry ((reverse.).(++)). first reverse\n  . ap (flip splitAt) (succ. fromJust. (elemIndex =<< maximum))\n \ndopancakeSort :: (Ord a) => [a] -> [a]\ndopancakeSort xs = dopcs (xs,[]) where\n  dopcs ([],rs) = rs\n  dopcs ([x],rs) = x:rs\n  dopcs (xs,rs) = dopcs $ (init &&& (:rs).last ) $ dblflipIt xs\n", "target": "public class PancakeSort\n{\n   int[] heap;\n\n   public String toString() {\n      String info = \"\";\n      for (int x: heap)\n         info += x + \" \";\n      return info;\n   }\n    \n   public void flip(int n) {\n      for (int i = 0; i < (n+1) / 2; ++i) {\n         int tmp = heap[i];\n         heap[i] = heap[n-i];\n         heap[n-i] = tmp;\n      }      \n      System.out.println(\"flip(0..\" + n + \"): \" + toString());\n   }\n   \n   public int[] minmax(int n) {\n      int xm, xM;\n      xm = xM = heap[0];\n      int posm = 0, posM = 0;\n      \n      for (int i = 1; i < n; ++i) {\n         if (heap[i] < xm) {\n            xm = heap[i];\n            posm = i;\n         }\n         else if (heap[i] > xM) {\n            xM = heap[i];\n            posM = i;\n         }\n      }\n      return new int[] {posm, posM};\n   }\n   \n   public void sort(int n, int dir) {\n      if (n == 0) return;\n         \n      int[] mM = minmax(n);\n      int bestXPos = mM[dir];\n      int altXPos = mM[1-dir];\n      boolean flipped = false;\n      \n      if (bestXPos == n-1) {\n         --n;\n      }\n      else if (bestXPos == 0) {\n         flip(n-1);\n         --n;\n      }\n      else if (altXPos == n-1) {\n         dir = 1-dir;\n         --n;\n         flipped = true;\n      }\n      else {\n         flip(bestXPos);\n      }\n      sort(n, dir);\n\n      if (flipped) {\n         flip(n);\n      }\n   }\n   \n   PancakeSort(int[] numbers) {\n      heap = numbers;\n      sort(numbers.length, 1);\n   } \n \n   public static void main(String[] args) {\n      int[] numbers = new int[args.length];\n      for (int i = 0; i < args.length; ++i)\n         numbers[i] = Integer.valueOf(args[i]);\n\n      PancakeSort pancakes = new PancakeSort(numbers);\n      System.out.println(pancakes);\n   }\n}\n"}
{"id": 344109, "name": "Call a function", "source": "Translate Haskell to Java: \nmultiply x y = x * y\nmultiply 10 20 \n\n\n\ntwopi = 6.28\n\ntwopi () = 6.28 \ntwopi :: Num a => () -> a \ntwopi () \n\n\nmultiply_by_10 = (10 * )\nmap multiply_by_10 [1, 2, 3] \nmultiply_all_by_10 = map multiply_by_10\nmultiply_all_by_10 [1, 2, 3] \n\n\n\n\n\n\n\n\n\n\n\n", "target": "foo();             \nInt x = bar();     \n"}
{"id": 344110, "name": "Call a function", "source": "Translate Haskell to Java: \nmultiply x y = x * y\nmultiply 10 20 \n\n\n\ntwopi = 6.28\n\ntwopi () = 6.28 \ntwopi :: Num a => () -> a \ntwopi () \n\n\nmultiply_by_10 = (10 * )\nmap multiply_by_10 [1, 2, 3] \nmultiply_all_by_10 = map multiply_by_10\nmultiply_all_by_10 [1, 2, 3] \n\n\n\n\n\n\n\n\n\n\n\n", "target": "foo();             \nInt x = bar();     \n"}
{"id": 344111, "name": "Extract file extension", "source": "Translate Haskell to Java: module FileExtension\n   where\n\nmyextension :: String -> String\nmyextension s\n   |not $ elem '.' s = \"\"\n   |elem '/' extension || elem '_' extension = \"\"\n   |otherwise = '.' : extension\n      where\n\t extension = reverse ( takeWhile ( /= '.' ) $ reverse s )\n", "target": "public class Test {\n \n    public static void main(String[] args) {\n        String[] filenames = { \"http:\n                               \"CharacterModel.3DS\",\n                               \".desktop\",\n                               \"document\",\n                               \"document.txt_backup\",\n                               \"/etc/pam.d/login\"\n        };\n\n        for (String filename : filenames) {\n            String ext = \"null\";\n            int idx = filename.lastIndexOf('.');\n            if (idx != -1) {\n                String tmp = filename.substring(idx);\n                if (tmp.matches(\"\\\\.[a-zA-Z0-9]+\")) {\n                    ext = tmp;\n                }\n            }\n            System.out.println(filename + \" -> \" + ext);\n        }\n    }\n}\n"}
{"id": 344112, "name": "Extract file extension", "source": "Translate Haskell to Java: module FileExtension\n   where\n\nmyextension :: String -> String\nmyextension s\n   |not $ elem '.' s = \"\"\n   |elem '/' extension || elem '_' extension = \"\"\n   |otherwise = '.' : extension\n      where\n\t extension = reverse ( takeWhile ( /= '.' ) $ reverse s )\n", "target": "public class Test {\n \n    public static void main(String[] args) {\n        String[] filenames = { \"http:\n                               \"CharacterModel.3DS\",\n                               \".desktop\",\n                               \"document\",\n                               \"document.txt_backup\",\n                               \"/etc/pam.d/login\"\n        };\n\n        for (String filename : filenames) {\n            String ext = \"null\";\n            int idx = filename.lastIndexOf('.');\n            if (idx != -1) {\n                String tmp = filename.substring(idx);\n                if (tmp.matches(\"\\\\.[a-zA-Z0-9]+\")) {\n                    ext = tmp;\n                }\n            }\n            System.out.println(filename + \" -> \" + ext);\n        }\n    }\n}\n"}
{"id": 344113, "name": "Solve the no connection puzzle", "source": "Translate Haskell to Java: import Data.List (permutations)\n\nsolution :: [Int]\nsolution@(a : b : c : d : e : f : g : h : _) =\n  head $\n    filter isSolution (permutations [1 .. 8])\n  where\n    isSolution :: [Int] -> Bool\n    isSolution (a : b : c : d : e : f : g : h : _) =\n      all ((> 1) . abs) $\n        zipWith\n          (-)\n          [a, c, g, e, a, c, g, e, b, d, h, f, b, d, h, f]\n          [d, d, d, d, c, g, e, a, e, e, e, e, d, h, f, b]\n\nmain :: IO ()\nmain =\n  (putStrLn . unlines) $\n    unlines\n      ( zipWith\n          (\\x y -> x : (\" = \" <> show y))\n          ['A' .. 'H']\n          solution\n      ) :\n    ( rightShift . unwords . fmap show\n        <$> [[], [a, b], [c, d, e, f], [g, h]]\n    )\n  where\n    rightShift s\n      | length s > 3 = s\n      | otherwise = \"  \" <> s\n", "target": "import static java.lang.Math.abs;\nimport java.util.*;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\n\npublic class NoConnection {\n\n    \n    static int[][] links = {\n        {2, 3, 4}, \n        {3, 4, 5}, \n        {2, 4},    \n        {5},       \n        {2, 3, 4}, \n        {3, 4, 5}, \n    };\n\n    static int[] pegs = new int[8];\n\n    public static void main(String[] args) {\n\n        List<Integer> vals = range(1, 9).mapToObj(i -> i).collect(toList());\n        do {\n            Collections.shuffle(vals);\n            for (int i = 0; i < pegs.length; i++)\n                pegs[i] = vals.get(i);\n\n        } while (!solved());\n\n        printResult();\n    }\n\n    static boolean solved() {\n        for (int i = 0; i < links.length; i++)\n            for (int peg : links[i])\n                if (abs(pegs[i] - peg) == 1)\n                    return false;\n        return true;\n    }\n\n    static void printResult() {\n        System.out.printf(\"  %s %s%n\", pegs[0], pegs[1]);\n        System.out.printf(\"%s %s %s %s%n\", pegs[2], pegs[3], pegs[4], pegs[5]);\n        System.out.printf(\"  %s %s%n\", pegs[6], pegs[7]);\n    }\n}\n"}
{"id": 344114, "name": "Permutation test", "source": "Translate Haskell to Java: binomial n m = (f !! n) `div` (f !! m) `div` (f !! (n - m))\n\twhere f = scanl (*) 1 [1..]\n\npermtest treat ctrl = (fromIntegral less) / (fromIntegral total) * 100\n\twhere\n\ttotal = binomial (length avail) (length treat)\n\tless  = combos (sum treat) (length treat) avail\n\tavail = ctrl ++ treat\n\tcombos total n a@(x:xs)\n\t\t| total < 0\t= binomial (length a) n\n\t\t| n == 0\t= 0\n\t\t| n > length a\t= 0\n\t\t| n == length a = fromEnum (total < sum a)\n\t\t| otherwise\t= combos (total - x) (n - 1) xs\n\t\t\t\t+ combos total n xs\n\nmain =\tlet\tr = permtest\n\t\t\t[85, 88, 75, 66, 25, 29, 83, 39, 97]\n\t\t\t[68, 41, 10, 49, 16, 65, 32, 92, 28, 98]\n\tin do\tputStr \">\u00a0: \"; print r\n\t\tputStr \"<=: \"; print $ 100 - r\n", "target": "public class PermutationTest {\n    private static final int[] data = new int[]{\n        85, 88, 75, 66, 25, 29, 83, 39, 97,\n        68, 41, 10, 49, 16, 65, 32, 92, 28, 98\n    };\n\n    private static int pick(int at, int remain, int accu, int treat) {\n        if (remain == 0) return (accu > treat) ? 1 : 0;\n        return pick(at - 1, remain - 1, accu + data[at - 1], treat)\n            + ((at > remain) ? pick(at - 1, remain, accu, treat) : 0);\n    }\n\n    public static void main(String[] args) {\n        int treat = 0;\n        double total = 1.0;\n        for (int i = 0; i <= 8; ++i) {\n            treat += data[i];\n        }\n        for (int i = 19; i >= 11; --i) {\n            total *= i;\n        }\n        for (int i = 9; i >= 1; --i) {\n            total /= i;\n        }\n        int gt = pick(19, 9, 0, treat);\n        int le = (int) (total - gt);\n        System.out.printf(\"<=\u00a0: %f%%  %d\\n\", 100.0 * le / total, le);\n        System.out.printf(\" >\u00a0: %f%%  %d\\n\", 100.0 * gt / total, gt);\n    }\n}\n"}
{"id": 344115, "name": "Abbreviations, simple", "source": "Translate Haskell to Java: import Data.List (find, isPrefixOf)\nimport Data.Char (isDigit, toUpper)\nimport Data.Maybe (maybe)\n\nwithExpansions :: [(String, Int)] -> String -> String\nwithExpansions tbl s = unwords $ expanded tbl <$> words s\n\nexpanded :: [(String, Int)] -> String -> String\nexpanded tbl k = maybe \"*error\" fst (expand k)\n  where\n    expand [] = Just ([], 0)\n    expand s =\n      let u = toUpper <$> s\n          lng = length s\n      in find (\\(w, n) -> lng >= n && isPrefixOf u w) tbl\n\ncmdsFromString :: String -> [(String, Int)]\ncmdsFromString s =\n  let go w@(x:_) (xs, n)\n        | isDigit x = (xs, read w :: Int)\n        | otherwise = ((toUpper <$> w, n) : xs, 0)\n  in fst $ foldr go ([], 0) (words s)\n\n\ntable :: [(String, Int)]\ntable =\n  cmdsFromString\n    \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1 \\\n    \\Schange Cinsert 2  Clast 3 compress 4 copy 2 count 3 Coverlay 3 \\\n    \\cursor 3  delete 3 Cdelete 2  down 1  duplicate 3 xEdit 1 expand 3 \\\n    \\extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 \\\n    \\forward 2  get  help 1 hexType 4 input 1 powerInput 3  join 1 \\\n    \\split 2 spltJOIN load locate 1 Clocate 2 lowerCase 3 upperCase 3 \\\n    \\Lprefix 2  macro  merge 2 modify 3 move 2 msg  next 1 overlay 1 \\\n    \\parse preserve 4 purge 3 put putD query 1 quit read recover 3 \\\n    \\refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 \\\n    \\rgtLEFT right 2 left 2  save  set  shift 2  si  sort  sos stack 3 \\\n    \\status 4 top  transfer 3  type 1  up 1\"\n\nmain :: IO ()\nmain = do\n  let unAbbrev = withExpansions table\n  print $\n    unAbbrev\n      \"riG   rePEAT copies  put mo   rest    types   fup.    6      poweRin\"\n  print $ unAbbrev \"\"\n", "target": "import java.util.*;\n\npublic class Abbreviations {\n    public static void main(String[] args) {\n        CommandList commands = new CommandList(commandTable);\n        String input = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\";\n        System.out.println(\" input: \" + input);\n        System.out.println(\"output: \" + test(commands, input));\n    }\n\n    private static String test(CommandList commands, String input) {\n        StringBuilder output = new StringBuilder();\n        Scanner scanner = new Scanner(input);\n        while (scanner.hasNext()) {\n            String word = scanner.next();\n            if (output.length() > 0)\n                output.append(' ');\n            Command cmd = commands.findCommand(word);\n            if (cmd != null)\n                output.append(cmd.cmd);\n            else\n                output.append(\"*error*\");\n        }\n        return output.toString();\n    }\n\n    private static String commandTable =\n        \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 \" +\n        \"compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate \" +\n        \"3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 \" +\n        \"forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load \" +\n        \"locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 \" +\n        \"msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 \" +\n        \"refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left \" +\n        \"2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\";\n\n    private static class Command {\n        private Command(String cmd, int minLength) {\n             this.cmd = cmd;\n             this.minLength = minLength;\n        }\n        private boolean match(String str) {\n            int olen = str.length();\n            return olen >= minLength && olen <= cmd.length()\n                && cmd.regionMatches(true, 0, str, 0, olen);\n        }\n        private String cmd;\n        private int minLength;\n    }\n\n    private static Integer parseInteger(String word) {\n        try {\n            return Integer.valueOf(word);\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n    }\n\n    private static class CommandList {\n        private CommandList(String table) {\n            Scanner scanner = new Scanner(table);\n            List<String> words = new ArrayList<>();\n            while (scanner.hasNext()) {\n                String word = scanner.next();\n                words.add(word.toUpperCase());\n            }\n            for (int i = 0, n = words.size(); i < n; ++i) {\n                String word = words.get(i);\n                \n                \n                \n                int len = word.length();\n                if (i + 1 < n) {\n                    Integer number = parseInteger(words.get(i + 1));\n                    if (number != null) {\n                        len = number.intValue();\n                        ++i;\n                    }\n                }\n                commands.add(new Command(word, len));\n            }\n        }\n        private Command findCommand(String word) {\n            for (Command command : commands) {\n                if (command.match(word))\n                    return command;\n            }\n            return null;\n        }\n        private List<Command> commands = new ArrayList<>();\n    }\n}\n"}
{"id": 344116, "name": "Abbreviations, simple", "source": "Translate Haskell to Java: import Data.List (find, isPrefixOf)\nimport Data.Char (isDigit, toUpper)\nimport Data.Maybe (maybe)\n\nwithExpansions :: [(String, Int)] -> String -> String\nwithExpansions tbl s = unwords $ expanded tbl <$> words s\n\nexpanded :: [(String, Int)] -> String -> String\nexpanded tbl k = maybe \"*error\" fst (expand k)\n  where\n    expand [] = Just ([], 0)\n    expand s =\n      let u = toUpper <$> s\n          lng = length s\n      in find (\\(w, n) -> lng >= n && isPrefixOf u w) tbl\n\ncmdsFromString :: String -> [(String, Int)]\ncmdsFromString s =\n  let go w@(x:_) (xs, n)\n        | isDigit x = (xs, read w :: Int)\n        | otherwise = ((toUpper <$> w, n) : xs, 0)\n  in fst $ foldr go ([], 0) (words s)\n\n\ntable :: [(String, Int)]\ntable =\n  cmdsFromString\n    \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1 \\\n    \\Schange Cinsert 2  Clast 3 compress 4 copy 2 count 3 Coverlay 3 \\\n    \\cursor 3  delete 3 Cdelete 2  down 1  duplicate 3 xEdit 1 expand 3 \\\n    \\extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 \\\n    \\forward 2  get  help 1 hexType 4 input 1 powerInput 3  join 1 \\\n    \\split 2 spltJOIN load locate 1 Clocate 2 lowerCase 3 upperCase 3 \\\n    \\Lprefix 2  macro  merge 2 modify 3 move 2 msg  next 1 overlay 1 \\\n    \\parse preserve 4 purge 3 put putD query 1 quit read recover 3 \\\n    \\refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 \\\n    \\rgtLEFT right 2 left 2  save  set  shift 2  si  sort  sos stack 3 \\\n    \\status 4 top  transfer 3  type 1  up 1\"\n\nmain :: IO ()\nmain = do\n  let unAbbrev = withExpansions table\n  print $\n    unAbbrev\n      \"riG   rePEAT copies  put mo   rest    types   fup.    6      poweRin\"\n  print $ unAbbrev \"\"\n", "target": "import java.util.*;\n\npublic class Abbreviations {\n    public static void main(String[] args) {\n        CommandList commands = new CommandList(commandTable);\n        String input = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\";\n        System.out.println(\" input: \" + input);\n        System.out.println(\"output: \" + test(commands, input));\n    }\n\n    private static String test(CommandList commands, String input) {\n        StringBuilder output = new StringBuilder();\n        Scanner scanner = new Scanner(input);\n        while (scanner.hasNext()) {\n            String word = scanner.next();\n            if (output.length() > 0)\n                output.append(' ');\n            Command cmd = commands.findCommand(word);\n            if (cmd != null)\n                output.append(cmd.cmd);\n            else\n                output.append(\"*error*\");\n        }\n        return output.toString();\n    }\n\n    private static String commandTable =\n        \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 \" +\n        \"compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate \" +\n        \"3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 \" +\n        \"forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load \" +\n        \"locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 \" +\n        \"msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 \" +\n        \"refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left \" +\n        \"2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\";\n\n    private static class Command {\n        private Command(String cmd, int minLength) {\n             this.cmd = cmd;\n             this.minLength = minLength;\n        }\n        private boolean match(String str) {\n            int olen = str.length();\n            return olen >= minLength && olen <= cmd.length()\n                && cmd.regionMatches(true, 0, str, 0, olen);\n        }\n        private String cmd;\n        private int minLength;\n    }\n\n    private static Integer parseInteger(String word) {\n        try {\n            return Integer.valueOf(word);\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n    }\n\n    private static class CommandList {\n        private CommandList(String table) {\n            Scanner scanner = new Scanner(table);\n            List<String> words = new ArrayList<>();\n            while (scanner.hasNext()) {\n                String word = scanner.next();\n                words.add(word.toUpperCase());\n            }\n            for (int i = 0, n = words.size(); i < n; ++i) {\n                String word = words.get(i);\n                \n                \n                \n                int len = word.length();\n                if (i + 1 < n) {\n                    Integer number = parseInteger(words.get(i + 1));\n                    if (number != null) {\n                        len = number.intValue();\n                        ++i;\n                    }\n                }\n                commands.add(new Command(word, len));\n            }\n        }\n        private Command findCommand(String word) {\n            for (Command command : commands) {\n                if (command.match(word))\n                    return command;\n            }\n            return null;\n        }\n        private List<Command> commands = new ArrayList<>();\n    }\n}\n"}
{"id": 344117, "name": "String comparison", "source": "Translate Haskell to Java: > \"abc\" == \"abc\"\nTrue\n> \"abc\" /= \"abc\"\nFalse\n> \"abc\" <= \"abcd\"\nTrue\n> \"abc\" <= \"abC\"\nFalse\n> \"HELLOWORLD\" == \"HelloWorld\"\nFalse\n> :m +Data.Char\n> map toLower \"ABC\"\n\"abc\"\n> map toLower \"HELLOWORLD\" == map toLower \"HelloWorld\"\nTrue\n", "target": "public class Compare\n{\n\t\n    \n    public static void compare (String A, String B)\n    {\n        if (A.equals(B))\n            System.debug(A + ' and  ' + B + ' are lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not lexically equal.');\n\n        if (A.equalsIgnoreCase(B))\n            System.debug(A + ' and  ' + B + ' are case-insensitive lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not case-insensitive lexically equal.');\n \n        if (A.compareTo(B) < 0)\n            System.debug(A + ' is lexically before ' + B);\n        else if (A.compareTo(B) > 0)\n            System.debug(A + ' is lexically after ' + B);\n \n        if (A.compareTo(B) >= 0)\n            System.debug(A + ' is not lexically before ' + B);\n        if (A.compareTo(B) <= 0)\n            System.debug(A + ' is not lexically after ' + B);\n \n        System.debug('The lexical relationship is: ' + A.compareTo(B));\n    }\n}\n"}
{"id": 344118, "name": "Entropy_Narcissist", "source": "Translate Haskell to Java: import qualified Data.ByteString as BS\nimport Data.List\nimport System.Environment\n\n(>>>) = flip (.)\n\nmain = getArgs >>= head >>> BS.readFile >>= BS.unpack >>> entropy >>> print\n          \nentropy = sort >>> group >>> map genericLength >>> normalize >>> map lg >>> sum\n  where lg c = -c * logBase 2 c\n        normalize c = let sc = sum c in map (/ sc) c\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class EntropyNarcissist {\n\n    private static final String FILE_NAME = \"src/EntropyNarcissist.java\";\n    \n    public static void main(String[] args) {\n        System.out.printf(\"Entropy of file \\\"%s\\\" =\u00a0%.12f.%n\", FILE_NAME, getEntropy(FILE_NAME));\n    }\n    \n    private static double getEntropy(String fileName) {\n        Map<Character,Integer> characterCount = new HashMap<>();\n        int length = 0;\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));) {        \n            int c = 0;\n            while ( (c = reader.read()) != -1 ) {\n                characterCount.merge((char) c, 1, (v1, v2) -> v1 + v2);\n                length++;\n            }\n        }\n        catch ( IOException e ) {\n            throw new RuntimeException(e);\n        }\n        \n        double entropy = 0;\n        for ( char key : characterCount.keySet() ) {\n            double fraction = (double) characterCount.get(key) / length;\n            entropy -= fraction * Math.log(fraction);\n        }\n\n        return entropy / Math.log(2);\n    }\n\n}\n"}
{"id": 344119, "name": "Entropy_Narcissist", "source": "Translate Haskell to Java: import qualified Data.ByteString as BS\nimport Data.List\nimport System.Environment\n\n(>>>) = flip (.)\n\nmain = getArgs >>= head >>> BS.readFile >>= BS.unpack >>> entropy >>> print\n          \nentropy = sort >>> group >>> map genericLength >>> normalize >>> map lg >>> sum\n  where lg c = -c * logBase 2 c\n        normalize c = let sc = sum c in map (/ sc) c\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class EntropyNarcissist {\n\n    private static final String FILE_NAME = \"src/EntropyNarcissist.java\";\n    \n    public static void main(String[] args) {\n        System.out.printf(\"Entropy of file \\\"%s\\\" =\u00a0%.12f.%n\", FILE_NAME, getEntropy(FILE_NAME));\n    }\n    \n    private static double getEntropy(String fileName) {\n        Map<Character,Integer> characterCount = new HashMap<>();\n        int length = 0;\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));) {        \n            int c = 0;\n            while ( (c = reader.read()) != -1 ) {\n                characterCount.merge((char) c, 1, (v1, v2) -> v1 + v2);\n                length++;\n            }\n        }\n        catch ( IOException e ) {\n            throw new RuntimeException(e);\n        }\n        \n        double entropy = 0;\n        for ( char key : characterCount.keySet() ) {\n            double fraction = (double) characterCount.get(key) / length;\n            entropy -= fraction * Math.log(fraction);\n        }\n\n        return entropy / Math.log(2);\n    }\n\n}\n"}
{"id": 344120, "name": "Verify distribution uniformity_Naive", "source": "Translate Haskell to Java: import System.Random\nimport Data.List\nimport Control.Monad\nimport Control.Arrow\n\ndistribCheck :: IO Int -> Int -> Int -> IO [(Int,(Int,Bool))]\ndistribCheck f n d = do\n  nrs <- replicateM n f\n  let group  = takeWhile (not.null) $ unfoldr (Just. (partition =<< (==). head)) nrs\n      avg    = (fromIntegral n) / fromIntegral (length group)\n      ul     = round $ (100 + fromIntegral d)/100 * avg\n      ll     = round $ (100 - fromIntegral d)/100 * avg\n  return $ map (head &&& (id &&& liftM2 (&&) (>ll)(<ul)).length) group\n", "target": "import static java.lang.Math.abs;\nimport java.util.*;\nimport java.util.function.IntSupplier;\n\npublic class Test {\n\n    static void distCheck(IntSupplier f, int nRepeats, double delta) {\n        Map<Integer, Integer> counts = new HashMap<>();\n\n        for (int i = 0; i < nRepeats; i++)\n            counts.compute(f.getAsInt(), (k, v) -> v == null ? 1 : v + 1);\n\n        double target = nRepeats / (double) counts.size();\n        int deltaCount = (int) (delta / 100.0 * target);\n\n        counts.forEach((k, v) -> {\n            if (abs(target - v) >= deltaCount)\n                System.out.printf(\"distribution potentially skewed \"\n                        + \"for '%s': '%d'%n\", k, v);\n        });\n\n        counts.keySet().stream().sorted().forEach(k\n                -> System.out.printf(\"%d %d%n\", k, counts.get(k)));\n    }\n\n    public static void main(String[] a) {\n        distCheck(() -> (int) (Math.random() * 5) + 1, 1_000_000, 1);\n    }\n}\n"}
{"id": 344121, "name": "Use another language to call a function", "source": "Translate Haskell to Java: \n\nmodule Called where\n\nimport Foreign\nimport Foreign.C.String (CString, withCStringLen)\nimport Foreign.C.Types\n\n\n\n\n\nquery_hs ::  CString -> Ptr CSize -> IO CInt\nquery_hs ptrBuff ptrSize = withCStringLen \"Here I am\"\n               (\\(str, len) -> do\n                   buffSize <- peek ptrSize\n                   if sizeOf str > (fromIntegral buffSize)\n                     then do\n                       poke ptrSize 0\n                       return 0\n                     else do\n                       poke ptrSize (fromIntegral len)\n                       copyArray ptrBuff str len\n                       return 1)\n\nforeign export ccall query_hs :: CString -> Ptr CSize -> IO CInt\n", "target": "\npublic class Query {\n    public static boolean call(byte[] data, int[] length)\n\tthrows java.io.UnsupportedEncodingException\n    {\n\tString message = \"Here am I\";\n\tbyte[] mb = message.getBytes(\"utf-8\");\n\tif (length[0] < mb.length)\n\t    return false;\n\tlength[0] = mb.length;\n\tSystem.arraycopy(mb, 0, data, 0, mb.length);\n\treturn true;\n    }\n}\n"}
{"id": 344122, "name": "Bioinformatics_Sequence mutation", "source": "Translate Haskell to Java: import Data.List       (group, sort)\nimport Data.List.Split (chunksOf)\nimport System.Random   (Random, randomR, random, newStdGen, randoms, getStdRandom)\nimport Text.Printf     (PrintfArg(..), fmtChar, fmtPrecision, formatString, IsChar(..), printf)\n\ndata Mutation = Swap | Delete | Insert deriving (Show, Eq, Ord, Enum, Bounded)\ndata DNABase = A | C | G | T deriving (Show, Read, Eq, Ord, Enum, Bounded)\ntype DNASequence = [DNABase]\n\ndata Result = Swapped Mutation Int (DNABase, DNABase)\n            | InsertDeleted Mutation Int DNABase\n\ninstance Random DNABase where\n  randomR (a, b) g = case randomR (fromEnum a, fromEnum b) g of (x, y) -> (toEnum x, y)\n  random = randomR (minBound, maxBound)\n\ninstance Random Mutation where\n  randomR (a, b) g = case randomR (fromEnum a, fromEnum b) g of (x, y) -> (toEnum x, y)\n  random = randomR (minBound, maxBound)\n\ninstance PrintfArg DNABase where\n  formatArg x fmt = formatString (show x) (fmt { fmtChar = 's', fmtPrecision = Nothing })\n\ninstance PrintfArg Mutation where\n  formatArg x fmt = formatString (show x) (fmt { fmtChar = 's', fmtPrecision = Nothing })\n\ninstance IsChar DNABase where\n  toChar = head . show\n  fromChar = read . pure\n\nchunkedDNASequence :: DNASequence -> [(Int, [DNABase])]\nchunkedDNASequence = zip [50,100..] . chunksOf 50\n\nbaseCounts :: DNASequence -> [(DNABase, Int)]\nbaseCounts = fmap ((,) . head <*> length) . group . sort\n\nnewSequence :: Int -> IO DNASequence\nnewSequence n = take n . randoms <$> newStdGen\n\nmutateSequence :: DNASequence -> IO (Result, DNASequence)\nmutateSequence [] = fail \"empty dna sequence\"\nmutateSequence ds = randomMutation >>= mutate ds\n  where\n    randomMutation = head . randoms <$> newStdGen\n    mutate xs m = do\n      i <- randomIndex (length xs)\n      case m of\n        Swap   -> randomDNA >>= \\d -> pure (Swapped Swap i (xs !! pred i, d), swapElement i d xs)\n        Insert -> randomDNA >>= \\d -> pure (InsertDeleted Insert i d, insertElement i d xs)\n        Delete -> pure (InsertDeleted Delete i (xs !! pred i), dropElement i xs)\n      where\n        dropElement i xs = take (pred i) xs <> drop i xs\n        insertElement i e xs = take i xs <> [e] <> drop i xs\n        swapElement i a xs = take (pred i) xs <> [a] <> drop i xs\n        randomIndex n = getStdRandom (randomR (1, n))\n        randomDNA = head . randoms <$> newStdGen\n\nmutate :: Int -> DNASequence -> IO DNASequence\nmutate 0 s = pure s\nmutate n s = do\n  (r, ms) <- mutateSequence s\n  case r of\n    Swapped m i (a, b)  -> printf \"%6s @\u00a0%-3d\u00a0: %s -> %s \\n\" m i a b\n    InsertDeleted m i a -> printf \"%6s @\u00a0%-3d\u00a0: %s\\n\" m i a\n  mutate (pred n) ms\n\nmain :: IO ()\nmain = do\n  ds <- newSequence 200\n  putStrLn \"\\nInitial Sequence:\" >> showSequence ds\n  putStrLn \"\\nBase Counts:\" >> showBaseCounts ds\n  showSumBaseCounts ds\n  ms <- mutate 10 ds\n  putStrLn \"\\nMutated Sequence:\" >> showSequence ms\n  putStrLn \"\\nBase Counts:\" >> showBaseCounts ms\n  showSumBaseCounts ms\n  where\n    showSequence   = mapM_ (uncurry (printf \"%3d: %s\\n\")) . chunkedDNASequence\n    showBaseCounts = mapM_ (uncurry (printf \"%s: %3d\\n\")) . baseCounts\n    showSumBaseCounts xs = putStrLn (replicate 6 '-') >> printf \"\u03a3: %d\\n\\n\" (length xs)\n", "target": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class SequenceMutation {\n    public static void main(String[] args) {\n        SequenceMutation sm = new SequenceMutation();\n        sm.setWeight(OP_CHANGE, 3);\n        String sequence = sm.generateSequence(250);\n        System.out.println(\"Initial sequence:\");\n        printSequence(sequence);\n        int count = 10;\n        for (int i = 0; i < count; ++i)\n            sequence = sm.mutateSequence(sequence);\n        System.out.println(\"After \" + count + \" mutations:\");\n        printSequence(sequence);\n    }\n\n    public SequenceMutation() {\n        totalWeight_ = OP_COUNT;\n        Arrays.fill(operationWeight_, 1);\n    }\n\n    public String generateSequence(int length) {\n        char[] ch = new char[length];\n        for (int i = 0; i < length; ++i)\n            ch[i] = getRandomBase();\n        return new String(ch);\n    }\n\n    public void setWeight(int operation, int weight) {\n        totalWeight_ -= operationWeight_[operation];\n        operationWeight_[operation] = weight;\n        totalWeight_ += weight;\n    }\n\n    public String mutateSequence(String sequence) {\n        char[] ch = sequence.toCharArray();\n        int pos = random_.nextInt(ch.length);\n        int operation = getRandomOperation();\n        if (operation == OP_CHANGE) {\n            char b = getRandomBase();\n            System.out.println(\"Change base at position \" + pos + \" from \"\n                               + ch[pos] + \" to \" + b);\n            ch[pos] = b;\n        } else if (operation == OP_ERASE) {\n            System.out.println(\"Erase base \" + ch[pos] + \" at position \" + pos);\n            char[] newCh = new char[ch.length - 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos + 1, newCh, pos, ch.length - pos - 1);\n            ch = newCh;\n        } else if (operation == OP_INSERT) {\n            char b = getRandomBase();\n            System.out.println(\"Insert base \" + b + \" at position \" + pos);\n            char[] newCh = new char[ch.length + 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos, newCh, pos + 1, ch.length - pos);\n            newCh[pos] = b;\n            ch = newCh;\n        }\n        return new String(ch);\n    }\n\n    public static void printSequence(String sequence) {\n        int[] count = new int[BASES.length];\n        for (int i = 0, n = sequence.length(); i < n; ++i) {\n            if (i % 50 == 0) {\n                if (i != 0)\n                    System.out.println();\n                System.out.printf(\"%3d: \", i);\n            }\n            char ch = sequence.charAt(i);\n            System.out.print(ch);\n            for (int j = 0; j < BASES.length; ++j) {\n                if (BASES[j] == ch) {\n                    ++count[j];\n                    break;\n                }\n            }\n        }\n        System.out.println();\n        System.out.println(\"Base counts:\");\n        int total = 0;\n        for (int j = 0; j < BASES.length; ++j) {\n            total += count[j];\n            System.out.print(BASES[j] + \": \" + count[j] + \", \");\n        }\n        System.out.println(\"Total: \" + total);\n    }\n\n    private char getRandomBase() {\n        return BASES[random_.nextInt(BASES.length)];\n    }\n\n    private int getRandomOperation() {\n        int n = random_.nextInt(totalWeight_), op = 0;\n        for (int weight = 0; op < OP_COUNT; ++op) {\n            weight += operationWeight_[op];\n            if (n < weight)\n                break;\n        }\n        return op;\n    }\n\n    private final Random random_ = new Random();\n    private int[] operationWeight_ = new int[OP_COUNT];\n    private int totalWeight_ = 0;\n\n    private static final int OP_CHANGE = 0;\n    private static final int OP_ERASE = 1;\n    private static final int OP_INSERT = 2;\n    private static final int OP_COUNT = 3;\n    private static final char[] BASES = {'A', 'C', 'G', 'T'};\n}\n"}
{"id": 344123, "name": "Bioinformatics_Sequence mutation", "source": "Translate Haskell to Java: import Data.List       (group, sort)\nimport Data.List.Split (chunksOf)\nimport System.Random   (Random, randomR, random, newStdGen, randoms, getStdRandom)\nimport Text.Printf     (PrintfArg(..), fmtChar, fmtPrecision, formatString, IsChar(..), printf)\n\ndata Mutation = Swap | Delete | Insert deriving (Show, Eq, Ord, Enum, Bounded)\ndata DNABase = A | C | G | T deriving (Show, Read, Eq, Ord, Enum, Bounded)\ntype DNASequence = [DNABase]\n\ndata Result = Swapped Mutation Int (DNABase, DNABase)\n            | InsertDeleted Mutation Int DNABase\n\ninstance Random DNABase where\n  randomR (a, b) g = case randomR (fromEnum a, fromEnum b) g of (x, y) -> (toEnum x, y)\n  random = randomR (minBound, maxBound)\n\ninstance Random Mutation where\n  randomR (a, b) g = case randomR (fromEnum a, fromEnum b) g of (x, y) -> (toEnum x, y)\n  random = randomR (minBound, maxBound)\n\ninstance PrintfArg DNABase where\n  formatArg x fmt = formatString (show x) (fmt { fmtChar = 's', fmtPrecision = Nothing })\n\ninstance PrintfArg Mutation where\n  formatArg x fmt = formatString (show x) (fmt { fmtChar = 's', fmtPrecision = Nothing })\n\ninstance IsChar DNABase where\n  toChar = head . show\n  fromChar = read . pure\n\nchunkedDNASequence :: DNASequence -> [(Int, [DNABase])]\nchunkedDNASequence = zip [50,100..] . chunksOf 50\n\nbaseCounts :: DNASequence -> [(DNABase, Int)]\nbaseCounts = fmap ((,) . head <*> length) . group . sort\n\nnewSequence :: Int -> IO DNASequence\nnewSequence n = take n . randoms <$> newStdGen\n\nmutateSequence :: DNASequence -> IO (Result, DNASequence)\nmutateSequence [] = fail \"empty dna sequence\"\nmutateSequence ds = randomMutation >>= mutate ds\n  where\n    randomMutation = head . randoms <$> newStdGen\n    mutate xs m = do\n      i <- randomIndex (length xs)\n      case m of\n        Swap   -> randomDNA >>= \\d -> pure (Swapped Swap i (xs !! pred i, d), swapElement i d xs)\n        Insert -> randomDNA >>= \\d -> pure (InsertDeleted Insert i d, insertElement i d xs)\n        Delete -> pure (InsertDeleted Delete i (xs !! pred i), dropElement i xs)\n      where\n        dropElement i xs = take (pred i) xs <> drop i xs\n        insertElement i e xs = take i xs <> [e] <> drop i xs\n        swapElement i a xs = take (pred i) xs <> [a] <> drop i xs\n        randomIndex n = getStdRandom (randomR (1, n))\n        randomDNA = head . randoms <$> newStdGen\n\nmutate :: Int -> DNASequence -> IO DNASequence\nmutate 0 s = pure s\nmutate n s = do\n  (r, ms) <- mutateSequence s\n  case r of\n    Swapped m i (a, b)  -> printf \"%6s @\u00a0%-3d\u00a0: %s -> %s \\n\" m i a b\n    InsertDeleted m i a -> printf \"%6s @\u00a0%-3d\u00a0: %s\\n\" m i a\n  mutate (pred n) ms\n\nmain :: IO ()\nmain = do\n  ds <- newSequence 200\n  putStrLn \"\\nInitial Sequence:\" >> showSequence ds\n  putStrLn \"\\nBase Counts:\" >> showBaseCounts ds\n  showSumBaseCounts ds\n  ms <- mutate 10 ds\n  putStrLn \"\\nMutated Sequence:\" >> showSequence ms\n  putStrLn \"\\nBase Counts:\" >> showBaseCounts ms\n  showSumBaseCounts ms\n  where\n    showSequence   = mapM_ (uncurry (printf \"%3d: %s\\n\")) . chunkedDNASequence\n    showBaseCounts = mapM_ (uncurry (printf \"%s: %3d\\n\")) . baseCounts\n    showSumBaseCounts xs = putStrLn (replicate 6 '-') >> printf \"\u03a3: %d\\n\\n\" (length xs)\n", "target": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class SequenceMutation {\n    public static void main(String[] args) {\n        SequenceMutation sm = new SequenceMutation();\n        sm.setWeight(OP_CHANGE, 3);\n        String sequence = sm.generateSequence(250);\n        System.out.println(\"Initial sequence:\");\n        printSequence(sequence);\n        int count = 10;\n        for (int i = 0; i < count; ++i)\n            sequence = sm.mutateSequence(sequence);\n        System.out.println(\"After \" + count + \" mutations:\");\n        printSequence(sequence);\n    }\n\n    public SequenceMutation() {\n        totalWeight_ = OP_COUNT;\n        Arrays.fill(operationWeight_, 1);\n    }\n\n    public String generateSequence(int length) {\n        char[] ch = new char[length];\n        for (int i = 0; i < length; ++i)\n            ch[i] = getRandomBase();\n        return new String(ch);\n    }\n\n    public void setWeight(int operation, int weight) {\n        totalWeight_ -= operationWeight_[operation];\n        operationWeight_[operation] = weight;\n        totalWeight_ += weight;\n    }\n\n    public String mutateSequence(String sequence) {\n        char[] ch = sequence.toCharArray();\n        int pos = random_.nextInt(ch.length);\n        int operation = getRandomOperation();\n        if (operation == OP_CHANGE) {\n            char b = getRandomBase();\n            System.out.println(\"Change base at position \" + pos + \" from \"\n                               + ch[pos] + \" to \" + b);\n            ch[pos] = b;\n        } else if (operation == OP_ERASE) {\n            System.out.println(\"Erase base \" + ch[pos] + \" at position \" + pos);\n            char[] newCh = new char[ch.length - 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos + 1, newCh, pos, ch.length - pos - 1);\n            ch = newCh;\n        } else if (operation == OP_INSERT) {\n            char b = getRandomBase();\n            System.out.println(\"Insert base \" + b + \" at position \" + pos);\n            char[] newCh = new char[ch.length + 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos, newCh, pos + 1, ch.length - pos);\n            newCh[pos] = b;\n            ch = newCh;\n        }\n        return new String(ch);\n    }\n\n    public static void printSequence(String sequence) {\n        int[] count = new int[BASES.length];\n        for (int i = 0, n = sequence.length(); i < n; ++i) {\n            if (i % 50 == 0) {\n                if (i != 0)\n                    System.out.println();\n                System.out.printf(\"%3d: \", i);\n            }\n            char ch = sequence.charAt(i);\n            System.out.print(ch);\n            for (int j = 0; j < BASES.length; ++j) {\n                if (BASES[j] == ch) {\n                    ++count[j];\n                    break;\n                }\n            }\n        }\n        System.out.println();\n        System.out.println(\"Base counts:\");\n        int total = 0;\n        for (int j = 0; j < BASES.length; ++j) {\n            total += count[j];\n            System.out.print(BASES[j] + \": \" + count[j] + \", \");\n        }\n        System.out.println(\"Total: \" + total);\n    }\n\n    private char getRandomBase() {\n        return BASES[random_.nextInt(BASES.length)];\n    }\n\n    private int getRandomOperation() {\n        int n = random_.nextInt(totalWeight_), op = 0;\n        for (int weight = 0; op < OP_COUNT; ++op) {\n            weight += operationWeight_[op];\n            if (n < weight)\n                break;\n        }\n        return op;\n    }\n\n    private final Random random_ = new Random();\n    private int[] operationWeight_ = new int[OP_COUNT];\n    private int totalWeight_ = 0;\n\n    private static final int OP_CHANGE = 0;\n    private static final int OP_ERASE = 1;\n    private static final int OP_INSERT = 2;\n    private static final int OP_COUNT = 3;\n    private static final char[] BASES = {'A', 'C', 'G', 'T'};\n}\n"}
{"id": 344124, "name": "Colour bars_Display", "source": "Translate Haskell to Java: #!/usr/bin/env stack\n\n\nimport Graphics.Vty\n\ncolorBars :: Int -> [(Int, Attr)] -> Image\ncolorBars h bars = horizCat $ map colorBar bars\n  where colorBar (w, attr) = charFill attr ' ' w h\n\nbarWidths :: Int -> Int -> [Int]\nbarWidths nBars totalWidth = map barWidth [0..nBars-1]\n  where fracWidth = fromIntegral totalWidth / fromIntegral nBars\n        barWidth n =\n          let n' = fromIntegral n :: Double\n          in floor ((n' + 1) * fracWidth) - floor (n' * fracWidth)\n\nbarImage :: Int -> Int -> Image\nbarImage w h = colorBars h $ zip (barWidths nBars w) attrs\n  where attrs = map color2attr colors\n        nBars = length colors\n        colors = [black, brightRed, brightGreen, brightMagenta, brightCyan, brightYellow, brightWhite]\n        color2attr c = Attr Default Default (SetTo c)\n\nmain = do\n    cfg <- standardIOConfig\n    vty <- mkVty cfg\n    let output = outputIface vty\n    bounds <- displayBounds output\n    let showBars (w,h) = do\n          let img = barImage w h\n              pic = picForImage img\n          update vty pic\n          e <- nextEvent vty\n          case e of\n            EvResize w' h' -> showBars (w',h')\n            _ -> return ()\n    showBars bounds\n    shutdown vty\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\n\npublic class ColorFrame extends JFrame {\n\tpublic ColorFrame(int width, int height) {\n\t\tthis.setDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tthis.setSize(width, height);\n\t\tthis.setVisible(true);\n\t}\n\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tColor[] colors = { Color.black, Color.red, Color.green, Color.blue,\n\t\t\t\tColor.pink, Color.CYAN, Color.yellow, Color.white };\n\n\t\tfor (int i = 0; i < colors.length; i++) {\n\t\t\tg.setColor(colors[i]);\n\t\t\tg.fillRect(this.getWidth() / colors.length * i, 0, this.getWidth()\n\t\t\t\t\t/ colors.length, this.getHeight());\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tnew ColorFrame(200, 200);\n\t}\n}\n"}
{"id": 344125, "name": "Colour bars_Display", "source": "Translate Haskell to Java: #!/usr/bin/env stack\n\n\nimport Graphics.Vty\n\ncolorBars :: Int -> [(Int, Attr)] -> Image\ncolorBars h bars = horizCat $ map colorBar bars\n  where colorBar (w, attr) = charFill attr ' ' w h\n\nbarWidths :: Int -> Int -> [Int]\nbarWidths nBars totalWidth = map barWidth [0..nBars-1]\n  where fracWidth = fromIntegral totalWidth / fromIntegral nBars\n        barWidth n =\n          let n' = fromIntegral n :: Double\n          in floor ((n' + 1) * fracWidth) - floor (n' * fracWidth)\n\nbarImage :: Int -> Int -> Image\nbarImage w h = colorBars h $ zip (barWidths nBars w) attrs\n  where attrs = map color2attr colors\n        nBars = length colors\n        colors = [black, brightRed, brightGreen, brightMagenta, brightCyan, brightYellow, brightWhite]\n        color2attr c = Attr Default Default (SetTo c)\n\nmain = do\n    cfg <- standardIOConfig\n    vty <- mkVty cfg\n    let output = outputIface vty\n    bounds <- displayBounds output\n    let showBars (w,h) = do\n          let img = barImage w h\n              pic = picForImage img\n          update vty pic\n          e <- nextEvent vty\n          case e of\n            EvResize w' h' -> showBars (w',h')\n            _ -> return ()\n    showBars bounds\n    shutdown vty\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\n\npublic class ColorFrame extends JFrame {\n\tpublic ColorFrame(int width, int height) {\n\t\tthis.setDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tthis.setSize(width, height);\n\t\tthis.setVisible(true);\n\t}\n\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tColor[] colors = { Color.black, Color.red, Color.green, Color.blue,\n\t\t\t\tColor.pink, Color.CYAN, Color.yellow, Color.white };\n\n\t\tfor (int i = 0; i < colors.length; i++) {\n\t\t\tg.setColor(colors[i]);\n\t\t\tg.fillRect(this.getWidth() / colors.length * i, 0, this.getWidth()\n\t\t\t\t\t/ colors.length, this.getHeight());\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tnew ColorFrame(200, 200);\n\t}\n}\n"}
{"id": 344126, "name": "Ray-casting algorithm", "source": "Translate Haskell to Java: import Data.Ratio\n\ntype Point = (Rational, Rational)\ntype Polygon = [Point]\ndata Line = Sloped {lineSlope, lineYIntercept :: Rational} |\n            Vert {lineXIntercept :: Rational}\n\npolygonSides :: Polygon -> [(Point, Point)]\npolygonSides poly@(p1 : ps) = zip poly $ ps ++ [p1]\n\nintersects :: Point -> Line -> Bool\n\nintersects (px, _)  (Vert xint)  = px <= xint\nintersects (px, py) (Sloped m b) | m < 0     = py <= m * px + b\n                                 | otherwise = py >= m * px + b\n\nonLine :: Point -> Line -> Bool\n\nonLine (px, _)  (Vert xint)  = px == xint\nonLine (px, py) (Sloped m b) = py == m * px + b\n\ncarrier :: (Point, Point) -> Line\n\ncarrier ((ax, ay), (bx, by)) | ax == bx  = Vert ax\n                             | otherwise = Sloped slope yint\n  where slope = (ay - by) / (ax - bx)\n        yint = ay - slope * ax\n\nbetween :: Ord a => a -> a -> a -> Bool\nbetween x a b | a > b     = b <= x && x <= a\n              | otherwise = a <= x && x <= b\n\ninPolygon :: Point -> Polygon -> Bool\ninPolygon p@(px, py) = f 0 . polygonSides\n  where f n []                             = odd n\n        f n (side : sides) | far           = f n       sides\n                           | onSegment     = True\n                           | rayIntersects = f (n + 1) sides\n                           | otherwise     = f n       sides\n          where far = not $ between py ay by\n                onSegment | ay == by  = between px ax bx\n                          | otherwise = p `onLine` line\n                rayIntersects =\n                    intersects p line &&\n                    (py /= ay || by < py) &&\n                    (py /= by || ay < py)\n                ((ax, ay), (bx, by)) = side\n                line = carrier side\n", "target": "import static java.lang.Math.*;\n\npublic class RayCasting {\n\n    static boolean intersects(int[] A, int[] B, double[] P) {\n        if (A[1] > B[1])\n            return intersects(B, A, P);\n\n        if (P[1] == A[1] || P[1] == B[1])\n            P[1] += 0.0001;\n\n        if (P[1] > B[1] || P[1] < A[1] || P[0] >= max(A[0], B[0]))\n            return false;\n\n        if (P[0] < min(A[0], B[0]))\n            return true;\n\n        double red = (P[1] - A[1]) / (double) (P[0] - A[0]);\n        double blue = (B[1] - A[1]) / (double) (B[0] - A[0]);\n        return red >= blue;\n    }\n\n    static boolean contains(int[][] shape, double[] pnt) {\n        boolean inside = false;\n        int len = shape.length;\n        for (int i = 0; i < len; i++) {\n            if (intersects(shape[i], shape[(i + 1) % len], pnt))\n                inside = !inside;\n        }\n        return inside;\n    }\n\n    public static void main(String[] a) {\n        double[][] testPoints = {{10, 10}, {10, 16}, {-20, 10}, {0, 10},\n        {20, 10}, {16, 10}, {20, 20}};\n\n        for (int[][] shape : shapes) {\n            for (double[] pnt : testPoints)\n                System.out.printf(\"%7s \", contains(shape, pnt));\n            System.out.println();\n        }\n    }\n\n    final static int[][] square = {{0, 0}, {20, 0}, {20, 20}, {0, 20}};\n\n    final static int[][] squareHole = {{0, 0}, {20, 0}, {20, 20}, {0, 20},\n    {5, 5}, {15, 5}, {15, 15}, {5, 15}};\n\n    final static int[][] strange = {{0, 0}, {5, 5}, {0, 20}, {5, 15}, {15, 15},\n    {20, 20}, {20, 0}};\n\n    final static int[][] hexagon = {{6, 0}, {14, 0}, {20, 10}, {14, 20},\n    {6, 20}, {0, 10}};\n\n    final static int[][][] shapes = {square, squareHole, strange, hexagon};\n}\n"}
{"id": 344127, "name": "Dining philosophers", "source": "Translate Haskell to Java: module Philosophers where\n\nimport Control.Monad\nimport Control.Concurrent\nimport Control.Concurrent.STM\nimport System.Random\n\n\n\n\n\n\n\ntype Fork = TMVar Int\n\nnewFork :: Int -> IO Fork\nnewFork i = newTMVarIO i\n\n\ntakeFork :: Fork -> STM Int\ntakeFork fork = takeTMVar fork\n\nreleaseFork :: Int -> Fork -> STM ()\nreleaseFork i fork = putTMVar fork i\n\ntype Name = String\n\nrunPhilosopher :: Name -> (Fork, Fork) -> IO ()\nrunPhilosopher name (left, right) = forever $ do\n  putStrLn (name ++ \" is hungry.\")\n  \n  \n  \n  (leftNum, rightNum) <- atomically $ do\n    leftNum <- takeFork left\n    rightNum <- takeFork right\n    return (leftNum, rightNum)\n  \n  putStrLn (name ++ \" got forks \" ++ show leftNum ++ \" and \" ++ show rightNum ++ \" and is now eating.\")\n  delay <- randomRIO (1,10)\n  threadDelay (delay * 1000000) \n  putStrLn (name ++ \" is done eating. Going back to thinking.\")\n\n  atomically $ do\n    releaseFork leftNum left\n    releaseFork rightNum right\n    \n  delay <- randomRIO (1, 10)\n  threadDelay (delay * 1000000)\n\nphilosophers :: [String]\nphilosophers = [\"Aristotle\", \"Kant\", \"Spinoza\", \"Marx\", \"Russel\"]\n\nmain = do\n  forks <- mapM newFork [1..5]\n  let namedPhilosophers  = map runPhilosopher philosophers\n      forkPairs          = zip forks (tail . cycle $ forks)\n      philosophersWithForks = zipWith ($) namedPhilosophers forkPairs\n  \n  putStrLn \"Running the philosophers. Press enter to quit.\"\n  \n  mapM_ forkIO philosophersWithForks\n  \n  \n  getLine\n", "target": "package diningphilosophers;\n\nimport java.util.ArrayList;\nimport java.util.Random;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nenum PhilosopherState { Get, Eat, Pon }\n\nclass Fork {\n    public static final int ON_TABLE = -1;\n    static int instances = 0;\n    public int id;\n    public AtomicInteger holder = new AtomicInteger(ON_TABLE);\n\n    Fork() { id = instances++; }\n}\n\nclass Philosopher implements Runnable {\n    static final int maxWaitMs = 100;                          \n    static AtomicInteger token = new AtomicInteger(0);\n    static int instances = 0;\n    static Random rand = new Random();\n    AtomicBoolean end = new AtomicBoolean(false);\n    int id;\n    PhilosopherState state = PhilosopherState.Get;\n    Fork left;\n    Fork right;\n    int timesEaten = 0;\n\n    Philosopher() {\n        id = instances++;\n        left = Main.forks.get(id);\n        right = Main.forks.get((id+1)%Main.philosopherCount);\n    }\n\n    void sleep() { try { Thread.sleep(rand.nextInt(maxWaitMs)); }\n        catch (InterruptedException ex) {} }\n\n    void waitForFork(Fork fork) {\n        do {\n            if (fork.holder.get() == Fork.ON_TABLE) {\n                fork.holder.set(id);                \n                return;\n            } else {                                \n                sleep();                            \n            }\n        } while (true);\n    }\n\n    public void run() {\n        do {\n            if (state == PhilosopherState.Pon) {    \n                state = PhilosopherState.Get;       \n            } else { \n                if (token.get() == id) {            \n                    waitForFork(left);\n                    waitForFork(right);             \n                    token.set((id+2)% Main.philosopherCount);\n                    state = PhilosopherState.Eat;\n                    timesEaten++;\n                    sleep();                        \n                    left.holder.set(Fork.ON_TABLE);\n                    right.holder.set(Fork.ON_TABLE);\n                    state = PhilosopherState.Pon;   \n                    sleep();\n                } else {                    \n                    sleep();\n                }\n            }\n        } while (!end.get());\n    }\n}\n\npublic class Main {\n    static final int philosopherCount = 5; \n    static final int runSeconds = 15;\n    static ArrayList<Fork> forks = new ArrayList<Fork>();\n    static ArrayList<Philosopher> philosophers = new ArrayList<Philosopher>();\n\n    public static void main(String[] args) {\n        for (int i = 0 ; i < philosopherCount ; i++) forks.add(new Fork());\n        for (int i = 0 ; i < philosopherCount ; i++)\n            philosophers.add(new Philosopher());\n        for (Philosopher p : philosophers) new Thread(p).start();\n        long endTime = System.currentTimeMillis() + (runSeconds * 1000);\n\n        do {                                                    \n            StringBuilder sb = new StringBuilder(\"|\");\n\n            for (Philosopher p : philosophers) {\n                sb.append(p.state.toString());\n                sb.append(\"|\");            \n            }                              \n\n            sb.append(\"     |\");\n\n            for (Fork f : forks) {\n                int holder = f.holder.get();\n                sb.append(holder==-1?\"   \":String.format(\"P%02d\",holder));\n                sb.append(\"|\");\n            }\n            \n            System.out.println(sb.toString());\n            try {Thread.sleep(1000);} catch (Exception ex) {}\n        } while (System.currentTimeMillis() < endTime);\n\n        for (Philosopher p : philosophers) p.end.set(true);\n        for (Philosopher p : philosophers)\n            System.out.printf(\"P%02d: ate\u00a0%,d times,\u00a0%,d/sec\\n\",\n                p.id, p.timesEaten, p.timesEaten/runSeconds);\n    }\n}\n"}
{"id": 344128, "name": "24 game", "source": "Translate Haskell to Java: import Data.List (sort)\nimport Data.Char (isDigit)\nimport Data.Maybe (fromJust)\nimport Control.Monad (foldM)\nimport System.Random (randomRs, getStdGen)\nimport System.IO (hSetBuffering, stdout, BufferMode(NoBuffering))\n\nmain = do\n  hSetBuffering stdout NoBuffering\n  mapM_\n    putStrLn\n    [ \"THE 24 GAME\\n\"\n    , \"Given four digits in the range 1 to 9\"\n    , \"Use the +, -, *, and / operators in reverse polish notation\"\n    , \"To show how to make an answer of 24.\\n\"\n    ]\n  digits <- fmap (sort . take 4 . randomRs (1, 9)) getStdGen :: IO [Int]\n  putStrLn (\"Your digits: \" ++ unwords (fmap show digits))\n  guessLoop digits\n  where\n    guessLoop digits =\n      putStr \"Your expression: \" >> fmap (processGuess digits . words) getLine >>=\n      either (\\m -> putStrLn m >> guessLoop digits) putStrLn\n\nprocessGuess _ [] = Right \"\"\nprocessGuess digits xs\n  | not matches = Left \"Wrong digits used\"\n  where\n    matches = digits == (sort . fmap read $ filter (all isDigit) xs)\nprocessGuess digits xs = calc xs >>= check\n  where\n    check 24 = Right \"Correct\"\n    check x = Left (show (fromRational (x :: Rational)) ++ \" is wrong\")\n\n\ncalc xs =\n  foldM simplify [] xs >>=\n  \\ns ->\n     (case ns of\n        [n] -> Right n\n        _ -> Left \"Too few operators\")\n\nsimplify (a:b:ns) s\n  | isOp s = Right ((fromJust $ lookup s ops) b a : ns)\nsimplify _ s\n  | isOp s = Left (\"Too few values before \" ++ s)\nsimplify ns s\n  | all isDigit s = Right (fromIntegral (read s) : ns)\nsimplify _ s = Left (\"Unrecognized symbol: \" ++ s)\n\nisOp v = elem v $ fmap fst ops\n\nops = [(\"+\", (+)), (\"-\", (-)), (\"*\", (*)), (\"/\", (/))]\n", "target": "import java.util.*;\n\npublic class Game24 {\n    static Random r = new Random();\n\n    public static void main(String[] args) {\n\n        int[] digits = randomDigits();\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Make 24 using these digits: \");\n        System.out.println(Arrays.toString(digits));\n        System.out.print(\"> \");\n\n        Stack<Float> s = new Stack<>();\n        long total = 0;\n        for (char c : in.nextLine().toCharArray()) {\n            if ('0' <= c && c <= '9') {\n                int d = c - '0';\n                total += (1 << (d * 5));\n                s.push((float) d);\n            } else if (\"+/-*\".indexOf(c) != -1) {\n                s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        }\n        if (tallyDigits(digits) != total)\n            System.out.print(\"Not the same digits. \");\n        else if (Math.abs(24 - s.peek()) < 0.001F)\n            System.out.println(\"Correct!\");\n        else\n            System.out.print(\"Not correct.\");\n    }\n\n    static float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    static long tallyDigits(int[] a) {\n        long total = 0;\n        for (int i = 0; i < 4; i++)\n            total += (1 << (a[i] * 5));\n        return total;\n    }\n\n    static int[] randomDigits() {        \n        int[] result = new int[4];\n        for (int i = 0; i < 4; i++)\n            result[i] = r.nextInt(9) + 1;\n        return result;\n    }\n}\n"}
{"id": 344129, "name": "24 game", "source": "Translate Haskell to Java: import Data.List (sort)\nimport Data.Char (isDigit)\nimport Data.Maybe (fromJust)\nimport Control.Monad (foldM)\nimport System.Random (randomRs, getStdGen)\nimport System.IO (hSetBuffering, stdout, BufferMode(NoBuffering))\n\nmain = do\n  hSetBuffering stdout NoBuffering\n  mapM_\n    putStrLn\n    [ \"THE 24 GAME\\n\"\n    , \"Given four digits in the range 1 to 9\"\n    , \"Use the +, -, *, and / operators in reverse polish notation\"\n    , \"To show how to make an answer of 24.\\n\"\n    ]\n  digits <- fmap (sort . take 4 . randomRs (1, 9)) getStdGen :: IO [Int]\n  putStrLn (\"Your digits: \" ++ unwords (fmap show digits))\n  guessLoop digits\n  where\n    guessLoop digits =\n      putStr \"Your expression: \" >> fmap (processGuess digits . words) getLine >>=\n      either (\\m -> putStrLn m >> guessLoop digits) putStrLn\n\nprocessGuess _ [] = Right \"\"\nprocessGuess digits xs\n  | not matches = Left \"Wrong digits used\"\n  where\n    matches = digits == (sort . fmap read $ filter (all isDigit) xs)\nprocessGuess digits xs = calc xs >>= check\n  where\n    check 24 = Right \"Correct\"\n    check x = Left (show (fromRational (x :: Rational)) ++ \" is wrong\")\n\n\ncalc xs =\n  foldM simplify [] xs >>=\n  \\ns ->\n     (case ns of\n        [n] -> Right n\n        _ -> Left \"Too few operators\")\n\nsimplify (a:b:ns) s\n  | isOp s = Right ((fromJust $ lookup s ops) b a : ns)\nsimplify _ s\n  | isOp s = Left (\"Too few values before \" ++ s)\nsimplify ns s\n  | all isDigit s = Right (fromIntegral (read s) : ns)\nsimplify _ s = Left (\"Unrecognized symbol: \" ++ s)\n\nisOp v = elem v $ fmap fst ops\n\nops = [(\"+\", (+)), (\"-\", (-)), (\"*\", (*)), (\"/\", (/))]\n", "target": "import java.util.*;\n\npublic class Game24 {\n    static Random r = new Random();\n\n    public static void main(String[] args) {\n\n        int[] digits = randomDigits();\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Make 24 using these digits: \");\n        System.out.println(Arrays.toString(digits));\n        System.out.print(\"> \");\n\n        Stack<Float> s = new Stack<>();\n        long total = 0;\n        for (char c : in.nextLine().toCharArray()) {\n            if ('0' <= c && c <= '9') {\n                int d = c - '0';\n                total += (1 << (d * 5));\n                s.push((float) d);\n            } else if (\"+/-*\".indexOf(c) != -1) {\n                s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        }\n        if (tallyDigits(digits) != total)\n            System.out.print(\"Not the same digits. \");\n        else if (Math.abs(24 - s.peek()) < 0.001F)\n            System.out.println(\"Correct!\");\n        else\n            System.out.print(\"Not correct.\");\n    }\n\n    static float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    static long tallyDigits(int[] a) {\n        long total = 0;\n        for (int i = 0; i < 4; i++)\n            total += (1 << (a[i] * 5));\n        return total;\n    }\n\n    static int[] randomDigits() {        \n        int[] result = new int[4];\n        for (int i = 0; i < 4; i++)\n            result[i] = r.nextInt(9) + 1;\n        return result;\n    }\n}\n"}
{"id": 344130, "name": "Enforced immutability", "source": "Translate Haskell to Java: pi  = 3.14159\nmsg = \"Hello World\"\n", "target": "final int immutableInt = 4;\nint mutableInt = 4;\nmutableInt = 6; \nimmutableInt = 6; \n"}
{"id": 344131, "name": "Strange numbers", "source": "Translate Haskell to Java: import Data.List (intercalate)\nimport Data.List.Split (chunksOf)\n\n\n\nisStrange :: Int -> Bool\nisStrange n =\n  all\n    (\\(a, b) -> abs (a - b) `elem` [2, 3, 5, 7])\n    $ (zip <*> tail) (digits n)\n\ndigits :: Int -> [Int]\ndigits = fmap (read . return) . show\n\n\nmain =\n  let xs = filter isStrange [100 .. 500]\n   in (putStrLn . intercalate \"\\n\\n\")\n        [ \"Strange numbers found in range [100..500]\",\n          \"(total \" <> (show . length) xs <> \")\",\n          \"Full list:\",\n          unlines\n            (unwords <$> chunksOf 10 (show <$> xs))\n        ]\n", "target": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class StrangeNumbers {\n    private static List<Integer> digits(int n) {\n        var result = new LinkedList<Integer>();\n        while (n > 0) {\n            var rem = n % 10;\n            result.addFirst(rem);\n            n /= 10;\n        }\n        return result;\n    }\n\n    private static boolean isStrange(int n) {\n        BiPredicate<Integer, Integer> test = (a, b) -> {\n            var abs = Math.abs(a - b);\n            return abs == 2 || abs == 3 || abs == 5 || abs == 7;\n        };\n\n        var xs = digits(n);\n        for (int i = 1; i < xs.size(); i++) {\n            if (test.negate().test(xs.get(i - 1), xs.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        var xs = IntStream.rangeClosed(100, 500)\n            .filter(StrangeNumbers::isStrange)\n            .boxed()\n            .collect(Collectors.toList());\n\n        System.out.println(\"Strange numbers in range [100..500]\");\n        System.out.printf(\"(Total: %d)\\n\\n\", xs.size());\n\n        for (int i = 0; i < xs.size(); i++) {\n            Integer x = xs.get(i);\n            System.out.print(x);\n\n            if ((i + 1) % 10 == 0) {\n                System.out.println();\n            } else {\n                System.out.print(' ');\n            }\n        }\n    }\n}\n"}
{"id": 344132, "name": "Strange numbers", "source": "Translate Haskell to Java: import Data.List (intercalate)\nimport Data.List.Split (chunksOf)\n\n\n\nisStrange :: Int -> Bool\nisStrange n =\n  all\n    (\\(a, b) -> abs (a - b) `elem` [2, 3, 5, 7])\n    $ (zip <*> tail) (digits n)\n\ndigits :: Int -> [Int]\ndigits = fmap (read . return) . show\n\n\nmain =\n  let xs = filter isStrange [100 .. 500]\n   in (putStrLn . intercalate \"\\n\\n\")\n        [ \"Strange numbers found in range [100..500]\",\n          \"(total \" <> (show . length) xs <> \")\",\n          \"Full list:\",\n          unlines\n            (unwords <$> chunksOf 10 (show <$> xs))\n        ]\n", "target": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class StrangeNumbers {\n    private static List<Integer> digits(int n) {\n        var result = new LinkedList<Integer>();\n        while (n > 0) {\n            var rem = n % 10;\n            result.addFirst(rem);\n            n /= 10;\n        }\n        return result;\n    }\n\n    private static boolean isStrange(int n) {\n        BiPredicate<Integer, Integer> test = (a, b) -> {\n            var abs = Math.abs(a - b);\n            return abs == 2 || abs == 3 || abs == 5 || abs == 7;\n        };\n\n        var xs = digits(n);\n        for (int i = 1; i < xs.size(); i++) {\n            if (test.negate().test(xs.get(i - 1), xs.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        var xs = IntStream.rangeClosed(100, 500)\n            .filter(StrangeNumbers::isStrange)\n            .boxed()\n            .collect(Collectors.toList());\n\n        System.out.println(\"Strange numbers in range [100..500]\");\n        System.out.printf(\"(Total: %d)\\n\\n\", xs.size());\n\n        for (int i = 0; i < xs.size(); i++) {\n            Integer x = xs.get(i);\n            System.out.print(x);\n\n            if ((i + 1) % 10 == 0) {\n                System.out.println();\n            } else {\n                System.out.print(' ');\n            }\n        }\n    }\n}\n"}
{"id": 344133, "name": "Hofstadter Q sequence", "source": "Translate Haskell to Java: qSequence = tail qq where\n  qq = 0 : 1 : 1 : map g [3..] \n  g n = qq !! (n - qq !! (n-1)) + qq !! (n - qq !! (n-2))\n\n\n*Main> (take 10 qSequence, qSequence !! (1000-1))\n([1,1,2,3,3,4,5,5,6,6],502)\n(0.00 secs, 525044 bytes)\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HofQ {\n\tprivate static Map<Integer, Integer> q = new HashMap<Integer, Integer>(){{\n\t\tput(1, 1);\n\t\tput(2, 1);\n\t}};\n\t\n\tprivate static int[] nUses = new int[100001];\n\t\n\tpublic static int Q(int n){\n\t\tnUses[n]++;\n\t\tif(q.containsKey(n)){\n\t\t\treturn q.get(n);\n\t\t}\n\t\tint ans = Q(n - Q(n - 1)) + Q(n - Q(n - 2));\n\t\tq.put(n, ans);\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"Q(\" + i + \") = \" + Q(i));\n\t\t}\n\t\tint last = 6;\n\t\tint count = 0;\n\t\tfor(int i = 11; i <= 100000; i++){\n\t\t\tint curr = Q(i);\n\t\t\tif(curr < last) count++;\n\t\t\tlast = curr;\n\t\t\tif(i == 1000) System.out.println(\"Q(1000) = \" + curr);\n\t\t}\n\t\tSystem.out.println(\"Q(i) is less than Q(i-1) for i <= 100000 \" + count + \" times\");\n\t\t\n\t\t\n\t\tint maxUses = 0, maxN = 0;\n\t\tfor(int i = 1; i<nUses.length;i++){\n\t\t\tif(nUses[i] > maxUses){\n\t\t\t\tmaxUses = nUses[i];\n\t\t\t\tmaxN = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Q(\" + maxN + \") was called the most with \" + maxUses + \" calls\");\n\t}\n}\n"}
{"id": 344134, "name": "Hofstadter Q sequence", "source": "Translate Haskell to Java: qSequence = tail qq where\n  qq = 0 : 1 : 1 : map g [3..] \n  g n = qq !! (n - qq !! (n-1)) + qq !! (n - qq !! (n-2))\n\n\n*Main> (take 10 qSequence, qSequence !! (1000-1))\n([1,1,2,3,3,4,5,5,6,6],502)\n(0.00 secs, 525044 bytes)\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HofQ {\n\tprivate static Map<Integer, Integer> q = new HashMap<Integer, Integer>(){{\n\t\tput(1, 1);\n\t\tput(2, 1);\n\t}};\n\t\n\tprivate static int[] nUses = new int[100001];\n\t\n\tpublic static int Q(int n){\n\t\tnUses[n]++;\n\t\tif(q.containsKey(n)){\n\t\t\treturn q.get(n);\n\t\t}\n\t\tint ans = Q(n - Q(n - 1)) + Q(n - Q(n - 2));\n\t\tq.put(n, ans);\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"Q(\" + i + \") = \" + Q(i));\n\t\t}\n\t\tint last = 6;\n\t\tint count = 0;\n\t\tfor(int i = 11; i <= 100000; i++){\n\t\t\tint curr = Q(i);\n\t\t\tif(curr < last) count++;\n\t\t\tlast = curr;\n\t\t\tif(i == 1000) System.out.println(\"Q(1000) = \" + curr);\n\t\t}\n\t\tSystem.out.println(\"Q(i) is less than Q(i-1) for i <= 100000 \" + count + \" times\");\n\t\t\n\t\t\n\t\tint maxUses = 0, maxN = 0;\n\t\tfor(int i = 1; i<nUses.length;i++){\n\t\t\tif(nUses[i] > maxUses){\n\t\t\t\tmaxUses = nUses[i];\n\t\t\t\tmaxN = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Q(\" + maxN + \") was called the most with \" + maxUses + \" calls\");\n\t}\n}\n"}
{"id": 344135, "name": "Count occurrences of a substring", "source": "Translate Haskell to Java: import Data.Text hiding (length)\n\n\ncountSubStrs str sub = length $ breakOnAll (pack sub) (pack str)\n\nmain = do\n  print $ countSubStrs \"the three truths\" \"th\"\n  print $ countSubStrs \"ababababab\" \"abab\"\n", "target": "public class CountSubstring {\n\tpublic static int countSubstring(String subStr, String str){\n\t\treturn (str.length() - str.replace(subStr, \"\").length()) / subStr.length();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(countSubstring(\"th\", \"the three truths\"));\n\t\tSystem.out.println(countSubstring(\"abab\", \"ababababab\"));\n\t\tSystem.out.println(countSubstring(\"a*b\", \"abaabba*bbaba*bbab\"));\n\t}\n}\n"}
{"id": 344136, "name": "User input_Graphical", "source": "Translate Haskell to Java: import Graphics.UI.Gtk\nimport Control.Monad\n\nmain = do\n  initGUI\n\n  window <- windowNew\n  set window [windowTitle := \"Graphical user input\", containerBorderWidth := 10]\n\n  vb <- vBoxNew False 0\n  containerAdd window vb\n\n  hb1 <- hBoxNew False 0\n  boxPackStart vb hb1 PackNatural 0\n  hb2 <- hBoxNew False 0\n  boxPackStart vb hb2 PackNatural 0\n\n  lab1 <- labelNew (Just \"Enter number 75000\")\n  boxPackStart hb1 lab1 PackNatural 0\n  nrfield <- entryNew\n  entrySetText nrfield \"75000\"\n  boxPackStart hb1 nrfield PackNatural 5\n\n  strfield <- entryNew\n  boxPackEnd hb2 strfield PackNatural 5\n  lab2 <- labelNew (Just \"Enter a text\")\n  boxPackEnd hb2 lab2 PackNatural 0\n  \n  accbox    <- hBoxNew False 0\n  boxPackStart vb accbox PackNatural 5\n  im <- imageNewFromStock stockApply IconSizeButton\n  acceptButton <- buttonNewWithLabel \"Accept\"\n  buttonSetImage acceptButton im\n  boxPackStart accbox acceptButton PackRepel 0\n\n  txtstack <- statusbarNew\n  boxPackStart vb txtstack PackNatural 0\n  id <- statusbarGetContextId txtstack \"Line\"\n\n  widgetShowAll window\n\n  onEntryActivate nrfield (showStat nrfield txtstack id)\n  onEntryActivate strfield (showStat strfield txtstack id)\n    \n  onPressed acceptButton $ do\n    g <- entryGetText nrfield\n    if g==\"75000\" then\n      widgetDestroy window\n     else do\n       msgid <- statusbarPush txtstack id \"You didn't enter 75000. Try again\"\n       return ()\n  \n  onDestroy window mainQuit\n  mainGUI\n\nshowStat :: Entry -> Statusbar -> ContextId -> IO ()\nshowStat fld stk id = do\n    txt <- entryGetText fld\n    let mesg = \"You entered \\\"\" ++ txt ++ \"\\\"\"\n    msgid <- statusbarPush stk id mesg\n    return ()\n", "target": "import javax.swing.*;\n\npublic class GetInputSwing {\n    public static void main(String[] args) throws Exception {\n        int number = Integer.parseInt(\n                JOptionPane.showInputDialog (\"Enter an Integer\"));\n        String string = JOptionPane.showInputDialog (\"Enter a String\");\n    }\n}\n"}
{"id": 344137, "name": "Carmichael 3 strong pseudoprimes", "source": "Translate Haskell to Java: #!/usr/bin/runhaskell\n\nimport Data.Numbers.Primes\nimport Control.Monad (guard)\n\ncarmichaels = do\n  p <- takeWhile (<= 61) primes\n  h3 <- [2..(p-1)]\n  let g = h3 + p\n  d <- [1..(g-1)]\n  guard $ (g * (p - 1)) `mod` d == 0 && (-1 * p * p) `mod` h3 == d `mod` h3\n  let q = 1 + (((p - 1) * g) `div` d)\n  guard $ isPrime q\n  let r = 1 + ((p * q) `div` h3)\n  guard $ isPrime r && (q * r) `mod` (p - 1) == 1\n  return (p, q, r)\n\nmain = putStr $ unlines $ map show carmichaels\n", "target": "public class Test {\n\n    static int mod(int n, int m) {\n        return ((n % m) + m) % m;\n    }\n\n    static boolean isPrime(int n) {\n        if (n == 2 || n == 3)\n            return true;\n        else if (n < 2 || n % 2 == 0 || n % 3 == 0)\n            return false;\n        for (int div = 5, inc = 2; Math.pow(div, 2) <= n;\n                div += inc, inc = 6 - inc)\n            if (n % div == 0)\n                return false;\n        return true;\n    }\n\n    public static void main(String[] args) {\n        for (int p = 2; p < 62; p++) {\n            if (!isPrime(p))\n                continue;\n            for (int h3 = 2; h3 < p; h3++) {\n                int g = h3 + p;\n                for (int d = 1; d < g; d++) {\n                    if ((g * (p - 1)) % d != 0 || mod(-p * p, h3) != d % h3)\n                        continue;\n                    int q = 1 + (p - 1) * g / d;\n                    if (!isPrime(q))\n                        continue;\n                    int r = 1 + (p * q / h3);\n                    if (!isPrime(r) || (q * r) % (p - 1) != 1)\n                        continue;\n                    System.out.printf(\"%d x %d x %d%n\", p, q, r);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 344138, "name": "Pascal's triangle_Puzzle", "source": "Translate Haskell to Java: puzzle = [[\"151\"],[\"\",\"\"],[\"40\",\"\",\"\"],[\"\",\"\",\"\",\"\"],[\"X\",\"11\",\"Y\",\"4\",\"Z\"]]\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class PascalsTrianglePuzzle {\n\n    public static void main(String[] args) {\n        Matrix mat = new Matrix(Arrays.asList(1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d, 0d), \n                                Arrays.asList(0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 1d, -1d),\n                                Arrays.asList(0d, 0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, -1d),\n                                Arrays.asList(1d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, -1d, 0d, 1d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 0d, 0d, 1d, 1d, 0d, 0d, 0d));\n        List<Double> b = Arrays.asList(11d, 11d, 0d, 4d, 4d, 40d, 0d, 0d, 40d, 0d, 151d);\n        List<Double> solution = cramersRule(mat, b);\n        System.out.println(\"Solution = \" + cramersRule(mat, b));\n        System.out.printf(\"X =\u00a0%.2f%n\", solution.get(8));\n        System.out.printf(\"Y =\u00a0%.2f%n\", solution.get(9));\n        System.out.printf(\"Z =\u00a0%.2f%n\", solution.get(10));\n    }\n    \n    private static List<Double> cramersRule(Matrix matrix, List<Double> b) {\n        double denominator = matrix.determinant();\n        List<Double> result = new ArrayList<>();\n        for ( int i = 0 ; i < b.size() ; i++ ) {\n            result.add(matrix.replaceColumn(b, i).determinant() / denominator);\n        }\n        return result;\n    }\n        \n    private static class Matrix {\n        \n        private List<List<Double>> matrix;\n        \n        @Override\n        public String toString() {\n            return matrix.toString();\n        }\n        \n        @SafeVarargs\n        public Matrix(List<Double> ... lists) {\n            matrix = new ArrayList<>();\n            for ( List<Double> list : lists) {\n                matrix.add(list);\n            }\n        }\n        \n        public Matrix(List<List<Double>> mat) {\n            matrix = mat;\n        }\n        \n        public double determinant() {\n            if ( matrix.size() == 1 ) {\n                return get(0, 0);\n            }\n            if ( matrix.size() == 2 ) {\n                return get(0, 0) * get(1, 1) - get(0, 1) * get(1, 0);\n            }\n            double sum = 0;\n            double sign = 1;\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                sum += sign * get(0, i) * coFactor(0, i).determinant();\n                sign *= -1;\n            }\n            return sum;\n        }\n        \n        private Matrix coFactor(int row, int col) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                if ( i == row ) {\n                    continue;\n                }\n                List<Double> list = new ArrayList<>();\n                for ( int j = 0 ; j < matrix.size() ; j++ ) {\n                    if ( j == col ) {\n                        continue;\n                    }\n                    list.add(get(i, j));\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private Matrix replaceColumn(List<Double> b, int column) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int row = 0 ; row < matrix.size() ; row++ ) {\n                List<Double> list = new ArrayList<>();\n                for ( int col = 0 ; col < matrix.size() ; col++ ) {\n                    double value = get(row, col);\n                    if ( col == column ) {\n                        value = b.get(row);\n                    }\n                    list.add(value);\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private double get(int row, int col) {\n            return matrix.get(row).get(col);\n        }\n        \n    }\n\n}\n"}
{"id": 344139, "name": "Pascal's triangle_Puzzle", "source": "Translate Haskell to Java: puzzle = [[\"151\"],[\"\",\"\"],[\"40\",\"\",\"\"],[\"\",\"\",\"\",\"\"],[\"X\",\"11\",\"Y\",\"4\",\"Z\"]]\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class PascalsTrianglePuzzle {\n\n    public static void main(String[] args) {\n        Matrix mat = new Matrix(Arrays.asList(1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d, 0d), \n                                Arrays.asList(0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 1d, -1d),\n                                Arrays.asList(0d, 0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, -1d),\n                                Arrays.asList(1d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, -1d, 0d, 1d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 0d, 0d, 1d, 1d, 0d, 0d, 0d));\n        List<Double> b = Arrays.asList(11d, 11d, 0d, 4d, 4d, 40d, 0d, 0d, 40d, 0d, 151d);\n        List<Double> solution = cramersRule(mat, b);\n        System.out.println(\"Solution = \" + cramersRule(mat, b));\n        System.out.printf(\"X =\u00a0%.2f%n\", solution.get(8));\n        System.out.printf(\"Y =\u00a0%.2f%n\", solution.get(9));\n        System.out.printf(\"Z =\u00a0%.2f%n\", solution.get(10));\n    }\n    \n    private static List<Double> cramersRule(Matrix matrix, List<Double> b) {\n        double denominator = matrix.determinant();\n        List<Double> result = new ArrayList<>();\n        for ( int i = 0 ; i < b.size() ; i++ ) {\n            result.add(matrix.replaceColumn(b, i).determinant() / denominator);\n        }\n        return result;\n    }\n        \n    private static class Matrix {\n        \n        private List<List<Double>> matrix;\n        \n        @Override\n        public String toString() {\n            return matrix.toString();\n        }\n        \n        @SafeVarargs\n        public Matrix(List<Double> ... lists) {\n            matrix = new ArrayList<>();\n            for ( List<Double> list : lists) {\n                matrix.add(list);\n            }\n        }\n        \n        public Matrix(List<List<Double>> mat) {\n            matrix = mat;\n        }\n        \n        public double determinant() {\n            if ( matrix.size() == 1 ) {\n                return get(0, 0);\n            }\n            if ( matrix.size() == 2 ) {\n                return get(0, 0) * get(1, 1) - get(0, 1) * get(1, 0);\n            }\n            double sum = 0;\n            double sign = 1;\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                sum += sign * get(0, i) * coFactor(0, i).determinant();\n                sign *= -1;\n            }\n            return sum;\n        }\n        \n        private Matrix coFactor(int row, int col) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                if ( i == row ) {\n                    continue;\n                }\n                List<Double> list = new ArrayList<>();\n                for ( int j = 0 ; j < matrix.size() ; j++ ) {\n                    if ( j == col ) {\n                        continue;\n                    }\n                    list.add(get(i, j));\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private Matrix replaceColumn(List<Double> b, int column) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int row = 0 ; row < matrix.size() ; row++ ) {\n                List<Double> list = new ArrayList<>();\n                for ( int col = 0 ; col < matrix.size() ; col++ ) {\n                    double value = get(row, col);\n                    if ( col == column ) {\n                        value = b.get(row);\n                    }\n                    list.add(value);\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private double get(int row, int col) {\n            return matrix.get(row).get(col);\n        }\n        \n    }\n\n}\n"}
{"id": 344140, "name": "Fractal tree", "source": "Translate Haskell to Java: import Graphics.Gloss\n\ntype Model = [Picture -> Picture]\n       \nfractal :: Int -> Model -> Picture -> Picture\nfractal n model pict = pictures $ take n $ iterate (mconcat model) pict\n\ntree1 _ = fractal 10 branches $ Line [(0,0),(0,100)]\n  where branches = [ Translate 0 100 . Scale 0.75 0.75 . Rotate 30 \n                   , Translate 0 100 . Scale 0.5 0.5 . Rotate (-30) ]\n\nmain = animate (InWindow \"Tree\" (800, 800) (0, 0)) white $ tree1 . (* 60)\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\nimport javax.swing.JFrame;\n\npublic class FractalTree extends JFrame {\n\n    public FractalTree() {\n        super(\"Fractal Tree\");\n        setBounds(100, 100, 800, 600);\n        setResizable(false);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n    }\n\n    private void drawTree(Graphics g, int x1, int y1, double angle, int depth) {\n        if (depth == 0) return;\n        int x2 = x1 + (int) (Math.cos(Math.toRadians(angle)) * depth * 10.0);\n        int y2 = y1 + (int) (Math.sin(Math.toRadians(angle)) * depth * 10.0);\n        g.drawLine(x1, y1, x2, y2);\n        drawTree(g, x2, y2, angle - 20, depth - 1);\n        drawTree(g, x2, y2, angle + 20, depth - 1);\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.setColor(Color.BLACK);\n        drawTree(g, 400, 500, -90, 9);\n    }\n\n    public static void main(String[] args) {\n        new FractalTree().setVisible(true);\n    }\n}\n"}
{"id": 344141, "name": "Rock-paper-scissors", "source": "Translate Haskell to Java: import System.Random (randomRIO)\n\ndata Choice\n  = Rock\n  | Paper\n  | Scissors\n  deriving (Show, Eq)\n\nbeats :: Choice -> Choice -> Bool\nbeats Paper Rock = True\nbeats Scissors Paper = True\nbeats Rock Scissors = True\nbeats _ _ = False\n\ngenrps :: (Int, Int, Int) -> IO Choice\ngenrps (r, p, s) = rps <$> rand\n  where\n    rps x\n      | x <= s = Rock\n      | x <= s + r = Paper\n      | otherwise = Scissors\n    rand = randomRIO (1, r + p + s) :: IO Int\n\ngetrps :: IO Choice\ngetrps = rps <$> getLine\n  where\n    rps \"scissors\" = Scissors\n    rps \"rock\" = Rock\n    rps \"paper\" = Paper\n    rps _ = error \"invalid input\"\n\ngame :: (Int, Int, Int) -> IO a\ngame (r, p, s) = do\n  putStrLn \"rock, paper or scissors?\"\n  h <- getrps\n  c <- genrps (r, p, s)\n  putStrLn (\"Player: \" ++ show h ++ \" Computer: \" ++ show c)\n  putStrLn\n    (if beats h c\n       then \"player wins\\n\"\n       else if beats c h\n              then \"player loses\\n\"\n              else \"draw\\n\")\n  let rr =\n        if h == Rock\n          then r + 1\n          else r\n      pp =\n        if h == Paper\n          then p + 1\n          else p\n      ss =\n        if h == Scissors\n          then s + 1\n          else s\n  game (rr, pp, ss)\n\nmain :: IO a\nmain = game (1, 1, 1)\n", "target": "import java.util.Arrays;\nimport java.util.EnumMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Random;\n\npublic class RPS {\n\tpublic enum Item{\n\t\tROCK, PAPER, SCISSORS, ;\n\t\tpublic List<Item> losesToList;\n\t\tpublic boolean losesTo(Item other) {\n\t\t\treturn losesToList.contains(other);\n\t\t}\n\t\tstatic {\n\t\t\tSCISSORS.losesToList = Arrays.asList(ROCK);\n\t\t\tROCK.losesToList = Arrays.asList(PAPER);\n\t\t\tPAPER.losesToList = Arrays.asList(SCISSORS);\n\t\t\t\n                }\n\t}\n\t\n\tpublic final Map<Item, Integer> counts = new EnumMap<Item, Integer>(Item.class){{\n\t\tfor(Item item:Item.values())\n\t\t\tput(item, 1);\n\t}};\n\n\tprivate int totalThrows = Item.values().length;\n\n\tpublic static void main(String[] args){\n\t\tRPS rps = new RPS();\n\t\trps.run();\n\t}\n\n\tpublic void run() {\n\t\tScanner in = new Scanner(System.in);\n\t\tSystem.out.print(\"Make your choice: \");\n\t\twhile(in.hasNextLine()){\n\t\t\tItem aiChoice = getAIChoice();\n\t\t\tString input = in.nextLine();\n\t\t\tItem choice;\n\t\t\ttry{\n\t\t\t\tchoice = Item.valueOf(input.toUpperCase());\n\t\t\t}catch (IllegalArgumentException ex){\n\t\t\t\tSystem.out.println(\"Invalid choice\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcounts.put(choice, counts.get(choice) + 1);\n\t\t\ttotalThrows++;\n\t\t\tSystem.out.println(\"Computer chose: \" + aiChoice);\n\t\t\tif(aiChoice == choice){\n\t\t\t\tSystem.out.println(\"Tie!\");\n\t\t\t}else if(aiChoice.losesTo(choice)){\n\t\t\t\tSystem.out.println(\"You chose...wisely. You win!\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"You chose...poorly. You lose!\");\n\t\t\t}\n\t\t\tSystem.out.print(\"Make your choice: \");\n\t\t}\n\t}\n\n\tprivate static final Random rng = new Random();\n\tprivate Item getAIChoice() {\n\t\tint rand = rng.nextInt(totalThrows);\n\t\tfor(Map.Entry<Item, Integer> entry:counts.entrySet()){\n\t\t\tItem item = entry.getKey();\n\t\t\tint count = entry.getValue();\n\t\t\tif(rand < count){\n\t\t\t\tList<Item> losesTo = item.losesToList;\n\t\t\t\treturn losesTo.get(rng.nextInt(losesTo.size()));\n\t\t\t}\n\t\t\trand -= count;\n\t\t}\n\t\treturn null;\n\t}\n}\n"}
{"id": 344142, "name": "Benford's law", "source": "Translate Haskell to Java: import qualified Data.Map as M\nimport Data.Char (digitToInt)\n\nfstdigit :: Integer -> Int\nfstdigit = digitToInt . head . show\n\nn = 1000 :: Int\n\nfibs = 1 : 1 : zipWith (+) fibs (tail fibs)\n\nfibdata = map fstdigit $ take n fibs\n\nfreqs = M.fromListWith (+) $ zip fibdata (repeat 1)\n\ntab :: [(Int, Double, Double)]\ntab =\n  [ ( d\n    , fromIntegral (M.findWithDefault 0 d freqs) / fromIntegral n\n    , logBase 10.0 $ 1 + 1 / fromIntegral d)\n  | d <- [1 .. 9] ]\n\nmain = print tab\n", "target": "import java.math.BigInteger;\nimport java.util.Locale;\n\npublic class BenfordsLaw {\n\n    private static BigInteger[] generateFibonacci(int n) {\n        BigInteger[] fib = new BigInteger[n];\n        fib[0] = BigInteger.ONE;\n        fib[1] = BigInteger.ONE;\n        for (int i = 2; i < fib.length; i++) {\n            fib[i] = fib[i - 2].add(fib[i - 1]);\n        }\n        return fib;\n    }\n\n    public static void main(String[] args) {\n        BigInteger[] numbers = generateFibonacci(1000);\n\n        int[] firstDigits = new int[10];\n        for (BigInteger number : numbers) {\n            firstDigits[Integer.valueOf(number.toString().substring(0, 1))]++;\n        }\n\n        for (int i = 1; i < firstDigits.length; i++) {\n            System.out.printf(Locale.ROOT, \"%d %10.6f %10.6f%n\",\n                    i, (double) firstDigits[i] / numbers.length, Math.log10(1.0 + 1.0 / i));\n        }\n    }\n}\n"}
{"id": 344143, "name": "Benford's law", "source": "Translate Haskell to Java: import qualified Data.Map as M\nimport Data.Char (digitToInt)\n\nfstdigit :: Integer -> Int\nfstdigit = digitToInt . head . show\n\nn = 1000 :: Int\n\nfibs = 1 : 1 : zipWith (+) fibs (tail fibs)\n\nfibdata = map fstdigit $ take n fibs\n\nfreqs = M.fromListWith (+) $ zip fibdata (repeat 1)\n\ntab :: [(Int, Double, Double)]\ntab =\n  [ ( d\n    , fromIntegral (M.findWithDefault 0 d freqs) / fromIntegral n\n    , logBase 10.0 $ 1 + 1 / fromIntegral d)\n  | d <- [1 .. 9] ]\n\nmain = print tab\n", "target": "import java.math.BigInteger;\nimport java.util.Locale;\n\npublic class BenfordsLaw {\n\n    private static BigInteger[] generateFibonacci(int n) {\n        BigInteger[] fib = new BigInteger[n];\n        fib[0] = BigInteger.ONE;\n        fib[1] = BigInteger.ONE;\n        for (int i = 2; i < fib.length; i++) {\n            fib[i] = fib[i - 2].add(fib[i - 1]);\n        }\n        return fib;\n    }\n\n    public static void main(String[] args) {\n        BigInteger[] numbers = generateFibonacci(1000);\n\n        int[] firstDigits = new int[10];\n        for (BigInteger number : numbers) {\n            firstDigits[Integer.valueOf(number.toString().substring(0, 1))]++;\n        }\n\n        for (int i = 1; i < firstDigits.length; i++) {\n            System.out.printf(Locale.ROOT, \"%d %10.6f %10.6f%n\",\n                    i, (double) firstDigits[i] / numbers.length, Math.log10(1.0 + 1.0 / i));\n        }\n    }\n}\n"}
{"id": 344144, "name": "Hickerson series of almost integers", "source": "Translate Haskell to Java: import Data.Number.CReal \n\nimport qualified Data.Number.CReal as C\n\nhickerson :: Int -> C.CReal\nhickerson n = (fromIntegral $ product [1..n]) / (2 * (log 2 ^ (n + 1)))\n\ncharAfter :: Char -> String -> Char\ncharAfter ch string = ( dropWhile (/= ch) string ) !! 1\n\nisAlmostInteger :: C.CReal -> Bool\nisAlmostInteger = (`elem` ['0', '9']) . charAfter '.' . show\n\ncheckHickerson :: Int -> String\ncheckHickerson n  = show $ (n, hickerson n, isAlmostInteger $ hickerson n)\n\nmain :: IO ()\nmain = mapM_ putStrLn $ map checkHickerson [1..18]\n", "target": "import java.math.*;\n\npublic class Hickerson {\n\n    final static String LN2 = \"0.693147180559945309417232121458\";\n\n    public static void main(String[] args) {\n        for (int n = 1; n <= 17; n++)\n            System.out.printf(\"%2s is almost integer: %s%n\", n, almostInteger(n));\n    }\n\n    static boolean almostInteger(int n) {\n        BigDecimal a = new BigDecimal(LN2);\n        a = a.pow(n + 1).multiply(BigDecimal.valueOf(2));\n\n        long f = n;\n        while (--n > 1)\n            f *= n;\n\n        BigDecimal b = new BigDecimal(f);\n        b = b.divide(a, MathContext.DECIMAL128);\n\n        BigInteger c = b.movePointRight(1).toBigInteger().mod(BigInteger.TEN);\n\n        return c.toString().matches(\"0|9\");\n    }\n}\n"}
{"id": 344145, "name": "Hickerson series of almost integers", "source": "Translate Haskell to Java: import Data.Number.CReal \n\nimport qualified Data.Number.CReal as C\n\nhickerson :: Int -> C.CReal\nhickerson n = (fromIntegral $ product [1..n]) / (2 * (log 2 ^ (n + 1)))\n\ncharAfter :: Char -> String -> Char\ncharAfter ch string = ( dropWhile (/= ch) string ) !! 1\n\nisAlmostInteger :: C.CReal -> Bool\nisAlmostInteger = (`elem` ['0', '9']) . charAfter '.' . show\n\ncheckHickerson :: Int -> String\ncheckHickerson n  = show $ (n, hickerson n, isAlmostInteger $ hickerson n)\n\nmain :: IO ()\nmain = mapM_ putStrLn $ map checkHickerson [1..18]\n", "target": "import java.math.*;\n\npublic class Hickerson {\n\n    final static String LN2 = \"0.693147180559945309417232121458\";\n\n    public static void main(String[] args) {\n        for (int n = 1; n <= 17; n++)\n            System.out.printf(\"%2s is almost integer: %s%n\", n, almostInteger(n));\n    }\n\n    static boolean almostInteger(int n) {\n        BigDecimal a = new BigDecimal(LN2);\n        a = a.pow(n + 1).multiply(BigDecimal.valueOf(2));\n\n        long f = n;\n        while (--n > 1)\n            f *= n;\n\n        BigDecimal b = new BigDecimal(f);\n        b = b.divide(a, MathContext.DECIMAL128);\n\n        BigInteger c = b.movePointRight(1).toBigInteger().mod(BigInteger.TEN);\n\n        return c.toString().matches(\"0|9\");\n    }\n}\n"}
{"id": 344146, "name": "Read a configuration file", "source": "Translate Haskell to Java: import Data.Char\nimport Data.List\nimport Data.List.Split\n\nmain :: IO ()\nmain = readFile \"config\" >>= (print . parseConfig)\n\nparseConfig :: String -> Config\nparseConfig = foldr addConfigValue defaultConfig . clean . lines\n    where clean = filter (not . flip any [\"#\", \";\", \"\", \" \"] . (==) . take 1)\n          \naddConfigValue :: String -> Config -> Config\naddConfigValue raw config = case key of\n    \"fullname\"       -> config {fullName      = values}\n    \"favouritefruit\" -> config {favoriteFruit = values}\n    \"needspeeling\"   -> config {needsPeeling  = True}\n    \"seedsremoved\"   -> config {seedsRemoved  = True}\n    \"otherfamily\"    -> config {otherFamily   = splitOn \",\" values}\n    _                -> config\n    where (k, vs) = span (/= ' ') raw\n          key = map toLower k\n          values = tail vs\n\ndata Config = Config\n    { fullName      :: String\n    , favoriteFruit :: String\n    , needsPeeling  :: Bool\n    , seedsRemoved  :: Bool\n    , otherFamily   :: [String]\n    } deriving (Show)\n\ndefaultConfig :: Config\ndefaultConfig = Config \"\" \"\" False False []\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ConfigReader {\n    private static final Pattern             LINE_PATTERN = Pattern.compile( \"([^ =]+)[ =]?(.*)\" );\n    private static final Map<String, Object> DEFAULTS     = new HashMap<String, Object>() {{\n        put( \"needspeeling\", false );\n        put( \"seedsremoved\", false );\n    }};\n\n    public static void main( final String[] args ) {\n        System.out.println( parseFile( args[ 0 ] ) );\n    }\n\n    public static Map<String, Object> parseFile( final String fileName ) {\n        final Map<String, Object> result = new HashMap<String, Object>( DEFAULTS );\n         BufferedReader      reader = null;\n\n        try {\n            reader = new BufferedReader( new FileReader( fileName ) );\n            for ( String line; null != ( line = reader.readLine() );  ) {\n                parseLine( line, result );\n            }\n        } catch ( final IOException x ) {\n            throw new RuntimeException( \"Oops: \" + x, x );\n        } finally {\n            if ( null != reader ) try {\n                reader.close();\n            } catch ( final IOException x2 ) {\n                System.err.println( \"Could not close \" + fileName + \" - \" + x2 );\n            }\n        }\n\n        return result;\n    }\n\n    private static void parseLine( final String line, final Map<String, Object> map ) {\n        if ( \"\".equals( line.trim() ) || line.startsWith( \"#\" ) || line.startsWith( \";\" ) )\n            return;\n\n        final Matcher matcher = LINE_PATTERN.matcher( line );\n\n        if ( ! matcher.matches() ) {\n            System.err.println( \"Bad config line: \" + line );\n            return;\n        }\n\n        final String key   = matcher.group( 1 ).trim().toLowerCase();\n        final String value = matcher.group( 2 ).trim();\n\n        if ( \"\".equals( value ) ) {\n            map.put( key, true );\n        } else if ( -1 == value.indexOf( ',' ) ) {\n            map.put( key, value );\n        } else {\n            final String[] values = value.split( \",\" );\n\n            for ( int i = 0; i < values.length; i++ ) {\n                values[ i ] = values[ i ].trim();\n            }\n            map.put( key, Arrays.asList( values ) );\n        }\n    }\n}\n"}
{"id": 344147, "name": "Kronecker product based fractals", "source": "Translate Haskell to Java: \nimport Reflex\nimport Reflex.Dom\nimport Data.Map as DM (Map, fromList)\nimport Data.Text (Text, pack)\nimport Data.List (transpose)\n\n\nmain :: IO ()\nmain = mainWidget $ do \n  elAttr \"h1\" (\"style\" =: \"color:black\") $ text \"Kroneker Product Based Fractals\" \n  elAttr \"a\" (\"href\" =: \"http://rosettacode.org/wiki/Kronecker_product_based_fractals#Haskell\") $ text \"Rosetta Code / Kroneker product based fractals / Haskell\"\n\n  \n  el \"br\" $ return ()\n  elAttr \"h2\" (\"style\" =: \"color:brown\") $ text \"Vicsek Fractal\" \n  showFractal [[0, 1, 0] ,[1, 1, 1] ,[0, 1, 0] ]\n\n  \n  el \"br\" $ return ()\n  elAttr \"h2\" (\"style\" =: \"color:brown\") $ text \"Sierpinski Carpet Fractal\" \n  showFractal [[1, 1, 1] ,[1, 0, 1] ,[1, 1, 1] ]\n\n\ncellSize :: Int\ncellSize = 8\n\n\nshowFractal :: MonadWidget t m => [[Int]] -> m ()\nshowFractal seed = do\n  let boardAttrs w h = \n         fromList [ (\"width\" , pack $ show $ w * cellSize)\n                  , (\"height\", pack $ show $ h * cellSize)\n                  ]\n      fractals = iterate (kronekerProduct seed) seed\n      shown = fractals !! 3 \n      w = length $ head shown\n      h = length shown\n  elSvgns \"svg\" (constDyn $ boardAttrs w h) $ showMatrix shown\n\n\nkronekerProduct :: Num a => [[a]] -> [[a]] -> [[a]]\nkronekerProduct xs ys = \n    let m0 = flip $ fmap.fmap.(*)\n        m1 = flip $ fmap.fmap.m0\n    in concat $ fmap (fmap concat.transpose) $ m1 xs ys\n\n\nshowMatrix :: MonadWidget t m => [[Int]] -> m ()\nshowMatrix m = mapM_ showRow $ zip [0..] m \n\n\nshowRow :: MonadWidget t m => (Int,[Int]) -> m ()\nshowRow (x,r) = mapM_ (showCell x) $ zip [0..] r \n\n\nshowCell :: MonadWidget t m => Int -> (Int,Int) -> m ()\nshowCell x (y,on) = \n  let boxAttrs (x,y) = \n        fromList [ (\"transform\", \n                    pack $    \"scale (\" ++ show cellSize ++ \", \" ++ show cellSize ++ \") \" \n                           ++ \"translate (\" ++ show x ++ \", \" ++ show y ++ \")\" \n                   )\n                 ] \n\n      cellAttrs = \n        fromList [ ( \"cx\",      \"0.5\")\n                 , ( \"cy\",      \"0.5\")\n                 , ( \"r\",       \"0.45\")\n                 , ( \"style\",   \"fill:green\")\n                 ] \n\n  in if (on==1) then  \n       elSvgns \"g\"  (constDyn $ boxAttrs (x,y)) $ \n         elSvgns \"circle\" (constDyn $ cellAttrs) $ \n           return ()\n     else\n       return ()\n\n\nelSvgns :: MonadWidget t m => Text -> Dynamic t (Map Text Text) -> m a -> m a\nelSvgns t m ma = do\n    (el, val) <- elDynAttrNS' (Just \"http://www.w3.org/2000/svg\") t m ma\n    return val\n", "target": "package kronecker;\n\n\npublic class ProductFractals {\n  \n  public static int[][] product(final int[][] a, final int[][] b) {\n    \n    \n    final int[][] c = new int[a.length*b.length][];\n    \n    \n    for (int ix = 0; ix < c.length; ix++) {\n      final int num_cols = a[0].length*b[0].length;\n      c[ix] = new int[num_cols];\n    }\n    \n    \n    for (int ia = 0; ia < a.length; ia++) {\n      for (int ja = 0; ja < a[ia].length; ja++) {\n        \n        for (int ib = 0; ib < b.length; ib++) {\n          for (int jb = 0; jb < b[ib].length; jb++) {\n             c[b.length*ia+ib][b[ib].length*ja+jb] = a[ia][ja] * b[ib][jb];\n          }\n        }\n      }\n    }\n\n    \n    return c;\n  }\n\n  \n  public static void show_matrix(final int[][] m, final char nz, final char z) {\n    for (int im = 0; im < m.length; im++) {\n      for (int jm = 0; jm < m[im].length; jm++) {\n        System.out.print(m[im][jm] == 0 ? z : nz);\n      }\n      System.out.println();\n    }\n  }\n\n  \n  public static int[][] power(final int[][] m, final int n) {\n    \n    int[][] m_pow = m;\n    \n    \n    for (int ix = 1; ix < n; ix++) {\n      m_pow = product(m, m_pow);\n    }\n    return m_pow;\n  }\n\n  \n  private static void test(final int[][] m, final int n) {\n    System.out.println(\"Test matrix\");\n    show_matrix(m, '*', ' ');\n    final int[][] m_pow = power(m, n);\n    System.out.println(\"Matrix power \" + n);\n    show_matrix(m_pow, '*', ' ');\n  }\n\n  \n  private static void test1() {\n    \n    final int[][] m = {{0, 1, 0},\n                       {1, 1, 1},\n                       {0, 1, 0}};\n    \n    test(m, 4);\n  }\n\n  \n  private static void test2() {\n    \n    final int[][] m = {{1, 1, 1},\n                       {1, 0, 1},\n                       {1, 1, 1}};\n    \n    test(m, 4);\n  }\n\n  \n  private static void test3() {\n    \n    final int[][] m = {{1, 0, 1},\n                       {1, 0, 1},\n                       {0, 1, 0}};\n    \n    test(m, 4);\n  }\n\n  \n  public static void main(final String[] args) {\n    \n    test1();\n    test2();\n    test3();\n  }\n\n}\n"}
{"id": 344148, "name": "Additive primes", "source": "Translate Haskell to Java: import Data.List (unfoldr)\n\n\nprimes = 2 : sieve [3,5..]\n  where sieve (x:xs) = x : sieve (filter (\\y -> y `mod` x /= 0) xs)\n\n\nisPrime n = all (\\p -> n `mod` p /= 0) $ takeWhile (< sqrtN) primes\n  where sqrtN = round . sqrt . fromIntegral $ n\n\n\ndigits = unfoldr f\n  where f 0 = Nothing\n        f n = let (q, r) = divMod n 10 in Just (r,q)\n\n\nisAdditivePrime n = isPrime n && (isPrime . sum . digits) n\n", "target": "public class additivePrimes {\n\n    public static void main(String[] args) {\n        int additive_primes = 0;\n        for (int i = 2; i < 500; i++) {\n            if(isPrime(i) && isPrime(digitSum(i))){\n                additive_primes++;\n                System.out.print(i + \" \");\n            }\n        }\n        System.out.print(\"\\nFound \" + additive_primes + \" additive primes less than 500\");\n    }\n\n    static boolean isPrime(int n) {\n        int counter = 1;\n        if (n < 2 || (n != 2 && n % 2 == 0) || (n != 3 && n % 3 == 0)) {\n            return false;\n        }\n        while (counter * 6 - 1 <= Math.sqrt(n)) {\n            if (n % (counter * 6 - 1) == 0 || n % (counter * 6 + 1) == 0) {\n                return false;\n            } else {\n                counter++;\n            }\n        }\n        return true;\n    }\n\n    static int digitSum(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"id": 344149, "name": "Case-sensitivity of identifiers", "source": "Translate Haskell to Java: import Text.Printf\n\nmain = printf \"The three dogs are named %s, %s and %s.\\n\" dog dOG dOg\n    where dog = \"Benjamin\"\n          dOG = \"Samba\"\n          dOg = \"Bernie\"\n", "target": "String dog = \"Benjamin\"; \nString Dog = \"Samba\";    \nString DOG = \"Bernie\";   \n@Inject Console console;\nconsole.print($\"There are three dogs named {dog}, {Dog}, and {DOG}\");\n"}
{"id": 344150, "name": "Extra primes", "source": "Translate Haskell to Java: import Data.Char ( digitToInt )\n\nisPrime :: Int -> Bool\nisPrime n \n   |n < 2 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n\ncondition :: Int -> Bool\ncondition n = isPrime n && all isPrime digits && isPrime ( sum digits )\n where\n  digits :: [Int]\n  digits = map digitToInt ( show n )\n\nsolution :: [Int]\nsolution = filter condition [1..9999]\n", "target": "public class ExtraPrimes {\n    private static int nextPrimeDigitNumber(int n) {\n        if (n == 0) {\n            return 2;\n        }\n        switch (n % 10) {\n            case 2:\n                return n + 1;\n            case 3:\n            case 5:\n                return n + 2;\n            default:\n                return 2 + nextPrimeDigitNumber(n / 10) * 10;\n        }\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if ((n & 1) == 0) {\n            return n == 2;\n        }\n        if (n % 3 == 0) {\n            return n == 3;\n        }\n        if (n % 5 == 0) {\n            return n == 5;\n        }\n\n        int[] wheel = new int[]{4, 2, 4, 2, 4, 6, 2, 6};\n        int p = 7;\n        while (true) {\n            for (int w : wheel) {\n                if (p * p > n) {\n                    return true;\n                }\n                if (n % p == 0) {\n                    return false;\n                }\n                p += w;\n            }\n        }\n    }\n\n    private static int digitSum(int n) {\n        int sum = 0;\n        for (; n > 0; n /= 10) {\n            sum += n % 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 10_000;\n        int p = 0, n = 0;\n\n        System.out.printf(\"Extra primes under %d:\\n\", limit);\n        while (p < limit) {\n            p = nextPrimeDigitNumber(p);\n            if (isPrime(p) && isPrime(digitSum(p))) {\n                n++;\n                System.out.printf(\"%2d: %d\\n\", n, p);\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 344151, "name": "Extra primes", "source": "Translate Haskell to Java: import Data.Char ( digitToInt )\n\nisPrime :: Int -> Bool\nisPrime n \n   |n < 2 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n\ncondition :: Int -> Bool\ncondition n = isPrime n && all isPrime digits && isPrime ( sum digits )\n where\n  digits :: [Int]\n  digits = map digitToInt ( show n )\n\nsolution :: [Int]\nsolution = filter condition [1..9999]\n", "target": "public class ExtraPrimes {\n    private static int nextPrimeDigitNumber(int n) {\n        if (n == 0) {\n            return 2;\n        }\n        switch (n % 10) {\n            case 2:\n                return n + 1;\n            case 3:\n            case 5:\n                return n + 2;\n            default:\n                return 2 + nextPrimeDigitNumber(n / 10) * 10;\n        }\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if ((n & 1) == 0) {\n            return n == 2;\n        }\n        if (n % 3 == 0) {\n            return n == 3;\n        }\n        if (n % 5 == 0) {\n            return n == 5;\n        }\n\n        int[] wheel = new int[]{4, 2, 4, 2, 4, 6, 2, 6};\n        int p = 7;\n        while (true) {\n            for (int w : wheel) {\n                if (p * p > n) {\n                    return true;\n                }\n                if (n % p == 0) {\n                    return false;\n                }\n                p += w;\n            }\n        }\n    }\n\n    private static int digitSum(int n) {\n        int sum = 0;\n        for (; n > 0; n /= 10) {\n            sum += n % 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 10_000;\n        int p = 0, n = 0;\n\n        System.out.printf(\"Extra primes under %d:\\n\", limit);\n        while (p < limit) {\n            p = nextPrimeDigitNumber(p);\n            if (isPrime(p) && isPrime(digitSum(p))) {\n                n++;\n                System.out.printf(\"%2d: %d\\n\", n, p);\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 344152, "name": "Abbreviations, easy", "source": "Translate Haskell to Java: import Data.Maybe (fromMaybe)\nimport Data.List (find, isPrefixOf)\nimport Data.Char (toUpper, isUpper)\n\nisAbbreviationOf :: String -> String -> Bool\nisAbbreviationOf abbreviation command =\n  minimumPrefix `isPrefixOf` normalizedAbbreviation\n  && normalizedAbbreviation `isPrefixOf` normalizedCommand\n  where\n    normalizedAbbreviation = map toUpper abbreviation\n    normalizedCommand = map toUpper command\n    minimumPrefix = takeWhile isUpper command\n\n\nexpandAbbreviation :: String -> String -> Maybe String\nexpandAbbreviation commandTable abbreviation = do\n  command <- find (isAbbreviationOf abbreviation) (words commandTable)\n  return $ map toUpper command\n\n\ncommandTable = unwords [\n  \"Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\",\n  \"COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\",\n  \"NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\",\n  \"Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\",\n  \"MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\",\n  \"READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\",\n  \"RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up\"]\n\n\nmain :: IO ()\nmain = do\n  input <- getLine\n  let abbreviations = words input\n  let commands = map (fromMaybe \"*error*\" . expandAbbreviation commandTable) abbreviations\n  putStrLn $ unwords results\n", "target": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class AbbreviationsEasy {\n    private static final Scanner input = new Scanner(System.in);\n    private static final String  COMMAND_TABLE\n            =       \"  Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\\n\" +\n                    \" COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\\n\" +\n                    \" NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\\n\" +\n                    \" Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\\n\" +\n                    \" MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\\n\" +\n                    \" READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\\n\" +\n                    \" RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus TOP TRAnsfer Type Up\";\n\n    public static void main(String[] args) {\n        String[]             cmdTableArr = COMMAND_TABLE.split(\"\\\\s+\");\n        Map<String, Integer> cmd_table   = new HashMap<String, Integer>();\n\n        for (String word : cmdTableArr) {  \n            cmd_table.put(word, countCaps(word));\n        }\n\n        System.out.print(\"Please enter your command to verify: \");\n        String   userInput  = input.nextLine();\n        String[] user_input = userInput.split(\"\\\\s+\");\n\n        for (String s : user_input) {\n            boolean match = false; \n            for (String cmd : cmd_table.keySet()) {\n                if (s.length() >= cmd_table.get(cmd) && s.length() <= cmd.length()) {\n                    String temp = cmd.toUpperCase();\n                    if (temp.startsWith(s.toUpperCase())) {\n                        System.out.print(temp + \" \");\n                        match = true;\n                    }\n                }\n            }\n            if (!match) { \n                System.out.print(\"*error* \");\n            }\n        }\n    }\n\n    private static int countCaps(String word) {\n        int numCaps = 0;\n        for (int i = 0; i < word.length(); i++) {\n            if (Character.isUpperCase(word.charAt(i))) {\n                numCaps++;\n            }\n        }\n        return numCaps;\n    }\n}\n"}
{"id": 344153, "name": "Abbreviations, easy", "source": "Translate Haskell to Java: import Data.Maybe (fromMaybe)\nimport Data.List (find, isPrefixOf)\nimport Data.Char (toUpper, isUpper)\n\nisAbbreviationOf :: String -> String -> Bool\nisAbbreviationOf abbreviation command =\n  minimumPrefix `isPrefixOf` normalizedAbbreviation\n  && normalizedAbbreviation `isPrefixOf` normalizedCommand\n  where\n    normalizedAbbreviation = map toUpper abbreviation\n    normalizedCommand = map toUpper command\n    minimumPrefix = takeWhile isUpper command\n\n\nexpandAbbreviation :: String -> String -> Maybe String\nexpandAbbreviation commandTable abbreviation = do\n  command <- find (isAbbreviationOf abbreviation) (words commandTable)\n  return $ map toUpper command\n\n\ncommandTable = unwords [\n  \"Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\",\n  \"COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\",\n  \"NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\",\n  \"Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\",\n  \"MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\",\n  \"READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\",\n  \"RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up\"]\n\n\nmain :: IO ()\nmain = do\n  input <- getLine\n  let abbreviations = words input\n  let commands = map (fromMaybe \"*error*\" . expandAbbreviation commandTable) abbreviations\n  putStrLn $ unwords results\n", "target": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class AbbreviationsEasy {\n    private static final Scanner input = new Scanner(System.in);\n    private static final String  COMMAND_TABLE\n            =       \"  Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\\n\" +\n                    \" COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\\n\" +\n                    \" NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\\n\" +\n                    \" Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\\n\" +\n                    \" MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\\n\" +\n                    \" READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\\n\" +\n                    \" RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus TOP TRAnsfer Type Up\";\n\n    public static void main(String[] args) {\n        String[]             cmdTableArr = COMMAND_TABLE.split(\"\\\\s+\");\n        Map<String, Integer> cmd_table   = new HashMap<String, Integer>();\n\n        for (String word : cmdTableArr) {  \n            cmd_table.put(word, countCaps(word));\n        }\n\n        System.out.print(\"Please enter your command to verify: \");\n        String   userInput  = input.nextLine();\n        String[] user_input = userInput.split(\"\\\\s+\");\n\n        for (String s : user_input) {\n            boolean match = false; \n            for (String cmd : cmd_table.keySet()) {\n                if (s.length() >= cmd_table.get(cmd) && s.length() <= cmd.length()) {\n                    String temp = cmd.toUpperCase();\n                    if (temp.startsWith(s.toUpperCase())) {\n                        System.out.print(temp + \" \");\n                        match = true;\n                    }\n                }\n            }\n            if (!match) { \n                System.out.print(\"*error* \");\n            }\n        }\n    }\n\n    private static int countCaps(String word) {\n        int numCaps = 0;\n        for (int i = 0; i < word.length(); i++) {\n            if (Character.isUpperCase(word.charAt(i))) {\n                numCaps++;\n            }\n        }\n        return numCaps;\n    }\n}\n"}
{"id": 344154, "name": "Sorting algorithms_Stooge sort", "source": "Translate Haskell to Java: import Data.List\nimport Control.Arrow\nimport Control.Monad\n\ninsertAt e k = uncurry(++).second ((e:).drop 1). splitAt k\n\nswapElems :: [a] -> Int -> Int -> [a]\nswapElems xs i j = insertAt (xs!!j) i $ insertAt (xs!!i) j xs \n\t\nstoogeSort [] = []\nstoogeSort [x] = [x]\nstoogeSort xs = doss 0 (length xs - 1) xs\ndoss :: (Ord a) => Int -> Int -> [a] -> [a]\ndoss i j xs\n      | j-i>1 = doss i (j-t) $ doss (i+t) j $ doss i (j-t) xs'\n      | otherwise = xs'\n    where t = (j-i+1)`div`3\n\t  xs'\n\t    | xs!!j < xs!!i = swapElems xs i j\n\t    | otherwise = xs\n", "target": "import java.util.Arrays;\n\npublic class Stooge {\n    public static void main(String[] args) {\n        int[] nums = {1, 4, 5, 3, -6, 3, 7, 10, -2, -5};\n        stoogeSort(nums);\n        System.out.println(Arrays.toString(nums));\n    }\n\n    public static void stoogeSort(int[] L) {\n        stoogeSort(L, 0, L.length - 1);\n    }\n\n    public static void stoogeSort(int[] L, int i, int j) {\n        if (L[j] < L[i]) {\n            int tmp = L[i];\n            L[i] = L[j];\n            L[j] = tmp;\n        }\n        if (j - i > 1) {\n            int t = (j - i + 1) / 3;\n            stoogeSort(L, i, j - t);\n            stoogeSort(L, i + t, j);\n            stoogeSort(L, i, j - t);\n        }\n    }\n}\n"}
{"id": 344155, "name": "Truncate a file", "source": "Translate Haskell to Java: setFileSize :: FilePath -> FileOffset -> IO ()\n\n\n\n\n", "target": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\n\npublic class TruncFile {\n\tpublic static void main(String[] args) throws IOException{\n\t\tif(args.length < 2){\n\t\t\tSystem.out.println(\"Usage: java TruncFile fileName newSize\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tFileChannel outChan = new FileOutputStream(args[0], true).getChannel();\n\t\tlong newSize = Long.parseLong(args[1]);\n\t\toutChan.truncate(newSize);\n\t\toutChan.close();\n\t}\n}\n"}
{"id": 344156, "name": "Truncate a file", "source": "Translate Haskell to Java: setFileSize :: FilePath -> FileOffset -> IO ()\n\n\n\n\n", "target": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\n\npublic class TruncFile {\n\tpublic static void main(String[] args) throws IOException{\n\t\tif(args.length < 2){\n\t\t\tSystem.out.println(\"Usage: java TruncFile fileName newSize\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tFileChannel outChan = new FileOutputStream(args[0], true).getChannel();\n\t\tlong newSize = Long.parseLong(args[1]);\n\t\toutChan.truncate(newSize);\n\t\toutChan.close();\n\t}\n}\n"}
{"id": 344157, "name": "Sorting algorithms_Shell sort", "source": "Translate Haskell to Java: import Data.List\n\nshellSort xs = foldr (invColumnize (map (foldr insert []))) xs gaps\n  where gaps = takeWhile (< length xs) $ iterate (succ.(3*)) 1\n        invColumnize f k = concat. transpose. f. transpose\n                           . takeWhile (not.null). unfoldr (Just. splitAt k)\n", "target": "public static void shell(int[] a) {\n\tint increment = a.length / 2;\n\twhile (increment > 0) {\n\t\tfor (int i = increment; i < a.length; i++) {\n\t\t\tint j = i;\n\t\t\tint temp = a[i];\n\t\t\twhile (j >= increment && a[j - increment] > temp) {\n\t\t\t\ta[j] = a[j - increment];\n\t\t\t\tj = j - increment;\n\t\t\t}\n\t\t\ta[j] = temp;\n\t\t}\n\t\tif (increment == 2) {\n\t\t\tincrement = 1;\n\t\t} else {\n\t\t\tincrement *= (5.0 / 11);\n\t\t}\n\t}\n}\n"}
{"id": 344158, "name": "Deconvolution_1D", "source": "Translate Haskell to Java: deconv1d :: [Double] -> [Double] -> [Double]\ndeconv1d xs ys = takeWhile (/= 0) $ deconv xs ys\n  where\n    [] `deconv` _ = []\n    (0:xs) `deconv` (0:ys) = xs `deconv` ys\n    (x:xs) `deconv` (y:ys) =\n      let q = x / y\n      in q : zipWith (-) xs (scale q ys ++ repeat 0) `deconv` (y : ys)\n\nscale :: Double -> [Double] -> [Double]\nscale = map . (*)\n\nh, f, g :: [Double]\nh = [-8, -9, -3, -1, -6, 7]\n\nf = [-3, -6, -1, 8, -6, 3, -1, -9, -9, 3, -2, 5, 2, -2, -7, -1]\n\ng =\n  [ 24\n  , 75\n  , 71\n  , -34\n  , 3\n  , 22\n  , -45\n  , 23\n  , 245\n  , 25\n  , 52\n  , 25\n  , -67\n  , -96\n  , 96\n  , 31\n  , 55\n  , 36\n  , 29\n  , -43\n  , -7\n  ]\n\nmain :: IO ()\nmain = print $ (h == deconv1d g f) && (f == deconv1d g h)\n", "target": "import java.util.Arrays;\n\npublic class Deconvolution1D {\n    public static int[] deconv(int[] g, int[] f) {\n        int[] h = new int[g.length - f.length + 1];\n        for (int n = 0; n < h.length; n++) {\n            h[n] = g[n];\n            int lower = Math.max(n - f.length + 1, 0);\n            for (int i = lower; i < n; i++)\n                h[n] -= h[i] * f[n - i];\n            h[n] /= f[0];\n        }\n        return h;\n    }\n\n    public static void main(String[] args) {\n        int[] h = { -8, -9, -3, -1, -6, 7 };\n        int[] f = { -3, -6, -1, 8, -6, 3, -1, -9, -9, 3, -2, 5, 2, -2, -7, -1 };\n        int[] g = { 24, 75, 71, -34, 3, 22, -45, 23, 245, 25, 52, 25, -67, -96,\n                96, 31, 55, 36, 29, -43, -7 };\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"h = \" + Arrays.toString(h) + \"\\n\");\n        sb.append(\"deconv(g, f) = \" + Arrays.toString(deconv(g, f)) + \"\\n\");\n        sb.append(\"f = \" + Arrays.toString(f) + \"\\n\");\n        sb.append(\"deconv(g, h) = \" + Arrays.toString(deconv(g, h)) + \"\\n\");\n        System.out.println(sb.toString());\n    }\n}\n"}
{"id": 344159, "name": "Read a specific line from a file", "source": "Translate Haskell to Java: main :: IO ()\nmain = do contents <- readFile filename\n          case drop 6 $ lines contents of\n            []  -> error \"File has less than seven lines\"\n            l:_ -> putStrLn l\n  where filename = \"testfile\"\n", "target": "package linenbr7;\n\nimport java.io.*;\n\npublic class LineNbr7 {\n\n    public static void main(String[] args) throws Exception {\n        File f = new File(args[0]);\n        if (!f.isFile() || !f.canRead())\n            throw new IOException(\"can't read \" + args[0]);\n\n        BufferedReader br = new BufferedReader(new FileReader(f));\n        try (LineNumberReader lnr = new LineNumberReader(br)) {\n            String line = null;\n            int lnum = 0;\n            while ((line = lnr.readLine()) != null\n                    && (lnum = lnr.getLineNumber()) < 7) {\n            }\n\n            switch (lnum) {\n                case 0:\n                    System.out.println(\"the file has zero length\");\n                    break;\n                case 7:\n                    boolean empty = \"\".equals(line);\n                    System.out.println(\"line 7: \" + (empty ? \"empty\" : line));\n                    break;\n                default:\n                    System.out.println(\"the file has only \" + lnum + \" line(s)\");\n            }\n        }\n    }\n}\n"}
{"id": 344160, "name": "Read a specific line from a file", "source": "Translate Haskell to Java: main :: IO ()\nmain = do contents <- readFile filename\n          case drop 6 $ lines contents of\n            []  -> error \"File has less than seven lines\"\n            l:_ -> putStrLn l\n  where filename = \"testfile\"\n", "target": "package linenbr7;\n\nimport java.io.*;\n\npublic class LineNbr7 {\n\n    public static void main(String[] args) throws Exception {\n        File f = new File(args[0]);\n        if (!f.isFile() || !f.canRead())\n            throw new IOException(\"can't read \" + args[0]);\n\n        BufferedReader br = new BufferedReader(new FileReader(f));\n        try (LineNumberReader lnr = new LineNumberReader(br)) {\n            String line = null;\n            int lnum = 0;\n            while ((line = lnr.readLine()) != null\n                    && (lnum = lnr.getLineNumber()) < 7) {\n            }\n\n            switch (lnum) {\n                case 0:\n                    System.out.println(\"the file has zero length\");\n                    break;\n                case 7:\n                    boolean empty = \"\".equals(line);\n                    System.out.println(\"line 7: \" + (empty ? \"empty\" : line));\n                    break;\n                default:\n                    System.out.println(\"the file has only \" + lnum + \" line(s)\");\n            }\n        }\n    }\n}\n"}
{"id": 344161, "name": "URL encoding", "source": "Translate Haskell to Java: import qualified Data.Char as Char\nimport Text.Printf\n\nencode :: Char -> String\nencode c\n  | c == ' ' = \"+\"\n  | Char.isAlphaNum c || c `elem` \"-._~\" = [c]\n  | otherwise = printf \"%%%02X\" c\n\nurlEncode :: String -> String\nurlEncode = concatMap encode\n\nmain :: IO ()\nmain = putStrLn $ urlEncode \"http://foo bar/\"\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\n\npublic class Main\n{\n    public static void main(String[] args) throws UnsupportedEncodingException\n    {\n        String normal = \"http:\n        String encoded = URLEncoder.encode(normal, \"utf-8\");\n        System.out.println(encoded);\n    }\n}\n"}
{"id": 344162, "name": "URL encoding", "source": "Translate Haskell to Java: import qualified Data.Char as Char\nimport Text.Printf\n\nencode :: Char -> String\nencode c\n  | c == ' ' = \"+\"\n  | Char.isAlphaNum c || c `elem` \"-._~\" = [c]\n  | otherwise = printf \"%%%02X\" c\n\nurlEncode :: String -> String\nurlEncode = concatMap encode\n\nmain :: IO ()\nmain = putStrLn $ urlEncode \"http://foo bar/\"\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\n\npublic class Main\n{\n    public static void main(String[] args) throws UnsupportedEncodingException\n    {\n        String normal = \"http:\n        String encoded = URLEncoder.encode(normal, \"utf-8\");\n        System.out.println(encoded);\n    }\n}\n"}
{"id": 344163, "name": "LU decomposition", "source": "Translate Haskell to Java: import Data.List\nimport Data.Maybe\nimport Text.Printf\n\n\nmmult :: Num a => [[a]] -> [[a]] -> [[a]] \nmmult a b = [ [ sum $ zipWith (*) ak bj | ak <- (transpose a) ] | bj <- b ]\n\nnth mA i j = (mA !! j) !! i\n\nidMatrixPart n m k = [ [if (i==j) then 1 else 0 | i <- [1..n]] | j <- [k..m]]\nidMatrix n = idMatrixPart n n 1\n\npermMatrix n ix1 ix2 =\n    [ [ if ((i==ix1 && j==ix2) || (i==ix2 && j==ix1) || (i==j && j /= ix1 && i /= ix2))\n        then 1 else 0| i <- [0..n-1]] | j <- [0..n-1]]\npermMatrix_inv n ix1 ix2 = permMatrix n ix2 ix1\n        \n\nelimColumn :: Int -> [[Rational]] -> Int -> [Rational]\nelimMatrix :: Int -> [[Rational]] -> Int -> [[Rational]]\nelimMatrix_inv :: Int -> [[Rational]] -> Int -> [[Rational]]\n\nelimColumn n mA k = [(let mAkk = (nth mA k k) in  if (i>k) then (-(nth mA i k)/mAkk)\n    else if (i==k) then 1 else 0) | i <- [0..n-1]]\nelimMatrix n mA k = (idMatrixPart n k 1) ++ [elimColumn n mA k] ++ (idMatrixPart n n (k+2))\nelimMatrix_inv n mA k = (idMatrixPart n k 1) ++ \n    [let c = (mA!!k) in [if (i==k) then 1 else if (i<k) then 0 else (-(c!!i)) | i <- [0..n-1]]]\n     ++ (idMatrixPart n n (k+2))\n\nswapIndx :: [[Rational]] -> Int -> Int\nswapIndx mA k = fromMaybe k (findIndex (>0) (drop k (mA!!k)))\n\n\npaStep_recP :: Int -> [[Rational]] -> [[Rational]] -> [[Rational]] -> Int -> [[[Rational]]]\npaStep_recM :: Int -> [[Rational]] -> [[Rational]] -> [[Rational]] -> Int -> [[[Rational]]]\nlupStep :: Int -> [[Rational]] -> [[[Rational]]]\n\npaStep_recP n mP mA mL cnt = \n    let mPt = permMatrix n cnt (swapIndx mA cnt) in \n        let mPtInv = permMatrix_inv n cnt (swapIndx mA cnt) in\n    if (cnt >= n) then [(mmult mP mL),mA,mP] else\n        (paStep_recM n (mmult mPt mP) (mmult mPt mA) (mmult mL mPtInv) cnt)\n\npaStep_recM n mP mA mL cnt =\n    let mMt = elimMatrix n mA cnt in\n        let mMtInv = elimMatrix_inv n mMt cnt in\n    paStep_recP n mP (mmult mMt mA) (mmult mL mMtInv) (cnt + 1)\n\nlupStep n mA = paStep_recP n (idMatrix n) mA (idMatrix n) 0\n\n\nmatrixFromRationalToString m = concat $ intersperse \"\\n\"\n    (map (\\x -> unwords $ printf \"%8.4f\" <$> (x::[Double])) \n        (transpose (matrixFromRational m))) where \n        matrixFromRational m = map (\\x -> map fromRational x) m\n\nsolveTask mY = let mLUP = lupStep (length mY) mY in\n    putStrLn (\"A: \\n\" ++ matrixFromRationalToString mY) >>\n    putStrLn (\"L: \\n\" ++ matrixFromRationalToString (mLUP!!0)) >>\n    putStrLn (\"U: \\n\" ++ matrixFromRationalToString (mLUP!!1)) >>\n    putStrLn (\"P: \\n\" ++ matrixFromRationalToString (mLUP!!2)) >>\n    putStrLn (\"Verify: PA\\n\" ++ matrixFromRationalToString (mmult (mLUP!!2) mY)) >>\n    putStrLn (\"Verify: LU\\n\" ++ matrixFromRationalToString (mmult (mLUP!!0) (mLUP!!1)))\n\nmY1 = [[1, 2, 1], [3, 4, 7], [5, 7, 0]] :: [[Rational]]\nmY2 = [[11, 1, 3, 2], [9, 5, 17, 5], [24, 2, 18, 7], [2, 6, 1, 1]] :: [[Rational]]\nmain = putStrLn \"Task1: \\n\" >> solveTask mY1 >>\n    putStrLn \"Task2: \\n\" >> solveTask mY2\n", "target": "import static java.util.Arrays.stream;\nimport java.util.Locale;\nimport static java.util.stream.IntStream.range;\n\npublic class Test {\n\n    static double dotProduct(double[] a, double[] b) {\n        return range(0, a.length).mapToDouble(i -> a[i] * b[i]).sum();\n    }\n\n    static double[][] matrixMul(double[][] A, double[][] B) {\n        double[][] result = new double[A.length][B[0].length];\n        double[] aux = new double[B.length];\n\n        for (int j = 0; j < B[0].length; j++) {\n\n            for (int k = 0; k < B.length; k++)\n                aux[k] = B[k][j];\n\n            for (int i = 0; i < A.length; i++)\n                result[i][j] = dotProduct(A[i], aux);\n        }\n        return result;\n    }\n\n    static double[][] pivotize(double[][] m) {\n        int n = m.length;\n        double[][] id = range(0, n).mapToObj(j -> range(0, n)\n                .mapToDouble(i -> i == j ? 1 : 0).toArray())\n                .toArray(double[][]::new);\n\n        for (int i = 0; i < n; i++) {\n            double maxm = m[i][i];\n            int row = i;\n            for (int j = i; j < n; j++)\n                if (m[j][i] > maxm) {\n                    maxm = m[j][i];\n                    row = j;\n                }\n\n            if (i != row) {\n                double[] tmp = id[i];\n                id[i] = id[row];\n                id[row] = tmp;\n            }\n        }\n        return id;\n    }\n\n    static double[][][] lu(double[][] A) {\n        int n = A.length;\n        double[][] L = new double[n][n];\n        double[][] U = new double[n][n];\n        double[][] P = pivotize(A);\n        double[][] A2 = matrixMul(P, A);\n\n        for (int j = 0; j < n; j++) {\n            L[j][j] = 1;\n            for (int i = 0; i < j + 1; i++) {\n                double s1 = 0;\n                for (int k = 0; k < i; k++)\n                    s1 += U[k][j] * L[i][k];\n                U[i][j] = A2[i][j] - s1;\n            }\n            for (int i = j; i < n; i++) {\n                double s2 = 0;\n                for (int k = 0; k < j; k++)\n                    s2 += U[k][j] * L[i][k];\n                L[i][j] = (A2[i][j] - s2) / U[j][j];\n            }\n        }\n        return new double[][][]{L, U, P};\n    }\n\n    static void print(double[][] m) {\n        stream(m).forEach(a -> {\n            stream(a).forEach(n -> System.out.printf(Locale.US, \"%5.1f \", n));\n            System.out.println();\n        });\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        double[][] a = {{1.0, 3, 5}, {2.0, 4, 7}, {1.0, 1, 0}};\n\n        double[][] b = {{11.0, 9, 24, 2}, {1.0, 5, 2, 6}, {3.0, 17, 18, 1},\n        {2.0, 5, 7, 1}};\n\n        for (double[][] m : lu(a))\n            print(m);\n\n        System.out.println();\n\n        for (double[][] m : lu(b))\n            print(m);\n    }\n}\n"}
{"id": 344164, "name": "Optional parameters", "source": "Translate Haskell to Java: \n\ndata SorterArgs = SorterArgs { cmp :: String, col :: Int, rev :: Bool } deriving Show\ndefSortArgs = SorterArgs \"lex\" 0 False\n\n\nsorter :: SorterArgs -> [[String]] -> [[String]]\nsorter (SorterArgs{..}) = case cmp of\n                            _ -> undefined\n\nmain = do\n    sorter defSortArgs{cmp = \"foo\", col=1, rev=True} [[]]\n    sorter defSortArgs{cmp = \"foo\"} [[]]\n    sorter defSortArgs [[]]\n    return ()\n", "target": "module OptionalParameters\n    {\n    typedef Type<String  >.Orderer as ColumnOrderer;\n    typedef Type<String[]>.Orderer as RowOrderer;\n\n    static String[][] sort(String[][]     table,\n                           ColumnOrderer? orderer = Null,\n                           Int            column  = 0,\n                           Boolean        reverse = False,\n                          )\n        {\n        \n        orderer ?:= (s1, s2) -> s1 <=> s2;\n\n        \n        ColumnOrderer byString = reverse\n                ? ((s1, s2) -> orderer(s1, s2).reversed)\n                : orderer;\n\n        \n        RowOrderer byColumn = (row1, row2) -> byString(row1[column], row2[column]);\n\n        return table.sorted(byColumn);\n        }\n\n    void run()\n        {\n        String[][] table =\n            [\n            [\"c\", \"x\", \"i\"],\n            [\"a\", \"y\", \"p\"],\n            [\"b\", \"z\", \"a\"],\n            ];\n\n        show(\"original input\", table);\n        show(\"by default sort on column 0\", sort(table));\n        show(\"by column 2\", sort(table, column=2));\n        show(\"by column 2 reversed\", sort(table, column=2, reverse=True));\n        }\n\n    void show(String title, String[][] table)\n        {\n        @Inject Console console;\n        console.print($\"{title}:\");\n        for (val row : table)\n            {\n            console.print($\"  {row}\");\n            }\n        console.print();\n        }\n    }\n"}
{"id": 344165, "name": "Numeric error propagation", "source": "Translate Haskell to Java: data Error a = Error {value :: a, uncertainty :: a} deriving (Eq, Show)\n\ninstance (Floating a) => Num (Error a) where\n\tError a ua + Error b ub = Error (a + b) (sqrt (ua ^ 2 + ub ^ 2))\n\tnegate (Error a ua) = Error (negate a) ua\n\tError a ua * Error b ub = Error (a * b) (abs (a * b * sqrt ((ua / a) ^ 2 + (ub / b) ^ 2))) \n\tfromInteger a = Error (fromInteger a) 0\n\ninstance (Floating a) => Fractional (Error a) where\n\tfromRational a = Error (fromRational a) 0\n\tError a ua / Error b ub = Error (a / b) (abs (a / b * sqrt ((ua / a) ^ 2 + (ub / b) ^ 2))) \n\ninstance (Floating a) => Floating (Error a) where\n\tError a ua ** Error c 0 = Error (a ** c) (abs (ua * c * a**c / a))\n\nmain = print (sqrt ((x1 - x2) ** 2 + (y1 - y2) ** 2)) where \n\tx1 = Error 100 1.1\n\ty1 = Error 50 1.2\n\tx2 = Error 200 2.2\n\ty2 = Error 100 2.3\n", "target": "public class Approx {\n    private double value;\n    private double error;\n    \n    public Approx(){this.value = this.error = 0;}\n    \n    public Approx(Approx b){\n        this.value = b.value;\n        this.error = b.error;\n    }\n    \n    public Approx(double value, double error){\n        this.value = value;\n        this.error = error;\n    }\n    \n    public Approx add(Approx b){\n        value+= b.value;\n        error = Math.sqrt(error * error + b.error * b.error);\n        return this;\n    }\n    \n    public Approx add(double b){\n        value+= b;\n        return this;\n    }\n    \n    public Approx sub(Approx b){\n        value-= b.value;\n        error = Math.sqrt(error * error + b.error * b.error);\n        return this;\n    }\n    \n    public Approx sub(double b){\n        value-= b;\n        return this;\n    }\n    \n    public Approx mult(Approx b){\n        double oldVal = value;\n        value*= b.value;\n        error = Math.sqrt(value * value * (error*error) / (oldVal*oldVal) +\n                                  (b.error*b.error) / (b.value*b.value));\n        return this;\n    }\n\n    public Approx mult(double b){\n        value*= b;\n        error = Math.abs(b * error);\n        return this;\n    }\n    \n    public Approx div(Approx b){\n        double oldVal = value;\n        value/= b.value;\n        error = Math.sqrt(value * value * (error*error) / (oldVal*oldVal) +\n                                  (b.error*b.error) / (b.value*b.value));\n        return this;\n    }\n\n    public Approx div(double b){\n        value/= b;\n        error = Math.abs(b * error);\n        return this;\n    }\n    \n    public Approx pow(double b){\n        double oldVal = value;\n        value = Math.pow(value, b);\n        error = Math.abs(value * b * (error / oldVal));\n        return this;\n    }\n    \n    @Override\n    public String toString(){return value+\"\u00b1\"+error;}\n    \n    public static void main(String[] args){\n        Approx x1 = new Approx(100, 1.1);\n        Approx y1 = new Approx(50, 1.2);\n        Approx x2 = new Approx(200, 2.2);\n        Approx y2 = new Approx(100, 2.3);\n        \n        x1.sub(x2).pow(2).add(y1.sub(y2).pow(2)).pow(0.5);\n        \n        System.out.println(x1);\n    }\n}\n"}
{"id": 344166, "name": "Trabb Pardo\u2013Knuth algorithm", "source": "Translate Haskell to Java: import Control.Monad (replicateM, mapM_)\n\nf :: Floating a => a -> a\nf x = sqrt (abs x) + 5 * x ** 3\n\nmain :: IO ()\nmain = do\n  putStrLn \"Enter 11 numbers for evaluation\"\n  x <- replicateM 11 readLn\n  mapM_\n    ((\\x ->\n         if x > 400\n           then putStrLn \"OVERFLOW\"\n           else print x) .\n     f) $\n    reverse x\n", "target": "\nimport java.util.*;\nimport java.io.*; \n\npublic class TPKA {\n\tpublic static void main(String... args) {\n\t\tdouble[] input = new double[11];\n\t\tdouble userInput = 0.0;\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(int i = 0; i < 11; i++) {\n\t\t\tSystem.out.print(\"Please enter a number: \");\n\t\t\tString s = in.nextLine();\n\t\t\ttry {\n\t\t\t\tuserInput = Double.parseDouble(s);\n\t\t\t} catch (NumberFormatException e) { \n\t\t\t\tSystem.out.println(\"You entered invalid input, exiting\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t\tinput[i] = userInput;\n\t\t}\n\t\tfor(int j = 10; j >= 0; j--) {\n\t\t\tdouble x = input[j]; double y = f(x);\n\t\t\tif( y < 400.0) {\n\t\t\t\tSystem.out.printf(\"f(\u00a0%.2f ) =\u00a0%.2f\\n\", x, y);\n\t\t\t} else {\n\t\t\t\tSystem.out.printf(\"f(\u00a0%.2f ) = %s\\n\", x, \"TOO LARGE\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static double f(double x) {\n\t\treturn Math.pow(Math.abs(x), 0.5) + (5*(Math.pow(x, 3)));\n\t}\n}\n"}
{"id": 344167, "name": "Rate counter", "source": "Translate Haskell to Java: import Control.Monad\nimport Control.Concurrent\nimport Data.Time\n\ngetTime :: IO DiffTime\ngetTime = fmap utctDayTime getCurrentTime\n\naddSample :: MVar [a] -> a -> IO ()\naddSample q v = modifyMVar_ q (return . (v:))\n\ntimeit :: Int -> IO a -> IO [DiffTime]\ntimeit n task = do\n    samples <- newMVar []\n    forM_ [0..n] $ \\n -> do\n        t1 <- getTime\n        task\n        t2 <- getTime\n        addSample samples (t2 - t1)\n\n    readMVar samples\n\nmain = timeit 10 (threadDelay 1000000)\n", "target": "import java.util.function.Consumer;\n\npublic class RateCounter {\n\n    public static void main(String[] args) {\n        for (double d : benchmark(10, x -> System.out.print(\"\"), 10))\n            System.out.println(d);\n    }\n\n    static double[] benchmark(int n, Consumer<Integer> f, int arg) {\n        double[] timings = new double[n];\n        for (int i = 0; i < n; i++) {\n            long time = System.nanoTime();\n            f.accept(arg);\n            timings[i] = System.nanoTime() - time;\n        }\n        return timings;\n    }\n}\n"}
{"id": 344168, "name": "EKG sequence convergence", "source": "Translate Haskell to Java: import Data.List (findIndex, isPrefixOf, tails)\nimport Data.Maybe (fromJust)\n\n\n\nseqEKGRec :: Int -> Int -> [Int] -> [Int]\nseqEKGRec _ 0 l = l\nseqEKGRec k n [] = seqEKGRec k (n - 2) [k, 1]\nseqEKGRec k n l@(h : t) =\n  seqEKGRec\n    k\n    (pred n)\n    ( head\n        ( filter\n            (((&&) . flip notElem l) <*> ((1 <) . gcd h))\n            [2 ..]\n        ) :\n      l\n    )\n\nseqEKG :: Int -> Int -> [Int]\nseqEKG k n = reverse (seqEKGRec k n [])\n\n\n\nmain :: IO ()\nmain =\n  mapM_\n    ( \\x ->\n        putStr \"EKG (\"\n          >> (putStr . show $ x)\n          >> putStr \") is \"\n          >> print (seqEKG x 20)\n    )\n    [2, 5, 7, 9, 10]\n    >> putStr \"EKG(5) and EKG(7) converge at \"\n    >> print\n      ( succ $\n          fromJust $\n            findIndex\n              (isPrefixOf (replicate 20 True))\n              ( tails\n                  ( zipWith\n                      (==)\n                      (seqEKG 7 80)\n                      (seqEKG 5 80)\n                  )\n              )\n      )\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class EKGSequenceConvergence {\n\n    public static void main(String[] args) {\n        System.out.println(\"Calculate and show here the first 10 members of EKG[2], EKG[5], EKG[7], EKG[9] and EKG[10].\");\n        for ( int i : new int[] {2, 5, 7, 9, 10} ) {\n            System.out.printf(\"EKG[%d] = %s%n\", i, ekg(i, 10));\n        }\n        System.out.println(\"Calculate and show here at which term EKG[5] and EKG[7] converge.\");\n        List<Integer> ekg5 = ekg(5, 100);\n        List<Integer> ekg7 = ekg(7, 100);\n        for ( int i = 1 ; i < ekg5.size() ; i++ ) {\n            if ( ekg5.get(i) == ekg7.get(i) && sameSeq(ekg5, ekg7, i)) {\n                System.out.printf(\"EKG[%d](%d) = EKG[%d](%d) = %d, and are identical from this term on%n\", 5, i+1, 7, i+1, ekg5.get(i));\n                break;\n            }\n        }\n    }\n    \n    \n    private static boolean sameSeq(List<Integer> seq1, List<Integer> seq2, int n) {\n        List<Integer> list1 = new ArrayList<>(seq1.subList(0, n));\n        Collections.sort(list1);\n        List<Integer> list2 = new ArrayList<>(seq2.subList(0, n));\n        Collections.sort(list2);\n        for ( int i = 0 ; i < n ; i++ ) {\n            if ( list1.get(i) != list2.get(i) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    \n    \n    \n    private static List<Integer> ekg(int two, int maxN) {\n        List<Integer> result = new ArrayList<>();\n        result.add(1);\n        result.add(two);\n        Map<Integer,Integer> seen = new HashMap<>();\n        seen.put(1, 1);\n        seen.put(two, 1);\n        int minUnseen = two == 2 ? 3 : 2;\n        int prev = two;\n        for ( int n = 3 ; n <= maxN ; n++ ) {\n            int test = minUnseen - 1;\n            while ( true ) {\n                test++;\n                if ( ! seen.containsKey(test) && gcd(test, prev) > 1 ) {\n                    \n                    result.add(test);\n                    seen.put(test, n);\n                    prev = test;\n                    if ( minUnseen == test ) {\n                        do {\n                            minUnseen++;\n                        } while ( seen.containsKey(minUnseen) );\n                    }\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    private static final int gcd(int a, int b) {\n        if ( b == 0 ) {\n            return a;\n        }\n        return gcd(b, a%b);\n    }\n        \n}\n"}
{"id": 344169, "name": "Dice game probabilities", "source": "Translate Haskell to Java: import Control.Monad (replicateM)\nimport Data.List (group, sort)\n\nsucceeds :: (Int, Int) -> (Int, Int) -> Double\nsucceeds p1 p2 =\n  sum\n    [ realToFrac (c1 * c2) / totalOutcomes\n    | (s1, c1) <- countSums p1 \n    , (s2, c2) <- countSums p2 \n    , s1 > s2 ]\n  where\n    totalOutcomes = realToFrac $ uncurry (^) p1 * uncurry (^) p2\n    countSums (nFaces, nDice) = f [1 .. nFaces]\n      where\n        f =\n          fmap (((,) . head) <*> (pred . length)) .\n          group . sort . fmap sum . replicateM nDice\n\nmain :: IO ()\nmain = do\n  print $ (4, 9) `succeeds` (6, 6)\n  print $ (10, 5) `succeeds` (7, 6)\n", "target": "import java.util.Random;\n\npublic class Dice{\n\tprivate static int roll(int nDice, int nSides){\n\t\tint sum = 0;\n\t\tRandom rand = new Random();\n\t\tfor(int i = 0; i < nDice; i++){\n\t\t\tsum += rand.nextInt(nSides) + 1;\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tprivate static int diceGame(int p1Dice, int p1Sides, int p2Dice, int p2Sides, int rolls){\n\t\tint p1Wins = 0;\n\t\tfor(int i = 0; i < rolls; i++){\n\t\t\tint p1Roll = roll(p1Dice, p1Sides);\n\t\t\tint p2Roll = roll(p2Dice, p2Sides);\n\t\t\tif(p1Roll > p2Roll) p1Wins++;\n\t\t}\n\t\treturn p1Wins;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tint p1Dice = 9; int p1Sides = 4;\n\t\tint p2Dice = 6; int p2Sides = 6;\n\t\tint rolls = 10000;\n\t\tint p1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);\n\t\tSystem.out.println(rolls + \" rolls, p1 = \" + p1Dice + \"d\" + p1Sides + \", p2 = \" + p2Dice + \"d\" + p2Sides);\n\t\tSystem.out.println(\"p1 wins \" + (100.0 * p1Wins / rolls) + \"% of the time\");\n\t\t\n\t\tSystem.out.println();\n\t\t\n\t\tp1Dice = 5; p1Sides = 10;\n\t\tp2Dice = 6; p2Sides = 7;\n\t\trolls = 10000;\n\t\tp1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);\n\t\tSystem.out.println(rolls + \" rolls, p1 = \" + p1Dice + \"d\" + p1Sides + \", p2 = \" + p2Dice + \"d\" + p2Sides);\n\t\tSystem.out.println(\"p1 wins \" + (100.0 * p1Wins / rolls) + \"% of the time\");\n\t\t\n\t\tSystem.out.println();\n\t\t\n\t\tp1Dice = 9; p1Sides = 4;\n\t\tp2Dice = 6; p2Sides = 6;\n\t\trolls = 1000000;\n\t\tp1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);\n\t\tSystem.out.println(rolls + \" rolls, p1 = \" + p1Dice + \"d\" + p1Sides + \", p2 = \" + p2Dice + \"d\" + p2Sides);\n\t\tSystem.out.println(\"p1 wins \" + (100.0 * p1Wins / rolls) + \"% of the time\");\n\t\t\n\t\tSystem.out.println();\n\t\t\n\t\tp1Dice = 5; p1Sides = 10;\n\t\tp2Dice = 6; p2Sides = 7;\n\t\trolls = 1000000;\n\t\tp1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);\n\t\tSystem.out.println(rolls + \" rolls, p1 = \" + p1Dice + \"d\" + p1Sides + \", p2 = \" + p2Dice + \"d\" + p2Sides);\n\t\tSystem.out.println(\"p1 wins \" + (100.0 * p1Wins / rolls) + \"% of the time\");\n\t}\n}\n"}
{"id": 344170, "name": "Metronome", "source": "Translate Haskell to Java: import Control.Concurrent\nimport Control.Concurrent.MVar\nimport System.Process (runCommand)\n\n\n\n\ndata Beep = Stop | Hi | Low\n\ntype Pattern = [Beep]\n\ntype BeatsPerMinute = Int\n\nminute = 60000000 \n\n\n\npattern4_4 = [Hi, Low, Low, Low]\npattern2_4 = [Hi, Low]\npattern3_4 = [Hi, Low, Low]\npattern6_8 = [Hi, Low, Low, Low, Low, Low]\n\n\n\n\n\n\n\n\n\n\n\nbeep Stop = return ()\nbeep Hi = putChar 'H' >> runCommand \"aplay hi.wav &> /dev/null\" >> return ()\nbeep Low = putChar 'L' >> runCommand \"aplay low.wav &> /dev/null\" >> return ()\n\ntick :: MVar Pattern -> BeatsPerMinute -> IO ()\ntick b i = do\n    t <- readMVar b\n    case t of\n        [Stop] -> return ()\n        x -> do\n            mapM_ (\\v -> forkIO (beep v) >> threadDelay (minute `div` i)) t\n            tick b i\n\nmetronome :: Pattern -> BeatsPerMinute -> IO ()\nmetronome p i = do\n    putStrLn \"Press any key to stop the metronome.\"\n    b <- newMVar p\n    _ <- forkIO $ tick b i\n    _ <- getChar\n    putMVar b [Stop]\n", "target": "class Metronome{\n\tdouble bpm;\n\tint measure, counter;\n\tpublic Metronome(double bpm, int measure){\n\t\tthis.bpm = bpm;\n\t\tthis.measure = measure;\t\n\t}\n\tpublic void start(){\n\t\twhile(true){\n\t\t\ttry {\n\t\t\t\tThread.sleep((long)(1000*(60.0/bpm)));\n\t\t\t}catch(InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tcounter++;\n\t\t\tif (counter%measure==0){\n\t\t\t\t System.out.println(\"TICK\");\n\t\t\t}else{\n\t\t\t\t System.out.println(\"TOCK\");\n\t\t\t}\n\t\t}\n\t}\n}\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tMetronome metronome1 = new Metronome(120,4);\n\t\tmetronome1.start();\n\t}\n}\n"}
{"id": 344171, "name": "Sum of elements below main diagonal of matrix", "source": "Translate Haskell to Java: \n\nmatrixTriangle :: Bool -> [[a]] -> Either String [[a]]\nmatrixTriangle upper matrix\n  | upper = go drop id\n  | otherwise = go take pred\n  where\n    go f g\n      | isSquare matrix =\n        (Right . snd) $\n          foldr\n            (\\xs (n, rows) -> (pred n, f n xs : rows))\n            (g $ length matrix, [])\n            matrix\n      | otherwise = Left \"Defined only for a square matrix.\"\n\nisSquare :: [[a]] -> Bool\nisSquare rows = all ((n ==) . length) rows\n  where\n    n = length rows\n\n\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n    zipWith\n      ( flip ((<>) . (<> \" triangle:\\n\\t\"))\n          . either id (show . sum . concat)\n      )\n      ( [matrixTriangle] <*> [False, True]\n          <*> [ [ [1, 3, 7, 8, 10],\n                  [2, 4, 16, 14, 4],\n                  [3, 1, 9, 18, 11],\n                  [12, 14, 17, 18, 20],\n                  [7, 1, 3, 9, 5]\n                ]\n              ]\n      )\n      [\"Lower\", \"Upper\"]\n", "target": "public static void main(String[] args) {\n    int[][] matrix = {{1, 3, 7, 8, 10},\n                      {2, 4, 16, 14, 4},\n                      {3, 1, 9, 18, 11},\n                      {12, 14, 17, 18, 20},\n                      {7, 1, 3, 9, 5}};\n    int sum = 0;\n    for (int row = 1; row < matrix.length; row++) {\n        for (int col = 0; col < row; col++) {\n            sum += matrix[row][col];\n        }\n    }\n    System.out.println(sum);\n}\n"}
{"id": 344172, "name": "Pythagoras tree", "source": "Translate Haskell to Java: mkBranches :: [(Float,Float)] -> [[(Float,Float)]]\nmkBranches [a, b, c, d] = let d  = 0.5 <*> (b <+> (-1 <*> a))\n                              l1 = d <+> orth d\n                              l2 = orth l1\n                    in\n                      [ [a <+> l2, b <+> (2 <*> l2), a <+> l1, a]\n                      , [a <+> (2 <*> l1), b <+> l1, b, b <+> l2] ]\n  where\n    (a, b) <+> (c, d) = (a+c, b+d)\n    n <*> (a, b) = (a*n, b*n)\n    orth (a, b) = (-b, a)\n", "target": "import java.awt.*;\nimport java.awt.geom.Path2D;\nimport javax.swing.*;\n\npublic class PythagorasTree extends JPanel {\n    final int depthLimit = 7;\n    float hue = 0.15f;\n\n    public PythagorasTree() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n    }\n\n    private void drawTree(Graphics2D g, float x1, float y1, float x2, float y2,\n            int depth) {\n\n        if (depth == depthLimit)\n            return;\n\n        float dx = x2 - x1;\n        float dy = y1 - y2;\n\n        float x3 = x2 - dy;\n        float y3 = y2 - dx;\n        float x4 = x1 - dy;\n        float y4 = y1 - dx;\n        float x5 = x4 + 0.5F * (dx - dy);\n        float y5 = y4 - 0.5F * (dx + dy);\n\n        Path2D square = new Path2D.Float();\n        square.moveTo(x1, y1);\n        square.lineTo(x2, y2);\n        square.lineTo(x3, y3);\n        square.lineTo(x4, y4);\n        square.closePath();\n\n        g.setColor(Color.getHSBColor(hue + depth * 0.02f, 1, 1));\n        g.fill(square);\n        g.setColor(Color.lightGray);\n        g.draw(square);\n\n        Path2D triangle = new Path2D.Float();\n        triangle.moveTo(x3, y3);\n        triangle.lineTo(x4, y4);\n        triangle.lineTo(x5, y5);\n        triangle.closePath();\n\n        g.setColor(Color.getHSBColor(hue + depth * 0.035f, 1, 1));\n        g.fill(triangle);\n        g.setColor(Color.lightGray);\n        g.draw(triangle);\n\n        drawTree(g, x4, y4, x5, y5, depth + 1);\n        drawTree(g, x5, y5, x3, y3, depth + 1);\n    }\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        drawTree((Graphics2D) g, 275, 500, 375, 500, 0);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Pythagoras Tree\");\n            f.setResizable(false);\n            f.add(new PythagorasTree(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 344173, "name": "Rep-string", "source": "Translate Haskell to Java: import Data.List (inits, maximumBy)\nimport Data.Maybe (fromMaybe)\n\nrepstring :: String -> Maybe String\n\nrepstring [] = Nothing\n\nrepstring [_] = Nothing\nrepstring xs\n  | any (`notElem` \"01\") xs = Nothing\n  | otherwise = longest xs\n  where\n    \n    lxs = length xs\n    \n    lq2 = lxs `quot` 2\n    \n    \n    subrepeat x = (x, take lxs $ concat $ repeat x)\n    \n    sndValid (_, ys) = ys == xs\n    \n    \n    possible = map subrepeat . take lq2 . tail . inits\n    \n    \n    valid = map fst . filter sndValid . possible\n    \n    compLength a b = compare (length a) (length b)\n    \n    \n    longest ys = case valid ys of\n      [] -> Nothing\n      zs -> Just $ maximumBy compLength zs\n\nmain :: IO ()\nmain =\n  mapM_ processIO examples\n  where\n    examples =\n      [ \"1001110011\",\n        \"1110111011\",\n        \"0010010010\",\n        \"1010101010\",\n        \"1111111111\",\n        \"0100101101\",\n        \"0100100\",\n        \"101\",\n        \"11\",\n        \"00\",\n        \"1\"\n      ]\n    process = fromMaybe \"Not a rep string\" . repstring\n    processIO xs = do\n      putStr (xs <> \": \")\n      putStrLn $ process xs\n", "target": "public class RepString {\n\n    static final String[] input = {\"1001110011\", \"1110111011\", \"0010010010\",\n        \"1010101010\", \"1111111111\", \"0100101101\", \"0100100\", \"101\", \"11\",\n        \"00\", \"1\", \"0100101\"};\n\n    public static void main(String[] args) {\n        for (String s : input)\n            System.out.printf(\"%s\u00a0: %s%n\", s, repString(s));\n    }\n\n    static String repString(String s) {\n        int len = s.length();\n        outer:\n        for (int part = len / 2; part > 0; part--) {\n            int tail = len % part;\n            if (tail > 0 && !s.substring(0, tail).equals(s.substring(len - tail)))\n                continue;\n            for (int j = 0; j < len / part - 1; j++) {\n                int a = j * part;\n                int b = (j + 1) * part;\n                int c = (j + 2) * part;\n                if (!s.substring(a, b).equals(s.substring(b, c)))\n                    continue outer;\n            }\n            return s.substring(0, part);\n        }\n        return \"none\";\n    }\n}\n"}
{"id": 344174, "name": "Topswops", "source": "Translate Haskell to Java: import Data.List (permutations)\n\ntopswops :: Int -> Int\ntopswops n = maximum $ map tops $ permutations [1 .. n]\n  where\n    tops (1:_) = 0\n    tops xa@(x:_) = 1 + tops reordered\n      where\n        reordered = reverse (take x xa) ++ drop x xa\n\nmain =\n  mapM_ (putStrLn . ((++) <$> show <*> (\":\\t\" ++) . show . topswops)) [1 .. 10]\n", "target": "public class Topswops {\n    static final int maxBest = 32;\n    static int[] best;\n\n    static private void trySwaps(int[] deck, int f, int d, int n) {\n        if (d > best[n])\n            best[n] = d;\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (deck[i] == -1 || deck[i] == i)\n                break;\n            if (d + best[i] <= best[n])\n                return;\n        }\n\n        int[] deck2 = deck.clone();\n        for (int i = 1; i < n; i++) {\n            final int k = 1 << i;\n            if (deck2[i] == -1) {\n                if ((f & k) != 0)\n                    continue;\n            } else if (deck2[i] != i)\n                continue;\n\n            deck2[0] = i;\n            for (int j = i - 1; j >= 0; j--)\n                deck2[i - j] = deck[j]; \n            trySwaps(deck2, f | k, d + 1, n);\n        }\n    }\n\n    static int topswops(int n) {\n        assert(n > 0 && n < maxBest);\n        best[n] = 0;\n        int[] deck0 = new int[n + 1];\n        for (int i = 1; i < n; i++)\n            deck0[i] = -1;\n        trySwaps(deck0, 1, 0, n);\n        return best[n];\n    }\n\n    public static void main(String[] args) {\n        best = new int[maxBest];\n        for (int i = 1; i < 11; i++)\n            System.out.println(i + \": \" + topswops(i));\n    }\n}\n"}
{"id": 344175, "name": "Sequence_ smallest number greater than previous term with exactly n divisors", "source": "Translate Haskell to Java: import Text.Printf (printf)\n\nsequence_A069654 :: [(Int,Int)]\nsequence_A069654 = go 1 $ (,) <*> countDivisors <$> [1..]\n where go t ((n,c):xs) | c == t    = (t,n):go (succ t) xs\n                       | otherwise = go t xs\n       countDivisors n = foldr f 0 [1..floor $ sqrt $ realToFrac n]\n        where f x r | n `mod` x == 0 = if n `div` x == x then r+1 else r+2\n                    | otherwise      = r\n\nmain :: IO ()\nmain = mapM_ (uncurry $ printf \"a(%2d)=%5d\\n\") $ take 15 sequence_A069654\n", "target": "public class AntiPrimesPlus {\n\n    static int count_divisors(int n) {\n        int count = 0;\n        for (int i = 1; i * i <= n; ++i) {\n            if (n % i == 0) {\n                if (i == n / i)\n                    count++;\n                else\n                    count += 2;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        final int max = 15;\n        System.out.printf(\"The first %d terms of the sequence are:\\n\", max);\n        for (int i = 1, next = 1; next <= max; ++i) {\n            if (next == count_divisors(i)) {           \n                System.out.printf(\"%d \", i);\n                next++;\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 344176, "name": "McNuggets problem", "source": "Translate Haskell to Java: import Data.Set (Set, fromList, member)\n\n\n\nmcNuggets :: Set Int\nmcNuggets =\n  let size = enumFromTo 0 . quot 100\n   in fromList $\n        size 6\n          >>= \\x ->\n            size 9\n              >>= \\y ->\n                size 20\n                  >>= \\z ->\n                    [ v\n                      | let v = sum [6 * x, 9 * y, 20 * z],\n                        101 > v\n                    ]\n\n\nmain :: IO ()\nmain =\n  (putStrLn . go) $\n    dropWhile (`member` mcNuggets) [100, 99 .. 1]\n  where\n    go (x : _) = show x\n    go [] = \"No unreachable quantities found ...\"\n", "target": "public class McNuggets {\n\n    public static void main(String... args) {\n        int[] SIZES = new int[] { 6, 9, 20 };\n        int MAX_TOTAL = 100;\n        \n        int numSizes = SIZES.length;\n        int[] counts = new int[numSizes];\n        int maxFound = MAX_TOTAL + 1;\n        boolean[] found = new boolean[maxFound];\n        int numFound = 0;\n        int total = 0;\n        boolean advancedState = false;\n        do {\n            if (!found[total]) {\n                found[total] = true;\n                numFound++;\n            }\n            \n            \n            advancedState = false;\n            for (int i = 0; i < numSizes; i++) {\n                int curSize = SIZES[i];\n                if ((total + curSize) > MAX_TOTAL) {\n                    \n                    total -= counts[i] * curSize;\n                    counts[i] = 0;\n                }\n                else {\n                    \n                    counts[i]++;\n                    total += curSize;\n                    advancedState = true;\n                    break;\n                }\n            }\n            \n        } while ((numFound < maxFound) && advancedState);\n        \n        if (numFound < maxFound) {\n            \n            for (int i = MAX_TOTAL; i >= 0; i--) {\n                if (!found[i]) {\n                    System.out.println(\"Largest non-McNugget number in the search space is \" + i);\n                    break;\n                }\n            }\n        }\n        else {\n            System.out.println(\"All numbers in the search space are McNugget numbers\");\n        }\n        \n        return;\n    }\n}\n"}
{"id": 344177, "name": "Idiomatically determine all the lowercase and uppercase letters", "source": "Translate Haskell to Java: main = do putStrLn $ \"Lower: \" ++ ['a'..'z']\n          putStrLn $ \"Upper: \" ++ ['A'..'Z']\n", "target": "import java.util.stream.IntStream;\n\npublic class Letters {\n    public static void main(String[] args) throws Exception {\n        System.out.print(\"Upper case: \");\n        IntStream.rangeClosed(0, 0x10FFFF)\n                 .filter(Character::isUpperCase)\n                 .limit(72)\n                 .forEach(n -> System.out.printf(\"%c\", n));\n        System.out.println(\"...\");\n\n        System.out.print(\"Lower case: \");\n        IntStream.rangeClosed(0, 0x10FFFF)\n                 .filter(Character::isLowerCase)\n                 .limit(72)\n                 .forEach(n -> System.out.printf(\"%c\", n));\n        System.out.println(\"...\");\n    }\n}\n"}
{"id": 344178, "name": "Superellipse", "source": "Translate Haskell to Java: \nimport Reflex\nimport Reflex.Dom\nimport Data.Text (Text, pack, unpack) \nimport Data.Map (Map, fromList, empty)\nimport Text.Read (readMaybe)\n\nwidth = 600\nheight = 500\n\ntype Point = (Float,Float)\ntype Segment = (Point,Point)\n\ndata Ellipse = Ellipse {a :: Float, b :: Float, n :: Float}\n\ntoFloat :: Text -> Maybe Float\ntoFloat  = readMaybe.unpack  \n\ntoEllipse :: Maybe Float -> Maybe Float -> Maybe Float -> Maybe Ellipse\ntoEllipse (Just a) (Just b) (Just n) = \n    if a < 1.0 || b <= 1.0 || n <= 0.0  \n    then Nothing \n    else Just $ Ellipse a b n\n\ntoEllipse _ _ _ = Nothing\n\nshowError :: Maybe a -> String\nshowError Nothing = \"invalid input\"\nshowError _ = \"\"\n\nreflect45 pts  =  pts ++ fmap (\\(x,y) -> ( y,  x)) (reverse pts)\nrotate90  pts  =  pts ++ fmap (\\(x,y) -> ( y, -x)) pts\nrotate180 pts  =  pts ++ fmap (\\(x,y) -> (-x, -y)) pts\nscale a b      =  fmap (\\(x,y) -> ( a*x, b*y )) \nsegments  pts  =  zip pts $ tail pts\n\ntoLineMap :: Maybe Ellipse -> Map Int ((Float,Float),(Float,Float))\ntoLineMap (Just (Ellipse a b n)) =\n    let f p = (1 - p**n)**(1/n)\n        dp = iterate (*0.9) 1.0\n        ip = map (\\p -> 1.0 -p) dp\n        points s = \n            if n > 1.0\n            then (\\p -> zip p (map f p)) ip\n            else (\\p -> zip (map f p) p) dp\n\n    in fromList $  \n       zip [0..] $ \n       segments $  \n       scale a b $ \n       rotate180 $ \n       rotate90 $  \n       reflect45 $ \n       takeWhile (\\(x,y) -> x < y ) $ \n       points 0.9\n\ntoLineMap Nothing = empty\n\nlineAttrs :: Segment -> Map Text Text\nlineAttrs ((x1,y1), (x2,y2)) =\n    fromList [ ( \"x1\",    pack $ show (width/2+x1))\n             , ( \"y1\",    pack $ show (height/2+y1))\n             , ( \"x2\",    pack $ show (width/2+x2))\n             , ( \"y2\",    pack $ show (height/2+y2))\n             , ( \"style\", \"stroke:brown;stroke-width:2\")\n             ]    \n         \nshowLine :: MonadWidget t m => Int -> Dynamic t Segment -> m ()\nshowLine _ dSegment = do\n    elSvgns \"line\" (lineAttrs <$> dSegment) $ return ()\n    return ()\n\nmain = mainWidget $ do\n    elAttr \"h1\" (\"style\" =: \"color:brown\") $ text \"Superellipse\" \n    ta <- el \"div\" $ do\n        text \"a: \"\n        textInput def { _textInputConfig_initialValue = \"200\"}\n\n    tb <- el \"div\" $ do\n        text \"b: \"\n        textInput def { _textInputConfig_initialValue = \"200\"}\n\n    tn <- el \"div\" $ do\n        text \"n: \"\n        textInput def { _textInputConfig_initialValue = \"2.5\"}\n    let \n        ab = zipDynWith toEllipse (toFloat <$> value ta) (toFloat <$> value tb)\n        dEllipse = zipDynWith ($) ab (toFloat <$> value tn)\n        dLines = fmap toLineMap dEllipse \n        \n        dAttrs = constDyn $ fromList \n                     [ (\"width\" , pack $ show width)\n                     , (\"height\", pack $ show height)\n                     ]\n    elAttr \"div\" (\"style\" =: \"color:red\") $ dynText $ fmap (pack.showError) dEllipse\n    el \"div\" $ elSvgns \"svg\" dAttrs $ listWithKey dLines showLine\n    return ()\n\n\nelSvgns :: forall t m a. MonadWidget t m => Text -> Dynamic t (Map Text Text) -> m a -> m (El t, a)\nelSvgns = elDynAttrNS' (Just \"http://www.w3.org/2000/svg\")\n", "target": "import java.awt.*;\nimport java.awt.geom.Path2D;\nimport static java.lang.Math.pow;\nimport java.util.Hashtable;\nimport javax.swing.*;\nimport javax.swing.event.*;\n\npublic class SuperEllipse extends JPanel implements ChangeListener {\n    private double exp = 2.5;\n\n    public SuperEllipse() {\n        setPreferredSize(new Dimension(650, 650));\n        setBackground(Color.white);\n        setFont(new Font(\"Serif\", Font.PLAIN, 18));\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setStroke(new BasicStroke(2));\n        g.setColor(new Color(0xEEEEEE));\n\n        int w = getWidth();\n        int h = getHeight();\n        int spacing = 25;\n\n        for (int i = 0; i < w / spacing; i++) {\n            g.drawLine(0, i * spacing, w, i * spacing);\n            g.drawLine(i * spacing, 0, i * spacing, w);\n        }\n        g.drawLine(0, h - 1, w, h - 1);\n\n        g.setColor(new Color(0xAAAAAA));\n        g.drawLine(0, w / 2, w, w / 2);\n        g.drawLine(w / 2, 0, w / 2, w);\n    }\n\n    void drawLegend(Graphics2D g) {\n        g.setColor(Color.black);\n        g.setFont(getFont());\n        g.drawString(\"n = \" + String.valueOf(exp), getWidth() - 150, 45);\n        g.drawString(\"a = b = 200\", getWidth() - 150, 75);\n    }\n\n    void drawEllipse(Graphics2D g) {\n\n        final int a = 200; \n        double[] points = new double[a + 1];\n\n        Path2D p = new Path2D.Double();\n        p.moveTo(a, 0);\n\n        \n        for (int x = a; x >= 0; x--) {\n            points[x] = pow(pow(a, exp) - pow(x, exp), 1 / exp); \n            p.lineTo(x, -points[x]);\n        }\n\n        \n        for (int x = 0; x <= a; x++)\n            p.lineTo(x, points[x]);\n\n        for (int x = a; x >= 0; x--)\n            p.lineTo(-x, points[x]);\n\n        for (int x = 0; x <= a; x++)\n            p.lineTo(-x, -points[x]);\n\n        g.translate(getWidth() / 2, getHeight() / 2);\n        g.setStroke(new BasicStroke(2));\n\n        g.setColor(new Color(0x25B0C4DE, true));\n        g.fill(p);\n\n        g.setColor(new Color(0xB0C4DE)); \n        g.draw(p);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n                RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n\n        drawGrid(g);\n        drawLegend(g);\n        drawEllipse(g);\n    }\n\n    @Override\n    public void stateChanged(ChangeEvent e) {\n        JSlider source = (JSlider) e.getSource();\n        exp = source.getValue() / 2.0;\n        repaint();\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Super Ellipse\");\n            f.setResizable(false);\n            SuperEllipse panel = new SuperEllipse();\n            f.add(panel, BorderLayout.CENTER);\n\n            JSlider exponent = new JSlider(JSlider.HORIZONTAL, 1, 9, 5);\n            exponent.addChangeListener(panel);\n            exponent.setMajorTickSpacing(1);\n            exponent.setPaintLabels(true);\n            exponent.setBackground(Color.white);\n            exponent.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));\n\n            Hashtable<Integer, JLabel> labelTable = new Hashtable<>();\n            for (int i = 1; i < 10; i++)\n                labelTable.put(i, new JLabel(String.valueOf(i * 0.5)));\n            exponent.setLabelTable(labelTable);\n\n            f.add(exponent, BorderLayout.SOUTH);\n\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 344179, "name": "Mutex", "source": "Translate Haskell to Java: takeMVar :: MVar a -> IO a\nputMVar :: MVar a -> a -> IO ()\ntryTakeMVar :: MVar a -> IO (Maybe a)\ntryPutMVar :: MVar a -> a -> IO Bool\n", "target": "import java.util.concurrent.Semaphore;\n\npublic class VolatileClass{\n   public Semaphore mutex = new Semaphore(1); \n                                              \n   public void needsToBeSynched(){\n      \n   }\n   \n}\n"}
{"id": 344180, "name": "Jaro similarity", "source": "Translate Haskell to Java: import Data.List (elemIndex, intercalate, sortOn)\nimport Data.Maybe (mapMaybe)\nimport Text.Printf (printf)\n\n\n\njaro :: Ord a => [a] -> [a] -> Float\njaro x y\n  | 0 == m = 0\n  | otherwise =\n    (1 / 3)\n      * ( (m / s1) + (m / s2) + ((m - t) / m))\n  where\n    f = fromIntegral . length\n    [m, t] =\n      [f, fromIntegral . transpositions]\n        <*> [matches x y]\n    [s1, s2] = [f] <*> [x, y]\n\nmatches :: Eq a => [a] -> [a] -> [(Int, a)]\nmatches s1 s2 =\n  let [(l1, xs), (l2, ys)] =\n        sortOn\n          fst\n          ((length >>= (,)) <$> [s1, s2])\n      r = quot l2 2 - 1\n   in mapMaybe\n        ( \\(c, n) ->\n            \n\n            let offset = max 0 (n - (r + 1))\n             in \n                elemIndex c (drop offset (take (n + r) ys))\n                  >>= (\\i -> Just (offset + i, c))\n        )\n        (zip xs [1 ..])\n\ntranspositions :: Ord a => [(Int, a)] -> Int\ntranspositions =\n  length\n    . filter (uncurry (>))\n    . (zip <*> tail)\n\n\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n    fmap\n      ( \\(s1, s2) ->\n          intercalate\n            \" -> \"\n            [s1, s2, printf \"%.3f\\n\" $ jaro s1 s2]\n      )\n      [ (\"DWAYNE\", \"DUANE\"),\n        (\"MARTHA\", \"MARHTA\"),\n        (\"DIXON\", \"DICKSONX\"),\n        (\"JELLYFISH\", \"SMELLYFISH\")\n      ]\n", "target": "public class JaroDistance {\n    public static double jaro(String s, String t) {\n        int s_len = s.length();\n        int t_len = t.length();\n\n        if (s_len == 0 && t_len == 0) return 1;\n\n        int match_distance = Integer.max(s_len, t_len) / 2 - 1;\n\n        boolean[] s_matches = new boolean[s_len];\n        boolean[] t_matches = new boolean[t_len];\n\n        int matches = 0;\n        int transpositions = 0;\n\n        for (int i = 0; i < s_len; i++) {\n            int start = Integer.max(0, i-match_distance);\n            int end = Integer.min(i+match_distance+1, t_len);\n\n            for (int j = start; j < end; j++) {\n                if (t_matches[j]) continue;\n                if (s.charAt(i) != t.charAt(j)) continue;\n                s_matches[i] = true;\n                t_matches[j] = true;\n                matches++;\n                break;\n            }\n        }\n\n        if (matches == 0) return 0;\n\n        int k = 0;\n        for (int i = 0; i < s_len; i++) {\n            if (!s_matches[i]) continue;\n            while (!t_matches[k]) k++;\n            if (s.charAt(i) != t.charAt(k)) transpositions++;\n            k++;\n        }\n\n        return (((double)matches / s_len) +\n                ((double)matches / t_len) +\n                (((double)matches - transpositions/2.0) / matches)) / 3.0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(jaro(   \"MARTHA\",      \"MARHTA\"));\n        System.out.println(jaro(    \"DIXON\",    \"DICKSONX\"));\n        System.out.println(jaro(\"JELLYFISH\",  \"SMELLYFISH\"));\n    }\n}\n"}
{"id": 344181, "name": "Odd word problem", "source": "Translate Haskell to Java: import System.IO\n       (BufferMode(..), getContents, hSetBuffering, stdin, stdout)\nimport Data.Char (isAlpha)\n\nsplit :: String -> (String, String)\nsplit = span isAlpha\n\nparse :: String -> String\nparse [] = []\nparse l =\n  let (a, w) = split l\n      (b, x) = splitAt 1 w\n      (c, y) = split x\n      (d, z) = splitAt 1 y\n  in a <> b <> reverse c <> d <> parse z\n\nmain :: IO ()\nmain =\n  hSetBuffering stdin NoBuffering >> hSetBuffering stdout NoBuffering >> getContents >>=\n  putStr . takeWhile (/= '.') . parse >>\n  putStrLn \".\"\n", "target": "public class OddWord {\n    interface CharHandler {\n\tCharHandler handle(char c) throws Exception;\n    }\n    final CharHandler fwd = new CharHandler() {\n\tpublic CharHandler handle(char c) {\n\t    System.out.print(c);\n\t    return (Character.isLetter(c) ? fwd : rev);\n\t}\n    };\n    class Reverser extends Thread implements CharHandler {\n\tReverser() {\n\t    setDaemon(true);\n\t    start();\n\t}\n\tprivate Character ch; \n\tprivate char recur() throws Exception {\n\t    notify();\n\t    while (ch == null) wait();\n\t    char c = ch, ret = c;\n\t    ch = null;\n\t    if (Character.isLetter(c)) {\n\t\tret = recur();\n\t\tSystem.out.print(c);\n\t    }\n\t    return ret;\n\t}\n\tpublic synchronized void run() {\n\t    try {\n\t\twhile (true) {\n\t\t    System.out.print(recur());\n\t\t    notify();\n\t\t}\n\t    } catch (Exception e) {}\n\t}\n\tpublic synchronized CharHandler handle(char c) throws Exception {\n\t    while (ch != null) wait();\n\t    ch = c;\n\t    notify();\n\t    while (ch != null) wait();\n\t    return (Character.isLetter(c) ? rev : fwd);\n\t}\n    }\n    final CharHandler rev = new Reverser();\n\n    public void loop() throws Exception {\n\tCharHandler handler = fwd;\n\tint c;\n\twhile ((c = System.in.read()) >= 0) {\n\t    handler = handler.handle((char) c);\n\t}\n    }\n\n    public static void main(String[] args) throws Exception {\n\tnew OddWord().loop();\n    }\n}\n"}
{"id": 344182, "name": "Pseudo-random numbers_PCG32", "source": "Translate Haskell to Java: import Data.Bits\nimport Data.Word\nimport System.Random\nimport Data.List\n\ndata PCGen = PCGen !Word64 !Word64 \n\nmkPCGen state sequence =\n  let\n    n = 6364136223846793005 :: Word64 \n    inc = (sequence `shiftL` 1) .|. 1 :: Word64 \n  in PCGen ((inc + state)*n + inc) inc \n\ninstance RandomGen PCGen where\n   next (PCGen state inc) =\n     let\n       n = 6364136223846793005 :: Word64\n       xs = fromIntegral $ ((state `shiftR` 18) `xor` state) `shiftR` 27 :: Word32\n       rot = fromIntegral $ state `shiftR` 59 :: Int\n     in (fromIntegral $ (xs `shiftR` rot) .|. (xs `shiftL` ((-rot) .&. 31))\n        , PCGen (state * n + inc) inc)\n\n   split _ = error \"PCG32 is not splittable\"\n\nrandoms' :: RandomGen g => g -> [Int]\nrandoms' g = unfoldr (pure . next) g\n\ntoFloat n = fromIntegral n / (2^32 - 1)\n", "target": "public class PCG32 {\n    private static final long N = 6364136223846793005L;\n\n    private long state = 0x853c49e6748fea9bL;\n    private long inc = 0xda3e39cb94b95bdbL;\n\n    public void seed(long seedState, long seedSequence) {\n        state = 0;\n        inc = (seedSequence << 1) | 1;\n        nextInt();\n        state = state + seedState;\n        nextInt();\n    }\n\n    public int nextInt() {\n        long old = state;\n        state = old * N + inc;\n        int shifted = (int) (((old >>> 18) ^ old) >>> 27);\n        int rot = (int) (old >>> 59);\n        return (shifted >>> rot) | (shifted << ((~rot + 1) & 31));\n    }\n\n    public double nextFloat() {\n        var u = Integer.toUnsignedLong(nextInt());\n        return (double) u / (1L << 32);\n    }\n\n    public static void main(String[] args) {\n        var r = new PCG32();\n\n        r.seed(42, 54);\n        System.out.println(Integer.toUnsignedString(r.nextInt()));\n        System.out.println(Integer.toUnsignedString(r.nextInt()));\n        System.out.println(Integer.toUnsignedString(r.nextInt()));\n        System.out.println(Integer.toUnsignedString(r.nextInt()));\n        System.out.println(Integer.toUnsignedString(r.nextInt()));\n        System.out.println();\n\n        int[] counts = {0, 0, 0, 0, 0};\n        r.seed(987654321, 1);\n        for (int i = 0; i < 100_000; i++) {\n            int j = (int) Math.floor(r.nextFloat() * 5.0);\n            counts[j]++;\n        }\n\n        System.out.println(\"The counts for 100,000 repetitions are:\");\n        for (int i = 0; i < counts.length; i++) {\n            System.out.printf(\"  %d\u00a0: %d\\n\", i, counts[i]);\n        }\n    }\n}\n"}
{"id": 344183, "name": "Summarize and say sequence", "source": "Translate Haskell to Java: import Data.Set (Set, member, insert, empty)\nimport Data.List (group, sort)\n\nstep :: String -> String\nstep = concatMap (\\list -> show (length list) ++ [head list]) . group . sort\n\nfindCycle :: (Ord a) => [a] -> [a]\nfindCycle = aux empty where\n\taux set (x : xs)\n\t\t| x `member` set = []\n\t\t| otherwise = x : aux (insert x set) xs\n\nselect :: [[a]] -> [[a]]\nselect = snd . foldl (\\(len, acc) xs -> case len `compare` length xs of\n\t\tLT -> (length xs, [xs])\n\t\tEQ -> (len, xs : acc)\n\t\tGT -> (len, acc)) (0, [])\n\nmain :: IO ()\nmain = mapM_ (mapM_ print) $ \n\tselect $ \n\tmap findCycle $ \n\tmap (iterate step) $ \n\tmap show \n\t[1..1000000] \n", "target": "import java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.IntStream;\n\npublic class SelfReferentialSequence {\n\n    static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);\n\n    public static void main(String[] args) {\n        Seeds res = IntStream.range(0, 1000_000)\n                .parallel()\n                .mapToObj(n -> summarize(n, false))\n                .collect(Seeds::new, Seeds::accept, Seeds::combine);\n\n        System.out.println(\"Seeds:\");\n        res.seeds.forEach(e -> System.out.println(Arrays.toString(e)));\n\n        System.out.println(\"\\nSequence:\");\n        summarize(res.seeds.get(0)[0], true);\n    }\n\n    static int[] summarize(int seed, boolean display) {\n        String n = String.valueOf(seed);\n\n        String k = Arrays.toString(n.chars().sorted().toArray());\n        if (!display && cache.get(k) != null)\n            return new int[]{seed, cache.get(k)};\n\n        Set<String> seen = new HashSet<>();\n        StringBuilder sb = new StringBuilder();\n\n        int[] freq = new int[10];\n\n        while (!seen.contains(n)) {\n            seen.add(n);\n\n            int len = n.length();\n            for (int i = 0; i < len; i++)\n                freq[n.charAt(i) - '0']++;\n\n            sb.setLength(0);\n            for (int i = 9; i >= 0; i--) {\n                if (freq[i] != 0) {\n                    sb.append(freq[i]).append(i);\n                    freq[i] = 0;\n                }\n            }\n            if (display)\n                System.out.println(n);\n            n = sb.toString();\n        }\n\n        cache.put(k, seen.size());\n\n        return new int[]{seed, seen.size()};\n    }\n\n    static class Seeds {\n        int largest = Integer.MIN_VALUE;\n        List<int[]> seeds = new ArrayList<>();\n\n        void accept(int[] s) {\n            int size = s[1];\n            if (size >= largest) {\n                if (size > largest) {\n                    largest = size;\n                    seeds.clear();\n                }\n                seeds.add(s);\n            }\n        }\n\n        void combine(Seeds acc) {\n            acc.seeds.forEach(this::accept);\n        }\n    }\n}\n"}
{"id": 344184, "name": "Koch curve", "source": "Translate Haskell to Java: import Data.Bifunctor (bimap)\nimport Text.Printf (printf)\n\n\nkochSnowflake ::\n  Int ->\n  (Float, Float) ->\n  (Float, Float) ->\n  [(Float, Float)]\nkochSnowflake n a b =\n  concat $\n    zipWith (kochCurve n) points (xs <> [x])\n  where\n    points@(x : xs) = [a, equilateralApex a b, b]\n\nkochCurve ::\n  Int ->\n  (Float, Float) ->\n  (Float, Float) ->\n  [(Float, Float)]\nkochCurve n ab xy = ab : go n (ab, xy)\n  where\n    go 0 (_, xy) = [xy]\n    go n (ab, xy) =\n      let (mp, mq) = midThirdOfLine ab xy\n          points@(_ : xs) =\n            [ ab,\n              mp,\n              equilateralApex mp mq,\n              mq,\n              xy\n            ]\n       in go (pred n) =<< zip points xs\n\nequilateralApex ::\n  (Float, Float) ->\n  (Float, Float) ->\n  (Float, Float)\nequilateralApex = rotatedPoint (pi / 3)\n\nrotatedPoint ::\n  Float ->\n  (Float, Float) ->\n  (Float, Float) ->\n  (Float, Float)\nrotatedPoint theta (ox, oy) (a, b) = (ox + dx, oy - dy)\n  where\n    (dx, dy) = rotatedVector theta (a - ox, oy - b)\n\nrotatedVector :: Float -> (Float, Float) -> (Float, Float)\nrotatedVector angle (x, y) =\n  ( x * cos angle - y * sin angle,\n    x * sin angle + y * cos angle\n  )\n\nmidThirdOfLine ::\n  (Float, Float) ->\n  (Float, Float) ->\n  ((Float, Float), (Float, Float))\nmidThirdOfLine (a, b) (x, y) = (p, f p)\n  where\n    (dx, dy) = ((x - a) / 3, (y - b) / 3)\n    f = bimap (dx +) (dy +)\n    p = f (a, b)\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n    svgFromPoints 1024 $\n      kochSnowflake 4 (200, 600) (800, 600)\n\n\nsvgFromPoints :: Int -> [(Float, Float)] -> String\nsvgFromPoints w xys =\n  unlines\n    [ \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\",\n      unwords\n        [ \"width=\\\"512\\\" height=\\\"512\\\" viewBox=\\\"5 5\",\n          sw,\n          sw,\n          \"\\\"> \"\n        ],\n      \"<path d=\\\"M\" <> points <> \"\\\" \",\n      unwords [\n        \"stroke-width=\\\"2\\\"\",\n        \"stroke=\\\"red\\\"\",\n        \"fill=\\\"transparent\\\"/>\"\n      ],\n      \"</svg>\"\n    ]\n  where\n    sw = show w\n    showN = printf \"%.2g\"\n    points =\n      ( unwords\n          . fmap\n            ( ((<>) . showN . fst)\n                <*> ((' ' :) . showN . snd)\n            )\n      )\n        xys\n", "target": "int l = 300;\n\nvoid setup() {\n  size(400, 400);\n  background(0, 0, 255);\n  stroke(255);\n  \n  translate(width/2.0, height/2.0);\n  \n  translate(-l/2.0, l*sqrt(3)/6.0);\n  for (int i = 1; i <= 3; i++) {\n    kcurve(0, l);\n    rotate(radians(120));\n    translate(-l, 0);\n  }\n}\n\nvoid kcurve(float x1, float x2) {\n  float s = (x2-x1)/3;\n  if (s < 5) {\n    pushMatrix();\n    translate(x1, 0);\n    line(0, 0, s, 0);\n    line(2*s, 0, 3*s, 0);\n    translate(s, 0);\n    rotate(radians(60));\n    line(0, 0, s, 0);\n    translate(s, 0);\n    rotate(radians(-120));\n    line(0, 0, s, 0);\n    popMatrix();\n    return;\n  }\n  pushMatrix();\n  translate(x1, 0);\n  kcurve(0, s);\n  kcurve(2*s, 3*s);\n  translate(s, 0);\n  rotate(radians(60));\n  kcurve(0, s);\n  translate(s, 0);\n  rotate(radians(-120));\n  kcurve(0, s);\n  popMatrix();\n}\n"}
{"id": 344185, "name": "Pseudo-random numbers_Xorshift star", "source": "Translate Haskell to Java: import Data.Bits\nimport Data.Word\nimport System.Random\nimport Data.List\n\nnewtype XorShift = XorShift Word64\n\ninstance RandomGen XorShift where\n   next (XorShift state) = (out newState, XorShift newState)\n     where\n       newState = (\\z -> z `xor` (z `shiftR` 27)) .\n                  (\\z -> z `xor` (z `shiftL` 25)) .\n                  (\\z -> z `xor` (z `shiftR` 12)) $ state\n       out x = fromIntegral $ (x * 0x2545f4914f6cdd1d) `shiftR` 32\n\n   split _ = error \"XorShift is not splittable\"\n\nrandoms' :: RandomGen g => g -> [Int]\nrandoms' = unfoldr (pure . next)\n\ntoFloat n = fromIntegral n / (2^32 - 1)\n", "target": "public class XorShiftStar {\n    private static final long MAGIC = Long.parseUnsignedLong(\"2545F4914F6CDD1D\", 16);\n    private long state;\n\n    public void seed(long num) {\n        state = num;\n    }\n\n    public int nextInt() {\n        long x;\n        int answer;\n\n        x = state;\n        x = x ^ (x >>> 12);\n        x = x ^ (x << 25);\n        x = x ^ (x >>> 27);\n        state = x;\n        answer = (int) ((x * MAGIC) >> 32);\n\n        return answer;\n    }\n\n    public float nextFloat() {\n        return (float) Integer.toUnsignedLong(nextInt()) / (1L << 32);\n    }\n\n    public static void main(String[] args) {\n        var rng = new XorShiftStar();\n        rng.seed(1234567);\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println();\n\n        int[] counts = {0, 0, 0, 0, 0};\n        rng.seed(987654321);\n        for (int i = 0; i < 100_000; i++) {\n            int j = (int) Math.floor(rng.nextFloat() * 5.0);\n            counts[j]++;\n        }\n        for (int i = 0; i < counts.length; i++) {\n            System.out.printf(\"%d: %d\\n\", i, counts[i]);\n        }\n    }\n}\n"}
{"id": 344186, "name": "Numbers with equal rises and falls", "source": "Translate Haskell to Java: import Data.Char\n\npairs :: [a] -> [(a,a)]\npairs (a:b:as) = (a,b):pairs (b:as)\npairs _        = [] \n\nriseEqFall :: Int -> Bool\nriseEqFall n = rel (>) digitPairs == rel (<) digitPairs\n    where rel r = sum . map (fromEnum . uncurry r)\n          digitPairs = pairs $ map digitToInt $ show n\n\na296712 :: [Int]\na296712 = [n | n <- [1..], riseEqFall n]\n\nmain :: IO ()\nmain = do\n\tputStrLn \"The first 200 numbers are: \"\n\tputStrLn $ unwords $ map show $ take 200 a296712\n\tputStrLn \"\"\n\tputStr \"The 10,000,000th number is: \"\n\tputStrLn $ show $ a296712 !! 9999999\n", "target": "public class EqualRisesFalls {\n    public static void main(String[] args) {\n        final int limit1 = 200;\n        final int limit2 = 10000000;\n        System.out.printf(\"The first %d numbers in the sequence are:\\n\", limit1);\n        int n = 0;\n        for (int count = 0; count < limit2; ) {\n            if (equalRisesAndFalls(++n)) {\n                ++count;\n                if (count <= limit1)\n                    System.out.printf(\"%3d%c\", n, count % 20 == 0 ? '\\n' : ' ');\n            }\n        }\n        System.out.printf(\"\\nThe %dth number in the sequence is %d.\\n\", limit2, n);\n    }\n\n    private static boolean equalRisesAndFalls(int n) {\n        int total = 0;\n        for (int previousDigit = -1; n > 0; n /= 10) {\n            int digit = n % 10;\n            if (previousDigit > digit)\n                ++total;\n            else if (previousDigit >= 0 && previousDigit < digit)\n                --total;\n            previousDigit = digit;\n        }\n        return total == 0;\n    }\n}\n"}
{"id": 344187, "name": "Pseudo-random numbers_Combined recursive generator MRG32k3a", "source": "Translate Haskell to Java: import Data.List\n\nrandoms :: Int -> [Int]\nrandoms seed = unfoldr go ([seed,0,0],[seed,0,0])\n  where\n    go (x1,x2) =\n      let x1i = sum (zipWith (*) x1 a1) `mod` m1\n          x2i = sum (zipWith (*) x2 a2) `mod` m2\n      in Just $ ((x1i - x2i) `mod` m1, (x1i:init x1, x2i:init x2))\n    \n    a1 = [0, 1403580, -810728]\n    m1 = 2^32 - 209\n    a2 = [527612, 0, -1370589]\n    m2 = 2^32 - 22853\n\nrandomsFloat = map ((/ (2^32 - 208)) . fromIntegral) . randoms\n", "target": "public class App {\n    private static long mod(long x, long y) {\n        long m = x % y;\n        if (m < 0) {\n            if (y < 0) {\n                return m - y;\n            } else {\n                return m + y;\n            }\n        }\n        return m;\n    }\n\n    public static class RNG {\n        \n        private final long[] a1 = {0, 1403580, -810728};\n        private static final long m1 = (1L << 32) - 209;\n        private long[] x1;\n        \n        private final long[] a2 = {527612, 0, -1370589};\n        private static final long m2 = (1L << 32) - 22853;\n        private long[] x2;\n        \n        private static final long d = m1 + 1;\n\n        public void seed(long state) {\n            x1 = new long[]{state, 0, 0};\n            x2 = new long[]{state, 0, 0};\n        }\n\n        public long nextInt() {\n            long x1i = mod(a1[0] * x1[0] + a1[1] * x1[1] + a1[2] * x1[2], m1);\n            long x2i = mod(a2[0] * x2[0] + a2[1] * x2[1] + a2[2] * x2[2], m2);\n            long z = mod(x1i - x2i, m1);\n\n            \n            x1 = new long[]{x1i, x1[0], x1[1]};\n            \n            x2 = new long[]{x2i, x2[0], x2[1]};\n\n            return z + 1;\n        }\n\n        public double nextFloat() {\n            return 1.0 * nextInt() / d;\n        }\n    }\n\n    public static void main(String[] args) {\n        RNG rng = new RNG();\n\n        rng.seed(1234567);\n        System.out.println(rng.nextInt());\n        System.out.println(rng.nextInt());\n        System.out.println(rng.nextInt());\n        System.out.println(rng.nextInt());\n        System.out.println(rng.nextInt());\n        System.out.println();\n\n        int[] counts = {0, 0, 0, 0, 0};\n        rng.seed(987654321);\n        for (int i = 0; i < 100_000; i++) {\n            int value = (int) Math.floor(rng.nextFloat() * 5.0);\n            counts[value]++;\n        }\n        for (int i = 0; i < counts.length; i++) {\n            System.out.printf(\"%d: %d%n\", i, counts[i]);\n        }\n    }\n}\n"}
{"id": 344188, "name": "Self-describing numbers", "source": "Translate Haskell to Java: import Data.Char\n\ncount :: Int -> [Int] -> Int\ncount x = length . filter (x ==)\n\nisSelfDescribing :: Integer -> Bool\nisSelfDescribing n = nu == f\n  where\n    nu = digitToInt <$> show n\n    f = (`count` nu) <$> [0 .. length nu - 1]\n\nmain :: IO ()\nmain = do\n  print $\n    isSelfDescribing <$>\n    [1210, 2020, 21200, 3211000, 42101000, 521001000, 6210001000]\n  print $ filter isSelfDescribing [0 .. 4000000]\n", "target": "public class SelfDescribingNumbers{\n    public static boolean isSelfDescribing(int a){\n        String s = Integer.toString(a);\n        for(int i = 0; i < s.length(); i++){\n            String s0 = s.charAt(i) + \"\";\n            int b = Integer.parseInt(s0); \n            int count = 0;\n            for(int j = 0; j < s.length(); j++){\n                int temp = Integer.parseInt(s.charAt(j) + \"\");\n                if(temp == i){\n                    count++;\n                }\n                if (count > b) return false;\n            }\n            if(count != b) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args){\n        for(int i = 0; i < 100000000; i++){\n            if(isSelfDescribing(i)){\n                System.out.println(i);\n             }\n        }\n    }\n}\n"}
{"id": 346868, "name": "Range consolidation", "source": "Translate Haskell to C#: import Data.List (intercalate, maximumBy, sort)\nimport Data.Ord (comparing)\n\n\n\nconsolidated :: [(Float, Float)] -> [(Float, Float)]\nconsolidated = foldr go [] . sort . fmap ab\n  where\n    go xy [] = [xy]\n    go xy@(x, y) abetc@((a, b) : etc)\n      | y >= b = xy : etc\n      | y >= a = (x, b) : etc\n      | otherwise = xy : abetc\n    ab (a, b)\n      | a <= b = (a, b)\n      | otherwise = (b, a)\n\n\n\ntests :: [[(Float, Float)]]\ntests =\n  [ [],\n    [(1.1, 2.2)],\n    [(6.1, 7.2), (7.2, 8.3)],\n    [(4, 3), (2, 1)],\n    [(4, 3), (2, 1), (-1, -2), (3.9, 10)],\n    [(1, 3), (-6, -1), (-4, -5), (8, 2), (-6, -6)]\n  ]\n\nmain :: IO ()\nmain =\n  putStrLn $\n    tabulated\n      \"Range consolidations:\"\n      showPairs\n      showPairs\n      consolidated\n      tests\n\n\n\ntabulated ::\n  String ->\n  (a -> String) ->\n  (b -> String) ->\n  (a -> b) ->\n  [a] ->\n  String\ntabulated s xShow fxShow f xs =\n  let w =\n        length $\n          maximumBy\n            (comparing length)\n            (xShow <$> xs)\n      rjust n c s = drop (length s) (replicate n c <> s)\n   in unlines $\n        s :\n        fmap\n          ( ((<>) . rjust w ' ' . xShow)\n              <*> ((\" -> \" <>) . fxShow . f)\n          )\n          xs\n\nshowPairs :: [(Float, Float)] -> String\nshowPairs xs\n  | null xs = \"[]\"\n  | otherwise =\n    '[' :\n    intercalate\n      \", \"\n      (showPair <$> xs)\n      <> \"]\"\n\nshowPair :: (Float, Float) -> String\nshowPair (a, b) =\n  '(' :\n  showNum a\n    <> \", \"\n    <> showNum b\n    <> \")\"\n\nshowNum :: Float -> String\nshowNum n\n  | 0 == (n - fromIntegral (round n)) = show (round n)\n  | otherwise = show n\n", "target": "using static System.Math;\nusing System.Linq;\nusing System;\n\npublic static class RangeConsolidation\n{\n    public static void Main() {\n        foreach (var list in new [] {\n            new[] { (1.1, 2.2) }.ToList(),\n            new[] { (6.1, 7.2), (7.2, 8.3) }.ToList(),\n            new[] { (4d, 3d), (2, 1) }.ToList(),\n            new[] { (4d, 3d), (2, 1), (-1, 2), (3.9, 10) }.ToList(),\n            new[] { (1d, 3d), (-6, -1), (-4, -5), (8, 2), (-6, -6) }.ToList()\n        })\n        {\n            for (int z = list.Count-1; z >= 1; z--) {\n                for (int y = z - 1; y >= 0; y--) {\n                    if (Overlap(list[z], list[y])) {\n                        list[y] = Consolidate(list[z], list[y]);\n                        list.RemoveAt(z);\n                        break;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\", \", list.Select(Normalize).OrderBy(range => range.s)));\n        }\n    }\n\n    private static bool Overlap((double s, double e) left, (double s, double e) right) =>\n        Max(left.s, left.e) > Max(right.s, right.e)\n        ? Max(right.s, right.e) >= Min(left.s, left.e)\n        : Max(left.s, left.e) >= Min(right.s, right.e);\n\n    private static (double s, double e) Consolidate((double s, double e) left, (double s, double e) right) =>\n        (Min(Min(left.s, left.e), Min(right.s, right.e)), Max(Max(left.s, left.e), Max(right.s, right.e)));\n    \n    private static (double s, double e) Normalize((double s, double e) range) =>\n        (Min(range.s, range.e), Max(range.s, range.e));\n}\n"}
{"id": 346869, "name": "Pascal matrix generation", "source": "Translate Haskell to C#: import Data.List (transpose)\nimport System.Environment (getArgs)\nimport Text.Printf (printf)\n\n\npascal :: [[Int]]\npascal = iterate (\\row -> 1 : zipWith (+) row (tail row) ++ [1]) [1]\n\n\npascLow :: Int -> [[Int]]\npascLow n = zipWith (\\row i -> row ++ replicate (n-i) 0) (take n pascal) [1..]\n\n\npascUp :: Int -> [[Int]]\npascUp = transpose . pascLow\n\n\npascSym :: Int -> [[Int]]\npascSym n = take n . map (take n) . transpose $ pascal\n\n\nprintMat :: String -> [[Int]] -> IO ()\nprintMat title mat = do\n  putStrLn $ title ++ \"\\n\"\n  mapM_ (putStrLn . concatMap (printf \" %2d\")) mat\n  putStrLn \"\\n\"\n\nmain :: IO ()\nmain = do\n  ns <- fmap (map read) getArgs\n  case ns of\n    [n] -> do printMat \"Lower triangular\" $ pascLow n\n              printMat \"Upper triangular\" $ pascUp  n\n              printMat \"Symmetric\"        $ pascSym n\n    _   -> error \"Usage: pascmat <number>\"\n", "target": "using System;\n\npublic static class PascalMatrixGeneration\n{\n    public static void Main() {\n        Print(GenerateUpper(5));\n        Console.WriteLine();\n        Print(GenerateLower(5));\n        Console.WriteLine();\n        Print(GenerateSymmetric(5));\n    }\n\n    static int[,] GenerateUpper(int size) {\n        int[,] m = new int[size, size];\n        for (int c = 0; c < size; c++) m[0, c] = 1;\n        for (int r = 1; r < size; r++) {\n            for (int c = r; c < size; c++) {\n                m[r, c] = m[r-1, c-1] + m[r, c-1];\n            }\n        }\n        return m;\n    }\n\n    static int[,] GenerateLower(int size) {\n        int[,] m = new int[size, size];\n        for (int r = 0; r < size; r++) m[r, 0] = 1;\n        for (int c = 1; c < size; c++) {\n            for (int r = c; r < size; r++) {\n                m[r, c] = m[r-1, c-1] + m[r-1, c];\n            }\n        }\n        return m;\n    }\n\n    static int[,] GenerateSymmetric(int size) {\n        int[,] m = new int[size, size];\n        for (int i = 0; i < size; i++) m[0, i] = m[i, 0] = 1;\n        for (int r = 1; r < size; r++) {\n            for (int c = 1; c < size; c++) {\n                m[r, c] = m[r-1, c] + m[r, c-1];\n            }\n        }\n        return m;\n    }\n\n    static void Print(int[,] matrix) {\n        string[,] m = ToString(matrix);\n        int width = m.Cast<string>().Select(s => s.Length).Max();\n        int rows = matrix.GetLength(0), columns = matrix.GetLength(1);\n        for (int row = 0; row < rows; row++) {\n            Console.WriteLine(\"|\" + string.Join(\" \", Range(0, columns).Select(column => m[row, column].PadLeft(width, ' '))) + \"|\");\n        }\n    }\n\n    static string[,] ToString(int[,] matrix) {\n        int rows = matrix.GetLength(0), columns = matrix.GetLength(1);\n        string[,] m = new string[rows, columns];\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < columns; c++) {\n                m[r, c] = matrix[r, c].ToString();\n            }\n        }\n        return m;\n    }\n    \n}\n"}
{"id": 346870, "name": "Mad Libs", "source": "Translate Haskell to C#: import System.IO (stdout, hFlush)\n\nimport System.Environment (getArgs)\n\nimport qualified Data.Map as M (Map, lookup, insert, empty)\n\ngetLines :: IO [String]\ngetLines = reverse <$> getLines_ []\n  where\n    getLines_ xs = do\n      line <- getLine\n      case line of\n        [] -> return xs\n        _ -> getLines_ $ line : xs\n\nprompt :: String -> IO String\nprompt p = putStr p >> hFlush stdout >> getLine\n\ngetKeyword :: String -> Maybe String\ngetKeyword ('<':xs) = getKeyword_ xs []\n  where\n    getKeyword_ [] _ = Nothing\n    getKeyword_ (x:'>':_) acc = Just $ '<' : reverse ('>' : x : acc)\n    getKeyword_ (x:xs) acc = getKeyword_ xs $ x : acc\ngetKeyword _ = Nothing\n\nparseText :: String -> M.Map String String -> IO String\nparseText [] _ = return []\nparseText line@(l:lx) keywords =\n  case getKeyword line of\n    Nothing -> (l :) <$> parseText lx keywords\n    Just keyword -> do\n      let rest = drop (length keyword) line\n      case M.lookup keyword keywords of\n        Nothing -> do\n          newword <- prompt $ \"Enter a word for \" ++ keyword ++ \": \"\n          rest_ <- parseText rest $ M.insert keyword newword keywords\n          return $ newword ++ rest_\n        Just knownword -> do\n          rest_ <- parseText rest keywords\n          return $ knownword ++ rest_\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  nlines <-\n    case args of\n      [] -> unlines <$> getLines\n      arg:_ -> readFile arg\n  nlines_ <- parseText nlines M.empty\n  putStrLn \"\"\n  putStrLn nlines_\n", "target": "using System;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace MadLibs_RosettaCode\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tstring madLibs = \n@\"Write a program to create a Mad Libs like story.\nThe program should read an arbitrary multiline story from input.\nThe story will be terminated with a blank line.\nThen, find each replacement to be made within the story, \nask the user for a word to replace it with, and make all the replacements.\nStop when there are none left and print the final story.\nThe input should be an arbitrary story in the form:\n<name> went for a walk in the park. <he or she>\nfound a <noun>. <name> decided to take it home.\nGiven this example, it should then ask for a name, \na he or she and a noun (<name> gets replaced both times with the same value).\";\n\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tRegex pattern = new Regex(@\"\\<(.*?)\\>\");\n\t\t\tstring storyLine;\n\t\t\tstring replacement;\n\n\t\t\tConsole.WriteLine(madLibs + Environment.NewLine + Environment.NewLine);\n\t\t\tConsole.WriteLine(\"Enter a story: \");\n\n\t\t\t\n\t\t\tdo\n\t\t\t{\n\t\t\t\tstoryLine = Console.ReadLine();\n\t\t\t\tsb.Append(storyLine + Environment.NewLine);\n\t\t\t} while (!string.IsNullOrEmpty(storyLine) && !string.IsNullOrWhiteSpace(storyLine));\n\n\t\t\t\n\t\t\tMatch nameMatch = pattern.Matches(sb.ToString()).OfType<Match>().Where(x => x.Value.Equals(\"<name>\")).Select(x => x.Value).Distinct() as Match;\n\t\t\tif(nameMatch != null)\n\t\t\t{\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine(\"Enter value for: \" + nameMatch.Value);\n\t\t\t\t\treplacement = Console.ReadLine();\n\t\t\t\t} while (string.IsNullOrEmpty(replacement) || string.IsNullOrWhiteSpace(replacement));\n\t\t\t\tsb.Replace(nameMatch.Value, replacement);\n\t\t\t}\n\n\t\t\tforeach (Match match in pattern.Matches(sb.ToString()))\n\t\t\t{\n\t\t\t\treplacement = string.Empty;\n\t\t\t\t\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine(\"Enter value for: \" + match.Value);\n\t\t\t\t\treplacement = Console.ReadLine();\n\t\t\t\t} while (string.IsNullOrEmpty(replacement) || string.IsNullOrWhiteSpace(replacement));\n\n\t\t\t\tint location = sb.ToString().IndexOf(match.Value);\n\t\t\t\tsb.Remove(location, match.Value.Length).Insert(location, replacement);\n\t\t\t}\n\n\t\t\tConsole.WriteLine(Environment.NewLine + Environment.NewLine + \"--[ Here's your story! ]--\");\n\t\t\tConsole.WriteLine(sb.ToString());\n\t\t}\n\t}\n}\n"}
{"id": 346871, "name": "Shortest common supersequence", "source": "Translate Haskell to C#: scs :: Eq a  => [a] -> [a] -> [a]\nscs [] ys = ys\nscs xs [] = xs\nscs xss@(x:xs) yss@(y:ys)\n  | x == y = x : scs xs ys\n  | otherwise = ws\n      where\n      us = scs xs yss\n      vs = scs xss ys\n      ws  | length us < length vs = x : us\n          | otherwise = y : vs\n\nmain = putStrLn $ scs \"abcbdab\" \"bdcaba\"\n", "target": "public class ShortestCommonSupersequence\n{\n    Dictionary<(string, string), string> cache = new();\n\n    public string scs(string x, string y)\n    {\n        if (x.Length == 0) return y;\n        if (y.Length == 0) return x;\n\n        if (cache.TryGetValue((x, y), out var result)) return result;\n\n        if (x[0] == y[0])\n        {\n            return cache[(x, y)] = x[0] + scs(x.Substring(1), y.Substring(1));\n        }\n\n        var xr = scs(x.Substring(1), y);\n        var yr = scs(x, y.Substring(1));\n        if (yr.Length <= xr.Length)\n        {\n            return cache[(x, y)] = y[0] + yr;\n        }\n        else\n        {\n            return cache[(x, y)] = x[0] + xr;\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        var scs = new ShortestCommonSupersequence();\n        Console.WriteLine(scs.scs(\"abcbdab\", \"bdcaba\"));\n    }\n}\n"}
{"id": 346872, "name": "Long year", "source": "Translate Haskell to C#: import Data.Time.Calendar (fromGregorian)\nimport Data.Time.Calendar.WeekDate (toWeekDate)\n\nlongYear :: Integer -> Bool\nlongYear y =\n  let (_, w, _) = toWeekDate $ fromGregorian y 12 28\n   in 52 < w\n\nmain :: IO ()\nmain = mapM_ print $ filter longYear [2000 .. 2100]\n", "target": "using static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Globalization;\n\npublic static class Program\n{\n    public static void Main()\n    {\n        WriteLine(\"Long years in the 21st century:\");\n        WriteLine(string.Join(\" \", 2000.To(2100).Where(y => ISOWeek.GetWeeksInYear(y) == 53)));\n    }\n    \n    public static IEnumerable<int> To(this int start, int end) {\n        for (int i = start; i < end; i++) yield return i;\n    }\n    \n}\n"}
{"id": 346873, "name": "Mian-Chowla sequence", "source": "Translate Haskell to C#: import Data.Set (Set, fromList, insert, member)\n\n\nmianChowlas :: Int -> [Int]\nmianChowlas =\n  reverse . snd . (iterate nextMC (fromList [2], [1]) !!) . subtract 1\n\nnextMC :: (Set Int, [Int]) -> (Set Int, [Int])\nnextMC (sumSet, mcs@(n:_)) =\n  (foldr insert sumSet ((2 * m) : fmap (m +) mcs), m : mcs)\n  where\n    valid x = not $ any (flip member sumSet . (x +)) mcs\n    m = until valid succ n\n\n\nmain :: IO ()\nmain =\n  (putStrLn . unlines)\n    [ \"First 30 terms of the Mian-Chowla series:\"\n    , show (mianChowlas 30)\n    , []\n    , \"Terms 91 to 100 of the Mian-Chowla series:\"\n    , show $ drop 90 (mianChowlas 100)\n    ]\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nstatic class Program {\n    static int[] MianChowla(int n) {\n        int[] mc = new int[n - 1 + 1];\n        HashSet<int> sums = new HashSet<int>(), ts = new HashSet<int>();\n        int sum; mc[0] = 1; sums.Add(2);\n        for (int i = 1; i <= n - 1; i++) {\n            for (int j = mc[i - 1] + 1; ; j++) {\n                mc[i] = j;\n                for (int k = 0; k <= i; k++) {\n                    sum = mc[k] + j;\n                    if (sums.Contains(sum)) { ts.Clear(); break; }\n                    ts.Add(sum);\n                }\n                if (ts.Count > 0) { sums.UnionWith(ts); break; }\n            }\n        }\n        return mc;\n    }\n\n    static void Main(string[] args)\n    {\n        const int n = 100; Stopwatch sw = new Stopwatch();\n        string str = \" of the Mian-Chowla sequence are:\\n\";\n        sw.Start(); int[] mc = MianChowla(n); sw.Stop();\n        Console.Write(\"The first 30 terms{1}{2}{0}{0}Terms 91 to 100{1}{3}{0}{0}\" +\n            \"Computation time was {4}ms.{0}\", '\\n', str, string.Join(\" \", mc.Take(30)),\n            string.Join(\" \", mc.Skip(n - 10)), sw.ElapsedMilliseconds);\n    }\n}\n"}
{"id": 346874, "name": "Water collected between towers", "source": "Translate Haskell to C#: import Data.Vector.Unboxed (Vector)\nimport qualified Data.Vector.Unboxed as V\n\nwaterCollected :: Vector Int -> Int\nwaterCollected =\n  V.sum .            \n  V.filter (> 0) .   \n  (V.zipWith (-) =<< \n   (V.zipWith min .  \n    V.scanl1 max <*> \n    V.scanr1 max))   \n\nmain :: IO ()\nmain =\n  mapM_\n    (print . waterCollected . V.fromList)\n    [ [1, 5, 3, 7, 2]\n    , [5, 3, 7, 2, 6, 4, 5, 9, 1, 2]\n    , [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1]\n    , [5, 5, 5, 5]\n    , [5, 6, 7, 8]\n    , [8, 7, 7, 6]\n    , [6, 7, 10, 7, 6]\n    ]\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        int[][] wta = {\n            new int[] {1, 5, 3, 7, 2},   new int[] { 5, 3, 7, 2, 6, 4, 5, 9, 1, 2 },\n            new int[] { 2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1 },\n            new int[] { 5, 5, 5, 5 },    new int[] { 5, 6, 7, 8 },\n            new int[] { 8, 7, 7, 6 },    new int[] { 6, 7, 10, 7, 6 }};\n        string blk, lf = \"\\n\", tb = \"\u2588\u2588\", wr = \"\u2248\u2248\", mt = \"  \";\n        for (int i = 0; i < wta.Length; i++)\n        {\n            int bpf; blk = \"\"; do\n            {\n                string floor = \"\"; bpf = 0; for (int j = 0; j < wta[i].Length; j++)\n                {\n                    if (wta[i][j] > 0)\n                    {    floor += tb; wta[i][j] -= 1; bpf += 1; }\n                    else floor += (j > 0 && j < wta[i].Length - 1 ? wr : mt);\n                }\n                if (bpf > 0) blk = floor + lf + blk;\n            } while (bpf > 0);\n            while (blk.Contains(mt + wr)) blk = blk.Replace(mt + wr, mt + mt);\n            while (blk.Contains(wr + mt)) blk = blk.Replace(wr + mt, mt + mt);\n            if (args.Length > 0) System.Console.Write(\"\\n{0}\", blk);\n            System.Console.WriteLine(\"Block {0} retains {1,2} water units.\",\n                i + 1, (blk.Length - blk.Replace(wr, \"\").Length) / 2);\n        }\n    }\n}\n"}
{"id": 346875, "name": "FASTA format", "source": "Translate Haskell to C#: import Data.List ( groupBy )\n\nparseFasta :: FilePath -> IO ()\nparseFasta fileName = do\n  file <- readFile fileName\n  let pairedFasta = readFasta $ lines file\n  mapM_ (\\(name, code) -> putStrLn $ name ++ \": \" ++ code) pairedFasta\n\nreadFasta :: [String] -> [(String, String)]\nreadFasta = pair . map concat . groupBy (\\x y -> notName x && notName y)\n where\n  notName :: String -> Bool\n  notName = (/=) '>' . head\n\n  pair :: [String] -> [(String, String)]\n  pair []           = []\n  pair (x : y : xs) = (drop 1 x, y) : pair xs\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\n\nclass Program\n{\n    public class FastaEntry\n    {\n        public string Name { get; set; }\n        public StringBuilder Sequence { get; set; }\n    }\n\n    static IEnumerable<FastaEntry> ParseFasta(StreamReader fastaFile)\n    {\n        FastaEntry f = null;\n        string line;\n        while ((line = fastaFile.ReadLine()) != null)\n        {\n            \n            if (line.StartsWith(\";\"))\n                continue;\n\n            if (line.StartsWith(\">\"))\n            {\n                if (f != null)\n                    yield return f;\n                f = new FastaEntry { Name = line.Substring(1), Sequence = new StringBuilder() };\n            }\n            else if (f != null)\n                f.Sequence.Append(line);\n        }\n        yield return f;\n    }\n\n    static void Main(string[] args)\n    {\n        try\n        {\n            using (var fastaFile = new StreamReader(\"fasta.txt\"))\n            {\n                foreach (FastaEntry f in ParseFasta(fastaFile))\n                    Console.WriteLine(\"{0}: {1}\", f.Name, f.Sequence);\n            }\n        }\n        catch (FileNotFoundException e)\n        {\n            Console.WriteLine(e);\n        }\n        Console.ReadLine();\n    }\n}\n"}
{"id": 346876, "name": "MAC vendor lookup", "source": "Translate Haskell to C#: #!/usr/bin/env stack\n\n\n\n\nimport Control.Exception (try)\nimport Control.Monad (forM_)\nimport qualified Data.ByteString.Lazy.Char8 as L8 (ByteString, unpack)\nimport Network.HTTP.Client\n  (Manager, parseRequest, httpLbs, responseStatus, responseBody,\n   newManager, defaultManagerSettings, Response, HttpException)\nimport Network.HTTP.Types.Status (statusIsSuccessful, notFound404)\nimport System.Environment (getArgs)\nimport Text.Printf (printf)\n\nfetchURL :: Manager\n         -> String\n         -> IO (Either HttpException (Response L8.ByteString))\nfetchURL mgr url = try $ do\n  req <- parseRequest url\n  httpLbs req mgr\n\nlookupMac :: Manager -> String -> IO String\nlookupMac mgr mac = do\n  eth <- fetchURL mgr $ \"http://api.macvendors.com/\" ++ mac\n  return $ case eth of\n             Left _ -> \"null\"\n             Right resp -> let body = responseBody resp\n                               status = responseStatus resp\n                           in if | status == notFound404 -> \"N/A\"\n                                 | not (statusIsSuccessful status) -> \"null\"\n                                 | otherwise -> L8.unpack body\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  mgr <- newManager defaultManagerSettings\n  forM_ args $ \\mac -> do\n    putStr $ printf \"%-17s\" mac ++ \" = \"\n    vendor <- lookupMac mgr mac\n    putStrLn vendor\n", "target": "using System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task<string> LookupMac(string MacAddress)\n    {\n        var uri = new Uri(\"http:\n        using (var wc = new HttpClient())\n            return await wc.GetStringAsync(uri);\n    }\n    static void Main(string[] args)\n    {\n        foreach (var mac in new string[] { \"88:53:2E:67:07:BE\", \"FC:FB:FB:01:FA:21\", \"D4:F4:6F:C9:EF:8D\" })\n            Console.WriteLine(mac + \"\\t\" + LookupMac(mac).Result);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 346877, "name": "Magic 8-ball", "source": "Translate Haskell to C#: import           System.Random (getStdRandom, randomR)\nimport           Control.Monad (forever)\n\nanswers :: [String]\nanswers =\n  [ \"It is certain\"\n  , \"It is decidedly so\"\n  , \"Without a doubt\"\n  , \"Yes, definitely\"\n  , \"You may rely on it\"\n  , \"As I see it, yes\"\n  , \"Most likely\"\n  , \"Outlook good\"\n  , \"Signs point to yes\"\n  , \"Yes\"\n  , \"Reply hazy, try again\"\n  , \"Ask again later\"\n  , \"Better not tell you now\"\n  , \"Cannot predict now\"\n  , \"Concentrate and ask again\"\n  , \"Don't bet on it\"\n  , \"My reply is no\"\n  , \"My sources say no\"\n  , \"Outlook not so good\"\n  , \"Very doubtful\"]\n\nmain :: IO ()\nmain = do\n  putStrLn \"Hello. The Magic 8 Ball knows all. Type your question.\"\n  forever $ do\n    getLine\n    n <- getStdRandom (randomR (0, pred $ length answers))\n    putStrLn $ answers !! n\n", "target": "using System;\n\nnamespace newProg\n{\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] answers =\n            {\n                \"It is certain.\",\n                \"It is decidedly so.\",\n                \"Without a doubt.\",\n                \"Yes \u2013 definitely.\",\n                \"You may rely on it.\",\n                \"As I see it, yes.\",\n                \"Most likely.\",\n                \"Outlook good.\",\n                \"Yes.\",\n                \"Signs point to yes.\",\n                \"Reply hazy, try again.\",\n                \"Ask again later\",\n                \"Better not tell you now.\",\n                \"Cannot predict now.\",\n                \"Concentrate and ask again.\",\n                \"Don't count on it.\",\n                \"My reply is no.\",\n                \"My sources say no.\",\n                \"Outlook not so good.\",\n                \"Very doubtful.\"\n            };\n\n            while (true)\n            {\n                Random rnd = new Random();\n                int result = rnd.Next(0, 19);\n\n                Console.WriteLine(\"Magic 8 Ball! Ask question and hit a key for the answer!\");\n\n                string inp = Console.ReadLine();\n                \n                Console.WriteLine(answers[result]);\n\n            }\n        }\n    }\n}\n"}
{"id": 346878, "name": "Validate International Securities Identification Number", "source": "Translate Haskell to C#: module ISINVerification2 where\n\nimport Data.Char (isUpper, isDigit, digitToInt)\n\nverifyISIN :: String -> Bool\nverifyISIN isin =\n  correctFormat isin && mod (oddsum + multiplied_even_sum) 10 == 0\n  where\n    reverted = reverse $ convertToNumber isin\n    theOdds = fst $ collectOddandEven reverted\n    theEvens = snd $ collectOddandEven reverted\n    oddsum = sum $ map digitToInt theOdds\n    multiplied_even_sum = addUpDigits $ map ((* 2) . digitToInt) theEvens\n\ncapitalLetters :: String\ncapitalLetters = ['A','B' .. 'Z']\n\nnumbers :: String\nnumbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\ncorrectFormat :: String -> Bool\ncorrectFormat isin =\n  (length isin == 12) &&\n  all (`elem` capitalLetters) (take 2 isin) &&\n  all (\\c -> elem c capitalLetters || elem c numbers) (drop 2 $ take 11 isin) &&\n  elem (last isin) numbers\n\nconvertToNumber :: String -> String\nconvertToNumber = concatMap convert\n  where\n    convert :: Char -> String\n    convert c =\n      if isDigit c\n        then show $ digitToInt c\n        else show (fromEnum c - 55)\n\ncollectOddandEven :: String -> (String, String)\ncollectOddandEven term\n  | odd $ length term =\n    ( concat\n        [ take 1 $ drop n term\n        | n <- [0,2 .. length term - 1] ]\n    , concat\n        [ take 1 $ drop d term\n        | d <- [1,3 .. length term - 2] ])\n  | otherwise =\n    ( concat\n        [ take 1 $ drop n term\n        | n <- [0,2 .. length term - 2] ]\n    , concat\n        [ take 1 $ drop d term\n        | d <- [1,3 .. length term - 1] ])\n\naddUpDigits :: [Int] -> Int\naddUpDigits list =\n  sum $\n  map\n    (\\d ->\n        if d > 9\n          then sum $ map digitToInt $ show d\n          else d)\n    list\n\nprintSolution :: String -> IO ()\nprintSolution str = do\n  putStr $ str ++ \" is\"\n  if verifyISIN str\n    then putStrLn \" valid\"\n    else putStrLn \" not valid\"\n\nmain :: IO ()\nmain = do\n  let isinnumbers =\n        [ \"US0378331005\"\n        , \"US0373831005\"\n        , \"U50378331005\"\n        , \"US03378331005\"\n        , \"AU0000XVGZA3\"\n        , \"AU0000VXGZA3\"\n        , \"FR0000988040\"\n        ]\n  mapM_ printSolution isinnumbers\n", "target": "using System;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace ValidateIsin\n{\n    public static class IsinValidator\n    {\n        public static bool IsValidIsin(string isin) => \n            IsinRegex.IsMatch(isin) && LuhnTest(Digitize(isin));\n\n        private static readonly Regex IsinRegex = \n            new Regex(\"^[A-Z]{2}[A-Z0-9]{9}\\\\d$\", RegexOptions.Compiled);\n\n        private static string Digitize(string isin) =>\n            string.Join(\"\", isin.Select(c => $\"{DigitValue(c)}\"));\n\n        private static bool LuhnTest(string number) => \n            number.Reverse().Select(DigitValue).Select(Summand).Sum() % 10 == 0;\n\n        private static int Summand(int digit, int i) =>\n            digit + (i % 2) * (digit - digit / 5 * 9);\n\n        private static int DigitValue(char c) =>\n            c >= '0' && c <= '9' \n                ? c - '0' \n                : c - 'A' + 10;\n   }\n\t\n   public class Program\n   {\n        public static void Main() \n        {\n            string[] isins = \n            {\n                \"US0378331005\",\n                \"US0373831005\",\n                \"U50378331005\",\n                \"US03378331005\",\n                \"AU0000XVGZA3\",\n                \"AU0000VXGZA3\",\n                \"FR0000988040\"\n            };\n\n            foreach (string isin in isins) {\n                string validOrNot = IsinValidator.IsValidIsin(isin) ? \"valid\" : \"not valid\";\n                Console.WriteLine($\"{isin} is {validOrNot}\");\n            }\n        }\n    }\n}\n"}
{"id": 346879, "name": "Cycle detection", "source": "Translate Haskell to C#: import Data.List (findIndex)\n\nfindCycle :: Eq a => [a] -> Maybe ([a], Int, Int)\nfindCycle lst =\n  do l <- findCycleLength lst\n     mu <- findIndex (uncurry (==)) $ zip lst (drop l lst)\n     let c = take l $ drop mu lst\n     return (c, l, mu)\n\nfindCycleLength :: Eq a => [a] -> Maybe Int\nfindCycleLength [] = Nothing\nfindCycleLength (x:xs) =\n  let loop _ _ _ [] = Nothing\n      loop pow lam x (y:ys)\n        | x == y     = Just lam\n        | pow == lam = loop (2*pow) 1 y ys\n        | otherwise  = loop pow (1+lam) x ys\n  in loop 1 1 x xs\n", "target": "\n\n\nusing System;\n\nnamespace DetectCycles\n{\n  \n  \n  \n  public class Cycles<T> where T : IEquatable<T>\n  {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    public static Tuple<int,int> FindCycle(T x0, Func<T,T> yielder)\n    {\n      int power, lambda;\n      T tortoise, hare;\n      power = lambda = 1;\n      tortoise = x0;\n      hare = yielder(x0);\n\n      \n      while (!tortoise.Equals (hare)) {\n        if (power == lambda) {\n          tortoise = hare;\n          power *= 2;\n          lambda = 0;  \n        }\n        hare = yielder (hare);\n        lambda += 1;\n      }\n\n      \n      var mu = 0;\n      tortoise = hare = x0;\n      for (var times = 0; times < lambda; times++) \n        hare = yielder (hare);\n      \n      while (!tortoise.Equals (hare)) \n      {\n        tortoise = yielder (tortoise);\n        hare = yielder (hare);\n        mu += 1;\n      }\n\n      return new Tuple<int,int> (lambda, mu);\n    }\n  }\n}\n\n\n\nusing System;\n\nnamespace DetectCycles\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\t\n\t\t\tFunc<int,int> sequence = (int _x) => (_x * _x + 1) % 255;\n\n\t\t\t\n\t\t\tvar x = 3;\n\t\t\tConsole.Write(x);\n\t\t\tfor (var times = 0; times < 40; times++) \n\t\t\t{\n\t\t\t\tx = sequence(x);\n\t\t\t\tConsole.Write(String.Format(\",{0}\", x));\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\n\t\t\t\n\t\t\tvar cycle = Cycles<int>.FindCycle(3, sequence);\n\t\t\tvar clength = cycle.Item1;\n\t\t\tvar cstart = cycle.Item2;\n\t\t\tConsole.Write(String.Format(\"Cycle length = {0}\\nStart index = {1}\\n\", clength, cstart));\n\t\t}\n\t}\n}\n"}
{"id": 346880, "name": "Input_Output for pairs of numbers", "source": "Translate Haskell to C#: main = do\n    contents <- getContents\n    let numberOfLines  =  read.head.lines$ contents\n        nums  =  map (map read.words).take numberOfLines.tail.lines$ contents\n        sums  =  map sum nums\n    mapM_ print sums\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main(string[] args)\n    {\n\tint count = Convert.ToInt32(Console.ReadLine());\n\tfor (int line = 0; line < count; line++) {\n            Console.WriteLine(Console.ReadLine().Split(' ').Sum(i => Convert.ToInt32(i)));\n\t}\n    }\n}\n"}
{"id": 346881, "name": "ABC words", "source": "Translate Haskell to C#: import Data.List (elemIndex)\nimport Data.Maybe (isJust)\n\n\n\nisABC :: String -> Bool\nisABC s =\n  isJust $\n    residue \"bc\" 'a' s\n      >>= residue \"c\" 'b' \n      >>= elemIndex 'c'\n\nresidue :: String -> Char -> String -> Maybe String\nresidue except c = go\n  where\n    go [] = Nothing\n    go (x : xs)\n      | x `elem` except = Nothing\n      | c == x = Just xs\n      | otherwise = go xs\n\n\nmain :: IO ()\nmain =\n  readFile \"unixdict.txt\"\n    >>= mapM_ print . zip [1 ..] . filter isABC . lines\n", "target": "class Program {\n    static void Main(string[] args) { int bi, i = 0; string chars = args.Length < 1 ? \"abc\" : args[0];\n        foreach (var item in System.IO.File.ReadAllLines(\"unixdict.txt\")) {\n            int ai = -1; foreach (var ch in chars)\n                if ((bi = item.IndexOf(ch)) > ai) ai = bi; else goto skip;\n            System.Console.Write(\"{0,3} {1,-18} {2}\", ++i, item, i % 5 == 0 ? \"\\n\" : \"\");\n        skip: ; } }\n}\n"}
{"id": 346882, "name": "Text between", "source": "Translate Haskell to C#: import Control.Monad (join)\nimport Data.Bifunctor (bimap)\nimport Data.List (intercalate)\nimport Data.Maybe (fromMaybe)\nimport Data.Text (Text, breakOn, pack, stripPrefix, unpack)\n\n\n\ntextBetween ::\n  (Either String Text, Either String Text) ->\n  Text ->\n  Text\ntextBetween (start, end) txt =\n  fromMaybe\n    (pack [])\n    ( retain (stripPrefix <*>) snd start txt\n        >>= retain (Just .) fst end\n    )\n  where\n    retain sub part delim t =\n      either\n        (Just . const t)\n        (sub $ part . flip breakOn t)\n        delim\n\n\nmain :: IO ()\nmain = do\n  mapM_ print $\n    flip textBetween (head samples)\n      <$> take 3 delims\n  (putStrLn . unlines) $\n    zipWith\n      ( \\d t ->\n          intercalate\n            (unpack $ textBetween d t)\n            [\"\\\"\", \"\\\"\"]\n      )\n      (drop 3 delims)\n      (tail samples)\n\nsamples :: [Text]\nsamples =\n  fmap\n    pack\n    [ \"Hello Rosetta Code world\",\n      \"</div><div style=\\\"chinese\\\">\u4f60\u597d\u5417</div>\",\n      \"<text>Hello <span>Rosetta Code</span> world\"\n        <> \"</text><table style=\\\"myTable\\\">\",\n      \"<table style=\\\"myTable\\\"><tr><td>\"\n        <> \"hello world</td></tr></table>\"\n    ]\n\ndelims :: [(Either String Text, Either String Text)]\ndelims =\n  fmap\n    (join bimap wrap)\n    [ (\"Hello \", \" world\"),\n      (\"start\", \" world\"),\n      (\"Hello\", \"end\"),\n      (\"<div style=\\\"chinese\\\">\", \"</div>\"),\n      (\"<text>\", \"<table>\"),\n      (\"<text>\", \"</table>\")\n    ]\n\nwrap :: String -> Either String Text\nwrap x\n  | x `elem` [\"start\", \"end\"] = Left x\n  | otherwise = Right (pack x)\n", "target": "using System;\n\nnamespace TextBetween {\n    class Program {\n        static string TextBetween(string source, string beg, string end) {\n            int startIndex;\n\n            if (beg == \"start\") {\n                startIndex = 0;\n            }\n            else {\n                startIndex = source.IndexOf(beg);\n                if (startIndex < 0) {\n                    return \"\";\n                }\n                startIndex += beg.Length;\n            }\n\n            int endIndex = source.IndexOf(end, startIndex);\n            if (endIndex < 0 || end == \"end\") {\n                return source.Substring(startIndex);\n            }\n            return source.Substring(startIndex, endIndex - startIndex);\n        }\n\n        static void Print(string s, string b, string e) {\n            Console.WriteLine(\"text: '{0}'\", s);\n            Console.WriteLine(\"start: '{0}'\", b);\n            Console.WriteLine(\"end: '{0}'\", e);\n            Console.WriteLine(\"result: '{0}'\", TextBetween(s, b, e));\n            Console.WriteLine();\n        }\n\n        static void Main(string[] args) {\n            Print(\"Hello Rosetta Code world\", \"Hello \", \" world\");\n            Print(\"Hello Rosetta Code world\", \"start\", \" world\");\n            Print(\"Hello Rosetta Code world\", \"Hello \", \"end\");\n            Print(\"</div><div style=\\\"chinese\\\">\u4f60\u597d\u55ce</div>\", \"<div style=\\\"chinese\\\">\", \"</div>\");\n            Print(\"<text>Hello <span>Rosetta Code</span> world</text><table style=\\\"myTable\\\">\", \"<text>\", \"<table>\");\n            Print(\"<table style=\\\"myTable\\\"><tr><td>hello world</td></tr></table>\", \"<table>\", \"</table>\");\n            Print(\"The quick brown fox jumps over the lazy other fox\", \"quick \", \" fox\");\n            Print(\"One fish two fish red fish blue fish\", \"fish \", \" red\");\n            Print(\"FooBarBazFooBuxQuux\", \"Foo\", \"Foo\");\n        }\n    }\n}\n"}
{"id": 346883, "name": "Two identical strings", "source": "Translate Haskell to C#: import Control.Monad (join)\nimport Data.Bits\n  ( countLeadingZeros,\n    finiteBitSize,\n    shift,\n    (.|.)\n  )\nimport Text.Printf (printf)\n\n\nnBits :: Int -> Int\nnBits = (-) . finiteBitSize <*> countLeadingZeros\n\n\nconcatSelf :: Int -> Int\nconcatSelf = (.|.) =<< shift <*> nBits\n\n\n\nidentStrInts :: [Int]\nidentStrInts = map concatSelf [1 ..]\n\nmain :: IO ()\nmain =\n  putStr $\n    unlines $\n      map (join $ printf \"%d: %b\") to1000\n  where\n    to1000 = takeWhile (<= 1000) identStrInts\n", "target": "using System; using static System.Console;\nclass Program { static void Main() { int c = 0, lmt = 1000;\n    for (int n = 1, p = 2, k; n <= lmt; n++)\n      if ((k = n + n * (p += n >= p ? p : 0)) > lmt) break;\n      else Console.Write(\"{0,3} ({1,-10})  {2}\", k,\n          Convert.ToString(k, 2), ++c % 5 == 0 ? \"\\n\" : \"\");\n    Write(\"\\nFound {0} numbers whose base 2 representation is the \" +\n      \"concatenation of two identical binary strings.\", c); } }\n"}
{"id": 346884, "name": "Sum of first n cubes", "source": "Translate Haskell to C#: import Data.List (intercalate, transpose)\nimport Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\n\n\nsumOfFirstNCubes :: Integer -> Integer\nsumOfFirstNCubes =\n  (^ 2)\n    . flip binomialCoefficient 2\n    . succ\n\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n    table \" \" $\n      chunksOf 10 $\n        show . sumOfFirstNCubes <$> [0 .. 49]\n\n\n\n\nbinomialCoefficient :: Integer -> Integer -> Integer\nbinomialCoefficient n k\n  | n < k = 0\n  | otherwise =\n    div\n      (factorial n)\n      (factorial k * factorial (n - k))\n\nfactorial :: Integer -> Integer\nfactorial = product . enumFromTo 1\n\n\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "using System; using static System.Console;\nclass Program { static void Main(string[] args) {\n    for (int i=0,j=-6,k=1,c=0,s=0;s<1600000;s+=c+=k+=j+=6)\n      Write(\"{0,-7}{1}\",s, (i+=i==3?-4:1)==0?\"\\n\":\" \"); } }\n"}
{"id": 346885, "name": "Flow-control structures", "source": "Translate Haskell to C#: import Control.Monad\nimport Control.Monad.Trans\nimport Control.Monad.Exit\n\nmain = do\n    runExitTMaybe $ do\n        forM_ [1..5] $ \\x -> do\n            forM_ [1..5] $ \\y -> do\n                lift $ print (x, y)\n                when (x == 3 && y == 2) $\n                    exitWith ()\n    putStrLn \"Done.\"\n", "target": "int GetNumber() {\n    return 5;\n}\n"}
{"id": 346886, "name": "2048", "source": "Translate Haskell to C#: import System.IO\nimport Data.List\nimport Data.Maybe\nimport Control.Monad\nimport Data.Random\nimport Data.Random.Distribution.Categorical\nimport System.Console.ANSI\nimport Control.Lens\n\n\n\n\nprob4 :: Double\nprob4 = 0.1\n\ntype Position = [[Int]]\n\ncombine, shift :: [Int]->[Int]\ncombine (x:y:l) | x==y = (2*x) : combine l\ncombine (x:l) = x : combine l\ncombine [] = []\n\nshift l = take (length l) $ combine (filter (>0) l) ++ [0,0..]\n\nreflect :: [[a]] ->[[a]]\nreflect = map reverse\n\ntype Move = Position -> Position\n\nleft, right, up, down :: Move\nleft = map shift\nright = reflect . left . reflect\nup = transpose . left . transpose\ndown = transpose . right . transpose\n\nprogress :: Eq a => (a -> a) -> a -> Maybe a\nprogress f pos = if pos==next_pos then Nothing else Just next_pos where next_pos= f pos\n\nlost, win:: Position -> Bool\nlost pos = all isNothing [progress move pos| move<-[left,right,up,down] ]\n\nwin = any $ any (>=2048)\n\ngo :: Position -> Maybe Move -> Maybe Position\ngo pos move = move >>= flip progress pos\n\n\n\n\n\nindicesOf :: [a] -> [ReifiedTraversal' [a] a]\nindicesOf l = [ Traversal $ ix i | i <- [0..length l - 1] ]\n\nindices2Of :: [[a]] -> [ReifiedTraversal' [[a]] a]\nindices2Of ls = [ Traversal $ i.j | Traversal i <- indicesOf ls, let Just l = ls ^? i, Traversal j <- indicesOf l]\n\nadd2or4 ::  Position -> RVar Position\nadd2or4 pos = do\n  xy <-  randomElement [ xy | Traversal xy <- indices2Of pos, pos ^? xy == Just 0 ]\n  a <- categorical [(1-prob4, 2), (prob4, 4) ]\n  return $  pos & xy .~ a\n\n\n\nplay :: Position -> IO ()\nplay pos = do\n   c <- getChar\n   case go pos $ lookup c [('D',left),('C',right),('A',up),('B',down)] of\n      Nothing -> play pos\n      Just pos1 -> do\n         pos2 <- sample $ add2or4 pos1\n         draw pos2\n         when (win pos2 && not (win pos)) $ putStrLn $ \"You win! You may keep going.\"\n         if lost pos2 then putStrLn \"You lost!\"\n            else play pos2\n\nmain :: IO ()\nmain = do\n  pos <- sample $ add2or4 $ replicate 4 (replicate 4 0)\n  draw pos\n  play pos\n\n\n\ncolors =\n [(0,\"\\ESC[38;5;234;48;5;250m     \")\n ,(2,\"\\ESC[38;5;234;48;5;255m  2  \")\n ,(4,\"\\ESC[38;5;234;48;5;230m  4  \")\n ,(8,\"\\ESC[38;5;15;48;5;208m  8  \")\n ,(16,\"\\ESC[38;5;15;48;5;209m  16 \")\n ,(32,\"\\ESC[38;5;15;48;5;203m  32 \")\n ,(64,\"\\ESC[38;5;15;48;5;9m  64 \")\n ,(128,\"\\ESC[38;5;15;48;5;228m 128 \")\n ,(256,\"\\ESC[38;5;15;48;5;227m 256 \")\n ,(512,\"\\ESC[38;5;15;48;5;226m 512 \")\n ,(1024,\"\\ESC[38;5;15;48;5;221m 1024\")\n ,(2048,\"\\ESC[38;5;15;48;5;220m 2048\")\n ,(4096,\"\\ESC[38;5;15;48;5;0m 4096\")\n ,(8192,\"\\ESC[38;5;15;48;5;0m 8192\")\n ,(16384,\"\\ESC[38;5;15;48;5;0m16384\")\n ,(32768,\"\\ESC[38;5;15;48;5;0m32768\")\n ,(65536,\"\\ESC[38;5;15;48;5;0m65536\")\n ,(131072,\"\\ESC[38;5;15;48;5;90m131072\")\n ]\n\nshowTile x = fromJust (lookup x colors) ++ \"\\ESC[B\\^H\\^H\\^H\\^H\\^H     \\ESC[A\\ESC[C\"\n\ndraw :: Position -> IO ()\ndraw pos = do\n  setSGR [Reset]\n  clearScreen\n  hideCursor\n  hSetEcho stdin False\n  hSetBuffering stdin NoBuffering\n  setSGR [SetConsoleIntensity BoldIntensity]\n  putStr \"\\ESC[38;5;234;48;5;248m\" \n  setCursorPosition 0 0\n  replicateM_ 13 $ putStrLn $ replicate 26 ' '\n  setCursorPosition 1 1\n  putStrLn $ intercalate \"\\n\\n\\n\\ESC[C\" $ concatMap showTile `map` pos\n", "target": "using System;\n\nnamespace g2048_csharp\n{\n    internal class Tile\n    {\n        public Tile()\n        {\n            Value = 0;\n            IsBlocked = false;\n        }\n\n        public int Value { get; set; }\n        public bool IsBlocked { get; set; }\n    }\n\n    internal enum MoveDirection\n    {\n        Up,\n        Down,\n        Left,\n        Right\n    }\n\n    internal class G2048\n    {\n        public G2048()\n        {\n            _isDone = false;\n            _isWon = false;\n            _isMoved = true;\n            _score = 0;\n            InitializeBoard();\n        }\n\n        private void InitializeBoard()\n        {\n            for (int y = 0; y < 4; y++)\n            {\n                for (int x = 0; x < 4; x++)\n                {\n                    _board[x, y] = new Tile();\n                }\n            }\n        }\n\n        private bool _isDone;\n        private bool _isWon;\n        private bool _isMoved;\n        private int _score;\n        private readonly Tile[,] _board = new Tile[4, 4];\n        private readonly Random _rand = new Random();\n\n        public void Loop()\n        {\n            AddTile();\n            while (true)\n            {\n                if (_isMoved)\n                {\n                    AddTile();\n                }\n\n                DrawBoard();\n                if (_isDone)\n                {\n                    break;\n                }\n\n                WaitKey();\n            }\n\n            string endMessage = _isWon ? \"You've made it!\" : \"Game Over!\";\n            Console.WriteLine(endMessage);\n        }\n\n        private void DrawBoard()\n        {\n            Console.Clear();\n            Console.WriteLine(\"Score: \" + _score + \"\\n\");\n            for (int y = 0; y < 4; y++)\n            {\n                Console.WriteLine(\"+------+------+------+------+\");\n                Console.Write(\"| \");\n                for (int x = 0; x < 4; x++)\n                {\n                    if (_board[x, y].Value == 0)\n                    {\n                        const string empty = \" \";\n                        Console.Write(empty.PadRight(4));\n                    }\n                    else\n                    {\n                        Console.Write(_board[x, y].Value.ToString().PadRight(4));\n                    }\n\n                    Console.Write(\" | \");\n                }\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine(\"+------+------+------+------+\\n\\n\");\n        }\n\n        private void WaitKey()\n        {\n            _isMoved = false;\n            Console.WriteLine(\"(W) Up (S) Down (A) Left (D) Right\");\n            char input;\n            char.TryParse(Console.ReadKey().Key.ToString(), out input);\n\n            switch (input)\n            {\n                case 'W':\n                    Move(MoveDirection.Up);\n                    break;\n                case 'A':\n                    Move(MoveDirection.Left);\n                    break;\n                case 'S':\n                    Move(MoveDirection.Down);\n                    break;\n                case 'D':\n                    Move(MoveDirection.Right);\n                    break;\n            }\n\n            for (int y = 0; y < 4; y++)\n            {\n                for (int x = 0; x < 4; x++)\n                {\n                    _board[x, y].IsBlocked = false;\n                }\n            }\n        }\n\n        private void AddTile()\n        {\n            for (int y = 0; y < 4; y++)\n            {\n                for (int x = 0; x < 4; x++)\n                {\n                    if (_board[x, y].Value != 0) continue;\n                    int a, b;\n                    do\n                    {\n                        a = _rand.Next(0, 4);\n                        b = _rand.Next(0, 4);\n                    } while (_board[a, b].Value != 0);\n\n                    double r = _rand.NextDouble();\n                    _board[a, b].Value = r > 0.89f ? 4 : 2;\n\n                    if (CanMove())\n                    {\n                        return;\n                    }\n                }\n            }\n\n            _isDone = true;\n        }\n\n        private bool CanMove()\n        {\n            for (int y = 0; y < 4; y++)\n            {\n                for (int x = 0; x < 4; x++)\n                {\n                    if (_board[x, y].Value == 0)\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            for (int y = 0; y < 4; y++)\n            {\n                for (int x = 0; x < 4; x++)\n                {\n                    if (TestAdd(x + 1, y, _board[x, y].Value)\n                        || TestAdd(x - 1, y, _board[x, y].Value)\n                        || TestAdd(x, y + 1, _board[x, y].Value)\n                        || TestAdd(x, y - 1, _board[x, y].Value))\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        private bool TestAdd(int x, int y, int value)\n        {\n            if (x < 0 || x > 3 || y < 0 || y > 3)\n            {\n                return false;\n            }\n\n            return _board[x, y].Value == value;\n        }\n\n        private void MoveVertically(int x, int y, int d)\n        {\n            if (_board[x, y + d].Value != 0\n                && _board[x, y + d].Value == _board[x, y].Value\n                && !_board[x, y].IsBlocked\n                && !_board[x, y + d].IsBlocked)\n            {\n                _board[x, y].Value = 0;\n                _board[x, y + d].Value *= 2;\n                _score += _board[x, y + d].Value;\n                _board[x, y + d].IsBlocked = true;\n                _isMoved = true;\n            }\n            else if (_board[x, y + d].Value == 0\n                     && _board[x, y].Value != 0)\n            {\n                _board[x, y + d].Value = _board[x, y].Value;\n                _board[x, y].Value = 0;\n                _isMoved = true;\n            }\n\n            if (d > 0)\n            {\n                if (y + d < 3)\n                {\n                    MoveVertically(x, y + d, 1);\n                }\n            }\n            else\n            {\n                if (y + d > 0)\n                {\n                    MoveVertically(x, y + d, -1);\n                }\n            }\n        }\n\n        private void MoveHorizontally(int x, int y, int d)\n        {\n            if (_board[x + d, y].Value != 0\n                && _board[x + d, y].Value == _board[x, y].Value\n                && !_board[x + d, y].IsBlocked\n                && !_board[x, y].IsBlocked)\n            {\n                _board[x, y].Value = 0;\n                _board[x + d, y].Value *= 2;\n                _score += _board[x + d, y].Value;\n                _board[x + d, y].IsBlocked = true;\n                _isMoved = true;\n            }\n            else if (_board[x + d, y].Value == 0\n                     && _board[x, y].Value != 0)\n            {\n                _board[x + d, y].Value = _board[x, y].Value;\n                _board[x, y].Value = 0;\n                _isMoved = true;\n            }\n\n            if (d > 0)\n            {\n                if (x + d < 3)\n                {\n                    MoveHorizontally(x + d, y, 1);\n                }\n            }\n            else\n            {\n                if (x + d > 0)\n                {\n                    MoveHorizontally(x + d, y, -1);\n                }\n            }\n        }\n\n        private void Move(MoveDirection direction)\n        {\n            switch (direction)\n            {\n                case MoveDirection.Up:\n                    for (int x = 0; x < 4; x++)\n                    {\n                        int y = 1;\n                        while (y < 4)\n                        {\n                            if (_board[x, y].Value != 0)\n                            {\n                                MoveVertically(x, y, -1);\n                            }\n\n                            y++;\n                        }\n                    }\n\n                    break;\n                case MoveDirection.Down:\n                    for (int x = 0; x < 4; x++)\n                    {\n                        int y = 2;\n                        while (y >= 0)\n                        {\n                            if (_board[x, y].Value != 0)\n                            {\n                                MoveVertically(x, y, 1);\n                            }\n\n                            y--;\n                        }\n                    }\n\n                    break;\n                case MoveDirection.Left:\n                    for (int y = 0; y < 4; y++)\n                    {\n                        int x = 1;\n                        while (x < 4)\n                        {\n                            if (_board[x, y].Value != 0)\n                            {\n                                MoveHorizontally(x, y, -1);\n                            }\n\n                            x++;\n                        }\n                    }\n\n                    break;\n                case MoveDirection.Right:\n                    for (int y = 0; y < 4; y++)\n                    {\n                        int x = 2;\n                        while (x >= 0)\n                        {\n                            if (_board[x, y].Value != 0)\n                            {\n                                MoveHorizontally(x, y, 1);\n                            }\n\n                            x--;\n                        }\n                    }\n\n                    break;\n            }\n        }\n    }\n\n    internal static class Program\n    {\n        public static void Main(string[] args)\n        {\n            RunGame();\n        }\n\n        private static void RunGame()\n        {\n            G2048 game = new G2048();\n            game.Loop();\n\n            CheckRestart();\n        }\n\n        private static void CheckRestart()\n        {\n            Console.WriteLine(\"(N) New game (P) Exit\");\n            while (true)\n            {\n                char input;\n                char.TryParse(Console.ReadKey().Key.ToString(), out input);\n                switch (input)\n                {\n                    case 'N':\n                        RunGame();\n                        break;\n                    case 'P':\n                        return;\n                    default:\n                        ClearLastLine();\n                        break;\n                }\n            }\n        }\n\n        private static void ClearLastLine()\n        {\n            Console.SetCursorPosition(0, Console.CursorTop);\n            Console.Write(new string(' ', Console.BufferWidth));\n            Console.SetCursorPosition(0, Console.CursorTop - 1);\n        }\n    }\n}\n"}
{"id": 346887, "name": "Successive prime differences", "source": "Translate Haskell to C#: \nimport Data.Numbers.Primes (primes)\n\ntype Result = [(String, [Int])]\n\noneMillionPrimes :: Integral p => [p]\noneMillionPrimes = takeWhile (<1_000_000) primes\n\ngetGroups :: [Int] -> Result\ngetGroups [] = []\ngetGroups ps@(n:x:y:z:xs) \n  | x-n == 6 && y-x == 4 && z-y == 2 = (\"(6 4 2)\", [n, x, y, z])            : getGroups (tail ps)\n  | x-n == 4 && y-x == 2             = (\"(4 2)\", [n, x, y])                 : getGroups (tail ps)\n  | x-n == 2 && y-x == 4             = (\"(2 4)\", [n, x, y]) : (\"2\", [n, x]) : getGroups (tail ps)\n  | x-n == 2 && y-x == 2             = (\"(2 2)\", [n, x, y]) : (\"2\", [n, x]) : getGroups (tail ps)\n  | x-n == 2                         = (\"2\", [n, x])                        : getGroups (tail ps)\n  | x-n == 1                         = (\"1\", [n, x])                        : getGroups (tail ps)\n  | otherwise                        = getGroups (tail ps)\ngetGroups (x:xs) = getGroups xs\n\ngroups :: Result\ngroups = getGroups oneMillionPrimes\n\nshowGroup :: String -> IO ()\nshowGroup group = do \n  putStrLn $ \"Differences of \" ++ group ++ \": \" ++ show (length r)\n  putStrLn $ \"First: \" ++ show (head r) ++ \"\\nLast:  \" ++ show (last r) ++ \"\\n\"\n  where r = foldr (\\(a, b) c -> if a == group then b : c else c) [] groups\n\nmain :: IO ()\nmain = showGroup \"2\" >> showGroup \"1\" >> showGroup \"(2 2)\" >> showGroup \"(2 4)\" >> showGroup \"(4 2)\" \n  >> showGroup \"(6 4 2)\"\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class SuccessivePrimeDifferences {\n\n    public static void Main() {\n        var primes = GeneratePrimes(1_000_000).ToList();\n        foreach (var d in new[] {\n            new [] { 2 },\n            new [] { 1 },\n            new [] { 2, 2 },\n            new [] { 2, 4 },\n            new [] { 4, 2 },\n            new [] { 6, 4, 2 },\n        }) {\n            IEnumerable<int> first = null, last = null;\n            int count = 0;\n            foreach (var grp in FindDifferenceGroups(d)) {\n                if (first == null) first = grp;\n                last = grp;\n                count++;\n            }\n            Console.WriteLine($\"{$\"({string.Join(\", \", first)})\"}, {$\"({string.Join(\", \", last)})\"}, {count}\");\n        }\n\n        IEnumerable<IEnumerable<int>> FindDifferenceGroups(int[] diffs) {\n            for (int pi = diffs.Length; pi < primes.Count; pi++)\n                if (Range(0, diffs.Length).All(di => primes[pi-diffs.Length+di+1] - primes[pi-diffs.Length+di] == diffs[di]))\n                    yield return Range(pi - diffs.Length, diffs.Length + 1).Select(i => primes[i]);\n        }\n\n        IEnumerable<int> GeneratePrimes(int lmt) {\n            bool[] comps = new bool[lmt + 1];\n            comps[0] = comps[1] = true;\n            yield return 2; yield return 3;\n            for (int j = 4; j <= lmt; j += 2) comps[j] = true;\n            for (int j = 9; j <= lmt; j += 6) comps[j] = true;\n            int i = 5, d = 4, rt = (int)Math.Sqrt(lmt);\n            for ( ; i <= rt; i += (d = 6 - d))\n                if (!comps[i]) {\n                    yield return i;\n                    for (int j = i * i, k = i << 1; j <= lmt; j += k)\n                        comps[j] = true;\n                }\n            for ( ; i <= lmt; i += (d = 6 - d)) if (!comps[i]) yield return i;\n        }\n    }\n}\n"}
{"id": 346888, "name": "Largest number divisible by its digits", "source": "Translate Haskell to C#: import Data.List (maximumBy, permutations, delete)\nimport Data.Ord (comparing)\nimport Data.Bool (bool)\n\nunDigits :: [Int] -> Int\nunDigits = foldl ((+) . (10 *)) 0\n\nds :: [Int]\nds = [1, 2, 3, 4, 6, 7, 8, 9] \n\nlcmDigits :: Int\nlcmDigits = foldr1 lcm ds \n\nsevenDigits :: [[Int]]\nsevenDigits = (`delete` ds) <$> [1, 4, 7] \n\nmain :: IO ()\nmain =\n  print $\n  maximumBy\n  \n    (comparing (bool 0 <*> (0 ==) . (`rem` lcmDigits)))\n    (unDigits <$> concat (permutations <$> sevenDigits))\n", "target": "using System;\n\nclass Program {\n    static int gcd(int a, int b) { return b > 0 ? gcd(b, a % b) : a; }\n\n    \n    static int lcmd(long x, int b) {\n      int r = (int)(x % b), a; x /= b; while (x > 0) {\n        r = (r * (a = (int)(x % b))) / gcd(r, a); x /= b; } return r; }\n\n    static void Main(string[] args) {\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        long mx = 987654321; \n             mx = 98764321; \n             mx /= 10;     \n        long skip = lcmd(mx, 10), i; bool nDup;\n        for (i = mx - mx % skip; ; i -= skip) {\n            var s = i.ToString().ToCharArray(); Array.Sort(s);\n            if (s[0] == '0') continue; \n            nDup = true; \n            for (int j = 0, k = 1; k < s.Length; j = k++)\n                if (s[j] == s[k] || s[k] == '5') { nDup = false; break; }\n            if (nDup) break; } sw.Stop(); \n        Console.Write(\"base 10 = {0} in {1} \u03bcs\\n\", i,\n          1000 * sw.Elapsed.TotalMilliseconds);\n        sw.Restart();\n        mx = 0xfedcba987654321;    \n        skip = lcmd(mx >> 4, 16); \n        for (i = mx - mx % skip; ; i -= skip) {\n            var s = i.ToString(\"x\").ToCharArray(); Array.Sort(s);\n            if (s[0] == '0') continue; \n            nDup = true; \n            for (int j = 0, k = 1; k < s.Length; j = k++)\n                if (s[j] == s[k]) { nDup = false; break; }\n            if (nDup) break; } sw.Stop(); \n        Console.Write(\"base 16 = {0} in {1} ms\", i.ToString(\"x\"),\n          sw.Elapsed.TotalMilliseconds); } }\n"}
{"id": 346889, "name": "Brazilian numbers", "source": "Translate Haskell to C#: import Data.Numbers.Primes (primes)\n\nisBrazil :: Int -> Bool\nisBrazil n = 7 <= n && (even n || any (monoDigit n) [2 .. n - 2])\n\nmonoDigit :: Int -> Int -> Bool\nmonoDigit n b =\n  let (q, d) = quotRem n b\n  in d ==\n     snd\n       (until\n          (uncurry (flip ((||) . (d /=)) . (0 ==)))\n          ((`quotRem` b) . fst)\n          (q, d))\n\nmain :: IO ()\nmain =\n  mapM_\n    (\\(s, xs) ->\n        (putStrLn . concat)\n          [ \"First 20 \"\n          , s\n          , \" Brazilians:\\n\"\n          , show . take 20 $ filter isBrazil xs\n          , \"\\n\"\n          ])\n    [([], [1 ..]), (\"odd\", [1,3 ..]), (\"prime\", primes)]\n", "target": "using System;\nclass Program {\n \n  static bool sameDigits(int n, int b) {\n    int f = n % b;\n    while ((n /= b) > 0) if (n % b != f) return false;\n    return true;\n  }\n \n  static bool isBrazilian(int n) {\n    if (n < 7) return false;\n    if (n % 2 == 0) return true;\n    for (int b = 2; b < n - 1; b++) if (sameDigits(n, b)) return true;\n    return false;\n  }\n \n  static bool isPrime(int n) {\n    if (n < 2) return false;\n    if (n % 2 == 0) return n == 2;\n    if (n % 3 == 0) return n == 3;\n    int d = 5;\n    while (d * d <= n) {\n      if (n % d == 0) return false; d += 2;\n      if (n % d == 0) return false; d += 4;\n    }\n    return true;\n  }\n \n  static void Main(string[] args) {\n    foreach (string kind in \",odd ,prime \".Split(',')) {\n      bool quiet = false; int BigLim = 99999, limit = 20;\n      Console.WriteLine(\"First {0} {1}Brazilian numbers:\", limit, kind);\n      int c = 0, n = 7;\n      while (c < BigLim) {\n        if (isBrazilian(n)) {\n          if (!quiet) Console.Write(\"{0:n0} \", n);\n          if (++c == limit) { Console.Write(\"\\n\\n\"); quiet = true; }\n        }\n        if (quiet && kind != \"\") continue;\n        switch (kind) {\n          case \"\": n++; break;\n          case \"odd \": n += 2; break;\n          case \"prime \":\n            while (true) {\n              n += 2;\n              if (isPrime(n)) break;\n            } break;\n        }\n      }\n      if (kind == \"\") Console.WriteLine(\"The {0:n0}th Brazilian number is: {1:n0}\\n\", BigLim + 1, n);\n    }\n  }\n}\n"}
{"id": 346890, "name": "Brazilian numbers", "source": "Translate Haskell to C#: import Data.Numbers.Primes (primes)\n\nisBrazil :: Int -> Bool\nisBrazil n = 7 <= n && (even n || any (monoDigit n) [2 .. n - 2])\n\nmonoDigit :: Int -> Int -> Bool\nmonoDigit n b =\n  let (q, d) = quotRem n b\n  in d ==\n     snd\n       (until\n          (uncurry (flip ((||) . (d /=)) . (0 ==)))\n          ((`quotRem` b) . fst)\n          (q, d))\n\nmain :: IO ()\nmain =\n  mapM_\n    (\\(s, xs) ->\n        (putStrLn . concat)\n          [ \"First 20 \"\n          , s\n          , \" Brazilians:\\n\"\n          , show . take 20 $ filter isBrazil xs\n          , \"\\n\"\n          ])\n    [([], [1 ..]), (\"odd\", [1,3 ..]), (\"prime\", primes)]\n", "target": "using System;\nclass Program {\n \n  static bool sameDigits(int n, int b) {\n    int f = n % b;\n    while ((n /= b) > 0) if (n % b != f) return false;\n    return true;\n  }\n \n  static bool isBrazilian(int n) {\n    if (n < 7) return false;\n    if (n % 2 == 0) return true;\n    for (int b = 2; b < n - 1; b++) if (sameDigits(n, b)) return true;\n    return false;\n  }\n \n  static bool isPrime(int n) {\n    if (n < 2) return false;\n    if (n % 2 == 0) return n == 2;\n    if (n % 3 == 0) return n == 3;\n    int d = 5;\n    while (d * d <= n) {\n      if (n % d == 0) return false; d += 2;\n      if (n % d == 0) return false; d += 4;\n    }\n    return true;\n  }\n \n  static void Main(string[] args) {\n    foreach (string kind in \",odd ,prime \".Split(',')) {\n      bool quiet = false; int BigLim = 99999, limit = 20;\n      Console.WriteLine(\"First {0} {1}Brazilian numbers:\", limit, kind);\n      int c = 0, n = 7;\n      while (c < BigLim) {\n        if (isBrazilian(n)) {\n          if (!quiet) Console.Write(\"{0:n0} \", n);\n          if (++c == limit) { Console.Write(\"\\n\\n\"); quiet = true; }\n        }\n        if (quiet && kind != \"\") continue;\n        switch (kind) {\n          case \"\": n++; break;\n          case \"odd \": n += 2; break;\n          case \"prime \":\n            while (true) {\n              n += 2;\n              if (isPrime(n)) break;\n            } break;\n        }\n      }\n      if (kind == \"\") Console.WriteLine(\"The {0:n0}th Brazilian number is: {1:n0}\\n\", BigLim + 1, n);\n    }\n  }\n}\n"}
{"id": 346891, "name": "Recaman's sequence", "source": "Translate Haskell to C#: recaman :: Int -> [Int]\nrecaman n = fst <$> reverse (go n)\n  where\n    go 0 = []\n    go 1 = [(0, 1)]\n    go x =\n        let xs@((r, i):_) = go (pred x)\n            back = r - i\n        in ( if 0 < back && not (any ((back ==) . fst) xs)\n               then back\n               else r + i\n           , succ i) :\n           xs\n\nmain :: IO ()\nmain = print $ recaman 15\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RecamanSequence {\n    class Program {\n        static void Main(string[] args) {\n            List<int> a = new List<int>() { 0 };\n            HashSet<int> used = new HashSet<int>() { 0 };\n            HashSet<int> used1000 = new HashSet<int>() { 0 };\n            bool foundDup = false;\n            int n = 1;\n            while (n <= 15 || !foundDup || used1000.Count < 1001) {\n                int next = a[n - 1] - n;\n                if (next < 1 || used.Contains(next)) {\n                    next += 2 * n;\n                }\n                bool alreadyUsed = used.Contains(next);\n                a.Add(next);\n                if (!alreadyUsed) {\n                    used.Add(next);\n                    if (0 <= next && next <= 1000) {\n                        used1000.Add(next);\n                    }\n                }\n                if (n == 14) {\n                    Console.WriteLine(\"The first 15 terms of the Recaman sequence are: [{0}]\", string.Join(\", \", a));\n                }\n                if (!foundDup && alreadyUsed) {\n                    Console.WriteLine(\"The first duplicated term is a[{0}] = {1}\", n, next);\n                    foundDup = true;\n                }\n                if (used1000.Count == 1001) {\n                    Console.WriteLine(\"Terms up to a[{0}] are needed to generate 0 to 1000\", n);\n                }\n                n++;\n            }\n        }\n    }\n}\n"}
{"id": 346892, "name": "Recaman's sequence", "source": "Translate Haskell to C#: recaman :: Int -> [Int]\nrecaman n = fst <$> reverse (go n)\n  where\n    go 0 = []\n    go 1 = [(0, 1)]\n    go x =\n        let xs@((r, i):_) = go (pred x)\n            back = r - i\n        in ( if 0 < back && not (any ((back ==) . fst) xs)\n               then back\n               else r + i\n           , succ i) :\n           xs\n\nmain :: IO ()\nmain = print $ recaman 15\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RecamanSequence {\n    class Program {\n        static void Main(string[] args) {\n            List<int> a = new List<int>() { 0 };\n            HashSet<int> used = new HashSet<int>() { 0 };\n            HashSet<int> used1000 = new HashSet<int>() { 0 };\n            bool foundDup = false;\n            int n = 1;\n            while (n <= 15 || !foundDup || used1000.Count < 1001) {\n                int next = a[n - 1] - n;\n                if (next < 1 || used.Contains(next)) {\n                    next += 2 * n;\n                }\n                bool alreadyUsed = used.Contains(next);\n                a.Add(next);\n                if (!alreadyUsed) {\n                    used.Add(next);\n                    if (0 <= next && next <= 1000) {\n                        used1000.Add(next);\n                    }\n                }\n                if (n == 14) {\n                    Console.WriteLine(\"The first 15 terms of the Recaman sequence are: [{0}]\", string.Join(\", \", a));\n                }\n                if (!foundDup && alreadyUsed) {\n                    Console.WriteLine(\"The first duplicated term is a[{0}] = {1}\", n, next);\n                    foundDup = true;\n                }\n                if (used1000.Count == 1001) {\n                    Console.WriteLine(\"Terms up to a[{0}] are needed to generate 0 to 1000\", n);\n                }\n                n++;\n            }\n        }\n    }\n}\n"}
{"id": 346893, "name": "Y combinator", "source": "Translate Haskell to C#: newtype Mu a = Roll\n  { unroll :: Mu a -> a }\n \nfix :: (a -> a) -> a\nfix = g <*> (Roll . g)\n  where\n    g = (. (>>= id) unroll)\n \n- this version is not in tail call position...\n\n\n\n\n\nfac :: Integer -> Integer\nfac =\n  (fix $ \\f n i -> if i <= 0 then n else f (i * n) (i - 1)) 1\n \n\n\n\n\n{\nfibs\u00a0:: () -> [Integer]\nfibs() =\n  fix $\n    (0\u00a0:) . (1\u00a0:) .\n      (fix\n        (\\f (x:xs) (y:ys) ->\n          case x + y of n -> n `seq` n\u00a0: f xs ys) <*> tail)\n\n\n\nfibs :: () -> [Integer]\nfibs() = 0 : 1 : fix fibs_ 0 1\n  where\n    fibs_ fnc f s =\n      case f + s of n -> n `seq` n : fnc s n\n \nmain :: IO ()\nmain =\n  mapM_\n    print\n    [ map fac [1 .. 20]\n    , take 20 $ fibs()\n    ]\n", "target": "using System;\n\nstatic class YCombinator<T, TResult>\n{\n    \n    private delegate Func<T, TResult> RecursiveFunc(RecursiveFunc r);\n\n    public static Func<Func<Func<T, TResult>, Func<T, TResult>>, Func<T, TResult>> Fix { get; } =\n        f => ((RecursiveFunc)(g => f(x => g(g)(x))))(g => f(x => g(g)(x)));\n}\n\nstatic class Program\n{\n    static void Main()\n    {\n        var fac = YCombinator<int, int>.Fix(f => x => x < 2 ? 1 : x * f(x - 1));\n        var fib = YCombinator<int, int>.Fix(f => x => x < 2 ? x : f(x - 1) + f(x - 2));\n\n        Console.WriteLine(fac(10));\n        Console.WriteLine(fib(10));\n    }\n}\n"}
{"id": 346894, "name": "Casting out nines", "source": "Translate Haskell to C#: co9 n\n  | n <= 8 = n\n  | otherwise = co9 $ sum $ filter (/= 9) $ digits 10 n\n\ntask2 = filter (\\n -> co9 n == co9 (n ^ 2)) [1 .. 100]\n\ntask3 k = filter (\\n -> n `mod` k == n ^ 2 `mod` k) [1 .. 100]\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace CastingOutNines {\n    public static class Helper {\n        public static string AsString<T>(this IEnumerable<T> e) {\n            var it = e.GetEnumerator();\n\n            StringBuilder builder = new StringBuilder();\n            builder.Append(\"[\");\n\n            if (it.MoveNext()) {\n                builder.Append(it.Current);\n            }\n            while (it.MoveNext()) {\n                builder.Append(\", \");\n                builder.Append(it.Current);\n            }\n\n            builder.Append(\"]\");\n            return builder.ToString();\n        }\n    }\n\n    class Program {\n        static List<int> CastOut(int @base, int start, int end) {\n            int[] ran = Enumerable\n                .Range(0, @base - 1)\n                .Where(a => a % (@base - 1) == (a * a) % (@base - 1))\n                .ToArray();\n            int x = start / (@base - 1);\n\n            List<int> result = new List<int>();\n            while (true) {\n                foreach (int n in ran) {\n                    int k = (@base - 1) * x + n;\n                    if (k < start) {\n                        continue;\n                    }\n                    if (k > end) {\n                        return result;\n                    }\n                    result.Add(k);\n                }\n                x++;\n            }\n        }\n\n        static void Main() {\n            Console.WriteLine(CastOut(16, 1, 255).AsString());\n            Console.WriteLine(CastOut(10, 1, 99).AsString());\n            Console.WriteLine(CastOut(17, 1, 288).AsString());\n        }\n    }\n}\n"}
{"id": 346895, "name": "Casting out nines", "source": "Translate Haskell to C#: co9 n\n  | n <= 8 = n\n  | otherwise = co9 $ sum $ filter (/= 9) $ digits 10 n\n\ntask2 = filter (\\n -> co9 n == co9 (n ^ 2)) [1 .. 100]\n\ntask3 k = filter (\\n -> n `mod` k == n ^ 2 `mod` k) [1 .. 100]\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace CastingOutNines {\n    public static class Helper {\n        public static string AsString<T>(this IEnumerable<T> e) {\n            var it = e.GetEnumerator();\n\n            StringBuilder builder = new StringBuilder();\n            builder.Append(\"[\");\n\n            if (it.MoveNext()) {\n                builder.Append(it.Current);\n            }\n            while (it.MoveNext()) {\n                builder.Append(\", \");\n                builder.Append(it.Current);\n            }\n\n            builder.Append(\"]\");\n            return builder.ToString();\n        }\n    }\n\n    class Program {\n        static List<int> CastOut(int @base, int start, int end) {\n            int[] ran = Enumerable\n                .Range(0, @base - 1)\n                .Where(a => a % (@base - 1) == (a * a) % (@base - 1))\n                .ToArray();\n            int x = start / (@base - 1);\n\n            List<int> result = new List<int>();\n            while (true) {\n                foreach (int n in ran) {\n                    int k = (@base - 1) * x + n;\n                    if (k < start) {\n                        continue;\n                    }\n                    if (k > end) {\n                        return result;\n                    }\n                    result.Add(k);\n                }\n                x++;\n            }\n        }\n\n        static void Main() {\n            Console.WriteLine(CastOut(16, 1, 255).AsString());\n            Console.WriteLine(CastOut(10, 1, 99).AsString());\n            Console.WriteLine(CastOut(17, 1, 288).AsString());\n        }\n    }\n}\n"}
{"id": 346896, "name": "Playing cards", "source": "Translate Haskell to C#: import System.Random\n\ndata Pip = Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten | \n           Jack | Queen | King | Ace \n  deriving (Ord, Enum, Bounded, Eq, Show)\n\ndata Suit = Diamonds | Spades | Hearts | Clubs\n  deriving (Ord, Enum, Bounded, Eq, Show)\n\ntype Card = (Pip, Suit)\n\nfullRange :: (Bounded a, Enum a) => [a]\nfullRange = [minBound..maxBound]\n\nfullDeck :: [Card]\nfullDeck = [(pip, suit) | pip <- fullRange, suit <- fullRange]\n\ninsertAt :: Int -> a -> [a] -> [a]\ninsertAt 0 x ys     = x:ys\ninsertAt n _ []     = error \"insertAt: list too short\"\ninsertAt n x (y:ys) = y : insertAt (n-1) x ys\n\nshuffle :: RandomGen g => g -> [a] -> [a]\nshuffle g xs = shuffle' g xs 0 [] where\n  shuffle' g []     _ ys = ys\n  shuffle' g (x:xs) n ys = shuffle' g' xs (n+1) (insertAt k x ys) where\n    (k,g') = randomR (0,n) g\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic struct Card\n{\n    public Card(string rank, string suit) : this()\n    {\n        Rank = rank;\n        Suit = suit;\n    }\n\n    public string Rank { get; }\n    public string Suit { get; }\n\n    public override string ToString() => $\"{Rank} of {Suit}\";\n}\n\npublic class Deck : IEnumerable<Card>\n{\n    static readonly string[] ranks = { \"Two\", \"Three\", \"Four\", \"Five\", \"Six\",\n        \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Jack\", \"Queen\", \"King\", \"Ace\" };\n    static readonly string[] suits = { \"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\" };\n    readonly List<Card> cards;\n \n    public Deck() {\n        cards = (from suit in suits\n                from rank in ranks\n                select new Card(rank, suit)).ToList();\n    }\n\n    public int Count => cards.Count;\n\n    public void Shuffle() {\n        \n        var random = new Random();\n        for (int i = 0; i < cards.Count; i++) {\n            int r = random.Next(i, cards.Count);\n            var temp = cards[i];\n            cards[i] = cards[r];\n            cards[r] = temp;\n        }\n    }\n\n    public Card Deal() {\n        int last = cards.Count - 1;\n        Card card = cards[last];\n        \n        \n        cards.RemoveAt(last);\n        return card;\n    }\n\n    public IEnumerator<Card> GetEnumerator() {\n        \n        \n        for (int i = cards.Count - 1; i >= 0; i--)\n            yield return cards[i];\n    }\n\n    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n}\n"}
{"id": 346897, "name": "Lah numbers", "source": "Translate Haskell to C#: import Text.Printf (printf)\nimport Control.Monad (when)\n \nfactorial :: Integral n => n -> n\nfactorial 0 = 1\nfactorial n = product [1..n]\n \nlah :: Integral n => n -> n -> n\nlah n k\n  | k == 1 = factorial n\n  | k == n = 1\n  | k > n  = 0\n  | k < 1 || n < 1 = 0\n  | otherwise = f n `div` f k `div` factorial (n - k)\n      where\n        f = (*) =<< (^ 2) . factorial . pred  \n \nprintLah :: (Word, Word) -> IO ()\nprintLah (n, k) = do\n  when (k == 0) (printf \"\\n%3d\" n)\n  printf \"%11d\" (lah n k)\n \nmain :: IO ()\nmain = do\n  printf \"Unsigned Lah numbers: L(n, k):\\nn/k\"\n  mapM_ (printf \"%11d\") zeroToTwelve\n  mapM_ printLah $ (,) <$> zeroToTwelve <*> zeroToTwelve\n  printf \"\\nMaximum value from the L(100, *) row:\\n%d\\n\"\n    (maximum $ lah 100 <$> ([0..100] :: [Integer]))\n  where zeroToTwelve = [0..12]\n", "target": "using System;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace LahNumbers {\n    class Program {\n        static BigInteger Factorial(BigInteger n) {\n            if (n == 0) return 1;\n            BigInteger res = 1;\n            while (n > 0) {\n                res *= n--;\n            }\n            return res;\n        }\n\n        static BigInteger Lah(BigInteger n, BigInteger k) {\n            if (k == 1) return Factorial(n);\n            if (k == n) return 1;\n            if (k > n) return 0;\n            if (k < 1 || n < 1) return 0;\n            return (Factorial(n) * Factorial(n - 1)) / (Factorial(k) * Factorial(k - 1)) / Factorial(n - k);\n        }\n\n        static void Main() {\n            Console.WriteLine(\"Unsigned Lah numbers: L(n, k):\");\n            Console.Write(\"n/k \");\n            foreach (var i in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,10} \", i);\n            }\n            Console.WriteLine();\n            foreach (var row in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,-3}\", row);\n                foreach (var i in Enumerable.Range(0, row + 1)) {\n                    var l = Lah(row, i);\n                    Console.Write(\"{0,11}\", l);\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine(\"\\nMaximum value from the L(100, *) row:\");\n            var maxVal = Enumerable.Range(0, 100).Select(a => Lah(100, a)).Max();\n            Console.WriteLine(maxVal);\n        }\n    }\n}\n"}
{"id": 346898, "name": "Lah numbers", "source": "Translate Haskell to C#: import Text.Printf (printf)\nimport Control.Monad (when)\n \nfactorial :: Integral n => n -> n\nfactorial 0 = 1\nfactorial n = product [1..n]\n \nlah :: Integral n => n -> n -> n\nlah n k\n  | k == 1 = factorial n\n  | k == n = 1\n  | k > n  = 0\n  | k < 1 || n < 1 = 0\n  | otherwise = f n `div` f k `div` factorial (n - k)\n      where\n        f = (*) =<< (^ 2) . factorial . pred  \n \nprintLah :: (Word, Word) -> IO ()\nprintLah (n, k) = do\n  when (k == 0) (printf \"\\n%3d\" n)\n  printf \"%11d\" (lah n k)\n \nmain :: IO ()\nmain = do\n  printf \"Unsigned Lah numbers: L(n, k):\\nn/k\"\n  mapM_ (printf \"%11d\") zeroToTwelve\n  mapM_ printLah $ (,) <$> zeroToTwelve <*> zeroToTwelve\n  printf \"\\nMaximum value from the L(100, *) row:\\n%d\\n\"\n    (maximum $ lah 100 <$> ([0..100] :: [Integer]))\n  where zeroToTwelve = [0..12]\n", "target": "using System;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace LahNumbers {\n    class Program {\n        static BigInteger Factorial(BigInteger n) {\n            if (n == 0) return 1;\n            BigInteger res = 1;\n            while (n > 0) {\n                res *= n--;\n            }\n            return res;\n        }\n\n        static BigInteger Lah(BigInteger n, BigInteger k) {\n            if (k == 1) return Factorial(n);\n            if (k == n) return 1;\n            if (k > n) return 0;\n            if (k < 1 || n < 1) return 0;\n            return (Factorial(n) * Factorial(n - 1)) / (Factorial(k) * Factorial(k - 1)) / Factorial(n - k);\n        }\n\n        static void Main() {\n            Console.WriteLine(\"Unsigned Lah numbers: L(n, k):\");\n            Console.Write(\"n/k \");\n            foreach (var i in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,10} \", i);\n            }\n            Console.WriteLine();\n            foreach (var row in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,-3}\", row);\n                foreach (var i in Enumerable.Range(0, row + 1)) {\n                    var l = Lah(row, i);\n                    Console.Write(\"{0,11}\", l);\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine(\"\\nMaximum value from the L(100, *) row:\");\n            var maxVal = Enumerable.Range(0, 100).Select(a => Lah(100, a)).Max();\n            Console.WriteLine(maxVal);\n        }\n    }\n}\n"}
{"id": 346899, "name": "Two sum", "source": "Translate Haskell to C#: twoSum::(Num a,Ord a) => a -> [a] -> [Int]\ntwoSum num list = sol ls (reverse ls)\n  where\n  ls = zip list [0..]\n  sol [] _ = []\n  sol _ [] = []\n  sol xs@((x,i):us) ys@((y,j):vs) = ans\n    where\n    s = x + y\n    ans | s == num  = [i,j]\n        | j <= i    = []\n        | s < num   = sol (dropWhile ((<num).(+y).fst) us) ys\n        | otherwise = sol xs $ dropWhile ((num <).(+x).fst) vs\n\nmain = print $ twoSum 21 [0, 2, 11, 19, 90]\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        int[] arr = { 0, 2, 11, 19, 90 };\n        const int sum = 21;\n\n        var ts = TwoSum(arr, sum);\n        Console.WriteLine(ts != null ? $\"{ts[0]}, {ts[1]}\" : \"no result\");\n\n        Console.ReadLine();\n    }\n\n    public static int[] TwoSum(int[] numbers, int sum)\n    {\n        var map = new Dictionary<int, int>();\n        for (int i = 0; i < numbers.Length; i++)\n        {\n            \n            var key = sum - numbers[i];\n            if (map.ContainsKey(key))\n            {\n                return new[] { map[key], i };\n            }\n            map.Add(numbers[i], i);\n        }\n        return null;\n    }\n}\n"}
{"id": 346900, "name": "Two sum", "source": "Translate Haskell to C#: twoSum::(Num a,Ord a) => a -> [a] -> [Int]\ntwoSum num list = sol ls (reverse ls)\n  where\n  ls = zip list [0..]\n  sol [] _ = []\n  sol _ [] = []\n  sol xs@((x,i):us) ys@((y,j):vs) = ans\n    where\n    s = x + y\n    ans | s == num  = [i,j]\n        | j <= i    = []\n        | s < num   = sol (dropWhile ((<num).(+y).fst) us) ys\n        | otherwise = sol xs $ dropWhile ((num <).(+x).fst) vs\n\nmain = print $ twoSum 21 [0, 2, 11, 19, 90]\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        int[] arr = { 0, 2, 11, 19, 90 };\n        const int sum = 21;\n\n        var ts = TwoSum(arr, sum);\n        Console.WriteLine(ts != null ? $\"{ts[0]}, {ts[1]}\" : \"no result\");\n\n        Console.ReadLine();\n    }\n\n    public static int[] TwoSum(int[] numbers, int sum)\n    {\n        var map = new Dictionary<int, int>();\n        for (int i = 0; i < numbers.Length; i++)\n        {\n            \n            var key = sum - numbers[i];\n            if (map.ContainsKey(key))\n            {\n                return new[] { map[key], i };\n            }\n            map.Add(numbers[i], i);\n        }\n        return null;\n    }\n}\n"}
{"id": 346901, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Haskell to C#: import Data.List.Split (chunksOf)\nimport Data.List (intercalate, transpose, unfoldr)\nimport Text.Printf\n\nprimeDigitsNumsSummingToN :: Int -> [Int]\nprimeDigitsNumsSummingToN n = concat $ unfoldr go (return <$> primeDigits)\n  where\n    primeDigits = [2, 3, 5, 7]\n    \n    go :: [[Int]] -> Maybe ([Int], [[Int]])\n    go xs\n      | null xs = Nothing\n      | otherwise = Just (nextLength xs)\n      \n    nextLength :: [[Int]] -> ([Int], [[Int]])\n    nextLength xs =\n      let harvest nv =\n            [ unDigits $ fst nv\n            | n == snd nv ]\n          prune nv =\n            [ fst nv\n            | pred n > snd nv ]\n      in ((,) . concatMap harvest <*> concatMap prune)\n           (((,) <*> sum) <$> ((<$> xs) . (<>) . return =<< primeDigits))\n\n\nmain :: IO ()\nmain = do\n  let n = 13\n      xs = primeDigitsNumsSummingToN n\n  mapM_\n    putStrLn\n    [ concat\n        [ (show . length) xs\n        , \" numbers with prime digits summing to \"\n        , show n\n        , \":\\n\"\n        ]\n    , table \" \" $ chunksOf 10 (show <$> xs)\n    ]\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ic = intercalate\n      ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip ic [\"%\", \"s\"] . show\n  in unlines $ ic gap . zipWith pw ws <$> rows\n\nunDigits :: [Int] -> Int\nunDigits = foldl ((+) . (10 *)) 0\n", "target": "using System;\nusing static System.Console; \nusing LI = System.Collections.Generic.SortedSet<int>;\n\nclass Program {\n\n  static LI unl(LI res, LI set, int lft, int mul = 1, int vlu = 0) {\n    if (lft == 0) res.Add(vlu);\n    else if (lft > 0) foreach (int itm in set)\n      res = unl(res, set, lft - itm, mul * 10, vlu + itm * mul);\n    return res; }\n\n  static void Main(string[] args) { WriteLine(string.Join(\" \",\n      unl(new LI {}, new LI { 2, 3, 5, 7 }, 13))); }\n}\n"}
{"id": 346902, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Haskell to C#: import Data.List.Split (chunksOf)\nimport Data.List (intercalate, transpose, unfoldr)\nimport Text.Printf\n\nprimeDigitsNumsSummingToN :: Int -> [Int]\nprimeDigitsNumsSummingToN n = concat $ unfoldr go (return <$> primeDigits)\n  where\n    primeDigits = [2, 3, 5, 7]\n    \n    go :: [[Int]] -> Maybe ([Int], [[Int]])\n    go xs\n      | null xs = Nothing\n      | otherwise = Just (nextLength xs)\n      \n    nextLength :: [[Int]] -> ([Int], [[Int]])\n    nextLength xs =\n      let harvest nv =\n            [ unDigits $ fst nv\n            | n == snd nv ]\n          prune nv =\n            [ fst nv\n            | pred n > snd nv ]\n      in ((,) . concatMap harvest <*> concatMap prune)\n           (((,) <*> sum) <$> ((<$> xs) . (<>) . return =<< primeDigits))\n\n\nmain :: IO ()\nmain = do\n  let n = 13\n      xs = primeDigitsNumsSummingToN n\n  mapM_\n    putStrLn\n    [ concat\n        [ (show . length) xs\n        , \" numbers with prime digits summing to \"\n        , show n\n        , \":\\n\"\n        ]\n    , table \" \" $ chunksOf 10 (show <$> xs)\n    ]\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ic = intercalate\n      ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip ic [\"%\", \"s\"] . show\n  in unlines $ ic gap . zipWith pw ws <$> rows\n\nunDigits :: [Int] -> Int\nunDigits = foldl ((+) . (10 *)) 0\n", "target": "using System;\nusing static System.Console; \nusing LI = System.Collections.Generic.SortedSet<int>;\n\nclass Program {\n\n  static LI unl(LI res, LI set, int lft, int mul = 1, int vlu = 0) {\n    if (lft == 0) res.Add(vlu);\n    else if (lft > 0) foreach (int itm in set)\n      res = unl(res, set, lft - itm, mul * 10, vlu + itm * mul);\n    return res; }\n\n  static void Main(string[] args) { WriteLine(string.Join(\" \",\n      unl(new LI {}, new LI { 2, 3, 5, 7 }, 13))); }\n}\n"}
{"id": 346903, "name": "Frobenius numbers", "source": "Translate Haskell to C#: primes = 2 : sieve [3,5..]\n  where sieve (x:xs) = x : sieve (filter (\\y -> y `mod` x /= 0) xs)\n\nfrobenius = zipWith (\\a b -> a*b - a - b) primes (tail primes)\n", "target": "using System.Collections.Generic; using System.Linq; using static System.Console; using static System.Math;\n\nclass Program {\n\n    static bool ispr(int x) { int lim = (int)Sqrt((double)x);\n        if (x < 2) return false; if ((x % 3) == 0) return x == 0; bool odd = false;\n        for (int d = 5; d <= lim; d += (odd = !odd) ? 2 : 4) {\n        if (x % d == 0) return false; } return true; }\n\n    static void Main() {\n        int c = 0, d = 0, f, lim = 1000000, l2 = lim / 100; var Frob = PG.Primes((int)Sqrt(lim) + 1).ToArray();\n        for (int n = 0, m = 1; m < Frob.Length; n = m++) {\n            if ((f = Frob[n] * Frob[m] - Frob[n] - Frob[m]) < l2) d++;\n            Write(\"{0,7:n0}{2} {1}\", f , ++c % 10 == 0 ? \"\\n\" : \"\", ispr(f) ? \" \" : \"*\"); }\n        Write(\"\\n\\nCalculated {0} Frobenius numbers of consecutive primes under {1:n0}, \" +\n            \"of which {2} were under {3:n0}\", c, lim, d, l2); } }\n\nclass PG { public static IEnumerable<int> Primes(int lim) { \n    var flags = new bool[lim + 1]; int j = 3; yield return 2; \n    for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n      if (!flags[j]) { yield return j;\n        for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true; }\n    for (; j <= lim; j += 2) if (!flags[j]) yield return j; } }\n"}
{"id": 346904, "name": "Integer roots", "source": "Translate Haskell to C#: root :: Integer -> Integer -> Integer\nroot a b = findAns $ iterate (\\x -> (a1 * x + b `div` (x ^ a1)) `div` a) 1\n  where\n    a1 = a - 1\n    findAns (x:xs@(y:z:_))\n      | x == y || x == z = min y z\n      | otherwise = findAns xs\n\nmain :: IO ()\nmain = do\n  print $ root 3 8\n  print $ root 3 9\n  print $ root 2 (2 * 100 ^ 2000) \n", "target": "using System;\nusing System.Numerics;\n\nnamespace IntegerRoots {\n    class Program {\n        static BigInteger IRoot(BigInteger @base, int n) {\n            if (@base < 0 || n <= 0) {\n                throw new ArgumentException();\n            }\n\n            int n1 = n - 1;\n            BigInteger n2 = n;\n            BigInteger n3 = n1;\n            BigInteger c = 1;\n            BigInteger d = (n3 + @base) / n2;\n            BigInteger e = ((n3 * d) + (@base / BigInteger.Pow(d, n1))) / n2;\n            while (c != d && c != e) {\n                c = d;\n                d = e;\n                e = (n3 * e + @base / BigInteger.Pow(e, n1)) / n2;\n            }\n            if (d < e) {\n                return d;\n            }\n            return e;\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"3rd integer root of 8 = {0}\", IRoot(8, 3));\n            Console.WriteLine(\"3rd integer root of 9 = {0}\", IRoot(9, 3));\n\n            BigInteger b = BigInteger.Pow(100, 2000) * 2;\n            Console.WriteLine(\"First 2001 digits of the sqaure root of 2: {0}\", IRoot(b, 2));\n        }\n    }\n}\n"}
{"id": 346905, "name": "Integer roots", "source": "Translate Haskell to C#: root :: Integer -> Integer -> Integer\nroot a b = findAns $ iterate (\\x -> (a1 * x + b `div` (x ^ a1)) `div` a) 1\n  where\n    a1 = a - 1\n    findAns (x:xs@(y:z:_))\n      | x == y || x == z = min y z\n      | otherwise = findAns xs\n\nmain :: IO ()\nmain = do\n  print $ root 3 8\n  print $ root 3 9\n  print $ root 2 (2 * 100 ^ 2000) \n", "target": "using System;\nusing System.Numerics;\n\nnamespace IntegerRoots {\n    class Program {\n        static BigInteger IRoot(BigInteger @base, int n) {\n            if (@base < 0 || n <= 0) {\n                throw new ArgumentException();\n            }\n\n            int n1 = n - 1;\n            BigInteger n2 = n;\n            BigInteger n3 = n1;\n            BigInteger c = 1;\n            BigInteger d = (n3 + @base) / n2;\n            BigInteger e = ((n3 * d) + (@base / BigInteger.Pow(d, n1))) / n2;\n            while (c != d && c != e) {\n                c = d;\n                d = e;\n                e = (n3 * e + @base / BigInteger.Pow(e, n1)) / n2;\n            }\n            if (d < e) {\n                return d;\n            }\n            return e;\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"3rd integer root of 8 = {0}\", IRoot(8, 3));\n            Console.WriteLine(\"3rd integer root of 9 = {0}\", IRoot(9, 3));\n\n            BigInteger b = BigInteger.Pow(100, 2000) * 2;\n            Console.WriteLine(\"First 2001 digits of the sqaure root of 2: {0}\", IRoot(b, 2));\n        }\n    }\n}\n"}
{"id": 346906, "name": "Find the last Sunday of each month", "source": "Translate Haskell to C#: import Data.List (find, intercalate, transpose)\nimport Data.Maybe (fromJust)\nimport Data.Time.Calendar\n  ( Day,\n    addDays,\n    fromGregorian,\n    gregorianMonthLength,\n    showGregorian,\n  )\nimport Data.Time.Calendar.WeekDate (toWeekDate)\n\n\n\nlastSundayOfEachMonth = lastWeekDayDates 7\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    ( intercalate \"  \"\n        <$> transpose\n          (lastSundayOfEachMonth <$> [2013 .. 2017])\n    )\n\n\n\nlastWeekDayDates :: Int -> Integer -> [String]\nlastWeekDayDates dayOfWeek year =\n  (showGregorian . mostRecentWeekday dayOfWeek)\n    . (fromGregorian year <*> gregorianMonthLength year)\n    <$> [1 .. 12]\n\nmostRecentWeekday :: Int -> Day -> Day\nmostRecentWeekday dayOfWeek date =\n  fromJust\n    (find p ((`addDays` date) <$> [-6 .. 0]))\n  where\n    p x =\n      let (_, _, day) = toWeekDate x\n       in dayOfWeek == day\n", "target": "using System;\n\nnamespace LastSundayOfEachMonth\n{\n    class Program\n    {\n        static void Main()\n        {\n            Console.Write(\"Year to calculate: \");\n\n            string strYear = Console.ReadLine();\n            int year = Convert.ToInt32(strYear);\n\n            DateTime date;\n            for (int i = 1; i <= 12; i++)\n            {\n                date = new DateTime(year, i, DateTime.DaysInMonth(year, i), System.Globalization.CultureInfo.CurrentCulture.Calendar);\n                \n                \n                int daysOffset = date.DayOfWeek - dayOfWeek; \n                if (daysOffset < 0) daysOffset += 7; \n                date = date.AddDays(-daysOffset ); \n                Console.WriteLine(date.ToString(\"yyyy-MM-dd\"));\n            }\n        }\n    }\n}\n"}
{"id": 346907, "name": "Random Latin squares", "source": "Translate Haskell to C#: import Data.List (permutations, (\\\\))\n\nlatinSquare :: Eq a => [a] -> [a] -> [[a]]\nlatinSquare [] [] = []\nlatinSquare c r\n  | head r /= head c = []\n  | otherwise = reverse <$> foldl addRow firstRow perms\n  where\n    \n    perms =\n      tail $\n        fmap\n          (fmap . (:) <*> (permutations . (r \\\\) . return))\n          c\n    firstRow = pure <$> r\n    addRow tbl rows =\n      head\n        [ zipWith (:) row tbl\n          | row <- rows,\n            and $ different (tail row) (tail tbl)\n        ]\n    different = zipWith $ (not .) . elem\n\nprintTable :: Show a => [[a]] -> IO ()\nprintTable tbl =\n  putStrLn $\n    unlines $\n      unwords . map show <$> tbl\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RandomLatinSquares {\n    using Matrix = List<List<int>>;\n\n    \n    static class Helper {\n        private static readonly Random rng = new Random();\n\n        public static void Shuffle<T>(this IList<T> list) {\n            int n = list.Count;\n            while (n > 1) {\n                n--;\n                int k = rng.Next(n + 1);\n                T value = list[k];\n                list[k] = list[n];\n                list[n] = value;\n            }\n        }\n    }\n\n    class Program {\n        static void PrintSquare(Matrix latin) {\n            foreach (var row in latin) {\n                Console.Write('[');\n\n                var it = row.GetEnumerator();\n                if (it.MoveNext()) {\n                    Console.Write(it.Current);\n                }\n                while (it.MoveNext()) {\n                    Console.Write(\", \");\n                    Console.Write(it.Current);\n                }\n\n                Console.WriteLine(']');\n            }\n            Console.WriteLine();\n        }\n\n        static void LatinSquare(int n) {\n            if (n <= 0) {\n                Console.WriteLine(\"[]\");\n                return;\n            }\n\n            var latin = new Matrix();\n            for (int i = 0; i < n; i++) {\n                List<int> temp = new List<int>();\n                for (int j = 0; j < n; j++) {\n                    temp.Add(j);\n                }\n                latin.Add(temp);\n            }\n            \n            latin[0].Shuffle();\n\n            \n            for (int i = 1; i < n - 1; i++) {\n                bool shuffled = false;\n\n                while (!shuffled) {\n                    latin[i].Shuffle();\n                    for (int k = 0; k < i; k++) {\n                        for (int j = 0; j < n; j++) {\n                            if (latin[k][j] == latin[i][j]) {\n                                goto shuffling;\n                            }\n                        }\n                    }\n                    shuffled = true;\n\n                shuffling: { }\n                }\n            }\n\n            \n            for (int j = 0; j < n; j++) {\n                List<bool> used = new List<bool>();\n                for (int i = 0; i < n; i++) {\n                    used.Add(false);\n                }\n\n                for (int i = 0; i < n-1; i++) {\n                    used[latin[i][j]] = true;\n                }\n                for (int k = 0; k < n; k++) {\n                    if (!used[k]) {\n                        latin[n - 1][j] = k;\n                        break;\n                    }\n                }\n            }\n\n            PrintSquare(latin);\n        }\n\n        static void Main() {\n            LatinSquare(5);\n            LatinSquare(5);\n            LatinSquare(10); \n        }\n    }\n}\n"}
{"id": 346908, "name": "RPG attributes generator", "source": "Translate Haskell to C#: import Control.Monad (replicateM)\nimport System.Random (randomRIO)\nimport Data.Bool (bool)\nimport Data.List (sort)\n\ncharacter :: IO [Int]\ncharacter =\n  discardUntil\n    (((&&) . (75 <) . sum) <*> ((2 <=) . length . filter (15 <=)))\n    (replicateM 6 $ sum . tail . sort <$> replicateM 4 (randomRIO (1, 6 :: Int)))\n\ndiscardUntil :: ([Int] -> Bool) -> IO [Int] -> IO [Int]\ndiscardUntil p throw = go\n  where\n    go = throw >>= (<*>) (bool go . return) p\n\n\nmain :: IO ()\nmain = replicateM 10 character >>= mapM_ (print . (sum >>= (,)))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Module1\n{\n    static Random r = new Random();\n\n    static List<int> getThree(int n)\n    {\n        List<int> g3 = new List<int>();\n        for (int i = 0; i < 4; i++) g3.Add(r.Next(n) + 1);\n        g3.Sort(); g3.RemoveAt(0); return g3;\n    }\n\n    static List<int> getSix()\n    {\n        List<int> g6 = new List<int>();\n        for (int i = 0; i < 6; i++) g6.Add(getThree(6).Sum());\n        return g6;\n    }\n\n    static void Main(string[] args)\n    {\n        bool good = false; do {\n            List<int> gs = getSix(); int gss = gs.Sum(); int hvc = gs.FindAll(x => x > 14).Count;\n            Console.Write(\"attribs: {0}, sum={1}, ({2} sum, high vals={3})\",\n                          string.Join(\", \", gs), gss, gss >= 75 ? \"good\" : \"low\", hvc);\n            Console.WriteLine(\" - {0}\", (good = gs.Sum() >= 75 && hvc > 1) ? \"success\" : \"failure\");\n        } while (!good);\n    }\n}\n"}
{"id": 346909, "name": "Kolakoski sequence", "source": "Translate Haskell to C#: import Data.List (group)\nimport Control.Monad (forM_)\n\nreplicateAtLeastOne :: Int -> a -> [a]\nreplicateAtLeastOne n x = x : replicate (n-1) x\n\nzipWithLazy :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWithLazy f ~(x:xs) ~(y:ys) = f x y : zipWithLazy f xs ys\n\nkolakoski :: [Int] -> [Int]\nkolakoski items = s\n  where s = concat $ zipWithLazy replicateAtLeastOne s $ cycle items\n\nrle :: Eq a => [a] -> [Int]\nrle = map length . group\n\nsameAsRleUpTo :: Int -> [Int] -> Bool\nsameAsRleUpTo n s = r == take (length r) prefix\n  where prefix = take n s\n        r = init $ rle prefix\n\nmain :: IO ()\nmain = forM_ [([1, 2], 20),\n              ([2, 1], 20), \n              ([1, 3, 1, 2], 30),\n              ([1, 3, 2, 1], 30)]\n        $ \\(items, n) -> do\n          putStrLn $ \"First \" ++ show n ++ \" members of the sequence generated by \" ++ show items ++ \":\"\n          let s = kolakoski items\n          print $ take n s\n          putStrLn $ \"Possible Kolakoski sequence? \" ++ show (sameAsRleUpTo n s)\n          putStrLn \"\"\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace KolakoskiSequence {\n    class Crutch {\n        public readonly int len;\n        public int[] s;\n        public int i;\n\n        public Crutch(int len) {\n            this.len = len;\n            s = new int[len];\n            i = 0;\n        }\n\n        public void Repeat(int count) {\n            for (int j = 0; j < count; j++) {\n                if (++i == len) return;\n                s[i] = s[i - 1];\n            }\n        }\n    }\n\n    static class Extension {\n        public static int NextInCycle(this int[] self, int index) {\n            return self[index % self.Length];\n        }\n\n        public static int[] Kolakoski(this int[] self, int len) {\n            Crutch c = new Crutch(len);\n\n            int k = 0;\n            while (c.i < len) {\n                c.s[c.i] = self.NextInCycle(k);\n                if (c.s[k] > 1) {\n                    c.Repeat(c.s[k] - 1);\n                }\n                if (++c.i == len) return c.s;\n                k++;\n            }\n            return c.s;\n        }\n\n        public static bool PossibleKolakoski(this int[] self) {\n            int[] rle = new int[self.Length];\n            int prev = self[0];\n            int count = 1;\n            int pos = 0;\n            for (int i = 1; i < self.Length; i++) {\n                if (self[i] == prev) {\n                    count++;\n                }\n                else {\n                    rle[pos++] = count;\n                    count = 1;\n                    prev = self[i];\n                }\n            }\n            \n            for (int i = 0; i < pos; i++) {\n                if (rle[i] != self[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public static string AsString(this int[] self) {\n            StringBuilder sb = new StringBuilder(\"[\");\n            int count = 0;\n            foreach (var item in self) {\n                if (count > 0) {\n                    sb.Append(\", \");\n                }\n                sb.Append(item);\n                count++;\n            }\n            return sb.Append(\"]\").ToString();\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            int[][] ias = {\n                new int[]{1, 2},\n                new int[]{2, 1},\n                new int[]{1, 3, 1, 2},\n                new int[]{1, 3, 2, 1}\n            };\n            int[] lens = { 20, 20, 30, 30 };\n\n            for (int i = 0; i < ias.Length; i++) {\n                int len = lens[i];\n                int[] kol = ias[i].Kolakoski(len);\n\n                Console.WriteLine(\"First {0} members of the sequence by {1}: \", len, ias[i].AsString());\n                Console.WriteLine(kol.AsString());\n                Console.WriteLine(\"Possible Kolakoski sequence? {0}\", kol.PossibleKolakoski());\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 346910, "name": "Longest increasing subsequence", "source": "Translate Haskell to C#: import Data.Ord          ( comparing )\nimport Data.List         ( maximumBy, subsequences )\nimport Data.List.Ordered ( isSorted, nub )\n\nlis :: Ord a => [a] -> [a]\nlis = maximumBy (comparing length) . map nub  . filter isSorted . subsequences                 \n\n\nmain = do\n  print $ lis [3,2,6,4,5,1]\n  print $ lis [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]\n  print $ lis [1,1,1,1]\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class LIS\n{\n    public static IEnumerable<T> FindRec<T>(IList<T> values, IComparer<T> comparer = null) =>\n        values == null ? throw new ArgumentNullException() :\n            FindRecImpl(values, Sequence<T>.Empty, 0, comparer ?? Comparer<T>.Default).Reverse();\n\n    private static Sequence<T> FindRecImpl<T>(IList<T> values, Sequence<T> current, int index, IComparer<T> comparer) {\n        if (index == values.Count) return current;\n        if (current.Length > 0 && comparer.Compare(values[index], current.Value) <= 0)\n            return FindRecImpl(values, current, index + 1, comparer);\n        return Max(\n            FindRecImpl(values, current, index + 1, comparer),\n            FindRecImpl(values, current + values[index], index + 1, comparer)\n        );\n    }\n\n    private static Sequence<T> Max<T>(Sequence<T> a, Sequence<T> b) => a.Length < b.Length ? b : a;\n\n    class Sequence<T> : IEnumerable<T>\n    {\n        public static readonly Sequence<T> Empty = new Sequence<T>(default(T), null);\n\n        public Sequence(T value, Sequence<T> tail)\n        {\n            Value = value;\n            Tail = tail;\n            Length = tail == null ? 0 : tail.Length + 1;\n        }\n\n        public T Value { get; }\n        public Sequence<T> Tail { get; }\n        public int Length { get; }\n\n        public static Sequence<T> operator +(Sequence<T> s, T value) => new Sequence<T>(value, s);\n\n        public IEnumerator<T> GetEnumerator()\n        {\n            for (var s = this; s.Length > 0; s = s.Tail) yield return s.Value;\n        }\n\n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n    }\n}\n"}
{"id": 346911, "name": "Dynamic variable names", "source": "Translate Haskell to C#: data Var a = Var String a deriving Show\nmain = do\n    putStrLn \"please enter you variable name\"\n    vName <- getLine\n    let var = Var vName 42\n    putStrLn $ \"this is your variable: \" ++ show var\n", "target": "using System;\nusing System.Dynamic;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string varname = Console.ReadLine();\n        \n        dynamic expando = new ExpandoObject();\n        var map = expando as IDictionary<string, object>;\n        map.Add(varname, \"Hello world!\");\n \n        Console.WriteLine(expando.foo);\n    }\n}\n"}
{"id": 346912, "name": "Comments", "source": "Translate Haskell to C#: i code = True \n\n\n   let u x = x x (this code not compiled)\n   Are you? -}\n\n\ni code = True\n\n\n\ni code = True\n", "target": "\n\n\n\n\n\n"}
{"id": 346913, "name": "Read a file character by character_UTF8", "source": "Translate Haskell to C#: #!/usr/bin/env runhaskell\n\n\n\nimport System.Environment (getArgs)\nimport System.IO (\n        Handle, IOMode (..),\n        hGetChar, hIsEOF, hSetEncoding, stdin, utf8, withFile\n    )\nimport Control.Monad (forM_, unless)\nimport Text.Printf (printf)\nimport Data.Char (ord)\n\nprocessCharacters :: Handle -> IO ()\nprocessCharacters h = do\n  done <- hIsEOF h\n  unless done $ do\n    c <- hGetChar h\n    putStrLn $ printf \"U+%04X\" (ord c)\n    processCharacters h\n\nprocessOneFile :: Handle -> IO ()\nprocessOneFile h = do\n  hSetEncoding h utf8\n  processCharacters h\n\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  case args of\n    [] -> processOneFile stdin\n    xs -> forM_ xs $ \\name -> do\n      putStrLn name\n      withFile name ReadMode processOneFile\n", "target": "using System;\nusing System.IO;\nusing System.Text;\n\nnamespace RosettaFileByChar\n{\n    class Program\n    {\n        static char GetNextCharacter(StreamReader streamReader) => (char)streamReader.Read();\n\n        static void Main(string[] args)\n        {\n            Console.OutputEncoding = Encoding.UTF8;\n            char c;\n            using (FileStream fs = File.OpenRead(\"input.txt\"))\n            {\n                using (StreamReader streamReader = new StreamReader(fs, Encoding.UTF8))\n                {\n                    while (!streamReader.EndOfStream)\n                    {\n                        c = GetNextCharacter(streamReader);\n                        Console.Write(c);\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 346914, "name": "Smallest square that begins with n", "source": "Translate Haskell to C#: import Control.Monad (join)\nimport Data.List (find, intercalate, isPrefixOf, transpose)\nimport Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\n\n\nfirstSquareWithPrefix :: Int -> Int\nfirstSquareWithPrefix n = unDigits match\n  where\n    ds = digits n\n    Just match = find (isPrefixOf ds) squareDigits\n\nsquareDigits :: [[Int]]\nsquareDigits = digits . join (*) <$> [0 ..]\n\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n    table \"  \" $\n      chunksOf 10 $\n        show . firstSquareWithPrefix <$> [1 .. 49]\n\n\n\ndigits :: Int -> [Int]\ndigits = fmap (read . return) . show\n\nunDigits :: [Int] -> Int\nunDigits = foldl ((+) . (10 *)) 0\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int i, d, s, t, n = 50, c = 1;\n        var sw = new int[n];\n        for (i = d = s = 1; c < n; i++, s += d += 2)\n            for (t = s; t > 0; t /= 10)\n                if (t < n && sw[t] < 1)\n                    Console.Write(\"\", sw[t] = s, c++);\n        Console.Write(string.Join(\" \", sw).Substring(2));\n    }\n}\n"}
{"id": 346915, "name": "Smallest square that begins with n", "source": "Translate Haskell to C#: import Control.Monad (join)\nimport Data.List (find, intercalate, isPrefixOf, transpose)\nimport Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\n\n\nfirstSquareWithPrefix :: Int -> Int\nfirstSquareWithPrefix n = unDigits match\n  where\n    ds = digits n\n    Just match = find (isPrefixOf ds) squareDigits\n\nsquareDigits :: [[Int]]\nsquareDigits = digits . join (*) <$> [0 ..]\n\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n    table \"  \" $\n      chunksOf 10 $\n        show . firstSquareWithPrefix <$> [1 .. 49]\n\n\n\ndigits :: Int -> [Int]\ndigits = fmap (read . return) . show\n\nunDigits :: [Int] -> Int\nunDigits = foldl ((+) . (10 *)) 0\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int i, d, s, t, n = 50, c = 1;\n        var sw = new int[n];\n        for (i = d = s = 1; c < n; i++, s += d += 2)\n            for (t = s; t > 0; t /= 10)\n                if (t < n && sw[t] < 1)\n                    Console.Write(\"\", sw[t] = s, c++);\n        Console.Write(string.Join(\" \", sw).Substring(2));\n    }\n}\n"}
{"id": 346916, "name": "Brace expansion", "source": "Translate Haskell to C#: import qualified Text.Parsec as P\n\nshowExpansion :: String -> String\nshowExpansion =\n  (<>) . (<> \"\\n\n\nparser :: P.Parsec String u [String]\nparser = expansion P.anyChar\n\nexpansion :: P.Parsec String u Char -> P.Parsec String u [String]\nexpansion =\n  fmap expand .\n  P.many .\n  ((P.try alts P.<|> P.try alt1 P.<|> escape) P.<|>) . fmap (pure . pure)\n\nexpand :: [[String]] -> [String]\nexpand = foldr ((<*>) . fmap (<>)) [[]]\n\nalts :: P.Parsec String u [String]\nalts = concat <$> P.between (P.char '{') (P.char '}') (alt `sepBy2` P.char ',')\n\nalt :: P.Parsec String u [String]\nalt = expansion (P.noneOf \",}\")\n\nalt1 :: P.Parsec String u [String]\nalt1 =\n  (\\x -> ['{' : (x <> \"}\")]) <$>\n  P.between (P.char '{') (P.char '}') (P.many $ P.noneOf \",{}\")\n\nsepBy2 :: P.Parsec String u a -> P.Parsec String u b -> P.Parsec String u [a]\np `sepBy2` sep = (:) <$> p <*> P.many1 (sep >> p)\n\nescape :: P.Parsec String u [String]\nescape = pure <$> sequence [P.char '\\\\', P.anyChar]\n\nmain :: IO ()\nmain =\n  mapM_\n    (putStrLn . showExpansion)\n    [ \"~/{Downloads,Pictures}/*.{jpg,gif,png}\"\n    , \"It{{em,alic}iz,erat}e{d,}, please.\"\n    , \"{,{,gotta have{ ,\\\\, again\\\\, }}more }cowbell!\"\n    , \"{}} some }{,{\\\\\\\\{ edge, edge} \\\\,}{ cases, {here} \\\\\\\\\\\\\\\\\\\\}\"\n    ]\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing static System.Linq.Enumerable;\n\npublic static class BraceExpansion\n{\n    enum TokenType { OpenBrace, CloseBrace, Separator, Text, Alternate, Concat }\n    const char L = '{', R = '}', S = ',';\n    \n    public static void Main() {\n        string[] input = {\n            \"It{{em,alic}iz,erat}e{d,}, please.\",\n            \"~/{Downloads,Pictures}/*.{jpg,gif,png}\",\n            @\"{,{,gotta have{ ,\\, again\\, }}more }cowbell!\",\n            @\"{}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\}\"\n        };\n        foreach (string text in input) Expand(text);\n    }\n    \n    static void Expand(string input) {\n        Token token = Tokenize(input);\n        foreach (string value in token) Console.WriteLine(value);\n        Console.WriteLine();\n    }\n    \n    static Token Tokenize(string input) {\n        var tokens = new List<Token>();\n        var buffer = new StringBuilder();\n        bool escaping = false;\n        int level = 0;\n        \n        foreach (char c in input) {\n            (escaping, level, tokens, buffer) = c switch {\n                _ when escaping => (false, level, tokens, buffer.Append(c)),\n                '\\\\' => (true, level, tokens, buffer.Append(c)),\n                L => (escaping, level + 1,\n                    tokens.With(buffer.Flush()).With(new Token(c.ToString(), TokenType.OpenBrace)), buffer),\n                S when level > 0 => (escaping, level,\n                    tokens.With(buffer.Flush()).With(new Token(c.ToString(), TokenType.Separator)), buffer),\n                R when level > 0 => (escaping, level - 1,\n                    tokens.With(buffer.Flush()).With(new Token(c.ToString(), TokenType.CloseBrace)).Merge(), buffer),\n                _ => (escaping, level, tokens, buffer.Append(c))\n            };\n        }\n        if (buffer.Length > 0) tokens.Add(buffer.Flush());\n        for (int i = 0; i < tokens.Count; i++) {\n            if (tokens[i].Type == TokenType.OpenBrace || tokens[i].Type == TokenType.Separator) {\n                tokens[i] = tokens[i].Value; \n            }\n        }\n        return new Token(tokens, TokenType.Concat);\n    }\n    \n    static List<Token> Merge(this List<Token> list) {\n        int separators = 0;\n        int last = list.Count - 1;\n        for (int i = list.Count - 3; i >= 0; i--) {\n            if (list[i].Type == TokenType.Separator) {\n                separators++;\n                Concat(list, i + 1, last);\n                list.RemoveAt(i);\n                last = i;\n            } else if (list[i].Type == TokenType.OpenBrace) {\n                Concat(list, i + 1, last);\n                if (separators > 0) {\n                    list[i] = new Token(list.Range((i+1)..^1), TokenType.Alternate);\n                    list.RemoveRange(i+1, list.Count - i - 1);\n                } else {\n                    list[i] = L.ToString();\n                    list[^1] = R.ToString();\n                    Concat(list, i, list.Count);\n                }\n                break;\n            }\n        }\n        return list;\n    }\n    \n    static void Concat(List<Token> list, int s, int e) {\n        for (int i = e - 2; i >= s; i--) {\n            (Token a, Token b) = (list[i], list[i+1]);\n            switch (a.Type, b.Type) {\n                case (TokenType.Text, TokenType.Text):\n                    list[i] = a.Value + b.Value;\n                    list.RemoveAt(i+1);\n                    break;\n                case (TokenType.Concat, TokenType.Concat):\n                    a.SubTokens.AddRange(b.SubTokens);\n                    list.RemoveAt(i+1);\n                    break;\n                case (TokenType.Concat, TokenType.Text) when b.Value == \"\":\n                    list.RemoveAt(i+1);\n                    break;\n                case (TokenType.Text, TokenType.Concat) when a.Value == \"\":\n                    list.RemoveAt(i);\n                    break;\n                default:\n                    list[i] = new Token(new [] { a, b }, TokenType.Concat);\n                    list.RemoveAt(i+1);\n                    break;\n            }\n        }\n    }\n    \n    private struct Token : IEnumerable<string>\n    {\n        private List<Token>? _subTokens;\n        \n        public string Value { get; }\n        public TokenType Type { get; }\n        public List<Token> SubTokens => _subTokens ??= new List<Token>();\n        \n        public Token(string value, TokenType type) => (Value, Type, _subTokens) = (value, type, null);\n        public Token(IEnumerable<Token> subTokens, TokenType type) => (Value, Type, _subTokens) = (\"\", type, subTokens.ToList());\n        \n        public static implicit operator Token(string value) => new Token(value, TokenType.Text);\n        \n        public IEnumerator<string> GetEnumerator() => (Type switch\n        {\n            TokenType.Concat => SubTokens.Select(t => t.AsEnumerable()).CartesianProduct().Select(p => string.Join(\"\", p)),\n            TokenType.Alternate => from t in SubTokens from s in t select s,\n            _ => Repeat(Value, 1)\n        }).GetEnumerator();\n        \n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();        \n    }\n    \n    \n    static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> sequences) {\n        IEnumerable<IEnumerable<T>> emptyProduct = new[] { Empty<T>() };\n        return sequences.Aggregate(\n            emptyProduct,\n            (accumulator, sequence) =>\n                from acc in accumulator\n                from item in sequence\n                select acc.Concat(new [] { item }));\n    }\n    \n    static List<Token> With(this List<Token> list, Token token) {\n        list.Add(token);\n        return list;\n    }\n    \n    static IEnumerable<Token> Range(this List<Token> list, Range range) {\n        int start = range.Start.GetOffset(list.Count);\n        int end = range.End.GetOffset(list.Count);\n        for (int i = start; i < end; i++) yield return list[i];\n    }\n    \n    static string Flush(this StringBuilder builder) {\n        string result = builder.ToString();\n        builder.Clear();\n        return result;\n    }\n}\n"}
{"id": 346917, "name": "Intersecting number wheels", "source": "Translate Haskell to C#: import Data.Char (isDigit)\nimport Data.List (mapAccumL)\nimport qualified Data.Map.Strict as M\nimport Data.Maybe (fromMaybe)\n\n\n\nclockWorkTick ::\n  M.Map Char String ->\n  (M.Map Char String, Char)\nclockWorkTick = flip click 'A'\n  where\n    click wheels name\n      | isDigit name = (wheels, name)\n      | otherwise =\n        ( click\n            . flip\n              (M.insert name . leftRotate)\n              wheels\n            <*> head\n        )\n          $ fromMaybe ['?'] $ M.lookup name wheels\n\nleftRotate :: [a] -> [a]\nleftRotate = take . length <*> (tail . cycle)\n\n\nmain :: IO ()\nmain = do\n  let wheelSets =\n        [ [('A', \"123\")],\n          [('A', \"1B2\"), ('B', \"34\")],\n          [('A', \"1DD\"), ('D', \"678\")],\n          [('A', \"1BC\"), ('B', \"34\"), ('C', \"5B\")]\n        ]\n  putStrLn \"State of each wheel-set after 20 clicks:\\n\"\n  mapM_ print $\n    fmap\n      ( flip\n          (mapAccumL (const . clockWorkTick))\n          (replicate 20 undefined)\n          . M.fromList\n      )\n      wheelSets\n  putStrLn \"\\nInitial state of the wheel-sets:\\n\"\n  mapM_ print wheelSets\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class IntersectingNumberWheels\n{\n    public static void Main() {\n        TurnWheels(('A', \"123\")).Take(20).Print();\n        TurnWheels(('A', \"1B2\"), ('B', \"34\")).Take(20).Print();\n        TurnWheels(('A', \"1DD\"), ('D', \"678\")).Take(20).Print();\n        TurnWheels(('A', \"1BC\"), ('B', \"34\"), ('C', \"5B\")).Take(20).Print();\n    }\n\n    static IEnumerable<char> TurnWheels(params (char name, string values)[] wheels) {\n        var data = wheels.ToDictionary(wheel => wheel.name, wheel => wheel.values.Loop().GetEnumerator());\n        var primary = data[wheels[0].name];\n        while (true) {\n            yield return Turn(primary);\n        }\n\n        char Turn(IEnumerator<char> sequence) {\n            sequence.MoveNext();\n            char c = sequence.Current;\n            return char.IsDigit(c) ? c : Turn(data[c]);\n        }\n    }\n\n    static IEnumerable<T> Loop<T>(this IEnumerable<T> seq) {\n        while (true) {\n            foreach (T element in seq) yield return element;\n        }\n    }\n\n    static void Print(this IEnumerable<char> sequence) => Console.WriteLine(string.Join(\" \", sequence));\n}\n"}
{"id": 346918, "name": "Intersecting number wheels", "source": "Translate Haskell to C#: import Data.Char (isDigit)\nimport Data.List (mapAccumL)\nimport qualified Data.Map.Strict as M\nimport Data.Maybe (fromMaybe)\n\n\n\nclockWorkTick ::\n  M.Map Char String ->\n  (M.Map Char String, Char)\nclockWorkTick = flip click 'A'\n  where\n    click wheels name\n      | isDigit name = (wheels, name)\n      | otherwise =\n        ( click\n            . flip\n              (M.insert name . leftRotate)\n              wheels\n            <*> head\n        )\n          $ fromMaybe ['?'] $ M.lookup name wheels\n\nleftRotate :: [a] -> [a]\nleftRotate = take . length <*> (tail . cycle)\n\n\nmain :: IO ()\nmain = do\n  let wheelSets =\n        [ [('A', \"123\")],\n          [('A', \"1B2\"), ('B', \"34\")],\n          [('A', \"1DD\"), ('D', \"678\")],\n          [('A', \"1BC\"), ('B', \"34\"), ('C', \"5B\")]\n        ]\n  putStrLn \"State of each wheel-set after 20 clicks:\\n\"\n  mapM_ print $\n    fmap\n      ( flip\n          (mapAccumL (const . clockWorkTick))\n          (replicate 20 undefined)\n          . M.fromList\n      )\n      wheelSets\n  putStrLn \"\\nInitial state of the wheel-sets:\\n\"\n  mapM_ print wheelSets\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class IntersectingNumberWheels\n{\n    public static void Main() {\n        TurnWheels(('A', \"123\")).Take(20).Print();\n        TurnWheels(('A', \"1B2\"), ('B', \"34\")).Take(20).Print();\n        TurnWheels(('A', \"1DD\"), ('D', \"678\")).Take(20).Print();\n        TurnWheels(('A', \"1BC\"), ('B', \"34\"), ('C', \"5B\")).Take(20).Print();\n    }\n\n    static IEnumerable<char> TurnWheels(params (char name, string values)[] wheels) {\n        var data = wheels.ToDictionary(wheel => wheel.name, wheel => wheel.values.Loop().GetEnumerator());\n        var primary = data[wheels[0].name];\n        while (true) {\n            yield return Turn(primary);\n        }\n\n        char Turn(IEnumerator<char> sequence) {\n            sequence.MoveNext();\n            char c = sequence.Current;\n            return char.IsDigit(c) ? c : Turn(data[c]);\n        }\n    }\n\n    static IEnumerable<T> Loop<T>(this IEnumerable<T> seq) {\n        while (true) {\n            foreach (T element in seq) yield return element;\n        }\n    }\n\n    static void Print(this IEnumerable<char> sequence) => Console.WriteLine(string.Join(\" \", sequence));\n}\n"}
{"id": 346919, "name": "Yahoo! search interface", "source": "Translate Haskell to C#: import Network.HTTP\nimport Text.Parsec\n\ndata YahooSearchItem = YahooSearchItem {\n    itemUrl, itemTitle, itemContent :: String }\n\ndata YahooSearch = YahooSearch {\n    searchQuery :: String,\n    searchPage :: Int,\n    searchItems :: [YahooSearchItem] }\n    \n\nyahooUrl = \"http://search.yahoo.com/search?p=\"\n\n\nyahoo :: String -> IO YahooSearch\nyahoo q = simpleHTTP (getRequest $ yahooUrl ++ q) >>=\n    getResponseBody >>= return . YahooSearch q 1 . items\n\n\nnext :: YahooSearch -> IO YahooSearch\nnext (YahooSearch q p _) =\n    simpleHTTP (getRequest $\n    \n    yahooUrl ++ q ++ \"&b=\" ++ show (p + 1)) >>=\n    getResponseBody >>= return . YahooSearch q (p + 1) . items\n\nprintResults :: YahooSearch -> IO ()\nprintResults (YahooSearch q p items) = do\n    putStrLn $ \"Showing Yahoo! search results for query: \" ++ q\n    putStrLn $ \"Page: \" ++ show p\n    putChar '\\n'\n    mapM_ printOne items\n    where\n        printOne (YahooSearchItem itemUrl itemTitle itemContent) = do\n            putStrLn $ \"URL  \u00a0: \" ++ itemUrl\n            putStrLn $ \"Title\u00a0: \" ++ itemTitle\n            putStrLn $ \"Abstr\u00a0: \" ++ itemContent\n            putChar '\\n'\n\nurlTag, titleTag, contentTag1, contentTag2, ignoreTag,\n    ignoreText :: Parsec String () String\n    \n\nurlTag = do { string \"<a id=\\\"link-\";\n    many digit; string \"\\\" class=\\\"yschttl spt\\\" href=\\\"\";\n    url <- manyTill anyChar (char '\"'); manyTill anyChar (char '>');\n    return url }\n\n\n\ntitleTag = do { urlTag; manyTill anyChar (try (string \"</a>\")) }\n\n\n\ncontentTag1 = do { string \"<div class=\\\"sm-abs\\\">\";\n    manyTill anyChar (try (string \"</div>\")) }\n\ncontentTag2 = do { string \"<div class=\\\"abstr\\\">\";\n    manyTill anyChar (try (string \"</div>\")) }\n\n\nignoreTag = do { char ('<'); manyTill anyChar (char '>');\n    return \"\" }\n\n\nignoreText = do { many1 (noneOf \"<\"); return \"\" }\n\n\nnonempty :: [String] -> Parsec String () [String]\nnonempty xs = return [ x | x <- xs, not (null x) ]\n\n\n\nparseCategory x = do\n    res <- many x\n    eof\n    nonempty res\n    \nurls, titles, contents :: Parsec String () [String]\n\n\nurls = parseCategory url where\n    url = (try urlTag) <|> ignoreTag <|> ignoreText\n\n\ntitles = parseCategory title where\n    title = (try titleTag) <|> ignoreTag <|> ignoreText\n\n\ncontents = parseCategory content where\n    content = (try contentTag1) <|> (try contentTag2) <|>\n        ignoreTag <|> ignoreText\n\n\n\n\nitems :: String -> [YahooSearchItem]\nitems q =\n    let ignoreOrKeep = either (const []) id\n        us = ignoreOrKeep $ parse urls \"\" q\n        ts = ignoreOrKeep $ parse titles \"\" q\n        cs = ignoreOrKeep $ parse contents \"\" q\n    in [ YahooSearchItem { itemUrl = u, itemTitle = t, itemContent = c } |\n        (u, t, c) <- zip3 us ts cs ]\n", "target": "using System;\nusing System.Net;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\n\nclass YahooSearch {\n    private string query;\n    private string content;\n    private int page;\n\n    const string yahoo = \"http:\n\n    public YahooSearch(string query) : this(query, 0) { }\n\n    public YahooSearch(string query, int page) {\n        this.query = query;\n        this.page = page;\n        this.content = new WebClient()\n            .DownloadString(\n                string.Format(yahoo + \"p={0}&b={1}\", query, this.page * 10 + 1)\n            );\n    }\n\n    public YahooResult[] Results {\n        get {\n            List<YahooResult> results = new List<YahooResult>();\n\n            Func<string, string, string> substringBefore = (str, before) =>\n            {\n                int iHref = str.IndexOf(before);\n                return iHref < 0 ? \"\" : str.Substring(0, iHref);\n            };\n            Func<string, string, string> substringAfter = (str, after) =>\n            {\n                int iHref = str.IndexOf(after);\n                return iHref < 0 ? \"\" : str.Substring(iHref + after.Length);\n            };\n            Converter<string, string> getText = p => \n                Regex.Replace(p, \"<[^>]*>\", x => \"\");\n\n            Regex rx = new Regex(@\"\n                <li>\n                    <div \\s class=\"\"res\"\">\n                        <div>\n                            <h3>\n                                <a \\s (?'LinkAttributes'[^>]+)>\n                                    (?'LinkText' .*?)\n                                (?></a>)\n                            </h3>\n                        </div>\n                        <div \\s class=\"\"abstr\"\">\n                            (?'Abstract' .*?)\n                        (?></div>)\n                        .*?\n                    (?></div>)\n                </li>\",\n                RegexOptions.IgnorePatternWhitespace\n                | RegexOptions.ExplicitCapture\n            );\n            foreach (Match e in rx.Matches(this.content)) {\n                string rurl = getText(substringBefore(substringAfter(\n                    e.Groups[\"LinkAttributes\"].Value, @\"href=\"\"\"), @\"\"\"\"));\n                string rtitle = getText(e.Groups[\"LinkText\"].Value);\n                string rcontent = getText(e.Groups[\"Abstract\"].Value);\n                \n                results.Add(new YahooResult(rurl, rtitle, rcontent));\n            }\n            return results.ToArray();\n        }\n    }\n\n    public YahooSearch NextPage() {\n        return new YahooSearch(this.query, this.page + 1);\n    }\n\n    public YahooSearch GetPage(int page) {\n        return new YahooSearch(this.query, page);\n    }\n}\n\nclass YahooResult {\n    public string URL { get; set; }\n    public string Title { get; set; }\n    public string Content { get; set; }\n\n    public YahooResult(string url, string title, string content) {\n        this.URL = url;\n        this.Title = title;\n        this.Content = content;\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"\\nTitle: {0}\\nLink:  {1}\\nText:  {2}\",\n            Title, URL, Content);\n    }\n}\n\n\n\nclass Prog {\n    static void Main() {\n        foreach (int page in new[] { 0, 1 })\n        {\n            YahooSearch x = new YahooSearch(\"test\", page);\n\n            foreach (YahooResult result in x.Results)\n            {\n                Console.WriteLine(result);\n            }\n        }\n    }\n}\n"}
{"id": 351001, "name": "Range consolidation", "source": "Translate Haskell to Python: import Data.List (intercalate, maximumBy, sort)\nimport Data.Ord (comparing)\n\n\n\nconsolidated :: [(Float, Float)] -> [(Float, Float)]\nconsolidated = foldr go [] . sort . fmap ab\n  where\n    go xy [] = [xy]\n    go xy@(x, y) abetc@((a, b) : etc)\n      | y >= b = xy : etc\n      | y >= a = (x, b) : etc\n      | otherwise = xy : abetc\n    ab (a, b)\n      | a <= b = (a, b)\n      | otherwise = (b, a)\n\n\n\ntests :: [[(Float, Float)]]\ntests =\n  [ [],\n    [(1.1, 2.2)],\n    [(6.1, 7.2), (7.2, 8.3)],\n    [(4, 3), (2, 1)],\n    [(4, 3), (2, 1), (-1, -2), (3.9, 10)],\n    [(1, 3), (-6, -1), (-4, -5), (8, 2), (-6, -6)]\n  ]\n\nmain :: IO ()\nmain =\n  putStrLn $\n    tabulated\n      \"Range consolidations:\"\n      showPairs\n      showPairs\n      consolidated\n      tests\n\n\n\ntabulated ::\n  String ->\n  (a -> String) ->\n  (b -> String) ->\n  (a -> b) ->\n  [a] ->\n  String\ntabulated s xShow fxShow f xs =\n  let w =\n        length $\n          maximumBy\n            (comparing length)\n            (xShow <$> xs)\n      rjust n c s = drop (length s) (replicate n c <> s)\n   in unlines $\n        s :\n        fmap\n          ( ((<>) . rjust w ' ' . xShow)\n              <*> ((\" -> \" <>) . fxShow . f)\n          )\n          xs\n\nshowPairs :: [(Float, Float)] -> String\nshowPairs xs\n  | null xs = \"[]\"\n  | otherwise =\n    '[' :\n    intercalate\n      \", \"\n      (showPair <$> xs)\n      <> \"]\"\n\nshowPair :: (Float, Float) -> String\nshowPair (a, b) =\n  '(' :\n  showNum a\n    <> \", \"\n    <> showNum b\n    <> \")\"\n\nshowNum :: Float -> String\nshowNum n\n  | 0 == (n - fromIntegral (round n)) = show (round n)\n  | otherwise = show n\n", "target": "def normalize(s):\n    return sorted(sorted(bounds) for bounds in s if bounds)\n\ndef consolidate(ranges):\n    norm = normalize(ranges)\n    for i, r1 in enumerate(norm):\n        if r1:\n            for r2 in norm[i+1:]:\n                if r2 and r1[-1] >= r2[0]:     \n                    r1[:] = [r1[0], max(r1[-1], r2[-1])]\n                    r2.clear()\n    return [rnge for rnge in norm if rnge]\n\nif __name__ == '__main__':\n    for s in [\n            [[1.1, 2.2]],\n            [[6.1, 7.2], [7.2, 8.3]],\n            [[4, 3], [2, 1]],\n            [[4, 3], [2, 1], [-1, -2], [3.9, 10]],\n            [[1, 3], [-6, -1], [-4, -5], [8, 2], [-6, -6]],\n            ]:\n        print(f\"{str(s)[1:-1]} => {str(consolidate(s))[1:-1]}\")\n"}
{"id": 351002, "name": "Pascal matrix generation", "source": "Translate Haskell to Python: import Data.List (transpose)\nimport System.Environment (getArgs)\nimport Text.Printf (printf)\n\n\npascal :: [[Int]]\npascal = iterate (\\row -> 1 : zipWith (+) row (tail row) ++ [1]) [1]\n\n\npascLow :: Int -> [[Int]]\npascLow n = zipWith (\\row i -> row ++ replicate (n-i) 0) (take n pascal) [1..]\n\n\npascUp :: Int -> [[Int]]\npascUp = transpose . pascLow\n\n\npascSym :: Int -> [[Int]]\npascSym n = take n . map (take n) . transpose $ pascal\n\n\nprintMat :: String -> [[Int]] -> IO ()\nprintMat title mat = do\n  putStrLn $ title ++ \"\\n\"\n  mapM_ (putStrLn . concatMap (printf \" %2d\")) mat\n  putStrLn \"\\n\"\n\nmain :: IO ()\nmain = do\n  ns <- fmap (map read) getArgs\n  case ns of\n    [n] -> do printMat \"Lower triangular\" $ pascLow n\n              printMat \"Upper triangular\" $ pascUp  n\n              printMat \"Symmetric\"        $ pascSym n\n    _   -> error \"Usage: pascmat <number>\"\n", "target": "from pprint import pprint as pp\n\ndef pascal_upp(n):\n    s = [[0] * n for _ in range(n)]\n    s[0] = [1] * n\n    for i in range(1, n):\n        for j in range(i, n):\n            s[i][j] = s[i-1][j-1] + s[i][j-1]\n    return s\n\ndef pascal_low(n):\n    \n    return [list(x) for x in zip(*pascal_upp(n))]\n\ndef pascal_sym(n):\n    s = [[1] * n for _ in range(n)]\n    for i in range(1, n):\n        for j in range(1, n):\n            s[i][j] = s[i-1][j] + s[i][j-1]\n    return s\n    \n\nif __name__ == \"__main__\":\n    n = 5\n    print(\"\\nUpper:\")\n    pp(pascal_upp(n))\n    print(\"\\nLower:\")\n    pp(pascal_low(n))\n    print(\"\\nSymmetric:\")\n    pp(pascal_sym(n))\n"}
{"id": 351003, "name": "Mad Libs", "source": "Translate Haskell to Python: import System.IO (stdout, hFlush)\n\nimport System.Environment (getArgs)\n\nimport qualified Data.Map as M (Map, lookup, insert, empty)\n\ngetLines :: IO [String]\ngetLines = reverse <$> getLines_ []\n  where\n    getLines_ xs = do\n      line <- getLine\n      case line of\n        [] -> return xs\n        _ -> getLines_ $ line : xs\n\nprompt :: String -> IO String\nprompt p = putStr p >> hFlush stdout >> getLine\n\ngetKeyword :: String -> Maybe String\ngetKeyword ('<':xs) = getKeyword_ xs []\n  where\n    getKeyword_ [] _ = Nothing\n    getKeyword_ (x:'>':_) acc = Just $ '<' : reverse ('>' : x : acc)\n    getKeyword_ (x:xs) acc = getKeyword_ xs $ x : acc\ngetKeyword _ = Nothing\n\nparseText :: String -> M.Map String String -> IO String\nparseText [] _ = return []\nparseText line@(l:lx) keywords =\n  case getKeyword line of\n    Nothing -> (l :) <$> parseText lx keywords\n    Just keyword -> do\n      let rest = drop (length keyword) line\n      case M.lookup keyword keywords of\n        Nothing -> do\n          newword <- prompt $ \"Enter a word for \" ++ keyword ++ \": \"\n          rest_ <- parseText rest $ M.insert keyword newword keywords\n          return $ newword ++ rest_\n        Just knownword -> do\n          rest_ <- parseText rest keywords\n          return $ knownword ++ rest_\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  nlines <-\n    case args of\n      [] -> unlines <$> getLines\n      arg:_ -> readFile arg\n  nlines_ <- parseText nlines M.empty\n  putStrLn \"\"\n  putStrLn nlines_\n", "target": "import re\n\n\n\n\n\ntemplate = \n\ndef madlibs(template):\n    print('The story template is:\\n' + template)\n    fields = sorted(set( re.findall('<[^>]+>', template) ))\n    values = input('\\nInput a comma-separated list of words to replace the following items'\n                   '\\n  %s: ' % ','.join(fields)).split(',')\n    story = template\n    for f,v in zip(fields, values):\n        story = story.replace(f, v)\n    print('\\nThe story becomes:\\n\\n' + story)\n\nmadlibs(template)\n"}
{"id": 351004, "name": "Shortest common supersequence", "source": "Translate Haskell to Python: scs :: Eq a  => [a] -> [a] -> [a]\nscs [] ys = ys\nscs xs [] = xs\nscs xss@(x:xs) yss@(y:ys)\n  | x == y = x : scs xs ys\n  | otherwise = ws\n      where\n      us = scs xs yss\n      vs = scs xss ys\n      ws  | length us < length vs = x : us\n          | otherwise = y : vs\n\nmain = putStrLn $ scs \"abcbdab\" \"bdcaba\"\n", "target": "\n\ndef shortest_common_supersequence(a, b):\n    lcs = longest_common_subsequence(a, b)\n    scs = \"\"\n    \n    while len(lcs) > 0:\n        if a[0]==lcs[0] and b[0]==lcs[0]:\n        \n            scs += lcs[0]\n            lcs = lcs[1:]\n            a = a[1:]\n            b = b[1:]\n        elif a[0]==lcs[0]:\n            scs += b[0]\n            b = b[1:]\n        else:\n            scs += a[0]\n            a = a[1:]\n    \n    return scs + a + b\n"}
{"id": 351005, "name": "Long year", "source": "Translate Haskell to Python: import Data.Time.Calendar (fromGregorian)\nimport Data.Time.Calendar.WeekDate (toWeekDate)\n\nlongYear :: Integer -> Bool\nlongYear y =\n  let (_, w, _) = toWeekDate $ fromGregorian y 12 28\n   in 52 < w\n\nmain :: IO ()\nmain = mapM_ print $ filter longYear [2000 .. 2100]\n", "target": "\n\nfrom datetime import date\n\n\n\ndef longYear(y):\n    \n    return 52 < date(y, 12, 28).isocalendar()[1]\n\n\n\n\ndef main():\n    \n    for year in [\n            x for x in range(2000, 1 + 2100)\n            if longYear(x)\n    ]:\n        print(year)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351006, "name": "Mian-Chowla sequence", "source": "Translate Haskell to Python: import Data.Set (Set, fromList, insert, member)\n\n\nmianChowlas :: Int -> [Int]\nmianChowlas =\n  reverse . snd . (iterate nextMC (fromList [2], [1]) !!) . subtract 1\n\nnextMC :: (Set Int, [Int]) -> (Set Int, [Int])\nnextMC (sumSet, mcs@(n:_)) =\n  (foldr insert sumSet ((2 * m) : fmap (m +) mcs), m : mcs)\n  where\n    valid x = not $ any (flip member sumSet . (x +)) mcs\n    m = until valid succ n\n\n\nmain :: IO ()\nmain =\n  (putStrLn . unlines)\n    [ \"First 30 terms of the Mian-Chowla series:\"\n    , show (mianChowlas 30)\n    , []\n    , \"Terms 91 to 100 of the Mian-Chowla series:\"\n    , show $ drop 90 (mianChowlas 100)\n    ]\n", "target": "from itertools import count, islice, chain\nimport time\n\ndef mian_chowla():\n    mc = [1]\n    yield mc[-1]\n    psums = set([2])\n    newsums = set([])\n    for trial in count(2):\n        for n in chain(mc, [trial]):\n            sum = n + trial\n            if sum in psums:\n                newsums.clear()\n                break\n            newsums.add(sum)\n        else:\n            psums |= newsums\n            newsums.clear()\n            mc.append(trial)\n            yield trial\n\ndef pretty(p, t, s, f):\n    print(p, t, \" \".join(str(n) for n in (islice(mian_chowla(), s, f))))\n\nif __name__ == '__main__':\n    st = time.time()\n    ts = \"of the Mian-Chowla sequence are:\\n\"\n    pretty(\"The first 30 terms\", ts, 0, 30)\n    pretty(\"\\nTerms 91 to 100\", ts, 90, 100)\n    print(\"\\nComputation time was\", (time.time()-st) * 1000, \"ms\")\n"}
{"id": 351007, "name": "Water collected between towers", "source": "Translate Haskell to Python: import Data.Vector.Unboxed (Vector)\nimport qualified Data.Vector.Unboxed as V\n\nwaterCollected :: Vector Int -> Int\nwaterCollected =\n  V.sum .            \n  V.filter (> 0) .   \n  (V.zipWith (-) =<< \n   (V.zipWith min .  \n    V.scanl1 max <*> \n    V.scanr1 max))   \n\nmain :: IO ()\nmain =\n  mapM_\n    (print . waterCollected . V.fromList)\n    [ [1, 5, 3, 7, 2]\n    , [5, 3, 7, 2, 6, 4, 5, 9, 1, 2]\n    , [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1]\n    , [5, 5, 5, 5]\n    , [5, 6, 7, 8]\n    , [8, 7, 7, 6]\n    , [6, 7, 10, 7, 6]\n    ]\n", "target": "def water_collected(tower):\n    N = len(tower)\n    highest_left = [0] + [max(tower[:n]) for n in range(1,N)]\n    highest_right = [max(tower[n:N]) for n in range(1,N)] + [0]\n    water_level = [max(min(highest_left[n], highest_right[n]) - tower[n], 0)\n        for n in range(N)]\n    print(\"highest_left:  \", highest_left)\n    print(\"highest_right: \", highest_right)\n    print(\"water_level:   \", water_level)\n    print(\"tower_level:   \", tower)\n    print(\"total_water:   \", sum(water_level))\n    print(\"\")\n    return sum(water_level)\n\ntowers = [[1, 5, 3, 7, 2],\n    [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],\n    [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],\n    [5, 5, 5, 5],\n    [5, 6, 7, 8],\n    [8, 7, 7, 6],\n    [6, 7, 10, 7, 6]]\n\n[water_collected(tower) for tower in towers]\n"}
{"id": 351008, "name": "FASTA format", "source": "Translate Haskell to Python: import Data.List ( groupBy )\n\nparseFasta :: FilePath -> IO ()\nparseFasta fileName = do\n  file <- readFile fileName\n  let pairedFasta = readFasta $ lines file\n  mapM_ (\\(name, code) -> putStrLn $ name ++ \": \" ++ code) pairedFasta\n\nreadFasta :: [String] -> [(String, String)]\nreadFasta = pair . map concat . groupBy (\\x y -> notName x && notName y)\n where\n  notName :: String -> Bool\n  notName = (/=) '>' . head\n\n  pair :: [String] -> [(String, String)]\n  pair []           = []\n  pair (x : y : xs) = (drop 1 x, y) : pair xs\n", "target": "import io\n\nFASTA=\n\ninfile = io.StringIO(FASTA)\n\ndef fasta_parse(infile):\n    key = ''\n    for line in infile:\n        if line.startswith('>'):\n            if key:\n                yield key, val\n            key, val = line[1:].rstrip().split()[0], ''\n        elif key:\n            val += line.rstrip()\n    if key:\n        yield key, val\n\nprint('\\n'.join('%s: %s' % keyval for keyval in fasta_parse(infile)))\n"}
{"id": 351009, "name": "MAC vendor lookup", "source": "Translate Haskell to Python: #!/usr/bin/env stack\n\n\n\n\nimport Control.Exception (try)\nimport Control.Monad (forM_)\nimport qualified Data.ByteString.Lazy.Char8 as L8 (ByteString, unpack)\nimport Network.HTTP.Client\n  (Manager, parseRequest, httpLbs, responseStatus, responseBody,\n   newManager, defaultManagerSettings, Response, HttpException)\nimport Network.HTTP.Types.Status (statusIsSuccessful, notFound404)\nimport System.Environment (getArgs)\nimport Text.Printf (printf)\n\nfetchURL :: Manager\n         -> String\n         -> IO (Either HttpException (Response L8.ByteString))\nfetchURL mgr url = try $ do\n  req <- parseRequest url\n  httpLbs req mgr\n\nlookupMac :: Manager -> String -> IO String\nlookupMac mgr mac = do\n  eth <- fetchURL mgr $ \"http://api.macvendors.com/\" ++ mac\n  return $ case eth of\n             Left _ -> \"null\"\n             Right resp -> let body = responseBody resp\n                               status = responseStatus resp\n                           in if | status == notFound404 -> \"N/A\"\n                                 | not (statusIsSuccessful status) -> \"null\"\n                                 | otherwise -> L8.unpack body\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  mgr <- newManager defaultManagerSettings\n  forM_ args $ \\mac -> do\n    putStr $ printf \"%-17s\" mac ++ \" = \"\n    vendor <- lookupMac mgr mac\n    putStrLn vendor\n", "target": "import requests\n\nfor addr in ['88:53:2E:67:07:BE', 'FC:FB:FB:01:FA:21',\n        'D4:F4:6F:C9:EF:8D', '23:45:67']:\n    vendor = requests.get('http://api.macvendors.com/' + addr).text\n    print(addr, vendor)\n"}
{"id": 351010, "name": "Magic 8-ball", "source": "Translate Haskell to Python: import           System.Random (getStdRandom, randomR)\nimport           Control.Monad (forever)\n\nanswers :: [String]\nanswers =\n  [ \"It is certain\"\n  , \"It is decidedly so\"\n  , \"Without a doubt\"\n  , \"Yes, definitely\"\n  , \"You may rely on it\"\n  , \"As I see it, yes\"\n  , \"Most likely\"\n  , \"Outlook good\"\n  , \"Signs point to yes\"\n  , \"Yes\"\n  , \"Reply hazy, try again\"\n  , \"Ask again later\"\n  , \"Better not tell you now\"\n  , \"Cannot predict now\"\n  , \"Concentrate and ask again\"\n  , \"Don't bet on it\"\n  , \"My reply is no\"\n  , \"My sources say no\"\n  , \"Outlook not so good\"\n  , \"Very doubtful\"]\n\nmain :: IO ()\nmain = do\n  putStrLn \"Hello. The Magic 8 Ball knows all. Type your question.\"\n  forever $ do\n    getLine\n    n <- getStdRandom (randomR (0, pred $ length answers))\n    putStrLn $ answers !! n\n", "target": "import random\n\ns = ('It is certain', 'It is decidedly so', 'Without a doubt', 'Yes, definitely',\n 'You may rely on it', 'As I see it, yes', 'Most likely', 'Outlook good',\n 'Signs point to yes', 'Yes', 'Reply hazy, try again', 'Ask again later',\n 'Better not tell you now', 'Cannot predict now', 'Concentrate and ask again',\n \"Don't bet on it\", 'My reply is no', 'My sources say no', 'Outlook not so good',\n 'Very doubtful')\n\nq_and_a = {}\n\nwhile True:\n    question = input('Ask your question:')\n    if len(question) == 0: break\n        \n    if question in q_and_a:\n        print('Your question has already been answered')\n    else:\n        answer = random.choice(s)\n        q_and_a[question] = answer\n        print(answer)\n"}
{"id": 351011, "name": "Validate International Securities Identification Number", "source": "Translate Haskell to Python: module ISINVerification2 where\n\nimport Data.Char (isUpper, isDigit, digitToInt)\n\nverifyISIN :: String -> Bool\nverifyISIN isin =\n  correctFormat isin && mod (oddsum + multiplied_even_sum) 10 == 0\n  where\n    reverted = reverse $ convertToNumber isin\n    theOdds = fst $ collectOddandEven reverted\n    theEvens = snd $ collectOddandEven reverted\n    oddsum = sum $ map digitToInt theOdds\n    multiplied_even_sum = addUpDigits $ map ((* 2) . digitToInt) theEvens\n\ncapitalLetters :: String\ncapitalLetters = ['A','B' .. 'Z']\n\nnumbers :: String\nnumbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\ncorrectFormat :: String -> Bool\ncorrectFormat isin =\n  (length isin == 12) &&\n  all (`elem` capitalLetters) (take 2 isin) &&\n  all (\\c -> elem c capitalLetters || elem c numbers) (drop 2 $ take 11 isin) &&\n  elem (last isin) numbers\n\nconvertToNumber :: String -> String\nconvertToNumber = concatMap convert\n  where\n    convert :: Char -> String\n    convert c =\n      if isDigit c\n        then show $ digitToInt c\n        else show (fromEnum c - 55)\n\ncollectOddandEven :: String -> (String, String)\ncollectOddandEven term\n  | odd $ length term =\n    ( concat\n        [ take 1 $ drop n term\n        | n <- [0,2 .. length term - 1] ]\n    , concat\n        [ take 1 $ drop d term\n        | d <- [1,3 .. length term - 2] ])\n  | otherwise =\n    ( concat\n        [ take 1 $ drop n term\n        | n <- [0,2 .. length term - 2] ]\n    , concat\n        [ take 1 $ drop d term\n        | d <- [1,3 .. length term - 1] ])\n\naddUpDigits :: [Int] -> Int\naddUpDigits list =\n  sum $\n  map\n    (\\d ->\n        if d > 9\n          then sum $ map digitToInt $ show d\n          else d)\n    list\n\nprintSolution :: String -> IO ()\nprintSolution str = do\n  putStr $ str ++ \" is\"\n  if verifyISIN str\n    then putStrLn \" valid\"\n    else putStrLn \" not valid\"\n\nmain :: IO ()\nmain = do\n  let isinnumbers =\n        [ \"US0378331005\"\n        , \"US0373831005\"\n        , \"U50378331005\"\n        , \"US03378331005\"\n        , \"AU0000XVGZA3\"\n        , \"AU0000VXGZA3\"\n        , \"FR0000988040\"\n        ]\n  mapM_ printSolution isinnumbers\n", "target": "def check_isin(a):\n    if len(a) != 12 or not all(c.isalpha() for c in a[:2]) or not all(c.isalnum() for c in a[2:]):\n        return False\n    s = \"\".join(str(int(c, 36)) for c in a)\n    return 0 == (sum(sum(divmod(2 * (ord(c) - 48), 10)) for c in s[-2::-2]) +\n                 sum(ord(c) - 48 for c in s[::-2])) % 10\n\n\ndef check_isin_alt(a):\n    if len(a) != 12:\n        return False\n    s = []\n    for i, c in enumerate(a):\n        if c.isdigit():\n            if i < 2:\n                return False\n            s.append(ord(c) - 48)\n        elif c.isupper():\n            if i == 11:\n                return False\n            s += divmod(ord(c) - 55, 10)\n        else:\n            return False\n    v = sum(s[::-2])\n    for k in s[-2::-2]:\n        k = 2 * k\n        v += k - 9 if k > 9 else k\n    return v % 10 == 0\n\n[check_isin(s) for s in [\"US0378331005\", \"US0373831005\", \"U50378331005\", \"US03378331005\",\n                         \"AU0000XVGZA3\", \"AU0000VXGZA3\", \"FR0000988040\"]]\n\n\n"}
{"id": 351012, "name": "Cycle detection", "source": "Translate Haskell to Python: import Data.List (findIndex)\n\nfindCycle :: Eq a => [a] -> Maybe ([a], Int, Int)\nfindCycle lst =\n  do l <- findCycleLength lst\n     mu <- findIndex (uncurry (==)) $ zip lst (drop l lst)\n     let c = take l $ drop mu lst\n     return (c, l, mu)\n\nfindCycleLength :: Eq a => [a] -> Maybe Int\nfindCycleLength [] = Nothing\nfindCycleLength (x:xs) =\n  let loop _ _ _ [] = Nothing\n      loop pow lam x (y:ys)\n        | x == y     = Just lam\n        | pow == lam = loop (2*pow) 1 y ys\n        | otherwise  = loop pow (1+lam) x ys\n  in loop 1 1 x xs\n", "target": "import itertools\n\ndef brent(f, x0):\n    \n    power = lam = 1\n    tortoise = x0\n    hare = f(x0)  \n    while tortoise != hare:\n        if power == lam:  \n            tortoise = hare\n            power *= 2\n            lam = 0\n        hare = f(hare)\n        lam += 1\n\n    \n    mu = 0\n    tortoise = hare = x0\n    for i in range(lam):\n    \n        hare = f(hare)\n    \n\n    \n    while tortoise != hare:\n        tortoise = f(tortoise)\n        hare = f(hare)\n        mu += 1\n \n    return lam, mu\n\ndef iterate(f, x0):\n    while True:\n        yield x0\n        x0 = f(x0)\n\nif __name__ == '__main__':\n    f = lambda x: (x * x + 1) % 255\n    x0 = 3\n    lam, mu = brent(f, x0)\n    print(\"Cycle length: %d\" % lam)\n    print(\"Cycle start index: %d\" % mu)\n    print(\"Cycle: %s\" % list(itertools.islice(iterate(f, x0), mu, mu+lam)))\n"}
{"id": 351013, "name": "Input_Output for pairs of numbers", "source": "Translate Haskell to Python: main = do\n    contents <- getContents\n    let numberOfLines  =  read.head.lines$ contents\n        nums  =  map (map read.words).take numberOfLines.tail.lines$ contents\n        sums  =  map sum nums\n    mapM_ print sums\n", "target": "def do_stuff(a, b):\n\treturn a + b\n\nt = input()\nfor x in range(0, t):\n\ta, b = raw_input().strip().split()\n\tprint do_stuff(int(a), int(b))\n"}
{"id": 351014, "name": "ABC words", "source": "Translate Haskell to Python: import Data.List (elemIndex)\nimport Data.Maybe (isJust)\n\n\n\nisABC :: String -> Bool\nisABC s =\n  isJust $\n    residue \"bc\" 'a' s\n      >>= residue \"c\" 'b' \n      >>= elemIndex 'c'\n\nresidue :: String -> Char -> String -> Maybe String\nresidue except c = go\n  where\n    go [] = Nothing\n    go (x : xs)\n      | x `elem` except = Nothing\n      | c == x = Just xs\n      | otherwise = go xs\n\n\nmain :: IO ()\nmain =\n  readFile \"unixdict.txt\"\n    >>= mapM_ print . zip [1 ..] . filter isABC . lines\n", "target": "python -c '\nimport sys\nfor ln in sys.stdin:\n    if \"a\" in ln and ln.find(\"a\") < ln.find(\"b\") < ln.find(\"c\"):\n        print(ln.rstrip())\n' < unixdict.txt\n"}
{"id": 351015, "name": "Text between", "source": "Translate Haskell to Python: import Control.Monad (join)\nimport Data.Bifunctor (bimap)\nimport Data.List (intercalate)\nimport Data.Maybe (fromMaybe)\nimport Data.Text (Text, breakOn, pack, stripPrefix, unpack)\n\n\n\ntextBetween ::\n  (Either String Text, Either String Text) ->\n  Text ->\n  Text\ntextBetween (start, end) txt =\n  fromMaybe\n    (pack [])\n    ( retain (stripPrefix <*>) snd start txt\n        >>= retain (Just .) fst end\n    )\n  where\n    retain sub part delim t =\n      either\n        (Just . const t)\n        (sub $ part . flip breakOn t)\n        delim\n\n\nmain :: IO ()\nmain = do\n  mapM_ print $\n    flip textBetween (head samples)\n      <$> take 3 delims\n  (putStrLn . unlines) $\n    zipWith\n      ( \\d t ->\n          intercalate\n            (unpack $ textBetween d t)\n            [\"\\\"\", \"\\\"\"]\n      )\n      (drop 3 delims)\n      (tail samples)\n\nsamples :: [Text]\nsamples =\n  fmap\n    pack\n    [ \"Hello Rosetta Code world\",\n      \"</div><div style=\\\"chinese\\\">\u4f60\u597d\u5417</div>\",\n      \"<text>Hello <span>Rosetta Code</span> world\"\n        <> \"</text><table style=\\\"myTable\\\">\",\n      \"<table style=\\\"myTable\\\"><tr><td>\"\n        <> \"hello world</td></tr></table>\"\n    ]\n\ndelims :: [(Either String Text, Either String Text)]\ndelims =\n  fmap\n    (join bimap wrap)\n    [ (\"Hello \", \" world\"),\n      (\"start\", \" world\"),\n      (\"Hello\", \"end\"),\n      (\"<div style=\\\"chinese\\\">\", \"</div>\"),\n      (\"<text>\", \"<table>\"),\n      (\"<text>\", \"</table>\")\n    ]\n\nwrap :: String -> Either String Text\nwrap x\n  | x `elem` [\"start\", \"end\"] = Left x\n  | otherwise = Right (pack x)\n", "target": "\nfrom sys import argv\n\n\n\n\n\n\ndef textBetween( thisText, startString, endString ):\n    try:\n    \tif startString is 'start':\n    \t\tstartIndex = 0\n    \telse:\n    \t\tstartIndex = thisText.index( startString ) \n    \t\n    \tif not (startIndex >= 0):\n    \t\treturn 'Start delimiter not found'\n    \telse:\n        \tif startString is not 'start':\n        \t\tstartIndex = startIndex + len( startString )\n        \n        returnText = thisText[startIndex:]\n\n\n    \tif endString is 'end':\n    \t\treturn returnText\n    \telse:\n    \t\tendIndex = returnText.index( endString )\n\n    \tif not (endIndex >= 0):\n    \t\treturn 'End delimiter not found'\n    \telse:\n        \treturnText = returnText[:endIndex]\n\n        return returnText\n    except ValueError:\n        return \"Value error\"\n\nscript, first, second, third = argv\n\nthisText = first\nstartString = second\nendString = third\n\nprint textBetween( thisText, startString, endString )\n"}
{"id": 351016, "name": "Two identical strings", "source": "Translate Haskell to Python: import Control.Monad (join)\nimport Data.Bits\n  ( countLeadingZeros,\n    finiteBitSize,\n    shift,\n    (.|.)\n  )\nimport Text.Printf (printf)\n\n\nnBits :: Int -> Int\nnBits = (-) . finiteBitSize <*> countLeadingZeros\n\n\nconcatSelf :: Int -> Int\nconcatSelf = (.|.) =<< shift <*> nBits\n\n\n\nidentStrInts :: [Int]\nidentStrInts = map concatSelf [1 ..]\n\nmain :: IO ()\nmain =\n  putStr $\n    unlines $\n      map (join $ printf \"%d: %b\") to1000\n  where\n    to1000 = takeWhile (<= 1000) identStrInts\n", "target": "def bits(n):\n    \n    r = 0\n    while n:\n        n >>= 1\n        r += 1\n    return r\n    \ndef concat(n):\n    \n    return n << bits(n) | n\n    \nn = 1\nwhile concat(n) <= 1000:\n    print(\"{0}: {0:b}\".format(concat(n)))\n    n += 1\n"}
{"id": 351017, "name": "Sum of first n cubes", "source": "Translate Haskell to Python: import Data.List (intercalate, transpose)\nimport Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\n\n\nsumOfFirstNCubes :: Integer -> Integer\nsumOfFirstNCubes =\n  (^ 2)\n    . flip binomialCoefficient 2\n    . succ\n\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n    table \" \" $\n      chunksOf 10 $\n        show . sumOfFirstNCubes <$> [0 .. 49]\n\n\n\n\nbinomialCoefficient :: Integer -> Integer -> Integer\nbinomialCoefficient n k\n  | n < k = 0\n  | otherwise =\n    div\n      (factorial n)\n      (factorial k * factorial (n - k))\n\nfactorial :: Integer -> Integer\nfactorial = product . enumFromTo 1\n\n\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "def main():\n    fila = 0\n    lenCubos = 51\n\n    print(\"Suma de N cubos para n = [0..49]\\n\")\n\n    for n in range(1, lenCubos):\n        sumCubos = 0\n        for m in range(1, n):\n            sumCubos = sumCubos + (m ** 3)\n            \n        fila += 1\n        print(f'{sumCubos:7} ', end='')\n        if fila % 5 == 0:\n            print(\" \")\n\n    print(f\"\\nEncontrados {fila} cubos.\")\n\nif __name__ == '__main__': main()\n"}
{"id": 351018, "name": "Pentagram", "source": "Translate Haskell to Python: \n\n\n\n\nimport Diagrams.Prelude\nimport Diagrams.Backend.SVG.CmdLine\n\npentagram = let [a, b, c, d, e] = trailVertices $ pentagon 1\n            in [a, c, e, b, d]\n               # fromVertices\n               # closeTrail\n               # strokeTrail\n               # lw ultraThick\n               # fc springgreen\n               # lc blue\n               # bgFrame 0.2 bisque\n\nmain = mainWith (pentagram :: Diagram B)\n", "target": "import turtle\n\nturtle.bgcolor(\"green\")\nt = turtle.Turtle()\nt.color(\"red\", \"blue\")\nt.begin_fill()\nfor i in range(0, 5):\n    t.forward(200)\n    t.right(144)\nt.end_fill()\n"}
{"id": 351019, "name": "Pentagram", "source": "Translate Haskell to Python: \n\n\n\n\nimport Diagrams.Prelude\nimport Diagrams.Backend.SVG.CmdLine\n\npentagram = let [a, b, c, d, e] = trailVertices $ pentagon 1\n            in [a, c, e, b, d]\n               # fromVertices\n               # closeTrail\n               # strokeTrail\n               # lw ultraThick\n               # fc springgreen\n               # lc blue\n               # bgFrame 0.2 bisque\n\nmain = mainWith (pentagram :: Diagram B)\n", "target": "import turtle\n\nturtle.bgcolor(\"green\")\nt = turtle.Turtle()\nt.color(\"red\", \"blue\")\nt.begin_fill()\nfor i in range(0, 5):\n    t.forward(200)\n    t.right(144)\nt.end_fill()\n"}
{"id": 351020, "name": "CSV to HTML translation", "source": "Translate Haskell to Python: \nsplitOn :: Char -> String -> [String] \nsplitOn delim = foldr (\\x rest ->\n                        if x == delim then \"\" : rest\n                        else (x:head rest):tail rest) [\"\"]\n\nhtmlEscape :: String -> String\nhtmlEscape =  concatMap escapeChar\n              where escapeChar '<' = \"&lt;\"\n                    escapeChar '>' = \"&gt;\"\n                    escapeChar '&' = \"&amp;\"\n                    escapeChar '\"' = \"&quot;\" \n                    escapeChar c   = [c]\n\ntoHtmlRow :: [String] -> String\ntoHtmlRow []   = \"<tr></tr>\"\ntoHtmlRow cols = let htmlColumns = concatMap toHtmlCol cols\n                  in \"<tr>\\n\" ++ htmlColumns  ++ \"</tr>\"\n               where toHtmlCol x = \"  <td>\" ++ htmlEscape x ++ \"</td>\\n\"\n\ncsvToTable :: String -> String\ncsvToTable csv = let rows = map (splitOn ',') $ lines csv\n                     html = unlines $ map toHtmlRow rows\n                  in \"<table>\\n\" ++ html ++ \"</table>\"\n\nmain = interact csvToTable\n", "target": "csvtxt = \n\nfrom cgi import escape\n\ndef _row2tr(row, attr=None):\n    cols = escape(row).split(',')\n    return ('<TR>'\n            + ''.join('<TD>%s</TD>' % data for data in cols)\n            + '</TR>')\n\ndef csv2html(txt):\n    htmltxt = '<TABLE summary=\"csv2html program output\">\\n'\n    for rownum, row in enumerate(txt.split('\\n')):\n        htmlrow = _row2tr(row)\n        htmlrow = '  <TBODY>%s</TBODY>\\n' % htmlrow\n        htmltxt += htmlrow\n    htmltxt += '</TABLE>\\n'\n    return htmltxt\n\nhtmltxt = csv2html(csvtxt)\nprint(htmltxt)\n"}
{"id": 351021, "name": "CSV to HTML translation", "source": "Translate Haskell to Python: \nsplitOn :: Char -> String -> [String] \nsplitOn delim = foldr (\\x rest ->\n                        if x == delim then \"\" : rest\n                        else (x:head rest):tail rest) [\"\"]\n\nhtmlEscape :: String -> String\nhtmlEscape =  concatMap escapeChar\n              where escapeChar '<' = \"&lt;\"\n                    escapeChar '>' = \"&gt;\"\n                    escapeChar '&' = \"&amp;\"\n                    escapeChar '\"' = \"&quot;\" \n                    escapeChar c   = [c]\n\ntoHtmlRow :: [String] -> String\ntoHtmlRow []   = \"<tr></tr>\"\ntoHtmlRow cols = let htmlColumns = concatMap toHtmlCol cols\n                  in \"<tr>\\n\" ++ htmlColumns  ++ \"</tr>\"\n               where toHtmlCol x = \"  <td>\" ++ htmlEscape x ++ \"</td>\\n\"\n\ncsvToTable :: String -> String\ncsvToTable csv = let rows = map (splitOn ',') $ lines csv\n                     html = unlines $ map toHtmlRow rows\n                  in \"<table>\\n\" ++ html ++ \"</table>\"\n\nmain = interact csvToTable\n", "target": "csvtxt = \n\nfrom cgi import escape\n\ndef _row2tr(row, attr=None):\n    cols = escape(row).split(',')\n    return ('<TR>'\n            + ''.join('<TD>%s</TD>' % data for data in cols)\n            + '</TR>')\n\ndef csv2html(txt):\n    htmltxt = '<TABLE summary=\"csv2html program output\">\\n'\n    for rownum, row in enumerate(txt.split('\\n')):\n        htmlrow = _row2tr(row)\n        htmlrow = '  <TBODY>%s</TBODY>\\n' % htmlrow\n        htmltxt += htmlrow\n    htmltxt += '</TABLE>\\n'\n    return htmltxt\n\nhtmltxt = csv2html(csvtxt)\nprint(htmltxt)\n"}
{"id": 351022, "name": "Alternade words", "source": "Translate Haskell to Python: import qualified Data.Set as S\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as TIO\n\n\nalt :: T.Text -> (T.Text, T.Text)\nalt = T.foldl' (\\(l, r) c -> (r `T.snoc` c, l)) (T.empty, T.empty)\n\n\nalternades :: S.Set T.Text -> [T.Text] -> [(T.Text, (T.Text, T.Text))]\nalternades dict ws = filter (areMembers . snd) $ zip ws $ map alt ws\n  where areMembers (x, y) = S.member x dict && S.member y dict\n\nmain :: IO ()\nmain = TIO.interact $ \\txt ->\n  let words' = map T.toLower $ T.lines txt\n      dict   = S.fromList words'\n  in T.unlines $ map alterShow $ alternades dict $ filter longEnough words'\n  where longEnough = (>= 6) . T.length\n        alterShow (w, (x, y)) = T.unwords [w, x, y]\n", "target": "WORDFILE = 'unixdict.txt'\nMINLEN = 6\n\nclass Trie(object):\n    \n    class Node(object):\n        \n        def __init__(self, char='\\0', parent=None):\n            self.children = {}\n            self.char = char\n            self.final = False\n            self.parent = parent\n            \n        def descend(self, char, extend=False):\n            \n            if not char in self.children:\n                if not extend: return None\n                self.children[char] = Trie.Node(char,self)\n            return self.children[char]\n        \n    def __init__(self):\n        self.root = Trie.Node()\n    \n    def insert(self, word):\n        \n        node = self.root\n        for char in word: node = node.descend(char, extend=True)\n        node.final = True\n        return node\n    \n    def __contains__(self, word):\n        \n        node = self.root\n        for char in word:\n            node = node.descend(char)\n            if not node: return False\n        return node.final \n    \n    def words(self):\n        \n        nodes = [self.root]\n        while nodes:\n            node = nodes.pop()\n            nodes += node.children.values()\n            if node.final:\n                word = []\n                while node:\n                    if node.char != '\\0': word.append(node.char)\n                    node = node.parent\n                yield \"\".join(reversed(word))\n    \n    def __iter__(self):\n        return self.words()\n                \n\nwords = Trie()\nwith open(WORDFILE, \"rt\") as f:\n    for word in f.readlines():\n        words.insert(word.strip())\n\nfor word in words:\n    if len(word) < MINLEN: continue\n    even = word[::2]\n    odd = word[1::2]\n    if even in words and odd in words:\n        print(word, even, odd)\n"}
{"id": 351023, "name": "Alternade words", "source": "Translate Haskell to Python: import qualified Data.Set as S\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as TIO\n\n\nalt :: T.Text -> (T.Text, T.Text)\nalt = T.foldl' (\\(l, r) c -> (r `T.snoc` c, l)) (T.empty, T.empty)\n\n\nalternades :: S.Set T.Text -> [T.Text] -> [(T.Text, (T.Text, T.Text))]\nalternades dict ws = filter (areMembers . snd) $ zip ws $ map alt ws\n  where areMembers (x, y) = S.member x dict && S.member y dict\n\nmain :: IO ()\nmain = TIO.interact $ \\txt ->\n  let words' = map T.toLower $ T.lines txt\n      dict   = S.fromList words'\n  in T.unlines $ map alterShow $ alternades dict $ filter longEnough words'\n  where longEnough = (>= 6) . T.length\n        alterShow (w, (x, y)) = T.unwords [w, x, y]\n", "target": "WORDFILE = 'unixdict.txt'\nMINLEN = 6\n\nclass Trie(object):\n    \n    class Node(object):\n        \n        def __init__(self, char='\\0', parent=None):\n            self.children = {}\n            self.char = char\n            self.final = False\n            self.parent = parent\n            \n        def descend(self, char, extend=False):\n            \n            if not char in self.children:\n                if not extend: return None\n                self.children[char] = Trie.Node(char,self)\n            return self.children[char]\n        \n    def __init__(self):\n        self.root = Trie.Node()\n    \n    def insert(self, word):\n        \n        node = self.root\n        for char in word: node = node.descend(char, extend=True)\n        node.final = True\n        return node\n    \n    def __contains__(self, word):\n        \n        node = self.root\n        for char in word:\n            node = node.descend(char)\n            if not node: return False\n        return node.final \n    \n    def words(self):\n        \n        nodes = [self.root]\n        while nodes:\n            node = nodes.pop()\n            nodes += node.children.values()\n            if node.final:\n                word = []\n                while node:\n                    if node.char != '\\0': word.append(node.char)\n                    node = node.parent\n                yield \"\".join(reversed(word))\n    \n    def __iter__(self):\n        return self.words()\n                \n\nwords = Trie()\nwith open(WORDFILE, \"rt\") as f:\n    for word in f.readlines():\n        words.insert(word.strip())\n\nfor word in words:\n    if len(word) < MINLEN: continue\n    even = word[::2]\n    odd = word[1::2]\n    if even in words and odd in words:\n        print(word, even, odd)\n"}
{"id": 351024, "name": "Count how many vowels and consonants occur in a string", "source": "Translate Haskell to Python: import Control.Monad (join)\nimport Data.Bifunctor (bimap, first, second)\nimport Data.Bool (bool)\nimport Data.Char (toUpper)\nimport qualified Data.Set as S\n\n\n\nvowelsAndConsonantsUsed ::\n  String -> String -> String -> (S.Set Char, S.Set Char)\nvowelsAndConsonantsUsed vowels alphabet =\n  foldr\n    ( \\c vc ->\n        if_\n          (S.member c vs)\n          (first (S.insert c))\n          (if_ (S.member c cs) (second (S.insert c)) id)\n          vc\n    )\n    (S.empty, S.empty)\n  where\n    vs = S.fromList $ vowels <> fmap toUpper vowels\n    cs =\n      S.fromList $\n        filter\n          (`S.notMember` vs)\n          (alphabet <> fmap toUpper alphabet)\n\n\nmain :: IO ()\nmain = do\n  putStrLn \"Unique vowels and consonants used, with counts:\\n\"\n  mapM_ print $\n    [(,) . S.toList <*> S.size]\n      <*> ( [fst, snd]\n              <*> [ vowelsAndConsonantsUsed\n                      \"aeiou\"\n                      ['a' .. 'z']\n                      \"Forever Fortran 2018 programming language\"\n                  ]\n          )\n\n\n\nboth :: (a -> b) -> (a, a) -> (b, b)\nboth = join bimap\n\nif_ :: Bool -> a -> a -> a\nif_ p t f =\n  if p\n    then t\n    else f\n", "target": "def isvowel(c):\n    \n    return c in ['a', 'e', 'i', 'o', 'u', 'A', 'E', \"I\", 'O', 'U']\n\ndef isletter(c):\n    \n    return 'a' <= c <= 'z' or 'A' <= c <= 'Z'\n\ndef isconsonant(c):\n    \n    return  not isvowel(c) and isletter(c)\n\ndef vccounts(s):\n    \n    a = list(s.lower())\n    au = set(a)\n    return sum([isvowel(c) for c in a]), sum([isconsonant(c) for c in a]), \\\n        sum([isvowel(c) for c in au]), sum([isconsonant(c) for c in au])\n\ndef testvccount():\n    teststrings = [\n        \"Forever Python programming language\",\n        \"Now is the time for all good men to come to the aid of their country.\"]\n    for s in teststrings:\n        vcnt, ccnt, vu, cu = vccounts(s)\n        print(f\"String: {s}\\n    Vowels: {vcnt} (distinct {vu})\\n    Consonants: {ccnt} (distinct {cu})\\n\")\n\ntestvccount()\n"}
{"id": 351025, "name": "Count how many vowels and consonants occur in a string", "source": "Translate Haskell to Python: import Control.Monad (join)\nimport Data.Bifunctor (bimap, first, second)\nimport Data.Bool (bool)\nimport Data.Char (toUpper)\nimport qualified Data.Set as S\n\n\n\nvowelsAndConsonantsUsed ::\n  String -> String -> String -> (S.Set Char, S.Set Char)\nvowelsAndConsonantsUsed vowels alphabet =\n  foldr\n    ( \\c vc ->\n        if_\n          (S.member c vs)\n          (first (S.insert c))\n          (if_ (S.member c cs) (second (S.insert c)) id)\n          vc\n    )\n    (S.empty, S.empty)\n  where\n    vs = S.fromList $ vowels <> fmap toUpper vowels\n    cs =\n      S.fromList $\n        filter\n          (`S.notMember` vs)\n          (alphabet <> fmap toUpper alphabet)\n\n\nmain :: IO ()\nmain = do\n  putStrLn \"Unique vowels and consonants used, with counts:\\n\"\n  mapM_ print $\n    [(,) . S.toList <*> S.size]\n      <*> ( [fst, snd]\n              <*> [ vowelsAndConsonantsUsed\n                      \"aeiou\"\n                      ['a' .. 'z']\n                      \"Forever Fortran 2018 programming language\"\n                  ]\n          )\n\n\n\nboth :: (a -> b) -> (a, a) -> (b, b)\nboth = join bimap\n\nif_ :: Bool -> a -> a -> a\nif_ p t f =\n  if p\n    then t\n    else f\n", "target": "def isvowel(c):\n    \n    return c in ['a', 'e', 'i', 'o', 'u', 'A', 'E', \"I\", 'O', 'U']\n\ndef isletter(c):\n    \n    return 'a' <= c <= 'z' or 'A' <= c <= 'Z'\n\ndef isconsonant(c):\n    \n    return  not isvowel(c) and isletter(c)\n\ndef vccounts(s):\n    \n    a = list(s.lower())\n    au = set(a)\n    return sum([isvowel(c) for c in a]), sum([isconsonant(c) for c in a]), \\\n        sum([isvowel(c) for c in au]), sum([isconsonant(c) for c in au])\n\ndef testvccount():\n    teststrings = [\n        \"Forever Python programming language\",\n        \"Now is the time for all good men to come to the aid of their country.\"]\n    for s in teststrings:\n        vcnt, ccnt, vu, cu = vccounts(s)\n        print(f\"String: {s}\\n    Vowels: {vcnt} (distinct {vu})\\n    Consonants: {ccnt} (distinct {cu})\\n\")\n\ntestvccount()\n"}
{"id": 351026, "name": "Pythagorean triples", "source": "Translate Haskell to Python: pytr :: Int -> [(Bool, Int, Int, Int)]\npytr n =\n  filter\n    (\\(_, a, b, c) -> a + b + c <= n)\n    [ (prim a b c, a, b, c)\n      | a <- xs,\n        b <- drop a xs,\n        c <- drop b xs,\n        a ^ 2 + b ^ 2 == c ^ 2\n    ]\n  where\n    xs = [1 .. n]\n    prim a b _ = gcd a b == 1\n\nmain :: IO ()\nmain =\n  putStrLn $\n    \"Up to 100 there are \"\n      <> show (length xs)\n      <> \" triples, of which \"\n      <> show (length $ filter (\\(x, _, _, _) -> x) xs)\n      <> \" are primitive.\"\n  where\n    xs = pytr 100\n", "target": "from fractions import gcd\n\n\ndef pt1(maxperimeter=100):\n    \n    trips = []\n    for a in range(1, maxperimeter):\n        aa = a*a\n        for b in range(a, maxperimeter-a+1):\n            bb = b*b\n            for c in range(b, maxperimeter-b-a+1):\n                cc = c*c\n                if a+b+c > maxperimeter or cc > aa + bb: break\n                if aa + bb == cc:\n                    trips.append((a,b,c, gcd(a, b) == 1))\n    return trips\n\ndef pytrip(trip=(3,4,5),perim=100, prim=1):\n    a0, b0, c0 = a, b, c = sorted(trip)\n    t, firstprim = set(), prim>0\n    while a + b + c <= perim:\n        t.add((a, b, c, firstprim>0))\n        a, b, c, firstprim = a+a0, b+b0, c+c0, False\n    \n    t2 = set()\n    for a, b, c, firstprim in t:\n        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7\n        if  a5 - b5 + c7 <= perim:\n            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)\n        if  a5 + b5 + c7 <= perim:\n            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)\n        if -a5 + b5 + c7 <= perim:\n            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)\n    return t | t2\n\ndef pt2(maxperimeter=100):\n    \n    trips = pytrip((3,4,5), maxperimeter, 1)\n    return trips\n\ndef printit(maxperimeter=100, pt=pt1):\n    trips = pt(maxperimeter)\n    print(\"  Up to a perimeter of %i there are %i triples, of which %i are primitive\"\n          % (maxperimeter,\n             len(trips),\n             len([prim for a,b,c,prim in trips if prim])))\n  \nfor algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):\n    print(algo.__doc__)\n    for maxperimeter in range(mn, mx+1, mn):\n        printit(maxperimeter, algo)\n"}
{"id": 351027, "name": "Pythagorean triples", "source": "Translate Haskell to Python: pytr :: Int -> [(Bool, Int, Int, Int)]\npytr n =\n  filter\n    (\\(_, a, b, c) -> a + b + c <= n)\n    [ (prim a b c, a, b, c)\n      | a <- xs,\n        b <- drop a xs,\n        c <- drop b xs,\n        a ^ 2 + b ^ 2 == c ^ 2\n    ]\n  where\n    xs = [1 .. n]\n    prim a b _ = gcd a b == 1\n\nmain :: IO ()\nmain =\n  putStrLn $\n    \"Up to 100 there are \"\n      <> show (length xs)\n      <> \" triples, of which \"\n      <> show (length $ filter (\\(x, _, _, _) -> x) xs)\n      <> \" are primitive.\"\n  where\n    xs = pytr 100\n", "target": "from fractions import gcd\n\n\ndef pt1(maxperimeter=100):\n    \n    trips = []\n    for a in range(1, maxperimeter):\n        aa = a*a\n        for b in range(a, maxperimeter-a+1):\n            bb = b*b\n            for c in range(b, maxperimeter-b-a+1):\n                cc = c*c\n                if a+b+c > maxperimeter or cc > aa + bb: break\n                if aa + bb == cc:\n                    trips.append((a,b,c, gcd(a, b) == 1))\n    return trips\n\ndef pytrip(trip=(3,4,5),perim=100, prim=1):\n    a0, b0, c0 = a, b, c = sorted(trip)\n    t, firstprim = set(), prim>0\n    while a + b + c <= perim:\n        t.add((a, b, c, firstprim>0))\n        a, b, c, firstprim = a+a0, b+b0, c+c0, False\n    \n    t2 = set()\n    for a, b, c, firstprim in t:\n        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7\n        if  a5 - b5 + c7 <= perim:\n            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)\n        if  a5 + b5 + c7 <= perim:\n            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)\n        if -a5 + b5 + c7 <= perim:\n            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)\n    return t | t2\n\ndef pt2(maxperimeter=100):\n    \n    trips = pytrip((3,4,5), maxperimeter, 1)\n    return trips\n\ndef printit(maxperimeter=100, pt=pt1):\n    trips = pt(maxperimeter)\n    print(\"  Up to a perimeter of %i there are %i triples, of which %i are primitive\"\n          % (maxperimeter,\n             len(trips),\n             len([prim for a,b,c,prim in trips if prim])))\n  \nfor algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):\n    print(algo.__doc__)\n    for maxperimeter in range(mn, mx+1, mn):\n        printit(maxperimeter, algo)\n"}
{"id": 351028, "name": "Call a foreign-language function", "source": "Translate Haskell to Python: \n\nimport Foreign (free)\nimport Foreign.C.String (CString, withCString, peekCString)\n\n\n\nforeign import ccall unsafe \"string.h strdup\" strdup :: CString -> IO CString\n\ntestC = withCString \"Hello World!\" \n        (\\s -> \n         do s2 <- strdup s\n            s2_hs <- peekCString s2 \n            putStrLn s2_hs\n            free s2) \n", "target": "import ctypes\nlibc = ctypes.CDLL(\"/lib/libc.so.6\")\nlibc.strcmp(\"abc\", \"def\")     \nlibc.strcmp(\"hello\", \"hello\") \n"}
{"id": 351029, "name": "Yellowstone sequence", "source": "Translate Haskell to Python: import Data.List (unfoldr)\n\nyellowstone :: [Integer]\nyellowstone = 1 : 2 : 3 : unfoldr (Just . f) (2, 3, [4 ..])\n  where\n    f ::\n      (Integer, Integer, [Integer]) ->\n      (Integer, (Integer, Integer, [Integer]))\n    f (p2, p1, rest) = (next, (p1, next, rest_))\n      where\n        (next, rest_) = select rest\n        select :: [Integer] -> (Integer, [Integer])\n        select (x : xs)\n          | gcd x p1 == 1 && gcd x p2 /= 1 = (x, xs)\n          | otherwise = (y, x : ys)\n          where\n            (y, ys) = select xs\n\nmain :: IO ()\nmain = print $ take 30 yellowstone\n", "target": "\n\nfrom itertools import chain, count, islice\nfrom operator import itemgetter\nfrom math import gcd\n\nfrom matplotlib import pyplot\n\n\n\ndef yellowstone():\n    \n    \n    def relativelyPrime(a):\n        return lambda b: 1 == gcd(a, b)\n\n    \n    def nextWindow(triple):\n        p2, p1, rest = triple\n        [rp2, rp1] = map(relativelyPrime, [p2, p1])\n\n        \n        def match(xxs):\n            x, xs = uncons(xxs)['Just']\n            return (x, xs) if rp1(x) and not rp2(x) else (\n                second(cons(x))(\n                    match(xs)\n                )\n            )\n        n, residue = match(rest)\n        return (p1, n, residue)\n\n    return chain(\n        range(1, 3),\n        map(\n            itemgetter(1),\n            iterate(nextWindow)(\n                (2, 3, count(4))\n            )\n        )\n    )\n\n\n\n\ndef main():\n    \n\n    print(showList(\n        take(30)(yellowstone())\n    ))\n    pyplot.plot(\n        take(100)(yellowstone())\n    )\n    pyplot.xlabel(main.__doc__)\n    pyplot.show()\n\n\n\n\n\ndef Just(x):\n    \n    return {'type': 'Maybe', 'Nothing': False, 'Just': x}\n\n\n\ndef Nothing():\n    \n    return {'type': 'Maybe', 'Nothing': True}\n\n\n\ndef cons(x):\n    \n    return lambda xs: [x] + xs if (\n        isinstance(xs, list)\n    ) else x + xs if (\n        isinstance(xs, str)\n    ) else chain([x], xs)\n\n\n\ndef iterate(f):\n    \n    def go(x):\n        v = x\n        while True:\n            yield v\n            v = f(v)\n    return go\n\n\n\ndef second(f):\n    \n    return lambda xy: (xy[0], f(xy[1]))\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(repr(x) for x in xs) + ']'\n\n\n\n\ndef take(n):\n    \n    return lambda xs: (\n        xs[0:n]\n        if isinstance(xs, (list, tuple))\n        else list(islice(xs, n))\n    )\n\n\n\ndef uncons(xs):\n    \n    if isinstance(xs, list):\n        return Just((xs[0], xs[1:])) if xs else Nothing()\n    else:\n        nxt = take(1)(xs)\n        return Just((nxt[0], xs)) if nxt else Nothing()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351030, "name": "Yellowstone sequence", "source": "Translate Haskell to Python: import Data.List (unfoldr)\n\nyellowstone :: [Integer]\nyellowstone = 1 : 2 : 3 : unfoldr (Just . f) (2, 3, [4 ..])\n  where\n    f ::\n      (Integer, Integer, [Integer]) ->\n      (Integer, (Integer, Integer, [Integer]))\n    f (p2, p1, rest) = (next, (p1, next, rest_))\n      where\n        (next, rest_) = select rest\n        select :: [Integer] -> (Integer, [Integer])\n        select (x : xs)\n          | gcd x p1 == 1 && gcd x p2 /= 1 = (x, xs)\n          | otherwise = (y, x : ys)\n          where\n            (y, ys) = select xs\n\nmain :: IO ()\nmain = print $ take 30 yellowstone\n", "target": "\n\nfrom itertools import chain, count, islice\nfrom operator import itemgetter\nfrom math import gcd\n\nfrom matplotlib import pyplot\n\n\n\ndef yellowstone():\n    \n    \n    def relativelyPrime(a):\n        return lambda b: 1 == gcd(a, b)\n\n    \n    def nextWindow(triple):\n        p2, p1, rest = triple\n        [rp2, rp1] = map(relativelyPrime, [p2, p1])\n\n        \n        def match(xxs):\n            x, xs = uncons(xxs)['Just']\n            return (x, xs) if rp1(x) and not rp2(x) else (\n                second(cons(x))(\n                    match(xs)\n                )\n            )\n        n, residue = match(rest)\n        return (p1, n, residue)\n\n    return chain(\n        range(1, 3),\n        map(\n            itemgetter(1),\n            iterate(nextWindow)(\n                (2, 3, count(4))\n            )\n        )\n    )\n\n\n\n\ndef main():\n    \n\n    print(showList(\n        take(30)(yellowstone())\n    ))\n    pyplot.plot(\n        take(100)(yellowstone())\n    )\n    pyplot.xlabel(main.__doc__)\n    pyplot.show()\n\n\n\n\n\ndef Just(x):\n    \n    return {'type': 'Maybe', 'Nothing': False, 'Just': x}\n\n\n\ndef Nothing():\n    \n    return {'type': 'Maybe', 'Nothing': True}\n\n\n\ndef cons(x):\n    \n    return lambda xs: [x] + xs if (\n        isinstance(xs, list)\n    ) else x + xs if (\n        isinstance(xs, str)\n    ) else chain([x], xs)\n\n\n\ndef iterate(f):\n    \n    def go(x):\n        v = x\n        while True:\n            yield v\n            v = f(v)\n    return go\n\n\n\ndef second(f):\n    \n    return lambda xy: (xy[0], f(xy[1]))\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(repr(x) for x in xs) + ']'\n\n\n\n\ndef take(n):\n    \n    return lambda xs: (\n        xs[0:n]\n        if isinstance(xs, (list, tuple))\n        else list(islice(xs, n))\n    )\n\n\n\ndef uncons(xs):\n    \n    if isinstance(xs, list):\n        return Just((xs[0], xs[1:])) if xs else Nothing()\n    else:\n        nxt = take(1)(xs)\n        return Just((nxt[0], xs)) if nxt else Nothing()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351031, "name": "Sorting algorithms_Patience sort", "source": "Translate Haskell to Python: import Control.Monad.ST\nimport Control.Monad\nimport Data.Array.ST\nimport Data.List\nimport qualified Data.Set as S\n\nnewtype Pile a = Pile [a]\n\ninstance Eq a => Eq (Pile a) where\n  Pile (x:_) == Pile (y:_) = x == y\n\ninstance Ord a => Ord (Pile a) where\n  Pile (x:_) `compare` Pile (y:_) = x `compare` y\n\npatienceSort :: Ord a => [a] -> [a]\npatienceSort = mergePiles . sortIntoPiles where\n\n  sortIntoPiles :: Ord a => [a] -> [[a]]\n  sortIntoPiles lst = runST $ do\n      piles <- newSTArray (1, length lst) []\n      let bsearchPiles x len = aux 1 len where\n            aux lo hi | lo > hi = return lo\n                      | otherwise = do\n              let mid = (lo + hi) `div` 2\n              m <- readArray piles mid\n              if head m < x then\n                aux (mid+1) hi\n              else\n                aux lo (mid-1)\n          f len x = do\n            i <- bsearchPiles x len\n            writeArray piles i . (x:) =<< readArray piles i\n            return $ if i == len+1 then len+1 else len\n      len <- foldM f 0 lst\n      e <- getElems piles\n      return $ take len e\n      where newSTArray :: Ix i => (i,i) -> e -> ST s (STArray s i e)\n            newSTArray = newArray\n\n  mergePiles :: Ord a => [[a]] -> [a]\n  mergePiles = unfoldr f . S.fromList . map Pile where\n    f pq = case S.minView pq of\n             Nothing -> Nothing\n             Just (Pile [x], pq') -> Just (x, pq')\n             Just (Pile (x:xs), pq') -> Just (x, S.insert (Pile xs) pq')\n\nmain :: IO ()\nmain = print $ patienceSort [4, 65, 2, -31, 0, 99, 83, 782, 1]\n", "target": "from functools import total_ordering\nfrom bisect import bisect_left\nfrom heapq import merge\n\n@total_ordering\nclass Pile(list):\n    def __lt__(self, other): return self[-1] < other[-1]\n    def __eq__(self, other): return self[-1] == other[-1]\n\ndef patience_sort(n):\n    piles = []\n    \n    for x in n:\n        new_pile = Pile([x])\n        i = bisect_left(piles, new_pile)\n        if i != len(piles):\n            piles[i].append(x)\n        else:\n            piles.append(new_pile)\n\n    \n    n[:] = merge(*[reversed(pile) for pile in piles])\n\nif __name__ == \"__main__\":\n    a = [4, 65, 2, -31, 0, 99, 83, 782, 1]\n    patience_sort(a)\n    print a\n"}
{"id": 351032, "name": "Extensible prime generator", "source": "Translate Haskell to Python: #!/usr/bin/env runghc\n\nimport Data.List\nimport Data.Numbers.Primes\nimport System.IO\n\nfirstNPrimes :: Integer -> [Integer]\nfirstNPrimes n = genericTake n primes\n\nprimesBetweenInclusive :: Integer -> Integer -> [Integer]\nprimesBetweenInclusive lo hi =\n  dropWhile (< lo) $ takeWhile (<= hi) primes\n\nnthPrime :: Integer -> Integer\nnthPrime n = genericIndex primes (n - 1) \n\nmain = do\n  hSetBuffering stdout NoBuffering\n  putStr \"First 20 primes: \"\n  print $ firstNPrimes 20\n  putStr \"Primes between 100 and 150: \"\n  print $ primesBetweenInclusive 100 150\n  putStr \"Number of primes between 7700 and 8000: \"\n  print $ genericLength $ primesBetweenInclusive 7700 8000\n  putStr \"The 10000th prime: \"\n  print $ nthPrime 10000\n", "target": "islice(count(7), 0, None, 2)\n"}
{"id": 351033, "name": "Flipping bits game", "source": "Translate Haskell to Python: import Data.List (intersperse)\n\nimport System.Random (randomRIO)\n\nimport Data.Array (Array, (!), (//), array, bounds)\n\nimport Control.Monad (zipWithM_, replicateM, foldM, when)\n\ntype Board = Array (Char, Char) Int\n\nflp :: Int -> Int\nflp 0 = 1\nflp 1 = 0\n\nnumRows, numCols :: Board -> String\nnumRows t =\n  let ((a, _), (b, _)) = bounds t\n  in [a .. b]\n\nnumCols t =\n  let ((_, a), (_, b)) = bounds t\n  in [a .. b]\n\nflipRow, flipCol :: Board -> Char -> Board\nflipRow t r =\n  let e =\n        [ (ix, flp (t ! ix))\n        | ix <- zip (repeat r) (numCols t) ]\n  in t // e\n\nflipCol t c =\n  let e =\n        [ (ix, flp (t ! ix))\n        | ix <- zip (numRows t) (repeat c) ]\n  in t // e\n\nprintBoard :: Board -> IO ()\nprintBoard t = do\n  let rows = numRows t\n      cols = numCols t\n      f 0 = '0'\n      f 1 = '1'\n      p r xs = putStrLn $ [r, ' '] ++ intersperse ' ' (map f xs)\n  putStrLn $ \"  \" ++ intersperse ' ' cols\n  zipWithM_\n    p\n    rows\n    [ [ t ! (y, x)\n      | x <- cols ]\n    | y <- rows ]\n\n\n\nsetupGame :: Char -> Char -> IO (Board, Board)\nsetupGame sizey sizex\n                \n = do\n  let mk rc = (\\v -> (rc, v)) <$> randomRIO (0, 1)\n      rows = ['a' .. sizey]\n      cols = ['1' .. sizex]\n  goal <-\n    array (('a', '1'), (sizey, sizex)) <$>\n    mapM\n      mk\n      [ (r, c)\n      | r <- rows \n      , c <- cols ]\n  start <-\n    do let change :: Board -> Int -> IO Board\n           \n           change t 0 = flipRow t <$> randomRIO ('a', sizey)\n           \n           change t 1 = flipCol t <$> randomRIO ('1', sizex)\n       numMoves <- randomRIO (3, 15) \n       \n       moves <- replicateM numMoves $ randomRIO (0, 1)\n       \n       foldM change goal moves\n  if goal /= start \n    then return (goal, start) \n    else setupGame sizey sizex \n\nmain :: IO ()\nmain = do\n  putStrLn \"Select a board size (1 - 9).\\nPress any other key to exit.\"\n  sizec <- getChar\n  when (sizec `elem` ['1' .. '9']) $\n    do let size = read [sizec] - 1\n       (g, s) <- setupGame (['a' ..] !! size) (['1' ..] !! size)\n       turns g s 0\n  where\n    turns goal current moves = do\n      putStrLn \"\\nGoal:\"\n      printBoard goal\n      putStrLn \"\\nBoard:\"\n      printBoard current\n      when (moves > 0) $\n        putStrLn $ \"\\nYou've made \" ++ show moves ++ \" moves so far.\"\n      putStrLn $\n        \"\\nFlip a row (\" ++\n        numRows current ++ \") or a column (\" ++ numCols current ++ \")\"\n      v <- getChar\n      if v `elem` numRows current\n        then check $ flipRow current v\n        else if v `elem` numCols current\n               then check $ flipCol current v\n               else tryAgain\n      where\n        check t =\n          if t == goal\n            then putStrLn $ \"\\nYou've won in \" ++ show (moves + 1) ++ \" moves!\"\n            else turns goal t (moves + 1)\n        tryAgain = do\n          putStrLn \": Invalid row or column.\"\n          turns goal current moves\n", "target": "\n\nfrom random import randrange\nfrom copy import deepcopy\nfrom string import ascii_lowercase\n\n\ntry:    \n    input = raw_input\nexcept:\n    pass\n\nN = 3   \n\nboard  = [[0]* N for i in range(N)]\n\ndef setbits(board, count=1):\n    for i in range(count):\n        board[randrange(N)][randrange(N)] ^= 1\n\ndef shuffle(board, count=1):\n    for i in range(count):\n        if randrange(0, 2):\n            fliprow(randrange(N))\n        else:\n            flipcol(randrange(N))\n\n\ndef pr(board, comment=''):\n    print(str(comment))\n    print('     ' + ' '.join(ascii_lowercase[i] for i in range(N)))\n    print('  ' + '\\n  '.join(' '.join(['%2s' % j] + [str(i) for i in line])\n                             for j, line in enumerate(board, 1)))\n\ndef init(board):\n    setbits(board, count=randrange(N)+1)\n    target = deepcopy(board)\n    while board == target:\n        shuffle(board, count=2 * N)\n    prompt = '  X, T, or 1-%i / %s-%s to flip: ' % (N, ascii_lowercase[0], \n                                                    ascii_lowercase[N-1])\n    return target, prompt\n\ndef fliprow(i):\n    board[i-1][:] = [x ^ 1 for x in board[i-1] ]\n    \ndef flipcol(i):\n    for row in board:\n        row[i] ^= 1\n\nif __name__ == '__main__':\n    print(__doc__ % (N, N))\n    target, prompt = init(board)\n    pr(target, 'Target configuration is:')\n    print('')\n    turns = 0\n    while board != target:\n        turns += 1\n        pr(board, '%i:' % turns)\n        ans = input(prompt).strip()\n        if (len(ans) == 1 \n            and ans in ascii_lowercase and ascii_lowercase.index(ans) < N):\n            flipcol(ascii_lowercase.index(ans))\n        elif ans and all(ch in '0123456789' for ch in ans) and 1 <= int(ans) <= N:\n            fliprow(int(ans))\n        elif ans == 'T':\n            pr(target, 'Target configuration is:')\n            turns -= 1\n        elif ans == 'X':\n            break\n        else:\n            print(\"  I don't understand %r... Try again. \"\n                  \"(X to exit or T to show target)\\n\" % ans[:9])\n            turns -= 1\n    else:\n        print('\\nWell done!\\nBye.')\n"}
{"id": 351034, "name": "Flipping bits game", "source": "Translate Haskell to Python: import Data.List (intersperse)\n\nimport System.Random (randomRIO)\n\nimport Data.Array (Array, (!), (//), array, bounds)\n\nimport Control.Monad (zipWithM_, replicateM, foldM, when)\n\ntype Board = Array (Char, Char) Int\n\nflp :: Int -> Int\nflp 0 = 1\nflp 1 = 0\n\nnumRows, numCols :: Board -> String\nnumRows t =\n  let ((a, _), (b, _)) = bounds t\n  in [a .. b]\n\nnumCols t =\n  let ((_, a), (_, b)) = bounds t\n  in [a .. b]\n\nflipRow, flipCol :: Board -> Char -> Board\nflipRow t r =\n  let e =\n        [ (ix, flp (t ! ix))\n        | ix <- zip (repeat r) (numCols t) ]\n  in t // e\n\nflipCol t c =\n  let e =\n        [ (ix, flp (t ! ix))\n        | ix <- zip (numRows t) (repeat c) ]\n  in t // e\n\nprintBoard :: Board -> IO ()\nprintBoard t = do\n  let rows = numRows t\n      cols = numCols t\n      f 0 = '0'\n      f 1 = '1'\n      p r xs = putStrLn $ [r, ' '] ++ intersperse ' ' (map f xs)\n  putStrLn $ \"  \" ++ intersperse ' ' cols\n  zipWithM_\n    p\n    rows\n    [ [ t ! (y, x)\n      | x <- cols ]\n    | y <- rows ]\n\n\n\nsetupGame :: Char -> Char -> IO (Board, Board)\nsetupGame sizey sizex\n                \n = do\n  let mk rc = (\\v -> (rc, v)) <$> randomRIO (0, 1)\n      rows = ['a' .. sizey]\n      cols = ['1' .. sizex]\n  goal <-\n    array (('a', '1'), (sizey, sizex)) <$>\n    mapM\n      mk\n      [ (r, c)\n      | r <- rows \n      , c <- cols ]\n  start <-\n    do let change :: Board -> Int -> IO Board\n           \n           change t 0 = flipRow t <$> randomRIO ('a', sizey)\n           \n           change t 1 = flipCol t <$> randomRIO ('1', sizex)\n       numMoves <- randomRIO (3, 15) \n       \n       moves <- replicateM numMoves $ randomRIO (0, 1)\n       \n       foldM change goal moves\n  if goal /= start \n    then return (goal, start) \n    else setupGame sizey sizex \n\nmain :: IO ()\nmain = do\n  putStrLn \"Select a board size (1 - 9).\\nPress any other key to exit.\"\n  sizec <- getChar\n  when (sizec `elem` ['1' .. '9']) $\n    do let size = read [sizec] - 1\n       (g, s) <- setupGame (['a' ..] !! size) (['1' ..] !! size)\n       turns g s 0\n  where\n    turns goal current moves = do\n      putStrLn \"\\nGoal:\"\n      printBoard goal\n      putStrLn \"\\nBoard:\"\n      printBoard current\n      when (moves > 0) $\n        putStrLn $ \"\\nYou've made \" ++ show moves ++ \" moves so far.\"\n      putStrLn $\n        \"\\nFlip a row (\" ++\n        numRows current ++ \") or a column (\" ++ numCols current ++ \")\"\n      v <- getChar\n      if v `elem` numRows current\n        then check $ flipRow current v\n        else if v `elem` numCols current\n               then check $ flipCol current v\n               else tryAgain\n      where\n        check t =\n          if t == goal\n            then putStrLn $ \"\\nYou've won in \" ++ show (moves + 1) ++ \" moves!\"\n            else turns goal t (moves + 1)\n        tryAgain = do\n          putStrLn \": Invalid row or column.\"\n          turns goal current moves\n", "target": "\n\nfrom random import randrange\nfrom copy import deepcopy\nfrom string import ascii_lowercase\n\n\ntry:    \n    input = raw_input\nexcept:\n    pass\n\nN = 3   \n\nboard  = [[0]* N for i in range(N)]\n\ndef setbits(board, count=1):\n    for i in range(count):\n        board[randrange(N)][randrange(N)] ^= 1\n\ndef shuffle(board, count=1):\n    for i in range(count):\n        if randrange(0, 2):\n            fliprow(randrange(N))\n        else:\n            flipcol(randrange(N))\n\n\ndef pr(board, comment=''):\n    print(str(comment))\n    print('     ' + ' '.join(ascii_lowercase[i] for i in range(N)))\n    print('  ' + '\\n  '.join(' '.join(['%2s' % j] + [str(i) for i in line])\n                             for j, line in enumerate(board, 1)))\n\ndef init(board):\n    setbits(board, count=randrange(N)+1)\n    target = deepcopy(board)\n    while board == target:\n        shuffle(board, count=2 * N)\n    prompt = '  X, T, or 1-%i / %s-%s to flip: ' % (N, ascii_lowercase[0], \n                                                    ascii_lowercase[N-1])\n    return target, prompt\n\ndef fliprow(i):\n    board[i-1][:] = [x ^ 1 for x in board[i-1] ]\n    \ndef flipcol(i):\n    for row in board:\n        row[i] ^= 1\n\nif __name__ == '__main__':\n    print(__doc__ % (N, N))\n    target, prompt = init(board)\n    pr(target, 'Target configuration is:')\n    print('')\n    turns = 0\n    while board != target:\n        turns += 1\n        pr(board, '%i:' % turns)\n        ans = input(prompt).strip()\n        if (len(ans) == 1 \n            and ans in ascii_lowercase and ascii_lowercase.index(ans) < N):\n            flipcol(ascii_lowercase.index(ans))\n        elif ans and all(ch in '0123456789' for ch in ans) and 1 <= int(ans) <= N:\n            fliprow(int(ans))\n        elif ans == 'T':\n            pr(target, 'Target configuration is:')\n            turns -= 1\n        elif ans == 'X':\n            break\n        else:\n            print(\"  I don't understand %r... Try again. \"\n                  \"(X to exit or T to show target)\\n\" % ans[:9])\n            turns -= 1\n    else:\n        print('\\nWell done!\\nBye.')\n"}
{"id": 351035, "name": "Gray code", "source": "Translate Haskell to Python: import Data.Bits\nimport Data.Char\nimport Numeric\nimport Control.Monad\nimport Text.Printf\n \ngrayToBin :: (Integral t, Bits t) => t -> t\ngrayToBin 0 = 0\ngrayToBin g = g `xor` (grayToBin $ g `shiftR` 1)\n \nbinToGray :: (Integral t, Bits t) => t -> t\nbinToGray b = b `xor` (b `shiftR` 1)\n\nshowBinary :: (Integral t, Show t) => t -> String\nshowBinary n = showIntAtBase 2 intToDigit n \"\"\n \nshowGrayCode :: (Integral t, Bits t, PrintfArg t, Show t) => t -> IO ()\nshowGrayCode num = do\n    let bin  = showBinary num\n    let gray = showBinary (binToGray num)\n    printf \"int: %2d -> bin: %5s -> gray: %5s\\n\" num bin gray\n\nmain = forM_ [0..31::Int] showGrayCode\n", "target": ">>> def int2bin(n):\n\t'From positive integer to list of binary bits, msb at index 0'\n\tif n:\n\t\tbits = []\n\t\twhile n:\n\t\t\tn,remainder = divmod(n, 2)\n\t\t\tbits.insert(0, remainder)\n\t\treturn bits\n\telse: return [0]\n\n\t\n>>> def bin2int(bits):\n\t'From binary bits, msb at index 0 to integer'\n\ti = 0\n\tfor bit in bits:\n\t\ti = i * 2 + bit\n\treturn i\n"}
{"id": 351036, "name": "Gray code", "source": "Translate Haskell to Python: import Data.Bits\nimport Data.Char\nimport Numeric\nimport Control.Monad\nimport Text.Printf\n \ngrayToBin :: (Integral t, Bits t) => t -> t\ngrayToBin 0 = 0\ngrayToBin g = g `xor` (grayToBin $ g `shiftR` 1)\n \nbinToGray :: (Integral t, Bits t) => t -> t\nbinToGray b = b `xor` (b `shiftR` 1)\n\nshowBinary :: (Integral t, Show t) => t -> String\nshowBinary n = showIntAtBase 2 intToDigit n \"\"\n \nshowGrayCode :: (Integral t, Bits t, PrintfArg t, Show t) => t -> IO ()\nshowGrayCode num = do\n    let bin  = showBinary num\n    let gray = showBinary (binToGray num)\n    printf \"int: %2d -> bin: %5s -> gray: %5s\\n\" num bin gray\n\nmain = forM_ [0..31::Int] showGrayCode\n", "target": ">>> def int2bin(n):\n\t'From positive integer to list of binary bits, msb at index 0'\n\tif n:\n\t\tbits = []\n\t\twhile n:\n\t\t\tn,remainder = divmod(n, 2)\n\t\t\tbits.insert(0, remainder)\n\t\treturn bits\n\telse: return [0]\n\n\t\n>>> def bin2int(bits):\n\t'From binary bits, msb at index 0 to integer'\n\ti = 0\n\tfor bit in bits:\n\t\ti = i * 2 + bit\n\treturn i\n"}
{"id": 351037, "name": "Vigen\u00e8re cipher_Cryptanalysis", "source": "Translate Haskell to Python: \nimport Data.List(transpose, nub, sort, maximumBy)\nimport Data.Ord (comparing)\nimport Data.Char (ord)\nimport Data.Map (Map, fromListWith, toList, findWithDefault)\n\naverage :: Fractional a => [a] -> a\naverage as = sum as / fromIntegral (length as)\n\n\n\ncountEntries :: Ord a => [a] -> Map a Int\ncountEntries = fromListWith (+) . fmap (,1)\n\n\nbreakup :: Int -> [a] -> [[a]]\nbreakup _ [] = []\nbreakup n as = \n    let (h, r) = splitAt n as\n    in h:breakup n r\n\n\ndistribute :: [a] -> Int -> [[a]]\ndistribute as n = transpose $ breakup n as\n\n\n\ncoincidence :: (Ord a, Fractional b) => [a] -> b\ncoincidence str = \n    let charCounts = snd <$> toList (countEntries str)\n        strln = length str\n        d = fromIntegral $ strln * (strln - 1)\n        n = fromIntegral $ sum $ fmap (\\cc -> cc * (cc-1)) charCounts\n    in n / d\n\n\n\n\n\nrate :: (Ord a, Fractional b) => [[a]] -> b\nrate d =  average (fmap coincidence d) - fromIntegral (length d) / 3000.0 \n\n\ndot :: Num a => [a] -> [a] -> a\ndot v0 v1 = sum $ zipWith (*) v0 v1\n\n\n\nrotateAndDot :: Num a => [a] -> [a] -> Char -> a\nrotateAndDot v0 v1 letter = dot v0 (drop (ord letter - ord 'A') (cycle v1))  \n\n\n\ngetKeyChar :: RealFrac a => [a] -> String -> Char\ngetKeyChar expected sample =\n    let charCounts = countEntries sample\n        countInSample c = findWithDefault 0 c charCounts\n        actual = fmap (fromIntegral . countInSample) ['A'..'Z']\n    in maximumBy (comparing $ rotateAndDot expected actual) ['A'..'Z']\n\nmain = do\n    let cr = filter (/=' ') crypt\n        \n        \n        distributions = fmap (distribute cr) [1..length cr `div` 20]\n        bestDistribution = maximumBy (comparing rate) distributions\n        key = fmap (getKeyChar englishFrequencies) bestDistribution\n        alphaSum a b = ['A'..'Z'] !! ((ord b - ord a) `mod` 26)\n    mapM_ putStrLn [\"Key: \" ++ key, \"Decrypted Text: \" ++ zipWith alphaSum (cycle key) cr]\n\nenglishFrequencies = \n    [ 0.08167, 0.01492, 0.02782, 0.04253, \n      0.12702, 0.02228, 0.02015, 0.06094, \n      0.06966, 0.00153, 0.00772, 0.04025, \n      0.02406, 0.06749, 0.07507, 0.01929, \n      0.00095, 0.05987, 0.06327, 0.09056, \n      0.02758, 0.00978, 0.02360, 0.00150, \n      0.01974, 0.00074 ] \n\ncrypt = \"\\\n    \\MOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYH\\\n    \\VUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRD\\\n    \\ITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQIS\\\n    \\FGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVG\\\n    \\ALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJ\\\n    \\ILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZS\\\n    \\JLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDT\\\n    \\LPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPST\\\n    \\MTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVH\\\n    \\QGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEV\\\n    \\RVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPW\\\n    \\TTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVO\\\n    \\SFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPR\\\n    \\ZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLX\\\n    \\BUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGB\\\n    \\BXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBA\\\n    \\FWAML ZZRXJ EKAHV FASMU LVVUT TGK\\\n    \\\"\n", "target": "from string import uppercase\nfrom operator import itemgetter\n\ndef vigenere_decrypt(target_freqs, input):\n    nchars = len(uppercase)\n    ordA = ord('A')\n    sorted_targets = sorted(target_freqs)\n\n    def frequency(input):\n        result = [[c, 0.0] for c in uppercase]\n        for c in input:\n            result[c - ordA][1] += 1\n        return result\n\n    def correlation(input):\n        result = 0.0\n        freq = frequency(input)\n        freq.sort(key=itemgetter(1))\n\n        for i, f in enumerate(freq):\n            result += f[1] * sorted_targets[i]\n        return result\n\n    cleaned = [ord(c) for c in input.upper() if c.isupper()]\n    best_len = 0\n    best_corr = -100.0\n\n    \n    \n    for i in xrange(2, len(cleaned) // 20):\n        pieces = [[] for _ in xrange(i)]\n        for j, c in enumerate(cleaned):\n            pieces[j % i].append(c)\n\n        \n        \n        corr = -0.5 * i + sum(correlation(p) for p in pieces)\n\n        if corr > best_corr:\n            best_len = i\n            best_corr = corr\n\n    if best_len == 0:\n        return (\"Text is too short to analyze\", \"\")\n\n    pieces = [[] for _ in xrange(best_len)]\n    for i, c in enumerate(cleaned):\n        pieces[i % best_len].append(c)\n\n    freqs = [frequency(p) for p in pieces]\n\n    key = \"\"\n    for fr in freqs:\n        fr.sort(key=itemgetter(1), reverse=True)\n\n        m = 0\n        max_corr = 0.0\n        for j in xrange(nchars):\n            corr = 0.0\n            c = ordA + j\n            for frc in fr:\n                d = (ord(frc[0]) - c + nchars) % nchars\n                corr += frc[1] * target_freqs[d]\n\n            if corr > max_corr:\n                m = j\n                max_corr = corr\n\n        key += chr(m + ordA)\n\n    r = (chr((c - ord(key[i % best_len]) + nchars) % nchars + ordA)\n         for i, c in enumerate(cleaned))\n    return (key, \"\".join(r))\n\n\ndef main():\n    encoded = \n\n    english_frequences = [\n        0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015,\n        0.06094, 0.06966, 0.00153, 0.00772, 0.04025, 0.02406, 0.06749,\n        0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09056, 0.02758,\n        0.00978, 0.02360, 0.00150, 0.01974, 0.00074]\n\n    (key, decoded) = vigenere_decrypt(english_frequences, encoded)\n    print \"Key:\", key\n    print \"\\nText:\", decoded\n\nmain()\n"}
{"id": 351038, "name": "File extension is in extensions list", "source": "Translate Haskell to Python: import Data.List\nimport qualified Data.Char as Ch\n\ntoLower :: String -> String \ntoLower = map Ch.toLower\n\nisExt :: String -> [String] -> Bool\nisExt filename extensions = any (`elem` (tails . toLower $ filename)) $ map toLower extensions\n", "target": "def isExt(fileName, extensions):\n  return True in map(fileName.lower().endswith, (\".\" + e.lower() for e in extensions))\n"}
{"id": 351039, "name": "File extension is in extensions list", "source": "Translate Haskell to Python: import Data.List\nimport qualified Data.Char as Ch\n\ntoLower :: String -> String \ntoLower = map Ch.toLower\n\nisExt :: String -> [String] -> Bool\nisExt filename extensions = any (`elem` (tails . toLower $ filename)) $ map toLower extensions\n", "target": "def isExt(fileName, extensions):\n  return True in map(fileName.lower().endswith, (\".\" + e.lower() for e in extensions))\n"}
{"id": 351040, "name": "Extreme floating point values", "source": "Translate Haskell to Python: main = do\nlet inf = 1/0\nlet minus_inf = -1/0\nlet minus_zero = -1/inf\nlet nan = 0/0\n\nputStrLn (\"Positive infinity = \"++(show inf))\nputStrLn (\"Negative infinity = \"++(show minus_inf))\nputStrLn (\"Negative zero = \"++(show minus_zero))\nputStrLn (\"Not a number = \"++(show nan))\n\n\n\nputStrLn (\"inf + 2.0 = \"++(show (inf+2.0)))\nputStrLn (\"inf - 10 = \"++(show (inf-10)))\nputStrLn (\"inf - inf = \"++(show (inf-inf)))\nputStrLn (\"inf * 0 = \"++(show (inf * 0)))\nputStrLn (\"nan + 1.0= \"++(show (nan+1.0)))\nputStrLn (\"nan + nan = \"++(show (nan + nan)))\n\n\n\nputStrLn (\"nan == nan = \"++(show (nan == nan)))\nputStrLn (\"0.0 == - 0.0 = \"++(show (0.0 == minus_zero)))\nputStrLn (\"inf == inf = \"++(show (inf == inf)))\n", "target": ">>> \n>>> inf = 1e234 * 1e234\n>>> _inf = 1e234 * -1e234\n>>> _zero = 1 / _inf\n>>> nan = inf + _inf\n>>> inf, _inf, _zero, nan\n(inf, -inf, -0.0, nan)\n>>> \n>>> for value in (inf, _inf, _zero, nan): print (value)\n\ninf\n-inf\n-0.0\nnan\n>>> \n>>> float('nan')\nnan\n>>> float('inf')\ninf\n>>> float('-inf')\n-inf\n>>> -0.\n-0.0\n>>> \n>>> nan == nan\nFalse\n>>> nan is nan\nTrue\n>>> 0. == -0.\nTrue\n>>> 0. is -0.\nFalse\n>>> inf + _inf\nnan\n>>> 0.0 * nan\nnan\n>>> nan * 0.0\nnan\n>>> 0.0 * inf\nnan\n>>> inf * 0.0\nnan\n"}
{"id": 351041, "name": "Extreme floating point values", "source": "Translate Haskell to Python: main = do\nlet inf = 1/0\nlet minus_inf = -1/0\nlet minus_zero = -1/inf\nlet nan = 0/0\n\nputStrLn (\"Positive infinity = \"++(show inf))\nputStrLn (\"Negative infinity = \"++(show minus_inf))\nputStrLn (\"Negative zero = \"++(show minus_zero))\nputStrLn (\"Not a number = \"++(show nan))\n\n\n\nputStrLn (\"inf + 2.0 = \"++(show (inf+2.0)))\nputStrLn (\"inf - 10 = \"++(show (inf-10)))\nputStrLn (\"inf - inf = \"++(show (inf-inf)))\nputStrLn (\"inf * 0 = \"++(show (inf * 0)))\nputStrLn (\"nan + 1.0= \"++(show (nan+1.0)))\nputStrLn (\"nan + nan = \"++(show (nan + nan)))\n\n\n\nputStrLn (\"nan == nan = \"++(show (nan == nan)))\nputStrLn (\"0.0 == - 0.0 = \"++(show (0.0 == minus_zero)))\nputStrLn (\"inf == inf = \"++(show (inf == inf)))\n", "target": ">>> \n>>> inf = 1e234 * 1e234\n>>> _inf = 1e234 * -1e234\n>>> _zero = 1 / _inf\n>>> nan = inf + _inf\n>>> inf, _inf, _zero, nan\n(inf, -inf, -0.0, nan)\n>>> \n>>> for value in (inf, _inf, _zero, nan): print (value)\n\ninf\n-inf\n-0.0\nnan\n>>> \n>>> float('nan')\nnan\n>>> float('inf')\ninf\n>>> float('-inf')\n-inf\n>>> -0.\n-0.0\n>>> \n>>> nan == nan\nFalse\n>>> nan is nan\nTrue\n>>> 0. == -0.\nTrue\n>>> 0. is -0.\nFalse\n>>> inf + _inf\nnan\n>>> 0.0 * nan\nnan\n>>> nan * 0.0\nnan\n>>> 0.0 * inf\nnan\n>>> inf * 0.0\nnan\n"}
{"id": 351042, "name": "Soundex", "source": "Translate Haskell to Python: import Text.PhoneticCode.Soundex\n\nmain :: IO ()\nmain =\n  mapM_ print $\n  ((,) <*> soundexSimple) <$> [\"Soundex\", \"Example\", \"Sownteks\", \"Ekzampul\"]\n", "target": "from itertools import groupby\n\ndef soundex(word):\n   codes = (\"bfpv\",\"cgjkqsxz\", \"dt\", \"l\", \"mn\", \"r\")\n   soundDict = dict((ch, str(ix+1)) for ix,cod in enumerate(codes) for ch in cod)\n   cmap2 = lambda kar: soundDict.get(kar, '9')\n   sdx =  ''.join(cmap2(kar) for kar in word.lower())\n   sdx2 = word[0].upper() + ''.join(k for k,g in list(groupby(sdx))[1:] if k!='9')\n   sdx3 = sdx2[0:4].ljust(4,'0')\n   return sdx3\n"}
{"id": 351043, "name": "Knuth's algorithm S", "source": "Translate Haskell to Python: import Control.Monad.Random\nimport Control.Monad.State\nimport qualified Data.Map as M\nimport System.Random\n\n\ns_of_n_creator :: Int -> a -> StateT (Int, [a]) (Rand StdGen) [a]\ns_of_n_creator n v = do\n  (i, vs) <- get\n  let i' = i + 1\n  if i' <= n\n    then do\n      let vs' = v : vs\n      put (i', vs')\n      pure vs'\n    else do\n      j <- getRandomR (1, i')\n      if j > n\n        then do\n          put (i', vs)\n          pure vs\n        else do\n          k <- getRandomR (0, n - 1)\n          let (f, (_ : b)) = splitAt k vs\n              vs' = v : f ++ b\n          put (i', vs')\n          pure vs'\n\nsample :: Int -> Rand StdGen [Int]\nsample n =\n  let s_of_n = s_of_n_creator n\n   in snd <$> execStateT (traverse s_of_n [0 .. 9 :: Int]) (0, [])\n\nincEach :: (Ord a, Num b) => M.Map a b -> [a] -> M.Map a b\nincEach m ks = foldl (\\m' k -> M.insertWith (+) k 1 m') m ks\n\nsampleInc :: Int -> M.Map Int Double -> Rand StdGen (M.Map Int Double)\nsampleInc n m = do\n  s <- sample n\n  pure $ incEach m s\n\nmain :: IO ()\nmain = do\n  let counts = M.empty :: M.Map Int Double\n      n = 100000\n  gen <- getStdGen\n  counts <- evalRandIO $ foldM (\\c _ -> sampleInc 3 c) M.empty [1 .. n]\n  print (fmap (/ n) counts)\n", "target": "from random import randrange\n\ndef s_of_n_creator(n):\n    sample, i = [], 0\n    def s_of_n(item):\n        nonlocal i\n\n        i += 1\n        if i <= n:\n            \n            sample.append(item)\n        elif randrange(i) < n:\n            \n            sample[randrange(n)] = item\n        return sample\n    return s_of_n\n\nif __name__ == '__main__':\n    bin = [0]* 10\n    items = range(10)\n    print(\"Single run samples for n = 3:\")\n    s_of_n = s_of_n_creator(3)\n    for item in items:\n        sample = s_of_n(item)\n        print(\"  Item: %i -> sample: %s\" % (item, sample))\n    \n    for trial in range(100000):\n        s_of_n = s_of_n_creator(3)\n        for item in items:\n            sample = s_of_n(item)\n        for s in sample:\n            bin[s] += 1\n    print(\"\\nTest item frequencies for 100000 runs:\\n \",\n          '\\n  '.join(\"%i:%i\" % x for x in enumerate(bin)))\n"}
{"id": 351044, "name": "Knuth's algorithm S", "source": "Translate Haskell to Python: import Control.Monad.Random\nimport Control.Monad.State\nimport qualified Data.Map as M\nimport System.Random\n\n\ns_of_n_creator :: Int -> a -> StateT (Int, [a]) (Rand StdGen) [a]\ns_of_n_creator n v = do\n  (i, vs) <- get\n  let i' = i + 1\n  if i' <= n\n    then do\n      let vs' = v : vs\n      put (i', vs')\n      pure vs'\n    else do\n      j <- getRandomR (1, i')\n      if j > n\n        then do\n          put (i', vs)\n          pure vs\n        else do\n          k <- getRandomR (0, n - 1)\n          let (f, (_ : b)) = splitAt k vs\n              vs' = v : f ++ b\n          put (i', vs')\n          pure vs'\n\nsample :: Int -> Rand StdGen [Int]\nsample n =\n  let s_of_n = s_of_n_creator n\n   in snd <$> execStateT (traverse s_of_n [0 .. 9 :: Int]) (0, [])\n\nincEach :: (Ord a, Num b) => M.Map a b -> [a] -> M.Map a b\nincEach m ks = foldl (\\m' k -> M.insertWith (+) k 1 m') m ks\n\nsampleInc :: Int -> M.Map Int Double -> Rand StdGen (M.Map Int Double)\nsampleInc n m = do\n  s <- sample n\n  pure $ incEach m s\n\nmain :: IO ()\nmain = do\n  let counts = M.empty :: M.Map Int Double\n      n = 100000\n  gen <- getStdGen\n  counts <- evalRandIO $ foldM (\\c _ -> sampleInc 3 c) M.empty [1 .. n]\n  print (fmap (/ n) counts)\n", "target": "from random import randrange\n\ndef s_of_n_creator(n):\n    sample, i = [], 0\n    def s_of_n(item):\n        nonlocal i\n\n        i += 1\n        if i <= n:\n            \n            sample.append(item)\n        elif randrange(i) < n:\n            \n            sample[randrange(n)] = item\n        return sample\n    return s_of_n\n\nif __name__ == '__main__':\n    bin = [0]* 10\n    items = range(10)\n    print(\"Single run samples for n = 3:\")\n    s_of_n = s_of_n_creator(3)\n    for item in items:\n        sample = s_of_n(item)\n        print(\"  Item: %i -> sample: %s\" % (item, sample))\n    \n    for trial in range(100000):\n        s_of_n = s_of_n_creator(3)\n        for item in items:\n            sample = s_of_n(item)\n        for s in sample:\n            bin[s] += 1\n    print(\"\\nTest item frequencies for 100000 runs:\\n \",\n          '\\n  '.join(\"%i:%i\" % x for x in enumerate(bin)))\n"}
{"id": 351045, "name": "Conjugate transpose", "source": "Translate Haskell to Python: import Data.Complex (Complex(..), conjugate)\nimport Data.List (transpose)\n\ntype Matrix a = [[a]]\n\nmain :: IO ()\nmain =\n  mapM_\n    (\\a -> do\n       putStrLn \"\\nMatrix:\"\n       mapM_ print a\n       putStrLn \"Conjugate Transpose:\"\n       mapM_ print (conjTranspose a)\n       putStrLn $ \"Hermitian? \" ++ show (isHermitianMatrix a)\n       putStrLn $ \"Normal? \" ++ show (isNormalMatrix a)\n       putStrLn $ \"Unitary? \" ++ show (isUnitaryMatrix a))\n    ([ [[3, 2 :+ 1], [2 :+ (-1), 1]]\n     , [[1, 1, 0], [0, 1, 1], [1, 0, 1]]\n     , [ [sqrt 2 / 2 :+ 0, sqrt 2 / 2 :+ 0, 0]\n       , [0 :+ sqrt 2 / 2, 0 :+ (-sqrt 2 / 2), 0]\n       , [0, 0, 0 :+ 1]\n       ]\n     ] :: [Matrix (Complex Double)])\n\nisHermitianMatrix, isNormalMatrix, isUnitaryMatrix\n  :: RealFloat a\n  => Matrix (Complex a) -> Bool\nisHermitianMatrix = mTest id conjTranspose\n\nisNormalMatrix = mTest mmct (mmul =<< conjTranspose)\n\nisUnitaryMatrix = mTest mmct (ident . length)\n\nmTest\n  :: RealFloat a\n  => (a2 -> Matrix (Complex a)) -> (a2 -> Matrix (Complex a)) -> a2 -> Bool\nmTest f g = (approxEqualMatrix . f) <*> g\n\nmmct\n  :: RealFloat a\n  => Matrix (Complex a) -> Matrix (Complex a)\nmmct = mmul <*> conjTranspose\n\napproxEqualMatrix\n  :: (Fractional a, Ord a)\n  => Matrix (Complex a) -> Matrix (Complex a) -> Bool\napproxEqualMatrix a b =\n  length a == length b &&\n  length (head a) == length (head b) &&\n  and (zipWith approxEqualComplex (concat a) (concat b))\n  where\n    approxEqualComplex (rx :+ ix) (ry :+ iy) =\n      abs (rx - ry) < eps && abs (ix - iy) < eps\n    eps = 1e-14\n\nmmul\n  :: Num a\n  => Matrix a -> Matrix a -> Matrix a\nmmul a b =\n  [ [ sum (zipWith (*) row column)\n    | column <- transpose b ]\n  | row <- a ]\n\nident\n  :: Num a\n  => Int -> Matrix a\nident size =\n  [ [ fromIntegral $ div a b * div b a\n    | a <- [1 .. size] ]\n  | b <- [1 .. size] ]\n\nconjTranspose\n  :: Num a\n  => Matrix (Complex a) -> Matrix (Complex a)\nconjTranspose = map (map conjugate) . transpose\n", "target": "def conjugate_transpose(m):\n    return tuple(tuple(n.conjugate() for n in row) for row in zip(*m))\n\ndef mmul( ma, mb):\n    return tuple(tuple(sum( ea*eb for ea,eb in zip(a,b)) for b in zip(*mb)) for a in ma)\n\ndef mi(size):\n    'Complex Identity matrix'\n    sz = range(size)\n    m = [[0 + 0j for i in sz] for j in sz]\n    for i in range(size):\n        m[i][i] = 1 + 0j\n    return tuple(tuple(row) for row in m)\n\ndef __allsame(vector):\n    first, rest = vector[0], vector[1:]\n    return all(i == first for i in rest)\n\ndef __allnearsame(vector, eps=1e-14):\n    first, rest = vector[0], vector[1:]\n    return all(abs(first.real - i.real) < eps and abs(first.imag - i.imag) < eps\n               for i in rest)\n\ndef isequal(matrices, eps=1e-14):\n    'Check any number of matrices for equality within eps'\n    x = [len(m) for m in matrices]\n    if not __allsame(x): return False\n    y = [len(m[0]) for m in matrices]\n    if not __allsame(y): return False\n    for s in range(x[0]):\n        for t in range(y[0]):\n            if not __allnearsame([m[s][t] for m in matrices], eps): return False\n    return True\n    \n\ndef ishermitian(m, ct):\n    return isequal([m, ct])\n\ndef isnormal(m, ct):\n    return isequal([mmul(m, ct), mmul(ct, m)])\n\ndef isunitary(m, ct):\n    mct, ctm = mmul(m, ct), mmul(ct, m)\n    mctx, mcty, cmx, ctmy = len(mct), len(mct[0]), len(ctm), len(ctm[0])\n    ident = mi(mctx)\n    return isequal([mct, ctm, ident])\n\ndef printm(comment, m):\n    print(comment)\n    fields = [['%g%+gj' % (f.real, f.imag) for f in row] for row in m]\n    width = max(max(len(f) for f in row) for row in fields)\n    lines = (', '.join('%*s' % (width, f) for f in row) for row in fields)\n    print('\\n'.join(lines))\n\nif __name__ == '__main__':\n    for matrix in [\n            ((( 3.000+0.000j), (+2.000+1.000j)), \n            (( 2.000-1.000j), (+1.000+0.000j))),\n\n            ((( 1.000+0.000j), (+1.000+0.000j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+1.000+0.000j), (+1.000+0.000j)), \n            (( 1.000+0.000j), (+0.000+0.000j), (+1.000+0.000j))),\n\n            ((( 2**0.5/2+0.000j), (+2**0.5/2+0.000j), (+0.000+0.000j)), \n            (( 0.000+2**0.5/2j), (+0.000-2**0.5/2j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+0.000+0.000j), (+0.000+1.000j)))]:\n        printm('\\nMatrix:', matrix)\n        ct = conjugate_transpose(matrix)\n        printm('Its conjugate transpose:', ct)\n        print('Hermitian? %s.' % ishermitian(matrix, ct))\n        print('Normal?    %s.' % isnormal(matrix, ct))\n        print('Unitary?   %s.' % isunitary(matrix, ct))\n"}
{"id": 351046, "name": "Conjugate transpose", "source": "Translate Haskell to Python: import Data.Complex (Complex(..), conjugate)\nimport Data.List (transpose)\n\ntype Matrix a = [[a]]\n\nmain :: IO ()\nmain =\n  mapM_\n    (\\a -> do\n       putStrLn \"\\nMatrix:\"\n       mapM_ print a\n       putStrLn \"Conjugate Transpose:\"\n       mapM_ print (conjTranspose a)\n       putStrLn $ \"Hermitian? \" ++ show (isHermitianMatrix a)\n       putStrLn $ \"Normal? \" ++ show (isNormalMatrix a)\n       putStrLn $ \"Unitary? \" ++ show (isUnitaryMatrix a))\n    ([ [[3, 2 :+ 1], [2 :+ (-1), 1]]\n     , [[1, 1, 0], [0, 1, 1], [1, 0, 1]]\n     , [ [sqrt 2 / 2 :+ 0, sqrt 2 / 2 :+ 0, 0]\n       , [0 :+ sqrt 2 / 2, 0 :+ (-sqrt 2 / 2), 0]\n       , [0, 0, 0 :+ 1]\n       ]\n     ] :: [Matrix (Complex Double)])\n\nisHermitianMatrix, isNormalMatrix, isUnitaryMatrix\n  :: RealFloat a\n  => Matrix (Complex a) -> Bool\nisHermitianMatrix = mTest id conjTranspose\n\nisNormalMatrix = mTest mmct (mmul =<< conjTranspose)\n\nisUnitaryMatrix = mTest mmct (ident . length)\n\nmTest\n  :: RealFloat a\n  => (a2 -> Matrix (Complex a)) -> (a2 -> Matrix (Complex a)) -> a2 -> Bool\nmTest f g = (approxEqualMatrix . f) <*> g\n\nmmct\n  :: RealFloat a\n  => Matrix (Complex a) -> Matrix (Complex a)\nmmct = mmul <*> conjTranspose\n\napproxEqualMatrix\n  :: (Fractional a, Ord a)\n  => Matrix (Complex a) -> Matrix (Complex a) -> Bool\napproxEqualMatrix a b =\n  length a == length b &&\n  length (head a) == length (head b) &&\n  and (zipWith approxEqualComplex (concat a) (concat b))\n  where\n    approxEqualComplex (rx :+ ix) (ry :+ iy) =\n      abs (rx - ry) < eps && abs (ix - iy) < eps\n    eps = 1e-14\n\nmmul\n  :: Num a\n  => Matrix a -> Matrix a -> Matrix a\nmmul a b =\n  [ [ sum (zipWith (*) row column)\n    | column <- transpose b ]\n  | row <- a ]\n\nident\n  :: Num a\n  => Int -> Matrix a\nident size =\n  [ [ fromIntegral $ div a b * div b a\n    | a <- [1 .. size] ]\n  | b <- [1 .. size] ]\n\nconjTranspose\n  :: Num a\n  => Matrix (Complex a) -> Matrix (Complex a)\nconjTranspose = map (map conjugate) . transpose\n", "target": "def conjugate_transpose(m):\n    return tuple(tuple(n.conjugate() for n in row) for row in zip(*m))\n\ndef mmul( ma, mb):\n    return tuple(tuple(sum( ea*eb for ea,eb in zip(a,b)) for b in zip(*mb)) for a in ma)\n\ndef mi(size):\n    'Complex Identity matrix'\n    sz = range(size)\n    m = [[0 + 0j for i in sz] for j in sz]\n    for i in range(size):\n        m[i][i] = 1 + 0j\n    return tuple(tuple(row) for row in m)\n\ndef __allsame(vector):\n    first, rest = vector[0], vector[1:]\n    return all(i == first for i in rest)\n\ndef __allnearsame(vector, eps=1e-14):\n    first, rest = vector[0], vector[1:]\n    return all(abs(first.real - i.real) < eps and abs(first.imag - i.imag) < eps\n               for i in rest)\n\ndef isequal(matrices, eps=1e-14):\n    'Check any number of matrices for equality within eps'\n    x = [len(m) for m in matrices]\n    if not __allsame(x): return False\n    y = [len(m[0]) for m in matrices]\n    if not __allsame(y): return False\n    for s in range(x[0]):\n        for t in range(y[0]):\n            if not __allnearsame([m[s][t] for m in matrices], eps): return False\n    return True\n    \n\ndef ishermitian(m, ct):\n    return isequal([m, ct])\n\ndef isnormal(m, ct):\n    return isequal([mmul(m, ct), mmul(ct, m)])\n\ndef isunitary(m, ct):\n    mct, ctm = mmul(m, ct), mmul(ct, m)\n    mctx, mcty, cmx, ctmy = len(mct), len(mct[0]), len(ctm), len(ctm[0])\n    ident = mi(mctx)\n    return isequal([mct, ctm, ident])\n\ndef printm(comment, m):\n    print(comment)\n    fields = [['%g%+gj' % (f.real, f.imag) for f in row] for row in m]\n    width = max(max(len(f) for f in row) for row in fields)\n    lines = (', '.join('%*s' % (width, f) for f in row) for row in fields)\n    print('\\n'.join(lines))\n\nif __name__ == '__main__':\n    for matrix in [\n            ((( 3.000+0.000j), (+2.000+1.000j)), \n            (( 2.000-1.000j), (+1.000+0.000j))),\n\n            ((( 1.000+0.000j), (+1.000+0.000j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+1.000+0.000j), (+1.000+0.000j)), \n            (( 1.000+0.000j), (+0.000+0.000j), (+1.000+0.000j))),\n\n            ((( 2**0.5/2+0.000j), (+2**0.5/2+0.000j), (+0.000+0.000j)), \n            (( 0.000+2**0.5/2j), (+0.000-2**0.5/2j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+0.000+0.000j), (+0.000+1.000j)))]:\n        printm('\\nMatrix:', matrix)\n        ct = conjugate_transpose(matrix)\n        printm('Its conjugate transpose:', ct)\n        print('Hermitian? %s.' % ishermitian(matrix, ct))\n        print('Normal?    %s.' % isnormal(matrix, ct))\n        print('Unitary?   %s.' % isunitary(matrix, ct))\n"}
{"id": 351047, "name": "Disarium numbers", "source": "Translate Haskell to Python: module Disarium \n   where\nimport Data.Char ( digitToInt)\n\nisDisarium :: Int -> Bool\nisDisarium n = (sum $ map (\\(c , i ) -> (digitToInt c ) ^ i )\n $ zip ( show n ) [1 , 2 ..]) == n\n\nsolution :: [Int]\nsolution = take 18 $ filter isDisarium [0, 1 ..]\n", "target": "\n\ndef isDisarium(n):\n    digitos = len(str(n))\n    suma = 0\n    x = n\n    while x != 0:\n        suma += (x % 10) ** digitos\n        digitos -= 1\n        x //= 10\n    if suma == n:\n        return True\n    else:\n        return False\n\nif __name__ == '__main__':\n    limite = 19\n    cont = 0\n    n = 0\n    print(\"The first\",limite,\"Disarium numbers are:\")\n    while cont < limite:\n        if isDisarium(n):\n            print(n, end = \" \")\n            cont += 1\n        n += 1\n"}
{"id": 351048, "name": "Disarium numbers", "source": "Translate Haskell to Python: module Disarium \n   where\nimport Data.Char ( digitToInt)\n\nisDisarium :: Int -> Bool\nisDisarium n = (sum $ map (\\(c , i ) -> (digitToInt c ) ^ i )\n $ zip ( show n ) [1 , 2 ..]) == n\n\nsolution :: [Int]\nsolution = take 18 $ filter isDisarium [0, 1 ..]\n", "target": "\n\ndef isDisarium(n):\n    digitos = len(str(n))\n    suma = 0\n    x = n\n    while x != 0:\n        suma += (x % 10) ** digitos\n        digitos -= 1\n        x //= 10\n    if suma == n:\n        return True\n    else:\n        return False\n\nif __name__ == '__main__':\n    limite = 19\n    cont = 0\n    n = 0\n    print(\"The first\",limite,\"Disarium numbers are:\")\n    while cont < limite:\n        if isDisarium(n):\n            print(n, end = \" \")\n            cont += 1\n        n += 1\n"}
{"id": 351049, "name": "Cousin primes", "source": "Translate Haskell to Python: import Data.List (intercalate, transpose)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes (isPrime, primes)\nimport Text.Printf (printf)\n\n\n\ncousinPrimes :: [(Integer, Integer)]\ncousinPrimes = concat $ (zipWith go <*> fmap (+ 4)) primes\n  where\n    go a b = [(a, b) | isPrime b]\n\n\n\nmain :: IO ()\nmain = do\n  let cousins = takeWhile ((< 1000) . snd) cousinPrimes\n  mapM_\n    putStrLn\n    [ (show . length) cousins <> \" cousin prime pairs:\",\n      \"\",\n      table \"   \" $\n        chunksOf 5 $ show <$> cousins\n    ]\n\n\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "\n\nfrom itertools import chain, takewhile\n\n\n\ndef cousinPrimes():\n    \n    def go(x):\n        n = 4 + x\n        return [(x, n)] if isPrime(n) else []\n\n    return chain.from_iterable(\n        map(go, primes())\n    )\n\n\n\n\ndef main():\n    \n\n    pairs = list(\n        takewhile(\n            lambda ab: 1000 > ab[1],\n            cousinPrimes()\n        )\n    )\n\n    print(f'{len(pairs)} cousin pairs below 1000:\\n')\n    print(\n        spacedTable(list(\n            chunksOf(4)([\n                repr(x) for x in pairs\n            ])\n        ))\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef listTranspose(xss):\n    \n    def go(xss):\n        if xss:\n            h, *t = xss\n            return (\n                [[h[0]] + [xs[0] for xs in t if xs]] + (\n                    go([h[1:]] + [xs[1:] for xs in t])\n                )\n            ) if h and isinstance(h, list) else go(t)\n        else:\n            return []\n    return go(xss)\n\n\n\ndef spacedTable(rows):\n    \n    columnWidths = [\n        len(str(row[-1])) for row in listTranspose(rows)\n    ]\n    return '\\n'.join([\n        ' '.join(\n            map(\n                lambda w, s: s.rjust(w, ' '),\n                columnWidths, row\n            )\n        ) for row in rows\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351050, "name": "Cousin primes", "source": "Translate Haskell to Python: import Data.List (intercalate, transpose)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes (isPrime, primes)\nimport Text.Printf (printf)\n\n\n\ncousinPrimes :: [(Integer, Integer)]\ncousinPrimes = concat $ (zipWith go <*> fmap (+ 4)) primes\n  where\n    go a b = [(a, b) | isPrime b]\n\n\n\nmain :: IO ()\nmain = do\n  let cousins = takeWhile ((< 1000) . snd) cousinPrimes\n  mapM_\n    putStrLn\n    [ (show . length) cousins <> \" cousin prime pairs:\",\n      \"\",\n      table \"   \" $\n        chunksOf 5 $ show <$> cousins\n    ]\n\n\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "\n\nfrom itertools import chain, takewhile\n\n\n\ndef cousinPrimes():\n    \n    def go(x):\n        n = 4 + x\n        return [(x, n)] if isPrime(n) else []\n\n    return chain.from_iterable(\n        map(go, primes())\n    )\n\n\n\n\ndef main():\n    \n\n    pairs = list(\n        takewhile(\n            lambda ab: 1000 > ab[1],\n            cousinPrimes()\n        )\n    )\n\n    print(f'{len(pairs)} cousin pairs below 1000:\\n')\n    print(\n        spacedTable(list(\n            chunksOf(4)([\n                repr(x) for x in pairs\n            ])\n        ))\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef listTranspose(xss):\n    \n    def go(xss):\n        if xss:\n            h, *t = xss\n            return (\n                [[h[0]] + [xs[0] for xs in t if xs]] + (\n                    go([h[1:]] + [xs[1:] for xs in t])\n                )\n            ) if h and isinstance(h, list) else go(t)\n        else:\n            return []\n    return go(xss)\n\n\n\ndef spacedTable(rows):\n    \n    columnWidths = [\n        len(str(row[-1])) for row in listTranspose(rows)\n    ]\n    return '\\n'.join([\n        ' '.join(\n            map(\n                lambda w, s: s.rjust(w, ' '),\n                columnWidths, row\n            )\n        ) for row in rows\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351051, "name": "Flow-control structures", "source": "Translate Haskell to Python: import Control.Monad\nimport Control.Monad.Trans\nimport Control.Monad.Exit\n\nmain = do\n    runExitTMaybe $ do\n        forM_ [1..5] $ \\x -> do\n            forM_ [1..5] $ \\y -> do\n                lift $ print (x, y)\n                when (x == 3 && y == 2) $\n                    exitWith ()\n    putStrLn \"Done.\"\n", "target": "\nfor i in range(n):\n    if (n%2) == 0:\n        continue\n    if (n%i) == 0:\n        result = i\n        break\nelse:\n    result = None\n    print \"No odd factors found\"\n"}
{"id": 351052, "name": "Find if a point is within a triangle", "source": "Translate Haskell to Python: type Pt a = (a, a)\n\ndata Overlapping = Inside | Outside | Boundary\n  deriving (Show, Eq)\n\ndata Triangle a = Triangle (Pt a) (Pt a) (Pt a)\n  deriving Show\n\nvertices (Triangle a b c) = [a, b, c]\n\n\n\n\ntoTriangle :: Num a => Triangle a -> Pt a -> (a, Pt a)\ntoTriangle t (x,y) = let\n  [(x0,y0), (x1,y1), (x2,y2)] = vertices t\n  s = x2*(y0-y1)+x0*(y1-y2)+x1*(-y0+y2)\n  in  ( abs s\n      , ( signum s * (x2*(-y+y0)+x0*(y-y2)+x*(-y0+y2))\n        , signum s * (x1*(y-y0)+x*(y0-y1)+x0*(-y+y1))))\n\noverlapping :: (Eq a, Ord a, Num a) =>\n  Triangle a -> Pt a -> Overlapping\noverlapping t p =  case toTriangle t p of\n  (s, (x, y))\n    | s == 0 && (x == 0 || y == 0)     -> Boundary\n    | s == 0                           -> Outside\n    | x > 0 && y > 0 && y < s - x      -> Inside\n    | (x <= s && x >= 0) &&\n      (y <= s && y >= 0) &&\n      (x == 0 || y == 0 || y == s - x) -> Boundary         \n    | otherwise                        -> Outside\n", "target": "\n\nfrom sympy.geometry import Point, Triangle\n\ndef sign(pt1, pt2, pt3):\n    \n    return (pt1.x - pt3.x) * (pt2.y - pt3.y) - (pt2.x - pt3.x) * (pt1.y - pt3.y)\n\n\ndef iswithin(point, pt1, pt2, pt3):\n    \n    zval1 = sign(point, pt1, pt2)\n    zval2 = sign(point, pt2, pt3)\n    zval3 = sign(point, pt3, pt1)\n    notanyneg = zval1 >= 0 and zval2 >= 0 and zval3 >= 0\n    notanypos = zval1 <= 0 and zval2 <= 0 and zval3 <= 0\n    return notanyneg or notanypos\n\nif __name__ == \"__main__\":\n    POINTS = [Point(0, 0)]\n    TRI = Triangle(Point(1.5, 2.4), Point(5.1, -3.1), Point(-3.8, 0.5))\n    for pnt in POINTS:\n        a, b, c = TRI.vertices\n        isornot = \"is\" if iswithin(pnt, a, b, c) else \"is not\"\n        print(\"Point\", pnt, isornot, \"within the triangle\", TRI)\n"}
{"id": 351053, "name": "Find if a point is within a triangle", "source": "Translate Haskell to Python: type Pt a = (a, a)\n\ndata Overlapping = Inside | Outside | Boundary\n  deriving (Show, Eq)\n\ndata Triangle a = Triangle (Pt a) (Pt a) (Pt a)\n  deriving Show\n\nvertices (Triangle a b c) = [a, b, c]\n\n\n\n\ntoTriangle :: Num a => Triangle a -> Pt a -> (a, Pt a)\ntoTriangle t (x,y) = let\n  [(x0,y0), (x1,y1), (x2,y2)] = vertices t\n  s = x2*(y0-y1)+x0*(y1-y2)+x1*(-y0+y2)\n  in  ( abs s\n      , ( signum s * (x2*(-y+y0)+x0*(y-y2)+x*(-y0+y2))\n        , signum s * (x1*(y-y0)+x*(y0-y1)+x0*(-y+y1))))\n\noverlapping :: (Eq a, Ord a, Num a) =>\n  Triangle a -> Pt a -> Overlapping\noverlapping t p =  case toTriangle t p of\n  (s, (x, y))\n    | s == 0 && (x == 0 || y == 0)     -> Boundary\n    | s == 0                           -> Outside\n    | x > 0 && y > 0 && y < s - x      -> Inside\n    | (x <= s && x >= 0) &&\n      (y <= s && y >= 0) &&\n      (x == 0 || y == 0 || y == s - x) -> Boundary         \n    | otherwise                        -> Outside\n", "target": "\n\nfrom sympy.geometry import Point, Triangle\n\ndef sign(pt1, pt2, pt3):\n    \n    return (pt1.x - pt3.x) * (pt2.y - pt3.y) - (pt2.x - pt3.x) * (pt1.y - pt3.y)\n\n\ndef iswithin(point, pt1, pt2, pt3):\n    \n    zval1 = sign(point, pt1, pt2)\n    zval2 = sign(point, pt2, pt3)\n    zval3 = sign(point, pt3, pt1)\n    notanyneg = zval1 >= 0 and zval2 >= 0 and zval3 >= 0\n    notanypos = zval1 <= 0 and zval2 <= 0 and zval3 <= 0\n    return notanyneg or notanypos\n\nif __name__ == \"__main__\":\n    POINTS = [Point(0, 0)]\n    TRI = Triangle(Point(1.5, 2.4), Point(5.1, -3.1), Point(-3.8, 0.5))\n    for pnt in POINTS:\n        a, b, c = TRI.vertices\n        isornot = \"is\" if iswithin(pnt, a, b, c) else \"is not\"\n        print(\"Point\", pnt, isornot, \"within the triangle\", TRI)\n"}
{"id": 351054, "name": "Change e letters to i in words", "source": "Translate Haskell to Python: import qualified Data.Set as S\n\n\n\nieTwins :: String -> [(String, String)]\nieTwins s =\n  [ (w, twin)\n    | w <- filter ('e' `elem`) longWords,\n      let twin = iForE w,\n      S.member twin lexicon\n  ]\n  where\n    longWords = filter ((5 <) . length) (lines s)\n    lexicon = S.fromList $ filter ('i' `elem`) longWords\n\niForE :: String -> String\niForE [] = []\niForE ('e' : cs) = 'i' : iForE cs\niForE (c : cs) = c : iForE cs\n\n\nmain :: IO ()\nmain =\n  readFile \"unixdict.txt\"\n    >>= (mapM_ print . ieTwins)\n", "target": "\n\n\n\ndef ieTwins(s):\n    \n    longWords = [\n        w for w in s.splitlines()\n        if 5 < len(w)\n    ]\n    lexicon = {\n        w for w in longWords\n        if 'i' in w\n    }\n\n    return [\n        (w, twin) for w in longWords\n        if 'e' in w and (\n            twin := w.replace('e', 'i')\n        ) in lexicon\n    ]\n\n\n\n\ndef main():\n    \n    for pair in ieTwins(\n        readFile(\"unixdict.txt\")\n    ):\n        print(pair)\n\n\n\n\n\ndef readFile(fp):\n    \n    with open(fp, 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351055, "name": "Change e letters to i in words", "source": "Translate Haskell to Python: import qualified Data.Set as S\n\n\n\nieTwins :: String -> [(String, String)]\nieTwins s =\n  [ (w, twin)\n    | w <- filter ('e' `elem`) longWords,\n      let twin = iForE w,\n      S.member twin lexicon\n  ]\n  where\n    longWords = filter ((5 <) . length) (lines s)\n    lexicon = S.fromList $ filter ('i' `elem`) longWords\n\niForE :: String -> String\niForE [] = []\niForE ('e' : cs) = 'i' : iForE cs\niForE (c : cs) = c : iForE cs\n\n\nmain :: IO ()\nmain =\n  readFile \"unixdict.txt\"\n    >>= (mapM_ print . ieTwins)\n", "target": "\n\n\n\ndef ieTwins(s):\n    \n    longWords = [\n        w for w in s.splitlines()\n        if 5 < len(w)\n    ]\n    lexicon = {\n        w for w in longWords\n        if 'i' in w\n    }\n\n    return [\n        (w, twin) for w in longWords\n        if 'e' in w and (\n            twin := w.replace('e', 'i')\n        ) in lexicon\n    ]\n\n\n\n\ndef main():\n    \n    for pair in ieTwins(\n        readFile(\"unixdict.txt\")\n    ):\n        print(pair)\n\n\n\n\n\ndef readFile(fp):\n    \n    with open(fp, 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351056, "name": "Fractran", "source": "Translate Haskell to Python: import Data.List (find)\nimport Data.Ratio (Ratio, (%), denominator)\n\nfractran :: (Integral a) => [Ratio a] -> a -> [a]\nfractran fracts n = n :\n  case find (\\f -> n `mod` denominator f == 0) fracts of\n    Nothing -> []\n    Just f -> fractran fracts $ truncate (fromIntegral n * f)\n", "target": "from fractions import Fraction\n\ndef fractran(n, fstring='17 / 91, 78 / 85, 19 / 51, 23 / 38, 29 / 33,'\n                        '77 / 29, 95 / 23, 77 / 19, 1 / 17, 11 / 13,'\n                        '13 / 11, 15 / 14, 15 / 2, 55 / 1'):\n    flist = [Fraction(f) for f in fstring.replace(' ', '').split(',')]\n\n    n = Fraction(n)\n    while True:\n        yield n.numerator\n        for f in flist:\n            if (n * f).denominator == 1:\n                break\n        else:\n            break\n        n *= f\n    \nif __name__ == '__main__':\n    n, m = 2, 15\n    print('First %i members of fractran(%i):\\n  ' % (m, n) +\n          ', '.join(str(f) for f,i in zip(fractran(n), range(m))))\n"}
{"id": 351057, "name": "Substring_Top and tail", "source": "Translate Haskell to Python: \n\n\nremFirst, remLast, remBoth :: String -> String\n\nremFirst \"\" = \"\"\nremFirst cs = tail cs\n\nremLast \"\" = \"\"\nremLast cs = init cs\n\nremBoth (c:cs) = remLast cs\nremBoth  _     = \"\"\n\nmain :: IO ()\nmain = do\n  let s = \"Some string.\"  \n  mapM_ (\\f -> putStrLn . f $ s) [remFirst, remLast, remBoth]\n", "target": "print \"knight\"[1:]     \nprint \"socks\"[:-1]     \nprint \"brooms\"[1:-1]   \n"}
{"id": 351058, "name": "Substring_Top and tail", "source": "Translate Haskell to Python: \n\n\nremFirst, remLast, remBoth :: String -> String\n\nremFirst \"\" = \"\"\nremFirst cs = tail cs\n\nremLast \"\" = \"\"\nremLast cs = init cs\n\nremBoth (c:cs) = remLast cs\nremBoth  _     = \"\"\n\nmain :: IO ()\nmain = do\n  let s = \"Some string.\"  \n  mapM_ (\\f -> putStrLn . f $ s) [remFirst, remLast, remBoth]\n", "target": "print \"knight\"[1:]     \nprint \"socks\"[:-1]     \nprint \"brooms\"[1:-1]   \n"}
{"id": 351059, "name": "Boolean values", "source": "Translate Haskell to Python: data Bool = False | True    deriving (Eq, Ord, Enum, Read, Show, Bounded)\n", "target": ">>> True\nTrue\n>>> not True\nFalse\n>>> \n>>> False + 0\n0\n>>> True + 0\n1\n>>> False + 0j\n0j\n>>> True * 3.141\n3.141\n>>> \n>>> not 0\nTrue\n>>> not not 0\nFalse\n>>> not 1234\nFalse\n>>> bool(0.0)\nFalse\n>>> bool(0j)\nFalse\n>>> bool(1+2j)\nTrue\n>>> \n>>> bool([])\nFalse\n>>> bool([None])\nTrue\n>>> 'I contain something' if (None,) else 'I am empty'\n'I contain something'\n>>> bool({})\nFalse\n>>> bool(\"\")\nFalse\n>>> bool(\"False\")\nTrue\n"}
{"id": 351060, "name": "Multiline shebang", "source": "Translate Haskell to Python: #!/bin/bash\nsed -n -e '7,$p' < \"$0\" > $0.$$.hs\nghc $0.$$.hs > /dev/null\n./$0.$$ \"$0\" \"$@\"\nrm $0.$$*\nexit\nimport Text.Printf\nimport System.Environment\n\nmain :: IO ()\nmain = getArgs >>= mapM_ (uncurry $ printf \"argv[%d] -> %s\\n\") . zip ([0..] :: [Int])\n", "target": "\n\"exec\" \"python\" \"$0\"\n\nprint \"Hello World\"\n"}
{"id": 351061, "name": "Multiline shebang", "source": "Translate Haskell to Python: #!/bin/bash\nsed -n -e '7,$p' < \"$0\" > $0.$$.hs\nghc $0.$$.hs > /dev/null\n./$0.$$ \"$0\" \"$@\"\nrm $0.$$*\nexit\nimport Text.Printf\nimport System.Environment\n\nmain :: IO ()\nmain = getArgs >>= mapM_ (uncurry $ printf \"argv[%d] -> %s\\n\") . zip ([0..] :: [Int])\n", "target": "\n\"exec\" \"python\" \"$0\"\n\nprint \"Hello World\"\n"}
{"id": 351062, "name": "Bitmap_Histogram", "source": "Translate Haskell to Python: module Bitmap.BW(module Bitmap.BW) where\n\nimport Bitmap\nimport Control.Monad.ST\n\nnewtype BW = BW Bool deriving (Eq, Ord)\n\ninstance Color BW where\n    luminance (BW False) = 0\n    luminance _          = 255\n    black = BW False\n    white = BW True\n    toNetpbm [] = \"\"\n    toNetpbm l = init (concatMap f line) ++ \"\\n\" ++ toNetpbm rest\n      where (line, rest) = splitAt 35 l\n            f (BW False) = \"1 \"\n            f _          = \"0 \"\n    fromNetpbm = map f\n      where f 1 = black\n            f _ = white\n    netpbmMagicNumber _ = \"P1\"\n    netpbmMaxval _ = \"\"\n\ntoBWImage :: Color c => Image s c -> ST s (Image s BW)\ntoBWImage = toBWImage' 128\n\ntoBWImage' :: Color c => Int -> Image s c -> ST s (Image s BW)\n\ntoBWImage' darkestWhite = mapImage $ f . luminance\n  where f x | x < darkestWhite = black\n            | otherwise        = white\n", "target": "from PIL import Image\n\n\nimage = Image.open(\"lena.jpg\")\n\nwidth, height = image.size\n\namount = width * height\n\n\ntotal = 0\n\nbw_image = Image.new('L', (width, height), 0)\n\nbm_image = Image.new('1', (width, height), 0)\n\nfor h in range(0, height):\n    for w in range(0, width):\n        r, g, b = image.getpixel((w, h))\n\n        greyscale = int((r + g + b) / 3)\n        total += greyscale\n\n        bw_image.putpixel((w, h), gray_scale)\n\n\navg = total / amount\n\nblack = 0\nwhite = 1\n\nfor h in range(0, height):\n    for w in range(0, width):\n        v = bw_image.getpixel((w, h))\n\n        if v >= avg:\n            bm_image.putpixel((w, h), white)\n        else:\n            bm_image.putpixel((w, h), black)\n\nbw_image.show()\nbm_image.show()\n"}
{"id": 351063, "name": "Plot coordinate pairs", "source": "Translate Haskell to Python: import Graphics.Gnuplot.Simple\n\npnts = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]\n\ndoPlot = plotPathStyle [ ( Title \"plotting dots\" )]\n            (PlotStyle Points (CustomStyle []))  (zip [0..] pnts)\n", "target": ">>> x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> y = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]\n\n>>> import pylab\n>>> pylab.plot(x, y, 'bo')\n>>> pylab.savefig('qsort-range-10-9.png')\n"}
{"id": 351064, "name": "Plot coordinate pairs", "source": "Translate Haskell to Python: import Graphics.Gnuplot.Simple\n\npnts = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]\n\ndoPlot = plotPathStyle [ ( Title \"plotting dots\" )]\n            (PlotStyle Points (CustomStyle []))  (zip [0..] pnts)\n", "target": ">>> x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> y = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]\n\n>>> import pylab\n>>> pylab.plot(x, y, 'bo')\n>>> pylab.savefig('qsort-range-10-9.png')\n"}
{"id": 351065, "name": "LZW compression", "source": "Translate Haskell to Python: import Data.List (elemIndex, tails)\nimport Data.Maybe (fromJust)\n\ndoLZW :: Eq a => [a] -> [a] -> [Int]\ndoLZW _ [] = []\ndoLZW as (x:xs) = lzw (return <$> as) [x] xs\n  where\n    lzw a w [] = [fromJust $ elemIndex w a]\n    lzw a w (x:xs)\n      | w_ `elem` a = lzw a w_ xs\n      | otherwise = fromJust (elemIndex w a) : lzw (a ++ [w_]) [x] xs\n      where\n        w_ = w ++ [x]\n\nundoLZW :: [a] -> [Int] -> [a]\nundoLZW _ [] = []\nundoLZW a cs =\n  cs >>=\n  (!!)\n    (foldl\n       ((.) <$> (++) <*>\n        (\\x xs -> return (((++) <$> head <*> take 1 . last) ((x !!) <$> xs))))\n       (return <$> a)\n       (take2 cs))\n\ntake2 :: [a] -> [[a]]\ntake2 xs = filter ((2 ==) . length) (take 2 <$> tails xs)\n\nmain :: IO ()\nmain = do\n  print $ doLZW ['\\0' .. '\\255'] \"TOBEORNOTTOBEORTOBEORNOT\"\n  print $\n    undoLZW\n      ['\\0' .. '\\255']\n      [84, 79, 66, 69, 79, 82, 78, 79, 84, 256, 258, 260, 265, 259, 261, 263]\n  print $\n    ((==) <*> ((.) <$> undoLZW <*> doLZW) ['\\NUL' .. '\\255'])\n      \"TOBEORNOTTOBEORTOBEORNOT\"\n", "target": "def compress(uncompressed):\n    \n\n    \n    dict_size = 256\n    dictionary = dict((chr(i), i) for i in range(dict_size))\n    \n\n    w = \"\"\n    result = []\n    for c in uncompressed:\n        wc = w + c\n        if wc in dictionary:\n            w = wc\n        else:\n            result.append(dictionary[w])\n            \n            dictionary[wc] = dict_size\n            dict_size += 1\n            w = c\n\n    \n    if w:\n        result.append(dictionary[w])\n    return result\n\n\ndef decompress(compressed):\n    \n    from io import StringIO\n\n    \n    dict_size = 256\n    dictionary = dict((i, chr(i)) for i in range(dict_size))\n    \n\n    \n    \n    result = StringIO()\n    w = chr(compressed.pop(0))\n    result.write(w)\n    for k in compressed:\n        if k in dictionary:\n            entry = dictionary[k]\n        elif k == dict_size:\n            entry = w + w[0]\n        else:\n            raise ValueError('Bad compressed k: %s' % k)\n        result.write(entry)\n\n        \n        dictionary[dict_size] = w + entry[0]\n        dict_size += 1\n\n        w = entry\n    return result.getvalue()\n\n\n\ncompressed = compress('TOBEORNOTTOBEORTOBEORNOT')\nprint (compressed)\ndecompressed = decompress(compressed)\nprint (decompressed)\n"}
{"id": 351066, "name": "Check input device is a terminal", "source": "Translate Haskell to Python: module Main (main) where\n \nimport           System.Posix.IO (stdInput)\nimport           System.Posix.Terminal (queryTerminal)\n \nmain :: IO ()\nmain = do\n    isTTY <- queryTerminal stdInput\n    putStrLn $ if isTTY\n                then \"stdin is TTY\"\n                else \"stdin is not TTY\"\n", "target": "from sys import stdin\nif stdin.isatty():\n    print(\"Input comes from tty.\")\nelse:\n    print(\"Input doesn't come from tty.\")\n"}
{"id": 351067, "name": "Check input device is a terminal", "source": "Translate Haskell to Python: module Main (main) where\n \nimport           System.Posix.IO (stdInput)\nimport           System.Posix.Terminal (queryTerminal)\n \nmain :: IO ()\nmain = do\n    isTTY <- queryTerminal stdInput\n    putStrLn $ if isTTY\n                then \"stdin is TTY\"\n                else \"stdin is not TTY\"\n", "target": "from sys import stdin\nif stdin.isatty():\n    print(\"Input comes from tty.\")\nelse:\n    print(\"Input doesn't come from tty.\")\n"}
{"id": 351068, "name": "Bioinformatics_base count", "source": "Translate Haskell to Python: import Data.List       (group, sort)\nimport Data.List.Split (chunksOf)\nimport Text.Printf     (printf, IsChar(..), PrintfArg(..), fmtChar, fmtPrecision, formatString)\n\ndata DNABase = A | C | G | T deriving (Show, Read, Eq, Ord)\ntype DNASequence = [DNABase]\n\ninstance IsChar DNABase where\n  toChar = head . show\n  fromChar = read . pure\n\ninstance PrintfArg DNABase where\n  formatArg x fmt = formatString (show x) (fmt { fmtChar = 's', fmtPrecision = Nothing })\n\ntest :: DNASequence\ntest = read . pure <$> concat\n  [ \"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\"\n  , \"CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\"\n  , \"AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\"\n  , \"GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\"\n  , \"CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\"\n  , \"TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\"\n  , \"TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\"\n  , \"CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\"\n  , \"TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\"\n  , \"GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\" ]\n\nchunkedDNASequence :: DNASequence -> [(Int, [DNABase])]\nchunkedDNASequence = zip [50,100..] . chunksOf 50\n\nbaseCounts :: DNASequence -> [(DNABase, Int)]\nbaseCounts = fmap ((,) . head <*> length) . group . sort\n\nmain :: IO ()\nmain = do\n  putStrLn \"Sequence:\"\n  mapM_ (uncurry (printf \"%3d: %s\\n\")) $ chunkedDNASequence test\n  putStrLn \"\\nBase Counts:\"\n  mapM_ (uncurry (printf \"%2s: %2d\\n\")) $ baseCounts test\n  putStrLn (replicate 8 '-') >> printf \" \u03a3: %d\\n\\n\" (length test)\n", "target": "from collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n    \nif __name__ == '__main__':\n    print(\"SEQUENCE:\")\n    sequence = \n    seq_pp(sequence)\n"}
{"id": 351069, "name": "Bioinformatics_base count", "source": "Translate Haskell to Python: import Data.List       (group, sort)\nimport Data.List.Split (chunksOf)\nimport Text.Printf     (printf, IsChar(..), PrintfArg(..), fmtChar, fmtPrecision, formatString)\n\ndata DNABase = A | C | G | T deriving (Show, Read, Eq, Ord)\ntype DNASequence = [DNABase]\n\ninstance IsChar DNABase where\n  toChar = head . show\n  fromChar = read . pure\n\ninstance PrintfArg DNABase where\n  formatArg x fmt = formatString (show x) (fmt { fmtChar = 's', fmtPrecision = Nothing })\n\ntest :: DNASequence\ntest = read . pure <$> concat\n  [ \"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\"\n  , \"CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\"\n  , \"AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\"\n  , \"GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\"\n  , \"CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\"\n  , \"TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\"\n  , \"TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\"\n  , \"CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\"\n  , \"TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\"\n  , \"GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\" ]\n\nchunkedDNASequence :: DNASequence -> [(Int, [DNABase])]\nchunkedDNASequence = zip [50,100..] . chunksOf 50\n\nbaseCounts :: DNASequence -> [(DNABase, Int)]\nbaseCounts = fmap ((,) . head <*> length) . group . sort\n\nmain :: IO ()\nmain = do\n  putStrLn \"Sequence:\"\n  mapM_ (uncurry (printf \"%3d: %s\\n\")) $ chunkedDNASequence test\n  putStrLn \"\\nBase Counts:\"\n  mapM_ (uncurry (printf \"%2s: %2d\\n\")) $ baseCounts test\n  putStrLn (replicate 8 '-') >> printf \" \u03a3: %d\\n\\n\" (length test)\n", "target": "from collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n    \nif __name__ == '__main__':\n    print(\"SEQUENCE:\")\n    sequence = \n    seq_pp(sequence)\n"}
{"id": 351070, "name": "Wireworld", "source": "Translate Haskell to Python: import Data.List\nimport Control.Monad\nimport Control.Arrow\nimport Data.Maybe\n\nstates=\" Ht.\"\nshiftS=\" t..\"\n\nborden bc xs = bs: (map (\\x -> bc:(x++[bc])) xs) ++ [bs]\n   where r = length $ head xs\n         bs = replicate (r+2) bc\n\ntake3x3 = ap ((.). taken. length) (taken. length. head) `ap` borden '*'\n   where taken n =  transpose. map (take n.map (take 3)).map tails\n\nnwState xs | e =='.' && noH>0 && noH<3 = 'H' \n           | otherwise = shiftS !! (fromJust $ elemIndex e states) \n   where e = xs!!1!!1\n         noH = length $ filter (=='H') $ concat xs\n\nrunCircuit = iterate (map(map nwState).take3x3)\n", "target": "\n\nfrom io import StringIO\nfrom collections import namedtuple\nfrom pprint import pprint as pp\nimport copy\n\nWW = namedtuple('WW', 'world, w, h')\nhead, tail, conductor, empty = allstates = 'Ht. '\n\n\ninfile = StringIO()\n\ndef readfile(f):\n    \n    world  = [row.rstrip('\\r\\n') for row in f]\n    height = len(world)\n    width  = max(len(row) for row in world)\n    \n    nonrow = [ \" %*s \" % (-width, \"\") ]\n    world  = nonrow + \\\n               [ \" %*s \" % (-width, row) for row in world ] + \\\n               nonrow   \n    world = [list(row) for row in world]\n    return WW(world, width, height)\n\ndef newcell(currentworld, x, y):\n    istate = currentworld[y][x]\n    assert istate in allstates, 'Wireworld cell set to unknown value \"%s\"' % istate\n    if istate == head:\n        ostate = tail\n    elif istate == tail:\n        ostate = conductor\n    elif istate == empty:\n        ostate = empty\n    else: \n        n = sum( currentworld[y+dy][x+dx] == head\n                 for dx,dy in ( (-1,-1), (-1,+0), (-1,+1),\n                                (+0,-1),          (+0,+1),\n                                (+1,-1), (+1,+0), (+1,+1) ) )\n        ostate = head if 1 <= n <= 2 else conductor\n    return ostate\n\ndef nextgen(ww):\n    'compute next generation of wireworld'\n    world, width, height = ww\n    newworld = copy.deepcopy(world)\n    for x in range(1, width+1):\n        for y in range(1, height+1):\n            newworld[y][x] = newcell(world, x, y)\n    return WW(newworld, width, height)\n\ndef world2string(ww):\n    return '\\n'.join( ''.join(row[1:-1]).rstrip() for row in ww.world[1:-1] )\n\nww = readfile(infile)\ninfile.close()\n\nfor gen in range(10):\n    print ( (\"\\n%3i \" % gen) + '=' * (ww.w-4) + '\\n' )\n    print ( world2string(ww) )\n    ww = nextgen(ww)\n"}
{"id": 351071, "name": "Ulam spiral (for primes)", "source": "Translate Haskell to Python: import Data.List\nimport Data.Numbers.Primes\n\nulam n representation = swirl n . map representation\n", "target": "\nfrom __future__ import print_function, division\nfrom math import sqrt\n\ndef cell(n, x, y, start=1):\n    d, y, x = 0, y - n//2, x - (n - 1)//2\n    l = 2*max(abs(x), abs(y))\n    d = (l*3 + x + y) if y >= x else (l - x - y)\n    return (l - 1)**2 + d + start - 1\n\ndef show_spiral(n, symbol='\n    top = start + n*n + 1\n    is_prime = [False,False,True] + [True,False]*(top//2)\n    for x in range(3, 1 + int(sqrt(top))):\n        if not is_prime[x]: continue\n        for i in range(x*x, top, x*2):\n            is_prime[i] = False\n\n    cell_str = lambda x: f(x) if is_prime[x] else space\n    f = lambda _: symbol \n\n    if space == None: space = ' '*len(symbol)\n\n    if not len(symbol): \n        max_str = len(str(n*n + start - 1))\n        if space == None: space = '.'*max_str + ' '\n        f = lambda x: ('%' + str(max_str) + 'd ')%x\n\n    for y in range(n):\n        print(''.join(cell_str(v) for v in [cell(n, x, y, start) for x in range(n)]))\n    print()\n\nshow_spiral(10, symbol=u'\u265e', space=u'\u2658') \nshow_spiral(9, symbol='', space=' - ')\n\n\n"}
{"id": 351072, "name": "Fibonacci word", "source": "Translate Haskell to Python: module Main where\n\nimport Control.Monad\nimport Data.List\nimport Data.Monoid\nimport Text.Printf\n\nentropy :: (Ord a) => [a] -> Double\nentropy = sum\n        . map (\\c -> (c *) . logBase 2 $ 1.0 / c)\n        . (\\cs -> let { sc = sum cs } in map (/ sc) cs)\n        . map (fromIntegral . length)\n        . group\n        . sort\n\nfibonacci :: (Monoid m) => m -> m -> [m]\nfibonacci a b = unfoldr (\\(a,b) -> Just (a, (b, a <> b))) (a,b)\n\nmain :: IO ()\nmain = do\n    printf \"%2s %10s %17s %s\\n\" \"N\" \"length\" \"entropy\" \"word\"\n    zipWithM_ (\\i v -> let { l = length v } in printf \"%2d %10d\u00a0%.15f %s\\n\"\n                   i l (entropy v) (if l > 40 then \"...\" else v))\n              [1..38::Int]\n              (take 37 $ fibonacci \"1\" \"0\")\n", "target": ">>> import math\n>>> from collections import Counter\n>>> \n>>> def entropy(s):\n...     p, lns = Counter(s), float(len(s))\n...     return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\n... \n>>> \n>>> def fibword(nmax=37):\n...     fwords = ['1', '0']\n...     print('%-3s %10s %-10s %s' % tuple('N Length Entropy Fibword'.split()))\n...     def pr(n, fwords):\n...         while len(fwords) < n:\n...             fwords += [''.join(fwords[-2:][::-1])]\n...         v = fwords[n-1]\n...         print('%3i %10i %10.7g %s' % (n, len(v), entropy(v), v if len(v) < 20 else '<too long>'))\n...     for n in range(1, nmax+1): pr(n, fwords)\n... \n>>> fibword()\nN       Length Entropy    Fibword\n  1          1         -0 1\n  2          1         -0 0\n  3          2          1 01\n  4          3  0.9182958 010\n  5          5  0.9709506 01001\n  6          8   0.954434 01001010\n  7         13  0.9612366 0100101001001\n  8         21  0.9587119 <too long>\n  9         34  0.9596869 <too long>\n 10         55   0.959316 <too long>\n 11         89  0.9594579 <too long>\n 12        144  0.9594038 <too long>\n 13        233  0.9594244 <too long>\n 14        377  0.9594165 <too long>\n 15        610  0.9594196 <too long>\n 16        987  0.9594184 <too long>\n 17       1597  0.9594188 <too long>\n 18       2584  0.9594187 <too long>\n 19       4181  0.9594187 <too long>\n 20       6765  0.9594187 <too long>\n 21      10946  0.9594187 <too long>\n 22      17711  0.9594187 <too long>\n 23      28657  0.9594187 <too long>\n 24      46368  0.9594187 <too long>\n 25      75025  0.9594187 <too long>\n 26     121393  0.9594187 <too long>\n 27     196418  0.9594187 <too long>\n 28     317811  0.9594187 <too long>\n 29     514229  0.9594187 <too long>\n 30     832040  0.9594187 <too long>\n 31    1346269  0.9594187 <too long>\n 32    2178309  0.9594187 <too long>\n 33    3524578  0.9594187 <too long>\n 34    5702887  0.9594187 <too long>\n 35    9227465  0.9594187 <too long>\n 36   14930352  0.9594187 <too long>\n 37   24157817  0.9594187 <too long>\n>>>\n"}
{"id": 351073, "name": "Fibonacci word", "source": "Translate Haskell to Python: module Main where\n\nimport Control.Monad\nimport Data.List\nimport Data.Monoid\nimport Text.Printf\n\nentropy :: (Ord a) => [a] -> Double\nentropy = sum\n        . map (\\c -> (c *) . logBase 2 $ 1.0 / c)\n        . (\\cs -> let { sc = sum cs } in map (/ sc) cs)\n        . map (fromIntegral . length)\n        . group\n        . sort\n\nfibonacci :: (Monoid m) => m -> m -> [m]\nfibonacci a b = unfoldr (\\(a,b) -> Just (a, (b, a <> b))) (a,b)\n\nmain :: IO ()\nmain = do\n    printf \"%2s %10s %17s %s\\n\" \"N\" \"length\" \"entropy\" \"word\"\n    zipWithM_ (\\i v -> let { l = length v } in printf \"%2d %10d\u00a0%.15f %s\\n\"\n                   i l (entropy v) (if l > 40 then \"...\" else v))\n              [1..38::Int]\n              (take 37 $ fibonacci \"1\" \"0\")\n", "target": ">>> import math\n>>> from collections import Counter\n>>> \n>>> def entropy(s):\n...     p, lns = Counter(s), float(len(s))\n...     return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\n... \n>>> \n>>> def fibword(nmax=37):\n...     fwords = ['1', '0']\n...     print('%-3s %10s %-10s %s' % tuple('N Length Entropy Fibword'.split()))\n...     def pr(n, fwords):\n...         while len(fwords) < n:\n...             fwords += [''.join(fwords[-2:][::-1])]\n...         v = fwords[n-1]\n...         print('%3i %10i %10.7g %s' % (n, len(v), entropy(v), v if len(v) < 20 else '<too long>'))\n...     for n in range(1, nmax+1): pr(n, fwords)\n... \n>>> fibword()\nN       Length Entropy    Fibword\n  1          1         -0 1\n  2          1         -0 0\n  3          2          1 01\n  4          3  0.9182958 010\n  5          5  0.9709506 01001\n  6          8   0.954434 01001010\n  7         13  0.9612366 0100101001001\n  8         21  0.9587119 <too long>\n  9         34  0.9596869 <too long>\n 10         55   0.959316 <too long>\n 11         89  0.9594579 <too long>\n 12        144  0.9594038 <too long>\n 13        233  0.9594244 <too long>\n 14        377  0.9594165 <too long>\n 15        610  0.9594196 <too long>\n 16        987  0.9594184 <too long>\n 17       1597  0.9594188 <too long>\n 18       2584  0.9594187 <too long>\n 19       4181  0.9594187 <too long>\n 20       6765  0.9594187 <too long>\n 21      10946  0.9594187 <too long>\n 22      17711  0.9594187 <too long>\n 23      28657  0.9594187 <too long>\n 24      46368  0.9594187 <too long>\n 25      75025  0.9594187 <too long>\n 26     121393  0.9594187 <too long>\n 27     196418  0.9594187 <too long>\n 28     317811  0.9594187 <too long>\n 29     514229  0.9594187 <too long>\n 30     832040  0.9594187 <too long>\n 31    1346269  0.9594187 <too long>\n 32    2178309  0.9594187 <too long>\n 33    3524578  0.9594187 <too long>\n 34    5702887  0.9594187 <too long>\n 35    9227465  0.9594187 <too long>\n 36   14930352  0.9594187 <too long>\n 37   24157817  0.9594187 <too long>\n>>>\n"}
{"id": 351074, "name": "Text processing_1", "source": "Translate Haskell to Python: import Data.List\nimport Numeric\nimport Control.Arrow\nimport Control.Monad\nimport Text.Printf\nimport System.Environment\nimport Data.Function\n\ntype Date = String\ntype Value = Double\ntype Flag = Bool\n\nreadFlg :: String -> Flag\nreadFlg = (> 0).read\n\nreadNum :: String -> Value\nreadNum = fst.head.readFloat\n\ntake2 = takeWhile(not.null).unfoldr (Just.splitAt 2)\n\nparseData :: [String] -> (Date,[(Value,Flag)])\nparseData = head &&& map(readNum.head &&& readFlg.last).take2.tail\n\nsumAccs :: (Date,[(Value,Flag)]) -> (Date, ((Value,Int),[Flag]))\nsumAccs = second (((sum &&& length).concat.uncurry(zipWith(\\v f -> [v|f])) &&& snd).unzip)\n\nmaxNAseq :: [Flag] -> [(Int,Int)]\nmaxNAseq = head.groupBy((==) `on` fst).sortBy(flip compare)\n           . concat.uncurry(zipWith(\\i (r,b)->[(r,i)|not b]))\n           . first(init.scanl(+)0). unzip\n           . map ((fst &&& id).(length &&& head)). group\n\nmain = do\n    file:_ <- getArgs\n    f <- readFile file\n    let dat :: [(Date,((Value,Int),[Flag]))]\n        dat      = map (sumAccs. parseData. words).lines $ f\n        summ     = ((sum *** sum). unzip *** maxNAseq.concat). unzip $ map snd dat\n        totalFmt = \"\\nSummary\\t\\t accept: %d\\t total:\u00a0%.3f \\taverage: %6.3f\\n\\n\"\n        lineFmt  = \"%8s\\t accept: %2d\\t total: %11.3f \\taverage: %6.3f\\n\"\n        maxFmt   =  \"Maximum of %d consecutive false readings, starting on line /%s/ and ending on line /%s/\\n\"\n\n    putStrLn \"\\nSome lines:\\n\"\n    mapM_ (\\(d,((v,n),_)) -> printf lineFmt d n v (v/fromIntegral n)) $ take 4 $ drop 2200 dat \n    (\\(t,n) -> printf totalFmt  n t (t/fromIntegral n)) $ fst summ\n    mapM_ ((\\(l, d1,d2) -> printf maxFmt l d1 d2)\n              . (\\(a,b)-> (a,(fst.(dat!!).(`div`24))b,(fst.(dat!!).(`div`24))(a+b)))) $ snd summ\n", "target": "import fileinput\nimport sys\n\nnodata = 0;             \nnodata_max=-1;          \nnodata_maxline=[];      \n\ntot_file = 0            \nnum_file = 0            \n\ninfiles = sys.argv[1:]\n\nfor line in fileinput.input():\n  tot_line=0;             \n  num_line=0;             \n\n  \n  field = line.split()\n  date  = field[0]\n  data  = [float(f) for f in field[1::2]]\n  flags = [int(f)   for f in field[2::2]]\n\n  for datum, flag in zip(data, flags):\n    if flag<1:\n      nodata += 1\n    else:\n      \n      if nodata_max==nodata and nodata>0:\n        nodata_maxline.append(date)\n      if nodata_max<nodata and nodata>0:\n        nodata_max=nodata\n        nodata_maxline=[date]\n      \n      nodata=0; \n      \n      tot_line += datum\n      num_line += 1\n\n  \n  tot_file += tot_line\n  num_file += num_line\n\n  print \"Line: %11s  Reject: %2i  Accept: %2i  Line_tot: %10.3f  Line_avg: %10.3f\" % (\n        date, \n        len(data) -num_line, \n        num_line, tot_line, \n        tot_line/num_line if (num_line>0) else 0)\n\nprint \"\"\nprint \"File(s)  = %s\" % (\", \".join(infiles),)\nprint \"Total    = %10.3f\" % (tot_file,)\nprint \"Readings = %6i\" % (num_file,)\nprint \"Average  = %10.3f\" % (tot_file / num_file,)\n\nprint \"\\nMaximum run(s) of %i consecutive false readings ends at line starting with date(s): %s\" % (\n    nodata_max, \", \".join(nodata_maxline))\n"}
{"id": 351075, "name": "Death Star", "source": "Translate Haskell to Python: import Data.List (genericLength)\n\nshades = \".:!*oe%#&@\"\nn = genericLength shades\ndot a b = sum $ zipWith (*) a b\nnormalize x = (/ sqrt (x `dot` x)) <$> x\n\ndeathStar r k amb = unlines $\n  [ [ if x*x + y*y <= r*r\n      then let vec = normalize $ normal x y\n               b = (light `dot` vec) ** k + amb\n               intensity = (1 - b)*(n - 1)\n           in shades !! round ((0 `max` intensity) `min` n)\n      else ' '\n    | y <- map (/2.12) [- 2*r - 0.5 .. 2*r + 0.5]  ]\n  | x <- [ - r - 0.5 .. r + 0.5] ]\n  where\n    light = normalize [-30,-30,-50]\n    normal x y\n      | (x+r)**2 + (y+r)**2 <= r**2 = [x+r, y+r, sph2 x y]\n      | otherwise = [x, y, sph1 x y]\n    sph1 x y = sqrt (r*r - x*x - y*y)\n    sph2 x y = r - sqrt (r*r - (x+r)**2 - (y+r)**2)\n", "target": "import sys, math, collections\n\nSphere = collections.namedtuple(\"Sphere\", \"cx cy cz r\")\nV3 = collections.namedtuple(\"V3\", \"x y z\")\n\ndef normalize((x, y, z)):\n    len = math.sqrt(x**2 + y**2 + z**2)\n    return V3(x / len, y / len, z / len)\n\ndef dot(v1, v2):\n    d = v1.x*v2.x + v1.y*v2.y + v1.z*v2.z\n    return -d if d < 0 else 0.0\n\ndef hit_sphere(sph, x0, y0):\n    x = x0 - sph.cx\n    y = y0 - sph.cy\n    zsq = sph.r ** 2 - (x ** 2 + y ** 2)\n    if zsq < 0:\n        return (False, 0, 0)\n    szsq = math.sqrt(zsq)\n    return (True, sph.cz - szsq, sph.cz + szsq)\n\ndef draw_sphere(k, ambient, light):\n    shades = \".:!*oe&\n    pos = Sphere(20.0, 20.0, 0.0, 20.0)\n    neg = Sphere(1.0, 1.0, -6.0, 20.0)\n\n    for i in xrange(int(math.floor(pos.cy - pos.r)),\n                    int(math.ceil(pos.cy + pos.r) + 1)):\n        y = i + 0.5\n        for j in xrange(int(math.floor(pos.cx - 2 * pos.r)),\n                        int(math.ceil(pos.cx + 2 * pos.r) + 1)):\n            x = (j - pos.cx) / 2.0 + 0.5 + pos.cx\n\n            (h, zb1, zb2) = hit_sphere(pos, x, y)\n            if not h:\n                hit_result = 0\n            else:\n                (h, zs1, zs2) = hit_sphere(neg, x, y)\n                if not h:\n                    hit_result = 1\n                elif zs1 > zb1:\n                    hit_result = 1\n                elif zs2 > zb2:\n                    hit_result = 0\n                elif zs2 > zb1:\n                    hit_result = 2\n                else:\n                    hit_result = 1\n\n            if hit_result == 0:\n                sys.stdout.write(' ')\n                continue\n            elif hit_result == 1:\n                vec = V3(x - pos.cx, y - pos.cy, zb1 - pos.cz)\n            elif hit_result == 2:\n                vec = V3(neg.cx-x, neg.cy-y, neg.cz-zs2)\n            vec = normalize(vec)\n\n            b = dot(light, vec) ** k + ambient\n            intensity = int((1 - b) * len(shades))\n            intensity = min(len(shades), max(0, intensity))\n            sys.stdout.write(shades[intensity])\n        print\n\nlight = normalize(V3(-50, 30, 50))\ndraw_sphere(2, 0.5, light)\n"}
{"id": 351076, "name": "Draw a sphere", "source": "Translate Haskell to Python: import Graphics.Rendering.OpenGL.GL\nimport Graphics.UI.GLUT.Objects\nimport Graphics.UI.GLUT\n\nsetProjection :: IO ()\nsetProjection = do\n  matrixMode $= Projection\n  ortho (-1) 1 (-1) 1 0 (-1)\n         \ngrey1,grey9,red,white :: Color4 GLfloat\ngrey1 = Color4 0.1 0.1 0.1 1\ngrey9 = Color4 0.9 0.9 0.9 1\nred   = Color4 1   0   0   1\nwhite = Color4 1   1   1   1\n\nsetLights :: IO ()\nsetLights = do\n  let l = Light 0\n  ambient  l $= grey1\n  diffuse  l $= white\n  specular l $= white\n  position l $= Vertex4 (-4) 4 3 (0 :: GLfloat)\n  light    l $= Enabled\n  lighting   $= Enabled\n\nsetMaterial :: IO ()\nsetMaterial = do\n  materialAmbient   Front $= grey1\n  materialDiffuse   Front $= red\n  materialSpecular  Front $= grey9\n  materialShininess Front $= (32 :: GLfloat)\n\ndisplay :: IO()\ndisplay = do\n  clear [ColorBuffer]\n  renderObject Solid $ Sphere' 0.8 64 64\n  swapBuffers\n\nmain :: IO()\nmain = do\n  _ <- getArgsAndInitialize\n  _ <- createWindow \"Sphere\"\n  clearColor $= Color4 0.0 0.0 0.0 0.0\n  setProjection\n  setLights\n  setMaterial\n  displayCallback $= display\n  mainLoop\n", "target": "import math\n\nshades = ('.',':','!','*','o','e','&','\n\ndef normalize(v):\n\tlen = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n\treturn (v[0]/len, v[1]/len, v[2]/len)\n\ndef dot(x,y):\n\td = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]\n\treturn -d if d < 0 else 0\n\ndef draw_sphere(r, k, ambient, light):\n\tfor i in range(int(math.floor(-r)),int(math.ceil(r)+1)):\n\t\tx = i + 0.5\n\t\tline = ''\n\n\t\tfor j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):\n\t\t\ty = j/2 + 0.5\n\t\t\tif x*x + y*y <= r*r:\n\t\t\t\tvec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))\n\t\t\t\tb = dot(light,vec)**k + ambient\n\t\t\t\tintensity = int((1-b)*(len(shades)-1))\n\t\t\t\tline += shades[intensity] if 0 <= intensity < len(shades) else shades[0]\n\t\t\telse:\n\t\t\t\tline += ' '\n\n\t\tprint(line)\n\nlight = normalize((30,30,-50))\ndraw_sphere(20,4,0.1, light)\ndraw_sphere(10,2,0.4, light)\n"}
{"id": 351077, "name": "Draw a sphere", "source": "Translate Haskell to Python: import Graphics.Rendering.OpenGL.GL\nimport Graphics.UI.GLUT.Objects\nimport Graphics.UI.GLUT\n\nsetProjection :: IO ()\nsetProjection = do\n  matrixMode $= Projection\n  ortho (-1) 1 (-1) 1 0 (-1)\n         \ngrey1,grey9,red,white :: Color4 GLfloat\ngrey1 = Color4 0.1 0.1 0.1 1\ngrey9 = Color4 0.9 0.9 0.9 1\nred   = Color4 1   0   0   1\nwhite = Color4 1   1   1   1\n\nsetLights :: IO ()\nsetLights = do\n  let l = Light 0\n  ambient  l $= grey1\n  diffuse  l $= white\n  specular l $= white\n  position l $= Vertex4 (-4) 4 3 (0 :: GLfloat)\n  light    l $= Enabled\n  lighting   $= Enabled\n\nsetMaterial :: IO ()\nsetMaterial = do\n  materialAmbient   Front $= grey1\n  materialDiffuse   Front $= red\n  materialSpecular  Front $= grey9\n  materialShininess Front $= (32 :: GLfloat)\n\ndisplay :: IO()\ndisplay = do\n  clear [ColorBuffer]\n  renderObject Solid $ Sphere' 0.8 64 64\n  swapBuffers\n\nmain :: IO()\nmain = do\n  _ <- getArgsAndInitialize\n  _ <- createWindow \"Sphere\"\n  clearColor $= Color4 0.0 0.0 0.0 0.0\n  setProjection\n  setLights\n  setMaterial\n  displayCallback $= display\n  mainLoop\n", "target": "import math\n\nshades = ('.',':','!','*','o','e','&','\n\ndef normalize(v):\n\tlen = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n\treturn (v[0]/len, v[1]/len, v[2]/len)\n\ndef dot(x,y):\n\td = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]\n\treturn -d if d < 0 else 0\n\ndef draw_sphere(r, k, ambient, light):\n\tfor i in range(int(math.floor(-r)),int(math.ceil(r)+1)):\n\t\tx = i + 0.5\n\t\tline = ''\n\n\t\tfor j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):\n\t\t\ty = j/2 + 0.5\n\t\t\tif x*x + y*y <= r*r:\n\t\t\t\tvec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))\n\t\t\t\tb = dot(light,vec)**k + ambient\n\t\t\t\tintensity = int((1-b)*(len(shades)-1))\n\t\t\t\tline += shades[intensity] if 0 <= intensity < len(shades) else shades[0]\n\t\t\telse:\n\t\t\t\tline += ' '\n\n\t\tprint(line)\n\nlight = normalize((30,30,-50))\ndraw_sphere(20,4,0.1, light)\ndraw_sphere(10,2,0.4, light)\n"}
{"id": 351078, "name": "Thiele's interpolation formula", "source": "Translate Haskell to Python: thiele :: [Double] -> [Double] -> Double -> Double\nthiele xs ys = f rho1 (tail xs)\n  where\n    f _ [] _ = 1\n    f r@(r0:r1:r2:rs) (x:xs) v = r2 - r0 + (v - x) / f (tail r) xs v\n    rho1 = (!! 1) . (++ [0]) <$> rho\n    rho = repeat 0 : repeat 0 : ys : rnext (tail rho) xs (tail xs)\n      where\n        rnext _ _ [] = []\n        rnext r@(r0:r1:rs) x xn =\n          let z_ = zipWith\n          in z_ (+) (tail r0) (z_ (/) (z_ (-) x xn) (z_ (-) r1 (tail r1))) :\n             rnext (tail r) x (tail xn)\n\n\ninvInterp :: (Double -> Double) -> [Double] -> Double -> Double\ninvInterp f xs = thiele (map f xs) xs\n\nmain :: IO ()\nmain =\n  mapM_\n    print\n    [ 3.21 * inv_sin (sin (pi / 3.21))\n    , pi / 1.2345 * inv_cos (cos 1.2345)\n    , 7 * inv_tan (tan (pi / 7))\n    ]\n  where\n    [inv_sin, inv_cos, inv_tan] =\n      uncurry ((. div_pi) . invInterp) <$>\n      [(sin, (2, 31)), (cos, (2, 100)), (tan, (4, 1000))]\n    \n    div_pi (d, n) = (* (pi / (d * n))) <$> [0 .. n]\n", "target": "\n\nimport math\n\ndef thieleInterpolator(x, y):\n    \u03c1 = [[yi]*(len(y)-i) for i, yi in enumerate(y)]\n    for i in range(len(\u03c1)-1):\n        \u03c1[i][1] = (x[i] - x[i+1]) / (\u03c1[i][0] - \u03c1[i+1][0])\n    for i in range(2, len(\u03c1)):\n        for j in range(len(\u03c1)-i):\n            \u03c1[j][i] = (x[j]-x[j+i]) / (\u03c1[j][i-1]-\u03c1[j+1][i-1]) + \u03c1[j+1][i-2]\n    \u03c10 = \u03c1[0]\n    def t(xin):\n        a = 0\n        for i in range(len(\u03c10)-1, 1, -1):\n            a = (xin - x[i-1]) / (\u03c10[i] - \u03c10[i-2] + a)\n        return y[0] + (xin-x[0]) / (\u03c10[1]+a)\n    return t\n\n\nxVal = [i*.05 for i in range(32)]\ntSin = [math.sin(x) for x in xVal]\ntCos = [math.cos(x) for x in xVal]\ntTan = [math.tan(x) for x in xVal]\n\niSin = thieleInterpolator(tSin, xVal)\niCos = thieleInterpolator(tCos, xVal)\niTan = thieleInterpolator(tTan, xVal)\n\nprint('{:16.14f}'.format(6*iSin(.5)))\nprint('{:16.14f}'.format(3*iCos(.5)))\nprint('{:16.14f}'.format(4*iTan(1)))\n"}
{"id": 351079, "name": "Longest string challenge", "source": "Translate Haskell to Python: module Main where\n\nimport           System.Environment\n\ncmp :: String -> String -> Ordering\ncmp [] []         = EQ\ncmp [] (_:_)      = LT\ncmp (_:_) []      = GT\ncmp (_:xs) (_:ys) = cmp xs ys\n\nlongest :: String -> String\nlongest = longest' \"\" \"\" . lines\n  where\n    longest' acc l []         = acc\n    longest' [] l (x:xs)      = longest' x x xs\n    longest' acc l (x:xs) = case cmp l x of\n                                   LT -> longest' x x xs\n                                   EQ -> longest' (acc ++ '\\n':x) l xs\n                                   GT -> longest' acc l xs\n\nmain :: IO ()\nmain = do\n  (file:_) <- getArgs\n  contents <- readFile file\n  putStrLn $ longest contents\n", "target": "import fileinput\n\n\n\n\n\n\ndef longer(a, b):\n    try:\n        b[len(a)-1]\n        return False\n    except:\n        return True\n\nlongest, lines = '', ''\nfor x in fileinput.input():\n    if longer(x, longest):\n        lines, longest = x, x\n    elif not longer(longest, x):\n        lines += x\n\nprint(lines, end='')\n"}
{"id": 351080, "name": "Hello world_Line printer", "source": "Translate Haskell to Python: import System.Process (ProcessHandle, runCommand)\n\nmain :: IO ProcessHandle\nmain = runCommand \"echo \\\"Hello World!\\\" | lpr\"\n", "target": "lp = open(\"/dev/lp0\")\nlp.write(\"Hello World!\\n\")\nlp.close()\n"}
{"id": 351081, "name": "Hello world_Line printer", "source": "Translate Haskell to Python: import System.Process (ProcessHandle, runCommand)\n\nmain :: IO ProcessHandle\nmain = runCommand \"echo \\\"Hello World!\\\" | lpr\"\n", "target": "lp = open(\"/dev/lp0\")\nlp.write(\"Hello World!\\n\")\nlp.close()\n"}
{"id": 351082, "name": "Magic squares of odd order", "source": "Translate Haskell to Python: \nimport Data.List\n\ntype Var = (Int, Int, Int, Int) \n\nmagicSum :: Int -> Int\nmagicSum x = ((x * x + 1) `div` 2) * x\n\nwrapInc :: Int -> Int -> Int\nwrapInc max x\n   | x + 1 == max    = 0\n   | otherwise       = x + 1\n\nwrapDec :: Int -> Int -> Int\nwrapDec max x\n   | x == 0    = max - 1\n   | otherwise = x - 1\n\nisZero :: [[Int]] -> Int -> Int -> Bool\nisZero m x y = m !! x !! y == 0\n\nsetAt :: (Int,Int) -> Int -> [[Int]] -> [[Int]]\nsetAt (x, y) val table\n   | (upper, current : lower) <- splitAt x table,\n     (left, this : right) <- splitAt y current\n         = upper ++ (left ++ val : right) : lower\n   | otherwise = error \"Outside\"\n\ncreate :: Int -> [[Int]]\ncreate x = replicate x $ replicate x 0\n\ncells :: [[Int]] -> Int\ncells m = x*x where x = length m\n   \nfill :: Var -> [[Int]] -> [[Int]]\nfill (sx, sy, sz, c) m\n   | c < cells m =\n      if isZero m sx sy \n      then fill ((wrapInc sz sx), (wrapDec sz sy), sz, c + 1) (setAt (sx, sy) (c + 1) m)\n      else fill ((wrapDec sz sx), (wrapInc sz(wrapInc sz sy)), sz, c) m\n   | otherwise = m\n\nmagicNumber :: Int -> [[Int]]\nmagicNumber d = transpose $ fill (d `div` 2, 0, d, 0) (create d)\n\ndisplay :: [[Int]] -> String\ndisplay (x:xs)\n   | null xs = vdisplay x\n   | otherwise = vdisplay x ++ ('\\n' : display xs)\n\nvdisplay :: [Int] -> String\nvdisplay (x:xs)\n   | null xs = show x\n   | otherwise = show x ++ \" \" ++ vdisplay xs\n\n\nmagicSquare x = do\n   putStr \"Magic Square of \"\n   putStr $ show x\n   putStr \" = \"\n   putStrLn $ show $ magicSum x\n   putStrLn $ display $ magicNumber x\n", "target": ">>> def magic(n):\n    for row in range(1, n + 1):\n        print(' '.join('%*i' % (len(str(n**2)), cell) for cell in\n                       (n * ((row + col - 1 + n // 2) % n) +\n                       ((row + 2 * col - 2) % n) + 1\n                       for col in range(1, n + 1))))\n    print('\\nAll sum to magic number %i' % ((n * n + 1) * n // 2))\n\n    \n>>> for n in (5, 3, 7):\n\tprint('\\nOrder %i\\n=======' % n)\n\tmagic(n)\n\n\t\n\nOrder 5\n=======\n17 24  1  8 15\n23  5  7 14 16\n 4  6 13 20 22\n10 12 19 21  3\n11 18 25  2  9\n\nAll sum to magic number 65\n\nOrder 3\n=======\n8 1 6\n3 5 7\n4 9 2\n\nAll sum to magic number 15\n\nOrder 7\n=======\n30 39 48  1 10 19 28\n38 47  7  9 18 27 29\n46  6  8 17 26 35 37\n 5 14 16 25 34 36 45\n13 15 24 33 42 44  4\n21 23 32 41 43  3 12\n22 31 40 49  2 11 20\n\nAll sum to magic number 175\n>>>\n"}
{"id": 351083, "name": "Magic squares of odd order", "source": "Translate Haskell to Python: \nimport Data.List\n\ntype Var = (Int, Int, Int, Int) \n\nmagicSum :: Int -> Int\nmagicSum x = ((x * x + 1) `div` 2) * x\n\nwrapInc :: Int -> Int -> Int\nwrapInc max x\n   | x + 1 == max    = 0\n   | otherwise       = x + 1\n\nwrapDec :: Int -> Int -> Int\nwrapDec max x\n   | x == 0    = max - 1\n   | otherwise = x - 1\n\nisZero :: [[Int]] -> Int -> Int -> Bool\nisZero m x y = m !! x !! y == 0\n\nsetAt :: (Int,Int) -> Int -> [[Int]] -> [[Int]]\nsetAt (x, y) val table\n   | (upper, current : lower) <- splitAt x table,\n     (left, this : right) <- splitAt y current\n         = upper ++ (left ++ val : right) : lower\n   | otherwise = error \"Outside\"\n\ncreate :: Int -> [[Int]]\ncreate x = replicate x $ replicate x 0\n\ncells :: [[Int]] -> Int\ncells m = x*x where x = length m\n   \nfill :: Var -> [[Int]] -> [[Int]]\nfill (sx, sy, sz, c) m\n   | c < cells m =\n      if isZero m sx sy \n      then fill ((wrapInc sz sx), (wrapDec sz sy), sz, c + 1) (setAt (sx, sy) (c + 1) m)\n      else fill ((wrapDec sz sx), (wrapInc sz(wrapInc sz sy)), sz, c) m\n   | otherwise = m\n\nmagicNumber :: Int -> [[Int]]\nmagicNumber d = transpose $ fill (d `div` 2, 0, d, 0) (create d)\n\ndisplay :: [[Int]] -> String\ndisplay (x:xs)\n   | null xs = vdisplay x\n   | otherwise = vdisplay x ++ ('\\n' : display xs)\n\nvdisplay :: [Int] -> String\nvdisplay (x:xs)\n   | null xs = show x\n   | otherwise = show x ++ \" \" ++ vdisplay xs\n\n\nmagicSquare x = do\n   putStr \"Magic Square of \"\n   putStr $ show x\n   putStr \" = \"\n   putStrLn $ show $ magicSum x\n   putStrLn $ display $ magicNumber x\n", "target": ">>> def magic(n):\n    for row in range(1, n + 1):\n        print(' '.join('%*i' % (len(str(n**2)), cell) for cell in\n                       (n * ((row + col - 1 + n // 2) % n) +\n                       ((row + 2 * col - 2) % n) + 1\n                       for col in range(1, n + 1))))\n    print('\\nAll sum to magic number %i' % ((n * n + 1) * n // 2))\n\n    \n>>> for n in (5, 3, 7):\n\tprint('\\nOrder %i\\n=======' % n)\n\tmagic(n)\n\n\t\n\nOrder 5\n=======\n17 24  1  8 15\n23  5  7 14 16\n 4  6 13 20 22\n10 12 19 21  3\n11 18 25  2  9\n\nAll sum to magic number 65\n\nOrder 3\n=======\n8 1 6\n3 5 7\n4 9 2\n\nAll sum to magic number 15\n\nOrder 7\n=======\n30 39 48  1 10 19 28\n38 47  7  9 18 27 29\n46  6  8 17 26 35 37\n 5 14 16 25 34 36 45\n13 15 24 33 42 44  4\n21 23 32 41 43  3 12\n22 31 40 49  2 11 20\n\nAll sum to magic number 175\n>>>\n"}
{"id": 351084, "name": "Sutherland-Hodgman polygon clipping", "source": "Translate Haskell to Python: module SuthHodgClip (clipTo) where\n\nimport Data.List\n\ntype   Pt a = (a, a)\ntype   Ln a = (Pt a, Pt a)\ntype Poly a = [Pt a]\n\n\npolyFrom ps = last ps : ps\n\n\nlinesFrom pps@(_:ps) = zip pps ps\n\n\n\n(.|) :: (Num a, Ord a) => Pt a -> Ln a -> Bool\n(x,y) .| ((px,py),(qx,qy)) = (qx-px)*(y-py) >= (qy-py)*(x-px)\n\n\n(><) :: Fractional a => Ln a -> Ln a -> Pt a\n((x1,y1),(x2,y2)) >< ((x3,y3),(x4,y4)) =\n    let (r,s) = (x1*y2-y1*x2, x3*y4-y3*x4)\n        (t,u,v,w) = (x1-x2, y3-y4, y1-y2, x3-x4)\n        d = t*u-v*w \n    in ((r*w-t*s)/d, (r*u-v*s)/d)\n\n\n\n\n\n(-|) :: (Fractional a, Ord a) => Ln a -> Ln a -> [Pt a]\nln@(p0, p1) -| clipLn =\n    case (p0 .| clipLn, p1 .| clipLn) of\n      (False, False) -> []\n      (False, True)  -> [isect, p1]\n      (True,  False) -> [isect]\n      (True,  True)  -> [p1]\n    where isect = ln >< clipLn\n\n\n(<|) :: (Fractional a, Ord a) => Poly a -> Ln a -> Poly a\npoly <| clipLn = polyFrom $ concatMap (-| clipLn) (linesFrom poly)\n\n\n\nclipTo :: (Fractional a, Ord a) => [Pt a] -> [Pt a] -> [Pt a]\ntargPts `clipTo` clipPts = \n    let targPoly = polyFrom targPts\n        clipLines = linesFrom (polyFrom clipPts)\n    in foldl' (<|) targPoly clipLines\n", "target": "def clip(subjectPolygon, clipPolygon):\n   def inside(p):\n      return(cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0])\n      \n   def computeIntersection():\n      dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ]\n      dp = [ s[0] - e[0], s[1] - e[1] ]\n      n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]\n      n2 = s[0] * e[1] - s[1] * e[0] \n      n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])\n      return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3]\n\n   outputList = subjectPolygon\n   cp1 = clipPolygon[-1]\n   \n   for clipVertex in clipPolygon:\n      cp2 = clipVertex\n      inputList = outputList\n      outputList = []\n      s = inputList[-1]\n\n      for subjectVertex in inputList:\n         e = subjectVertex\n         if inside(e):\n            if not inside(s):\n               outputList.append(computeIntersection())\n            outputList.append(e)\n         elif inside(s):\n            outputList.append(computeIntersection())\n         s = e\n      cp1 = cp2\n   return(outputList)\n"}
{"id": 351085, "name": "Sorting algorithms_Pancake sort", "source": "Translate Haskell to Python: import Data.List\nimport Control.Arrow\nimport Control.Monad\nimport Data.Maybe\n\ndblflipIt :: (Ord a) => [a] -> [a]\ndblflipIt = uncurry ((reverse.).(++)). first reverse\n  . ap (flip splitAt) (succ. fromJust. (elemIndex =<< maximum))\n \ndopancakeSort :: (Ord a) => [a] -> [a]\ndopancakeSort xs = dopcs (xs,[]) where\n  dopcs ([],rs) = rs\n  dopcs ([x],rs) = x:rs\n  dopcs (xs,rs) = dopcs $ (init &&& (:rs).last ) $ dblflipIt xs\n", "target": "tutor = False\n\ndef pancakesort(data):\n    if len(data) <= 1:\n        return data\n    if tutor: print()\n    for size in range(len(data), 1, -1):\n        maxindex = max(range(size), key=data.__getitem__)\n        if maxindex+1 != size:\n            \n            if maxindex != 0:\n                \n                if tutor: print('With: %r doflip  %i'\n                                % ( ' '.join(str(x) for x in data), maxindex+1 ))\n                data[:maxindex+1] = reversed(data[:maxindex+1])\n            \n            if tutor: print('With: %r  doflip %i'\n                                % ( ' '.join(str(x) for x in data), size ))\n            data[:size] = reversed(data[:size])\n    if tutor: print()\n"}
{"id": 351086, "name": "Call a function", "source": "Translate Haskell to Python: \nmultiply x y = x * y\nmultiply 10 20 \n\n\n\ntwopi = 6.28\n\ntwopi () = 6.28 \ntwopi :: Num a => () -> a \ntwopi () \n\n\nmultiply_by_10 = (10 * )\nmap multiply_by_10 [1, 2, 3] \nmultiply_all_by_10 = map multiply_by_10\nmultiply_all_by_10 [1, 2, 3] \n\n\n\n\n\n\n\n\n\n\n\n", "target": "def no_args():\n    pass\n\nno_args()\n\ndef fixed_args(x, y):\n    print('x=%r, y=%r' % (x, y))\n\nfixed_args(1, 2)        \n\n\nfixed_args(y=2, x=1)\n\n\nmyargs=(1,2) \nfixed_args(*myargs)\n\ndef opt_args(x=1):\n    print(x)\n\nopt_args()              \nopt_args(3.141)         \n\ndef var_args(*v):\n    print(v)\n\nvar_args(1, 2, 3)       \nvar_args(1, (2,3))      \nvar_args()              \n\n\nfixed_args(y=2, x=1)    \n\n\nif 1:\n    no_args()\n\n\nassert no_args() is None\n\ndef return_something():\n    return 1\nx = return_something()\n\ndef is_builtin(x):\n\tprint(x.__name__ in dir(__builtins__))\n\nis_builtin(pow)         \nis_builtin(is_builtin)  \n\n\n\ndef takes_anything(*args, **kwargs):\n    for each in args:\n        print(each)\n    for key, value in sorted(kwargs.items()):\n        print(\"%s:%s\" % (key, value))\n    \n    wrapped_fn(*args, **kwargs)\n    \n    \n\n\n\n\n\n\n\n\n\n"}
{"id": 351087, "name": "Call a function", "source": "Translate Haskell to Python: \nmultiply x y = x * y\nmultiply 10 20 \n\n\n\ntwopi = 6.28\n\ntwopi () = 6.28 \ntwopi :: Num a => () -> a \ntwopi () \n\n\nmultiply_by_10 = (10 * )\nmap multiply_by_10 [1, 2, 3] \nmultiply_all_by_10 = map multiply_by_10\nmultiply_all_by_10 [1, 2, 3] \n\n\n\n\n\n\n\n\n\n\n\n", "target": "def no_args():\n    pass\n\nno_args()\n\ndef fixed_args(x, y):\n    print('x=%r, y=%r' % (x, y))\n\nfixed_args(1, 2)        \n\n\nfixed_args(y=2, x=1)\n\n\nmyargs=(1,2) \nfixed_args(*myargs)\n\ndef opt_args(x=1):\n    print(x)\n\nopt_args()              \nopt_args(3.141)         \n\ndef var_args(*v):\n    print(v)\n\nvar_args(1, 2, 3)       \nvar_args(1, (2,3))      \nvar_args()              \n\n\nfixed_args(y=2, x=1)    \n\n\nif 1:\n    no_args()\n\n\nassert no_args() is None\n\ndef return_something():\n    return 1\nx = return_something()\n\ndef is_builtin(x):\n\tprint(x.__name__ in dir(__builtins__))\n\nis_builtin(pow)         \nis_builtin(is_builtin)  \n\n\n\ndef takes_anything(*args, **kwargs):\n    for each in args:\n        print(each)\n    for key, value in sorted(kwargs.items()):\n        print(\"%s:%s\" % (key, value))\n    \n    wrapped_fn(*args, **kwargs)\n    \n    \n\n\n\n\n\n\n\n\n\n"}
{"id": 351088, "name": "Extract file extension", "source": "Translate Haskell to Python: module FileExtension\n   where\n\nmyextension :: String -> String\nmyextension s\n   |not $ elem '.' s = \"\"\n   |elem '/' extension || elem '_' extension = \"\"\n   |otherwise = '.' : extension\n      where\n\t extension = reverse ( takeWhile ( /= '.' ) $ reverse s )\n", "target": "import re\ndef extractExt(url):\n  m = re.search(r'\\.[A-Za-z0-9]+$', url)\n  return m.group(0) if m else \"\"\n"}
{"id": 351089, "name": "Extract file extension", "source": "Translate Haskell to Python: module FileExtension\n   where\n\nmyextension :: String -> String\nmyextension s\n   |not $ elem '.' s = \"\"\n   |elem '/' extension || elem '_' extension = \"\"\n   |otherwise = '.' : extension\n      where\n\t extension = reverse ( takeWhile ( /= '.' ) $ reverse s )\n", "target": "import re\ndef extractExt(url):\n  m = re.search(r'\\.[A-Za-z0-9]+$', url)\n  return m.group(0) if m else \"\"\n"}
{"id": 351090, "name": "Solve the no connection puzzle", "source": "Translate Haskell to Python: import Data.List (permutations)\n\nsolution :: [Int]\nsolution@(a : b : c : d : e : f : g : h : _) =\n  head $\n    filter isSolution (permutations [1 .. 8])\n  where\n    isSolution :: [Int] -> Bool\n    isSolution (a : b : c : d : e : f : g : h : _) =\n      all ((> 1) . abs) $\n        zipWith\n          (-)\n          [a, c, g, e, a, c, g, e, b, d, h, f, b, d, h, f]\n          [d, d, d, d, c, g, e, a, e, e, e, e, d, h, f, b]\n\nmain :: IO ()\nmain =\n  (putStrLn . unlines) $\n    unlines\n      ( zipWith\n          (\\x y -> x : (\" = \" <> show y))\n          ['A' .. 'H']\n          solution\n      ) :\n    ( rightShift . unwords . fmap show\n        <$> [[], [a, b], [c, d, e, f], [g, h]]\n    )\n  where\n    rightShift s\n      | length s > 3 = s\n      | otherwise = \"  \" <> s\n", "target": "from __future__ import print_function\nfrom itertools import permutations\nfrom enum import Enum\n\nA, B, C, D, E, F, G, H = Enum('Peg', 'A, B, C, D, E, F, G, H')\n\nconnections = ((A, C), (A, D), (A, E),\n               (B, D), (B, E), (B, F),\n               (G, C), (G, D), (G, E),\n               (H, D), (H, E), (H, F),\n               (C, D), (D, E), (E, F))\n\n\ndef ok(conn, perm):\n    \n    this, that = (c.value - 1 for c in conn)\n    return abs(perm[this] - perm[that]) != 1\n\n\ndef solve():\n    return [perm for perm in permutations(range(1, 9))\n            if all(ok(conn, perm) for conn in connections)]\n\n\nif __name__ == '__main__':\n    solutions = solve()\n    print(\"A, B, C, D, E, F, G, H =\", ', '.join(str(i) for i in solutions[0]))\n"}
{"id": 351091, "name": "Permutation test", "source": "Translate Haskell to Python: binomial n m = (f !! n) `div` (f !! m) `div` (f !! (n - m))\n\twhere f = scanl (*) 1 [1..]\n\npermtest treat ctrl = (fromIntegral less) / (fromIntegral total) * 100\n\twhere\n\ttotal = binomial (length avail) (length treat)\n\tless  = combos (sum treat) (length treat) avail\n\tavail = ctrl ++ treat\n\tcombos total n a@(x:xs)\n\t\t| total < 0\t= binomial (length a) n\n\t\t| n == 0\t= 0\n\t\t| n > length a\t= 0\n\t\t| n == length a = fromEnum (total < sum a)\n\t\t| otherwise\t= combos (total - x) (n - 1) xs\n\t\t\t\t+ combos total n xs\n\nmain =\tlet\tr = permtest\n\t\t\t[85, 88, 75, 66, 25, 29, 83, 39, 97]\n\t\t\t[68, 41, 10, 49, 16, 65, 32, 92, 28, 98]\n\tin do\tputStr \">\u00a0: \"; print r\n\t\tputStr \"<=: \"; print $ 100 - r\n", "target": "from itertools import combinations as comb\n\ndef statistic(ab, a):\n    sumab, suma = sum(ab), sum(a)\n    return ( suma / len(a) -\n             (sumab -suma) / (len(ab) - len(a)) )\n\ndef permutationTest(a, b):\n    ab = a + b\n    Tobs = statistic(ab, a)\n    under = 0\n    for count, perm in enumerate(comb(ab, len(a)), 1):\n        if statistic(ab, perm) <= Tobs:\n            under += 1\n    return under * 100. / count\n\ntreatmentGroup = [85, 88, 75, 66, 25, 29, 83, 39, 97]\ncontrolGroup   = [68, 41, 10, 49, 16, 65, 32, 92, 28, 98]\nunder = permutationTest(treatmentGroup, controlGroup)\nprint(\"under=%.2f%%, over=%.2f%%\" % (under, 100. - under))\n"}
{"id": 351092, "name": "Keyboard input_Obtain a Y or N response", "source": "Translate Haskell to Python: import System.IO\n\nhFlushInput :: Handle -> IO ()\nhFlushInput hdl = do\n  r <- hReady hdl\n  if r then do\n    c <- hGetChar hdl\n    hFlushInput hdl\n  else\n    return ()\n\nyorn :: IO Char\nyorn = do\n  c <- getChar\n  if c == 'Y' || c == 'N' then return c\n  else if c == 'y' then return 'Y'\n  else if c == 'n' then return 'N'\n  else yorn\n\nmain :: IO ()\nmain = do\n  hSetBuffering stdout NoBuffering\n  putStr \"Press Y or N to continue: \"\n\n  hSetBuffering stdin NoBuffering\n  hSetEcho stdin False\n  hFlushInput stdin\n  answer <- yorn\n  putStrLn [answer]\n", "target": "\n\ntry:\n    from msvcrt import getch\nexcept ImportError:\n    def getch():\n        import sys, tty, termios\n        fd = sys.stdin.fileno()\n        old_settings = termios.tcgetattr(fd)\n        try:\n            tty.setraw(sys.stdin.fileno())\n            ch = sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n        return ch\n\nprint \"Press Y or N to continue\"\nwhile True:\n    char = getch()\n    if char.lower() in (\"y\", \"n\"):\n        print char\n        break\n"}
{"id": 351093, "name": "Keyboard input_Obtain a Y or N response", "source": "Translate Haskell to Python: import System.IO\n\nhFlushInput :: Handle -> IO ()\nhFlushInput hdl = do\n  r <- hReady hdl\n  if r then do\n    c <- hGetChar hdl\n    hFlushInput hdl\n  else\n    return ()\n\nyorn :: IO Char\nyorn = do\n  c <- getChar\n  if c == 'Y' || c == 'N' then return c\n  else if c == 'y' then return 'Y'\n  else if c == 'n' then return 'N'\n  else yorn\n\nmain :: IO ()\nmain = do\n  hSetBuffering stdout NoBuffering\n  putStr \"Press Y or N to continue: \"\n\n  hSetBuffering stdin NoBuffering\n  hSetEcho stdin False\n  hFlushInput stdin\n  answer <- yorn\n  putStrLn [answer]\n", "target": "\n\ntry:\n    from msvcrt import getch\nexcept ImportError:\n    def getch():\n        import sys, tty, termios\n        fd = sys.stdin.fileno()\n        old_settings = termios.tcgetattr(fd)\n        try:\n            tty.setraw(sys.stdin.fileno())\n            ch = sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n        return ch\n\nprint \"Press Y or N to continue\"\nwhile True:\n    char = getch()\n    if char.lower() in (\"y\", \"n\"):\n        print char\n        break\n"}
{"id": 351094, "name": "Abbreviations, simple", "source": "Translate Haskell to Python: import Data.List (find, isPrefixOf)\nimport Data.Char (isDigit, toUpper)\nimport Data.Maybe (maybe)\n\nwithExpansions :: [(String, Int)] -> String -> String\nwithExpansions tbl s = unwords $ expanded tbl <$> words s\n\nexpanded :: [(String, Int)] -> String -> String\nexpanded tbl k = maybe \"*error\" fst (expand k)\n  where\n    expand [] = Just ([], 0)\n    expand s =\n      let u = toUpper <$> s\n          lng = length s\n      in find (\\(w, n) -> lng >= n && isPrefixOf u w) tbl\n\ncmdsFromString :: String -> [(String, Int)]\ncmdsFromString s =\n  let go w@(x:_) (xs, n)\n        | isDigit x = (xs, read w :: Int)\n        | otherwise = ((toUpper <$> w, n) : xs, 0)\n  in fst $ foldr go ([], 0) (words s)\n\n\ntable :: [(String, Int)]\ntable =\n  cmdsFromString\n    \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1 \\\n    \\Schange Cinsert 2  Clast 3 compress 4 copy 2 count 3 Coverlay 3 \\\n    \\cursor 3  delete 3 Cdelete 2  down 1  duplicate 3 xEdit 1 expand 3 \\\n    \\extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 \\\n    \\forward 2  get  help 1 hexType 4 input 1 powerInput 3  join 1 \\\n    \\split 2 spltJOIN load locate 1 Clocate 2 lowerCase 3 upperCase 3 \\\n    \\Lprefix 2  macro  merge 2 modify 3 move 2 msg  next 1 overlay 1 \\\n    \\parse preserve 4 purge 3 put putD query 1 quit read recover 3 \\\n    \\refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 \\\n    \\rgtLEFT right 2 left 2  save  set  shift 2  si  sort  sos stack 3 \\\n    \\status 4 top  transfer 3  type 1  up 1\"\n\nmain :: IO ()\nmain = do\n  let unAbbrev = withExpansions table\n  print $\n    unAbbrev\n      \"riG   rePEAT copies  put mo   rest    types   fup.    6      poweRin\"\n  print $ unAbbrev \"\"\n", "target": "command_table_text = \n\nuser_words = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\n\n\ndef find_abbreviations_length(command_table_text):\n    \n    command_table = dict()\n    input_iter = iter(command_table_text.split())\n\n    word = None\n    try:\n        while True:\n            if word is None:\n                word = next(input_iter)\n            abbr_len = next(input_iter, len(word))\n            try:\n                command_table[word] = int(abbr_len)\n                word = None\n            except ValueError:\n                command_table[word] = len(word)\n                word = abbr_len\n    except StopIteration:\n        pass\n    return command_table\n\n\ndef find_abbreviations(command_table):\n    \n    abbreviations = dict()\n    for command, min_abbr_len in command_table.items():\n        for l in range(min_abbr_len, len(command)+1):\n            abbr = command[:l].lower()\n            abbreviations[abbr] = command.upper()\n    return abbreviations\n\n\ndef parse_user_string(user_string, abbreviations):\n    user_words = [word.lower() for word in user_string.split()]\n    commands = [abbreviations.get(user_word, \"*error*\") for user_word in user_words]\n    return \" \".join(commands)\n\n\ncommand_table = find_abbreviations_length(command_table_text)\nabbreviations_table = find_abbreviations(command_table)\n\nfull_words = parse_user_string(user_words, abbreviations_table)\n\nprint(\"user words:\", user_words)\nprint(\"full words:\", full_words)\n"}
{"id": 351095, "name": "Abbreviations, simple", "source": "Translate Haskell to Python: import Data.List (find, isPrefixOf)\nimport Data.Char (isDigit, toUpper)\nimport Data.Maybe (maybe)\n\nwithExpansions :: [(String, Int)] -> String -> String\nwithExpansions tbl s = unwords $ expanded tbl <$> words s\n\nexpanded :: [(String, Int)] -> String -> String\nexpanded tbl k = maybe \"*error\" fst (expand k)\n  where\n    expand [] = Just ([], 0)\n    expand s =\n      let u = toUpper <$> s\n          lng = length s\n      in find (\\(w, n) -> lng >= n && isPrefixOf u w) tbl\n\ncmdsFromString :: String -> [(String, Int)]\ncmdsFromString s =\n  let go w@(x:_) (xs, n)\n        | isDigit x = (xs, read w :: Int)\n        | otherwise = ((toUpper <$> w, n) : xs, 0)\n  in fst $ foldr go ([], 0) (words s)\n\n\ntable :: [(String, Int)]\ntable =\n  cmdsFromString\n    \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1 \\\n    \\Schange Cinsert 2  Clast 3 compress 4 copy 2 count 3 Coverlay 3 \\\n    \\cursor 3  delete 3 Cdelete 2  down 1  duplicate 3 xEdit 1 expand 3 \\\n    \\extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 \\\n    \\forward 2  get  help 1 hexType 4 input 1 powerInput 3  join 1 \\\n    \\split 2 spltJOIN load locate 1 Clocate 2 lowerCase 3 upperCase 3 \\\n    \\Lprefix 2  macro  merge 2 modify 3 move 2 msg  next 1 overlay 1 \\\n    \\parse preserve 4 purge 3 put putD query 1 quit read recover 3 \\\n    \\refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 \\\n    \\rgtLEFT right 2 left 2  save  set  shift 2  si  sort  sos stack 3 \\\n    \\status 4 top  transfer 3  type 1  up 1\"\n\nmain :: IO ()\nmain = do\n  let unAbbrev = withExpansions table\n  print $\n    unAbbrev\n      \"riG   rePEAT copies  put mo   rest    types   fup.    6      poweRin\"\n  print $ unAbbrev \"\"\n", "target": "command_table_text = \n\nuser_words = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\n\n\ndef find_abbreviations_length(command_table_text):\n    \n    command_table = dict()\n    input_iter = iter(command_table_text.split())\n\n    word = None\n    try:\n        while True:\n            if word is None:\n                word = next(input_iter)\n            abbr_len = next(input_iter, len(word))\n            try:\n                command_table[word] = int(abbr_len)\n                word = None\n            except ValueError:\n                command_table[word] = len(word)\n                word = abbr_len\n    except StopIteration:\n        pass\n    return command_table\n\n\ndef find_abbreviations(command_table):\n    \n    abbreviations = dict()\n    for command, min_abbr_len in command_table.items():\n        for l in range(min_abbr_len, len(command)+1):\n            abbr = command[:l].lower()\n            abbreviations[abbr] = command.upper()\n    return abbreviations\n\n\ndef parse_user_string(user_string, abbreviations):\n    user_words = [word.lower() for word in user_string.split()]\n    commands = [abbreviations.get(user_word, \"*error*\") for user_word in user_words]\n    return \" \".join(commands)\n\n\ncommand_table = find_abbreviations_length(command_table_text)\nabbreviations_table = find_abbreviations(command_table)\n\nfull_words = parse_user_string(user_words, abbreviations_table)\n\nprint(\"user words:\", user_words)\nprint(\"full words:\", full_words)\n"}
{"id": 351096, "name": "String comparison", "source": "Translate Haskell to Python: > \"abc\" == \"abc\"\nTrue\n> \"abc\" /= \"abc\"\nFalse\n> \"abc\" <= \"abcd\"\nTrue\n> \"abc\" <= \"abC\"\nFalse\n> \"HELLOWORLD\" == \"HelloWorld\"\nFalse\n> :m +Data.Char\n> map toLower \"ABC\"\n\"abc\"\n> map toLower \"HELLOWORLD\" == map toLower \"HelloWorld\"\nTrue\n", "target": "fun compare(a, b):\n    print(\"\\n$a is of type ${typeof(a)} and $b is of type ${typeof(b)}\")\n    if a < b: print(\"$a is strictly less than $b\")\n    if a <= b: print(\"$a is less than or equal to $b\")\n    if a >  b: print(\"$a is strictly greater than $b\")\n    if a >= b: print(\"$a is greater than or equal to $b\")\n    if a == b: print(\"$a is equal to $b\")\n    if a != b: print(\"$a is not equal to $b\")\n    if a is b: print(\"$a has object identity with $b\")\n    if a is not b: print(\"$a has negated object identity with $b\")\n\ncompare(\"YUP\", \"YUP\")\ncompare('a', 'z')\ncompare(\"24\", \"123\")\ncompare(24, 123)\ncompare(5.0, 5)\n"}
{"id": 351097, "name": "Pseudo-random numbers_Middle-square method", "source": "Translate Haskell to Python: findPseudoRandom :: Int -> Int\nfindPseudoRandom seed = \n   let square = seed * seed\n       squarestr = show square\n       enlarged = replicate ( 12 - length squarestr ) '0' ++ squarestr\n   in read $ take 6 $ drop 3 enlarged\n\nsolution :: [Int]\nsolution = tail $ take 6 $ iterate findPseudoRandom 675248\n", "target": "seed = 675248\ndef random():\n    global seed\n    seed = int(str(seed ** 2).zfill(12)[3:9])\n    return seed\nfor _ in range(5):\n    print(random())\n"}
{"id": 351098, "name": "Pseudo-random numbers_Middle-square method", "source": "Translate Haskell to Python: findPseudoRandom :: Int -> Int\nfindPseudoRandom seed = \n   let square = seed * seed\n       squarestr = show square\n       enlarged = replicate ( 12 - length squarestr ) '0' ++ squarestr\n   in read $ take 6 $ drop 3 enlarged\n\nsolution :: [Int]\nsolution = tail $ take 6 $ iterate findPseudoRandom 675248\n", "target": "seed = 675248\ndef random():\n    global seed\n    seed = int(str(seed ** 2).zfill(12)[3:9])\n    return seed\nfor _ in range(5):\n    print(random())\n"}
{"id": 351099, "name": "Entropy_Narcissist", "source": "Translate Haskell to Python: import qualified Data.ByteString as BS\nimport Data.List\nimport System.Environment\n\n(>>>) = flip (.)\n\nmain = getArgs >>= head >>> BS.readFile >>= BS.unpack >>> entropy >>> print\n          \nentropy = sort >>> group >>> map genericLength >>> normalize >>> map lg >>> sum\n  where lg c = -c * logBase 2 c\n        normalize c = let sc = sum c in map (/ sc) c\n", "target": "import math\nfrom collections import Counter\n\ndef entropy(s):\n    p, lns = Counter(s), float(len(s))\n    return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\n\nwith open(__file__) as f:\n    b=f.read()\n    \nprint(entropy(b))\n"}
{"id": 351100, "name": "Entropy_Narcissist", "source": "Translate Haskell to Python: import qualified Data.ByteString as BS\nimport Data.List\nimport System.Environment\n\n(>>>) = flip (.)\n\nmain = getArgs >>= head >>> BS.readFile >>= BS.unpack >>> entropy >>> print\n          \nentropy = sort >>> group >>> map genericLength >>> normalize >>> map lg >>> sum\n  where lg c = -c * logBase 2 c\n        normalize c = let sc = sum c in map (/ sc) c\n", "target": "import math\nfrom collections import Counter\n\ndef entropy(s):\n    p, lns = Counter(s), float(len(s))\n    return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\n\nwith open(__file__) as f:\n    b=f.read()\n    \nprint(entropy(b))\n"}
{"id": 351101, "name": "Verify distribution uniformity_Naive", "source": "Translate Haskell to Python: import System.Random\nimport Data.List\nimport Control.Monad\nimport Control.Arrow\n\ndistribCheck :: IO Int -> Int -> Int -> IO [(Int,(Int,Bool))]\ndistribCheck f n d = do\n  nrs <- replicateM n f\n  let group  = takeWhile (not.null) $ unfoldr (Just. (partition =<< (==). head)) nrs\n      avg    = (fromIntegral n) / fromIntegral (length group)\n      ul     = round $ (100 + fromIntegral d)/100 * avg\n      ll     = round $ (100 - fromIntegral d)/100 * avg\n  return $ map (head &&& (id &&& liftM2 (&&) (>ll)(<ul)).length) group\n", "target": "from collections import Counter\nfrom pprint import pprint as pp\n\ndef distcheck(fn, repeats, delta):\n    \n    bin = Counter(fn() for i in range(repeats))\n    target = repeats // len(bin)\n    deltacount = int(delta / 100. * target)\n    assert all( abs(target - count) < deltacount\n                for count in bin.values() ), \"Bin distribution skewed from %i +/- %i: %s\" % (\n                    target, deltacount, [ (key, target - count)\n                                          for key, count in sorted(bin.items()) ]\n                    )\n    pp(dict(bin))\n"}
{"id": 351102, "name": "Use another language to call a function", "source": "Translate Haskell to Python: \n\nmodule Called where\n\nimport Foreign\nimport Foreign.C.String (CString, withCStringLen)\nimport Foreign.C.Types\n\n\n\n\n\nquery_hs ::  CString -> Ptr CSize -> IO CInt\nquery_hs ptrBuff ptrSize = withCStringLen \"Here I am\"\n               (\\(str, len) -> do\n                   buffSize <- peek ptrSize\n                   if sizeOf str > (fromIntegral buffSize)\n                     then do\n                       poke ptrSize 0\n                       return 0\n                     else do\n                       poke ptrSize (fromIntegral len)\n                       copyArray ptrBuff str len\n                       return 1)\n\nforeign export ccall query_hs :: CString -> Ptr CSize -> IO CInt\n", "target": "\n\ndef query(buffer_length):\n    message = b'Here am I'\n    L = len(message)\n    return message[0:L*(L <= buffer_length)]\n"}
{"id": 351103, "name": "Bioinformatics_Sequence mutation", "source": "Translate Haskell to Python: import Data.List       (group, sort)\nimport Data.List.Split (chunksOf)\nimport System.Random   (Random, randomR, random, newStdGen, randoms, getStdRandom)\nimport Text.Printf     (PrintfArg(..), fmtChar, fmtPrecision, formatString, IsChar(..), printf)\n\ndata Mutation = Swap | Delete | Insert deriving (Show, Eq, Ord, Enum, Bounded)\ndata DNABase = A | C | G | T deriving (Show, Read, Eq, Ord, Enum, Bounded)\ntype DNASequence = [DNABase]\n\ndata Result = Swapped Mutation Int (DNABase, DNABase)\n            | InsertDeleted Mutation Int DNABase\n\ninstance Random DNABase where\n  randomR (a, b) g = case randomR (fromEnum a, fromEnum b) g of (x, y) -> (toEnum x, y)\n  random = randomR (minBound, maxBound)\n\ninstance Random Mutation where\n  randomR (a, b) g = case randomR (fromEnum a, fromEnum b) g of (x, y) -> (toEnum x, y)\n  random = randomR (minBound, maxBound)\n\ninstance PrintfArg DNABase where\n  formatArg x fmt = formatString (show x) (fmt { fmtChar = 's', fmtPrecision = Nothing })\n\ninstance PrintfArg Mutation where\n  formatArg x fmt = formatString (show x) (fmt { fmtChar = 's', fmtPrecision = Nothing })\n\ninstance IsChar DNABase where\n  toChar = head . show\n  fromChar = read . pure\n\nchunkedDNASequence :: DNASequence -> [(Int, [DNABase])]\nchunkedDNASequence = zip [50,100..] . chunksOf 50\n\nbaseCounts :: DNASequence -> [(DNABase, Int)]\nbaseCounts = fmap ((,) . head <*> length) . group . sort\n\nnewSequence :: Int -> IO DNASequence\nnewSequence n = take n . randoms <$> newStdGen\n\nmutateSequence :: DNASequence -> IO (Result, DNASequence)\nmutateSequence [] = fail \"empty dna sequence\"\nmutateSequence ds = randomMutation >>= mutate ds\n  where\n    randomMutation = head . randoms <$> newStdGen\n    mutate xs m = do\n      i <- randomIndex (length xs)\n      case m of\n        Swap   -> randomDNA >>= \\d -> pure (Swapped Swap i (xs !! pred i, d), swapElement i d xs)\n        Insert -> randomDNA >>= \\d -> pure (InsertDeleted Insert i d, insertElement i d xs)\n        Delete -> pure (InsertDeleted Delete i (xs !! pred i), dropElement i xs)\n      where\n        dropElement i xs = take (pred i) xs <> drop i xs\n        insertElement i e xs = take i xs <> [e] <> drop i xs\n        swapElement i a xs = take (pred i) xs <> [a] <> drop i xs\n        randomIndex n = getStdRandom (randomR (1, n))\n        randomDNA = head . randoms <$> newStdGen\n\nmutate :: Int -> DNASequence -> IO DNASequence\nmutate 0 s = pure s\nmutate n s = do\n  (r, ms) <- mutateSequence s\n  case r of\n    Swapped m i (a, b)  -> printf \"%6s @\u00a0%-3d\u00a0: %s -> %s \\n\" m i a b\n    InsertDeleted m i a -> printf \"%6s @\u00a0%-3d\u00a0: %s\\n\" m i a\n  mutate (pred n) ms\n\nmain :: IO ()\nmain = do\n  ds <- newSequence 200\n  putStrLn \"\\nInitial Sequence:\" >> showSequence ds\n  putStrLn \"\\nBase Counts:\" >> showBaseCounts ds\n  showSumBaseCounts ds\n  ms <- mutate 10 ds\n  putStrLn \"\\nMutated Sequence:\" >> showSequence ms\n  putStrLn \"\\nBase Counts:\" >> showBaseCounts ms\n  showSumBaseCounts ms\n  where\n    showSequence   = mapM_ (uncurry (printf \"%3d: %s\\n\")) . chunkedDNASequence\n    showBaseCounts = mapM_ (uncurry (printf \"%s: %3d\\n\")) . baseCounts\n    showSumBaseCounts xs = putStrLn (replicate 6 '-') >> printf \"\u03a3: %d\\n\\n\" (length xs)\n", "target": "import random\nfrom collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n\ndef seq_mutate(dna, count=1, kinds=\"IDSSSS\", choice=\"ATCG\" ):\n    mutation = []\n    k2txt = dict(I='Insert', D='Delete', S='Substitute')\n    for _ in range(count):\n        kind = random.choice(kinds)\n        index = random.randint(0, len(dna))\n        if kind == 'I':    \n            dna = dna[:index] + random.choice(choice) + dna[index:]\n        elif kind == 'D' and dna:  \n            dna = dna[:index] + dna[index+1:]\n        elif kind == 'S' and dna:  \n            dna = dna[:index] + random.choice(choice) + dna[index+1:]\n        mutation.append((k2txt[kind], index))\n    return dna, mutation\n\nif __name__ == '__main__':\n    length = 250\n    print(\"SEQUENCE:\")\n    sequence = ''.join(random.choices('ACGT', weights=(1, 0.8, .9, 1.1), k=length))\n    seq_pp(sequence)\n    print(\"\\n\\nMUTATIONS:\")\n    mseq, m = seq_mutate(sequence, 10)\n    for kind, index in m:\n        print(f\" {kind:>10} @{index}\")\n    print()\n    seq_pp(mseq)\n"}
{"id": 351104, "name": "Bioinformatics_Sequence mutation", "source": "Translate Haskell to Python: import Data.List       (group, sort)\nimport Data.List.Split (chunksOf)\nimport System.Random   (Random, randomR, random, newStdGen, randoms, getStdRandom)\nimport Text.Printf     (PrintfArg(..), fmtChar, fmtPrecision, formatString, IsChar(..), printf)\n\ndata Mutation = Swap | Delete | Insert deriving (Show, Eq, Ord, Enum, Bounded)\ndata DNABase = A | C | G | T deriving (Show, Read, Eq, Ord, Enum, Bounded)\ntype DNASequence = [DNABase]\n\ndata Result = Swapped Mutation Int (DNABase, DNABase)\n            | InsertDeleted Mutation Int DNABase\n\ninstance Random DNABase where\n  randomR (a, b) g = case randomR (fromEnum a, fromEnum b) g of (x, y) -> (toEnum x, y)\n  random = randomR (minBound, maxBound)\n\ninstance Random Mutation where\n  randomR (a, b) g = case randomR (fromEnum a, fromEnum b) g of (x, y) -> (toEnum x, y)\n  random = randomR (minBound, maxBound)\n\ninstance PrintfArg DNABase where\n  formatArg x fmt = formatString (show x) (fmt { fmtChar = 's', fmtPrecision = Nothing })\n\ninstance PrintfArg Mutation where\n  formatArg x fmt = formatString (show x) (fmt { fmtChar = 's', fmtPrecision = Nothing })\n\ninstance IsChar DNABase where\n  toChar = head . show\n  fromChar = read . pure\n\nchunkedDNASequence :: DNASequence -> [(Int, [DNABase])]\nchunkedDNASequence = zip [50,100..] . chunksOf 50\n\nbaseCounts :: DNASequence -> [(DNABase, Int)]\nbaseCounts = fmap ((,) . head <*> length) . group . sort\n\nnewSequence :: Int -> IO DNASequence\nnewSequence n = take n . randoms <$> newStdGen\n\nmutateSequence :: DNASequence -> IO (Result, DNASequence)\nmutateSequence [] = fail \"empty dna sequence\"\nmutateSequence ds = randomMutation >>= mutate ds\n  where\n    randomMutation = head . randoms <$> newStdGen\n    mutate xs m = do\n      i <- randomIndex (length xs)\n      case m of\n        Swap   -> randomDNA >>= \\d -> pure (Swapped Swap i (xs !! pred i, d), swapElement i d xs)\n        Insert -> randomDNA >>= \\d -> pure (InsertDeleted Insert i d, insertElement i d xs)\n        Delete -> pure (InsertDeleted Delete i (xs !! pred i), dropElement i xs)\n      where\n        dropElement i xs = take (pred i) xs <> drop i xs\n        insertElement i e xs = take i xs <> [e] <> drop i xs\n        swapElement i a xs = take (pred i) xs <> [a] <> drop i xs\n        randomIndex n = getStdRandom (randomR (1, n))\n        randomDNA = head . randoms <$> newStdGen\n\nmutate :: Int -> DNASequence -> IO DNASequence\nmutate 0 s = pure s\nmutate n s = do\n  (r, ms) <- mutateSequence s\n  case r of\n    Swapped m i (a, b)  -> printf \"%6s @\u00a0%-3d\u00a0: %s -> %s \\n\" m i a b\n    InsertDeleted m i a -> printf \"%6s @\u00a0%-3d\u00a0: %s\\n\" m i a\n  mutate (pred n) ms\n\nmain :: IO ()\nmain = do\n  ds <- newSequence 200\n  putStrLn \"\\nInitial Sequence:\" >> showSequence ds\n  putStrLn \"\\nBase Counts:\" >> showBaseCounts ds\n  showSumBaseCounts ds\n  ms <- mutate 10 ds\n  putStrLn \"\\nMutated Sequence:\" >> showSequence ms\n  putStrLn \"\\nBase Counts:\" >> showBaseCounts ms\n  showSumBaseCounts ms\n  where\n    showSequence   = mapM_ (uncurry (printf \"%3d: %s\\n\")) . chunkedDNASequence\n    showBaseCounts = mapM_ (uncurry (printf \"%s: %3d\\n\")) . baseCounts\n    showSumBaseCounts xs = putStrLn (replicate 6 '-') >> printf \"\u03a3: %d\\n\\n\" (length xs)\n", "target": "import random\nfrom collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n\ndef seq_mutate(dna, count=1, kinds=\"IDSSSS\", choice=\"ATCG\" ):\n    mutation = []\n    k2txt = dict(I='Insert', D='Delete', S='Substitute')\n    for _ in range(count):\n        kind = random.choice(kinds)\n        index = random.randint(0, len(dna))\n        if kind == 'I':    \n            dna = dna[:index] + random.choice(choice) + dna[index:]\n        elif kind == 'D' and dna:  \n            dna = dna[:index] + dna[index+1:]\n        elif kind == 'S' and dna:  \n            dna = dna[:index] + random.choice(choice) + dna[index+1:]\n        mutation.append((k2txt[kind], index))\n    return dna, mutation\n\nif __name__ == '__main__':\n    length = 250\n    print(\"SEQUENCE:\")\n    sequence = ''.join(random.choices('ACGT', weights=(1, 0.8, .9, 1.1), k=length))\n    seq_pp(sequence)\n    print(\"\\n\\nMUTATIONS:\")\n    mseq, m = seq_mutate(sequence, 10)\n    for kind, index in m:\n        print(f\" {kind:>10} @{index}\")\n    print()\n    seq_pp(mseq)\n"}
{"id": 351105, "name": "Colour bars_Display", "source": "Translate Haskell to Python: #!/usr/bin/env stack\n\n\nimport Graphics.Vty\n\ncolorBars :: Int -> [(Int, Attr)] -> Image\ncolorBars h bars = horizCat $ map colorBar bars\n  where colorBar (w, attr) = charFill attr ' ' w h\n\nbarWidths :: Int -> Int -> [Int]\nbarWidths nBars totalWidth = map barWidth [0..nBars-1]\n  where fracWidth = fromIntegral totalWidth / fromIntegral nBars\n        barWidth n =\n          let n' = fromIntegral n :: Double\n          in floor ((n' + 1) * fracWidth) - floor (n' * fracWidth)\n\nbarImage :: Int -> Int -> Image\nbarImage w h = colorBars h $ zip (barWidths nBars w) attrs\n  where attrs = map color2attr colors\n        nBars = length colors\n        colors = [black, brightRed, brightGreen, brightMagenta, brightCyan, brightYellow, brightWhite]\n        color2attr c = Attr Default Default (SetTo c)\n\nmain = do\n    cfg <- standardIOConfig\n    vty <- mkVty cfg\n    let output = outputIface vty\n    bounds <- displayBounds output\n    let showBars (w,h) = do\n          let img = barImage w h\n              pic = picForImage img\n          update vty pic\n          e <- nextEvent vty\n          case e of\n            EvResize w' h' -> showBars (w',h')\n            _ -> return ()\n    showBars bounds\n    shutdown vty\n", "target": "\n\n\nfrom livewires import *\n\nhoriz=640; vert=480\nbegin_graphics(width=horiz,height=vert,title=\"v_stripes\",background=Colour.black)\nNameColors=[\"black\",\"red\",\"green\",\"dark_blue\",\"purple\",\"blue\",\"yellow\",\"white\"]\nstepik=horiz/len(NameColors)\n\nfor index,each in enumerate(NameColors):\n\tExcStrng=\"set_colour(Colour.\"+each+\")\"\n\texec ExcStrng\n\tbox(index*stepik,0,(index+1)*stepik,vert,filled=1)\n\nwhile keys_pressed() != ['x']: \n\tpass\n\nend_graphics()\n"}
{"id": 351106, "name": "Colour bars_Display", "source": "Translate Haskell to Python: #!/usr/bin/env stack\n\n\nimport Graphics.Vty\n\ncolorBars :: Int -> [(Int, Attr)] -> Image\ncolorBars h bars = horizCat $ map colorBar bars\n  where colorBar (w, attr) = charFill attr ' ' w h\n\nbarWidths :: Int -> Int -> [Int]\nbarWidths nBars totalWidth = map barWidth [0..nBars-1]\n  where fracWidth = fromIntegral totalWidth / fromIntegral nBars\n        barWidth n =\n          let n' = fromIntegral n :: Double\n          in floor ((n' + 1) * fracWidth) - floor (n' * fracWidth)\n\nbarImage :: Int -> Int -> Image\nbarImage w h = colorBars h $ zip (barWidths nBars w) attrs\n  where attrs = map color2attr colors\n        nBars = length colors\n        colors = [black, brightRed, brightGreen, brightMagenta, brightCyan, brightYellow, brightWhite]\n        color2attr c = Attr Default Default (SetTo c)\n\nmain = do\n    cfg <- standardIOConfig\n    vty <- mkVty cfg\n    let output = outputIface vty\n    bounds <- displayBounds output\n    let showBars (w,h) = do\n          let img = barImage w h\n              pic = picForImage img\n          update vty pic\n          e <- nextEvent vty\n          case e of\n            EvResize w' h' -> showBars (w',h')\n            _ -> return ()\n    showBars bounds\n    shutdown vty\n", "target": "\n\n\nfrom livewires import *\n\nhoriz=640; vert=480\nbegin_graphics(width=horiz,height=vert,title=\"v_stripes\",background=Colour.black)\nNameColors=[\"black\",\"red\",\"green\",\"dark_blue\",\"purple\",\"blue\",\"yellow\",\"white\"]\nstepik=horiz/len(NameColors)\n\nfor index,each in enumerate(NameColors):\n\tExcStrng=\"set_colour(Colour.\"+each+\")\"\n\texec ExcStrng\n\tbox(index*stepik,0,(index+1)*stepik,vert,filled=1)\n\nwhile keys_pressed() != ['x']: \n\tpass\n\nend_graphics()\n"}
{"id": 351107, "name": "Ray-casting algorithm", "source": "Translate Haskell to Python: import Data.Ratio\n\ntype Point = (Rational, Rational)\ntype Polygon = [Point]\ndata Line = Sloped {lineSlope, lineYIntercept :: Rational} |\n            Vert {lineXIntercept :: Rational}\n\npolygonSides :: Polygon -> [(Point, Point)]\npolygonSides poly@(p1 : ps) = zip poly $ ps ++ [p1]\n\nintersects :: Point -> Line -> Bool\n\nintersects (px, _)  (Vert xint)  = px <= xint\nintersects (px, py) (Sloped m b) | m < 0     = py <= m * px + b\n                                 | otherwise = py >= m * px + b\n\nonLine :: Point -> Line -> Bool\n\nonLine (px, _)  (Vert xint)  = px == xint\nonLine (px, py) (Sloped m b) = py == m * px + b\n\ncarrier :: (Point, Point) -> Line\n\ncarrier ((ax, ay), (bx, by)) | ax == bx  = Vert ax\n                             | otherwise = Sloped slope yint\n  where slope = (ay - by) / (ax - bx)\n        yint = ay - slope * ax\n\nbetween :: Ord a => a -> a -> a -> Bool\nbetween x a b | a > b     = b <= x && x <= a\n              | otherwise = a <= x && x <= b\n\ninPolygon :: Point -> Polygon -> Bool\ninPolygon p@(px, py) = f 0 . polygonSides\n  where f n []                             = odd n\n        f n (side : sides) | far           = f n       sides\n                           | onSegment     = True\n                           | rayIntersects = f (n + 1) sides\n                           | otherwise     = f n       sides\n          where far = not $ between py ay by\n                onSegment | ay == by  = between px ax bx\n                          | otherwise = p `onLine` line\n                rayIntersects =\n                    intersects p line &&\n                    (py /= ay || by < py) &&\n                    (py /= by || ay < py)\n                ((ax, ay), (bx, by)) = side\n                line = carrier side\n", "target": "from collections import namedtuple\nfrom pprint import pprint as pp\nimport sys\n\nPt = namedtuple('Pt', 'x, y')               \nEdge = namedtuple('Edge', 'a, b')           \nPoly = namedtuple('Poly', 'name, edges')    \n\n_eps = 0.00001\n_huge = sys.float_info.max\n_tiny = sys.float_info.min\n\ndef rayintersectseg(p, edge):\n    \n    a,b = edge\n    if a.y > b.y:\n        a,b = b,a\n    if p.y == a.y or p.y == b.y:\n        p = Pt(p.x, p.y + _eps)\n\n    intersect = False\n\n    if (p.y > b.y or p.y < a.y) or (\n        p.x > max(a.x, b.x)):\n        return False\n\n    if p.x < min(a.x, b.x):\n        intersect = True\n    else:\n        if abs(a.x - b.x) > _tiny:\n            m_red = (b.y - a.y) / float(b.x - a.x)\n        else:\n            m_red = _huge\n        if abs(a.x - p.x) > _tiny:\n            m_blue = (p.y - a.y) / float(p.x - a.x)\n        else:\n            m_blue = _huge\n        intersect = m_blue >= m_red\n    return intersect\n\ndef _odd(x): return x%2 == 1\n\ndef ispointinside(p, poly):\n    ln = len(poly)\n    return _odd(sum(rayintersectseg(p, edge)\n                    for edge in poly.edges ))\n\ndef polypp(poly):\n    print (\"\\n  Polygon(name='%s', edges=(\" % poly.name)\n    print ('   ', ',\\n    '.join(str(e) for e in poly.edges) + '\\n    ))')\n\nif __name__ == '__main__':\n    polys = [\n      Poly(name='square', edges=(\n        Edge(a=Pt(x=0, y=0), b=Pt(x=10, y=0)),\n        Edge(a=Pt(x=10, y=0), b=Pt(x=10, y=10)),\n        Edge(a=Pt(x=10, y=10), b=Pt(x=0, y=10)),\n        Edge(a=Pt(x=0, y=10), b=Pt(x=0, y=0))\n        )),\n      Poly(name='square_hole', edges=(\n        Edge(a=Pt(x=0, y=0), b=Pt(x=10, y=0)),\n        Edge(a=Pt(x=10, y=0), b=Pt(x=10, y=10)),\n        Edge(a=Pt(x=10, y=10), b=Pt(x=0, y=10)),\n        Edge(a=Pt(x=0, y=10), b=Pt(x=0, y=0)),\n        Edge(a=Pt(x=2.5, y=2.5), b=Pt(x=7.5, y=2.5)),\n        Edge(a=Pt(x=7.5, y=2.5), b=Pt(x=7.5, y=7.5)),\n        Edge(a=Pt(x=7.5, y=7.5), b=Pt(x=2.5, y=7.5)),\n        Edge(a=Pt(x=2.5, y=7.5), b=Pt(x=2.5, y=2.5))\n        )),\n      Poly(name='strange', edges=(\n        Edge(a=Pt(x=0, y=0), b=Pt(x=2.5, y=2.5)),\n        Edge(a=Pt(x=2.5, y=2.5), b=Pt(x=0, y=10)),\n        Edge(a=Pt(x=0, y=10), b=Pt(x=2.5, y=7.5)),\n        Edge(a=Pt(x=2.5, y=7.5), b=Pt(x=7.5, y=7.5)),\n        Edge(a=Pt(x=7.5, y=7.5), b=Pt(x=10, y=10)),\n        Edge(a=Pt(x=10, y=10), b=Pt(x=10, y=0)),\n        Edge(a=Pt(x=10, y=0), b=Pt(x=2.5, y=2.5))\n        )),\n      Poly(name='exagon', edges=(\n        Edge(a=Pt(x=3, y=0), b=Pt(x=7, y=0)),\n        Edge(a=Pt(x=7, y=0), b=Pt(x=10, y=5)),\n        Edge(a=Pt(x=10, y=5), b=Pt(x=7, y=10)),\n        Edge(a=Pt(x=7, y=10), b=Pt(x=3, y=10)),\n        Edge(a=Pt(x=3, y=10), b=Pt(x=0, y=5)),\n        Edge(a=Pt(x=0, y=5), b=Pt(x=3, y=0))\n        )),\n      ]\n    testpoints = (Pt(x=5, y=5), Pt(x=5, y=8),\n                  Pt(x=-10, y=5), Pt(x=0, y=5),\n                  Pt(x=10, y=5), Pt(x=8, y=5),\n                  Pt(x=10, y=10))\n    \n    print (\"\\n TESTING WHETHER POINTS ARE WITHIN POLYGONS\")\n    for poly in polys:\n        polypp(poly)\n        print ('   ', '\\t'.join(\"%s: %s\" % (p, ispointinside(p, poly))\n                               for p in testpoints[:3]))\n        print ('   ', '\\t'.join(\"%s: %s\" % (p, ispointinside(p, poly))\n                               for p in testpoints[3:6]))\n        print ('   ', '\\t'.join(\"%s: %s\" % (p, ispointinside(p, poly))\n                               for p in testpoints[6:]))\n"}
{"id": 351108, "name": "Dining philosophers", "source": "Translate Haskell to Python: module Philosophers where\n\nimport Control.Monad\nimport Control.Concurrent\nimport Control.Concurrent.STM\nimport System.Random\n\n\n\n\n\n\n\ntype Fork = TMVar Int\n\nnewFork :: Int -> IO Fork\nnewFork i = newTMVarIO i\n\n\ntakeFork :: Fork -> STM Int\ntakeFork fork = takeTMVar fork\n\nreleaseFork :: Int -> Fork -> STM ()\nreleaseFork i fork = putTMVar fork i\n\ntype Name = String\n\nrunPhilosopher :: Name -> (Fork, Fork) -> IO ()\nrunPhilosopher name (left, right) = forever $ do\n  putStrLn (name ++ \" is hungry.\")\n  \n  \n  \n  (leftNum, rightNum) <- atomically $ do\n    leftNum <- takeFork left\n    rightNum <- takeFork right\n    return (leftNum, rightNum)\n  \n  putStrLn (name ++ \" got forks \" ++ show leftNum ++ \" and \" ++ show rightNum ++ \" and is now eating.\")\n  delay <- randomRIO (1,10)\n  threadDelay (delay * 1000000) \n  putStrLn (name ++ \" is done eating. Going back to thinking.\")\n\n  atomically $ do\n    releaseFork leftNum left\n    releaseFork rightNum right\n    \n  delay <- randomRIO (1, 10)\n  threadDelay (delay * 1000000)\n\nphilosophers :: [String]\nphilosophers = [\"Aristotle\", \"Kant\", \"Spinoza\", \"Marx\", \"Russel\"]\n\nmain = do\n  forks <- mapM newFork [1..5]\n  let namedPhilosophers  = map runPhilosopher philosophers\n      forkPairs          = zip forks (tail . cycle $ forks)\n      philosophersWithForks = zipWith ($) namedPhilosophers forkPairs\n  \n  putStrLn \"Running the philosophers. Press enter to quit.\"\n  \n  mapM_ forkIO philosophersWithForks\n  \n  \n  getLine\n", "target": "import threading\nimport random\nimport time\n\n\n\n\n\n\n\n\n\n\nclass Philosopher(threading.Thread):\n    \n    running = True\n\n    def __init__(self, xname, forkOnLeft, forkOnRight):\n        threading.Thread.__init__(self)\n        self.name = xname\n        self.forkOnLeft = forkOnLeft\n        self.forkOnRight = forkOnRight\n\n    def run(self):\n        while(self.running):\n            \n            time.sleep( random.uniform(3,13))\n            print '%s is hungry.' % self.name\n            self.dine()\n\n    def dine(self):\n        fork1, fork2 = self.forkOnLeft, self.forkOnRight\n\n        while self.running:\n            fork1.acquire(True)\n            locked = fork2.acquire(False)\n            if locked: break\n            fork1.release()\n            print '%s swaps forks' % self.name\n            fork1, fork2 = fork2, fork1\n        else:\n            return\n\n        self.dining()\n        fork2.release()\n        fork1.release()\n\n    def dining(self):\t\t\t\n        print '%s starts eating '% self.name\n        time.sleep(random.uniform(1,10))\n        print '%s finishes eating and leaves to think.' % self.name\n\ndef DiningPhilosophers():\n    forks = [threading.Lock() for n in range(5)]\n    philosopherNames = ('Aristotle','Kant','Spinoza','Marx', 'Russel')\n\n    philosophers= [Philosopher(philosopherNames[i], forks[i%5], forks[(i+1)%5]) \\\n            for i in range(5)]\n\n    random.seed(507129)\n    Philosopher.running = True\n    for p in philosophers: p.start()\n    time.sleep(100)\n    Philosopher.running = False\n    print (\"Now we're finishing.\")\n\nDiningPhilosophers()\n"}
{"id": 351109, "name": "Exceptions", "source": "Translate Haskell to Python: do \n   throwIO SomeException\n", "target": "import exceptions\nclass SillyError(exceptions.Exception):\n    def __init__(self,args=None):\n         self.args=args\n"}
{"id": 351110, "name": "24 game", "source": "Translate Haskell to Python: import Data.List (sort)\nimport Data.Char (isDigit)\nimport Data.Maybe (fromJust)\nimport Control.Monad (foldM)\nimport System.Random (randomRs, getStdGen)\nimport System.IO (hSetBuffering, stdout, BufferMode(NoBuffering))\n\nmain = do\n  hSetBuffering stdout NoBuffering\n  mapM_\n    putStrLn\n    [ \"THE 24 GAME\\n\"\n    , \"Given four digits in the range 1 to 9\"\n    , \"Use the +, -, *, and / operators in reverse polish notation\"\n    , \"To show how to make an answer of 24.\\n\"\n    ]\n  digits <- fmap (sort . take 4 . randomRs (1, 9)) getStdGen :: IO [Int]\n  putStrLn (\"Your digits: \" ++ unwords (fmap show digits))\n  guessLoop digits\n  where\n    guessLoop digits =\n      putStr \"Your expression: \" >> fmap (processGuess digits . words) getLine >>=\n      either (\\m -> putStrLn m >> guessLoop digits) putStrLn\n\nprocessGuess _ [] = Right \"\"\nprocessGuess digits xs\n  | not matches = Left \"Wrong digits used\"\n  where\n    matches = digits == (sort . fmap read $ filter (all isDigit) xs)\nprocessGuess digits xs = calc xs >>= check\n  where\n    check 24 = Right \"Correct\"\n    check x = Left (show (fromRational (x :: Rational)) ++ \" is wrong\")\n\n\ncalc xs =\n  foldM simplify [] xs >>=\n  \\ns ->\n     (case ns of\n        [n] -> Right n\n        _ -> Left \"Too few operators\")\n\nsimplify (a:b:ns) s\n  | isOp s = Right ((fromJust $ lookup s ops) b a : ns)\nsimplify _ s\n  | isOp s = Left (\"Too few values before \" ++ s)\nsimplify ns s\n  | all isDigit s = Right (fromIntegral (read s) : ns)\nsimplify _ s = Left (\"Unrecognized symbol: \" ++ s)\n\nisOp v = elem v $ fmap fst ops\n\nops = [(\"+\", (+)), (\"-\", (-)), (\"*\", (*)), (\"/\", (/))]\n", "target": "\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n"}
{"id": 351111, "name": "24 game", "source": "Translate Haskell to Python: import Data.List (sort)\nimport Data.Char (isDigit)\nimport Data.Maybe (fromJust)\nimport Control.Monad (foldM)\nimport System.Random (randomRs, getStdGen)\nimport System.IO (hSetBuffering, stdout, BufferMode(NoBuffering))\n\nmain = do\n  hSetBuffering stdout NoBuffering\n  mapM_\n    putStrLn\n    [ \"THE 24 GAME\\n\"\n    , \"Given four digits in the range 1 to 9\"\n    , \"Use the +, -, *, and / operators in reverse polish notation\"\n    , \"To show how to make an answer of 24.\\n\"\n    ]\n  digits <- fmap (sort . take 4 . randomRs (1, 9)) getStdGen :: IO [Int]\n  putStrLn (\"Your digits: \" ++ unwords (fmap show digits))\n  guessLoop digits\n  where\n    guessLoop digits =\n      putStr \"Your expression: \" >> fmap (processGuess digits . words) getLine >>=\n      either (\\m -> putStrLn m >> guessLoop digits) putStrLn\n\nprocessGuess _ [] = Right \"\"\nprocessGuess digits xs\n  | not matches = Left \"Wrong digits used\"\n  where\n    matches = digits == (sort . fmap read $ filter (all isDigit) xs)\nprocessGuess digits xs = calc xs >>= check\n  where\n    check 24 = Right \"Correct\"\n    check x = Left (show (fromRational (x :: Rational)) ++ \" is wrong\")\n\n\ncalc xs =\n  foldM simplify [] xs >>=\n  \\ns ->\n     (case ns of\n        [n] -> Right n\n        _ -> Left \"Too few operators\")\n\nsimplify (a:b:ns) s\n  | isOp s = Right ((fromJust $ lookup s ops) b a : ns)\nsimplify _ s\n  | isOp s = Left (\"Too few values before \" ++ s)\nsimplify ns s\n  | all isDigit s = Right (fromIntegral (read s) : ns)\nsimplify _ s = Left (\"Unrecognized symbol: \" ++ s)\n\nisOp v = elem v $ fmap fst ops\n\nops = [(\"+\", (+)), (\"-\", (-)), (\"*\", (*)), (\"/\", (/))]\n", "target": "\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n"}
{"id": 351112, "name": "Enforced immutability", "source": "Translate Haskell to Python: pi  = 3.14159\nmsg = \"Hello World\"\n", "target": ">>> s = \"Hello\"\n>>> s[0] = \"h\"\n\nTraceback (most recent call last):\n  File \"<pyshell\n    s[0] = \"h\"\nTypeError: 'str' object does not support item assignment\n"}
{"id": 351113, "name": "Strange numbers", "source": "Translate Haskell to Python: import Data.List (intercalate)\nimport Data.List.Split (chunksOf)\n\n\n\nisStrange :: Int -> Bool\nisStrange n =\n  all\n    (\\(a, b) -> abs (a - b) `elem` [2, 3, 5, 7])\n    $ (zip <*> tail) (digits n)\n\ndigits :: Int -> [Int]\ndigits = fmap (read . return) . show\n\n\nmain =\n  let xs = filter isStrange [100 .. 500]\n   in (putStrLn . intercalate \"\\n\\n\")\n        [ \"Strange numbers found in range [100..500]\",\n          \"(total \" <> (show . length) xs <> \")\",\n          \"Full list:\",\n          unlines\n            (unwords <$> chunksOf 10 (show <$> xs))\n        ]\n", "target": "\n\n\n\ndef isStrange(n):\n    \n    def test(a, b):\n        return abs(a - b) in [2, 3, 5, 7]\n\n    xs = digits(n)\n    return all(map(test, xs, xs[1:]))\n\n\n\n\ndef main():\n    \n\n    xs = [\n        n for n in range(100, 1 + 500)\n        if isStrange(n)\n    ]\n    print('\\nStrange numbers in range [100..500]\\n')\n    print('(Total: ' + str(len(xs)) + ')\\n')\n    print(\n        '\\n'.join(\n            ' '.join(\n                str(x) for x in row\n            ) for row in chunksOf(10)(xs)\n        )\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digits(n):\n    \n    return [int(c) for c in str(n)]\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351114, "name": "Strange numbers", "source": "Translate Haskell to Python: import Data.List (intercalate)\nimport Data.List.Split (chunksOf)\n\n\n\nisStrange :: Int -> Bool\nisStrange n =\n  all\n    (\\(a, b) -> abs (a - b) `elem` [2, 3, 5, 7])\n    $ (zip <*> tail) (digits n)\n\ndigits :: Int -> [Int]\ndigits = fmap (read . return) . show\n\n\nmain =\n  let xs = filter isStrange [100 .. 500]\n   in (putStrLn . intercalate \"\\n\\n\")\n        [ \"Strange numbers found in range [100..500]\",\n          \"(total \" <> (show . length) xs <> \")\",\n          \"Full list:\",\n          unlines\n            (unwords <$> chunksOf 10 (show <$> xs))\n        ]\n", "target": "\n\n\n\ndef isStrange(n):\n    \n    def test(a, b):\n        return abs(a - b) in [2, 3, 5, 7]\n\n    xs = digits(n)\n    return all(map(test, xs, xs[1:]))\n\n\n\n\ndef main():\n    \n\n    xs = [\n        n for n in range(100, 1 + 500)\n        if isStrange(n)\n    ]\n    print('\\nStrange numbers in range [100..500]\\n')\n    print('(Total: ' + str(len(xs)) + ')\\n')\n    print(\n        '\\n'.join(\n            ' '.join(\n                str(x) for x in row\n            ) for row in chunksOf(10)(xs)\n        )\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digits(n):\n    \n    return [int(c) for c in str(n)]\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351115, "name": "Hofstadter Q sequence", "source": "Translate Haskell to Python: qSequence = tail qq where\n  qq = 0 : 1 : 1 : map g [3..] \n  g n = qq !! (n - qq !! (n-1)) + qq !! (n - qq !! (n-2))\n\n\n*Main> (take 10 qSequence, qSequence !! (1000-1))\n([1,1,2,3,3,4,5,5,6,6],502)\n(0.00 secs, 525044 bytes)\n", "target": "def q(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return q.seq[n]\n    except IndexError:\n        ans = q(n - q(n - 1)) + q(n - q(n - 2))\n        q.seq.append(ans)\n        return ans\nq.seq = [None, 1, 1]\n\nif __name__ == '__main__':\n    first10 = [q(i) for i in range(1,11)]\n    assert first10 == [1, 1, 2, 3, 3, 4, 5, 5, 6, 6], \"Q() value error(s)\"\n    print(\"Q(n) for n = [1..10] is:\", ', '.join(str(i) for i in first10))\n    assert q(1000) == 502, \"Q(1000) value error\"\n    print(\"Q(1000) =\", q(1000))\n"}
{"id": 351116, "name": "Hofstadter Q sequence", "source": "Translate Haskell to Python: qSequence = tail qq where\n  qq = 0 : 1 : 1 : map g [3..] \n  g n = qq !! (n - qq !! (n-1)) + qq !! (n - qq !! (n-2))\n\n\n*Main> (take 10 qSequence, qSequence !! (1000-1))\n([1,1,2,3,3,4,5,5,6,6],502)\n(0.00 secs, 525044 bytes)\n", "target": "def q(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return q.seq[n]\n    except IndexError:\n        ans = q(n - q(n - 1)) + q(n - q(n - 2))\n        q.seq.append(ans)\n        return ans\nq.seq = [None, 1, 1]\n\nif __name__ == '__main__':\n    first10 = [q(i) for i in range(1,11)]\n    assert first10 == [1, 1, 2, 3, 3, 4, 5, 5, 6, 6], \"Q() value error(s)\"\n    print(\"Q(n) for n = [1..10] is:\", ', '.join(str(i) for i in first10))\n    assert q(1000) == 502, \"Q(1000) value error\"\n    print(\"Q(1000) =\", q(1000))\n"}
{"id": 351117, "name": "Count occurrences of a substring", "source": "Translate Haskell to Python: import Data.Text hiding (length)\n\n\ncountSubStrs str sub = length $ breakOnAll (pack sub) (pack str)\n\nmain = do\n  print $ countSubStrs \"the three truths\" \"th\"\n  print $ countSubStrs \"ababababab\" \"abab\"\n", "target": ">>> \"the three truths\".count(\"th\")\n3\n>>> \"ababababab\".count(\"abab\")\n2\n"}
{"id": 351118, "name": "Append numbers at same position in strings", "source": "Translate Haskell to Python: main :: IO ()\nmain =\n  mapM_ putStrLn $\n  zipWith3\n    (\\ x y z -> [x, y, z] >>= show)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    [10, 11, 12, 13, 14, 15, 16, 17, 18]\n    [19, 20, 21, 22, 23, 24, 25, 26, 27]\n", "target": "list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nlist2 = [10, 11, 12, 13, 14, 15, 16, 17, 18]\nlist3 = [19, 20, 21, 22, 23, 24, 25, 26, 27]\n\nprint([\n    ''.join(str(n) for n in z) for z\n    in zip(list1, list2, list3)\n])\n"}
{"id": 351119, "name": "Append numbers at same position in strings", "source": "Translate Haskell to Python: main :: IO ()\nmain =\n  mapM_ putStrLn $\n  zipWith3\n    (\\ x y z -> [x, y, z] >>= show)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    [10, 11, 12, 13, 14, 15, 16, 17, 18]\n    [19, 20, 21, 22, 23, 24, 25, 26, 27]\n", "target": "list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nlist2 = [10, 11, 12, 13, 14, 15, 16, 17, 18]\nlist3 = [19, 20, 21, 22, 23, 24, 25, 26, 27]\n\nprint([\n    ''.join(str(n) for n in z) for z\n    in zip(list1, list2, list3)\n])\n"}
{"id": 351120, "name": "User input_Graphical", "source": "Translate Haskell to Python: import Graphics.UI.Gtk\nimport Control.Monad\n\nmain = do\n  initGUI\n\n  window <- windowNew\n  set window [windowTitle := \"Graphical user input\", containerBorderWidth := 10]\n\n  vb <- vBoxNew False 0\n  containerAdd window vb\n\n  hb1 <- hBoxNew False 0\n  boxPackStart vb hb1 PackNatural 0\n  hb2 <- hBoxNew False 0\n  boxPackStart vb hb2 PackNatural 0\n\n  lab1 <- labelNew (Just \"Enter number 75000\")\n  boxPackStart hb1 lab1 PackNatural 0\n  nrfield <- entryNew\n  entrySetText nrfield \"75000\"\n  boxPackStart hb1 nrfield PackNatural 5\n\n  strfield <- entryNew\n  boxPackEnd hb2 strfield PackNatural 5\n  lab2 <- labelNew (Just \"Enter a text\")\n  boxPackEnd hb2 lab2 PackNatural 0\n  \n  accbox    <- hBoxNew False 0\n  boxPackStart vb accbox PackNatural 5\n  im <- imageNewFromStock stockApply IconSizeButton\n  acceptButton <- buttonNewWithLabel \"Accept\"\n  buttonSetImage acceptButton im\n  boxPackStart accbox acceptButton PackRepel 0\n\n  txtstack <- statusbarNew\n  boxPackStart vb txtstack PackNatural 0\n  id <- statusbarGetContextId txtstack \"Line\"\n\n  widgetShowAll window\n\n  onEntryActivate nrfield (showStat nrfield txtstack id)\n  onEntryActivate strfield (showStat strfield txtstack id)\n    \n  onPressed acceptButton $ do\n    g <- entryGetText nrfield\n    if g==\"75000\" then\n      widgetDestroy window\n     else do\n       msgid <- statusbarPush txtstack id \"You didn't enter 75000. Try again\"\n       return ()\n  \n  onDestroy window mainQuit\n  mainGUI\n\nshowStat :: Entry -> Statusbar -> ContextId -> IO ()\nshowStat fld stk id = do\n    txt <- entryGetText fld\n    let mesg = \"You entered \\\"\" ++ txt ++ \"\\\"\"\n    msgid <- statusbarPush stk id mesg\n    return ()\n", "target": "from javax.swing import JOptionPane\n\ndef to_int(n, default=0):\n    try:\n        return int(n)\n    except ValueError:\n        return default\n\nnumber = to_int(JOptionPane.showInputDialog (\"Enter an Integer\")) \nprintln(number)\n\na_string = JOptionPane.showInputDialog (\"Enter a String\")\nprintln(a_string)\n"}
{"id": 351121, "name": "Carmichael 3 strong pseudoprimes", "source": "Translate Haskell to Python: #!/usr/bin/runhaskell\n\nimport Data.Numbers.Primes\nimport Control.Monad (guard)\n\ncarmichaels = do\n  p <- takeWhile (<= 61) primes\n  h3 <- [2..(p-1)]\n  let g = h3 + p\n  d <- [1..(g-1)]\n  guard $ (g * (p - 1)) `mod` d == 0 && (-1 * p * p) `mod` h3 == d `mod` h3\n  let q = 1 + (((p - 1) * g) `div` d)\n  guard $ isPrime q\n  let r = 1 + ((p * q) `div` h3)\n  guard $ isPrime r && (q * r) `mod` (p - 1) == 1\n  return (p, q, r)\n\nmain = putStr $ unlines $ map show carmichaels\n", "target": "class Isprime():\n    \n    multiples = {2}\n    primes = [2]\n    nmax = 2\n    \n    def __init__(self, nmax):\n        if nmax > self.nmax:\n            self.check(nmax)\n\n    def check(self, n):\n        if type(n) == float:\n            if not n.is_integer(): return False\n            n = int(n)\n        multiples = self.multiples\n        if n <= self.nmax:\n            return n not in multiples\n        else:\n            \n            primes, nmax = self.primes, self.nmax\n            newmax = max(nmax*2, n)\n            for p in primes:\n                multiples.update(range(p*((nmax + p + 1) // p), newmax+1, p))\n            for i in range(nmax+1, newmax+1):\n                if i not in multiples:\n                    primes.append(i)\n                    multiples.update(range(i*2, newmax+1, i))\n            self.nmax = newmax\n            return n not in multiples\n\n    __call__ = check\n            \n        \ndef carmichael(p1):\n    ans = []\n    if isprime(p1):\n        for h3 in range(2, p1):\n            g = h3 + p1\n            for d in range(1, g):\n                if (g * (p1 - 1)) % d == 0 and (-p1 * p1) % h3 == d % h3:\n                    p2 = 1 + ((p1 - 1)* g // d)\n                    if isprime(p2):\n                        p3 = 1 + (p1 * p2 // h3)\n                        if isprime(p3):\n                            if (p2 * p3) % (p1 - 1) == 1:\n                                \n                                ans += [tuple(sorted((p1, p2, p3)))]\n    return ans\n                \nisprime = Isprime(2)\n \nans = sorted(sum((carmichael(n) for n in range(62) if isprime(n)), []))\nprint(',\\n'.join(repr(ans[i:i+5])[1:-1] for i in range(0, len(ans)+1, 5)))\n"}
{"id": 351122, "name": "Find square difference", "source": "Translate Haskell to Python: import Data.List (findIndex)\n\nf = succ . flip div 2\n\n\n\ng n = i\n  where\n    Just i = succ <$> findIndex (> n) [1, 3 ..]\n\nmain = mapM_ print $ [f, g] <*> [1000]\n", "target": "import math\nprint(\"working...\")\nlimit1 = 6000\nlimit2 = 1000\noldSquare = 0\nnewSquare = 0\n\nfor n in range(limit1):\n    newSquare = n*n\n    if (newSquare - oldSquare > limit2):\n     print(\"Least number is = \", end = \"\");\n     print(int(math.sqrt(newSquare)))\n     break\n    oldSquare = n*n\n\nprint(\"done...\")\nprint()\n"}
{"id": 351123, "name": "Find square difference", "source": "Translate Haskell to Python: import Data.List (findIndex)\n\nf = succ . flip div 2\n\n\n\ng n = i\n  where\n    Just i = succ <$> findIndex (> n) [1, 3 ..]\n\nmain = mapM_ print $ [f, g] <*> [1000]\n", "target": "import math\nprint(\"working...\")\nlimit1 = 6000\nlimit2 = 1000\noldSquare = 0\nnewSquare = 0\n\nfor n in range(limit1):\n    newSquare = n*n\n    if (newSquare - oldSquare > limit2):\n     print(\"Least number is = \", end = \"\");\n     print(int(math.sqrt(newSquare)))\n     break\n    oldSquare = n*n\n\nprint(\"done...\")\nprint()\n"}
{"id": 351124, "name": "Snake", "source": "Translate Haskell to Python: \nimport Control.Monad.Random (getRandomRs)\nimport Graphics.Gloss.Interface.Pure.Game\nimport Lens.Micro ((%~), (^.), (&), set)\nimport Lens.Micro.TH (makeLenses)\n\n\n\n\ndata Snake = Snake { _body :: [Point], _direction :: Point }\nmakeLenses ''Snake\n\ndata World = World { _snake :: Snake , _food :: [Point]\n                   , _score :: Int , _maxScore :: Int }\nmakeLenses ''World\n\n\n\n\nmoves (Snake b d) = Snake (step b d : init b) d\neats  (Snake b d) = Snake (step b d : b) d\nbites (Snake b _) = any (== head b)\nstep ((x,y):_) (a,b) = (x+a, y+b)\n\nturn (x',y') (Snake b (x,y)) | (x+x',y+y') == (0,0)  = Snake b (x,y)\n                             | otherwise             = Snake b (x',y')\n\n\n\n\ncreateWorld = do xs <- map fromIntegral <$> getRandomRs (2, 38 :: Int)\n                 ys <- map fromIntegral <$> getRandomRs (2, 38 :: Int)\n                 return (Ok, World snake (zip xs ys) 0 0)\n                 where\n                   snake = Snake [(20, 20)] (1,0)\n                 \n\n\n\ndata Status = Ok | Fail | Stop\n\ncontinue = \\x -> (Ok, x)\nstop     = \\x -> (Stop, x)\nf >>> g  = \\x -> case f x of { (Ok, y) -> g y; b -> b }    \nf <|> g  = \\x -> case f x of { (Fail, _) -> g x; b -> b }  \np ==> f  = \\x -> if p x then f x else (Fail, x)            \nl .& f   = continue . (l %~ f)                             \nl .= y   = continue . set l y                              \n\n\n\n\nupdateWorld _ =  id >>> (snakeEats <|> snakeMoves) \n  where\n    snakeEats  = (snakeFindsFood ==> (snake .& eats)) >>>\n                 (score .& (+1)) >>> (food .& tail)\n\n    snakeMoves = (snakeBitesTail ==> stop) <|>\n                 (snakeHitsWall ==> stop) <|>\n                 (snake .& moves)\n\n    snakeFindsFood w = (w^.snake & moves) `bites` (w^.food & take 1)\n    snakeBitesTail w = (w^.snake) `bites` (w^.snake.body & tail)\n    snakeHitsWall w  = (w^.snake.body) & head & isOutside\n    isOutside (x,y) = or [x <= 0, 40 <= x, y <= 0, 40 <= y]\n\n\n\n\nhandleEvents e (s,w) = f w\n  where f = case s of\n          Ok -> case e of\n            EventKey (SpecialKey k) _ _ _ -> case k of\n              KeyRight -> snake .& turn (1,0)\n              KeyLeft  -> snake .& turn (-1,0)\n              KeyUp    -> snake .& turn (0,1)\n              KeyDown  -> snake .& turn (0,-1)\n              _-> continue\n            _-> continue\n          _-> \\w -> w & ((snake.body) .= [(20,20)]) >>>\n                         (maxScore .& max (w^.score)) >>> (score .= 0)\n                         \n\n\n\nrenderWorld (s, w) = pictures [frame, color c drawSnake, drawFood, showScore]\n  where c = case s of { Ok -> orange; _-> red }\n        drawSnake = foldMap (rectangleSolid 10 10 `at`) (w^.snake.body)\n        drawFood = color blue $ circleSolid 5 `at` (w^.food & head)\n        frame = color black $ rectangleWire 400 400\n        showScore = color orange $ scale 0.2 0.2 $ txt `at` (-80,130)\n        txt = Text $ mconcat [\"Score: \", w^.score & show\n                             ,\"   Maximal score: \", w^.maxScore & show]\n        at p (x,y) = Translate (10*x-200) (10*y-200) p\n\n\n\nmain = do world <- createWorld\n          play inW white 7 world renderWorld handleEvents updateWorld\n  where inW = InWindow \"The Snake\" (400, 400) (10, 10)\n", "target": "from __future__ import annotations\n\nimport itertools\nimport random\n\nfrom enum import Enum\n\nfrom typing import Any\nfrom typing import Tuple\n\nimport pygame as pg\n\nfrom pygame import Color\nfrom pygame import Rect\n\nfrom pygame.surface import Surface\n\nfrom pygame.sprite import AbstractGroup\nfrom pygame.sprite import Group\nfrom pygame.sprite import RenderUpdates\nfrom pygame.sprite import Sprite\n\n\nclass Direction(Enum):\n    UP = (0, -1)\n    DOWN = (0, 1)\n    LEFT = (-1, 0)\n    RIGHT = (1, 0)\n\n    def opposite(self, other: Direction):\n        return (self[0] + other[0], self[1] + other[1]) == (0, 0)\n\n    def __getitem__(self, i: int):\n        return self.value[i]\n\n\nclass SnakeHead(Sprite):\n    def __init__(\n        self,\n        size: int,\n        position: Tuple[int, int],\n        facing: Direction,\n        bounds: Rect,\n    ) -> None:\n        super().__init__()\n        self.image = Surface((size, size))\n        self.image.fill(Color(\"aquamarine4\"))\n        self.rect = self.image.get_rect()\n        self.rect.center = position\n        self.facing = facing\n        self.size = size\n        self.speed = size\n        self.bounds = bounds\n\n    def update(self, *args: Any, **kwargs: Any) -> None:\n        \n        self.rect.move_ip(\n            (\n                self.facing[0] * self.speed,\n                self.facing[1] * self.speed,\n            )\n        )\n\n        \n        if self.rect.right > self.bounds.right:\n            self.rect.left = 0\n        elif self.rect.left < 0:\n            self.rect.right = self.bounds.right\n\n        if self.rect.bottom > self.bounds.bottom:\n            self.rect.top = 0\n        elif self.rect.top < 0:\n            self.rect.bottom = self.bounds.bottom\n\n    def change_direction(self, direction: Direction):\n        if not self.facing == direction and not direction.opposite(self.facing):\n            self.facing = direction\n\n\nclass SnakeBody(Sprite):\n    def __init__(\n        self,\n        size: int,\n        position: Tuple[int, int],\n        colour: str = \"white\",\n    ) -> None:\n        super().__init__()\n        self.image = Surface((size, size))\n        self.image.fill(Color(colour))\n        self.rect = self.image.get_rect()\n        self.rect.center = position\n\n\nclass Snake(RenderUpdates):\n    def __init__(self, game: Game) -> None:\n        self.segment_size = game.segment_size\n        self.colours = itertools.cycle([\"aquamarine1\", \"aquamarine3\"])\n\n        self.head = SnakeHead(\n            size=self.segment_size,\n            position=game.rect.center,\n            facing=Direction.RIGHT,\n            bounds=game.rect,\n        )\n\n        neck = [\n            SnakeBody(\n                size=self.segment_size,\n                position=game.rect.center,\n                colour=next(self.colours),\n            )\n            for _ in range(2)\n        ]\n\n        super().__init__(*[self.head, *neck])\n\n        self.body = Group()\n        self.tail = neck[-1]\n\n    def update(self, *args: Any, **kwargs: Any) -> None:\n        self.head.update()\n\n        \n        segments = self.sprites()\n        for i in range(len(segments) - 1, 0, -1):\n            \n            segments[i].rect.center = segments[i - 1].rect.center\n\n    def change_direction(self, direction: Direction):\n        self.head.change_direction(direction)\n\n    def grow(self):\n        tail = SnakeBody(\n            size=self.segment_size,\n            position=self.tail.rect.center,\n            colour=next(self.colours),\n        )\n        self.tail = tail\n        self.add(self.tail)\n        self.body.add(self.tail)\n\n\nclass SnakeFood(Sprite):\n    def __init__(self, game: Game, size: int, *groups: AbstractGroup) -> None:\n        super().__init__(*groups)\n        self.image = Surface((size, size))\n        self.image.fill(Color(\"red\"))\n        self.rect = self.image.get_rect()\n\n        self.rect.topleft = (\n            random.randint(0, game.rect.width),\n            random.randint(0, game.rect.height),\n        )\n\n        self.rect.clamp_ip(game.rect)\n\n        \n        \n        while pg.sprite.spritecollideany(self, game.snake):\n            self.rect.topleft = (\n                random.randint(0, game.rect.width),\n                random.randint(0, game.rect.height),\n            )\n\n            self.rect.clamp_ip(game.rect)\n\n\nclass Game:\n    def __init__(self) -> None:\n        self.rect = Rect(0, 0, 640, 480)\n        self.background = Surface(self.rect.size)\n        self.background.fill(Color(\"black\"))\n\n        self.score = 0\n        self.framerate = 16\n\n        self.segment_size = 10\n        self.snake = Snake(self)\n        self.food_group = RenderUpdates(SnakeFood(game=self, size=self.segment_size))\n\n        pg.init()\n\n    def _init_display(self) -> Surface:\n        bestdepth = pg.display.mode_ok(self.rect.size, 0, 32)\n        screen = pg.display.set_mode(self.rect.size, 0, bestdepth)\n\n        pg.display.set_caption(\"Snake\")\n        pg.mouse.set_visible(False)\n\n        screen.blit(self.background, (0, 0))\n        pg.display.flip()\n\n        return screen\n\n    def draw(self, screen: Surface):\n        dirty = self.snake.draw(screen)\n        pg.display.update(dirty)\n\n        dirty = self.food_group.draw(screen)\n        pg.display.update(dirty)\n\n    def update(self, screen):\n        self.food_group.clear(screen, self.background)\n        self.food_group.update()\n        self.snake.clear(screen, self.background)\n        self.snake.update()\n\n    def main(self) -> int:\n        screen = self._init_display()\n        clock = pg.time.Clock()\n\n        while self.snake.head.alive():\n            for event in pg.event.get():\n                if event.type == pg.QUIT or (\n                    event.type == pg.KEYDOWN and event.key in (pg.K_ESCAPE, pg.K_q)\n                ):\n                    return self.score\n\n            \n            keystate = pg.key.get_pressed()\n\n            if keystate[pg.K_RIGHT]:\n                self.snake.change_direction(Direction.RIGHT)\n            elif keystate[pg.K_LEFT]:\n                self.snake.change_direction(Direction.LEFT)\n            elif keystate[pg.K_UP]:\n                self.snake.change_direction(Direction.UP)\n            elif keystate[pg.K_DOWN]:\n                self.snake.change_direction(Direction.DOWN)\n\n            \n            self.update(screen)\n\n            \n            for food in pg.sprite.spritecollide(\n                self.snake.head, self.food_group, dokill=False\n            ):\n                food.kill()\n                self.snake.grow()\n                self.score += 1\n\n                \n                if self.score % 5 == 0:\n                    self.framerate += 1\n\n                self.food_group.add(SnakeFood(self, self.segment_size))\n\n            \n            if pg.sprite.spritecollideany(self.snake.head, self.snake.body):\n                self.snake.head.kill()\n\n            self.draw(screen)\n            clock.tick(self.framerate)\n\n        return self.score\n\n\nif __name__ == \"__main__\":\n    game = Game()\n    score = game.main()\n    print(score)\n"}
{"id": 351125, "name": "Pascal's triangle_Puzzle", "source": "Translate Haskell to Python: puzzle = [[\"151\"],[\"\",\"\"],[\"40\",\"\",\"\"],[\"\",\"\",\"\",\"\"],[\"X\",\"11\",\"Y\",\"4\",\"Z\"]]\n", "target": "\n\n\n\n\n\n\n\ndef combine( snl, snr ):\n\n\tcl = {}\n\tif isinstance(snl, int):\n\t\tcl['1'] = snl\n\telif isinstance(snl, string):\n\t\tcl[snl] = 1\n\telse:\n\t\tcl.update( snl)\n\n\tif isinstance(snr, int):\n\t\tn = cl.get('1', 0)\n\t\tcl['1'] = n + snr\n\telif isinstance(snr, string):\n\t\tn = cl.get(snr, 0)\n\t\tcl[snr] = n + 1\n\telse:\n\t\tfor k,v in snr.items():\n\t\t\tn = cl.get(k, 0)\n\t\t\tcl[k] = n+v\n\treturn cl\n\n\ndef constrain(nsum, vn ):\n\tnn = {}\n\tnn.update(vn)\n\tn = nn.get('1', 0)\n\tnn['1'] = n - nsum\n\treturn nn\n\ndef makeMatrix( constraints ):\n\tvmap = set()\n\tfor c in constraints:\n\t\tvmap.update( c.keys())\n\tvmap.remove('1')\n\tnvars = len(vmap)\n\tvmap = sorted(vmap)\t\t\n\tmtx = []\n\tfor c in constraints:\n\t\trow = []\n\t\tfor vv in vmap:\n\t\t\trow.append(float(c.get(vv, 0)))\n\t\trow.append(-float(c.get('1',0)))\n\t\tmtx.append(row)\n\t\n\tif len(constraints) == nvars:\n\t\tprint 'System appears solvable'\n\telif len(constraints) < nvars:\n\t\tprint 'System is not solvable - needs more constraints.'\n\treturn mtx, vmap\n\n\ndef SolvePyramid( vl, cnstr ):\n\n\tvl.reverse()\n\tconstraints = [cnstr]\n\tlvls = len(vl)\n\tfor lvln in range(1,lvls):\n\t\tlvd = vl[lvln]\n\t\tfor k in range(lvls - lvln):\n\t\t\tsn = lvd[k]\n\t\t\tll = vl[lvln-1]\n\t\t\tvn = combine(ll[k], ll[k+1])\n\t\t\tif sn is None:\n\t\t\t\tlvd[k] = vn\n\t\t\telse:\n\t\t\t\tconstraints.append(constrain( sn, vn ))\n\n\tprint 'Constraint Equations:'\n\tfor cstr in constraints:\n\t\tfset = ('%d*%s'%(v,k) for k,v in cstr.items() )\n\t\tprint ' + '.join(fset), ' = 0'\n\n\tmtx,vmap = makeMatrix(constraints)\n\n\tMtxSolve(mtx)\n\n\td = len(vmap)\n\tfor j in range(d):\n\t\tprint vmap[j],'=', mtx[j][d]\n\n\ndef MtxSolve(mtx):\n\t\n\n\tmDim = len(mtx)\t\t\t\n\tfor j in range(mDim):\n\t\trw0= mtx[j]\n\t\tf = 1.0/rw0[j]\n\t\tfor k in range(j, mDim+1):\n\t\t\trw0[k] *= f\n\t\t\n\t\tfor l in range(1+j,mDim):\n\t\t\trwl = mtx[l]\n\t\t\tf = -rwl[j]\n\t\t\tfor k in range(j, mDim+1):\n\t\t\t\trwl[k] += f * rw0[k]\n\n\t\n\tfor j1 in range(1,mDim):\n\t\tj = mDim - j1\n\t\trw0= mtx[j]\n\t\tfor l in range(0, j):\n\t\t\trwl = mtx[l]\n\t\t\tf = -rwl[j]\n\t\t\trwl[j]    += f * rw0[j]\n\t\t\trwl[mDim] += f * rw0[mDim]\n\n\treturn mtx\n\n\np = [ [151], [None,None], [40,None,None], [None,None,None,None], ['X', 11, 'Y', 4, 'Z'] ]\naddlConstraint = { 'X':1, 'Y':-1, 'Z':1, '1':0 }\nSolvePyramid( p, addlConstraint)\n"}
{"id": 351126, "name": "Pascal's triangle_Puzzle", "source": "Translate Haskell to Python: puzzle = [[\"151\"],[\"\",\"\"],[\"40\",\"\",\"\"],[\"\",\"\",\"\",\"\"],[\"X\",\"11\",\"Y\",\"4\",\"Z\"]]\n", "target": "\n\n\n\n\n\n\n\ndef combine( snl, snr ):\n\n\tcl = {}\n\tif isinstance(snl, int):\n\t\tcl['1'] = snl\n\telif isinstance(snl, string):\n\t\tcl[snl] = 1\n\telse:\n\t\tcl.update( snl)\n\n\tif isinstance(snr, int):\n\t\tn = cl.get('1', 0)\n\t\tcl['1'] = n + snr\n\telif isinstance(snr, string):\n\t\tn = cl.get(snr, 0)\n\t\tcl[snr] = n + 1\n\telse:\n\t\tfor k,v in snr.items():\n\t\t\tn = cl.get(k, 0)\n\t\t\tcl[k] = n+v\n\treturn cl\n\n\ndef constrain(nsum, vn ):\n\tnn = {}\n\tnn.update(vn)\n\tn = nn.get('1', 0)\n\tnn['1'] = n - nsum\n\treturn nn\n\ndef makeMatrix( constraints ):\n\tvmap = set()\n\tfor c in constraints:\n\t\tvmap.update( c.keys())\n\tvmap.remove('1')\n\tnvars = len(vmap)\n\tvmap = sorted(vmap)\t\t\n\tmtx = []\n\tfor c in constraints:\n\t\trow = []\n\t\tfor vv in vmap:\n\t\t\trow.append(float(c.get(vv, 0)))\n\t\trow.append(-float(c.get('1',0)))\n\t\tmtx.append(row)\n\t\n\tif len(constraints) == nvars:\n\t\tprint 'System appears solvable'\n\telif len(constraints) < nvars:\n\t\tprint 'System is not solvable - needs more constraints.'\n\treturn mtx, vmap\n\n\ndef SolvePyramid( vl, cnstr ):\n\n\tvl.reverse()\n\tconstraints = [cnstr]\n\tlvls = len(vl)\n\tfor lvln in range(1,lvls):\n\t\tlvd = vl[lvln]\n\t\tfor k in range(lvls - lvln):\n\t\t\tsn = lvd[k]\n\t\t\tll = vl[lvln-1]\n\t\t\tvn = combine(ll[k], ll[k+1])\n\t\t\tif sn is None:\n\t\t\t\tlvd[k] = vn\n\t\t\telse:\n\t\t\t\tconstraints.append(constrain( sn, vn ))\n\n\tprint 'Constraint Equations:'\n\tfor cstr in constraints:\n\t\tfset = ('%d*%s'%(v,k) for k,v in cstr.items() )\n\t\tprint ' + '.join(fset), ' = 0'\n\n\tmtx,vmap = makeMatrix(constraints)\n\n\tMtxSolve(mtx)\n\n\td = len(vmap)\n\tfor j in range(d):\n\t\tprint vmap[j],'=', mtx[j][d]\n\n\ndef MtxSolve(mtx):\n\t\n\n\tmDim = len(mtx)\t\t\t\n\tfor j in range(mDim):\n\t\trw0= mtx[j]\n\t\tf = 1.0/rw0[j]\n\t\tfor k in range(j, mDim+1):\n\t\t\trw0[k] *= f\n\t\t\n\t\tfor l in range(1+j,mDim):\n\t\t\trwl = mtx[l]\n\t\t\tf = -rwl[j]\n\t\t\tfor k in range(j, mDim+1):\n\t\t\t\trwl[k] += f * rw0[k]\n\n\t\n\tfor j1 in range(1,mDim):\n\t\tj = mDim - j1\n\t\trw0= mtx[j]\n\t\tfor l in range(0, j):\n\t\t\trwl = mtx[l]\n\t\t\tf = -rwl[j]\n\t\t\trwl[j]    += f * rw0[j]\n\t\t\trwl[mDim] += f * rw0[mDim]\n\n\treturn mtx\n\n\np = [ [151], [None,None], [40,None,None], [None,None,None,None], ['X', 11, 'Y', 4, 'Z'] ]\naddlConstraint = { 'X':1, 'Y':-1, 'Z':1, '1':0 }\nSolvePyramid( p, addlConstraint)\n"}
{"id": 351127, "name": "Keyboard input_Flush the keyboard buffer", "source": "Translate Haskell to Python: import Control.Concurrent (threadDelay)\nimport Control.Monad (when)\nimport System.IO (hFlush, stdout)\nimport System.Posix\n\n\n\ntermFlush :: Fd -> IO ()\ntermFlush fd = do\n  isTerm <- queryTerminal fd\n  when isTerm $ discardData fd InputQueue\n\nmain :: IO ()\nmain = do\n  putStrLn \"Type some stuff...\\n\"\n  threadDelay $ 3 * 1000000\n  putStrLn \"\\n\\nOk, stop typing!\\n\"\n  threadDelay $ 2 * 1000000\n\n  termFlush stdInput\n\n  putStr \"\\n\\nType a line of text, ending with a newline: \"\n  hFlush stdout\n  line <- getLine\n  putStrLn $ \"You typed: \" ++ line\n  termFlush stdInput\n", "target": "def flush_input():\n    try:\n        import msvcrt\n        while msvcrt.kbhit():\n            msvcrt.getch()\n    except ImportError:\n        import sys, termios\n        termios.tcflush(sys.stdin, termios.TCIOFLUSH)\n"}
{"id": 351128, "name": "Fractal tree", "source": "Translate Haskell to Python: import Graphics.Gloss\n\ntype Model = [Picture -> Picture]\n       \nfractal :: Int -> Model -> Picture -> Picture\nfractal n model pict = pictures $ take n $ iterate (mconcat model) pict\n\ntree1 _ = fractal 10 branches $ Line [(0,0),(0,100)]\n  where branches = [ Translate 0 100 . Scale 0.75 0.75 . Rotate 30 \n                   , Translate 0 100 . Scale 0.5 0.5 . Rotate (-30) ]\n\nmain = animate (InWindow \"Tree\" (800, 800) (0, 0)) white $ tree1 . (* 60)\n", "target": "def setup():\n    size(600, 600)\n    background(0)\n    stroke(255)\n    drawTree(300, 550, 9)\n    \ndef drawTree(x, y, depth):\n    fork_ang = radians(20)\n    base_len = 10\n    if depth > 0:\n        pushMatrix()\n        translate(x, y - baseLen * depth)\n        line(0, baseLen * depth, 0, 0)  \n        rotate(fork_ang)\n        drawTree(0, 0, depth - 1)  \n        rotate(2 * -fork_ang)\n        drawTree(0, 0, depth - 1) \n        popMatrix()\n"}
{"id": 351129, "name": "Rock-paper-scissors", "source": "Translate Haskell to Python: import System.Random (randomRIO)\n\ndata Choice\n  = Rock\n  | Paper\n  | Scissors\n  deriving (Show, Eq)\n\nbeats :: Choice -> Choice -> Bool\nbeats Paper Rock = True\nbeats Scissors Paper = True\nbeats Rock Scissors = True\nbeats _ _ = False\n\ngenrps :: (Int, Int, Int) -> IO Choice\ngenrps (r, p, s) = rps <$> rand\n  where\n    rps x\n      | x <= s = Rock\n      | x <= s + r = Paper\n      | otherwise = Scissors\n    rand = randomRIO (1, r + p + s) :: IO Int\n\ngetrps :: IO Choice\ngetrps = rps <$> getLine\n  where\n    rps \"scissors\" = Scissors\n    rps \"rock\" = Rock\n    rps \"paper\" = Paper\n    rps _ = error \"invalid input\"\n\ngame :: (Int, Int, Int) -> IO a\ngame (r, p, s) = do\n  putStrLn \"rock, paper or scissors?\"\n  h <- getrps\n  c <- genrps (r, p, s)\n  putStrLn (\"Player: \" ++ show h ++ \" Computer: \" ++ show c)\n  putStrLn\n    (if beats h c\n       then \"player wins\\n\"\n       else if beats c h\n              then \"player loses\\n\"\n              else \"draw\\n\")\n  let rr =\n        if h == Rock\n          then r + 1\n          else r\n      pp =\n        if h == Paper\n          then p + 1\n          else p\n      ss =\n        if h == Scissors\n          then s + 1\n          else s\n  game (rr, pp, ss)\n\nmain :: IO a\nmain = game (1, 1, 1)\n", "target": "from random import choice\n\nrules = {'rock': 'paper', 'scissors': 'rock', 'paper': 'scissors'}\nprevious = ['rock', 'paper', 'scissors']\n\nwhile True:\n    human = input('\\nchoose your weapon: ')\n    computer = rules[choice(previous)]  \n\n    if human in ('quit', 'exit'): break\n\n    elif human in rules:\n        previous.append(human)\n        print('the computer played', computer, end='; ')\n\n        if rules[computer] == human:  \n            print('yay you win!')\n        elif rules[human] == computer:  \n            print('the computer beat you...\u00a0:(')\n        else: print(\"it's a tie!\")\n\n    else: print(\"that's not a valid choice\")\n"}
{"id": 351130, "name": "Benford's law", "source": "Translate Haskell to Python: import qualified Data.Map as M\nimport Data.Char (digitToInt)\n\nfstdigit :: Integer -> Int\nfstdigit = digitToInt . head . show\n\nn = 1000 :: Int\n\nfibs = 1 : 1 : zipWith (+) fibs (tail fibs)\n\nfibdata = map fstdigit $ take n fibs\n\nfreqs = M.fromListWith (+) $ zip fibdata (repeat 1)\n\ntab :: [(Int, Double, Double)]\ntab =\n  [ ( d\n    , fromIntegral (M.findWithDefault 0 d freqs) / fromIntegral n\n    , logBase 10.0 $ 1 + 1 / fromIntegral d)\n  | d <- [1 .. 9] ]\n\nmain = print tab\n", "target": "from __future__ import division\nfrom itertools import islice, count\nfrom collections import Counter\nfrom math import log10\nfrom random import randint\n\nexpected = [log10(1+1/d) for d in range(1,10)]\n\ndef fib():\n    a,b = 1,1\n    while True:\n        yield a\n        a,b = b,a+b\n\n\ndef power_of_threes():\n    return (3**k for k in count(0))\n\ndef heads(s):\n    for a in s: yield int(str(a)[0])\n\ndef show_dist(title, s):\n    c = Counter(s)\n    size = sum(c.values())\n    res = [c[d]/size for d in range(1,10)]\n\n    print(\"\\n%s Benfords deviation\" % title)\n    for r, e in zip(res, expected):\n        print(\"%5.1f%% %5.1f%%  %5.1f%%\" % (r*100., e*100., abs(r - e)*100.))\n\ndef rand1000():\n    while True: yield randint(1,9999)\n\nif __name__ == '__main__':\n    show_dist(\"fibbed\", islice(heads(fib()), 1000))\n    show_dist(\"threes\", islice(heads(power_of_threes()), 1000))\n\n    \n    show_dist(\"random\", islice(heads(rand1000()), 10000))\n"}
{"id": 351131, "name": "Benford's law", "source": "Translate Haskell to Python: import qualified Data.Map as M\nimport Data.Char (digitToInt)\n\nfstdigit :: Integer -> Int\nfstdigit = digitToInt . head . show\n\nn = 1000 :: Int\n\nfibs = 1 : 1 : zipWith (+) fibs (tail fibs)\n\nfibdata = map fstdigit $ take n fibs\n\nfreqs = M.fromListWith (+) $ zip fibdata (repeat 1)\n\ntab :: [(Int, Double, Double)]\ntab =\n  [ ( d\n    , fromIntegral (M.findWithDefault 0 d freqs) / fromIntegral n\n    , logBase 10.0 $ 1 + 1 / fromIntegral d)\n  | d <- [1 .. 9] ]\n\nmain = print tab\n", "target": "from __future__ import division\nfrom itertools import islice, count\nfrom collections import Counter\nfrom math import log10\nfrom random import randint\n\nexpected = [log10(1+1/d) for d in range(1,10)]\n\ndef fib():\n    a,b = 1,1\n    while True:\n        yield a\n        a,b = b,a+b\n\n\ndef power_of_threes():\n    return (3**k for k in count(0))\n\ndef heads(s):\n    for a in s: yield int(str(a)[0])\n\ndef show_dist(title, s):\n    c = Counter(s)\n    size = sum(c.values())\n    res = [c[d]/size for d in range(1,10)]\n\n    print(\"\\n%s Benfords deviation\" % title)\n    for r, e in zip(res, expected):\n        print(\"%5.1f%% %5.1f%%  %5.1f%%\" % (r*100., e*100., abs(r - e)*100.))\n\ndef rand1000():\n    while True: yield randint(1,9999)\n\nif __name__ == '__main__':\n    show_dist(\"fibbed\", islice(heads(fib()), 1000))\n    show_dist(\"threes\", islice(heads(power_of_threes()), 1000))\n\n    \n    show_dist(\"random\", islice(heads(rand1000()), 10000))\n"}
{"id": 351132, "name": "Hickerson series of almost integers", "source": "Translate Haskell to Python: import Data.Number.CReal \n\nimport qualified Data.Number.CReal as C\n\nhickerson :: Int -> C.CReal\nhickerson n = (fromIntegral $ product [1..n]) / (2 * (log 2 ^ (n + 1)))\n\ncharAfter :: Char -> String -> Char\ncharAfter ch string = ( dropWhile (/= ch) string ) !! 1\n\nisAlmostInteger :: C.CReal -> Bool\nisAlmostInteger = (`elem` ['0', '9']) . charAfter '.' . show\n\ncheckHickerson :: Int -> String\ncheckHickerson n  = show $ (n, hickerson n, isAlmostInteger $ hickerson n)\n\nmain :: IO ()\nmain = mapM_ putStrLn $ map checkHickerson [1..18]\n", "target": "from decimal import Decimal\nimport math\n\ndef h(n):\n    'Simple, reduced precision calculation'\n    return math.factorial(n) / (2 * math.log(2) ** (n + 1))\n    \ndef h2(n):\n    'Extended precision Hickerson function'\n    return Decimal(math.factorial(n)) / (2 * Decimal(2).ln() ** (n + 1))\n\nfor n in range(18):\n    x = h2(n)\n    norm = str(x.normalize())\n    almostinteger = (' Nearly integer' \n                     if 'E' not in norm and ('.0' in norm or '.9' in norm) \n                     else ' NOT nearly integer!')\n    print('n:%2i h:%s%s' % (n, norm, almostinteger))\n"}
{"id": 351133, "name": "Hickerson series of almost integers", "source": "Translate Haskell to Python: import Data.Number.CReal \n\nimport qualified Data.Number.CReal as C\n\nhickerson :: Int -> C.CReal\nhickerson n = (fromIntegral $ product [1..n]) / (2 * (log 2 ^ (n + 1)))\n\ncharAfter :: Char -> String -> Char\ncharAfter ch string = ( dropWhile (/= ch) string ) !! 1\n\nisAlmostInteger :: C.CReal -> Bool\nisAlmostInteger = (`elem` ['0', '9']) . charAfter '.' . show\n\ncheckHickerson :: Int -> String\ncheckHickerson n  = show $ (n, hickerson n, isAlmostInteger $ hickerson n)\n\nmain :: IO ()\nmain = mapM_ putStrLn $ map checkHickerson [1..18]\n", "target": "from decimal import Decimal\nimport math\n\ndef h(n):\n    'Simple, reduced precision calculation'\n    return math.factorial(n) / (2 * math.log(2) ** (n + 1))\n    \ndef h2(n):\n    'Extended precision Hickerson function'\n    return Decimal(math.factorial(n)) / (2 * Decimal(2).ln() ** (n + 1))\n\nfor n in range(18):\n    x = h2(n)\n    norm = str(x.normalize())\n    almostinteger = (' Nearly integer' \n                     if 'E' not in norm and ('.0' in norm or '.9' in norm) \n                     else ' NOT nearly integer!')\n    print('n:%2i h:%s%s' % (n, norm, almostinteger))\n"}
{"id": 351134, "name": "Read a configuration file", "source": "Translate Haskell to Python: import Data.Char\nimport Data.List\nimport Data.List.Split\n\nmain :: IO ()\nmain = readFile \"config\" >>= (print . parseConfig)\n\nparseConfig :: String -> Config\nparseConfig = foldr addConfigValue defaultConfig . clean . lines\n    where clean = filter (not . flip any [\"#\", \";\", \"\", \" \"] . (==) . take 1)\n          \naddConfigValue :: String -> Config -> Config\naddConfigValue raw config = case key of\n    \"fullname\"       -> config {fullName      = values}\n    \"favouritefruit\" -> config {favoriteFruit = values}\n    \"needspeeling\"   -> config {needsPeeling  = True}\n    \"seedsremoved\"   -> config {seedsRemoved  = True}\n    \"otherfamily\"    -> config {otherFamily   = splitOn \",\" values}\n    _                -> config\n    where (k, vs) = span (/= ' ') raw\n          key = map toLower k\n          values = tail vs\n\ndata Config = Config\n    { fullName      :: String\n    , favoriteFruit :: String\n    , needsPeeling  :: Bool\n    , seedsRemoved  :: Bool\n    , otherFamily   :: [String]\n    } deriving (Show)\n\ndefaultConfig :: Config\ndefaultConfig = Config \"\" \"\" False False []\n", "target": "def readconf(fn):\n    ret = {}\n    with file(fn) as fp:\n        for line in fp:\n            \n            line = line.strip()\n            if not line or line.startswith('\n            \n            boolval = True\n            \n            if line.startswith(';'):\n                \n                line = line.lstrip(';')\n                \n                if len(line.split()) != 1: continue\n                boolval = False\n            \n            bits = line.split(None, 1)\n            if len(bits) == 1:\n                \n                k = bits[0]\n                v = boolval\n            else:\n                \n                k, v = bits\n            ret[k.lower()] = v\n    return ret\n\n\nif __name__ == '__main__':\n    import sys\n    conf = readconf(sys.argv[1])\n    for k, v in sorted(conf.items()):\n        print k, '=', v\n"}
{"id": 351135, "name": "Kronecker product based fractals", "source": "Translate Haskell to Python: \nimport Reflex\nimport Reflex.Dom\nimport Data.Map as DM (Map, fromList)\nimport Data.Text (Text, pack)\nimport Data.List (transpose)\n\n\nmain :: IO ()\nmain = mainWidget $ do \n  elAttr \"h1\" (\"style\" =: \"color:black\") $ text \"Kroneker Product Based Fractals\" \n  elAttr \"a\" (\"href\" =: \"http://rosettacode.org/wiki/Kronecker_product_based_fractals#Haskell\") $ text \"Rosetta Code / Kroneker product based fractals / Haskell\"\n\n  \n  el \"br\" $ return ()\n  elAttr \"h2\" (\"style\" =: \"color:brown\") $ text \"Vicsek Fractal\" \n  showFractal [[0, 1, 0] ,[1, 1, 1] ,[0, 1, 0] ]\n\n  \n  el \"br\" $ return ()\n  elAttr \"h2\" (\"style\" =: \"color:brown\") $ text \"Sierpinski Carpet Fractal\" \n  showFractal [[1, 1, 1] ,[1, 0, 1] ,[1, 1, 1] ]\n\n\ncellSize :: Int\ncellSize = 8\n\n\nshowFractal :: MonadWidget t m => [[Int]] -> m ()\nshowFractal seed = do\n  let boardAttrs w h = \n         fromList [ (\"width\" , pack $ show $ w * cellSize)\n                  , (\"height\", pack $ show $ h * cellSize)\n                  ]\n      fractals = iterate (kronekerProduct seed) seed\n      shown = fractals !! 3 \n      w = length $ head shown\n      h = length shown\n  elSvgns \"svg\" (constDyn $ boardAttrs w h) $ showMatrix shown\n\n\nkronekerProduct :: Num a => [[a]] -> [[a]] -> [[a]]\nkronekerProduct xs ys = \n    let m0 = flip $ fmap.fmap.(*)\n        m1 = flip $ fmap.fmap.m0\n    in concat $ fmap (fmap concat.transpose) $ m1 xs ys\n\n\nshowMatrix :: MonadWidget t m => [[Int]] -> m ()\nshowMatrix m = mapM_ showRow $ zip [0..] m \n\n\nshowRow :: MonadWidget t m => (Int,[Int]) -> m ()\nshowRow (x,r) = mapM_ (showCell x) $ zip [0..] r \n\n\nshowCell :: MonadWidget t m => Int -> (Int,Int) -> m ()\nshowCell x (y,on) = \n  let boxAttrs (x,y) = \n        fromList [ (\"transform\", \n                    pack $    \"scale (\" ++ show cellSize ++ \", \" ++ show cellSize ++ \") \" \n                           ++ \"translate (\" ++ show x ++ \", \" ++ show y ++ \")\" \n                   )\n                 ] \n\n      cellAttrs = \n        fromList [ ( \"cx\",      \"0.5\")\n                 , ( \"cy\",      \"0.5\")\n                 , ( \"r\",       \"0.45\")\n                 , ( \"style\",   \"fill:green\")\n                 ] \n\n  in if (on==1) then  \n       elSvgns \"g\"  (constDyn $ boxAttrs (x,y)) $ \n         elSvgns \"circle\" (constDyn $ cellAttrs) $ \n           return ()\n     else\n       return ()\n\n\nelSvgns :: MonadWidget t m => Text -> Dynamic t (Map Text Text) -> m a -> m a\nelSvgns t m ma = do\n    (el, val) <- elDynAttrNS' (Just \"http://www.w3.org/2000/svg\") t m ma\n    return val\n", "target": "import os\nfrom PIL import Image\n\n\ndef imgsave(path, arr):\n    w, h = len(arr), len(arr[0])\n    img = Image.new('1', (w, h))\n    for x in range(w):\n        for y in range(h):\n            img.putpixel((x, y), arr[x][y])\n    img.save(path)\n\n\ndef get_shape(mat):\n    return len(mat), len(mat[0])\n\n\ndef kron(matrix1, matrix2):\n    \n    final_list = []\n\n    count = len(matrix2)\n\n    for elem1 in matrix1:\n        for i in range(count):\n            sub_list = []\n            for num1 in elem1:\n                for num2 in matrix2[i]:\n                    sub_list.append(num1 * num2)\n            final_list.append(sub_list)\n\n    return final_list\n\n\ndef kronpow(mat):\n    \n    matrix = mat\n    while True:\n        yield matrix\n        matrix = kron(mat, matrix)\n\n\ndef fractal(name, mat, order=6):\n    \n    path = os.path.join('fractals', name)\n    os.makedirs(path, exist_ok=True)\n\n    fgen = kronpow(mat)\n    print(name)\n    for i in range(order):\n        p = os.path.join(path, f'{i}.jpg')\n        print('Calculating n =', i, end='\\t', flush=True)\n\n        mat = next(fgen)\n        imgsave(p, mat)\n\n        x, y = get_shape(mat)\n        print('Saved as', x, 'x', y, 'image', p)\n\n\ntest1 = [\n    [0, 1, 0],\n    [1, 1, 1],\n    [0, 1, 0]\n]\n\ntest2 = [\n    [1, 1, 1],\n    [1, 0, 1],\n    [1, 1, 1]\n]\n\ntest3 = [\n    [1, 0, 1],\n    [0, 1, 0],\n    [1, 0, 1]\n]\n\nfractal('test1', test1)\nfractal('test2', test2)\nfractal('test3', test3)\n"}
{"id": 351136, "name": "Additive primes", "source": "Translate Haskell to Python: import Data.List (unfoldr)\n\n\nprimes = 2 : sieve [3,5..]\n  where sieve (x:xs) = x : sieve (filter (\\y -> y `mod` x /= 0) xs)\n\n\nisPrime n = all (\\p -> n `mod` p /= 0) $ takeWhile (< sqrtN) primes\n  where sqrtN = round . sqrt . fromIntegral $ n\n\n\ndigits = unfoldr f\n  where f 0 = Nothing\n        f n = let (q, r) = divMod n 10 in Just (r,q)\n\n\nisAdditivePrime n = isPrime n && (isPrime . sum . digits) n\n", "target": "def is_prime(n: int) -> bool:\n    if n <= 3:\n        return n > 1\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i ** 2 <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef digit_sum(n: int) -> int:\n    sum = 0\n    while n > 0:\n        sum += n % 10\n        n //= 10\n    return sum\n\ndef main() -> None:\n    additive_primes = 0\n    for i in range(2, 500):\n        if is_prime(i) and is_prime(digit_sum(i)):\n            additive_primes += 1\n            print(i, end=\" \")\n    print(f\"\\nFound {additive_primes} additive primes less than 500\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 351137, "name": "Case-sensitivity of identifiers", "source": "Translate Haskell to Python: import Text.Printf\n\nmain = printf \"The three dogs are named %s, %s and %s.\\n\" dog dOG dOg\n    where dog = \"Benjamin\"\n          dOG = \"Samba\"\n          dOg = \"Bernie\"\n", "target": ">>> dog = 'Benjamin'; Dog = 'Samba'; DOG = 'Bernie'\n>>> print ('The three dogs are named ',dog,', ',Dog,', and ',DOG)\nThe three dogs are named  Benjamin ,  Samba , and  Bernie\n>>>\n"}
{"id": 351138, "name": "Extra primes", "source": "Translate Haskell to Python: import Data.Char ( digitToInt )\n\nisPrime :: Int -> Bool\nisPrime n \n   |n < 2 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n\ncondition :: Int -> Bool\ncondition n = isPrime n && all isPrime digits && isPrime ( sum digits )\n where\n  digits :: [Int]\n  digits = map digitToInt ( show n )\n\nsolution :: [Int]\nsolution = filter condition [1..9999]\n", "target": "from itertools import *\nfrom functools import reduce\n\nclass Sieve(object):\n    \n    def __init__(self):\n        self._primes = []\n        self._comps = {}\n        self._max = 2;\n    \n    def isprime(self, n):\n        \n        if n >= self._max: self._genprimes(n)\n        return n >= 2 and n in self._primes\n    \n    def _genprimes(self, max):\n        while self._max <= max:\n            if self._max not in self._comps:\n                self._primes.append(self._max)\n                self._comps[self._max*self._max] = [self._max]\n            else:\n                for p in self._comps[self._max]:\n                    ps = self._comps.setdefault(self._max+p, [])\n                    ps.append(p)\n                del self._comps[self._max]\n            self._max += 1\n                \ndef extra_primes():\n    \n    d = [2,3,5,7]\n    s = Sieve()\n    for cand in chain.from_iterable(product(d, repeat=r) for r in count(1)):\n        num = reduce(lambda x, y: x*10+y, cand)\n        if s.isprime(num) and s.isprime(sum(cand)): yield num\n        \nfor n in takewhile(lambda n: n < 10000, extra_primes()):\n    print(n)\n"}
{"id": 351139, "name": "Extra primes", "source": "Translate Haskell to Python: import Data.Char ( digitToInt )\n\nisPrime :: Int -> Bool\nisPrime n \n   |n < 2 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n\ncondition :: Int -> Bool\ncondition n = isPrime n && all isPrime digits && isPrime ( sum digits )\n where\n  digits :: [Int]\n  digits = map digitToInt ( show n )\n\nsolution :: [Int]\nsolution = filter condition [1..9999]\n", "target": "from itertools import *\nfrom functools import reduce\n\nclass Sieve(object):\n    \n    def __init__(self):\n        self._primes = []\n        self._comps = {}\n        self._max = 2;\n    \n    def isprime(self, n):\n        \n        if n >= self._max: self._genprimes(n)\n        return n >= 2 and n in self._primes\n    \n    def _genprimes(self, max):\n        while self._max <= max:\n            if self._max not in self._comps:\n                self._primes.append(self._max)\n                self._comps[self._max*self._max] = [self._max]\n            else:\n                for p in self._comps[self._max]:\n                    ps = self._comps.setdefault(self._max+p, [])\n                    ps.append(p)\n                del self._comps[self._max]\n            self._max += 1\n                \ndef extra_primes():\n    \n    d = [2,3,5,7]\n    s = Sieve()\n    for cand in chain.from_iterable(product(d, repeat=r) for r in count(1)):\n        num = reduce(lambda x, y: x*10+y, cand)\n        if s.isprime(num) and s.isprime(sum(cand)): yield num\n        \nfor n in takewhile(lambda n: n < 10000, extra_primes()):\n    print(n)\n"}
{"id": 351140, "name": "Abbreviations, easy", "source": "Translate Haskell to Python: import Data.Maybe (fromMaybe)\nimport Data.List (find, isPrefixOf)\nimport Data.Char (toUpper, isUpper)\n\nisAbbreviationOf :: String -> String -> Bool\nisAbbreviationOf abbreviation command =\n  minimumPrefix `isPrefixOf` normalizedAbbreviation\n  && normalizedAbbreviation `isPrefixOf` normalizedCommand\n  where\n    normalizedAbbreviation = map toUpper abbreviation\n    normalizedCommand = map toUpper command\n    minimumPrefix = takeWhile isUpper command\n\n\nexpandAbbreviation :: String -> String -> Maybe String\nexpandAbbreviation commandTable abbreviation = do\n  command <- find (isAbbreviationOf abbreviation) (words commandTable)\n  return $ map toUpper command\n\n\ncommandTable = unwords [\n  \"Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\",\n  \"COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\",\n  \"NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\",\n  \"Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\",\n  \"MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\",\n  \"READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\",\n  \"RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up\"]\n\n\nmain :: IO ()\nmain = do\n  input <- getLine\n  let abbreviations = words input\n  let commands = map (fromMaybe \"*error*\" . expandAbbreviation commandTable) abbreviations\n  putStrLn $ unwords results\n", "target": "command_table_text = \\\n\n\nuser_words = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\n\ndef find_abbreviations_length(command_table_text):\n    \n    command_table = dict()\n    for word in command_table_text.split():\n        abbr_len = sum(1 for c in word if c.isupper())\n        if abbr_len == 0:\n            abbr_len = len(word)\n        command_table[word] = abbr_len\n    return command_table\n\ndef find_abbreviations(command_table):\n    \n    abbreviations = dict()\n    for command, min_abbr_len in command_table.items():\n        for l in range(min_abbr_len, len(command)+1):\n            abbr = command[:l].lower()\n            abbreviations[abbr] = command.upper()\n    return abbreviations\n\ndef parse_user_string(user_string, abbreviations):\n    user_words = [word.lower() for word in user_string.split()]\n    commands = [abbreviations.get(user_word, \"*error*\") for user_word in user_words]\n    return \" \".join(commands)\n\ncommand_table = find_abbreviations_length(command_table_text)\nabbreviations_table = find_abbreviations(command_table)\n\nfull_words = parse_user_string(user_words, abbreviations_table)\n\nprint(\"user words:\", user_words)\nprint(\"full words:\", full_words)\n"}
{"id": 351141, "name": "Abbreviations, easy", "source": "Translate Haskell to Python: import Data.Maybe (fromMaybe)\nimport Data.List (find, isPrefixOf)\nimport Data.Char (toUpper, isUpper)\n\nisAbbreviationOf :: String -> String -> Bool\nisAbbreviationOf abbreviation command =\n  minimumPrefix `isPrefixOf` normalizedAbbreviation\n  && normalizedAbbreviation `isPrefixOf` normalizedCommand\n  where\n    normalizedAbbreviation = map toUpper abbreviation\n    normalizedCommand = map toUpper command\n    minimumPrefix = takeWhile isUpper command\n\n\nexpandAbbreviation :: String -> String -> Maybe String\nexpandAbbreviation commandTable abbreviation = do\n  command <- find (isAbbreviationOf abbreviation) (words commandTable)\n  return $ map toUpper command\n\n\ncommandTable = unwords [\n  \"Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\",\n  \"COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\",\n  \"NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\",\n  \"Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\",\n  \"MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\",\n  \"READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\",\n  \"RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up\"]\n\n\nmain :: IO ()\nmain = do\n  input <- getLine\n  let abbreviations = words input\n  let commands = map (fromMaybe \"*error*\" . expandAbbreviation commandTable) abbreviations\n  putStrLn $ unwords results\n", "target": "command_table_text = \\\n\n\nuser_words = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\n\ndef find_abbreviations_length(command_table_text):\n    \n    command_table = dict()\n    for word in command_table_text.split():\n        abbr_len = sum(1 for c in word if c.isupper())\n        if abbr_len == 0:\n            abbr_len = len(word)\n        command_table[word] = abbr_len\n    return command_table\n\ndef find_abbreviations(command_table):\n    \n    abbreviations = dict()\n    for command, min_abbr_len in command_table.items():\n        for l in range(min_abbr_len, len(command)+1):\n            abbr = command[:l].lower()\n            abbreviations[abbr] = command.upper()\n    return abbreviations\n\ndef parse_user_string(user_string, abbreviations):\n    user_words = [word.lower() for word in user_string.split()]\n    commands = [abbreviations.get(user_word, \"*error*\") for user_word in user_words]\n    return \" \".join(commands)\n\ncommand_table = find_abbreviations_length(command_table_text)\nabbreviations_table = find_abbreviations(command_table)\n\nfull_words = parse_user_string(user_words, abbreviations_table)\n\nprint(\"user words:\", user_words)\nprint(\"full words:\", full_words)\n"}
{"id": 351142, "name": "Common sorted list", "source": "Translate Haskell to Python: import Data.List (nub, sort)\n\n\n\ncommonSorted :: Ord a => [[a]] -> [a]\ncommonSorted = sort . nub . concat\n\n\nmain :: IO ()\nmain =\n  print $\n    commonSorted\n      [ [5, 1, 3, 8, 9, 4, 8, 7],\n        [3, 5, 9, 8, 4],\n        [1, 3, 7, 9]\n      ]\n", "target": "\n\nfrom itertools import chain\n\n\n\n\ndef main():\n    \n\n    print(\n        sorted(nub(concat([\n            [5, 1, 3, 8, 9, 4, 8, 7],\n            [3, 5, 9, 8, 4],\n            [1, 3, 7, 9]\n        ])))\n    )\n\n\n\n\n\n\ndef concat(xs):\n    \n    return list(chain(*xs))\n\n\n\ndef nub(xs):\n    \n    return list(dict.fromkeys(xs))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351143, "name": "Sorting algorithms_Stooge sort", "source": "Translate Haskell to Python: import Data.List\nimport Control.Arrow\nimport Control.Monad\n\ninsertAt e k = uncurry(++).second ((e:).drop 1). splitAt k\n\nswapElems :: [a] -> Int -> Int -> [a]\nswapElems xs i j = insertAt (xs!!j) i $ insertAt (xs!!i) j xs \n\t\nstoogeSort [] = []\nstoogeSort [x] = [x]\nstoogeSort xs = doss 0 (length xs - 1) xs\ndoss :: (Ord a) => Int -> Int -> [a] -> [a]\ndoss i j xs\n      | j-i>1 = doss i (j-t) $ doss (i+t) j $ doss i (j-t) xs'\n      | otherwise = xs'\n    where t = (j-i+1)`div`3\n\t  xs'\n\t    | xs!!j < xs!!i = swapElems xs i j\n\t    | otherwise = xs\n", "target": ">>> data = [1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7]\n>>> def stoogesort(L, i=0, j=None):\n\tif j is None:\n\t\tj = len(L) - 1\n\tif L[j] < L[i]:\n\t\tL[i], L[j] = L[j], L[i]\n\tif j - i > 1:\n\t\tt = (j - i + 1) // 3\n\t\tstoogesort(L, i  , j-t)\n\t\tstoogesort(L, i+t, j  )\n\t\tstoogesort(L, i  , j-t)\n\treturn L\n\n>>> stoogesort(data)\n[-6, -5, -3, -2, 1, 3, 3, 4, 5, 5, 7, 7, 7, 9, 10]\n"}
{"id": 351144, "name": "Truncate a file", "source": "Translate Haskell to Python: setFileSize :: FilePath -> FileOffset -> IO ()\n\n\n\n\n", "target": "def truncate_file(name, length):\n    if not os.path.isfile(name):\n        return False\n    if length >= os.path.getsize(name):\n        return False\n    with open(name, 'ab') as f:\n        f.truncate(length)\n    return True\n"}
{"id": 351145, "name": "Truncate a file", "source": "Translate Haskell to Python: setFileSize :: FilePath -> FileOffset -> IO ()\n\n\n\n\n", "target": "def truncate_file(name, length):\n    if not os.path.isfile(name):\n        return False\n    if length >= os.path.getsize(name):\n        return False\n    with open(name, 'ab') as f:\n        f.truncate(length)\n    return True\n"}
{"id": 351146, "name": "Sorting algorithms_Shell sort", "source": "Translate Haskell to Python: import Data.List\n\nshellSort xs = foldr (invColumnize (map (foldr insert []))) xs gaps\n  where gaps = takeWhile (< length xs) $ iterate (succ.(3*)) 1\n        invColumnize f k = concat. transpose. f. transpose\n                           . takeWhile (not.null). unfoldr (Just. splitAt k)\n", "target": "def shell(seq):\n    inc = len(seq) // 2\n    while inc:\n        for i, el in enumerate(seq[inc:], inc):\n            while i >= inc and seq[i - inc] > el:\n                seq[i] = seq[i - inc]\n                i -= inc\n            seq[i] = el\n        inc = 1 if inc == 2 else inc * 5 // 11\n"}
{"id": 351147, "name": "Formal power series", "source": "Translate Haskell to Python: newtype Series a = S { coeffs :: [a] } deriving (Eq, Show)\n\n\ninstance Num a => Num (Series a) where\n  fromInteger n = S $ fromInteger n : repeat 0\n  negate (S fs) = S $ map negate fs\n  S fs + S gs   = S $ zipWith (+) fs gs\n  S (f:ft) * S gs@(g:gt) = S $ f*g : coeffs (S ft * S gs + S (map (f*) gt))\n\ninstance Fractional a => Fractional (Series a) where\n  fromRational n = S $ fromRational n : repeat 0\n  S (f:ft) / S (g:gt) = S qs where qs = f/g : map (/g) (coeffs (S ft - S qs * S gt))\n\n\nfromFiniteList xs = S (xs ++ repeat 0)\n\nint (S fs) = S $ 0 : zipWith (/) fs [1..]\n\ndiff (S (_:ft)) = S $ zipWith (*) ft [1..]\n\nsinx,cosx :: Series Rational\nsinx = int cosx\ncosx = 1 - int sinx\n\nfiboS = 1 / fromFiniteList [1,-1,-1]\n", "target": "\n\nfrom itertools import islice\nfrom fractions import Fraction\nfrom functools import reduce\ntry:\n    from itertools import izip as zip \nexcept:\n    pass\n\ndef head(n):\n    \n    return lambda seq: islice(seq, n)\n\ndef pipe(gen, *cmds):\n    \n    return reduce(lambda gen, cmd: cmd(gen), cmds, gen)\n\ndef sinepower():\n    n = 0\n    fac = 1\n    sign = +1\n    zero = 0\n    yield zero\n    while True:\n        n +=1\n        fac *= n\n        yield Fraction(1, fac*sign)\n        sign = -sign\n        n +=1\n        fac *= n\n        yield zero\ndef cosinepower():\n    n = 0\n    fac = 1\n    sign = +1\n    yield Fraction(1,fac)\n    zero = 0\n    while True:\n        n +=1\n        fac *= n\n        yield zero\n        sign = -sign\n        n +=1\n        fac *= n\n        yield Fraction(1, fac*sign)\ndef pluspower(*powergenerators):\n    for elements in zip(*powergenerators):\n        yield sum(elements)\ndef minuspower(*powergenerators):\n    for elements in zip(*powergenerators):\n        yield elements[0] - sum(elements[1:])\ndef mulpower(fgen,ggen):\n    'From: http://en.wikipedia.org/wiki/Power_series\n    a,b = [],[]\n    for f,g in zip(fgen, ggen):\n        a.append(f)\n        b.append(g)\n        yield sum(f*g for f,g in zip(a, reversed(b)))\ndef constpower(n):\n    yield n\n    while True:\n        yield 0\ndef diffpower(gen):\n    'differentiatiate power series'\n    next(gen)\n    for n, an in enumerate(gen, start=1):\n        yield an*n\ndef intgpower(k=0):\n    'integrate power series with constant k'\n    def _intgpower(gen):\n        yield k\n        for n, an in enumerate(gen, start=1):\n            yield an * Fraction(1,n)\n    return _intgpower\n\n\nprint(\"cosine\")\nc = list(pipe(cosinepower(), head(10)))\nprint(c)\nprint(\"sine\")\ns = list(pipe(sinepower(), head(10)))\nprint(s)\n\nintegc = list(pipe(cosinepower(),intgpower(0), head(10)))\n\nintegs1 = list(minuspower(pipe(constpower(1), head(10)),\n                          pipe(sinepower(),intgpower(0), head(10))))\n\nassert s == integc, \"The integral of cos should be sin\"\nassert c == integs1, \"1 minus the integral of sin should be cos\"\n"}
{"id": 351148, "name": "Deconvolution_1D", "source": "Translate Haskell to Python: deconv1d :: [Double] -> [Double] -> [Double]\ndeconv1d xs ys = takeWhile (/= 0) $ deconv xs ys\n  where\n    [] `deconv` _ = []\n    (0:xs) `deconv` (0:ys) = xs `deconv` ys\n    (x:xs) `deconv` (y:ys) =\n      let q = x / y\n      in q : zipWith (-) xs (scale q ys ++ repeat 0) `deconv` (y : ys)\n\nscale :: Double -> [Double] -> [Double]\nscale = map . (*)\n\nh, f, g :: [Double]\nh = [-8, -9, -3, -1, -6, 7]\n\nf = [-3, -6, -1, 8, -6, 3, -1, -9, -9, 3, -2, 5, 2, -2, -7, -1]\n\ng =\n  [ 24\n  , 75\n  , 71\n  , -34\n  , 3\n  , 22\n  , -45\n  , 23\n  , 245\n  , 25\n  , 52\n  , 25\n  , -67\n  , -96\n  , 96\n  , 31\n  , 55\n  , 36\n  , 29\n  , -43\n  , -7\n  ]\n\nmain :: IO ()\nmain = print $ (h == deconv1d g f) && (f == deconv1d g h)\n", "target": "def ToReducedRowEchelonForm( M ):\n    if not M: return\n    lead = 0\n    rowCount = len(M)\n    columnCount = len(M[0])\n    for r in range(rowCount):\n        if lead >= columnCount:\n            return\n        i = r\n        while M[i][lead] == 0:\n            i += 1\n            if i == rowCount:\n                i = r\n                lead += 1\n                if columnCount == lead:\n                    return\n        M[i],M[r] = M[r],M[i]\n        lv = M[r][lead]\n        M[r] = [ mrx / lv for mrx in M[r]]\n        for i in range(rowCount):\n            if i != r:\n                lv = M[i][lead]\n                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]\n        lead += 1\n    return M\n \ndef pmtx(mtx):\n    print ('\\n'.join(''.join(' %4s' % col for col in row) for row in mtx))\n \ndef convolve(f, h):\n    g = [0] * (len(f) + len(h) - 1)\n    for hindex, hval in enumerate(h):\n        for findex, fval in enumerate(f):\n            g[hindex + findex] += fval * hval\n    return g\n\ndef deconvolve(g, f):\n    lenh = len(g) - len(f) + 1\n    mtx = [[0 for x in range(lenh+1)] for y in g]\n    for hindex in range(lenh):\n        for findex, fval in enumerate(f):\n            gindex = hindex + findex\n            mtx[gindex][hindex] = fval\n    for gindex, gval in enumerate(g):        \n        mtx[gindex][lenh] = gval\n    ToReducedRowEchelonForm( mtx )\n    return [mtx[i][lenh] for i in range(lenh)]  \n\nif __name__ == '__main__':\n    h = [-8,-9,-3,-1,-6,7]\n    f = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]\n    g = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]\n    assert convolve(f,h) == g\n    assert deconvolve(g, f) == h\n"}
{"id": 351149, "name": "Read a specific line from a file", "source": "Translate Haskell to Python: main :: IO ()\nmain = do contents <- readFile filename\n          case drop 6 $ lines contents of\n            []  -> error \"File has less than seven lines\"\n            l:_ -> putStrLn l\n  where filename = \"testfile\"\n", "target": "with open('xxx.txt') as f:\n    for i, line in enumerate(f):\n        if i == 6:\n            break\n    else:\n        print('Not 7 lines in file')\n        line = None\n"}
{"id": 351150, "name": "Read a specific line from a file", "source": "Translate Haskell to Python: main :: IO ()\nmain = do contents <- readFile filename\n          case drop 6 $ lines contents of\n            []  -> error \"File has less than seven lines\"\n            l:_ -> putStrLn l\n  where filename = \"testfile\"\n", "target": "with open('xxx.txt') as f:\n    for i, line in enumerate(f):\n        if i == 6:\n            break\n    else:\n        print('Not 7 lines in file')\n        line = None\n"}
{"id": 351151, "name": "Find prime n such that reversed n is also prime", "source": "Translate Haskell to Python: import Data.List (intercalate, transpose)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes (isPrime, primes)\nimport Text.Printf (printf)\n\n\n\np :: Int -> Bool\np n = isPrime (read (reverse $ show n) :: Int)\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"Reversible primes below 500:\",\n      (table \" \" . chunksOf 10 . fmap show) $\n        takeWhile (< 500) (filter p primes)\n    ]\n\n\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let widths =\n        maximum . fmap length\n          <$> transpose rows\n   in unlines $\n        fmap\n          ( intercalate gap\n              . zipWith\n                ( printf\n                    . flip intercalate [\"%\", \"s\"]\n                    . show\n                )\n                widths\n          )\n          rows\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef isBackPrime(n):\n    if not isPrime(n):\n        return False\n    m = 0\n    while n:\n        m *= 10\n        m += n % 10\n        n //= 10\n    return isPrime(m)\n\nif __name__ == '__main__':\n    for n in range(2, 499):\n        if isBackPrime(n):\n            print(n, end=' ');\n"}
{"id": 351152, "name": "Find prime n such that reversed n is also prime", "source": "Translate Haskell to Python: import Data.List (intercalate, transpose)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes (isPrime, primes)\nimport Text.Printf (printf)\n\n\n\np :: Int -> Bool\np n = isPrime (read (reverse $ show n) :: Int)\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"Reversible primes below 500:\",\n      (table \" \" . chunksOf 10 . fmap show) $\n        takeWhile (< 500) (filter p primes)\n    ]\n\n\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let widths =\n        maximum . fmap length\n          <$> transpose rows\n   in unlines $\n        fmap\n          ( intercalate gap\n              . zipWith\n                ( printf\n                    . flip intercalate [\"%\", \"s\"]\n                    . show\n                )\n                widths\n          )\n          rows\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef isBackPrime(n):\n    if not isPrime(n):\n        return False\n    m = 0\n    while n:\n        m *= 10\n        m += n % 10\n        n //= 10\n    return isPrime(m)\n\nif __name__ == '__main__':\n    for n in range(2, 499):\n        if isBackPrime(n):\n            print(n, end=' ');\n"}
{"id": 351153, "name": "URL encoding", "source": "Translate Haskell to Python: import qualified Data.Char as Char\nimport Text.Printf\n\nencode :: Char -> String\nencode c\n  | c == ' ' = \"+\"\n  | Char.isAlphaNum c || c `elem` \"-._~\" = [c]\n  | otherwise = printf \"%%%02X\" c\n\nurlEncode :: String -> String\nurlEncode = concatMap encode\n\nmain :: IO ()\nmain = putStrLn $ urlEncode \"http://foo bar/\"\n", "target": "import urllib\ns = 'http://foo/bar/'\ns = urllib.quote(s)\n"}
{"id": 351154, "name": "URL encoding", "source": "Translate Haskell to Python: import qualified Data.Char as Char\nimport Text.Printf\n\nencode :: Char -> String\nencode c\n  | c == ' ' = \"+\"\n  | Char.isAlphaNum c || c `elem` \"-._~\" = [c]\n  | otherwise = printf \"%%%02X\" c\n\nurlEncode :: String -> String\nurlEncode = concatMap encode\n\nmain :: IO ()\nmain = putStrLn $ urlEncode \"http://foo bar/\"\n", "target": "import urllib\ns = 'http://foo/bar/'\ns = urllib.quote(s)\n"}
{"id": 351155, "name": "LU decomposition", "source": "Translate Haskell to Python: import Data.List\nimport Data.Maybe\nimport Text.Printf\n\n\nmmult :: Num a => [[a]] -> [[a]] -> [[a]] \nmmult a b = [ [ sum $ zipWith (*) ak bj | ak <- (transpose a) ] | bj <- b ]\n\nnth mA i j = (mA !! j) !! i\n\nidMatrixPart n m k = [ [if (i==j) then 1 else 0 | i <- [1..n]] | j <- [k..m]]\nidMatrix n = idMatrixPart n n 1\n\npermMatrix n ix1 ix2 =\n    [ [ if ((i==ix1 && j==ix2) || (i==ix2 && j==ix1) || (i==j && j /= ix1 && i /= ix2))\n        then 1 else 0| i <- [0..n-1]] | j <- [0..n-1]]\npermMatrix_inv n ix1 ix2 = permMatrix n ix2 ix1\n        \n\nelimColumn :: Int -> [[Rational]] -> Int -> [Rational]\nelimMatrix :: Int -> [[Rational]] -> Int -> [[Rational]]\nelimMatrix_inv :: Int -> [[Rational]] -> Int -> [[Rational]]\n\nelimColumn n mA k = [(let mAkk = (nth mA k k) in  if (i>k) then (-(nth mA i k)/mAkk)\n    else if (i==k) then 1 else 0) | i <- [0..n-1]]\nelimMatrix n mA k = (idMatrixPart n k 1) ++ [elimColumn n mA k] ++ (idMatrixPart n n (k+2))\nelimMatrix_inv n mA k = (idMatrixPart n k 1) ++ \n    [let c = (mA!!k) in [if (i==k) then 1 else if (i<k) then 0 else (-(c!!i)) | i <- [0..n-1]]]\n     ++ (idMatrixPart n n (k+2))\n\nswapIndx :: [[Rational]] -> Int -> Int\nswapIndx mA k = fromMaybe k (findIndex (>0) (drop k (mA!!k)))\n\n\npaStep_recP :: Int -> [[Rational]] -> [[Rational]] -> [[Rational]] -> Int -> [[[Rational]]]\npaStep_recM :: Int -> [[Rational]] -> [[Rational]] -> [[Rational]] -> Int -> [[[Rational]]]\nlupStep :: Int -> [[Rational]] -> [[[Rational]]]\n\npaStep_recP n mP mA mL cnt = \n    let mPt = permMatrix n cnt (swapIndx mA cnt) in \n        let mPtInv = permMatrix_inv n cnt (swapIndx mA cnt) in\n    if (cnt >= n) then [(mmult mP mL),mA,mP] else\n        (paStep_recM n (mmult mPt mP) (mmult mPt mA) (mmult mL mPtInv) cnt)\n\npaStep_recM n mP mA mL cnt =\n    let mMt = elimMatrix n mA cnt in\n        let mMtInv = elimMatrix_inv n mMt cnt in\n    paStep_recP n mP (mmult mMt mA) (mmult mL mMtInv) (cnt + 1)\n\nlupStep n mA = paStep_recP n (idMatrix n) mA (idMatrix n) 0\n\n\nmatrixFromRationalToString m = concat $ intersperse \"\\n\"\n    (map (\\x -> unwords $ printf \"%8.4f\" <$> (x::[Double])) \n        (transpose (matrixFromRational m))) where \n        matrixFromRational m = map (\\x -> map fromRational x) m\n\nsolveTask mY = let mLUP = lupStep (length mY) mY in\n    putStrLn (\"A: \\n\" ++ matrixFromRationalToString mY) >>\n    putStrLn (\"L: \\n\" ++ matrixFromRationalToString (mLUP!!0)) >>\n    putStrLn (\"U: \\n\" ++ matrixFromRationalToString (mLUP!!1)) >>\n    putStrLn (\"P: \\n\" ++ matrixFromRationalToString (mLUP!!2)) >>\n    putStrLn (\"Verify: PA\\n\" ++ matrixFromRationalToString (mmult (mLUP!!2) mY)) >>\n    putStrLn (\"Verify: LU\\n\" ++ matrixFromRationalToString (mmult (mLUP!!0) (mLUP!!1)))\n\nmY1 = [[1, 2, 1], [3, 4, 7], [5, 7, 0]] :: [[Rational]]\nmY2 = [[11, 1, 3, 2], [9, 5, 17, 5], [24, 2, 18, 7], [2, 6, 1, 1]] :: [[Rational]]\nmain = putStrLn \"Task1: \\n\" >> solveTask mY1 >>\n    putStrLn \"Task2: \\n\" >> solveTask mY2\n", "target": "from pprint import pprint\n\ndef matrixMul(A, B):\n    TB = zip(*B)\n    return [[sum(ea*eb for ea,eb in zip(a,b)) for b in TB] for a in A]\n\ndef pivotize(m):\n    \n    n = len(m)\n    ID = [[float(i == j) for i in xrange(n)] for j in xrange(n)]\n    for j in xrange(n):\n        row = max(xrange(j, n), key=lambda i: abs(m[i][j]))\n        if j != row:\n            ID[j], ID[row] = ID[row], ID[j]\n    return ID\n\ndef lu(A):\n    \n    n = len(A)\n    L = [[0.0] * n for i in xrange(n)]\n    U = [[0.0] * n for i in xrange(n)]\n    P = pivotize(A)\n    A2 = matrixMul(P, A)\n    for j in xrange(n):\n        L[j][j] = 1.0\n        for i in xrange(j+1):\n            s1 = sum(U[k][j] * L[i][k] for k in xrange(i))\n            U[i][j] = A2[i][j] - s1\n        for i in xrange(j, n):\n            s2 = sum(U[k][j] * L[i][k] for k in xrange(j))\n            L[i][j] = (A2[i][j] - s2) / U[j][j]\n    return (L, U, P)\n\na = [[1, 3, 5], [2, 4, 7], [1, 1, 0]]\nfor part in lu(a):\n    pprint(part, width=19)\n    print\nprint\nb = [[11,9,24,2],[1,5,2,6],[3,17,18,1],[2,5,7,1]]\nfor part in lu(b):\n    pprint(part)\n    print\n"}
{"id": 351156, "name": "Optional parameters", "source": "Translate Haskell to Python: \n\ndata SorterArgs = SorterArgs { cmp :: String, col :: Int, rev :: Bool } deriving Show\ndefSortArgs = SorterArgs \"lex\" 0 False\n\n\nsorter :: SorterArgs -> [[String]] -> [[String]]\nsorter (SorterArgs{..}) = case cmp of\n                            _ -> undefined\n\nmain = do\n    sorter defSortArgs{cmp = \"foo\", col=1, rev=True} [[]]\n    sorter defSortArgs{cmp = \"foo\"} [[]]\n    sorter defSortArgs [[]]\n    return ()\n", "target": ">>> def printtable(data):\n    for row in data:\n        print ' '.join('%-5s' % ('\"%s\"' % cell) for cell in row)\n\n        \n>>> import operator\n>>> def sorttable(table, ordering=None, column=0, reverse=False):\n    return sorted(table, cmp=ordering, key=operator.itemgetter(column), reverse=reverse)\n\n>>> data = [[\"a\", \"b\", \"c\"], [\"\", \"q\", \"z\"], [\"zap\", \"zip\", \"Zot\"]]\n>>> printtable(data)\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n\"zap\" \"zip\" \"Zot\"\n>>> printtable( sorttable(data) )\n\"\"    \"q\"   \"z\"  \n\"a\"   \"b\"   \"c\"  \n\"zap\" \"zip\" \"Zot\"\n>>> printtable( sorttable(data, column=2) )\n\"zap\" \"zip\" \"Zot\"\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n>>> printtable( sorttable(data, column=1) )\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n\"zap\" \"zip\" \"Zot\"\n>>> printtable( sorttable(data, column=1, reverse=True) )\n\"zap\" \"zip\" \"Zot\"\n\"\"    \"q\"   \"z\"  \n\"a\"   \"b\"   \"c\"  \n>>> printtable( sorttable(data, ordering=lambda a,b: cmp(len(b),len(a))) )\n\"zap\" \"zip\" \"Zot\"\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n>>>\n"}
{"id": 351157, "name": "Numeric error propagation", "source": "Translate Haskell to Python: data Error a = Error {value :: a, uncertainty :: a} deriving (Eq, Show)\n\ninstance (Floating a) => Num (Error a) where\n\tError a ua + Error b ub = Error (a + b) (sqrt (ua ^ 2 + ub ^ 2))\n\tnegate (Error a ua) = Error (negate a) ua\n\tError a ua * Error b ub = Error (a * b) (abs (a * b * sqrt ((ua / a) ^ 2 + (ub / b) ^ 2))) \n\tfromInteger a = Error (fromInteger a) 0\n\ninstance (Floating a) => Fractional (Error a) where\n\tfromRational a = Error (fromRational a) 0\n\tError a ua / Error b ub = Error (a / b) (abs (a / b * sqrt ((ua / a) ^ 2 + (ub / b) ^ 2))) \n\ninstance (Floating a) => Floating (Error a) where\n\tError a ua ** Error c 0 = Error (a ** c) (abs (ua * c * a**c / a))\n\nmain = print (sqrt ((x1 - x2) ** 2 + (y1 - y2) ** 2)) where \n\tx1 = Error 100 1.1\n\ty1 = Error 50 1.2\n\tx2 = Error 200 2.2\n\ty2 = Error 100 2.3\n", "target": "from collections import namedtuple\nimport math\n \nclass I(namedtuple('Imprecise', 'value, delta')):\n    'Imprecise type: I(value=0.0, delta=0.0)' \n \n    __slots__ = () \n \n    def __new__(_cls, value=0.0, delta=0.0):\n        'Defaults to 0.0 \u00b1 delta'\n        return super().__new__(_cls, float(value), abs(float(delta)))\n \n    def reciprocal(self):\n        return I(1. / self.value, self.delta / (self.value**2)) \n \n    def __str__(self):\n        'Shorter form of Imprecise as string'\n        return 'I(%g, %g)' % self\n \n    def __neg__(self):\n        return I(-self.value, self.delta)\n \n    def __add__(self, other):\n        if type(other) == I:\n            return I( self.value + other.value, (self.delta**2 + other.delta**2)**0.5 )\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value + c, self.delta)\n\n    def __sub__(self, other):\n        return self + (-other)\n \n    def __radd__(self, other):\n        return I.__add__(self, other)\n \n    def __mul__(self, other):\n        if type(other) == I:\n            \n            \n            a1,b1 = self\n            a2,b2 = other\n            f = a1 * a2\n            return I( f, f * ( (b1 / a1)**2 + (b2 / a2)**2 )**0.5 )\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value * c, self.delta * c)\n \n    def __pow__(self, other):\n        if type(other) == I:\n            return NotImplemented\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        f = self.value ** c\n        return I(f, f * c * (self.delta / self.value))\n \n    def __rmul__(self, other):\n        return I.__mul__(self, other)\n \n    def __truediv__(self, other):\n        if type(other) == I:\n            return self.__mul__(other.reciprocal())\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value / c, self.delta / c)\n \n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n \n    __div__, __rdiv__ = __truediv__, __rtruediv__\n \nImprecise = I\n\ndef distance(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    return ((x1 - x2)**2 + (y1 - y2)**2)**0.5\n \nx1 = I(100, 1.1)\nx2 = I(200, 2.2)\ny1 = I( 50, 1.2)\ny2 = I(100, 2.3)\n\np1, p2 = (x1, y1), (x2, y2)\nprint(\"Distance between points\\n  p1: %s\\n  and p2: %s\\n  = %r\" % (\n      p1, p2, distance(p1, p2)))\n"}
{"id": 351158, "name": "Trabb Pardo\u2013Knuth algorithm", "source": "Translate Haskell to Python: import Control.Monad (replicateM, mapM_)\n\nf :: Floating a => a -> a\nf x = sqrt (abs x) + 5 * x ** 3\n\nmain :: IO ()\nmain = do\n  putStrLn \"Enter 11 numbers for evaluation\"\n  x <- replicateM 11 readLn\n  mapM_\n    ((\\x ->\n         if x > 400\n           then putStrLn \"OVERFLOW\"\n           else print x) .\n     f) $\n    reverse x\n", "target": "Python 3.2.2 (default, Sep  4 2011, 09:51:08) [MSC v.1500 32 bit (Intel)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> def f(x): return abs(x) ** 0.5 + 5 * x**3\n\n>>> print(', '.join('%s:%s' % (x, v if v<=400 else \"TOO LARGE!\")\n\t           for x,v in ((y, f(float(y))) for y in input('\\nnumbers: ').strip().split()[:11][::-1])))\n\n11 numbers: 1 2 3 4 5 6 7 8 9 10 11\n11:TOO LARGE!, 10:TOO LARGE!, 9:TOO LARGE!, 8:TOO LARGE!, 7:TOO LARGE!, 6:TOO LARGE!, 5:TOO LARGE!, 4:322.0, 3:136.73205080756887, 2:41.41421356237309, 1:6.0\n>>>\n"}
{"id": 351159, "name": "Rate counter", "source": "Translate Haskell to Python: import Control.Monad\nimport Control.Concurrent\nimport Data.Time\n\ngetTime :: IO DiffTime\ngetTime = fmap utctDayTime getCurrentTime\n\naddSample :: MVar [a] -> a -> IO ()\naddSample q v = modifyMVar_ q (return . (v:))\n\ntimeit :: Int -> IO a -> IO [DiffTime]\ntimeit n task = do\n    samples <- newMVar []\n    forM_ [0..n] $ \\n -> do\n        t1 <- getTime\n        task\n        t2 <- getTime\n        addSample samples (t2 - t1)\n\n    readMVar samples\n\nmain = timeit 10 (threadDelay 1000000)\n", "target": "import subprocess\nimport time\n\nclass Tlogger(object):\n    def __init__(self):\n        self.counts = 0\n        self.tottime = 0.0\n        self.laststart = 0.0\n        self.lastreport = time.time()\n\n    def logstart(self):\n        self.laststart = time.time()\n\n    def logend(self):\n        self.counts +=1\n        self.tottime += (time.time()-self.laststart)\n        if (time.time()-self.lastreport)>5.0:   \n           self.report()\n\n    def report(self):\n        if ( self.counts > 4*self.tottime):\n            print \"Subtask execution rate: %f times/second\"% (self.counts/self.tottime);\n        else:\n            print \"Average execution time: %f seconds\"%(self.tottime/self.counts);\n        self.lastreport = time.time()\n\n\ndef taskTimer( n, subproc_args ):\n    logger = Tlogger()\n\n    for x in range(n):\n        logger.logstart()\n        p = subprocess.Popen(subproc_args)\n        p.wait()\n        logger.logend()\n    logger.report()\n\n\nimport timeit\nimport sys\n\ndef main( ):\n\n    \n    s = \n    timer = timeit.Timer(s)\n    rzlts = timer.repeat(5, 5000)\n    for t in rzlts:\n        print \"Time for 5000 executions of statement = \",t\n    \n    \n    print \"\n    print \"Command:\",sys.argv[2:]\n    print \"\"\n    for k in range(3):\n       taskTimer( int(sys.argv[1]), sys.argv[2:])\n\nmain()\n"}
{"id": 351160, "name": "EKG sequence convergence", "source": "Translate Haskell to Python: import Data.List (findIndex, isPrefixOf, tails)\nimport Data.Maybe (fromJust)\n\n\n\nseqEKGRec :: Int -> Int -> [Int] -> [Int]\nseqEKGRec _ 0 l = l\nseqEKGRec k n [] = seqEKGRec k (n - 2) [k, 1]\nseqEKGRec k n l@(h : t) =\n  seqEKGRec\n    k\n    (pred n)\n    ( head\n        ( filter\n            (((&&) . flip notElem l) <*> ((1 <) . gcd h))\n            [2 ..]\n        ) :\n      l\n    )\n\nseqEKG :: Int -> Int -> [Int]\nseqEKG k n = reverse (seqEKGRec k n [])\n\n\n\nmain :: IO ()\nmain =\n  mapM_\n    ( \\x ->\n        putStr \"EKG (\"\n          >> (putStr . show $ x)\n          >> putStr \") is \"\n          >> print (seqEKG x 20)\n    )\n    [2, 5, 7, 9, 10]\n    >> putStr \"EKG(5) and EKG(7) converge at \"\n    >> print\n      ( succ $\n          fromJust $\n            findIndex\n              (isPrefixOf (replicate 20 True))\n              ( tails\n                  ( zipWith\n                      (==)\n                      (seqEKG 7 80)\n                      (seqEKG 5 80)\n                  )\n              )\n      )\n", "target": "from itertools import count, islice, takewhile\nfrom math import gcd\n\ndef EKG_gen(start=2):\n    \n    c = count(start + 1)\n    last, so_far = start, list(range(2, start))\n    yield 1, []\n    yield last, []\n    while True:\n        for index, sf in enumerate(so_far):\n            if gcd(last, sf) > 1:\n                last = so_far.pop(index)\n                yield last, so_far[::]\n                break\n        else:\n            so_far.append(next(c))\n\ndef find_convergence(ekgs=(5,7)):\n    \"Returns the convergence point or zero if not found within the limit\"\n    ekg = [EKG_gen(n) for n in ekgs]\n    for e in ekg:\n        next(e)    \n    return 2 + len(list(takewhile(lambda state: not all(state[0] == s for  s in state[1:]),\n                                  zip(*ekg))))\n\nif __name__ == '__main__':\n    for start in 2, 5, 7, 9, 10:\n        print(f\"EKG({start}):\", str([n[0] for n in islice(EKG_gen(start), 10)])[1: -1])\n    print(f\"\\nEKG(5) and EKG(7) converge at term {find_convergence(ekgs=(5,7))}!\")\n"}
{"id": 351161, "name": "Dice game probabilities", "source": "Translate Haskell to Python: import Control.Monad (replicateM)\nimport Data.List (group, sort)\n\nsucceeds :: (Int, Int) -> (Int, Int) -> Double\nsucceeds p1 p2 =\n  sum\n    [ realToFrac (c1 * c2) / totalOutcomes\n    | (s1, c1) <- countSums p1 \n    , (s2, c2) <- countSums p2 \n    , s1 > s2 ]\n  where\n    totalOutcomes = realToFrac $ uncurry (^) p1 * uncurry (^) p2\n    countSums (nFaces, nDice) = f [1 .. nFaces]\n      where\n        f =\n          fmap (((,) . head) <*> (pred . length)) .\n          group . sort . fmap sum . replicateM nDice\n\nmain :: IO ()\nmain = do\n  print $ (4, 9) `succeeds` (6, 6)\n  print $ (10, 5) `succeeds` (7, 6)\n", "target": "from itertools import product\n\ndef gen_dict(n_faces, n_dice):\n    counts = [0] * ((n_faces + 1) * n_dice)\n    for t in product(range(1, n_faces + 1), repeat=n_dice):\n        counts[sum(t)] += 1\n    return counts, n_faces ** n_dice\n\ndef beating_probability(n_sides1, n_dice1, n_sides2, n_dice2):\n    c1, p1 = gen_dict(n_sides1, n_dice1)\n    c2, p2 = gen_dict(n_sides2, n_dice2)\n    p12 = float(p1 * p2)\n\n    return sum(p[1] * q[1] / p12\n               for p, q in product(enumerate(c1), enumerate(c2))\n               if p[0] > q[0])\n\nprint beating_probability(4, 9, 6, 6)\nprint beating_probability(10, 5, 7, 6)\n"}
{"id": 351162, "name": "Metronome", "source": "Translate Haskell to Python: import Control.Concurrent\nimport Control.Concurrent.MVar\nimport System.Process (runCommand)\n\n\n\n\ndata Beep = Stop | Hi | Low\n\ntype Pattern = [Beep]\n\ntype BeatsPerMinute = Int\n\nminute = 60000000 \n\n\n\npattern4_4 = [Hi, Low, Low, Low]\npattern2_4 = [Hi, Low]\npattern3_4 = [Hi, Low, Low]\npattern6_8 = [Hi, Low, Low, Low, Low, Low]\n\n\n\n\n\n\n\n\n\n\n\nbeep Stop = return ()\nbeep Hi = putChar 'H' >> runCommand \"aplay hi.wav &> /dev/null\" >> return ()\nbeep Low = putChar 'L' >> runCommand \"aplay low.wav &> /dev/null\" >> return ()\n\ntick :: MVar Pattern -> BeatsPerMinute -> IO ()\ntick b i = do\n    t <- readMVar b\n    case t of\n        [Stop] -> return ()\n        x -> do\n            mapM_ (\\v -> forkIO (beep v) >> threadDelay (minute `div` i)) t\n            tick b i\n\nmetronome :: Pattern -> BeatsPerMinute -> IO ()\nmetronome p i = do\n    putStrLn \"Press any key to stop the metronome.\"\n    b <- newMVar p\n    _ <- forkIO $ tick b i\n    _ <- getChar\n    putMVar b [Stop]\n", "target": "\nimport time\n\ndef main(bpm = 72, bpb = 4):\n    sleep = 60.0 / bpm\n    counter = 0\n    while True:\n        counter += 1\n        if counter % bpb:\n            print 'tick'\n        else:\n            print 'TICK'\n        time.sleep(sleep)\n        \n\n\nmain()\n"}
{"id": 351163, "name": "Sum of elements below main diagonal of matrix", "source": "Translate Haskell to Python: \n\nmatrixTriangle :: Bool -> [[a]] -> Either String [[a]]\nmatrixTriangle upper matrix\n  | upper = go drop id\n  | otherwise = go take pred\n  where\n    go f g\n      | isSquare matrix =\n        (Right . snd) $\n          foldr\n            (\\xs (n, rows) -> (pred n, f n xs : rows))\n            (g $ length matrix, [])\n            matrix\n      | otherwise = Left \"Defined only for a square matrix.\"\n\nisSquare :: [[a]] -> Bool\nisSquare rows = all ((n ==) . length) rows\n  where\n    n = length rows\n\n\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n    zipWith\n      ( flip ((<>) . (<> \" triangle:\\n\\t\"))\n          . either id (show . sum . concat)\n      )\n      ( [matrixTriangle] <*> [False, True]\n          <*> [ [ [1, 3, 7, 8, 10],\n                  [2, 4, 16, 14, 4],\n                  [3, 1, 9, 18, 11],\n                  [12, 14, 17, 18, 20],\n                  [7, 1, 3, 9, 5]\n                ]\n              ]\n      )\n      [\"Lower\", \"Upper\"]\n", "target": "from numpy import array, tril, sum\n\nA = [[1,3,7,8,10],\n    [2,4,16,14,4],\n    [3,1,9,18,11],\n    [12,14,17,18,20],\n    [7,1,3,9,5]]\n\nprint(sum(tril(A, -1)))   \n"}
{"id": 351164, "name": "Pythagoras tree", "source": "Translate Haskell to Python: mkBranches :: [(Float,Float)] -> [[(Float,Float)]]\nmkBranches [a, b, c, d] = let d  = 0.5 <*> (b <+> (-1 <*> a))\n                              l1 = d <+> orth d\n                              l2 = orth l1\n                    in\n                      [ [a <+> l2, b <+> (2 <*> l2), a <+> l1, a]\n                      , [a <+> (2 <*> l1), b <+> l1, b, b <+> l2] ]\n  where\n    (a, b) <+> (c, d) = (a+c, b+d)\n    n <*> (a, b) = (a*n, b*n)\n    orth (a, b) = (-b, a)\n", "target": "def setup():\n    size(800, 400)\n    background(255)\n    stroke(0, 255, 0)\n    tree(width / 2.3, height, width / 1.8, height, 10)\n\n\ndef tree(x1, y1, x2, y2, depth):\n    if depth <= 0: return\n    dx = (x2 - x1)\n    dy = (y1 - y2)\n\n    x3 = (x2 - dy)\n    y3 = (y2 - dx)\n    x4 = (x1 - dy)\n    y4 = (y1 - dx)\n    x5 = (x4 + 0.5 * (dx - dy))\n    y5 = (y4 - 0.5 * (dx + dy))\n\n    \n    beginShape()\n    fill(0.0, 255.0 / depth, 0.0)\n    vertex(x1, y1)\n    vertex(x2, y2)\n    vertex(x3, y3)\n    vertex(x4, y4)\n    vertex(x1, y1)\n    endShape()\n\n    \n    beginShape()\n    fill(0.0, 255.0 / depth, 0.0)\n    vertex(x3, y3)\n    vertex(x4, y4)\n    vertex(x5, y5)\n    vertex(x3, y3)\n    endShape()\n\n    tree(x4, y4, x5, y5, depth - 1)\n    tree(x5, y5, x3, y3, depth - 1)\n"}
{"id": 351165, "name": "Rep-string", "source": "Translate Haskell to Python: import Data.List (inits, maximumBy)\nimport Data.Maybe (fromMaybe)\n\nrepstring :: String -> Maybe String\n\nrepstring [] = Nothing\n\nrepstring [_] = Nothing\nrepstring xs\n  | any (`notElem` \"01\") xs = Nothing\n  | otherwise = longest xs\n  where\n    \n    lxs = length xs\n    \n    lq2 = lxs `quot` 2\n    \n    \n    subrepeat x = (x, take lxs $ concat $ repeat x)\n    \n    sndValid (_, ys) = ys == xs\n    \n    \n    possible = map subrepeat . take lq2 . tail . inits\n    \n    \n    valid = map fst . filter sndValid . possible\n    \n    compLength a b = compare (length a) (length b)\n    \n    \n    longest ys = case valid ys of\n      [] -> Nothing\n      zs -> Just $ maximumBy compLength zs\n\nmain :: IO ()\nmain =\n  mapM_ processIO examples\n  where\n    examples =\n      [ \"1001110011\",\n        \"1110111011\",\n        \"0010010010\",\n        \"1010101010\",\n        \"1111111111\",\n        \"0100101101\",\n        \"0100100\",\n        \"101\",\n        \"11\",\n        \"00\",\n        \"1\"\n      ]\n    process = fromMaybe \"Not a rep string\" . repstring\n    processIO xs = do\n      putStr (xs <> \": \")\n      putStrLn $ process xs\n", "target": "def is_repeated(text):\n    'check if the first part of the string is repeated throughout the string'\n    for x in range(len(text)//2, 0, -1):\n        if text.startswith(text[x:]): return x\n    return 0\n\nmatchstr = \nfor line in matchstr.split():\n    ln = is_repeated(line)\n    print('%r has a repetition length of %i i.e. %s' \n           % (line, ln, repr(line[:ln]) if ln else '*not* a rep-string'))\n"}
{"id": 351166, "name": "File size distribution", "source": "Translate Haskell to Python: \n\nimport           Control.Concurrent          (forkIO, setNumCapabilities)\nimport           Control.Concurrent.Chan     (Chan, newChan, readChan,\n                                              writeChan, writeList2Chan)\nimport           Control.Exception           (IOException, catch)\nimport           Control.Monad               (filterM, forever, join,\n                                              replicateM, replicateM_, (>=>))\nimport           Control.Parallel.Strategies (parTraversable, rseq, using,\n                                              withStrategy)\nimport           Data.Char                   (isDigit)\nimport           Data.List                   (find, sort)\nimport qualified Data.Map.Strict             as Map\nimport           GHC.Conc                    (getNumProcessors)\nimport           System.Directory            (doesDirectoryExist, doesFileExist,\n                                              listDirectory,\n                                              pathIsSymbolicLink)\nimport           System.Environment          (getArgs)\nimport           System.FilePath.Posix       ((</>))\nimport           System.IO                   (FilePath, IOMode (ReadMode),\n                                              hFileSize, hPutStrLn, stderr,\n                                              withFile)\nimport           Text.Printf                 (hPrintf, printf)\n\ndata Item = File FilePath Integer | Folder FilePath deriving (Show)\n\ntype FGKey = (Integer, Integer)\ntype FrequencyGroup = (FGKey, Integer)\ntype FrequencyGroups = Map.Map FGKey Integer\n\nnewFrequencyGroups :: FrequencyGroups\nnewFrequencyGroups = Map.empty\n\nfileSizes :: [Item] -> [Integer]\nfileSizes = foldr f [] where f (File _ n) acc = n:acc\n                             f _          acc = acc\n\nfolders :: [Item] -> [FilePath]\nfolders = foldr f [] where f (Folder p) acc = p:acc\n                           f _          acc = acc\n\ntotalBytes :: [Item] -> Integer\ntotalBytes = sum . fileSizes\n\ncounts :: [Item] -> (Integer, Integer)\ncounts = foldr (\\x (a, b) -> case x of File _ _ -> (succ a, b)\n                                       Folder _ -> (a, succ b)) (0, 0)\n\n\nfrequencyGroups :: Int             \n                -> [Integer]       \n                -> FrequencyGroups \nfrequencyGroups _ [] = newFrequencyGroups\nfrequencyGroups totalGroups xs\n  | length xs == 1 = Map.singleton (head xs, head xs) 1\n  | otherwise = foldr placeGroups newFrequencyGroups xs `using` parTraversable rseq\n  where\n    range = maximum xs - minimum xs\n    groupSize = succ $ ceiling $ realToFrac range / realToFrac totalGroups\n    groups = takeWhile (<=groupSize + maximum xs) $ iterate (+groupSize) 0\n    groupMinMax = zip groups (pred <$> tail groups)\n    findGroup n = find (\\(low, high) -> n >= low && n <= high)\n\n    incrementCount (Just n) = Just (succ n) \n    incrementCount Nothing  = Just 1        \n\n    placeGroups n fgMap = case findGroup n groupMinMax of\n      Just k  -> Map.alter incrementCount k fgMap\n      Nothing -> fgMap \n\nexpandGroups :: Int             \n             -> [Integer]       \n             -> Integer         \n             -> FrequencyGroups \nexpandGroups gsize fileSizes groupThreshold\n  | groupThreshold > 0 = loop 15 $ frequencyGroups gsize sortedFileSizes\n  | otherwise = frequencyGroups gsize sortedFileSizes\n  where\n    sortedFileSizes = sort fileSizes\n    loop 0 gs = gs \n    loop n gs | all (<= groupThreshold) $ Map.elems gs = gs\n              | otherwise = loop (pred n) (expand gs)\n\n    expand :: FrequencyGroups -> FrequencyGroups\n    expand = foldr f . withStrategy (parTraversable rseq) <*>\n      Map.mapWithKey groupsFromGroup . Map.filter (> groupThreshold)\n      where\n        f :: Maybe (FGKey, FrequencyGroups) \n          -> FrequencyGroups                \n          -> FrequencyGroups                \n        f (Just (k, fg)) acc = Map.union (Map.delete k acc) fg\n        f Nothing        acc = acc\n\n        groupsFromGroup\n          :: FGKey                          \n          -> Integer                        \n          -> Maybe (FGKey, FrequencyGroups) \n        groupsFromGroup (min, max) count\n          | length range > 1 = Just ((min, max), frequencyGroups gsize range)\n          | otherwise        = Nothing\n          where\n            range = filter (\\n -> n >= min && n <= max) sortedFileSizes\n\ndisplaySize :: Integer -> String\ndisplaySize n\n  |              n <= 2^10 = printf \"%8dB \" n\n  | n >= 2^10 && n <= 2^20 = display (2^10) \"KB\"\n  | n >= 2^20 && n <= 2^30 = display (2^20) \"MB\"\n  | n >= 2^30 && n <= 2^40 = display (2^30) \"GB\"\n  | n >= 2^40 && n <= 2^50 = display (2^40) \"TB\"\n  | otherwise = \"Too large!\"\n  where\n    display :: Double -> String -> String\n    display b = printf \"%7.2f%s \" (realToFrac n / b)\n\ndisplayFrequency :: Integer -> FrequencyGroup -> IO ()\ndisplayFrequency filesCount ((min, max), count) = do\n  printf \"%s <-> %s\" (displaySize min) (displaySize max)\n  printf \"=\u00a0%-10d %6.3f%%:\u00a0%-5s\\n\" count percentage bars\n  where\n    percentage :: Double\n    percentage = (realToFrac count / realToFrac filesCount) * 100\n    size = round percentage\n    bars | size == 0 = \"\u258d\"\n         | otherwise = replicate size '\u2588'\n\nfolderWorker :: Chan FilePath -> Chan [Item] -> IO ()\nfolderWorker folderChan resultItemsChan =\n  forever (readChan folderChan >>= collectItems >>= writeChan resultItemsChan)\n\ncollectItems :: FilePath -> IO [Item]\ncollectItems folderPath = catch tryCollect $ \\e -> do\n    hPrintf stderr \"Skipping: %s\\n\" $ show (e :: IOException)\n    pure []\n  where\n    tryCollect = (fmap (folderPath </>) <$> listDirectory folderPath) >>=\n      mapM (\\p -> doesDirectoryExist p >>=\n              \\case True  -> pure $ Folder p\n                    False -> File p <$> withFile p ReadMode hFileSize)\n\nparallelItemCollector :: FilePath -> IO [Item]\nparallelItemCollector folder = do\n  wCount <- getNumProcessors\n  setNumCapabilities wCount\n  printf \"Using %d worker threads\\n\" wCount\n  folderChan <- newChan\n  resultItemsChan <- newChan\n  replicateM_ wCount (forkIO $ folderWorker folderChan resultItemsChan)\n  loop folderChan resultItemsChan [Folder folder]\n  where\n    loop :: Chan FilePath -> Chan [Item] -> [Item] -> IO [Item]\n    loop folderChan resultItemsChan xs = do\n      regularFolders <- filterM (pathIsSymbolicLink >=> (pure . not)) $ folders xs\n      if null regularFolders then pure []\n      else do\n        writeList2Chan folderChan regularFolders\n        childItems <- replicateM (length regularFolders) (readChan resultItemsChan)\n        result <- mapM (loop folderChan resultItemsChan) childItems\n        pure (join childItems <> join result)\n\nparseArgs :: [String] -> Either String (FilePath, Int)\nparseArgs (x:y:xs)\n  | all isDigit y = Right (x, read y)\n  | otherwise     = Left \"Invalid frequency group size\"\nparseArgs (x:xs) = Right (x, 4)\nparseArgs _ = Right (\".\", 4)\n\nmain :: IO ()\nmain = parseArgs <$> getArgs >>= \\case\n    Left errorMessage -> hPutStrLn stderr errorMessage\n    Right (path, groupSize) -> do\n      items <- parallelItemCollector path\n      let (fileCount, folderCount) = counts items\n      printf \"Total files: %d\\nTotal folders: %d\\n\" fileCount folderCount\n      printf \"Total size: %s\\n\" $ displaySize $ totalBytes items\n      printf \"\\nDistribution:\\n\\n%9s  <-> %9s %7s\\n\" \"From\" \"To\" \"Count\"\n      putStrLn $ replicate 46 '-'\n      let results = expandGroups groupSize (fileSizes items) (groupThreshold fileCount)\n      mapM_ (displayFrequency fileCount) $ Map.assocs results\n  where\n    groupThreshold = round . (*0.25) . realToFrac\n", "target": "import sys, os\nfrom collections import Counter\n\ndef dodir(path):\n    global h\n\n    for name in os.listdir(path):\n        p = os.path.join(path, name)\n\n        if os.path.islink(p):\n            pass\n        elif os.path.isfile(p):\n            h[os.stat(p).st_size] += 1\n        elif os.path.isdir(p):\n            dodir(p)\n        else:\n            pass\n\ndef main(arg):\n    global h\n    h = Counter()\n    for dir in arg:\n        dodir(dir)\n\n    s = n = 0\n    for k, v in sorted(h.items()):\n        print(\"Size %d -> %d file(s)\" % (k, v))\n        n += v\n        s += k * v\n    print(\"Total %d bytes for %d files\" % (s, n))\n\nmain(sys.argv[1:])\n"}
{"id": 351167, "name": "Topswops", "source": "Translate Haskell to Python: import Data.List (permutations)\n\ntopswops :: Int -> Int\ntopswops n = maximum $ map tops $ permutations [1 .. n]\n  where\n    tops (1:_) = 0\n    tops xa@(x:_) = 1 + tops reordered\n      where\n        reordered = reverse (take x xa) ++ drop x xa\n\nmain =\n  mapM_ (putStrLn . ((++) <$> show <*> (\":\\t\" ++) . show . topswops)) [1 .. 10]\n", "target": ">>> from itertools import permutations\n>>> def f1(p):\n\ti = 0\n\twhile True:\n\t\tp0  = p[0]\n\t\tif p0 == 1: break\n\t\tp[:p0] = p[:p0][::-1]\n\t\ti  += 1\n\treturn i\n\n>>> def fannkuch(n):\n\treturn max(f1(list(p)) for p in permutations(range(1, n+1)))\n\n>>> for n in range(1, 11): print(n,fannkuch(n))\n\n1 0\n2 1\n3 2\n4 4\n5 7\n6 10\n7 16\n8 22\n9 30\n10 38\n>>>\n"}
{"id": 351168, "name": "Sequence_ smallest number greater than previous term with exactly n divisors", "source": "Translate Haskell to Python: import Text.Printf (printf)\n\nsequence_A069654 :: [(Int,Int)]\nsequence_A069654 = go 1 $ (,) <*> countDivisors <$> [1..]\n where go t ((n,c):xs) | c == t    = (t,n):go (succ t) xs\n                       | otherwise = go t xs\n       countDivisors n = foldr f 0 [1..floor $ sqrt $ realToFrac n]\n        where f x r | n `mod` x == 0 = if n `div` x == x then r+1 else r+2\n                    | otherwise      = r\n\nmain :: IO ()\nmain = mapM_ (uncurry $ printf \"a(%2d)=%5d\\n\") $ take 15 sequence_A069654\n", "target": "def divisors(n):\n    divs = [1]\n    for ii in range(2, int(n ** 0.5) + 3):\n        if n % ii == 0:\n            divs.append(ii)\n            divs.append(int(n / ii))\n    divs.append(n)\n    return list(set(divs))\n\n\ndef sequence(max_n=None):\n    previous = 0\n    n = 0\n    while True:\n        n += 1\n        ii = previous\n        if max_n is not None:\n            if n > max_n:\n                break\n        while True:\n            ii += 1\n            if len(divisors(ii)) == n:\n                yield ii\n                previous = ii\n                break\n\n\nif __name__ == '__main__':\n    for item in sequence(15):\n        print(item)\n"}
{"id": 351169, "name": "McNuggets problem", "source": "Translate Haskell to Python: import Data.Set (Set, fromList, member)\n\n\n\nmcNuggets :: Set Int\nmcNuggets =\n  let size = enumFromTo 0 . quot 100\n   in fromList $\n        size 6\n          >>= \\x ->\n            size 9\n              >>= \\y ->\n                size 20\n                  >>= \\z ->\n                    [ v\n                      | let v = sum [6 * x, 9 * y, 20 * z],\n                        101 > v\n                    ]\n\n\nmain :: IO ()\nmain =\n  (putStrLn . go) $\n    dropWhile (`member` mcNuggets) [100, 99 .. 1]\n  where\n    go (x : _) = show x\n    go [] = \"No unreachable quantities found ...\"\n", "target": ">>> from itertools import product\n>>> nuggets = set(range(101))\n>>> for s, n, t in product(range(100//6+1), range(100//9+1), range(100//20+1)):\n\tnuggets.discard(6*s + 9*n + 20*t)\n\n\t\n>>> max(nuggets)\n43\n>>>\n"}
{"id": 351170, "name": "Idiomatically determine all the lowercase and uppercase letters", "source": "Translate Haskell to Python: main = do putStrLn $ \"Lower: \" ++ ['a'..'z']\n          putStrLn $ \"Upper: \" ++ ['A'..'Z']\n", "target": "classes = (str.isupper, str.islower, str.isalnum, str.isalpha, str.isdecimal,\n           str.isdigit, str.isidentifier, str.isnumeric, str.isprintable,\n           str.isspace, str.istitle)\n\nfor stringclass in classes:\n    chars = ''.join(chr(i) for i in range(0x10FFFF+1) if stringclass(chr(i)))\n    print('\\nString class %s has %i characters the first of which are:\\n  %r'\n          % (stringclass.__name__, len(chars), chars[:100]))\n"}
{"id": 351171, "name": "Superellipse", "source": "Translate Haskell to Python: \nimport Reflex\nimport Reflex.Dom\nimport Data.Text (Text, pack, unpack) \nimport Data.Map (Map, fromList, empty)\nimport Text.Read (readMaybe)\n\nwidth = 600\nheight = 500\n\ntype Point = (Float,Float)\ntype Segment = (Point,Point)\n\ndata Ellipse = Ellipse {a :: Float, b :: Float, n :: Float}\n\ntoFloat :: Text -> Maybe Float\ntoFloat  = readMaybe.unpack  \n\ntoEllipse :: Maybe Float -> Maybe Float -> Maybe Float -> Maybe Ellipse\ntoEllipse (Just a) (Just b) (Just n) = \n    if a < 1.0 || b <= 1.0 || n <= 0.0  \n    then Nothing \n    else Just $ Ellipse a b n\n\ntoEllipse _ _ _ = Nothing\n\nshowError :: Maybe a -> String\nshowError Nothing = \"invalid input\"\nshowError _ = \"\"\n\nreflect45 pts  =  pts ++ fmap (\\(x,y) -> ( y,  x)) (reverse pts)\nrotate90  pts  =  pts ++ fmap (\\(x,y) -> ( y, -x)) pts\nrotate180 pts  =  pts ++ fmap (\\(x,y) -> (-x, -y)) pts\nscale a b      =  fmap (\\(x,y) -> ( a*x, b*y )) \nsegments  pts  =  zip pts $ tail pts\n\ntoLineMap :: Maybe Ellipse -> Map Int ((Float,Float),(Float,Float))\ntoLineMap (Just (Ellipse a b n)) =\n    let f p = (1 - p**n)**(1/n)\n        dp = iterate (*0.9) 1.0\n        ip = map (\\p -> 1.0 -p) dp\n        points s = \n            if n > 1.0\n            then (\\p -> zip p (map f p)) ip\n            else (\\p -> zip (map f p) p) dp\n\n    in fromList $  \n       zip [0..] $ \n       segments $  \n       scale a b $ \n       rotate180 $ \n       rotate90 $  \n       reflect45 $ \n       takeWhile (\\(x,y) -> x < y ) $ \n       points 0.9\n\ntoLineMap Nothing = empty\n\nlineAttrs :: Segment -> Map Text Text\nlineAttrs ((x1,y1), (x2,y2)) =\n    fromList [ ( \"x1\",    pack $ show (width/2+x1))\n             , ( \"y1\",    pack $ show (height/2+y1))\n             , ( \"x2\",    pack $ show (width/2+x2))\n             , ( \"y2\",    pack $ show (height/2+y2))\n             , ( \"style\", \"stroke:brown;stroke-width:2\")\n             ]    \n         \nshowLine :: MonadWidget t m => Int -> Dynamic t Segment -> m ()\nshowLine _ dSegment = do\n    elSvgns \"line\" (lineAttrs <$> dSegment) $ return ()\n    return ()\n\nmain = mainWidget $ do\n    elAttr \"h1\" (\"style\" =: \"color:brown\") $ text \"Superellipse\" \n    ta <- el \"div\" $ do\n        text \"a: \"\n        textInput def { _textInputConfig_initialValue = \"200\"}\n\n    tb <- el \"div\" $ do\n        text \"b: \"\n        textInput def { _textInputConfig_initialValue = \"200\"}\n\n    tn <- el \"div\" $ do\n        text \"n: \"\n        textInput def { _textInputConfig_initialValue = \"2.5\"}\n    let \n        ab = zipDynWith toEllipse (toFloat <$> value ta) (toFloat <$> value tb)\n        dEllipse = zipDynWith ($) ab (toFloat <$> value tn)\n        dLines = fmap toLineMap dEllipse \n        \n        dAttrs = constDyn $ fromList \n                     [ (\"width\" , pack $ show width)\n                     , (\"height\", pack $ show height)\n                     ]\n    elAttr \"div\" (\"style\" =: \"color:red\") $ dynText $ fmap (pack.showError) dEllipse\n    el \"div\" $ elSvgns \"svg\" dAttrs $ listWithKey dLines showLine\n    return ()\n\n\nelSvgns :: forall t m a. MonadWidget t m => Text -> Dynamic t (Map Text Text) -> m a -> m (El t, a)\nelSvgns = elDynAttrNS' (Just \"http://www.w3.org/2000/svg\")\n", "target": "\n\n\nimport matplotlib.pyplot as plt\nfrom math import sin, cos, pi\n\ndef sgn(x):\n\treturn ((x>0)-(x<0))*1\n\na,b,n=200,200,2.5 \nna=2/n\nstep=100 \npiece=(pi*2)/step\nxp=[];yp=[]\n\nt=0\nfor t1 in range(step+1):\n\t\n\tx=(abs((cos(t)))**na)*a*sgn(cos(t))\n\ty=(abs((sin(t)))**na)*b*sgn(sin(t))\n\txp.append(x);yp.append(y)\n\tt+=piece\n\nplt.plot(xp,yp) \nplt.title(\"Superellipse with parameter \"+str(n))\nplt.show()\n"}
{"id": 351172, "name": "Mutex", "source": "Translate Haskell to Python: takeMVar :: MVar a -> IO a\nputMVar :: MVar a -> a -> IO ()\ntryTakeMVar :: MVar a -> IO (Maybe a)\ntryPutMVar :: MVar a -> a -> IO Bool\n", "target": "import threading\nfrom time import sleep\n\n\n\nres = 2\nsema = threading.Semaphore(res)\n\nclass res_thread(threading.Thread):\n    def run(self):\n        global res\n        n = self.getName()\n        for i in range(1, 4):\n            \n            \n            \n            sema.acquire()\n            res = res - 1\n            print n, \"+  res count\", res\n            sleep(2)\n\n                        \n            res = res + 1\n            print n, \"-  res count\", res\n            sema.release()\n\n\nfor i in range(1, 5):\n    t = res_thread()\n    t.start()\n"}
{"id": 351173, "name": "Jaro similarity", "source": "Translate Haskell to Python: import Data.List (elemIndex, intercalate, sortOn)\nimport Data.Maybe (mapMaybe)\nimport Text.Printf (printf)\n\n\n\njaro :: Ord a => [a] -> [a] -> Float\njaro x y\n  | 0 == m = 0\n  | otherwise =\n    (1 / 3)\n      * ( (m / s1) + (m / s2) + ((m - t) / m))\n  where\n    f = fromIntegral . length\n    [m, t] =\n      [f, fromIntegral . transpositions]\n        <*> [matches x y]\n    [s1, s2] = [f] <*> [x, y]\n\nmatches :: Eq a => [a] -> [a] -> [(Int, a)]\nmatches s1 s2 =\n  let [(l1, xs), (l2, ys)] =\n        sortOn\n          fst\n          ((length >>= (,)) <$> [s1, s2])\n      r = quot l2 2 - 1\n   in mapMaybe\n        ( \\(c, n) ->\n            \n\n            let offset = max 0 (n - (r + 1))\n             in \n                elemIndex c (drop offset (take (n + r) ys))\n                  >>= (\\i -> Just (offset + i, c))\n        )\n        (zip xs [1 ..])\n\ntranspositions :: Ord a => [(Int, a)] -> Int\ntranspositions =\n  length\n    . filter (uncurry (>))\n    . (zip <*> tail)\n\n\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n    fmap\n      ( \\(s1, s2) ->\n          intercalate\n            \" -> \"\n            [s1, s2, printf \"%.3f\\n\" $ jaro s1 s2]\n      )\n      [ (\"DWAYNE\", \"DUANE\"),\n        (\"MARTHA\", \"MARHTA\"),\n        (\"DIXON\", \"DICKSONX\"),\n        (\"JELLYFISH\", \"SMELLYFISH\")\n      ]\n", "target": "\n\nfrom __future__ import division\n\n\ndef jaro(s, t):\n    \n    s_len = len(s)\n    t_len = len(t)\n\n    if s_len == 0 and t_len == 0:\n        return 1\n\n    match_distance = (max(s_len, t_len) // 2) - 1\n\n    s_matches = [False] * s_len\n    t_matches = [False] * t_len\n\n    matches = 0\n    transpositions = 0\n\n    for i in range(s_len):\n        start = max(0, i - match_distance)\n        end = min(i + match_distance + 1, t_len)\n\n        for j in range(start, end):\n            if t_matches[j]:\n                continue\n            if s[i] != t[j]:\n                continue\n            s_matches[i] = True\n            t_matches[j] = True\n            matches += 1\n            break\n\n    if matches == 0:\n        return 0\n\n    k = 0\n    for i in range(s_len):\n        if not s_matches[i]:\n            continue\n        while not t_matches[k]:\n            k += 1\n        if s[i] != t[k]:\n            transpositions += 1\n        k += 1\n\n    return ((matches / s_len) +\n            (matches / t_len) +\n            ((matches - transpositions / 2) / matches)) / 3\n\n\ndef main():\n    \n\n    for s, t in [('MARTHA', 'MARHTA'),\n                 ('DIXON', 'DICKSONX'),\n                 ('JELLYFISH', 'SMELLYFISH')]:\n        print(\"jaro(%r, %r) = %.10f\" % (s, t, jaro(s, t)))\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351174, "name": "Odd word problem", "source": "Translate Haskell to Python: import System.IO\n       (BufferMode(..), getContents, hSetBuffering, stdin, stdout)\nimport Data.Char (isAlpha)\n\nsplit :: String -> (String, String)\nsplit = span isAlpha\n\nparse :: String -> String\nparse [] = []\nparse l =\n  let (a, w) = split l\n      (b, x) = splitAt 1 w\n      (c, y) = split x\n      (d, z) = splitAt 1 y\n  in a <> b <> reverse c <> d <> parse z\n\nmain :: IO ()\nmain =\n  hSetBuffering stdin NoBuffering >> hSetBuffering stdout NoBuffering >> getContents >>=\n  putStr . takeWhile (/= '.') . parse >>\n  putStrLn \".\"\n", "target": "from sys import stdin, stdout\n\ndef char_in(): return stdin.read(1)\ndef char_out(c): stdout.write(c)\n\ndef odd(prev = lambda: None):\n\ta = char_in()\n\tif not a.isalpha():\n\t\tprev()\n\t\tchar_out(a)\n\t\treturn a != '.'\n\n\t\n\tdef clos():\n\t\tchar_out(a)\n\t\tprev()\n\n\treturn odd(clos)\n\ndef even():\n\twhile True:\n\t\tc = char_in()\n\t\tchar_out(c)\n\t\tif not c.isalpha(): return c != '.'\n\ne = False\nwhile odd() if e else even():\n\te = not e\n"}
{"id": 351175, "name": "Pseudo-random numbers_PCG32", "source": "Translate Haskell to Python: import Data.Bits\nimport Data.Word\nimport System.Random\nimport Data.List\n\ndata PCGen = PCGen !Word64 !Word64 \n\nmkPCGen state sequence =\n  let\n    n = 6364136223846793005 :: Word64 \n    inc = (sequence `shiftL` 1) .|. 1 :: Word64 \n  in PCGen ((inc + state)*n + inc) inc \n\ninstance RandomGen PCGen where\n   next (PCGen state inc) =\n     let\n       n = 6364136223846793005 :: Word64\n       xs = fromIntegral $ ((state `shiftR` 18) `xor` state) `shiftR` 27 :: Word32\n       rot = fromIntegral $ state `shiftR` 59 :: Int\n     in (fromIntegral $ (xs `shiftR` rot) .|. (xs `shiftL` ((-rot) .&. 31))\n        , PCGen (state * n + inc) inc)\n\n   split _ = error \"PCG32 is not splittable\"\n\nrandoms' :: RandomGen g => g -> [Int]\nrandoms' g = unfoldr (pure . next) g\n\ntoFloat n = fromIntegral n / (2^32 - 1)\n", "target": "mask64 = (1 << 64) - 1\nmask32 = (1 << 32) - 1\nCONST = 6364136223846793005\n\n\nclass PCG32():\n    \n    def __init__(self, seed_state=None, seed_sequence=None):\n        if all(type(x) == int for x in (seed_state, seed_sequence)):\n            self.seed(seed_state, seed_sequence)\n        else:\n            self.state = self.inc = 0\n    \n    def seed(self, seed_state, seed_sequence):\n        self.state = 0\n        self.inc = ((seed_sequence << 1) | 1) & mask64\n        self.next_int()\n        self.state = (self.state + seed_state)\n        self.next_int()\n        \n    def next_int(self):\n        \"return random 32 bit unsigned int\"\n        old = self.state\n        self.state = ((old * CONST) + self.inc) & mask64\n        xorshifted = (((old >> 18) ^ old) >> 27) & mask32\n        rot = (old >> 59) & mask32\n        answer = (xorshifted >> rot) | (xorshifted << ((-rot) & 31))\n        answer = answer &mask32\n        \n        return answer\n    \n    def  next_float(self):\n        \"return random float between 0 and 1\"\n        return self.next_int() / (1 << 32)\n    \n\nif __name__ == '__main__':\n    random_gen = PCG32()\n    random_gen.seed(42, 54)\n    for i in range(5):\n        print(random_gen.next_int())\n        \n    random_gen.seed(987654321, 1)\n    hist = {i:0 for i in range(5)}\n    for i in range(100_000):\n        hist[int(random_gen.next_float() *5)] += 1\n    print(hist)\n"}
{"id": 351176, "name": "Largest proper divisor of n", "source": "Translate Haskell to Python: import Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\nlpd :: Int -> Int\nlpd 1 = 1\nlpd n = head [x | x <- [n -1, n -2 .. 1], n `mod` x == 0]\n\nmain :: IO ()\nmain =\n  (putStr . unlines . map concat . chunksOf 10) $\n     printf \"%3d\" . lpd <$> [1 .. 100]\n", "target": "def lpd(n):\n    for i in range(n-1,0,-1):\n        if n%i==0: return i\n    return 1\n\nfor i in range(1,101):\n    print(\"{:3}\".format(lpd(i)), end=i%10==0 and '\\n' or '')\n"}
{"id": 351177, "name": "Summarize and say sequence", "source": "Translate Haskell to Python: import Data.Set (Set, member, insert, empty)\nimport Data.List (group, sort)\n\nstep :: String -> String\nstep = concatMap (\\list -> show (length list) ++ [head list]) . group . sort\n\nfindCycle :: (Ord a) => [a] -> [a]\nfindCycle = aux empty where\n\taux set (x : xs)\n\t\t| x `member` set = []\n\t\t| otherwise = x : aux (insert x set) xs\n\nselect :: [[a]] -> [[a]]\nselect = snd . foldl (\\(len, acc) xs -> case len `compare` length xs of\n\t\tLT -> (length xs, [xs])\n\t\tEQ -> (len, xs : acc)\n\t\tGT -> (len, acc)) (0, [])\n\nmain :: IO ()\nmain = mapM_ (mapM_ print) $ \n\tselect $ \n\tmap findCycle $ \n\tmap (iterate step) $ \n\tmap show \n\t[1..1000000] \n", "target": "from itertools import groupby, permutations\n\ndef A036058(number):\n    return ''.join( str(len(list(g))) + k\n                    for k,g in groupby(sorted(str(number), reverse=True)) )\n\ndef A036058_length(numberstring='0', printit=False):\n    iterations, last_three, queue_index = 1, ([None] * 3), 0\n\n    def A036058(number):\n        \n        return ''.join( str(len(list(g))) + k\n                        for k,g in groupby(number) )\n\n    while True:\n        if printit:\n            print(\"  %2i %s\" % (iterations, numberstring))\n        numberstring = ''.join(sorted(numberstring, reverse=True))\n        if numberstring in last_three:\n            break\n        assert iterations < 1000000\n        last_three[queue_index], numberstring = numberstring, A036058(numberstring)\n        iterations += 1\n        queue_index +=1\n        queue_index %=3\n    return iterations\n    \ndef max_A036058_length( start_range=range(11) ):\n    already_done = set()\n    max_len = (-1, [])\n    for n in start_range:\n        sn = str(n)\n        sns = tuple(sorted(sn, reverse=True))\n        if sns not in already_done:\n            already_done.add(sns)\n            size = A036058_length(sns)\n            if size > max_len[0]:\n                max_len = (size, [n])\n            elif size == max_len[0]:\n                max_len[1].append(n)\n    return max_len\n\nlenmax, starts = max_A036058_length( range(1000000) )\n\n\nallstarts = []\nfor n in starts:\n    allstarts += [int(''.join(x))\n                  for x in set(k\n                               for k in permutations(str(n), 4)\n                               if k[0] != '0')]\nallstarts = [x for x in sorted(allstarts) if x < 1000000]\n\nprint (  % (lenmax, allstarts)   )\n\nprint (  )\n\nfor n in starts:\n    print()\n    A036058_length(str(n), printit=True)\n"}
{"id": 351178, "name": "Koch curve", "source": "Translate Haskell to Python: import Data.Bifunctor (bimap)\nimport Text.Printf (printf)\n\n\nkochSnowflake ::\n  Int ->\n  (Float, Float) ->\n  (Float, Float) ->\n  [(Float, Float)]\nkochSnowflake n a b =\n  concat $\n    zipWith (kochCurve n) points (xs <> [x])\n  where\n    points@(x : xs) = [a, equilateralApex a b, b]\n\nkochCurve ::\n  Int ->\n  (Float, Float) ->\n  (Float, Float) ->\n  [(Float, Float)]\nkochCurve n ab xy = ab : go n (ab, xy)\n  where\n    go 0 (_, xy) = [xy]\n    go n (ab, xy) =\n      let (mp, mq) = midThirdOfLine ab xy\n          points@(_ : xs) =\n            [ ab,\n              mp,\n              equilateralApex mp mq,\n              mq,\n              xy\n            ]\n       in go (pred n) =<< zip points xs\n\nequilateralApex ::\n  (Float, Float) ->\n  (Float, Float) ->\n  (Float, Float)\nequilateralApex = rotatedPoint (pi / 3)\n\nrotatedPoint ::\n  Float ->\n  (Float, Float) ->\n  (Float, Float) ->\n  (Float, Float)\nrotatedPoint theta (ox, oy) (a, b) = (ox + dx, oy - dy)\n  where\n    (dx, dy) = rotatedVector theta (a - ox, oy - b)\n\nrotatedVector :: Float -> (Float, Float) -> (Float, Float)\nrotatedVector angle (x, y) =\n  ( x * cos angle - y * sin angle,\n    x * sin angle + y * cos angle\n  )\n\nmidThirdOfLine ::\n  (Float, Float) ->\n  (Float, Float) ->\n  ((Float, Float), (Float, Float))\nmidThirdOfLine (a, b) (x, y) = (p, f p)\n  where\n    (dx, dy) = ((x - a) / 3, (y - b) / 3)\n    f = bimap (dx +) (dy +)\n    p = f (a, b)\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n    svgFromPoints 1024 $\n      kochSnowflake 4 (200, 600) (800, 600)\n\n\nsvgFromPoints :: Int -> [(Float, Float)] -> String\nsvgFromPoints w xys =\n  unlines\n    [ \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\",\n      unwords\n        [ \"width=\\\"512\\\" height=\\\"512\\\" viewBox=\\\"5 5\",\n          sw,\n          sw,\n          \"\\\"> \"\n        ],\n      \"<path d=\\\"M\" <> points <> \"\\\" \",\n      unwords [\n        \"stroke-width=\\\"2\\\"\",\n        \"stroke=\\\"red\\\"\",\n        \"fill=\\\"transparent\\\"/>\"\n      ],\n      \"</svg>\"\n    ]\n  where\n    sw = show w\n    showN = printf \"%.2g\"\n    points =\n      ( unwords\n          . fmap\n            ( ((<>) . showN . fst)\n                <*> ((' ' :) . showN . snd)\n            )\n      )\n        xys\n", "target": "l = 300\n\ndef setup():\n    size(400, 400)\n    background(0, 0, 255)\n    stroke(255)\n    \n    translate(width / 2.0, height / 2.0)\n    \n    translate(-l / 2.0, l * sqrt(3) / 6.0)\n    for i in range(4):\n        kcurve(0, l)\n        rotate(radians(120))\n        translate(-l, 0)\n\n\ndef kcurve(x1, x2):\n    s = (x2 - x1) / 3.0\n    if s < 5:\n        pushMatrix()\n        translate(x1, 0)\n        line(0, 0, s, 0)\n        line(2 * s, 0, 3 * s, 0)\n        translate(s, 0)\n        rotate(radians(60))\n        line(0, 0, s, 0)\n        translate(s, 0)\n        rotate(radians(-120))\n        line(0, 0, s, 0)\n        popMatrix()\n        return\n\n    pushMatrix()\n    translate(x1, 0)\n    kcurve(0, s)\n    kcurve(2 * s, 3 * s)\n    translate(s, 0)\n    rotate(radians(60))\n    kcurve(0, s)\n    translate(s, 0)\n    rotate(radians(-120))\n    kcurve(0, s)\n    popMatrix()\n"}
{"id": 351179, "name": "Pseudo-random numbers_Xorshift star", "source": "Translate Haskell to Python: import Data.Bits\nimport Data.Word\nimport System.Random\nimport Data.List\n\nnewtype XorShift = XorShift Word64\n\ninstance RandomGen XorShift where\n   next (XorShift state) = (out newState, XorShift newState)\n     where\n       newState = (\\z -> z `xor` (z `shiftR` 27)) .\n                  (\\z -> z `xor` (z `shiftL` 25)) .\n                  (\\z -> z `xor` (z `shiftR` 12)) $ state\n       out x = fromIntegral $ (x * 0x2545f4914f6cdd1d) `shiftR` 32\n\n   split _ = error \"XorShift is not splittable\"\n\nrandoms' :: RandomGen g => g -> [Int]\nrandoms' = unfoldr (pure . next)\n\ntoFloat n = fromIntegral n / (2^32 - 1)\n", "target": "mask64 = (1 << 64) - 1\nmask32 = (1 << 32) - 1\nconst = 0x2545F4914F6CDD1D\n\n\n\nclass Xorshift_star():\n    \n    def __init__(self, seed=0):\n        self.state = seed & mask64\n\n    def seed(self, num):\n        self.state =  num & mask64\n    \n    def next_int(self):\n        \"return random int between 0 and 2**32\"\n        x = self.state\n        x = (x ^ (x >> 12)) & mask64\n        x = (x ^ (x << 25)) & mask64\n        x = (x ^ (x >> 27)) & mask64\n        self.state = x\n        answer = (((x * const) & mask64) >> 32) & mask32 \n        return answer\n    \n    def  next_float(self):\n        \"return random float between 0 and 1\"\n        return self.next_int() / (1 << 32)\n    \n\nif __name__ == '__main__':\n    random_gen = Xorshift_star()\n    random_gen.seed(1234567)\n    for i in range(5):\n        print(random_gen.next_int())\n        \n    random_gen.seed(987654321)\n    hist = {i:0 for i in range(5)}\n    for i in range(100_000):\n        hist[int(random_gen.next_float() *5)] += 1\n    print(hist)\n"}
{"id": 351180, "name": "Numbers with equal rises and falls", "source": "Translate Haskell to Python: import Data.Char\n\npairs :: [a] -> [(a,a)]\npairs (a:b:as) = (a,b):pairs (b:as)\npairs _        = [] \n\nriseEqFall :: Int -> Bool\nriseEqFall n = rel (>) digitPairs == rel (<) digitPairs\n    where rel r = sum . map (fromEnum . uncurry r)\n          digitPairs = pairs $ map digitToInt $ show n\n\na296712 :: [Int]\na296712 = [n | n <- [1..], riseEqFall n]\n\nmain :: IO ()\nmain = do\n\tputStrLn \"The first 200 numbers are: \"\n\tputStrLn $ unwords $ map show $ take 200 a296712\n\tputStrLn \"\"\n\tputStr \"The 10,000,000th number is: \"\n\tputStrLn $ show $ a296712 !! 9999999\n", "target": "import itertools\n\ndef riseEqFall(num):\n    \n    height = 0\n    d1 = num % 10\n    num //= 10\n    while num:\n        d2 = num % 10\n        height += (d1<d2) - (d1>d2)\n        d1 = d2\n        num //= 10\n    return height == 0\n    \ndef sequence(start, fn):\n    \n    num=start-1\n    while True:\n        num += 1\n        while not fn(num): num += 1\n        yield num\n\na296712 = sequence(1, riseEqFall)\n\n\nprint(\"The first 200 numbers are:\")\nprint(*itertools.islice(a296712, 200))\n\n\nprint(\"The 10,000,000th number is:\")\nprint(*itertools.islice(a296712, 10000000-200-1, 10000000-200))\n\n\n"}
{"id": 351181, "name": "Pseudo-random numbers_Combined recursive generator MRG32k3a", "source": "Translate Haskell to Python: import Data.List\n\nrandoms :: Int -> [Int]\nrandoms seed = unfoldr go ([seed,0,0],[seed,0,0])\n  where\n    go (x1,x2) =\n      let x1i = sum (zipWith (*) x1 a1) `mod` m1\n          x2i = sum (zipWith (*) x2 a2) `mod` m2\n      in Just $ ((x1i - x2i) `mod` m1, (x1i:init x1, x2i:init x2))\n    \n    a1 = [0, 1403580, -810728]\n    m1 = 2^32 - 209\n    a2 = [527612, 0, -1370589]\n    m2 = 2^32 - 22853\n\nrandomsFloat = map ((/ (2^32 - 208)) . fromIntegral) . randoms\n", "target": "\na1 = [0, 1403580, -810728]\nm1 = 2**32 - 209\n\na2 = [527612, 0, -1370589]\nm2 = 2**32 - 22853\n\nd = m1 + 1\n\nclass MRG32k3a():\n    \n    def __init__(self, seed_state=123):\n        self.seed(seed_state)\n    \n    def seed(self, seed_state):\n        assert 0 <seed_state < d, f\"Out of Range 0 x < {d}\"\n        self.x1 = [seed_state, 0, 0]\n        self.x2 = [seed_state, 0, 0]\n        \n    def next_int(self):\n        \"return random int in range 0..d\"\n        x1i = sum(aa * xx  for aa, xx in zip(a1, self.x1)) % m1\n        x2i = sum(aa * xx  for aa, xx in zip(a2, self.x2)) % m2\n        self.x1 = [x1i] + self.x1[:2]\n        self.x2 = [x2i] + self.x2[:2]\n\n        z = (x1i - x2i) % m1\n        answer = (z + 1)\n        \n        return answer\n    \n    def  next_float(self):\n        \"return random float between 0 and 1\"\n        return self.next_int() / d\n    \n\nif __name__ == '__main__':\n    random_gen = MRG32k3a()\n    random_gen.seed(1234567)\n    for i in range(5):\n        print(random_gen.next_int())\n        \n    random_gen.seed(987654321)\n    hist = {i:0 for i in range(5)}\n    for i in range(100_000):\n        hist[int(random_gen.next_float() *5)] += 1\n    print(hist)\n"}
{"id": 351182, "name": "Self-describing numbers", "source": "Translate Haskell to Python: import Data.Char\n\ncount :: Int -> [Int] -> Int\ncount x = length . filter (x ==)\n\nisSelfDescribing :: Integer -> Bool\nisSelfDescribing n = nu == f\n  where\n    nu = digitToInt <$> show n\n    f = (`count` nu) <$> [0 .. length nu - 1]\n\nmain :: IO ()\nmain = do\n  print $\n    isSelfDescribing <$>\n    [1210, 2020, 21200, 3211000, 42101000, 521001000, 6210001000]\n  print $ filter isSelfDescribing [0 .. 4000000]\n", "target": ">>> def isSelfDescribing(n):\n\ts = str(n)\n\treturn all(s.count(str(i)) == int(ch) for i, ch in enumerate(s))\n\n>>> [x for x in range(4000000) if isSelfDescribing(x)]\n[1210, 2020, 21200, 3211000]\n>>> [(x, isSelfDescribing(x)) for x in (1210, 2020, 21200, 3211000, 42101000, 521001000, 6210001000)]\n[(1210, True), (2020, True), (21200, True), (3211000, True), (42101000, True), (521001000, True), (6210001000, True)]\n"}
{"id": 351183, "name": "Exactly three adjacent 3 in lists", "source": "Translate Haskell to Python: import Data.Bifunctor (bimap)\nimport Data.List (span)\n\nnnPeers :: Int -> [Int] -> Bool\nnnPeers n xs =\n  let p x = n == x\n   in uncurry (&&) $\n        bimap\n          (p . length)\n          (not . any p)\n          (span p $ dropWhile (not . p) xs)\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n    unlines $\n      fmap\n        (\\xs -> show xs <> \" -> \" <> show (nnPeers 3 xs))\n        [ [9, 3, 3, 3, 2, 1, 7, 8, 5],\n          [5, 2, 9, 3, 3, 7, 8, 4, 1],\n          [1, 4, 3, 6, 7, 3, 8, 3, 2],\n          [1, 2, 3, 4, 5, 6, 7, 8, 9],\n          [4, 6, 8, 7, 2, 3, 3, 3, 1]\n        ]\n", "target": "\n\nfrom itertools import dropwhile, takewhile\n\n\n\ndef nnPeers(n):\n    \n    def p(x):\n        return n == x\n\n    def go(xs):\n        fromFirstMatch = list(dropwhile(\n            lambda v: not p(v),\n            xs\n        ))\n        ns = list(takewhile(p, fromFirstMatch))\n        rest = fromFirstMatch[len(ns):]\n\n        return p(len(ns)) and (\n            not any(p(x) for x in rest)\n        )\n\n    return go\n\n\n\n\ndef main():\n    \n    print(\n        '\\n'.join([\n            f'{xs} -> {nnPeers(3)(xs)}' for xs in [\n                [9, 3, 3, 3, 2, 1, 7, 8, 5],\n                [5, 2, 9, 3, 3, 7, 8, 4, 1],\n                [1, 4, 3, 6, 7, 3, 8, 3, 2],\n                [1, 2, 3, 4, 5, 6, 7, 8, 9],\n                [4, 6, 8, 7, 2, 3, 3, 3, 1]\n            ]\n        ])\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351184, "name": "Minimum numbers of three lists", "source": "Translate Haskell to Python: import Data.List (transpose)\n\nnumbers1, numbers2, numbers3 :: [Integer]\nnumbers1 = [5, 45, 23, 21, 67]\nnumbers2 = [43, 22, 78, 46, 38]\nnumbers3 = [9, 98, 12, 98, 53]\n\nmain :: IO ()\nmain =\n  print $\n    minimum\n      <$> transpose\n        [numbers1, numbers2, numbers3]\n", "target": "numbers1 = [5,45,23,21,67]\nnumbers2 = [43,22,78,46,38]\nnumbers3 = [9,98,12,98,53]\n\nnumbers = [min(numbers1[i],numbers2[i],numbers3[i]) for i in range(0,len(numbers1))]\n\nprint(numbers)\n"}
{"id": 351185, "name": "Mosaic matrix", "source": "Translate Haskell to Python: import Data.Matrix (Matrix, matrix)\n\nmosaic :: Int -> Matrix Int\nmosaic n =\n  matrix n n ((`rem` 2) . succ . uncurry (+))\n\nmain :: IO ()\nmain = mapM_ (print . mosaic) [7, 8]\n", "target": "size = 9\nfor Row in range(size):\n    for Col in range(size):\n        if (Row % 2 == 1 and Col % 2 == 1) or (Row % 2 == 0 and Col % 2 == 0):\n            print(\"1\", end=\" \")\n        else:\n            print(\"0\", end=\" \")\n    print()\n"}
{"id": 351186, "name": "Find words with alternating vowels and consonants", "source": "Translate Haskell to Python: import Control.Monad (join)\nimport Data.Bifunctor (bimap)\nimport Data.List.Split (chunksOf)\n\n\n\nisLongAlternator :: String -> Bool\nisLongAlternator s =\n  9 < length s\n    && all alternating (zip s $ tail s)\n\nalternating :: (Char, Char) -> Bool\nalternating = uncurry (/=) . join bimap isVowel\n\nisVowel :: Char -> Bool\nisVowel = flip elem \"aeiou\"\n\n\nmain :: IO ()\nmain =\n  readFile \"unixdict.txt\"\n    >>= mapM_ putStrLn\n      . ( ((:) . (<> \" matching words:\\n\") . show . length)\n            <*> inColumns 4\n        )\n      . filter isLongAlternator\n      . lines\n\n\n\ninColumns :: Int -> [String] -> [String]\ninColumns n xs = unwords <$> chunksOf n (justifyLeft w ' ' <$> xs)\n  where\n    w = maximum (length <$> xs)\n\njustifyLeft :: Int -> Char -> String -> String\njustifyLeft n c s = take n (s <> replicate n c)\n", "target": "\n\n\n\ndef isLongAlternator(s):\n    \n    def p(a, b):\n        return isVowel(a) != isVowel(b)\n    return 9 < len(s) and all(map(p, s, s[1:]))\n\n\ndef isVowel(c):\n    \n    return c in 'aeiou'\n\n\n\n\ndef main():\n    \n    matches = [\n        x for x in readFile('unixdict.txt').splitlines()\n        if isLongAlternator(x)\n    ]\n    w = max(len(x) for x in matches)\n    print(str(len(matches)) + ' matching words:\\n')\n    print(\n        '\\n'.join(\n            ' '.join(s) for s in chunksOf(4)([\n                x.ljust(w, ' ') for x in matches\n            ])\n        )\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef readFile(fp):\n    \n    with open(fp, 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351187, "name": "Input_Output for lines of text", "source": "Translate Haskell to Python: import Control.Monad\nmain = do\n        number <- getLine \n        input <- replicateM (read number) getLine\n        mapM_ putStrLn input\n", "target": "try: input = raw_input\nexcept: pass\n\ndef do_stuff(words):\n\tprint(words)\n\nlinecount = int(input())\nfor x in range(linecount):\n\tline = input()\n\tdo_stuff(line)\n"}
{"id": 351188, "name": "Numbers divisible by their individual digits, but not by the product of their digits.", "source": "Translate Haskell to Python: import Data.List.Split (chunksOf)\nimport Text.Printf\n\ndivisible :: Int -> Bool\ndivisible = divdgt <*> dgt\n  where\n    dgt = map (read . pure) . show\n    divdgt x d =\n      notElem 0 d\n        && 0 /= x `mod` product d\n        && all ((0 ==) . mod x) d\n\nnumbers :: [Int]\nnumbers = filter divisible [1 ..]\n\nmain :: IO ()\nmain = putStr $ unlines $ map (concatMap $ printf \"%5d\") split\n  where\n    n = takeWhile (< 1000) numbers\n    split = chunksOf 10 n\n", "target": "\n\nfrom functools import reduce\nfrom operator import mul\n\n\n\ndef p(n):\n    \n    digits = [int(c) for c in str(n)]\n    return not 0 in digits and (\n        0 != (n % reduce(mul, digits, 1))\n    ) and all(0 == n % d for d in digits)\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 1000)\n        if p(n)\n    ]\n    w = len(xs[-1])\n    print(f'{len(xs)} matching numbers:\\n')\n    print('\\n'.join(\n        ' '.join(cell.rjust(w, ' ') for cell in row)\n        for row in chunksOf(10)(xs)\n    ))\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351189, "name": "Length of an arc between two angles", "source": "Translate Haskell to Python: arcLength radius angle1 angle2 = (360.0 - (abs $ angle1 - angle2)) * pi * radius / 180.0\n\nmain = putStrLn $ \"arcLength 10.0 10.0 120.0 = \" ++ show (arcLength 10.0 10.0 120.0)\n", "target": "import math\n\ndef arc_length(r, angleA, angleB):\n    return (360.0 - abs(angleB - angleA)) * math.pi * r / 180.0\n"}
{"id": 351190, "name": "Shift list elements to left by 3", "source": "Translate Haskell to Python: \n\nrotated :: Int -> [a] -> [a]\nrotated n =\n  ( (<*>) take\n      . flip (drop . mod n)\n      . cycle\n  )\n    <*> length\n\n\nmain :: IO ()\nmain =\n  let xs = [1 .. 9]\n   in putStrLn (\"Initial list: \" <> show xs <> \"\\n\")\n        >> putStrLn \"Rotated 3 or 30 positions to the left:\"\n        >> print (rotated 3 xs)\n        >> print (rotated 30 xs)\n        >> putStrLn \"\\nRotated 3 or 30 positions to the right:\"\n        >> print (rotated (-3) xs)\n        >> print (rotated (-30) xs)\n", "target": "def rotate(list, n):\n    for _ in range(n):\n        list.append(list.pop(0))\n\n    return list\n\n\n\ndef rotate(list, n):\n    k = (len(list) + n) % len(list)\n    return list[k::] + list[:k:]\n\n\nlist = [1,2,3,4,5,6,7,8,9]\nprint(list, \" => \", rotate(list, 3))\n"}
{"id": 351191, "name": "Numbers with same digit set in base 10 and base 16", "source": "Translate Haskell to Python: import qualified Data.Set as S\nimport Numeric (showHex)\n\n\n\nsameDigitSet :: (Integral a, Show a) => a -> [(a, String)]\nsameDigitSet n =\n  [ (n, h)\n    | let h = showHex n \"\",\n      S.fromList h == S.fromList (show n)\n  ]\n\n\nmain = do\n  print (\"decimal\", \"hex\")\n  mapM_ print $ [0 .. 100000] >>= sameDigitSet\n", "target": "col = 0\nfor i in range(100000):\n    if set(str(i)) == set(hex(i)[2:]):\n        col += 1\n        print(\"{:7}\".format(i), end='\\n'[:col % 10 == 0])\nprint()\n"}
{"id": 351192, "name": "Matrix with two diagonals", "source": "Translate Haskell to Python: \n\ntwoDiagonalMatrix :: Int -> [[Int]]\ntwoDiagonalMatrix n = flip (fmap . go) xs <$> xs\n  where\n    xs = [1 .. n]\n    go x y\n      | y == x = 1\n      | y == succ (subtract x n) = 1\n      | otherwise = 0\n\n\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n    unlines . fmap (((' ' :) . show) =<<)\n      . twoDiagonalMatrix\n      <$> [7, 8]\n", "target": "\n\n\n\ndef twoDiagonalMatrix(n):\n    \n    return matrix(\n        n, n, lambda row, col: int(\n            row in (col, 1 + (n - col))\n        )\n    )\n\n\n\n\ndef main():\n    \n    for n in [7, 8]:\n        print(\n            showMatrix(\n                twoDiagonalMatrix(n)\n            ) + '\\n'\n        )\n\n\n\n\n\ndef matrix(nRows, nCols, f):\n    \n    return [\n        [f(y, x) for x in range(1, 1 + nCols)]\n        for y in range(1, 1 + nRows)\n    ]\n\n\n\ndef showMatrix(rows):\n    \n    return '\\n'.join([\n        ' '.join([str(x) for x in y]) for y in rows\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351193, "name": "Four sides of square", "source": "Translate Haskell to Python: import Data.List (intercalate, intersperse)\nimport Data.List.Split (chunksOf)\nimport System.Environment (getArgs)\n\n\n\nsquare :: Int -> String\nsquare n = intercalate \"\\n\" $ map (intersperse ' ') $ chunksOf n sq\n  where sq = [sqChar r c | r <- [0..n-1], c <- [0..n-1]]\n        sqChar r c = if isBorder r c then '1' else '0'\n        isBorder r c = r == 0 || r == n-1 || c == 0 || c == n-1\n\nmain :: IO ()\nmain = do\n  sizes <- map read <$> getArgs\n  putStrLn $ intercalate \"\\n\\n\" $ map square sizes\n", "target": "size = 9\nfor row in range(size):\n    for col in range(size):\n        if row == 0 or row == size-1 or col == 0 or col == size-1:\n            print(\"1\", end=\" \")\n        else:\n            print(\"0\", end=\" \")\n    print()\n"}
{"id": 351194, "name": "Longest common suffix", "source": "Translate Haskell to Python: import Data.List (transpose)\n\nlongestCommonSuffix :: [String] -> String\nlongestCommonSuffix =\n  foldr (flip (<>) . return . head) [] .\n  takeWhile (all =<< (==) . head) . transpose . fmap reverse\n\nmain :: IO ()\nmain =\n  mapM_\n    (putStrLn . longestCommonSuffix)\n    [ [ \"Sunday\"\n      , \"Monday\"\n      , \"Tuesday\"\n      , \"Wednesday\"\n      , \"Thursday\"\n      , \"Friday\"\n      , \"Saturday\"\n      ]\n    , [ \"Sondag\"\n      , \"Maandag\"\n      , \"Dinsdag\"\n      , \"Woensdag\"\n      , \"Donderdag\"\n      , \"Vrydag\"\n      , \"Saterdag\"\n      , \"dag\"\n      ]\n    ]\n", "target": "\n\nfrom itertools import takewhile\nfrom functools import reduce\n\n\n\ndef longestCommonSuffix(xs):\n    \n    def allSame(cs):\n        h = cs[0]\n        return all(h == c for c in cs[1:])\n\n    def firstCharPrepended(s, cs):\n        return cs[0] + s\n    return reduce(\n        firstCharPrepended,\n        takewhile(\n            allSame,\n            zip(*(reversed(x) for x in xs))\n        ),\n        ''\n    )\n\n\n\n\ndef main():\n    \n\n    samples = [\n        [\n            \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n            \"Thursday\", \"Friday\", \"Saturday\"\n        ], [\n            \"Sondag\", \"Maandag\", \"Dinsdag\", \"Woensdag\",\n            \"Donderdag\", \"Vrydag\", \"Saterdag\"\n        ]\n    ]\n    for xs in samples:\n        print(\n            longestCommonSuffix(xs)\n        )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351195, "name": "Distinct power numbers", "source": "Translate Haskell to Python: import qualified Data.Set as S\n\n\n\n\ndistinctPowerNumbers :: Int -> Int -> [Int]\ndistinctPowerNumbers a b =\n  (S.elems . S.fromList) $\n    (fmap (^) >>= (<*>)) [a .. b]\n\n\n\nmain :: IO ()\nmain =\n  print $\n    distinctPowerNumbers 2 5\n", "target": "from itertools import product\nprint(sorted(set(a**b for (a,b) in product(range(2,6), range(2,6)))))\n"}
{"id": 351196, "name": "Unique characters", "source": "Translate Haskell to Python: import Data.List (group, sort)\n\nuniques :: [String] -> String\nuniques ks =\n  [c | (c : cs) <- (group . sort . concat) ks, null cs]\n\nmain :: IO ()\nmain =\n  putStrLn $\n    uniques\n      [ \"133252abcdeeffd\",\n        \"a6789798st\",\n        \"yxcdfgxcyz\"\n      ]\n", "target": "\n\nfrom itertools import chain, groupby\n\n\n\ndef uniques(xs):\n    \n    return [\n        h for h, (_, *tail) in\n        groupby(sorted(chain(*xs)))\n        if not tail\n    ]\n\n\n\n\ndef main():\n    \n    print(\n        uniques([\n            \"133252abcdeeffd\",\n            \"a6789798st\",\n            \"yxcdfgxcyz\"\n        ])\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351197, "name": "Continued fraction_Arithmetic_G(matrix ng, continued fraction n)", "source": "Translate Haskell to Python: \n\n\n\n\n\nimport Data.Ratio ((%))\n\nreal2cf frac =\n  let (quotient, remainder) = properFraction frac\n  in (quotient : (if remainder == 0\n                  then []\n                  else real2cf (1 / remainder)))\n\napply_hfunc (a1, a, b1, b) cf =\n  recurs (a1, a, b1, b, cf)\n  where recurs (a1, a, b1, b, cf) =\n          if b1 == 0 && b == 0 then\n            []\n          else if b1 /= 0 && b /= 0 then\n            let q1 = div a1 b1\n                q = div a b\n            in\n              if q1 == q then\n                q : recurs (b1, b, a1 - (b1 * q), a - (b * q), cf)\n              else\n                recurs (take_term (a1, a, b1, b, cf))\n          else recurs (take_term (a1, a, b1, b, cf))\n          where take_term (a1, a, b1, b, cf) =\n                  case cf of\n                    [] -> (a1, a1, b1, b1, cf)\n                    (term : cf1) -> (a + (a1 * term), a1,\n                                     b + (b1 * term), b1,\n                                     cf1)\n\ncf_13_11 = real2cf (13 % 11)\ncf_22_7 = real2cf (22 % 7)\ncf_sqrt2 = real2cf (sqrt 2)\n\ncfToString cf =\n  loop 0 0 \"[\" cf\n  where loop i sep s lst =\n          case lst of\n            [] -> s ++ \"]\"\n            (term : tail) ->\n              if i == 20\n              then s ++ \",...]\"\n              else\n                do loop (i + 1) sep1 s1 tail\n                     where sepStr = case sep of\n                                      0 -> \"\"\n                                      1 -> \";\"\n                                      _ -> \",\"\n                           sep1 = min (sep + 1) 2\n                           termStr = show term\n                           s1 = s ++ sepStr ++ termStr\n\nshow_cf expr cf =\n  do putStr expr;\n     putStr \" => \";\n     putStrLn (cfToString cf)\n\nmain =\n  do show_cf \"13/11\" cf_13_11;\n     show_cf \"22/7\" cf_22_7;\n     show_cf \"sqrt(2)\" cf_sqrt2;\n     show_cf \"13/11 + 1/2\" (apply_hfunc (2, 1, 0, 2) cf_13_11);\n     show_cf \"22/7 + 1/2\" (apply_hfunc (2, 1, 0, 2) cf_22_7);\n     show_cf \"(22/7)/4\" (apply_hfunc (1, 0, 0, 4) cf_22_7);\n     show_cf \"1/sqrt(2)\" (apply_hfunc (0, 1, 1, 0) cf_sqrt2);\n     show_cf \"(2 + sqrt(2))/4\" (apply_hfunc (1, 2, 0, 4) cf_sqrt2);\n     show_cf \"(1 + 1/sqrt(2))/2\" (apply_hfunc (2, 1, 0, 2) \n                                  (apply_hfunc (1, 0, 0, 2)  \n                                   (apply_hfunc (0, 1, 1, 0) \n                                     cf_sqrt2)))\n", "target": "class NG:\n  def __init__(self, a1, a, b1, b):\n    self.a1, self.a, self.b1, self.b = a1, a, b1, b\n\n  def ingress(self, n):\n    self.a, self.a1 = self.a1, self.a + self.a1 * n\n    self.b, self.b1 = self.b1, self.b + self.b1 * n\n\n  @property\n  def needterm(self):\n    return (self.b == 0 or self.b1 == 0) or not self.a//self.b == self.a1//self.b1\n\n  @property\n  def egress(self):\n    n = self.a // self.b\n    self.a,  self.b  = self.b,  self.a  - self.b  * n\n    self.a1, self.b1 = self.b1, self.a1 - self.b1 * n\n    return n\n\n  @property\n  def egress_done(self):\n    if self.needterm: self.a, self.b = self.a1, self.b1\n    return self.egress\n\n  @property\n  def done(self):\n    return self.b == 0 and self.b1 == 0\n"}
{"id": 351198, "name": "Continued fraction_Arithmetic_G(matrix ng, continued fraction n)", "source": "Translate Haskell to Python: \n\n\n\n\n\nimport Data.Ratio ((%))\n\nreal2cf frac =\n  let (quotient, remainder) = properFraction frac\n  in (quotient : (if remainder == 0\n                  then []\n                  else real2cf (1 / remainder)))\n\napply_hfunc (a1, a, b1, b) cf =\n  recurs (a1, a, b1, b, cf)\n  where recurs (a1, a, b1, b, cf) =\n          if b1 == 0 && b == 0 then\n            []\n          else if b1 /= 0 && b /= 0 then\n            let q1 = div a1 b1\n                q = div a b\n            in\n              if q1 == q then\n                q : recurs (b1, b, a1 - (b1 * q), a - (b * q), cf)\n              else\n                recurs (take_term (a1, a, b1, b, cf))\n          else recurs (take_term (a1, a, b1, b, cf))\n          where take_term (a1, a, b1, b, cf) =\n                  case cf of\n                    [] -> (a1, a1, b1, b1, cf)\n                    (term : cf1) -> (a + (a1 * term), a1,\n                                     b + (b1 * term), b1,\n                                     cf1)\n\ncf_13_11 = real2cf (13 % 11)\ncf_22_7 = real2cf (22 % 7)\ncf_sqrt2 = real2cf (sqrt 2)\n\ncfToString cf =\n  loop 0 0 \"[\" cf\n  where loop i sep s lst =\n          case lst of\n            [] -> s ++ \"]\"\n            (term : tail) ->\n              if i == 20\n              then s ++ \",...]\"\n              else\n                do loop (i + 1) sep1 s1 tail\n                     where sepStr = case sep of\n                                      0 -> \"\"\n                                      1 -> \";\"\n                                      _ -> \",\"\n                           sep1 = min (sep + 1) 2\n                           termStr = show term\n                           s1 = s ++ sepStr ++ termStr\n\nshow_cf expr cf =\n  do putStr expr;\n     putStr \" => \";\n     putStrLn (cfToString cf)\n\nmain =\n  do show_cf \"13/11\" cf_13_11;\n     show_cf \"22/7\" cf_22_7;\n     show_cf \"sqrt(2)\" cf_sqrt2;\n     show_cf \"13/11 + 1/2\" (apply_hfunc (2, 1, 0, 2) cf_13_11);\n     show_cf \"22/7 + 1/2\" (apply_hfunc (2, 1, 0, 2) cf_22_7);\n     show_cf \"(22/7)/4\" (apply_hfunc (1, 0, 0, 4) cf_22_7);\n     show_cf \"1/sqrt(2)\" (apply_hfunc (0, 1, 1, 0) cf_sqrt2);\n     show_cf \"(2 + sqrt(2))/4\" (apply_hfunc (1, 2, 0, 4) cf_sqrt2);\n     show_cf \"(1 + 1/sqrt(2))/2\" (apply_hfunc (2, 1, 0, 2) \n                                  (apply_hfunc (1, 0, 0, 2)  \n                                   (apply_hfunc (0, 1, 1, 0) \n                                     cf_sqrt2)))\n", "target": "class NG:\n  def __init__(self, a1, a, b1, b):\n    self.a1, self.a, self.b1, self.b = a1, a, b1, b\n\n  def ingress(self, n):\n    self.a, self.a1 = self.a1, self.a + self.a1 * n\n    self.b, self.b1 = self.b1, self.b + self.b1 * n\n\n  @property\n  def needterm(self):\n    return (self.b == 0 or self.b1 == 0) or not self.a//self.b == self.a1//self.b1\n\n  @property\n  def egress(self):\n    n = self.a // self.b\n    self.a,  self.b  = self.b,  self.a  - self.b  * n\n    self.a1, self.b1 = self.b1, self.a1 - self.b1 * n\n    return n\n\n  @property\n  def egress_done(self):\n    if self.needterm: self.a, self.b = self.a1, self.b1\n    return self.egress\n\n  @property\n  def done(self):\n    return self.b == 0 and self.b1 == 0\n"}
{"id": 351199, "name": "Here document", "source": "Translate Haskell to Python: main :: IO ()\nmain = do\n\n\n  putStrLn \"Hello\\\n            \\ World!\\n\"\n\n\n  putStrLn $ unwords [\"This\", \"is\", \"an\", \"example\", \"text!\\n\"]\n\n\n  putStrLn $ unlines [\n             unwords [\"This\", \"is\", \"the\", \"first\" , \"line.\"]\n           , unwords [\"This\", \"is\", \"the\", \"second\", \"line.\"]\n           , unwords [\"This\", \"is\", \"the\", \"third\" , \"line.\"]\n           ]\n", "target": "print()\n"}
{"id": 351200, "name": "Here document", "source": "Translate Haskell to Python: main :: IO ()\nmain = do\n\n\n  putStrLn \"Hello\\\n            \\ World!\\n\"\n\n\n  putStrLn $ unwords [\"This\", \"is\", \"an\", \"example\", \"text!\\n\"]\n\n\n  putStrLn $ unlines [\n             unwords [\"This\", \"is\", \"the\", \"first\" , \"line.\"]\n           , unwords [\"This\", \"is\", \"the\", \"second\", \"line.\"]\n           , unwords [\"This\", \"is\", \"the\", \"third\" , \"line.\"]\n           ]\n", "target": "print()\n"}
{"id": 351201, "name": "Abelian sandpile model_Identity", "source": "Translate Haskell to Python: \n\nimport Data.List (findIndex, transpose)\nimport Data.List.Split (chunksOf)\n\n\nmain :: IO ()\nmain = do\n  let s0 = [[4, 3, 3], [3, 1, 2], [0, 2, 3]]\n      s1 = [[1, 2, 0], [2, 1, 1], [0, 1, 3]]\n      s2 = [[2, 1, 3], [1, 0, 1], [0, 1, 0]]\n      s3_id = [[2, 1, 2], [1, 0, 1], [2, 1, 2]]\n      s3 = replicate 3 (replicate 3 3)\n      x:xs = reverse $ cascade s0\n  mapM_\n    putStrLn\n    [ \"Cascade:\"\n    , showCascade $ ([], x) : fmap (\"->\", ) xs\n    \n    , \"s1 + s2 == s2 + s1 -> \" <> show (addSand s1 s2 == addSand s2 s1)\n    , showCascade [([], s1), (\" +\", s2), (\" =\", addSand s1 s2)]\n    , showCascade [([], s2), (\" +\", s1), (\" =\", addSand s2 s1)]\n    \n    , \"s3 + s3_id == s3 -> \" <> show (addSand s3 s3_id == s3)\n    , showCascade [([], s3), (\" +\", s3_id), (\" =\", addSand s3 s3_id)]\n    \n    , \"s3_id + s3_id == s3_id -> \" <> show (addSand s3_id s3_id == s3_id)\n    , showCascade [([], s3_id), (\" +\", s3_id), (\" =\", addSand s3_id s3_id)]\n    ]\n\n\naddSand :: [[Int]] -> [[Int]] -> [[Int]]\naddSand xs ys =\n  (head . cascade . chunksOf (length xs)) $ zipWith (+) (concat xs) (concat ys)\n\ncascade :: [[Int]] -> [[[Int]]]\ncascade xs = chunksOf w <$> convergence (==) (iterate (tumble w) (concat xs))\n  where\n    w = length xs\n\nconvergence :: (a -> a -> Bool) -> [a] -> [a]\nconvergence p = go\n  where\n    go (x:ys@(y:_))\n      | p x y = [x]\n      | otherwise = go ys <> [x]\n\ntumble :: Int -> [Int] -> [Int]\ntumble w xs = maybe xs go $ findIndex (w <) xs\n  where\n    go i = zipWith f [0 ..] xs\n      where\n        neighbours = indexNeighbours w i\n        f j x\n          | j `elem` neighbours = succ x\n          | i == j = x - succ w\n          | otherwise = x\n\nindexNeighbours :: Int -> Int -> [Int]\nindexNeighbours w = go\n  where\n    go i =\n      concat\n        [ [ j\n          | j <- [i - w, i + w] \n          , -1 < j \n          , wSqr > j ]\n        , [ pred i\n          | 0 /= col ]\n        , [ succ i\n          | pred w /= col ]\n        ]\n      where\n        wSqr = w * w\n        col = rem i w\n\n\nshowCascade :: [(String, [[Int]])] -> String\nshowCascade pairs =\n  unlines $\n  fmap unwords $\n  transpose $\n  fmap\n    (\\(pfx, xs) ->\n        unwords <$> transpose (centered pfx : transpose (fmap (fmap show) xs)))\n    pairs\n\ncentered :: String -> [String]\ncentered s = [pad, s, pad <> replicate r ' ']\n  where\n    lng = length s\n    pad = replicate lng ' '\n    (q, r) = quotRem (2 + lng) 2\n", "target": "from itertools import product\nfrom collections import defaultdict\n\n\nclass Sandpile():\n    def __init__(self, gridtext):\n        array = [int(x) for x in gridtext.strip().split()]\n        self.grid = defaultdict(int,\n                                {(i //3, i % 3): x \n                                 for i, x in enumerate(array)})\n\n    _border = set((r, c) \n                  for r, c in product(range(-1, 4), repeat=2) \n                  if not 0 <= r <= 2 or not 0 <= c <= 2\n                  )\n    _cell_coords = list(product(range(3), repeat=2))\n    \n    def topple(self):\n        g = self.grid\n        for r, c in self._cell_coords:\n            if g[(r, c)] >= 4:\n                g[(r - 1, c)] += 1\n                g[(r + 1, c)] += 1\n                g[(r, c - 1)] += 1\n                g[(r, c + 1)] += 1\n                g[(r, c)] -= 4\n                return True\n        return False\n    \n    def stabilise(self):\n        while self.topple():\n            pass\n        \n        g = self.grid\n        for row_col in self._border.intersection(g.keys()):\n            del g[row_col]\n        return self\n    \n    __pos__ = stabilise     \n    \n    def __eq__(self, other):\n        g = self.grid\n        return all(g[row_col] == other.grid[row_col]\n                   for row_col in self._cell_coords)\n\n    def __add__(self, other):\n        g = self.grid\n        ans = Sandpile(\"\")\n        for row_col in self._cell_coords:\n            ans.grid[row_col] = g[row_col] + other.grid[row_col]\n        return ans.stabilise()\n       \n    def __str__(self):\n        g, txt = self.grid, []\n        for row in range(3):\n            txt.append(' '.join(str(g[(row, col)]) \n                                for col in range(3)))\n        return '\\n'.join(txt)\n    \n    def __repr__(self):\n        return f'{self.__class__.__name__}()'\n        \n\nunstable = Sandpile()\ns1 = Sandpile()\ns2 = Sandpile()\ns3 = Sandpile(\"3 3 3  3 3 3  3 3 3\")\ns3_id = Sandpile(\"2 1 2  1 0 1  2 1 2\")\n"}
{"id": 351202, "name": "Abelian sandpile model_Identity", "source": "Translate Haskell to Python: \n\nimport Data.List (findIndex, transpose)\nimport Data.List.Split (chunksOf)\n\n\nmain :: IO ()\nmain = do\n  let s0 = [[4, 3, 3], [3, 1, 2], [0, 2, 3]]\n      s1 = [[1, 2, 0], [2, 1, 1], [0, 1, 3]]\n      s2 = [[2, 1, 3], [1, 0, 1], [0, 1, 0]]\n      s3_id = [[2, 1, 2], [1, 0, 1], [2, 1, 2]]\n      s3 = replicate 3 (replicate 3 3)\n      x:xs = reverse $ cascade s0\n  mapM_\n    putStrLn\n    [ \"Cascade:\"\n    , showCascade $ ([], x) : fmap (\"->\", ) xs\n    \n    , \"s1 + s2 == s2 + s1 -> \" <> show (addSand s1 s2 == addSand s2 s1)\n    , showCascade [([], s1), (\" +\", s2), (\" =\", addSand s1 s2)]\n    , showCascade [([], s2), (\" +\", s1), (\" =\", addSand s2 s1)]\n    \n    , \"s3 + s3_id == s3 -> \" <> show (addSand s3 s3_id == s3)\n    , showCascade [([], s3), (\" +\", s3_id), (\" =\", addSand s3 s3_id)]\n    \n    , \"s3_id + s3_id == s3_id -> \" <> show (addSand s3_id s3_id == s3_id)\n    , showCascade [([], s3_id), (\" +\", s3_id), (\" =\", addSand s3_id s3_id)]\n    ]\n\n\naddSand :: [[Int]] -> [[Int]] -> [[Int]]\naddSand xs ys =\n  (head . cascade . chunksOf (length xs)) $ zipWith (+) (concat xs) (concat ys)\n\ncascade :: [[Int]] -> [[[Int]]]\ncascade xs = chunksOf w <$> convergence (==) (iterate (tumble w) (concat xs))\n  where\n    w = length xs\n\nconvergence :: (a -> a -> Bool) -> [a] -> [a]\nconvergence p = go\n  where\n    go (x:ys@(y:_))\n      | p x y = [x]\n      | otherwise = go ys <> [x]\n\ntumble :: Int -> [Int] -> [Int]\ntumble w xs = maybe xs go $ findIndex (w <) xs\n  where\n    go i = zipWith f [0 ..] xs\n      where\n        neighbours = indexNeighbours w i\n        f j x\n          | j `elem` neighbours = succ x\n          | i == j = x - succ w\n          | otherwise = x\n\nindexNeighbours :: Int -> Int -> [Int]\nindexNeighbours w = go\n  where\n    go i =\n      concat\n        [ [ j\n          | j <- [i - w, i + w] \n          , -1 < j \n          , wSqr > j ]\n        , [ pred i\n          | 0 /= col ]\n        , [ succ i\n          | pred w /= col ]\n        ]\n      where\n        wSqr = w * w\n        col = rem i w\n\n\nshowCascade :: [(String, [[Int]])] -> String\nshowCascade pairs =\n  unlines $\n  fmap unwords $\n  transpose $\n  fmap\n    (\\(pfx, xs) ->\n        unwords <$> transpose (centered pfx : transpose (fmap (fmap show) xs)))\n    pairs\n\ncentered :: String -> [String]\ncentered s = [pad, s, pad <> replicate r ' ']\n  where\n    lng = length s\n    pad = replicate lng ' '\n    (q, r) = quotRem (2 + lng) 2\n", "target": "from itertools import product\nfrom collections import defaultdict\n\n\nclass Sandpile():\n    def __init__(self, gridtext):\n        array = [int(x) for x in gridtext.strip().split()]\n        self.grid = defaultdict(int,\n                                {(i //3, i % 3): x \n                                 for i, x in enumerate(array)})\n\n    _border = set((r, c) \n                  for r, c in product(range(-1, 4), repeat=2) \n                  if not 0 <= r <= 2 or not 0 <= c <= 2\n                  )\n    _cell_coords = list(product(range(3), repeat=2))\n    \n    def topple(self):\n        g = self.grid\n        for r, c in self._cell_coords:\n            if g[(r, c)] >= 4:\n                g[(r - 1, c)] += 1\n                g[(r + 1, c)] += 1\n                g[(r, c - 1)] += 1\n                g[(r, c + 1)] += 1\n                g[(r, c)] -= 4\n                return True\n        return False\n    \n    def stabilise(self):\n        while self.topple():\n            pass\n        \n        g = self.grid\n        for row_col in self._border.intersection(g.keys()):\n            del g[row_col]\n        return self\n    \n    __pos__ = stabilise     \n    \n    def __eq__(self, other):\n        g = self.grid\n        return all(g[row_col] == other.grid[row_col]\n                   for row_col in self._cell_coords)\n\n    def __add__(self, other):\n        g = self.grid\n        ans = Sandpile(\"\")\n        for row_col in self._cell_coords:\n            ans.grid[row_col] = g[row_col] + other.grid[row_col]\n        return ans.stabilise()\n       \n    def __str__(self):\n        g, txt = self.grid, []\n        for row in range(3):\n            txt.append(' '.join(str(g[(row, col)]) \n                                for col in range(3)))\n        return '\\n'.join(txt)\n    \n    def __repr__(self):\n        return f'{self.__class__.__name__}()'\n        \n\nunstable = Sandpile()\ns1 = Sandpile()\ns2 = Sandpile()\ns3 = Sandpile(\"3 3 3  3 3 3  3 3 3\")\ns3_id = Sandpile(\"2 1 2  1 0 1  2 1 2\")\n"}
{"id": 351203, "name": "Base 16 numbers needing a to f", "source": "Translate Haskell to Python: import Data.List (intercalate, transpose)\nimport Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\n\n\np :: Int -> Bool\np n =\n  9 < n\n    && ( 9 < rem n 16\n           || p (quot n 16)\n       )\n\n\nmain :: IO ()\nmain =\n  let upperLimit = 500\n      xs = [show x | x <- [0 .. upperLimit], p x]\n   in mapM_\n        putStrLn\n        [ show (length xs)\n            <> \" matches up to \"\n            <> show upperLimit\n            <> \":\\n\",\n          table justifyRight \" \" $ chunksOf 15 xs\n        ]\n\n\n\ntable ::\n  (Int -> Char -> String -> String) ->\n  String ->\n  [[String]] ->\n  String\ntable alignment gap rows =\n  unlines $\n    fmap\n      ( intercalate gap\n          . zipWith (`alignment` ' ') colWidths\n      )\n      rows\n  where\n    colWidths = maximum . fmap length <$> transpose rows\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "\n\n\n\ndef p(n):\n    \n    return 9 < n and (9 < n % 16 or p(n // 16))\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 1 + 500)\n        if p(n)\n    ]\n    print(f'{len(xs)} matches for the predicate:\\n')\n    print(\n        table(6)(xs)\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351204, "name": "Base 16 numbers needing a to f", "source": "Translate Haskell to Python: import Data.List (intercalate, transpose)\nimport Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\n\n\np :: Int -> Bool\np n =\n  9 < n\n    && ( 9 < rem n 16\n           || p (quot n 16)\n       )\n\n\nmain :: IO ()\nmain =\n  let upperLimit = 500\n      xs = [show x | x <- [0 .. upperLimit], p x]\n   in mapM_\n        putStrLn\n        [ show (length xs)\n            <> \" matches up to \"\n            <> show upperLimit\n            <> \":\\n\",\n          table justifyRight \" \" $ chunksOf 15 xs\n        ]\n\n\n\ntable ::\n  (Int -> Char -> String -> String) ->\n  String ->\n  [[String]] ->\n  String\ntable alignment gap rows =\n  unlines $\n    fmap\n      ( intercalate gap\n          . zipWith (`alignment` ' ') colWidths\n      )\n      rows\n  where\n    colWidths = maximum . fmap length <$> transpose rows\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "\n\n\n\ndef p(n):\n    \n    return 9 < n and (9 < n % 16 or p(n // 16))\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 1 + 500)\n        if p(n)\n    ]\n    print(f'{len(xs)} matches for the predicate:\\n')\n    print(\n        table(6)(xs)\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351205, "name": "Juggler sequence", "source": "Translate Haskell to Python: import Text.Printf\nimport Data.List\n\njuggler :: Integer -> [Integer]\njuggler = takeWhile (> 1) . iterate (\\x -> if odd x\n                                           then isqrt (x*x*x)\n                                           else isqrt x)\n\ntask :: Integer -> IO ()\ntask n = printf s n (length ns + 1) (i :: Int) (showMax m)\n  where\n    ns = juggler n\n    (m, i) = maximum $ zip ns [0..]\n    s = \"n = %d length = %d maximal value at = %d (%s)\\n\"\n    showMax n = let s = show n\n                in if n > 10^100\n                   then show (length s) ++ \" digits\" \n                   else show n \n\nmain = do\n  mapM_ task [20..39]\n  putStrLn \"\\nTough guys\\n\"\n  mapM_ task [ 113, 173, 193, 2183, 11229, 15065, 15845, 30817 ]\n", "target": "from math import isqrt\n\ndef juggler(k, countdig=True, maxiters=1000):\n    m, maxj, maxjpos = k, k, 0\n    for i in range(1, maxiters):\n        m = isqrt(m) if m % 2 == 0 else isqrt(m * m * m)\n        if m >= maxj:\n            maxj, maxjpos  = m, i\n        if m == 1:\n            print(f\"{k: 9}{i: 6,}{maxjpos: 6}{len(str(maxj)) if countdig else maxj: 20,}{' digits' if countdig else ''}\")\n            return i\n\n    print(\"ERROR: Juggler series starting with $k did not converge in $maxiters iterations\")\n\n\nprint(\"       n    l(n)  i(n)       h(n) or d(n)\\n-------------------------------------------\")\nfor k in range(20, 40):\n    juggler(k, False)\n\nfor k in [113, 173, 193, 2183, 11229, 15065, 15845, 30817, 48443, 275485, 1267909]:\n    juggler(k)\n"}
{"id": 351206, "name": "Juggler sequence", "source": "Translate Haskell to Python: import Text.Printf\nimport Data.List\n\njuggler :: Integer -> [Integer]\njuggler = takeWhile (> 1) . iterate (\\x -> if odd x\n                                           then isqrt (x*x*x)\n                                           else isqrt x)\n\ntask :: Integer -> IO ()\ntask n = printf s n (length ns + 1) (i :: Int) (showMax m)\n  where\n    ns = juggler n\n    (m, i) = maximum $ zip ns [0..]\n    s = \"n = %d length = %d maximal value at = %d (%s)\\n\"\n    showMax n = let s = show n\n                in if n > 10^100\n                   then show (length s) ++ \" digits\" \n                   else show n \n\nmain = do\n  mapM_ task [20..39]\n  putStrLn \"\\nTough guys\\n\"\n  mapM_ task [ 113, 173, 193, 2183, 11229, 15065, 15845, 30817 ]\n", "target": "from math import isqrt\n\ndef juggler(k, countdig=True, maxiters=1000):\n    m, maxj, maxjpos = k, k, 0\n    for i in range(1, maxiters):\n        m = isqrt(m) if m % 2 == 0 else isqrt(m * m * m)\n        if m >= maxj:\n            maxj, maxjpos  = m, i\n        if m == 1:\n            print(f\"{k: 9}{i: 6,}{maxjpos: 6}{len(str(maxj)) if countdig else maxj: 20,}{' digits' if countdig else ''}\")\n            return i\n\n    print(\"ERROR: Juggler series starting with $k did not converge in $maxiters iterations\")\n\n\nprint(\"       n    l(n)  i(n)       h(n) or d(n)\\n-------------------------------------------\")\nfor k in range(20, 40):\n    juggler(k, False)\n\nfor k in [113, 173, 193, 2183, 11229, 15065, 15845, 30817, 48443, 275485, 1267909]:\n    juggler(k)\n"}

{"id": 338126, "name": "Long year", "source": "Translate Swift to Java: func isLongYear(_ year: Int) -> Bool {\n  let year1 = year - 1\n  let p = (year + (year / 4) - (year / 100) + (year / 400)) % 7\n  let p1 = (year1 + (year1 / 4) - (year1 / 100) + (year1 / 400)) % 7\n\n  return p == 4 || p1 == 3\n}\n\nfor range in [1900...1999, 2000...2099, 2100...2199] {\n  print(\"\\(range): \\(range.filter(isLongYear))\")\n}\n", "target": "import java.time.LocalDate;\nimport java.time.temporal.WeekFields;\n\npublic class LongYear {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Long years this century:%n\");\n        for (int year = 2000 ; year < 2100 ; year++ ) {\n            if ( longYear(year) ) {\n                System.out.print(year + \"  \");\n            }\n        }\n    }\n    \n    private static boolean longYear(int year) {\n        return LocalDate.of(year, 12, 28).get(WeekFields.ISO.weekOfYear()) == 53;\n    }\n\n}\n"}
{"id": 338127, "name": "Mian-Chowla sequence", "source": "Translate Swift to Java: public func mianChowla(n: Int) -> [Int] {\n  var mc = Array(repeating: 0, count: n)\n  var ls = [2: true]\n  var sum = 0\n\n  mc[0] = 1\n\n  for i in 1..<n {\n    var lsx = [Int]()\n\n    jLoop: for j in (mc[i-1]+1)... {\n      mc[i] = j\n\n      for k in 0...i {\n        sum = mc[k] + j\n\n        if ls[sum] ?? false {\n          lsx = []\n          continue jLoop\n        }\n\n        lsx.append(sum)\n      }\n\n      for n in lsx {\n        ls[n] = true\n      }\n\n      break\n    }\n  }\n\n  return mc\n}\n\nlet seq = mianChowla(n: 100)\n\nprint(\"First 30 terms in sequence are: \\(Array(seq.prefix(30)))\")\nprint(\"Terms 91 to 100 are: \\(Array(seq[90..<100]))\")\n", "target": "import java.util.Arrays;\n\npublic class MianChowlaSequence {\n\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        System.out.println(\"First 30 terms of the Mian\u2013Chowla sequence.\");\n        mianChowla(1, 30);\n        System.out.println(\"Terms 91 through 100 of the Mian\u2013Chowla sequence.\");\n        mianChowla(91, 100);\n        long end = System.currentTimeMillis();\n        System.out.printf(\"Elapsed = %d ms%n\", (end-start));\n    }\n\n    private static void mianChowla(int minIndex, int maxIndex) {\n        int [] sums = new int[1];\n        int [] chowla = new int[maxIndex+1];\n        sums[0] = 2;\n        chowla[0] = 0;\n        chowla[1] = 1;\n        if ( minIndex == 1 ) {\n            System.out.printf(\"%d \", 1);\n        }\n        int chowlaLength = 1;\n        for ( int n = 2 ; n <= maxIndex ; n++ ) {\n\n            \n            int test = chowla[n - 1];\n            \n            int[] sumsNew = Arrays.copyOf(sums, sums.length + n);\n            int sumNewLength = sums.length;\n            int savedsSumNewLength = sumNewLength;\n            \n            \n            boolean found = false;\n            while ( ! found ) {\n                test++;\n                found = true;\n                sumNewLength = savedsSumNewLength;\n                \n                for ( int j = 0 ; j <= chowlaLength ; j++ ) {\n                    int testSum = (j == 0 ? test : chowla[j]) + test;\n                    boolean duplicate = false;\n                    \n                    \n                    for ( int k = 0 ; k < sumNewLength ; k++ ) {\n                        if ( sumsNew[k] == testSum ) {\n                            duplicate = true;\n                            break;\n                        }\n                    }\n                    if ( ! duplicate ) {\n                        \n                        sumsNew[sumNewLength] = testSum;\n                        sumNewLength++;\n                    }\n                    else {\n                        \n                        found = false;\n                        break;\n                    }\n                }\n            }\n            \n            \n            chowla[n] = test;\n            chowlaLength++;            \n            sums = sumsNew;\n            if ( n >= minIndex ) {\n                System.out.printf(\"%d %s\", chowla[n], (n==maxIndex ? \"\\n\" : \"\"));\n            }\n        }\n    }\n\n}\n"}
{"id": 338128, "name": "Water collected between towers", "source": "Translate Swift to Java: \n\n\nfunc waterCollected(_ heights: [Int]) -> Int {\n    guard heights.count > 0 else {\n        return 0\n    }\n    var water = 0\n    var left = 0, right = heights.count - 1\n    var maxLeft = heights[left], maxRight = heights[right]\n    \n    while left < right {\n        if heights[left] <= heights[right] {\n            maxLeft = max(heights[left], maxLeft)\n            water += maxLeft - heights[left]\n            left += 1\n        } else {\n            maxRight = max(heights[right], maxRight)\n            water += maxRight - heights[right]\n            right -= 1\n        }\n    }\n    return water\n}\n\nfor heights in [[1, 5, 3, 7, 2],\n                [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],\n                [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],\n                [5, 5, 5, 5],\n                [5, 6, 7, 8],\n                [8, 7, 7, 6],\n                [6, 7, 10, 7, 6]] {\n    print(\"water collected = \\(waterCollected(heights))\")\n}\n", "target": "public class WaterBetweenTowers {\n    public static void main(String[] args) {\n        int i = 1;\n        int[][] tba = new int[][]{\n            new int[]{1, 5, 3, 7, 2},\n            new int[]{5, 3, 7, 2, 6, 4, 5, 9, 1, 2},\n            new int[]{2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1},\n            new int[]{5, 5, 5, 5},\n            new int[]{5, 6, 7, 8},\n            new int[]{8, 7, 7, 6},\n            new int[]{6, 7, 10, 7, 6}\n        };\n\n        for (int[] tea : tba) {\n            int rht, wu = 0, bof;\n            do {\n                for (rht = tea.length - 1; rht >= 0; rht--) {\n                    if (tea[rht] > 0) {\n                        break;\n                    }\n                }\n\n                if (rht < 0) {\n                    break;\n                }\n\n                bof = 0;\n                for (int col = 0; col <= rht; col++) {\n                    if (tea[col] > 0) {\n                        tea[col]--;\n                        bof += 1;\n                    } else if (bof > 0) {\n                        wu++;\n                    }\n                }\n                if (bof < 2) {\n                    break;\n                }\n            } while (true);\n\n            System.out.printf(\"Block %d\", i++);\n            if (wu == 0) {\n                System.out.print(\" does not hold any\");\n            } else {\n                System.out.printf(\" holds %d\", wu);\n            }\n            System.out.println(\" water units.\");\n        }\n    }\n}\n"}
{"id": 338129, "name": "Orbital elements", "source": "Translate Swift to Java: import Foundation\n\npublic struct Vector {\n  public var x = 0.0\n  public var y = 0.0\n  public var z = 0.0\n\n  public init(x: Double, y: Double, z: Double) {\n    (self.x, self.y, self.z) = (x, y, z)\n  }\n\n  public func mod() -> Double {\n    (x * x + y * y + z * z).squareRoot()\n  }\n\n  public static func + (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      x: lhs.x + rhs.x,\n      y: lhs.y + rhs.y,\n      z: lhs.z + rhs.z\n    )\n  }\n\n  public static func * (lhs: Vector, rhs: Double) -> Vector {\n    return Vector(\n      x: lhs.x * rhs,\n      y: lhs.y * rhs,\n      z: lhs.z * rhs\n    )\n  }\n\n  public static func *= (lhs: inout Vector, rhs: Double) {\n    lhs.x *= rhs\n    lhs.y *= rhs\n    lhs.z *= rhs\n  }\n\n  public static func / (lhs: Vector, rhs: Double) -> Vector {\n    return lhs * (1 / rhs)\n  }\n\n  public static func /= (lhs: inout Vector, rhs: Double) {\n    lhs = lhs * (1 / rhs)\n  }\n}\n\nextension Vector: CustomStringConvertible {\n  public var description: String {\n    return String(format: \"%.6f\\t%.6f\\t%.6f\", x, y, z)\n  }\n}\n\nprivate func mulAdd(v1: Vector, x1: Double, v2: Vector, x2: Double) -> Vector {\n  return v1 * x1 + v2 * x2\n}\n\nprivate func rotate(_ i: Vector, _ j: Vector, alpha: Double) -> (Vector, Vector) {\n  return (\n    mulAdd(v1: i, x1: +cos(alpha), v2: j, x2: sin(alpha)),\n    mulAdd(v1: i, x1: -sin(alpha), v2: j, x2: cos(alpha))\n  )\n}\n\npublic func orbitalStateVectors(\n  semimajorAxis: Double,\n  eccentricity: Double,\n  inclination: Double,\n  longitudeOfAscendingNode: Double,\n  argumentOfPeriapsis: Double,\n  trueAnomaly: Double\n) -> (Vector, Vector) {\n  var i = Vector(x: 1.0, y: 0.0, z: 0.0)\n  var j = Vector(x: 0.0, y: 1.0, z: 0.0)\n  let k = Vector(x: 0.0, y: 0.0, z: 1.0)\n\n  (i, j) = rotate(i, j, alpha: longitudeOfAscendingNode)\n  (j, _) = rotate(j, k, alpha: inclination)\n  (i, j) = rotate(i, j, alpha: argumentOfPeriapsis)\n\n  let l = eccentricity == 1.0 ? 2.0 : 1.0 - eccentricity * eccentricity\n  let c = cos(trueAnomaly)\n  let s = sin(trueAnomaly)\n  let r = l / (1.0 + eccentricity * c)\n  let rPrime = s * r * r / l\n  let position = mulAdd(v1: i, x1: c, v2: j, x2: s) * r\n  var speed = mulAdd(v1: i, x1: rPrime * c - r * s, v2: j, x2: rPrime * s + r * c)\n\n  speed /= speed.mod()\n  speed *= (2.0 / r - 1.0 / semimajorAxis).squareRoot()\n\n  return (position, speed)\n}\n\nlet (position, speed) = orbitalStateVectors(\n  semimajorAxis: 1.0,\n  eccentricity: 0.1,\n  inclination: 0.0,\n  longitudeOfAscendingNode: 355.0 / (113.0 * 6.0),\n  argumentOfPeriapsis: 0.0,\n  trueAnomaly: 0.0\n)\n\nprint(\"Position: \\(position); Speed: \\(speed)\")\n", "target": "public class OrbitalElements {\n    private static class Vector {\n        private double x, y, z;\n \n        public Vector(double x, double y, double z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n \n        public Vector plus(Vector rhs) {\n            return new Vector(x + rhs.x, y + rhs.y, z + rhs.z);\n        }\n \n        public Vector times(double s) {\n            return new Vector(s * x, s * y, s * z);\n        }\n \n        public Vector div(double d) {\n            return new Vector(x / d, y / d, z / d);\n        }\n \n        public double abs() {\n            return Math.sqrt(x * x + y * y + z * z);\n        }\n \n        @Override\n        public String toString() {\n            return String.format(\"(%.16f,\u00a0%.16f,\u00a0%.16f)\", x, y, z);\n        }\n    }\n \n    private static Vector mulAdd(Vector v1, Double x1, Vector v2, Double x2) {\n        return v1.times(x1).plus(v2.times(x2));\n    }\n \n    private static Vector[] rotate(Vector i, Vector j, double alpha) {\n        return new Vector[]{\n            mulAdd(i, Math.cos(alpha), j, Math.sin(alpha)),\n            mulAdd(i, -Math.sin(alpha), j, Math.cos(alpha))\n        };\n    }\n \n    private static Vector[] orbitalStateVectors(\n        double semimajorAxis, double eccentricity, \n        double inclination, double longitudeOfAscendingNode, \n        double argumentOfPeriapsis, double trueAnomaly\n    ) {\n        Vector i = new Vector(1, 0, 0);\n        Vector j = new Vector(0, 1, 0);\n        Vector k = new Vector(0, 0, 1);\n \n        Vector[] p = rotate(i, j, longitudeOfAscendingNode);\n        i = p[0];\n        j = p[1];\n        p = rotate(j, k, inclination);\n        j = p[0];\n        p = rotate(i, j, argumentOfPeriapsis);\n        i = p[0];\n        j = p[1];\n \n        double l = (eccentricity == 1.0) ? 2.0 : 1.0 - eccentricity * eccentricity;\n        l *= semimajorAxis;\n        double c = Math.cos(trueAnomaly);\n        double s = Math.sin(trueAnomaly);\n        double r = l / (1.0 + eccentricity * c);\n        double rprime = s * r * r / l;\n        Vector position = mulAdd(i, c, j, s).times(r);\n        Vector speed = mulAdd(i, rprime * c - r * s, j, rprime * s + r * c);\n        speed = speed.div(speed.abs());\n        speed = speed.times(Math.sqrt(2.0 / r - 1.0 / semimajorAxis));\n \n        return new Vector[]{position, speed};\n    }\n \n    public static void main(String[] args) {\n        Vector[] ps = orbitalStateVectors(1.0, 0.1, 0.0, 355.0 / (113.0 * 6.0), 0.0, 0.0);\n        System.out.printf(\"Position\u00a0: %s\\n\", ps[0]);\n        System.out.printf(\"Speed\u00a0: %s\\n\", ps[1]);\n    }\n}\n"}
{"id": 338130, "name": "ABC words", "source": "Translate Swift to Java: import Foundation\n\nfunc loadDictionary(_ path: String) throws -> [String] {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return contents.components(separatedBy: \"\\n\")\n}\n\nfunc isAbcWord(_ word: String) -> Bool {\n    var a = false\n    var b = false\n    for ch in word {\n        switch (ch) {\n        case \"a\":\n            if !a {\n                a = true\n            }\n        case \"b\":\n            if !b {\n                if !a {\n                    return false\n                }\n                b = true\n            }\n        case \"c\":\n            return b\n        default:\n            break\n        }\n    }\n    return false\n}\n\ndo {\n    let dictionary = try loadDictionary(\"unixdict.txt\")\n    var n = 1\n    for word in dictionary {\n        if isAbcWord(word) {\n            print(\"\\(n): \\(word)\")\n            n += 1\n        }\n    }\n} catch {\n    print(error)\n}\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class AbcWords {\n    public static void main(String[] args) {\n        String fileName = \"unixdict.txt\";\n        String chars = \"abc\";\n        for (int i = 0; i + 1 < args.length\n                && args[i].length() > 1\n                && args[i].charAt(0) == '-'; ++i) {\n            switch (args[i].charAt(1)) {\n            case 'f':\n                fileName = args[++i];\n                break;\n            case 'c':\n                chars = args[++i];\n                break;\n            }\n        }\n        \n        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n            String line;\n            int n = 0;\n            while ((line = reader.readLine()) != null) {\n                if (match(line, chars)) {\n                    ++n;\n                    System.out.printf(\"%3d:\u00a0%-20s\", n, line);\n                    if (n % 3 == 0)\n                        System.out.println();\n                }\n            }\n            if (n > 0 && n % 3 != 0)\n                System.out.println();\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n\n    \n    \n    private static boolean match(String word, String chars) {\n        int length = chars.length();\n        boolean[] seen = new boolean[length];\n        int wordLength = word.length();\n        for (int w = 0; w < wordLength; ++w) {\n            char ch = word.charAt(w);\n            int index = -1;\n            for (int c = 0; c < length; ++c) {\n                if (ch == chars.charAt(c) && !seen[c]) {\n                    index = c;\n                    break;\n                }\n            }\n            if (index == -1)\n                continue;\n            if (index + 1 == length)\n                return index == 0 ? true : seen[index - 1];\n            if (index > 0 && !seen[index - 1])\n                return false;\n            seen[index] = true;\n        }\n        return false;\n    }\n}\n"}
{"id": 338131, "name": "Text between", "source": "Translate Swift to Java: import Foundation\n\npublic extension String {\n  func textBetween(_ startDelim: String, and endDelim: String) -> String {\n    precondition(!startDelim.isEmpty && !endDelim.isEmpty)\n\n    let startIdx: String.Index\n    let endIdx: String.Index\n\n    if startDelim == \"start\" {\n      startIdx = startIndex\n    } else if let r = range(of: startDelim) {\n      startIdx = r.upperBound\n    } else {\n      return \"\"\n    }\n\n    if endDelim == \"end\" {\n      endIdx = endIndex\n    } else if let r = self[startIdx...].range(of: endDelim) {\n      endIdx = r.lowerBound\n    } else {\n      endIdx = endIndex\n    }\n\n    return String(self[startIdx..<endIdx])\n  }\n}\n\nlet tests = [\n  (\"Hello Rosetta Code world\", \"Hello \", \" world\"),\n  (\"Hello Rosetta Code world\", \"start\", \" world\"),\n  (\"Hello Rosetta Code world\", \"Hello \", \"end\"),\n  (\"</div><div style=\\\"chinese\\\">\u4f60\u597d\u55ce</div>\", \"<div style=\\\"chinese\\\">\", \"</div>\"),\n  (\"<text>Hello <span>Rosetta Code</span> world</text><table style=\\\"myTable\\\">\", \"<text>\", \"<table>\"),\n  (\"<table style=\\\"myTable\\\"><tr><td>hello world</td></tr></table>\", \"<table>\", \"</table>\"),\n  (\"The quick brown fox jumps over the lazy other fox\", \"quick \", \" fox\"),\n  (\"One fish two fish red fish blue fish\", \"fish \", \" red\"),\n  (\"FooBarBazFooBuxQuux\", \"Foo\", \"Foo\")\n]\n\nfor (input, start, end) in tests {\n  print(\"Input: \\\"\\(input)\\\"\")\n  print(\"Start delimiter: \\\"\\(start)\\\"\")\n  print(\"End delimiter: \\\"\\(end)\\\"\")\n  print(\"Text between: \\\"\\(input.textBetween(start, and: end))\\\"\\n\")\n}\n", "target": "public class textBetween\n{\n    \n    static String textBetween(String thisText, String startString, String endString)\n    {\n    \tString returnText = \"\";\n    \tint startIndex = 0;\n    \tint endIndex = 0;\n    \t\n    \tif (startString.equals(\"start\"))\n    \t{\n    \t\tstartIndex = 0;\n    \t} else {\n\t    \tstartIndex = thisText.indexOf(startString);\n\t    \t\n\t    \tif (startIndex < 0) \n\t        {\n\t        \treturn \"\";\t        \t\n\t        } else {\n\t        \tstartIndex = startIndex + startString.length();\n\t        }\n    \t}\n        \n    \tif (endString.equals(\"end\"))\n    \t{\n    \t\tendIndex = thisText.length();\n    \t} else {\n    \t\tendIndex = thisText.indexOf(endString);\n            \n            if (endIndex <= 0) \n            {\n            \treturn \"\";\n            } else {\n\n            }\t\n    \t}\n    \t\n    \treturnText = thisText.substring(startIndex,endIndex);\n    \t\n    \treturn returnText;\n    } \n\n    \n    public static void main(String[] args)\n    {\n    \tString thisText = args[0];\n    \tString startDelimiter = args[1];\n    \tString endDelimiter = args[2];\n    \t\n    \tString returnText = \"\";\n    \treturnText = textBetween(thisText, startDelimiter, endDelimiter);\n    \t\n        System.out.println(returnText);\n\n    } \n    \n} \n"}
{"id": 338132, "name": "Two identical strings", "source": "Translate Swift to Java: print(\"Decimal\\tBinary\")\nvar n = 1\nwhile (true) {\n    let binary = String(n, radix: 2)\n    let i = n + (n << binary.count)\n    if i >= 1000 {\n        break\n    }\n    print(\"\\(i)\\t\\(binary)\\(binary)\")\n    n += 1\n}\n", "target": "public class TwoIdenticalStrings {\n    public static void main(String[] args) {\n        System.out.println(\"Decimal Binary\");\n        for (int i = 0; i < 1_000; i++) {\n            String binStr = Integer.toBinaryString(i);\n            if (binStr.length() % 2 == 0) {\n                int len = binStr.length() / 2;\n                if (binStr.substring(0, len).equals(binStr.substring(len))) {\n                    System.out.printf(\"%7d %s%n\", i, binStr);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 338133, "name": "Alternade words", "source": "Translate Swift to Java: import Foundation\n\nfunc loadDictionary(_ path: String) throws -> Set<String> {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return Set<String>(contents.components(separatedBy: \"\\n\").filter{!$0.isEmpty})\n}\n\nfunc lpad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : string + String(repeating: \" \", count: width - string.count)\n}\n\ndo {\n    let dictionary = try loadDictionary(\"unixdict.txt\")\n    var alternades: [(String,String,String)] = []\n    for word in dictionary {\n        if word.count < 6 {\n            continue\n        }\n        var word1 = \"\"\n        var word2 = \"\"\n        for (i, c) in word.enumerated() {\n            if (i & 1) == 0 {\n                word1.append(c)\n            } else {\n                word2.append(c)\n            }\n        }\n        if dictionary.contains(word1) && dictionary.contains(word2) {\n            alternades.append((word, word1, word2))\n        }\n    }\n    alternades.sort(by: {$0.0 < $1.0})\n    for (word, word1, word2) in alternades {\n        print(\"\\(lpad(string: word, width: 10))\\(lpad(string: word1, width: 6))\\(word2)\")\n    }\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class AlternadeWords {\n    public static void main(String[] args) {\n        try {\n            Set<String> dictionary = new TreeSet<>();\n            try (BufferedReader reader = new BufferedReader(new FileReader(\"unixdict.txt\"))) {\n                String line;\n                while ((line = reader.readLine()) != null)\n                    dictionary.add(line);\n            }\n            StringBuilder word1 = new StringBuilder();\n            StringBuilder word2 = new StringBuilder();\n            for (String word : dictionary) {\n                int length = word.length();\n                if (length < 6)\n                    continue;\n                word1.setLength(0);\n                word2.setLength(0);\n                for (int i = 0; i < length; i += 2) {\n                    word1.append(word.charAt(i));\n                    if (i + 1 < length)\n                        word2.append(word.charAt(i + 1));\n                }\n                String w1 = word1.toString();\n                String w2 = word2.toString();\n                if (dictionary.contains(w1) && dictionary.contains(w2))\n                    System.out.printf(\"%-10s%-6s%s\\n\", word, w1, w2);\n            }\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"id": 338134, "name": "Pythagorean triples", "source": "Translate Swift to Java: var total = 0\nvar prim = 0\nvar maxPeri = 100\n\nfunc newTri(s0:Int, _ s1:Int, _ s2: Int) -> () {\n    \n    let p = s0 + s1 + s2\n    if p <= maxPeri {\n        prim += 1\n        total += maxPeri / p\n        newTri( s0 + 2*(-s1+s2), 2*( s0+s2) - s1, 2*( s0-s1+s2) + s2)\n        newTri( s0 + 2*( s1+s2), 2*( s0+s2) + s1, 2*( s0+s1+s2) + s2)\n        newTri(-s0 + 2*( s1+s2), 2*(-s0+s2) + s1, 2*(-s0+s1+s2) + s2)\n    }\n}\n\nwhile maxPeri <= 100_000_000 {\n    prim = 0\n    total = 0\n    newTri(3, 4, 5)\n    print(\"Up to \\(maxPeri)\u00a0: \\(total) triples \\( prim) primitives.\")\n    maxPeri *= 10\n}\n", "target": "import java.math.BigInteger;\nimport static java.math.BigInteger.ONE;\n\npublic class PythTrip{\n\n    public static void main(String[] args){\n        long tripCount = 0, primCount = 0;\n\n        \n        BigInteger periLimit = BigInteger.valueOf(100),\n                peri2 = periLimit.divide(BigInteger.valueOf(2)),\n                peri3 = periLimit.divide(BigInteger.valueOf(3));\n\n        for(BigInteger a = ONE; a.compareTo(peri3) < 0; a = a.add(ONE)){\n            BigInteger aa = a.multiply(a);\n            \n            for(BigInteger b = a.add(ONE);\n                    b.compareTo(peri2) < 0; b = b.add(ONE)){\n                BigInteger bb = b.multiply(b);\n                BigInteger ab = a.add(b);\n                BigInteger aabb = aa.add(bb);\n                \n                for(BigInteger c = b.add(ONE);\n                        c.compareTo(peri2) < 0; c = c.add(ONE)){\n\n                    int compare = aabb.compareTo(c.multiply(c));\n                    \n                    if(ab.add(c).compareTo(periLimit) > 0){\n                        break;\n                    }\n                    \n                    if(compare < 0){\n                        break;\n                    }else if (compare == 0){\n                        tripCount++;\n                        System.out.print(a + \", \" + b + \", \" + c);\n\n                        \n                        if(a.gcd(b).equals(ONE)){\n                            System.out.print(\" primitive\");\n                            primCount++;\n                        }\n                        System.out.println();\n                    }\n                }\n            }\n        }\n        System.out.println(\"Up to a perimeter of \" + periLimit + \", there are \"\n                + tripCount + \" triples, of which \" + primCount + \" are primitive.\");\n    }\n}\n"}
{"id": 338135, "name": "Pythagorean triples", "source": "Translate Swift to Java: var total = 0\nvar prim = 0\nvar maxPeri = 100\n\nfunc newTri(s0:Int, _ s1:Int, _ s2: Int) -> () {\n    \n    let p = s0 + s1 + s2\n    if p <= maxPeri {\n        prim += 1\n        total += maxPeri / p\n        newTri( s0 + 2*(-s1+s2), 2*( s0+s2) - s1, 2*( s0-s1+s2) + s2)\n        newTri( s0 + 2*( s1+s2), 2*( s0+s2) + s1, 2*( s0+s1+s2) + s2)\n        newTri(-s0 + 2*( s1+s2), 2*(-s0+s2) + s1, 2*(-s0+s1+s2) + s2)\n    }\n}\n\nwhile maxPeri <= 100_000_000 {\n    prim = 0\n    total = 0\n    newTri(3, 4, 5)\n    print(\"Up to \\(maxPeri)\u00a0: \\(total) triples \\( prim) primitives.\")\n    maxPeri *= 10\n}\n", "target": "import java.math.BigInteger;\nimport static java.math.BigInteger.ONE;\n\npublic class PythTrip{\n\n    public static void main(String[] args){\n        long tripCount = 0, primCount = 0;\n\n        \n        BigInteger periLimit = BigInteger.valueOf(100),\n                peri2 = periLimit.divide(BigInteger.valueOf(2)),\n                peri3 = periLimit.divide(BigInteger.valueOf(3));\n\n        for(BigInteger a = ONE; a.compareTo(peri3) < 0; a = a.add(ONE)){\n            BigInteger aa = a.multiply(a);\n            \n            for(BigInteger b = a.add(ONE);\n                    b.compareTo(peri2) < 0; b = b.add(ONE)){\n                BigInteger bb = b.multiply(b);\n                BigInteger ab = a.add(b);\n                BigInteger aabb = aa.add(bb);\n                \n                for(BigInteger c = b.add(ONE);\n                        c.compareTo(peri2) < 0; c = c.add(ONE)){\n\n                    int compare = aabb.compareTo(c.multiply(c));\n                    \n                    if(ab.add(c).compareTo(periLimit) > 0){\n                        break;\n                    }\n                    \n                    if(compare < 0){\n                        break;\n                    }else if (compare == 0){\n                        tripCount++;\n                        System.out.print(a + \", \" + b + \", \" + c);\n\n                        \n                        if(a.gcd(b).equals(ONE)){\n                            System.out.print(\" primitive\");\n                            primCount++;\n                        }\n                        System.out.println();\n                    }\n                }\n            }\n        }\n        System.out.println(\"Up to a perimeter of \" + periLimit + \", there are \"\n                + tripCount + \" triples, of which \" + primCount + \" are primitive.\");\n    }\n}\n"}
{"id": 338136, "name": "Call a foreign-language function", "source": "Translate Swift to Java: import Foundation\n\nlet hello = \"Hello, World!\"\nlet fromC = strdup(hello)\nlet backToSwiftString = String.fromCString(fromC)\n", "target": "public class JNIDemo\n{\n  static\n  {  System.loadLibrary(\"JNIDemo\");  }\n  \n  public static void main(String[] args)\n  {\n    System.out.println(callStrdup(\"Hello World!\"));\n  }\n  \n  private static native String callStrdup(String s);\n}\n"}
{"id": 338137, "name": "Extensible prime generator", "source": "Translate Swift to Java: import Foundation\n\nfunc soeDictOdds() -> UnfoldSequence<Int, Int> {\n  var bp = 5; var q = 25\n  var bps: UnfoldSequence<Int, Int>.Iterator? = nil\n  var dict = [9: 6] \n  return sequence(state: 2, next: { n in\n    if n < 9 { if n < 3 { n = 3; return 2 }; defer {n += 2}; return n }\n    while n >= q || dict[n] != nil {\n      if n >= q {\n        let inc = bp + bp\n        dict[n + inc] = inc\n        if bps == nil {\n          bps = soeDictOdds().makeIterator()\n          bp = (bps?.next())!; bp = (bps?.next())!; bp = (bps?.next())! \n        }\n        bp = (bps?.next())!; q = bp * bp \n      } else {\n        let inc = dict[n] ?? 0\n        dict[n] = nil\n        var next = n + inc\n        while dict[next] != nil { next += inc }\n        dict[next] = inc\n      }\n      n += 2\n    }\n    defer { n += 2 }; return n\n  })\n}\n\nprint(\"The first 20 primes are:  \", terminator: \"\")\nsoeDictOdds().lazy.prefix(20).forEach { print($0, \"\", terminator: \"\") }\nprint()\n\nprint(\"The primes between 100 and 150 are:  \", terminator: \"\")\nsoeDictOdds().lazy.drop(while: { $0 < Prime(100) }).lazy.prefix(while: { $0 <= 150 })\n    .forEach { print($0, \"\", terminator: \"\") }\nprint()\n\nprint(\"The number of primes from 7700 to 8000 is \u00a0:\", terminator: \"\")\nprint(soeDictOdds().lazy.drop(while: { $0 < 7700 }).lazy.prefix(while: { $0 <= 8000 })\n        .lazy.reduce(0, { a, _ in a + 1 }))\n\nprint(\"The 10,000th prime is:  \", terminator: \"\")\nprint((soeDictOdds().lazy.dropFirst(9999).first { $0 == $0 })!)\n\nprint(\"The sum of primes to 2 million is:  \", terminator: \"\")\n\nlet start = NSDate()\nlet answr = soeDictOdds().lazy.prefix(while: { $0 <= 2000000 })\n              .reduce(0, { a, p in a + Int64(p) })\nlet elpsd = -start.timeIntervalSinceNow\n\nprint(answr)\nprint(String(format: \"This test took\u00a0%.3f milliseconds.\", elpsd * 1000))\n", "target": "import java.util.*;\n\npublic class PrimeGenerator {\n    private int limit_;\n    private int index_ = 0;\n    private int increment_;\n    private int count_ = 0;\n    private List<Integer> primes_ = new ArrayList<>();\n    private BitSet sieve_ = new BitSet();\n    private int sieveLimit_ = 0;\n\n    public PrimeGenerator(int initialLimit, int increment) {\n        limit_ = nextOddNumber(initialLimit);\n        increment_ = increment;\n        primes_.add(2);\n        findPrimes(3);\n    }\n\n    public int nextPrime() {\n        if (index_ == primes_.size()) {\n            if (Integer.MAX_VALUE - increment_ < limit_)\n                return 0;\n            int start = limit_ + 2;\n            limit_ = nextOddNumber(limit_ + increment_);\n            primes_.clear();\n            findPrimes(start);\n        }\n        ++count_;\n        return primes_.get(index_++);\n    }\n\n    public int count() {\n        return count_;\n    }\n\n    private void findPrimes(int start) {\n        index_ = 0;\n        int newLimit = sqrt(limit_);\n        for (int p = 3; p * p <= newLimit; p += 2) {\n            if (sieve_.get(p/2 - 1))\n                continue;\n            int q = p * Math.max(p, nextOddNumber((sieveLimit_ + p - 1)/p));\n            for (; q <= newLimit; q += 2*p)\n                sieve_.set(q/2 - 1, true);\n        }\n        sieveLimit_ = newLimit;\n        int count = (limit_ - start)/2 + 1;\n        BitSet composite = new BitSet(count);\n        for (int p = 3; p <= newLimit; p += 2) {\n            if (sieve_.get(p/2 - 1))\n                continue;\n            int q = p * Math.max(p, nextOddNumber((start + p - 1)/p)) - start;\n            q /= 2;\n            for (; q >= 0 && q < count; q += p)\n                composite.set(q, true);\n        }\n        for (int p = 0; p < count; ++p) {\n            if (!composite.get(p))\n                primes_.add(p * 2 + start);\n        }\n    }\n\n    private static int sqrt(int n) {\n        return nextOddNumber((int)Math.sqrt(n));\n    }\n\n    private static int nextOddNumber(int n) {\n        return 1 + 2 * (n/2);\n    }\n\n    public static void main(String[] args) {\n        PrimeGenerator pgen = new PrimeGenerator(20, 200000);\n        System.out.println(\"First 20 primes:\");\n        for (int i = 0; i < 20; ++i) {\n            if (i > 0)\n                System.out.print(\", \");\n            System.out.print(pgen.nextPrime());\n        }\n        System.out.println();\n        System.out.println(\"Primes between 100 and 150:\");\n        for (int i = 0; ; ) {\n            int prime = pgen.nextPrime();\n            if (prime > 150)\n                break;\n            if (prime >= 100) {\n                if (i++ != 0)\n                    System.out.print(\", \");\n                System.out.print(prime);\n            }\n        }\n        System.out.println();\n        int count = 0;\n        for (;;) {\n            int prime = pgen.nextPrime();\n            if (prime > 8000)\n                break;\n            if (prime >= 7700)\n                ++count;\n        }\n        System.out.println(\"Number of primes between 7700 and 8000: \" + count);\n        int n = 10000;\n        for (;;) {\n            int prime = pgen.nextPrime();\n            if (prime == 0) {\n                System.out.println(\"Can't generate any more primes.\");\n                break;\n            }\n            if (pgen.count() == n) {\n                System.out.println(n + \"th prime: \" + prime);\n                n *= 10;\n            }\n        }\n    }\n}\n"}
{"id": 338138, "name": "Flipping bits game", "source": "Translate Swift to Java: import Foundation\n\nstruct Board: Equatable, CustomStringConvertible {\n    let size: Int\n    private var tiles: [Bool]\n\n    init(size: Int) {\n        self.size = size\n        tiles = Array(count: size * size, repeatedValue: false)\n    }\n\n    subscript(x: Int, y: Int) -> Bool {\n        get {\n            return tiles[y * size + x]\n        }\n        set {\n            tiles[y * size + x] = newValue\n        }\n    }\n\n    mutating func randomize() {\n        for i in 0..<tiles.count {\n            tiles[i] = Bool(random() % 2)\n        }\n    }\n\n    mutating func flipRow(row: Int) {\n        for i in 0..<size {\n            self[row, i] = !self[row, i]\n        }\n    }\n\n    mutating func flipColumn(column: Int) {\n        for i in 0..<size {\n            self[i, column] = !self[i, column]\n        }\n    }\n\n    var description: String {\n        var desc = \"\\n\\ta\\tb\\tc\\n\"\n        for i in 0..<size {\n            desc += \"\\(i+1):\\t\"\n            for j in 0..<size {\n                desc += \"\\(Int(self[i, j]))\\t\"\n            }\n            desc += \"\\n\"\n        }\n\n        return desc\n    }\n}\n\nfunc ==(lhs: Board, rhs: Board) -> Bool {\n    return lhs.tiles == rhs.tiles\n}\n\nclass FlippingGame: CustomStringConvertible {\n\n    var board: Board\n    var target: Board\n    var solved: Bool { return board == target }\n\n    init(boardSize: Int) {\n        target = Board(size: 3)\n        board = Board(size: 3)\n        generateTarget()\n    }\n\n    func generateTarget() {\n        target.randomize()\n        board = target\n        let size = board.size\n        while solved {\n            for _ in 0..<size + (random() % size + 1) {\n                if random() % 2 == 0 {\n                    board.flipColumn(random() % size)\n                }\n                else {\n                    board.flipRow(random() % size)\n                }\n            }\n        }\n    }\n\n    func getMove() -> Bool {\n        print(self)\n        print(\"Flip what? \", terminator: \"\")\n\n        guard\n            let move = readLine(stripNewline: true)\n            where move.characters.count == 1\n            else { return false }\n\n        var moveValid = true\n\n        if let row = Int(move) {\n            board.flipRow(row - 1)\n        }\n        else if let column = move.lowercaseString.utf8.first where column < 100 && column > 96  {\n            board.flipColumn(numericCast(column) - 97)\n        }\n        else {\n            moveValid = false\n        }\n\n        return moveValid\n    }\n\n    var description: String {\n        var str = \"\"\n        print(\"Target: \\n \\(target)\", toStream: &str)\n        print(\"Board: \\n \\(board)\", toStream: &str)\n\n        return str\n    }\n}\n\nfunc playGame(game: FlippingGame) -> String {\n    game.generateTarget()\n    var numMoves = 0\n    while !game.solved {\n        numMoves++\n        print(\"Move #\\(numMoves)\")\n        while !game.getMove() {}\n    }\n    print(\"You win!\")\n    print(\"Number of moves: \\(numMoves)\")\n    print(\"\\n\\nPlay Again? \", terminator: \"\")\n\n    return readLine(stripNewline: true)!.lowercaseString\n}\n\nlet game = FlippingGame(boardSize: 3)\nrepeat { } while playGame(game) == \"y\"\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\n\npublic class FlippingBitsGame extends JPanel {\n    final int maxLevel = 7;\n    final int minLevel = 3;\n\n    private Random rand = new Random();\n    private int[][] grid, target;\n    private Rectangle box;\n    private int n = maxLevel;\n    private boolean solved = true;\n\n    FlippingBitsGame() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n        setFont(new Font(\"SansSerif\", Font.PLAIN, 18));\n\n        box = new Rectangle(120, 90, 400, 400);\n\n        startNewGame();\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (solved) {\n                    startNewGame();\n                } else {\n                    int x = e.getX();\n                    int y = e.getY();\n\n                    if (box.contains(x, y))\n                        return;\n\n                    if (x > box.x && x < box.x + box.width) {\n                        flipCol((x - box.x) / (box.width / n));\n\n                    } else if (y > box.y && y < box.y + box.height)\n                        flipRow((y - box.y) / (box.height / n));\n\n                    if (solved(grid, target))\n                        solved = true;\n\n                    printGrid(solved ? \"Solved!\" : \"The board\", grid);\n                }\n                repaint();\n            }\n        });\n    }\n\n    void startNewGame() {\n        if (solved) {\n\n            n = (n == maxLevel) ? minLevel : n + 1;\n\n            grid = new int[n][n];\n            target = new int[n][n];\n\n            do {\n                shuffle();\n\n                for (int i = 0; i < n; i++)\n                    target[i] = Arrays.copyOf(grid[i], n);\n\n                shuffle();\n\n            } while (solved(grid, target));\n\n            solved = false;\n            printGrid(\"The target\", target);\n            printGrid(\"The board\", grid);\n        }\n    }\n\n    void printGrid(String msg, int[][] g) {\n        System.out.println(msg);\n        for (int[] row : g)\n            System.out.println(Arrays.toString(row));\n        System.out.println();\n    }\n\n    boolean solved(int[][] a, int[][] b) {\n        for (int i = 0; i < n; i++)\n            if (!Arrays.equals(a[i], b[i]))\n                return false;\n        return true;\n    }\n\n    void shuffle() {\n        for (int i = 0; i < n * n; i++) {\n            if (rand.nextBoolean())\n                flipRow(rand.nextInt(n));\n            else\n                flipCol(rand.nextInt(n));\n        }\n    }\n\n    void flipRow(int r) {\n        for (int c = 0; c < n; c++) {\n            grid[r][c] ^= 1;\n        }\n    }\n\n    void flipCol(int c) {\n        for (int[] row : grid) {\n            row[c] ^= 1;\n        }\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setColor(getForeground());\n\n        if (solved)\n            g.drawString(\"Solved! Click here to play again.\", 180, 600);\n        else\n            g.drawString(\"Click next to a row or a column to flip.\", 170, 600);\n\n        int size = box.width / n;\n\n        for (int r = 0; r < n; r++)\n            for (int c = 0; c < n; c++) {\n                g.setColor(grid[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(getBackground());\n                g.drawRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(target[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(7 + box.x + c * size, 7 + box.y + r * size, 10, 10);\n            }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Flipping Bits Game\");\n            f.setResizable(false);\n            f.add(new FlippingBitsGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 338139, "name": "Flipping bits game", "source": "Translate Swift to Java: import Foundation\n\nstruct Board: Equatable, CustomStringConvertible {\n    let size: Int\n    private var tiles: [Bool]\n\n    init(size: Int) {\n        self.size = size\n        tiles = Array(count: size * size, repeatedValue: false)\n    }\n\n    subscript(x: Int, y: Int) -> Bool {\n        get {\n            return tiles[y * size + x]\n        }\n        set {\n            tiles[y * size + x] = newValue\n        }\n    }\n\n    mutating func randomize() {\n        for i in 0..<tiles.count {\n            tiles[i] = Bool(random() % 2)\n        }\n    }\n\n    mutating func flipRow(row: Int) {\n        for i in 0..<size {\n            self[row, i] = !self[row, i]\n        }\n    }\n\n    mutating func flipColumn(column: Int) {\n        for i in 0..<size {\n            self[i, column] = !self[i, column]\n        }\n    }\n\n    var description: String {\n        var desc = \"\\n\\ta\\tb\\tc\\n\"\n        for i in 0..<size {\n            desc += \"\\(i+1):\\t\"\n            for j in 0..<size {\n                desc += \"\\(Int(self[i, j]))\\t\"\n            }\n            desc += \"\\n\"\n        }\n\n        return desc\n    }\n}\n\nfunc ==(lhs: Board, rhs: Board) -> Bool {\n    return lhs.tiles == rhs.tiles\n}\n\nclass FlippingGame: CustomStringConvertible {\n\n    var board: Board\n    var target: Board\n    var solved: Bool { return board == target }\n\n    init(boardSize: Int) {\n        target = Board(size: 3)\n        board = Board(size: 3)\n        generateTarget()\n    }\n\n    func generateTarget() {\n        target.randomize()\n        board = target\n        let size = board.size\n        while solved {\n            for _ in 0..<size + (random() % size + 1) {\n                if random() % 2 == 0 {\n                    board.flipColumn(random() % size)\n                }\n                else {\n                    board.flipRow(random() % size)\n                }\n            }\n        }\n    }\n\n    func getMove() -> Bool {\n        print(self)\n        print(\"Flip what? \", terminator: \"\")\n\n        guard\n            let move = readLine(stripNewline: true)\n            where move.characters.count == 1\n            else { return false }\n\n        var moveValid = true\n\n        if let row = Int(move) {\n            board.flipRow(row - 1)\n        }\n        else if let column = move.lowercaseString.utf8.first where column < 100 && column > 96  {\n            board.flipColumn(numericCast(column) - 97)\n        }\n        else {\n            moveValid = false\n        }\n\n        return moveValid\n    }\n\n    var description: String {\n        var str = \"\"\n        print(\"Target: \\n \\(target)\", toStream: &str)\n        print(\"Board: \\n \\(board)\", toStream: &str)\n\n        return str\n    }\n}\n\nfunc playGame(game: FlippingGame) -> String {\n    game.generateTarget()\n    var numMoves = 0\n    while !game.solved {\n        numMoves++\n        print(\"Move #\\(numMoves)\")\n        while !game.getMove() {}\n    }\n    print(\"You win!\")\n    print(\"Number of moves: \\(numMoves)\")\n    print(\"\\n\\nPlay Again? \", terminator: \"\")\n\n    return readLine(stripNewline: true)!.lowercaseString\n}\n\nlet game = FlippingGame(boardSize: 3)\nrepeat { } while playGame(game) == \"y\"\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\n\npublic class FlippingBitsGame extends JPanel {\n    final int maxLevel = 7;\n    final int minLevel = 3;\n\n    private Random rand = new Random();\n    private int[][] grid, target;\n    private Rectangle box;\n    private int n = maxLevel;\n    private boolean solved = true;\n\n    FlippingBitsGame() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n        setFont(new Font(\"SansSerif\", Font.PLAIN, 18));\n\n        box = new Rectangle(120, 90, 400, 400);\n\n        startNewGame();\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (solved) {\n                    startNewGame();\n                } else {\n                    int x = e.getX();\n                    int y = e.getY();\n\n                    if (box.contains(x, y))\n                        return;\n\n                    if (x > box.x && x < box.x + box.width) {\n                        flipCol((x - box.x) / (box.width / n));\n\n                    } else if (y > box.y && y < box.y + box.height)\n                        flipRow((y - box.y) / (box.height / n));\n\n                    if (solved(grid, target))\n                        solved = true;\n\n                    printGrid(solved ? \"Solved!\" : \"The board\", grid);\n                }\n                repaint();\n            }\n        });\n    }\n\n    void startNewGame() {\n        if (solved) {\n\n            n = (n == maxLevel) ? minLevel : n + 1;\n\n            grid = new int[n][n];\n            target = new int[n][n];\n\n            do {\n                shuffle();\n\n                for (int i = 0; i < n; i++)\n                    target[i] = Arrays.copyOf(grid[i], n);\n\n                shuffle();\n\n            } while (solved(grid, target));\n\n            solved = false;\n            printGrid(\"The target\", target);\n            printGrid(\"The board\", grid);\n        }\n    }\n\n    void printGrid(String msg, int[][] g) {\n        System.out.println(msg);\n        for (int[] row : g)\n            System.out.println(Arrays.toString(row));\n        System.out.println();\n    }\n\n    boolean solved(int[][] a, int[][] b) {\n        for (int i = 0; i < n; i++)\n            if (!Arrays.equals(a[i], b[i]))\n                return false;\n        return true;\n    }\n\n    void shuffle() {\n        for (int i = 0; i < n * n; i++) {\n            if (rand.nextBoolean())\n                flipRow(rand.nextInt(n));\n            else\n                flipCol(rand.nextInt(n));\n        }\n    }\n\n    void flipRow(int r) {\n        for (int c = 0; c < n; c++) {\n            grid[r][c] ^= 1;\n        }\n    }\n\n    void flipCol(int c) {\n        for (int[] row : grid) {\n            row[c] ^= 1;\n        }\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setColor(getForeground());\n\n        if (solved)\n            g.drawString(\"Solved! Click here to play again.\", 180, 600);\n        else\n            g.drawString(\"Click next to a row or a column to flip.\", 170, 600);\n\n        int size = box.width / n;\n\n        for (int r = 0; r < n; r++)\n            for (int c = 0; c < n; c++) {\n                g.setColor(grid[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(getBackground());\n                g.drawRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(target[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(7 + box.x + c * size, 7 + box.y + r * size, 10, 10);\n            }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Flipping Bits Game\");\n            f.setResizable(false);\n            f.add(new FlippingBitsGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 338140, "name": "Gray code", "source": "Translate Swift to Java: func grayEncode(_ i: Int) -> Int {\n  return (i >> 1) ^ i\n}\n\nfunc grayDecode(_ i: Int) -> Int {\n  switch i {\n  case 0:\n    return 0\n  case _:\n    return i ^ grayDecode(i >> 1)\n  }\n}\n\nfor i in 0..<32 {\n  let iStr = String(i, radix: 2)\n  let encode = grayEncode(i)\n  let encodeStr = String(encode, radix: 2)\n  let decode = grayDecode(encode)\n  let decodeStr = String(decode, radix: 2)\n\n  print(\"\\(i) (\\(iStr)) => \\(encode) (\\(encodeStr)) => \\(decode) (\\(decodeStr))\")\n}\n", "target": "public class Gray {\n\tpublic static long grayEncode(long n){\n\t\treturn n ^ (n >>> 1);\n\t}\n\t\n\tpublic static long grayDecode(long n) {\n\t\tlong p = n;\n\t\twhile ((n >>>= 1) != 0)\n\t\t\tp ^= n;\n\t\treturn p;\n\t}\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"i\\tBinary\\tGray\\tDecoded\");\n\t\tfor(int i = -1; i < 32;i++){\n\t\t\tSystem.out.print(i +\"\\t\");\n\t\t\tSystem.out.print(Integer.toBinaryString(i) + \"\\t\");\n\t\t\tSystem.out.print(Long.toBinaryString(grayEncode(i))+ \"\\t\");\n\t\t\tSystem.out.println(grayDecode(grayEncode(i)));\n\t\t}\n\t}\n}\n"}
{"id": 338141, "name": "Gray code", "source": "Translate Swift to Java: func grayEncode(_ i: Int) -> Int {\n  return (i >> 1) ^ i\n}\n\nfunc grayDecode(_ i: Int) -> Int {\n  switch i {\n  case 0:\n    return 0\n  case _:\n    return i ^ grayDecode(i >> 1)\n  }\n}\n\nfor i in 0..<32 {\n  let iStr = String(i, radix: 2)\n  let encode = grayEncode(i)\n  let encodeStr = String(encode, radix: 2)\n  let decode = grayDecode(encode)\n  let decodeStr = String(decode, radix: 2)\n\n  print(\"\\(i) (\\(iStr)) => \\(encode) (\\(encodeStr)) => \\(decode) (\\(decodeStr))\")\n}\n", "target": "public class Gray {\n\tpublic static long grayEncode(long n){\n\t\treturn n ^ (n >>> 1);\n\t}\n\t\n\tpublic static long grayDecode(long n) {\n\t\tlong p = n;\n\t\twhile ((n >>>= 1) != 0)\n\t\t\tp ^= n;\n\t\treturn p;\n\t}\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"i\\tBinary\\tGray\\tDecoded\");\n\t\tfor(int i = -1; i < 32;i++){\n\t\t\tSystem.out.print(i +\"\\t\");\n\t\t\tSystem.out.print(Integer.toBinaryString(i) + \"\\t\");\n\t\t\tSystem.out.print(Long.toBinaryString(grayEncode(i))+ \"\\t\");\n\t\t\tSystem.out.println(grayDecode(grayEncode(i)));\n\t\t}\n\t}\n}\n"}
{"id": 338142, "name": "Extreme floating point values", "source": "Translate Swift to Java: let negInf = -1.0 / 0.0\nlet inf = 1.0 / 0.0 \nlet nan = 0.0 / 0.0 \nlet negZero = -2.0 / inf\n\nprintln(\"Negative inf: \\(negInf)\")\nprintln(\"Positive inf: \\(inf)\")\nprintln(\"NaN: \\(nan)\")\nprintln(\"Negative 0: \\(negZero)\")\nprintln(\"inf + -inf: \\(inf + negInf)\")\nprintln(\"0 * NaN: \\(0 * nan)\")\nprintln(\"NaN == NaN: \\(nan == nan)\")\n", "target": "public class Extreme {\n    public static void main(String[] args) {\n        double negInf = -1.0 / 0.0; \n        double inf = 1.0 / 0.0; \n        double nan = 0.0 / 0.0; \n        double negZero = -2.0 / inf;\n\n        System.out.println(\"Negative inf: \" + negInf);\n        System.out.println(\"Positive inf: \" + inf);\n        System.out.println(\"NaN: \" + nan);\n        System.out.println(\"Negative 0: \" + negZero);\n        System.out.println(\"inf + -inf: \" + (inf + negInf));\n        System.out.println(\"0 * NaN: \" + (0 * nan));\n        System.out.println(\"NaN == NaN: \" + (nan == nan));\n    }\n}\n"}
{"id": 338143, "name": "Extreme floating point values", "source": "Translate Swift to Java: let negInf = -1.0 / 0.0\nlet inf = 1.0 / 0.0 \nlet nan = 0.0 / 0.0 \nlet negZero = -2.0 / inf\n\nprintln(\"Negative inf: \\(negInf)\")\nprintln(\"Positive inf: \\(inf)\")\nprintln(\"NaN: \\(nan)\")\nprintln(\"Negative 0: \\(negZero)\")\nprintln(\"inf + -inf: \\(inf + negInf)\")\nprintln(\"0 * NaN: \\(0 * nan)\")\nprintln(\"NaN == NaN: \\(nan == nan)\")\n", "target": "public class Extreme {\n    public static void main(String[] args) {\n        double negInf = -1.0 / 0.0; \n        double inf = 1.0 / 0.0; \n        double nan = 0.0 / 0.0; \n        double negZero = -2.0 / inf;\n\n        System.out.println(\"Negative inf: \" + negInf);\n        System.out.println(\"Positive inf: \" + inf);\n        System.out.println(\"NaN: \" + nan);\n        System.out.println(\"Negative 0: \" + negZero);\n        System.out.println(\"inf + -inf: \" + (inf + negInf));\n        System.out.println(\"0 * NaN: \" + (0 * nan));\n        System.out.println(\"NaN == NaN: \" + (nan == nan));\n    }\n}\n"}
{"id": 338144, "name": "Knuth's algorithm S", "source": "Translate Swift to Java: import Darwin\n\nfunc s_of_n_creator<T>(n: Int) -> T -> [T]  {\n  var sample = [T]()\n  var i = 0\n  return {(item: T) in\n    i++\n    if (i <= n) {\n      sample.append(item)\n    } else if (Int(arc4random_uniform(UInt32(i))) < n) {\n      sample[Int(arc4random_uniform(UInt32(n)))] = item\n    }\n    return sample\n  }\n}\n\nvar bin = [Int](count:10, repeatedValue:0)\nfor trial in 0..<100000 {\n  let s_of_n: Int -> [Int] = s_of_n_creator(3)\n  var sample: [Int] = []\n  for i in 0..<10 {\n    sample = s_of_n(i)\n  }\n  for s in sample {\n    bin[s]++\n  }\n}\nprintln(bin)\n", "target": "import java.util.*;\n \nclass SOfN<T> {\n    private static final Random rand = new Random();\n \n    private List<T> sample;\n    private int i = 0;\n    private int n;\n\n    public SOfN(int _n) {\n        n = _n;\n        sample = new ArrayList<T>(n);\n    }\n\n    public List<T> process(T item) {\n        if (++i <= n) {\n            sample.add(item);\n        } else if (rand.nextInt(i) < n) {\n            sample.set(rand.nextInt(n), item);\n        }\n        return sample;\n    }\n}\n \npublic class AlgorithmS {\n    public static void main(String[] args) {\n        int[] bin = new int[10];\n        for (int trial = 0; trial < 100000; trial++) {\n            SOfN<Integer> s_of_n = new SOfN<Integer>(3);\n            for (int i = 0; i < 9; i++) s_of_n.process(i);\n            for (int s : s_of_n.process(9)) bin[s]++;\n        }\n        System.out.println(Arrays.toString(bin));\n    }\n}\n"}
{"id": 338145, "name": "Knuth's algorithm S", "source": "Translate Swift to Java: import Darwin\n\nfunc s_of_n_creator<T>(n: Int) -> T -> [T]  {\n  var sample = [T]()\n  var i = 0\n  return {(item: T) in\n    i++\n    if (i <= n) {\n      sample.append(item)\n    } else if (Int(arc4random_uniform(UInt32(i))) < n) {\n      sample[Int(arc4random_uniform(UInt32(n)))] = item\n    }\n    return sample\n  }\n}\n\nvar bin = [Int](count:10, repeatedValue:0)\nfor trial in 0..<100000 {\n  let s_of_n: Int -> [Int] = s_of_n_creator(3)\n  var sample: [Int] = []\n  for i in 0..<10 {\n    sample = s_of_n(i)\n  }\n  for s in sample {\n    bin[s]++\n  }\n}\nprintln(bin)\n", "target": "import java.util.*;\n \nclass SOfN<T> {\n    private static final Random rand = new Random();\n \n    private List<T> sample;\n    private int i = 0;\n    private int n;\n\n    public SOfN(int _n) {\n        n = _n;\n        sample = new ArrayList<T>(n);\n    }\n\n    public List<T> process(T item) {\n        if (++i <= n) {\n            sample.add(item);\n        } else if (rand.nextInt(i) < n) {\n            sample.set(rand.nextInt(n), item);\n        }\n        return sample;\n    }\n}\n \npublic class AlgorithmS {\n    public static void main(String[] args) {\n        int[] bin = new int[10];\n        for (int trial = 0; trial < 100000; trial++) {\n            SOfN<Integer> s_of_n = new SOfN<Integer>(3);\n            for (int i = 0; i < 9; i++) s_of_n.process(i);\n            for (int s : s_of_n.process(9)) bin[s]++;\n        }\n        System.out.println(Arrays.toString(bin));\n    }\n}\n"}
{"id": 338146, "name": "Return multiple values", "source": "Translate Swift to Java: func addsub(x: Int, y: Int) -> (Int, Int) {\n  return (x + y, x - y)\n}\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\n\npublic class RReturnMultipleVals {\n  public static final String K_lipsum = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\";\n  public static final Long   K_1024   = 1024L;\n  public static final String L        = \"L\";\n  public static final String R        = \"R\";\n\n  \n  public static void main(String[] args) throws NumberFormatException{\n    Long nv_;\n    String sv_;\n    switch (args.length) {\n      case 0:\n        nv_ = K_1024;\n        sv_ = K_lipsum;\n        break;\n      case 1:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = K_lipsum;\n        break;\n      case 2:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = args[1];\n        break;\n      default:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = args[1];\n        for (int ix = 2; ix < args.length; ++ix) {\n          sv_ = sv_ + \" \" + args[ix];\n        }\n        break;\n    }\n\n    RReturnMultipleVals lcl = new RReturnMultipleVals();\n\n    Pair<Long, String> rvp = lcl.getPairFromPair(nv_, sv_); \n    System.out.println(\"Results extracted from a composite object:\");\n    System.out.printf(\"%s, %s%n%n\", rvp.getLeftVal(), rvp.getRightVal());\n\n    List<Object> rvl = lcl.getPairFromList(nv_, sv_); \n    System.out.println(\"Results extracted from a Java Colections \\\"List\\\" object:\");\n    System.out.printf(\"%s, %s%n%n\", rvl.get(0), rvl.get(1));\n\n    Map<String, Object> rvm = lcl.getPairFromMap(nv_, sv_); \n    System.out.println(\"Results extracted from a Java Colections \\\"Map\\\" object:\");\n    System.out.printf(\"%s, %s%n%n\", rvm.get(L), rvm.get(R));\n  }\n  \n  \n  \n  public <T, U> Pair<T, U> getPairFromPair(T vl_, U vr_) {\n    return new Pair<T, U>(vl_, vr_);\n  }\n  \n  \n  \n  public List<Object> getPairFromList(Object nv_, Object sv_) {\n    List<Object> rset = new ArrayList<Object>();\n    rset.add(nv_);\n    rset.add(sv_);\n    return rset;\n  }\n  \n  \n  \n  public Map<String, Object> getPairFromMap(Object nv_, Object sv_) {\n    Map<String, Object> rset = new HashMap<String, Object>();\n    rset.put(L, nv_);\n    rset.put(R, sv_);\n    return rset;\n  }\n\n  \n  private static class Pair<L, R> {\n    private L leftVal;\n    private R rightVal;\n\n    public Pair(L nv_, R sv_) {\n      setLeftVal(nv_);\n      setRightVal(sv_);\n    }\n    public void setLeftVal(L nv_) {\n      leftVal = nv_;\n    }\n    public L getLeftVal() {\n      return leftVal;\n    }\n    public void setRightVal(R sv_) {\n      rightVal = sv_;\n    }\n    public R getRightVal() {\n      return rightVal;\n    }\n  }\n}\n"}
{"id": 338147, "name": "Substring_Top and tail", "source": "Translate Swift to Java: let txt = \"0123456789\"\nprintln(dropFirst(txt))\nprintln(dropLast(txt))\nprintln(dropFirst(dropLast(txt)))\n", "target": "String strOrig = 'brooms';\nString str1 = strOrig.substring(1, strOrig.length());\nsystem.debug(str1);\nString str2 = strOrig.substring(0, strOrig.length()-1);\nsystem.debug(str2);\nString str3 = strOrig.substring(1, strOrig.length()-1);\nsystem.debug(str3);\n\n\nString strOrig = 'brooms';\nString str1 = strOrig.replaceAll( '^.', '' );\nsystem.debug(str1);\nString str2 = strOrig.replaceAll( '.$', '' ) ;\nsystem.debug(str2);\nString str3 = strOrig.replaceAll( '^.|.$', '' );\nsystem.debug(str3);\n"}
{"id": 338148, "name": "Substring_Top and tail", "source": "Translate Swift to Java: let txt = \"0123456789\"\nprintln(dropFirst(txt))\nprintln(dropLast(txt))\nprintln(dropFirst(dropLast(txt)))\n", "target": "String strOrig = 'brooms';\nString str1 = strOrig.substring(1, strOrig.length());\nsystem.debug(str1);\nString str2 = strOrig.substring(0, strOrig.length()-1);\nsystem.debug(str2);\nString str3 = strOrig.substring(1, strOrig.length()-1);\nsystem.debug(str3);\n\n\nString strOrig = 'brooms';\nString str1 = strOrig.replaceAll( '^.', '' );\nsystem.debug(str1);\nString str2 = strOrig.replaceAll( '.$', '' ) ;\nsystem.debug(str2);\nString str3 = strOrig.replaceAll( '^.|.$', '' );\nsystem.debug(str3);\n"}
{"id": 338149, "name": "LZW compression", "source": "Translate Swift to Java: class LZW {\n    class func compress(_ uncompressed:String) -> [Int] {\n        var dict = [String : Int]()\n\n        for i in 0 ..< 256 {\n            let s = String(Unicode.Scalar(UInt8(i)))\n            dict[s] = i\n        }\n\n        var dictSize = 256\n        var w = \"\"\n        var result = [Int]()\n        for c in uncompressed {\n            let wc = w + String(c)\n            if dict[wc] != nil {\n                w = wc\n            } else {\n                result.append(dict[w]!)\n                dict[wc] = dictSize\n                dictSize += 1 \n                w = String(c)\n            }\n        }\n\n        if w != \"\" {\n            result.append(dict[w]!)\n        }\n        return result\n    }\n\n    class func decompress(_ compressed:[Int]) -> String? {\n        var dict = [Int : String]()\n\n        for i in 0 ..< 256 {\n            dict[i] = String(Unicode.Scalar(UInt8(i)))\n        }\n\n        var dictSize = 256\n        var w = String(Unicode.Scalar(UInt8(compressed[0])))\n        var result = w\n        for k in compressed[1 ..< compressed.count] {\n            let entry : String\n            if let x = dict[k] {\n                entry = x\n            } else if k == dictSize {\n                entry = w + String(w[w.startIndex])\n            } else {\n                return nil\n            }\n\n            result += entry\n            dict[dictSize] = w + String(entry[entry.startIndex])\n            dictSize += 1\n            w = entry\n        }\n        return result\n    }\n}\n\nlet comp = LZW.compress(\"TOBEORNOTTOBEORTOBEORNOT\")\nprint(comp)\n\nif let decomp = LZW.decompress(comp) {\n    print(decomp)\n}\n", "target": "import java.util.*;\n\npublic class LZW {\n    \n    public static List<Integer> compress(String uncompressed) {\n        \n        int dictSize = 256;\n        Map<String,Integer> dictionary = new HashMap<String,Integer>();\n        for (int i = 0; i < 256; i++)\n            dictionary.put(\"\" + (char)i, i);\n        \n        String w = \"\";\n        List<Integer> result = new ArrayList<Integer>();\n        for (char c : uncompressed.toCharArray()) {\n            String wc = w + c;\n            if (dictionary.containsKey(wc))\n                w = wc;\n            else {\n                result.add(dictionary.get(w));\n                \n                dictionary.put(wc, dictSize++);\n                w = \"\" + c;\n            }\n        }\n \n        \n        if (!w.equals(\"\"))\n            result.add(dictionary.get(w));\n        return result;\n    }\n    \n    \n    public static String decompress(List<Integer> compressed) {\n        \n        int dictSize = 256;\n        Map<Integer,String> dictionary = new HashMap<Integer,String>();\n        for (int i = 0; i < 256; i++)\n            dictionary.put(i, \"\" + (char)i);\n        \n        String w = \"\" + (char)(int)compressed.remove(0);\n        StringBuffer result = new StringBuffer(w);\n        for (int k : compressed) {\n            String entry;\n            if (dictionary.containsKey(k))\n                entry = dictionary.get(k);\n            else if (k == dictSize)\n                entry = w + w.charAt(0);\n            else\n                throw new IllegalArgumentException(\"Bad compressed k: \" + k);\n            \n            result.append(entry);\n            \n            \n            dictionary.put(dictSize++, w + entry.charAt(0));\n            \n            w = entry;\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        List<Integer> compressed = compress(\"TOBEORNOTTOBEORTOBEORNOT\");\n        System.out.println(compressed);\n        String decompressed = decompress(compressed);\n        System.out.println(decompressed);\n    }\n}\n"}
{"id": 338150, "name": "Bioinformatics_base count", "source": "Translate Swift to Java: import Foundation\n\nlet dna = \"\"\"\n          CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\n          CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\n          AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\n          GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\n          CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\n          TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\n          TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\n          CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\n          TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\n          GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\n          \"\"\"\n\nprint(\"input:\\n\\(dna)\\n\")\n\nlet counts =\n  dna.replacingOccurrences(of: \"\\n\", with: \"\").reduce(into: [:], { $0[$1, default: 0] += 1 })\n\nprint(\"Counts: \\(counts)\")\nprint(\"Total: \\(counts.values.reduce(0, +))\")\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class orderedSequence {\n    public static void main(String[] args) {\n        Sequence gene = new Sequence(\"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\");\n        gene.runSequence();\n    }\n}\n\n\npublic class Sequence {\n    \n    private final String seq;\n    \n    public Sequence(String sq) {\n        this.seq = sq;\n    }\n    \n    \n    public void prettyPrint() {\n        System.out.println(\"Sequence:\");\n        int i = 0;\n        for ( ; i < seq.length() - 50 ; i += 50) {\n            System.out.printf(\"%5s\u00a0: %s\\n\", i + 50, seq.substring(i, i + 50));\n        }\n        System.out.printf(\"%5s\u00a0: %s\\n\", seq.length(), seq.substring(i));\n    }\n    \n    \n    public void displayCount() {\n        Map<Character, Integer> counter = new HashMap<>();\n        for (int i = 0 ; i < seq.length() ; ++i) {\n            counter.merge(seq.charAt(i), 1, Integer::sum);\n        }\n\n        System.out.println(\"Base vs. Count:\");\n        counter.forEach(\n            key, value -> System.out.printf(\"%5s\u00a0: %s\\n\", key, value));\n        System.out.printf(\"%5s: %s\\n\", \"SUM\", seq.length());\n    }\n    \n    public void runSequence() {\n        this.prettyPrint();\n        this.displayCount();\n    }\n}\n"}
{"id": 338151, "name": "Bioinformatics_base count", "source": "Translate Swift to Java: import Foundation\n\nlet dna = \"\"\"\n          CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\n          CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\n          AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\n          GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\n          CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\n          TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\n          TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\n          CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\n          TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\n          GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\n          \"\"\"\n\nprint(\"input:\\n\\(dna)\\n\")\n\nlet counts =\n  dna.replacingOccurrences(of: \"\\n\", with: \"\").reduce(into: [:], { $0[$1, default: 0] += 1 })\n\nprint(\"Counts: \\(counts)\")\nprint(\"Total: \\(counts.values.reduce(0, +))\")\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class orderedSequence {\n    public static void main(String[] args) {\n        Sequence gene = new Sequence(\"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\");\n        gene.runSequence();\n    }\n}\n\n\npublic class Sequence {\n    \n    private final String seq;\n    \n    public Sequence(String sq) {\n        this.seq = sq;\n    }\n    \n    \n    public void prettyPrint() {\n        System.out.println(\"Sequence:\");\n        int i = 0;\n        for ( ; i < seq.length() - 50 ; i += 50) {\n            System.out.printf(\"%5s\u00a0: %s\\n\", i + 50, seq.substring(i, i + 50));\n        }\n        System.out.printf(\"%5s\u00a0: %s\\n\", seq.length(), seq.substring(i));\n    }\n    \n    \n    public void displayCount() {\n        Map<Character, Integer> counter = new HashMap<>();\n        for (int i = 0 ; i < seq.length() ; ++i) {\n            counter.merge(seq.charAt(i), 1, Integer::sum);\n        }\n\n        System.out.println(\"Base vs. Count:\");\n        counter.forEach(\n            key, value -> System.out.printf(\"%5s\u00a0: %s\\n\", key, value));\n        System.out.printf(\"%5s: %s\\n\", \"SUM\", seq.length());\n    }\n    \n    public void runSequence() {\n        this.prettyPrint();\n        this.displayCount();\n    }\n}\n"}
{"id": 338152, "name": "Fibonacci word", "source": "Translate Swift to Java: import Foundation\n\nstruct Fib: Sequence, IteratorProtocol {\n  private var cur: String\n  private var nex: String\n\n  init(cur: String, nex: String) {\n    self.cur = cur\n    self.nex = nex\n  }\n\n  mutating func next() -> String? {\n    let ret = cur\n\n    cur = nex\n    nex = \"\\(ret)\\(nex)\"\n\n    return ret\n  }\n}\n\nfunc getEntropy(_ s: [Int]) -> Double {\n  var entropy = 0.0\n  var hist = Array(repeating: 0.0, count: 256)\n\n  for i in 0..<s.count {\n    hist[s[i]] += 1\n  }\n\n  for i in 0..<256 where hist[i] > 0 {\n    let rat = hist[i] / Double(s.count)\n    entropy -= rat * log2(rat)\n  }\n\n  return entropy\n}\n\nfor (i, str) in Fib(cur: \"1\", nex: \"0\").prefix(37).enumerated() {\n  let ent = getEntropy(str.map({ Int($0.asciiValue!) }))\n\n  print(\"i: \\(i) len: \\(str.count) entropy: \\(ent)\")\n}\n", "target": "import java.util.*;\n\npublic class FWord {\n    private  String fWord0 = \"\";\n    private  String fWord1 = \"\";\n\n    private String nextFWord () {\n        final String result;\n        \n        if ( \"\".equals ( fWord1 ) )      result = \"1\";\n        else if ( \"\".equals ( fWord0 ) ) result = \"0\";\n        else                             result = fWord1 + fWord0;\n\n        fWord0 = fWord1;\n        fWord1 = result;\n\n        return result;\n    }\n\n    public static double entropy ( final String source ) {\n        final int                        length = source.length ();\n        final Map < Character, Integer > counts = new HashMap < Character, Integer > ();\n         double                     result = 0.0;\n \n        for ( int i = 0; i < length; i++ ) {\n            final char c = source.charAt ( i );\n\n            if ( counts.containsKey ( c ) ) counts.put ( c, counts.get ( c ) + 1 );\n            else                            counts.put ( c, 1 );\n        }\n\n        for ( final int count : counts.values () ) {\n            final double proportion = ( double ) count / length;\n\n            result -= proportion * ( Math.log ( proportion ) / Math.log ( 2 ) );\n        }\n\n        return result;\n    }\n\n    public static void main ( final String [] args ) {\n        final FWord fWord = new FWord ();\n\n        for ( int i = 0; i < 37;  ) {\n            final String word = fWord.nextFWord ();\n\n            System.out.printf ( \"%3d %10d %s %n\", ++i, word.length (), entropy ( word ) );\n        }\n    }\n}\n"}
{"id": 338153, "name": "Fibonacci word", "source": "Translate Swift to Java: import Foundation\n\nstruct Fib: Sequence, IteratorProtocol {\n  private var cur: String\n  private var nex: String\n\n  init(cur: String, nex: String) {\n    self.cur = cur\n    self.nex = nex\n  }\n\n  mutating func next() -> String? {\n    let ret = cur\n\n    cur = nex\n    nex = \"\\(ret)\\(nex)\"\n\n    return ret\n  }\n}\n\nfunc getEntropy(_ s: [Int]) -> Double {\n  var entropy = 0.0\n  var hist = Array(repeating: 0.0, count: 256)\n\n  for i in 0..<s.count {\n    hist[s[i]] += 1\n  }\n\n  for i in 0..<256 where hist[i] > 0 {\n    let rat = hist[i] / Double(s.count)\n    entropy -= rat * log2(rat)\n  }\n\n  return entropy\n}\n\nfor (i, str) in Fib(cur: \"1\", nex: \"0\").prefix(37).enumerated() {\n  let ent = getEntropy(str.map({ Int($0.asciiValue!) }))\n\n  print(\"i: \\(i) len: \\(str.count) entropy: \\(ent)\")\n}\n", "target": "import java.util.*;\n\npublic class FWord {\n    private  String fWord0 = \"\";\n    private  String fWord1 = \"\";\n\n    private String nextFWord () {\n        final String result;\n        \n        if ( \"\".equals ( fWord1 ) )      result = \"1\";\n        else if ( \"\".equals ( fWord0 ) ) result = \"0\";\n        else                             result = fWord1 + fWord0;\n\n        fWord0 = fWord1;\n        fWord1 = result;\n\n        return result;\n    }\n\n    public static double entropy ( final String source ) {\n        final int                        length = source.length ();\n        final Map < Character, Integer > counts = new HashMap < Character, Integer > ();\n         double                     result = 0.0;\n \n        for ( int i = 0; i < length; i++ ) {\n            final char c = source.charAt ( i );\n\n            if ( counts.containsKey ( c ) ) counts.put ( c, counts.get ( c ) + 1 );\n            else                            counts.put ( c, 1 );\n        }\n\n        for ( final int count : counts.values () ) {\n            final double proportion = ( double ) count / length;\n\n            result -= proportion * ( Math.log ( proportion ) / Math.log ( 2 ) );\n        }\n\n        return result;\n    }\n\n    public static void main ( final String [] args ) {\n        final FWord fWord = new FWord ();\n\n        for ( int i = 0; i < 37;  ) {\n            final String word = fWord.nextFWord ();\n\n            System.out.printf ( \"%3d %10d %s %n\", ++i, word.length (), entropy ( word ) );\n        }\n    }\n}\n"}
{"id": 338154, "name": "Text processing_1", "source": "Translate Swift to Java: import Foundation\n\nlet fmtDbl = { String(format: \"%10.3f\", $0) }\n\nTask.detached {\n  let formatter = DateFormatter()\n\n  formatter.dateFormat = \"yyyy-MM-dd\"\n\n  let (data, _) = try await URLSession.shared.bytes(from: URL(fileURLWithPath: CommandLine.arguments[1]))\n  var rowStats = [(Date, Double, Int)]()\n  var invalidPeriods = 0\n  var invalidStart: Date?\n  var sumFile = 0.0\n  var readings = 0\n  var longestInvalid = 0\n  var longestInvalidStart: Date?\n  var longestInvalidEnd: Date?\n\n  for try await line in data.lines {\n    let lineSplit = line.components(separatedBy: \"\\t\")\n\n    guard !lineSplit.isEmpty, let date = formatter.date(from: lineSplit[0]) else {\n      fatalError(\"Invalid date \\(lineSplit[0])\")\n    }\n\n    let data = Array(lineSplit.dropFirst())\n    let parsed = stride(from: 0, to: data.endIndex, by: 2).map({idx -> (Double, Int) in\n      let slice = data[idx..<idx+2]\n\n      return (Double(slice[idx]) ?? 0, Int(slice[idx+1]) ?? 0)\n    })\n\n    var sum = 0.0\n    var numValid = 0\n\n    for (val, flag) in parsed {\n      if flag <= 0 {\n        if invalidStart == nil {\n          invalidStart = date\n        }\n\n        invalidPeriods += 1\n      } else {\n        if invalidPeriods > longestInvalid {\n          longestInvalid = invalidPeriods\n          longestInvalidStart = invalidStart\n          longestInvalidEnd = date\n        }\n\n        sumFile += val\n        sum += val\n        numValid += 1\n        readings += 1\n        invalidPeriods = 0\n        invalidStart = nil\n      }\n    }\n\n    if numValid != 0 {\n      rowStats.append((date, sum / Double(numValid), parsed.count - numValid))\n    }\n  }\n\n  for stat in rowStats.lazy.reversed().prefix(5) {\n    print(\"\\(stat.0): Average: \\(fmtDbl(stat.1)); Valid Readings: \\(24 - stat.2); Invalid Readings: \\(stat.2)\")\n  }\n\n  print(\"\"\"\n\n        Sum File: \\(fmtDbl(sumFile))\n        Average: \\(fmtDbl(sumFile / Double(readings)))\n        Readings: \\(readings)\n        Longest Invalid: \\(longestInvalid) (\\(longestInvalidStart!) - \\(longestInvalidEnd!))\n        \"\"\")\n\n  exit(0)\n}\n\ndispatchMain()\n", "target": "import java.io.File;\nimport java.util.*;\nimport static java.lang.System.out;\n\npublic class TextProcessing1 {\n\n    public static void main(String[] args) throws Exception {\n        Locale.setDefault(new Locale(\"en\", \"US\"));\n        Metrics metrics = new Metrics();\n\n        int dataGap = 0;\n        String gapBeginDate = null;\n        try (Scanner lines = new Scanner(new File(\"readings.txt\"))) {\n            while (lines.hasNextLine()) {\n\n                double lineTotal = 0.0;\n                int linePairs = 0;\n                int lineInvalid = 0;\n                String lineDate;\n\n                try (Scanner line = new Scanner(lines.nextLine())) {\n\n                    lineDate = line.next();\n\n                    while (line.hasNext()) {\n                        final double value = line.nextDouble();\n                        if (line.nextInt() <= 0) {\n                            if (dataGap == 0)\n                                gapBeginDate = lineDate;\n                            dataGap++;\n                            lineInvalid++;\n                            continue;\n                        }\n                        lineTotal += value;\n                        linePairs++;\n\n                        metrics.addDataGap(dataGap, gapBeginDate, lineDate);\n                        dataGap = 0;\n                    }\n                }\n                metrics.addLine(lineTotal, linePairs);\n                metrics.lineResult(lineDate, lineInvalid, linePairs, lineTotal);\n            }\n            metrics.report();\n        }\n    }\n\n    private static class Metrics {\n        private List<String[]> gapDates;\n        private int maxDataGap = -1;\n        private double total;\n        private int pairs;\n        private int lineResultCount;\n\n        void addLine(double tot, double prs) {\n            total += tot;\n            pairs += prs;\n        }\n\n        void addDataGap(int gap, String begin, String end) {\n            if (gap > 0 && gap >= maxDataGap) {\n                if (gap > maxDataGap) {\n                    maxDataGap = gap;\n                    gapDates = new ArrayList<>();\n                }\n                gapDates.add(new String[]{begin, end});\n            }\n        }\n\n        void lineResult(String date, int invalid, int prs, double tot) {\n            if (lineResultCount >= 3)\n                return;\n            out.printf(\"%10s  out: %2d  in: %2d  tot: %10.3f  avg: %10.3f%n\",\n                    date, invalid, prs, tot, (prs > 0) ? tot / prs : 0.0);\n            lineResultCount++;\n        }\n\n        void report() {\n            out.printf(\"%ntotal    = %10.3f%n\", total);\n            out.printf(\"readings = %6d%n\", pairs);\n            out.printf(\"average  = %010.3f%n\", total / pairs);\n            out.printf(\"%nmaximum run(s) of %d invalid measurements: %n\",\n                    maxDataGap);\n            for (String[] dates : gapDates)\n                out.printf(\"begins at %s and ends at %s%n\", dates[0], dates[1]);\n\n        }\n    }\n}\n"}
{"id": 338155, "name": "Draw a sphere", "source": "Translate Swift to Java: class Sphere: UIView{\n  \n  override func drawRect(rect: CGRect)\n  {\n    let context = UIGraphicsGetCurrentContext()\n    let locations: [CGFloat] = [0.0, 1.0]\n    \n    let colors = [UIColor.whiteColor().CGColor,\n      UIColor.blueColor().CGColor]\n    \n    let colorspace = CGColorSpaceCreateDeviceRGB()\n    \n    let gradient = CGGradientCreateWithColors(colorspace,\n      colors, locations)\n    \n    var startPoint = CGPoint()\n    var endPoint = CGPoint()\n    startPoint.x = self.center.x - (self.frame.width * 0.1)\n    startPoint.y = self.center.y - (self.frame.width * 0.15)\n    endPoint.x = self.center.x\n    endPoint.y = self.center.y\n    let startRadius: CGFloat = 0\n    let endRadius: CGFloat = self.frame.width * 0.38\n    \n    CGContextDrawRadialGradient (context, gradient, startPoint,\n      startRadius, endPoint, endRadius,\n      0)\n  }\n}\n\nvar s = Sphere(frame: CGRectMake(0, 0, 200, 200))\n", "target": "using System;\n\nnamespace Sphere {\n    internal class Program {\n        private const string Shades = \".:!*oe%&#@\";\n        private static readonly double[] Light = {30, 30, -50};\n\n        private static void Normalize(double[] v) {\n            double len = Math.Sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n            v[0] /= len;\n            v[1] /= len;\n            v[2] /= len;\n        }\n\n        private static double Dot(double[] x, double[] y) {\n            double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n            return d < 0 ? -d : 0;\n        }\n\n        public static void DrawSphere(double r, double k, double ambient) {\n            var vec = new double[3];\n            for(var i = (int)Math.Floor(-r); i <= (int)Math.Ceiling(r); i++) {\n                double x = i + .5;\n                for(var j = (int)Math.Floor(-2*r); j <= (int)Math.Ceiling(2*r); j++) {\n                    double y = j/2.0 + .5;\n                    if(x*x + y*y <= r*r) {\n                        vec[0] = x;\n                        vec[1] = y;\n                        vec[2] = Math.Sqrt(r*r - x*x - y*y);\n                        Normalize(vec);\n                        double b = Math.Pow(Dot(Light, vec), k) + ambient;\n                        int intensity = (b <= 0)\n                                            ? Shades.Length - 2\n                                            : (int)Math.Max((1 - b)*(Shades.Length - 1), 0);\n                        Console.Write(Shades[intensity]);\n                    }\n                    else\n                        Console.Write(' ');\n                }\n                Console.WriteLine();\n            }\n        }\n\n        private static void Main() {\n            Normalize(Light);\n            DrawSphere(6, 4, .1);\n            DrawSphere(10, 2, .4);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 338156, "name": "Draw a sphere", "source": "Translate Swift to Java: class Sphere: UIView{\n  \n  override func drawRect(rect: CGRect)\n  {\n    let context = UIGraphicsGetCurrentContext()\n    let locations: [CGFloat] = [0.0, 1.0]\n    \n    let colors = [UIColor.whiteColor().CGColor,\n      UIColor.blueColor().CGColor]\n    \n    let colorspace = CGColorSpaceCreateDeviceRGB()\n    \n    let gradient = CGGradientCreateWithColors(colorspace,\n      colors, locations)\n    \n    var startPoint = CGPoint()\n    var endPoint = CGPoint()\n    startPoint.x = self.center.x - (self.frame.width * 0.1)\n    startPoint.y = self.center.y - (self.frame.width * 0.15)\n    endPoint.x = self.center.x\n    endPoint.y = self.center.y\n    let startRadius: CGFloat = 0\n    let endRadius: CGFloat = self.frame.width * 0.38\n    \n    CGContextDrawRadialGradient (context, gradient, startPoint,\n      startRadius, endPoint, endRadius,\n      0)\n  }\n}\n\nvar s = Sphere(frame: CGRectMake(0, 0, 200, 200))\n", "target": "using System;\n\nnamespace Sphere {\n    internal class Program {\n        private const string Shades = \".:!*oe%&#@\";\n        private static readonly double[] Light = {30, 30, -50};\n\n        private static void Normalize(double[] v) {\n            double len = Math.Sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n            v[0] /= len;\n            v[1] /= len;\n            v[2] /= len;\n        }\n\n        private static double Dot(double[] x, double[] y) {\n            double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n            return d < 0 ? -d : 0;\n        }\n\n        public static void DrawSphere(double r, double k, double ambient) {\n            var vec = new double[3];\n            for(var i = (int)Math.Floor(-r); i <= (int)Math.Ceiling(r); i++) {\n                double x = i + .5;\n                for(var j = (int)Math.Floor(-2*r); j <= (int)Math.Ceiling(2*r); j++) {\n                    double y = j/2.0 + .5;\n                    if(x*x + y*y <= r*r) {\n                        vec[0] = x;\n                        vec[1] = y;\n                        vec[2] = Math.Sqrt(r*r - x*x - y*y);\n                        Normalize(vec);\n                        double b = Math.Pow(Dot(Light, vec), k) + ambient;\n                        int intensity = (b <= 0)\n                                            ? Shades.Length - 2\n                                            : (int)Math.Max((1 - b)*(Shades.Length - 1), 0);\n                        Console.Write(Shades[intensity]);\n                    }\n                    else\n                        Console.Write(' ');\n                }\n                Console.WriteLine();\n            }\n        }\n\n        private static void Main() {\n            Normalize(Light);\n            DrawSphere(6, 4, .1);\n            DrawSphere(10, 2, .4);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 338157, "name": "Thiele's interpolation formula", "source": "Translate Swift to Java: let N = 32\nlet N2 = N * (N - 1) / 2\nlet step = 0.05\n\nvar xval = [Double](repeating: 0, count: N)\nvar tsin = [Double](repeating: 0, count: N)\nvar tcos = [Double](repeating: 0, count: N)\nvar ttan = [Double](repeating: 0, count: N)\nvar rsin = [Double](repeating: .nan, count: N2)\nvar rcos = [Double](repeating: .nan, count: N2)\nvar rtan = [Double](repeating: .nan, count: N2)\n\nfunc rho(_ x: [Double], _ y: [Double], _ r: inout [Double], _ i: Int, _ n: Int) -> Double {\n  guard n >= 0 else {\n    return 0\n  }\n\n  guard n != 0 else {\n    return y[i]\n  }\n\n  let idx = (N - 1 - n) * (N - n) / 2 + i\n\n  if r[idx] != r[idx] {\n    r[idx] = (x[i] - x[i + n]) /\n      (rho(x, y, &r, i, n - 1) - rho(x, y, &r, i + 1, n - 1)) + rho(x, y, &r, i + 1, n - 2)\n  }\n\n  return r[idx]\n}\n\nfunc thiele(_ x: [Double], _ y: [Double], _ r: inout [Double], _ xin: Double, _ n: Int) -> Double {\n  guard n <= N - 1 else {\n    return 1\n  }\n\n  return rho(x, y, &r, 0, n) - rho(x, y, &r, 0, n - 2) + (xin - x[n]) / thiele(x, y, &r, xin, n + 1)\n}\n\nfor i in 0..<N {\n  xval[i] = Double(i) * step\n  tsin[i] = sin(xval[i])\n  tcos[i] = cos(xval[i])\n  ttan[i] = tsin[i] / tcos[i]\n}\n\nprint(String(format: \"%16.14f\", 6 * thiele(tsin, xval, &rsin, 0.5, 0)))\nprint(String(format: \"%16.14f\", 3 * thiele(tcos, xval, &rcos, 0.5, 0)))\nprint(String(format: \"%16.14f\", 4 * thiele(ttan, xval, &rtan, 1.0, 0)))\n", "target": "import static java.lang.Math.*;\n\npublic class Test {\n    final static int N = 32;\n    final static int N2 = (N * (N - 1) / 2);\n    final static double STEP = 0.05;\n\n    static double[] xval = new double[N];\n    static double[] t_sin = new double[N];\n    static double[] t_cos = new double[N];\n    static double[] t_tan = new double[N];\n\n    static double[] r_sin = new double[N2];\n    static double[] r_cos = new double[N2];\n    static double[] r_tan = new double[N2];\n\n    static double rho(double[] x, double[] y, double[] r, int i, int n) {\n        if (n < 0)\n            return 0;\n\n        if (n == 0)\n            return y[i];\n\n        int idx = (N - 1 - n) * (N - n) / 2 + i;\n        if (r[idx] != r[idx])\n            r[idx] = (x[i] - x[i + n])\n                    / (rho(x, y, r, i, n - 1) - rho(x, y, r, i + 1, n - 1))\n                    + rho(x, y, r, i + 1, n - 2);\n\n        return r[idx];\n    }\n\n    static double thiele(double[] x, double[] y, double[] r, double xin, int n) {\n        if (n > N - 1)\n            return 1;\n        return rho(x, y, r, 0, n) - rho(x, y, r, 0, n - 2)\n                + (xin - x[n]) / thiele(x, y, r, xin, n + 1);\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < N; i++) {\n            xval[i] = i * STEP;\n            t_sin[i] = sin(xval[i]);\n            t_cos[i] = cos(xval[i]);\n            t_tan[i] = t_sin[i] / t_cos[i];\n        }\n\n        for (int i = 0; i < N2; i++)\n            r_sin[i] = r_cos[i] = r_tan[i] = Double.NaN;\n\n        System.out.printf(\"%16.14f%n\", 6 * thiele(t_sin, xval, r_sin, 0.5, 0));\n        System.out.printf(\"%16.14f%n\", 3 * thiele(t_cos, xval, r_cos, 0.5, 0));\n        System.out.printf(\"%16.14f%n\", 4 * thiele(t_tan, xval, r_tan, 1.0, 0));\n    }\n}\n"}
{"id": 338158, "name": "Hello world_Line printer", "source": "Translate Swift to Java: import Foundation\n\nlet out = NSOutputStream(toFileAtPath: \"/dev/lp0\", append: true)\nlet data = \"Hello, World!\".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nout?.open()\nout?.write(UnsafePointer<UInt8>(data!.bytes), maxLength: data!.length)\nout?.close()\n", "target": "import java.io.FileWriter;\nimport java.io.IOException;\n \npublic class LinePrinter {\n  public static void main(String[] args) {\n    try {\n      FileWriter lp0 = new FileWriter(\"/dev/lp0\");\n      lp0.write(\"Hello World!\");\n      lp0.close();\n    } catch (IOException ioe) {\n      ioe.printStackTrace();\n    }\n  }\n}\n"}
{"id": 338159, "name": "Hello world_Line printer", "source": "Translate Swift to Java: import Foundation\n\nlet out = NSOutputStream(toFileAtPath: \"/dev/lp0\", append: true)\nlet data = \"Hello, World!\".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nout?.open()\nout?.write(UnsafePointer<UInt8>(data!.bytes), maxLength: data!.length)\nout?.close()\n", "target": "import java.io.FileWriter;\nimport java.io.IOException;\n \npublic class LinePrinter {\n  public static void main(String[] args) {\n    try {\n      FileWriter lp0 = new FileWriter(\"/dev/lp0\");\n      lp0.write(\"Hello World!\");\n      lp0.close();\n    } catch (IOException ioe) {\n      ioe.printStackTrace();\n    }\n  }\n}\n"}
{"id": 338160, "name": "Sutherland-Hodgman polygon clipping", "source": "Translate Swift to Java: struct Point {\n  var x: Double\n  var y: Double\n}\n\nstruct Polygon {\n  var points: [Point]\n\n  init(points: [Point]) {\n    self.points = points\n  }\n\n  init(points: [(Double, Double)]) {\n    self.init(points: points.map({ Point(x: $0.0, y: $0.1) }))\n  }\n}\n\nfunc isInside(_ p1: Point, _ p2: Point, _ p3: Point) -> Bool {\n  (p3.x - p2.x) * (p1.y - p2.y) > (p3.y - p2.y) * (p1.x - p2.x)\n}\n\nfunc computeIntersection(_ p1: Point, _ p2: Point, _ s: Point, _ e: Point) -> Point {\n  let dc = Point(x: p1.x - p2.x, y: p1.y - p2.y)\n  let dp = Point(x: s.x - e.x, y: s.y - e.y)\n  let n1 = p1.x * p2.y - p1.y * p2.x\n  let n2 = s.x * e.y - s.y * e.x\n  let n3 = 1.0 / (dc.x * dp.y - dc.y * dp.x)\n\n  return Point(x: (n1 * dp.x - n2 * dc.x) * n3, y: (n1 * dp.y - n2 * dc.y) * n3)\n}\n\nfunc sutherlandHodgmanClip(subjPoly: Polygon, clipPoly: Polygon) -> Polygon {\n  var ring = subjPoly.points\n  var p1 = clipPoly.points.last!\n\n  for p2 in clipPoly.points {\n    let input = ring\n    var s = input.last!\n\n    ring = []\n\n    for e in input {\n      if isInside(e, p1, p2) {\n        if !isInside(s, p1, p2) {\n          ring.append(computeIntersection(p1, p2, s, e))\n        }\n\n        ring.append(e)\n      } else if isInside(s, p1, p2) {\n        ring.append(computeIntersection(p1, p2, s, e))\n      }\n\n      s = e\n    }\n\n    p1 = p2\n  }\n\n  return Polygon(points: ring)\n}\n\nlet subj = Polygon(points: [\n  (50.0, 150.0),\n  (200.0, 50.0),\n  (350.0, 150.0),\n  (350.0, 300.0),\n  (250.0, 300.0),\n  (200.0, 250.0),\n  (150.0, 350.0),\n  (100.0, 250.0),\n  (100.0, 200.0)\n])\n\nlet clip = Polygon(points: [\n  (100.0, 100.0),\n  (300.0, 100.0),\n  (300.0, 300.0),\n  (100.0, 300.0)\n])\n\nprint(sutherlandHodgmanClip(subjPoly: subj, clipPoly: clip))\n", "target": "import java.awt.*;\nimport java.awt.geom.Line2D;\nimport java.util.*;\nimport java.util.List;\nimport javax.swing.*;\n\npublic class SutherlandHodgman extends JFrame {\n\n    SutherlandHodgmanPanel panel;\n\n    public static void main(String[] args) {\n        JFrame f = new SutherlandHodgman();\n        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        f.setVisible(true);\n    }\n\n    public SutherlandHodgman() {\n        Container content = getContentPane();\n        content.setLayout(new BorderLayout());\n        panel = new SutherlandHodgmanPanel();\n        content.add(panel, BorderLayout.CENTER);\n        setTitle(\"SutherlandHodgman\");\n        pack();\n        setLocationRelativeTo(null);\n    }\n}\n\nclass SutherlandHodgmanPanel extends JPanel {\n    List<double[]> subject, clipper, result;\n\n    public SutherlandHodgmanPanel() {\n        setPreferredSize(new Dimension(600, 500));\n\n        \n        double[][] subjPoints = {{50, 150}, {200, 50}, {350, 150}, {350, 300},\n        {250, 300}, {200, 250}, {150, 350}, {100, 250}, {100, 200}};\n\n        double[][] clipPoints = {{100, 100}, {300, 100}, {300, 300}, {100, 300}};\n\n        subject = new ArrayList<>(Arrays.asList(subjPoints));\n        result  = new ArrayList<>(subject);\n        clipper = new ArrayList<>(Arrays.asList(clipPoints));\n\n        clipPolygon();\n    }\n\n    private void clipPolygon() {\n        int len = clipper.size();\n        for (int i = 0; i < len; i++) {\n\n            int len2 = result.size();\n            List<double[]> input = result;\n            result = new ArrayList<>(len2);\n\n            double[] A = clipper.get((i + len - 1) % len);\n            double[] B = clipper.get(i);\n\n            for (int j = 0; j < len2; j++) {\n\n                double[] P = input.get((j + len2 - 1) % len2);\n                double[] Q = input.get(j);\n\n                if (isInside(A, B, Q)) {\n                    if (!isInside(A, B, P))\n                        result.add(intersection(A, B, P, Q));\n                    result.add(Q);\n                } else if (isInside(A, B, P))\n                    result.add(intersection(A, B, P, Q));\n            }\n        }\n    }\n\n    private boolean isInside(double[] a, double[] b, double[] c) {\n        return (a[0] - c[0]) * (b[1] - c[1]) > (a[1] - c[1]) * (b[0] - c[0]);\n    }\n\n    private double[] intersection(double[] a, double[] b, double[] p, double[] q) {\n        double A1 = b[1] - a[1];\n        double B1 = a[0] - b[0];\n        double C1 = A1 * a[0] + B1 * a[1];\n\n        double A2 = q[1] - p[1];\n        double B2 = p[0] - q[0];\n        double C2 = A2 * p[0] + B2 * p[1];\n\n        double det = A1 * B2 - A2 * B1;\n        double x = (B2 * C1 - B1 * C2) / det;\n        double y = (A1 * C2 - A2 * C1) / det;\n\n        return new double[]{x, y};\n    }\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2 = (Graphics2D) g;\n        g2.translate(80, 60);\n        g2.setStroke(new BasicStroke(3));\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawPolygon(g2, subject, Color.blue);\n        drawPolygon(g2, clipper, Color.red);\n        drawPolygon(g2, result, Color.green);\n    }\n\n    private void drawPolygon(Graphics2D g2, List<double[]> points, Color color) {\n        g2.setColor(color);\n        int len = points.size();\n        Line2D line = new Line2D.Double();\n        for (int i = 0; i < len; i++) {\n            double[] p1 = points.get(i);\n            double[] p2 = points.get((i + 1) % len);\n            line.setLine(p1[0], p1[1], p2[0], p2[1]);\n            g2.draw(line);\n        }\n    }\n}\n"}
{"id": 338161, "name": "Sorting algorithms_Pancake sort", "source": "Translate Swift to Java: import Foundation\n\nstruct PancakeSort {\n    var arr:[Int]\n    \n    mutating func flip(n:Int) {\n        for i in 0 ..< (n + 1) / 2 {\n            swap(&arr[n - i], &arr[i])\n        }\n        println(\"flip(0.. \\(n)): \\(arr)\")\n    }\n    \n    func minmax(n:Int) -> [Int] {\n        var xm = arr[0]\n        var xM = arr[0]\n        var posm = 0\n        var posM = 0\n        \n        for i in 1..<n {\n            if (arr[i] < xm) {\n                xm = arr[i]\n                posm = i\n            } else if (arr[i] > xM) {\n                xM = arr[i]\n                posM = i\n            }\n        }\n        \n        return [posm, posM]\n    }\n    \n    mutating func sort(var n:Int, var dir:Int) {\n        if n == 0 {\n            return\n        }\n        \n        let mM = minmax(n)\n        let bestXPos = mM[dir]\n        let altXPos = mM[1 - dir]\n        var flipped = false\n        \n        if bestXPos == n - 1 {\n            n--\n        } else if bestXPos == 0 {\n            flip(n - 1)\n            n--\n        } else if altXPos == n - 1 {\n            dir = 1 - dir\n            n--\n            flipped = true\n        } else {\n            flip(bestXPos)\n        }\n        \n        sort(n, dir: dir)\n        \n        if flipped {\n            flip(n)\n        }\n    }\n}\n\nlet arr = [2, 3, 6, 1, 4, 5, 10, 8, 7, 9]\nvar a = PancakeSort(arr: arr)\na.sort(arr.count, dir: 1)\nprintln(a.arr)\n", "target": "public class PancakeSort\n{\n   int[] heap;\n\n   public String toString() {\n      String info = \"\";\n      for (int x: heap)\n         info += x + \" \";\n      return info;\n   }\n    \n   public void flip(int n) {\n      for (int i = 0; i < (n+1) / 2; ++i) {\n         int tmp = heap[i];\n         heap[i] = heap[n-i];\n         heap[n-i] = tmp;\n      }      \n      System.out.println(\"flip(0..\" + n + \"): \" + toString());\n   }\n   \n   public int[] minmax(int n) {\n      int xm, xM;\n      xm = xM = heap[0];\n      int posm = 0, posM = 0;\n      \n      for (int i = 1; i < n; ++i) {\n         if (heap[i] < xm) {\n            xm = heap[i];\n            posm = i;\n         }\n         else if (heap[i] > xM) {\n            xM = heap[i];\n            posM = i;\n         }\n      }\n      return new int[] {posm, posM};\n   }\n   \n   public void sort(int n, int dir) {\n      if (n == 0) return;\n         \n      int[] mM = minmax(n);\n      int bestXPos = mM[dir];\n      int altXPos = mM[1-dir];\n      boolean flipped = false;\n      \n      if (bestXPos == n-1) {\n         --n;\n      }\n      else if (bestXPos == 0) {\n         flip(n-1);\n         --n;\n      }\n      else if (altXPos == n-1) {\n         dir = 1-dir;\n         --n;\n         flipped = true;\n      }\n      else {\n         flip(bestXPos);\n      }\n      sort(n, dir);\n\n      if (flipped) {\n         flip(n);\n      }\n   }\n   \n   PancakeSort(int[] numbers) {\n      heap = numbers;\n      sort(numbers.length, 1);\n   } \n \n   public static void main(String[] args) {\n      int[] numbers = new int[args.length];\n      for (int i = 0; i < args.length; ++i)\n         numbers[i] = Integer.valueOf(args[i]);\n\n      PancakeSort pancakes = new PancakeSort(numbers);\n      System.out.println(pancakes);\n   }\n}\n"}
{"id": 338162, "name": "Call a function", "source": "Translate Swift to Java: \nnoArgs()\n\n\noneArgUnnamed(1)\n\n\noneArgNamed(arg: 1)\n\n\ntwoArgsUnnamed(1, 2)\n\n\ntwoArgsNamed(arg1: 1, arg2: 2)\n\n\n\noptionalArguments(arg: 1)\n\noptionalArguments() \n\n\nfuncArg(noArgs)\n\n\nvariadic(opts: \"foo\", \"bar\")\n\n\nlet foo = returnString()\n\n\nlet (foo, bar, baz) = returnSomeValues()\n\n\nlet (foo, _, baz) = returnSomeValues()\n", "target": "foo();             \nInt x = bar();     \n"}
{"id": 338163, "name": "Call a function", "source": "Translate Swift to Java: \nnoArgs()\n\n\noneArgUnnamed(1)\n\n\noneArgNamed(arg: 1)\n\n\ntwoArgsUnnamed(1, 2)\n\n\ntwoArgsNamed(arg1: 1, arg2: 2)\n\n\n\noptionalArguments(arg: 1)\n\noptionalArguments() \n\n\nfuncArg(noArgs)\n\n\nvariadic(opts: \"foo\", \"bar\")\n\n\nlet foo = returnString()\n\n\nlet (foo, bar, baz) = returnSomeValues()\n\n\nlet (foo, _, baz) = returnSomeValues()\n", "target": "foo();             \nInt x = bar();     \n"}
{"id": 338164, "name": "Copy a string", "source": "Translate Swift to Java: var src = \"Hello\"\nvar dst = src\n", "target": "String src = \"Hello\";\nString newAlias = src;\nString strCopy = new String(src);\n\n\n\n\n"}
{"id": 338165, "name": "String comparison", "source": "Translate Swift to Java: func compare (a: String, b: String) {\n  if a == b {\n    println(\"'\\(a)' and '\\(b)' are lexically equal.\")\n  }\n  if a != b {\n    println(\"'\\(a)' and '\\(b)' are not lexically equal.\")\n  }\n  \n  if a < b {\n    println(\"'\\(a)' is lexically before '\\(b)'.\")\n  }\n  if a > b {\n    println(\"'\\(a)' is lexically after '\\(b)'.\")\n  }\n  \n  if a >= b {\n    println(\"'\\(a)' is not lexically before '\\(b)'.\")\n  }\n  if a <= b {\n    println(\"'\\(a)' is not lexically after '\\(b)'.\")\n  }\n}\ncompare(\"cat\", \"dog\")\n", "target": "public class Compare\n{\n\t\n    \n    public static void compare (String A, String B)\n    {\n        if (A.equals(B))\n            System.debug(A + ' and  ' + B + ' are lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not lexically equal.');\n\n        if (A.equalsIgnoreCase(B))\n            System.debug(A + ' and  ' + B + ' are case-insensitive lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not case-insensitive lexically equal.');\n \n        if (A.compareTo(B) < 0)\n            System.debug(A + ' is lexically before ' + B);\n        else if (A.compareTo(B) > 0)\n            System.debug(A + ' is lexically after ' + B);\n \n        if (A.compareTo(B) >= 0)\n            System.debug(A + ' is not lexically before ' + B);\n        if (A.compareTo(B) <= 0)\n            System.debug(A + ' is not lexically after ' + B);\n \n        System.debug('The lexical relationship is: ' + A.compareTo(B));\n    }\n}\n"}
{"id": 338166, "name": "Bioinformatics_Sequence mutation", "source": "Translate Swift to Java: let bases: [Character] = [\"A\", \"C\", \"G\", \"T\"]\n\nenum Action: CaseIterable {\n  case swap, delete, insert\n}\n\n@discardableResult\nfunc mutate(dna: inout String) -> Action {\n  guard let i = dna.indices.shuffled().first(where: { $0 != dna.endIndex }) else {\n    fatalError()\n  }\n\n  let action = Action.allCases.randomElement()!\n\n  switch action {\n  case .swap:\n    dna.replaceSubrange(i..<i, with: [bases.randomElement()!])\n  case .delete:\n    dna.remove(at: i)\n  case .insert:\n    dna.insert(bases.randomElement()!, at: i)\n  }\n\n  return action\n}\n\nvar d = \"\"\n\nfor _ in 0..<200 {\n  d.append(bases.randomElement()!)\n}\n\nfunc printSeq(_ dna: String) {\n  for startI in stride(from: 0, to: dna.count, by: 50) {\n    print(\"\\(startI): \\(dna.dropFirst(startI).prefix(50))\")\n  }\n\n  print()\n  print(\"Size: \\(dna.count)\")\n  print()\n\n  let counts = dna.reduce(into: [:], { $0[$1, default: 0] += 1 })\n\n  for (char, count) in counts.sorted(by: { $0.key < $1.key }) {\n    print(\"\\(char): \\(count)\")\n  }\n}\n\nprintSeq(d)\n\nprint()\n\nfor _ in 0..<20 {\n  mutate(dna: &d)\n}\n\nprintSeq(d)\n", "target": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class SequenceMutation {\n    public static void main(String[] args) {\n        SequenceMutation sm = new SequenceMutation();\n        sm.setWeight(OP_CHANGE, 3);\n        String sequence = sm.generateSequence(250);\n        System.out.println(\"Initial sequence:\");\n        printSequence(sequence);\n        int count = 10;\n        for (int i = 0; i < count; ++i)\n            sequence = sm.mutateSequence(sequence);\n        System.out.println(\"After \" + count + \" mutations:\");\n        printSequence(sequence);\n    }\n\n    public SequenceMutation() {\n        totalWeight_ = OP_COUNT;\n        Arrays.fill(operationWeight_, 1);\n    }\n\n    public String generateSequence(int length) {\n        char[] ch = new char[length];\n        for (int i = 0; i < length; ++i)\n            ch[i] = getRandomBase();\n        return new String(ch);\n    }\n\n    public void setWeight(int operation, int weight) {\n        totalWeight_ -= operationWeight_[operation];\n        operationWeight_[operation] = weight;\n        totalWeight_ += weight;\n    }\n\n    public String mutateSequence(String sequence) {\n        char[] ch = sequence.toCharArray();\n        int pos = random_.nextInt(ch.length);\n        int operation = getRandomOperation();\n        if (operation == OP_CHANGE) {\n            char b = getRandomBase();\n            System.out.println(\"Change base at position \" + pos + \" from \"\n                               + ch[pos] + \" to \" + b);\n            ch[pos] = b;\n        } else if (operation == OP_ERASE) {\n            System.out.println(\"Erase base \" + ch[pos] + \" at position \" + pos);\n            char[] newCh = new char[ch.length - 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos + 1, newCh, pos, ch.length - pos - 1);\n            ch = newCh;\n        } else if (operation == OP_INSERT) {\n            char b = getRandomBase();\n            System.out.println(\"Insert base \" + b + \" at position \" + pos);\n            char[] newCh = new char[ch.length + 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos, newCh, pos + 1, ch.length - pos);\n            newCh[pos] = b;\n            ch = newCh;\n        }\n        return new String(ch);\n    }\n\n    public static void printSequence(String sequence) {\n        int[] count = new int[BASES.length];\n        for (int i = 0, n = sequence.length(); i < n; ++i) {\n            if (i % 50 == 0) {\n                if (i != 0)\n                    System.out.println();\n                System.out.printf(\"%3d: \", i);\n            }\n            char ch = sequence.charAt(i);\n            System.out.print(ch);\n            for (int j = 0; j < BASES.length; ++j) {\n                if (BASES[j] == ch) {\n                    ++count[j];\n                    break;\n                }\n            }\n        }\n        System.out.println();\n        System.out.println(\"Base counts:\");\n        int total = 0;\n        for (int j = 0; j < BASES.length; ++j) {\n            total += count[j];\n            System.out.print(BASES[j] + \": \" + count[j] + \", \");\n        }\n        System.out.println(\"Total: \" + total);\n    }\n\n    private char getRandomBase() {\n        return BASES[random_.nextInt(BASES.length)];\n    }\n\n    private int getRandomOperation() {\n        int n = random_.nextInt(totalWeight_), op = 0;\n        for (int weight = 0; op < OP_COUNT; ++op) {\n            weight += operationWeight_[op];\n            if (n < weight)\n                break;\n        }\n        return op;\n    }\n\n    private final Random random_ = new Random();\n    private int[] operationWeight_ = new int[OP_COUNT];\n    private int totalWeight_ = 0;\n\n    private static final int OP_CHANGE = 0;\n    private static final int OP_ERASE = 1;\n    private static final int OP_INSERT = 2;\n    private static final int OP_COUNT = 3;\n    private static final char[] BASES = {'A', 'C', 'G', 'T'};\n}\n"}
{"id": 338167, "name": "Bioinformatics_Sequence mutation", "source": "Translate Swift to Java: let bases: [Character] = [\"A\", \"C\", \"G\", \"T\"]\n\nenum Action: CaseIterable {\n  case swap, delete, insert\n}\n\n@discardableResult\nfunc mutate(dna: inout String) -> Action {\n  guard let i = dna.indices.shuffled().first(where: { $0 != dna.endIndex }) else {\n    fatalError()\n  }\n\n  let action = Action.allCases.randomElement()!\n\n  switch action {\n  case .swap:\n    dna.replaceSubrange(i..<i, with: [bases.randomElement()!])\n  case .delete:\n    dna.remove(at: i)\n  case .insert:\n    dna.insert(bases.randomElement()!, at: i)\n  }\n\n  return action\n}\n\nvar d = \"\"\n\nfor _ in 0..<200 {\n  d.append(bases.randomElement()!)\n}\n\nfunc printSeq(_ dna: String) {\n  for startI in stride(from: 0, to: dna.count, by: 50) {\n    print(\"\\(startI): \\(dna.dropFirst(startI).prefix(50))\")\n  }\n\n  print()\n  print(\"Size: \\(dna.count)\")\n  print()\n\n  let counts = dna.reduce(into: [:], { $0[$1, default: 0] += 1 })\n\n  for (char, count) in counts.sorted(by: { $0.key < $1.key }) {\n    print(\"\\(char): \\(count)\")\n  }\n}\n\nprintSeq(d)\n\nprint()\n\nfor _ in 0..<20 {\n  mutate(dna: &d)\n}\n\nprintSeq(d)\n", "target": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class SequenceMutation {\n    public static void main(String[] args) {\n        SequenceMutation sm = new SequenceMutation();\n        sm.setWeight(OP_CHANGE, 3);\n        String sequence = sm.generateSequence(250);\n        System.out.println(\"Initial sequence:\");\n        printSequence(sequence);\n        int count = 10;\n        for (int i = 0; i < count; ++i)\n            sequence = sm.mutateSequence(sequence);\n        System.out.println(\"After \" + count + \" mutations:\");\n        printSequence(sequence);\n    }\n\n    public SequenceMutation() {\n        totalWeight_ = OP_COUNT;\n        Arrays.fill(operationWeight_, 1);\n    }\n\n    public String generateSequence(int length) {\n        char[] ch = new char[length];\n        for (int i = 0; i < length; ++i)\n            ch[i] = getRandomBase();\n        return new String(ch);\n    }\n\n    public void setWeight(int operation, int weight) {\n        totalWeight_ -= operationWeight_[operation];\n        operationWeight_[operation] = weight;\n        totalWeight_ += weight;\n    }\n\n    public String mutateSequence(String sequence) {\n        char[] ch = sequence.toCharArray();\n        int pos = random_.nextInt(ch.length);\n        int operation = getRandomOperation();\n        if (operation == OP_CHANGE) {\n            char b = getRandomBase();\n            System.out.println(\"Change base at position \" + pos + \" from \"\n                               + ch[pos] + \" to \" + b);\n            ch[pos] = b;\n        } else if (operation == OP_ERASE) {\n            System.out.println(\"Erase base \" + ch[pos] + \" at position \" + pos);\n            char[] newCh = new char[ch.length - 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos + 1, newCh, pos, ch.length - pos - 1);\n            ch = newCh;\n        } else if (operation == OP_INSERT) {\n            char b = getRandomBase();\n            System.out.println(\"Insert base \" + b + \" at position \" + pos);\n            char[] newCh = new char[ch.length + 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos, newCh, pos + 1, ch.length - pos);\n            newCh[pos] = b;\n            ch = newCh;\n        }\n        return new String(ch);\n    }\n\n    public static void printSequence(String sequence) {\n        int[] count = new int[BASES.length];\n        for (int i = 0, n = sequence.length(); i < n; ++i) {\n            if (i % 50 == 0) {\n                if (i != 0)\n                    System.out.println();\n                System.out.printf(\"%3d: \", i);\n            }\n            char ch = sequence.charAt(i);\n            System.out.print(ch);\n            for (int j = 0; j < BASES.length; ++j) {\n                if (BASES[j] == ch) {\n                    ++count[j];\n                    break;\n                }\n            }\n        }\n        System.out.println();\n        System.out.println(\"Base counts:\");\n        int total = 0;\n        for (int j = 0; j < BASES.length; ++j) {\n            total += count[j];\n            System.out.print(BASES[j] + \": \" + count[j] + \", \");\n        }\n        System.out.println(\"Total: \" + total);\n    }\n\n    private char getRandomBase() {\n        return BASES[random_.nextInt(BASES.length)];\n    }\n\n    private int getRandomOperation() {\n        int n = random_.nextInt(totalWeight_), op = 0;\n        for (int weight = 0; op < OP_COUNT; ++op) {\n            weight += operationWeight_[op];\n            if (n < weight)\n                break;\n        }\n        return op;\n    }\n\n    private final Random random_ = new Random();\n    private int[] operationWeight_ = new int[OP_COUNT];\n    private int totalWeight_ = 0;\n\n    private static final int OP_CHANGE = 0;\n    private static final int OP_ERASE = 1;\n    private static final int OP_INSERT = 2;\n    private static final int OP_COUNT = 3;\n    private static final char[] BASES = {'A', 'C', 'G', 'T'};\n}\n"}
{"id": 338168, "name": "Exceptions", "source": "Translate Swift to Java: enum MyException : ErrorType {\n  case TerribleException\n}\n", "target": "\npublic class MyException extends Exception {\n   \n}\n\n\npublic class MyRuntimeException extends RuntimeException {}\n"}
{"id": 338169, "name": "24 game", "source": "Translate Swift to Java: import Darwin\nimport Foundation\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> Int[] {\n    var result = Int[]();\n    for var i = 0; i < 4; i++ {\n        result.append(Int(arc4random_uniform(9)+1))\n    }\n    return result;\n}\n\n\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits\u00a0: \")\n\nfor digit in digits {\n    print(\"\\(digit) \")\n}\nprintln()\n\n\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)\n\nvar enteredDigits = Int[]()\n\nvar enteredOperations = Character[]()\n\nlet inputString = input as String\n\n\nfor character in inputString {\n    switch character {\n        case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n            let digit = String(character)\n            enteredDigits.append(digit.toInt()!)\n        case \"+\", \"-\", \"*\", \"/\":\n            enteredOperations.append(character)\n        case \"\\n\":\n            println()\n        default:\n            println(\"Invalid expression\")\n    }\n}\n\n\nvar value = Int()\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n    value = enteredDigits[0]\n    for (i, operation) in enumerate(enteredOperations) {\n        switch operation {\n            case \"+\":\n                value = value + enteredDigits[i+1]\n            case \"-\":\n                value = value - enteredDigits[i+1]\n            case \"*\":\n                value = value * enteredDigits[i+1]\n            case \"/\":\n                value = value / enteredDigits[i+1]\n            default:\n                println(\"This message should never happen!\")\n        }\n    }\n}\n\nif value != 24 {\n    println(\"The value of the provided expression is \\(value) instead of 24!\")\n} else {\n    println(\"Congratulations, you found a solution!\")\n}\n", "target": "import java.util.*;\n\npublic class Game24 {\n    static Random r = new Random();\n\n    public static void main(String[] args) {\n\n        int[] digits = randomDigits();\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Make 24 using these digits: \");\n        System.out.println(Arrays.toString(digits));\n        System.out.print(\"> \");\n\n        Stack<Float> s = new Stack<>();\n        long total = 0;\n        for (char c : in.nextLine().toCharArray()) {\n            if ('0' <= c && c <= '9') {\n                int d = c - '0';\n                total += (1 << (d * 5));\n                s.push((float) d);\n            } else if (\"+/-*\".indexOf(c) != -1) {\n                s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        }\n        if (tallyDigits(digits) != total)\n            System.out.print(\"Not the same digits. \");\n        else if (Math.abs(24 - s.peek()) < 0.001F)\n            System.out.println(\"Correct!\");\n        else\n            System.out.print(\"Not correct.\");\n    }\n\n    static float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    static long tallyDigits(int[] a) {\n        long total = 0;\n        for (int i = 0; i < 4; i++)\n            total += (1 << (a[i] * 5));\n        return total;\n    }\n\n    static int[] randomDigits() {        \n        int[] result = new int[4];\n        for (int i = 0; i < 4; i++)\n            result[i] = r.nextInt(9) + 1;\n        return result;\n    }\n}\n"}
{"id": 338170, "name": "24 game", "source": "Translate Swift to Java: import Darwin\nimport Foundation\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> Int[] {\n    var result = Int[]();\n    for var i = 0; i < 4; i++ {\n        result.append(Int(arc4random_uniform(9)+1))\n    }\n    return result;\n}\n\n\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits\u00a0: \")\n\nfor digit in digits {\n    print(\"\\(digit) \")\n}\nprintln()\n\n\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)\n\nvar enteredDigits = Int[]()\n\nvar enteredOperations = Character[]()\n\nlet inputString = input as String\n\n\nfor character in inputString {\n    switch character {\n        case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n            let digit = String(character)\n            enteredDigits.append(digit.toInt()!)\n        case \"+\", \"-\", \"*\", \"/\":\n            enteredOperations.append(character)\n        case \"\\n\":\n            println()\n        default:\n            println(\"Invalid expression\")\n    }\n}\n\n\nvar value = Int()\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n    value = enteredDigits[0]\n    for (i, operation) in enumerate(enteredOperations) {\n        switch operation {\n            case \"+\":\n                value = value + enteredDigits[i+1]\n            case \"-\":\n                value = value - enteredDigits[i+1]\n            case \"*\":\n                value = value * enteredDigits[i+1]\n            case \"/\":\n                value = value / enteredDigits[i+1]\n            default:\n                println(\"This message should never happen!\")\n        }\n    }\n}\n\nif value != 24 {\n    println(\"The value of the provided expression is \\(value) instead of 24!\")\n} else {\n    println(\"Congratulations, you found a solution!\")\n}\n", "target": "import java.util.*;\n\npublic class Game24 {\n    static Random r = new Random();\n\n    public static void main(String[] args) {\n\n        int[] digits = randomDigits();\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Make 24 using these digits: \");\n        System.out.println(Arrays.toString(digits));\n        System.out.print(\"> \");\n\n        Stack<Float> s = new Stack<>();\n        long total = 0;\n        for (char c : in.nextLine().toCharArray()) {\n            if ('0' <= c && c <= '9') {\n                int d = c - '0';\n                total += (1 << (d * 5));\n                s.push((float) d);\n            } else if (\"+/-*\".indexOf(c) != -1) {\n                s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        }\n        if (tallyDigits(digits) != total)\n            System.out.print(\"Not the same digits. \");\n        else if (Math.abs(24 - s.peek()) < 0.001F)\n            System.out.println(\"Correct!\");\n        else\n            System.out.print(\"Not correct.\");\n    }\n\n    static float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    static long tallyDigits(int[] a) {\n        long total = 0;\n        for (int i = 0; i < 4; i++)\n            total += (1 << (a[i] * 5));\n        return total;\n    }\n\n    static int[] randomDigits() {        \n        int[] result = new int[4];\n        for (int i = 0; i < 4; i++)\n            result[i] = r.nextInt(9) + 1;\n        return result;\n    }\n}\n"}
{"id": 338171, "name": "Enforced immutability", "source": "Translate Swift to Java: let a = 1\na = 1 \nvar b = 1\nb = 1\n", "target": "final int immutableInt = 4;\nint mutableInt = 4;\nmutableInt = 6; \nimmutableInt = 6; \n"}
{"id": 338172, "name": "Hofstadter Q sequence", "source": "Translate Swift to Java: let n = 100000\n\nvar q = Array(repeating: 0, count: n)\nq[0] = 1\nq[1] = 1\n\nfor i in 2..<n {\n    q[i] = q[i - q[i - 1]] + q[i - q[i - 2]]\n}\n\nprint(\"First 10 elements of the sequence: \\(q[0..<10])\")\nprint(\"1000th element of the sequence: \\(q[999])\")\n\nvar count = 0\nfor i in 1..<n {\n    if q[i] < q[i - 1] {\n        count += 1\n    }\n}\nprint(\"Number of times a member of the sequence is less than the preceding term for terms up to and including the 100,000th term: \\(count)\")\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HofQ {\n\tprivate static Map<Integer, Integer> q = new HashMap<Integer, Integer>(){{\n\t\tput(1, 1);\n\t\tput(2, 1);\n\t}};\n\t\n\tprivate static int[] nUses = new int[100001];\n\t\n\tpublic static int Q(int n){\n\t\tnUses[n]++;\n\t\tif(q.containsKey(n)){\n\t\t\treturn q.get(n);\n\t\t}\n\t\tint ans = Q(n - Q(n - 1)) + Q(n - Q(n - 2));\n\t\tq.put(n, ans);\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"Q(\" + i + \") = \" + Q(i));\n\t\t}\n\t\tint last = 6;\n\t\tint count = 0;\n\t\tfor(int i = 11; i <= 100000; i++){\n\t\t\tint curr = Q(i);\n\t\t\tif(curr < last) count++;\n\t\t\tlast = curr;\n\t\t\tif(i == 1000) System.out.println(\"Q(1000) = \" + curr);\n\t\t}\n\t\tSystem.out.println(\"Q(i) is less than Q(i-1) for i <= 100000 \" + count + \" times\");\n\t\t\n\t\t\n\t\tint maxUses = 0, maxN = 0;\n\t\tfor(int i = 1; i<nUses.length;i++){\n\t\t\tif(nUses[i] > maxUses){\n\t\t\t\tmaxUses = nUses[i];\n\t\t\t\tmaxN = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Q(\" + maxN + \") was called the most with \" + maxUses + \" calls\");\n\t}\n}\n"}
{"id": 338173, "name": "Hofstadter Q sequence", "source": "Translate Swift to Java: let n = 100000\n\nvar q = Array(repeating: 0, count: n)\nq[0] = 1\nq[1] = 1\n\nfor i in 2..<n {\n    q[i] = q[i - q[i - 1]] + q[i - q[i - 2]]\n}\n\nprint(\"First 10 elements of the sequence: \\(q[0..<10])\")\nprint(\"1000th element of the sequence: \\(q[999])\")\n\nvar count = 0\nfor i in 1..<n {\n    if q[i] < q[i - 1] {\n        count += 1\n    }\n}\nprint(\"Number of times a member of the sequence is less than the preceding term for terms up to and including the 100,000th term: \\(count)\")\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HofQ {\n\tprivate static Map<Integer, Integer> q = new HashMap<Integer, Integer>(){{\n\t\tput(1, 1);\n\t\tput(2, 1);\n\t}};\n\t\n\tprivate static int[] nUses = new int[100001];\n\t\n\tpublic static int Q(int n){\n\t\tnUses[n]++;\n\t\tif(q.containsKey(n)){\n\t\t\treturn q.get(n);\n\t\t}\n\t\tint ans = Q(n - Q(n - 1)) + Q(n - Q(n - 2));\n\t\tq.put(n, ans);\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"Q(\" + i + \") = \" + Q(i));\n\t\t}\n\t\tint last = 6;\n\t\tint count = 0;\n\t\tfor(int i = 11; i <= 100000; i++){\n\t\t\tint curr = Q(i);\n\t\t\tif(curr < last) count++;\n\t\t\tlast = curr;\n\t\t\tif(i == 1000) System.out.println(\"Q(1000) = \" + curr);\n\t\t}\n\t\tSystem.out.println(\"Q(i) is less than Q(i-1) for i <= 100000 \" + count + \" times\");\n\t\t\n\t\t\n\t\tint maxUses = 0, maxN = 0;\n\t\tfor(int i = 1; i<nUses.length;i++){\n\t\t\tif(nUses[i] > maxUses){\n\t\t\t\tmaxUses = nUses[i];\n\t\t\t\tmaxN = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Q(\" + maxN + \") was called the most with \" + maxUses + \" calls\");\n\t}\n}\n"}
{"id": 338174, "name": "Count occurrences of a substring", "source": "Translate Swift to Java: import Foundation\n\nfunc countSubstring(str: String, substring: String) -> Int {\n  return str.components(separatedBy: substring).count - 1\n}\n\nprint(countSubstring(str: \"the three truths\", substring: \"th\"))\nprint(countSubstring(str: \"ababababab\", substring: \"abab\"))\n", "target": "public class CountSubstring {\n\tpublic static int countSubstring(String subStr, String str){\n\t\treturn (str.length() - str.replace(subStr, \"\").length()) / subStr.length();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(countSubstring(\"th\", \"the three truths\"));\n\t\tSystem.out.println(countSubstring(\"abab\", \"ababababab\"));\n\t\tSystem.out.println(countSubstring(\"a*b\", \"abaabba*bbaba*bbab\"));\n\t}\n}\n"}
{"id": 338175, "name": "Carmichael 3 strong pseudoprimes", "source": "Translate Swift to Java: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) {\n      if self % i == 0 {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\n@inlinable\npublic func carmichael<T: BinaryInteger & SignedNumeric>(p1: T) -> [(T, T, T)] {\n  func mod(_ n: T, _ m: T) -> T { (n % m + m) % m }\n\n  var res = [(T, T, T)]()\n\n  guard p1.isPrime else {\n    return res\n  }\n\n  for h3 in stride(from: 2, to: p1, by: 1) {\n    for d in stride(from: 1, to: h3 + p1, by: 1) {\n      if (h3 + p1) * (p1 - 1) % d != 0 || mod(-p1 * p1, h3) != d % h3 {\n        continue\n      }\n\n      let p2 = 1 + (p1 - 1) * (h3 + p1) / d\n\n      guard p2.isPrime else {\n        continue\n      }\n\n      let p3 = 1 + p1 * p2 / h3\n\n      guard p3.isPrime && (p2 * p3) % (p1 - 1) == 1 else {\n        continue\n      }\n\n      res.append((p1, p2, p3))\n    }\n  }\n\n  return res\n}\n\n\nlet res =\n  (1..<62)\n    .lazy\n    .filter({ $0.isPrime })\n    .map(carmichael)\n    .filter({ !$0.isEmpty })\n    .flatMap({ $0 })\n\nfor c in res {\n  print(c)\n}\n", "target": "public class Test {\n\n    static int mod(int n, int m) {\n        return ((n % m) + m) % m;\n    }\n\n    static boolean isPrime(int n) {\n        if (n == 2 || n == 3)\n            return true;\n        else if (n < 2 || n % 2 == 0 || n % 3 == 0)\n            return false;\n        for (int div = 5, inc = 2; Math.pow(div, 2) <= n;\n                div += inc, inc = 6 - inc)\n            if (n % div == 0)\n                return false;\n        return true;\n    }\n\n    public static void main(String[] args) {\n        for (int p = 2; p < 62; p++) {\n            if (!isPrime(p))\n                continue;\n            for (int h3 = 2; h3 < p; h3++) {\n                int g = h3 + p;\n                for (int d = 1; d < g; d++) {\n                    if ((g * (p - 1)) % d != 0 || mod(-p * p, h3) != d % h3)\n                        continue;\n                    int q = 1 + (p - 1) * g / d;\n                    if (!isPrime(q))\n                        continue;\n                    int r = 1 + (p * q / h3);\n                    if (!isPrime(r) || (q * r) % (p - 1) != 1)\n                        continue;\n                    System.out.printf(\"%d x %d x %d%n\", p, q, r);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 338176, "name": "Fractal tree", "source": "Translate Swift to Java: extension CGFloat {\n  func degrees_to_radians() -> CGFloat {\n    return CGFloat(M_PI) * self / 180.0\n  }\n}\n\nextension Double {\n  func degrees_to_radians() -> Double {\n    return Double(M_PI) * self / 180.0\n  }\n}\n\n\nclass Tree: UIView {\n  \n  \n  func drawTree(x1: CGFloat, y1: CGFloat, angle: CGFloat, depth:Int){\n    if depth == 0 {\n      return\n    }\n    let ang = angle.degrees_to_radians()\n    let x2:CGFloat = x1 + ( cos(ang) as CGFloat) * CGFloat(depth) * (self.frame.width / 60)\n    let y2:CGFloat = y1 + ( sin(ang) as CGFloat) * CGFloat(depth) * (self.frame.width / 60)\n    \n    let line = drawLine(x1, y1: y1, x2: x2, y2: y2)\n  \n    line.stroke()\n    drawTree(x2, y1: y2, angle: angle - 20, depth: depth - 1)\n    drawTree(x2, y1: y2, angle: angle + 20, depth: depth - 1)\n  }\n  \n  func drawLine(x1:CGFloat, y1:CGFloat, x2:CGFloat, y2:CGFloat) -> UIBezierPath\n  {\n    \n    let path = UIBezierPath()\n    path.moveToPoint(CGPoint(x: x1,y: y1))\n    path.addLineToPoint(CGPoint(x: x2,y: y2))\n    path.lineWidth = 1\n    return path\n  }\n  \n  override func drawRect(rect: CGRect) {\n    \n    let color = UIColor(red: 1.0, green: 0.0, blue: 0.0, alpha: 1.0)\n    color.set()\n    drawTree(self.frame.width / 2 , y1: self.frame.height * 0.8, angle: -90 , depth: 9 )\n  }\n}\n\n\nlet tree = Tree(frame: CGRectMake(0, 0, 300, 300))\ntree\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\nimport javax.swing.JFrame;\n\npublic class FractalTree extends JFrame {\n\n    public FractalTree() {\n        super(\"Fractal Tree\");\n        setBounds(100, 100, 800, 600);\n        setResizable(false);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n    }\n\n    private void drawTree(Graphics g, int x1, int y1, double angle, int depth) {\n        if (depth == 0) return;\n        int x2 = x1 + (int) (Math.cos(Math.toRadians(angle)) * depth * 10.0);\n        int y2 = y1 + (int) (Math.sin(Math.toRadians(angle)) * depth * 10.0);\n        g.drawLine(x1, y1, x2, y2);\n        drawTree(g, x2, y2, angle - 20, depth - 1);\n        drawTree(g, x2, y2, angle + 20, depth - 1);\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.setColor(Color.BLACK);\n        drawTree(g, 400, 500, -90, 9);\n    }\n\n    public static void main(String[] args) {\n        new FractalTree().setVisible(true);\n    }\n}\n"}
{"id": 338177, "name": "Rock-paper-scissors", "source": "Translate Swift to Java: enum Choice: CaseIterable {\n  case rock\n  case paper\n  case scissors\n  case lizard\n  case spock\n}\n\nextension Choice {\n  var weaknesses: Set<Choice> {\n    switch self {\n      case .rock:\n        return [.paper, .spock]\n      case .paper:\n        return [.scissors, .lizard]\n      case .scissors:\n        return [.rock, .spock]\n      case .lizard:\n        return [.rock, .scissors]\n      case .spock:\n        return [.paper, .lizard]\n    }\n  }\n}\n\nstruct Game {\n  private(set) var history: [(Choice, Choice)] = []\n  private(set) var p1Score: Int = 0\n  private(set) var p2Score: Int = 0\n\n  mutating func play(_ p1Choice: Choice, against p2Choice: Choice) {\n    history.append((p1Choice, p2Choice))\n    if p2Choice.weaknesses.contains(p1Choice) {\n      p1Score += 1\n    } else if p1Choice.weaknesses.contains(p2Choice) {\n      p2Score += 1\n    }\n  }\n}\n\nfunc aiChoice(for game: Game) -> Choice {\n  if let weightedWeekness = game.history.flatMap({ $0.0.weaknesses }).randomElement() {\n    return weightedWeekness\n  } else {\n    \n    return Choice.allCases.randomElement()!\n  }\n}\n\nvar game = Game()\nprint(\"Type your choice to play a round, or 'q' to quit\")\nloop: while true {\n  let choice: Choice\n  switch readLine().map({ $0.lowercased() }) {\n    case \"r\", \"rock\":\n      choice = .rock\n    case \"p\", \"paper\":\n      choice = .paper\n    case \"scissors\":\n      choice = .scissors\n    case \"l\", \"lizard\":\n      choice = .lizard\n    case \"spock\":\n      choice = .spock\n    case \"q\", \"quit\", \"exit\":\n      break loop\n    case \"s\":\n      print(\"Do you mean Spock, or scissors?\")\n      continue\n    default: \n      print(\"Unknown choice. Type 'q' to quit\")\n      continue\n  }\n  let p2Choice = aiChoice(for: game)\n  print(\"You played \\(choice) against \\(p2Choice)\")\n  game.play(choice, against: p2Choice)\n  print(\"Current score: \\(game.p1Score)\u00a0: \\(game.p2Score)\")\n}\n", "target": "import java.util.Arrays;\nimport java.util.EnumMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Random;\n\npublic class RPS {\n\tpublic enum Item{\n\t\tROCK, PAPER, SCISSORS, ;\n\t\tpublic List<Item> losesToList;\n\t\tpublic boolean losesTo(Item other) {\n\t\t\treturn losesToList.contains(other);\n\t\t}\n\t\tstatic {\n\t\t\tSCISSORS.losesToList = Arrays.asList(ROCK);\n\t\t\tROCK.losesToList = Arrays.asList(PAPER);\n\t\t\tPAPER.losesToList = Arrays.asList(SCISSORS);\n\t\t\t\n                }\n\t}\n\t\n\tpublic final Map<Item, Integer> counts = new EnumMap<Item, Integer>(Item.class){{\n\t\tfor(Item item:Item.values())\n\t\t\tput(item, 1);\n\t}};\n\n\tprivate int totalThrows = Item.values().length;\n\n\tpublic static void main(String[] args){\n\t\tRPS rps = new RPS();\n\t\trps.run();\n\t}\n\n\tpublic void run() {\n\t\tScanner in = new Scanner(System.in);\n\t\tSystem.out.print(\"Make your choice: \");\n\t\twhile(in.hasNextLine()){\n\t\t\tItem aiChoice = getAIChoice();\n\t\t\tString input = in.nextLine();\n\t\t\tItem choice;\n\t\t\ttry{\n\t\t\t\tchoice = Item.valueOf(input.toUpperCase());\n\t\t\t}catch (IllegalArgumentException ex){\n\t\t\t\tSystem.out.println(\"Invalid choice\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcounts.put(choice, counts.get(choice) + 1);\n\t\t\ttotalThrows++;\n\t\t\tSystem.out.println(\"Computer chose: \" + aiChoice);\n\t\t\tif(aiChoice == choice){\n\t\t\t\tSystem.out.println(\"Tie!\");\n\t\t\t}else if(aiChoice.losesTo(choice)){\n\t\t\t\tSystem.out.println(\"You chose...wisely. You win!\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"You chose...poorly. You lose!\");\n\t\t\t}\n\t\t\tSystem.out.print(\"Make your choice: \");\n\t\t}\n\t}\n\n\tprivate static final Random rng = new Random();\n\tprivate Item getAIChoice() {\n\t\tint rand = rng.nextInt(totalThrows);\n\t\tfor(Map.Entry<Item, Integer> entry:counts.entrySet()){\n\t\t\tItem item = entry.getKey();\n\t\t\tint count = entry.getValue();\n\t\t\tif(rand < count){\n\t\t\t\tList<Item> losesTo = item.losesToList;\n\t\t\t\treturn losesTo.get(rng.nextInt(losesTo.size()));\n\t\t\t}\n\t\t\trand -= count;\n\t\t}\n\t\treturn null;\n\t}\n}\n"}
{"id": 338178, "name": "Benford's law", "source": "Translate Swift to Java: import Foundation\n\n\nfunc readFromFile(fileName file:String) -> String{\n    \n    var ret:String = \"\"\n    \n    let path = Foundation.URL(string: \"file:\n    \n    do {\n        ret = try String(contentsOf: path!, encoding: String.Encoding.utf8)\n    }\n    catch {\n        print(\"Could not read from file!\")\n        exit(-1)\n    }\n   \n    return ret\n}\n\n\nfunc benford(digit z:Int) -> Double {\n    \n    if z<=0 || z>9 {\n        perror(\"Argument must be between 1 and 9.\")\n        return 0\n    }\n    \n    return log10(Double(1)+Double(1)/Double(z))\n}\n\n\nif CommandLine.arguments.count < 2 {\n    print(\"Usage: Benford [FILE]\")\n    exit(-1)\n}\n\nlet pathToFile = CommandLine.arguments[1]\n\n\nlet content = readFromFile(fileName: pathToFile)\nlet lines = content.components(separatedBy: \"\\n\")\n\nvar digitCount:UInt64 = 0\nvar countDigit:[UInt64] = [0,0,0,0,0,0,0,0,0]\n\n\nfor line in lines {\n    if line == \"\" {\n        continue\n    }\n    let charLine = Array(line.characters)\n        switch(charLine[0]){\n            case \"1\":\n                countDigit[0] += 1\n                digitCount += 1\n                break\n            case \"2\":\n                countDigit[1] += 1\n                digitCount += 1\n                break\n            case \"3\":\n                countDigit[2] += 1\n                digitCount += 1\n                break\n            case \"4\":\n                countDigit[3] += 1\n                digitCount += 1\n                break\n            case \"5\":\n                countDigit[4] += 1\n                digitCount += 1\n                break\n            case \"6\":\n                countDigit[5] += 1\n                digitCount += 1\n                break\n            case \"7\":\n                countDigit[6] += 1\n                digitCount += 1\n                break\n            case \"8\":\n                countDigit[7] += 1\n                digitCount += 1\n                break\n            case \"9\":\n                countDigit[8] += 1\n                digitCount += 1\n                break\n            default:\n                break\n        }\n    \n}\n\n\nprint(\"Digit\\tBenford [%]\\tObserved [%]\\tDeviation\")\nprint(\"~~~~~\\t~~~~~~~~~~~~\\t~~~~~~~~~~~~\\t~~~~~~~~~\")\nfor i in 0..<9 {\n    let temp:Double = Double(countDigit[i])/Double(digitCount)\n    let ben = benford(digit: i+1)\n    print(String(format: \"%d\\t%.2f\\t\\t%.2f\\t\\t%.4f\", i+1,ben*100,temp*100,ben-temp))\n}\n", "target": "import java.math.BigInteger;\nimport java.util.Locale;\n\npublic class BenfordsLaw {\n\n    private static BigInteger[] generateFibonacci(int n) {\n        BigInteger[] fib = new BigInteger[n];\n        fib[0] = BigInteger.ONE;\n        fib[1] = BigInteger.ONE;\n        for (int i = 2; i < fib.length; i++) {\n            fib[i] = fib[i - 2].add(fib[i - 1]);\n        }\n        return fib;\n    }\n\n    public static void main(String[] args) {\n        BigInteger[] numbers = generateFibonacci(1000);\n\n        int[] firstDigits = new int[10];\n        for (BigInteger number : numbers) {\n            firstDigits[Integer.valueOf(number.toString().substring(0, 1))]++;\n        }\n\n        for (int i = 1; i < firstDigits.length; i++) {\n            System.out.printf(Locale.ROOT, \"%d %10.6f %10.6f%n\",\n                    i, (double) firstDigits[i] / numbers.length, Math.log10(1.0 + 1.0 / i));\n        }\n    }\n}\n"}
{"id": 338179, "name": "Benford's law", "source": "Translate Swift to Java: import Foundation\n\n\nfunc readFromFile(fileName file:String) -> String{\n    \n    var ret:String = \"\"\n    \n    let path = Foundation.URL(string: \"file:\n    \n    do {\n        ret = try String(contentsOf: path!, encoding: String.Encoding.utf8)\n    }\n    catch {\n        print(\"Could not read from file!\")\n        exit(-1)\n    }\n   \n    return ret\n}\n\n\nfunc benford(digit z:Int) -> Double {\n    \n    if z<=0 || z>9 {\n        perror(\"Argument must be between 1 and 9.\")\n        return 0\n    }\n    \n    return log10(Double(1)+Double(1)/Double(z))\n}\n\n\nif CommandLine.arguments.count < 2 {\n    print(\"Usage: Benford [FILE]\")\n    exit(-1)\n}\n\nlet pathToFile = CommandLine.arguments[1]\n\n\nlet content = readFromFile(fileName: pathToFile)\nlet lines = content.components(separatedBy: \"\\n\")\n\nvar digitCount:UInt64 = 0\nvar countDigit:[UInt64] = [0,0,0,0,0,0,0,0,0]\n\n\nfor line in lines {\n    if line == \"\" {\n        continue\n    }\n    let charLine = Array(line.characters)\n        switch(charLine[0]){\n            case \"1\":\n                countDigit[0] += 1\n                digitCount += 1\n                break\n            case \"2\":\n                countDigit[1] += 1\n                digitCount += 1\n                break\n            case \"3\":\n                countDigit[2] += 1\n                digitCount += 1\n                break\n            case \"4\":\n                countDigit[3] += 1\n                digitCount += 1\n                break\n            case \"5\":\n                countDigit[4] += 1\n                digitCount += 1\n                break\n            case \"6\":\n                countDigit[5] += 1\n                digitCount += 1\n                break\n            case \"7\":\n                countDigit[6] += 1\n                digitCount += 1\n                break\n            case \"8\":\n                countDigit[7] += 1\n                digitCount += 1\n                break\n            case \"9\":\n                countDigit[8] += 1\n                digitCount += 1\n                break\n            default:\n                break\n        }\n    \n}\n\n\nprint(\"Digit\\tBenford [%]\\tObserved [%]\\tDeviation\")\nprint(\"~~~~~\\t~~~~~~~~~~~~\\t~~~~~~~~~~~~\\t~~~~~~~~~\")\nfor i in 0..<9 {\n    let temp:Double = Double(countDigit[i])/Double(digitCount)\n    let ben = benford(digit: i+1)\n    print(String(format: \"%d\\t%.2f\\t\\t%.2f\\t\\t%.4f\", i+1,ben*100,temp*100,ben-temp))\n}\n", "target": "import java.math.BigInteger;\nimport java.util.Locale;\n\npublic class BenfordsLaw {\n\n    private static BigInteger[] generateFibonacci(int n) {\n        BigInteger[] fib = new BigInteger[n];\n        fib[0] = BigInteger.ONE;\n        fib[1] = BigInteger.ONE;\n        for (int i = 2; i < fib.length; i++) {\n            fib[i] = fib[i - 2].add(fib[i - 1]);\n        }\n        return fib;\n    }\n\n    public static void main(String[] args) {\n        BigInteger[] numbers = generateFibonacci(1000);\n\n        int[] firstDigits = new int[10];\n        for (BigInteger number : numbers) {\n            firstDigits[Integer.valueOf(number.toString().substring(0, 1))]++;\n        }\n\n        for (int i = 1; i < firstDigits.length; i++) {\n            System.out.printf(Locale.ROOT, \"%d %10.6f %10.6f%n\",\n                    i, (double) firstDigits[i] / numbers.length, Math.log10(1.0 + 1.0 / i));\n        }\n    }\n}\n"}
{"id": 338180, "name": "Additive primes", "source": "Translate Swift to Java: import Foundation\n\nfunc isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfunc digitSum(_ num: Int) -> Int {\n    var sum = 0\n    var n = num\n    while n > 0 {\n        sum += n % 10\n        n /= 10\n    }\n    return sum\n}\n\nlet limit = 500\nprint(\"Additive primes less than \\(limit):\")\nvar count = 0\nfor n in 1..<limit {\n    if isPrime(digitSum(n)) && isPrime(n) {\n        count += 1\n        print(String(format: \"%3d\", n), terminator: count % 10 == 0 ? \"\\n\" : \" \")\n    }\n}\nprint(\"\\n\\(count) additive primes found.\")\n", "target": "public class additivePrimes {\n\n    public static void main(String[] args) {\n        int additive_primes = 0;\n        for (int i = 2; i < 500; i++) {\n            if(isPrime(i) && isPrime(digitSum(i))){\n                additive_primes++;\n                System.out.print(i + \" \");\n            }\n        }\n        System.out.print(\"\\nFound \" + additive_primes + \" additive primes less than 500\");\n    }\n\n    static boolean isPrime(int n) {\n        int counter = 1;\n        if (n < 2 || (n != 2 && n % 2 == 0) || (n != 3 && n % 3 == 0)) {\n            return false;\n        }\n        while (counter * 6 - 1 <= Math.sqrt(n)) {\n            if (n % (counter * 6 - 1) == 0 || n % (counter * 6 + 1) == 0) {\n                return false;\n            } else {\n                counter++;\n            }\n        }\n        return true;\n    }\n\n    static int digitSum(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"id": 338181, "name": "Case-sensitivity of identifiers", "source": "Translate Swift to Java: let dog = \"Benjamin\"\nlet Dog = \"Samba\"\nlet DOG = \"Bernie\"\nprintln(\"The three dogs are named \\(dog), \\(Dog), and \\(DOG).\")\n", "target": "String dog = \"Benjamin\"; \nString Dog = \"Samba\";    \nString DOG = \"Bernie\";   \n@Inject Console console;\nconsole.print($\"There are three dogs named {dog}, {Dog}, and {DOG}\");\n"}
{"id": 338182, "name": "Extra primes", "source": "Translate Swift to Java: import Foundation\n\nlet wheel = [4,2,4,2,4,6,2,6]\n\nfunc isPrime(_ number: Int) -> Bool {\n    if number < 2 {\n        return false\n    }\n    if number % 2 == 0 {\n        return number == 2\n    }\n    if number % 3 == 0 {\n        return number == 3\n    }\n    if number % 5 == 0 {\n        return number == 5\n    }\n    var p = 7\n    while true {\n        for w in wheel {\n            if p * p > number {\n                return true\n            }\n            if number % p == 0 {\n                return false\n            }\n            p += w\n        }\n    }\n}\n\nfunc nextPrimeDigitNumber(_ number: Int) -> Int {\n    if number == 0 {\n        return 2\n    }\n    switch number % 10 {\n    case 2:\n        return number + 1\n    case 3, 5:\n        return number + 2\n    default:\n        return 2 + nextPrimeDigitNumber(number/10) * 10\n    }\n}\n\nfunc digitSum(_ num: Int) -> Int {\n    var sum = 0\n    var n = num\n    while n > 0 {\n        sum += n % 10\n        n /= 10\n    }\n    return sum\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize(_ number: Int) -> String {\n    let n = NSNumber(value: number)\n    return NumberFormatter.localizedString(from: n, number: .decimal)\n}\n\nlet limit1 = 10000\nlet limit2 = 1000000000\nlet last = 10\nvar p = nextPrimeDigitNumber(0)\nvar n = 0\n\nprint(\"Extra primes less than \\(commatize(limit1)):\")\nwhile p < limit1 {\n    if isPrime(digitSum(p)) && isPrime(p) {\n        n += 1\n        print(pad(string: commatize(p), width: 5),\n              terminator: n % 10 == 0 ? \"\\n\" : \" \")\n    }\n    p = nextPrimeDigitNumber(p)\n}\n\nprint(\"\\n\\nLast \\(last) extra primes less than \\(commatize(limit2)):\")\n\nvar extraPrimes = Array(repeating: 0, count: last)\nwhile p < limit2 {\n    if isPrime(digitSum(p)) && isPrime(p) {\n        n += 1\n        extraPrimes[n % last] = p\n    }\n    p = nextPrimeDigitNumber(p)\n}\n\nfor i in stride(from: last - 1, through: 0, by: -1) {\n    print(\"\\(commatize(n - i)): \\(commatize(extraPrimes[(n - i) % last]))\")\n}\n", "target": "public class ExtraPrimes {\n    private static int nextPrimeDigitNumber(int n) {\n        if (n == 0) {\n            return 2;\n        }\n        switch (n % 10) {\n            case 2:\n                return n + 1;\n            case 3:\n            case 5:\n                return n + 2;\n            default:\n                return 2 + nextPrimeDigitNumber(n / 10) * 10;\n        }\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if ((n & 1) == 0) {\n            return n == 2;\n        }\n        if (n % 3 == 0) {\n            return n == 3;\n        }\n        if (n % 5 == 0) {\n            return n == 5;\n        }\n\n        int[] wheel = new int[]{4, 2, 4, 2, 4, 6, 2, 6};\n        int p = 7;\n        while (true) {\n            for (int w : wheel) {\n                if (p * p > n) {\n                    return true;\n                }\n                if (n % p == 0) {\n                    return false;\n                }\n                p += w;\n            }\n        }\n    }\n\n    private static int digitSum(int n) {\n        int sum = 0;\n        for (; n > 0; n /= 10) {\n            sum += n % 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 10_000;\n        int p = 0, n = 0;\n\n        System.out.printf(\"Extra primes under %d:\\n\", limit);\n        while (p < limit) {\n            p = nextPrimeDigitNumber(p);\n            if (isPrime(p) && isPrime(digitSum(p))) {\n                n++;\n                System.out.printf(\"%2d: %d\\n\", n, p);\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 338183, "name": "Extra primes", "source": "Translate Swift to Java: import Foundation\n\nlet wheel = [4,2,4,2,4,6,2,6]\n\nfunc isPrime(_ number: Int) -> Bool {\n    if number < 2 {\n        return false\n    }\n    if number % 2 == 0 {\n        return number == 2\n    }\n    if number % 3 == 0 {\n        return number == 3\n    }\n    if number % 5 == 0 {\n        return number == 5\n    }\n    var p = 7\n    while true {\n        for w in wheel {\n            if p * p > number {\n                return true\n            }\n            if number % p == 0 {\n                return false\n            }\n            p += w\n        }\n    }\n}\n\nfunc nextPrimeDigitNumber(_ number: Int) -> Int {\n    if number == 0 {\n        return 2\n    }\n    switch number % 10 {\n    case 2:\n        return number + 1\n    case 3, 5:\n        return number + 2\n    default:\n        return 2 + nextPrimeDigitNumber(number/10) * 10\n    }\n}\n\nfunc digitSum(_ num: Int) -> Int {\n    var sum = 0\n    var n = num\n    while n > 0 {\n        sum += n % 10\n        n /= 10\n    }\n    return sum\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize(_ number: Int) -> String {\n    let n = NSNumber(value: number)\n    return NumberFormatter.localizedString(from: n, number: .decimal)\n}\n\nlet limit1 = 10000\nlet limit2 = 1000000000\nlet last = 10\nvar p = nextPrimeDigitNumber(0)\nvar n = 0\n\nprint(\"Extra primes less than \\(commatize(limit1)):\")\nwhile p < limit1 {\n    if isPrime(digitSum(p)) && isPrime(p) {\n        n += 1\n        print(pad(string: commatize(p), width: 5),\n              terminator: n % 10 == 0 ? \"\\n\" : \" \")\n    }\n    p = nextPrimeDigitNumber(p)\n}\n\nprint(\"\\n\\nLast \\(last) extra primes less than \\(commatize(limit2)):\")\n\nvar extraPrimes = Array(repeating: 0, count: last)\nwhile p < limit2 {\n    if isPrime(digitSum(p)) && isPrime(p) {\n        n += 1\n        extraPrimes[n % last] = p\n    }\n    p = nextPrimeDigitNumber(p)\n}\n\nfor i in stride(from: last - 1, through: 0, by: -1) {\n    print(\"\\(commatize(n - i)): \\(commatize(extraPrimes[(n - i) % last]))\")\n}\n", "target": "public class ExtraPrimes {\n    private static int nextPrimeDigitNumber(int n) {\n        if (n == 0) {\n            return 2;\n        }\n        switch (n % 10) {\n            case 2:\n                return n + 1;\n            case 3:\n            case 5:\n                return n + 2;\n            default:\n                return 2 + nextPrimeDigitNumber(n / 10) * 10;\n        }\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if ((n & 1) == 0) {\n            return n == 2;\n        }\n        if (n % 3 == 0) {\n            return n == 3;\n        }\n        if (n % 5 == 0) {\n            return n == 5;\n        }\n\n        int[] wheel = new int[]{4, 2, 4, 2, 4, 6, 2, 6};\n        int p = 7;\n        while (true) {\n            for (int w : wheel) {\n                if (p * p > n) {\n                    return true;\n                }\n                if (n % p == 0) {\n                    return false;\n                }\n                p += w;\n            }\n        }\n    }\n\n    private static int digitSum(int n) {\n        int sum = 0;\n        for (; n > 0; n /= 10) {\n            sum += n % 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 10_000;\n        int p = 0, n = 0;\n\n        System.out.printf(\"Extra primes under %d:\\n\", limit);\n        while (p < limit) {\n            p = nextPrimeDigitNumber(p);\n            if (isPrime(p) && isPrime(digitSum(p))) {\n                n++;\n                System.out.printf(\"%2d: %d\\n\", n, p);\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 338184, "name": "Sorting algorithms_Stooge sort", "source": "Translate Swift to Java: func stoogeSort(inout arr:[Int], _ i:Int = 0, var _ j:Int = -1) {\n    if j == -1 {\n        j = arr.count - 1\n    }\n    \n    if arr[i] > arr[j] {\n        swap(&arr[i], &arr[j])\n    }\n    \n    if j - i > 1 {\n        let t = (j - i + 1) / 3\n        stoogeSort(&arr, i, j - t)\n        stoogeSort(&arr, i + t, j)\n        stoogeSort(&arr, i, j - t)\n    }\n}\n\nvar a = [-4, 2, 5, 2, 3, -2, 1, 100, 20]\n\nstoogeSort(&a)\n\nprintln(a)\n", "target": "import java.util.Arrays;\n\npublic class Stooge {\n    public static void main(String[] args) {\n        int[] nums = {1, 4, 5, 3, -6, 3, 7, 10, -2, -5};\n        stoogeSort(nums);\n        System.out.println(Arrays.toString(nums));\n    }\n\n    public static void stoogeSort(int[] L) {\n        stoogeSort(L, 0, L.length - 1);\n    }\n\n    public static void stoogeSort(int[] L, int i, int j) {\n        if (L[j] < L[i]) {\n            int tmp = L[i];\n            L[i] = L[j];\n            L[j] = tmp;\n        }\n        if (j - i > 1) {\n            int t = (j - i + 1) / 3;\n            stoogeSort(L, i, j - t);\n            stoogeSort(L, i + t, j);\n            stoogeSort(L, i, j - t);\n        }\n    }\n}\n"}
{"id": 338185, "name": "Sorting algorithms_Shell sort", "source": "Translate Swift to Java: func shellsort<T where T : Comparable>(inout seq: [T]) {\n    var inc = seq.count / 2\n    while inc > 0 {\n        for (var i, el) in EnumerateSequence(seq) {\n            while i >= inc && seq[i - inc] > el {\n                seq[i] = seq[i - inc]\n                i -= inc\n            }\n            seq[i] = el\n        }\n        if inc == 2 {\n            inc = 1\n        } else {\n            inc = inc * 5 / 11\n        }\n    }\n}\n", "target": "public static void shell(int[] a) {\n\tint increment = a.length / 2;\n\twhile (increment > 0) {\n\t\tfor (int i = increment; i < a.length; i++) {\n\t\t\tint j = i;\n\t\t\tint temp = a[i];\n\t\t\twhile (j >= increment && a[j - increment] > temp) {\n\t\t\t\ta[j] = a[j - increment];\n\t\t\t\tj = j - increment;\n\t\t\t}\n\t\t\ta[j] = temp;\n\t\t}\n\t\tif (increment == 2) {\n\t\t\tincrement = 1;\n\t\t} else {\n\t\t\tincrement *= (5.0 / 11);\n\t\t}\n\t}\n}\n"}
{"id": 338186, "name": "Deconvolution_1D", "source": "Translate Swift to Java: func deconv(g: [Double], f: [Double]) -> [Double] {\n  let fs = f.count\n  var ret = [Double](repeating: 0, count: g.count - fs + 1)\n\n  for n in 0..<ret.count {\n    ret[n] = g[n]\n    let lower = n >= fs ? n - fs + 1 : 0\n\n    for i in lower..<n {\n      ret[n] -= ret[i] * f[n - i]\n    }\n\n    ret[n] /= f[0]\n  }\n\n  return ret\n}\n\nlet h = [-8.0, -9.0, -3.0, -1.0, -6.0, 7.0]\nlet f = [-3.0, -6.0, -1.0,  8.0, -6.0,  3.0, -1.0, -9.0,\n         -9.0,  3.0, -2.0,  5.0,  2.0, -2.0, -7.0, -1.0]\nlet g = [24.0,  75.0, 71.0, -34.0,  3.0,  22.0, -45.0,\n         23.0, 245.0, 25.0,  52.0, 25.0, -67.0, -96.0,\n         96.0,  31.0, 55.0,  36.0, 29.0, -43.0,  -7.0]\n\nprint(\"\\(h.map({ Int($0) }))\")\nprint(\"\\(deconv(g: g, f: f).map({ Int($0) }))\\n\")\n\n\nprint(\"\\(f.map({ Int($0) }))\")\nprint(\"\\(deconv(g: g, f: h).map({ Int($0) }))\")\n", "target": "import java.util.Arrays;\n\npublic class Deconvolution1D {\n    public static int[] deconv(int[] g, int[] f) {\n        int[] h = new int[g.length - f.length + 1];\n        for (int n = 0; n < h.length; n++) {\n            h[n] = g[n];\n            int lower = Math.max(n - f.length + 1, 0);\n            for (int i = lower; i < n; i++)\n                h[n] -= h[i] * f[n - i];\n            h[n] /= f[0];\n        }\n        return h;\n    }\n\n    public static void main(String[] args) {\n        int[] h = { -8, -9, -3, -1, -6, 7 };\n        int[] f = { -3, -6, -1, 8, -6, 3, -1, -9, -9, 3, -2, 5, 2, -2, -7, -1 };\n        int[] g = { 24, 75, 71, -34, 3, 22, -45, 23, 245, 25, 52, 25, -67, -96,\n                96, 31, 55, 36, 29, -43, -7 };\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"h = \" + Arrays.toString(h) + \"\\n\");\n        sb.append(\"deconv(g, f) = \" + Arrays.toString(deconv(g, f)) + \"\\n\");\n        sb.append(\"f = \" + Arrays.toString(f) + \"\\n\");\n        sb.append(\"deconv(g, h) = \" + Arrays.toString(deconv(g, h)) + \"\\n\");\n        System.out.println(sb.toString());\n    }\n}\n"}
{"id": 338187, "name": "Optional parameters", "source": "Translate Swift to Java: enum SortOrder { case kOrdNone, kOrdLex, kOrdByAddress, kOrdNumeric }\n\nfunc sortTable(table: [[String]], less: (String,String)->Bool = (<), column: Int = 0, reversed: Bool = false) {\n  \n}\n", "target": "module OptionalParameters\n    {\n    typedef Type<String  >.Orderer as ColumnOrderer;\n    typedef Type<String[]>.Orderer as RowOrderer;\n\n    static String[][] sort(String[][]     table,\n                           ColumnOrderer? orderer = Null,\n                           Int            column  = 0,\n                           Boolean        reverse = False,\n                          )\n        {\n        \n        orderer ?:= (s1, s2) -> s1 <=> s2;\n\n        \n        ColumnOrderer byString = reverse\n                ? ((s1, s2) -> orderer(s1, s2).reversed)\n                : orderer;\n\n        \n        RowOrderer byColumn = (row1, row2) -> byString(row1[column], row2[column]);\n\n        return table.sorted(byColumn);\n        }\n\n    void run()\n        {\n        String[][] table =\n            [\n            [\"c\", \"x\", \"i\"],\n            [\"a\", \"y\", \"p\"],\n            [\"b\", \"z\", \"a\"],\n            ];\n\n        show(\"original input\", table);\n        show(\"by default sort on column 0\", sort(table));\n        show(\"by column 2\", sort(table, column=2));\n        show(\"by column 2 reversed\", sort(table, column=2, reverse=True));\n        }\n\n    void show(String title, String[][] table)\n        {\n        @Inject Console console;\n        console.print($\"{title}:\");\n        for (val row : table)\n            {\n            console.print($\"  {row}\");\n            }\n        console.print();\n        }\n    }\n"}
{"id": 341659, "name": "Long year", "source": "Translate Swift to C#: func isLongYear(_ year: Int) -> Bool {\n  let year1 = year - 1\n  let p = (year + (year / 4) - (year / 100) + (year / 400)) % 7\n  let p1 = (year1 + (year1 / 4) - (year1 / 100) + (year1 / 400)) % 7\n\n  return p == 4 || p1 == 3\n}\n\nfor range in [1900...1999, 2000...2099, 2100...2199] {\n  print(\"\\(range): \\(range.filter(isLongYear))\")\n}\n", "target": "using static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Globalization;\n\npublic static class Program\n{\n    public static void Main()\n    {\n        WriteLine(\"Long years in the 21st century:\");\n        WriteLine(string.Join(\" \", 2000.To(2100).Where(y => ISOWeek.GetWeeksInYear(y) == 53)));\n    }\n    \n    public static IEnumerable<int> To(this int start, int end) {\n        for (int i = start; i < end; i++) yield return i;\n    }\n    \n}\n"}
{"id": 341660, "name": "Water collected between towers", "source": "Translate Swift to C#: \n\n\nfunc waterCollected(_ heights: [Int]) -> Int {\n    guard heights.count > 0 else {\n        return 0\n    }\n    var water = 0\n    var left = 0, right = heights.count - 1\n    var maxLeft = heights[left], maxRight = heights[right]\n    \n    while left < right {\n        if heights[left] <= heights[right] {\n            maxLeft = max(heights[left], maxLeft)\n            water += maxLeft - heights[left]\n            left += 1\n        } else {\n            maxRight = max(heights[right], maxRight)\n            water += maxRight - heights[right]\n            right -= 1\n        }\n    }\n    return water\n}\n\nfor heights in [[1, 5, 3, 7, 2],\n                [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],\n                [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],\n                [5, 5, 5, 5],\n                [5, 6, 7, 8],\n                [8, 7, 7, 6],\n                [6, 7, 10, 7, 6]] {\n    print(\"water collected = \\(waterCollected(heights))\")\n}\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        int[][] wta = {\n            new int[] {1, 5, 3, 7, 2},   new int[] { 5, 3, 7, 2, 6, 4, 5, 9, 1, 2 },\n            new int[] { 2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1 },\n            new int[] { 5, 5, 5, 5 },    new int[] { 5, 6, 7, 8 },\n            new int[] { 8, 7, 7, 6 },    new int[] { 6, 7, 10, 7, 6 }};\n        string blk, lf = \"\\n\", tb = \"\u2588\u2588\", wr = \"\u2248\u2248\", mt = \"  \";\n        for (int i = 0; i < wta.Length; i++)\n        {\n            int bpf; blk = \"\"; do\n            {\n                string floor = \"\"; bpf = 0; for (int j = 0; j < wta[i].Length; j++)\n                {\n                    if (wta[i][j] > 0)\n                    {    floor += tb; wta[i][j] -= 1; bpf += 1; }\n                    else floor += (j > 0 && j < wta[i].Length - 1 ? wr : mt);\n                }\n                if (bpf > 0) blk = floor + lf + blk;\n            } while (bpf > 0);\n            while (blk.Contains(mt + wr)) blk = blk.Replace(mt + wr, mt + mt);\n            while (blk.Contains(wr + mt)) blk = blk.Replace(wr + mt, mt + mt);\n            if (args.Length > 0) System.Console.Write(\"\\n{0}\", blk);\n            System.Console.WriteLine(\"Block {0} retains {1,2} water units.\",\n                i + 1, (blk.Length - blk.Replace(wr, \"\").Length) / 2);\n        }\n    }\n}\n"}
{"id": 341661, "name": "Orbital elements", "source": "Translate Swift to C#: import Foundation\n\npublic struct Vector {\n  public var x = 0.0\n  public var y = 0.0\n  public var z = 0.0\n\n  public init(x: Double, y: Double, z: Double) {\n    (self.x, self.y, self.z) = (x, y, z)\n  }\n\n  public func mod() -> Double {\n    (x * x + y * y + z * z).squareRoot()\n  }\n\n  public static func + (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      x: lhs.x + rhs.x,\n      y: lhs.y + rhs.y,\n      z: lhs.z + rhs.z\n    )\n  }\n\n  public static func * (lhs: Vector, rhs: Double) -> Vector {\n    return Vector(\n      x: lhs.x * rhs,\n      y: lhs.y * rhs,\n      z: lhs.z * rhs\n    )\n  }\n\n  public static func *= (lhs: inout Vector, rhs: Double) {\n    lhs.x *= rhs\n    lhs.y *= rhs\n    lhs.z *= rhs\n  }\n\n  public static func / (lhs: Vector, rhs: Double) -> Vector {\n    return lhs * (1 / rhs)\n  }\n\n  public static func /= (lhs: inout Vector, rhs: Double) {\n    lhs = lhs * (1 / rhs)\n  }\n}\n\nextension Vector: CustomStringConvertible {\n  public var description: String {\n    return String(format: \"%.6f\\t%.6f\\t%.6f\", x, y, z)\n  }\n}\n\nprivate func mulAdd(v1: Vector, x1: Double, v2: Vector, x2: Double) -> Vector {\n  return v1 * x1 + v2 * x2\n}\n\nprivate func rotate(_ i: Vector, _ j: Vector, alpha: Double) -> (Vector, Vector) {\n  return (\n    mulAdd(v1: i, x1: +cos(alpha), v2: j, x2: sin(alpha)),\n    mulAdd(v1: i, x1: -sin(alpha), v2: j, x2: cos(alpha))\n  )\n}\n\npublic func orbitalStateVectors(\n  semimajorAxis: Double,\n  eccentricity: Double,\n  inclination: Double,\n  longitudeOfAscendingNode: Double,\n  argumentOfPeriapsis: Double,\n  trueAnomaly: Double\n) -> (Vector, Vector) {\n  var i = Vector(x: 1.0, y: 0.0, z: 0.0)\n  var j = Vector(x: 0.0, y: 1.0, z: 0.0)\n  let k = Vector(x: 0.0, y: 0.0, z: 1.0)\n\n  (i, j) = rotate(i, j, alpha: longitudeOfAscendingNode)\n  (j, _) = rotate(j, k, alpha: inclination)\n  (i, j) = rotate(i, j, alpha: argumentOfPeriapsis)\n\n  let l = eccentricity == 1.0 ? 2.0 : 1.0 - eccentricity * eccentricity\n  let c = cos(trueAnomaly)\n  let s = sin(trueAnomaly)\n  let r = l / (1.0 + eccentricity * c)\n  let rPrime = s * r * r / l\n  let position = mulAdd(v1: i, x1: c, v2: j, x2: s) * r\n  var speed = mulAdd(v1: i, x1: rPrime * c - r * s, v2: j, x2: rPrime * s + r * c)\n\n  speed /= speed.mod()\n  speed *= (2.0 / r - 1.0 / semimajorAxis).squareRoot()\n\n  return (position, speed)\n}\n\nlet (position, speed) = orbitalStateVectors(\n  semimajorAxis: 1.0,\n  eccentricity: 0.1,\n  inclination: 0.0,\n  longitudeOfAscendingNode: 355.0 / (113.0 * 6.0),\n  argumentOfPeriapsis: 0.0,\n  trueAnomaly: 0.0\n)\n\nprint(\"Position: \\(position); Speed: \\(speed)\")\n", "target": "using System;\n\nnamespace OrbitalElements {\n    class Vector {\n        public Vector(double x, double y, double z) {\n            X = x;\n            Y = y;\n            Z = z;\n        }\n\n        public double X { get; set; }\n        public double Y { get; set; }\n        public double Z { get; set; }\n\n        public double Abs() {\n            return Math.Sqrt(X * X + Y * Y + Z * Z);\n        }\n\n        public static Vector operator +(Vector lhs, Vector rhs) {\n            return new Vector(lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z);\n        }\n\n        public static Vector operator *(Vector self, double m) {\n            return new Vector(self.X * m, self.Y * m, self.Z * m);\n        }\n\n        public static Vector operator /(Vector self, double m) {\n            return new Vector(self.X / m, self.Y / m, self.Z / m);\n        }\n\n        public override string ToString() {\n            return string.Format(\"({0}, {1}, {2})\", X, Y, Z);\n        }\n    }\n\n    class Program {\n        static Tuple<Vector, Vector> OrbitalStateVectors(\n            double semiMajorAxis,\n            double eccentricity,\n            double inclination,\n            double longitudeOfAscendingNode,\n            double argumentOfPeriapsis,\n            double trueAnomaly\n        ) {\n            Vector mulAdd(Vector v1, double x1, Vector v2, double x2) {\n                return v1 * x1 + v2 * x2;\n            }\n\n            Tuple<Vector, Vector> rotate(Vector iv, Vector jv, double alpha) {\n                return new Tuple<Vector, Vector>(\n                    mulAdd(iv, +Math.Cos(alpha), jv, Math.Sin(alpha)),\n                    mulAdd(iv, -Math.Sin(alpha), jv, Math.Cos(alpha))\n                );\n            }\n\n            var i = new Vector(1, 0, 0);\n            var j = new Vector(0, 1, 0);\n            var k = new Vector(0, 0, 1);\n\n            var p = rotate(i, j, longitudeOfAscendingNode);\n            i = p.Item1; j = p.Item2;\n            p = rotate(j, k, inclination);\n            j = p.Item1;\n            p = rotate(i, j, argumentOfPeriapsis);\n            i = p.Item1; j = p.Item2;\n\n            var l = semiMajorAxis * ((eccentricity == 1.0) ? 2.0 : (1.0 - eccentricity * eccentricity));\n            var c = Math.Cos(trueAnomaly);\n            var s = Math.Sin(trueAnomaly);\n            var r = l / (1.0 + eccentricity * c);\n            var rprime = s * r * r / l;\n            var position = mulAdd(i, c, j, s) * r;\n            var speed = mulAdd(i, rprime * c - r * s, j, rprime * s + r * c);\n            speed /= speed.Abs();\n            speed *= Math.Sqrt(2.0 / r - 1.0 / semiMajorAxis);\n\n            return new Tuple<Vector, Vector>(position, speed);\n        }\n\n        static void Main(string[] args) {\n            var res = OrbitalStateVectors(1.0, 0.1, 0.0, 355.0 / (113.0 * 6.0), 0.0, 0.0);\n            Console.WriteLine(\"Position\u00a0: {0}\", res.Item1);\n            Console.WriteLine(\"Speed   \u00a0: {0}\", res.Item2);\n        }\n    }\n}\n"}
{"id": 341662, "name": "ABC words", "source": "Translate Swift to C#: import Foundation\n\nfunc loadDictionary(_ path: String) throws -> [String] {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return contents.components(separatedBy: \"\\n\")\n}\n\nfunc isAbcWord(_ word: String) -> Bool {\n    var a = false\n    var b = false\n    for ch in word {\n        switch (ch) {\n        case \"a\":\n            if !a {\n                a = true\n            }\n        case \"b\":\n            if !b {\n                if !a {\n                    return false\n                }\n                b = true\n            }\n        case \"c\":\n            return b\n        default:\n            break\n        }\n    }\n    return false\n}\n\ndo {\n    let dictionary = try loadDictionary(\"unixdict.txt\")\n    var n = 1\n    for word in dictionary {\n        if isAbcWord(word) {\n            print(\"\\(n): \\(word)\")\n            n += 1\n        }\n    }\n} catch {\n    print(error)\n}\n", "target": "class Program {\n    static void Main(string[] args) { int bi, i = 0; string chars = args.Length < 1 ? \"abc\" : args[0];\n        foreach (var item in System.IO.File.ReadAllLines(\"unixdict.txt\")) {\n            int ai = -1; foreach (var ch in chars)\n                if ((bi = item.IndexOf(ch)) > ai) ai = bi; else goto skip;\n            System.Console.Write(\"{0,3} {1,-18} {2}\", ++i, item, i % 5 == 0 ? \"\\n\" : \"\");\n        skip: ; } }\n}\n"}
{"id": 341663, "name": "Text between", "source": "Translate Swift to C#: import Foundation\n\npublic extension String {\n  func textBetween(_ startDelim: String, and endDelim: String) -> String {\n    precondition(!startDelim.isEmpty && !endDelim.isEmpty)\n\n    let startIdx: String.Index\n    let endIdx: String.Index\n\n    if startDelim == \"start\" {\n      startIdx = startIndex\n    } else if let r = range(of: startDelim) {\n      startIdx = r.upperBound\n    } else {\n      return \"\"\n    }\n\n    if endDelim == \"end\" {\n      endIdx = endIndex\n    } else if let r = self[startIdx...].range(of: endDelim) {\n      endIdx = r.lowerBound\n    } else {\n      endIdx = endIndex\n    }\n\n    return String(self[startIdx..<endIdx])\n  }\n}\n\nlet tests = [\n  (\"Hello Rosetta Code world\", \"Hello \", \" world\"),\n  (\"Hello Rosetta Code world\", \"start\", \" world\"),\n  (\"Hello Rosetta Code world\", \"Hello \", \"end\"),\n  (\"</div><div style=\\\"chinese\\\">\u4f60\u597d\u55ce</div>\", \"<div style=\\\"chinese\\\">\", \"</div>\"),\n  (\"<text>Hello <span>Rosetta Code</span> world</text><table style=\\\"myTable\\\">\", \"<text>\", \"<table>\"),\n  (\"<table style=\\\"myTable\\\"><tr><td>hello world</td></tr></table>\", \"<table>\", \"</table>\"),\n  (\"The quick brown fox jumps over the lazy other fox\", \"quick \", \" fox\"),\n  (\"One fish two fish red fish blue fish\", \"fish \", \" red\"),\n  (\"FooBarBazFooBuxQuux\", \"Foo\", \"Foo\")\n]\n\nfor (input, start, end) in tests {\n  print(\"Input: \\\"\\(input)\\\"\")\n  print(\"Start delimiter: \\\"\\(start)\\\"\")\n  print(\"End delimiter: \\\"\\(end)\\\"\")\n  print(\"Text between: \\\"\\(input.textBetween(start, and: end))\\\"\\n\")\n}\n", "target": "using System;\n\nnamespace TextBetween {\n    class Program {\n        static string TextBetween(string source, string beg, string end) {\n            int startIndex;\n\n            if (beg == \"start\") {\n                startIndex = 0;\n            }\n            else {\n                startIndex = source.IndexOf(beg);\n                if (startIndex < 0) {\n                    return \"\";\n                }\n                startIndex += beg.Length;\n            }\n\n            int endIndex = source.IndexOf(end, startIndex);\n            if (endIndex < 0 || end == \"end\") {\n                return source.Substring(startIndex);\n            }\n            return source.Substring(startIndex, endIndex - startIndex);\n        }\n\n        static void Print(string s, string b, string e) {\n            Console.WriteLine(\"text: '{0}'\", s);\n            Console.WriteLine(\"start: '{0}'\", b);\n            Console.WriteLine(\"end: '{0}'\", e);\n            Console.WriteLine(\"result: '{0}'\", TextBetween(s, b, e));\n            Console.WriteLine();\n        }\n\n        static void Main(string[] args) {\n            Print(\"Hello Rosetta Code world\", \"Hello \", \" world\");\n            Print(\"Hello Rosetta Code world\", \"start\", \" world\");\n            Print(\"Hello Rosetta Code world\", \"Hello \", \"end\");\n            Print(\"</div><div style=\\\"chinese\\\">\u4f60\u597d\u55ce</div>\", \"<div style=\\\"chinese\\\">\", \"</div>\");\n            Print(\"<text>Hello <span>Rosetta Code</span> world</text><table style=\\\"myTable\\\">\", \"<text>\", \"<table>\");\n            Print(\"<table style=\\\"myTable\\\"><tr><td>hello world</td></tr></table>\", \"<table>\", \"</table>\");\n            Print(\"The quick brown fox jumps over the lazy other fox\", \"quick \", \" fox\");\n            Print(\"One fish two fish red fish blue fish\", \"fish \", \" red\");\n            Print(\"FooBarBazFooBuxQuux\", \"Foo\", \"Foo\");\n        }\n    }\n}\n"}
{"id": 341664, "name": "Two identical strings", "source": "Translate Swift to C#: print(\"Decimal\\tBinary\")\nvar n = 1\nwhile (true) {\n    let binary = String(n, radix: 2)\n    let i = n + (n << binary.count)\n    if i >= 1000 {\n        break\n    }\n    print(\"\\(i)\\t\\(binary)\\(binary)\")\n    n += 1\n}\n", "target": "using System; using static System.Console;\nclass Program { static void Main() { int c = 0, lmt = 1000;\n    for (int n = 1, p = 2, k; n <= lmt; n++)\n      if ((k = n + n * (p += n >= p ? p : 0)) > lmt) break;\n      else Console.Write(\"{0,3} ({1,-10})  {2}\", k,\n          Convert.ToString(k, 2), ++c % 5 == 0 ? \"\\n\" : \"\");\n    Write(\"\\nFound {0} numbers whose base 2 representation is the \" +\n      \"concatenation of two identical binary strings.\", c); } }\n"}
{"id": 341665, "name": "Address of a variable", "source": "Translate Swift to C#: class MyClass { }\n\nfunc printAddress<T>(of pointer: UnsafePointer<T>) {\n    print(pointer)\n}\n\nfunc test() {\n    var x = 42\n    var y = 3.14\n    var z = \"foo\"\n    var obj = MyClass()\n\n    \n    withUnsafePointer(to: &x)   { print($0) }\n    withUnsafePointer(to: &y)   { print($0) }\n    withUnsafePointer(to: &z)   { print($0) }\n    withUnsafePointer(to: &obj) { print($0) }\n\n    \n    printAddress(of: &x)\n    printAddress(of: &y)\n    printAddress(of: &z)\n    printAddress(of: &obj)\n\n    \n    print(Unmanaged.passUnretained(obj).toOpaque())\n}\n\ntest()\n", "target": "int i = 5;\nint* p = &i;\n"}
{"id": 341666, "name": "Function definition", "source": "Translate Swift to C#: func multiply(a: Double, b: Double) -> Double {\n   return a * b\n}\n", "target": "static double multiply(double a, double b)\n{\n    return a * b;\n}\n"}
{"id": 341667, "name": "Sattolo cycle", "source": "Translate Swift to C#: extension Array {\n  public mutating func satalloShuffle() {\n    for i in stride(from: index(before: endIndex), through: 1, by: -1) {\n      swapAt(i, .random(in: 0..<i))\n    }\n  }\n\n  public func satalloShuffled() -> [Element] {\n    var arr = Array(self)\n\n    arr.satalloShuffle()\n\n    return arr\n  }\n}\n\nlet testCases = [\n  [],\n  [10, 20],\n  [10, 20, 30],\n  [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n]\n\nfor testCase in testCases {\n  let shuffled = testCase.satalloShuffled()\n\n  guard zip(testCase, shuffled).allSatisfy(!=) else {\n    fatalError(\"satallo shuffle failed\")\n  }\n\n  print(\"\\(testCase) shuffled = \\(shuffled)\")\n}\n", "target": "private static readonly Random Rand = new Random();\n\nvoid sattoloCycle<T>(IList<T> items) {\n    for (var i = items.Count; i-- > 1;) {\n        int j = Rand.Next(i);\n        var tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n"}
{"id": 341668, "name": "Sattolo cycle", "source": "Translate Swift to C#: extension Array {\n  public mutating func satalloShuffle() {\n    for i in stride(from: index(before: endIndex), through: 1, by: -1) {\n      swapAt(i, .random(in: 0..<i))\n    }\n  }\n\n  public func satalloShuffled() -> [Element] {\n    var arr = Array(self)\n\n    arr.satalloShuffle()\n\n    return arr\n  }\n}\n\nlet testCases = [\n  [],\n  [10, 20],\n  [10, 20, 30],\n  [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n]\n\nfor testCase in testCases {\n  let shuffled = testCase.satalloShuffled()\n\n  guard zip(testCase, shuffled).allSatisfy(!=) else {\n    fatalError(\"satallo shuffle failed\")\n  }\n\n  print(\"\\(testCase) shuffled = \\(shuffled)\")\n}\n", "target": "private static readonly Random Rand = new Random();\n\nvoid sattoloCycle<T>(IList<T> items) {\n    for (var i = items.Count; i-- > 1;) {\n        int j = Rand.Next(i);\n        var tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n"}
{"id": 341669, "name": "Y combinator", "source": "Translate Swift to C#: struct RecursiveFunc<F> {\n  let o : RecursiveFunc<F> -> F\n}\n\nfunc Y<A, B>(f: (A -> B) -> A -> B) -> A -> B {\n  let r = RecursiveFunc<A -> B> { w in f { w.o(w)($0) } }\n  return r.o(r)\n}\n\nlet fac = Y { (f: Int -> Int) in\n  { $0 <= 1 ? 1 : $0 * f($0-1) }\n}\nlet fib = Y { (f: Int -> Int) in\n  { $0 <= 2 ? 1 : f($0-1)+f($0-2) }\n}\nprintln(\"fac(5) = \\(fac(5))\")\nprintln(\"fib(9) = \\(fib(9))\")\n", "target": "using System;\n\nstatic class YCombinator<T, TResult>\n{\n    \n    private delegate Func<T, TResult> RecursiveFunc(RecursiveFunc r);\n\n    public static Func<Func<Func<T, TResult>, Func<T, TResult>>, Func<T, TResult>> Fix { get; } =\n        f => ((RecursiveFunc)(g => f(x => g(g)(x))))(g => f(x => g(g)(x)));\n}\n\nstatic class Program\n{\n    static void Main()\n    {\n        var fac = YCombinator<int, int>.Fix(f => x => x < 2 ? 1 : x * f(x - 1));\n        var fib = YCombinator<int, int>.Fix(f => x => x < 2 ? x : f(x - 1) + f(x - 2));\n\n        Console.WriteLine(fac(10));\n        Console.WriteLine(fib(10));\n    }\n}\n"}
{"id": 341670, "name": "Playing cards", "source": "Translate Swift to C#: struct Card: CustomStringConvertible\n{\n\tenum Suit: String, CaseIterable, CustomStringConvertible\n\t{\n\t\tcase clubs = \"\u2663\ufe0f\"\n\t\tcase diamonds = \"\u2666\ufe0f\"\n\t\tcase hearts = \"\u2665\ufe0f\"\n\t\tcase spades = \"\u2660\ufe0f\"\n\n\t\tvar description: String { rawValue }\n\t}\n\n\tlet suit: Suit\n\tlet value: Int\n\n\tvar description: String\n\t{\n\t\tlet valueAsString: String\n\t\tswitch value\n\t\t{\n\t\tcase 1:\n\t\t\tvalueAsString = \"A\"\n\t\tcase 11:\n\t\t\tvalueAsString = \"J\"\n\t\tcase 12:\n\t\t\tvalueAsString = \"Q\"\n\t\tcase 13:\n\t\t\tvalueAsString = \"K\"\n\t\tdefault:\n\t\t\tvalueAsString = \"\\(value)\"\n\t\t}\n\t\treturn valueAsString + suit.description\n\t}\n}\n\nstruct Deck: CustomStringConvertible\n{\n\tvar cards: [Card] = []\n\n\tinit()\n\t{\n\t\tfor suit in Card.Suit.allCases\n\t\t{\n\t\t\tfor faceValue in 1 ... 13\n\t\t\t{\n\t\t\t\tcards.append(Card(suit: suit, value: faceValue))\n\t\t\t}\n\t\t}\n\t}\n\n\tvar description: String\n\t{\n\t\tString(cards.map{ $0.description }.joined(separator: \", \"))\n\t}\n\n\tmutating func shuffle()\n\t{\n\t\tcards.shuffle()\n\t}\n\n\tmutating func dealCard() -> Card?\n\t{\n\t\tguard !cards.isEmpty else { return nil }\n\t\treturn cards.removeLast()\n\t}\n}\n\nvar deck = Deck()\nprint(\"New deck:\")\nprint(deck)\ndeck.shuffle()\nprint(\"Shuffled deck:\")\nprint(deck)\n\nvar hands: [[Card]] = [[], [], [], []]\n\nvar handIndex = 0\n\nwhile let card = deck.dealCard()\n{\n\thands[handIndex].append(card)\n\thandIndex = (handIndex + 1) % hands.count\n}\n\nprint (\"Hands:\")\nprint(hands.map({ $0.description }).joined(separator: \"\\n\"))\nprint(\"Remaining deck (should be empty):\")\nprint(deck)\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic struct Card\n{\n    public Card(string rank, string suit) : this()\n    {\n        Rank = rank;\n        Suit = suit;\n    }\n\n    public string Rank { get; }\n    public string Suit { get; }\n\n    public override string ToString() => $\"{Rank} of {Suit}\";\n}\n\npublic class Deck : IEnumerable<Card>\n{\n    static readonly string[] ranks = { \"Two\", \"Three\", \"Four\", \"Five\", \"Six\",\n        \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Jack\", \"Queen\", \"King\", \"Ace\" };\n    static readonly string[] suits = { \"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\" };\n    readonly List<Card> cards;\n \n    public Deck() {\n        cards = (from suit in suits\n                from rank in ranks\n                select new Card(rank, suit)).ToList();\n    }\n\n    public int Count => cards.Count;\n\n    public void Shuffle() {\n        \n        var random = new Random();\n        for (int i = 0; i < cards.Count; i++) {\n            int r = random.Next(i, cards.Count);\n            var temp = cards[i];\n            cards[i] = cards[r];\n            cards[r] = temp;\n        }\n    }\n\n    public Card Deal() {\n        int last = cards.Count - 1;\n        Card card = cards[last];\n        \n        \n        cards.RemoveAt(last);\n        return card;\n    }\n\n    public IEnumerator<Card> GetEnumerator() {\n        \n        \n        for (int i = cards.Count - 1; i >= 0; i--)\n            yield return cards[i];\n    }\n\n    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n}\n"}
{"id": 341671, "name": "Lah numbers", "source": "Translate Swift to C#: import BigInt\nimport Foundation\n\n@inlinable\npublic func factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\n@inlinable\npublic func lah<T: BinaryInteger>(n: T, k: T) -> T {\n  if k == 1 {\n    return factorial(n)\n  } else if k == n {\n    return 1\n  } else if k > n {\n    return 0\n  } else if k < 1 || n < 1 {\n    return 0\n  } else {\n    let a = (factorial(n) * factorial(n - 1))\n    let b = (factorial(k) * factorial(k - 1))\n    let c = factorial(n - k)\n\n    return a / b / c\n  }\n}\n\nprint(\"Unsigned Lah numbers: L(n, k):\")\nprint(\"n\\\\k\", terminator: \"\")\n\nfor i in 0...12 {\n  print(String(format: \"%10d\", i), terminator: \" \")\n}\n\nprint()\n\nfor row in 0...12 {\n  print(String(format: \"%-2d\", row), terminator: \"\")\n\n  for i in 0...row {\n    lah(n: BigInt(row), k: BigInt(i)).description.withCString {str in\n      print(String(format: \"%11s\", str), terminator: \"\")\n    }\n  }\n\n  print()\n}\n\nlet maxLah = (0...100).map({ lah(n: BigInt(100), k: BigInt($0)) }).max()!\n\nprint(\"Maximum value from the L(100, *) row: \\(maxLah)\")\n", "target": "using System;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace LahNumbers {\n    class Program {\n        static BigInteger Factorial(BigInteger n) {\n            if (n == 0) return 1;\n            BigInteger res = 1;\n            while (n > 0) {\n                res *= n--;\n            }\n            return res;\n        }\n\n        static BigInteger Lah(BigInteger n, BigInteger k) {\n            if (k == 1) return Factorial(n);\n            if (k == n) return 1;\n            if (k > n) return 0;\n            if (k < 1 || n < 1) return 0;\n            return (Factorial(n) * Factorial(n - 1)) / (Factorial(k) * Factorial(k - 1)) / Factorial(n - k);\n        }\n\n        static void Main() {\n            Console.WriteLine(\"Unsigned Lah numbers: L(n, k):\");\n            Console.Write(\"n/k \");\n            foreach (var i in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,10} \", i);\n            }\n            Console.WriteLine();\n            foreach (var row in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,-3}\", row);\n                foreach (var i in Enumerable.Range(0, row + 1)) {\n                    var l = Lah(row, i);\n                    Console.Write(\"{0,11}\", l);\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine(\"\\nMaximum value from the L(100, *) row:\");\n            var maxVal = Enumerable.Range(0, 100).Select(a => Lah(100, a)).Max();\n            Console.WriteLine(maxVal);\n        }\n    }\n}\n"}
{"id": 341672, "name": "Lah numbers", "source": "Translate Swift to C#: import BigInt\nimport Foundation\n\n@inlinable\npublic func factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\n@inlinable\npublic func lah<T: BinaryInteger>(n: T, k: T) -> T {\n  if k == 1 {\n    return factorial(n)\n  } else if k == n {\n    return 1\n  } else if k > n {\n    return 0\n  } else if k < 1 || n < 1 {\n    return 0\n  } else {\n    let a = (factorial(n) * factorial(n - 1))\n    let b = (factorial(k) * factorial(k - 1))\n    let c = factorial(n - k)\n\n    return a / b / c\n  }\n}\n\nprint(\"Unsigned Lah numbers: L(n, k):\")\nprint(\"n\\\\k\", terminator: \"\")\n\nfor i in 0...12 {\n  print(String(format: \"%10d\", i), terminator: \" \")\n}\n\nprint()\n\nfor row in 0...12 {\n  print(String(format: \"%-2d\", row), terminator: \"\")\n\n  for i in 0...row {\n    lah(n: BigInt(row), k: BigInt(i)).description.withCString {str in\n      print(String(format: \"%11s\", str), terminator: \"\")\n    }\n  }\n\n  print()\n}\n\nlet maxLah = (0...100).map({ lah(n: BigInt(100), k: BigInt($0)) }).max()!\n\nprint(\"Maximum value from the L(100, *) row: \\(maxLah)\")\n", "target": "using System;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace LahNumbers {\n    class Program {\n        static BigInteger Factorial(BigInteger n) {\n            if (n == 0) return 1;\n            BigInteger res = 1;\n            while (n > 0) {\n                res *= n--;\n            }\n            return res;\n        }\n\n        static BigInteger Lah(BigInteger n, BigInteger k) {\n            if (k == 1) return Factorial(n);\n            if (k == n) return 1;\n            if (k > n) return 0;\n            if (k < 1 || n < 1) return 0;\n            return (Factorial(n) * Factorial(n - 1)) / (Factorial(k) * Factorial(k - 1)) / Factorial(n - k);\n        }\n\n        static void Main() {\n            Console.WriteLine(\"Unsigned Lah numbers: L(n, k):\");\n            Console.Write(\"n/k \");\n            foreach (var i in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,10} \", i);\n            }\n            Console.WriteLine();\n            foreach (var row in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,-3}\", row);\n                foreach (var i in Enumerable.Range(0, row + 1)) {\n                    var l = Lah(row, i);\n                    Console.Write(\"{0,11}\", l);\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine(\"\\nMaximum value from the L(100, *) row:\");\n            var maxVal = Enumerable.Range(0, 100).Select(a => Lah(100, a)).Max();\n            Console.WriteLine(maxVal);\n        }\n    }\n}\n"}
{"id": 341673, "name": "Find the last Sunday of each month", "source": "Translate Swift to C#: import Foundation\n\nfunc lastSundays(of year: Int) -> [Date] {\n\t\n\tlet calendar = Calendar.current\n\tvar dates = [Date]()\n\t\n\tfor month in 1...12 {\n\t\t\n\t\tvar dateComponents = DateComponents(calendar: calendar,\n\t\t                                    year: year,\n\t\t                                    month: month + 1,\n\t\t                                    day: 0,\n\t\t                                    hour: 12)\n\t\t\n\t\tlet date = calendar.date(from: dateComponents)!\n\t\tlet weekday = calendar.component(.weekday, from: date)\n\n\t\tif weekday != 1 {\n\t\t\tdateComponents.day! -= weekday - 1\n\t\t}\n\t\t\n\t\tdates.append(calendar.date(from: dateComponents)!)\n\t}\n\treturn dates\n}\n\nvar dateFormatter = DateFormatter()\ndateFormatter.dateStyle = .short\n\nprint(lastSundays(of: 2013).map(dateFormatter.string).joined(separator: \"\\n\"))\n", "target": "using System;\n\nnamespace LastSundayOfEachMonth\n{\n    class Program\n    {\n        static void Main()\n        {\n            Console.Write(\"Year to calculate: \");\n\n            string strYear = Console.ReadLine();\n            int year = Convert.ToInt32(strYear);\n\n            DateTime date;\n            for (int i = 1; i <= 12; i++)\n            {\n                date = new DateTime(year, i, DateTime.DaysInMonth(year, i), System.Globalization.CultureInfo.CurrentCulture.Calendar);\n                \n                \n                int daysOffset = date.DayOfWeek - dayOfWeek; \n                if (daysOffset < 0) daysOffset += 7; \n                date = date.AddDays(-daysOffset ); \n                Console.WriteLine(date.ToString(\"yyyy-MM-dd\"));\n            }\n        }\n    }\n}\n"}
{"id": 341674, "name": "Find the last Sunday of each month", "source": "Translate Swift to C#: import Foundation\n\nfunc lastSundays(of year: Int) -> [Date] {\n\t\n\tlet calendar = Calendar.current\n\tvar dates = [Date]()\n\t\n\tfor month in 1...12 {\n\t\t\n\t\tvar dateComponents = DateComponents(calendar: calendar,\n\t\t                                    year: year,\n\t\t                                    month: month + 1,\n\t\t                                    day: 0,\n\t\t                                    hour: 12)\n\t\t\n\t\tlet date = calendar.date(from: dateComponents)!\n\t\tlet weekday = calendar.component(.weekday, from: date)\n\n\t\tif weekday != 1 {\n\t\t\tdateComponents.day! -= weekday - 1\n\t\t}\n\t\t\n\t\tdates.append(calendar.date(from: dateComponents)!)\n\t}\n\treturn dates\n}\n\nvar dateFormatter = DateFormatter()\ndateFormatter.dateStyle = .short\n\nprint(lastSundays(of: 2013).map(dateFormatter.string).joined(separator: \"\\n\"))\n", "target": "using System;\n\nnamespace LastSundayOfEachMonth\n{\n    class Program\n    {\n        static void Main()\n        {\n            Console.Write(\"Year to calculate: \");\n\n            string strYear = Console.ReadLine();\n            int year = Convert.ToInt32(strYear);\n\n            DateTime date;\n            for (int i = 1; i <= 12; i++)\n            {\n                date = new DateTime(year, i, DateTime.DaysInMonth(year, i), System.Globalization.CultureInfo.CurrentCulture.Calendar);\n                \n                \n                int daysOffset = date.DayOfWeek - dayOfWeek; \n                if (daysOffset < 0) daysOffset += 7; \n                date = date.AddDays(-daysOffset ); \n                Console.WriteLine(date.ToString(\"yyyy-MM-dd\"));\n            }\n        }\n    }\n}\n"}
{"id": 341675, "name": "Longest increasing subsequence", "source": "Translate Swift to C#: import Foundation\n\nextension Array where Element: Comparable {\n  @inlinable\n  public func longestIncreasingSubsequence() -> [Element] {\n    var startI = [Int](repeating: 0, count: count)\n    var endI = [Int](repeating: 0, count: count + 1)\n    var len = 0\n\n    for i in 0..<count {\n      var lo = 1\n      var hi = len\n\n      while lo <= hi {\n        let mid = Int(ceil((Double(lo + hi)) / 2))\n\n        if self[endI[mid]] <= self[i] {\n          lo = mid + 1\n        } else {\n          hi = mid - 1\n        }\n      }\n\n      startI[i] = endI[lo-1]\n      endI[lo] = i\n\n      if lo > len {\n        len = lo\n      }\n    }\n\n    var s = [Element]()\n    var k = endI[len]\n\n    for _ in 0..<len {\n      s.append(self[k])\n      k = startI[k]\n    }\n\n    return s.reversed()\n  }\n}\n\nlet l1 = [3, 2, 6, 4, 5, 1]\nlet l2 = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\n\nprint(\"\\(l1) = \\(l1.longestIncreasingSubsequence())\")\nprint(\"\\(l2) = \\(l2.longestIncreasingSubsequence())\")\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class LIS\n{\n    public static IEnumerable<T> FindRec<T>(IList<T> values, IComparer<T> comparer = null) =>\n        values == null ? throw new ArgumentNullException() :\n            FindRecImpl(values, Sequence<T>.Empty, 0, comparer ?? Comparer<T>.Default).Reverse();\n\n    private static Sequence<T> FindRecImpl<T>(IList<T> values, Sequence<T> current, int index, IComparer<T> comparer) {\n        if (index == values.Count) return current;\n        if (current.Length > 0 && comparer.Compare(values[index], current.Value) <= 0)\n            return FindRecImpl(values, current, index + 1, comparer);\n        return Max(\n            FindRecImpl(values, current, index + 1, comparer),\n            FindRecImpl(values, current + values[index], index + 1, comparer)\n        );\n    }\n\n    private static Sequence<T> Max<T>(Sequence<T> a, Sequence<T> b) => a.Length < b.Length ? b : a;\n\n    class Sequence<T> : IEnumerable<T>\n    {\n        public static readonly Sequence<T> Empty = new Sequence<T>(default(T), null);\n\n        public Sequence(T value, Sequence<T> tail)\n        {\n            Value = value;\n            Tail = tail;\n            Length = tail == null ? 0 : tail.Length + 1;\n        }\n\n        public T Value { get; }\n        public Sequence<T> Tail { get; }\n        public int Length { get; }\n\n        public static Sequence<T> operator +(Sequence<T> s, T value) => new Sequence<T>(value, s);\n\n        public IEnumerator<T> GetEnumerator()\n        {\n            for (var s = this; s.Length > 0; s = s.Tail) yield return s.Value;\n        }\n\n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n    }\n}\n"}
{"id": 341676, "name": "Circles of given radius through two points", "source": "Translate Swift to C#: import Foundation\n\nstruct Point: Equatable {\n    var x: Double\n    var y: Double\n}\n\nstruct Circle {\n  var center: Point\n  var radius: Double\n\n  static func circleBetween(\n    _ p1: Point,\n    _ p2: Point,\n    withRadius radius: Double\n  ) -> (Circle, Circle?)? {\n    func applyPoint(_ p1: Point, _ p2: Point, op: (Double, Double) -> Double) -> Point {\n      return Point(x: op(p1.x, p2.x), y: op(p1.y, p2.y))\n    }\n\n    func mul2(_ p: Point, mul: Double) -> Point {\n      return Point(x: p.x * mul, y: p.y * mul)\n    }\n\n    func div2(_ p: Point, div: Double) -> Point {\n      return Point(x: p.x / div, y: p.y / div)\n    }\n\n    func norm(_ p: Point) -> Point {\n      return div2(p, div: (p.x * p.x + p.y * p.y).squareRoot())\n    }\n\n    guard radius != 0, p1 != p2 else {\n      return nil\n    }\n\n    let diameter = 2 * radius\n    let pq = applyPoint(p1, p2, op: -)\n    let magPQ = (pq.x * pq.x + pq.y * pq.y).squareRoot()\n\n    guard diameter >= magPQ else {\n      return nil\n    }\n\n    let midpoint = div2(applyPoint(p1, p2, op: +), div: 2)\n    let halfPQ = magPQ / 2\n    let magMidC = abs(radius * radius - halfPQ * halfPQ).squareRoot()\n    let midC = mul2(norm(Point(x: -pq.y, y: pq.x)), mul: magMidC)\n    let center1 = applyPoint(midpoint, midC, op: +)\n    let center2 = applyPoint(midpoint, midC, op: -)\n\n    if center1 == center2 {\n      return (Circle(center: center1, radius: radius), nil)\n    } else {\n      return (Circle(center: center1, radius: radius), Circle(center: center2, radius: radius))\n    }\n  }\n}\n\nlet testCases = [\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 2.0),\n  (Point(x: 0.0000, y: 2.0000), Point(x: 0.0000, y: 0.0000), 1.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 2.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 0.5),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 0.0)\n]\n\nfor testCase in testCases {\n  switch Circle.circleBetween(testCase.0, testCase.1, withRadius: testCase.2) {\n  case nil:\n    print(\"No ans\")\n  case (let circle1, nil)?:\n    print(\"One ans: \\(circle1)\")\n  case (let circle1, let circle2?)?:\n    print(\"Two ans: \\(circle1) \\(circle2)\")\n  }\n}\n", "target": "using System;\npublic class CirclesOfGivenRadiusThroughTwoPoints\n{\n    public static void Main()\n    {\n        double[][] values = new double[][] {\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345,   2 },\n            new [] { 0.0,       2.0,    0.0,    0.0,   1 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   2 },\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345, 0.5 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   0 }\n        };\n\t\t\n        foreach (var a in values) {\n            var p = new Point(a[0], a[1]);\n            var q = new Point(a[2], a[3]);\n            Console.WriteLine($\"Points {p} and {q} with radius {a[4]}:\");\n            try {\n                var centers = FindCircles(p, q, a[4]);\n                Console.WriteLine(\"\\t\" + string.Join(\" and \", centers));\n            } catch (Exception ex) {\n                Console.WriteLine(\"\\t\" + ex.Message);\n            }\n        }\n    }\n\t\n    static Point[] FindCircles(Point p, Point q, double radius) {\n        if(radius < 0) throw new ArgumentException(\"Negative radius.\");\n        if(radius == 0) {\n            if(p == q) return new [] { p };\n            else throw new InvalidOperationException(\"No circles.\");\n        }\n        if (p == q) throw new InvalidOperationException(\"Infinite number of circles.\");\n\t\t\n        double sqDistance = Point.SquaredDistance(p, q);\n        double sqDiameter = 4 * radius * radius;\n        if (sqDistance > sqDiameter) throw new InvalidOperationException(\"Points are too far apart.\");\n\t\t\n        Point midPoint = new Point((p.X + q.X) / 2, (p.Y + q.Y) / 2);\n        if (sqDistance == sqDiameter) return new [] { midPoint };\n\t\t\n        double d = Math.Sqrt(radius * radius - sqDistance / 4);\n        double distance = Math.Sqrt(sqDistance);\n        double ox = d * (q.X - p.X) / distance, oy = d * (q.Y - p.Y) / distance;\n        return new [] {\n            new Point(midPoint.X - oy, midPoint.Y + ox),\n            new Point(midPoint.X + oy, midPoint.Y - ox)\n        };\n    }\n\t\n    public struct Point\n    {\n        public Point(double x, double y) : this() {\n            X = x;\n            Y = y;\n        }\n\t\n        public double X { get; }\n        public double Y { get; }\n\t\n        public static bool operator ==(Point p, Point q) => p.X == q.X && p.Y == q.Y;\n        public static bool operator !=(Point p, Point q) => p.X != q.X || p.Y != q.Y;\n\t\n        public static double SquaredDistance(Point p, Point q) {\n            double dx = q.X - p.X, dy = q.Y - p.Y;\n            return dx * dx + dy * dy;\n        }\n\t\t\n        public override string ToString() => $\"({X}, {Y})\";\n\t\t\n    }\t\n}\n"}
{"id": 341677, "name": "Vampire number", "source": "Translate Swift to C#: import Foundation\n\nfunc vampire<T>(n: T) -> [(T, T)] where T: BinaryInteger, T.Stride: SignedInteger {\n  let strN = String(n).sorted()\n  let fangLength = strN.count / 2\n  let start = T(pow(10, Double(fangLength - 1)))\n  let end = T(Double(n).squareRoot())\n\n  var fangs = [(T, T)]()\n\n  for i in start...end where n % i == 0 {\n    let quot = n / i\n\n    guard i % 10 != 0 || quot % 10 != 0 else {\n      continue\n    }\n\n    if \"\\(i)\\(quot)\".sorted() == strN {\n      fangs.append((i, quot))\n    }\n  }\n\n  return fangs\n}\n\nvar count = 0\nvar i = 1.0\n\nwhile count < 25 {\n  let start = Int(pow(10, i))\n  let end = start * 10\n\n  for num in start...end {\n    let fangs = vampire(n: num)\n\n    guard !fangs.isEmpty else { continue }\n\n    count += 1\n\n    print(\"\\(num) is a vampire number with fangs: \\(fangs)\")\n\n    guard count != 25 else { break }\n  }\n\n  i += 2\n}\n\nfor (vamp, fangs) in [16758243290880, 24959017348650, 14593825548650].lazy.map({ ($0, vampire(n: $0)) }) {\n  if fangs.isEmpty {\n    print(\"\\(vamp) is not a vampire number\")\n  } else {\n    print(\"\\(vamp) is a vampire number with fangs: \\(fangs)\")\n  }\n}\n", "target": "using System;\n\nnamespace RosettaVampireNumber\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int i, j, n;\n            ulong x;\n            var f = new ulong[16];\n            var bigs = new ulong[] { 16758243290880UL, 24959017348650UL, 14593825548650UL, 0 };\n            ulong[] tens = new ulong[20];\n            tens[0] = 1;\n            for (i = 1; i < 20; i++)\n                tens[i] = tens[i - 1] * 10;\n            \n            for (x = 1, n = 0; n < 25; x++)\n            {\n                if ((j = fangs(x, f, tens)) == 0) continue;\n                Console.Write(++n + \": \");\n                show_fangs(x, f, j);\n            }\n\n            Console.WriteLine();\n            for (i = 0; bigs[i] > 0 ; i++)\n            {\n                if ((j = fangs(bigs[i], f, tens)) > 0)\n                    show_fangs(bigs[i], f, j);\n                else\n                    Console.WriteLine(bigs[i] + \" is not vampiric.\");\n            }\n            Console.ReadLine();\n        }\n\n        private static void show_fangs(ulong x, ulong[] f, int cnt)\n        {\n            Console.Write(x); \n            int i;\n            for (i = 0; i < cnt; i++)\n                Console.Write(\" =\u00a0\" + f[i] + \" * \" + (x / f[i]));\n            Console.WriteLine();\n        }\n\n        private static int fangs(ulong x, ulong[] f, ulong[] tens)\n        {\n            int n = 0;\n            int nd = ndigits(x);\n            if ((nd & 1) > 0) return 0;\n            nd /= 2;\n\n            ulong lo, hi;\n            lo = Math.Max(tens[nd - 1], (x + tens[nd] - 2) / (tens[nd] - 1));\n            hi = Math.Min(x / lo, (ulong) Math.Sqrt(x));\n\n            ulong a, b, t = dtally(x);\n            for (a = lo; a <= hi; a++)\n            {\n                b = x / a;\n                if (a * b == x && ((a % 10) > 0 || (b % 10) > 0) && t == dtally(a) + dtally(b))\n                    f[n++] = a;\n            }\n\n            return n;\n        }\n\n        private static ulong dtally(ulong x)\n        {\n            ulong t = 0;\n            while (x > 0)\n            {\n                t += 1UL << (int)((x % 10) * 6);\n                x /= 10;\n            }\n\n            return t;\n        }\n\n        private static int ndigits(ulong x)\n        {\n            int n = 0;\n            while (x > 0)\n            {\n                n++;\n                x /= 10;\n            }\n            return n;\n        }\n    }\n}\n"}
{"id": 341678, "name": "Play recorded sounds", "source": "Translate Swift to C#: import AVFoundation\n\n\n\n\n\n\nclass PlayerControl: NSObject, AVAudioPlayerDelegate {\n    let player1:AVAudioPlayer!\n    let player2:AVAudioPlayer!\n    var playedBoth = false\n    var volume:Float {\n        get {\n            return player1.volume\n        }\n        \n        set {\n            player1.volume = newValue\n            player2.volume = newValue\n        }\n    }\n    \n    init(player1:AVAudioPlayer, player2:AVAudioPlayer) {\n        super.init()\n        self.player1 = player1\n        self.player2 = player2\n        self.player1.delegate = self\n        self.player2.delegate = self\n    }\n    \n    func loop() {\n        player1.numberOfLoops = 1\n        player1.play()\n        \n        let time = Int64((Double(player1.duration) + 2.0) * Double(NSEC_PER_SEC))\n        \n        dispatch_after(dispatch_time(0, time), dispatch_get_main_queue()) {[weak self] in\n            println(\"Stopping track\")\n            self?.player1.stop()\n            exit(0)\n        }\n    }\n    \n    func playBoth() {\n        player1.play()\n        player2.play()\n    }\n    \n    func audioPlayerDidFinishPlaying(player:AVAudioPlayer!, successfully flag:Bool) {\n        if player === player2 && !playedBoth {\n            playBoth()\n            playedBoth = true\n        } else if player === player2 && playedBoth {\n            loop()\n        }\n    }\n}\n\nlet url1 = NSURL(string: \"file:\nlet url2 = NSURL(string: \"file:\n\nvar err:NSError?\nlet player1 = AVAudioPlayer(contentsOfURL: url1, error: &err)\nlet player2 = AVAudioPlayer(contentsOfURL: url2, error: &err)\n\nlet player = PlayerControl(player1: player1, player2: player2)\n\n\nplayer.volume = 0.5\n\n\n\n\n\n\nplayer.player2.play()\n\nCFRunLoopRun()\n", "target": "using System;\nusing System.Threading;\nusing System.Media;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        SoundPlayer s1 = new SoundPlayer(); \n        s1.SoundLocation = file; \n\n        \n        s1.Play();     \n\n        \n        s1.Play();\n        Thread.Sleep(100);\n        s1.Stop();\n\n        \n        s1.PlayLooping();\n    }\n}\n"}
{"id": 341679, "name": "Nonoblock", "source": "Translate Swift to C#: import Foundation\n\nfunc nonoblock(cells: Int, blocks: [Int]) {\n    print(\"\\(cells) cells and blocks \\(blocks):\")\n    let totalBlockSize = blocks.reduce(0, +)\n    if cells < totalBlockSize + blocks.count - 1 {\n        print(\"no solution\")\n        return\n    }\n\n    func solve(cells: Int, index: Int, totalBlockSize: Int, offset: Int) {\n        if index == blocks.count {\n            count += 1\n            print(\"\\(String(format: \"%2d\", count))  \\(String(output))\")\n            return\n        }\n        let blockSize = blocks[index]\n        let maxPos = cells - (totalBlockSize + blocks.count - index - 1)\n        let t = totalBlockSize - blockSize\n        var c = cells - (blockSize + 1)\n        for pos in 0...maxPos {\n            fill(value: \".\", offset: offset, count: maxPos + blockSize)\n            fill(value: \"#\", offset: offset + pos, count: blockSize)\n            solve(cells: c, index: index + 1, totalBlockSize: t,\n                  offset: offset + blockSize + pos + 1)\n            c -= 1\n        }\n    }\n\n    func fill(value: Character, offset: Int, count: Int) {\n        output.replaceSubrange(offset..<offset+count,\n                               with: repeatElement(value, count: count))\n    }\n    \n    var output: [Character] = Array(repeating: \".\", count: cells)\n    var count = 0\n    solve(cells: cells, index: 0, totalBlockSize: totalBlockSize, offset: 0)\n}\n\nnonoblock(cells: 5, blocks: [2, 1])\nprint()\n\nnonoblock(cells: 5, blocks: [])\nprint()\n\nnonoblock(cells: 10, blocks: [8])\nprint()\n\nnonoblock(cells: 15, blocks: [2, 3, 2, 3])\nprint()\n\nnonoblock(cells: 5, blocks: [2, 3])\n", "target": "using System;\nusing System.Linq;\nusing System.Text;\n\npublic static class Nonoblock\n{\n    public static void Main() {\n        Positions(5, 2,1);\n        Positions(5);\n        Positions(10, 8);\n        Positions(15, 2,3,2,3);\n        Positions(5, 2,3);\n    }\n\n    public static void Positions(int cells, params int[] blocks) {\n        if (cells < 0 || blocks == null || blocks.Any(b => b < 1)) throw new ArgumentOutOfRangeException();\n        Console.WriteLine($\"{cells} cells with [{string.Join(\", \", blocks)}]\");\n        if (blocks.Sum() + blocks.Length - 1 > cells) {\n            Console.WriteLine(\"No solution\");\n            return;\n        }\n        var spaces = new int[blocks.Length + 1];\n        int total = -1;\n        for (int i = 0; i < blocks.Length; i++) {\n            total += blocks[i] + 1;\n            spaces[i+1] = total;\n        }\n        spaces[spaces.Length - 1] = cells - 1;\n        var sb = new StringBuilder(string.Join(\".\", blocks.Select(b => new string('#', b))).PadRight(cells, '.'));\n        Iterate(sb, spaces, spaces.Length - 1, 0);\n        Console.WriteLine();\n    }\n\n    private static void Iterate(StringBuilder output, int[] spaces, int index, int offset) {\n        Console.WriteLine(output.ToString());\n        if (index <= 0) return;\n        int count = 0;\n        while (output[spaces[index] - offset] != '#') {\n            count++;\n            output.Remove(spaces[index], 1);\n            output.Insert(spaces[index-1], '.');\n            spaces[index-1]++;\n            Iterate(output, spaces, index - 1, 1);\n        }\n        if (offset == 0) return;\n        spaces[index-1] -= count;\n        output.Remove(spaces[index-1], count);\n        output.Insert(spaces[index] - count, \".\", count);\n    }\n\n}\n"}
{"id": 341680, "name": "Nonoblock", "source": "Translate Swift to C#: import Foundation\n\nfunc nonoblock(cells: Int, blocks: [Int]) {\n    print(\"\\(cells) cells and blocks \\(blocks):\")\n    let totalBlockSize = blocks.reduce(0, +)\n    if cells < totalBlockSize + blocks.count - 1 {\n        print(\"no solution\")\n        return\n    }\n\n    func solve(cells: Int, index: Int, totalBlockSize: Int, offset: Int) {\n        if index == blocks.count {\n            count += 1\n            print(\"\\(String(format: \"%2d\", count))  \\(String(output))\")\n            return\n        }\n        let blockSize = blocks[index]\n        let maxPos = cells - (totalBlockSize + blocks.count - index - 1)\n        let t = totalBlockSize - blockSize\n        var c = cells - (blockSize + 1)\n        for pos in 0...maxPos {\n            fill(value: \".\", offset: offset, count: maxPos + blockSize)\n            fill(value: \"#\", offset: offset + pos, count: blockSize)\n            solve(cells: c, index: index + 1, totalBlockSize: t,\n                  offset: offset + blockSize + pos + 1)\n            c -= 1\n        }\n    }\n\n    func fill(value: Character, offset: Int, count: Int) {\n        output.replaceSubrange(offset..<offset+count,\n                               with: repeatElement(value, count: count))\n    }\n    \n    var output: [Character] = Array(repeating: \".\", count: cells)\n    var count = 0\n    solve(cells: cells, index: 0, totalBlockSize: totalBlockSize, offset: 0)\n}\n\nnonoblock(cells: 5, blocks: [2, 1])\nprint()\n\nnonoblock(cells: 5, blocks: [])\nprint()\n\nnonoblock(cells: 10, blocks: [8])\nprint()\n\nnonoblock(cells: 15, blocks: [2, 3, 2, 3])\nprint()\n\nnonoblock(cells: 5, blocks: [2, 3])\n", "target": "using System;\nusing System.Linq;\nusing System.Text;\n\npublic static class Nonoblock\n{\n    public static void Main() {\n        Positions(5, 2,1);\n        Positions(5);\n        Positions(10, 8);\n        Positions(15, 2,3,2,3);\n        Positions(5, 2,3);\n    }\n\n    public static void Positions(int cells, params int[] blocks) {\n        if (cells < 0 || blocks == null || blocks.Any(b => b < 1)) throw new ArgumentOutOfRangeException();\n        Console.WriteLine($\"{cells} cells with [{string.Join(\", \", blocks)}]\");\n        if (blocks.Sum() + blocks.Length - 1 > cells) {\n            Console.WriteLine(\"No solution\");\n            return;\n        }\n        var spaces = new int[blocks.Length + 1];\n        int total = -1;\n        for (int i = 0; i < blocks.Length; i++) {\n            total += blocks[i] + 1;\n            spaces[i+1] = total;\n        }\n        spaces[spaces.Length - 1] = cells - 1;\n        var sb = new StringBuilder(string.Join(\".\", blocks.Select(b => new string('#', b))).PadRight(cells, '.'));\n        Iterate(sb, spaces, spaces.Length - 1, 0);\n        Console.WriteLine();\n    }\n\n    private static void Iterate(StringBuilder output, int[] spaces, int index, int offset) {\n        Console.WriteLine(output.ToString());\n        if (index <= 0) return;\n        int count = 0;\n        while (output[spaces[index] - offset] != '#') {\n            count++;\n            output.Remove(spaces[index], 1);\n            output.Insert(spaces[index-1], '.');\n            spaces[index-1]++;\n            Iterate(output, spaces, index - 1, 1);\n        }\n        if (offset == 0) return;\n        spaces[index-1] -= count;\n        output.Remove(spaces[index-1], count);\n        output.Insert(spaces[index] - count, \".\", count);\n    }\n\n}\n"}
{"id": 341681, "name": "Knapsack problem_Bounded", "source": "Translate Swift to C#: public struct KnapsackItem: Hashable {\n  public var name: String\n  public var weight: Int\n  public var value: Int\n\n  public init(name: String, weight: Int, value: Int) {\n    self.name = name\n    self.weight = weight\n    self.value = value\n  }\n}\n\npublic func knapsack(items: [KnapsackItem], limit: Int) -> [KnapsackItem] {\n  var table = Array(repeating: Array(repeating: 0, count: limit + 1), count: items.count + 1)\n\n  for j in 1...items.count {\n    let item = items[j-1]\n\n    for w in 1...limit {\n      if item.weight > w {\n        table[j][w] = table[j-1][w]\n      } else {\n        table[j][w] = max(table[j-1][w], table[j-1][w-item.weight] + item.value)\n      }\n    }\n  }\n\n  var result = [KnapsackItem]()\n  var w = limit\n\n  for j in stride(from: items.count, to: 0, by: -1) where table[j][w] != table[j-1][w] {\n    let item = items[j-1]\n\n    result.append(item)\n\n    w -= item.weight\n  }\n\n  return result\n}\n\ntypealias GroupedItem = (name: String, weight: Int, val: Int, n: Int)\n\nlet groupedItems: [GroupedItem] = [\n  (\"map\", 9, 150, 1),\n  (\"compass\", 13, 35, 1),\n  (\"water\", 153, 200, 3),\n  (\"sandwich\", 50, 60, 2),\n  (\"glucose\", 15, 60, 2),\n  (\"tin\", 68, 45, 3),\n  (\"banana\", 27, 60, 3),\n  (\"apple\", 39, 40, 3),\n  (\"cheese\", 23, 30, 1),\n  (\"beer\", 52, 10, 3),\n  (\"suntan cream\", 11, 70, 1),\n  (\"camera\", 32, 30, 1),\n  (\"t-shirt\", 24, 15, 2),\n  (\"trousers\", 48, 10, 2),\n  (\"umbrella\", 73, 40, 1),\n  (\"waterproof trousers\", 42, 70, 1),\n  (\"waterproof overclothes\", 43, 75, 1),\n  (\"note-case\", 22, 80, 1),\n  (\"sunglasses\", 7, 20, 1),\n  (\"towel\", 18, 12, 2),\n  (\"socks\", 4, 50, 1),\n  (\"book\", 30, 10, 2)\n]\n\nlet items = groupedItems.flatMap({item in\n  (0..<item.n).map({_ in KnapsackItem(name: item.name, weight: item.weight, value: item.val) })\n})\n\nlet bagged = knapsack(items: items, limit: 400)\nlet (totalVal, totalWeight) = bagged.reduce((0, 0), {cur, item in (cur.0 + item.value, cur.1 + item.weight) })\n\nprint(\"Bagged the following \\(bagged.count) items:\")\n\nfor item in bagged {\n  print(\"\\t\\(item.name)\")\n}\n\nprint(\"For a total value of \\(totalVal) and weight of \\(totalWeight)\")\n", "target": "using System;  \nclass program\n{\n    static void Main()\n    {\n        knapSack(40);\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        Console.Write(knapSack(400) + \"\\n\" + sw.Elapsed);  \n        Console.Read();\n    }\n\n    static string knapSack(uint w1)\n    {\n        init(); change();\n        uint n = (uint)w.Length; var K = new uint[n + 1, w1 + 1];\n        for (uint vi, wi, w0, x, i = 0; i < n; i++)\n            for (vi = v[i], wi = w[i], w0 = 1; w0 <= w1; w0++)\n            {\n                x = K[i, w0];\n                if (wi <= w0) x = max(vi + K[i, w0 - wi], x);\n                K[i + 1, w0] = x;\n            }\n        string str = \"\";\n        for (uint v1 = K[n, w1]; v1 > 0; n--)\n            if (v1 != K[n - 1, w1])\n            {\n                v1 -= v[n - 1]; w1 -= w[n - 1]; str += items[n - 1] + \"\\n\";\n            }\n        return str;\n    }\n\n    static uint max(uint a, uint b) { return a > b ? a : b; }\n\n    static byte[] w, v; static string[] items;\n\n    static byte[] p = { 1, 1, 2, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2 };\n\n    static void init()\n    {\n        w = new byte[] { 9, 13, 153, 50, 15, 68, 27, 39, 23, 52, 11,\n                          32, 24, 48, 73, 42, 43, 22, 7, 18, 4, 30 };\n\n        v = new byte[] { 150, 35, 200, 60, 60, 45, 60, 40, 30, 10, 70,\n                          30, 15, 10, 40, 70, 75, 80, 20, 12, 50, 10 };\n\n        items = new string[] {\"map\",\"compass\",\"water\",\"sandwich\",\"glucose\",\"tin\",\n                              \"banana\",\"apple\",\"cheese\",\"beer\",\"suntan cream\",\n                              \"camera\",\"T-shirt\",\"trousers\",\"umbrella\",\n                              \"waterproof trousers\",\"waterproof overclothes\",\n                              \"note-case\",\"sunglasses\",\"towel\",\"socks\",\"book\"};\n    }\n\n    static void change()\n    {\n        int n = w.Length, s = 0, i, j, k; byte xi;\n        for (i = 0; i < n; i++) s += p[i];\n        {\n            byte[] x = new byte[s];\n            for (k = i = 0; i < n; i++)\n                for (xi = w[i], j = p[i]; j > 0; j--) x[k++] = xi;\n            w = x;\n        }\n        {\n            byte[] x = new byte[s];\n            for (k = i = 0; i < n; i++)\n                for (xi = v[i], j = p[i]; j > 0; j--) x[k++] = xi;\n            v = x;\n        }\n        string[] pItems = new string[s]; string itemI;\n        for (k = i = 0; i < n; i++)\n            for (itemI = items[i], j = p[i]; j > 0; j--) pItems[k++] = itemI;\n        items = pItems;\n    }\n}\n"}
{"id": 351502, "name": "Long year", "source": "Translate Swift to Python: func isLongYear(_ year: Int) -> Bool {\n  let year1 = year - 1\n  let p = (year + (year / 4) - (year / 100) + (year / 400)) % 7\n  let p1 = (year1 + (year1 / 4) - (year1 / 100) + (year1 / 400)) % 7\n\n  return p == 4 || p1 == 3\n}\n\nfor range in [1900...1999, 2000...2099, 2100...2199] {\n  print(\"\\(range): \\(range.filter(isLongYear))\")\n}\n", "target": "\n\nfrom datetime import date\n\n\n\ndef longYear(y):\n    \n    return 52 < date(y, 12, 28).isocalendar()[1]\n\n\n\n\ndef main():\n    \n    for year in [\n            x for x in range(2000, 1 + 2100)\n            if longYear(x)\n    ]:\n        print(year)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351503, "name": "Mian-Chowla sequence", "source": "Translate Swift to Python: public func mianChowla(n: Int) -> [Int] {\n  var mc = Array(repeating: 0, count: n)\n  var ls = [2: true]\n  var sum = 0\n\n  mc[0] = 1\n\n  for i in 1..<n {\n    var lsx = [Int]()\n\n    jLoop: for j in (mc[i-1]+1)... {\n      mc[i] = j\n\n      for k in 0...i {\n        sum = mc[k] + j\n\n        if ls[sum] ?? false {\n          lsx = []\n          continue jLoop\n        }\n\n        lsx.append(sum)\n      }\n\n      for n in lsx {\n        ls[n] = true\n      }\n\n      break\n    }\n  }\n\n  return mc\n}\n\nlet seq = mianChowla(n: 100)\n\nprint(\"First 30 terms in sequence are: \\(Array(seq.prefix(30)))\")\nprint(\"Terms 91 to 100 are: \\(Array(seq[90..<100]))\")\n", "target": "from itertools import count, islice, chain\nimport time\n\ndef mian_chowla():\n    mc = [1]\n    yield mc[-1]\n    psums = set([2])\n    newsums = set([])\n    for trial in count(2):\n        for n in chain(mc, [trial]):\n            sum = n + trial\n            if sum in psums:\n                newsums.clear()\n                break\n            newsums.add(sum)\n        else:\n            psums |= newsums\n            newsums.clear()\n            mc.append(trial)\n            yield trial\n\ndef pretty(p, t, s, f):\n    print(p, t, \" \".join(str(n) for n in (islice(mian_chowla(), s, f))))\n\nif __name__ == '__main__':\n    st = time.time()\n    ts = \"of the Mian-Chowla sequence are:\\n\"\n    pretty(\"The first 30 terms\", ts, 0, 30)\n    pretty(\"\\nTerms 91 to 100\", ts, 90, 100)\n    print(\"\\nComputation time was\", (time.time()-st) * 1000, \"ms\")\n"}
{"id": 351504, "name": "Water collected between towers", "source": "Translate Swift to Python: \n\n\nfunc waterCollected(_ heights: [Int]) -> Int {\n    guard heights.count > 0 else {\n        return 0\n    }\n    var water = 0\n    var left = 0, right = heights.count - 1\n    var maxLeft = heights[left], maxRight = heights[right]\n    \n    while left < right {\n        if heights[left] <= heights[right] {\n            maxLeft = max(heights[left], maxLeft)\n            water += maxLeft - heights[left]\n            left += 1\n        } else {\n            maxRight = max(heights[right], maxRight)\n            water += maxRight - heights[right]\n            right -= 1\n        }\n    }\n    return water\n}\n\nfor heights in [[1, 5, 3, 7, 2],\n                [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],\n                [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],\n                [5, 5, 5, 5],\n                [5, 6, 7, 8],\n                [8, 7, 7, 6],\n                [6, 7, 10, 7, 6]] {\n    print(\"water collected = \\(waterCollected(heights))\")\n}\n", "target": "def water_collected(tower):\n    N = len(tower)\n    highest_left = [0] + [max(tower[:n]) for n in range(1,N)]\n    highest_right = [max(tower[n:N]) for n in range(1,N)] + [0]\n    water_level = [max(min(highest_left[n], highest_right[n]) - tower[n], 0)\n        for n in range(N)]\n    print(\"highest_left:  \", highest_left)\n    print(\"highest_right: \", highest_right)\n    print(\"water_level:   \", water_level)\n    print(\"tower_level:   \", tower)\n    print(\"total_water:   \", sum(water_level))\n    print(\"\")\n    return sum(water_level)\n\ntowers = [[1, 5, 3, 7, 2],\n    [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],\n    [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],\n    [5, 5, 5, 5],\n    [5, 6, 7, 8],\n    [8, 7, 7, 6],\n    [6, 7, 10, 7, 6]]\n\n[water_collected(tower) for tower in towers]\n"}
{"id": 351505, "name": "Orbital elements", "source": "Translate Swift to Python: import Foundation\n\npublic struct Vector {\n  public var x = 0.0\n  public var y = 0.0\n  public var z = 0.0\n\n  public init(x: Double, y: Double, z: Double) {\n    (self.x, self.y, self.z) = (x, y, z)\n  }\n\n  public func mod() -> Double {\n    (x * x + y * y + z * z).squareRoot()\n  }\n\n  public static func + (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      x: lhs.x + rhs.x,\n      y: lhs.y + rhs.y,\n      z: lhs.z + rhs.z\n    )\n  }\n\n  public static func * (lhs: Vector, rhs: Double) -> Vector {\n    return Vector(\n      x: lhs.x * rhs,\n      y: lhs.y * rhs,\n      z: lhs.z * rhs\n    )\n  }\n\n  public static func *= (lhs: inout Vector, rhs: Double) {\n    lhs.x *= rhs\n    lhs.y *= rhs\n    lhs.z *= rhs\n  }\n\n  public static func / (lhs: Vector, rhs: Double) -> Vector {\n    return lhs * (1 / rhs)\n  }\n\n  public static func /= (lhs: inout Vector, rhs: Double) {\n    lhs = lhs * (1 / rhs)\n  }\n}\n\nextension Vector: CustomStringConvertible {\n  public var description: String {\n    return String(format: \"%.6f\\t%.6f\\t%.6f\", x, y, z)\n  }\n}\n\nprivate func mulAdd(v1: Vector, x1: Double, v2: Vector, x2: Double) -> Vector {\n  return v1 * x1 + v2 * x2\n}\n\nprivate func rotate(_ i: Vector, _ j: Vector, alpha: Double) -> (Vector, Vector) {\n  return (\n    mulAdd(v1: i, x1: +cos(alpha), v2: j, x2: sin(alpha)),\n    mulAdd(v1: i, x1: -sin(alpha), v2: j, x2: cos(alpha))\n  )\n}\n\npublic func orbitalStateVectors(\n  semimajorAxis: Double,\n  eccentricity: Double,\n  inclination: Double,\n  longitudeOfAscendingNode: Double,\n  argumentOfPeriapsis: Double,\n  trueAnomaly: Double\n) -> (Vector, Vector) {\n  var i = Vector(x: 1.0, y: 0.0, z: 0.0)\n  var j = Vector(x: 0.0, y: 1.0, z: 0.0)\n  let k = Vector(x: 0.0, y: 0.0, z: 1.0)\n\n  (i, j) = rotate(i, j, alpha: longitudeOfAscendingNode)\n  (j, _) = rotate(j, k, alpha: inclination)\n  (i, j) = rotate(i, j, alpha: argumentOfPeriapsis)\n\n  let l = eccentricity == 1.0 ? 2.0 : 1.0 - eccentricity * eccentricity\n  let c = cos(trueAnomaly)\n  let s = sin(trueAnomaly)\n  let r = l / (1.0 + eccentricity * c)\n  let rPrime = s * r * r / l\n  let position = mulAdd(v1: i, x1: c, v2: j, x2: s) * r\n  var speed = mulAdd(v1: i, x1: rPrime * c - r * s, v2: j, x2: rPrime * s + r * c)\n\n  speed /= speed.mod()\n  speed *= (2.0 / r - 1.0 / semimajorAxis).squareRoot()\n\n  return (position, speed)\n}\n\nlet (position, speed) = orbitalStateVectors(\n  semimajorAxis: 1.0,\n  eccentricity: 0.1,\n  inclination: 0.0,\n  longitudeOfAscendingNode: 355.0 / (113.0 * 6.0),\n  argumentOfPeriapsis: 0.0,\n  trueAnomaly: 0.0\n)\n\nprint(\"Position: \\(position); Speed: \\(speed)\")\n", "target": "import math\n\nclass Vector:\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y, self.z + other.z)\n\n    def __mul__(self, other):\n        return Vector(self.x * other, self.y * other, self.z * other)\n\n    def __div__(self, other):\n        return Vector(self.x / other, self.y / other, self.z / other)\n\n    def __str__(self):\n        return '({x}, {y}, {z})'.format(x=self.x, y=self.y, z=self.z)\n\n    def abs(self):\n        return math.sqrt(self.x*self.x + self.y*self.y + self.z*self.z)\n\ndef mulAdd(v1, x1, v2, x2):\n    return v1 * x1 + v2 * x2\n\ndef rotate(i, j, alpha):\n    return [mulAdd(i,math.cos(alpha),j,math.sin(alpha)), mulAdd(i,-math.sin(alpha),j,math.cos(alpha))]\n\ndef orbitalStateVectors(semimajorAxis, eccentricity, inclination, longitudeOfAscendingNode, argumentOfPeriapsis, trueAnomaly):\n    i = Vector(1, 0, 0)\n    j = Vector(0, 1, 0)\n    k = Vector(0, 0, 1)\n\n    p = rotate(i, j, longitudeOfAscendingNode)\n    i = p[0]\n    j = p[1]\n    p = rotate(j, k, inclination)\n    j = p[0]\n    p  =rotate(i, j, argumentOfPeriapsis)\n    i = p[0]\n    j = p[1]\n\n    l = 2.0 if (eccentricity == 1.0) else 1.0 - eccentricity * eccentricity\n    l *= semimajorAxis\n    c = math.cos(trueAnomaly)\n    s = math.sin(trueAnomaly)\n    r = 1 / (1.0 + eccentricity * c)\n    rprime = s * r * r / l\n    position = mulAdd(i, c, j, s) * r\n    speed = mulAdd(i, rprime * c - r * s, j, rprime * s + r * c)\n    speed = speed / speed.abs()\n    speed = speed * math.sqrt(2.0 / r - 1.0 / semimajorAxis)\n\n    return [position, speed]\n\nps = orbitalStateVectors(1.0, 0.1, 0.0, 355.0 / (113.0 * 6.0), 0.0, 0.0)\nprint \"Position\u00a0:\", ps[0]\nprint \"Speed   \u00a0:\", ps[1]\n"}
{"id": 351506, "name": "ABC words", "source": "Translate Swift to Python: import Foundation\n\nfunc loadDictionary(_ path: String) throws -> [String] {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return contents.components(separatedBy: \"\\n\")\n}\n\nfunc isAbcWord(_ word: String) -> Bool {\n    var a = false\n    var b = false\n    for ch in word {\n        switch (ch) {\n        case \"a\":\n            if !a {\n                a = true\n            }\n        case \"b\":\n            if !b {\n                if !a {\n                    return false\n                }\n                b = true\n            }\n        case \"c\":\n            return b\n        default:\n            break\n        }\n    }\n    return false\n}\n\ndo {\n    let dictionary = try loadDictionary(\"unixdict.txt\")\n    var n = 1\n    for word in dictionary {\n        if isAbcWord(word) {\n            print(\"\\(n): \\(word)\")\n            n += 1\n        }\n    }\n} catch {\n    print(error)\n}\n", "target": "python -c '\nimport sys\nfor ln in sys.stdin:\n    if \"a\" in ln and ln.find(\"a\") < ln.find(\"b\") < ln.find(\"c\"):\n        print(ln.rstrip())\n' < unixdict.txt\n"}
{"id": 351507, "name": "Text between", "source": "Translate Swift to Python: import Foundation\n\npublic extension String {\n  func textBetween(_ startDelim: String, and endDelim: String) -> String {\n    precondition(!startDelim.isEmpty && !endDelim.isEmpty)\n\n    let startIdx: String.Index\n    let endIdx: String.Index\n\n    if startDelim == \"start\" {\n      startIdx = startIndex\n    } else if let r = range(of: startDelim) {\n      startIdx = r.upperBound\n    } else {\n      return \"\"\n    }\n\n    if endDelim == \"end\" {\n      endIdx = endIndex\n    } else if let r = self[startIdx...].range(of: endDelim) {\n      endIdx = r.lowerBound\n    } else {\n      endIdx = endIndex\n    }\n\n    return String(self[startIdx..<endIdx])\n  }\n}\n\nlet tests = [\n  (\"Hello Rosetta Code world\", \"Hello \", \" world\"),\n  (\"Hello Rosetta Code world\", \"start\", \" world\"),\n  (\"Hello Rosetta Code world\", \"Hello \", \"end\"),\n  (\"</div><div style=\\\"chinese\\\">\u4f60\u597d\u55ce</div>\", \"<div style=\\\"chinese\\\">\", \"</div>\"),\n  (\"<text>Hello <span>Rosetta Code</span> world</text><table style=\\\"myTable\\\">\", \"<text>\", \"<table>\"),\n  (\"<table style=\\\"myTable\\\"><tr><td>hello world</td></tr></table>\", \"<table>\", \"</table>\"),\n  (\"The quick brown fox jumps over the lazy other fox\", \"quick \", \" fox\"),\n  (\"One fish two fish red fish blue fish\", \"fish \", \" red\"),\n  (\"FooBarBazFooBuxQuux\", \"Foo\", \"Foo\")\n]\n\nfor (input, start, end) in tests {\n  print(\"Input: \\\"\\(input)\\\"\")\n  print(\"Start delimiter: \\\"\\(start)\\\"\")\n  print(\"End delimiter: \\\"\\(end)\\\"\")\n  print(\"Text between: \\\"\\(input.textBetween(start, and: end))\\\"\\n\")\n}\n", "target": "\nfrom sys import argv\n\n\n\n\n\n\ndef textBetween( thisText, startString, endString ):\n    try:\n    \tif startString is 'start':\n    \t\tstartIndex = 0\n    \telse:\n    \t\tstartIndex = thisText.index( startString ) \n    \t\n    \tif not (startIndex >= 0):\n    \t\treturn 'Start delimiter not found'\n    \telse:\n        \tif startString is not 'start':\n        \t\tstartIndex = startIndex + len( startString )\n        \n        returnText = thisText[startIndex:]\n\n\n    \tif endString is 'end':\n    \t\treturn returnText\n    \telse:\n    \t\tendIndex = returnText.index( endString )\n\n    \tif not (endIndex >= 0):\n    \t\treturn 'End delimiter not found'\n    \telse:\n        \treturnText = returnText[:endIndex]\n\n        return returnText\n    except ValueError:\n        return \"Value error\"\n\nscript, first, second, third = argv\n\nthisText = first\nstartString = second\nendString = third\n\nprint textBetween( thisText, startString, endString )\n"}
{"id": 351508, "name": "Two identical strings", "source": "Translate Swift to Python: print(\"Decimal\\tBinary\")\nvar n = 1\nwhile (true) {\n    let binary = String(n, radix: 2)\n    let i = n + (n << binary.count)\n    if i >= 1000 {\n        break\n    }\n    print(\"\\(i)\\t\\(binary)\\(binary)\")\n    n += 1\n}\n", "target": "def bits(n):\n    \n    r = 0\n    while n:\n        n >>= 1\n        r += 1\n    return r\n    \ndef concat(n):\n    \n    return n << bits(n) | n\n    \nn = 1\nwhile concat(n) <= 1000:\n    print(\"{0}: {0:b}\".format(concat(n)))\n    n += 1\n"}
{"id": 351509, "name": "Alternade words", "source": "Translate Swift to Python: import Foundation\n\nfunc loadDictionary(_ path: String) throws -> Set<String> {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return Set<String>(contents.components(separatedBy: \"\\n\").filter{!$0.isEmpty})\n}\n\nfunc lpad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : string + String(repeating: \" \", count: width - string.count)\n}\n\ndo {\n    let dictionary = try loadDictionary(\"unixdict.txt\")\n    var alternades: [(String,String,String)] = []\n    for word in dictionary {\n        if word.count < 6 {\n            continue\n        }\n        var word1 = \"\"\n        var word2 = \"\"\n        for (i, c) in word.enumerated() {\n            if (i & 1) == 0 {\n                word1.append(c)\n            } else {\n                word2.append(c)\n            }\n        }\n        if dictionary.contains(word1) && dictionary.contains(word2) {\n            alternades.append((word, word1, word2))\n        }\n    }\n    alternades.sort(by: {$0.0 < $1.0})\n    for (word, word1, word2) in alternades {\n        print(\"\\(lpad(string: word, width: 10))\\(lpad(string: word1, width: 6))\\(word2)\")\n    }\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "WORDFILE = 'unixdict.txt'\nMINLEN = 6\n\nclass Trie(object):\n    \n    class Node(object):\n        \n        def __init__(self, char='\\0', parent=None):\n            self.children = {}\n            self.char = char\n            self.final = False\n            self.parent = parent\n            \n        def descend(self, char, extend=False):\n            \n            if not char in self.children:\n                if not extend: return None\n                self.children[char] = Trie.Node(char,self)\n            return self.children[char]\n        \n    def __init__(self):\n        self.root = Trie.Node()\n    \n    def insert(self, word):\n        \n        node = self.root\n        for char in word: node = node.descend(char, extend=True)\n        node.final = True\n        return node\n    \n    def __contains__(self, word):\n        \n        node = self.root\n        for char in word:\n            node = node.descend(char)\n            if not node: return False\n        return node.final \n    \n    def words(self):\n        \n        nodes = [self.root]\n        while nodes:\n            node = nodes.pop()\n            nodes += node.children.values()\n            if node.final:\n                word = []\n                while node:\n                    if node.char != '\\0': word.append(node.char)\n                    node = node.parent\n                yield \"\".join(reversed(word))\n    \n    def __iter__(self):\n        return self.words()\n                \n\nwords = Trie()\nwith open(WORDFILE, \"rt\") as f:\n    for word in f.readlines():\n        words.insert(word.strip())\n\nfor word in words:\n    if len(word) < MINLEN: continue\n    even = word[::2]\n    odd = word[1::2]\n    if even in words and odd in words:\n        print(word, even, odd)\n"}
{"id": 351510, "name": "Alternade words", "source": "Translate Swift to Python: import Foundation\n\nfunc loadDictionary(_ path: String) throws -> Set<String> {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return Set<String>(contents.components(separatedBy: \"\\n\").filter{!$0.isEmpty})\n}\n\nfunc lpad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : string + String(repeating: \" \", count: width - string.count)\n}\n\ndo {\n    let dictionary = try loadDictionary(\"unixdict.txt\")\n    var alternades: [(String,String,String)] = []\n    for word in dictionary {\n        if word.count < 6 {\n            continue\n        }\n        var word1 = \"\"\n        var word2 = \"\"\n        for (i, c) in word.enumerated() {\n            if (i & 1) == 0 {\n                word1.append(c)\n            } else {\n                word2.append(c)\n            }\n        }\n        if dictionary.contains(word1) && dictionary.contains(word2) {\n            alternades.append((word, word1, word2))\n        }\n    }\n    alternades.sort(by: {$0.0 < $1.0})\n    for (word, word1, word2) in alternades {\n        print(\"\\(lpad(string: word, width: 10))\\(lpad(string: word1, width: 6))\\(word2)\")\n    }\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "WORDFILE = 'unixdict.txt'\nMINLEN = 6\n\nclass Trie(object):\n    \n    class Node(object):\n        \n        def __init__(self, char='\\0', parent=None):\n            self.children = {}\n            self.char = char\n            self.final = False\n            self.parent = parent\n            \n        def descend(self, char, extend=False):\n            \n            if not char in self.children:\n                if not extend: return None\n                self.children[char] = Trie.Node(char,self)\n            return self.children[char]\n        \n    def __init__(self):\n        self.root = Trie.Node()\n    \n    def insert(self, word):\n        \n        node = self.root\n        for char in word: node = node.descend(char, extend=True)\n        node.final = True\n        return node\n    \n    def __contains__(self, word):\n        \n        node = self.root\n        for char in word:\n            node = node.descend(char)\n            if not node: return False\n        return node.final \n    \n    def words(self):\n        \n        nodes = [self.root]\n        while nodes:\n            node = nodes.pop()\n            nodes += node.children.values()\n            if node.final:\n                word = []\n                while node:\n                    if node.char != '\\0': word.append(node.char)\n                    node = node.parent\n                yield \"\".join(reversed(word))\n    \n    def __iter__(self):\n        return self.words()\n                \n\nwords = Trie()\nwith open(WORDFILE, \"rt\") as f:\n    for word in f.readlines():\n        words.insert(word.strip())\n\nfor word in words:\n    if len(word) < MINLEN: continue\n    even = word[::2]\n    odd = word[1::2]\n    if even in words and odd in words:\n        print(word, even, odd)\n"}
{"id": 351511, "name": "Pythagorean triples", "source": "Translate Swift to Python: var total = 0\nvar prim = 0\nvar maxPeri = 100\n\nfunc newTri(s0:Int, _ s1:Int, _ s2: Int) -> () {\n    \n    let p = s0 + s1 + s2\n    if p <= maxPeri {\n        prim += 1\n        total += maxPeri / p\n        newTri( s0 + 2*(-s1+s2), 2*( s0+s2) - s1, 2*( s0-s1+s2) + s2)\n        newTri( s0 + 2*( s1+s2), 2*( s0+s2) + s1, 2*( s0+s1+s2) + s2)\n        newTri(-s0 + 2*( s1+s2), 2*(-s0+s2) + s1, 2*(-s0+s1+s2) + s2)\n    }\n}\n\nwhile maxPeri <= 100_000_000 {\n    prim = 0\n    total = 0\n    newTri(3, 4, 5)\n    print(\"Up to \\(maxPeri)\u00a0: \\(total) triples \\( prim) primitives.\")\n    maxPeri *= 10\n}\n", "target": "from fractions import gcd\n\n\ndef pt1(maxperimeter=100):\n    \n    trips = []\n    for a in range(1, maxperimeter):\n        aa = a*a\n        for b in range(a, maxperimeter-a+1):\n            bb = b*b\n            for c in range(b, maxperimeter-b-a+1):\n                cc = c*c\n                if a+b+c > maxperimeter or cc > aa + bb: break\n                if aa + bb == cc:\n                    trips.append((a,b,c, gcd(a, b) == 1))\n    return trips\n\ndef pytrip(trip=(3,4,5),perim=100, prim=1):\n    a0, b0, c0 = a, b, c = sorted(trip)\n    t, firstprim = set(), prim>0\n    while a + b + c <= perim:\n        t.add((a, b, c, firstprim>0))\n        a, b, c, firstprim = a+a0, b+b0, c+c0, False\n    \n    t2 = set()\n    for a, b, c, firstprim in t:\n        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7\n        if  a5 - b5 + c7 <= perim:\n            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)\n        if  a5 + b5 + c7 <= perim:\n            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)\n        if -a5 + b5 + c7 <= perim:\n            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)\n    return t | t2\n\ndef pt2(maxperimeter=100):\n    \n    trips = pytrip((3,4,5), maxperimeter, 1)\n    return trips\n\ndef printit(maxperimeter=100, pt=pt1):\n    trips = pt(maxperimeter)\n    print(\"  Up to a perimeter of %i there are %i triples, of which %i are primitive\"\n          % (maxperimeter,\n             len(trips),\n             len([prim for a,b,c,prim in trips if prim])))\n  \nfor algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):\n    print(algo.__doc__)\n    for maxperimeter in range(mn, mx+1, mn):\n        printit(maxperimeter, algo)\n"}
{"id": 351512, "name": "Pythagorean triples", "source": "Translate Swift to Python: var total = 0\nvar prim = 0\nvar maxPeri = 100\n\nfunc newTri(s0:Int, _ s1:Int, _ s2: Int) -> () {\n    \n    let p = s0 + s1 + s2\n    if p <= maxPeri {\n        prim += 1\n        total += maxPeri / p\n        newTri( s0 + 2*(-s1+s2), 2*( s0+s2) - s1, 2*( s0-s1+s2) + s2)\n        newTri( s0 + 2*( s1+s2), 2*( s0+s2) + s1, 2*( s0+s1+s2) + s2)\n        newTri(-s0 + 2*( s1+s2), 2*(-s0+s2) + s1, 2*(-s0+s1+s2) + s2)\n    }\n}\n\nwhile maxPeri <= 100_000_000 {\n    prim = 0\n    total = 0\n    newTri(3, 4, 5)\n    print(\"Up to \\(maxPeri)\u00a0: \\(total) triples \\( prim) primitives.\")\n    maxPeri *= 10\n}\n", "target": "from fractions import gcd\n\n\ndef pt1(maxperimeter=100):\n    \n    trips = []\n    for a in range(1, maxperimeter):\n        aa = a*a\n        for b in range(a, maxperimeter-a+1):\n            bb = b*b\n            for c in range(b, maxperimeter-b-a+1):\n                cc = c*c\n                if a+b+c > maxperimeter or cc > aa + bb: break\n                if aa + bb == cc:\n                    trips.append((a,b,c, gcd(a, b) == 1))\n    return trips\n\ndef pytrip(trip=(3,4,5),perim=100, prim=1):\n    a0, b0, c0 = a, b, c = sorted(trip)\n    t, firstprim = set(), prim>0\n    while a + b + c <= perim:\n        t.add((a, b, c, firstprim>0))\n        a, b, c, firstprim = a+a0, b+b0, c+c0, False\n    \n    t2 = set()\n    for a, b, c, firstprim in t:\n        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7\n        if  a5 - b5 + c7 <= perim:\n            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)\n        if  a5 + b5 + c7 <= perim:\n            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)\n        if -a5 + b5 + c7 <= perim:\n            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)\n    return t | t2\n\ndef pt2(maxperimeter=100):\n    \n    trips = pytrip((3,4,5), maxperimeter, 1)\n    return trips\n\ndef printit(maxperimeter=100, pt=pt1):\n    trips = pt(maxperimeter)\n    print(\"  Up to a perimeter of %i there are %i triples, of which %i are primitive\"\n          % (maxperimeter,\n             len(trips),\n             len([prim for a,b,c,prim in trips if prim])))\n  \nfor algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):\n    print(algo.__doc__)\n    for maxperimeter in range(mn, mx+1, mn):\n        printit(maxperimeter, algo)\n"}
{"id": 351513, "name": "Call a foreign-language function", "source": "Translate Swift to Python: import Foundation\n\nlet hello = \"Hello, World!\"\nlet fromC = strdup(hello)\nlet backToSwiftString = String.fromCString(fromC)\n", "target": "import ctypes\nlibc = ctypes.CDLL(\"/lib/libc.so.6\")\nlibc.strcmp(\"abc\", \"def\")     \nlibc.strcmp(\"hello\", \"hello\") \n"}
{"id": 351514, "name": "Extensible prime generator", "source": "Translate Swift to Python: import Foundation\n\nfunc soeDictOdds() -> UnfoldSequence<Int, Int> {\n  var bp = 5; var q = 25\n  var bps: UnfoldSequence<Int, Int>.Iterator? = nil\n  var dict = [9: 6] \n  return sequence(state: 2, next: { n in\n    if n < 9 { if n < 3 { n = 3; return 2 }; defer {n += 2}; return n }\n    while n >= q || dict[n] != nil {\n      if n >= q {\n        let inc = bp + bp\n        dict[n + inc] = inc\n        if bps == nil {\n          bps = soeDictOdds().makeIterator()\n          bp = (bps?.next())!; bp = (bps?.next())!; bp = (bps?.next())! \n        }\n        bp = (bps?.next())!; q = bp * bp \n      } else {\n        let inc = dict[n] ?? 0\n        dict[n] = nil\n        var next = n + inc\n        while dict[next] != nil { next += inc }\n        dict[next] = inc\n      }\n      n += 2\n    }\n    defer { n += 2 }; return n\n  })\n}\n\nprint(\"The first 20 primes are:  \", terminator: \"\")\nsoeDictOdds().lazy.prefix(20).forEach { print($0, \"\", terminator: \"\") }\nprint()\n\nprint(\"The primes between 100 and 150 are:  \", terminator: \"\")\nsoeDictOdds().lazy.drop(while: { $0 < Prime(100) }).lazy.prefix(while: { $0 <= 150 })\n    .forEach { print($0, \"\", terminator: \"\") }\nprint()\n\nprint(\"The number of primes from 7700 to 8000 is \u00a0:\", terminator: \"\")\nprint(soeDictOdds().lazy.drop(while: { $0 < 7700 }).lazy.prefix(while: { $0 <= 8000 })\n        .lazy.reduce(0, { a, _ in a + 1 }))\n\nprint(\"The 10,000th prime is:  \", terminator: \"\")\nprint((soeDictOdds().lazy.dropFirst(9999).first { $0 == $0 })!)\n\nprint(\"The sum of primes to 2 million is:  \", terminator: \"\")\n\nlet start = NSDate()\nlet answr = soeDictOdds().lazy.prefix(while: { $0 <= 2000000 })\n              .reduce(0, { a, p in a + Int64(p) })\nlet elpsd = -start.timeIntervalSinceNow\n\nprint(answr)\nprint(String(format: \"This test took\u00a0%.3f milliseconds.\", elpsd * 1000))\n", "target": "islice(count(7), 0, None, 2)\n"}
{"id": 351515, "name": "Flipping bits game", "source": "Translate Swift to Python: import Foundation\n\nstruct Board: Equatable, CustomStringConvertible {\n    let size: Int\n    private var tiles: [Bool]\n\n    init(size: Int) {\n        self.size = size\n        tiles = Array(count: size * size, repeatedValue: false)\n    }\n\n    subscript(x: Int, y: Int) -> Bool {\n        get {\n            return tiles[y * size + x]\n        }\n        set {\n            tiles[y * size + x] = newValue\n        }\n    }\n\n    mutating func randomize() {\n        for i in 0..<tiles.count {\n            tiles[i] = Bool(random() % 2)\n        }\n    }\n\n    mutating func flipRow(row: Int) {\n        for i in 0..<size {\n            self[row, i] = !self[row, i]\n        }\n    }\n\n    mutating func flipColumn(column: Int) {\n        for i in 0..<size {\n            self[i, column] = !self[i, column]\n        }\n    }\n\n    var description: String {\n        var desc = \"\\n\\ta\\tb\\tc\\n\"\n        for i in 0..<size {\n            desc += \"\\(i+1):\\t\"\n            for j in 0..<size {\n                desc += \"\\(Int(self[i, j]))\\t\"\n            }\n            desc += \"\\n\"\n        }\n\n        return desc\n    }\n}\n\nfunc ==(lhs: Board, rhs: Board) -> Bool {\n    return lhs.tiles == rhs.tiles\n}\n\nclass FlippingGame: CustomStringConvertible {\n\n    var board: Board\n    var target: Board\n    var solved: Bool { return board == target }\n\n    init(boardSize: Int) {\n        target = Board(size: 3)\n        board = Board(size: 3)\n        generateTarget()\n    }\n\n    func generateTarget() {\n        target.randomize()\n        board = target\n        let size = board.size\n        while solved {\n            for _ in 0..<size + (random() % size + 1) {\n                if random() % 2 == 0 {\n                    board.flipColumn(random() % size)\n                }\n                else {\n                    board.flipRow(random() % size)\n                }\n            }\n        }\n    }\n\n    func getMove() -> Bool {\n        print(self)\n        print(\"Flip what? \", terminator: \"\")\n\n        guard\n            let move = readLine(stripNewline: true)\n            where move.characters.count == 1\n            else { return false }\n\n        var moveValid = true\n\n        if let row = Int(move) {\n            board.flipRow(row - 1)\n        }\n        else if let column = move.lowercaseString.utf8.first where column < 100 && column > 96  {\n            board.flipColumn(numericCast(column) - 97)\n        }\n        else {\n            moveValid = false\n        }\n\n        return moveValid\n    }\n\n    var description: String {\n        var str = \"\"\n        print(\"Target: \\n \\(target)\", toStream: &str)\n        print(\"Board: \\n \\(board)\", toStream: &str)\n\n        return str\n    }\n}\n\nfunc playGame(game: FlippingGame) -> String {\n    game.generateTarget()\n    var numMoves = 0\n    while !game.solved {\n        numMoves++\n        print(\"Move #\\(numMoves)\")\n        while !game.getMove() {}\n    }\n    print(\"You win!\")\n    print(\"Number of moves: \\(numMoves)\")\n    print(\"\\n\\nPlay Again? \", terminator: \"\")\n\n    return readLine(stripNewline: true)!.lowercaseString\n}\n\nlet game = FlippingGame(boardSize: 3)\nrepeat { } while playGame(game) == \"y\"\n", "target": "\n\nfrom random import randrange\nfrom copy import deepcopy\nfrom string import ascii_lowercase\n\n\ntry:    \n    input = raw_input\nexcept:\n    pass\n\nN = 3   \n\nboard  = [[0]* N for i in range(N)]\n\ndef setbits(board, count=1):\n    for i in range(count):\n        board[randrange(N)][randrange(N)] ^= 1\n\ndef shuffle(board, count=1):\n    for i in range(count):\n        if randrange(0, 2):\n            fliprow(randrange(N))\n        else:\n            flipcol(randrange(N))\n\n\ndef pr(board, comment=''):\n    print(str(comment))\n    print('     ' + ' '.join(ascii_lowercase[i] for i in range(N)))\n    print('  ' + '\\n  '.join(' '.join(['%2s' % j] + [str(i) for i in line])\n                             for j, line in enumerate(board, 1)))\n\ndef init(board):\n    setbits(board, count=randrange(N)+1)\n    target = deepcopy(board)\n    while board == target:\n        shuffle(board, count=2 * N)\n    prompt = '  X, T, or 1-%i / %s-%s to flip: ' % (N, ascii_lowercase[0], \n                                                    ascii_lowercase[N-1])\n    return target, prompt\n\ndef fliprow(i):\n    board[i-1][:] = [x ^ 1 for x in board[i-1] ]\n    \ndef flipcol(i):\n    for row in board:\n        row[i] ^= 1\n\nif __name__ == '__main__':\n    print(__doc__ % (N, N))\n    target, prompt = init(board)\n    pr(target, 'Target configuration is:')\n    print('')\n    turns = 0\n    while board != target:\n        turns += 1\n        pr(board, '%i:' % turns)\n        ans = input(prompt).strip()\n        if (len(ans) == 1 \n            and ans in ascii_lowercase and ascii_lowercase.index(ans) < N):\n            flipcol(ascii_lowercase.index(ans))\n        elif ans and all(ch in '0123456789' for ch in ans) and 1 <= int(ans) <= N:\n            fliprow(int(ans))\n        elif ans == 'T':\n            pr(target, 'Target configuration is:')\n            turns -= 1\n        elif ans == 'X':\n            break\n        else:\n            print(\"  I don't understand %r... Try again. \"\n                  \"(X to exit or T to show target)\\n\" % ans[:9])\n            turns -= 1\n    else:\n        print('\\nWell done!\\nBye.')\n"}
{"id": 351516, "name": "Flipping bits game", "source": "Translate Swift to Python: import Foundation\n\nstruct Board: Equatable, CustomStringConvertible {\n    let size: Int\n    private var tiles: [Bool]\n\n    init(size: Int) {\n        self.size = size\n        tiles = Array(count: size * size, repeatedValue: false)\n    }\n\n    subscript(x: Int, y: Int) -> Bool {\n        get {\n            return tiles[y * size + x]\n        }\n        set {\n            tiles[y * size + x] = newValue\n        }\n    }\n\n    mutating func randomize() {\n        for i in 0..<tiles.count {\n            tiles[i] = Bool(random() % 2)\n        }\n    }\n\n    mutating func flipRow(row: Int) {\n        for i in 0..<size {\n            self[row, i] = !self[row, i]\n        }\n    }\n\n    mutating func flipColumn(column: Int) {\n        for i in 0..<size {\n            self[i, column] = !self[i, column]\n        }\n    }\n\n    var description: String {\n        var desc = \"\\n\\ta\\tb\\tc\\n\"\n        for i in 0..<size {\n            desc += \"\\(i+1):\\t\"\n            for j in 0..<size {\n                desc += \"\\(Int(self[i, j]))\\t\"\n            }\n            desc += \"\\n\"\n        }\n\n        return desc\n    }\n}\n\nfunc ==(lhs: Board, rhs: Board) -> Bool {\n    return lhs.tiles == rhs.tiles\n}\n\nclass FlippingGame: CustomStringConvertible {\n\n    var board: Board\n    var target: Board\n    var solved: Bool { return board == target }\n\n    init(boardSize: Int) {\n        target = Board(size: 3)\n        board = Board(size: 3)\n        generateTarget()\n    }\n\n    func generateTarget() {\n        target.randomize()\n        board = target\n        let size = board.size\n        while solved {\n            for _ in 0..<size + (random() % size + 1) {\n                if random() % 2 == 0 {\n                    board.flipColumn(random() % size)\n                }\n                else {\n                    board.flipRow(random() % size)\n                }\n            }\n        }\n    }\n\n    func getMove() -> Bool {\n        print(self)\n        print(\"Flip what? \", terminator: \"\")\n\n        guard\n            let move = readLine(stripNewline: true)\n            where move.characters.count == 1\n            else { return false }\n\n        var moveValid = true\n\n        if let row = Int(move) {\n            board.flipRow(row - 1)\n        }\n        else if let column = move.lowercaseString.utf8.first where column < 100 && column > 96  {\n            board.flipColumn(numericCast(column) - 97)\n        }\n        else {\n            moveValid = false\n        }\n\n        return moveValid\n    }\n\n    var description: String {\n        var str = \"\"\n        print(\"Target: \\n \\(target)\", toStream: &str)\n        print(\"Board: \\n \\(board)\", toStream: &str)\n\n        return str\n    }\n}\n\nfunc playGame(game: FlippingGame) -> String {\n    game.generateTarget()\n    var numMoves = 0\n    while !game.solved {\n        numMoves++\n        print(\"Move #\\(numMoves)\")\n        while !game.getMove() {}\n    }\n    print(\"You win!\")\n    print(\"Number of moves: \\(numMoves)\")\n    print(\"\\n\\nPlay Again? \", terminator: \"\")\n\n    return readLine(stripNewline: true)!.lowercaseString\n}\n\nlet game = FlippingGame(boardSize: 3)\nrepeat { } while playGame(game) == \"y\"\n", "target": "\n\nfrom random import randrange\nfrom copy import deepcopy\nfrom string import ascii_lowercase\n\n\ntry:    \n    input = raw_input\nexcept:\n    pass\n\nN = 3   \n\nboard  = [[0]* N for i in range(N)]\n\ndef setbits(board, count=1):\n    for i in range(count):\n        board[randrange(N)][randrange(N)] ^= 1\n\ndef shuffle(board, count=1):\n    for i in range(count):\n        if randrange(0, 2):\n            fliprow(randrange(N))\n        else:\n            flipcol(randrange(N))\n\n\ndef pr(board, comment=''):\n    print(str(comment))\n    print('     ' + ' '.join(ascii_lowercase[i] for i in range(N)))\n    print('  ' + '\\n  '.join(' '.join(['%2s' % j] + [str(i) for i in line])\n                             for j, line in enumerate(board, 1)))\n\ndef init(board):\n    setbits(board, count=randrange(N)+1)\n    target = deepcopy(board)\n    while board == target:\n        shuffle(board, count=2 * N)\n    prompt = '  X, T, or 1-%i / %s-%s to flip: ' % (N, ascii_lowercase[0], \n                                                    ascii_lowercase[N-1])\n    return target, prompt\n\ndef fliprow(i):\n    board[i-1][:] = [x ^ 1 for x in board[i-1] ]\n    \ndef flipcol(i):\n    for row in board:\n        row[i] ^= 1\n\nif __name__ == '__main__':\n    print(__doc__ % (N, N))\n    target, prompt = init(board)\n    pr(target, 'Target configuration is:')\n    print('')\n    turns = 0\n    while board != target:\n        turns += 1\n        pr(board, '%i:' % turns)\n        ans = input(prompt).strip()\n        if (len(ans) == 1 \n            and ans in ascii_lowercase and ascii_lowercase.index(ans) < N):\n            flipcol(ascii_lowercase.index(ans))\n        elif ans and all(ch in '0123456789' for ch in ans) and 1 <= int(ans) <= N:\n            fliprow(int(ans))\n        elif ans == 'T':\n            pr(target, 'Target configuration is:')\n            turns -= 1\n        elif ans == 'X':\n            break\n        else:\n            print(\"  I don't understand %r... Try again. \"\n                  \"(X to exit or T to show target)\\n\" % ans[:9])\n            turns -= 1\n    else:\n        print('\\nWell done!\\nBye.')\n"}
{"id": 351517, "name": "Gray code", "source": "Translate Swift to Python: func grayEncode(_ i: Int) -> Int {\n  return (i >> 1) ^ i\n}\n\nfunc grayDecode(_ i: Int) -> Int {\n  switch i {\n  case 0:\n    return 0\n  case _:\n    return i ^ grayDecode(i >> 1)\n  }\n}\n\nfor i in 0..<32 {\n  let iStr = String(i, radix: 2)\n  let encode = grayEncode(i)\n  let encodeStr = String(encode, radix: 2)\n  let decode = grayDecode(encode)\n  let decodeStr = String(decode, radix: 2)\n\n  print(\"\\(i) (\\(iStr)) => \\(encode) (\\(encodeStr)) => \\(decode) (\\(decodeStr))\")\n}\n", "target": ">>> def int2bin(n):\n\t'From positive integer to list of binary bits, msb at index 0'\n\tif n:\n\t\tbits = []\n\t\twhile n:\n\t\t\tn,remainder = divmod(n, 2)\n\t\t\tbits.insert(0, remainder)\n\t\treturn bits\n\telse: return [0]\n\n\t\n>>> def bin2int(bits):\n\t'From binary bits, msb at index 0 to integer'\n\ti = 0\n\tfor bit in bits:\n\t\ti = i * 2 + bit\n\treturn i\n"}
{"id": 351518, "name": "Gray code", "source": "Translate Swift to Python: func grayEncode(_ i: Int) -> Int {\n  return (i >> 1) ^ i\n}\n\nfunc grayDecode(_ i: Int) -> Int {\n  switch i {\n  case 0:\n    return 0\n  case _:\n    return i ^ grayDecode(i >> 1)\n  }\n}\n\nfor i in 0..<32 {\n  let iStr = String(i, radix: 2)\n  let encode = grayEncode(i)\n  let encodeStr = String(encode, radix: 2)\n  let decode = grayDecode(encode)\n  let decodeStr = String(decode, radix: 2)\n\n  print(\"\\(i) (\\(iStr)) => \\(encode) (\\(encodeStr)) => \\(decode) (\\(decodeStr))\")\n}\n", "target": ">>> def int2bin(n):\n\t'From positive integer to list of binary bits, msb at index 0'\n\tif n:\n\t\tbits = []\n\t\twhile n:\n\t\t\tn,remainder = divmod(n, 2)\n\t\t\tbits.insert(0, remainder)\n\t\treturn bits\n\telse: return [0]\n\n\t\n>>> def bin2int(bits):\n\t'From binary bits, msb at index 0 to integer'\n\ti = 0\n\tfor bit in bits:\n\t\ti = i * 2 + bit\n\treturn i\n"}
{"id": 351519, "name": "Extreme floating point values", "source": "Translate Swift to Python: let negInf = -1.0 / 0.0\nlet inf = 1.0 / 0.0 \nlet nan = 0.0 / 0.0 \nlet negZero = -2.0 / inf\n\nprintln(\"Negative inf: \\(negInf)\")\nprintln(\"Positive inf: \\(inf)\")\nprintln(\"NaN: \\(nan)\")\nprintln(\"Negative 0: \\(negZero)\")\nprintln(\"inf + -inf: \\(inf + negInf)\")\nprintln(\"0 * NaN: \\(0 * nan)\")\nprintln(\"NaN == NaN: \\(nan == nan)\")\n", "target": ">>> \n>>> inf = 1e234 * 1e234\n>>> _inf = 1e234 * -1e234\n>>> _zero = 1 / _inf\n>>> nan = inf + _inf\n>>> inf, _inf, _zero, nan\n(inf, -inf, -0.0, nan)\n>>> \n>>> for value in (inf, _inf, _zero, nan): print (value)\n\ninf\n-inf\n-0.0\nnan\n>>> \n>>> float('nan')\nnan\n>>> float('inf')\ninf\n>>> float('-inf')\n-inf\n>>> -0.\n-0.0\n>>> \n>>> nan == nan\nFalse\n>>> nan is nan\nTrue\n>>> 0. == -0.\nTrue\n>>> 0. is -0.\nFalse\n>>> inf + _inf\nnan\n>>> 0.0 * nan\nnan\n>>> nan * 0.0\nnan\n>>> 0.0 * inf\nnan\n>>> inf * 0.0\nnan\n"}
{"id": 351520, "name": "Extreme floating point values", "source": "Translate Swift to Python: let negInf = -1.0 / 0.0\nlet inf = 1.0 / 0.0 \nlet nan = 0.0 / 0.0 \nlet negZero = -2.0 / inf\n\nprintln(\"Negative inf: \\(negInf)\")\nprintln(\"Positive inf: \\(inf)\")\nprintln(\"NaN: \\(nan)\")\nprintln(\"Negative 0: \\(negZero)\")\nprintln(\"inf + -inf: \\(inf + negInf)\")\nprintln(\"0 * NaN: \\(0 * nan)\")\nprintln(\"NaN == NaN: \\(nan == nan)\")\n", "target": ">>> \n>>> inf = 1e234 * 1e234\n>>> _inf = 1e234 * -1e234\n>>> _zero = 1 / _inf\n>>> nan = inf + _inf\n>>> inf, _inf, _zero, nan\n(inf, -inf, -0.0, nan)\n>>> \n>>> for value in (inf, _inf, _zero, nan): print (value)\n\ninf\n-inf\n-0.0\nnan\n>>> \n>>> float('nan')\nnan\n>>> float('inf')\ninf\n>>> float('-inf')\n-inf\n>>> -0.\n-0.0\n>>> \n>>> nan == nan\nFalse\n>>> nan is nan\nTrue\n>>> 0. == -0.\nTrue\n>>> 0. is -0.\nFalse\n>>> inf + _inf\nnan\n>>> 0.0 * nan\nnan\n>>> nan * 0.0\nnan\n>>> 0.0 * inf\nnan\n>>> inf * 0.0\nnan\n"}
{"id": 351521, "name": "Knuth's algorithm S", "source": "Translate Swift to Python: import Darwin\n\nfunc s_of_n_creator<T>(n: Int) -> T -> [T]  {\n  var sample = [T]()\n  var i = 0\n  return {(item: T) in\n    i++\n    if (i <= n) {\n      sample.append(item)\n    } else if (Int(arc4random_uniform(UInt32(i))) < n) {\n      sample[Int(arc4random_uniform(UInt32(n)))] = item\n    }\n    return sample\n  }\n}\n\nvar bin = [Int](count:10, repeatedValue:0)\nfor trial in 0..<100000 {\n  let s_of_n: Int -> [Int] = s_of_n_creator(3)\n  var sample: [Int] = []\n  for i in 0..<10 {\n    sample = s_of_n(i)\n  }\n  for s in sample {\n    bin[s]++\n  }\n}\nprintln(bin)\n", "target": "from random import randrange\n\ndef s_of_n_creator(n):\n    sample, i = [], 0\n    def s_of_n(item):\n        nonlocal i\n\n        i += 1\n        if i <= n:\n            \n            sample.append(item)\n        elif randrange(i) < n:\n            \n            sample[randrange(n)] = item\n        return sample\n    return s_of_n\n\nif __name__ == '__main__':\n    bin = [0]* 10\n    items = range(10)\n    print(\"Single run samples for n = 3:\")\n    s_of_n = s_of_n_creator(3)\n    for item in items:\n        sample = s_of_n(item)\n        print(\"  Item: %i -> sample: %s\" % (item, sample))\n    \n    for trial in range(100000):\n        s_of_n = s_of_n_creator(3)\n        for item in items:\n            sample = s_of_n(item)\n        for s in sample:\n            bin[s] += 1\n    print(\"\\nTest item frequencies for 100000 runs:\\n \",\n          '\\n  '.join(\"%i:%i\" % x for x in enumerate(bin)))\n"}
{"id": 351522, "name": "Knuth's algorithm S", "source": "Translate Swift to Python: import Darwin\n\nfunc s_of_n_creator<T>(n: Int) -> T -> [T]  {\n  var sample = [T]()\n  var i = 0\n  return {(item: T) in\n    i++\n    if (i <= n) {\n      sample.append(item)\n    } else if (Int(arc4random_uniform(UInt32(i))) < n) {\n      sample[Int(arc4random_uniform(UInt32(n)))] = item\n    }\n    return sample\n  }\n}\n\nvar bin = [Int](count:10, repeatedValue:0)\nfor trial in 0..<100000 {\n  let s_of_n: Int -> [Int] = s_of_n_creator(3)\n  var sample: [Int] = []\n  for i in 0..<10 {\n    sample = s_of_n(i)\n  }\n  for s in sample {\n    bin[s]++\n  }\n}\nprintln(bin)\n", "target": "from random import randrange\n\ndef s_of_n_creator(n):\n    sample, i = [], 0\n    def s_of_n(item):\n        nonlocal i\n\n        i += 1\n        if i <= n:\n            \n            sample.append(item)\n        elif randrange(i) < n:\n            \n            sample[randrange(n)] = item\n        return sample\n    return s_of_n\n\nif __name__ == '__main__':\n    bin = [0]* 10\n    items = range(10)\n    print(\"Single run samples for n = 3:\")\n    s_of_n = s_of_n_creator(3)\n    for item in items:\n        sample = s_of_n(item)\n        print(\"  Item: %i -> sample: %s\" % (item, sample))\n    \n    for trial in range(100000):\n        s_of_n = s_of_n_creator(3)\n        for item in items:\n            sample = s_of_n(item)\n        for s in sample:\n            bin[s] += 1\n    print(\"\\nTest item frequencies for 100000 runs:\\n \",\n          '\\n  '.join(\"%i:%i\" % x for x in enumerate(bin)))\n"}
{"id": 351523, "name": "Cousin primes", "source": "Translate Swift to Python: import Foundation\n\nfunc primeSieve(limit: Int) -> [Bool] {\n    guard limit > 0 else {\n        return []\n    }\n    var sieve = Array(repeating: true, count: limit)\n    sieve[0] = false\n    if limit > 1 {\n        sieve[1] = false\n    }\n    if limit > 4 {\n        for i in stride(from: 4, to: limit, by: 2) {\n            sieve[i] = false\n        }\n    }\n    var p = 3\n    var sq = p * p\n    while sq < limit {\n        if sieve[p] {\n            for i in stride(from: sq, to: limit, by: p * 2) {\n                sieve[i] = false\n            }\n        }\n        sq += (p + 1) * 4;\n        p += 2\n    }\n    return sieve\n}\n\nfunc toString(_ number: Int) -> String {\n    return String(format: \"%3d\", number)\n}\n\nlet limit = 1000\nlet sieve = primeSieve(limit: limit)\nvar count = 0\nfor p in 0..<limit - 4 {\n    if sieve[p] && sieve[p + 4] {\n        print(\"(\\(toString(p)), \\(toString(p + 4)))\", terminator: \"\")\n        count += 1\n        print(count % 5 == 0 ? \"\\n\" : \" \", terminator: \"\")\n    }\n}\nprint(\"\\nNumber of cousin prime pairs < \\(limit): \\(count)\")\n", "target": "\n\nfrom itertools import chain, takewhile\n\n\n\ndef cousinPrimes():\n    \n    def go(x):\n        n = 4 + x\n        return [(x, n)] if isPrime(n) else []\n\n    return chain.from_iterable(\n        map(go, primes())\n    )\n\n\n\n\ndef main():\n    \n\n    pairs = list(\n        takewhile(\n            lambda ab: 1000 > ab[1],\n            cousinPrimes()\n        )\n    )\n\n    print(f'{len(pairs)} cousin pairs below 1000:\\n')\n    print(\n        spacedTable(list(\n            chunksOf(4)([\n                repr(x) for x in pairs\n            ])\n        ))\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef listTranspose(xss):\n    \n    def go(xss):\n        if xss:\n            h, *t = xss\n            return (\n                [[h[0]] + [xs[0] for xs in t if xs]] + (\n                    go([h[1:]] + [xs[1:] for xs in t])\n                )\n            ) if h and isinstance(h, list) else go(t)\n        else:\n            return []\n    return go(xss)\n\n\n\ndef spacedTable(rows):\n    \n    columnWidths = [\n        len(str(row[-1])) for row in listTranspose(rows)\n    ]\n    return '\\n'.join([\n        ' '.join(\n            map(\n                lambda w, s: s.rjust(w, ' '),\n                columnWidths, row\n            )\n        ) for row in rows\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351524, "name": "Cousin primes", "source": "Translate Swift to Python: import Foundation\n\nfunc primeSieve(limit: Int) -> [Bool] {\n    guard limit > 0 else {\n        return []\n    }\n    var sieve = Array(repeating: true, count: limit)\n    sieve[0] = false\n    if limit > 1 {\n        sieve[1] = false\n    }\n    if limit > 4 {\n        for i in stride(from: 4, to: limit, by: 2) {\n            sieve[i] = false\n        }\n    }\n    var p = 3\n    var sq = p * p\n    while sq < limit {\n        if sieve[p] {\n            for i in stride(from: sq, to: limit, by: p * 2) {\n                sieve[i] = false\n            }\n        }\n        sq += (p + 1) * 4;\n        p += 2\n    }\n    return sieve\n}\n\nfunc toString(_ number: Int) -> String {\n    return String(format: \"%3d\", number)\n}\n\nlet limit = 1000\nlet sieve = primeSieve(limit: limit)\nvar count = 0\nfor p in 0..<limit - 4 {\n    if sieve[p] && sieve[p + 4] {\n        print(\"(\\(toString(p)), \\(toString(p + 4)))\", terminator: \"\")\n        count += 1\n        print(count % 5 == 0 ? \"\\n\" : \" \", terminator: \"\")\n    }\n}\nprint(\"\\nNumber of cousin prime pairs < \\(limit): \\(count)\")\n", "target": "\n\nfrom itertools import chain, takewhile\n\n\n\ndef cousinPrimes():\n    \n    def go(x):\n        n = 4 + x\n        return [(x, n)] if isPrime(n) else []\n\n    return chain.from_iterable(\n        map(go, primes())\n    )\n\n\n\n\ndef main():\n    \n\n    pairs = list(\n        takewhile(\n            lambda ab: 1000 > ab[1],\n            cousinPrimes()\n        )\n    )\n\n    print(f'{len(pairs)} cousin pairs below 1000:\\n')\n    print(\n        spacedTable(list(\n            chunksOf(4)([\n                repr(x) for x in pairs\n            ])\n        ))\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef listTranspose(xss):\n    \n    def go(xss):\n        if xss:\n            h, *t = xss\n            return (\n                [[h[0]] + [xs[0] for xs in t if xs]] + (\n                    go([h[1:]] + [xs[1:] for xs in t])\n                )\n            ) if h and isinstance(h, list) else go(t)\n        else:\n            return []\n    return go(xss)\n\n\n\ndef spacedTable(rows):\n    \n    columnWidths = [\n        len(str(row[-1])) for row in listTranspose(rows)\n    ]\n    return '\\n'.join([\n        ' '.join(\n            map(\n                lambda w, s: s.rjust(w, ' '),\n                columnWidths, row\n            )\n        ) for row in rows\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351525, "name": "Return multiple values", "source": "Translate Swift to Python: func addsub(x: Int, y: Int) -> (Int, Int) {\n  return (x + y, x - y)\n}\n", "target": "def addsub(x, y):\n  return x + y, x - y\n"}
{"id": 351526, "name": "Change e letters to i in words", "source": "Translate Swift to Python: import Foundation\n\nfunc loadDictionary(path: String, minLength: Int) throws -> Set<String> {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return Set<String>(contents.components(separatedBy: \"\\n\").filter{$0.count >= minLength})\n}\n\nfunc pad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : string + String(repeating: \" \", count: width - string.count)\n}\n\ndo {\n    let dictionary = try loadDictionary(path: \"unixdict.txt\", minLength: 6)\n    var words: [(String,String)] = []\n    for word1 in dictionary {\n        let word2 = word1.replacingOccurrences(of: \"e\", with: \"i\")\n        if word1 != word2 && dictionary.contains(word2) {\n            words.append((word1, word2))\n        }\n    }\n    words.sort(by: {$0 < $1})\n    for (n, (word1, word2)) in words.enumerated() {\n        print(String(format: \"%2d.\u00a0%@ ->\u00a0%@\", n + 1, pad(string: word1, width: 10), word2))\n    }\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "\n\n\n\ndef ieTwins(s):\n    \n    longWords = [\n        w for w in s.splitlines()\n        if 5 < len(w)\n    ]\n    lexicon = {\n        w for w in longWords\n        if 'i' in w\n    }\n\n    return [\n        (w, twin) for w in longWords\n        if 'e' in w and (\n            twin := w.replace('e', 'i')\n        ) in lexicon\n    ]\n\n\n\n\ndef main():\n    \n    for pair in ieTwins(\n        readFile(\"unixdict.txt\")\n    ):\n        print(pair)\n\n\n\n\n\ndef readFile(fp):\n    \n    with open(fp, 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351527, "name": "Change e letters to i in words", "source": "Translate Swift to Python: import Foundation\n\nfunc loadDictionary(path: String, minLength: Int) throws -> Set<String> {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return Set<String>(contents.components(separatedBy: \"\\n\").filter{$0.count >= minLength})\n}\n\nfunc pad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : string + String(repeating: \" \", count: width - string.count)\n}\n\ndo {\n    let dictionary = try loadDictionary(path: \"unixdict.txt\", minLength: 6)\n    var words: [(String,String)] = []\n    for word1 in dictionary {\n        let word2 = word1.replacingOccurrences(of: \"e\", with: \"i\")\n        if word1 != word2 && dictionary.contains(word2) {\n            words.append((word1, word2))\n        }\n    }\n    words.sort(by: {$0 < $1})\n    for (n, (word1, word2)) in words.enumerated() {\n        print(String(format: \"%2d.\u00a0%@ ->\u00a0%@\", n + 1, pad(string: word1, width: 10), word2))\n    }\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "\n\n\n\ndef ieTwins(s):\n    \n    longWords = [\n        w for w in s.splitlines()\n        if 5 < len(w)\n    ]\n    lexicon = {\n        w for w in longWords\n        if 'i' in w\n    }\n\n    return [\n        (w, twin) for w in longWords\n        if 'e' in w and (\n            twin := w.replace('e', 'i')\n        ) in lexicon\n    ]\n\n\n\n\ndef main():\n    \n    for pair in ieTwins(\n        readFile(\"unixdict.txt\")\n    ):\n        print(pair)\n\n\n\n\n\ndef readFile(fp):\n    \n    with open(fp, 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 351528, "name": "Substring_Top and tail", "source": "Translate Swift to Python: let txt = \"0123456789\"\nprintln(dropFirst(txt))\nprintln(dropLast(txt))\nprintln(dropFirst(dropLast(txt)))\n", "target": "print \"knight\"[1:]     \nprint \"socks\"[:-1]     \nprint \"brooms\"[1:-1]   \n"}
{"id": 351529, "name": "Substring_Top and tail", "source": "Translate Swift to Python: let txt = \"0123456789\"\nprintln(dropFirst(txt))\nprintln(dropLast(txt))\nprintln(dropFirst(dropLast(txt)))\n", "target": "print \"knight\"[1:]     \nprint \"socks\"[:-1]     \nprint \"brooms\"[1:-1]   \n"}
{"id": 351530, "name": "LZW compression", "source": "Translate Swift to Python: class LZW {\n    class func compress(_ uncompressed:String) -> [Int] {\n        var dict = [String : Int]()\n\n        for i in 0 ..< 256 {\n            let s = String(Unicode.Scalar(UInt8(i)))\n            dict[s] = i\n        }\n\n        var dictSize = 256\n        var w = \"\"\n        var result = [Int]()\n        for c in uncompressed {\n            let wc = w + String(c)\n            if dict[wc] != nil {\n                w = wc\n            } else {\n                result.append(dict[w]!)\n                dict[wc] = dictSize\n                dictSize += 1 \n                w = String(c)\n            }\n        }\n\n        if w != \"\" {\n            result.append(dict[w]!)\n        }\n        return result\n    }\n\n    class func decompress(_ compressed:[Int]) -> String? {\n        var dict = [Int : String]()\n\n        for i in 0 ..< 256 {\n            dict[i] = String(Unicode.Scalar(UInt8(i)))\n        }\n\n        var dictSize = 256\n        var w = String(Unicode.Scalar(UInt8(compressed[0])))\n        var result = w\n        for k in compressed[1 ..< compressed.count] {\n            let entry : String\n            if let x = dict[k] {\n                entry = x\n            } else if k == dictSize {\n                entry = w + String(w[w.startIndex])\n            } else {\n                return nil\n            }\n\n            result += entry\n            dict[dictSize] = w + String(entry[entry.startIndex])\n            dictSize += 1\n            w = entry\n        }\n        return result\n    }\n}\n\nlet comp = LZW.compress(\"TOBEORNOTTOBEORTOBEORNOT\")\nprint(comp)\n\nif let decomp = LZW.decompress(comp) {\n    print(decomp)\n}\n", "target": "def compress(uncompressed):\n    \n\n    \n    dict_size = 256\n    dictionary = dict((chr(i), i) for i in range(dict_size))\n    \n\n    w = \"\"\n    result = []\n    for c in uncompressed:\n        wc = w + c\n        if wc in dictionary:\n            w = wc\n        else:\n            result.append(dictionary[w])\n            \n            dictionary[wc] = dict_size\n            dict_size += 1\n            w = c\n\n    \n    if w:\n        result.append(dictionary[w])\n    return result\n\n\ndef decompress(compressed):\n    \n    from io import StringIO\n\n    \n    dict_size = 256\n    dictionary = dict((i, chr(i)) for i in range(dict_size))\n    \n\n    \n    \n    result = StringIO()\n    w = chr(compressed.pop(0))\n    result.write(w)\n    for k in compressed:\n        if k in dictionary:\n            entry = dictionary[k]\n        elif k == dict_size:\n            entry = w + w[0]\n        else:\n            raise ValueError('Bad compressed k: %s' % k)\n        result.write(entry)\n\n        \n        dictionary[dict_size] = w + entry[0]\n        dict_size += 1\n\n        w = entry\n    return result.getvalue()\n\n\n\ncompressed = compress('TOBEORNOTTOBEORTOBEORNOT')\nprint (compressed)\ndecompressed = decompress(compressed)\nprint (decompressed)\n"}
{"id": 351531, "name": "Bioinformatics_base count", "source": "Translate Swift to Python: import Foundation\n\nlet dna = \"\"\"\n          CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\n          CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\n          AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\n          GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\n          CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\n          TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\n          TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\n          CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\n          TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\n          GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\n          \"\"\"\n\nprint(\"input:\\n\\(dna)\\n\")\n\nlet counts =\n  dna.replacingOccurrences(of: \"\\n\", with: \"\").reduce(into: [:], { $0[$1, default: 0] += 1 })\n\nprint(\"Counts: \\(counts)\")\nprint(\"Total: \\(counts.values.reduce(0, +))\")\n", "target": "from collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n    \nif __name__ == '__main__':\n    print(\"SEQUENCE:\")\n    sequence = \n    seq_pp(sequence)\n"}
{"id": 351532, "name": "Bioinformatics_base count", "source": "Translate Swift to Python: import Foundation\n\nlet dna = \"\"\"\n          CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\n          CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\n          AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\n          GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\n          CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\n          TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\n          TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\n          CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\n          TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\n          GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\n          \"\"\"\n\nprint(\"input:\\n\\(dna)\\n\")\n\nlet counts =\n  dna.replacingOccurrences(of: \"\\n\", with: \"\").reduce(into: [:], { $0[$1, default: 0] += 1 })\n\nprint(\"Counts: \\(counts)\")\nprint(\"Total: \\(counts.values.reduce(0, +))\")\n", "target": "from collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n    \nif __name__ == '__main__':\n    print(\"SEQUENCE:\")\n    sequence = \n    seq_pp(sequence)\n"}
{"id": 351533, "name": "Fibonacci word", "source": "Translate Swift to Python: import Foundation\n\nstruct Fib: Sequence, IteratorProtocol {\n  private var cur: String\n  private var nex: String\n\n  init(cur: String, nex: String) {\n    self.cur = cur\n    self.nex = nex\n  }\n\n  mutating func next() -> String? {\n    let ret = cur\n\n    cur = nex\n    nex = \"\\(ret)\\(nex)\"\n\n    return ret\n  }\n}\n\nfunc getEntropy(_ s: [Int]) -> Double {\n  var entropy = 0.0\n  var hist = Array(repeating: 0.0, count: 256)\n\n  for i in 0..<s.count {\n    hist[s[i]] += 1\n  }\n\n  for i in 0..<256 where hist[i] > 0 {\n    let rat = hist[i] / Double(s.count)\n    entropy -= rat * log2(rat)\n  }\n\n  return entropy\n}\n\nfor (i, str) in Fib(cur: \"1\", nex: \"0\").prefix(37).enumerated() {\n  let ent = getEntropy(str.map({ Int($0.asciiValue!) }))\n\n  print(\"i: \\(i) len: \\(str.count) entropy: \\(ent)\")\n}\n", "target": ">>> import math\n>>> from collections import Counter\n>>> \n>>> def entropy(s):\n...     p, lns = Counter(s), float(len(s))\n...     return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\n... \n>>> \n>>> def fibword(nmax=37):\n...     fwords = ['1', '0']\n...     print('%-3s %10s %-10s %s' % tuple('N Length Entropy Fibword'.split()))\n...     def pr(n, fwords):\n...         while len(fwords) < n:\n...             fwords += [''.join(fwords[-2:][::-1])]\n...         v = fwords[n-1]\n...         print('%3i %10i %10.7g %s' % (n, len(v), entropy(v), v if len(v) < 20 else '<too long>'))\n...     for n in range(1, nmax+1): pr(n, fwords)\n... \n>>> fibword()\nN       Length Entropy    Fibword\n  1          1         -0 1\n  2          1         -0 0\n  3          2          1 01\n  4          3  0.9182958 010\n  5          5  0.9709506 01001\n  6          8   0.954434 01001010\n  7         13  0.9612366 0100101001001\n  8         21  0.9587119 <too long>\n  9         34  0.9596869 <too long>\n 10         55   0.959316 <too long>\n 11         89  0.9594579 <too long>\n 12        144  0.9594038 <too long>\n 13        233  0.9594244 <too long>\n 14        377  0.9594165 <too long>\n 15        610  0.9594196 <too long>\n 16        987  0.9594184 <too long>\n 17       1597  0.9594188 <too long>\n 18       2584  0.9594187 <too long>\n 19       4181  0.9594187 <too long>\n 20       6765  0.9594187 <too long>\n 21      10946  0.9594187 <too long>\n 22      17711  0.9594187 <too long>\n 23      28657  0.9594187 <too long>\n 24      46368  0.9594187 <too long>\n 25      75025  0.9594187 <too long>\n 26     121393  0.9594187 <too long>\n 27     196418  0.9594187 <too long>\n 28     317811  0.9594187 <too long>\n 29     514229  0.9594187 <too long>\n 30     832040  0.9594187 <too long>\n 31    1346269  0.9594187 <too long>\n 32    2178309  0.9594187 <too long>\n 33    3524578  0.9594187 <too long>\n 34    5702887  0.9594187 <too long>\n 35    9227465  0.9594187 <too long>\n 36   14930352  0.9594187 <too long>\n 37   24157817  0.9594187 <too long>\n>>>\n"}
{"id": 351534, "name": "Fibonacci word", "source": "Translate Swift to Python: import Foundation\n\nstruct Fib: Sequence, IteratorProtocol {\n  private var cur: String\n  private var nex: String\n\n  init(cur: String, nex: String) {\n    self.cur = cur\n    self.nex = nex\n  }\n\n  mutating func next() -> String? {\n    let ret = cur\n\n    cur = nex\n    nex = \"\\(ret)\\(nex)\"\n\n    return ret\n  }\n}\n\nfunc getEntropy(_ s: [Int]) -> Double {\n  var entropy = 0.0\n  var hist = Array(repeating: 0.0, count: 256)\n\n  for i in 0..<s.count {\n    hist[s[i]] += 1\n  }\n\n  for i in 0..<256 where hist[i] > 0 {\n    let rat = hist[i] / Double(s.count)\n    entropy -= rat * log2(rat)\n  }\n\n  return entropy\n}\n\nfor (i, str) in Fib(cur: \"1\", nex: \"0\").prefix(37).enumerated() {\n  let ent = getEntropy(str.map({ Int($0.asciiValue!) }))\n\n  print(\"i: \\(i) len: \\(str.count) entropy: \\(ent)\")\n}\n", "target": ">>> import math\n>>> from collections import Counter\n>>> \n>>> def entropy(s):\n...     p, lns = Counter(s), float(len(s))\n...     return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\n... \n>>> \n>>> def fibword(nmax=37):\n...     fwords = ['1', '0']\n...     print('%-3s %10s %-10s %s' % tuple('N Length Entropy Fibword'.split()))\n...     def pr(n, fwords):\n...         while len(fwords) < n:\n...             fwords += [''.join(fwords[-2:][::-1])]\n...         v = fwords[n-1]\n...         print('%3i %10i %10.7g %s' % (n, len(v), entropy(v), v if len(v) < 20 else '<too long>'))\n...     for n in range(1, nmax+1): pr(n, fwords)\n... \n>>> fibword()\nN       Length Entropy    Fibword\n  1          1         -0 1\n  2          1         -0 0\n  3          2          1 01\n  4          3  0.9182958 010\n  5          5  0.9709506 01001\n  6          8   0.954434 01001010\n  7         13  0.9612366 0100101001001\n  8         21  0.9587119 <too long>\n  9         34  0.9596869 <too long>\n 10         55   0.959316 <too long>\n 11         89  0.9594579 <too long>\n 12        144  0.9594038 <too long>\n 13        233  0.9594244 <too long>\n 14        377  0.9594165 <too long>\n 15        610  0.9594196 <too long>\n 16        987  0.9594184 <too long>\n 17       1597  0.9594188 <too long>\n 18       2584  0.9594187 <too long>\n 19       4181  0.9594187 <too long>\n 20       6765  0.9594187 <too long>\n 21      10946  0.9594187 <too long>\n 22      17711  0.9594187 <too long>\n 23      28657  0.9594187 <too long>\n 24      46368  0.9594187 <too long>\n 25      75025  0.9594187 <too long>\n 26     121393  0.9594187 <too long>\n 27     196418  0.9594187 <too long>\n 28     317811  0.9594187 <too long>\n 29     514229  0.9594187 <too long>\n 30     832040  0.9594187 <too long>\n 31    1346269  0.9594187 <too long>\n 32    2178309  0.9594187 <too long>\n 33    3524578  0.9594187 <too long>\n 34    5702887  0.9594187 <too long>\n 35    9227465  0.9594187 <too long>\n 36   14930352  0.9594187 <too long>\n 37   24157817  0.9594187 <too long>\n>>>\n"}
{"id": 351535, "name": "Text processing_1", "source": "Translate Swift to Python: import Foundation\n\nlet fmtDbl = { String(format: \"%10.3f\", $0) }\n\nTask.detached {\n  let formatter = DateFormatter()\n\n  formatter.dateFormat = \"yyyy-MM-dd\"\n\n  let (data, _) = try await URLSession.shared.bytes(from: URL(fileURLWithPath: CommandLine.arguments[1]))\n  var rowStats = [(Date, Double, Int)]()\n  var invalidPeriods = 0\n  var invalidStart: Date?\n  var sumFile = 0.0\n  var readings = 0\n  var longestInvalid = 0\n  var longestInvalidStart: Date?\n  var longestInvalidEnd: Date?\n\n  for try await line in data.lines {\n    let lineSplit = line.components(separatedBy: \"\\t\")\n\n    guard !lineSplit.isEmpty, let date = formatter.date(from: lineSplit[0]) else {\n      fatalError(\"Invalid date \\(lineSplit[0])\")\n    }\n\n    let data = Array(lineSplit.dropFirst())\n    let parsed = stride(from: 0, to: data.endIndex, by: 2).map({idx -> (Double, Int) in\n      let slice = data[idx..<idx+2]\n\n      return (Double(slice[idx]) ?? 0, Int(slice[idx+1]) ?? 0)\n    })\n\n    var sum = 0.0\n    var numValid = 0\n\n    for (val, flag) in parsed {\n      if flag <= 0 {\n        if invalidStart == nil {\n          invalidStart = date\n        }\n\n        invalidPeriods += 1\n      } else {\n        if invalidPeriods > longestInvalid {\n          longestInvalid = invalidPeriods\n          longestInvalidStart = invalidStart\n          longestInvalidEnd = date\n        }\n\n        sumFile += val\n        sum += val\n        numValid += 1\n        readings += 1\n        invalidPeriods = 0\n        invalidStart = nil\n      }\n    }\n\n    if numValid != 0 {\n      rowStats.append((date, sum / Double(numValid), parsed.count - numValid))\n    }\n  }\n\n  for stat in rowStats.lazy.reversed().prefix(5) {\n    print(\"\\(stat.0): Average: \\(fmtDbl(stat.1)); Valid Readings: \\(24 - stat.2); Invalid Readings: \\(stat.2)\")\n  }\n\n  print(\"\"\"\n\n        Sum File: \\(fmtDbl(sumFile))\n        Average: \\(fmtDbl(sumFile / Double(readings)))\n        Readings: \\(readings)\n        Longest Invalid: \\(longestInvalid) (\\(longestInvalidStart!) - \\(longestInvalidEnd!))\n        \"\"\")\n\n  exit(0)\n}\n\ndispatchMain()\n", "target": "import fileinput\nimport sys\n\nnodata = 0;             \nnodata_max=-1;          \nnodata_maxline=[];      \n\ntot_file = 0            \nnum_file = 0            \n\ninfiles = sys.argv[1:]\n\nfor line in fileinput.input():\n  tot_line=0;             \n  num_line=0;             \n\n  \n  field = line.split()\n  date  = field[0]\n  data  = [float(f) for f in field[1::2]]\n  flags = [int(f)   for f in field[2::2]]\n\n  for datum, flag in zip(data, flags):\n    if flag<1:\n      nodata += 1\n    else:\n      \n      if nodata_max==nodata and nodata>0:\n        nodata_maxline.append(date)\n      if nodata_max<nodata and nodata>0:\n        nodata_max=nodata\n        nodata_maxline=[date]\n      \n      nodata=0; \n      \n      tot_line += datum\n      num_line += 1\n\n  \n  tot_file += tot_line\n  num_file += num_line\n\n  print \"Line: %11s  Reject: %2i  Accept: %2i  Line_tot: %10.3f  Line_avg: %10.3f\" % (\n        date, \n        len(data) -num_line, \n        num_line, tot_line, \n        tot_line/num_line if (num_line>0) else 0)\n\nprint \"\"\nprint \"File(s)  = %s\" % (\", \".join(infiles),)\nprint \"Total    = %10.3f\" % (tot_file,)\nprint \"Readings = %6i\" % (num_file,)\nprint \"Average  = %10.3f\" % (tot_file / num_file,)\n\nprint \"\\nMaximum run(s) of %i consecutive false readings ends at line starting with date(s): %s\" % (\n    nodata_max, \", \".join(nodata_maxline))\n"}
{"id": 351536, "name": "Draw a sphere", "source": "Translate Swift to Python: class Sphere: UIView{\n  \n  override func drawRect(rect: CGRect)\n  {\n    let context = UIGraphicsGetCurrentContext()\n    let locations: [CGFloat] = [0.0, 1.0]\n    \n    let colors = [UIColor.whiteColor().CGColor,\n      UIColor.blueColor().CGColor]\n    \n    let colorspace = CGColorSpaceCreateDeviceRGB()\n    \n    let gradient = CGGradientCreateWithColors(colorspace,\n      colors, locations)\n    \n    var startPoint = CGPoint()\n    var endPoint = CGPoint()\n    startPoint.x = self.center.x - (self.frame.width * 0.1)\n    startPoint.y = self.center.y - (self.frame.width * 0.15)\n    endPoint.x = self.center.x\n    endPoint.y = self.center.y\n    let startRadius: CGFloat = 0\n    let endRadius: CGFloat = self.frame.width * 0.38\n    \n    CGContextDrawRadialGradient (context, gradient, startPoint,\n      startRadius, endPoint, endRadius,\n      0)\n  }\n}\n\nvar s = Sphere(frame: CGRectMake(0, 0, 200, 200))\n", "target": "import math\n\nshades = ('.',':','!','*','o','e','&','\n\ndef normalize(v):\n\tlen = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n\treturn (v[0]/len, v[1]/len, v[2]/len)\n\ndef dot(x,y):\n\td = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]\n\treturn -d if d < 0 else 0\n\ndef draw_sphere(r, k, ambient, light):\n\tfor i in range(int(math.floor(-r)),int(math.ceil(r)+1)):\n\t\tx = i + 0.5\n\t\tline = ''\n\n\t\tfor j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):\n\t\t\ty = j/2 + 0.5\n\t\t\tif x*x + y*y <= r*r:\n\t\t\t\tvec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))\n\t\t\t\tb = dot(light,vec)**k + ambient\n\t\t\t\tintensity = int((1-b)*(len(shades)-1))\n\t\t\t\tline += shades[intensity] if 0 <= intensity < len(shades) else shades[0]\n\t\t\telse:\n\t\t\t\tline += ' '\n\n\t\tprint(line)\n\nlight = normalize((30,30,-50))\ndraw_sphere(20,4,0.1, light)\ndraw_sphere(10,2,0.4, light)\n"}
{"id": 351537, "name": "Draw a sphere", "source": "Translate Swift to Python: class Sphere: UIView{\n  \n  override func drawRect(rect: CGRect)\n  {\n    let context = UIGraphicsGetCurrentContext()\n    let locations: [CGFloat] = [0.0, 1.0]\n    \n    let colors = [UIColor.whiteColor().CGColor,\n      UIColor.blueColor().CGColor]\n    \n    let colorspace = CGColorSpaceCreateDeviceRGB()\n    \n    let gradient = CGGradientCreateWithColors(colorspace,\n      colors, locations)\n    \n    var startPoint = CGPoint()\n    var endPoint = CGPoint()\n    startPoint.x = self.center.x - (self.frame.width * 0.1)\n    startPoint.y = self.center.y - (self.frame.width * 0.15)\n    endPoint.x = self.center.x\n    endPoint.y = self.center.y\n    let startRadius: CGFloat = 0\n    let endRadius: CGFloat = self.frame.width * 0.38\n    \n    CGContextDrawRadialGradient (context, gradient, startPoint,\n      startRadius, endPoint, endRadius,\n      0)\n  }\n}\n\nvar s = Sphere(frame: CGRectMake(0, 0, 200, 200))\n", "target": "import math\n\nshades = ('.',':','!','*','o','e','&','\n\ndef normalize(v):\n\tlen = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n\treturn (v[0]/len, v[1]/len, v[2]/len)\n\ndef dot(x,y):\n\td = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]\n\treturn -d if d < 0 else 0\n\ndef draw_sphere(r, k, ambient, light):\n\tfor i in range(int(math.floor(-r)),int(math.ceil(r)+1)):\n\t\tx = i + 0.5\n\t\tline = ''\n\n\t\tfor j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):\n\t\t\ty = j/2 + 0.5\n\t\t\tif x*x + y*y <= r*r:\n\t\t\t\tvec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))\n\t\t\t\tb = dot(light,vec)**k + ambient\n\t\t\t\tintensity = int((1-b)*(len(shades)-1))\n\t\t\t\tline += shades[intensity] if 0 <= intensity < len(shades) else shades[0]\n\t\t\telse:\n\t\t\t\tline += ' '\n\n\t\tprint(line)\n\nlight = normalize((30,30,-50))\ndraw_sphere(20,4,0.1, light)\ndraw_sphere(10,2,0.4, light)\n"}
{"id": 351538, "name": "Thiele's interpolation formula", "source": "Translate Swift to Python: let N = 32\nlet N2 = N * (N - 1) / 2\nlet step = 0.05\n\nvar xval = [Double](repeating: 0, count: N)\nvar tsin = [Double](repeating: 0, count: N)\nvar tcos = [Double](repeating: 0, count: N)\nvar ttan = [Double](repeating: 0, count: N)\nvar rsin = [Double](repeating: .nan, count: N2)\nvar rcos = [Double](repeating: .nan, count: N2)\nvar rtan = [Double](repeating: .nan, count: N2)\n\nfunc rho(_ x: [Double], _ y: [Double], _ r: inout [Double], _ i: Int, _ n: Int) -> Double {\n  guard n >= 0 else {\n    return 0\n  }\n\n  guard n != 0 else {\n    return y[i]\n  }\n\n  let idx = (N - 1 - n) * (N - n) / 2 + i\n\n  if r[idx] != r[idx] {\n    r[idx] = (x[i] - x[i + n]) /\n      (rho(x, y, &r, i, n - 1) - rho(x, y, &r, i + 1, n - 1)) + rho(x, y, &r, i + 1, n - 2)\n  }\n\n  return r[idx]\n}\n\nfunc thiele(_ x: [Double], _ y: [Double], _ r: inout [Double], _ xin: Double, _ n: Int) -> Double {\n  guard n <= N - 1 else {\n    return 1\n  }\n\n  return rho(x, y, &r, 0, n) - rho(x, y, &r, 0, n - 2) + (xin - x[n]) / thiele(x, y, &r, xin, n + 1)\n}\n\nfor i in 0..<N {\n  xval[i] = Double(i) * step\n  tsin[i] = sin(xval[i])\n  tcos[i] = cos(xval[i])\n  ttan[i] = tsin[i] / tcos[i]\n}\n\nprint(String(format: \"%16.14f\", 6 * thiele(tsin, xval, &rsin, 0.5, 0)))\nprint(String(format: \"%16.14f\", 3 * thiele(tcos, xval, &rcos, 0.5, 0)))\nprint(String(format: \"%16.14f\", 4 * thiele(ttan, xval, &rtan, 1.0, 0)))\n", "target": "\n\nimport math\n\ndef thieleInterpolator(x, y):\n    \u03c1 = [[yi]*(len(y)-i) for i, yi in enumerate(y)]\n    for i in range(len(\u03c1)-1):\n        \u03c1[i][1] = (x[i] - x[i+1]) / (\u03c1[i][0] - \u03c1[i+1][0])\n    for i in range(2, len(\u03c1)):\n        for j in range(len(\u03c1)-i):\n            \u03c1[j][i] = (x[j]-x[j+i]) / (\u03c1[j][i-1]-\u03c1[j+1][i-1]) + \u03c1[j+1][i-2]\n    \u03c10 = \u03c1[0]\n    def t(xin):\n        a = 0\n        for i in range(len(\u03c10)-1, 1, -1):\n            a = (xin - x[i-1]) / (\u03c10[i] - \u03c10[i-2] + a)\n        return y[0] + (xin-x[0]) / (\u03c10[1]+a)\n    return t\n\n\nxVal = [i*.05 for i in range(32)]\ntSin = [math.sin(x) for x in xVal]\ntCos = [math.cos(x) for x in xVal]\ntTan = [math.tan(x) for x in xVal]\n\niSin = thieleInterpolator(tSin, xVal)\niCos = thieleInterpolator(tCos, xVal)\niTan = thieleInterpolator(tTan, xVal)\n\nprint('{:16.14f}'.format(6*iSin(.5)))\nprint('{:16.14f}'.format(3*iCos(.5)))\nprint('{:16.14f}'.format(4*iTan(1)))\n"}
{"id": 351539, "name": "Hello world_Line printer", "source": "Translate Swift to Python: import Foundation\n\nlet out = NSOutputStream(toFileAtPath: \"/dev/lp0\", append: true)\nlet data = \"Hello, World!\".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nout?.open()\nout?.write(UnsafePointer<UInt8>(data!.bytes), maxLength: data!.length)\nout?.close()\n", "target": "lp = open(\"/dev/lp0\")\nlp.write(\"Hello World!\\n\")\nlp.close()\n"}
{"id": 351540, "name": "Hello world_Line printer", "source": "Translate Swift to Python: import Foundation\n\nlet out = NSOutputStream(toFileAtPath: \"/dev/lp0\", append: true)\nlet data = \"Hello, World!\".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nout?.open()\nout?.write(UnsafePointer<UInt8>(data!.bytes), maxLength: data!.length)\nout?.close()\n", "target": "lp = open(\"/dev/lp0\")\nlp.write(\"Hello World!\\n\")\nlp.close()\n"}
{"id": 351541, "name": "Sutherland-Hodgman polygon clipping", "source": "Translate Swift to Python: struct Point {\n  var x: Double\n  var y: Double\n}\n\nstruct Polygon {\n  var points: [Point]\n\n  init(points: [Point]) {\n    self.points = points\n  }\n\n  init(points: [(Double, Double)]) {\n    self.init(points: points.map({ Point(x: $0.0, y: $0.1) }))\n  }\n}\n\nfunc isInside(_ p1: Point, _ p2: Point, _ p3: Point) -> Bool {\n  (p3.x - p2.x) * (p1.y - p2.y) > (p3.y - p2.y) * (p1.x - p2.x)\n}\n\nfunc computeIntersection(_ p1: Point, _ p2: Point, _ s: Point, _ e: Point) -> Point {\n  let dc = Point(x: p1.x - p2.x, y: p1.y - p2.y)\n  let dp = Point(x: s.x - e.x, y: s.y - e.y)\n  let n1 = p1.x * p2.y - p1.y * p2.x\n  let n2 = s.x * e.y - s.y * e.x\n  let n3 = 1.0 / (dc.x * dp.y - dc.y * dp.x)\n\n  return Point(x: (n1 * dp.x - n2 * dc.x) * n3, y: (n1 * dp.y - n2 * dc.y) * n3)\n}\n\nfunc sutherlandHodgmanClip(subjPoly: Polygon, clipPoly: Polygon) -> Polygon {\n  var ring = subjPoly.points\n  var p1 = clipPoly.points.last!\n\n  for p2 in clipPoly.points {\n    let input = ring\n    var s = input.last!\n\n    ring = []\n\n    for e in input {\n      if isInside(e, p1, p2) {\n        if !isInside(s, p1, p2) {\n          ring.append(computeIntersection(p1, p2, s, e))\n        }\n\n        ring.append(e)\n      } else if isInside(s, p1, p2) {\n        ring.append(computeIntersection(p1, p2, s, e))\n      }\n\n      s = e\n    }\n\n    p1 = p2\n  }\n\n  return Polygon(points: ring)\n}\n\nlet subj = Polygon(points: [\n  (50.0, 150.0),\n  (200.0, 50.0),\n  (350.0, 150.0),\n  (350.0, 300.0),\n  (250.0, 300.0),\n  (200.0, 250.0),\n  (150.0, 350.0),\n  (100.0, 250.0),\n  (100.0, 200.0)\n])\n\nlet clip = Polygon(points: [\n  (100.0, 100.0),\n  (300.0, 100.0),\n  (300.0, 300.0),\n  (100.0, 300.0)\n])\n\nprint(sutherlandHodgmanClip(subjPoly: subj, clipPoly: clip))\n", "target": "def clip(subjectPolygon, clipPolygon):\n   def inside(p):\n      return(cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0])\n      \n   def computeIntersection():\n      dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ]\n      dp = [ s[0] - e[0], s[1] - e[1] ]\n      n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]\n      n2 = s[0] * e[1] - s[1] * e[0] \n      n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])\n      return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3]\n\n   outputList = subjectPolygon\n   cp1 = clipPolygon[-1]\n   \n   for clipVertex in clipPolygon:\n      cp2 = clipVertex\n      inputList = outputList\n      outputList = []\n      s = inputList[-1]\n\n      for subjectVertex in inputList:\n         e = subjectVertex\n         if inside(e):\n            if not inside(s):\n               outputList.append(computeIntersection())\n            outputList.append(e)\n         elif inside(s):\n            outputList.append(computeIntersection())\n         s = e\n      cp1 = cp2\n   return(outputList)\n"}
{"id": 351542, "name": "Sorting algorithms_Pancake sort", "source": "Translate Swift to Python: import Foundation\n\nstruct PancakeSort {\n    var arr:[Int]\n    \n    mutating func flip(n:Int) {\n        for i in 0 ..< (n + 1) / 2 {\n            swap(&arr[n - i], &arr[i])\n        }\n        println(\"flip(0.. \\(n)): \\(arr)\")\n    }\n    \n    func minmax(n:Int) -> [Int] {\n        var xm = arr[0]\n        var xM = arr[0]\n        var posm = 0\n        var posM = 0\n        \n        for i in 1..<n {\n            if (arr[i] < xm) {\n                xm = arr[i]\n                posm = i\n            } else if (arr[i] > xM) {\n                xM = arr[i]\n                posM = i\n            }\n        }\n        \n        return [posm, posM]\n    }\n    \n    mutating func sort(var n:Int, var dir:Int) {\n        if n == 0 {\n            return\n        }\n        \n        let mM = minmax(n)\n        let bestXPos = mM[dir]\n        let altXPos = mM[1 - dir]\n        var flipped = false\n        \n        if bestXPos == n - 1 {\n            n--\n        } else if bestXPos == 0 {\n            flip(n - 1)\n            n--\n        } else if altXPos == n - 1 {\n            dir = 1 - dir\n            n--\n            flipped = true\n        } else {\n            flip(bestXPos)\n        }\n        \n        sort(n, dir: dir)\n        \n        if flipped {\n            flip(n)\n        }\n    }\n}\n\nlet arr = [2, 3, 6, 1, 4, 5, 10, 8, 7, 9]\nvar a = PancakeSort(arr: arr)\na.sort(arr.count, dir: 1)\nprintln(a.arr)\n", "target": "tutor = False\n\ndef pancakesort(data):\n    if len(data) <= 1:\n        return data\n    if tutor: print()\n    for size in range(len(data), 1, -1):\n        maxindex = max(range(size), key=data.__getitem__)\n        if maxindex+1 != size:\n            \n            if maxindex != 0:\n                \n                if tutor: print('With: %r doflip  %i'\n                                % ( ' '.join(str(x) for x in data), maxindex+1 ))\n                data[:maxindex+1] = reversed(data[:maxindex+1])\n            \n            if tutor: print('With: %r  doflip %i'\n                                % ( ' '.join(str(x) for x in data), size ))\n            data[:size] = reversed(data[:size])\n    if tutor: print()\n"}
{"id": 351543, "name": "Call a function", "source": "Translate Swift to Python: \nnoArgs()\n\n\noneArgUnnamed(1)\n\n\noneArgNamed(arg: 1)\n\n\ntwoArgsUnnamed(1, 2)\n\n\ntwoArgsNamed(arg1: 1, arg2: 2)\n\n\n\noptionalArguments(arg: 1)\n\noptionalArguments() \n\n\nfuncArg(noArgs)\n\n\nvariadic(opts: \"foo\", \"bar\")\n\n\nlet foo = returnString()\n\n\nlet (foo, bar, baz) = returnSomeValues()\n\n\nlet (foo, _, baz) = returnSomeValues()\n", "target": "def no_args():\n    pass\n\nno_args()\n\ndef fixed_args(x, y):\n    print('x=%r, y=%r' % (x, y))\n\nfixed_args(1, 2)        \n\n\nfixed_args(y=2, x=1)\n\n\nmyargs=(1,2) \nfixed_args(*myargs)\n\ndef opt_args(x=1):\n    print(x)\n\nopt_args()              \nopt_args(3.141)         \n\ndef var_args(*v):\n    print(v)\n\nvar_args(1, 2, 3)       \nvar_args(1, (2,3))      \nvar_args()              \n\n\nfixed_args(y=2, x=1)    \n\n\nif 1:\n    no_args()\n\n\nassert no_args() is None\n\ndef return_something():\n    return 1\nx = return_something()\n\ndef is_builtin(x):\n\tprint(x.__name__ in dir(__builtins__))\n\nis_builtin(pow)         \nis_builtin(is_builtin)  \n\n\n\ndef takes_anything(*args, **kwargs):\n    for each in args:\n        print(each)\n    for key, value in sorted(kwargs.items()):\n        print(\"%s:%s\" % (key, value))\n    \n    wrapped_fn(*args, **kwargs)\n    \n    \n\n\n\n\n\n\n\n\n\n"}
{"id": 351544, "name": "Call a function", "source": "Translate Swift to Python: \nnoArgs()\n\n\noneArgUnnamed(1)\n\n\noneArgNamed(arg: 1)\n\n\ntwoArgsUnnamed(1, 2)\n\n\ntwoArgsNamed(arg1: 1, arg2: 2)\n\n\n\noptionalArguments(arg: 1)\n\noptionalArguments() \n\n\nfuncArg(noArgs)\n\n\nvariadic(opts: \"foo\", \"bar\")\n\n\nlet foo = returnString()\n\n\nlet (foo, bar, baz) = returnSomeValues()\n\n\nlet (foo, _, baz) = returnSomeValues()\n", "target": "def no_args():\n    pass\n\nno_args()\n\ndef fixed_args(x, y):\n    print('x=%r, y=%r' % (x, y))\n\nfixed_args(1, 2)        \n\n\nfixed_args(y=2, x=1)\n\n\nmyargs=(1,2) \nfixed_args(*myargs)\n\ndef opt_args(x=1):\n    print(x)\n\nopt_args()              \nopt_args(3.141)         \n\ndef var_args(*v):\n    print(v)\n\nvar_args(1, 2, 3)       \nvar_args(1, (2,3))      \nvar_args()              \n\n\nfixed_args(y=2, x=1)    \n\n\nif 1:\n    no_args()\n\n\nassert no_args() is None\n\ndef return_something():\n    return 1\nx = return_something()\n\ndef is_builtin(x):\n\tprint(x.__name__ in dir(__builtins__))\n\nis_builtin(pow)         \nis_builtin(is_builtin)  \n\n\n\ndef takes_anything(*args, **kwargs):\n    for each in args:\n        print(each)\n    for key, value in sorted(kwargs.items()):\n        print(\"%s:%s\" % (key, value))\n    \n    wrapped_fn(*args, **kwargs)\n    \n    \n\n\n\n\n\n\n\n\n\n"}
{"id": 351545, "name": "Copy a string", "source": "Translate Swift to Python: var src = \"Hello\"\nvar dst = src\n", "target": ">>> src = \"hello\"\n>>> a = src\n>>> b = src[:]\n>>> import copy\n>>> c = copy.copy(src)\n>>> d = copy.deepcopy(src)\n>>> src is a is b is c is d\nTrue\n"}
{"id": 351546, "name": "String comparison", "source": "Translate Swift to Python: func compare (a: String, b: String) {\n  if a == b {\n    println(\"'\\(a)' and '\\(b)' are lexically equal.\")\n  }\n  if a != b {\n    println(\"'\\(a)' and '\\(b)' are not lexically equal.\")\n  }\n  \n  if a < b {\n    println(\"'\\(a)' is lexically before '\\(b)'.\")\n  }\n  if a > b {\n    println(\"'\\(a)' is lexically after '\\(b)'.\")\n  }\n  \n  if a >= b {\n    println(\"'\\(a)' is not lexically before '\\(b)'.\")\n  }\n  if a <= b {\n    println(\"'\\(a)' is not lexically after '\\(b)'.\")\n  }\n}\ncompare(\"cat\", \"dog\")\n", "target": "fun compare(a, b):\n    print(\"\\n$a is of type ${typeof(a)} and $b is of type ${typeof(b)}\")\n    if a < b: print(\"$a is strictly less than $b\")\n    if a <= b: print(\"$a is less than or equal to $b\")\n    if a >  b: print(\"$a is strictly greater than $b\")\n    if a >= b: print(\"$a is greater than or equal to $b\")\n    if a == b: print(\"$a is equal to $b\")\n    if a != b: print(\"$a is not equal to $b\")\n    if a is b: print(\"$a has object identity with $b\")\n    if a is not b: print(\"$a has negated object identity with $b\")\n\ncompare(\"YUP\", \"YUP\")\ncompare('a', 'z')\ncompare(\"24\", \"123\")\ncompare(24, 123)\ncompare(5.0, 5)\n"}
{"id": 351547, "name": "Find prime numbers of the form n_n_n+2", "source": "Translate Swift to Python: import Foundation\n\nfunc isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfor n in 1...200 {\n    let p = n * n * n + 2\n    if isPrime(p) {\n        print(String(format: \"%3d%9d\", n, p))\n    }\n}\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    for n in range(1, 200):\n        if isPrime(n**3+2):\n            print(f'{n}\\t{n**3+2}');\n"}
{"id": 351548, "name": "Find prime numbers of the form n_n_n+2", "source": "Translate Swift to Python: import Foundation\n\nfunc isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfor n in 1...200 {\n    let p = n * n * n + 2\n    if isPrime(p) {\n        print(String(format: \"%3d%9d\", n, p))\n    }\n}\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    for n in range(1, 200):\n        if isPrime(n**3+2):\n            print(f'{n}\\t{n**3+2}');\n"}
{"id": 351549, "name": "Bioinformatics_Sequence mutation", "source": "Translate Swift to Python: let bases: [Character] = [\"A\", \"C\", \"G\", \"T\"]\n\nenum Action: CaseIterable {\n  case swap, delete, insert\n}\n\n@discardableResult\nfunc mutate(dna: inout String) -> Action {\n  guard let i = dna.indices.shuffled().first(where: { $0 != dna.endIndex }) else {\n    fatalError()\n  }\n\n  let action = Action.allCases.randomElement()!\n\n  switch action {\n  case .swap:\n    dna.replaceSubrange(i..<i, with: [bases.randomElement()!])\n  case .delete:\n    dna.remove(at: i)\n  case .insert:\n    dna.insert(bases.randomElement()!, at: i)\n  }\n\n  return action\n}\n\nvar d = \"\"\n\nfor _ in 0..<200 {\n  d.append(bases.randomElement()!)\n}\n\nfunc printSeq(_ dna: String) {\n  for startI in stride(from: 0, to: dna.count, by: 50) {\n    print(\"\\(startI): \\(dna.dropFirst(startI).prefix(50))\")\n  }\n\n  print()\n  print(\"Size: \\(dna.count)\")\n  print()\n\n  let counts = dna.reduce(into: [:], { $0[$1, default: 0] += 1 })\n\n  for (char, count) in counts.sorted(by: { $0.key < $1.key }) {\n    print(\"\\(char): \\(count)\")\n  }\n}\n\nprintSeq(d)\n\nprint()\n\nfor _ in 0..<20 {\n  mutate(dna: &d)\n}\n\nprintSeq(d)\n", "target": "import random\nfrom collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n\ndef seq_mutate(dna, count=1, kinds=\"IDSSSS\", choice=\"ATCG\" ):\n    mutation = []\n    k2txt = dict(I='Insert', D='Delete', S='Substitute')\n    for _ in range(count):\n        kind = random.choice(kinds)\n        index = random.randint(0, len(dna))\n        if kind == 'I':    \n            dna = dna[:index] + random.choice(choice) + dna[index:]\n        elif kind == 'D' and dna:  \n            dna = dna[:index] + dna[index+1:]\n        elif kind == 'S' and dna:  \n            dna = dna[:index] + random.choice(choice) + dna[index+1:]\n        mutation.append((k2txt[kind], index))\n    return dna, mutation\n\nif __name__ == '__main__':\n    length = 250\n    print(\"SEQUENCE:\")\n    sequence = ''.join(random.choices('ACGT', weights=(1, 0.8, .9, 1.1), k=length))\n    seq_pp(sequence)\n    print(\"\\n\\nMUTATIONS:\")\n    mseq, m = seq_mutate(sequence, 10)\n    for kind, index in m:\n        print(f\" {kind:>10} @{index}\")\n    print()\n    seq_pp(mseq)\n"}
{"id": 351550, "name": "Bioinformatics_Sequence mutation", "source": "Translate Swift to Python: let bases: [Character] = [\"A\", \"C\", \"G\", \"T\"]\n\nenum Action: CaseIterable {\n  case swap, delete, insert\n}\n\n@discardableResult\nfunc mutate(dna: inout String) -> Action {\n  guard let i = dna.indices.shuffled().first(where: { $0 != dna.endIndex }) else {\n    fatalError()\n  }\n\n  let action = Action.allCases.randomElement()!\n\n  switch action {\n  case .swap:\n    dna.replaceSubrange(i..<i, with: [bases.randomElement()!])\n  case .delete:\n    dna.remove(at: i)\n  case .insert:\n    dna.insert(bases.randomElement()!, at: i)\n  }\n\n  return action\n}\n\nvar d = \"\"\n\nfor _ in 0..<200 {\n  d.append(bases.randomElement()!)\n}\n\nfunc printSeq(_ dna: String) {\n  for startI in stride(from: 0, to: dna.count, by: 50) {\n    print(\"\\(startI): \\(dna.dropFirst(startI).prefix(50))\")\n  }\n\n  print()\n  print(\"Size: \\(dna.count)\")\n  print()\n\n  let counts = dna.reduce(into: [:], { $0[$1, default: 0] += 1 })\n\n  for (char, count) in counts.sorted(by: { $0.key < $1.key }) {\n    print(\"\\(char): \\(count)\")\n  }\n}\n\nprintSeq(d)\n\nprint()\n\nfor _ in 0..<20 {\n  mutate(dna: &d)\n}\n\nprintSeq(d)\n", "target": "import random\nfrom collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n\ndef seq_mutate(dna, count=1, kinds=\"IDSSSS\", choice=\"ATCG\" ):\n    mutation = []\n    k2txt = dict(I='Insert', D='Delete', S='Substitute')\n    for _ in range(count):\n        kind = random.choice(kinds)\n        index = random.randint(0, len(dna))\n        if kind == 'I':    \n            dna = dna[:index] + random.choice(choice) + dna[index:]\n        elif kind == 'D' and dna:  \n            dna = dna[:index] + dna[index+1:]\n        elif kind == 'S' and dna:  \n            dna = dna[:index] + random.choice(choice) + dna[index+1:]\n        mutation.append((k2txt[kind], index))\n    return dna, mutation\n\nif __name__ == '__main__':\n    length = 250\n    print(\"SEQUENCE:\")\n    sequence = ''.join(random.choices('ACGT', weights=(1, 0.8, .9, 1.1), k=length))\n    seq_pp(sequence)\n    print(\"\\n\\nMUTATIONS:\")\n    mseq, m = seq_mutate(sequence, 10)\n    for kind, index in m:\n        print(f\" {kind:>10} @{index}\")\n    print()\n    seq_pp(mseq)\n"}
{"id": 351551, "name": "Exceptions", "source": "Translate Swift to Python: enum MyException : ErrorType {\n  case TerribleException\n}\n", "target": "import exceptions\nclass SillyError(exceptions.Exception):\n    def __init__(self,args=None):\n         self.args=args\n"}
{"id": 351552, "name": "24 game", "source": "Translate Swift to Python: import Darwin\nimport Foundation\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> Int[] {\n    var result = Int[]();\n    for var i = 0; i < 4; i++ {\n        result.append(Int(arc4random_uniform(9)+1))\n    }\n    return result;\n}\n\n\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits\u00a0: \")\n\nfor digit in digits {\n    print(\"\\(digit) \")\n}\nprintln()\n\n\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)\n\nvar enteredDigits = Int[]()\n\nvar enteredOperations = Character[]()\n\nlet inputString = input as String\n\n\nfor character in inputString {\n    switch character {\n        case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n            let digit = String(character)\n            enteredDigits.append(digit.toInt()!)\n        case \"+\", \"-\", \"*\", \"/\":\n            enteredOperations.append(character)\n        case \"\\n\":\n            println()\n        default:\n            println(\"Invalid expression\")\n    }\n}\n\n\nvar value = Int()\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n    value = enteredDigits[0]\n    for (i, operation) in enumerate(enteredOperations) {\n        switch operation {\n            case \"+\":\n                value = value + enteredDigits[i+1]\n            case \"-\":\n                value = value - enteredDigits[i+1]\n            case \"*\":\n                value = value * enteredDigits[i+1]\n            case \"/\":\n                value = value / enteredDigits[i+1]\n            default:\n                println(\"This message should never happen!\")\n        }\n    }\n}\n\nif value != 24 {\n    println(\"The value of the provided expression is \\(value) instead of 24!\")\n} else {\n    println(\"Congratulations, you found a solution!\")\n}\n", "target": "\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n"}
{"id": 351553, "name": "24 game", "source": "Translate Swift to Python: import Darwin\nimport Foundation\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> Int[] {\n    var result = Int[]();\n    for var i = 0; i < 4; i++ {\n        result.append(Int(arc4random_uniform(9)+1))\n    }\n    return result;\n}\n\n\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits\u00a0: \")\n\nfor digit in digits {\n    print(\"\\(digit) \")\n}\nprintln()\n\n\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)\n\nvar enteredDigits = Int[]()\n\nvar enteredOperations = Character[]()\n\nlet inputString = input as String\n\n\nfor character in inputString {\n    switch character {\n        case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n            let digit = String(character)\n            enteredDigits.append(digit.toInt()!)\n        case \"+\", \"-\", \"*\", \"/\":\n            enteredOperations.append(character)\n        case \"\\n\":\n            println()\n        default:\n            println(\"Invalid expression\")\n    }\n}\n\n\nvar value = Int()\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n    value = enteredDigits[0]\n    for (i, operation) in enumerate(enteredOperations) {\n        switch operation {\n            case \"+\":\n                value = value + enteredDigits[i+1]\n            case \"-\":\n                value = value - enteredDigits[i+1]\n            case \"*\":\n                value = value * enteredDigits[i+1]\n            case \"/\":\n                value = value / enteredDigits[i+1]\n            default:\n                println(\"This message should never happen!\")\n        }\n    }\n}\n\nif value != 24 {\n    println(\"The value of the provided expression is \\(value) instead of 24!\")\n} else {\n    println(\"Congratulations, you found a solution!\")\n}\n", "target": "\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n"}
{"id": 351554, "name": "Enforced immutability", "source": "Translate Swift to Python: let a = 1\na = 1 \nvar b = 1\nb = 1\n", "target": ">>> s = \"Hello\"\n>>> s[0] = \"h\"\n\nTraceback (most recent call last):\n  File \"<pyshell\n    s[0] = \"h\"\nTypeError: 'str' object does not support item assignment\n"}
{"id": 351555, "name": "Hofstadter Q sequence", "source": "Translate Swift to Python: let n = 100000\n\nvar q = Array(repeating: 0, count: n)\nq[0] = 1\nq[1] = 1\n\nfor i in 2..<n {\n    q[i] = q[i - q[i - 1]] + q[i - q[i - 2]]\n}\n\nprint(\"First 10 elements of the sequence: \\(q[0..<10])\")\nprint(\"1000th element of the sequence: \\(q[999])\")\n\nvar count = 0\nfor i in 1..<n {\n    if q[i] < q[i - 1] {\n        count += 1\n    }\n}\nprint(\"Number of times a member of the sequence is less than the preceding term for terms up to and including the 100,000th term: \\(count)\")\n", "target": "def q(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return q.seq[n]\n    except IndexError:\n        ans = q(n - q(n - 1)) + q(n - q(n - 2))\n        q.seq.append(ans)\n        return ans\nq.seq = [None, 1, 1]\n\nif __name__ == '__main__':\n    first10 = [q(i) for i in range(1,11)]\n    assert first10 == [1, 1, 2, 3, 3, 4, 5, 5, 6, 6], \"Q() value error(s)\"\n    print(\"Q(n) for n = [1..10] is:\", ', '.join(str(i) for i in first10))\n    assert q(1000) == 502, \"Q(1000) value error\"\n    print(\"Q(1000) =\", q(1000))\n"}
{"id": 351556, "name": "Hofstadter Q sequence", "source": "Translate Swift to Python: let n = 100000\n\nvar q = Array(repeating: 0, count: n)\nq[0] = 1\nq[1] = 1\n\nfor i in 2..<n {\n    q[i] = q[i - q[i - 1]] + q[i - q[i - 2]]\n}\n\nprint(\"First 10 elements of the sequence: \\(q[0..<10])\")\nprint(\"1000th element of the sequence: \\(q[999])\")\n\nvar count = 0\nfor i in 1..<n {\n    if q[i] < q[i - 1] {\n        count += 1\n    }\n}\nprint(\"Number of times a member of the sequence is less than the preceding term for terms up to and including the 100,000th term: \\(count)\")\n", "target": "def q(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return q.seq[n]\n    except IndexError:\n        ans = q(n - q(n - 1)) + q(n - q(n - 2))\n        q.seq.append(ans)\n        return ans\nq.seq = [None, 1, 1]\n\nif __name__ == '__main__':\n    first10 = [q(i) for i in range(1,11)]\n    assert first10 == [1, 1, 2, 3, 3, 4, 5, 5, 6, 6], \"Q() value error(s)\"\n    print(\"Q(n) for n = [1..10] is:\", ', '.join(str(i) for i in first10))\n    assert q(1000) == 502, \"Q(1000) value error\"\n    print(\"Q(1000) =\", q(1000))\n"}
{"id": 351557, "name": "Count occurrences of a substring", "source": "Translate Swift to Python: import Foundation\n\nfunc countSubstring(str: String, substring: String) -> Int {\n  return str.components(separatedBy: substring).count - 1\n}\n\nprint(countSubstring(str: \"the three truths\", substring: \"th\"))\nprint(countSubstring(str: \"ababababab\", substring: \"abab\"))\n", "target": ">>> \"the three truths\".count(\"th\")\n3\n>>> \"ababababab\".count(\"abab\")\n2\n"}
{"id": 351558, "name": "Carmichael 3 strong pseudoprimes", "source": "Translate Swift to Python: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) {\n      if self % i == 0 {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\n@inlinable\npublic func carmichael<T: BinaryInteger & SignedNumeric>(p1: T) -> [(T, T, T)] {\n  func mod(_ n: T, _ m: T) -> T { (n % m + m) % m }\n\n  var res = [(T, T, T)]()\n\n  guard p1.isPrime else {\n    return res\n  }\n\n  for h3 in stride(from: 2, to: p1, by: 1) {\n    for d in stride(from: 1, to: h3 + p1, by: 1) {\n      if (h3 + p1) * (p1 - 1) % d != 0 || mod(-p1 * p1, h3) != d % h3 {\n        continue\n      }\n\n      let p2 = 1 + (p1 - 1) * (h3 + p1) / d\n\n      guard p2.isPrime else {\n        continue\n      }\n\n      let p3 = 1 + p1 * p2 / h3\n\n      guard p3.isPrime && (p2 * p3) % (p1 - 1) == 1 else {\n        continue\n      }\n\n      res.append((p1, p2, p3))\n    }\n  }\n\n  return res\n}\n\n\nlet res =\n  (1..<62)\n    .lazy\n    .filter({ $0.isPrime })\n    .map(carmichael)\n    .filter({ !$0.isEmpty })\n    .flatMap({ $0 })\n\nfor c in res {\n  print(c)\n}\n", "target": "class Isprime():\n    \n    multiples = {2}\n    primes = [2]\n    nmax = 2\n    \n    def __init__(self, nmax):\n        if nmax > self.nmax:\n            self.check(nmax)\n\n    def check(self, n):\n        if type(n) == float:\n            if not n.is_integer(): return False\n            n = int(n)\n        multiples = self.multiples\n        if n <= self.nmax:\n            return n not in multiples\n        else:\n            \n            primes, nmax = self.primes, self.nmax\n            newmax = max(nmax*2, n)\n            for p in primes:\n                multiples.update(range(p*((nmax + p + 1) // p), newmax+1, p))\n            for i in range(nmax+1, newmax+1):\n                if i not in multiples:\n                    primes.append(i)\n                    multiples.update(range(i*2, newmax+1, i))\n            self.nmax = newmax\n            return n not in multiples\n\n    __call__ = check\n            \n        \ndef carmichael(p1):\n    ans = []\n    if isprime(p1):\n        for h3 in range(2, p1):\n            g = h3 + p1\n            for d in range(1, g):\n                if (g * (p1 - 1)) % d == 0 and (-p1 * p1) % h3 == d % h3:\n                    p2 = 1 + ((p1 - 1)* g // d)\n                    if isprime(p2):\n                        p3 = 1 + (p1 * p2 // h3)\n                        if isprime(p3):\n                            if (p2 * p3) % (p1 - 1) == 1:\n                                \n                                ans += [tuple(sorted((p1, p2, p3)))]\n    return ans\n                \nisprime = Isprime(2)\n \nans = sorted(sum((carmichael(n) for n in range(62) if isprime(n)), []))\nprint(',\\n'.join(repr(ans[i:i+5])[1:-1] for i in range(0, len(ans)+1, 5)))\n"}
{"id": 351559, "name": "Fractal tree", "source": "Translate Swift to Python: extension CGFloat {\n  func degrees_to_radians() -> CGFloat {\n    return CGFloat(M_PI) * self / 180.0\n  }\n}\n\nextension Double {\n  func degrees_to_radians() -> Double {\n    return Double(M_PI) * self / 180.0\n  }\n}\n\n\nclass Tree: UIView {\n  \n  \n  func drawTree(x1: CGFloat, y1: CGFloat, angle: CGFloat, depth:Int){\n    if depth == 0 {\n      return\n    }\n    let ang = angle.degrees_to_radians()\n    let x2:CGFloat = x1 + ( cos(ang) as CGFloat) * CGFloat(depth) * (self.frame.width / 60)\n    let y2:CGFloat = y1 + ( sin(ang) as CGFloat) * CGFloat(depth) * (self.frame.width / 60)\n    \n    let line = drawLine(x1, y1: y1, x2: x2, y2: y2)\n  \n    line.stroke()\n    drawTree(x2, y1: y2, angle: angle - 20, depth: depth - 1)\n    drawTree(x2, y1: y2, angle: angle + 20, depth: depth - 1)\n  }\n  \n  func drawLine(x1:CGFloat, y1:CGFloat, x2:CGFloat, y2:CGFloat) -> UIBezierPath\n  {\n    \n    let path = UIBezierPath()\n    path.moveToPoint(CGPoint(x: x1,y: y1))\n    path.addLineToPoint(CGPoint(x: x2,y: y2))\n    path.lineWidth = 1\n    return path\n  }\n  \n  override func drawRect(rect: CGRect) {\n    \n    let color = UIColor(red: 1.0, green: 0.0, blue: 0.0, alpha: 1.0)\n    color.set()\n    drawTree(self.frame.width / 2 , y1: self.frame.height * 0.8, angle: -90 , depth: 9 )\n  }\n}\n\n\nlet tree = Tree(frame: CGRectMake(0, 0, 300, 300))\ntree\n", "target": "def setup():\n    size(600, 600)\n    background(0)\n    stroke(255)\n    drawTree(300, 550, 9)\n    \ndef drawTree(x, y, depth):\n    fork_ang = radians(20)\n    base_len = 10\n    if depth > 0:\n        pushMatrix()\n        translate(x, y - baseLen * depth)\n        line(0, baseLen * depth, 0, 0)  \n        rotate(fork_ang)\n        drawTree(0, 0, depth - 1)  \n        rotate(2 * -fork_ang)\n        drawTree(0, 0, depth - 1) \n        popMatrix()\n"}
{"id": 351560, "name": "Rock-paper-scissors", "source": "Translate Swift to Python: enum Choice: CaseIterable {\n  case rock\n  case paper\n  case scissors\n  case lizard\n  case spock\n}\n\nextension Choice {\n  var weaknesses: Set<Choice> {\n    switch self {\n      case .rock:\n        return [.paper, .spock]\n      case .paper:\n        return [.scissors, .lizard]\n      case .scissors:\n        return [.rock, .spock]\n      case .lizard:\n        return [.rock, .scissors]\n      case .spock:\n        return [.paper, .lizard]\n    }\n  }\n}\n\nstruct Game {\n  private(set) var history: [(Choice, Choice)] = []\n  private(set) var p1Score: Int = 0\n  private(set) var p2Score: Int = 0\n\n  mutating func play(_ p1Choice: Choice, against p2Choice: Choice) {\n    history.append((p1Choice, p2Choice))\n    if p2Choice.weaknesses.contains(p1Choice) {\n      p1Score += 1\n    } else if p1Choice.weaknesses.contains(p2Choice) {\n      p2Score += 1\n    }\n  }\n}\n\nfunc aiChoice(for game: Game) -> Choice {\n  if let weightedWeekness = game.history.flatMap({ $0.0.weaknesses }).randomElement() {\n    return weightedWeekness\n  } else {\n    \n    return Choice.allCases.randomElement()!\n  }\n}\n\nvar game = Game()\nprint(\"Type your choice to play a round, or 'q' to quit\")\nloop: while true {\n  let choice: Choice\n  switch readLine().map({ $0.lowercased() }) {\n    case \"r\", \"rock\":\n      choice = .rock\n    case \"p\", \"paper\":\n      choice = .paper\n    case \"scissors\":\n      choice = .scissors\n    case \"l\", \"lizard\":\n      choice = .lizard\n    case \"spock\":\n      choice = .spock\n    case \"q\", \"quit\", \"exit\":\n      break loop\n    case \"s\":\n      print(\"Do you mean Spock, or scissors?\")\n      continue\n    default: \n      print(\"Unknown choice. Type 'q' to quit\")\n      continue\n  }\n  let p2Choice = aiChoice(for: game)\n  print(\"You played \\(choice) against \\(p2Choice)\")\n  game.play(choice, against: p2Choice)\n  print(\"Current score: \\(game.p1Score)\u00a0: \\(game.p2Score)\")\n}\n", "target": "from random import choice\n\nrules = {'rock': 'paper', 'scissors': 'rock', 'paper': 'scissors'}\nprevious = ['rock', 'paper', 'scissors']\n\nwhile True:\n    human = input('\\nchoose your weapon: ')\n    computer = rules[choice(previous)]  \n\n    if human in ('quit', 'exit'): break\n\n    elif human in rules:\n        previous.append(human)\n        print('the computer played', computer, end='; ')\n\n        if rules[computer] == human:  \n            print('yay you win!')\n        elif rules[human] == computer:  \n            print('the computer beat you...\u00a0:(')\n        else: print(\"it's a tie!\")\n\n    else: print(\"that's not a valid choice\")\n"}
{"id": 351561, "name": "Benford's law", "source": "Translate Swift to Python: import Foundation\n\n\nfunc readFromFile(fileName file:String) -> String{\n    \n    var ret:String = \"\"\n    \n    let path = Foundation.URL(string: \"file:\n    \n    do {\n        ret = try String(contentsOf: path!, encoding: String.Encoding.utf8)\n    }\n    catch {\n        print(\"Could not read from file!\")\n        exit(-1)\n    }\n   \n    return ret\n}\n\n\nfunc benford(digit z:Int) -> Double {\n    \n    if z<=0 || z>9 {\n        perror(\"Argument must be between 1 and 9.\")\n        return 0\n    }\n    \n    return log10(Double(1)+Double(1)/Double(z))\n}\n\n\nif CommandLine.arguments.count < 2 {\n    print(\"Usage: Benford [FILE]\")\n    exit(-1)\n}\n\nlet pathToFile = CommandLine.arguments[1]\n\n\nlet content = readFromFile(fileName: pathToFile)\nlet lines = content.components(separatedBy: \"\\n\")\n\nvar digitCount:UInt64 = 0\nvar countDigit:[UInt64] = [0,0,0,0,0,0,0,0,0]\n\n\nfor line in lines {\n    if line == \"\" {\n        continue\n    }\n    let charLine = Array(line.characters)\n        switch(charLine[0]){\n            case \"1\":\n                countDigit[0] += 1\n                digitCount += 1\n                break\n            case \"2\":\n                countDigit[1] += 1\n                digitCount += 1\n                break\n            case \"3\":\n                countDigit[2] += 1\n                digitCount += 1\n                break\n            case \"4\":\n                countDigit[3] += 1\n                digitCount += 1\n                break\n            case \"5\":\n                countDigit[4] += 1\n                digitCount += 1\n                break\n            case \"6\":\n                countDigit[5] += 1\n                digitCount += 1\n                break\n            case \"7\":\n                countDigit[6] += 1\n                digitCount += 1\n                break\n            case \"8\":\n                countDigit[7] += 1\n                digitCount += 1\n                break\n            case \"9\":\n                countDigit[8] += 1\n                digitCount += 1\n                break\n            default:\n                break\n        }\n    \n}\n\n\nprint(\"Digit\\tBenford [%]\\tObserved [%]\\tDeviation\")\nprint(\"~~~~~\\t~~~~~~~~~~~~\\t~~~~~~~~~~~~\\t~~~~~~~~~\")\nfor i in 0..<9 {\n    let temp:Double = Double(countDigit[i])/Double(digitCount)\n    let ben = benford(digit: i+1)\n    print(String(format: \"%d\\t%.2f\\t\\t%.2f\\t\\t%.4f\", i+1,ben*100,temp*100,ben-temp))\n}\n", "target": "from __future__ import division\nfrom itertools import islice, count\nfrom collections import Counter\nfrom math import log10\nfrom random import randint\n\nexpected = [log10(1+1/d) for d in range(1,10)]\n\ndef fib():\n    a,b = 1,1\n    while True:\n        yield a\n        a,b = b,a+b\n\n\ndef power_of_threes():\n    return (3**k for k in count(0))\n\ndef heads(s):\n    for a in s: yield int(str(a)[0])\n\ndef show_dist(title, s):\n    c = Counter(s)\n    size = sum(c.values())\n    res = [c[d]/size for d in range(1,10)]\n\n    print(\"\\n%s Benfords deviation\" % title)\n    for r, e in zip(res, expected):\n        print(\"%5.1f%% %5.1f%%  %5.1f%%\" % (r*100., e*100., abs(r - e)*100.))\n\ndef rand1000():\n    while True: yield randint(1,9999)\n\nif __name__ == '__main__':\n    show_dist(\"fibbed\", islice(heads(fib()), 1000))\n    show_dist(\"threes\", islice(heads(power_of_threes()), 1000))\n\n    \n    show_dist(\"random\", islice(heads(rand1000()), 10000))\n"}
{"id": 351562, "name": "Benford's law", "source": "Translate Swift to Python: import Foundation\n\n\nfunc readFromFile(fileName file:String) -> String{\n    \n    var ret:String = \"\"\n    \n    let path = Foundation.URL(string: \"file:\n    \n    do {\n        ret = try String(contentsOf: path!, encoding: String.Encoding.utf8)\n    }\n    catch {\n        print(\"Could not read from file!\")\n        exit(-1)\n    }\n   \n    return ret\n}\n\n\nfunc benford(digit z:Int) -> Double {\n    \n    if z<=0 || z>9 {\n        perror(\"Argument must be between 1 and 9.\")\n        return 0\n    }\n    \n    return log10(Double(1)+Double(1)/Double(z))\n}\n\n\nif CommandLine.arguments.count < 2 {\n    print(\"Usage: Benford [FILE]\")\n    exit(-1)\n}\n\nlet pathToFile = CommandLine.arguments[1]\n\n\nlet content = readFromFile(fileName: pathToFile)\nlet lines = content.components(separatedBy: \"\\n\")\n\nvar digitCount:UInt64 = 0\nvar countDigit:[UInt64] = [0,0,0,0,0,0,0,0,0]\n\n\nfor line in lines {\n    if line == \"\" {\n        continue\n    }\n    let charLine = Array(line.characters)\n        switch(charLine[0]){\n            case \"1\":\n                countDigit[0] += 1\n                digitCount += 1\n                break\n            case \"2\":\n                countDigit[1] += 1\n                digitCount += 1\n                break\n            case \"3\":\n                countDigit[2] += 1\n                digitCount += 1\n                break\n            case \"4\":\n                countDigit[3] += 1\n                digitCount += 1\n                break\n            case \"5\":\n                countDigit[4] += 1\n                digitCount += 1\n                break\n            case \"6\":\n                countDigit[5] += 1\n                digitCount += 1\n                break\n            case \"7\":\n                countDigit[6] += 1\n                digitCount += 1\n                break\n            case \"8\":\n                countDigit[7] += 1\n                digitCount += 1\n                break\n            case \"9\":\n                countDigit[8] += 1\n                digitCount += 1\n                break\n            default:\n                break\n        }\n    \n}\n\n\nprint(\"Digit\\tBenford [%]\\tObserved [%]\\tDeviation\")\nprint(\"~~~~~\\t~~~~~~~~~~~~\\t~~~~~~~~~~~~\\t~~~~~~~~~\")\nfor i in 0..<9 {\n    let temp:Double = Double(countDigit[i])/Double(digitCount)\n    let ben = benford(digit: i+1)\n    print(String(format: \"%d\\t%.2f\\t\\t%.2f\\t\\t%.4f\", i+1,ben*100,temp*100,ben-temp))\n}\n", "target": "from __future__ import division\nfrom itertools import islice, count\nfrom collections import Counter\nfrom math import log10\nfrom random import randint\n\nexpected = [log10(1+1/d) for d in range(1,10)]\n\ndef fib():\n    a,b = 1,1\n    while True:\n        yield a\n        a,b = b,a+b\n\n\ndef power_of_threes():\n    return (3**k for k in count(0))\n\ndef heads(s):\n    for a in s: yield int(str(a)[0])\n\ndef show_dist(title, s):\n    c = Counter(s)\n    size = sum(c.values())\n    res = [c[d]/size for d in range(1,10)]\n\n    print(\"\\n%s Benfords deviation\" % title)\n    for r, e in zip(res, expected):\n        print(\"%5.1f%% %5.1f%%  %5.1f%%\" % (r*100., e*100., abs(r - e)*100.))\n\ndef rand1000():\n    while True: yield randint(1,9999)\n\nif __name__ == '__main__':\n    show_dist(\"fibbed\", islice(heads(fib()), 1000))\n    show_dist(\"threes\", islice(heads(power_of_threes()), 1000))\n\n    \n    show_dist(\"random\", islice(heads(rand1000()), 10000))\n"}
{"id": 351563, "name": "Additive primes", "source": "Translate Swift to Python: import Foundation\n\nfunc isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfunc digitSum(_ num: Int) -> Int {\n    var sum = 0\n    var n = num\n    while n > 0 {\n        sum += n % 10\n        n /= 10\n    }\n    return sum\n}\n\nlet limit = 500\nprint(\"Additive primes less than \\(limit):\")\nvar count = 0\nfor n in 1..<limit {\n    if isPrime(digitSum(n)) && isPrime(n) {\n        count += 1\n        print(String(format: \"%3d\", n), terminator: count % 10 == 0 ? \"\\n\" : \" \")\n    }\n}\nprint(\"\\n\\(count) additive primes found.\")\n", "target": "def is_prime(n: int) -> bool:\n    if n <= 3:\n        return n > 1\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i ** 2 <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef digit_sum(n: int) -> int:\n    sum = 0\n    while n > 0:\n        sum += n % 10\n        n //= 10\n    return sum\n\ndef main() -> None:\n    additive_primes = 0\n    for i in range(2, 500):\n        if is_prime(i) and is_prime(digit_sum(i)):\n            additive_primes += 1\n            print(i, end=\" \")\n    print(f\"\\nFound {additive_primes} additive primes less than 500\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 351564, "name": "Case-sensitivity of identifiers", "source": "Translate Swift to Python: let dog = \"Benjamin\"\nlet Dog = \"Samba\"\nlet DOG = \"Bernie\"\nprintln(\"The three dogs are named \\(dog), \\(Dog), and \\(DOG).\")\n", "target": ">>> dog = 'Benjamin'; Dog = 'Samba'; DOG = 'Bernie'\n>>> print ('The three dogs are named ',dog,', ',Dog,', and ',DOG)\nThe three dogs are named  Benjamin ,  Samba , and  Bernie\n>>>\n"}
{"id": 351565, "name": "Extra primes", "source": "Translate Swift to Python: import Foundation\n\nlet wheel = [4,2,4,2,4,6,2,6]\n\nfunc isPrime(_ number: Int) -> Bool {\n    if number < 2 {\n        return false\n    }\n    if number % 2 == 0 {\n        return number == 2\n    }\n    if number % 3 == 0 {\n        return number == 3\n    }\n    if number % 5 == 0 {\n        return number == 5\n    }\n    var p = 7\n    while true {\n        for w in wheel {\n            if p * p > number {\n                return true\n            }\n            if number % p == 0 {\n                return false\n            }\n            p += w\n        }\n    }\n}\n\nfunc nextPrimeDigitNumber(_ number: Int) -> Int {\n    if number == 0 {\n        return 2\n    }\n    switch number % 10 {\n    case 2:\n        return number + 1\n    case 3, 5:\n        return number + 2\n    default:\n        return 2 + nextPrimeDigitNumber(number/10) * 10\n    }\n}\n\nfunc digitSum(_ num: Int) -> Int {\n    var sum = 0\n    var n = num\n    while n > 0 {\n        sum += n % 10\n        n /= 10\n    }\n    return sum\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize(_ number: Int) -> String {\n    let n = NSNumber(value: number)\n    return NumberFormatter.localizedString(from: n, number: .decimal)\n}\n\nlet limit1 = 10000\nlet limit2 = 1000000000\nlet last = 10\nvar p = nextPrimeDigitNumber(0)\nvar n = 0\n\nprint(\"Extra primes less than \\(commatize(limit1)):\")\nwhile p < limit1 {\n    if isPrime(digitSum(p)) && isPrime(p) {\n        n += 1\n        print(pad(string: commatize(p), width: 5),\n              terminator: n % 10 == 0 ? \"\\n\" : \" \")\n    }\n    p = nextPrimeDigitNumber(p)\n}\n\nprint(\"\\n\\nLast \\(last) extra primes less than \\(commatize(limit2)):\")\n\nvar extraPrimes = Array(repeating: 0, count: last)\nwhile p < limit2 {\n    if isPrime(digitSum(p)) && isPrime(p) {\n        n += 1\n        extraPrimes[n % last] = p\n    }\n    p = nextPrimeDigitNumber(p)\n}\n\nfor i in stride(from: last - 1, through: 0, by: -1) {\n    print(\"\\(commatize(n - i)): \\(commatize(extraPrimes[(n - i) % last]))\")\n}\n", "target": "from itertools import *\nfrom functools import reduce\n\nclass Sieve(object):\n    \n    def __init__(self):\n        self._primes = []\n        self._comps = {}\n        self._max = 2;\n    \n    def isprime(self, n):\n        \n        if n >= self._max: self._genprimes(n)\n        return n >= 2 and n in self._primes\n    \n    def _genprimes(self, max):\n        while self._max <= max:\n            if self._max not in self._comps:\n                self._primes.append(self._max)\n                self._comps[self._max*self._max] = [self._max]\n            else:\n                for p in self._comps[self._max]:\n                    ps = self._comps.setdefault(self._max+p, [])\n                    ps.append(p)\n                del self._comps[self._max]\n            self._max += 1\n                \ndef extra_primes():\n    \n    d = [2,3,5,7]\n    s = Sieve()\n    for cand in chain.from_iterable(product(d, repeat=r) for r in count(1)):\n        num = reduce(lambda x, y: x*10+y, cand)\n        if s.isprime(num) and s.isprime(sum(cand)): yield num\n        \nfor n in takewhile(lambda n: n < 10000, extra_primes()):\n    print(n)\n"}
{"id": 351566, "name": "Extra primes", "source": "Translate Swift to Python: import Foundation\n\nlet wheel = [4,2,4,2,4,6,2,6]\n\nfunc isPrime(_ number: Int) -> Bool {\n    if number < 2 {\n        return false\n    }\n    if number % 2 == 0 {\n        return number == 2\n    }\n    if number % 3 == 0 {\n        return number == 3\n    }\n    if number % 5 == 0 {\n        return number == 5\n    }\n    var p = 7\n    while true {\n        for w in wheel {\n            if p * p > number {\n                return true\n            }\n            if number % p == 0 {\n                return false\n            }\n            p += w\n        }\n    }\n}\n\nfunc nextPrimeDigitNumber(_ number: Int) -> Int {\n    if number == 0 {\n        return 2\n    }\n    switch number % 10 {\n    case 2:\n        return number + 1\n    case 3, 5:\n        return number + 2\n    default:\n        return 2 + nextPrimeDigitNumber(number/10) * 10\n    }\n}\n\nfunc digitSum(_ num: Int) -> Int {\n    var sum = 0\n    var n = num\n    while n > 0 {\n        sum += n % 10\n        n /= 10\n    }\n    return sum\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize(_ number: Int) -> String {\n    let n = NSNumber(value: number)\n    return NumberFormatter.localizedString(from: n, number: .decimal)\n}\n\nlet limit1 = 10000\nlet limit2 = 1000000000\nlet last = 10\nvar p = nextPrimeDigitNumber(0)\nvar n = 0\n\nprint(\"Extra primes less than \\(commatize(limit1)):\")\nwhile p < limit1 {\n    if isPrime(digitSum(p)) && isPrime(p) {\n        n += 1\n        print(pad(string: commatize(p), width: 5),\n              terminator: n % 10 == 0 ? \"\\n\" : \" \")\n    }\n    p = nextPrimeDigitNumber(p)\n}\n\nprint(\"\\n\\nLast \\(last) extra primes less than \\(commatize(limit2)):\")\n\nvar extraPrimes = Array(repeating: 0, count: last)\nwhile p < limit2 {\n    if isPrime(digitSum(p)) && isPrime(p) {\n        n += 1\n        extraPrimes[n % last] = p\n    }\n    p = nextPrimeDigitNumber(p)\n}\n\nfor i in stride(from: last - 1, through: 0, by: -1) {\n    print(\"\\(commatize(n - i)): \\(commatize(extraPrimes[(n - i) % last]))\")\n}\n", "target": "from itertools import *\nfrom functools import reduce\n\nclass Sieve(object):\n    \n    def __init__(self):\n        self._primes = []\n        self._comps = {}\n        self._max = 2;\n    \n    def isprime(self, n):\n        \n        if n >= self._max: self._genprimes(n)\n        return n >= 2 and n in self._primes\n    \n    def _genprimes(self, max):\n        while self._max <= max:\n            if self._max not in self._comps:\n                self._primes.append(self._max)\n                self._comps[self._max*self._max] = [self._max]\n            else:\n                for p in self._comps[self._max]:\n                    ps = self._comps.setdefault(self._max+p, [])\n                    ps.append(p)\n                del self._comps[self._max]\n            self._max += 1\n                \ndef extra_primes():\n    \n    d = [2,3,5,7]\n    s = Sieve()\n    for cand in chain.from_iterable(product(d, repeat=r) for r in count(1)):\n        num = reduce(lambda x, y: x*10+y, cand)\n        if s.isprime(num) and s.isprime(sum(cand)): yield num\n        \nfor n in takewhile(lambda n: n < 10000, extra_primes()):\n    print(n)\n"}
{"id": 351567, "name": "Sorting algorithms_Stooge sort", "source": "Translate Swift to Python: func stoogeSort(inout arr:[Int], _ i:Int = 0, var _ j:Int = -1) {\n    if j == -1 {\n        j = arr.count - 1\n    }\n    \n    if arr[i] > arr[j] {\n        swap(&arr[i], &arr[j])\n    }\n    \n    if j - i > 1 {\n        let t = (j - i + 1) / 3\n        stoogeSort(&arr, i, j - t)\n        stoogeSort(&arr, i + t, j)\n        stoogeSort(&arr, i, j - t)\n    }\n}\n\nvar a = [-4, 2, 5, 2, 3, -2, 1, 100, 20]\n\nstoogeSort(&a)\n\nprintln(a)\n", "target": ">>> data = [1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7]\n>>> def stoogesort(L, i=0, j=None):\n\tif j is None:\n\t\tj = len(L) - 1\n\tif L[j] < L[i]:\n\t\tL[i], L[j] = L[j], L[i]\n\tif j - i > 1:\n\t\tt = (j - i + 1) // 3\n\t\tstoogesort(L, i  , j-t)\n\t\tstoogesort(L, i+t, j  )\n\t\tstoogesort(L, i  , j-t)\n\treturn L\n\n>>> stoogesort(data)\n[-6, -5, -3, -2, 1, 3, 3, 4, 5, 5, 7, 7, 7, 9, 10]\n"}
{"id": 351568, "name": "Sorting algorithms_Shell sort", "source": "Translate Swift to Python: func shellsort<T where T : Comparable>(inout seq: [T]) {\n    var inc = seq.count / 2\n    while inc > 0 {\n        for (var i, el) in EnumerateSequence(seq) {\n            while i >= inc && seq[i - inc] > el {\n                seq[i] = seq[i - inc]\n                i -= inc\n            }\n            seq[i] = el\n        }\n        if inc == 2 {\n            inc = 1\n        } else {\n            inc = inc * 5 / 11\n        }\n    }\n}\n", "target": "def shell(seq):\n    inc = len(seq) // 2\n    while inc:\n        for i, el in enumerate(seq[inc:], inc):\n            while i >= inc and seq[i - inc] > el:\n                seq[i] = seq[i - inc]\n                i -= inc\n            seq[i] = el\n        inc = 1 if inc == 2 else inc * 5 // 11\n"}
{"id": 351569, "name": "Deconvolution_1D", "source": "Translate Swift to Python: func deconv(g: [Double], f: [Double]) -> [Double] {\n  let fs = f.count\n  var ret = [Double](repeating: 0, count: g.count - fs + 1)\n\n  for n in 0..<ret.count {\n    ret[n] = g[n]\n    let lower = n >= fs ? n - fs + 1 : 0\n\n    for i in lower..<n {\n      ret[n] -= ret[i] * f[n - i]\n    }\n\n    ret[n] /= f[0]\n  }\n\n  return ret\n}\n\nlet h = [-8.0, -9.0, -3.0, -1.0, -6.0, 7.0]\nlet f = [-3.0, -6.0, -1.0,  8.0, -6.0,  3.0, -1.0, -9.0,\n         -9.0,  3.0, -2.0,  5.0,  2.0, -2.0, -7.0, -1.0]\nlet g = [24.0,  75.0, 71.0, -34.0,  3.0,  22.0, -45.0,\n         23.0, 245.0, 25.0,  52.0, 25.0, -67.0, -96.0,\n         96.0,  31.0, 55.0,  36.0, 29.0, -43.0,  -7.0]\n\nprint(\"\\(h.map({ Int($0) }))\")\nprint(\"\\(deconv(g: g, f: f).map({ Int($0) }))\\n\")\n\n\nprint(\"\\(f.map({ Int($0) }))\")\nprint(\"\\(deconv(g: g, f: h).map({ Int($0) }))\")\n", "target": "def ToReducedRowEchelonForm( M ):\n    if not M: return\n    lead = 0\n    rowCount = len(M)\n    columnCount = len(M[0])\n    for r in range(rowCount):\n        if lead >= columnCount:\n            return\n        i = r\n        while M[i][lead] == 0:\n            i += 1\n            if i == rowCount:\n                i = r\n                lead += 1\n                if columnCount == lead:\n                    return\n        M[i],M[r] = M[r],M[i]\n        lv = M[r][lead]\n        M[r] = [ mrx / lv for mrx in M[r]]\n        for i in range(rowCount):\n            if i != r:\n                lv = M[i][lead]\n                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]\n        lead += 1\n    return M\n \ndef pmtx(mtx):\n    print ('\\n'.join(''.join(' %4s' % col for col in row) for row in mtx))\n \ndef convolve(f, h):\n    g = [0] * (len(f) + len(h) - 1)\n    for hindex, hval in enumerate(h):\n        for findex, fval in enumerate(f):\n            g[hindex + findex] += fval * hval\n    return g\n\ndef deconvolve(g, f):\n    lenh = len(g) - len(f) + 1\n    mtx = [[0 for x in range(lenh+1)] for y in g]\n    for hindex in range(lenh):\n        for findex, fval in enumerate(f):\n            gindex = hindex + findex\n            mtx[gindex][hindex] = fval\n    for gindex, gval in enumerate(g):        \n        mtx[gindex][lenh] = gval\n    ToReducedRowEchelonForm( mtx )\n    return [mtx[i][lenh] for i in range(lenh)]  \n\nif __name__ == '__main__':\n    h = [-8,-9,-3,-1,-6,7]\n    f = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]\n    g = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]\n    assert convolve(f,h) == g\n    assert deconvolve(g, f) == h\n"}
{"id": 351570, "name": "Inverted syntax", "source": "Translate Swift to Python: infix operator ~= {}\ninfix operator ! {}\n\nfunc ~=(lhs:Int, inout rhs:Int) {\n    rhs = lhs\n}\n\nfunc !(lhs:(() -> Void), rhs:Bool) {\n    if (rhs) {\n        lhs()\n    }\n}\n\n\nvar a = 0\n\n\n20 ~= a\n\nlet raining = true\nlet tornado = true\nvar needUmbrella = false\nvar stayInside = false\n\n\nif raining {needUmbrella = true}\n\n\n_ = {stayInside = true} ! tornado\n", "target": "x = truevalue if condition else falsevalue\n"}
{"id": 351571, "name": "Inverted syntax", "source": "Translate Swift to Python: infix operator ~= {}\ninfix operator ! {}\n\nfunc ~=(lhs:Int, inout rhs:Int) {\n    rhs = lhs\n}\n\nfunc !(lhs:(() -> Void), rhs:Bool) {\n    if (rhs) {\n        lhs()\n    }\n}\n\n\nvar a = 0\n\n\n20 ~= a\n\nlet raining = true\nlet tornado = true\nvar needUmbrella = false\nvar stayInside = false\n\n\nif raining {needUmbrella = true}\n\n\n_ = {stayInside = true} ! tornado\n", "target": "x = truevalue if condition else falsevalue\n"}
{"id": 351572, "name": "Optional parameters", "source": "Translate Swift to Python: enum SortOrder { case kOrdNone, kOrdLex, kOrdByAddress, kOrdNumeric }\n\nfunc sortTable(table: [[String]], less: (String,String)->Bool = (<), column: Int = 0, reversed: Bool = false) {\n  \n}\n", "target": ">>> def printtable(data):\n    for row in data:\n        print ' '.join('%-5s' % ('\"%s\"' % cell) for cell in row)\n\n        \n>>> import operator\n>>> def sorttable(table, ordering=None, column=0, reverse=False):\n    return sorted(table, cmp=ordering, key=operator.itemgetter(column), reverse=reverse)\n\n>>> data = [[\"a\", \"b\", \"c\"], [\"\", \"q\", \"z\"], [\"zap\", \"zip\", \"Zot\"]]\n>>> printtable(data)\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n\"zap\" \"zip\" \"Zot\"\n>>> printtable( sorttable(data) )\n\"\"    \"q\"   \"z\"  \n\"a\"   \"b\"   \"c\"  \n\"zap\" \"zip\" \"Zot\"\n>>> printtable( sorttable(data, column=2) )\n\"zap\" \"zip\" \"Zot\"\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n>>> printtable( sorttable(data, column=1) )\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n\"zap\" \"zip\" \"Zot\"\n>>> printtable( sorttable(data, column=1, reverse=True) )\n\"zap\" \"zip\" \"Zot\"\n\"\"    \"q\"   \"z\"  \n\"a\"   \"b\"   \"c\"  \n>>> printtable( sorttable(data, ordering=lambda a,b: cmp(len(b),len(a))) )\n\"zap\" \"zip\" \"Zot\"\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n>>>\n"}
{"id": 351573, "name": "Numeric error propagation", "source": "Translate Swift to Python: import Foundation\n\nprecedencegroup ExponentiationGroup {\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationGroup\ninfix operator \u00b1\n\nfunc \u00b1(_ lhs: Double, _ rhs: Double) -> UncertainDouble { UncertainDouble(value: lhs, error: rhs) }\n\nstruct UncertainDouble {\n  var value: Double\n  var error: Double\n\n  static func +(_ lhs: UncertainDouble, _ rhs: UncertainDouble) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value + rhs.value, error: pow(pow(lhs.error, 2) + pow(rhs.error, 2), 0.5))\n  }\n\n  static func +(_ lhs: UncertainDouble, _ rhs: Double) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value + rhs, error: lhs.error)\n  }\n\n  static func -(_ lhs: UncertainDouble, _ rhs: UncertainDouble) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value - rhs.value, error: pow(pow(lhs.error, 2) + pow(rhs.error, 2), 0.5))\n  }\n\n  static func -(_ lhs: UncertainDouble, _ rhs: Double) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value - rhs, error: lhs.error)\n  }\n\n  static func *(_ lhs: UncertainDouble, _ rhs: UncertainDouble) -> UncertainDouble {\n    let val = lhs.value * rhs.value\n\n    return UncertainDouble(\n      value: val,\n      error: pow(pow(val, 2) * (pow(lhs.error / lhs.value, 2) + pow(rhs.error / rhs.value, 2)), 0.5)\n    )\n  }\n\n  static func *(_ lhs: UncertainDouble, _ rhs: Double) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value * rhs, error: abs(lhs.error * rhs))\n  }\n\n  static func /(_ lhs: UncertainDouble, _ rhs: UncertainDouble) -> UncertainDouble {\n    let val = lhs.value / rhs.value\n\n    return UncertainDouble(\n      value: val,\n      error: pow(val, 2) * (pow(lhs.error / lhs.value, 2) + pow(rhs.error / rhs.value, 2))\n    )\n  }\n\n  static func /(_ lhs: UncertainDouble, _ rhs: Double) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value / rhs, error: abs(lhs.error * rhs))\n  }\n\n  static func **(_ lhs: UncertainDouble, _ power: Double) -> UncertainDouble {\n    let val = pow(lhs.value, power)\n\n    return UncertainDouble(value: val, error: abs((val * power) * (lhs.error / lhs.value)))\n  }\n}\n\nextension UncertainDouble: CustomStringConvertible {\n  public var description: String { \"\\(value) \u00b1 \\(error)\" }\n}\n\nlet (x1, y1) = (100 \u00b1 1.1, 50 \u00b1 1.2)\nlet (x2, y2) = (200 \u00b1 2.2, 100 \u00b1 2.3)\n\nlet d = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\nprint(d)\n", "target": "from collections import namedtuple\nimport math\n \nclass I(namedtuple('Imprecise', 'value, delta')):\n    'Imprecise type: I(value=0.0, delta=0.0)' \n \n    __slots__ = () \n \n    def __new__(_cls, value=0.0, delta=0.0):\n        'Defaults to 0.0 \u00b1 delta'\n        return super().__new__(_cls, float(value), abs(float(delta)))\n \n    def reciprocal(self):\n        return I(1. / self.value, self.delta / (self.value**2)) \n \n    def __str__(self):\n        'Shorter form of Imprecise as string'\n        return 'I(%g, %g)' % self\n \n    def __neg__(self):\n        return I(-self.value, self.delta)\n \n    def __add__(self, other):\n        if type(other) == I:\n            return I( self.value + other.value, (self.delta**2 + other.delta**2)**0.5 )\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value + c, self.delta)\n\n    def __sub__(self, other):\n        return self + (-other)\n \n    def __radd__(self, other):\n        return I.__add__(self, other)\n \n    def __mul__(self, other):\n        if type(other) == I:\n            \n            \n            a1,b1 = self\n            a2,b2 = other\n            f = a1 * a2\n            return I( f, f * ( (b1 / a1)**2 + (b2 / a2)**2 )**0.5 )\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value * c, self.delta * c)\n \n    def __pow__(self, other):\n        if type(other) == I:\n            return NotImplemented\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        f = self.value ** c\n        return I(f, f * c * (self.delta / self.value))\n \n    def __rmul__(self, other):\n        return I.__mul__(self, other)\n \n    def __truediv__(self, other):\n        if type(other) == I:\n            return self.__mul__(other.reciprocal())\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value / c, self.delta / c)\n \n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n \n    __div__, __rdiv__ = __truediv__, __rtruediv__\n \nImprecise = I\n\ndef distance(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    return ((x1 - x2)**2 + (y1 - y2)**2)**0.5\n \nx1 = I(100, 1.1)\nx2 = I(200, 2.2)\ny1 = I( 50, 1.2)\ny2 = I(100, 2.3)\n\np1, p2 = (x1, y1), (x2, y2)\nprint(\"Distance between points\\n  p1: %s\\n  and p2: %s\\n  = %r\" % (\n      p1, p2, distance(p1, p2)))\n"}
{"id": 351574, "name": "Trabb Pardo\u2013Knuth algorithm", "source": "Translate Swift to Python: import Foundation\n\nprint(\"Enter 11 numbers for the Trabb\u2500Pardo\u2500Knuth algorithm:\")\n\nlet f: (Double) -> Double = { sqrt(fabs($0)) + 5 * pow($0, 3) }\n\n(1...11)\n    .generate()\n    .map { i -> Double in\n        print(\"\\(i): \", terminator: \"\")\n        guard let s = readLine(), let n = Double(s) else { return 0 }\n        return n\n    }\n    .reverse()\n    .forEach {\n        let result = f($0)\n        print(\"f(\\($0))\", result > 400.0 ? \"OVERFLOW\" : result, separator: \"\\t\")\n    }\n", "target": "Python 3.2.2 (default, Sep  4 2011, 09:51:08) [MSC v.1500 32 bit (Intel)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> def f(x): return abs(x) ** 0.5 + 5 * x**3\n\n>>> print(', '.join('%s:%s' % (x, v if v<=400 else \"TOO LARGE!\")\n\t           for x,v in ((y, f(float(y))) for y in input('\\nnumbers: ').strip().split()[:11][::-1])))\n\n11 numbers: 1 2 3 4 5 6 7 8 9 10 11\n11:TOO LARGE!, 10:TOO LARGE!, 9:TOO LARGE!, 8:TOO LARGE!, 7:TOO LARGE!, 6:TOO LARGE!, 5:TOO LARGE!, 4:322.0, 3:136.73205080756887, 2:41.41421356237309, 1:6.0\n>>>\n"}

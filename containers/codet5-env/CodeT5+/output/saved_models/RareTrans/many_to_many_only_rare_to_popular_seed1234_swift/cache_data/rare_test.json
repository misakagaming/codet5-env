{"id": 392489, "name": "Numeric error propagation", "source": "Translate Swift to Java: import Foundation\n\nprecedencegroup ExponentiationGroup {\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationGroup\ninfix operator \u00b1\n\nfunc \u00b1(_ lhs: Double, _ rhs: Double) -> UncertainDouble { UncertainDouble(value: lhs, error: rhs) }\n\nstruct UncertainDouble {\n  var value: Double\n  var error: Double\n\n  static func +(_ lhs: UncertainDouble, _ rhs: UncertainDouble) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value + rhs.value, error: pow(pow(lhs.error, 2) + pow(rhs.error, 2), 0.5))\n  }\n\n  static func +(_ lhs: UncertainDouble, _ rhs: Double) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value + rhs, error: lhs.error)\n  }\n\n  static func -(_ lhs: UncertainDouble, _ rhs: UncertainDouble) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value - rhs.value, error: pow(pow(lhs.error, 2) + pow(rhs.error, 2), 0.5))\n  }\n\n  static func -(_ lhs: UncertainDouble, _ rhs: Double) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value - rhs, error: lhs.error)\n  }\n\n  static func *(_ lhs: UncertainDouble, _ rhs: UncertainDouble) -> UncertainDouble {\n    let val = lhs.value * rhs.value\n\n    return UncertainDouble(\n      value: val,\n      error: pow(pow(val, 2) * (pow(lhs.error / lhs.value, 2) + pow(rhs.error / rhs.value, 2)), 0.5)\n    )\n  }\n\n  static func *(_ lhs: UncertainDouble, _ rhs: Double) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value * rhs, error: abs(lhs.error * rhs))\n  }\n\n  static func /(_ lhs: UncertainDouble, _ rhs: UncertainDouble) -> UncertainDouble {\n    let val = lhs.value / rhs.value\n\n    return UncertainDouble(\n      value: val,\n      error: pow(val, 2) * (pow(lhs.error / lhs.value, 2) + pow(rhs.error / rhs.value, 2))\n    )\n  }\n\n  static func /(_ lhs: UncertainDouble, _ rhs: Double) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value / rhs, error: abs(lhs.error * rhs))\n  }\n\n  static func **(_ lhs: UncertainDouble, _ power: Double) -> UncertainDouble {\n    let val = pow(lhs.value, power)\n\n    return UncertainDouble(value: val, error: abs((val * power) * (lhs.error / lhs.value)))\n  }\n}\n\nextension UncertainDouble: CustomStringConvertible {\n  public var description: String { \"\\(value) \u00b1 \\(error)\" }\n}\n\nlet (x1, y1) = (100 \u00b1 1.1, 50 \u00b1 1.2)\nlet (x2, y2) = (200 \u00b1 2.2, 100 \u00b1 2.3)\n\nlet d = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\nprint(d)\n", "target": "public class Approx {\n    private double value;\n    private double error;\n    \n    public Approx(){this.value = this.error = 0;}\n    \n    public Approx(Approx b){\n        this.value = b.value;\n        this.error = b.error;\n    }\n    \n    public Approx(double value, double error){\n        this.value = value;\n        this.error = error;\n    }\n    \n    public Approx add(Approx b){\n        value+= b.value;\n        error = Math.sqrt(error * error + b.error * b.error);\n        return this;\n    }\n    \n    public Approx add(double b){\n        value+= b;\n        return this;\n    }\n    \n    public Approx sub(Approx b){\n        value-= b.value;\n        error = Math.sqrt(error * error + b.error * b.error);\n        return this;\n    }\n    \n    public Approx sub(double b){\n        value-= b;\n        return this;\n    }\n    \n    public Approx mult(Approx b){\n        double oldVal = value;\n        value*= b.value;\n        error = Math.sqrt(value * value * (error*error) / (oldVal*oldVal) +\n                                  (b.error*b.error) / (b.value*b.value));\n        return this;\n    }\n\n    public Approx mult(double b){\n        value*= b;\n        error = Math.abs(b * error);\n        return this;\n    }\n    \n    public Approx div(Approx b){\n        double oldVal = value;\n        value/= b.value;\n        error = Math.sqrt(value * value * (error*error) / (oldVal*oldVal) +\n                                  (b.error*b.error) / (b.value*b.value));\n        return this;\n    }\n\n    public Approx div(double b){\n        value/= b;\n        error = Math.abs(b * error);\n        return this;\n    }\n    \n    public Approx pow(double b){\n        double oldVal = value;\n        value = Math.pow(value, b);\n        error = Math.abs(value * b * (error / oldVal));\n        return this;\n    }\n    \n    @Override\n    public String toString(){return value+\"\u00b1\"+error;}\n    \n    public static void main(String[] args){\n        Approx x1 = new Approx(100, 1.1);\n        Approx y1 = new Approx(50, 1.2);\n        Approx x2 = new Approx(200, 2.2);\n        Approx y2 = new Approx(100, 2.3);\n        \n        x1.sub(x2).pow(2).add(y1.sub(y2).pow(2)).pow(0.5);\n        \n        System.out.println(x1);\n    }\n}\n"}
{"id": 392490, "name": "Trabb Pardo\u2013Knuth algorithm", "source": "Translate Swift to Java: import Foundation\n\nprint(\"Enter 11 numbers for the Trabb\u2500Pardo\u2500Knuth algorithm:\")\n\nlet f: (Double) -> Double = { sqrt(fabs($0)) + 5 * pow($0, 3) }\n\n(1...11)\n    .generate()\n    .map { i -> Double in\n        print(\"\\(i): \", terminator: \"\")\n        guard let s = readLine(), let n = Double(s) else { return 0 }\n        return n\n    }\n    .reverse()\n    .forEach {\n        let result = f($0)\n        print(\"f(\\($0))\", result > 400.0 ? \"OVERFLOW\" : result, separator: \"\\t\")\n    }\n", "target": "\nimport java.util.*;\nimport java.io.*; \n\npublic class TPKA {\n\tpublic static void main(String... args) {\n\t\tdouble[] input = new double[11];\n\t\tdouble userInput = 0.0;\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(int i = 0; i < 11; i++) {\n\t\t\tSystem.out.print(\"Please enter a number: \");\n\t\t\tString s = in.nextLine();\n\t\t\ttry {\n\t\t\t\tuserInput = Double.parseDouble(s);\n\t\t\t} catch (NumberFormatException e) { \n\t\t\t\tSystem.out.println(\"You entered invalid input, exiting\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t\tinput[i] = userInput;\n\t\t}\n\t\tfor(int j = 10; j >= 0; j--) {\n\t\t\tdouble x = input[j]; double y = f(x);\n\t\t\tif( y < 400.0) {\n\t\t\t\tSystem.out.printf(\"f(\u00a0%.2f ) =\u00a0%.2f\\n\", x, y);\n\t\t\t} else {\n\t\t\t\tSystem.out.printf(\"f(\u00a0%.2f ) = %s\\n\", x, \"TOO LARGE\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static double f(double x) {\n\t\treturn Math.pow(Math.abs(x), 0.5) + (5*(Math.pow(x, 3)));\n\t}\n}\n"}
{"id": 392491, "name": "Rep-string", "source": "Translate Swift to Java: import Foundation\n\nfunc repString(_ input: String) -> [String] {\n  return (1..<(1 + input.count / 2)).compactMap({x -> String? in\n    let i = input.index(input.startIndex, offsetBy: x)\n    return input.hasPrefix(input[i...]) ? String(input.prefix(x)) : nil\n  })\n}\n\nlet testCases = \"\"\"\n                1001110011\n                1110111011\n                0010010010\n                1010101010\n                1111111111\n                0100101101\n                0100100\n                101\n                11\n                00\n                1\n                \"\"\".components(separatedBy: \"\\n\")\n\nfor testCase in testCases {\n  print(\"\\(testCase) has reps: \\(repString(testCase))\")\n}\n", "target": "public class RepString {\n\n    static final String[] input = {\"1001110011\", \"1110111011\", \"0010010010\",\n        \"1010101010\", \"1111111111\", \"0100101101\", \"0100100\", \"101\", \"11\",\n        \"00\", \"1\", \"0100101\"};\n\n    public static void main(String[] args) {\n        for (String s : input)\n            System.out.printf(\"%s\u00a0: %s%n\", s, repString(s));\n    }\n\n    static String repString(String s) {\n        int len = s.length();\n        outer:\n        for (int part = len / 2; part > 0; part--) {\n            int tail = len % part;\n            if (tail > 0 && !s.substring(0, tail).equals(s.substring(len - tail)))\n                continue;\n            for (int j = 0; j < len / part - 1; j++) {\n                int a = j * part;\n                int b = (j + 1) * part;\n                int c = (j + 2) * part;\n                if (!s.substring(a, b).equals(s.substring(b, c)))\n                    continue outer;\n            }\n            return s.substring(0, part);\n        }\n        return \"none\";\n    }\n}\n"}
{"id": 392492, "name": "Sequence_ smallest number greater than previous term with exactly n divisors", "source": "Translate Swift to Java: \nfunc divisorCount(number: Int) -> Int {\n    var n = number\n    var total = 1\n    \n    while n % 2 == 0 {\n        total += 1\n        n /= 2\n    }\n    \n    var p = 3\n    while p * p <= n {\n        var count = 1\n        while n % p == 0 {\n            count += 1\n            n /= p\n        }\n        total *= count\n        p += 2\n    }\n    \n    if n > 1 {\n        total *= 2\n    }\n    return total\n}\n\nlet limit = 32\nvar n = 1\nvar next = 1\nwhile next <= limit {\n    if next == divisorCount(number: n) {\n        print(n, terminator: \" \")\n        next += 1\n        if next > 4 && divisorCount(number: next) == 2 {\n            n = 1 << (next - 1) - 1;\n        }\n    }\n    n += 1\n}\nprint()\n", "target": "public class AntiPrimesPlus {\n\n    static int count_divisors(int n) {\n        int count = 0;\n        for (int i = 1; i * i <= n; ++i) {\n            if (n % i == 0) {\n                if (i == n / i)\n                    count++;\n                else\n                    count += 2;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        final int max = 15;\n        System.out.printf(\"The first %d terms of the sequence are:\\n\", max);\n        for (int i = 1, next = 1; next <= max; ++i) {\n            if (next == count_divisors(i)) {           \n                System.out.printf(\"%d \", i);\n                next++;\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 392493, "name": "McNuggets problem", "source": "Translate Swift to Java: func maxNugget(limit: Int) -> Int {\n  var (max, sixes, nines, twenties, i) = (0, 0, 0, 0, 0)\n\n  mainLoop: while i < limit {\n    sixes = 0\n\n    while sixes * 6 < i {\n      if sixes * 6 == i {\n        i += 1\n        continue mainLoop\n      }\n\n      nines = 0\n\n      while nines * 9 < i {\n        if sixes * 6 + nines * 9 == i {\n          i += 1\n          continue mainLoop\n        }\n\n        twenties = 0\n\n        while twenties * 20 < i {\n          if sixes * 6 + nines * 9 + twenties * 20 == i {\n            i += 1\n            continue mainLoop\n          }\n\n          twenties += 1\n        }\n\n        nines += 1\n      }\n\n      sixes += 1\n    }\n\n    max = i\n    i += 1\n  }\n\n  return max\n}\n\nprint(maxNugget(limit: 100))\n", "target": "public class McNuggets {\n\n    public static void main(String... args) {\n        int[] SIZES = new int[] { 6, 9, 20 };\n        int MAX_TOTAL = 100;\n        \n        int numSizes = SIZES.length;\n        int[] counts = new int[numSizes];\n        int maxFound = MAX_TOTAL + 1;\n        boolean[] found = new boolean[maxFound];\n        int numFound = 0;\n        int total = 0;\n        boolean advancedState = false;\n        do {\n            if (!found[total]) {\n                found[total] = true;\n                numFound++;\n            }\n            \n            \n            advancedState = false;\n            for (int i = 0; i < numSizes; i++) {\n                int curSize = SIZES[i];\n                if ((total + curSize) > MAX_TOTAL) {\n                    \n                    total -= counts[i] * curSize;\n                    counts[i] = 0;\n                }\n                else {\n                    \n                    counts[i]++;\n                    total += curSize;\n                    advancedState = true;\n                    break;\n                }\n            }\n            \n        } while ((numFound < maxFound) && advancedState);\n        \n        if (numFound < maxFound) {\n            \n            for (int i = MAX_TOTAL; i >= 0; i--) {\n                if (!found[i]) {\n                    System.out.println(\"Largest non-McNugget number in the search space is \" + i);\n                    break;\n                }\n            }\n        }\n        else {\n            System.out.println(\"All numbers in the search space are McNugget numbers\");\n        }\n        \n        return;\n    }\n}\n"}
{"id": 392494, "name": "Jaro similarity", "source": "Translate Swift to Java:  func jaroWinklerMatch(_ s: String, _ t: String) -> Double {\n    let s_len: Int = s.count\n    let t_len: Int = t.count\n    \n    if s_len == 0 && t_len == 0 {\n        return 1.0\n    }\n    \n    if s_len == 0 || t_len == 0 {\n        return 0.0\n    }\n    \n    var match_distance: Int = 0\n    \n    if s_len == 1 && t_len == 1 {\n        match_distance = 1\n    } else {\n        match_distance = ([s_len, t_len].max()!/2) - 1\n    }\n    \n    \n    var s_matches = [Bool]()\n    var t_matches = [Bool]()\n    \n    for _ in 1...s_len {\n        s_matches.append(false)\n    }\n    \n    for _ in 1...t_len {\n        t_matches.append(false)\n    }\n    \n    var matches: Double = 0.0\n    var transpositions: Double = 0.0\n    \n    for i in 0...s_len-1 {\n        \n        let start = [0, (i-match_distance)].max()!\n        let end = [(i + match_distance), t_len-1].min()!\n        \n        if start > end {\n            break\n        }\n        \n        for j in start...end {\n\n            if t_matches[j] {\n                continue\n            }\n\n            if s[String.Index.init(encodedOffset: i)] != t[String.Index.init(encodedOffset: j)] {\n                continue\n            }\n            \n            s_matches[i] = true\n            t_matches[j] = true\n            matches += 1\n            break\n        }\n    }\n    \n    if matches == 0 {\n        return 0.0\n    }\n    \n    var k = 0\n    for i in 0...s_len-1 {\n        if !s_matches[i] {\n            continue\n        }\n        while !t_matches[k] {\n            k += 1\n        }\n        if s[String.Index.init(encodedOffset: i)] != t[String.Index.init(encodedOffset: k)] {\n            \n            transpositions += 1\n        }\n        \n        k += 1\n    }\n    \n    let top = (matches / Double(s_len)) + (matches / Double(t_len)) + (matches - (transpositions / 2)) / matches\n    return top/3\n}\n\nprint(\"DWAYNE/DUANE:\", jaroWinklerMatch(\"DWAYNE\", \"DUANE\"))\nprint(\"MARTHA/MARHTA:\", jaroWinklerMatch(\"MARTHA\", \"MARHTA\"))\nprint(\"DIXON/DICKSONX:\", jaroWinklerMatch(\"DIXON\", \"DICKSONX\"))\nprint(\"JELLYFISH/SMELLYFISH:\", jaroWinklerMatch(\"JELLYFISH\", \"SMELLYFISH\"))\n", "target": "public class JaroDistance {\n    public static double jaro(String s, String t) {\n        int s_len = s.length();\n        int t_len = t.length();\n\n        if (s_len == 0 && t_len == 0) return 1;\n\n        int match_distance = Integer.max(s_len, t_len) / 2 - 1;\n\n        boolean[] s_matches = new boolean[s_len];\n        boolean[] t_matches = new boolean[t_len];\n\n        int matches = 0;\n        int transpositions = 0;\n\n        for (int i = 0; i < s_len; i++) {\n            int start = Integer.max(0, i-match_distance);\n            int end = Integer.min(i+match_distance+1, t_len);\n\n            for (int j = start; j < end; j++) {\n                if (t_matches[j]) continue;\n                if (s.charAt(i) != t.charAt(j)) continue;\n                s_matches[i] = true;\n                t_matches[j] = true;\n                matches++;\n                break;\n            }\n        }\n\n        if (matches == 0) return 0;\n\n        int k = 0;\n        for (int i = 0; i < s_len; i++) {\n            if (!s_matches[i]) continue;\n            while (!t_matches[k]) k++;\n            if (s.charAt(i) != t.charAt(k)) transpositions++;\n            k++;\n        }\n\n        return (((double)matches / s_len) +\n                ((double)matches / t_len) +\n                (((double)matches - transpositions/2.0) / matches)) / 3.0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(jaro(   \"MARTHA\",      \"MARHTA\"));\n        System.out.println(jaro(    \"DIXON\",    \"DICKSONX\"));\n        System.out.println(jaro(\"JELLYFISH\",  \"SMELLYFISH\"));\n    }\n}\n"}
{"id": 392495, "name": "Pseudo-random numbers_Xorshift star", "source": "Translate Swift to Java: import Foundation\n\nstruct XorshiftStar {\n  private let magic: UInt64 = 0x2545F4914F6CDD1D\n  private var state: UInt64\n\n  init(seed: UInt64) {\n    state = seed\n  }\n  \n  mutating func nextInt() -> UInt64 {\n    state ^= state &>> 12\n    state ^= state &<< 25\n    state ^= state &>> 27\n\n    return (state &* magic) &>> 32\n  }\n\n  mutating func nextFloat() -> Float {\n    return Float(nextInt()) / Float(1 << 32)\n  }\n}\n\nextension XorshiftStar: RandomNumberGenerator, IteratorProtocol, Sequence {\n  mutating func next() -> UInt64 {\n    return nextInt()\n  }\n\n  mutating func next() -> UInt64? {\n    return nextInt()\n  }\n}\n\nfor (i, n) in XorshiftStar(seed: 1234567).lazy.enumerated().prefix(5) {\n  print(\"\\(i): \\(n)\")\n}\n\nvar gen = XorshiftStar(seed: 987654321)\nvar counts = [Float: Int]()\n\nfor _ in 0..<100_000 {\n  counts[floorf(gen.nextFloat() * 5), default: 0] += 1\n}\n\nprint(counts)\n", "target": "public class XorShiftStar {\n    private static final long MAGIC = Long.parseUnsignedLong(\"2545F4914F6CDD1D\", 16);\n    private long state;\n\n    public void seed(long num) {\n        state = num;\n    }\n\n    public int nextInt() {\n        long x;\n        int answer;\n\n        x = state;\n        x = x ^ (x >>> 12);\n        x = x ^ (x << 25);\n        x = x ^ (x >>> 27);\n        state = x;\n        answer = (int) ((x * MAGIC) >> 32);\n\n        return answer;\n    }\n\n    public float nextFloat() {\n        return (float) Integer.toUnsignedLong(nextInt()) / (1L << 32);\n    }\n\n    public static void main(String[] args) {\n        var rng = new XorShiftStar();\n        rng.seed(1234567);\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println();\n\n        int[] counts = {0, 0, 0, 0, 0};\n        rng.seed(987654321);\n        for (int i = 0; i < 100_000; i++) {\n            int j = (int) Math.floor(rng.nextFloat() * 5.0);\n            counts[j]++;\n        }\n        for (int i = 0; i < counts.length; i++) {\n            System.out.printf(\"%d: %d\\n\", i, counts[i]);\n        }\n    }\n}\n"}
{"id": 392496, "name": "Numbers with equal rises and falls", "source": "Translate Swift to Java: import Foundation\n\nfunc equalRisesAndFalls(_ n: Int) -> Bool {\n    var total = 0\n    var previousDigit = -1\n    var m = n\n    while m > 0 {\n        let digit = m % 10\n        m /= 10\n        if previousDigit > digit {\n            total += 1\n        } else if previousDigit >= 0 && previousDigit < digit {\n            total -= 1\n        }\n        previousDigit = digit\n    }\n    return total == 0\n}\n\nvar count = 0\nvar n = 0\nlet limit1 = 200\nlet limit2 = 10000000\nprint(\"The first \\(limit1) numbers in the sequence are:\")\nwhile count < limit2 {\n    n += 1\n    if equalRisesAndFalls(n) {\n        count += 1\n        if count <= limit1 {\n            print(String(format: \"%3d\", n), terminator: count % 20 == 0 ? \"\\n\" : \" \")\n        }\n    }\n}\nprint(\"\\nThe \\(limit2)th number in the sequence is \\(n).\")\n", "target": "public class EqualRisesFalls {\n    public static void main(String[] args) {\n        final int limit1 = 200;\n        final int limit2 = 10000000;\n        System.out.printf(\"The first %d numbers in the sequence are:\\n\", limit1);\n        int n = 0;\n        for (int count = 0; count < limit2; ) {\n            if (equalRisesAndFalls(++n)) {\n                ++count;\n                if (count <= limit1)\n                    System.out.printf(\"%3d%c\", n, count % 20 == 0 ? '\\n' : ' ');\n            }\n        }\n        System.out.printf(\"\\nThe %dth number in the sequence is %d.\\n\", limit2, n);\n    }\n\n    private static boolean equalRisesAndFalls(int n) {\n        int total = 0;\n        for (int previousDigit = -1; n > 0; n /= 10) {\n            int digit = n % 10;\n            if (previousDigit > digit)\n                ++total;\n            else if (previousDigit >= 0 && previousDigit < digit)\n                --total;\n            previousDigit = digit;\n        }\n        return total == 0;\n    }\n}\n"}
{"id": 392497, "name": "Self-describing numbers", "source": "Translate Swift to Java: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isSelfDescribing: Bool {\n    let stringChars = String(self).map({ String($0) })\n    let counts = stringChars.reduce(into: [Int: Int](), {res, char in res[Int(char), default: 0] += 1})\n\n    for (i, n) in stringChars.enumerated() where counts[i, default: 0] != Int(n) {\n      return false\n    }\n\n    return true\n  }\n}\n\nprint(\"Self-describing numbers less than 100,000,000:\")\n\nDispatchQueue.concurrentPerform(iterations: 100_000_000) {i in\n  defer {\n    if i == 100_000_000 - 1 {\n      exit(0)\n    }\n  }\n\n  guard i.isSelfDescribing else {\n    return\n  }\n\n  print(i)\n}\n\ndispatchMain()\n", "target": "public class SelfDescribingNumbers{\n    public static boolean isSelfDescribing(int a){\n        String s = Integer.toString(a);\n        for(int i = 0; i < s.length(); i++){\n            String s0 = s.charAt(i) + \"\";\n            int b = Integer.parseInt(s0); \n            int count = 0;\n            for(int j = 0; j < s.length(); j++){\n                int temp = Integer.parseInt(s.charAt(j) + \"\");\n                if(temp == i){\n                    count++;\n                }\n                if (count > b) return false;\n            }\n            if(count != b) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args){\n        for(int i = 0; i < 100000000; i++){\n            if(isSelfDescribing(i)){\n                System.out.println(i);\n             }\n        }\n    }\n}\n"}
{"id": 392498, "name": "Air mass", "source": "Translate Swift to Java: import Foundation\n\nextension Double {\n  var radians: Double { self * .pi / 180 }\n}\n\nfunc columnDensity(_ a: Double, _ z: Double) -> Double {\n  func rho(_ a: Double) -> Double {\n    exp(-a / 8500)\n  }\n\n  func height(_ d: Double) -> Double {\n    let aa = 6_371_000 + a\n    let hh = aa * aa + d * d - 2 * d * aa * cos((180 - z).radians)\n\n    return hh.squareRoot() - 6_371_000\n  }\n\n  var sum = 0.0\n  var d = 0.0\n\n  while d < 1e7 {\n    let delta = max(0.001, 0.001 * d)\n\n    sum += rho(height(d + 0.5 * delta)) * delta\n    d += delta\n  }\n\n  return sum\n}\n\nfunc airMass(altitude: Double, zenith: Double) -> Double {\n  return columnDensity(altitude, zenith) / columnDensity(altitude, 0)\n}\n\nprint(\"Angle     0 m              13700 m\")\nprint(\"------------------------------------\")\n\nfor z in stride(from: 0.0, through: 90.0, by: 5.0) {\n  let air = String(\n    format: \"%2.0f      %11.8f      %11.8f\",\n    z,\n    airMass(altitude: 0, zenith: z),\n    airMass(altitude: 13700, zenith: z)\n  )\n\n  print(air)\n}\n", "target": "public class AirMass {\n    public static void main(String[] args) {\n        System.out.println(\"Angle     0 m              13700 m\");\n        System.out.println(\"------------------------------------\");\n        for (double z = 0; z <= 90; z+= 5) {\n            System.out.printf(\"%2.0f      %11.8f      %11.8f\\n\",\n                            z, airmass(0.0, z), airmass(13700.0, z));\n        }\n    }\n\n    private static double rho(double a) {\n        \n        return Math.exp(-a / 8500.0);\n    }\n\n    private static double height(double a, double z, double d) {\n        \n        \n        \n        double aa = RE + a;\n        double hh = Math.sqrt(aa * aa + d * d - 2.0 * d * aa * Math.cos(Math.toRadians(180 - z)));\n        return hh - RE;\n    }\n\n    private static double columnDensity(double a, double z) {\n        \n        double sum = 0.0, d = 0.0;\n        while (d < FIN) {\n            \n            double delta = Math.max(DD * d, DD);\n            sum += rho(height(a, z, d + 0.5 * delta)) * delta;\n            d += delta;\n        }\n        return sum;\n    }\n     \n    private static double airmass(double a, double z) {\n        return columnDensity(a, z) / columnDensity(a, 0.0);\n    }\n\n    private static final double RE = 6371000.0; \n    private static final double DD = 0.001; \n    private static final double FIN = 10000000.0; \n}\n"}
{"id": 392499, "name": "Odd words", "source": "Translate Swift to Java: import Foundation\n\nlet minLength = 5\n\nfunc loadDictionary(_ path: String) throws -> Set<String> {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return Set<String>(contents.components(separatedBy: \"\\n\").filter{$0.count >= minLength})\n}\n\nfunc pad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : string + String(repeating: \" \", count: width - string.count)\n}\n\nfunc printWords(words: [(String,String)]) {\n    for (n, (word1, word2)) in words.enumerated() {\n        print(\"\\(String(format: \"%2d\", n + 1)): \\(pad(string: word1, width: 14))\\(word2)\")\n    }\n}\n\ndo {\n    let dictionary = try loadDictionary(\"unixdict.txt\")\n    var oddWords: [(String, String)] = []\n    var evenWords: [(String, String)] = []\n    for word in dictionary {\n        if word.count < minLength + 2*(minLength/2) {\n            continue\n        }\n        var oddWord = \"\"\n        var evenWord = \"\"\n        for (i, c) in word.enumerated() {\n            if (i & 1) == 0 {\n                oddWord.append(c)\n            } else {\n                evenWord.append(c)\n            }\n        }\n        if dictionary.contains(oddWord) {\n            oddWords.append((word, oddWord))\n        }\n        if dictionary.contains(evenWord) {\n            evenWords.append((word, evenWord))\n        }\n    }\n    oddWords.sort(by: {$0.0 < $1.0})\n    evenWords.sort(by: {$0.0 < $1.0})\n    print(\"Odd words:\")\n    printWords(words: oddWords)\n    print(\"\\nEven words:\")\n    printWords(words: evenWords)\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class OddWords {\n    public static void main(String[] args) {\n        try {\n            Set<String> dictionary = new TreeSet<>();\n            final int minLength = 5;\n            String fileName = \"unixdict.txt\";\n            if (args.length != 0)\n                fileName = args[0];\n            try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    if (line.length() >= minLength)\n                        dictionary.add(line);\n                }\n            }\n            StringBuilder word1 = new StringBuilder();\n            StringBuilder word2 = new StringBuilder();\n            List<StringPair> evenWords = new ArrayList<>();\n            List<StringPair> oddWords = new ArrayList<>();\n            for (String word : dictionary) {\n                int length = word.length();\n                if (length < minLength + 2 * (minLength/2))\n                    continue;\n                word1.setLength(0);\n                word2.setLength(0);\n                for (int i = 0; i < length; ++i) {\n                    if ((i & 1) == 0)\n                        word1.append(word.charAt(i));\n                    else\n                        word2.append(word.charAt(i));\n                }\n                String oddWord = word1.toString();\n                String evenWord = word2.toString();\n                if (dictionary.contains(oddWord))\n                    oddWords.add(new StringPair(word, oddWord));\n                if (dictionary.contains(evenWord))\n                    evenWords.add(new StringPair(word, evenWord));\n            }\n            System.out.println(\"Odd words:\");\n            printWords(oddWords);\n            System.out.println(\"\\nEven words:\");\n            printWords(evenWords);\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n\n    private static void printWords(List<StringPair> strings) {\n        int n = 1;\n        for (StringPair pair : strings) {\n            System.out.printf(\"%2d:\u00a0%-14s%s\\n\", n++,\n                                    pair.string1, pair.string2);\n        }\n    }\n\n    private static class StringPair {\n        private String string1;\n        private String string2;\n        private StringPair(String s1, String s2) {\n            string1 = s1;\n            string2 = s2;\n        }\n    }\n}\n"}
{"id": 392500, "name": "Deming's funnel", "source": "Translate Swift to Java: import Foundation\n\nlet dxs = [\n  -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,\n  1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,\n  -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,\n  0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,\n  -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,\n  -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,\n  0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,\n  -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,\n  0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,\n  -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,\n  0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,\n  0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,\n  0.443, -0.521, -0.799,  0.087\n]\n\nlet dys = [\n  0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,\n  0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,\n  0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,\n  0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,\n  -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,\n  0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,\n  0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,\n  1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,\n  -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,\n  0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,\n  -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,\n  1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,\n  -0.947, -1.424, -0.542, -1.032\n]\n\nextension Collection where Element: FloatingPoint {\n  @inlinable\n  public func mean() -> Element {\n    return reduce(0, +) / Element(count)\n  }\n\n  @inlinable\n  public func stdDev() -> Element {\n    let m = mean()\n\n    return map({ ($0 - m) * ($0 - m) }).mean().squareRoot()\n  }\n}\n\ntypealias Rule = (Double, Double) -> Double\n\nfunc funnel(_ arr: [Double], rule: Rule) -> [Double] {\n  var x = 0.0\n  var res = [Double](repeating: 0, count: arr.count)\n\n  for (i, d) in arr.enumerated() {\n    res[i] = x + d\n    x = rule(x, d)\n  }\n\n  return res\n}\n\nfunc experiment(label: String, rule: Rule) {\n  let rxs = funnel(dxs, rule: rule)\n  let rys = funnel(dys, rule: rule)\n\n  print(\"\\(label)\\t:    x        y\")\n  print(\"Mean\\t:\\(String(format: \"%7.4f, %7.4f\", rxs.mean(), rys.mean()))\")\n  print(\"Std Dev\\t:\\(String(format: \"%7.4f, %7.4f\", rxs.stdDev(), rys.stdDev()))\")\n  print()\n}\n\nexperiment(label: \"Rule 1\", rule: {_, _ in 0 })\nexperiment(label: \"Rule 2\", rule: {_, dz in -dz })\nexperiment(label: \"Rule 3\", rule: {z, dz in -(z + dz) })\nexperiment(label: \"Rule 4\", rule: {z, dz in z + dz })\n", "target": "import static java.lang.Math.*;\nimport java.util.Arrays;\nimport java.util.function.BiFunction;\n\npublic class DemingsFunnel {\n\n    public static void main(String[] args) {\n        double[] dxs = {\n            -0.533, 0.270, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275,\n            1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.150, 0.001,\n            -0.382, 0.161, 0.915, 2.080, -2.337, 0.034, -0.126, 0.014,\n            0.709, 0.129, -1.093, -0.483, -1.193, 0.020, -0.051, 0.047,\n            -0.095, 0.695, 0.340, -0.182, 0.287, 0.213, -0.423, -0.021,\n            -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315,\n            0.201, 0.034, 0.097, -0.170, 0.054, -0.553, -0.024, -0.181,\n            -0.700, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658,\n            0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774,\n            -1.043, 0.051, 0.021, 0.247, -0.310, 0.171, 0.000, 0.106,\n            0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017,\n            0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598,\n            0.443, -0.521, -0.799, 0.087};\n\n        double[] dys = {\n            0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395,\n            0.490, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0.000,\n            0.426, 0.205, -0.765, -2.188, -0.742, -0.010, 0.089, 0.208,\n            0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096,\n            -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007,\n            0.009, 0.508, -0.790, 0.723, 0.881, -0.508, 0.393, -0.226,\n            0.710, 0.038, -0.217, 0.831, 0.480, 0.407, 0.447, -0.295,\n            1.126, 0.380, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217,\n            -0.822, 0.491, 1.347, -0.141, 1.230, -0.044, 0.079, 0.219,\n            0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104,\n            -0.729, 0.650, -1.103, 0.154, -1.720, 0.051, -0.385, 0.477,\n            1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224,\n            -0.947, -1.424, -0.542, -1.032};\n\n        experiment(\"Rule 1:\", dxs, dys, (z, dz) -> 0.0);\n        experiment(\"Rule 2:\", dxs, dys, (z, dz) -> -dz);\n        experiment(\"Rule 3:\", dxs, dys, (z, dz) -> -(z + dz));\n        experiment(\"Rule 4:\", dxs, dys, (z, dz) -> z + dz);\n    }\n\n    static void experiment(String label, double[] dxs, double[] dys,\n            BiFunction<Double, Double, Double> rule) {\n\n        double[] resx = funnel(dxs, rule);\n        double[] resy = funnel(dys, rule);\n        System.out.println(label);\n        System.out.printf(\"Mean x, y:   \u00a0%.4f,\u00a0%.4f%n\", mean(resx), mean(resy));\n        System.out.printf(\"Std dev x, y:\u00a0%.4f,\u00a0%.4f%n\", stdDev(resx), stdDev(resy));\n        System.out.println();\n    }\n\n    static double[] funnel(double[] input, BiFunction<Double, Double, Double> rule) {\n        double x = 0;\n        double[] result = new double[input.length];\n\n        for (int i = 0; i < input.length; i++) {\n            double rx = x + input[i];\n            x = rule.apply(x, input[i]);\n            result[i] = rx;\n        }\n        return result;\n    }\n\n    static double mean(double[] xs) {\n        return Arrays.stream(xs).sum() / xs.length;\n    }\n\n    static double stdDev(double[] xs) {\n        double m = mean(xs);\n        return sqrt(Arrays.stream(xs).map(x -> pow((x - m), 2)).sum() / xs.length);\n    }\n}\n"}
{"id": 392501, "name": "Deming's funnel", "source": "Translate Swift to Java: import Foundation\n\nlet dxs = [\n  -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,\n  1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,\n  -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,\n  0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,\n  -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,\n  -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,\n  0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,\n  -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,\n  0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,\n  -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,\n  0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,\n  0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,\n  0.443, -0.521, -0.799,  0.087\n]\n\nlet dys = [\n  0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,\n  0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,\n  0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,\n  0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,\n  -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,\n  0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,\n  0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,\n  1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,\n  -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,\n  0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,\n  -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,\n  1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,\n  -0.947, -1.424, -0.542, -1.032\n]\n\nextension Collection where Element: FloatingPoint {\n  @inlinable\n  public func mean() -> Element {\n    return reduce(0, +) / Element(count)\n  }\n\n  @inlinable\n  public func stdDev() -> Element {\n    let m = mean()\n\n    return map({ ($0 - m) * ($0 - m) }).mean().squareRoot()\n  }\n}\n\ntypealias Rule = (Double, Double) -> Double\n\nfunc funnel(_ arr: [Double], rule: Rule) -> [Double] {\n  var x = 0.0\n  var res = [Double](repeating: 0, count: arr.count)\n\n  for (i, d) in arr.enumerated() {\n    res[i] = x + d\n    x = rule(x, d)\n  }\n\n  return res\n}\n\nfunc experiment(label: String, rule: Rule) {\n  let rxs = funnel(dxs, rule: rule)\n  let rys = funnel(dys, rule: rule)\n\n  print(\"\\(label)\\t:    x        y\")\n  print(\"Mean\\t:\\(String(format: \"%7.4f, %7.4f\", rxs.mean(), rys.mean()))\")\n  print(\"Std Dev\\t:\\(String(format: \"%7.4f, %7.4f\", rxs.stdDev(), rys.stdDev()))\")\n  print()\n}\n\nexperiment(label: \"Rule 1\", rule: {_, _ in 0 })\nexperiment(label: \"Rule 2\", rule: {_, dz in -dz })\nexperiment(label: \"Rule 3\", rule: {z, dz in -(z + dz) })\nexperiment(label: \"Rule 4\", rule: {z, dz in z + dz })\n", "target": "import static java.lang.Math.*;\nimport java.util.Arrays;\nimport java.util.function.BiFunction;\n\npublic class DemingsFunnel {\n\n    public static void main(String[] args) {\n        double[] dxs = {\n            -0.533, 0.270, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275,\n            1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.150, 0.001,\n            -0.382, 0.161, 0.915, 2.080, -2.337, 0.034, -0.126, 0.014,\n            0.709, 0.129, -1.093, -0.483, -1.193, 0.020, -0.051, 0.047,\n            -0.095, 0.695, 0.340, -0.182, 0.287, 0.213, -0.423, -0.021,\n            -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315,\n            0.201, 0.034, 0.097, -0.170, 0.054, -0.553, -0.024, -0.181,\n            -0.700, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658,\n            0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774,\n            -1.043, 0.051, 0.021, 0.247, -0.310, 0.171, 0.000, 0.106,\n            0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017,\n            0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598,\n            0.443, -0.521, -0.799, 0.087};\n\n        double[] dys = {\n            0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395,\n            0.490, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0.000,\n            0.426, 0.205, -0.765, -2.188, -0.742, -0.010, 0.089, 0.208,\n            0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096,\n            -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007,\n            0.009, 0.508, -0.790, 0.723, 0.881, -0.508, 0.393, -0.226,\n            0.710, 0.038, -0.217, 0.831, 0.480, 0.407, 0.447, -0.295,\n            1.126, 0.380, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217,\n            -0.822, 0.491, 1.347, -0.141, 1.230, -0.044, 0.079, 0.219,\n            0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104,\n            -0.729, 0.650, -1.103, 0.154, -1.720, 0.051, -0.385, 0.477,\n            1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224,\n            -0.947, -1.424, -0.542, -1.032};\n\n        experiment(\"Rule 1:\", dxs, dys, (z, dz) -> 0.0);\n        experiment(\"Rule 2:\", dxs, dys, (z, dz) -> -dz);\n        experiment(\"Rule 3:\", dxs, dys, (z, dz) -> -(z + dz));\n        experiment(\"Rule 4:\", dxs, dys, (z, dz) -> z + dz);\n    }\n\n    static void experiment(String label, double[] dxs, double[] dys,\n            BiFunction<Double, Double, Double> rule) {\n\n        double[] resx = funnel(dxs, rule);\n        double[] resy = funnel(dys, rule);\n        System.out.println(label);\n        System.out.printf(\"Mean x, y:   \u00a0%.4f,\u00a0%.4f%n\", mean(resx), mean(resy));\n        System.out.printf(\"Std dev x, y:\u00a0%.4f,\u00a0%.4f%n\", stdDev(resx), stdDev(resy));\n        System.out.println();\n    }\n\n    static double[] funnel(double[] input, BiFunction<Double, Double, Double> rule) {\n        double x = 0;\n        double[] result = new double[input.length];\n\n        for (int i = 0; i < input.length; i++) {\n            double rx = x + input[i];\n            x = rule.apply(x, input[i]);\n            result[i] = rx;\n        }\n        return result;\n    }\n\n    static double mean(double[] xs) {\n        return Arrays.stream(xs).sum() / xs.length;\n    }\n\n    static double stdDev(double[] xs) {\n        double m = mean(xs);\n        return sqrt(Arrays.stream(xs).map(x -> pow((x - m), 2)).sum() / xs.length);\n    }\n}\n"}
{"id": 392502, "name": "MD5_Implementation", "source": "Translate Swift to Java:     import Foundation\n    public class MD5 {\n        \n        private let s: [UInt32] = [7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,\n                           5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,\n                           4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,\n                           6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21]\n        \n        \n        private let K: [UInt32] = (0 ..< 64).map { UInt32(0x100000000 * abs(sin(Double($0 + 1)))) }\n        \n        let a0: UInt32 = 0x67452301\n        let b0: UInt32 = 0xefcdab89\n        let c0: UInt32 = 0x98badcfe\n        let d0: UInt32 = 0x10325476\n        \n        private var message: NSData\n        \n        \n        \n        public init(_ message: NSData) {\n            self.message = message\n        }\n        \n        public func calculate() -> NSData? {\n            var tmpMessage: NSMutableData = NSMutableData(data: message)\n            let wordSize = sizeof(UInt32)\n            \n            var aa = a0\n            var bb = b0\n            var cc = c0\n            var dd = d0\n            \n            \n            tmpMessage.appendBytes([0x80]) \n            \n            \n            while tmpMessage.length % 64 != 56 {\n                tmpMessage.appendBytes([0x00])\n            }\n            \n            \n            var lengthInBits = (message.length * 8)\n            var lengthBytes = lengthInBits.bytes(64 / 8)\n            tmpMessage.appendBytes(reverse(lengthBytes));\n            \n            \n            let chunkSizeBytes = 512 / 8\n            var leftMessageBytes = tmpMessage.length\n            for var i = 0; i < tmpMessage.length; i = i + chunkSizeBytes, leftMessageBytes -= chunkSizeBytes {\n                let chunk = tmpMessage.subdataWithRange(NSRange(location: i, length: min(chunkSizeBytes,leftMessageBytes)))\n                \n                \n                \n                var M:[UInt32] = [UInt32](count: 16, repeatedValue: 0)\n                for x in 0..<M.count {\n                    var range = NSRange(location:x * wordSize, length: wordSize)\n                    chunk.getBytes(&M[x], range:range);\n                }\n                \n                \n                var A:UInt32 = a0\n                var B:UInt32 = b0\n                var C:UInt32 = c0\n                var D:UInt32 = d0\n                \n                var dTemp:UInt32 = 0\n                \n                \n                for j in 0...63 {\n                    var g = 0\n                    var F:UInt32 = 0\n                    \n                    switch (j) {\n                    case 0...15:\n                        F = (B & C) | ((~B) & D)\n                        g = j\n                        break\n                    case 16...31:\n                        F = (D & B) | (~D & C)\n                        g = (5 * j + 1) % 16\n                        break\n                    case 32...47:\n                        F = B ^ C ^ D\n                        g = (3 * j + 5) % 16\n                        break\n                    case 48...63:\n                        F = C ^ (B | (~D))\n                        g = (7 * j) % 16\n                        break\n                    default:\n                        break\n                    }\n                    dTemp = D\n                    D = C\n                    C = B\n                    B = B &+ rotateLeft((A &+ F &+ K[j] &+ M[g]), s[j])\n                    A = dTemp    \n                }\n                \n                aa = aa &+ A\n                bb = bb &+ B\n                cc = cc &+ C\n                dd = dd &+ D\n            }\n\n            var buf: NSMutableData = NSMutableData();\n            buf.appendBytes(&aa, length: wordSize)\n            buf.appendBytes(&bb, length: wordSize)\n            buf.appendBytes(&cc, length: wordSize)\n            buf.appendBytes(&dd, length: wordSize)\n            \n            return buf.copy() as? NSData;\n        }\n\n        \n        class func calculate(message: NSData) -> NSData?\n        {\n            return MD5(message).calculate();\n        }\n        \n        \n        private func rotateLeft(x:UInt32, _ n:UInt32) -> UInt32 {\n            return (x &<< n) | (x &>> (32 - n))\n        }\n    }\n", "target": "class MD5\n{\n\n  private static final int INIT_A = 0x67452301;\n  private static final int INIT_B = (int)0xEFCDAB89L;\n  private static final int INIT_C = (int)0x98BADCFEL;\n  private static final int INIT_D = 0x10325476;\n  \n  private static final int[] SHIFT_AMTS = {\n    7, 12, 17, 22,\n    5,  9, 14, 20,\n    4, 11, 16, 23,\n    6, 10, 15, 21\n  };\n  \n  private static final int[] TABLE_T = new int[64];\n  static\n  {\n    for (int i = 0; i < 64; i++)\n      TABLE_T[i] = (int)(long)((1L << 32) * Math.abs(Math.sin(i + 1)));\n  }\n  \n  public static byte[] computeMD5(byte[] message)\n  {\n    int messageLenBytes = message.length;\n    int numBlocks = ((messageLenBytes + 8) >>> 6) + 1;\n    int totalLen = numBlocks << 6;\n    byte[] paddingBytes = new byte[totalLen - messageLenBytes];\n    paddingBytes[0] = (byte)0x80;\n    \n    long messageLenBits = (long)messageLenBytes << 3;\n    for (int i = 0; i < 8; i++)\n    {\n      paddingBytes[paddingBytes.length - 8 + i] = (byte)messageLenBits;\n      messageLenBits >>>= 8;\n    }\n    \n    int a = INIT_A;\n    int b = INIT_B;\n    int c = INIT_C;\n    int d = INIT_D;\n    int[] buffer = new int[16];\n    for (int i = 0; i < numBlocks; i ++)\n    {\n      int index = i << 6;\n      for (int j = 0; j < 64; j++, index++)\n        buffer[j >>> 2] = ((int)((index < messageLenBytes) ? message[index] : paddingBytes[index - messageLenBytes]) << 24) | (buffer[j >>> 2] >>> 8);\n      int originalA = a;\n      int originalB = b;\n      int originalC = c;\n      int originalD = d;\n      for (int j = 0; j < 64; j++)\n      {\n        int div16 = j >>> 4;\n        int f = 0;\n        int bufferIndex = j;\n        switch (div16)\n        {\n          case 0:\n            f = (b & c) | (~b & d);\n            break;\n            \n          case 1:\n            f = (b & d) | (c & ~d);\n            bufferIndex = (bufferIndex * 5 + 1) & 0x0F;\n            break;\n            \n          case 2:\n            f = b ^ c ^ d;\n            bufferIndex = (bufferIndex * 3 + 5) & 0x0F;\n            break;\n            \n          case 3:\n            f = c ^ (b | ~d);\n            bufferIndex = (bufferIndex * 7) & 0x0F;\n            break;\n        }\n        int temp = b + Integer.rotateLeft(a + f + buffer[bufferIndex] + TABLE_T[j], SHIFT_AMTS[(div16 << 2) | (j & 3)]);\n        a = d;\n        d = c;\n        c = b;\n        b = temp;\n      }\n      \n      a += originalA;\n      b += originalB;\n      c += originalC;\n      d += originalD;\n    }\n    \n    byte[] md5 = new byte[16];\n    int count = 0;\n    for (int i = 0; i < 4; i++)\n    {\n      int n = (i == 0) ? a : ((i == 1) ? b : ((i == 2) ? c : d));\n      for (int j = 0; j < 4; j++)\n      {\n        md5[count++] = (byte)n;\n        n >>>= 8;\n      }\n    }\n    return md5;\n  }\n  \n  public static String toHexString(byte[] b)\n  {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < b.length; i++)\n    {\n      sb.append(String.format(\"%02X\", b[i] & 0xFF));\n    }\n    return sb.toString();\n  }\n\n  public static void main(String[] args)\n  {\n    String[] testStrings = { \"\", \"a\", \"abc\", \"message digest\", \"abcdefghijklmnopqrstuvwxyz\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\" };\n    for (String s : testStrings)\n      System.out.println(\"0x\" + toHexString(computeMD5(s.getBytes())) + \" <== \\\"\" + s + \"\\\"\");\n    return;\n  }\n  \n}\n"}
{"id": 392503, "name": "History variables", "source": "Translate Swift to Java: var historyOfHistory = [Int]()\nvar history:Int = 0 {\n    willSet {\n        historyOfHistory.append(history)\n    }\n}\n\nhistory = 2\nhistory = 3\nhistory = 4\nprintln(historyOfHistory)\n", "target": "public class HistoryVariable\n{\n    private Object value;\n\n    public HistoryVariable(Object v)\n    {\n        value = v;\n    }\n\n    public void update(Object v)\n    {\n        value = v;\n    }\n\n    public Object undo()\n    {\n        return value;\n    }\n\n    @Override\n    public String toString()\n    {\n        return value.toString();\n    }\n\n    public void dispose()\n    {\n    }\n}\n"}
{"id": 392504, "name": "Function definition", "source": "Translate Swift to Java: func multiply(a: Double, b: Double) -> Double {\n   return a * b\n}\n", "target": "module MultiplyExample\n    {\n    static <Value extends Number> Value multiply(Value n1, Value n2)\n        {\n        return n1 * n2;\n        }\n\n    void run()\n        {\n        (Int i1, Int i2) = (7, 3);\n        Int i3 = multiply(i1, i2);\n        (Double d1, Double d2) = (2.7182818, 3.1415);\n        Double d3 = multiply(d1, d2);\n        @Inject Console console;\n        console.print($\"{i1}*{i2}={i3}, {d1}*{d2}={d3}\");\n        }\n    }\n"}
{"id": 392505, "name": "Jacobi symbol", "source": "Translate Swift to Java: import Foundation\n\nfunc jacobi(a: Int, n: Int) -> Int {\n  var a = a % n\n  var n = n\n  var res = 1\n\n  while a != 0 {\n    while a & 1 == 0 {\n      a >>= 1\n\n      if n % 8 == 3 || n % 8 == 5 {\n        res = -res\n      }\n    }\n\n    (a, n) = (n, a)\n\n    if a % 4 == 3 && n % 4 == 3 {\n      res = -res\n    }\n    \n    a %= n\n  }\n\n  return n == 1 ? res : 0\n}\n\nprint(\"n/a  0  1  2  3  4  5  6  7  8  9\")\nprint(\"---------------------------------\")\n\nfor n in stride(from: 1, through: 17, by: 2) {\n  print(String(format: \"%2d\", n), terminator: \"\")\n\n  for a in 0..<10 {\n    print(String(format: \"\u00a0% d\", jacobi(a: a, n: n)), terminator: \"\")\n  }\n\n  print()\n}\n", "target": "public class JacobiSymbol {\n\n    public static void main(String[] args) {\n        int max = 30;\n        System.out.printf(\"n\\\\k \");\n        for ( int k = 1 ; k <= max ; k++ ) {\n            System.out.printf(\"%2d  \", k);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 1 ; n <= max ; n += 2 ) {\n            System.out.printf(\"%2d  \", n);\n            for ( int k = 1 ; k <= max ; k++ ) {\n                System.out.printf(\"%2d  \", jacobiSymbol(k, n));\n            }\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    \n    \n    private static int jacobiSymbol(int k, int n) {\n        if ( k < 0 || n % 2 == 0 ) {\n            throw new IllegalArgumentException(\"Invalid value. k = \" + k + \", n = \" + n);\n        }\n        k %= n;\n        int jacobi = 1;\n        while ( k > 0 ) {\n            while ( k % 2 == 0 ) {\n                k /= 2;\n                int r = n % 8;\n                if ( r == 3 || r == 5 ) {\n                    jacobi = -jacobi;\n                }\n            }\n            int temp = n;\n            n = k;\n            k = temp;\n            if ( k % 4 == 3 && n % 4 == 3 ) {\n                jacobi = -jacobi;\n            }\n            k %= n;\n        }\n        if ( n == 1 ) {\n            return jacobi;\n        }\n        return 0;\n    }\n\n}\n"}
{"id": 392506, "name": "Jacobi symbol", "source": "Translate Swift to Java: import Foundation\n\nfunc jacobi(a: Int, n: Int) -> Int {\n  var a = a % n\n  var n = n\n  var res = 1\n\n  while a != 0 {\n    while a & 1 == 0 {\n      a >>= 1\n\n      if n % 8 == 3 || n % 8 == 5 {\n        res = -res\n      }\n    }\n\n    (a, n) = (n, a)\n\n    if a % 4 == 3 && n % 4 == 3 {\n      res = -res\n    }\n    \n    a %= n\n  }\n\n  return n == 1 ? res : 0\n}\n\nprint(\"n/a  0  1  2  3  4  5  6  7  8  9\")\nprint(\"---------------------------------\")\n\nfor n in stride(from: 1, through: 17, by: 2) {\n  print(String(format: \"%2d\", n), terminator: \"\")\n\n  for a in 0..<10 {\n    print(String(format: \"\u00a0% d\", jacobi(a: a, n: n)), terminator: \"\")\n  }\n\n  print()\n}\n", "target": "public class JacobiSymbol {\n\n    public static void main(String[] args) {\n        int max = 30;\n        System.out.printf(\"n\\\\k \");\n        for ( int k = 1 ; k <= max ; k++ ) {\n            System.out.printf(\"%2d  \", k);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 1 ; n <= max ; n += 2 ) {\n            System.out.printf(\"%2d  \", n);\n            for ( int k = 1 ; k <= max ; k++ ) {\n                System.out.printf(\"%2d  \", jacobiSymbol(k, n));\n            }\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    \n    \n    private static int jacobiSymbol(int k, int n) {\n        if ( k < 0 || n % 2 == 0 ) {\n            throw new IllegalArgumentException(\"Invalid value. k = \" + k + \", n = \" + n);\n        }\n        k %= n;\n        int jacobi = 1;\n        while ( k > 0 ) {\n            while ( k % 2 == 0 ) {\n                k /= 2;\n                int r = n % 8;\n                if ( r == 3 || r == 5 ) {\n                    jacobi = -jacobi;\n                }\n            }\n            int temp = n;\n            n = k;\n            k = temp;\n            if ( k % 4 == 3 && n % 4 == 3 ) {\n                jacobi = -jacobi;\n            }\n            k %= n;\n        }\n        if ( n == 1 ) {\n            return jacobi;\n        }\n        return 0;\n    }\n\n}\n"}
{"id": 392507, "name": "Sattolo cycle", "source": "Translate Swift to Java: extension Array {\n  public mutating func satalloShuffle() {\n    for i in stride(from: index(before: endIndex), through: 1, by: -1) {\n      swapAt(i, .random(in: 0..<i))\n    }\n  }\n\n  public func satalloShuffled() -> [Element] {\n    var arr = Array(self)\n\n    arr.satalloShuffle()\n\n    return arr\n  }\n}\n\nlet testCases = [\n  [],\n  [10, 20],\n  [10, 20, 30],\n  [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n]\n\nfor testCase in testCases {\n  let shuffled = testCase.satalloShuffled()\n\n  guard zip(testCase, shuffled).allSatisfy(!=) else {\n    fatalError(\"satallo shuffle failed\")\n  }\n\n  print(\"\\(testCase) shuffled = \\(shuffled)\")\n}\n", "target": "private static final Random rng = new Random();\n\nvoid sattoloCycle(Object[] items) {\n    for (int i = items.length-1; i > 0; i--) {\n        int j = rng.nextInt(i);\n        Object tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n"}
{"id": 392508, "name": "Sattolo cycle", "source": "Translate Swift to Java: extension Array {\n  public mutating func satalloShuffle() {\n    for i in stride(from: index(before: endIndex), through: 1, by: -1) {\n      swapAt(i, .random(in: 0..<i))\n    }\n  }\n\n  public func satalloShuffled() -> [Element] {\n    var arr = Array(self)\n\n    arr.satalloShuffle()\n\n    return arr\n  }\n}\n\nlet testCases = [\n  [],\n  [10, 20],\n  [10, 20, 30],\n  [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n]\n\nfor testCase in testCases {\n  let shuffled = testCase.satalloShuffled()\n\n  guard zip(testCase, shuffled).allSatisfy(!=) else {\n    fatalError(\"satallo shuffle failed\")\n  }\n\n  print(\"\\(testCase) shuffled = \\(shuffled)\")\n}\n", "target": "private static final Random rng = new Random();\n\nvoid sattoloCycle(Object[] items) {\n    for (int i = items.length-1; i > 0; i--) {\n        int j = rng.nextInt(i);\n        Object tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n"}
{"id": 392509, "name": "Y combinator", "source": "Translate Swift to Java: struct RecursiveFunc<F> {\n  let o : RecursiveFunc<F> -> F\n}\n\nfunc Y<A, B>(f: (A -> B) -> A -> B) -> A -> B {\n  let r = RecursiveFunc<A -> B> { w in f { w.o(w)($0) } }\n  return r.o(r)\n}\n\nlet fac = Y { (f: Int -> Int) in\n  { $0 <= 1 ? 1 : $0 * f($0-1) }\n}\nlet fib = Y { (f: Int -> Int) in\n  { $0 <= 2 ? 1 : f($0-1)+f($0-2) }\n}\nprintln(\"fac(5) = \\(fac(5))\")\nprintln(\"fib(9) = \\(fib(9))\")\n", "target": "import java.util.function.Function;\n\npublic interface YCombinator {\n  interface RecursiveFunction<F> extends Function<RecursiveFunction<F>, F> { }\n  public static <A,B> Function<A,B> Y(Function<Function<A,B>, Function<A,B>> f) {\n    RecursiveFunction<Function<A,B>> r = w -> f.apply(x -> w.apply(w).apply(x));\n    return r.apply(r);\n  }\n\n  public static void main(String... arguments) {\n    Function<Integer,Integer> fib = Y(f -> n ->\n      (n <= 2)\n        ? 1\n        : (f.apply(n - 1) + f.apply(n - 2))\n    );\n    Function<Integer,Integer> fac = Y(f -> n ->\n      (n <= 1)\n        ? 1\n        : (n * f.apply(n - 1))\n    );\n\n    System.out.println(\"fib(10) = \" + fib.apply(10));\n    System.out.println(\"fac(10) = \" + fac.apply(10));\n  }\n}\n"}
{"id": 392510, "name": "Factorions", "source": "Translate Swift to Java: var fact = Array(repeating: 0, count: 12)\n\nfact[0] = 1\n\nfor n in 1..<12 {\n  fact[n] = fact[n - 1] * n\n}\n\nfor b in 9...12 {\n  print(\"The factorions for base \\(b) are:\")\n\n  for i in 1..<1500000 {\n    var sum = 0\n    var j = i\n\n    while j > 0 {\n      sum += fact[j % b]\n      j /= b\n    }\n\n    if sum == i {\n      print(\"\\(i)\", terminator: \" \")\n      fflush(stdout)\n    }\n  }\n\n  print(\"\\n\")\n}\n", "target": "public class Factorion {\n    public static void main(String [] args){\n        System.out.println(\"Base 9:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,9);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 10:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,10);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 11:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,11);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 12:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,12);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n    }\n    public static int factorialRec(int n){\n        int result = 1;\n        return n == 0 ? result : result * n * factorialRec(n-1);\n    }\n\n    public static int operate(String s, int base){\n        int sum = 0;\n        String strx = fromDeci(base, Integer.parseInt(s));\n        for(int i = 0; i < strx.length(); i++){\n            if(strx.charAt(i) == 'A'){\n                sum += factorialRec(10);\n            }else if(strx.charAt(i) == 'B') {\n                sum += factorialRec(11);\n            }else if(strx.charAt(i) == 'C') {\n                sum += factorialRec(12);\n            }else {\n                sum += factorialRec(Integer.parseInt(String.valueOf(strx.charAt(i)), base));\n            }\n        }\n        return sum;\n    }\n    \n    static char reVal(int num) {\n        if (num >= 0 && num <= 9)\n            return (char)(num + 48);\n        else\n            return (char)(num - 10 + 65);\n    }\n    static String fromDeci(int base, int num){\n        StringBuilder s = new StringBuilder();\n        while (num > 0) {\n            s.append(reVal(num % base));\n            num /= base;\n        }\n        return new String(new StringBuilder(s).reverse());\n    }\n}\n"}
{"id": 392511, "name": "Factorions", "source": "Translate Swift to Java: var fact = Array(repeating: 0, count: 12)\n\nfact[0] = 1\n\nfor n in 1..<12 {\n  fact[n] = fact[n - 1] * n\n}\n\nfor b in 9...12 {\n  print(\"The factorions for base \\(b) are:\")\n\n  for i in 1..<1500000 {\n    var sum = 0\n    var j = i\n\n    while j > 0 {\n      sum += fact[j % b]\n      j /= b\n    }\n\n    if sum == i {\n      print(\"\\(i)\", terminator: \" \")\n      fflush(stdout)\n    }\n  }\n\n  print(\"\\n\")\n}\n", "target": "public class Factorion {\n    public static void main(String [] args){\n        System.out.println(\"Base 9:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,9);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 10:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,10);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 11:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,11);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 12:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,12);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n    }\n    public static int factorialRec(int n){\n        int result = 1;\n        return n == 0 ? result : result * n * factorialRec(n-1);\n    }\n\n    public static int operate(String s, int base){\n        int sum = 0;\n        String strx = fromDeci(base, Integer.parseInt(s));\n        for(int i = 0; i < strx.length(); i++){\n            if(strx.charAt(i) == 'A'){\n                sum += factorialRec(10);\n            }else if(strx.charAt(i) == 'B') {\n                sum += factorialRec(11);\n            }else if(strx.charAt(i) == 'C') {\n                sum += factorialRec(12);\n            }else {\n                sum += factorialRec(Integer.parseInt(String.valueOf(strx.charAt(i)), base));\n            }\n        }\n        return sum;\n    }\n    \n    static char reVal(int num) {\n        if (num >= 0 && num <= 9)\n            return (char)(num + 48);\n        else\n            return (char)(num - 10 + 65);\n    }\n    static String fromDeci(int base, int num){\n        StringBuilder s = new StringBuilder();\n        while (num > 0) {\n            s.append(reVal(num % base));\n            num /= base;\n        }\n        return new String(new StringBuilder(s).reverse());\n    }\n}\n"}
{"id": 392512, "name": "Tau function", "source": "Translate Swift to Java: import Foundation\n\n\nfunc divisorCount(number: Int) -> Int {\n    var n = number\n    var total = 1\n    \n    while (n & 1) == 0 {\n        total += 1\n        n >>= 1\n    }\n    \n    var p = 3\n    while p * p <= n {\n        var count = 1\n        while n % p == 0 {\n            count += 1\n            n /= p\n        }\n        total *= count\n        p += 2\n    }\n    \n    if n > 1 {\n        total *= 2\n    }\n    return total\n}\n\nlet limit = 100\nprint(\"Count of divisors for the first \\(limit) positive integers:\")\nfor n in 1...limit {\n    print(String(format: \"%3d\", divisorCount(number: n)), terminator: \"\")\n    if n % 20 == 0 {\n        print()\n    }\n}\n", "target": "public class TauFunction {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 100;\n        System.out.printf(\"Count of divisors for the first %d positive integers:\\n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%3d\", divisorCount(n));\n            if (n % 20 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 392513, "name": "Tau function", "source": "Translate Swift to Java: import Foundation\n\n\nfunc divisorCount(number: Int) -> Int {\n    var n = number\n    var total = 1\n    \n    while (n & 1) == 0 {\n        total += 1\n        n >>= 1\n    }\n    \n    var p = 3\n    while p * p <= n {\n        var count = 1\n        while n % p == 0 {\n            count += 1\n            n /= p\n        }\n        total *= count\n        p += 2\n    }\n    \n    if n > 1 {\n        total *= 2\n    }\n    return total\n}\n\nlet limit = 100\nprint(\"Count of divisors for the first \\(limit) positive integers:\")\nfor n in 1...limit {\n    print(String(format: \"%3d\", divisorCount(number: n)), terminator: \"\")\n    if n % 20 == 0 {\n        print()\n    }\n}\n", "target": "public class TauFunction {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 100;\n        System.out.printf(\"Count of divisors for the first %d positive integers:\\n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%3d\", divisorCount(n));\n            if (n % 20 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 392514, "name": "Execute Brain____", "source": "Translate Swift to Java: import Foundation\n\nlet valids = [\">\", \"<\", \"+\", \"-\", \".\", \",\", \"[\", \"]\"] as Set<Character>\nvar ip = 0\nvar dp = 0\nvar data = [UInt8](count: 30_000, repeatedValue: 0)\n\nlet input = Process.arguments\n\nif input.count != 2 {\n    fatalError(\"Need one input file\")\n}\n\nlet infile: String!\n\ndo {\n    infile = try String(contentsOfFile: input[1], encoding: NSUTF8StringEncoding) ?? \"\"\n} catch let err {\n    infile = \"\"\n}\n\nvar program = \"\"\n\n\nfor c in infile.characters {\n    if valids.contains(c) {\n        program += String(c)\n    }\n}\n\nlet numChars = program.characters.count\n\nif numChars == 0 {\n    fatalError(\"Error reading file\")\n}\n\nfunc increaseInstructionPointer() {\n    ip += 1\n}\n\nfunc executeInstruction(ins: Character) {\n    switch ins {\n    case \">\":\n        dp += 1\n        increaseInstructionPointer()\n    case \"<\":\n        dp -= 1\n        increaseInstructionPointer()\n    case \"+\":\n        data[dp] = data[dp] &+ 1\n        increaseInstructionPointer()\n    case \"-\":\n        data[dp] = data[dp] &- 1\n        increaseInstructionPointer()\n    case \".\":\n        print(Character(UnicodeScalar(data[dp])), terminator: \"\")\n        increaseInstructionPointer()\n    case \",\":\n        handleIn()\n        increaseInstructionPointer()\n    case \"[\":\n        handleOpenBracket()\n    case \"]\":\n        handleClosedBracket()\n    default:\n        fatalError(\"What\")\n    }\n}\n\nfunc handleIn() {\n    let input = NSFileHandle.fileHandleWithStandardInput()\n    let bytes = input.availableData.bytes\n    let buf = unsafeBitCast(UnsafeBufferPointer(start: bytes, count: 1),\n        UnsafeBufferPointer<UInt8>.self)\n    \n    data[dp] = buf[0]\n}\n\nfunc handleOpenBracket() {\n    if data[dp] == 0 {\n        var i = 1\n        \n        while i > 0 {\n            ip += 1\n            let ins = program[program.startIndex.advancedBy(ip)]\n            \n            if ins == \"[\" {\n                i += 1\n            } else if ins == \"]\" {\n                i -= 1\n            }\n        }\n    } else {\n        increaseInstructionPointer()\n    }\n}\n\nfunc handleClosedBracket() {\n    if data[dp] != 0 {\n        var i = 1\n        \n        while i > 0 {\n            ip -= 1\n            let ins = program[program.startIndex.advancedBy(ip)]\n            \n            if ins == \"[\" {\n                i -= 1\n            } else if ins == \"]\" {\n                i += 1\n            }\n        }\n    } else {\n        increaseInstructionPointer()\n    }\n}\n\nfunc tick() {\n    let ins = program[program.startIndex.advancedBy(ip)]\n    \n    if valids.contains(ins) {\n        executeInstruction(ins)\n    } else {\n        increaseInstructionPointer()\n    }\n}\n\nwhile ip != numChars {\n    tick()\n}\n", "target": "import java.io.IOException;\n\npublic class Interpreter {\n\n    public final static int MEMORY_SIZE = 65536;\n\n    private final char[] memory = new char[MEMORY_SIZE];\n    private int dp;\n    private int ip;\n    private int border;\n\n    private void reset() {\n\n        for (int i = 0; i < MEMORY_SIZE; i++) {\n            memory[i] = 0;\n        }\n        ip = 0;\n        dp = 0;\n    }\n\n    private void load(String program) {\n\n        if (program.length() > MEMORY_SIZE - 2) {\n            throw new RuntimeException(\"Not enough memory.\");\n        }\n\n        reset();\n\n        for (; dp < program.length(); dp++) {\n            memory[dp] = program.charAt(dp);\n        }\n\n        \n        \n        border = dp;\n\n        dp += 1;\n    }\n\n    public void execute(String program) {\n\n        load(program);\n        char instruction = memory[ip];\n\n        while (instruction != 0) {\n\n            switch (instruction) {\n                case '>':\n                    dp++;\n                    if (dp == MEMORY_SIZE) {\n                        throw new RuntimeException(\"Out of memory.\");\n                    }\n                    break;\n                case '<':\n                    dp--;\n                    if (dp == border) {\n                        throw new RuntimeException(\"Invalid data pointer.\");\n                    }\n                    break;\n                case '+':\n                    memory[dp]++;\n                    break;\n                case '-':\n                    memory[dp]--;\n                    break;\n                case '.':\n                    System.out.print(memory[dp]);\n                    break;\n                case ',':\n                    try {\n                        \n                        memory[dp] = (char) System.in.read();\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                case '[':\n                    if (memory[dp] == 0) {\n                        skipLoop();\n                    }\n                    break;\n                case ']':\n                    if (memory[dp] != 0) {\n                        loop();\n                    }\n                    break;\n                default:\n                    throw new RuntimeException(\"Unknown instruction.\");\n            }\n\n            instruction = memory[++ip];\n        }\n    }\n\n    private void skipLoop() {\n\n        int loopCount = 0;\n\n        while (memory[ip] != 0) {\n            if (memory[ip] == '[') {\n                loopCount++;\n            } else if (memory[ip] == ']') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip++;\n        }\n\n        if (memory[ip] == 0) {\n            throw new RuntimeException(\"Unable to find a matching ']'.\");\n        }\n    }\n\n    private void loop() {\n\n        int loopCount = 0;\n\n        while (ip >= 0) {\n            if (memory[ip] == ']') {\n                loopCount++;\n            } else if (memory[ip] == '[') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip--;\n        }\n\n        if (ip == -1) {\n            throw new RuntimeException(\"Unable to find a matching '['.\");\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Interpreter interpreter = new Interpreter();\n        interpreter.execute(\">++++++++[-<+++++++++>]<.>>+>-[+]++>++>+++[>[->+++<<+++>]<<]>-----.>->+++..+++.>-.<<+[>[+>+]>>]<--------------.>>.+++.------.--------.>+.>+.\");\n    }\n}\n"}
{"id": 392515, "name": "Execute Brain____", "source": "Translate Swift to Java: import Foundation\n\nlet valids = [\">\", \"<\", \"+\", \"-\", \".\", \",\", \"[\", \"]\"] as Set<Character>\nvar ip = 0\nvar dp = 0\nvar data = [UInt8](count: 30_000, repeatedValue: 0)\n\nlet input = Process.arguments\n\nif input.count != 2 {\n    fatalError(\"Need one input file\")\n}\n\nlet infile: String!\n\ndo {\n    infile = try String(contentsOfFile: input[1], encoding: NSUTF8StringEncoding) ?? \"\"\n} catch let err {\n    infile = \"\"\n}\n\nvar program = \"\"\n\n\nfor c in infile.characters {\n    if valids.contains(c) {\n        program += String(c)\n    }\n}\n\nlet numChars = program.characters.count\n\nif numChars == 0 {\n    fatalError(\"Error reading file\")\n}\n\nfunc increaseInstructionPointer() {\n    ip += 1\n}\n\nfunc executeInstruction(ins: Character) {\n    switch ins {\n    case \">\":\n        dp += 1\n        increaseInstructionPointer()\n    case \"<\":\n        dp -= 1\n        increaseInstructionPointer()\n    case \"+\":\n        data[dp] = data[dp] &+ 1\n        increaseInstructionPointer()\n    case \"-\":\n        data[dp] = data[dp] &- 1\n        increaseInstructionPointer()\n    case \".\":\n        print(Character(UnicodeScalar(data[dp])), terminator: \"\")\n        increaseInstructionPointer()\n    case \",\":\n        handleIn()\n        increaseInstructionPointer()\n    case \"[\":\n        handleOpenBracket()\n    case \"]\":\n        handleClosedBracket()\n    default:\n        fatalError(\"What\")\n    }\n}\n\nfunc handleIn() {\n    let input = NSFileHandle.fileHandleWithStandardInput()\n    let bytes = input.availableData.bytes\n    let buf = unsafeBitCast(UnsafeBufferPointer(start: bytes, count: 1),\n        UnsafeBufferPointer<UInt8>.self)\n    \n    data[dp] = buf[0]\n}\n\nfunc handleOpenBracket() {\n    if data[dp] == 0 {\n        var i = 1\n        \n        while i > 0 {\n            ip += 1\n            let ins = program[program.startIndex.advancedBy(ip)]\n            \n            if ins == \"[\" {\n                i += 1\n            } else if ins == \"]\" {\n                i -= 1\n            }\n        }\n    } else {\n        increaseInstructionPointer()\n    }\n}\n\nfunc handleClosedBracket() {\n    if data[dp] != 0 {\n        var i = 1\n        \n        while i > 0 {\n            ip -= 1\n            let ins = program[program.startIndex.advancedBy(ip)]\n            \n            if ins == \"[\" {\n                i -= 1\n            } else if ins == \"]\" {\n                i += 1\n            }\n        }\n    } else {\n        increaseInstructionPointer()\n    }\n}\n\nfunc tick() {\n    let ins = program[program.startIndex.advancedBy(ip)]\n    \n    if valids.contains(ins) {\n        executeInstruction(ins)\n    } else {\n        increaseInstructionPointer()\n    }\n}\n\nwhile ip != numChars {\n    tick()\n}\n", "target": "import java.io.IOException;\n\npublic class Interpreter {\n\n    public final static int MEMORY_SIZE = 65536;\n\n    private final char[] memory = new char[MEMORY_SIZE];\n    private int dp;\n    private int ip;\n    private int border;\n\n    private void reset() {\n\n        for (int i = 0; i < MEMORY_SIZE; i++) {\n            memory[i] = 0;\n        }\n        ip = 0;\n        dp = 0;\n    }\n\n    private void load(String program) {\n\n        if (program.length() > MEMORY_SIZE - 2) {\n            throw new RuntimeException(\"Not enough memory.\");\n        }\n\n        reset();\n\n        for (; dp < program.length(); dp++) {\n            memory[dp] = program.charAt(dp);\n        }\n\n        \n        \n        border = dp;\n\n        dp += 1;\n    }\n\n    public void execute(String program) {\n\n        load(program);\n        char instruction = memory[ip];\n\n        while (instruction != 0) {\n\n            switch (instruction) {\n                case '>':\n                    dp++;\n                    if (dp == MEMORY_SIZE) {\n                        throw new RuntimeException(\"Out of memory.\");\n                    }\n                    break;\n                case '<':\n                    dp--;\n                    if (dp == border) {\n                        throw new RuntimeException(\"Invalid data pointer.\");\n                    }\n                    break;\n                case '+':\n                    memory[dp]++;\n                    break;\n                case '-':\n                    memory[dp]--;\n                    break;\n                case '.':\n                    System.out.print(memory[dp]);\n                    break;\n                case ',':\n                    try {\n                        \n                        memory[dp] = (char) System.in.read();\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                case '[':\n                    if (memory[dp] == 0) {\n                        skipLoop();\n                    }\n                    break;\n                case ']':\n                    if (memory[dp] != 0) {\n                        loop();\n                    }\n                    break;\n                default:\n                    throw new RuntimeException(\"Unknown instruction.\");\n            }\n\n            instruction = memory[++ip];\n        }\n    }\n\n    private void skipLoop() {\n\n        int loopCount = 0;\n\n        while (memory[ip] != 0) {\n            if (memory[ip] == '[') {\n                loopCount++;\n            } else if (memory[ip] == ']') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip++;\n        }\n\n        if (memory[ip] == 0) {\n            throw new RuntimeException(\"Unable to find a matching ']'.\");\n        }\n    }\n\n    private void loop() {\n\n        int loopCount = 0;\n\n        while (ip >= 0) {\n            if (memory[ip] == ']') {\n                loopCount++;\n            } else if (memory[ip] == '[') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip--;\n        }\n\n        if (ip == -1) {\n            throw new RuntimeException(\"Unable to find a matching '['.\");\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Interpreter interpreter = new Interpreter();\n        interpreter.execute(\">++++++++[-<+++++++++>]<.>>+>-[+]++>++>+++[>[->+++<<+++>]<<]>-----.>->+++..+++.>-.<<+[>[+>+]>>]<--------------.>>.+++.------.--------.>+.>+.\");\n    }\n}\n"}
{"id": 392516, "name": "Mertens function", "source": "Translate Swift to Java: import Foundation\n\nfunc mertensNumbers(max: Int) -> [Int] {\n    var mertens = Array(repeating: 1, count: max + 1)\n    for n in 2...max {\n        for k in 2...n {\n            mertens[n] -= mertens[n / k]\n        }\n    }\n    return mertens\n}\n\nlet max = 1000\nlet mertens = mertensNumbers(max: max)\n\nlet count = 200\nlet columns = 20\nprint(\"First \\(count - 1) Mertens numbers:\")\nfor i in 0..<count {\n    if i % columns > 0 {\n        print(\" \", terminator: \"\")\n    }\n    print(i == 0 ? \"  \" : String(format: \"%2d\", mertens[i]), terminator: \"\")\n    if (i + 1) % columns == 0 {\n        print()\n    }\n}\n\nvar zero = 0, cross = 0, previous = 0\nfor i in 1...max {\n    let m = mertens[i]\n    if m == 0 {\n        zero += 1\n        if previous != 0 {\n            cross += 1\n        }\n    }\n    previous = m\n}\nprint(\"M(n) is zero \\(zero) times for 1 <= n <= \\(max).\")\nprint(\"M(n) crosses zero \\(cross) times for 1 <= n <= \\(max).\")\n", "target": "public class MertensFunction {\n\n    public static void main(String[] args) {\n        System.out.printf(\"First 199 terms of the merten function are as follows:%n    \");\n        for ( int n = 1 ; n < 200 ; n++ ) {\n            System.out.printf(\"%2d  \", mertenFunction(n));\n            if ( (n+1) % 20 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n        \n        for ( int exponent = 3 ; exponent<= 8 ; exponent++ ) {\n            int zeroCount = 0;\n            int zeroCrossingCount = 0;\n            int positiveCount = 0;\n            int negativeCount = 0;\n            int mSum = 0;\n            int mMin = Integer.MAX_VALUE;\n            int mMinIndex = 0;\n            int mMax = Integer.MIN_VALUE;\n            int mMaxIndex = 0;\n            int nMax = (int) Math.pow(10, exponent);\n            for ( int n = 1 ; n <= nMax ; n++ ) {\n                int m = mertenFunction(n);\n                mSum += m;\n                if ( m < mMin ) {\n                    mMin = m;\n                    mMinIndex = n;\n                }\n                if ( m > mMax ) {\n                    mMax = m;\n                    mMaxIndex = n;\n                }\n                if ( m > 0 ) {\n                    positiveCount++;\n                }\n                if ( m < 0 ) {\n                    negativeCount++;\n                }\n                if ( m == 0 ) {\n                    zeroCount++;\n                }\n                if ( m == 0 && mertenFunction(n - 1) != 0 ) {\n                    zeroCrossingCount++;\n                }\n            }\n            System.out.printf(\"%nFor M(x) with x from 1 to\u00a0%,d%n\", nMax);        \n            System.out.printf(\"The maximum of M(x) is M(%,d) =\u00a0%,d.%n\", mMaxIndex, mMax);\n            System.out.printf(\"The minimum of M(x) is M(%,d) =\u00a0%,d.%n\", mMinIndex, mMin);\n            System.out.printf(\"The sum of M(x) is\u00a0%,d.%n\", mSum);\n            System.out.printf(\"The count of positive M(x) is\u00a0%,d, count of negative M(x) is\u00a0%,d.%n\", positiveCount, negativeCount);\n            System.out.printf(\"M(x) has\u00a0%,d zeroes in the interval.%n\", zeroCount);\n            System.out.printf(\"M(x) has\u00a0%,d crossings in the interval.%n\", zeroCrossingCount);\n        }\n    }\n    \n    private static int MU_MAX = 100_000_000;\n    private static int[] MU = null;\n    private static int[] MERTEN = null;\n        \n    \n    private static int mertenFunction(int n) {\n        if ( MERTEN != null ) {\n            return MERTEN[n];\n        }\n        \n        \n        MU = new int[MU_MAX+1];\n        MERTEN = new int[MU_MAX+1];\n        MERTEN[1] = 1;\n        int sqrt = (int) Math.sqrt(MU_MAX);\n        for ( int i = 0 ; i < MU_MAX ; i++ ) {\n            MU[i] = 1;\n        }\n        \n        for ( int i = 2 ; i <= sqrt ; i++ ) {\n            if ( MU[i] == 1 ) {\n                \n                for ( int j = i ; j <= MU_MAX ; j += i ) {\n                    MU[j] *= -i;\n                }\n                \n                for ( int j = i*i ; j <= MU_MAX ; j += i*i ) {\n                    MU[j] = 0;\n                }\n            }\n        }\n        \n        int sum = 1;\n        for ( int i = 2 ; i <= MU_MAX ; i++ ) {\n            if ( MU[i] == i ) {\n                MU[i] = 1;\n            }\n            else if ( MU[i] == -i ) {\n                MU[i] = -1;\n            }\n            else if ( MU[i] < 0 ) {\n                MU[i] = 1;               \n            }\n            else if ( MU[i] > 0 ) {\n                MU[i] = -1;\n            }\n            sum += MU[i];\n            MERTEN[i] = sum;\n        }\n        return MERTEN[n];\n    }\n\n}\n"}
{"id": 392517, "name": "Playing cards", "source": "Translate Swift to Java: struct Card: CustomStringConvertible\n{\n\tenum Suit: String, CaseIterable, CustomStringConvertible\n\t{\n\t\tcase clubs = \"\u2663\ufe0f\"\n\t\tcase diamonds = \"\u2666\ufe0f\"\n\t\tcase hearts = \"\u2665\ufe0f\"\n\t\tcase spades = \"\u2660\ufe0f\"\n\n\t\tvar description: String { rawValue }\n\t}\n\n\tlet suit: Suit\n\tlet value: Int\n\n\tvar description: String\n\t{\n\t\tlet valueAsString: String\n\t\tswitch value\n\t\t{\n\t\tcase 1:\n\t\t\tvalueAsString = \"A\"\n\t\tcase 11:\n\t\t\tvalueAsString = \"J\"\n\t\tcase 12:\n\t\t\tvalueAsString = \"Q\"\n\t\tcase 13:\n\t\t\tvalueAsString = \"K\"\n\t\tdefault:\n\t\t\tvalueAsString = \"\\(value)\"\n\t\t}\n\t\treturn valueAsString + suit.description\n\t}\n}\n\nstruct Deck: CustomStringConvertible\n{\n\tvar cards: [Card] = []\n\n\tinit()\n\t{\n\t\tfor suit in Card.Suit.allCases\n\t\t{\n\t\t\tfor faceValue in 1 ... 13\n\t\t\t{\n\t\t\t\tcards.append(Card(suit: suit, value: faceValue))\n\t\t\t}\n\t\t}\n\t}\n\n\tvar description: String\n\t{\n\t\tString(cards.map{ $0.description }.joined(separator: \", \"))\n\t}\n\n\tmutating func shuffle()\n\t{\n\t\tcards.shuffle()\n\t}\n\n\tmutating func dealCard() -> Card?\n\t{\n\t\tguard !cards.isEmpty else { return nil }\n\t\treturn cards.removeLast()\n\t}\n}\n\nvar deck = Deck()\nprint(\"New deck:\")\nprint(deck)\ndeck.shuffle()\nprint(\"Shuffled deck:\")\nprint(deck)\n\nvar hands: [[Card]] = [[], [], [], []]\n\nvar handIndex = 0\n\nwhile let card = deck.dealCard()\n{\n\thands[handIndex].append(card)\n\thandIndex = (handIndex + 1) % hands.count\n}\n\nprint (\"Hands:\")\nprint(hands.map({ $0.description }).joined(separator: \"\\n\"))\nprint(\"Remaining deck (should be empty):\")\nprint(deck)\n", "target": "public enum Pip { Two, Three, Four, Five, Six, Seven, \n    Eight, Nine, Ten, Jack, Queen, King, Ace }\n"}
{"id": 392518, "name": "Perfect totient numbers", "source": "Translate Swift to Java: public func totient(n: Int) -> Int {\n  var n = n\n  var i = 2\n  var tot = n\n\n  while i * i <= n {\n    if n % i == 0 {\n      while n % i == 0 {\n        n /= i\n      }\n\n      tot -= tot / i\n    }\n\n    if i == 2 {\n      i = 1\n    }\n\n    i += 2\n  }\n\n  if n > 1 {\n    tot -= tot / n\n  }\n\n  return tot\n}\n\npublic struct PerfectTotients: Sequence, IteratorProtocol {\n  private var m = 1\n\n  public init() { }\n\n  public mutating func next() -> Int? {\n    while true {\n      defer {\n        m += 1\n      }\n\n      var tot = m\n      var sum = 0\n\n      while tot != 1 {\n        tot = totient(n: tot)\n        sum += tot\n      }\n\n      if sum == m {\n        return m\n      }\n    }\n  }\n}\n\nprint(\"The first 20 perfect totient numbers are:\")\nprint(Array(PerfectTotients().prefix(20)))\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PerfectTotientNumbers {\n\n    public static void main(String[] args) {\n        computePhi();\n        int n = 20;\n        System.out.printf(\"The first %d perfect totient numbers:%n%s%n\", n, perfectTotient(n));\n    }\n    \n    private static final List<Integer> perfectTotient(int n) {\n        int test = 2;\n        List<Integer> results = new ArrayList<Integer>();\n        for ( int i = 0 ; i < n ; test++ ) {\n            int phiLoop = test;\n            int sum = 0;\n            do {\n                phiLoop = phi[phiLoop];\n                sum += phiLoop;\n            } while ( phiLoop > 1);\n            if ( sum == test ) {\n                i++;\n                results.add(test);\n            }\n        }\n        return results;\n    }\n\n    private static final int max = 100000;\n    private static final int[] phi = new int[max+1];\n\n    private static final void computePhi() {\n        for ( int i = 1 ; i <= max ; i++ ) {\n            phi[i] = i;\n        }\n        for ( int i = 2 ; i <= max ; i++ ) {\n            if (phi[i] < i) continue;\n            for ( int j = i ; j <= max ; j += i ) {\n                phi[j] -= phi[j] / i;\n            }\n        }\n    }\n\n}\n"}
{"id": 392519, "name": "Perfect totient numbers", "source": "Translate Swift to Java: public func totient(n: Int) -> Int {\n  var n = n\n  var i = 2\n  var tot = n\n\n  while i * i <= n {\n    if n % i == 0 {\n      while n % i == 0 {\n        n /= i\n      }\n\n      tot -= tot / i\n    }\n\n    if i == 2 {\n      i = 1\n    }\n\n    i += 2\n  }\n\n  if n > 1 {\n    tot -= tot / n\n  }\n\n  return tot\n}\n\npublic struct PerfectTotients: Sequence, IteratorProtocol {\n  private var m = 1\n\n  public init() { }\n\n  public mutating func next() -> Int? {\n    while true {\n      defer {\n        m += 1\n      }\n\n      var tot = m\n      var sum = 0\n\n      while tot != 1 {\n        tot = totient(n: tot)\n        sum += tot\n      }\n\n      if sum == m {\n        return m\n      }\n    }\n  }\n}\n\nprint(\"The first 20 perfect totient numbers are:\")\nprint(Array(PerfectTotients().prefix(20)))\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PerfectTotientNumbers {\n\n    public static void main(String[] args) {\n        computePhi();\n        int n = 20;\n        System.out.printf(\"The first %d perfect totient numbers:%n%s%n\", n, perfectTotient(n));\n    }\n    \n    private static final List<Integer> perfectTotient(int n) {\n        int test = 2;\n        List<Integer> results = new ArrayList<Integer>();\n        for ( int i = 0 ; i < n ; test++ ) {\n            int phiLoop = test;\n            int sum = 0;\n            do {\n                phiLoop = phi[phiLoop];\n                sum += phiLoop;\n            } while ( phiLoop > 1);\n            if ( sum == test ) {\n                i++;\n                results.add(test);\n            }\n        }\n        return results;\n    }\n\n    private static final int max = 100000;\n    private static final int[] phi = new int[max+1];\n\n    private static final void computePhi() {\n        for ( int i = 1 ; i <= max ; i++ ) {\n            phi[i] = i;\n        }\n        for ( int i = 2 ; i <= max ; i++ ) {\n            if (phi[i] < i) continue;\n            for ( int j = i ; j <= max ; j += i ) {\n                phi[j] -= phi[j] / i;\n            }\n        }\n    }\n\n}\n"}
{"id": 392520, "name": "Lah numbers", "source": "Translate Swift to Java: import BigInt\nimport Foundation\n\n@inlinable\npublic func factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\n@inlinable\npublic func lah<T: BinaryInteger>(n: T, k: T) -> T {\n  if k == 1 {\n    return factorial(n)\n  } else if k == n {\n    return 1\n  } else if k > n {\n    return 0\n  } else if k < 1 || n < 1 {\n    return 0\n  } else {\n    let a = (factorial(n) * factorial(n - 1))\n    let b = (factorial(k) * factorial(k - 1))\n    let c = factorial(n - k)\n\n    return a / b / c\n  }\n}\n\nprint(\"Unsigned Lah numbers: L(n, k):\")\nprint(\"n\\\\k\", terminator: \"\")\n\nfor i in 0...12 {\n  print(String(format: \"%10d\", i), terminator: \" \")\n}\n\nprint()\n\nfor row in 0...12 {\n  print(String(format: \"%-2d\", row), terminator: \"\")\n\n  for i in 0...row {\n    lah(n: BigInt(row), k: BigInt(i)).description.withCString {str in\n      print(String(format: \"%11s\", str), terminator: \"\")\n    }\n  }\n\n  print()\n}\n\nlet maxLah = (0...100).map({ lah(n: BigInt(100), k: BigInt($0)) }).max()!\n\nprint(\"Maximum value from the L(100, *) row: \\(maxLah)\")\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LahNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the unsigned Lah numbers up to n = 12:\");\n        for ( int n = 0 ; n <= 12 ; n++ ) {\n            System.out.printf(\"%5s\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%12s\", lahNumber(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        \n        System.out.println(\"Show the maximum value of L(100, k):\");\n        int n = 100;\n        BigInteger max = BigInteger.ZERO;\n        for ( int k = 0 ; k <= n ; k++ ) {\n            max = max.max(lahNumber(n, k));\n        }\n        System.out.printf(\"%s\", max);\n    }\n    \n    private static Map<String,BigInteger> CACHE = new HashMap<>();\n    \n    private static BigInteger lahNumber(int n, int k) {\n        String key = n + \",\" + k;\n        if ( CACHE.containsKey(key) ) {\n            return CACHE.get(key);\n        }\n        \n        \n        BigInteger result;\n        if ( n == 0 && k == 0 ) {\n            result = BigInteger.ONE;\n        }\n        else if ( k == 0 ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( k > n ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( n == 1 && k == 1 ) {\n            result = BigInteger.ONE;\n        }\n        else {\n            result = BigInteger.valueOf(n-1+k).multiply(lahNumber(n-1,k)).add(lahNumber(n-1,k-1));\n        }\n        \n        CACHE.put(key, result);\n        \n        return result;\n    }\n\n}\n"}
{"id": 392521, "name": "Lah numbers", "source": "Translate Swift to Java: import BigInt\nimport Foundation\n\n@inlinable\npublic func factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\n@inlinable\npublic func lah<T: BinaryInteger>(n: T, k: T) -> T {\n  if k == 1 {\n    return factorial(n)\n  } else if k == n {\n    return 1\n  } else if k > n {\n    return 0\n  } else if k < 1 || n < 1 {\n    return 0\n  } else {\n    let a = (factorial(n) * factorial(n - 1))\n    let b = (factorial(k) * factorial(k - 1))\n    let c = factorial(n - k)\n\n    return a / b / c\n  }\n}\n\nprint(\"Unsigned Lah numbers: L(n, k):\")\nprint(\"n\\\\k\", terminator: \"\")\n\nfor i in 0...12 {\n  print(String(format: \"%10d\", i), terminator: \" \")\n}\n\nprint()\n\nfor row in 0...12 {\n  print(String(format: \"%-2d\", row), terminator: \"\")\n\n  for i in 0...row {\n    lah(n: BigInt(row), k: BigInt(i)).description.withCString {str in\n      print(String(format: \"%11s\", str), terminator: \"\")\n    }\n  }\n\n  print()\n}\n\nlet maxLah = (0...100).map({ lah(n: BigInt(100), k: BigInt($0)) }).max()!\n\nprint(\"Maximum value from the L(100, *) row: \\(maxLah)\")\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LahNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the unsigned Lah numbers up to n = 12:\");\n        for ( int n = 0 ; n <= 12 ; n++ ) {\n            System.out.printf(\"%5s\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%12s\", lahNumber(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        \n        System.out.println(\"Show the maximum value of L(100, k):\");\n        int n = 100;\n        BigInteger max = BigInteger.ZERO;\n        for ( int k = 0 ; k <= n ; k++ ) {\n            max = max.max(lahNumber(n, k));\n        }\n        System.out.printf(\"%s\", max);\n    }\n    \n    private static Map<String,BigInteger> CACHE = new HashMap<>();\n    \n    private static BigInteger lahNumber(int n, int k) {\n        String key = n + \",\" + k;\n        if ( CACHE.containsKey(key) ) {\n            return CACHE.get(key);\n        }\n        \n        \n        BigInteger result;\n        if ( n == 0 && k == 0 ) {\n            result = BigInteger.ONE;\n        }\n        else if ( k == 0 ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( k > n ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( n == 1 && k == 1 ) {\n            result = BigInteger.ONE;\n        }\n        else {\n            result = BigInteger.valueOf(n-1+k).multiply(lahNumber(n-1,k)).add(lahNumber(n-1,k-1));\n        }\n        \n        CACHE.put(key, result);\n        \n        return result;\n    }\n\n}\n"}
{"id": 392522, "name": "Sorting algorithms_Cocktail sort with shifting bounds", "source": "Translate Swift to Java: func cocktailShakerSort<T: Comparable>(_ a: inout [T]) {\n    var begin = 0\n    var end = a.count\n    if end == 0 {\n        return\n    }\n    end -= 1\n    while begin < end {\n        var new_begin = end\n        var new_end = begin\n        var i = begin\n        while i < end {\n            if a[i + 1] < a[i] {\n                a.swapAt(i, i + 1)\n                new_end = i\n            }\n            i += 1\n        }\n        end = new_end\n        i = end\n        while i > begin {\n            if a[i] < a[i - 1] {\n                a.swapAt(i, i - 1)\n                new_begin = i\n            }\n            i -= 1\n        }\n        begin = new_begin\n    }\n}\n\nvar array = [5, 1, -6, 12, 3, 13, 2, 4, 0, 15]\nprint(\"before: \\(array)\")\ncocktailShakerSort(&array)\nprint(\" after: \\(array)\")\n\nvar array2 = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\"]\nprint(\"before: \\(array2)\")\ncocktailShakerSort(&array2)\nprint(\" after: \\(array2)\")\n", "target": "import java.util.*;\n\npublic class CocktailSort {\n    public static void main(String[] args) {\n        Integer[] array = new Integer[]{ 5, 1, -6, 12, 3, 13, 2, 4, 0, 15 };\n        System.out.println(\"before: \" + Arrays.toString(array));\n        cocktailSort(array);\n        System.out.println(\"after: \" + Arrays.toString(array));\n    }\n\n    \n    public static void cocktailSort(Object[] array) {\n        int begin = 0;\n        int end = array.length;\n        if (end == 0)\n            return;\n        for (--end; begin < end; ) {\n            int new_begin = end;\n            int new_end = begin;\n            for (int i = begin; i < end; ++i) {\n                Comparable c1 = (Comparable)array[i];\n                Comparable c2 = (Comparable)array[i + 1];\n                if (c1.compareTo(c2) > 0) {\n                    swap(array, i, i + 1);\n                    new_end = i;\n                }\n            }\n            end = new_end;\n            for (int i = end; i > begin; --i) {\n                Comparable c1 = (Comparable)array[i - 1];\n                Comparable c2 = (Comparable)array[i];\n                if (c1.compareTo(c2) > 0) {\n                    swap(array, i, i - 1);\n                    new_begin = i;\n                }\n            }\n            begin = new_begin;\n        }\n    }\n\n    private static void swap(Object[] array, int i, int j) {\n        Object tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}\n"}
{"id": 392523, "name": "Unprimeable numbers", "source": "Translate Swift to Java: import Foundation\n\nclass BitArray {\n    var array: [UInt32]\n\n    init(size: Int) {\n        array = Array(repeating: 0, count: (size + 31)/32)\n    }\n    \n    func get(index: Int) -> Bool {\n        let bit = UInt32(1) << (index & 31)\n        return (array[index >> 5] & bit) != 0\n    }\n    \n    func set(index: Int, value: Bool) {\n        let bit = UInt32(1) << (index & 31)\n        if value {\n            array[index >> 5] |= bit\n        } else {\n            array[index >> 5] &= ~bit\n        }\n    }\n}\n\nclass PrimeSieve {\n    let composite: BitArray\n    \n    init(size: Int) {\n        composite = BitArray(size: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite.get(index: p/2 - 1) {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite.set(index: q/2 - 1, value: true)\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite.get(index: number/2 - 1)\n    }\n}\n\n\nfunc countDigits(number: Int) -> Int {\n    var digits = 0\n    var n = number\n    while n > 0 {\n        n /= 10\n        digits += 1\n    }\n    return digits\n}\n\n\nfunc changeDigit(number: Int, index: Int, digit: Int) -> Int {\n    var p = 1\n    var changed = 0\n    var n = number\n    var i = index\n    while i > 0 {\n        changed += p * (n % 10)\n        p *= 10\n        n /= 10\n        i -= 1\n    }\n    changed += (10 * (n / 10) + digit) * p\n    return changed\n}\n\nfunc unprimeable(sieve: PrimeSieve, number: Int) -> Bool {\n    if sieve.isPrime(number: number) {\n        return false\n    }\n    for i in 0..<countDigits(number: number) {\n        for j in 0..<10 {\n            let n = changeDigit(number: number, index: i, digit: j)\n            if n != number && sieve.isPrime(number: n) {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nvar count = 0\nvar n = 100\nvar lowest = Array(repeating: 0, count: 10)\nvar found = 0\nlet sieve = PrimeSieve(size: 10000000)\nprint(\"First 35 unprimeable numbers:\")\nwhile count < 600 || found < 10 {\n    if unprimeable(sieve: sieve, number: n) {\n        if count < 35 {\n            if count > 0 {\n                print(\", \", terminator: \"\")\n            }\n            print(n, terminator: \"\")\n        }\n        count += 1\n        if count == 600 {\n            print(\"\\n600th unprimeable number: \\(n)\")\n        }\n        let lastDigit = n % 10\n        if lowest[lastDigit] == 0 {\n            lowest[lastDigit] = n\n            found += 1\n        }\n    }\n    n += 1\n}\nfor i in 0..<10 {\n    let number = NSNumber(value: lowest[i])\n    let str = NumberFormatter.localizedString(from: number, number: .decimal)\n    print(\"Least unprimeable number ending in \\(i): \\(str)\")\n}\n", "target": "public class UnprimeableNumbers {\n\n    private static int MAX = 10_000_000;\n    private static boolean[] primes = new boolean[MAX];\n\n    public static void main(String[] args) {\n        sieve();\n        System.out.println(\"First 35 unprimeable numbers:\");\n        displayUnprimeableNumbers(35);\n        int n = 600;\n        System.out.printf(\"%nThe %dth unprimeable number =\u00a0%,d%n%n\", n, nthUnprimeableNumber(n));\n        int[] lowest = genLowest();\n        System.out.println(\"Least unprimeable number that ends in:\");\n        for ( int i = 0 ; i <= 9 ; i++ ) {\n            System.out.printf(\" %d is\u00a0%,d%n\", i, lowest[i]);\n        }\n    }\n    \n    private static int[] genLowest() {\n        int[] lowest = new int[10];\n        int count = 0;\n        int test = 1;\n        while ( count < 10 ) {\n            test++;\n            if ( unPrimable(test) && lowest[test % 10] == 0 ) {\n                lowest[test % 10] = test;\n                count++;\n            }\n        }\n        return lowest;\n    }\n\n    private static int nthUnprimeableNumber(int maxCount) {\n        int test = 1;\n        int count = 0;\n        int result = 0;\n        while ( count < maxCount ) {\n            test++;\n            if ( unPrimable(test) ) {\n                count++;\n                result = test;\n            }\n        }\n        return result;\n    }\n\n    private static void displayUnprimeableNumbers(int maxCount) {\n        int test = 1;\n        int count = 0;\n        while ( count < maxCount ) {\n            test++;\n            if ( unPrimable(test) ) {\n                count++;\n                System.out.printf(\"%d \", test);\n            }\n        }\n        System.out.println();\n    }\n    \n    private static boolean unPrimable(int test) {\n        if ( primes[test] ) {\n            return false;\n        }\n        String s = test + \"\";\n        for ( int i = 0 ; i < s.length() ; i++ ) {\n            for ( int j = 0 ; j <= 9 ; j++ ) {\n                if ( primes[Integer.parseInt(replace(s, i, j))] ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    private static String replace(String str, int position, int value) {\n        char[] sChar = str.toCharArray();\n        sChar[position] = (char) value;\n        return str.substring(0, position) + value + str.substring(position + 1);\n    }\n\n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 392524, "name": "Tau number", "source": "Translate Swift to Java: import Foundation\n\n\nfunc divisorCount(number: Int) -> Int {\n    var n = number\n    var total = 1\n    \n    while (n & 1) == 0 {\n        total += 1\n        n >>= 1\n    }\n    \n    var p = 3\n    while p * p <= n {\n        var count = 1\n        while n % p == 0 {\n            count += 1\n            n /= p\n        }\n        total *= count\n        p += 2\n    }\n    \n    if n > 1 {\n        total *= 2\n    }\n    return total\n}\n\nlet limit = 100\nprint(\"The first \\(limit) tau numbers are:\")\nvar count = 0\nvar n = 1\nwhile count < limit {\n    if n % divisorCount(number: n) == 0 {\n        print(String(format: \"%5d\", n), terminator: \"\")\n        count += 1\n        if count % 10 == 0 {\n            print()\n        }\n    }\n    n += 1\n}\n", "target": "public class Tau {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final long limit = 100;\n        System.out.printf(\"The first %d tau numbers are:%n\", limit);\n        long count = 0;\n        for (long n = 1; count < limit; ++n) {\n            if (n % divisorCount(n) == 0) {\n                System.out.printf(\"%6d\", n);\n                ++count;\n                if (count % 10 == 0) {\n                    System.out.println();\n                }\n            }\n        }\n    }\n}\n"}
{"id": 392525, "name": "Modulinos", "source": "Translate Swift to Java: import Foundation\n\npublic class ScriptedMain {\n  public var meaningOfLife = 42\n\n  public init() {}\n\n  public class func main() {\n    var meaning = ScriptedMain().meaningOfLife\n\n    println(\"Main: The meaning of life is \\(meaning)\")\n  }\n}\n\n#if SCRIPTEDMAIN\n@objc class ScriptedMainAutoload {\n  @objc class func load() {\n    ScriptedMain.main()\n  }\n}\n#endif\n", "target": "public class ScriptedMain {\n\tpublic static int meaningOfLife() {\n\t\treturn 42;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Main: The meaning of life is \" + meaningOfLife());\n\t}\n}\n"}
{"id": 392526, "name": "Modulinos", "source": "Translate Swift to Java: import Foundation\n\npublic class ScriptedMain {\n  public var meaningOfLife = 42\n\n  public init() {}\n\n  public class func main() {\n    var meaning = ScriptedMain().meaningOfLife\n\n    println(\"Main: The meaning of life is \\(meaning)\")\n  }\n}\n\n#if SCRIPTEDMAIN\n@objc class ScriptedMainAutoload {\n  @objc class func load() {\n    ScriptedMain.main()\n  }\n}\n#endif\n", "target": "public class ScriptedMain {\n\tpublic static int meaningOfLife() {\n\t\treturn 42;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Main: The meaning of life is \" + meaningOfLife());\n\t}\n}\n"}
{"id": 392527, "name": "Find the last Sunday of each month", "source": "Translate Swift to Java: import Foundation\n\nfunc lastSundays(of year: Int) -> [Date] {\n\t\n\tlet calendar = Calendar.current\n\tvar dates = [Date]()\n\t\n\tfor month in 1...12 {\n\t\t\n\t\tvar dateComponents = DateComponents(calendar: calendar,\n\t\t                                    year: year,\n\t\t                                    month: month + 1,\n\t\t                                    day: 0,\n\t\t                                    hour: 12)\n\t\t\n\t\tlet date = calendar.date(from: dateComponents)!\n\t\tlet weekday = calendar.component(.weekday, from: date)\n\n\t\tif weekday != 1 {\n\t\t\tdateComponents.day! -= weekday - 1\n\t\t}\n\t\t\n\t\tdates.append(calendar.date(from: dateComponents)!)\n\t}\n\treturn dates\n}\n\nvar dateFormatter = DateFormatter()\ndateFormatter.dateStyle = .short\n\nprint(lastSundays(of: 2013).map(dateFormatter.string).joined(separator: \"\\n\"))\n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 392528, "name": "Find the last Sunday of each month", "source": "Translate Swift to Java: import Foundation\n\nfunc lastSundays(of year: Int) -> [Date] {\n\t\n\tlet calendar = Calendar.current\n\tvar dates = [Date]()\n\t\n\tfor month in 1...12 {\n\t\t\n\t\tvar dateComponents = DateComponents(calendar: calendar,\n\t\t                                    year: year,\n\t\t                                    month: month + 1,\n\t\t                                    day: 0,\n\t\t                                    hour: 12)\n\t\t\n\t\tlet date = calendar.date(from: dateComponents)!\n\t\tlet weekday = calendar.component(.weekday, from: date)\n\n\t\tif weekday != 1 {\n\t\t\tdateComponents.day! -= weekday - 1\n\t\t}\n\t\t\n\t\tdates.append(calendar.date(from: dateComponents)!)\n\t}\n\treturn dates\n}\n\nvar dateFormatter = DateFormatter()\ndateFormatter.dateStyle = .short\n\nprint(lastSundays(of: 2013).map(dateFormatter.string).joined(separator: \"\\n\"))\n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 392529, "name": "Teacup rim text", "source": "Translate Swift to Java: import Foundation\n\nfunc loadDictionary(_ path: String) throws -> Set<String> {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return Set<String>(contents.components(separatedBy: \"\\n\").filter{!$0.isEmpty})\n}\n\nfunc rotate<T>(_ array: inout [T]) {\n    guard array.count > 1 else {\n        return\n    }\n    let first = array[0]\n    array.replaceSubrange(0..<array.count-1, with: array[1...])\n    array[array.count - 1] = first\n}\n\nfunc findTeacupWords(_ dictionary: Set<String>) {\n    var teacupWords: [String] = []\n    var found = Set<String>()\n    for word in dictionary {\n        if word.count < 3 || found.contains(word) {\n            continue\n        }\n        teacupWords.removeAll()\n        var isTeacupWord = true\n        var chars = Array(word)\n        for _ in 1..<word.count {\n            rotate(&chars)\n            let w = String(chars)\n            if (!dictionary.contains(w)) {\n                isTeacupWord = false\n                break\n            }\n            if w != word && !teacupWords.contains(w) {\n                teacupWords.append(w)\n            }\n        }\n        if !isTeacupWord || teacupWords.isEmpty {\n            continue\n        }\n        print(word, terminator: \"\")\n        found.insert(word)\n        for w in teacupWords {\n            found.insert(w)\n            print(\" \\(w)\", terminator: \"\")\n        }\n        print()\n    }\n}\n\ndo {\n    let dictionary = try loadDictionary(\"unixdict.txt\")\n    findTeacupWords(dictionary)\n} catch {\n    print(error)\n}\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class Teacup {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"usage: java Teacup dictionary\");\n            System.exit(1);\n        }\n        try {\n            findTeacupWords(loadDictionary(args[0]));\n        } catch (Exception ex) {\n            System.err.println(ex.getMessage());\n        }\n    }\n\n    \n    private static Set<String> loadDictionary(String fileName) throws IOException {\n        Set<String> words = new TreeSet<>();\n        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n            String word;\n            while ((word = reader.readLine()) != null)\n                words.add(word);\n            return words;\n        }\n    }\n\n    private static void findTeacupWords(Set<String> words) {\n        List<String> teacupWords = new ArrayList<>();\n        Set<String> found = new HashSet<>();\n        for (String word : words) {\n            int len = word.length();\n            if (len < 3 || found.contains(word))\n                continue;\n            teacupWords.clear();\n            teacupWords.add(word);\n            char[] chars = word.toCharArray();\n            for (int i = 0; i < len - 1; ++i) {\n                String rotated = new String(rotate(chars));\n                if (rotated.equals(word) || !words.contains(rotated))\n                    break;\n                teacupWords.add(rotated);\n            }\n            if (teacupWords.size() == len) {\n                found.addAll(teacupWords);\n                System.out.print(word);\n                for (int i = 1; i < len; ++i)\n                    System.out.print(\" \" + teacupWords.get(i));\n                System.out.println();\n            }\n        }\n    }\n\n    private static char[] rotate(char[] ch) {\n        char c = ch[0];\n        System.arraycopy(ch, 1, ch, 0, ch.length - 1);\n        ch[ch.length - 1] = c;\n        return ch;\n    }\n}\n"}
{"id": 392530, "name": "Esthetic numbers", "source": "Translate Swift to Java: extension Sequence {\n  func take(_ n: Int) -> [Element] {\n    var res = [Element]()\n\n    for el in self {\n      guard res.count != n else {\n        return res\n      }\n\n      res.append(el)\n    }\n\n    return res\n  }\n}\n\nextension String {\n  func isEsthetic(base: Int = 10) -> Bool {\n    zip(dropFirst(0), dropFirst())\n      .lazy\n      .allSatisfy({ abs(Int(String($0.0), radix: base)! - Int(String($0.1), radix: base)!) == 1 })\n  }\n}\n\nfunc getEsthetics(from: Int, to: Int, base: Int = 10) -> [String] {\n  guard base >= 2, to >= from else {\n    return []\n  }\n\n  var start = \"\"\n  var end = \"\"\n\n  repeat {\n    if start.count & 1 == 1 {\n      start += \"0\"\n    } else {\n      start += \"1\"\n    }\n  } while Int(start, radix: base)! < from\n\n  let digiMax = String(base - 1, radix: base)\n  let lessThanDigiMax = String(base - 2, radix: base)\n  var count = 0\n\n  repeat {\n    if count != base - 1 {\n      end += String(count + 1, radix: base)\n      count += 1\n    } else {\n      if String(end.last!) == digiMax {\n        end += lessThanDigiMax\n      } else {\n        end += digiMax\n      }\n    }\n  } while Int(end, radix: base)! < to\n\n  if Int(start, radix: base)! >= Int(end, radix: base)! {\n    return []\n  }\n\n  var esthetics = [Int]()\n\n  func shimmer(_ n: Int, _ m: Int, _ i: Int) {\n    if (n...m).contains(i) {\n      esthetics.append(i)\n    } else if i == 0 || i > m {\n      return\n    }\n\n    let d = i % base\n    let i1 = i &* base &+ d &- 1\n    let i2 = i1 &+ 2\n\n    if (i1 < i || i2 < i) {\n      \n      return\n    }\n\n    switch d {\n    case 0: shimmer(n, m, i2)\n    case base-1: shimmer(n, m, i1)\n    case _:\n      shimmer(n, m, i1)\n      shimmer(n, m, i2)\n    }\n  }\n\n  for digit in 0..<base {\n    shimmer(Int(start, radix: base)!, Int(end, radix: base)!, digit)\n  }\n\n  return esthetics.filter({ $0 <= to }).map({ String($0, radix: base) })\n}\n\nfor base in 2...16 {\n  let esthetics = (0...)\n    .lazy\n    .map({ String($0, radix: base) })\n    .filter({ $0.isEsthetic(base: base) })\n    .dropFirst(base * 4)\n    .take((base * 6) - (base * 4) + 1)\n\n  print(\"Base \\(base) esthetics from \\(base * 4) to \\(base * 6)\")\n  print(esthetics)\n  print()\n}\n\nlet base10Esthetics = (1000...9999).filter({ String($0).isEsthetic() })\n\nprint(\"\\(base10Esthetics.count) esthetics between 1000 and 9999:\")\nprint(base10Esthetics)\nprint()\n\nfunc printSlice(of array: [String]) {\n  print(array.take(5))\n  print(\"...\")\n  print(Array(array.lazy.reversed().take(5).reversed()))\n  print(\"\\(array.count) total\\n\")\n}\n\nprint(\"Esthetics between \\(Int(1e8)) and \\(13 * Int(1e7)):\")\nprintSlice(of: getEsthetics(from: Int(1e8), to: 13 * Int(1e7)))\n\nprint(\"Esthetics between \\(Int(1e11)) and \\(13 * Int(1e10))\")\nprintSlice(of: getEsthetics(from: Int(1e11), to: 13 * Int(1e10)))\n\nprint(\"Esthetics between \\(Int(1e14)) and \\(13 * Int(1e13)):\")\nprintSlice(of: getEsthetics(from: Int(1e14), to: 13 * Int(1e13)))\n\nprint(\"Esthetics between \\(Int(1e17)) and \\(13 * Int(1e16)):\")\nprintSlice(of: getEsthetics(from: Int(1e17), to: 13 * Int(1e16)))\n", "target": "import java.util.ArrayList;\nimport java.util.stream.IntStream;\nimport java.util.stream.LongStream;\n\npublic class EstheticNumbers {\n    interface RecTriConsumer<A, B, C> {\n        void accept(RecTriConsumer<A, B, C> f, A a, B b, C c);\n    }\n\n    private static boolean isEsthetic(long n, long b) {\n        if (n == 0) {\n            return false;\n        }\n        var i = n % b;\n        var n2 = n / b;\n        while (n2 > 0) {\n            var j = n2 % b;\n            if (Math.abs(i - j) != 1) {\n                return false;\n            }\n            n2 /= b;\n            i = j;\n        }\n        return true;\n    }\n\n    private static void listEsths(long n, long n2, long m, long m2, int perLine, boolean all) {\n        var esths = new ArrayList<Long>();\n        var dfs = new RecTriConsumer<Long, Long, Long>() {\n            public void accept(Long n, Long m, Long i) {\n                accept(this, n, m, i);\n            }\n\n            @Override\n            public void accept(RecTriConsumer<Long, Long, Long> f, Long n, Long m, Long i) {\n                if (n <= i && i <= m) {\n                    esths.add(i);\n                }\n                if (i == 0 || i > m) {\n                    return;\n                }\n                var d = i % 10;\n                var i1 = i * 10 + d - 1;\n                var i2 = i1 + 2;\n                if (d == 0) {\n                    f.accept(f, n, m, i2);\n                } else if (d == 9) {\n                    f.accept(f, n, m, i1);\n                } else {\n                    f.accept(f, n, m, i1);\n                    f.accept(f, n, m, i2);\n                }\n            }\n        };\n\n        LongStream.range(0, 10).forEach(i -> dfs.accept(n2, m2, i));\n\n        var le = esths.size();\n        System.out.printf(\"Base 10: %d esthetic numbers between %d and %d:%n\", le, n, m);\n        if (all) {\n            for (int i = 0; i < esths.size(); i++) {\n                System.out.printf(\"%d \", esths.get(i));\n                if ((i + 1) % perLine == 0) {\n                    System.out.println();\n                }\n            }\n        } else {\n            for (int i = 0; i < perLine; i++) {\n                System.out.printf(\"%d \", esths.get(i));\n            }\n            System.out.println();\n            System.out.println(\"............\");\n            for (int i = le - perLine; i < le; i++) {\n                System.out.printf(\"%d \", esths.get(i));\n            }\n        }\n        System.out.println();\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        IntStream.rangeClosed(2, 16).forEach(b -> {\n            System.out.printf(\"Base %d: %dth to %dth esthetic numbers:%n\", b, 4 * b, 6 * b);\n            var n = 1L;\n            var c = 0L;\n            while (c < 6 * b) {\n                if (isEsthetic(n, b)) {\n                    c++;\n                    if (c >= 4 * b) {\n                        System.out.printf(\"%s \", Long.toString(n, b));\n                    }\n                }\n                n++;\n            }\n            System.out.println();\n        });\n        System.out.println();\n\n        \n        listEsths(1000, 1010, 9999, 9898, 16, true);\n        listEsths((long) 1e8, 101_010_101, 13 * (long) 1e7, 123_456_789, 9, true);\n        listEsths((long) 1e11, 101_010_101_010L, 13 * (long) 1e10, 123_456_789_898L, 7, false);\n        listEsths((long) 1e14, 101_010_101_010_101L, 13 * (long) 1e13, 123_456_789_898_989L, 5, false);\n        listEsths((long) 1e17, 101_010_101_010_101_010L, 13 * (long) 1e16, 123_456_789_898_989_898L, 4, false);\n    }\n}\n"}
{"id": 392531, "name": "Permutations by swapping", "source": "Translate Swift to Java: \n\nfunc generate<T>(array: inout [T], output: (_: [T], _: Int) -> Void) {\n    let n = array.count\n    var c = Array(repeating: 0, count: n)\n    var i = 1\n    var sign = 1\n    output(array, sign)\n    while i < n {\n        if c[i] < i {\n            if (i & 1) == 0 {\n                array.swapAt(0, i)\n            } else {\n                array.swapAt(c[i], i)\n            }\n            sign = -sign\n            output(array, sign)\n            c[i] += 1\n            i = 1\n        } else {\n            c[i] = 0\n            i += 1\n        }\n    }\n}\n\nfunc printPermutation<T>(array: [T], sign: Int) {\n    print(\"\\(array) \\(sign)\")\n}\n\nprint(\"Permutations and signs for three items:\")\nvar a = [0, 1, 2]\ngenerate(array: &a, output: printPermutation)\n\nprint(\"\\nPermutations and signs for four items:\")\nvar b = [0, 1, 2, 3]\ngenerate(array: &b, output: printPermutation)\n", "target": "package org.rosettacode.java;\n\nimport java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class HeapsAlgorithm {\n\n\tpublic static void main(String[] args) {\n\t\tObject[] array = IntStream.range(0, 4)\n\t\t\t\t.boxed()\n\t\t\t\t.toArray();\n\t\tHeapsAlgorithm algorithm = new HeapsAlgorithm();\n\t\talgorithm.recursive(array);\n\t\tSystem.out.println();\n\t\talgorithm.loop(array);\n\t}\n\n\tvoid recursive(Object[] array) {\n\t\trecursive(array, array.length, true);\n\t}\n\n\tvoid recursive(Object[] array, int n, boolean plus) {\n\t\tif (n == 1) {\n\t\t\toutput(array, plus);\n\t\t} else {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\trecursive(array, n - 1, i == 0);\n\t\t\t\tswap(array, n % 2 == 0 ? i : 0, n - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid output(Object[] array, boolean plus) {\n\t\tSystem.out.println(Arrays.toString(array) + (plus ? \" +1\" : \" -1\"));\n\t}\n\n\tvoid swap(Object[] array, int a, int b) {\n\t\tObject o = array[a];\n\t\tarray[a] = array[b];\n\t\tarray[b] = o;\n\t}\n\n\tvoid loop(Object[] array) {\n\t\tloop(array, array.length);\n\t}\n\n\tvoid loop(Object[] array, int n) {\n\t\tint[] c = new int[n];\n\t\toutput(array, true);\n\t\tboolean plus = false;\n\t\tfor (int i = 0; i < n; ) {\n\t\t\tif (c[i] < i) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tswap(array, 0, i);\n\t\t\t\t} else {\n\t\t\t\t\tswap(array, c[i], i);\n\t\t\t\t}\n\t\t\t\toutput(array, plus);\n\t\t\t\tplus = !plus;\n\t\t\t\tc[i]++;\n\t\t\t\ti = 0;\n\t\t\t} else {\n\t\t\t\tc[i] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 392532, "name": "Sequence_ smallest number with exactly n divisors", "source": "Translate Swift to Java: \nfunc divisorCount(number: Int) -> Int {\n    var n = number\n    var total = 1\n    \n    while n % 2 == 0 {\n        total += 1\n        n /= 2\n    }\n    \n    var p = 3\n    while p * p <= n {\n        var count = 1\n        while n % p == 0 {\n            count += 1\n            n /= p\n        }\n        total *= count\n        p += 2\n    }\n    \n    if n > 1 {\n        total *= 2\n    }\n    return total\n}\n\nlet limit = 15\nvar sequence = Array(repeating: 0, count: limit)\nvar count = 0\nvar n = 1\nwhile count < limit {\n    let divisors = divisorCount(number: n)\n    if divisors <= limit && sequence[divisors - 1] == 0 {\n        sequence[divisors - 1] = n\n        count += 1\n    }\n    n += 1\n}\nfor n in sequence {\n    print(n, terminator: \" \")\n}\nprint()\n", "target": "import java.util.Arrays;\n\npublic class OEIS_A005179 {\n\n    static int count_divisors(int n) {\n        int count = 0;\n        for (int i = 1; i * i <= n; ++i) {\n            if (n % i == 0) {\n                if (i == n / i)\n                    count++;\n                else\n                    count += 2;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        final int max = 15;\n        int[] seq = new int[max];\n        System.out.printf(\"The first %d terms of the sequence are:\\n\", max);\n        for (int i = 1, n = 0; n < max; ++i) {\n            int k = count_divisors(i);\n            if (k <= max && seq[k - 1] == 0) {        \n                seq[k- 1] = i;\n                n++;\n            }\n        }\n        System.out.println(Arrays.toString(seq));\n    }\n}\n"}
{"id": 392533, "name": "Longest increasing subsequence", "source": "Translate Swift to Java: import Foundation\n\nextension Array where Element: Comparable {\n  @inlinable\n  public func longestIncreasingSubsequence() -> [Element] {\n    var startI = [Int](repeating: 0, count: count)\n    var endI = [Int](repeating: 0, count: count + 1)\n    var len = 0\n\n    for i in 0..<count {\n      var lo = 1\n      var hi = len\n\n      while lo <= hi {\n        let mid = Int(ceil((Double(lo + hi)) / 2))\n\n        if self[endI[mid]] <= self[i] {\n          lo = mid + 1\n        } else {\n          hi = mid - 1\n        }\n      }\n\n      startI[i] = endI[lo-1]\n      endI[lo] = i\n\n      if lo > len {\n        len = lo\n      }\n    }\n\n    var s = [Element]()\n    var k = endI[len]\n\n    for _ in 0..<len {\n      s.append(self[k])\n      k = startI[k]\n    }\n\n    return s.reversed()\n  }\n}\n\nlet l1 = [3, 2, 6, 4, 5, 1]\nlet l2 = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\n\nprint(\"\\(l1) = \\(l1.longestIncreasingSubsequence())\")\nprint(\"\\(l2) = \\(l2.longestIncreasingSubsequence())\")\n", "target": "import java.util.*;\n\npublic class LIS {\n    public static <E extends Comparable<? super E>> List<E> lis(List<E> n) {\n        List<Node<E>> pileTops = new ArrayList<Node<E>>();\n        \n        for (E x : n) {\n\t    Node<E> node = new Node<E>();\n\t    node.value = x;\n            int i = Collections.binarySearch(pileTops, node);\n            if (i < 0) i = ~i;\n\t    if (i != 0)\n\t\tnode.pointer = pileTops.get(i-1);\n            if (i != pileTops.size())\n                pileTops.set(i, node);\n            else\n                pileTops.add(node);\n        }\n\t\n\tList<E> result = new ArrayList<E>();\n\tfor (Node<E> node = pileTops.size() == 0 ? null : pileTops.get(pileTops.size()-1);\n                node != null; node = node.pointer)\n\t    result.add(node.value);\n\tCollections.reverse(result);\n\treturn result;\n    }\n\n    private static class Node<E extends Comparable<? super E>> implements Comparable<Node<E>> {\n\tpublic E value;\n\tpublic Node<E> pointer;\n        public int compareTo(Node<E> y) { return value.compareTo(y.value); }\n    }\n\n    public static void main(String[] args) {\n\tList<Integer> d = Arrays.asList(3,2,6,4,5,1);\n\tSystem.out.printf(\"an L.I.S. of %s is %s\\n\", d, lis(d));\n        d = Arrays.asList(0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15);\n\tSystem.out.printf(\"an L.I.S. of %s is %s\\n\", d, lis(d));\n    }\n}\n"}
{"id": 392534, "name": "Brilliant numbers", "source": "Translate Swift to Java: \n\n\n\n\n\nfunc primeArray(n: Int) -> [Bool] {\n    \n    var primeArr = [Bool](repeating: true, count: n + 1)\n    primeArr[0] = false \n    primeArr[1] = false \n    \n    \n    var p = 2\n    while (p * p) <= n {\n        if primeArr[p] == true {\n            for j in stride(from: p * 2, through: n, by: p) {\n                primeArr[j] = false\n            }\n        }\n        p += 1\n    }\n    \n    return primeArr\n}\n\n\nfunc digitsCount(n: Int) -> Int {\n    \n    \n    var num = n\n    var count = 0;\n    while num != 0 {\n        num = num/10\n        count += 1\n    }\n    \n    return count\n}\n\n\nfunc isBrilliant(n: Int) -> Bool {\n    \n    var isPrime = [Bool]()\n    isPrime = primeArray(n: n)\n    \n    \n    \n    for i in stride(from: 2, through: n, by: 1) { \n        let x = n / i \n        if (isPrime[i] && isPrime[x] && x * i == n) { \n            if (digitsCount(n: i) == digitsCount(n: x)) {\n                return true\n            }\n        }\n    }\n    \n    return false\n}\n\n\nfunc print100Brilliants() {\n    \n    var brilNums = [Int]()\n    var count = 4\n    while brilNums.count != 100 {\n        if isBrilliant(n: count) {\n            brilNums.append(count)\n        }\n        count += 1\n    }\n    \n    print(\"First 100 brilliant numbers:\\n\", brilNums)\n}\n\n\nfunc printBrilliantsOfMagnitude() {\n    \n    \n    var basePower = 10.0\n    var brilNums: [Double] = [0.0]\n    var count = 1.0\n    while basePower != pow(basePower, 6) {\n        if isBrilliant(n: Int(count)) {\n            brilNums.append(count)\n            if count >= basePower {\n                print(\"First brilliant number >= \\(Int(basePower)): \\(Int(count)) at position \\(brilNums.firstIndex(of: count)!)\")\n                basePower *= 10\n            }\n        }\n        count += 1\n    }\n}\n\n\nprint100Brilliants()\nprintBrilliantsOfMagnitude()\n", "target": "import java.util.*;\n\npublic class BrilliantNumbers {\n    public static void main(String[] args) {\n        var primesByDigits = getPrimesByDigits(100000000);\n        System.out.println(\"First 100 brilliant numbers:\");\n        List<Integer> brilliantNumbers = new ArrayList<>();\n        for (var primes : primesByDigits) {\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                int prime1 = primes.get(i);\n                for (int j = i; j < n; ++j) {\n                    int prime2 = primes.get(j);\n                    brilliantNumbers.add(prime1 * prime2);\n                }\n            }\n            if (brilliantNumbers.size() >= 100)\n                break;\n        }\n        Collections.sort(brilliantNumbers);\n        for (int i = 0; i < 100; ++i) {\n            char c = (i + 1) % 10 == 0 ? '\\n' : ' ';\n            System.out.printf(\"%,5d%c\", brilliantNumbers.get(i), c);\n        }\n        System.out.println();\n        long power = 10;\n        long count = 0;\n        for (int p = 1; p < 2 * primesByDigits.size(); ++p) {\n            var primes = primesByDigits.get(p / 2);\n            long position = count + 1;\n            long minProduct = 0;\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                long prime1 = primes.get(i);\n                var primes2 = primes.subList(i, n);\n                int q = (int)((power + prime1 - 1) / prime1);\n                int j = Collections.binarySearch(primes2, q);\n                if (j == n)\n                    continue;\n                if (j < 0)\n                    j = -(j + 1);\n                long prime2 = primes2.get(j);\n                long product = prime1 * prime2;\n                if (minProduct == 0 || product < minProduct)\n                    minProduct = product;\n                position += j;\n                if (prime1 >= prime2)\n                    break;\n            }\n            System.out.printf(\"First brilliant number >= 10^%d is\u00a0%,d at position\u00a0%,d\\n\",\n                                p, minProduct, position);\n            power *= 10;\n            if (p % 2 == 1) {\n                long size = primes.size();\n                count += size * (size + 1) / 2;\n            }\n        }\n    }\n\n    private static List<List<Integer>> getPrimesByDigits(int limit) {\n        PrimeGenerator primeGen = new PrimeGenerator(100000, 100000);\n        List<List<Integer>> primesByDigits = new ArrayList<>();\n        List<Integer> primes = new ArrayList<>();\n        for (int p = 10; p <= limit; ) {\n            int prime = primeGen.nextPrime();\n            if (prime > p) {\n                primesByDigits.add(primes);\n                primes = new ArrayList<>();\n                p *= 10;\n            }\n            primes.add(prime);\n        }\n        return primesByDigits;\n    }\n}\n"}
{"id": 392535, "name": "Brilliant numbers", "source": "Translate Swift to Java: \n\n\n\n\n\nfunc primeArray(n: Int) -> [Bool] {\n    \n    var primeArr = [Bool](repeating: true, count: n + 1)\n    primeArr[0] = false \n    primeArr[1] = false \n    \n    \n    var p = 2\n    while (p * p) <= n {\n        if primeArr[p] == true {\n            for j in stride(from: p * 2, through: n, by: p) {\n                primeArr[j] = false\n            }\n        }\n        p += 1\n    }\n    \n    return primeArr\n}\n\n\nfunc digitsCount(n: Int) -> Int {\n    \n    \n    var num = n\n    var count = 0;\n    while num != 0 {\n        num = num/10\n        count += 1\n    }\n    \n    return count\n}\n\n\nfunc isBrilliant(n: Int) -> Bool {\n    \n    var isPrime = [Bool]()\n    isPrime = primeArray(n: n)\n    \n    \n    \n    for i in stride(from: 2, through: n, by: 1) { \n        let x = n / i \n        if (isPrime[i] && isPrime[x] && x * i == n) { \n            if (digitsCount(n: i) == digitsCount(n: x)) {\n                return true\n            }\n        }\n    }\n    \n    return false\n}\n\n\nfunc print100Brilliants() {\n    \n    var brilNums = [Int]()\n    var count = 4\n    while brilNums.count != 100 {\n        if isBrilliant(n: count) {\n            brilNums.append(count)\n        }\n        count += 1\n    }\n    \n    print(\"First 100 brilliant numbers:\\n\", brilNums)\n}\n\n\nfunc printBrilliantsOfMagnitude() {\n    \n    \n    var basePower = 10.0\n    var brilNums: [Double] = [0.0]\n    var count = 1.0\n    while basePower != pow(basePower, 6) {\n        if isBrilliant(n: Int(count)) {\n            brilNums.append(count)\n            if count >= basePower {\n                print(\"First brilliant number >= \\(Int(basePower)): \\(Int(count)) at position \\(brilNums.firstIndex(of: count)!)\")\n                basePower *= 10\n            }\n        }\n        count += 1\n    }\n}\n\n\nprint100Brilliants()\nprintBrilliantsOfMagnitude()\n", "target": "import java.util.*;\n\npublic class BrilliantNumbers {\n    public static void main(String[] args) {\n        var primesByDigits = getPrimesByDigits(100000000);\n        System.out.println(\"First 100 brilliant numbers:\");\n        List<Integer> brilliantNumbers = new ArrayList<>();\n        for (var primes : primesByDigits) {\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                int prime1 = primes.get(i);\n                for (int j = i; j < n; ++j) {\n                    int prime2 = primes.get(j);\n                    brilliantNumbers.add(prime1 * prime2);\n                }\n            }\n            if (brilliantNumbers.size() >= 100)\n                break;\n        }\n        Collections.sort(brilliantNumbers);\n        for (int i = 0; i < 100; ++i) {\n            char c = (i + 1) % 10 == 0 ? '\\n' : ' ';\n            System.out.printf(\"%,5d%c\", brilliantNumbers.get(i), c);\n        }\n        System.out.println();\n        long power = 10;\n        long count = 0;\n        for (int p = 1; p < 2 * primesByDigits.size(); ++p) {\n            var primes = primesByDigits.get(p / 2);\n            long position = count + 1;\n            long minProduct = 0;\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                long prime1 = primes.get(i);\n                var primes2 = primes.subList(i, n);\n                int q = (int)((power + prime1 - 1) / prime1);\n                int j = Collections.binarySearch(primes2, q);\n                if (j == n)\n                    continue;\n                if (j < 0)\n                    j = -(j + 1);\n                long prime2 = primes2.get(j);\n                long product = prime1 * prime2;\n                if (minProduct == 0 || product < minProduct)\n                    minProduct = product;\n                position += j;\n                if (prime1 >= prime2)\n                    break;\n            }\n            System.out.printf(\"First brilliant number >= 10^%d is\u00a0%,d at position\u00a0%,d\\n\",\n                                p, minProduct, position);\n            power *= 10;\n            if (p % 2 == 1) {\n                long size = primes.size();\n                count += size * (size + 1) / 2;\n            }\n        }\n    }\n\n    private static List<List<Integer>> getPrimesByDigits(int limit) {\n        PrimeGenerator primeGen = new PrimeGenerator(100000, 100000);\n        List<List<Integer>> primesByDigits = new ArrayList<>();\n        List<Integer> primes = new ArrayList<>();\n        for (int p = 10; p <= limit; ) {\n            int prime = primeGen.nextPrime();\n            if (prime > p) {\n                primesByDigits.add(primes);\n                primes = new ArrayList<>();\n                p *= 10;\n            }\n            primes.add(prime);\n        }\n        return primesByDigits;\n    }\n}\n"}
{"id": 392536, "name": "Order disjoint list items", "source": "Translate Swift to Java: func disjointOrder<T: Hashable>(m: [T], n: [T]) -> [T] {\n  let replaceCounts = n.reduce(into: [T: Int](), { $0[$1, default: 0] += 1 })\n  let reduced = m.reduce(into: ([T](), n, replaceCounts), {cur, el in\n    cur.0.append(cur.2[el, default: 0] > 0 ? cur.1.removeFirst() : el)\n    cur.2[el]? -= 1\n  })\n\n  return reduced.0\n}\n\nprint(disjointOrder(m: [\"the\", \"cat\", \"sat\", \"on\", \"the\", \"mat\"], n: [\"mat\", \"cat\"]))\nprint(disjointOrder(m: [\"the\", \"cat\", \"sat\", \"on\", \"the\", \"mat\"], n: [\"cat\", \"mat\"]))\nprint(disjointOrder(m: [\"A\", \"B\", \"C\", \"A\", \"B\", \"C\", \"A\", \"B\", \"C\"], n: [\"C\", \"A\", \"C\", \"A\"]))\nprint(disjointOrder(m: [\"A\", \"B\", \"C\", \"A\", \"B\", \"D\", \"A\", \"B\", \"E\"], n: [\"E\", \"A\", \"D\", \"A\"]))\nprint(disjointOrder(m: [\"A\", \"B\"], n: [\"B\"]))\nprint(disjointOrder(m: [\"A\", \"B\"], n: [\"B\", \"A\"]))\nprint(disjointOrder(m: [\"A\", \"B\", \"B\", \"A\"], n: [\"B\", \"A\"]))\n", "target": "import java.util.Arrays;\nimport java.util.BitSet;\nimport org.apache.commons.lang3.ArrayUtils;\n\npublic class OrderDisjointItems {\n\n    public static void main(String[] args) {\n        final String[][] MNs = {{\"the cat sat on the mat\", \"mat cat\"},\n        {\"the cat sat on the mat\", \"cat mat\"},\n        {\"A B C A B C A B C\", \"C A C A\"}, {\"A B C A B D A B E\", \"E A D A\"},\n        {\"A B\", \"B\"}, {\"A B\", \"B A\"}, {\"A B B A\", \"B A\"}, {\"X X Y\", \"X\"}};\n\n        for (String[] a : MNs) {\n            String[] r = orderDisjointItems(a[0].split(\" \"), a[1].split(\" \"));\n            System.out.printf(\"%s | %s -> %s%n\", a[0], a[1], Arrays.toString(r));\n        }\n    }\n\n    \n    static String[] orderDisjointItems(String[] m, String[] n) {\n        for (String e : n) {\n            int idx = ArrayUtils.indexOf(m, e);\n            if (idx != -1)\n                m[idx] = null;\n        }\n        for (int i = 0, j = 0; i < m.length; i++) {\n            if (m[i] == null)\n                m[i] = n[j++];\n        }\n        return m;\n    }\n\n    \n    static String[] orderDisjointItems2(String[] m, String[] n) {\n        BitSet bitSet = new BitSet(m.length);\n        for (String e : n) {\n            int idx = -1;\n            do {\n                idx = ArrayUtils.indexOf(m, e, idx + 1);\n            } while (idx != -1 && bitSet.get(idx));\n            if (idx != -1)\n                bitSet.set(idx);\n        }\n        for (int i = 0, j = 0; i < m.length; i++) {\n            if (bitSet.get(i))\n                m[i] = n[j++];\n        }\n        return m;\n    }\n}\n"}
{"id": 392537, "name": "Generate random numbers without repeating a value", "source": "Translate Swift to Java: var array = Array(1...20)\narray.shuffle()\nprint(array)\n", "target": "import java.util.*;\n\npublic class RandomShuffle {\n    public static void main(String[] args) {\n        Random rand = new Random();\n        List<Integer> list = new ArrayList<>();\n        for (int j = 1; j <= 20; ++j)\n            list.add(j);\n        Collections.shuffle(list, rand);\n        System.out.println(list);\n    }\n}\n"}
{"id": 392538, "name": "Sorting Algorithms_Circle Sort", "source": "Translate Swift to Java: func circleSort<T: Comparable>(_ array: inout [T]) {\n    func circSort(low: Int, high: Int, swaps: Int) -> Int {\n        if low == high {\n            return swaps\n        }\n        var lo = low\n        var hi = high\n        let mid = (hi - lo) / 2\n        var s = swaps\n        while lo < hi {\n            if array[lo] > array[hi] {\n                array.swapAt(lo, hi)\n                s += 1\n            }\n            lo += 1\n            hi -= 1\n        }\n        if lo == hi {\n            if array[lo] > array[hi + 1] {\n                array.swapAt(lo, hi + 1)\n                s += 1\n            }\n        }\n        s = circSort(low: low, high: low + mid, swaps: s)\n        s = circSort(low: low + mid + 1, high: high, swaps: s)\n        return s\n    }\n    while circSort(low: 0, high: array.count - 1, swaps: 0) != 0 {}\n}\n\nvar array = [10, 8, 4, 3, 1, 9, 0, 2, 7, 5, 6]\nprint(\"before: \\(array)\")\ncircleSort(&array)\nprint(\" after: \\(array)\")\n\nvar array2 = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\"]\nprint(\"before: \\(array2)\")\ncircleSort(&array2)\nprint(\" after: \\(array2)\")\n", "target": "import java.util.Arrays;\n\npublic class CircleSort {\n\n    public static void main(String[] args) {\n        circleSort(new int[]{2, 14, 4, 6, 8, 1, 3, 5, 7, 11, 0, 13, 12, -1});\n    }\n\n    public static void circleSort(int[] arr) {\n        if (arr.length > 0)\n            do {\n                System.out.println(Arrays.toString(arr));\n            } while (circleSortR(arr, 0, arr.length - 1, 0) != 0);\n    }\n\n    private static int circleSortR(int[] arr, int lo, int hi, int numSwaps) {\n        if (lo == hi)\n            return numSwaps;\n\n        int high = hi;\n        int low = lo;\n        int mid = (hi - lo) / 2;\n\n        while (lo < hi) {\n            if (arr[lo] > arr[hi]) {\n                swap(arr, lo, hi);\n                numSwaps++;\n            }\n            lo++;\n            hi--;\n        }\n\n        if (lo == hi && arr[lo] > arr[hi + 1]) {\n            swap(arr, lo, hi + 1);\n            numSwaps++;\n        }\n\n        numSwaps = circleSortR(arr, low, low + mid, numSwaps);\n        numSwaps = circleSortR(arr, low + mid + 1, high, numSwaps);\n\n        return numSwaps;\n    }\n\n    private static void swap(int[] arr, int idx1, int idx2) {\n        int tmp = arr[idx1];\n        arr[idx1] = arr[idx2];\n        arr[idx2] = tmp;\n    }\n}\n"}
{"id": 392539, "name": "Circles of given radius through two points", "source": "Translate Swift to Java: import Foundation\n\nstruct Point: Equatable {\n    var x: Double\n    var y: Double\n}\n\nstruct Circle {\n  var center: Point\n  var radius: Double\n\n  static func circleBetween(\n    _ p1: Point,\n    _ p2: Point,\n    withRadius radius: Double\n  ) -> (Circle, Circle?)? {\n    func applyPoint(_ p1: Point, _ p2: Point, op: (Double, Double) -> Double) -> Point {\n      return Point(x: op(p1.x, p2.x), y: op(p1.y, p2.y))\n    }\n\n    func mul2(_ p: Point, mul: Double) -> Point {\n      return Point(x: p.x * mul, y: p.y * mul)\n    }\n\n    func div2(_ p: Point, div: Double) -> Point {\n      return Point(x: p.x / div, y: p.y / div)\n    }\n\n    func norm(_ p: Point) -> Point {\n      return div2(p, div: (p.x * p.x + p.y * p.y).squareRoot())\n    }\n\n    guard radius != 0, p1 != p2 else {\n      return nil\n    }\n\n    let diameter = 2 * radius\n    let pq = applyPoint(p1, p2, op: -)\n    let magPQ = (pq.x * pq.x + pq.y * pq.y).squareRoot()\n\n    guard diameter >= magPQ else {\n      return nil\n    }\n\n    let midpoint = div2(applyPoint(p1, p2, op: +), div: 2)\n    let halfPQ = magPQ / 2\n    let magMidC = abs(radius * radius - halfPQ * halfPQ).squareRoot()\n    let midC = mul2(norm(Point(x: -pq.y, y: pq.x)), mul: magMidC)\n    let center1 = applyPoint(midpoint, midC, op: +)\n    let center2 = applyPoint(midpoint, midC, op: -)\n\n    if center1 == center2 {\n      return (Circle(center: center1, radius: radius), nil)\n    } else {\n      return (Circle(center: center1, radius: radius), Circle(center: center2, radius: radius))\n    }\n  }\n}\n\nlet testCases = [\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 2.0),\n  (Point(x: 0.0000, y: 2.0000), Point(x: 0.0000, y: 0.0000), 1.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 2.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 0.5),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 0.0)\n]\n\nfor testCase in testCases {\n  switch Circle.circleBetween(testCase.0, testCase.1, withRadius: testCase.2) {\n  case nil:\n    print(\"No ans\")\n  case (let circle1, nil)?:\n    print(\"One ans: \\(circle1)\")\n  case (let circle1, let circle2?)?:\n    print(\"Two ans: \\(circle1) \\(circle2)\")\n  }\n}\n", "target": "import java.util.Objects;\n\npublic class Circles {\n    private static class Point {\n        private final double x, y;\n\n        public Point(Double x, Double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double distanceFrom(Point other) {\n            double dx = x - other.x;\n            double dy = y - other.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (this == other) return true;\n            if (other == null || getClass() != other.getClass()) return false;\n            Point point = (Point) other;\n            return x == point.x && y == point.y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%.4f,\u00a0%.4f)\", x, y);\n        }\n    }\n\n    private static Point[] findCircles(Point p1, Point p2, double r) {\n        if (r < 0.0) throw new IllegalArgumentException(\"the radius can't be negative\");\n        if (r == 0.0 && p1 != p2) throw new IllegalArgumentException(\"no circles can ever be drawn\");\n        if (r == 0.0) return new Point[]{p1, p1};\n        if (Objects.equals(p1, p2)) throw new IllegalArgumentException(\"an infinite number of circles can be drawn\");\n        double distance = p1.distanceFrom(p2);\n        double diameter = 2.0 * r;\n        if (distance > diameter) throw new IllegalArgumentException(\"the points are too far apart to draw a circle\");\n        Point center = new Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);\n        if (distance == diameter) return new Point[]{center, center};\n        double mirrorDistance = Math.sqrt(r * r - distance * distance / 4.0);\n        double dx = (p2.x - p1.x) * mirrorDistance / distance;\n        double dy = (p2.y - p1.y) * mirrorDistance / distance;\n        return new Point[]{\n            new Point(center.x - dy, center.y + dx),\n            new Point(center.x + dy, center.y - dx)\n        };\n    }\n\n    public static void main(String[] args) {\n        Point[] p = new Point[]{\n            new Point(0.1234, 0.9876),\n            new Point(0.8765, 0.2345),\n            new Point(0.0000, 2.0000),\n            new Point(0.0000, 0.0000)\n        };\n        Point[][] points = new Point[][]{\n            {p[0], p[1]},\n            {p[2], p[3]},\n            {p[0], p[0]},\n            {p[0], p[1]},\n            {p[0], p[0]},\n        };\n        double[] radii = new double[]{2.0, 1.0, 2.0, 0.5, 0.0};\n        for (int i = 0; i < radii.length; ++i) {\n            Point p1 = points[i][0];\n            Point p2 = points[i][1];\n            double r = radii[i];\n            System.out.printf(\"For points %s and %s with radius %f\\n\", p1, p2, r);\n            try {\n                Point[] circles = findCircles(p1, p2, r);\n                Point c1 = circles[0];\n                Point c2 = circles[1];\n                if (Objects.equals(c1, c2)) {\n                    System.out.printf(\"there is just one circle with center at %s\\n\", c1);\n                } else {\n                    System.out.printf(\"there are two circles with centers at %s and %s\\n\", c1, c2);\n                }\n            } catch (IllegalArgumentException ex) {\n                System.out.println(ex.getMessage());\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 392540, "name": "Circles of given radius through two points", "source": "Translate Swift to Java: import Foundation\n\nstruct Point: Equatable {\n    var x: Double\n    var y: Double\n}\n\nstruct Circle {\n  var center: Point\n  var radius: Double\n\n  static func circleBetween(\n    _ p1: Point,\n    _ p2: Point,\n    withRadius radius: Double\n  ) -> (Circle, Circle?)? {\n    func applyPoint(_ p1: Point, _ p2: Point, op: (Double, Double) -> Double) -> Point {\n      return Point(x: op(p1.x, p2.x), y: op(p1.y, p2.y))\n    }\n\n    func mul2(_ p: Point, mul: Double) -> Point {\n      return Point(x: p.x * mul, y: p.y * mul)\n    }\n\n    func div2(_ p: Point, div: Double) -> Point {\n      return Point(x: p.x / div, y: p.y / div)\n    }\n\n    func norm(_ p: Point) -> Point {\n      return div2(p, div: (p.x * p.x + p.y * p.y).squareRoot())\n    }\n\n    guard radius != 0, p1 != p2 else {\n      return nil\n    }\n\n    let diameter = 2 * radius\n    let pq = applyPoint(p1, p2, op: -)\n    let magPQ = (pq.x * pq.x + pq.y * pq.y).squareRoot()\n\n    guard diameter >= magPQ else {\n      return nil\n    }\n\n    let midpoint = div2(applyPoint(p1, p2, op: +), div: 2)\n    let halfPQ = magPQ / 2\n    let magMidC = abs(radius * radius - halfPQ * halfPQ).squareRoot()\n    let midC = mul2(norm(Point(x: -pq.y, y: pq.x)), mul: magMidC)\n    let center1 = applyPoint(midpoint, midC, op: +)\n    let center2 = applyPoint(midpoint, midC, op: -)\n\n    if center1 == center2 {\n      return (Circle(center: center1, radius: radius), nil)\n    } else {\n      return (Circle(center: center1, radius: radius), Circle(center: center2, radius: radius))\n    }\n  }\n}\n\nlet testCases = [\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 2.0),\n  (Point(x: 0.0000, y: 2.0000), Point(x: 0.0000, y: 0.0000), 1.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 2.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 0.5),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 0.0)\n]\n\nfor testCase in testCases {\n  switch Circle.circleBetween(testCase.0, testCase.1, withRadius: testCase.2) {\n  case nil:\n    print(\"No ans\")\n  case (let circle1, nil)?:\n    print(\"One ans: \\(circle1)\")\n  case (let circle1, let circle2?)?:\n    print(\"Two ans: \\(circle1) \\(circle2)\")\n  }\n}\n", "target": "import java.util.Objects;\n\npublic class Circles {\n    private static class Point {\n        private final double x, y;\n\n        public Point(Double x, Double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double distanceFrom(Point other) {\n            double dx = x - other.x;\n            double dy = y - other.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (this == other) return true;\n            if (other == null || getClass() != other.getClass()) return false;\n            Point point = (Point) other;\n            return x == point.x && y == point.y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%.4f,\u00a0%.4f)\", x, y);\n        }\n    }\n\n    private static Point[] findCircles(Point p1, Point p2, double r) {\n        if (r < 0.0) throw new IllegalArgumentException(\"the radius can't be negative\");\n        if (r == 0.0 && p1 != p2) throw new IllegalArgumentException(\"no circles can ever be drawn\");\n        if (r == 0.0) return new Point[]{p1, p1};\n        if (Objects.equals(p1, p2)) throw new IllegalArgumentException(\"an infinite number of circles can be drawn\");\n        double distance = p1.distanceFrom(p2);\n        double diameter = 2.0 * r;\n        if (distance > diameter) throw new IllegalArgumentException(\"the points are too far apart to draw a circle\");\n        Point center = new Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);\n        if (distance == diameter) return new Point[]{center, center};\n        double mirrorDistance = Math.sqrt(r * r - distance * distance / 4.0);\n        double dx = (p2.x - p1.x) * mirrorDistance / distance;\n        double dy = (p2.y - p1.y) * mirrorDistance / distance;\n        return new Point[]{\n            new Point(center.x - dy, center.y + dx),\n            new Point(center.x + dy, center.y - dx)\n        };\n    }\n\n    public static void main(String[] args) {\n        Point[] p = new Point[]{\n            new Point(0.1234, 0.9876),\n            new Point(0.8765, 0.2345),\n            new Point(0.0000, 2.0000),\n            new Point(0.0000, 0.0000)\n        };\n        Point[][] points = new Point[][]{\n            {p[0], p[1]},\n            {p[2], p[3]},\n            {p[0], p[0]},\n            {p[0], p[1]},\n            {p[0], p[0]},\n        };\n        double[] radii = new double[]{2.0, 1.0, 2.0, 0.5, 0.0};\n        for (int i = 0; i < radii.length; ++i) {\n            Point p1 = points[i][0];\n            Point p2 = points[i][1];\n            double r = radii[i];\n            System.out.printf(\"For points %s and %s with radius %f\\n\", p1, p2, r);\n            try {\n                Point[] circles = findCircles(p1, p2, r);\n                Point c1 = circles[0];\n                Point c2 = circles[1];\n                if (Objects.equals(c1, c2)) {\n                    System.out.printf(\"there is just one circle with center at %s\\n\", c1);\n                } else {\n                    System.out.printf(\"there are two circles with centers at %s and %s\\n\", c1, c2);\n                }\n            } catch (IllegalArgumentException ex) {\n                System.out.println(ex.getMessage());\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 392541, "name": "Vampire number", "source": "Translate Swift to Java: import Foundation\n\nfunc vampire<T>(n: T) -> [(T, T)] where T: BinaryInteger, T.Stride: SignedInteger {\n  let strN = String(n).sorted()\n  let fangLength = strN.count / 2\n  let start = T(pow(10, Double(fangLength - 1)))\n  let end = T(Double(n).squareRoot())\n\n  var fangs = [(T, T)]()\n\n  for i in start...end where n % i == 0 {\n    let quot = n / i\n\n    guard i % 10 != 0 || quot % 10 != 0 else {\n      continue\n    }\n\n    if \"\\(i)\\(quot)\".sorted() == strN {\n      fangs.append((i, quot))\n    }\n  }\n\n  return fangs\n}\n\nvar count = 0\nvar i = 1.0\n\nwhile count < 25 {\n  let start = Int(pow(10, i))\n  let end = start * 10\n\n  for num in start...end {\n    let fangs = vampire(n: num)\n\n    guard !fangs.isEmpty else { continue }\n\n    count += 1\n\n    print(\"\\(num) is a vampire number with fangs: \\(fangs)\")\n\n    guard count != 25 else { break }\n  }\n\n  i += 2\n}\n\nfor (vamp, fangs) in [16758243290880, 24959017348650, 14593825548650].lazy.map({ ($0, vampire(n: $0)) }) {\n  if fangs.isEmpty {\n    print(\"\\(vamp) is not a vampire number\")\n  } else {\n    print(\"\\(vamp) is a vampire number with fangs: \\(fangs)\")\n  }\n}\n", "target": "import java.util.Arrays;\nimport java.util.HashSet;\n\npublic class VampireNumbers{\n    private static int numDigits(long num){\n        return Long.toString(Math.abs(num)).length();\n    }\n\n    private static boolean fangCheck(long orig, long fang1, long fang2){\n        if(Long.toString(fang1).endsWith(\"0\") && Long.toString(fang2).endsWith(\"0\")) return false;\n\n        int origLen = numDigits(orig);\n        if(numDigits(fang1) != origLen / 2 || numDigits(fang2) != origLen / 2) return false;\n\n        byte[] origBytes = Long.toString(orig).getBytes();\n        byte[] fangBytes = (Long.toString(fang1) + Long.toString(fang2)).getBytes();\n        Arrays.sort(origBytes);\n        Arrays.sort(fangBytes);\n        return Arrays.equals(origBytes, fangBytes);\n    }\n\n    public static void main(String[] args){\n        HashSet<Long> vamps = new HashSet<Long>();\n        for(long i = 10; vamps.size() <= 25; i++ ){\n            if((numDigits(i) % 2) != 0) {i = i * 10 - 1; continue;}\n            for(long fang1 = 2; fang1 <= Math.sqrt(i) + 1; fang1++){\n                if(i % fang1 == 0){\n                    long fang2 = i / fang1;\n                    if(fangCheck(i, fang1, fang2) && fang1 <= fang2){\n                        vamps.add(i);\n                        System.out.println(i + \": [\" + fang1 + \", \" + fang2 +\"]\");\n                    }\n                }\n            }\n        }\n        Long[] nums = {16758243290880L, 24959017348650L, 14593825548650L};\n        for(Long i : nums){\n            for(long fang1 = 2; fang1 <= Math.sqrt(i) + 1; fang1++){\n                if(i % fang1 == 0){\n                    long fang2 = i / fang1;\n                    if(fangCheck(i, fang1, fang2) && fang1 <= fang2){\n                        System.out.println(i + \": [\" + fang1 + \", \" + fang2 +\"]\");\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 392542, "name": "Nonoblock", "source": "Translate Swift to Java: import Foundation\n\nfunc nonoblock(cells: Int, blocks: [Int]) {\n    print(\"\\(cells) cells and blocks \\(blocks):\")\n    let totalBlockSize = blocks.reduce(0, +)\n    if cells < totalBlockSize + blocks.count - 1 {\n        print(\"no solution\")\n        return\n    }\n\n    func solve(cells: Int, index: Int, totalBlockSize: Int, offset: Int) {\n        if index == blocks.count {\n            count += 1\n            print(\"\\(String(format: \"%2d\", count))  \\(String(output))\")\n            return\n        }\n        let blockSize = blocks[index]\n        let maxPos = cells - (totalBlockSize + blocks.count - index - 1)\n        let t = totalBlockSize - blockSize\n        var c = cells - (blockSize + 1)\n        for pos in 0...maxPos {\n            fill(value: \".\", offset: offset, count: maxPos + blockSize)\n            fill(value: \"#\", offset: offset + pos, count: blockSize)\n            solve(cells: c, index: index + 1, totalBlockSize: t,\n                  offset: offset + blockSize + pos + 1)\n            c -= 1\n        }\n    }\n\n    func fill(value: Character, offset: Int, count: Int) {\n        output.replaceSubrange(offset..<offset+count,\n                               with: repeatElement(value, count: count))\n    }\n    \n    var output: [Character] = Array(repeating: \".\", count: cells)\n    var count = 0\n    solve(cells: cells, index: 0, totalBlockSize: totalBlockSize, offset: 0)\n}\n\nnonoblock(cells: 5, blocks: [2, 1])\nprint()\n\nnonoblock(cells: 5, blocks: [])\nprint()\n\nnonoblock(cells: 10, blocks: [8])\nprint()\n\nnonoblock(cells: 15, blocks: [2, 3, 2, 3])\nprint()\n\nnonoblock(cells: 5, blocks: [2, 3])\n", "target": "import java.util.*;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\n\npublic class Nonoblock {\n\n    public static void main(String[] args) {\n        printBlock(\"21\", 5);\n        printBlock(\"\", 5);\n        printBlock(\"8\", 10);\n        printBlock(\"2323\", 15);\n        printBlock(\"23\", 5);\n    }\n\n    static void printBlock(String data, int len) {\n        int sumChars = data.chars().map(c -> Character.digit(c, 10)).sum();\n        String[] a = data.split(\"\");\n\n        System.out.printf(\"%nblocks %s, cells %s%n\", Arrays.toString(a), len);\n        if (len - sumChars <= 0) {\n            System.out.println(\"No solution\");\n            return;\n        }\n\n        List<String> prep = stream(a).filter(x -> !\"\".equals(x))\n                .map(x -> repeat(Character.digit(x.charAt(0), 10), \"1\"))\n                .collect(toList());\n\n        for (String r : genSequence(prep, len - sumChars + 1))\n            System.out.println(r.substring(1));\n    }\n\n    \n    static List<String> genSequence(List<String> ones, int numZeros) {\n        if (ones.isEmpty())\n            return Arrays.asList(repeat(numZeros, \"0\"));\n\n        List<String> result = new ArrayList<>();\n        for (int x = 1; x < numZeros - ones.size() + 2; x++) {\n            List<String> skipOne = ones.stream().skip(1).collect(toList());\n            for (String tail : genSequence(skipOne, numZeros - x))\n                result.add(repeat(x, \"0\") + ones.get(0) + tail);\n        }\n        return result;\n    }\n\n    static String repeat(int n, String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++)\n            sb.append(s);\n        return sb.toString();\n    }\n}\n"}
{"id": 392543, "name": "Nonoblock", "source": "Translate Swift to Java: import Foundation\n\nfunc nonoblock(cells: Int, blocks: [Int]) {\n    print(\"\\(cells) cells and blocks \\(blocks):\")\n    let totalBlockSize = blocks.reduce(0, +)\n    if cells < totalBlockSize + blocks.count - 1 {\n        print(\"no solution\")\n        return\n    }\n\n    func solve(cells: Int, index: Int, totalBlockSize: Int, offset: Int) {\n        if index == blocks.count {\n            count += 1\n            print(\"\\(String(format: \"%2d\", count))  \\(String(output))\")\n            return\n        }\n        let blockSize = blocks[index]\n        let maxPos = cells - (totalBlockSize + blocks.count - index - 1)\n        let t = totalBlockSize - blockSize\n        var c = cells - (blockSize + 1)\n        for pos in 0...maxPos {\n            fill(value: \".\", offset: offset, count: maxPos + blockSize)\n            fill(value: \"#\", offset: offset + pos, count: blockSize)\n            solve(cells: c, index: index + 1, totalBlockSize: t,\n                  offset: offset + blockSize + pos + 1)\n            c -= 1\n        }\n    }\n\n    func fill(value: Character, offset: Int, count: Int) {\n        output.replaceSubrange(offset..<offset+count,\n                               with: repeatElement(value, count: count))\n    }\n    \n    var output: [Character] = Array(repeating: \".\", count: cells)\n    var count = 0\n    solve(cells: cells, index: 0, totalBlockSize: totalBlockSize, offset: 0)\n}\n\nnonoblock(cells: 5, blocks: [2, 1])\nprint()\n\nnonoblock(cells: 5, blocks: [])\nprint()\n\nnonoblock(cells: 10, blocks: [8])\nprint()\n\nnonoblock(cells: 15, blocks: [2, 3, 2, 3])\nprint()\n\nnonoblock(cells: 5, blocks: [2, 3])\n", "target": "import java.util.*;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\n\npublic class Nonoblock {\n\n    public static void main(String[] args) {\n        printBlock(\"21\", 5);\n        printBlock(\"\", 5);\n        printBlock(\"8\", 10);\n        printBlock(\"2323\", 15);\n        printBlock(\"23\", 5);\n    }\n\n    static void printBlock(String data, int len) {\n        int sumChars = data.chars().map(c -> Character.digit(c, 10)).sum();\n        String[] a = data.split(\"\");\n\n        System.out.printf(\"%nblocks %s, cells %s%n\", Arrays.toString(a), len);\n        if (len - sumChars <= 0) {\n            System.out.println(\"No solution\");\n            return;\n        }\n\n        List<String> prep = stream(a).filter(x -> !\"\".equals(x))\n                .map(x -> repeat(Character.digit(x.charAt(0), 10), \"1\"))\n                .collect(toList());\n\n        for (String r : genSequence(prep, len - sumChars + 1))\n            System.out.println(r.substring(1));\n    }\n\n    \n    static List<String> genSequence(List<String> ones, int numZeros) {\n        if (ones.isEmpty())\n            return Arrays.asList(repeat(numZeros, \"0\"));\n\n        List<String> result = new ArrayList<>();\n        for (int x = 1; x < numZeros - ones.size() + 2; x++) {\n            List<String> skipOne = ones.stream().skip(1).collect(toList());\n            for (String tail : genSequence(skipOne, numZeros - x))\n                result.add(repeat(x, \"0\") + ones.get(0) + tail);\n        }\n        return result;\n    }\n\n    static String repeat(int n, String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++)\n            sb.append(s);\n        return sb.toString();\n    }\n}\n"}
{"id": 392544, "name": "Knapsack problem_Bounded", "source": "Translate Swift to Java: public struct KnapsackItem: Hashable {\n  public var name: String\n  public var weight: Int\n  public var value: Int\n\n  public init(name: String, weight: Int, value: Int) {\n    self.name = name\n    self.weight = weight\n    self.value = value\n  }\n}\n\npublic func knapsack(items: [KnapsackItem], limit: Int) -> [KnapsackItem] {\n  var table = Array(repeating: Array(repeating: 0, count: limit + 1), count: items.count + 1)\n\n  for j in 1...items.count {\n    let item = items[j-1]\n\n    for w in 1...limit {\n      if item.weight > w {\n        table[j][w] = table[j-1][w]\n      } else {\n        table[j][w] = max(table[j-1][w], table[j-1][w-item.weight] + item.value)\n      }\n    }\n  }\n\n  var result = [KnapsackItem]()\n  var w = limit\n\n  for j in stride(from: items.count, to: 0, by: -1) where table[j][w] != table[j-1][w] {\n    let item = items[j-1]\n\n    result.append(item)\n\n    w -= item.weight\n  }\n\n  return result\n}\n\ntypealias GroupedItem = (name: String, weight: Int, val: Int, n: Int)\n\nlet groupedItems: [GroupedItem] = [\n  (\"map\", 9, 150, 1),\n  (\"compass\", 13, 35, 1),\n  (\"water\", 153, 200, 3),\n  (\"sandwich\", 50, 60, 2),\n  (\"glucose\", 15, 60, 2),\n  (\"tin\", 68, 45, 3),\n  (\"banana\", 27, 60, 3),\n  (\"apple\", 39, 40, 3),\n  (\"cheese\", 23, 30, 1),\n  (\"beer\", 52, 10, 3),\n  (\"suntan cream\", 11, 70, 1),\n  (\"camera\", 32, 30, 1),\n  (\"t-shirt\", 24, 15, 2),\n  (\"trousers\", 48, 10, 2),\n  (\"umbrella\", 73, 40, 1),\n  (\"waterproof trousers\", 42, 70, 1),\n  (\"waterproof overclothes\", 43, 75, 1),\n  (\"note-case\", 22, 80, 1),\n  (\"sunglasses\", 7, 20, 1),\n  (\"towel\", 18, 12, 2),\n  (\"socks\", 4, 50, 1),\n  (\"book\", 30, 10, 2)\n]\n\nlet items = groupedItems.flatMap({item in\n  (0..<item.n).map({_ in KnapsackItem(name: item.name, weight: item.weight, value: item.val) })\n})\n\nlet bagged = knapsack(items: items, limit: 400)\nlet (totalVal, totalWeight) = bagged.reduce((0, 0), {cur, item in (cur.0 + item.value, cur.1 + item.weight) })\n\nprint(\"Bagged the following \\(bagged.count) items:\")\n\nfor item in bagged {\n  print(\"\\t\\(item.name)\")\n}\n\nprint(\"For a total value of \\(totalVal) and weight of \\(totalWeight)\")\n", "target": "package hu.pj.alg.test;\n\nimport hu.pj.alg.BoundedKnapsack;\nimport hu.pj.obj.Item;\nimport java.util.*;\nimport java.text.*;\n\npublic class BoundedKnapsackForTourists {\n    public BoundedKnapsackForTourists() {\n        BoundedKnapsack bok = new BoundedKnapsack(400); \n\n        \n        bok.add(\"map\", 9, 150, 1);\n        bok.add(\"compass\", 13, 35, 1);\n        bok.add(\"water\", 153, 200, 3);\n        bok.add(\"sandwich\", 50, 60, 2);\n        bok.add(\"glucose\", 15, 60, 2);\n        bok.add(\"tin\", 68, 45, 3);\n        bok.add(\"banana\", 27, 60, 3);\n        bok.add(\"apple\", 39, 40, 3);\n        bok.add(\"cheese\", 23, 30, 1);\n        bok.add(\"beer\", 52, 10, 3);\n        bok.add(\"suntan cream\", 11, 70, 1);\n        bok.add(\"camera\", 32, 30, 1);\n        bok.add(\"t-shirt\", 24, 15, 2);\n        bok.add(\"trousers\", 48, 10, 2);\n        bok.add(\"umbrella\", 73, 40, 1);\n        bok.add(\"waterproof trousers\", 42, 70, 1);\n        bok.add(\"waterproof overclothes\", 43, 75, 1);\n        bok.add(\"note-case\", 22, 80, 1);\n        bok.add(\"sunglasses\", 7, 20, 1);\n        bok.add(\"towel\", 18, 12, 2);\n        bok.add(\"socks\", 4, 50, 1);\n        bok.add(\"book\", 30, 10, 2);\n\n        \n        List<Item> itemList = bok.calcSolution();\n\n        \n        if (bok.isCalculated()) {\n            NumberFormat nf  = NumberFormat.getInstance();\n\n            System.out.println(\n                \"Maximal weight           = \" +\n                nf.format(bok.getMaxWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total weight of solution = \" +\n                nf.format(bok.getSolutionWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total value              = \" +\n                bok.getProfit()\n            );\n            System.out.println();\n            System.out.println(\n                \"You can carry te following materials \" +\n                \"in the knapsack:\"\n            );\n            for (Item item : itemList) {\n                if (item.getInKnapsack() > 0) {\n                    System.out.format(\n                        \"%1$-10s %2$-23s %3$-3s %4$-5s %5$-15s \\n\",\n                        item.getInKnapsack() + \" unit(s) \",\n                        item.getName(),\n                        item.getInKnapsack() * item.getWeight(), \"dag  \",\n                        \"(value = \" + item.getInKnapsack() * item.getValue() + \")\"\n                    );\n                }\n            }\n        } else {\n            System.out.println(\n                \"The problem is not solved. \" +\n                \"Maybe you gave wrong data.\"\n            );\n        }\n\n    }\n\n    public static void main(String[] args) {\n        new BoundedKnapsackForTourists();\n    }\n} \n"}
{"id": 392545, "name": "Angles (geometric), normalization and conversion", "source": "Translate Swift to Java: import Foundation\n\nfunc normalize(_ f: Double, N: Double) -> Double {\n  var a = f\n\n  while a < -N { a += N }\n  while a >= N { a -= N }\n\n  return a\n}\n\nfunc normalizeToDeg(_ f: Double) -> Double {\n  return normalize(f, N: 360)\n}\n\nfunc normalizeToGrad(_ f: Double) -> Double {\n  return normalize(f, N: 400)\n}\n\nfunc normalizeToMil(_ f: Double) -> Double {\n  return normalize(f, N: 6400)\n}\n\nfunc normalizeToRad(_ f: Double) -> Double {\n  return normalize(f, N: 2 * .pi)\n}\n\nfunc d2g(_ f: Double) -> Double { f * 10 / 9 }\nfunc d2m(_ f: Double) -> Double { f * 160 / 9 }\nfunc d2r(_ f: Double) -> Double { f * .pi / 180 }\n\nfunc g2d(_ f: Double) -> Double { f * 9 / 10 }\nfunc g2m(_ f: Double) -> Double { f * 16 }\nfunc g2r(_ f: Double) -> Double { f * .pi / 200 }\n\nfunc m2d(_ f: Double) -> Double { f * 9 / 160 }\nfunc m2g(_ f: Double) -> Double { f / 16 }\nfunc m2r(_ f: Double) -> Double { f * .pi / 3200 }\n\nfunc r2d(_ f: Double) -> Double { f * 180 / .pi }\nfunc r2g(_ f: Double) -> Double { f * 200 / .pi }\nfunc r2m(_ f: Double) -> Double { f * 3200 / .pi }\n\nlet angles = [-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 6399, 1_000_000]\nlet names = [\"Degrees\", \"Gradians\", \"Mils\", \"Radians\"]\nlet fmt = { String(format: \"%.4f\", $0) }\n\nlet normal = [normalizeToDeg, normalizeToGrad, normalizeToMil, normalizeToRad]\nlet convert = [\n  [{ $0 }, d2g, d2m, d2r],\n  [g2d, { $0 }, g2m, g2r],\n  [m2d, m2g, { $0 }, m2r],\n  [r2d, r2g, r2m, { $0 }]\n]\n\nlet ans =\n  angles.map({ angle in\n    (0..<4).map({ ($0, normal[$0](angle)) }).map({\n      (fmt(angle),\n        fmt($0.1),\n        names[$0.0],\n        fmt(convert[$0.0][0]($0.1)),\n        fmt(convert[$0.0][1]($0.1)),\n        fmt(convert[$0.0][2]($0.1)),\n        fmt(convert[$0.0][3]($0.1))\n      )\n    })\n  })\n\nprint(\"angle\", \"normalized\", \"unit\", \"degrees\", \"grads\", \"mils\", \"radians\")\n\nfor res in ans {\n  for unit in res {\n    print(unit)\n  }\n\n  print()\n}\n", "target": "import java.text.DecimalFormat;\n\n\n\npublic class AnglesNormalizationAndConversion {\n\n    public static void main(String[] args) {\n        DecimalFormat formatAngle = new DecimalFormat(\"######0.000000\");\n        DecimalFormat formatConv = new DecimalFormat(\"###0.0000\");\n        System.out.printf(\"                               degrees    gradiens        mils     radians%n\");\n        for ( double angle : new double[] {-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 399, 6399, 1000000} ) {\n            for ( String units : new String[] {\"degrees\", \"gradiens\", \"mils\", \"radians\"}) {\n                double d = 0, g = 0, m = 0, r = 0;\n                switch (units) {\n                case \"degrees\":\n                    d = d2d(angle);\n                    g = d2g(d);\n                    m = d2m(d);\n                    r = d2r(d);\n                    break;\n                case \"gradiens\":\n                    g = g2g(angle);\n                    d = g2d(g);\n                    m = g2m(g);\n                    r = g2r(g);\n                    break;\n                case \"mils\":\n                    m = m2m(angle);\n                    d = m2d(m);\n                    g = m2g(m);\n                    r = m2r(m);\n                    break;\n                case \"radians\":\n                    r = r2r(angle);\n                    d = r2d(r);\n                    g = r2g(r);\n                    m = r2m(r);\n                    break;\n                }\n                System.out.printf(\"%15s  %8s = %10s  %10s  %10s  %10s%n\", formatAngle.format(angle), units, formatConv.format(d), formatConv.format(g), formatConv.format(m), formatConv.format(r));\n            }\n        }\n    }\n\n    private static final double DEGREE = 360D;\n    private static final double GRADIAN = 400D;\n    private static final double MIL = 6400D;\n    private static final double RADIAN = (2 * Math.PI);\n    \n    private static double d2d(double a) {\n        return a % DEGREE;\n    }\n    private static double d2g(double a) {\n        return a * (GRADIAN / DEGREE);\n    }\n    private static double d2m(double a) {\n        return a * (MIL / DEGREE);\n    }\n    private static double d2r(double a) {\n        return a * (RADIAN / 360);\n    }\n\n    private static double g2d(double a) {\n        return a * (DEGREE / GRADIAN);\n    }\n    private static double g2g(double a) {\n        return a % GRADIAN;\n    }\n    private static double g2m(double a) {\n        return a * (MIL / GRADIAN);\n    }\n    private static double g2r(double a) {\n        return a * (RADIAN / GRADIAN);\n    }\n    \n    private static double m2d(double a) {\n        return a * (DEGREE / MIL);\n    }\n    private static double m2g(double a) {\n        return a * (GRADIAN / MIL);\n    }\n    private static double m2m(double a) {\n        return a % MIL;\n    }\n    private static double m2r(double a) {\n        return a * (RADIAN / MIL);\n    }\n    \n    private static double r2d(double a) {\n        return a * (DEGREE / RADIAN);\n    }\n    private static double r2g(double a) {\n        return a * (GRADIAN / RADIAN);\n    }\n    private static double r2m(double a) {\n        return a * (MIL / RADIAN);\n    }\n    private static double r2r(double a) {\n        return a % RADIAN;\n    }\n    \n}\n"}
{"id": 392546, "name": "I before E except after C", "source": "Translate Swift to Java: import Foundation\n\nlet request = NSURLRequest(URL: NSURL(string: \"http:\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in\n    if (data != nil) {\n        if let fileAsString = NSString(data: data, encoding: NSUTF8StringEncoding) {\n            var firstCase = false\n            var secondCase = false\n            var cie = 0\n            var cei = 0\n            var not_c_ie = 0\n            var not_c_ei = 0\n            let words = fileAsString.componentsSeparatedByString(\"\\n\")\n            for word in words {\n                var wordRegex = RegexMutable(word as String)\n                if (wordRegex[\"cie\"]) {\n                    cie++\n                }\n                if (wordRegex[\"cei\"]) {\n                    cei++\n                }\n                if (wordRegex[\"(^ie|[^c]ie)\"].matches().count != 0) {\n                    not_c_ie++\n                }\n                if (wordRegex[\"(^ei|[^c]ei)\"].matches().count != 0) {\n                    not_c_ei++\n                }\n            }\n            \n            \n            if (not_c_ie > not_c_ei * 2) {\n                println(\"I before E when not preceded by C is plausable\")\n                firstCase = true\n            } else {\n                println(\"I before E when not preceded by C is not plausable\")\n            }\n            \n            if (cei > cie * 2) {\n                secondCase = true\n                println(\"E before I when preceded by C is plausable\")\n            } else {\n                println(\"E before I when preceded by C is not plausable\")\n            }\n            \n            if (firstCase && secondCase) {\n                println(\"I before E except after C is plausible\")\n            } else {\n                println(\"I before E except after C is not plausible\")\n            }\n        }\n    }\n}\n\nCFRunLoopRun()\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class IbeforeE \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tIbeforeE now=new IbeforeE();\n\t\tString wordlist=\"unixdict.txt\";\n\t\tif(now.isPlausibleRule(wordlist))\n\t\t\tSystem.out.println(\"Rule is plausible.\");\n\t\telse\n\t\t\tSystem.out.println(\"Rule is not plausible.\");\n\t}\n\tboolean isPlausibleRule(String filename)\n\t{\n\t\tint truecount=0,falsecount=0;\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\tString word;\n\t\t\twhile((word=br.readLine())!=null)\n\t\t\t{\n\t\t\t\tif(isPlausibleWord(word))\n\t\t\t\t\ttruecount++;\n\t\t\t\telse if(isOppPlausibleWord(word))\n\t\t\t\t\tfalsecount++;\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Plausible count: \"+truecount);\n\t\tSystem.out.println(\"Implausible count: \"+falsecount);\n\t\tif(truecount>2*falsecount)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ie\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cei\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isOppPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ei\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cie\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n"}
{"id": 392547, "name": "I before E except after C", "source": "Translate Swift to Java: import Foundation\n\nlet request = NSURLRequest(URL: NSURL(string: \"http:\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in\n    if (data != nil) {\n        if let fileAsString = NSString(data: data, encoding: NSUTF8StringEncoding) {\n            var firstCase = false\n            var secondCase = false\n            var cie = 0\n            var cei = 0\n            var not_c_ie = 0\n            var not_c_ei = 0\n            let words = fileAsString.componentsSeparatedByString(\"\\n\")\n            for word in words {\n                var wordRegex = RegexMutable(word as String)\n                if (wordRegex[\"cie\"]) {\n                    cie++\n                }\n                if (wordRegex[\"cei\"]) {\n                    cei++\n                }\n                if (wordRegex[\"(^ie|[^c]ie)\"].matches().count != 0) {\n                    not_c_ie++\n                }\n                if (wordRegex[\"(^ei|[^c]ei)\"].matches().count != 0) {\n                    not_c_ei++\n                }\n            }\n            \n            \n            if (not_c_ie > not_c_ei * 2) {\n                println(\"I before E when not preceded by C is plausable\")\n                firstCase = true\n            } else {\n                println(\"I before E when not preceded by C is not plausable\")\n            }\n            \n            if (cei > cie * 2) {\n                secondCase = true\n                println(\"E before I when preceded by C is plausable\")\n            } else {\n                println(\"E before I when preceded by C is not plausable\")\n            }\n            \n            if (firstCase && secondCase) {\n                println(\"I before E except after C is plausible\")\n            } else {\n                println(\"I before E except after C is not plausible\")\n            }\n        }\n    }\n}\n\nCFRunLoopRun()\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class IbeforeE \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tIbeforeE now=new IbeforeE();\n\t\tString wordlist=\"unixdict.txt\";\n\t\tif(now.isPlausibleRule(wordlist))\n\t\t\tSystem.out.println(\"Rule is plausible.\");\n\t\telse\n\t\t\tSystem.out.println(\"Rule is not plausible.\");\n\t}\n\tboolean isPlausibleRule(String filename)\n\t{\n\t\tint truecount=0,falsecount=0;\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\tString word;\n\t\t\twhile((word=br.readLine())!=null)\n\t\t\t{\n\t\t\t\tif(isPlausibleWord(word))\n\t\t\t\t\ttruecount++;\n\t\t\t\telse if(isOppPlausibleWord(word))\n\t\t\t\t\tfalsecount++;\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Plausible count: \"+truecount);\n\t\tSystem.out.println(\"Implausible count: \"+falsecount);\n\t\tif(truecount>2*falsecount)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ie\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cei\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isOppPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ei\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cie\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n"}
{"id": 392548, "name": "Xiaolin Wu's line algorithm", "source": "Translate Swift to Java: import Darwin\n\npublic func pixel(color: Color, x: Int, y: Int) {\n    let idx = x + y * self.width\n    if idx >= 0 && idx < self.bitmap.count {\n        self.bitmap[idx] = self.blendColors(bot: self.bitmap[idx], top: color)\n    }\n}\n\n\nfunc fpart(_ x: Double) -> Double {\n    return modf(x).1\n}\n\n\nfunc rfpart(_ x: Double) -> Double {\n    return 1 - fpart(x)\n}\n\n\npublic func smoothLine(_ p0: Point, _ p1: Point) {\n    var x0 = p0.x, x1 = p1.x, y0 = p0.y, y1 = p1.y \n    let steep = abs(y1 - y0) > abs(x1 - x0)\n    if steep {\n        swap(&x0, &y0)\n        swap(&x1, &y1)\n    }\n    if x0 > x1 {\n        swap(&x0, &x1)\n        swap(&y0, &y1)\n    }\n    let dX = x1 - x0\n    let dY = y1 - y0\n    \n    var gradient: Double\n    if dX == 0.0 {\n        gradient = 1.0\n    }\n    else {\n        gradient = dY / dX\n    }\n    \n    \n    var xend = round(x0)\n    var yend = y0 + gradient * (xend - x0)\n    var xgap = self.rfpart(x0 + 0.5)\n    let xpxl1 = Int(xend)\n    let ypxl1 = Int(yend)\n    \n    \n    var intery = yend + gradient\n    \n    if steep {\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(yend) * xgap), x: ypxl1, y: xpxl1)\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(yend) * xgap), x: ypxl1 + 1, y: xpxl1)\n    }\n    else {\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(yend) * xgap), x: xpxl1, y: ypxl1)\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(yend) * xgap), x: xpxl1, y: ypxl1 + 1)\n    }\n    \n    xend = round(x1)\n    yend = y1 + gradient * (xend - x1)\n    xgap = self.fpart(x1 + 0.5)\n    let xpxl2 = Int(xend)\n    let ypxl2 = Int(yend)\n    \n    \n    if steep {\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(yend) * xgap), x: ypxl2, y: xpxl2)\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(yend) * xgap), x: ypxl2 + 1, y: xpxl2)\n    }\n    else {\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(yend) * xgap), x: xpxl2, y: ypxl2)\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(yend) * xgap), x: xpxl2, y: ypxl2 + 1)\n    }\n    \n    \n    if steep {\n        for x in xpxl1+1..<xpxl2 {\n            self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(intery)), x: Int(intery), y: x)\n            self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(intery)), x: Int(intery) + 1, y:x)\n            intery += gradient\n        }\n    }\n    else {\n        for x in xpxl1+1..<xpxl2 {\n            self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(intery)), x: x, y: Int(intery))\n            self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(intery)), x: x, y: Int(intery) + 1)\n            intery += gradient\n        }\n    }\n}\n", "target": "import java.awt.*;\nimport static java.lang.Math.*;\nimport javax.swing.*;\n\npublic class XiaolinWu extends JPanel {\n\n    public XiaolinWu() {\n        Dimension dim = new Dimension(640, 640);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n    }\n\n    void plot(Graphics2D g, double x, double y, double c) {\n        g.setColor(new Color(0f, 0f, 0f, (float)c));\n        g.fillOval((int) x, (int) y, 2, 2);\n    }\n\n    int ipart(double x) {\n        return (int) x;\n    }\n\n    double fpart(double x) {\n        return x - floor(x);\n    }\n\n    double rfpart(double x) {\n        return 1.0 - fpart(x);\n    }\n\n    void drawLine(Graphics2D g, double x0, double y0, double x1, double y1) {\n\n        boolean steep = abs(y1 - y0) > abs(x1 - x0);\n        if (steep)\n            drawLine(g, y0, x0, y1, x1);\n\n        if (x0 > x1)\n            drawLine(g, x1, y1, x0, y0);\n\n        double dx = x1 - x0;\n        double dy = y1 - y0;\n        double gradient = dy / dx;\n\n        \n        double xend = round(x0);\n        double yend = y0 + gradient * (xend - x0);\n        double xgap = rfpart(x0 + 0.5);\n        double xpxl1 = xend; \n        double ypxl1 = ipart(yend);\n\n        if (steep) {\n            plot(g, ypxl1, xpxl1, rfpart(yend) * xgap);\n            plot(g, ypxl1 + 1, xpxl1, fpart(yend) * xgap);\n        } else {\n            plot(g, xpxl1, ypxl1, rfpart(yend) * xgap);\n            plot(g, xpxl1, ypxl1 + 1, fpart(yend) * xgap);\n        }\n\n        \n        double intery = yend + gradient;\n\n        \n        xend = round(x1);\n        yend = y1 + gradient * (xend - x1);\n        xgap = fpart(x1 + 0.5);\n        double xpxl2 = xend; \n        double ypxl2 = ipart(yend);\n\n        if (steep) {\n            plot(g, ypxl2, xpxl2, rfpart(yend) * xgap);\n            plot(g, ypxl2 + 1, xpxl2, fpart(yend) * xgap);\n        } else {\n            plot(g, xpxl2, ypxl2, rfpart(yend) * xgap);\n            plot(g, xpxl2, ypxl2 + 1, fpart(yend) * xgap);\n        }\n\n        \n        for (double x = xpxl1 + 1; x <= xpxl2 - 1; x++) {\n            if (steep) {\n                plot(g, ipart(intery), x, rfpart(intery));\n                plot(g, ipart(intery) + 1, x, fpart(intery));\n            } else {\n                plot(g, x, ipart(intery), rfpart(intery));\n                plot(g, x, ipart(intery) + 1, fpart(intery));\n            }\n            intery = intery + gradient;\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n\n        drawLine(g, 550, 170, 50, 435);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Xiaolin Wu's line algorithm\");\n            f.setResizable(false);\n            f.add(new XiaolinWu(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 392549, "name": "Four is magic", "source": "Translate Swift to Java: import Foundation\n\nfunc fourIsMagic(_ number: NSNumber) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .spellOut\n    formatter.locale = Locale(identifier: \"en_EN\")\n\n    var result: [String] = []\n\n    var numberString = formatter.string(from: number)!\n    result.append(numberString.capitalized)\n\n    while numberString != \"four\" {\n        numberString = formatter.string(from: NSNumber(value: numberString.count))!\n        result.append(contentsOf: [\" is \", numberString, \", \", numberString])\n    }\n\n    result.append(\" is magic.\")\n    return result.joined()\n}\n\nfor testInput in [23, 1000000000, 20140, 100, 130, 151, -7] { \n    print(fourIsMagic(testInput as NSNumber))\n}\n", "target": "public class FourIsMagic {\n\n    public static void main(String[] args) {\n        for ( long n : new long[] {6, 60, 89, 300, 670, 2000, 2467, 20000, 24500,200000, 230000, 246571, 2300000, 2465712, 20000000, 24657123, 230000000, 245000000, -246570000, 123456789712345l, 8777777777777777777L, Long.MAX_VALUE}) {\n            String magic = fourIsMagic(n);\n            System.out.printf(\"%d = %s%n\", n, toSentence(magic));\n        }\n    }\n    \n    private static final String toSentence(String s) {\n        return s.substring(0,1).toUpperCase() + s.substring(1) + \".\";\n    }\n    \n    private static final String[] nums = new String[] {\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n            \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n    };\n    \n    private static final String[] tens = new String[] {\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n\n    private static final String fourIsMagic(long n) {\n        if ( n == 4 ) {\n            return numToString(n) + \" is magic\";\n        }\n        String result = numToString(n);\n        return result + \" is \" + numToString(result.length()) + \", \" + fourIsMagic(result.length());\n    }\n    \n    private static final String numToString(long n) {\n        if ( n < 0 ) { \n            return \"negative \" + numToString(-n);\n        }\n        int index = (int) n;\n        if ( n <= 19 ) {\n            return nums[index];\n        }\n        if ( n <= 99 ) {\n            return tens[index/10] + (n % 10 > 0 ? \" \" + numToString(n % 10) : \"\");\n        }\n        String label = null;\n        long factor = 0;\n        if ( n <= 999 ) {\n            label = \"hundred\";\n            factor = 100;\n        }\n        else if ( n <= 999999) {\n            label = \"thousand\";\n            factor = 1000;\n        }\n        else if ( n <= 999999999) {\n            label = \"million\";\n            factor = 1000000;\n        }\n        else if ( n <= 999999999999L) {\n            label = \"billion\";\n            factor = 1000000000;\n        }\n        else if ( n <= 999999999999999L) {\n            label = \"trillion\";\n            factor = 1000000000000L;\n        }\n        else if ( n <= 999999999999999999L) {\n            label = \"quadrillion\";\n            factor = 1000000000000000L;\n        }\n        else {\n            label = \"quintillion\";\n            factor = 1000000000000000000L;\n        }\n        return numToString(n / factor) + \" \" + label + (n % factor > 0 ? \" \" + numToString(n % factor ) : \"\");\n    }\n\n}\n"}
{"id": 392550, "name": "Zhang-Suen thinning algorithm", "source": "Translate Swift to Java: import UIKit\n\n\nlet beforeTxt = \"\"\"\n1100111\n1100111\n1100111\n1100111\n1100110\n1100110\n1100110\n1100110\n1100110\n1100110\n1100110\n1100110\n1111110\n0000000\n\"\"\"\n\nlet smallrc01 = \"\"\"\n00000000000000000000000000000000\n01111111110000000111111110000000\n01110001111000001111001111000000\n01110000111000001110000111000000\n01110001111000001110000000000000\n01111111110000001110000000000000\n01110111100000001110000111000000\n01110011110011101111001111011100\n01110001111011100111111110011100\n00000000000000000000000000000000\n\"\"\"\n \nlet rc01 = \"\"\"\n00000000000000000000000000000000000000000000000000000000000\n01111111111111111100000000000000000001111111111111000000000\n01111111111111111110000000000000001111111111111111000000000\n01111111111111111111000000000000111111111111111111000000000\n01111111100000111111100000000001111111111111111111000000000\n00011111100000111111100000000011111110000000111111000000000\n00011111100000111111100000000111111100000000000000000000000\n00011111111111111111000000000111111100000000000000000000000\n00011111111111111110000000000111111100000000000000000000000\n00011111111111111111000000000111111100000000000000000000000\n00011111100000111111100000000111111100000000000000000000000\n00011111100000111111100000000111111100000000000000000000000\n00011111100000111111100000000011111110000000111111000000000\n01111111100000111111100000000001111111111111111111000000000\n01111111100000111111101111110000111111111111111111011111100\n01111111100000111111101111110000001111111111111111011111100\n01111111100000111111101111110000000001111111111111011111100\n00000000000000000000000000000000000000000000000000000000000\n\"\"\"\n\n\n\nfunc zhangSuen(image: inout [[Int]]) -> [[Int]] {\n    \n    var changing1, changing2: [(Int, Int)]\n    repeat {\n        \n        changing1 = []\n        changing2 = []\n        \n        \n        for y in 1..<image.count-1 {\n            \n            for x in 1..<image[0].count-1 {\n                \n                var nb = neighbours(x: x, y: y, image: image)\n                \n                let P2 = nb[0], P4 = nb[2], P6 = nb[4], P8 = nb[6]\n                \n                \n                if (image[y][x] == 1 &&                      \n                    (2...6).contains(nb.reduce(0, +)) &&     \n                    transitions(neighbours: &nb) == 1 &&     \n                    P2 * P4 * P6 == 0 &&                     \n                    P4 * P6 * P8 == 0                        \n                ) {\n                    \n                    changing1.append((x,y))\n                }\n            }\n        }\n        \n        for (x, y) in changing1 {\n            image[y][x] = 0\n        }\n        \n        \n        for y in 1..<image.count-1 {\n            \n            for x in 1..<image[0].count-1 {\n                \n                var nb = neighbours(x: x, y: y, image: image)\n                \n                let P2 = nb[0], P4 = nb[2], P6 = nb[4], P8 = nb[6]\n                if (image[y][x] == 1 &&                      \n                    (2...6).contains(nb.reduce(0, +)) &&     \n                    transitions(neighbours: &nb) == 1 &&     \n                    P2 * P4 * P8 == 0 &&                     \n                    P2 * P6 * P8 == 0                        \n                ) {\n                    \n                    changing2.append((x,y))\n                }\n            }\n        }\n        \n        for (x, y) in changing2 {\n            image[y][x] = 0\n        }\n        \n    } while !changing1.isEmpty && !changing2.isEmpty\n    \n    return image\n}\n\n\nfunc intarray(binstring: String) -> [[Int]] {\n    \n    \n    return binstring.split(separator: \"\\n\").map {$0.compactMap{$0.wholeNumberValue}}\n}\n\n\nfunc toTxt(intmatrix: [[Int]]) -> String {\n    \n    \n    return intmatrix.map {$0.map { $0 == 1 ? \"#\" : \".\"}.joined(separator: \"\")}.joined(separator: \"\\n\")\n}\n\n\nfunc neighbours(x: Int, y: Int, image: [[Int]]) -> [Int] {\n    let i = image\n    \n    let x1 = x+1, y1 = y-1, x_1 = x-1, y_1 = y+1\n    \n    return [i[y1][x],  i[y1][x1],   i[y][x1],  i[y_1][x1],  \n            i[y_1][x], i[y_1][x_1], i[y][x_1], i[y1][x_1]]  \n}\n\n\nfunc transitions(neighbours: inout [Int]) -> Int {\n    \n    let n = neighbours + [neighbours[0]]\n    var result = 0\n    \n    \n    for (n1, n2) in zip(n, n.suffix(n.count - 1)) {\n        \n        if (n1, n2) == (0, 1) { result += 1 }\n    }\n    \n    return result\n}\n\n\n\nlet testCases: [String] = [beforeTxt, smallrc01, rc01]\nfor picture in testCases {\n    \n    var image = intarray(binstring: picture)\n    \n    print(\"\\nFrom:\\n\\(toTxt(intmatrix: image))\")\n    \n    let after = zhangSuen(image: &image)\n    \n    print(\"\\nTo thinned:\\n\\(toTxt(intmatrix: after))\")\n}\n", "target": "import java.awt.Point;\nimport java.util.*;\n\npublic class ZhangSuen {\n\n    final static String[] image = {\n        \"                                                          \",\n        \" #################                   #############        \",\n        \" ##################               ################        \",\n        \" ###################            ##################        \",\n        \" ########     #######          ###################        \",\n        \"   ######     #######         #######       ######        \",\n        \"   ######     #######        #######                      \",\n        \"   #################         #######                      \",\n        \"   ################          #######                      \",\n        \"   #################         #######                      \",\n        \"   ######     #######        #######                      \",\n        \"   ######     #######        #######                      \",\n        \"   ######     #######         #######       ######        \",\n        \" ########     #######          ###################        \",\n        \" ########     ####### ######    ################## ###### \",\n        \" ########     ####### ######      ################ ###### \",\n        \" ########     ####### ######         ############# ###### \",\n        \"                                                          \"};\n\n    final static int[][] nbrs = {{0, -1}, {1, -1}, {1, 0}, {1, 1}, {0, 1},\n        {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}};\n\n    final static int[][][] nbrGroups = {{{0, 2, 4}, {2, 4, 6}}, {{0, 2, 6},\n        {0, 4, 6}}};\n\n    static List<Point> toWhite = new ArrayList<>();\n    static char[][] grid;\n\n    public static void main(String[] args) {\n        grid = new char[image.length][];\n        for (int r = 0; r < image.length; r++)\n            grid[r] = image[r].toCharArray();\n\n        thinImage();\n    }\n\n    static void thinImage() {\n        boolean firstStep = false;\n        boolean hasChanged;\n\n        do {\n            hasChanged = false;\n            firstStep = !firstStep;\n\n            for (int r = 1; r < grid.length - 1; r++) {\n                for (int c = 1; c < grid[0].length - 1; c++) {\n\n                    if (grid[r][c] != '#')\n                        continue;\n\n                    int nn = numNeighbors(r, c);\n                    if (nn < 2 || nn > 6)\n                        continue;\n\n                    if (numTransitions(r, c) != 1)\n                        continue;\n\n                    if (!atLeastOneIsWhite(r, c, firstStep ? 0 : 1))\n                        continue;\n\n                    toWhite.add(new Point(c, r));\n                    hasChanged = true;\n                }\n            }\n\n            for (Point p : toWhite)\n                grid[p.y][p.x] = ' ';\n            toWhite.clear();\n\n        } while (firstStep || hasChanged);\n\n        printResult();\n    }\n\n    static int numNeighbors(int r, int c) {\n        int count = 0;\n        for (int i = 0; i < nbrs.length - 1; i++)\n            if (grid[r + nbrs[i][1]][c + nbrs[i][0]] == '#')\n                count++;\n        return count;\n    }\n\n    static int numTransitions(int r, int c) {\n        int count = 0;\n        for (int i = 0; i < nbrs.length - 1; i++)\n            if (grid[r + nbrs[i][1]][c + nbrs[i][0]] == ' ') {\n                if (grid[r + nbrs[i + 1][1]][c + nbrs[i + 1][0]] == '#')\n                    count++;\n            }\n        return count;\n    }\n\n    static boolean atLeastOneIsWhite(int r, int c, int step) {\n        int count = 0;\n        int[][] group = nbrGroups[step];\n        for (int i = 0; i < 2; i++)\n            for (int j = 0; j < group[i].length; j++) {\n                int[] nbr = nbrs[group[i][j]];\n                if (grid[r + nbr[1]][c + nbr[0]] == ' ') {\n                    count++;\n                    break;\n                }\n            }\n        return count > 1;\n    }\n\n    static void printResult() {\n        for (char[] row : grid)\n            System.out.println(row);\n    }\n}\n"}
{"id": 392551, "name": "Generate Chess960 starting position", "source": "Translate Swift to Java: func isValid960Position(_ firstRank: String) -> Bool {\n  var rooksPlaced = 0\n  var bishopColor = -1\n\n  for (i, piece) in firstRank.enumerated() {\n    switch piece {\n    case \"\u265a\" where rooksPlaced != 1:\n      return false\n    case \"\u265c\":\n      rooksPlaced += 1\n    case \"\u265d\" where bishopColor == -1:\n      bishopColor = i & 1\n    case \"\u265d\" where bishopColor == i & 1:\n      return false\n    case _:\n      continue\n    }\n  }\n\n  return true\n}\n\nstruct Chess960Counts {\n  var king = 0, queen = 0, rook = 0, bishop = 0, knight = 0\n\n  subscript(_ piece: String) -> Int {\n    get {\n      switch piece {\n      case \"\u265a\": return king\n      case \"\u265b\": return queen\n      case \"\u265c\": return rook\n      case \"\u265d\": return bishop\n      case \"\u265e\": return knight\n      case _:   fatalError()\n      }\n    }\n\n    set {\n      switch piece {\n      case \"\u265a\": king = newValue\n      case \"\u265b\": queen = newValue\n      case \"\u265c\": rook = newValue\n      case \"\u265d\": bishop = newValue\n      case \"\u265e\": knight = newValue\n      case _:   fatalError()\n      }\n    }\n  }\n}\n\nfunc get960Position() -> String {\n  var counts = Chess960Counts()\n  var bishopColor = -1 \n  var output = \"\"\n\n  for i in 1...8 {\n    let validPieces = [\n      counts[\"\u265c\"] == 1 && counts[\"\u265a\"] == 0 ? \"\u265a\" : nil, \n      i == 1 || (counts[\"\u265b\"] == 0) ? \"\u265b\" : nil, \n      i == 1 || (counts[\"\u265c\"] == 0 || counts[\"\u265c\"] < 2 && counts[\"\u265a\"] == 1) ? \"\u265c\" : nil, \n      i == 1 || (counts[\"\u265d\"] < 2 && bishopColor == -1 || bishopColor != i & 1) ? \"\u265d\" : nil, \n      i == 1 || (counts[\"\u265e\"] < 2) ? \"\u265e\" : nil \n    ].lazy.compactMap({ $0 })\n\n    guard let chosenPiece = validPieces.randomElement() else {\n      \n      output.insert(\"\u265d\", at: output.index(before: output.endIndex))\n\n      break\n    }\n\n    counts[chosenPiece] += 1\n    output += chosenPiece\n\n    if bishopColor == -1 && chosenPiece == \"\u265d\" {\n      bishopColor = i & 1\n    }\n  }\n\n  assert(isValid960Position(output), \"invalid 960 position \\(output)\")\n\n  return output\n}\n\nvar positions = Set<String>()\n\nwhile positions.count != 960 {\n  positions.insert(get960Position())\n}\n\nprint(positions.count, positions.randomElement()!)\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Chess960{\n\tprivate static List<Character> pieces = Arrays.asList('R','B','N','Q','K','N','B','R');\n\n\tpublic static List<Character> generateFirstRank(){\n\t\tdo{\n\t\t\tCollections.shuffle(pieces);\n\t\t}while(!check(pieces.toString().replaceAll(\"[^\\\\p{Upper}]\", \"\"))); \n\t\t\n\t\treturn pieces;\n\t}\n\n\tprivate static boolean check(String rank){\n\t\tif(!rank.matches(\".*R.*K.*R.*\")) return false;\t\t\t\n\t\tif(!rank.matches(\".*B(..|....|......|)B.*\")) return false;\t\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tSystem.out.println(generateFirstRank());\n\t\t}\n\t}\n}\n"}
{"id": 392552, "name": "Spelling of ordinal numbers", "source": "Translate Swift to Java: fileprivate class NumberNames {\n    let cardinal: String\n    let ordinal: String\n\n    init(cardinal: String, ordinal: String) {\n        self.cardinal = cardinal\n        self.ordinal = ordinal\n    }\n    \n    func getName(_ ordinal: Bool) -> String {\n        return ordinal ? self.ordinal : self.cardinal\n    }\n    \n    class func numberName(number: Int, ordinal: Bool) -> String {\n        guard number < 100 else {\n            return \"\"\n        }\n        if number < 20 {\n            return smallNames[number].getName(ordinal)\n        }\n        if number % 10 == 0 {\n            return tens[number/10 - 2].getName(ordinal)\n        }\n        var result = tens[number/10 - 2].getName(false)\n        result += \"-\"\n        result += smallNames[number % 10].getName(ordinal)\n        return result\n    }\n    \n    static let smallNames = [\n        NumberNames(cardinal: \"zero\", ordinal: \"zeroth\"),\n        NumberNames(cardinal: \"one\", ordinal: \"first\"),\n        NumberNames(cardinal: \"two\", ordinal: \"second\"),\n        NumberNames(cardinal: \"three\", ordinal: \"third\"),\n        NumberNames(cardinal: \"four\", ordinal: \"fourth\"),\n        NumberNames(cardinal: \"five\", ordinal: \"fifth\"),\n        NumberNames(cardinal: \"six\", ordinal: \"sixth\"),\n        NumberNames(cardinal: \"seven\", ordinal: \"seventh\"),\n        NumberNames(cardinal: \"eight\", ordinal: \"eighth\"),\n        NumberNames(cardinal: \"nine\", ordinal: \"ninth\"),\n        NumberNames(cardinal: \"ten\", ordinal: \"tenth\"),\n        NumberNames(cardinal: \"eleven\", ordinal: \"eleventh\"),\n        NumberNames(cardinal: \"twelve\", ordinal: \"twelfth\"),\n        NumberNames(cardinal: \"thirteen\", ordinal: \"thirteenth\"),\n        NumberNames(cardinal: \"fourteen\", ordinal: \"fourteenth\"),\n        NumberNames(cardinal: \"fifteen\", ordinal: \"fifteenth\"),\n        NumberNames(cardinal: \"sixteen\", ordinal: \"sixteenth\"),\n        NumberNames(cardinal: \"seventeen\", ordinal: \"seventeenth\"),\n        NumberNames(cardinal: \"eighteen\", ordinal: \"eighteenth\"),\n        NumberNames(cardinal: \"nineteen\", ordinal: \"nineteenth\")\n    ]\n\n    static let tens = [\n        NumberNames(cardinal: \"twenty\", ordinal: \"twentieth\"),\n        NumberNames(cardinal: \"thirty\", ordinal: \"thirtieth\"),\n        NumberNames(cardinal: \"forty\", ordinal: \"fortieth\"),\n        NumberNames(cardinal: \"fifty\", ordinal: \"fiftieth\"),\n        NumberNames(cardinal: \"sixty\", ordinal: \"sixtieth\"),\n        NumberNames(cardinal: \"seventy\", ordinal: \"seventieth\"),\n        NumberNames(cardinal: \"eighty\", ordinal: \"eightieth\"),\n        NumberNames(cardinal: \"ninety\", ordinal: \"ninetieth\")\n    ]\n}\n\nfileprivate class NamedPower {\n    let cardinal: String\n    let ordinal: String\n    let number: UInt64\n    \n    init(cardinal: String, ordinal: String, number: UInt64) {\n        self.cardinal = cardinal\n        self.ordinal = ordinal\n        self.number = number\n    }\n    \n    func getName(_ ordinal: Bool) -> String {\n        return ordinal ? self.ordinal : self.cardinal\n    }\n\n    class func getNamedPower(_ number: UInt64) -> NamedPower {\n        for i in 1..<namedPowers.count {\n            if number < namedPowers[i].number {\n                return namedPowers[i - 1]\n            }\n        }\n        return namedPowers[namedPowers.count - 1]\n    }\n\n    static let namedPowers = [\n        NamedPower(cardinal: \"hundred\", ordinal: \"hundredth\",\n                   number: 100),\n        NamedPower(cardinal: \"thousand\", ordinal: \"thousandth\",\n                   number: 1000),\n        NamedPower(cardinal: \"million\", ordinal: \"millionth\",\n                   number: 1000000),\n        NamedPower(cardinal: \"billion\", ordinal: \"billionth\",\n                   number: 1000000000),\n        NamedPower(cardinal: \"trillion\", ordinal: \"trillionth\",\n                   number: 1000000000000),\n        NamedPower(cardinal: \"quadrillion\", ordinal: \"quadrillionth\",\n                   number: 1000000000000000),\n        NamedPower(cardinal: \"quintillion\", ordinal: \"quintillionth\",\n                   number: 1000000000000000000)\n    ]\n}\n\npublic func numberName(number: UInt64, ordinal: Bool) -> String {\n    if number < 100 {\n        return NumberNames.numberName(number: Int(truncatingIfNeeded: number),\n                                      ordinal: ordinal)\n    }\n    let p = NamedPower.getNamedPower(number)\n    var result = numberName(number: number/p.number, ordinal: false)\n    result += \" \"\n    if number % p.number == 0 {\n        result += p.getName(ordinal)\n    } else {\n        result += p.getName(false)\n        result += \" \"\n        result += numberName(number: number % p.number, ordinal: ordinal)\n    }\n    return result\n}\n\nfunc printOrdinal(_ number: UInt64) {\n    print(\"\\(number): \\(numberName(number: number, ordinal: true))\")\n}\n\nprintOrdinal(1)\nprintOrdinal(2)\nprintOrdinal(3)\nprintOrdinal(4)\nprintOrdinal(5)\nprintOrdinal(11)\nprintOrdinal(15)\nprintOrdinal(21)\nprintOrdinal(42)\nprintOrdinal(65)\nprintOrdinal(98)\nprintOrdinal(100)\nprintOrdinal(101)\nprintOrdinal(272)\nprintOrdinal(300)\nprintOrdinal(750)\nprintOrdinal(23456)\nprintOrdinal(7891233)\nprintOrdinal(8007006005004003)\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class SpellingOfOrdinalNumbers {\n\n    public static void main(String[] args) {\n        for ( long test : new long[] {1,  2,  3,  4,  5,  11,  65,  100,  101,  272,  23456,  8007006005004003L} ) {\n            System.out.printf(\"%d = %s%n\", test, toOrdinal(test));\n        }\n    }\n\n    private static Map<String,String> ordinalMap = new HashMap<>();\n    static {\n        ordinalMap.put(\"one\", \"first\");\n        ordinalMap.put(\"two\", \"second\");\n        ordinalMap.put(\"three\", \"third\");\n        ordinalMap.put(\"five\", \"fifth\");\n        ordinalMap.put(\"eight\", \"eighth\");\n        ordinalMap.put(\"nine\", \"ninth\");\n        ordinalMap.put(\"twelve\", \"twelfth\");\n    }\n    \n    private static String toOrdinal(long n) {\n        String spelling = numToString(n);\n        String[] split = spelling.split(\" \");\n        String last = split[split.length - 1];\n        String replace = \"\";\n        if ( last.contains(\"-\") ) {\n            String[] lastSplit = last.split(\"-\");\n            String lastWithDash = lastSplit[1];\n            String lastReplace = \"\";\n            if ( ordinalMap.containsKey(lastWithDash) ) {\n                lastReplace = ordinalMap.get(lastWithDash);\n            }\n            else if ( lastWithDash.endsWith(\"y\") ) {\n                lastReplace = lastWithDash.substring(0, lastWithDash.length() - 1) + \"ieth\";\n            }\n            else {\n                lastReplace = lastWithDash + \"th\";\n            }\n            replace = lastSplit[0] + \"-\" + lastReplace;\n        }\n        else {\n            if ( ordinalMap.containsKey(last) ) {\n                replace = ordinalMap.get(last);\n            }\n            else if ( last.endsWith(\"y\") ) {\n                replace = last.substring(0, last.length() - 1) + \"ieth\";\n            }\n            else {\n                replace = last + \"th\";\n            }\n        }\n        split[split.length - 1] = replace;\n        return String.join(\" \", split);\n    }\n\n    private static final String[] nums = new String[] {\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n            \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n    };\n    \n    private static final String[] tens = new String[] {\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n\n    private static final String numToString(long n) {\n        return numToStringHelper(n);\n    }\n    \n    private static final String numToStringHelper(long n) {\n        if ( n < 0 ) {\n            return \"negative \" + numToStringHelper(-n);\n        }\n        int index = (int) n;\n        if ( n <= 19 ) {\n            return nums[index];\n        }\n        if ( n <= 99 ) {\n            return tens[index/10] + (n % 10 > 0 ? \"-\" + numToStringHelper(n % 10) : \"\");\n        }\n        String label = null;\n        long factor = 0;\n        if ( n <= 999 ) {\n            label = \"hundred\";\n            factor = 100;\n        }\n        else if ( n <= 999999) {\n            label = \"thousand\";\n            factor = 1000;\n        }\n        else if ( n <= 999999999) {\n            label = \"million\";\n            factor = 1000000;\n        }\n        else if ( n <= 999999999999L) {\n            label = \"billion\";\n            factor = 1000000000;\n        }\n        else if ( n <= 999999999999999L) {\n            label = \"trillion\";\n            factor = 1000000000000L;\n        }\n        else if ( n <= 999999999999999999L) {\n            label = \"quadrillion\";\n            factor = 1000000000000000L;\n        }\n        else {\n            label = \"quintillion\";\n            factor = 1000000000000000000L;\n        }\n        return numToStringHelper(n / factor) + \" \" + label + (n % factor > 0 ? \" \" + numToStringHelper(n % factor ) : \"\");\n    }\n\n}\n"}
{"id": 392553, "name": "Line circle intersection", "source": "Translate Swift to Java: import Foundation\nimport CoreGraphics\n\nfunc lineCircleIntersection(start: NSPoint, end: NSPoint, center: NSPoint,\n                            radius: CGFloat, segment: Bool) -> [NSPoint] {\n    var result: [NSPoint] = []\n    let angle = atan2(end.y - start.y, end.x - start.x)\n    var at = AffineTransform(rotationByRadians: angle)\n    at.invert()\n    at.translate(x: -center.x, y: -center.y)\n    let p1 = at.transform(start)\n    let p2 = at.transform(end)\n    let minX = min(p1.x, p2.x), maxX = max(p1.x, p2.x)\n    let y = p1.y\n    at.invert()\n    func addPoint(x: CGFloat, y: CGFloat) {\n        if !segment || (x <= maxX && x >= minX) {\n            result.append(at.transform(NSMakePoint(x, y)))\n        }\n    }\n    if y == radius || y == -radius {\n        addPoint(x: 0, y: y)\n    } else if y < radius && y > -radius {\n        let x = (radius * radius - y * y).squareRoot()\n        addPoint(x: -x, y: y)\n        addPoint(x: x, y: y)\n    }\n    return result\n}\n\nfunc toString(points: [NSPoint]) -> String {\n    var result = \"[\"\n    result += points.map{String(format: \"(%.4f,\u00a0%.4f)\", $0.x, $0.y)}.joined(separator: \", \")\n    result += \"]\"\n    return result\n}\n\nvar center = NSMakePoint(3, -5)\nvar radius: CGFloat = 3\n\nprint(\"The intersection points (if any) between:\")\nprint(\"\\n  A circle, center (3, -5) with radius 3, and:\")\nprint(\"\\n    a line containing the points (-10, 11) and (10, -9) is/are:\")\nvar points = lineCircleIntersection(start: NSMakePoint(-10, 11), end: NSMakePoint(10, -9),\n                                    center: center, radius: radius,\n                                    segment: false)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a segment starting at (-10, 11) and ending at (-11, 12) is/are\")\npoints = lineCircleIntersection(start: NSMakePoint(-10, 11), end: NSMakePoint(-11, 12),\n                                center: center, radius: radius,\n                                segment: true)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a horizontal line containing the points (3, -2) and (7, -2) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(3, -2), end: NSMakePoint(7, -2),\n                                center: center, radius: radius,\n                                segment: false)\nprint(\"     \\(toString(points: points))\")\n\ncenter.x = 0\ncenter.y = 0\nradius = 4\n\nprint(\"\\n  A circle, center (0, 0) with radius 4, and:\")\nprint(\"\\n    a vertical line containing the points (0, -3) and (0, 6) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(0, -3), end: NSMakePoint(0, 6),\n                                center: center, radius: radius,\n                                segment: false)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a vertical segment starting at (0, -3) and ending at (0, 6) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(0, -3), end: NSMakePoint(0, 6),\n                                center: center, radius: radius,\n                                segment: true)\nprint(\"     \\(toString(points: points))\")\n\ncenter.x = 4\ncenter.y = 2\nradius = 5\n\nprint(\"\\n  A circle, center (4, 2) with radius 5, and:\")\nprint(\"\\n    a line containing the points (6, 3) and (10, 7) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(6, 3), end: NSMakePoint(10, 7),\n                                center: center, radius: radius,\n                                segment: false)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a segment starting at (7, 4) and ending at (11, 8) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(7, 4), end: NSMakePoint(11, 8),\n                                center: center, radius: radius,\n                                segment: true)\nprint(\"     \\(toString(points: points))\")\n", "target": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class LineCircleIntersection {\n    public static void main(String[] args) {\n        try {\n            demo();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void demo() throws NoninvertibleTransformException {\n        Point2D center = makePoint(3, -5);\n        double radius = 3.0;\n        System.out.println(\"The intersection points (if any) between:\");\n        System.out.println(\"\\n  A circle, center (3, -5) with radius 3, and:\");\n        System.out.println(\"\\n    a line containing the points (-10, 11) and (10, -9) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(-10, 11), makePoint(10, -9),\n                            center, radius, false)));\n        System.out.println(\"\\n    a segment starting at (-10, 11) and ending at (-11, 12) is/are\");\n        System.out.println(\"     \" + toString(intersection(makePoint(-10, 11), makePoint(-11, 12),\n                            center, radius, true)));\n        System.out.println(\"\\n    a horizontal line containing the points (3, -2) and (7, -2) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(3, -2), makePoint(7, -2), center, radius, false)));\n        center.setLocation(0, 0);\n        radius = 4.0;\n        System.out.println(\"\\n  A circle, center (0, 0) with radius 4, and:\");\n        System.out.println(\"\\n    a vertical line containing the points (0, -3) and (0, 6) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(0, -3), makePoint(0, 6),\n                            center, radius, false)));\n        System.out.println(\"\\n    a vertical segment starting at (0, -3) and ending at (0, 6) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(0, -3), makePoint(0, 6),\n                            center, radius, true)));\n        center.setLocation(4, 2);\n        radius = 5.0;\n        System.out.println(\"\\n  A circle, center (4, 2) with radius 5, and:\");\n        System.out.println(\"\\n    a line containing the points (6, 3) and (10, 7) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(6, 3), makePoint(10, 7),\n                            center, radius, false)));\n        System.out.println(\"\\n    a segment starting at (7, 4) and ending at (11, 8) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(7, 4), makePoint(11, 8),\n                            center, radius, true)));\n    }\n\n    private static Point2D makePoint(double x, double y) {\n        return new Point2D.Double(x, y);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public static List<Point2D> intersection(Point2D p1, Point2D p2, Point2D center,\n            double radius, boolean isSegment) throws NoninvertibleTransformException {\n        List<Point2D> result = new ArrayList<>();\n        double dx = p2.getX() - p1.getX();\n        double dy = p2.getY() - p1.getY();\n        AffineTransform trans = AffineTransform.getRotateInstance(dx, dy);\n        trans.invert();\n        trans.translate(-center.getX(), -center.getY());\n        Point2D p1a = trans.transform(p1, null);\n        Point2D p2a = trans.transform(p2, null);\n        double y = p1a.getY();\n        double minX = Math.min(p1a.getX(), p2a.getX());\n        double maxX = Math.max(p1a.getX(), p2a.getX());\n        if (y == radius || y == -radius) {\n            if (!isSegment || (0 <= maxX && 0 >= minX)) {\n                p1a.setLocation(0, y);\n                trans.inverseTransform(p1a, p1a);\n                result.add(p1a);\n            }\n        } else if (y < radius && y > -radius) {\n            double x = Math.sqrt(radius * radius - y * y);\n            if (!isSegment || (-x <= maxX && -x >= minX)) {\n                p1a.setLocation(-x, y);\n                trans.inverseTransform(p1a, p1a);\n                result.add(p1a);\n            }\n            if (!isSegment || (x <= maxX && x >= minX)) {\n                p2a.setLocation(x, y);\n                trans.inverseTransform(p2a, p2a);\n                result.add(p2a);\n            }\n        }\n        return result;\n    }\n\n    public static String toString(Point2D point) {\n        return String.format(\"(%g, %g)\", point.getX(), point.getY());\n    }\n\n    public static String toString(List<Point2D> points) {\n        StringBuilder str = new StringBuilder(\"[\");\n        for (int i = 0, n = points.size(); i < n; ++i) {\n            if (i > 0)\n                str.append(\", \");\n            str.append(toString(points.get(i)));\n        }\n        str.append(\"]\");\n        return str.toString();\n    }\n}\n"}
{"id": 392554, "name": "Farey sequence", "source": "Translate Swift to Java: class Farey {\n    let n: Int\n\n    init(_ x: Int) {\n        n = x\n    }\n\n    \n    var sequence: [(Int,Int)] {\n        var a = 0\n        var b = 1\n        var c = 1\n        var d = n\n        var results = [(a, b)]\n        while c <= n {\n            let k = (n + b) / d\n            let oldA = a\n            let oldB = b\n            a = c\n            b = d\n            c = k * c - oldA\n            d = k * d - oldB\n            results += [(a, b)]\n        }\n        return results\n    }\n\n    var formattedSequence: String {\n        var s = \"\\(n):\"\n        for pair in sequence {\n            s += \" \\(pair.0)/\\(pair.1)\"\n        }\n        return s\n    }\n\n}\n\nprint(\"Sequences\\n\")\n\nfor n in 1...11 {\n    print(Farey(n).formattedSequence)\n}\n\nprint(\"\\nSequence Lengths\\n\")\n\nfor n in 1...10 {\n    let m = n * 100\n    print(\"\\(m): \\(Farey(m).sequence.count)\")\n}\n", "target": "import java.util.TreeSet;\n\npublic class Farey{\n\tprivate static class Frac implements Comparable<Frac>{\n\t\tint num;\n\t\tint den;\n\t\t\n\t\tpublic Frac(int num, int den){\n\t\t\tthis.num = num;\n\t\t\tthis.den = den;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn num + \"/\" + den;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Frac o){\n\t\t\treturn Double.compare((double)num / den, (double)o.num / o.den);\n\t\t}\n\t}\n\t\n\tpublic static TreeSet<Frac> genFarey(int i){\n\t\tTreeSet<Frac> farey = new TreeSet<Frac>();\n\t\tfor(int den = 1; den <= i; den++){\n\t\t\tfor(int num = 0; num <= den; num++){\n\t\t\t\tfarey.add(new Frac(num, den));\n\t\t\t}\n\t\t}\n\t\treturn farey;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 11; i++){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i));\n\t\t}\n\t\t\n\t\tfor(int i = 100; i <= 1000; i += 100){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i).size() + \" members\");\n\t\t}\n\t}\n}\n"}
{"id": 392555, "name": "Farey sequence", "source": "Translate Swift to Java: class Farey {\n    let n: Int\n\n    init(_ x: Int) {\n        n = x\n    }\n\n    \n    var sequence: [(Int,Int)] {\n        var a = 0\n        var b = 1\n        var c = 1\n        var d = n\n        var results = [(a, b)]\n        while c <= n {\n            let k = (n + b) / d\n            let oldA = a\n            let oldB = b\n            a = c\n            b = d\n            c = k * c - oldA\n            d = k * d - oldB\n            results += [(a, b)]\n        }\n        return results\n    }\n\n    var formattedSequence: String {\n        var s = \"\\(n):\"\n        for pair in sequence {\n            s += \" \\(pair.0)/\\(pair.1)\"\n        }\n        return s\n    }\n\n}\n\nprint(\"Sequences\\n\")\n\nfor n in 1...11 {\n    print(Farey(n).formattedSequence)\n}\n\nprint(\"\\nSequence Lengths\\n\")\n\nfor n in 1...10 {\n    let m = n * 100\n    print(\"\\(m): \\(Farey(m).sequence.count)\")\n}\n", "target": "import java.util.TreeSet;\n\npublic class Farey{\n\tprivate static class Frac implements Comparable<Frac>{\n\t\tint num;\n\t\tint den;\n\t\t\n\t\tpublic Frac(int num, int den){\n\t\t\tthis.num = num;\n\t\t\tthis.den = den;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn num + \"/\" + den;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Frac o){\n\t\t\treturn Double.compare((double)num / den, (double)o.num / o.den);\n\t\t}\n\t}\n\t\n\tpublic static TreeSet<Frac> genFarey(int i){\n\t\tTreeSet<Frac> farey = new TreeSet<Frac>();\n\t\tfor(int den = 1; den <= i; den++){\n\t\t\tfor(int num = 0; num <= den; num++){\n\t\t\t\tfarey.add(new Frac(num, den));\n\t\t\t}\n\t\t}\n\t\treturn farey;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 11; i++){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i));\n\t\t}\n\t\t\n\t\tfor(int i = 100; i <= 1000; i += 100){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i).size() + \" members\");\n\t\t}\n\t}\n}\n"}
{"id": 392556, "name": "Aliquot sequence classifications", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\nstruct SeqClass: CustomStringConvertible {\n  var seq: [Int]\n  var desc: String\n\n  var description: String {\n    return \"\\(desc):    \\(seq)\"\n  }\n}\n\nfunc classifySequence(k: Int, threshold: Int = 1 << 47) -> SeqClass {\n  var last = k\n  var seq = [k]\n\n  while true {\n    last = last.factors().dropLast().reduce(0, +)\n    seq.append(last)\n\n    let n = seq.count\n\n    if last == 0 {\n      return SeqClass(seq: seq, desc: \"Terminating\")\n    } else if n == 2 && last == k {\n      return SeqClass(seq: seq, desc: \"Perfect\")\n    } else if n == 3 && last == k {\n      return SeqClass(seq: seq, desc: \"Amicable\")\n    } else if n >= 4 && last == k {\n      return SeqClass(seq: seq, desc: \"Sociable[\\(n - 1)]\")\n    } else if last == seq[n - 2] {\n      return SeqClass(seq: seq, desc: \"Aspiring\")\n    } else if seq.dropFirst().dropLast(2).contains(last) {\n      return SeqClass(seq: seq, desc: \"Cyclic[\\(n - 1 - seq.firstIndex(of: last)!)]\")\n    } else if n == 16 || last > threshold {\n      return SeqClass(seq: seq, desc: \"Non-terminating\")\n    }\n  }\n\n  fatalError()\n}\n\nfor i in 1...10 {\n  print(\"\\(i): \\(classifySequence(k: i))\")\n}\n\nprint()\n\nfor i in [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488] {\n  print(\"\\(i): \\(classifySequence(k: i))\")\n}\n\nprint()\n\nprint(\"\\(15355717786080): \\(classifySequence(k: 15355717786080))\")\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.LongStream;\n\npublic class AliquotSequenceClassifications {\n\n    private static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\n    }\n\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\n        List<Long> s = new ArrayList<>(maxLen);\n        s.add(n);\n        long newN = n;\n\n        while (s.size() <= maxLen && newN < maxTerm) {\n\n            newN = properDivsSum(s.get(s.size() - 1));\n\n            if (s.contains(newN)) {\n\n                if (s.get(0) == newN) {\n\n                    switch (s.size()) {\n                        case 1:\n                            return report(\"Perfect\", s);\n                        case 2:\n                            return report(\"Amicable\", s);\n                        default:\n                            return report(\"Sociable of length \" + s.size(), s);\n                    }\n\n                } else if (s.get(s.size() - 1) == newN) {\n                    return report(\"Aspiring\", s);\n\n                } else\n                    return report(\"Cyclic back to \" + newN, s);\n\n            } else {\n                s.add(newN);\n                if (newN == 0)\n                    return report(\"Terminating\", s);\n            }\n        }\n\n        return report(\"Non-terminating\", s);\n    }\n\n    static boolean report(String msg, List<Long> result) {\n        System.out.println(msg + \": \" + result);\n        return false;\n    }\n\n    public static void main(String[] args) {\n        long[] arr = {\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\n                790, 909, 562, 1064, 1488};\n\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\n        System.out.println();\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\n    }\n}\n"}
{"id": 392557, "name": "Aliquot sequence classifications", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\nstruct SeqClass: CustomStringConvertible {\n  var seq: [Int]\n  var desc: String\n\n  var description: String {\n    return \"\\(desc):    \\(seq)\"\n  }\n}\n\nfunc classifySequence(k: Int, threshold: Int = 1 << 47) -> SeqClass {\n  var last = k\n  var seq = [k]\n\n  while true {\n    last = last.factors().dropLast().reduce(0, +)\n    seq.append(last)\n\n    let n = seq.count\n\n    if last == 0 {\n      return SeqClass(seq: seq, desc: \"Terminating\")\n    } else if n == 2 && last == k {\n      return SeqClass(seq: seq, desc: \"Perfect\")\n    } else if n == 3 && last == k {\n      return SeqClass(seq: seq, desc: \"Amicable\")\n    } else if n >= 4 && last == k {\n      return SeqClass(seq: seq, desc: \"Sociable[\\(n - 1)]\")\n    } else if last == seq[n - 2] {\n      return SeqClass(seq: seq, desc: \"Aspiring\")\n    } else if seq.dropFirst().dropLast(2).contains(last) {\n      return SeqClass(seq: seq, desc: \"Cyclic[\\(n - 1 - seq.firstIndex(of: last)!)]\")\n    } else if n == 16 || last > threshold {\n      return SeqClass(seq: seq, desc: \"Non-terminating\")\n    }\n  }\n\n  fatalError()\n}\n\nfor i in 1...10 {\n  print(\"\\(i): \\(classifySequence(k: i))\")\n}\n\nprint()\n\nfor i in [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488] {\n  print(\"\\(i): \\(classifySequence(k: i))\")\n}\n\nprint()\n\nprint(\"\\(15355717786080): \\(classifySequence(k: 15355717786080))\")\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.LongStream;\n\npublic class AliquotSequenceClassifications {\n\n    private static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\n    }\n\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\n        List<Long> s = new ArrayList<>(maxLen);\n        s.add(n);\n        long newN = n;\n\n        while (s.size() <= maxLen && newN < maxTerm) {\n\n            newN = properDivsSum(s.get(s.size() - 1));\n\n            if (s.contains(newN)) {\n\n                if (s.get(0) == newN) {\n\n                    switch (s.size()) {\n                        case 1:\n                            return report(\"Perfect\", s);\n                        case 2:\n                            return report(\"Amicable\", s);\n                        default:\n                            return report(\"Sociable of length \" + s.size(), s);\n                    }\n\n                } else if (s.get(s.size() - 1) == newN) {\n                    return report(\"Aspiring\", s);\n\n                } else\n                    return report(\"Cyclic back to \" + newN, s);\n\n            } else {\n                s.add(newN);\n                if (newN == 0)\n                    return report(\"Terminating\", s);\n            }\n        }\n\n        return report(\"Non-terminating\", s);\n    }\n\n    static boolean report(String msg, List<Long> result) {\n        System.out.println(msg + \": \" + result);\n        return false;\n    }\n\n    public static void main(String[] args) {\n        long[] arr = {\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\n                790, 909, 562, 1064, 1488};\n\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\n        System.out.println();\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\n    }\n}\n"}
{"id": 392558, "name": "Magnanimous numbers", "source": "Translate Swift to Java: import Foundation\n\nfunc isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfunc isMagnanimous(_ n: Int) -> Bool {\n    var p = 10;\n    while n >= p {\n        if !isPrime(n % p + n / p) {\n            return false\n        }\n        p *= 10\n    }\n    return true\n}\n\nlet m = (0...).lazy.filter{isMagnanimous($0)}.prefix(400);\nprint(\"First 45 magnanimous numbers:\");\nfor (i, n) in m.prefix(45).enumerated() {\n    if i > 0 && i % 15 == 0 {\n        print()\n    }\n    print(String(format: \"%3d\", n), terminator: \" \")\n}\nprint(\"\\n\\n241st through 250th magnanimous numbers:\");\nfor n in m.dropFirst(240).prefix(10) {\n    print(n, terminator: \" \")\n}\nprint(\"\\n\\n391st through 400th magnanimous numbers:\");\nfor n in m.dropFirst(390) {\n    print(n, terminator: \" \")\n}\nprint()\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class MagnanimousNumbers {\n\n    public static void main(String[] args) {\n        runTask(\"Find and display the first 45 magnanimous numbers.\", 1, 45);\n        runTask(\"241st through 250th magnanimous numbers.\", 241, 250);\n        runTask(\"391st through 400th magnanimous numbers.\", 391, 400);\n    }\n    \n    private static void runTask(String message, int startN, int endN) {\n        int count = 0;\n        List<Integer> nums = new ArrayList<>();\n        for ( int n = 0 ; count < endN ; n++ ) {\n            if ( isMagnanimous(n) ) {\n                nums.add(n);\n                count++;\n            }\n        }\n        System.out.printf(\"%s%n\", message);\n        System.out.printf(\"%s%n%n\", nums.subList(startN-1, endN));\n    }\n    \n    private static boolean isMagnanimous(long n) {\n        if ( n >= 0 && n <= 9 ) {\n            return true;\n        }\n        long q = 11;\n        for ( long div = 10 ; q >= 10 ; div *= 10 ) {\n            q = n / div;\n            long r = n % div;\n            if ( ! isPrime(q+r) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private static final int MAX = 100_000;\n    private static final boolean[] primes = new boolean[MAX];\n    private static boolean SIEVE_COMPLETE = false;\n    \n    private static final boolean isPrimeTrivial(long test) {\n        if ( ! SIEVE_COMPLETE ) {\n            sieve();\n            SIEVE_COMPLETE = true;\n        }\n        return primes[(int) test];\n    }\n    \n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n    \n    public static final boolean isPrime(long testValue) {\n        if ( testValue == 2 ) return true;\n        if ( testValue % 2 == 0 ) return false;\n        if ( testValue <= MAX ) return isPrimeTrivial(testValue);\n        long d = testValue-1;\n        int s = 0;\n        while ( d % 2 == 0 ) {\n            s += 1;\n            d /= 2;\n        }\n        if ( testValue < 1373565L ) {\n            if ( ! aSrp(2, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(3, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        if ( testValue < 4759123141L ) {\n            if ( ! aSrp(2, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(7, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(61, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        if ( testValue < 10000000000000000L ) {\n            if ( ! aSrp(3, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(24251, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        \n        if ( ! aSrp(37, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(47, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(61, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(73, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(83, s, d, testValue) ) {\n            return false;\n        }\n        \n        return true;\n    }\n\n    private static final boolean aSrp(int a, int s, long d, long n) {\n        long modPow = modPow(a, d, n);\n        \n        if ( modPow == 1 ) {\n            return true;\n        }\n        int twoExpR = 1;\n        for ( int r = 0 ; r < s ; r++ ) {\n            if ( modPow(modPow, twoExpR, n) == n-1 ) {\n                return true;\n            }\n            twoExpR *= 2;\n        }\n        return false;\n    }\n    \n    private static final long SQRT = (long) Math.sqrt(Long.MAX_VALUE);\n    \n    public static final long modPow(long base, long exponent, long modulus) {\n        long result = 1;\n        while ( exponent > 0 ) {\n            if ( exponent % 2 == 1 ) {\n                if ( result > SQRT || base > SQRT ) {\n                    result = multiply(result, base, modulus);\n                }\n                else {\n                    result = (result * base) % modulus;\n                }\n            }\n            exponent >>= 1;\n            if ( base > SQRT ) {\n                base = multiply(base, base, modulus);\n            }\n            else {\n                base = (base * base) % modulus;\n            }\n        }\n        return result;\n    }\n\n\n    \n    public static final long multiply(long a, long b, long modulus) {\n        long x = 0;\n        long y = a % modulus;\n        long t;\n        while ( b > 0 ) {\n            if ( b % 2 == 1 ) {\n                t = x + y;\n                x = (t > modulus ? t-modulus : t);\n            }\n            t = y << 1;\n            y = (t > modulus ? t-modulus : t);\n            b >>= 1;\n        }\n        return x % modulus;\n    }\n\n}\n"}
{"id": 392559, "name": "Taxicab numbers", "source": "Translate Swift to Java: extension Array {\n  func combinations(_ k: Int) -> [[Element]] {\n    return Self._combinations(slice: self[startIndex...], k)\n  }\n\n  static func _combinations(slice: Self.SubSequence, _ k: Int) -> [[Element]] {\n    guard k != 1 else {\n      return slice.map({ [$0] })\n    }\n\n    guard k != slice.count else {\n      return [slice.map({ $0 })]\n    }\n\n    let chopped = slice[slice.index(after: slice.startIndex)...]\n\n    var res = _combinations(slice: chopped, k - 1).map({ [[slice.first!], $0].flatMap({ $0 }) })\n\n    res += _combinations(slice: chopped, k)\n\n    return res\n  }\n}\n\nlet cubes = (1...).lazy.map({ $0 * $0 * $0 })\nlet taxis =\n  Array(cubes.prefix(1201))\n    .combinations(2)\n    .reduce(into: [Int: [[Int]]](), { $0[$1[0] + $1[1], default: []].append($1) })\n\n\nlet res =\n  taxis\n    .lazy\n    .filter({ $0.value.count > 1 })\n    .sorted(by: { $0.key < $1.key })\n    .map({ ($0.key, $0.value) })\n    .prefix(2006)\n\nprint(\"First 25 taxicab numbers:\")\nfor taxi in res[..<25] {\n  print(taxi)\n}\n\nprint(\"\\n2000th through 2006th taxicab numbers:\")\nfor taxi in res[1999..<2006] {\n  print(taxi)\n}\n", "target": "import java.util.PriorityQueue;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Iterator;\n\nclass CubeSum implements Comparable<CubeSum> {\n\tpublic long x, y, value;\n\n\tpublic CubeSum(long x, long y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.value = x*x*x + y*y*y;\n\t}\n\n\tpublic String toString() {\n\t\treturn String.format(\"%4d^3 + %4d^3\", x, y);\n\t}\n\n\tpublic int compareTo(CubeSum that) {\n\t\treturn value < that.value ? -1 : value > that.value ? 1 : 0;\n\t}\n}\n\nclass SumIterator implements Iterator<CubeSum> {\n\tPriorityQueue<CubeSum> pq = new PriorityQueue<CubeSum>();\n\tlong n = 0;\n\n\tpublic boolean hasNext() { return true; }\n\tpublic CubeSum next() {\n\t\twhile (pq.size() == 0 || pq.peek().value >= n*n*n)\n\t\t\tpq.add(new CubeSum(++n, 1));\n\n\t\tCubeSum s = pq.remove();\n\t\tif (s.x > s.y + 1) pq.add(new CubeSum(s.x, s.y+1));\n\n\t\treturn s;\n\t}\n}\n\nclass TaxiIterator implements Iterator<List<CubeSum>> {\n\tIterator<CubeSum> sumIterator = new SumIterator();\n\tCubeSum last = sumIterator.next();\n\n\tpublic boolean hasNext() { return true; }\n\tpublic List<CubeSum> next() {\n\t\tCubeSum s;\n\t\tList<CubeSum> train = new ArrayList<CubeSum>();\n\n\t\twhile ((s = sumIterator.next()).value != last.value)\n\t\t\tlast = s;\n\n\t\ttrain.add(last);\n\n\t\tdo { train.add(s); } while ((s = sumIterator.next()).value == last.value);\n\t\tlast = s;\n\n\t\treturn train;\n\t}\n}\n\t\npublic class Taxi {\n\tpublic static final void main(String[] args) {\n\t\tIterator<List<CubeSum>> taxi = new TaxiIterator();\n\n\t\tfor (int i = 1; i <= 2006; i++) {\n\t\t\tList<CubeSum> t = taxi.next();\n\t\t\tif (i > 25 && i < 2000) continue;\n\n\t\t\tSystem.out.printf(\"%4d: %10d\", i, t.get(0).value);\n\t\t\tfor (CubeSum s: t)\n\t\t\t\tSystem.out.print(\" = \" + s);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 392560, "name": "Strong and weak primes", "source": "Translate Swift to Java: import Foundation\n\nclass PrimeSieve {\n    var composite: [Bool]\n    \n    init(size: Int) {\n        composite = Array(repeating: false, count: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite[p/2 - 1] {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite[q/2 - 1] = true\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite[number/2 - 1]\n    }\n}\n\nfunc commatize(_ number: Int) -> String {\n    let n = NSNumber(value: number)\n    return NumberFormatter.localizedString(from: n, number: .decimal)\n}\n\nlet limit1 = 1000000\nlet limit2 = 10000000\n\nclass PrimeInfo {\n    let maxPrint: Int\n    var count1: Int\n    var count2: Int\n    var primes: [Int]\n    \n    init(maxPrint: Int) {\n        self.maxPrint = maxPrint\n        count1 = 0\n        count2 = 0\n        primes = []\n    }\n    \n    func addPrime(prime: Int) {\n        count2 += 1\n        if prime < limit1 {\n            count1 += 1\n        }\n        if count2 <= maxPrint {\n            primes.append(prime)\n        }\n    }\n    \n    func printInfo(name: String) {\n        print(\"First \\(maxPrint) \\(name) primes: \\(primes)\")\n        print(\"Number of \\(name) primes below \\(commatize(limit1)): \\(commatize(count1))\")\n        print(\"Number of \\(name) primes below \\(commatize(limit2)): \\(commatize(count2))\")\n    }\n}\n\nvar strongPrimes = PrimeInfo(maxPrint: 36)\nvar weakPrimes = PrimeInfo(maxPrint: 37)\n\nlet sieve = PrimeSieve(size: limit2 + 100)\n\nvar p1 = 2, p2 = 3, p3 = 5\nwhile p2 < limit2 {\n    if sieve.isPrime(number: p3) {\n        let diff = p1 + p3 - 2 * p2\n        if diff < 0 {\n            strongPrimes.addPrime(prime: p2)\n        } else if diff > 0 {\n            weakPrimes.addPrime(prime: p2)\n        }\n        p1 = p2\n        p2 = p3\n    }\n    p3 += 2\n}\n\nstrongPrimes.printInfo(name: \"strong\")\nweakPrimes.printInfo(name: \"weak\")\n", "target": "public class StrongAndWeakPrimes {\n\n    private static int MAX = 10_000_000 + 1000;\n    private static boolean[] primes = new boolean[MAX];\n\n    public static void main(String[] args) {\n        sieve();\n        System.out.println(\"First 36 strong primes:\");        \n        displayStrongPrimes(36);\n        for ( int n : new int[] {1_000_000, 10_000_000}) {\n            System.out.printf(\"Number of strong primes below\u00a0%,d =\u00a0%,d%n\", n, strongPrimesBelow(n));\n        }\n        System.out.println(\"First 37 weak primes:\");        \n        displayWeakPrimes(37);\n        for ( int n : new int[] {1_000_000, 10_000_000}) {\n            System.out.printf(\"Number of weak primes below\u00a0%,d =\u00a0%,d%n\", n, weakPrimesBelow(n));\n        }\n    }\n\n    private static int weakPrimesBelow(int maxPrime) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( currentPrime < maxPrime ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 < priorPrime + nextPrime ) {\n                count++;\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        return count;\n    }\n\n    private static void displayWeakPrimes(int maxCount) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( count < maxCount ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 < priorPrime + nextPrime) {\n                count++;\n                System.out.printf(\"%d \", currentPrime);\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        System.out.println();\n    }\n\n    private static int getNextPrime(int currentPrime) {\n        int nextPrime = currentPrime + 2;\n        while ( ! primes[nextPrime] ) {\n            nextPrime += 2;\n        }\n        return nextPrime;\n    }\n    \n    private static int strongPrimesBelow(int maxPrime) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( currentPrime < maxPrime ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 > priorPrime + nextPrime ) {\n                count++;\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        return count;\n    }\n    \n    private static void displayStrongPrimes(int maxCount) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( count < maxCount ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 > priorPrime + nextPrime) {\n                count++;\n                System.out.printf(\"%d \", currentPrime);\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        System.out.println();\n    }\n\n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 392561, "name": "Left factorials", "source": "Translate Swift to Java: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nprefix func ! <T: BinaryInteger>(n: T) -> T {\n  guard n != 0 else {\n    return 0\n  }\n\n  return stride(from: 0, to: n, by: 1).lazy.map(factorial).reduce(0, +)\n}\n\nfor i in 0...10 {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nfor i in stride(from: BigInt(20), through: 110, by: 10) {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nprint(\"!1000 = \\((!BigInt(1000)).description.count) digit number\")\n\nprint()\n\nfor i in stride(from: BigInt(2000), through: 10_000, by: 1000) {\n  print(\"!\\(i) = \\((!i).description.count) digit number\")\n}\n", "target": "import java.math.BigInteger;\n\npublic class LeftFac{\n\tpublic static BigInteger factorial(BigInteger n){\n\t\tBigInteger ans = BigInteger.ONE;\n\t\tfor(BigInteger x = BigInteger.ONE; x.compareTo(n) <= 0; x = x.add(BigInteger.ONE)){\n\t\t\tans = ans.multiply(x);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static BigInteger leftFact(BigInteger n){\n\t\tBigInteger ans = BigInteger.ZERO;\n\t\tfor(BigInteger k = BigInteger.ZERO; k.compareTo(n.subtract(BigInteger.ONE)) <= 0; k = k.add(BigInteger.ONE)){\n\t\t\tans = ans.add(factorial(k));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 20; i <= 110; i += 10){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 1000; i <= 10000; i += 1000){\n\t\t\tSystem.out.println(\"!\" + i + \" has \" + leftFact(BigInteger.valueOf(i)).toString().length() + \" digits\");\n\t\t}\n\t}\n}\n"}
{"id": 392562, "name": "Left factorials", "source": "Translate Swift to Java: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nprefix func ! <T: BinaryInteger>(n: T) -> T {\n  guard n != 0 else {\n    return 0\n  }\n\n  return stride(from: 0, to: n, by: 1).lazy.map(factorial).reduce(0, +)\n}\n\nfor i in 0...10 {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nfor i in stride(from: BigInt(20), through: 110, by: 10) {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nprint(\"!1000 = \\((!BigInt(1000)).description.count) digit number\")\n\nprint()\n\nfor i in stride(from: BigInt(2000), through: 10_000, by: 1000) {\n  print(\"!\\(i) = \\((!i).description.count) digit number\")\n}\n", "target": "import java.math.BigInteger;\n\npublic class LeftFac{\n\tpublic static BigInteger factorial(BigInteger n){\n\t\tBigInteger ans = BigInteger.ONE;\n\t\tfor(BigInteger x = BigInteger.ONE; x.compareTo(n) <= 0; x = x.add(BigInteger.ONE)){\n\t\t\tans = ans.multiply(x);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static BigInteger leftFact(BigInteger n){\n\t\tBigInteger ans = BigInteger.ZERO;\n\t\tfor(BigInteger k = BigInteger.ZERO; k.compareTo(n.subtract(BigInteger.ONE)) <= 0; k = k.add(BigInteger.ONE)){\n\t\t\tans = ans.add(factorial(k));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 20; i <= 110; i += 10){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 1000; i <= 10000; i += 1000){\n\t\t\tSystem.out.println(\"!\" + i + \" has \" + leftFact(BigInteger.valueOf(i)).toString().length() + \" digits\");\n\t\t}\n\t}\n}\n"}
{"id": 392563, "name": "Strange unique prime triplets", "source": "Translate Swift to Java: import Foundation\n\nfunc primeSieve(limit: Int) -> [Bool] {\n    guard limit > 0 else {\n        return []\n    }\n    var sieve = Array(repeating: true, count: limit)\n    sieve[0] = false\n    if limit > 1 {\n        sieve[1] = false\n    }\n    if limit > 4 {\n        for i in stride(from: 4, to: limit, by: 2) {\n            sieve[i] = false\n        }\n    }\n    var p = 3\n    while true {\n        var q = p * p\n        if q >= limit {\n            break\n        }\n        if sieve[p] {\n            let inc = 2 * p\n            while q < limit {\n                sieve[q] = false\n                q += inc\n            }\n        }\n        p += 2\n    }\n    return sieve\n}\n\nfunc strangeUniquePrimeTriplets(limit: Int, verbose: Bool) {\n    guard limit > 5 else {\n        return;\n    }\n    let sieve = primeSieve(limit: 3 * limit)\n    var primes: [Int] = []\n    for p in stride(from: 3, to: limit, by: 2) {\n        if sieve[p] {\n            primes.append(p)\n        }\n    }\n    let n = primes.count\n    var count = 0\n    if verbose {\n        print(\"Strange unique prime triplets < \\(limit):\")\n    }\n    for i in (0..<n - 2) {\n        for j in (i + 1..<n - 1) {\n            for k in (j + 1..<n) {\n                let sum = primes[i] + primes[j] + primes[k]\n                if sieve[sum] {\n                    count += 1\n                    if verbose {\n                        print(String(format: \"%2d + %2d + %2d = %2d\",\n                                     primes[i], primes[j], primes[k], sum))\n                    }\n                }\n            }\n        }\n    }\n    print(\"\\nCount of strange unique prime triplets < \\(limit) is \\(count).\")\n}\n\nstrangeUniquePrimeTriplets(limit: 30, verbose: true)\nstrangeUniquePrimeTriplets(limit: 1000, verbose: false)\n", "target": "import java.util.*;\n\npublic class StrangeUniquePrimeTriplets {\n    public static void main(String[] args) {\n        strangeUniquePrimeTriplets(30, true);\n        strangeUniquePrimeTriplets(1000, false);\n    }\n\n    private static void strangeUniquePrimeTriplets(int limit, boolean verbose) {\n        boolean[] sieve = primeSieve(limit * 3);\n        List<Integer> primeList = new ArrayList<>();\n        for (int p = 3; p < limit; p += 2) {\n            if (sieve[p])\n                primeList.add(p);\n        }\n        int n = primeList.size();\n        \n        int[] primes = new int[n];\n        for (int i = 0; i < n; ++i)\n            primes[i] = primeList.get(i);\n        int count = 0;\n        if (verbose)\n            System.out.printf(\"Strange unique prime triplets < %d:\\n\", limit);\n        for (int i = 0; i + 2 < n; ++i) {\n            for (int j = i + 1; j + 1 < n; ++j) {\n                int s = primes[i] + primes[j];\n                for (int k = j + 1; k < n; ++k) {\n                    int sum = s + primes[k];\n                    if (sieve[sum]) {\n                        ++count;\n                        if (verbose)\n                            System.out.printf(\"%2d + %2d + %2d = %2d\\n\", primes[i], primes[j], primes[k], sum);\n                    }\n                }\n            }\n        }\n        System.out.printf(\"\\nCount of strange unique prime triplets < %d is %d.\\n\", limit, count);\n    }\n\n    private static boolean[] primeSieve(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        if (limit > 0)\n            sieve[0] = false;\n        if (limit > 1)\n            sieve[1] = false;\n        for (int i = 4; i < limit; i += 2)\n            sieve[i] = false;\n        for (int p = 3; ; p += 2) {\n            int q = p * p;\n            if (q >= limit)\n                break;\n            if (sieve[p]) {\n                int inc = 2 * p;\n                for (; q < limit; q += inc)\n                    sieve[q] = false;\n            }\n        }\n        return sieve;\n    }\n}\n"}
{"id": 392564, "name": "Strange unique prime triplets", "source": "Translate Swift to Java: import Foundation\n\nfunc primeSieve(limit: Int) -> [Bool] {\n    guard limit > 0 else {\n        return []\n    }\n    var sieve = Array(repeating: true, count: limit)\n    sieve[0] = false\n    if limit > 1 {\n        sieve[1] = false\n    }\n    if limit > 4 {\n        for i in stride(from: 4, to: limit, by: 2) {\n            sieve[i] = false\n        }\n    }\n    var p = 3\n    while true {\n        var q = p * p\n        if q >= limit {\n            break\n        }\n        if sieve[p] {\n            let inc = 2 * p\n            while q < limit {\n                sieve[q] = false\n                q += inc\n            }\n        }\n        p += 2\n    }\n    return sieve\n}\n\nfunc strangeUniquePrimeTriplets(limit: Int, verbose: Bool) {\n    guard limit > 5 else {\n        return;\n    }\n    let sieve = primeSieve(limit: 3 * limit)\n    var primes: [Int] = []\n    for p in stride(from: 3, to: limit, by: 2) {\n        if sieve[p] {\n            primes.append(p)\n        }\n    }\n    let n = primes.count\n    var count = 0\n    if verbose {\n        print(\"Strange unique prime triplets < \\(limit):\")\n    }\n    for i in (0..<n - 2) {\n        for j in (i + 1..<n - 1) {\n            for k in (j + 1..<n) {\n                let sum = primes[i] + primes[j] + primes[k]\n                if sieve[sum] {\n                    count += 1\n                    if verbose {\n                        print(String(format: \"%2d + %2d + %2d = %2d\",\n                                     primes[i], primes[j], primes[k], sum))\n                    }\n                }\n            }\n        }\n    }\n    print(\"\\nCount of strange unique prime triplets < \\(limit) is \\(count).\")\n}\n\nstrangeUniquePrimeTriplets(limit: 30, verbose: true)\nstrangeUniquePrimeTriplets(limit: 1000, verbose: false)\n", "target": "import java.util.*;\n\npublic class StrangeUniquePrimeTriplets {\n    public static void main(String[] args) {\n        strangeUniquePrimeTriplets(30, true);\n        strangeUniquePrimeTriplets(1000, false);\n    }\n\n    private static void strangeUniquePrimeTriplets(int limit, boolean verbose) {\n        boolean[] sieve = primeSieve(limit * 3);\n        List<Integer> primeList = new ArrayList<>();\n        for (int p = 3; p < limit; p += 2) {\n            if (sieve[p])\n                primeList.add(p);\n        }\n        int n = primeList.size();\n        \n        int[] primes = new int[n];\n        for (int i = 0; i < n; ++i)\n            primes[i] = primeList.get(i);\n        int count = 0;\n        if (verbose)\n            System.out.printf(\"Strange unique prime triplets < %d:\\n\", limit);\n        for (int i = 0; i + 2 < n; ++i) {\n            for (int j = i + 1; j + 1 < n; ++j) {\n                int s = primes[i] + primes[j];\n                for (int k = j + 1; k < n; ++k) {\n                    int sum = s + primes[k];\n                    if (sieve[sum]) {\n                        ++count;\n                        if (verbose)\n                            System.out.printf(\"%2d + %2d + %2d = %2d\\n\", primes[i], primes[j], primes[k], sum);\n                    }\n                }\n            }\n        }\n        System.out.printf(\"\\nCount of strange unique prime triplets < %d is %d.\\n\", limit, count);\n    }\n\n    private static boolean[] primeSieve(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        if (limit > 0)\n            sieve[0] = false;\n        if (limit > 1)\n            sieve[1] = false;\n        for (int i = 4; i < limit; i += 2)\n            sieve[i] = false;\n        for (int p = 3; ; p += 2) {\n            int q = p * p;\n            if (q >= limit)\n                break;\n            if (sieve[p]) {\n                int inc = 2 * p;\n                for (; q < limit; q += inc)\n                    sieve[q] = false;\n            }\n        }\n        return sieve;\n    }\n}\n"}
{"id": 392565, "name": "Smarandache prime-digital sequence", "source": "Translate Swift to Java: func isPrime(number: Int) -> Bool {\n    if number < 2 {\n        return false\n    }\n    if number % 2 == 0 {\n        return number == 2\n    }\n    if number % 3 == 0 {\n        return number == 3\n    }\n    if number % 5 == 0 {\n        return number == 5\n    }\n    var p = 7\n    let wheel = [4,2,4,2,4,6,2,6]\n    while true {\n        for w in wheel {\n            if p * p > number {\n                return true\n            }\n            if number % p == 0 {\n                return false\n            }\n            p += w\n        }\n    }\n}\n\nfunc nextPrimeDigitNumber(number: Int) -> Int {\n    if number == 0 {\n        return 2\n    }\n    switch number % 10 {\n    case 2:\n        return number + 1\n    case 3, 5:\n        return number + 2\n    default:\n        return 2 + nextPrimeDigitNumber(number: number/10) * 10\n    }\n}\n\nlet limit = 1000000000\nvar n = 0\nvar max = 0\nvar count = 0\nprint(\"First 25 SPDS primes:\")\nwhile n < limit {\n    n = nextPrimeDigitNumber(number: n)\n    if !isPrime(number: n) {\n        continue\n    }\n    if count < 25 {\n        print(n, terminator: \" \")\n    } else if count == 25 {\n        print()\n    }\n    count += 1\n    if (count == 100) {\n        print(\"Hundredth SPDS prime: \\(n)\")\n    } else if (count == 1000) {\n        print(\"Thousandth SPDS prime: \\(n)\")\n    } else if (count == 10000) {\n        print(\"Ten thousandth SPDS prime: \\(n)\")\n    }\n    max = n\n}\nprint(\"Largest SPDS prime less than \\(limit): \\(max)\")\n", "target": "public class SmarandachePrimeDigitalSequence {\n\n    public static void main(String[] args) {\n        long s = getNextSmarandache(7);\n        System.out.printf(\"First 25 Smarandache prime-digital sequence numbers:%n2 3 5 7 \");\n        for ( int count = 1 ; count <= 21 ; s = getNextSmarandache(s) ) {\n            if ( isPrime(s) ) {\n                System.out.printf(\"%d \", s);\n                count++;\n            }\n        }\n        System.out.printf(\"%n%n\");\n        for (int i = 2 ; i <=5 ; i++ ) {\n            long n = (long) Math.pow(10, i);\n            System.out.printf(\"%,dth Smarandache prime-digital sequence number = %d%n\", n, getSmarandachePrime(n));\n        }\n    }\n    \n    private static final long getSmarandachePrime(long n) {\n        if ( n < 10 ) {\n            switch ((int) n) {\n            case 1:  return 2;\n            case 2:  return 3;\n            case 3:  return 5;\n            case 4:  return 7;\n            }\n        }\n        long s = getNextSmarandache(7);\n        long result = 0;\n        for ( int count = 1 ; count <= n-4 ; s = getNextSmarandache(s) ) {\n            if ( isPrime(s) ) {\n                count++;\n                result = s;\n            }\n        }\n        return result;\n    }\n    \n    private static final boolean isPrime(long test) {\n        if ( test % 2 == 0 ) return false;\n        for ( long i = 3 ; i <= Math.sqrt(test) ; i += 2 ) {\n            if ( test % i == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static long getNextSmarandache(long n) {\n        \n        if ( n % 10 == 3 ) {\n            return n+4;\n        }\n        long retVal = n-4;\n        \n        \n        int k = 0;\n        while ( n % 10 == 7 ) {\n            k++;\n            n /= 10;\n        }\n        \n        \n        long digit = n % 10;\n\n        \n        long coeff = (digit == 2 ? 1 : 2);\n        \n        \n        retVal += coeff * Math.pow(10, k);\n        \n        \n        while ( k > 1 ) {\n            retVal -= 5 * Math.pow(10, k-1);\n            k--;\n        }\n        \n        \n        return retVal;\n    }\n\n}\n"}
{"id": 392566, "name": "Pythagorean quadruples", "source": "Translate Swift to Java: func missingD(upTo n: Int) -> [Int] {\n  var a2 = 0, s = 3, s1 = 0, s2 = 0\n  var res = [Int](repeating: 0, count: n + 1)\n  var ab = [Int](repeating: 0, count: n * n * 2 + 1)\n\n  for a in 1...n {\n    a2 = a * a\n\n    for b in a...n {\n      ab[a2 + b * b] = 1\n    }\n  }\n\n  for c in 1..<n {\n    s1 = s\n    s += 2\n    s2 = s\n\n    for d in c+1...n {\n      if ab[s1] != 0 {\n        res[d] = 1\n      }\n\n      s1 += s2\n      s2 += 2\n    }\n  }\n\n  return (1...n).filter({ res[$0] == 0 })\n}\n\nprint(missingD(upTo: 2200))\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PythagoreanQuadruples {\n\n    public static void main(String[] args) {\n        long d = 2200;\n        System.out.printf(\"Values of d < %d where a, b, and c are non-zero and a^2 + b^2 + c^2 = d^2 has no solutions:%n%s%n\", d, getPythagoreanQuadruples(d));\n    }\n\n    \n    private static List<Long> getPythagoreanQuadruples(long max) {\n        List<Long> list = new ArrayList<>();\n        long n = -1;\n        long m = -1;\n        while ( true ) {\n            long nTest = (long) Math.pow(2, n+1);\n            long mTest = (long) (5L * Math.pow(2, m+1));\n            long test = 0;\n            if ( nTest > mTest ) {\n                test = mTest;\n                m++;\n            }\n            else {\n                test = nTest;\n                n++;\n            }\n            if ( test < max ) {\n                list.add(test);\n            }\n            else {\n                break;\n            }\n        }\n        return list;\n    }\n\n}\n"}
{"id": 392567, "name": "Safe primes and unsafe primes", "source": "Translate Swift to Java: import Foundation\n\nclass PrimeSieve {\n    var composite: [Bool]\n    \n    init(size: Int) {\n        composite = Array(repeating: false, count: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite[p/2 - 1] {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite[q/2 - 1] = true\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite[number/2 - 1]\n    }\n}\n\nfunc commatize(_ number: Int) -> String {\n    let n = NSNumber(value: number)\n    return NumberFormatter.localizedString(from: n, number: .decimal)\n}\n\nlet limit1 = 1000000\nlet limit2 = 10000000\n\nclass PrimeInfo {\n    let maxPrint: Int\n    var count1: Int\n    var count2: Int\n    var primes: [Int]\n    \n    init(maxPrint: Int) {\n        self.maxPrint = maxPrint\n        count1 = 0\n        count2 = 0\n        primes = []\n    }\n    \n    func addPrime(prime: Int) {\n        count2 += 1\n        if prime < limit1 {\n            count1 += 1\n        }\n        if count2 <= maxPrint {\n            primes.append(prime)\n        }\n    }\n    \n    func printInfo(name: String) {\n        print(\"First \\(maxPrint) \\(name) primes: \\(primes)\")\n        print(\"Number of \\(name) primes below \\(commatize(limit1)): \\(commatize(count1))\")\n        print(\"Number of \\(name) primes below \\(commatize(limit2)): \\(commatize(count2))\")\n    }\n}\n\nvar safePrimes = PrimeInfo(maxPrint: 35)\nvar unsafePrimes = PrimeInfo(maxPrint: 40)\n\nlet sieve = PrimeSieve(size: limit2)\n\nfor prime in 2..<limit2 {\n    if sieve.isPrime(number: prime) {\n        if sieve.isPrime(number: (prime - 1)/2) {\n            safePrimes.addPrime(prime: prime)\n        } else {\n            unsafePrimes.addPrime(prime: prime)\n        }\n    }\n}\n\nsafePrimes.printInfo(name: \"safe\")\nunsafePrimes.printInfo(name: \"unsafe\")\n", "target": "public class SafePrimes {\n    public static void main(String... args) {\n        \n        int SIEVE_SIZE = 10_000_000;\n        boolean[] isComposite = new boolean[SIEVE_SIZE];\n        \n        isComposite[0] = true;\n        isComposite[1] = true;\n        for (int n = 2; n < SIEVE_SIZE; n++) {\n            if (isComposite[n]) {\n                continue;\n            }\n            for (int i = n * 2; i < SIEVE_SIZE; i += n) {\n                isComposite[i] = true;\n            }\n        }\n        \n        int oldSafePrimeCount = 0;\n        int oldUnsafePrimeCount = 0;\n        int safePrimeCount = 0;\n        int unsafePrimeCount = 0;\n        StringBuilder safePrimes = new StringBuilder();\n        StringBuilder unsafePrimes = new StringBuilder();\n        int safePrimesStrCount = 0;\n        int unsafePrimesStrCount = 0;\n        for (int n = 2; n < SIEVE_SIZE; n++) {\n            if (n == 1_000_000) {\n                oldSafePrimeCount = safePrimeCount;\n                oldUnsafePrimeCount = unsafePrimeCount;\n            }\n            if (isComposite[n]) {\n                continue;\n            }\n            boolean isUnsafe = isComposite[(n - 1) >>> 1];\n            if (isUnsafe) {\n                if (unsafePrimeCount < 40) {\n                    if (unsafePrimeCount > 0) {\n                        unsafePrimes.append(\", \");\n                    }\n                    unsafePrimes.append(n);\n                    unsafePrimesStrCount++;\n                }\n                unsafePrimeCount++;\n            }\n            else {\n                if (safePrimeCount < 35) {\n                    if (safePrimeCount > 0) {\n                        safePrimes.append(\", \");\n                    }\n                    safePrimes.append(n);\n                    safePrimesStrCount++;\n                }\n                safePrimeCount++;\n            }\n        }\n        \n        System.out.println(\"First \" + safePrimesStrCount + \" safe primes: \" + safePrimes.toString());\n        System.out.println(\"Number of safe primes below 1,000,000: \" + oldSafePrimeCount);\n        System.out.println(\"Number of safe primes below 10,000,000: \" + safePrimeCount);\n        System.out.println(\"First \" + unsafePrimesStrCount + \" unsafe primes: \" + unsafePrimes.toString());\n        System.out.println(\"Number of unsafe primes below 1,000,000: \" + oldUnsafePrimeCount);\n        System.out.println(\"Number of unsafe primes below 10,000,000: \" + unsafePrimeCount);\n        \n        return;\n    }\n}\n"}
{"id": 392568, "name": "Hash join", "source": "Translate Swift to Java: func hashJoin<A, B, K: Hashable>(_ first: [(K, A)], _ second: [(K, B)]) -> [(A, K, B)] {\n  var map = [K: [B]]()\n\n  for (key, val) in second {\n    map[key, default: []].append(val)\n  }\n\n  var res = [(A, K, B)]()\n\n  for (key, val) in first {\n    guard let vals = map[key] else {\n      continue\n    }\n\n    res += vals.map({ (val, key, $0) })\n  }\n\n  return res\n}\n\nlet t1 = [\n  (\"Jonah\", 27), \n  (\"Alan\", 18), \n  (\"Glory\", 28), \n  (\"Popeye\", 18), \n  (\"Alan\", 28)\n]\n\nlet t2 = [\n  (\"Jonah\", \"Whales\"), \n  (\"Jonah\", \"Spiders\"),\n  (\"Alan\", \"Ghosts\"),\n  (\"Alan\", \"Zombies\"),\n  (\"Glory\", \"Buffy\")\n]\n\nprint(\"Age | Character Name | Nemesis\")\nprint(\"----|----------------|--------\")\n\nfor (age, name, nemesis) in hashJoin(t1, t2) {\n  print(\"\\(age) | \\(name) | \\(nemesis)\")\n}\n", "target": "import java.util.*;\n\npublic class HashJoin {\n\n    public static void main(String[] args) {\n        String[][] table1 = {{\"27\", \"Jonah\"}, {\"18\", \"Alan\"}, {\"28\", \"Glory\"},\n        {\"18\", \"Popeye\"}, {\"28\", \"Alan\"}};\n\n        String[][] table2 = {{\"Jonah\", \"Whales\"}, {\"Jonah\", \"Spiders\"},\n        {\"Alan\", \"Ghosts\"}, {\"Alan\", \"Zombies\"}, {\"Glory\", \"Buffy\"},\n        {\"Bob\", \"foo\"}};\n\n        hashJoin(table1, 1, table2, 0).stream()\n                .forEach(r -> System.out.println(Arrays.deepToString(r)));\n    }\n\n    static List<String[][]> hashJoin(String[][] records1, int idx1,\n            String[][] records2, int idx2) {\n\n        List<String[][]> result = new ArrayList<>();\n        Map<String, List<String[]>> map = new HashMap<>();\n\n        for (String[] record : records1) {\n            List<String[]> v = map.getOrDefault(record[idx1], new ArrayList<>());\n            v.add(record);\n            map.put(record[idx1], v);\n        }\n\n        for (String[] record : records2) {\n            List<String[]> lst = map.get(record[idx2]);\n            if (lst != null) {\n                lst.stream().forEach(r -> {\n                    result.add(new String[][]{r, record});\n                });\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"id": 392569, "name": "Terminal control_Preserve screen", "source": "Translate Swift to Java: public let CSI = ESC+\"[\"   \nfunc write(_ text: String...) {\n  for txt in text { write(STDOUT_FILENO, txt, txt.utf8.count) }\n}\nwrite(CSI,\"?1049h\") \nprint(\"Alternate screen buffer\\n\")\nfor n in (1...5).reversed() {\n    print(\"Going back in \\(n)...\")\n    sleep(1)\n}\nwrite(CSI,\"?1049l\") \n", "target": "public class PreserveScreen\n{\n    public static void main(String[] args) throws InterruptedException {\n        System.out.print(\"\\033[?1049h\\033[H\");\n        System.out.println(\"Alternate screen buffer\\n\");\n        for (int i = 5; i > 0; i--) {\n            String s = (i > 1) ? \"s\" : \"\";\n            System.out.printf(\"\\rgoing back in %d second%s...\", i, s);\n            Thread.sleep(1000);\n        }\n        System.out.print(\"\\033[?1049l\");\n    }\n}\n"}
{"id": 392570, "name": "24 game_Solve", "source": "Translate Swift to Java: import Darwin\nimport Foundation\n\nvar solution = \"\"\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> [Int] {\n  var result = [Int]()\n  for i in 0 ..< 4 {\n    result.append(Int(arc4random_uniform(9)+1))\n  }\n  return result\n}\n\n\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits\u00a0: \")\n\nfor digit in digits {\n  print(\"\\(digit) \")\n}\nprintln()\n\n\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)!\n\nvar enteredDigits = [Double]()\n\nvar enteredOperations = [Character]()\n\nlet inputString = input as String\n\n\nfor character in inputString {\n  switch character {\n  case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n    let digit = String(character)\n    enteredDigits.append(Double(digit.toInt()!))\n  case \"+\", \"-\", \"*\", \"/\":\n    enteredOperations.append(character)\n  case \"\\n\":\n    println()\n  default:\n    println(\"Invalid expression\")\n  }\n}\n\n\nvar value = 0.0\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n  value = enteredDigits[0]\n  for (i, operation) in enumerate(enteredOperations) {\n    switch operation {\n    case \"+\":\n      value = value + enteredDigits[i+1]\n    case \"-\":\n      value = value - enteredDigits[i+1]\n    case \"*\":\n      value = value * enteredDigits[i+1]\n    case \"/\":\n      value = value / enteredDigits[i+1]\n    default:\n      println(\"This message should never happen!\")\n    }\n  }\n}\n\nfunc evaluate(dPerm: [Double], oPerm: [String]) -> Bool {\n  var value = 0.0\n  \n  if dPerm.count == 4 && oPerm.count == 3 {\n    value = dPerm[0]\n    for (i, operation) in enumerate(oPerm) {\n      switch operation {\n      case \"+\":\n        value = value + dPerm[i+1]\n      case \"-\":\n        value = value - dPerm[i+1]\n      case \"*\":\n        value = value * dPerm[i+1]\n      case \"/\":\n        value = value / dPerm[i+1]\n      default:\n        println(\"This message should never happen!\")\n      }\n    }\n  }\n  return (abs(24 - value) < 0.001)\n}\n\nfunc isSolvable(inout digits: [Double]) -> Bool {\n  \n  var result = false\n  var dPerms = [[Double]]()\n  permute(&digits, &dPerms, 0)\n  \n  let total = 4 * 4 * 4\n  var oPerms = [[String]]()\n  permuteOperators(&oPerms, 4, total)\n  \n  \n  for dig in dPerms {\n    for opr in oPerms {\n      var expression = \"\"\n      \n      if evaluate(dig, opr) {\n        for digit in dig {\n          expression += \"\\(digit)\"\n        }\n        \n        for oper in opr {\n          expression += oper\n        }\n        \n        solution = beautify(expression)\n        result = true\n      }\n    }\n  }\n  return result\n}\n\nfunc permute(inout lst: [Double], inout res: [[Double]], k: Int) -> Void {\n  for i in k ..< lst.count {\n    swap(&lst[i], &lst[k])\n    permute(&lst, &res, k + 1)\n    swap(&lst[k], &lst[i])\n  }\n  if k == lst.count {\n    res.append(lst)\n  }\n}\n\n\nfunc permuteOperators(inout res: [[String]], n: Int, total: Int) -> Void {\n  let posOperations = [\"+\", \"-\", \"*\", \"/\"]\n  let npow = n * n\n  for i in 0 ..< total {\n    res.append([posOperations[(i / npow)], posOperations[((i % npow) / n)], posOperations[(i % n)]])\n  }\n}\n\nfunc beautify(infix: String) -> String {\n  let newString = infix as NSString\n  \n  var solution = \"\"\n  \n  solution += newString.substringWithRange(NSMakeRange(0, 1))\n  solution += newString.substringWithRange(NSMakeRange(12, 1))\n  solution += newString.substringWithRange(NSMakeRange(3, 1))\n  solution += newString.substringWithRange(NSMakeRange(13, 1))\n  solution += newString.substringWithRange(NSMakeRange(6, 1))\n  solution += newString.substringWithRange(NSMakeRange(14, 1))\n  solution += newString.substringWithRange(NSMakeRange(9, 1))\n  \n  return solution\n}\n\nif value != 24 {\n  println(\"The value of the provided expression is \\(value) instead of 24!\")\n  if isSolvable(&enteredDigits) {\n    println(\"A possible solution could have been \" + solution)\n  } else {\n    println(\"Anyway, there was no known solution to this one.\")\n  }\n} else {\n  println(\"Congratulations, you found a solution!\")\n}\n", "target": "import java.util.*;\n\npublic class Game24Player {\n    final String[] patterns = {\"nnonnoo\", \"nnonono\", \"nnnoono\", \"nnnonoo\",\n        \"nnnnooo\"};\n    final String ops = \"+-*/^\";\n\n    String solution;\n    List<Integer> digits;\n\n    public static void main(String[] args) {\n        new Game24Player().play();\n    }\n\n    void play() {\n        digits = getSolvableDigits();\n\n        Scanner in = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Make 24 using these digits: \");\n            System.out.println(digits);\n            System.out.println(\"(Enter 'q' to quit, 's' for a solution)\");\n            System.out.print(\"> \");\n\n            String line = in.nextLine();\n            if (line.equalsIgnoreCase(\"q\")) {\n                System.out.println(\"\\nThanks for playing\");\n                return;\n            }\n\n            if (line.equalsIgnoreCase(\"s\")) {\n                System.out.println(solution);\n                digits = getSolvableDigits();\n                continue;\n            }\n\n            char[] entry = line.replaceAll(\"[^*+-/)(\\\\d]\", \"\").toCharArray();\n\n            try {\n                validate(entry);\n\n                if (evaluate(infixToPostfix(entry))) {\n                    System.out.println(\"\\nCorrect! Want to try another? \");\n                    digits = getSolvableDigits();\n                } else {\n                    System.out.println(\"\\nNot correct.\");\n                }\n\n            } catch (Exception e) {\n                System.out.printf(\"%n%s Try again.%n\", e.getMessage());\n            }\n        }\n    }\n\n    void validate(char[] input) throws Exception {\n        int total1 = 0, parens = 0, opsCount = 0;\n\n        for (char c : input) {\n            if (Character.isDigit(c))\n                total1 += 1 << (c - '0') * 4;\n            else if (c == '(')\n                parens++;\n            else if (c == ')')\n                parens--;\n            else if (ops.indexOf(c) != -1)\n                opsCount++;\n            if (parens < 0)\n                throw new Exception(\"Parentheses mismatch.\");\n        }\n\n        if (parens != 0)\n            throw new Exception(\"Parentheses mismatch.\");\n\n        if (opsCount != 3)\n            throw new Exception(\"Wrong number of operators.\");\n\n        int total2 = 0;\n        for (int d : digits)\n            total2 += 1 << d * 4;\n\n        if (total1 != total2)\n            throw new Exception(\"Not the same digits.\");\n    }\n\n    boolean evaluate(char[] line) throws Exception {\n        Stack<Float> s = new Stack<>();\n        try {\n            for (char c : line) {\n                if ('0' <= c && c <= '9')\n                    s.push((float) c - '0');\n                else\n                    s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return (Math.abs(24 - s.peek()) < 0.001F);\n    }\n\n    float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    List<Integer> randomDigits() {\n        Random r = new Random();\n        List<Integer> result = new ArrayList<>(4);\n        for (int i = 0; i < 4; i++)\n            result.add(r.nextInt(9) + 1);\n        return result;\n    }\n\n    List<Integer> getSolvableDigits() {\n        List<Integer> result;\n        do {\n            result = randomDigits();\n        } while (!isSolvable(result));\n        return result;\n    }\n\n    boolean isSolvable(List<Integer> digits) {\n        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);\n        permute(digits, dPerms, 0);\n\n        int total = 4 * 4 * 4;\n        List<List<Integer>> oPerms = new ArrayList<>(total);\n        permuteOperators(oPerms, 4, total);\n\n        StringBuilder sb = new StringBuilder(4 + 3);\n\n        for (String pattern : patterns) {\n            char[] patternChars = pattern.toCharArray();\n\n            for (List<Integer> dig : dPerms) {\n                for (List<Integer> opr : oPerms) {\n\n                    int i = 0, j = 0;\n                    for (char c : patternChars) {\n                        if (c == 'n')\n                            sb.append(dig.get(i++));\n                        else\n                            sb.append(ops.charAt(opr.get(j++)));\n                    }\n\n                    String candidate = sb.toString();\n                    try {\n                        if (evaluate(candidate.toCharArray())) {\n                            solution = postfixToInfix(candidate);\n                            return true;\n                        }\n                    } catch (Exception ignored) {\n                    }\n                    sb.setLength(0);\n                }\n            }\n        }\n        return false;\n    }\n\n    String postfixToInfix(String postfix) {\n        class Expression {\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (char c : postfix.toCharArray()) {\n            int idx = ops.indexOf(c);\n            if (idx != -1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec)\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec <= opPrec)\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, \"\" + c));\n            } else {\n                expr.push(new Expression(\"\" + c));\n            }\n        }\n        return expr.peek().ex;\n    }\n\n    char[] infixToPostfix(char[] infix) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n        try {\n            for (char c : infix) {\n                int idx = ops.indexOf(c);\n                if (idx != -1) {\n                    if (s.isEmpty())\n                        s.push(idx);\n                    else {\n                        while (!s.isEmpty()) {\n                            int prec2 = s.peek() / 2;\n                            int prec1 = idx / 2;\n                            if (prec2 >= prec1)\n                                sb.append(ops.charAt(s.pop()));\n                            else\n                                break;\n                        }\n                        s.push(idx);\n                    }\n                } else if (c == '(') {\n                    s.push(-2);\n                } else if (c == ')') {\n                    while (s.peek() != -2)\n                        sb.append(ops.charAt(s.pop()));\n                    s.pop();\n                } else {\n                    sb.append(c);\n                }\n            }\n            while (!s.isEmpty())\n                sb.append(ops.charAt(s.pop()));\n\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return sb.toString().toCharArray();\n    }\n\n    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {\n        for (int i = k; i < lst.size(); i++) {\n            Collections.swap(lst, i, k);\n            permute(lst, res, k + 1);\n            Collections.swap(lst, k, i);\n        }\n        if (k == lst.size())\n            res.add(new ArrayList<>(lst));\n    }\n\n    void permuteOperators(List<List<Integer>> res, int n, int total) {\n        for (int i = 0, npow = n * n; i < total; i++)\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\n    }\n}\n"}
{"id": 392571, "name": "24 game_Solve", "source": "Translate Swift to Java: import Darwin\nimport Foundation\n\nvar solution = \"\"\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> [Int] {\n  var result = [Int]()\n  for i in 0 ..< 4 {\n    result.append(Int(arc4random_uniform(9)+1))\n  }\n  return result\n}\n\n\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits\u00a0: \")\n\nfor digit in digits {\n  print(\"\\(digit) \")\n}\nprintln()\n\n\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)!\n\nvar enteredDigits = [Double]()\n\nvar enteredOperations = [Character]()\n\nlet inputString = input as String\n\n\nfor character in inputString {\n  switch character {\n  case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n    let digit = String(character)\n    enteredDigits.append(Double(digit.toInt()!))\n  case \"+\", \"-\", \"*\", \"/\":\n    enteredOperations.append(character)\n  case \"\\n\":\n    println()\n  default:\n    println(\"Invalid expression\")\n  }\n}\n\n\nvar value = 0.0\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n  value = enteredDigits[0]\n  for (i, operation) in enumerate(enteredOperations) {\n    switch operation {\n    case \"+\":\n      value = value + enteredDigits[i+1]\n    case \"-\":\n      value = value - enteredDigits[i+1]\n    case \"*\":\n      value = value * enteredDigits[i+1]\n    case \"/\":\n      value = value / enteredDigits[i+1]\n    default:\n      println(\"This message should never happen!\")\n    }\n  }\n}\n\nfunc evaluate(dPerm: [Double], oPerm: [String]) -> Bool {\n  var value = 0.0\n  \n  if dPerm.count == 4 && oPerm.count == 3 {\n    value = dPerm[0]\n    for (i, operation) in enumerate(oPerm) {\n      switch operation {\n      case \"+\":\n        value = value + dPerm[i+1]\n      case \"-\":\n        value = value - dPerm[i+1]\n      case \"*\":\n        value = value * dPerm[i+1]\n      case \"/\":\n        value = value / dPerm[i+1]\n      default:\n        println(\"This message should never happen!\")\n      }\n    }\n  }\n  return (abs(24 - value) < 0.001)\n}\n\nfunc isSolvable(inout digits: [Double]) -> Bool {\n  \n  var result = false\n  var dPerms = [[Double]]()\n  permute(&digits, &dPerms, 0)\n  \n  let total = 4 * 4 * 4\n  var oPerms = [[String]]()\n  permuteOperators(&oPerms, 4, total)\n  \n  \n  for dig in dPerms {\n    for opr in oPerms {\n      var expression = \"\"\n      \n      if evaluate(dig, opr) {\n        for digit in dig {\n          expression += \"\\(digit)\"\n        }\n        \n        for oper in opr {\n          expression += oper\n        }\n        \n        solution = beautify(expression)\n        result = true\n      }\n    }\n  }\n  return result\n}\n\nfunc permute(inout lst: [Double], inout res: [[Double]], k: Int) -> Void {\n  for i in k ..< lst.count {\n    swap(&lst[i], &lst[k])\n    permute(&lst, &res, k + 1)\n    swap(&lst[k], &lst[i])\n  }\n  if k == lst.count {\n    res.append(lst)\n  }\n}\n\n\nfunc permuteOperators(inout res: [[String]], n: Int, total: Int) -> Void {\n  let posOperations = [\"+\", \"-\", \"*\", \"/\"]\n  let npow = n * n\n  for i in 0 ..< total {\n    res.append([posOperations[(i / npow)], posOperations[((i % npow) / n)], posOperations[(i % n)]])\n  }\n}\n\nfunc beautify(infix: String) -> String {\n  let newString = infix as NSString\n  \n  var solution = \"\"\n  \n  solution += newString.substringWithRange(NSMakeRange(0, 1))\n  solution += newString.substringWithRange(NSMakeRange(12, 1))\n  solution += newString.substringWithRange(NSMakeRange(3, 1))\n  solution += newString.substringWithRange(NSMakeRange(13, 1))\n  solution += newString.substringWithRange(NSMakeRange(6, 1))\n  solution += newString.substringWithRange(NSMakeRange(14, 1))\n  solution += newString.substringWithRange(NSMakeRange(9, 1))\n  \n  return solution\n}\n\nif value != 24 {\n  println(\"The value of the provided expression is \\(value) instead of 24!\")\n  if isSolvable(&enteredDigits) {\n    println(\"A possible solution could have been \" + solution)\n  } else {\n    println(\"Anyway, there was no known solution to this one.\")\n  }\n} else {\n  println(\"Congratulations, you found a solution!\")\n}\n", "target": "import java.util.*;\n\npublic class Game24Player {\n    final String[] patterns = {\"nnonnoo\", \"nnonono\", \"nnnoono\", \"nnnonoo\",\n        \"nnnnooo\"};\n    final String ops = \"+-*/^\";\n\n    String solution;\n    List<Integer> digits;\n\n    public static void main(String[] args) {\n        new Game24Player().play();\n    }\n\n    void play() {\n        digits = getSolvableDigits();\n\n        Scanner in = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Make 24 using these digits: \");\n            System.out.println(digits);\n            System.out.println(\"(Enter 'q' to quit, 's' for a solution)\");\n            System.out.print(\"> \");\n\n            String line = in.nextLine();\n            if (line.equalsIgnoreCase(\"q\")) {\n                System.out.println(\"\\nThanks for playing\");\n                return;\n            }\n\n            if (line.equalsIgnoreCase(\"s\")) {\n                System.out.println(solution);\n                digits = getSolvableDigits();\n                continue;\n            }\n\n            char[] entry = line.replaceAll(\"[^*+-/)(\\\\d]\", \"\").toCharArray();\n\n            try {\n                validate(entry);\n\n                if (evaluate(infixToPostfix(entry))) {\n                    System.out.println(\"\\nCorrect! Want to try another? \");\n                    digits = getSolvableDigits();\n                } else {\n                    System.out.println(\"\\nNot correct.\");\n                }\n\n            } catch (Exception e) {\n                System.out.printf(\"%n%s Try again.%n\", e.getMessage());\n            }\n        }\n    }\n\n    void validate(char[] input) throws Exception {\n        int total1 = 0, parens = 0, opsCount = 0;\n\n        for (char c : input) {\n            if (Character.isDigit(c))\n                total1 += 1 << (c - '0') * 4;\n            else if (c == '(')\n                parens++;\n            else if (c == ')')\n                parens--;\n            else if (ops.indexOf(c) != -1)\n                opsCount++;\n            if (parens < 0)\n                throw new Exception(\"Parentheses mismatch.\");\n        }\n\n        if (parens != 0)\n            throw new Exception(\"Parentheses mismatch.\");\n\n        if (opsCount != 3)\n            throw new Exception(\"Wrong number of operators.\");\n\n        int total2 = 0;\n        for (int d : digits)\n            total2 += 1 << d * 4;\n\n        if (total1 != total2)\n            throw new Exception(\"Not the same digits.\");\n    }\n\n    boolean evaluate(char[] line) throws Exception {\n        Stack<Float> s = new Stack<>();\n        try {\n            for (char c : line) {\n                if ('0' <= c && c <= '9')\n                    s.push((float) c - '0');\n                else\n                    s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return (Math.abs(24 - s.peek()) < 0.001F);\n    }\n\n    float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    List<Integer> randomDigits() {\n        Random r = new Random();\n        List<Integer> result = new ArrayList<>(4);\n        for (int i = 0; i < 4; i++)\n            result.add(r.nextInt(9) + 1);\n        return result;\n    }\n\n    List<Integer> getSolvableDigits() {\n        List<Integer> result;\n        do {\n            result = randomDigits();\n        } while (!isSolvable(result));\n        return result;\n    }\n\n    boolean isSolvable(List<Integer> digits) {\n        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);\n        permute(digits, dPerms, 0);\n\n        int total = 4 * 4 * 4;\n        List<List<Integer>> oPerms = new ArrayList<>(total);\n        permuteOperators(oPerms, 4, total);\n\n        StringBuilder sb = new StringBuilder(4 + 3);\n\n        for (String pattern : patterns) {\n            char[] patternChars = pattern.toCharArray();\n\n            for (List<Integer> dig : dPerms) {\n                for (List<Integer> opr : oPerms) {\n\n                    int i = 0, j = 0;\n                    for (char c : patternChars) {\n                        if (c == 'n')\n                            sb.append(dig.get(i++));\n                        else\n                            sb.append(ops.charAt(opr.get(j++)));\n                    }\n\n                    String candidate = sb.toString();\n                    try {\n                        if (evaluate(candidate.toCharArray())) {\n                            solution = postfixToInfix(candidate);\n                            return true;\n                        }\n                    } catch (Exception ignored) {\n                    }\n                    sb.setLength(0);\n                }\n            }\n        }\n        return false;\n    }\n\n    String postfixToInfix(String postfix) {\n        class Expression {\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (char c : postfix.toCharArray()) {\n            int idx = ops.indexOf(c);\n            if (idx != -1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec)\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec <= opPrec)\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, \"\" + c));\n            } else {\n                expr.push(new Expression(\"\" + c));\n            }\n        }\n        return expr.peek().ex;\n    }\n\n    char[] infixToPostfix(char[] infix) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n        try {\n            for (char c : infix) {\n                int idx = ops.indexOf(c);\n                if (idx != -1) {\n                    if (s.isEmpty())\n                        s.push(idx);\n                    else {\n                        while (!s.isEmpty()) {\n                            int prec2 = s.peek() / 2;\n                            int prec1 = idx / 2;\n                            if (prec2 >= prec1)\n                                sb.append(ops.charAt(s.pop()));\n                            else\n                                break;\n                        }\n                        s.push(idx);\n                    }\n                } else if (c == '(') {\n                    s.push(-2);\n                } else if (c == ')') {\n                    while (s.peek() != -2)\n                        sb.append(ops.charAt(s.pop()));\n                    s.pop();\n                } else {\n                    sb.append(c);\n                }\n            }\n            while (!s.isEmpty())\n                sb.append(ops.charAt(s.pop()));\n\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return sb.toString().toCharArray();\n    }\n\n    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {\n        for (int i = k; i < lst.size(); i++) {\n            Collections.swap(lst, i, k);\n            permute(lst, res, k + 1);\n            Collections.swap(lst, k, i);\n        }\n        if (k == lst.size())\n            res.add(new ArrayList<>(lst));\n    }\n\n    void permuteOperators(List<List<Integer>> res, int n, int total) {\n        for (int i = 0, npow = n * n; i < total; i++)\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\n    }\n}\n"}
{"id": 392572, "name": "Super-d numbers", "source": "Translate Swift to Java: import BigInt\nimport Foundation\n\nlet rd = [\"22\", \"333\", \"4444\", \"55555\", \"666666\", \"7777777\", \"88888888\", \"999999999\"]\n\nfor d in 2...9 {\n  print(\"First 10 super-\\(d) numbers:\")\n\n  var count = 0\n  var n = BigInt(3)\n  var k = BigInt(0)\n\n  while true {\n    k = n.power(d)\n    k *= BigInt(d)\n\n    if let _ = String(k).range(of: rd[d - 2]) {\n      count += 1\n\n      print(n, terminator: \" \")\n      fflush(stdout)\n\n      guard count < 10 else {\n        break\n      }\n    }\n\n    n += 1\n  }\n\n  print()\n  print()\n}\n", "target": "import java.math.BigInteger;\n\npublic class SuperDNumbers {\n\n    public static void main(String[] args) {\n        for ( int i = 2 ; i <= 9 ; i++ ) {\n            superD(i, 10);\n        }\n    }\n    \n    private static final void superD(int d, int max) {\n        long start = System.currentTimeMillis();\n        String test = \"\";\n        for ( int i = 0 ; i < d ; i++ ) {\n            test += (\"\"+d);\n        }\n        \n        int n = 0;\n        int i = 0;\n        System.out.printf(\"First %d super-%d numbers: %n\", max, d);\n        while ( n < max ) {\n            i++;\n            BigInteger val = BigInteger.valueOf(d).multiply(BigInteger.valueOf(i).pow(d));\n            if ( val.toString().contains(test) ) {\n                n++;\n                System.out.printf(\"%d \", i);\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"%nRun time %d ms%n%n\", end-start);\n        \n    }\n\n}\n"}
{"id": 392573, "name": "Super-d numbers", "source": "Translate Swift to Java: import BigInt\nimport Foundation\n\nlet rd = [\"22\", \"333\", \"4444\", \"55555\", \"666666\", \"7777777\", \"88888888\", \"999999999\"]\n\nfor d in 2...9 {\n  print(\"First 10 super-\\(d) numbers:\")\n\n  var count = 0\n  var n = BigInt(3)\n  var k = BigInt(0)\n\n  while true {\n    k = n.power(d)\n    k *= BigInt(d)\n\n    if let _ = String(k).range(of: rd[d - 2]) {\n      count += 1\n\n      print(n, terminator: \" \")\n      fflush(stdout)\n\n      guard count < 10 else {\n        break\n      }\n    }\n\n    n += 1\n  }\n\n  print()\n  print()\n}\n", "target": "import java.math.BigInteger;\n\npublic class SuperDNumbers {\n\n    public static void main(String[] args) {\n        for ( int i = 2 ; i <= 9 ; i++ ) {\n            superD(i, 10);\n        }\n    }\n    \n    private static final void superD(int d, int max) {\n        long start = System.currentTimeMillis();\n        String test = \"\";\n        for ( int i = 0 ; i < d ; i++ ) {\n            test += (\"\"+d);\n        }\n        \n        int n = 0;\n        int i = 0;\n        System.out.printf(\"First %d super-%d numbers: %n\", max, d);\n        while ( n < max ) {\n            i++;\n            BigInteger val = BigInteger.valueOf(d).multiply(BigInteger.valueOf(i).pow(d));\n            if ( val.toString().contains(test) ) {\n                n++;\n                System.out.printf(\"%d \", i);\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"%nRun time %d ms%n%n\", end-start);\n        \n    }\n\n}\n"}
{"id": 392574, "name": "Textonyms", "source": "Translate Swift to Java: import Foundation\n\nfunc textCharacter(_ ch: Character) -> Character? {\n    switch (ch) {\n    case \"a\", \"b\", \"c\":\n        return \"2\"\n    case \"d\", \"e\", \"f\":\n        return \"3\"\n    case \"g\", \"h\", \"i\":\n        return \"4\"\n    case \"j\", \"k\", \"l\":\n        return \"5\"\n    case \"m\", \"n\", \"o\":\n        return \"6\"\n    case \"p\", \"q\", \"r\", \"s\":\n        return \"7\"\n    case \"t\", \"u\", \"v\":\n        return \"8\"\n    case \"w\", \"x\", \"y\", \"z\":\n        return \"9\"\n    default:\n        return nil\n    }\n}\n\nfunc textString(_ string: String) -> String? {\n    var result = String()\n    result.reserveCapacity(string.count)\n    for ch in string {\n        if let tch = textCharacter(ch) {\n            result.append(tch)\n        } else {\n            return nil\n        }\n    }\n    return result\n}\n\nfunc compareByWordCount(pair1: (key: String, value: [String]),\n                        pair2: (key: String, value: [String])) -> Bool {\n    if pair1.value.count == pair2.value.count {\n        return pair1.key < pair2.key\n    }\n    return pair1.value.count > pair2.value.count\n}\n\nfunc compareByTextLength(pair1: (key: String, value: [String]),\n                         pair2: (key: String, value: [String])) -> Bool {\n    if pair1.key.count == pair2.key.count {\n        return pair1.key < pair2.key\n    }\n    return pair1.key.count > pair2.key.count\n}\n\nfunc findTextonyms(_ path: String) throws {\n    var dict = Dictionary<String, [String]>()\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    var count = 0\n    for line in contents.components(separatedBy: \"\\n\") {\n        if line.isEmpty {\n            continue\n        }\n        let word = line.lowercased()\n        if let text = textString(word) {\n            dict[text, default: []].append(word)\n            count += 1\n        }\n    }\n    var textonyms = Array(dict.filter{$0.1.count > 1})\n    print(\"There are \\(count) words in '\\(path)' which can be represented by the digit key mapping.\")\n    print(\"They require \\(dict.count) digit combinations to represent them.\")\n    print(\"\\(textonyms.count) digit combinations represent Textonyms.\")\n\n    let top = min(5, textonyms.count)\n    print(\"\\nTop \\(top) by number of words:\")\n    textonyms.sort(by: compareByWordCount)\n    for (text, words) in textonyms.prefix(top) {\n        print(\"\\(text) = \\(words.joined(separator: \", \"))\")\n    }\n\n    print(\"\\nTop \\(top) by length:\")\n    textonyms.sort(by: compareByTextLength)\n    for (text, words) in textonyms.prefix(top) {\n        print(\"\\(text) = \\(words.joined(separator: \", \"))\")\n    }\n}\n\ndo {\n    try findTextonyms(\"unixdict.txt\")\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class RTextonyms {\n\n  private static final Map<Character, Character> mapping;\n  private int total, elements, textonyms, max_found;\n  private String filename, mappingResult;\n  private Vector<String> max_strings;\n  private Map<String, Vector<String>> values;\n\n  static {\n    mapping = new HashMap<Character, Character>();\n    mapping.put('A', '2'); mapping.put('B', '2'); mapping.put('C', '2');\n    mapping.put('D', '3'); mapping.put('E', '3'); mapping.put('F', '3');\n    mapping.put('G', '4'); mapping.put('H', '4'); mapping.put('I', '4');\n    mapping.put('J', '5'); mapping.put('K', '5'); mapping.put('L', '5');\n    mapping.put('M', '6'); mapping.put('N', '6'); mapping.put('O', '6');\n    mapping.put('P', '7'); mapping.put('Q', '7'); mapping.put('R', '7'); mapping.put('S', '7');\n    mapping.put('T', '8'); mapping.put('U', '8'); mapping.put('V', '8');\n    mapping.put('W', '9'); mapping.put('X', '9'); mapping.put('Y', '9'); mapping.put('Z', '9');\n  }\n\n  public RTextonyms(String filename) {\n\n    this.filename = filename;\n    this.total = this.elements = this.textonyms = this.max_found = 0;\n    this.values = new HashMap<String, Vector<String>>();\n    this.max_strings = new Vector<String>();\n\n    return;\n  }\n\n  public void add(String line) {\n\n    String mapping = \"\";\n    total++;\n    if (!get_mapping(line)) {\n      return;\n    }\n    mapping = mappingResult;\n\n    if (values.get(mapping) == null) {\n      values.put(mapping, new Vector<String>());\n    }\n\n    int num_strings;\n    num_strings = values.get(mapping).size();\n    textonyms += num_strings == 1 ? 1 : 0;\n    elements++;\n\n    if (num_strings > max_found) {\n      max_strings.clear();\n      max_strings.add(mapping);\n      max_found = num_strings;\n    }\n    else if (num_strings == max_found) {\n      max_strings.add(mapping);\n    }\n\n    values.get(mapping).add(line);\n\n    return;\n  }\n\n  public void results() {\n\n    System.out.printf(\"Read\u00a0%,d words from %s%n%n\", total, filename);\n    System.out.printf(\"There are\u00a0%,d words in %s which can be represented by the digit key mapping.%n\", elements,\n        filename);\n    System.out.printf(\"They require\u00a0%,d digit combinations to represent them.%n\", values.size());\n    System.out.printf(\"%,d digit combinations represent Textonyms.%n\", textonyms);\n    System.out.printf(\"The numbers mapping to the most words map to\u00a0%,d words each:%n\", max_found + 1);\n    for (String key : max_strings) {\n      System.out.printf(\"%16s maps to: %s%n\", key, values.get(key).toString());\n    }\n    System.out.println();\n\n    return;\n  }\n\n  public void match(String key) {\n\n    Vector<String> match;\n    match = values.get(key);\n    if (match == null) {\n      System.out.printf(\"Key %s not found%n\", key);\n    }\n    else {\n      System.out.printf(\"Key %s matches: %s%n\", key, match.toString());\n    }\n\n    return;\n  }\n\n  private boolean get_mapping(String line) {\n\n    mappingResult = line;\n    StringBuilder mappingBuilder = new StringBuilder();\n    for (char cc : line.toCharArray()) {\n      if (Character.isAlphabetic(cc)) {\n        mappingBuilder.append(mapping.get(Character.toUpperCase(cc)));\n      }\n      else if (Character.isDigit(cc)) {\n        mappingBuilder.append(cc);\n      }\n      else {\n        return false;\n      }\n    }\n    mappingResult = mappingBuilder.toString();\n\n    return true;\n  }\n\n  public static void main(String[] args) {\n\n    String filename;\n    if (args.length > 0) {\n      filename = args[0];\n    }\n    else {\n      filename = \"./unixdict.txt\";\n    }\n    RTextonyms tc;\n    tc = new RTextonyms(filename);\n    Path fp = Paths.get(filename);\n    try (Scanner fs = new Scanner(fp, StandardCharsets.UTF_8.name())) {\n      while (fs.hasNextLine()) {\n        tc.add(fs.nextLine());\n      }\n    }\n    catch (IOException ex) {\n      ex.printStackTrace();\n    }\n\n    List<String> numbers = Arrays.asList(\n        \"001\", \"228\", \"27484247\", \"7244967473642\",\n        \".\"\n        );\n\n    tc.results();\n    for (String number : numbers) {\n      if (number.equals(\".\")) {\n        System.out.println();\n      }\n      else {\n        tc.match(number);\n      }\n    }\n\n    return;\n  }\n}\n"}
{"id": 392575, "name": "Church numerals", "source": "Translate Swift to Java: func succ<A, B, C>(_ n: @escaping (@escaping (A) -> B) -> (C) -> A) -> (@escaping (A) -> B) -> (C) -> B {\n  return {f in\n    return {x in\n      return f(n(f)(x))\n    }\n  }\n}\n\nfunc zero<A, B>(_ a: A) -> (B) -> B {\n  return {b in\n    return b\n  }\n}\n\nfunc three<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(zero)))(f)(x)\n  }\n}\n\nfunc four<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(succ(zero))))(f)(x)\n  }\n}\n\nfunc add<A, B, C>(_ m: @escaping (B) -> (A) -> C) -> (@escaping (B) -> (C) -> A) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return m(f)(n(f)(x))\n      }\n    }\n  }\n}\n\nfunc mult<A, B, C>(_ m: @escaping (A) -> B) -> (@escaping (C) -> A) -> (C) -> B {\n  return {n in\n    return {f in\n      return m(n(f))\n    }\n  }\n}\n\nfunc exp<A, B, C>(_ m: A) -> (@escaping (A) -> (B) -> (C) -> C) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return n(m)(f)(x)\n      }\n    }\n  }\n}\n\nfunc church<A>(_ x: Int) -> (@escaping (A) -> A) -> (A) -> A {\n  guard x != 0 else { return zero }\n\n  return {f in\n    return {a in\n      return f(church(x - 1)(f)(a))\n    }\n  }\n}\n\nfunc unchurch<A>(_ f: (@escaping (Int) -> Int) -> (Int) -> A) -> A {\n  return f({i in\n    return i + 1\n  })(0)\n}\n\nlet a = unchurch(add(three)(four))\nlet b = unchurch(mult(three)(four))\n\nlet c = unchurch(exp(mult(four)(church(1)))(three))\nlet d = unchurch(exp(mult(three)(church(1)))(four))\n\nprint(a, b, c, d)\n", "target": "package lvijay;\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Function;\n\npublic class Church {\n    public static interface ChurchNum extends Function<ChurchNum, ChurchNum> {\n    }\n\n    public static ChurchNum zero() {\n        return f -> x -> x;\n    }\n\n    public static ChurchNum next(ChurchNum n) {\n        return f -> x -> f.apply(n.apply(f).apply(x));\n    }\n\n    public static ChurchNum plus(ChurchNum a) {\n        return b -> f -> x -> b.apply(f).apply(a.apply(f).apply(x));\n    }\n\n    public static ChurchNum pow(ChurchNum m) {\n        return n -> m.apply(n);\n    }\n\n    public static ChurchNum mult(ChurchNum a) {\n        return b -> f -> x -> b.apply(a.apply(f)).apply(x);\n    }\n\n    public static ChurchNum toChurchNum(int n) {\n        if (n <= 0) {\n            return zero();\n        }\n        return next(toChurchNum(n - 1));\n    }\n\n    public static int toInt(ChurchNum c) {\n        AtomicInteger counter = new AtomicInteger(0);\n        ChurchNum funCounter = f -> {\n            counter.incrementAndGet();\n            return f;\n        };\n\n        plus(zero()).apply(c).apply(funCounter).apply(x -> x);\n\n        return counter.get();\n    }\n\n    public static void main(String[] args) {\n        ChurchNum zero  = zero();\n        ChurchNum three = next(next(next(zero)));\n        ChurchNum four  = next(next(next(next(zero))));\n\n        System.out.println(\"3+4=\" + toInt(plus(three).apply(four))); \n        System.out.println(\"4+3=\" + toInt(plus(four).apply(three))); \n\n        System.out.println(\"3*4=\" + toInt(mult(three).apply(four))); \n        System.out.println(\"4*3=\" + toInt(mult(four).apply(three))); \n\n        \n        System.out.println(\"3^4=\" + toInt(pow(four).apply(three))); \n        System.out.println(\"4^3=\" + toInt(pow(three).apply(four))); \n\n        System.out.println(\"  8=\" + toInt(toChurchNum(8))); \n    }\n}\n"}
{"id": 392576, "name": "Church numerals", "source": "Translate Swift to Java: func succ<A, B, C>(_ n: @escaping (@escaping (A) -> B) -> (C) -> A) -> (@escaping (A) -> B) -> (C) -> B {\n  return {f in\n    return {x in\n      return f(n(f)(x))\n    }\n  }\n}\n\nfunc zero<A, B>(_ a: A) -> (B) -> B {\n  return {b in\n    return b\n  }\n}\n\nfunc three<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(zero)))(f)(x)\n  }\n}\n\nfunc four<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(succ(zero))))(f)(x)\n  }\n}\n\nfunc add<A, B, C>(_ m: @escaping (B) -> (A) -> C) -> (@escaping (B) -> (C) -> A) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return m(f)(n(f)(x))\n      }\n    }\n  }\n}\n\nfunc mult<A, B, C>(_ m: @escaping (A) -> B) -> (@escaping (C) -> A) -> (C) -> B {\n  return {n in\n    return {f in\n      return m(n(f))\n    }\n  }\n}\n\nfunc exp<A, B, C>(_ m: A) -> (@escaping (A) -> (B) -> (C) -> C) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return n(m)(f)(x)\n      }\n    }\n  }\n}\n\nfunc church<A>(_ x: Int) -> (@escaping (A) -> A) -> (A) -> A {\n  guard x != 0 else { return zero }\n\n  return {f in\n    return {a in\n      return f(church(x - 1)(f)(a))\n    }\n  }\n}\n\nfunc unchurch<A>(_ f: (@escaping (Int) -> Int) -> (Int) -> A) -> A {\n  return f({i in\n    return i + 1\n  })(0)\n}\n\nlet a = unchurch(add(three)(four))\nlet b = unchurch(mult(three)(four))\n\nlet c = unchurch(exp(mult(four)(church(1)))(three))\nlet d = unchurch(exp(mult(three)(church(1)))(four))\n\nprint(a, b, c, d)\n", "target": "package lvijay;\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Function;\n\npublic class Church {\n    public static interface ChurchNum extends Function<ChurchNum, ChurchNum> {\n    }\n\n    public static ChurchNum zero() {\n        return f -> x -> x;\n    }\n\n    public static ChurchNum next(ChurchNum n) {\n        return f -> x -> f.apply(n.apply(f).apply(x));\n    }\n\n    public static ChurchNum plus(ChurchNum a) {\n        return b -> f -> x -> b.apply(f).apply(a.apply(f).apply(x));\n    }\n\n    public static ChurchNum pow(ChurchNum m) {\n        return n -> m.apply(n);\n    }\n\n    public static ChurchNum mult(ChurchNum a) {\n        return b -> f -> x -> b.apply(a.apply(f)).apply(x);\n    }\n\n    public static ChurchNum toChurchNum(int n) {\n        if (n <= 0) {\n            return zero();\n        }\n        return next(toChurchNum(n - 1));\n    }\n\n    public static int toInt(ChurchNum c) {\n        AtomicInteger counter = new AtomicInteger(0);\n        ChurchNum funCounter = f -> {\n            counter.incrementAndGet();\n            return f;\n        };\n\n        plus(zero()).apply(c).apply(funCounter).apply(x -> x);\n\n        return counter.get();\n    }\n\n    public static void main(String[] args) {\n        ChurchNum zero  = zero();\n        ChurchNum three = next(next(next(zero)));\n        ChurchNum four  = next(next(next(next(zero))));\n\n        System.out.println(\"3+4=\" + toInt(plus(three).apply(four))); \n        System.out.println(\"4+3=\" + toInt(plus(four).apply(three))); \n\n        System.out.println(\"3*4=\" + toInt(mult(three).apply(four))); \n        System.out.println(\"4*3=\" + toInt(mult(four).apply(three))); \n\n        \n        System.out.println(\"3^4=\" + toInt(pow(four).apply(three))); \n        System.out.println(\"4^3=\" + toInt(pow(three).apply(four))); \n\n        System.out.println(\"  8=\" + toInt(toChurchNum(8))); \n    }\n}\n"}
{"id": 392577, "name": "Send an unknown method call", "source": "Translate Swift to Java: import Foundation\n\nclass MyUglyClass: NSObject {\n  @objc\n  func myUglyFunction() {\n    print(\"called myUglyFunction\")\n  }\n}\n\nlet someObject: NSObject = MyUglyClass()\n\nsomeObject.perform(NSSelectorFromString(\"myUglyFunction\"))\n", "target": "import java.lang.reflect.Method;\n\nclass Example {\n  public int foo(int x) {\n    return 42 + x;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    Object example = new Example();\n    String name = \"foo\";\n    Class<?> clazz = example.getClass();\n    Method meth = clazz.getMethod(name, int.class);\n    Object result = meth.invoke(example, 5); \n    System.out.println(result);        \n  }\n}\n"}
{"id": 392578, "name": "Sequence of primorial primes", "source": "Translate Swift to Java: import BigInt \nimport Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n}\n\nlet limit = 20\nvar primorial = 1\nvar count = 1\nvar p = 3\nvar prod = BigInt(2)\n\nprint(1, terminator: \" \")\n\nwhile true {\n  defer {\n    p += 2\n  }\n\n  guard p.isPrime else {\n    continue\n  }\n\n  prod *= BigInt(p)\n  primorial += 1\n\n  if (prod + 1).isPrime() || (prod - 1).isPrime() {\n    print(primorial, terminator: \" \")\n\n    count += 1\n\n    fflush(stdout)\n\n    if count == limit {\n      break\n    }\n  }\n}\n", "target": "import java.math.BigInteger;\n\npublic class PrimorialPrimes {\n\n    final static int sieveLimit = 1550_000;\n    static boolean[] notPrime = sieve(sieveLimit);\n\n    public static void main(String[] args) {\n\n        int count = 0;\n        for (int i = 1; i < 1000_000 && count < 20; i++) {\n            BigInteger b = primorial(i);\n            if (b.add(BigInteger.ONE).isProbablePrime(1)\n                    || b.subtract(BigInteger.ONE).isProbablePrime(1)) {\n                System.out.printf(\"%d \", i);\n                count++;\n            }\n        }\n    }\n\n    static BigInteger primorial(int n) {\n        if (n == 0)\n            return BigInteger.ONE;\n\n        BigInteger result = BigInteger.ONE;\n        for (int i = 0; i < sieveLimit && n > 0; i++) {\n            if (notPrime[i])\n                continue;\n            result = result.multiply(BigInteger.valueOf(i));\n            n--;\n        }\n        return result;\n    }\n\n    public static boolean[] sieve(int limit) {\n        boolean[] composite = new boolean[limit];\n        composite[0] = composite[1] = true;\n\n        int max = (int) Math.sqrt(limit);\n        for (int n = 2; n <= max; n++) {\n            if (!composite[n]) {\n                for (int k = n * n; k < limit; k += n) {\n                    composite[k] = true;\n                }\n            }\n        }\n        return composite;\n    }\n}\n"}
{"id": 392579, "name": "Combinations and permutations", "source": "Translate Swift to Java: import BigInt\n\nfunc permutations(n: Int, k: Int) -> BigInt {\n  let l = n - k + 1\n\n  guard l <= n else {\n    return 1\n  }\n\n  return (l...n).reduce(BigInt(1), { $0 * BigInt($1) })\n}\n\nfunc combinations(n: Int, k: Int) -> BigInt {\n  let fact = {() -> BigInt in\n    guard k > 1 else {\n      return 1\n    }\n\n    return (2...k).map({ BigInt($0) }).reduce(1, *)\n  }()\n\n  return permutations(n: n, k: k) / fact\n}\n\nprint(\"Sample of permutations from 1 to 12\")\n\nfor i in 1...12 {\n  print(\"\\(i) P \\(i / 3) = \\(permutations(n: i, k: i / 3))\")\n}\n\nprint(\"\\nSample of combinations from 10 to 60\")\n\nfor i in stride(from: 10, through: 60, by: 10) {\n  print(\"\\(i) C \\(i / 3) = \\(combinations(n: i, k: i / 3))\")\n}\n\nprint(\"\\nSample of permutations from 5 to 15,000\")\n\nfor i in [5, 50, 500, 1000, 5000, 15000] {\n  let k = i / 3\n  let res = permutations(n: i, k: k).description\n  let extra = res.count > 40 ? \"... (\\(res.count - 40) more digits)\" : \"\"\n\n  print(\"\\(i) P \\(k) = \\(res.prefix(40))\\(extra)\")\n}\n\nprint(\"\\nSample of combinations from 100 to 1000\")\n\nfor i in stride(from: 100, through: 1000, by: 100) {\n  let k = i / 3\n  let res = combinations(n: i, k: k).description\n  let extra = res.count > 40 ? \"... (\\(res.count - 40) more digits)\" : \"\"\n\n  print(\"\\(i) C \\(k) = \\(res.prefix(40))\\(extra)\")\n}\n", "target": "import java.math.BigInteger;\n\npublic class CombinationsAndPermutations {\n\n    public static void main(String[] args) {\n        System.out.println(Double.MAX_VALUE);\n        System.out.println(\"A sample of permutations from 1 to 12 with exact Integer arithmetic:\");\n        for ( int n = 1 ; n <= 12 ; n++ ) {\n            int k = n / 2;\n            System.out.printf(\"%d P %d = %s%n\", n, k, permutation(n, k));\n        }\n\n        System.out.println();\n        System.out.println(\"A sample of combinations from 10 to 60 with exact Integer arithmetic:\");\n        for ( int n = 10 ; n <= 60 ; n += 5 ) {\n            int k = n / 2;\n            System.out.printf(\"%d C %d = %s%n\", n, k, combination(n, k));\n        }\n        \n        System.out.println();\n        System.out.println(\"A sample of permutations from 5 to 15000 displayed in floating point arithmetic:\");\n        System.out.printf(\"%d P %d = %s%n\", 5, 2, display(permutation(5, 2), 50));\n        for ( int n = 1000 ; n <= 15000 ; n += 1000 ) {\n            int k = n / 2;\n            System.out.printf(\"%d P %d = %s%n\", n, k, display(permutation(n, k), 50));\n        }\n        \n        System.out.println();\n        System.out.println(\"A sample of combinations from 100 to 1000 displayed in floating point arithmetic:\");\n        for ( int n = 100 ; n <= 1000 ; n += 100 ) {\n            int k = n / 2;\n            System.out.printf(\"%d C %d = %s%n\", n, k, display(combination(n, k), 50));\n        }\n\n    }\n    \n    private static String display(BigInteger val, int precision) {\n        String s = val.toString();\n        precision = Math.min(precision, s.length());\n        StringBuilder sb = new StringBuilder();\n        sb.append(s.substring(0, 1));\n        sb.append(\".\");\n        sb.append(s.substring(1, precision));\n        sb.append(\" * 10^\");\n        sb.append(s.length()-1);\n        return sb.toString();\n    }\n    \n    public static BigInteger combination(int n, int k) {\n        \n        \n        if ( n-k < k ) {\n            k = n-k;\n        }\n        BigInteger result = permutation(n, k);\n        while ( k > 0 ) {\n            result = result.divide(BigInteger.valueOf(k));\n            k--;\n        }\n        return result;\n    }\n    \n    public static BigInteger permutation(int n, int k) {\n        BigInteger result = BigInteger.ONE;\n        for ( int i = n ; i >= n-k+1 ; i-- ) {\n            result = result.multiply(BigInteger.valueOf(i));\n        }\n        return result;\n    }\n    \n}\n"}
{"id": 392580, "name": "Long primes", "source": "Translate Swift to Java: public struct Eratosthenes: Sequence, IteratorProtocol {\n  private let n: Int\n  private let limit: Int\n\n  private var i = 2\n  private var sieve: [Int]\n\n  public init(upTo: Int) {\n    if upTo <= 1 {\n      self.n = 0\n      self.limit = -1\n      self.sieve = []\n    } else {\n      self.n = upTo\n      self.limit = Int(Double(n).squareRoot())\n      self.sieve = Array(0...n)\n    }\n  }\n\n  public mutating func next() -> Int? {\n    while i < n {\n      defer { i += 1 }\n\n      if sieve[i] != 0 {\n        if i <= limit {\n          for notPrime in stride(from: i * i, through: n, by: i) {\n            sieve[notPrime] = 0\n          }\n        }\n\n        return i\n      }\n    }\n\n    return nil\n  }\n}\n\nfunc findPeriod(n: Int) -> Int {\n  let r = (1...n+1).reduce(1, {res, _ in (10 * res) % n })\n  var rr = r\n  var period = 0\n\n  repeat {\n    rr = (10 * rr) % n\n    period += 1\n  } while r != rr\n\n  return period\n}\n\nlet longPrimes = Eratosthenes(upTo: 64000).dropFirst().lazy.filter({ findPeriod(n: $0) == $0 - 1 })\n\nprint(\"Long primes less than 500: \\(Array(longPrimes.prefix(while: { $0 <= 500 })))\")\n\nlet counts =\n  longPrimes.reduce(into: [500: 0, 1000: 0, 2000: 0, 4000: 0, 8000: 0, 16000: 0, 32000: 0, 64000: 0], {counts, n in\n    for key in counts.keys where n < key {\n      counts[key]! += 1\n    }\n  })\n\nfor key in counts.keys.sorted() {\n  print(\"There are \\(counts[key]!) long primes less than \\(key)\")\n}\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\npublic class LongPrimes\n{\n    private static void sieve(int limit, List<Integer> primes)\n    {\n        boolean[] c = new boolean[limit];\n        for (int i = 0; i < limit; i++)\n            c[i] = false;\n        \n        int p = 3, n = 0;\n        int p2 = p * p;\n        while (p2 <= limit)\n        {\n            for (int i = p2; i <= limit; i += 2 * p)\n                c[i] = true;\n            do\n                p += 2;\n            while (c[p]);\n            p2 = p * p;\n        }\n        for (int i = 3; i <= limit; i += 2)\n            if (!c[i])\n                primes.add(i);\n    }\n\n    \n    private static int findPeriod(int n)\n    {\n        int r = 1, period = 0;\n        for (int i = 1; i < n; i++)\n            r = (10 * r) % n;\n        int rr = r;\n        do\n        {\n            r = (10 * r) % n;\n            ++period;\n        }\n        while (r != rr);\n        return period;\n    }\n    \n    public static void main(String[] args)\n    {\n        int[] numbers = new int[]{500, 1000, 2000, 4000, 8000, 16000, 32000, 64000};\n        int[] totals = new int[numbers.length]; \n        List<Integer> primes = new LinkedList<Integer>();\n        List<Integer> longPrimes = new LinkedList<Integer>();\n        sieve(64000, primes);\n        for (int prime : primes)\n            if (findPeriod(prime) == prime - 1)\n                longPrimes.add(prime);\n        int count = 0, index = 0;\n        for (int longPrime : longPrimes)\n        {\n            if (longPrime > numbers[index])\n                totals[index++] = count;\n            ++count;\n        }\n        totals[numbers.length - 1] = count;\n        System.out.println(\"The long primes up to \" + numbers[0] + \" are:\");\n        System.out.println(longPrimes.subList(0, totals[0]));\n        System.out.println();\n        System.out.println(\"The number of long primes up to:\");\n        for (int i = 0; i <= 7; i++)\n            System.out.printf(\"  %5d is %d\\n\", numbers[i], totals[i]);\n    }\n}\n"}
{"id": 392581, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Swift to Java: \nimport Foundation\n\n\nstruct Stack<T> {\n\tprivate(set) var elements = [T]()\n\t\n\tvar isEmpty: Bool {\n\t\telements.isEmpty\n\t}\n\t\n\tvar top: T? {\n\t\telements.last\n\t}\n\t\n\tmutating func push(_ newElement: T) {\n\t\telements.append(newElement)\n\t}\n\t\n\tmutating func pop() -> T? {\n\t\tself.isEmpty ? nil : elements.removeLast()\n\t}\n}\n\nstruct Queue<T> {\n\tprivate(set) var elements = [T]()\n\t\n\tvar isEmpty: Bool {\n\t\telements.isEmpty\n\t}\n\t\n\tmutating func enqueue(_ newElement: T) {\n\t\telements.append(newElement)\n\t}\n\t\n\tmutating func dequeue() -> T {\n\t\treturn elements.removeFirst()\n\t}\n}\n\nenum Associativity {\n\tcase Left, Right\n}\n\n\nprotocol OperatorType: Comparable, Hashable {\n\tvar name: String { get }\n\tvar precedence: Int { get }\n\tvar associativity: Associativity { get }\n}\n\nstruct Operator: OperatorType {\n\tlet name: String\n\tlet precedence: Int\n\tlet associativity: Associativity\n\t\n\t\n\tfunc hash(into hasher: inout Hasher) {\n\t\thasher.combine(self.name)\n\t}\n\t\n\tinit(_ name: String, _ precedence: Int, _ associativity: Associativity) {\n\t\tself.name = name; self.precedence = precedence; self.associativity = associativity\n\t}\n}\n\nfunc ==(x: Operator, y: Operator) -> Bool {\n\t\n\tx.name == y.name\n}\n\nfunc <(x: Operator, y: Operator) -> Bool {\n\t\n\t(x.associativity == .Left && x.precedence == y.precedence) || x.precedence < y.precedence\n}\n\nextension Set where Element: OperatorType {\n\tfunc contains(_ operatorName: String) -> Bool {\n\t\tcontains { $0.name == operatorName }\n\t}\n\t\n\tsubscript (operatorName: String) -> Element? {\n\t\tget {\n\t\t\tfilter { $0.name == operatorName }.first\n\t\t}\n\t}\n}\n\n\nextension String {\n\tvar isNumber: Bool { return Double(self) != nil }\n}\n\nstruct ShuntingYard {\n\tenum ParseError: Error {\n\t\tcase MismatchedParenthesis(parenthesis: String, expression: String)\n\t\tcase UnrecognizedToken(token: String, expression: String)\n\t\tcase ExtraneousToken(token: String, expression: String)\n\t}\n\t\n\tstatic func parse(_ input: String, operators: Set<Operator>) throws -> String {\n\t\tvar stack = Stack<String>()\n\t\tvar output = Queue<String>()\n\t\tlet tokens = input.components(separatedBy: \" \")\n\t\t\n\t\tfor token in tokens {\n\t\t\t\n\t\t\tif token.isNumber {\n\t\t\t\t\n\t\t\t\toutput.enqueue(token)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif operators.contains(token) {\n\t\t\t\t\n\t\t\t\twhile let top = stack.top,\n\t\t\t\t\t  operators.contains(top) && Self.hasLowerPrecedence(token, top, operators) {\n\t\t\t\t\t\n\t\t\t\t\toutput.enqueue(stack.pop()!)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstack.push(token)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif token == \"(\" {\n\t\t\t\t\n\t\t\t\tstack.push(token)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif token == \")\" {\n\t\t\t\t\n\t\t\t\twhile let top = stack.top, top != \"(\" {\n\t\t\t\t\t\n\t\t\t\t\toutput.enqueue(stack.pop()!)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tguard let _ = stack.pop() else {\n\t\t\t\t\t\n\t\t\t\t\tthrow ParseError.MismatchedParenthesis(parenthesis: \")\", expression: input)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tthrow ParseError.UnrecognizedToken(token: token, expression: token)\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\twhile let top = stack.top,\n\t\t\t  operators.contains(top) {\n\t\t\t\n\t\t\toutput.enqueue(stack.pop()!)\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tif let top = stack.pop() {\n\t\t\tthrow (\n\t\t\t\ttop == \"(\"\n\t\t\t\t? ParseError.MismatchedParenthesis(parenthesis: \"(\", expression: input)\n\t\t\t\t: ParseError.ExtraneousToken(token: top, expression: input)\n\t\t\t)\n\t\t}\n\t\t\n\t\treturn output.elements.joined(separator: \" \")\n\t}\n\t\n\tstatic private func hasLowerPrecedence(_ firstToken: String, _ secondToken: String, _ operators: Set<Operator>) -> Bool {\n\t\tguard let firstOperator = operators[firstToken],\n\t\t\t  let secondOperator = operators[secondToken] else {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\treturn firstOperator < secondOperator\n\t}\n}\n\n\n", "target": "import java.util.Stack;\n\npublic class ShuntingYard {\n\n    public static void main(String[] args) {\n        String infix = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\";\n        System.out.printf(\"infix:   %s%n\", infix);\n        System.out.printf(\"postfix: %s%n\", infixToPostfix(infix));\n    }\n\n    static String infixToPostfix(String infix) {\n        \n        final String ops = \"-+/*^\";\n\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n\n        for (String token : infix.split(\"\\\\s\")) {\n            if (token.isEmpty())\n                continue;\n            char c = token.charAt(0);\n            int idx = ops.indexOf(c);\n\n            \n            if (idx != -1) {\n                if (s.isEmpty())\n                    s.push(idx);\n          \n                else {\n                    while (!s.isEmpty()) {\n                        int prec2 = s.peek() / 2;\n                        int prec1 = idx / 2;\n                        if (prec2 > prec1 || (prec2 == prec1 && c != '^'))\n                            sb.append(ops.charAt(s.pop())).append(' ');\n                        else break;\n                    }\n                    s.push(idx);\n                }\n            } \n            else if (c == '(') {\n                s.push(-2); \n            } \n            else if (c == ')') {\n                \n                while (s.peek() != -2)\n                    sb.append(ops.charAt(s.pop())).append(' ');\n                s.pop();\n            }\n            else {\n                sb.append(token).append(' ');\n            }\n        }\n        while (!s.isEmpty())\n            sb.append(ops.charAt(s.pop())).append(' ');\n        return sb.toString();\n    }\n}\n"}
{"id": 392582, "name": "Perlin noise", "source": "Translate Swift to Java: import Foundation\n\nstruct Perlin {\n  private static let permutation = [\n    151, 160, 137,  91,  90,  15, 131,  13, 201,  95,  96,  53, 194, 233,   7, 225,\n    140,  36, 103,  30,  69, 142,   8,  99,  37, 240,  21,  10,  23, 190,   6, 148,\n    247, 120, 234,  75,   0,  26, 197,  62,  94, 252, 219, 203, 117,  35,  11,  32,\n    57, 177,  33,  88, 237, 149,  56,  87, 174,  20, 125, 136, 171, 168,  68, 175,\n    74, 165,  71, 134, 139,  48,  27, 166,  77, 146, 158, 231,  83, 111, 229, 122,\n    60, 211, 133, 230, 220, 105,  92,  41,  55,  46, 245,  40, 244, 102, 143,  54,\n    65,  25,  63, 161,   1, 216,  80,  73, 209,  76, 132, 187, 208,  89,  18, 169,\n    200, 196, 135, 130, 116, 188, 159,  86, 164, 100, 109, 198, 173, 186,   3,  64,\n    52, 217, 226, 250, 124, 123,   5, 202,  38, 147, 118, 126, 255,  82,  85, 212,\n    207, 206,  59, 227,  47,  16,  58,  17, 182, 189,  28,  42, 223, 183, 170, 213,\n    119, 248, 152,   2,  44, 154, 163,  70, 221, 153, 101, 155, 167,  43, 172,   9,\n    129,  22,  39, 253,  19,  98, 108, 110,  79, 113, 224, 232, 178, 185, 112, 104,\n    218, 246,  97, 228, 251,  34, 242, 193, 238, 210, 144,  12, 191, 179, 162, 241,\n    81,  51, 145, 235, 249,  14, 239, 107,  49, 192, 214,  31, 181, 199, 106, 157,\n    184,  84, 204, 176, 115, 121,  50,  45, 127,   4, 150, 254, 138, 236, 205,  93,\n    222, 114,  67,  29,  24,  72, 243, 141, 128, 195,  78,  66, 215,  61, 156, 180\n  ]\n\n  private static let p = (0..<512).map({i -> Int in\n    if i < 256 {\n      return permutation[i]\n    } else {\n      return permutation[i - 256]\n    }\n  })\n\n  private static func fade(_ t: Double) -> Double { t * t * t * (t * (t * 6 - 15) + 10) }\n\n  private static func lerp(_ t: Double, _ a: Double, _ b: Double) -> Double { a + t * (b - a) }\n\n  private static func grad(_ hash: Int, _ x: Double, _ y: Double, _ z: Double) -> Double {\n    let h = hash & 15\n    let u = h < 8 ? x : y\n    let v = h < 4 ? y : h == 12 || h == 14 ? x : z\n\n    return (h & 1 == 0 ? u : -u) + (h & 2 == 0 ? v : -v)\n  }\n\n  static func noise(x: Double, y: Double, z: Double) -> Double {\n    let xi = Int(x) & 255\n    let yi = Int(y) & 255\n    let zi = Int(z) & 255\n\n    let xx = x - floor(x)\n    let yy = y - floor(y)\n    let zz = z - floor(z)\n\n    let u = fade(xx)\n    let v = fade(yy)\n    let w = fade(zz)\n\n    let a  = p[xi] + yi\n    let aa = p[a] + zi\n    let b  = p[xi + 1] + yi\n    let ba = p[b] + zi\n    let ab = p[a + 1] + zi\n    let bb = p[b + 1] + zi\n\n    return lerp(w, lerp(v, lerp(u, grad(p[aa], xx, yy, zz),\n      grad(p[ba], xx - 1, yy, zz)),\n      lerp(u, grad(p[ab], xx, yy - 1, zz),\n        grad(p[bb], xx - 1, yy - 1, zz))),\n      lerp(v, lerp(u, grad(p[aa + 1], xx, yy, zz - 1),\n        grad(p[ba + 1], xx - 1, yy, zz - 1)),\n        lerp(u, grad(p[ab + 1], xx, yy - 1, zz - 1),\n          grad(p[bb + 1], xx - 1, yy - 1, zz - 1))))\n  }\n}\n\nprint(Perlin.noise(x: 3.14, y: 42, z: 7))\n", "target": "\n\npublic final class ImprovedNoise {\n   static public double noise(double x, double y, double z) {\n      int X = (int)Math.floor(x) & 255,                  \n          Y = (int)Math.floor(y) & 255,                  \n          Z = (int)Math.floor(z) & 255;\n      x -= Math.floor(x);                                \n      y -= Math.floor(y);                                \n      z -= Math.floor(z);\n      double u = fade(x),                                \n             v = fade(y),                                \n             w = fade(z);\n      int A = p[X  ]+Y, AA = p[A]+Z, AB = p[A+1]+Z,      \n          B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;      \n\n      return lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z   ),  \n                                     grad(p[BA  ], x-1, y  , z   )), \n                             lerp(u, grad(p[AB  ], x  , y-1, z   ),  \n                                     grad(p[BB  ], x-1, y-1, z   ))),\n                     lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1 ),  \n                                     grad(p[BA+1], x-1, y  , z-1 )), \n                             lerp(u, grad(p[AB+1], x  , y-1, z-1 ),\n                                     grad(p[BB+1], x-1, y-1, z-1 ))));\n   }\n   static double fade(double t) { return t * t * t * (t * (t * 6 - 15) + 10); }\n   static double lerp(double t, double a, double b) { return a + t * (b - a); }\n   static double grad(int hash, double x, double y, double z) {\n      int h = hash & 15;                      \n      double u = h<8 ? x : y,                 \n             v = h<4 ? y : h==12||h==14 ? x : z;\n      return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\n   }\n   static final int p[] = new int[512], permutation[] = { 151,160,137,91,90,15,\n   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n   };\n   static { for (int i=0; i < 256 ; i++) p[256+i] = p[i] = permutation[i]; }\n}\n"}
{"id": 392583, "name": "Lychrel numbers", "source": "Translate Swift to Java: import BigInt\n\npublic struct Lychrel<T: ReversibleNumeric & CustomStringConvertible>: Sequence, IteratorProtocol {\n  @usableFromInline\n  let seed: T\n\n  @usableFromInline\n  var done = false\n\n  @usableFromInline\n  var n: T\n\n  @usableFromInline\n  var iterations: T\n\n  @inlinable\n  public init(seed: T, iterations: T = 500) {\n    self.seed = seed\n    self.n = seed\n    self.iterations = iterations\n  }\n\n  @inlinable\n  public mutating func next() -> T? {\n    guard !done && iterations != 0 else {\n      return nil\n    }\n\n    guard !isPalindrome(n) || n == seed else {\n      done = true\n\n      return n\n    }\n\n    defer {\n      n += n.reversed()\n      iterations -= 1\n    }\n\n    return n\n  }\n}\n\n@inlinable\npublic func isPalindrome<T: CustomStringConvertible>(_ x: T) -> Bool {\n  let asString = String(describing: x)\n\n  for (c, c1) in zip(asString, asString.reversed()) where c != c1 {\n    return false\n  }\n\n  return true\n}\n\npublic protocol ReversibleNumeric: Numeric {\n  func reversed() -> Self\n}\n\nextension BigInt: ReversibleNumeric {\n  public func reversed() -> BigInt {\n    return BigInt(String(description.reversed()))!\n  }\n}\n\ntypealias LychrelReduce = (seen: Set<BigInt>, seeds: Set<BigInt>, related: Set<BigInt>)\n\nlet (seen, seeds, related): LychrelReduce =\n  (1...10_000)\n    .map({ BigInt($0) })\n    .reduce(into: LychrelReduce(seen: Set(), seeds: Set(), related: Set()), {res, cur in\n      guard !res.seen.contains(cur) else {\n        res.related.insert(cur)\n\n        return\n      }\n\n      var seen = false\n\n      let seq = Lychrel(seed: cur).prefix(while: { seen = res.seen.contains($0); return !seen })\n      let last = seq.last!\n\n      guard !isPalindrome(last) || seen else {\n        return\n      }\n\n      res.seen.formUnion(seq)\n\n      if seq.count == 500 {\n        res.seeds.insert(cur)\n      } else {\n        res.related.insert(cur)\n      }\n  })\n\nprint(\"Found \\(seeds.count + related.count) Lychrel numbers between 1...10_000 when limited to 500 iterations\")\nprint(\"Number of Lychrel seeds found: \\(seeds.count)\")\nprint(\"Lychrel seeds found: \\(seeds.sorted())\")\nprint(\"Number of related Lychrel nums found: \\(related.count)\")\nprint(\"Lychrel palindromes found: \\(seeds.union(related).filter(isPalindrome).sorted())\")\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class Lychrel {\n\n    static Map<BigInteger, Tuple> cache = new HashMap<>();\n\n    static class Tuple {\n        final Boolean flag;\n        final BigInteger bi;\n\n        Tuple(boolean f, BigInteger b) {\n            flag = f;\n            bi = b;\n        }\n    }\n\n    static BigInteger rev(BigInteger bi) {\n        String s = new StringBuilder(bi.toString()).reverse().toString();\n        return new BigInteger(s);\n    }\n\n    static Tuple lychrel(BigInteger n) {\n        Tuple res;\n        if ((res = cache.get(n)) != null)\n            return res;\n\n        BigInteger r = rev(n);\n        res = new Tuple(true, n);\n        List<BigInteger> seen = new ArrayList<>();\n\n        for (int i = 0; i < 500; i++) {\n            n = n.add(r);\n            r = rev(n);\n\n            if (n.equals(r)) {\n                res = new Tuple(false, BigInteger.ZERO);\n                break;\n            }\n\n            if (cache.containsKey(n)) {\n                res = cache.get(n);\n                break;\n            }\n\n            seen.add(n);\n        }\n\n        for (BigInteger bi : seen)\n            cache.put(bi, res);\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n\n        List<BigInteger> seeds = new ArrayList<>();\n        List<BigInteger> related = new ArrayList<>();\n        List<BigInteger> palin = new ArrayList<>();\n\n        for (int i = 1; i <= 10_000; i++) {\n            BigInteger n = BigInteger.valueOf(i);\n\n            Tuple t = lychrel(n);\n\n            if (!t.flag)\n                continue;\n\n            if (n.equals(t.bi))\n                seeds.add(t.bi);\n            else\n                related.add(t.bi);\n\n            if (n.equals(t.bi))\n                palin.add(t.bi);\n        }\n\n        System.out.printf(\"%d Lychrel seeds: %s%n\", seeds.size(), seeds);\n        System.out.printf(\"%d Lychrel related%n\", related.size());\n        System.out.printf(\"%d Lychrel palindromes: %s%n\", palin.size(), palin);\n    }\n}\n"}
{"id": 392584, "name": "Lychrel numbers", "source": "Translate Swift to Java: import BigInt\n\npublic struct Lychrel<T: ReversibleNumeric & CustomStringConvertible>: Sequence, IteratorProtocol {\n  @usableFromInline\n  let seed: T\n\n  @usableFromInline\n  var done = false\n\n  @usableFromInline\n  var n: T\n\n  @usableFromInline\n  var iterations: T\n\n  @inlinable\n  public init(seed: T, iterations: T = 500) {\n    self.seed = seed\n    self.n = seed\n    self.iterations = iterations\n  }\n\n  @inlinable\n  public mutating func next() -> T? {\n    guard !done && iterations != 0 else {\n      return nil\n    }\n\n    guard !isPalindrome(n) || n == seed else {\n      done = true\n\n      return n\n    }\n\n    defer {\n      n += n.reversed()\n      iterations -= 1\n    }\n\n    return n\n  }\n}\n\n@inlinable\npublic func isPalindrome<T: CustomStringConvertible>(_ x: T) -> Bool {\n  let asString = String(describing: x)\n\n  for (c, c1) in zip(asString, asString.reversed()) where c != c1 {\n    return false\n  }\n\n  return true\n}\n\npublic protocol ReversibleNumeric: Numeric {\n  func reversed() -> Self\n}\n\nextension BigInt: ReversibleNumeric {\n  public func reversed() -> BigInt {\n    return BigInt(String(description.reversed()))!\n  }\n}\n\ntypealias LychrelReduce = (seen: Set<BigInt>, seeds: Set<BigInt>, related: Set<BigInt>)\n\nlet (seen, seeds, related): LychrelReduce =\n  (1...10_000)\n    .map({ BigInt($0) })\n    .reduce(into: LychrelReduce(seen: Set(), seeds: Set(), related: Set()), {res, cur in\n      guard !res.seen.contains(cur) else {\n        res.related.insert(cur)\n\n        return\n      }\n\n      var seen = false\n\n      let seq = Lychrel(seed: cur).prefix(while: { seen = res.seen.contains($0); return !seen })\n      let last = seq.last!\n\n      guard !isPalindrome(last) || seen else {\n        return\n      }\n\n      res.seen.formUnion(seq)\n\n      if seq.count == 500 {\n        res.seeds.insert(cur)\n      } else {\n        res.related.insert(cur)\n      }\n  })\n\nprint(\"Found \\(seeds.count + related.count) Lychrel numbers between 1...10_000 when limited to 500 iterations\")\nprint(\"Number of Lychrel seeds found: \\(seeds.count)\")\nprint(\"Lychrel seeds found: \\(seeds.sorted())\")\nprint(\"Number of related Lychrel nums found: \\(related.count)\")\nprint(\"Lychrel palindromes found: \\(seeds.union(related).filter(isPalindrome).sorted())\")\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class Lychrel {\n\n    static Map<BigInteger, Tuple> cache = new HashMap<>();\n\n    static class Tuple {\n        final Boolean flag;\n        final BigInteger bi;\n\n        Tuple(boolean f, BigInteger b) {\n            flag = f;\n            bi = b;\n        }\n    }\n\n    static BigInteger rev(BigInteger bi) {\n        String s = new StringBuilder(bi.toString()).reverse().toString();\n        return new BigInteger(s);\n    }\n\n    static Tuple lychrel(BigInteger n) {\n        Tuple res;\n        if ((res = cache.get(n)) != null)\n            return res;\n\n        BigInteger r = rev(n);\n        res = new Tuple(true, n);\n        List<BigInteger> seen = new ArrayList<>();\n\n        for (int i = 0; i < 500; i++) {\n            n = n.add(r);\n            r = rev(n);\n\n            if (n.equals(r)) {\n                res = new Tuple(false, BigInteger.ZERO);\n                break;\n            }\n\n            if (cache.containsKey(n)) {\n                res = cache.get(n);\n                break;\n            }\n\n            seen.add(n);\n        }\n\n        for (BigInteger bi : seen)\n            cache.put(bi, res);\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n\n        List<BigInteger> seeds = new ArrayList<>();\n        List<BigInteger> related = new ArrayList<>();\n        List<BigInteger> palin = new ArrayList<>();\n\n        for (int i = 1; i <= 10_000; i++) {\n            BigInteger n = BigInteger.valueOf(i);\n\n            Tuple t = lychrel(n);\n\n            if (!t.flag)\n                continue;\n\n            if (n.equals(t.bi))\n                seeds.add(t.bi);\n            else\n                related.add(t.bi);\n\n            if (n.equals(t.bi))\n                palin.add(t.bi);\n        }\n\n        System.out.printf(\"%d Lychrel seeds: %s%n\", seeds.size(), seeds);\n        System.out.printf(\"%d Lychrel related%n\", related.size());\n        System.out.printf(\"%d Lychrel palindromes: %s%n\", palin.size(), palin);\n    }\n}\n"}
{"id": 392585, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Swift to Java: let ld10 = log(2.0) / log(10.0)\n\nfunc p(L: Int, n: Int) -> Int {\n  var l = L\n  var digits = 1\n\n  while l >= 10 {\n    digits *= 10\n    l /= 10\n  }\n\n  var count = 0\n  var i = 0\n\n  while count < n {\n    let rhs = (Double(i) * ld10).truncatingRemainder(dividingBy: 1)\n    let e = exp(log(10.0) * rhs)\n\n    if Int(e * Double(digits)) == L {\n      count += 1\n    }\n\n    i += 1\n  }\n\n  return i - 1\n}\n\nlet cases = [\n  (12, 1),\n  (12, 2),\n  (123, 45),\n  (123, 12345),\n  (123, 678910)\n]\n\nfor (l, n) in cases {\n  print(\"p(\\(l), \\(n)) = \\(p(L: l, n: n))\")\n}\n", "target": "public class FirstPowerOfTwo {\n\n    public static void main(String[] args) {\n        runTest(12, 1);\n        runTest(12, 2);\n        runTest(123, 45);\n        runTest(123, 12345);\n        runTest(123, 678910);\n    }\n    \n    private static void runTest(int l, int n) {\n        System.out.printf(\"p(%d, %d) =\u00a0%,d%n\", l, n, p(l, n));\n    }\n    \n    public static int p(int l, int n) {\n        int test = 0;\n        double log = Math.log(2) / Math.log(10);\n        int factor = 1;\n        int loop = l;\n        while ( loop > 10 ) {\n            factor *= 10;\n            loop /= 10;\n        }\n        while ( n > 0) {\n            test++;\n            int val = (int) (factor * Math.pow(10, test * log % 1));\n            if ( val == l ) {\n                n--;\n            }\n        }\n        return test;\n    }\n    \n}\n"}
{"id": 392586, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Swift to Java: let ld10 = log(2.0) / log(10.0)\n\nfunc p(L: Int, n: Int) -> Int {\n  var l = L\n  var digits = 1\n\n  while l >= 10 {\n    digits *= 10\n    l /= 10\n  }\n\n  var count = 0\n  var i = 0\n\n  while count < n {\n    let rhs = (Double(i) * ld10).truncatingRemainder(dividingBy: 1)\n    let e = exp(log(10.0) * rhs)\n\n    if Int(e * Double(digits)) == L {\n      count += 1\n    }\n\n    i += 1\n  }\n\n  return i - 1\n}\n\nlet cases = [\n  (12, 1),\n  (12, 2),\n  (123, 45),\n  (123, 12345),\n  (123, 678910)\n]\n\nfor (l, n) in cases {\n  print(\"p(\\(l), \\(n)) = \\(p(L: l, n: n))\")\n}\n", "target": "public class FirstPowerOfTwo {\n\n    public static void main(String[] args) {\n        runTest(12, 1);\n        runTest(12, 2);\n        runTest(123, 45);\n        runTest(123, 12345);\n        runTest(123, 678910);\n    }\n    \n    private static void runTest(int l, int n) {\n        System.out.printf(\"p(%d, %d) =\u00a0%,d%n\", l, n, p(l, n));\n    }\n    \n    public static int p(int l, int n) {\n        int test = 0;\n        double log = Math.log(2) / Math.log(10);\n        int factor = 1;\n        int loop = l;\n        while ( loop > 10 ) {\n            factor *= 10;\n            loop /= 10;\n        }\n        while ( n > 0) {\n            test++;\n            int val = (int) (factor * Math.pow(10, test * log % 1));\n            if ( val == l ) {\n                n--;\n            }\n        }\n        return test;\n    }\n    \n}\n"}
{"id": 392587, "name": "Pierpont primes", "source": "Translate Swift to Java: import BigInt\nimport Foundation\n\npublic func pierpoint(n: Int) -> (first: [BigInt], second: [BigInt]) {\n  var primes = (first: [BigInt](repeating: 0, count: n), second: [BigInt](repeating: 0, count: n))\n\n  primes.first[0] = 2\n\n  var count1 = 1, count2 = 0\n  var s = [BigInt(1)]\n  var i2 = 0, i3 = 0, k = 1\n  var n2 = BigInt(0), n3 = BigInt(0), t = BigInt(0)\n\n  while min(count1, count2) < n {\n    n2 = s[i2] * 2\n    n3 = s[i3] * 3\n\n    if n2 < n3 {\n      t = n2\n      i2 += 1\n    } else {\n      t = n3\n      i3 += 1\n    }\n\n    if t <= s[k - 1] {\n      continue\n    }\n\n    s.append(t)\n    k += 1\n    t += 1\n\n    if count1 < n && t.isPrime(rounds: 10) {\n      primes.first[count1] = t\n      count1 += 1\n    }\n\n    t -= 2\n\n    if count2 < n && t.isPrime(rounds: 10) {\n      primes.second[count2] = t\n      count2 += 1\n    }\n  }\n\n  return primes\n}\n\n\nlet primes = pierpoint(n: 250)\n\nprint(\"First 50 Pierpoint primes of the first kind: \\(Array(primes.first.prefix(50)))\\n\")\nprint(\"First 50 Pierpoint primes of the second kind: \\(Array(primes.second.prefix(50)))\")\nprint()\nprint(\"250th Pierpoint prime of the first kind: \\(primes.first[249])\")\nprint(\"250th Pierpoint prime of the second kind: \\(primes.second[249])\")\n", "target": "import java.math.BigInteger;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PierpontPrimes {\n\n    public static void main(String[] args) {\n        NumberFormat nf = NumberFormat.getNumberInstance();\n        display(\"First 50 Pierpont primes of the first kind:\", pierpontPrimes(50, true));\n        display(\"First 50 Pierpont primes of the second kind:\", pierpontPrimes(50, false));\n        System.out.printf(\"250th Pierpont prime of the first kind:     %s%n%n\", nf.format(pierpontPrimes(250, true).get(249)));\n        System.out.printf(\"250th Pierpont prime of the second kind: %s%n%n\", nf.format(pierpontPrimes(250, false).get(249)));\n    }\n    \n    private static void display(String message, List<BigInteger> primes) {\n        NumberFormat nf = NumberFormat.getNumberInstance();\n        System.out.printf(\"%s%n\", message);\n        for ( int i = 1 ; i <= primes.size() ; i++ ) {\n            System.out.printf(\"%10s  \", nf.format(primes.get(i-1)));\n            if ( i % 10 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n        System.out.printf(\"%n\");\n    }\n\n    public static List<BigInteger> pierpontPrimes(int n, boolean first) {\n        List<BigInteger> primes = new ArrayList<BigInteger>();\n        if ( first ) {\n            primes.add(BigInteger.valueOf(2));\n            n -= 1;\n        }\n\n        BigInteger two = BigInteger.valueOf(2);\n        BigInteger twoTest = two;\n        BigInteger three = BigInteger.valueOf(3);\n        BigInteger threeTest = three;\n        int twoIndex = 0, threeIndex = 0;\n        List<BigInteger> twoSmooth = new ArrayList<BigInteger>();\n\n        BigInteger one = BigInteger.ONE;\n        BigInteger mOne = BigInteger.valueOf(-1);\n        int count = 0;\n        while ( count < n ) {\n            BigInteger min = twoTest.min(threeTest);\n            twoSmooth.add(min);\n            if ( min.compareTo(twoTest) == 0 ) {\n                twoTest = two.multiply(twoSmooth.get(twoIndex));\n                twoIndex++;\n            }\n            if ( min.compareTo(threeTest) == 0 ) {\n                threeTest = three.multiply(twoSmooth.get(threeIndex));\n                threeIndex++;\n            }\n            BigInteger test = min.add(first ? one : mOne);\n            if ( test.isProbablePrime(10) ) {\n                primes.add(test);\n                count++;\n            }\n        }\n        return primes;\n    }\n    \n}\n"}
{"id": 392588, "name": "N-smooth numbers", "source": "Translate Swift to Java: import BigInt\nimport Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) {\n      if self % i == 0 {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\n@inlinable\npublic func smoothN<T: BinaryInteger>(n: T, count: Int) -> [T] {\n  let primes = stride(from: 2, to: n + 1, by: 1).filter({ $0.isPrime })\n  var next = primes\n  var indices = [Int](repeating: 0, count: primes.count)\n  var res = [T](repeating: 0, count: count)\n\n  res[0] = 1\n\n  guard count > 1 else {\n    return res\n  }\n\n  for m in 1..<count {\n    res[m] = next.min()!\n\n    for i in 0..<indices.count where res[m] == next[i] {\n      indices[i] += 1\n      next[i] = primes[i] * res[indices[i]]\n    }\n  }\n\n  return res\n}\n\nfor n in 2...29 where n.isPrime {\n  print(\"The first 25 \\(n)-smooth numbers are: \\(smoothN(n: n, count: 25))\")\n}\n\nprint()\n\nfor n in 3...29 where n.isPrime {\n  print(\"The 3000...3002 \\(n)-smooth numbers are: \\(smoothN(n: BigInt(n), count: 3002).dropFirst(2999).prefix(3))\")\n}\n\nprint()\n\nfor n in 503...521 where n.isPrime {\n  print(\"The 30,000...30,019 \\(n)-smooth numbers are: \\(smoothN(n: BigInt(n), count: 30_019).dropFirst(29999).prefix(20))\")\n}\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class NSmoothNumbers {\n\n    public static void main(String[] args) {\n        System.out.printf(\"show the first 25 n-smooth numbers for n = 2 through n = 29%n\");\n        int max = 25;\n        List<BigInteger> primes = new ArrayList<>();\n        for ( int n = 2 ; n <= 29 ; n++ ) {\n            if ( isPrime(n) ) {\n                primes.add(BigInteger.valueOf(n));\n                System.out.printf(\"The first %d %d-smooth numbers:%n\", max, n);\n                BigInteger[] humble = nSmooth(max, primes.toArray(new BigInteger[0]));\n                for ( int i = 0 ; i < max ; i++ ) {\n                    System.out.printf(\"%s \", humble[i]);\n                }\n                System.out.printf(\"%n%n\");\n            }\n        }\n        \n        System.out.printf(\"show three numbers starting with 3,000 for n-smooth numbers for n = 3 through n = 29%n\");\n        int count = 3;\n        max = 3000 + count - 1;\n        primes = new ArrayList<>();\n        primes.add(BigInteger.valueOf(2));\n        for ( int n = 3 ; n <= 29 ; n++ ) {\n            if ( isPrime(n) ) {\n                primes.add(BigInteger.valueOf(n));\n                System.out.printf(\"The %d through %d %d-smooth numbers:%n\", max-count+1, max, n);\n                BigInteger[] nSmooth = nSmooth(max, primes.toArray(new BigInteger[0]));\n                for ( int i = max-count ; i < max ; i++ ) {\n                    System.out.printf(\"%s \", nSmooth[i]);\n                }\n                System.out.printf(\"%n%n\");\n            }\n        }\n        \n        System.out.printf(\"Show twenty numbers starting with 30,000 n-smooth numbers for n=503 through n=521%n\");\n        count = 20;\n        max = 30000 + count - 1;\n        primes = new ArrayList<>();\n        for ( int n = 2 ; n <= 521 ; n++ ) {\n            if ( isPrime(n) ) {\n                primes.add(BigInteger.valueOf(n));\n                if ( n >= 503 && n <= 521 ) {\n                    System.out.printf(\"The %d through %d %d-smooth numbers:%n\", max-count+1, max, n);\n                    BigInteger[] nSmooth = nSmooth(max, primes.toArray(new BigInteger[0]));\n                    for ( int i = max-count ; i < max ; i++ ) {\n                        System.out.printf(\"%s \", nSmooth[i]);\n                    }\n                    System.out.printf(\"%n%n\");\n                }\n            }\n        }\n\n    }\n\n    private static final boolean isPrime(long test) {\n        if ( test == 2 ) {\n            return true;\n        }\n        if ( test % 2 == 0 ) return false;\n        for ( long i = 3 ; i <= Math.sqrt(test) ; i += 2 ) {\n            if ( test % i == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static BigInteger[] nSmooth(int n, BigInteger[] primes) {\n        int size = primes.length;\n        BigInteger[] test = new BigInteger[size];\n        for ( int i = 0 ; i < size ; i++ ) {\n            test[i] = primes[i];\n        }\n        BigInteger[] results = new BigInteger[n];\n        results[0] = BigInteger.ONE;\n        \n        int[] indexes = new int[size];\n        for ( int i = 0 ; i < size ; i++ ) {\n            indexes[i] = 0;\n        }\n        \n        for ( int index = 1 ; index < n ; index++ ) {\n            BigInteger min = test[0];\n            for ( int i = 1 ; i < size ; i++ ) {\n                min = min.min(test[i]);\n            }\n            results[index] = min;\n            \n            for ( int i = 0 ; i < size ; i++ ) {\n                if ( results[index].compareTo(test[i]) == 0 ) {\n                    indexes[i] = indexes[i] + 1;\n                    test[i] = primes[i].multiply(results[indexes[i]]);\n                }\n            }\n        }\n        return results;\n    }\n\n}\n"}
{"id": 392589, "name": "Partition an integer x into n primes", "source": "Translate Swift to Java: import Foundation\n\nclass BitArray {\n    var array: [UInt32]\n\n    init(size: Int) {\n        array = Array(repeating: 0, count: (size + 31)/32)\n    }\n    \n    func get(index: Int) -> Bool {\n        let bit = UInt32(1) << (index & 31)\n        return (array[index >> 5] & bit) != 0\n    }\n    \n    func set(index: Int, value: Bool) {\n        let bit = UInt32(1) << (index & 31)\n        if value {\n            array[index >> 5] |= bit\n        } else {\n            array[index >> 5] &= ~bit\n        }\n    }\n}\n\nclass PrimeSieve {\n    let composite: BitArray\n    \n    init(size: Int) {\n        composite = BitArray(size: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite.get(index: p/2 - 1) {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite.set(index: q/2 - 1, value: true)\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite.get(index: number/2 - 1)\n    }\n}\n\nfunc findPrimePartition(sieve: PrimeSieve, number: Int,\n                        count: Int, minPrime: Int,\n                        primes: inout [Int], index: Int) -> Bool {\n    if count == 1 {\n        if number >= minPrime && sieve.isPrime(number: number) {\n            primes[index] = number\n            return true\n        }\n        return false\n    }\n    if minPrime >= number {\n        return false\n    }\n    for p in minPrime..<number {\n        if sieve.isPrime(number: p)\n            && findPrimePartition(sieve: sieve, number: number - p,\n                                  count: count - 1, minPrime: p + 1,\n                                  primes: &primes, index: index + 1) {\n            primes[index] = p\n            return true\n        }\n    }\n    return false\n}\n\nfunc printPrimePartition(sieve: PrimeSieve, number: Int, count: Int) {\n    var primes = Array(repeating: 0, count: count)\n    if !findPrimePartition(sieve: sieve, number: number, count: count,\n                           minPrime: 2, primes: &primes, index: 0) {\n        print(\"\\(number) cannot be partitioned into \\(count) primes.\")\n    } else {\n        print(\"\\(number) = \\(primes[0])\", terminator: \"\")\n        for i in 1..<count {\n            print(\" + \\(primes[i])\", terminator: \"\")\n        }\n        print()\n    }\n}\n\nlet sieve = PrimeSieve(size: 100000)\nprintPrimePartition(sieve: sieve, number: 99809, count: 1)\nprintPrimePartition(sieve: sieve, number: 18, count: 2)\nprintPrimePartition(sieve: sieve, number: 19, count: 3)\nprintPrimePartition(sieve: sieve, number: 20, count: 4)\nprintPrimePartition(sieve: sieve, number: 2017, count: 24)\nprintPrimePartition(sieve: sieve, number: 22699, count: 1)\nprintPrimePartition(sieve: sieve, number: 22699, count: 2)\nprintPrimePartition(sieve: sieve, number: 22699, count: 3)\nprintPrimePartition(sieve: sieve, number: 22699, count: 4)\nprintPrimePartition(sieve: sieve, number: 40355, count: 3)\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class PartitionInteger {\n    private static final int[] primes = IntStream.concat(IntStream.of(2), IntStream.iterate(3, n -> n + 2))\n        .filter(PartitionInteger::isPrime)\n        .limit(50_000)\n        .toArray();\n\n    private static boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d * d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    private static boolean findCombo(int k, int x, int m, int n, int[] combo) {\n        boolean foundCombo = false;\n        if (k >= m) {\n            if (Arrays.stream(combo).map(i -> primes[i]).sum() == x) {\n                String s = m > 1 ? \"s\" : \"\";\n                System.out.printf(\"Partitioned %5d with %2d prime%s: \", x, m, s);\n                for (int i = 0; i < m; ++i) {\n                    System.out.print(primes[combo[i]]);\n                    if (i < m - 1) System.out.print('+');\n                    else System.out.println();\n                }\n                foundCombo = true;\n            }\n        } else {\n            for (int j = 0; j < n; ++j) {\n                if (k == 0 || j > combo[k - 1]) {\n                    combo[k] = j;\n                    if (!foundCombo) {\n                        foundCombo = findCombo(k + 1, x, m, n, combo);\n                    }\n                }\n            }\n        }\n        return foundCombo;\n    }\n\n    private static void partition(int x, int m) {\n        if (x < 2 || m < 1 || m >= x) {\n            throw new IllegalArgumentException();\n        }\n        int[] filteredPrimes = Arrays.stream(primes).filter(it -> it <= x).toArray();\n        int n = filteredPrimes.length;\n        if (n < m) throw new IllegalArgumentException(\"Not enough primes\");\n        int[] combo = new int[m];\n        boolean foundCombo = findCombo(0, x, m, n, combo);\n        if (!foundCombo) {\n            String s = m > 1 ? \"s\" : \" \";\n            System.out.printf(\"Partitioned %5d with %2d prime%s: (not possible)\\n\", x, m, s);\n        }\n    }\n\n    public static void main(String[] args) {\n        partition(99809, 1);\n        partition(18, 2);\n        partition(19, 3);\n        partition(20, 4);\n        partition(2017, 24);\n        partition(22699, 1);\n        partition(22699, 2);\n        partition(22699, 3);\n        partition(22699, 4);\n        partition(40355, 3);\n    }\n}\n"}
{"id": 392590, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Swift to Java: struct Point: CustomStringConvertible {\n    let x: Double, y: Double\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nfunc perpendicularDistance(p: Point, p1: Point, p2: Point) -> Double {\n    let dx = p2.x - p1.x\n    let dy = p2.y - p1.y\n    let d = (p.x * dy - p.y * dx + p2.x * p1.y - p2.y * p1.x)\n    return abs(d)/(dx * dx + dy * dy).squareRoot()\n}\n\nfunc ramerDouglasPeucker(points: [Point], epsilon: Double) -> [Point] {\n    var result : [Point] = []\n    func rdp(begin: Int, end: Int) {\n        guard end > begin else {\n            return\n        }\n        var maxDist = 0.0\n        var index = 0\n        for i in begin+1..<end {\n            let dist = perpendicularDistance(p: points[i], p1: points[begin],\n                                             p2: points[end])\n            if dist > maxDist {\n                maxDist = dist\n                index = i\n            }\n        }\n        if maxDist > epsilon {\n            rdp(begin: begin, end: index)\n            rdp(begin: index, end: end)\n        } else {\n            result.append(points[end])\n        }\n    }\n    if points.count > 0 && epsilon >= 0.0 {\n        result.append(points[0])\n        rdp(begin: 0, end: points.count - 1)\n    }\n    return result\n}\n\nlet points = [\n    Point(x: 0.0, y: 0.0),\n    Point(x: 1.0, y: 0.1),\n    Point(x: 2.0, y: -0.1),\n    Point(x: 3.0, y: 5.0),\n    Point(x: 4.0, y: 6.0),\n    Point(x: 5.0, y: 7.0),\n    Point(x: 6.0, y: 8.1),\n    Point(x: 7.0, y: 9.0),\n    Point(x: 8.0, y: 9.0),\n    Point(x: 9.0, y: 9.0)\n]\nprint(\"\\(ramerDouglasPeucker(points: points, epsilon: 1.0))\")\n", "target": "import javafx.util.Pair;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LineSimplification {\n    private static class Point extends Pair<Double, Double> {\n        Point(Double key, Double value) {\n            super(key, value);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", getKey(), getValue());\n        }\n    }\n\n    private static double perpendicularDistance(Point pt, Point lineStart, Point lineEnd) {\n        double dx = lineEnd.getKey() - lineStart.getKey();\n        double dy = lineEnd.getValue() - lineStart.getValue();\n\n        \n        double mag = Math.hypot(dx, dy);\n        if (mag > 0.0) {\n            dx /= mag;\n            dy /= mag;\n        }\n        double pvx = pt.getKey() - lineStart.getKey();\n        double pvy = pt.getValue() - lineStart.getValue();\n\n        \n        double pvdot = dx * pvx + dy * pvy;\n\n        \n        double ax = pvx - pvdot * dx;\n        double ay = pvy - pvdot * dy;\n\n        return Math.hypot(ax, ay);\n    }\n\n    private static void ramerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> out) {\n        if (pointList.size() < 2) throw new IllegalArgumentException(\"Not enough points to simplify\");\n\n        \n        double dmax = 0.0;\n        int index = 0;\n        int end = pointList.size() - 1;\n        for (int i = 1; i < end; ++i) {\n            double d = perpendicularDistance(pointList.get(i), pointList.get(0), pointList.get(end));\n            if (d > dmax) {\n                index = i;\n                dmax = d;\n            }\n        }\n\n        \n        if (dmax > epsilon) {\n            List<Point> recResults1 = new ArrayList<>();\n            List<Point> recResults2 = new ArrayList<>();\n            List<Point> firstLine = pointList.subList(0, index + 1);\n            List<Point> lastLine = pointList.subList(index, pointList.size());\n            ramerDouglasPeucker(firstLine, epsilon, recResults1);\n            ramerDouglasPeucker(lastLine, epsilon, recResults2);\n\n            \n            out.addAll(recResults1.subList(0, recResults1.size() - 1));\n            out.addAll(recResults2);\n            if (out.size() < 2) throw new RuntimeException(\"Problem assembling output\");\n        } else {\n            \n            out.clear();\n            out.add(pointList.get(0));\n            out.add(pointList.get(pointList.size() - 1));\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Point> pointList = List.of(\n                new Point(0.0, 0.0),\n                new Point(1.0, 0.1),\n                new Point(2.0, -0.1),\n                new Point(3.0, 5.0),\n                new Point(4.0, 6.0),\n                new Point(5.0, 7.0),\n                new Point(6.0, 8.1),\n                new Point(7.0, 9.0),\n                new Point(8.0, 9.0),\n                new Point(9.0, 9.0)\n        );\n        List<Point> pointListOut = new ArrayList<>();\n        ramerDouglasPeucker(pointList, 1.0, pointListOut);\n        System.out.println(\"Points remaining after simplification:\");\n        pointListOut.forEach(System.out::println);\n    }\n}\n"}
{"id": 392591, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Swift to Java: struct Point: CustomStringConvertible {\n    let x: Double, y: Double\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nfunc perpendicularDistance(p: Point, p1: Point, p2: Point) -> Double {\n    let dx = p2.x - p1.x\n    let dy = p2.y - p1.y\n    let d = (p.x * dy - p.y * dx + p2.x * p1.y - p2.y * p1.x)\n    return abs(d)/(dx * dx + dy * dy).squareRoot()\n}\n\nfunc ramerDouglasPeucker(points: [Point], epsilon: Double) -> [Point] {\n    var result : [Point] = []\n    func rdp(begin: Int, end: Int) {\n        guard end > begin else {\n            return\n        }\n        var maxDist = 0.0\n        var index = 0\n        for i in begin+1..<end {\n            let dist = perpendicularDistance(p: points[i], p1: points[begin],\n                                             p2: points[end])\n            if dist > maxDist {\n                maxDist = dist\n                index = i\n            }\n        }\n        if maxDist > epsilon {\n            rdp(begin: begin, end: index)\n            rdp(begin: index, end: end)\n        } else {\n            result.append(points[end])\n        }\n    }\n    if points.count > 0 && epsilon >= 0.0 {\n        result.append(points[0])\n        rdp(begin: 0, end: points.count - 1)\n    }\n    return result\n}\n\nlet points = [\n    Point(x: 0.0, y: 0.0),\n    Point(x: 1.0, y: 0.1),\n    Point(x: 2.0, y: -0.1),\n    Point(x: 3.0, y: 5.0),\n    Point(x: 4.0, y: 6.0),\n    Point(x: 5.0, y: 7.0),\n    Point(x: 6.0, y: 8.1),\n    Point(x: 7.0, y: 9.0),\n    Point(x: 8.0, y: 9.0),\n    Point(x: 9.0, y: 9.0)\n]\nprint(\"\\(ramerDouglasPeucker(points: points, epsilon: 1.0))\")\n", "target": "import javafx.util.Pair;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LineSimplification {\n    private static class Point extends Pair<Double, Double> {\n        Point(Double key, Double value) {\n            super(key, value);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", getKey(), getValue());\n        }\n    }\n\n    private static double perpendicularDistance(Point pt, Point lineStart, Point lineEnd) {\n        double dx = lineEnd.getKey() - lineStart.getKey();\n        double dy = lineEnd.getValue() - lineStart.getValue();\n\n        \n        double mag = Math.hypot(dx, dy);\n        if (mag > 0.0) {\n            dx /= mag;\n            dy /= mag;\n        }\n        double pvx = pt.getKey() - lineStart.getKey();\n        double pvy = pt.getValue() - lineStart.getValue();\n\n        \n        double pvdot = dx * pvx + dy * pvy;\n\n        \n        double ax = pvx - pvdot * dx;\n        double ay = pvy - pvdot * dy;\n\n        return Math.hypot(ax, ay);\n    }\n\n    private static void ramerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> out) {\n        if (pointList.size() < 2) throw new IllegalArgumentException(\"Not enough points to simplify\");\n\n        \n        double dmax = 0.0;\n        int index = 0;\n        int end = pointList.size() - 1;\n        for (int i = 1; i < end; ++i) {\n            double d = perpendicularDistance(pointList.get(i), pointList.get(0), pointList.get(end));\n            if (d > dmax) {\n                index = i;\n                dmax = d;\n            }\n        }\n\n        \n        if (dmax > epsilon) {\n            List<Point> recResults1 = new ArrayList<>();\n            List<Point> recResults2 = new ArrayList<>();\n            List<Point> firstLine = pointList.subList(0, index + 1);\n            List<Point> lastLine = pointList.subList(index, pointList.size());\n            ramerDouglasPeucker(firstLine, epsilon, recResults1);\n            ramerDouglasPeucker(lastLine, epsilon, recResults2);\n\n            \n            out.addAll(recResults1.subList(0, recResults1.size() - 1));\n            out.addAll(recResults2);\n            if (out.size() < 2) throw new RuntimeException(\"Problem assembling output\");\n        } else {\n            \n            out.clear();\n            out.add(pointList.get(0));\n            out.add(pointList.get(pointList.size() - 1));\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Point> pointList = List.of(\n                new Point(0.0, 0.0),\n                new Point(1.0, 0.1),\n                new Point(2.0, -0.1),\n                new Point(3.0, 5.0),\n                new Point(4.0, 6.0),\n                new Point(5.0, 7.0),\n                new Point(6.0, 8.1),\n                new Point(7.0, 9.0),\n                new Point(8.0, 9.0),\n                new Point(9.0, 9.0)\n        );\n        List<Point> pointListOut = new ArrayList<>();\n        ramerDouglasPeucker(pointList, 1.0, pointListOut);\n        System.out.println(\"Points remaining after simplification:\");\n        pointListOut.forEach(System.out::println);\n    }\n}\n"}
{"id": 392592, "name": "Chebyshev coefficients", "source": "Translate Swift to Java: import Foundation\n\ntypealias DFunc = (Double) -> Double\n\nfunc mapRange(x: Double, min: Double, max: Double, minTo: Double, maxTo: Double) -> Double {\n  return (x - min) / (max - min) * (maxTo - minTo) + minTo\n}\n\nfunc chebCoeffs(fun: DFunc, n: Int, min: Double, max: Double) -> [Double] {\n  var res = [Double](repeating: 0, count: n)\n\n  for i in 0..<n {\n    let dI = Double(i)\n    let dN = Double(n)\n    let f = fun(mapRange(x: cos(.pi * (dI + 0.5) / dN), min: -1, max: 1, minTo: min, maxTo: max)) * 2.0 / dN\n\n    for j in 0..<n {\n      res[j] += f * cos(.pi * Double(j) * (dI + 0.5) / dN)\n    }\n  }\n\n  return res\n}\n\nfunc chebApprox(x: Double, n: Int, min: Double, max: Double, coeffs: [Double]) -> Double {\n  var a = 1.0\n  var b = mapRange(x: x, min: min, max: max, minTo: -1, maxTo: 1)\n  var res = coeffs[0] / 2.0 + coeffs[1] * b\n  let xx = 2 * b\n  var i = 2\n\n  while i < n {\n    let c = xx * b - a\n    res += coeffs[i] * c\n    (a, b) = (b, c)\n    i += 1\n  }\n\n  return res\n}\n\nlet coeffs = chebCoeffs(fun: cos, n: 10, min: 0, max: 1)\n\nprint(\"Coefficients\")\n\nfor coeff in coeffs {\n  print(String(format: \"%+1.15g\", coeff))\n}\n\nprint(\"\\nApproximations:\\n  x      func(x)     approx       diff\")\n\nfor i in stride(from: 0.0, through: 20, by: 1) {\n  let x = mapRange(x: i, min: 0, max: 20, minTo: 0, maxTo: 1)\n  let f = cos(x)\n  let approx = chebApprox(x: x, n: 10, min: 0, max: 1, coeffs: coeffs)\n\n  print(String(format: \"%1.3f  %1.8f  %1.8f \u00a0% 4.1e\", x, f, approx, approx - f))\n}\n", "target": "import static java.lang.Math.*;\nimport java.util.function.Function;\n\npublic class ChebyshevCoefficients {\n\n    static double map(double x, double min_x, double max_x, double min_to,\n            double max_to) {\n        return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to;\n    }\n\n    static void chebyshevCoef(Function<Double, Double> func, double min,\n            double max, double[] coef) {\n\n        int N = coef.length;\n\n        for (int i = 0; i < N; i++) {\n\n            double m = map(cos(PI * (i + 0.5f) / N), -1, 1, min, max);\n            double f = func.apply(m) * 2 / N;\n\n            for (int j = 0; j < N; j++) {\n                coef[j] += f * cos(PI * j * (i + 0.5f) / N);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        final int N = 10;\n        double[] c = new double[N];\n        double min = 0, max = 1;\n        chebyshevCoef(x -> cos(x), min, max, c);\n\n        System.out.println(\"Coefficients:\");\n        for (double d : c)\n            System.out.println(d);\n    }\n}\n"}
{"id": 392593, "name": "Chebyshev coefficients", "source": "Translate Swift to Java: import Foundation\n\ntypealias DFunc = (Double) -> Double\n\nfunc mapRange(x: Double, min: Double, max: Double, minTo: Double, maxTo: Double) -> Double {\n  return (x - min) / (max - min) * (maxTo - minTo) + minTo\n}\n\nfunc chebCoeffs(fun: DFunc, n: Int, min: Double, max: Double) -> [Double] {\n  var res = [Double](repeating: 0, count: n)\n\n  for i in 0..<n {\n    let dI = Double(i)\n    let dN = Double(n)\n    let f = fun(mapRange(x: cos(.pi * (dI + 0.5) / dN), min: -1, max: 1, minTo: min, maxTo: max)) * 2.0 / dN\n\n    for j in 0..<n {\n      res[j] += f * cos(.pi * Double(j) * (dI + 0.5) / dN)\n    }\n  }\n\n  return res\n}\n\nfunc chebApprox(x: Double, n: Int, min: Double, max: Double, coeffs: [Double]) -> Double {\n  var a = 1.0\n  var b = mapRange(x: x, min: min, max: max, minTo: -1, maxTo: 1)\n  var res = coeffs[0] / 2.0 + coeffs[1] * b\n  let xx = 2 * b\n  var i = 2\n\n  while i < n {\n    let c = xx * b - a\n    res += coeffs[i] * c\n    (a, b) = (b, c)\n    i += 1\n  }\n\n  return res\n}\n\nlet coeffs = chebCoeffs(fun: cos, n: 10, min: 0, max: 1)\n\nprint(\"Coefficients\")\n\nfor coeff in coeffs {\n  print(String(format: \"%+1.15g\", coeff))\n}\n\nprint(\"\\nApproximations:\\n  x      func(x)     approx       diff\")\n\nfor i in stride(from: 0.0, through: 20, by: 1) {\n  let x = mapRange(x: i, min: 0, max: 20, minTo: 0, maxTo: 1)\n  let f = cos(x)\n  let approx = chebApprox(x: x, n: 10, min: 0, max: 1, coeffs: coeffs)\n\n  print(String(format: \"%1.3f  %1.8f  %1.8f \u00a0% 4.1e\", x, f, approx, approx - f))\n}\n", "target": "import static java.lang.Math.*;\nimport java.util.function.Function;\n\npublic class ChebyshevCoefficients {\n\n    static double map(double x, double min_x, double max_x, double min_to,\n            double max_to) {\n        return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to;\n    }\n\n    static void chebyshevCoef(Function<Double, Double> func, double min,\n            double max, double[] coef) {\n\n        int N = coef.length;\n\n        for (int i = 0; i < N; i++) {\n\n            double m = map(cos(PI * (i + 0.5f) / N), -1, 1, min, max);\n            double f = func.apply(m) * 2 / N;\n\n            for (int j = 0; j < N; j++) {\n                coef[j] += f * cos(PI * j * (i + 0.5f) / N);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        final int N = 10;\n        double[] c = new double[N];\n        double min = 0, max = 1;\n        chebyshevCoef(x -> cos(x), min, max, c);\n\n        System.out.println(\"Coefficients:\");\n        for (double d : c)\n            System.out.println(d);\n    }\n}\n"}
{"id": 392594, "name": "Burrows\u2013Wheeler transform", "source": "Translate Swift to Java: import Foundation\n\nprivate let stx = \"\\u{2}\"\nprivate let etx = \"\\u{3}\"\n\nfunc bwt(_ str: String) -> String? {\n  guard !str.contains(stx), !str.contains(etx) else {\n    return nil\n  }\n\n  let ss = stx + str + etx\n  let table = ss.indices.map({i in ss[i...] + ss[ss.startIndex..<i] }).sorted()\n\n  return String(table.map({str in str.last!}))\n}\n\nfunc ibwt(_ str: String) -> String? {\n  let len = str.count\n  var table = Array(repeating: \"\", count: len)\n\n  for _ in 0..<len {\n    for i in 0..<len {\n      table[i] = String(str[str.index(str.startIndex, offsetBy: i)]) + table[i]\n    }\n\n    table.sort()\n  }\n\n  for row in table where row.hasSuffix(etx) {\n    return String(row.dropFirst().dropLast())\n  }\n\n  return nil\n}\n\n\nfunc readableBwt(_ str: String) -> String {\n  return str.replacingOccurrences(of: \"\\u{2}\", with: \"^\").replacingOccurrences(of: \"\\u{3}\", with: \"|\")\n}\n\nlet testCases = [\n  \"banana\",\n  \"appellee\",\n  \"dogwood\",\n  \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n  \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n  \"\\u{2}ABC\\u{3}\"\n]\n\nfor test in testCases {\n  let b = bwt(test) ?? \"error\"\n  let c = ibwt(b) ?? \"error\"\n\n  print(\"\\(readableBwt(test)) -> \\(readableBwt(b)) -> \\(readableBwt(c))\")\n}\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class BWT {\n    private static final String STX = \"\\u0002\";\n    private static final String ETX = \"\\u0003\";\n\n    private static String bwt(String s) {\n        if (s.contains(STX) || s.contains(ETX)) {\n            throw new IllegalArgumentException(\"String cannot contain STX or ETX\");\n        }\n\n        String ss = STX + s + ETX;\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < ss.length(); i++) {\n            String before = ss.substring(i);\n            String after = ss.substring(0, i);\n            table.add(before + after);\n        }\n        table.sort(String::compareTo);\n\n        StringBuilder sb = new StringBuilder();\n        for (String str : table) {\n            sb.append(str.charAt(str.length() - 1));\n        }\n        return sb.toString();\n    }\n\n    private static String ibwt(String r) {\n        int len = r.length();\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < len; ++i) {\n            table.add(\"\");\n        }\n        for (int j = 0; j < len; ++j) {\n            for (int i = 0; i < len; ++i) {\n                table.set(i, r.charAt(i) + table.get(i));\n            }\n            table.sort(String::compareTo);\n        }\n        for (String row : table) {\n            if (row.endsWith(ETX)) {\n                return row.substring(1, len - 1);\n            }\n        }\n        return \"\";\n    }\n\n    private static String makePrintable(String s) {\n        \n        return s.replace(STX, \"^\").replace(ETX, \"|\");\n    }\n\n    public static void main(String[] args) {\n        List<String> tests = List.of(\n            \"banana\",\n            \"appellee\",\n            \"dogwood\",\n            \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n            \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n            \"\\u0002ABC\\u0003\"\n        );\n        for (String test : tests) {\n            System.out.println(makePrintable(test));\n            System.out.print(\" --> \");\n            String t = \"\";\n            try {\n                t = bwt(test);\n                System.out.println(makePrintable(t));\n            } catch (IllegalArgumentException e) {\n                System.out.println(\"ERROR: \" + e.getMessage());\n            }\n            String r = ibwt(t);\n            System.out.printf(\" --> %s\\n\\n\", r);\n        }\n    }\n}\n"}
{"id": 392595, "name": "Burrows\u2013Wheeler transform", "source": "Translate Swift to Java: import Foundation\n\nprivate let stx = \"\\u{2}\"\nprivate let etx = \"\\u{3}\"\n\nfunc bwt(_ str: String) -> String? {\n  guard !str.contains(stx), !str.contains(etx) else {\n    return nil\n  }\n\n  let ss = stx + str + etx\n  let table = ss.indices.map({i in ss[i...] + ss[ss.startIndex..<i] }).sorted()\n\n  return String(table.map({str in str.last!}))\n}\n\nfunc ibwt(_ str: String) -> String? {\n  let len = str.count\n  var table = Array(repeating: \"\", count: len)\n\n  for _ in 0..<len {\n    for i in 0..<len {\n      table[i] = String(str[str.index(str.startIndex, offsetBy: i)]) + table[i]\n    }\n\n    table.sort()\n  }\n\n  for row in table where row.hasSuffix(etx) {\n    return String(row.dropFirst().dropLast())\n  }\n\n  return nil\n}\n\n\nfunc readableBwt(_ str: String) -> String {\n  return str.replacingOccurrences(of: \"\\u{2}\", with: \"^\").replacingOccurrences(of: \"\\u{3}\", with: \"|\")\n}\n\nlet testCases = [\n  \"banana\",\n  \"appellee\",\n  \"dogwood\",\n  \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n  \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n  \"\\u{2}ABC\\u{3}\"\n]\n\nfor test in testCases {\n  let b = bwt(test) ?? \"error\"\n  let c = ibwt(b) ?? \"error\"\n\n  print(\"\\(readableBwt(test)) -> \\(readableBwt(b)) -> \\(readableBwt(c))\")\n}\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class BWT {\n    private static final String STX = \"\\u0002\";\n    private static final String ETX = \"\\u0003\";\n\n    private static String bwt(String s) {\n        if (s.contains(STX) || s.contains(ETX)) {\n            throw new IllegalArgumentException(\"String cannot contain STX or ETX\");\n        }\n\n        String ss = STX + s + ETX;\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < ss.length(); i++) {\n            String before = ss.substring(i);\n            String after = ss.substring(0, i);\n            table.add(before + after);\n        }\n        table.sort(String::compareTo);\n\n        StringBuilder sb = new StringBuilder();\n        for (String str : table) {\n            sb.append(str.charAt(str.length() - 1));\n        }\n        return sb.toString();\n    }\n\n    private static String ibwt(String r) {\n        int len = r.length();\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < len; ++i) {\n            table.add(\"\");\n        }\n        for (int j = 0; j < len; ++j) {\n            for (int i = 0; i < len; ++i) {\n                table.set(i, r.charAt(i) + table.get(i));\n            }\n            table.sort(String::compareTo);\n        }\n        for (String row : table) {\n            if (row.endsWith(ETX)) {\n                return row.substring(1, len - 1);\n            }\n        }\n        return \"\";\n    }\n\n    private static String makePrintable(String s) {\n        \n        return s.replace(STX, \"^\").replace(ETX, \"|\");\n    }\n\n    public static void main(String[] args) {\n        List<String> tests = List.of(\n            \"banana\",\n            \"appellee\",\n            \"dogwood\",\n            \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n            \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n            \"\\u0002ABC\\u0003\"\n        );\n        for (String test : tests) {\n            System.out.println(makePrintable(test));\n            System.out.print(\" --> \");\n            String t = \"\";\n            try {\n                t = bwt(test);\n                System.out.println(makePrintable(t));\n            } catch (IllegalArgumentException e) {\n                System.out.println(\"ERROR: \" + e.getMessage());\n            }\n            String r = ibwt(t);\n            System.out.printf(\" --> %s\\n\\n\", r);\n        }\n    }\n}\n"}
{"id": 392596, "name": "Lucky and even lucky numbers", "source": "Translate Swift to Java: struct LuckyNumbers : Sequence, IteratorProtocol {\n  let even: Bool\n  let through: Int\n  \n  private var drainI = 0\n  private var n = 0\n  private var lst: [Int]\n  \n  init(even: Bool = false, through: Int = 1_000_000) {\n    self.even = even\n    self.through = through\n    self.lst = Array(stride(from: even ? 2 : 1, through: through, by: 2))\n  }\n  \n  mutating func next() -> Int? {\n    guard n != 0 else {\n      defer { n += 1 }\n      \n      return lst[0]\n    }\n    \n    while n < lst.count && lst[n] < lst.count {\n      let retVal = lst[n]\n      \n      lst = lst.enumerated().filter({ ($0.offset + 1) % lst[n] != 0  }).map({ $0.element })\n      n += 1\n      \n      return retVal\n    }\n    \n    if drainI == 0 {\n      lst = Array(lst.dropFirst(n))\n    }\n\n    while drainI < lst.count {\n      defer { drainI += 1 }\n      \n      return lst[drainI]\n    }\n    \n    return nil\n  }\n}\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class LuckyNumbers {\n\n    private static int MAX = 200000;\n    private static List<Integer> luckyEven = luckyNumbers(MAX, true);\n    private static List<Integer> luckyOdd = luckyNumbers(MAX, false);\n    \n    public static void main(String[] args) {\n        \n        if ( args.length == 1 || ( args.length == 2 && args[1].compareTo(\"lucky\") == 0 ) ) {\n            int n = Integer.parseInt(args[0]);\n            System.out.printf(\"LuckyNumber(%d) = %d%n\", n, luckyOdd.get(n-1));\n        }\n        \n        else if ( args.length == 2 && args[1].compareTo(\"evenLucky\") == 0 ) {\n            int n = Integer.parseInt(args[0]);\n            System.out.printf(\"EvenLuckyNumber(%d) = %d%n\", n, luckyEven.get(n-1));            \n        }\n        \n        else if ( args.length == 2 || args.length == 3 ) {\n            int j = Integer.parseInt(args[0]);\n            int k = Integer.parseInt(args[1]);\n            \n            if ( ( args.length == 2 && k > 0 ) || (args.length == 3 && k > 0 && args[2].compareTo(\"lucky\") == 0 ) ) {\n                System.out.printf(\"LuckyNumber(%d) through LuckyNumber(%d) = %s%n\", j, k, luckyOdd.subList(j-1, k));\n            }\n            \n            else if ( args.length == 3 && k > 0 && args[2].compareTo(\"evenLucky\") == 0 ) {\n                System.out.printf(\"EvenLuckyNumber(%d) through EvenLuckyNumber(%d) = %s%n\", j, k, luckyEven.subList(j-1, k));\n            }\n            \n            else if ( ( args.length == 2 && k < 0 ) || (args.length == 3 && k < 0 && args[2].compareTo(\"lucky\") == 0 ) ) {\n                int n = Collections.binarySearch(luckyOdd, j);\n                int m = Collections.binarySearch(luckyOdd, -k);\n                System.out.printf(\"Lucky Numbers in the range %d to %d inclusive = %s%n\", j, -k, luckyOdd.subList(n < 0 ? -n-1 : n, m < 0 ? -m-1 : m+1));\n            }\n            \n            else if ( args.length == 3 && k < 0 && args[2].compareTo(\"evenLucky\") == 0 ) {\n                int n = Collections.binarySearch(luckyEven, j);\n                int m = Collections.binarySearch(luckyEven, -k);\n                System.out.printf(\"Even Lucky Numbers in the range %d to %d inclusive = %s%n\", j, -k, luckyEven.subList(n < 0 ? -n-1 : n, m < 0 ? -m-1 : m+1));\n            }\n        }\n    }\n    \n    private static List<Integer> luckyNumbers(int max, boolean even) {\n        List<Integer> luckyList = new ArrayList<>();\n        for ( int i = even ? 2 : 1 ; i <= max ; i += 2 ) {\n            luckyList.add(i);\n        }\n        int start = 1;\n        boolean removed = true;\n        while ( removed ) {\n            removed = false;\n            int increment = luckyList.get(start);\n            List<Integer> remove = new ArrayList<>();\n            for ( int i = increment-1 ; i < luckyList.size() ; i += increment ) {\n                remove.add(0, i);\n                removed = true;\n            }\n            for ( int i : remove ) {\n                luckyList.remove(i);\n            }\n            start++;\n        }\n        return luckyList;\n    }\n\n}\n"}
{"id": 392597, "name": "Peaceful chess queen armies", "source": "Translate Swift to Java: enum Piece {\n  case empty, black, white\n}\n\ntypealias Position = (Int, Int)\n\nfunc place(_ m: Int, _ n: Int, pBlackQueens: inout [Position], pWhiteQueens: inout [Position]) -> Bool {\n  guard m != 0 else {\n    return true\n  }\n\n  var placingBlack = true\n\n  for i in 0..<n {\n    inner: for j in 0..<n {\n      let pos = (i, j)\n\n      for queen in pBlackQueens where queen == pos || !placingBlack && isAttacking(queen, pos) {\n        continue inner\n      }\n\n      for queen in pWhiteQueens where queen == pos || placingBlack && isAttacking(queen, pos) {\n        continue inner\n      }\n\n      if placingBlack {\n        pBlackQueens.append(pos)\n        placingBlack = false\n      } else {\n        placingBlack = true\n\n        pWhiteQueens.append(pos)\n\n        if place(m - 1, n, pBlackQueens: &pBlackQueens, pWhiteQueens: &pWhiteQueens) {\n          return true\n        } else {\n          pBlackQueens.removeLast()\n          pWhiteQueens.removeLast()\n        }\n      }\n    }\n  }\n\n  if !placingBlack {\n    pBlackQueens.removeLast()\n  }\n\n  return false\n}\n\nfunc isAttacking(_ queen: Position, _ pos: Position) -> Bool {\n  queen.0 == pos.0 || queen.1 == pos.1 || abs(queen.0 - pos.0) == abs(queen.1 - pos.1)\n}\n\nfunc printBoard(n: Int, pBlackQueens: [Position], pWhiteQueens: [Position]) {\n  var board = Array(repeating: Piece.empty, count: n * n)\n\n  for queen in pBlackQueens {\n    board[queen.0 * n + queen.1] = .black\n  }\n\n  for queen in pWhiteQueens {\n    board[queen.0 * n + queen.1] = .white\n  }\n\n  for (i, p) in board.enumerated() {\n    if i != 0 && i % n == 0 {\n      print()\n    }\n\n    switch p {\n    case .black:\n      print(\"B \", terminator: \"\")\n    case .white:\n      print(\"W \", terminator: \"\")\n    case .empty:\n      let j = i / n\n      let k = i - j * n\n\n      if j % 2 == k % 2 {\n        print(\"\u2022 \", terminator: \"\")\n      } else {\n        print(\"\u25e6 \", terminator: \"\")\n      }\n    }\n  }\n\n  print(\"\\n\")\n}\n\nlet nms = [\n  (2, 1), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3),\n  (5, 1), (5, 2), (5, 3), (5, 4), (5, 5),\n  (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6),\n  (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7)\n]\n\nfor (n, m) in nms {\n  print(\"\\(m) black and white queens on \\(n) x \\(n) board\")\n\n  var blackQueens = [Position]()\n  var whiteQueens = [Position]()\n\n  if place(m, n, pBlackQueens: &blackQueens, pWhiteQueens: &whiteQueens) {\n    printBoard(n: n, pBlackQueens: blackQueens, pWhiteQueens: whiteQueens)\n  } else {\n    print(\"No solution\")\n  }\n}\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Peaceful {\n    enum Piece {\n        Empty,\n        Black,\n        White,\n    }\n\n    public static class Position {\n        public int x, y;\n\n        public Position(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof Position) {\n                Position pos = (Position) obj;\n                return pos.x == x && pos.y == y;\n            }\n            return false;\n        }\n    }\n\n    private static boolean place(int m, int n, List<Position> pBlackQueens, List<Position> pWhiteQueens) {\n        if (m == 0) {\n            return true;\n        }\n        boolean placingBlack = true;\n        for (int i = 0; i < n; ++i) {\n            inner:\n            for (int j = 0; j < n; ++j) {\n                Position pos = new Position(i, j);\n                for (Position queen : pBlackQueens) {\n                    if (pos.equals(queen) || !placingBlack && isAttacking(queen, pos)) {\n                        continue inner;\n                    }\n                }\n                for (Position queen : pWhiteQueens) {\n                    if (pos.equals(queen) || placingBlack && isAttacking(queen, pos)) {\n                        continue inner;\n                    }\n                }\n                if (placingBlack) {\n                    pBlackQueens.add(pos);\n                    placingBlack = false;\n                } else {\n                    pWhiteQueens.add(pos);\n                    if (place(m - 1, n, pBlackQueens, pWhiteQueens)) {\n                        return true;\n                    }\n                    pBlackQueens.remove(pBlackQueens.size() - 1);\n                    pWhiteQueens.remove(pWhiteQueens.size() - 1);\n                    placingBlack = true;\n                }\n            }\n        }\n        if (!placingBlack) {\n            pBlackQueens.remove(pBlackQueens.size() - 1);\n        }\n        return false;\n    }\n\n    private static boolean isAttacking(Position queen, Position pos) {\n        return queen.x == pos.x\n            || queen.y == pos.y\n            || Math.abs(queen.x - pos.x) == Math.abs(queen.y - pos.y);\n    }\n\n    private static void printBoard(int n, List<Position> blackQueens, List<Position> whiteQueens) {\n        Piece[] board = new Piece[n * n];\n        Arrays.fill(board, Piece.Empty);\n\n        for (Position queen : blackQueens) {\n            board[queen.x + n * queen.y] = Piece.Black;\n        }\n        for (Position queen : whiteQueens) {\n            board[queen.x + n * queen.y] = Piece.White;\n        }\n        for (int i = 0; i < board.length; ++i) {\n            if ((i != 0) && i % n == 0) {\n                System.out.println();\n            }\n\n            Piece b = board[i];\n            if (b == Piece.Black) {\n                System.out.print(\"B \");\n            } else if (b == Piece.White) {\n                System.out.print(\"W \");\n            } else {\n                int j = i / n;\n                int k = i - j * n;\n                if (j % 2 == k % 2) {\n                    System.out.print(\"\u2022 \");\n                } else {\n                    System.out.print(\"\u25e6 \");\n                }\n            }\n        }\n        System.out.println('\\n');\n    }\n\n    public static void main(String[] args) {\n        List<Position> nms = List.of(\n            new Position(2, 1),\n            new Position(3, 1),\n            new Position(3, 2),\n            new Position(4, 1),\n            new Position(4, 2),\n            new Position(4, 3),\n            new Position(5, 1),\n            new Position(5, 2),\n            new Position(5, 3),\n            new Position(5, 4),\n            new Position(5, 5),\n            new Position(6, 1),\n            new Position(6, 2),\n            new Position(6, 3),\n            new Position(6, 4),\n            new Position(6, 5),\n            new Position(6, 6),\n            new Position(7, 1),\n            new Position(7, 2),\n            new Position(7, 3),\n            new Position(7, 4),\n            new Position(7, 5),\n            new Position(7, 6),\n            new Position(7, 7)\n        );\n        for (Position nm : nms) {\n            int m = nm.y;\n            int n = nm.x;\n            System.out.printf(\"%d black and %d white queens on a %d x %d board:\\n\", m, m, n, n);\n            List<Position> blackQueens = new ArrayList<>();\n            List<Position> whiteQueens = new ArrayList<>();\n            if (place(m, n, blackQueens, whiteQueens)) {\n                printBoard(n, blackQueens, whiteQueens);\n            } else {\n                System.out.println(\"No solution exists.\\n\");\n            }\n        }\n    }\n}\n"}
{"id": 392598, "name": "N-body problem", "source": "Translate Swift to Java: import Foundation\n\npublic struct Vector {\n  public var px = 0.0\n  public var py = 0.0\n  public var pz = 0.0\n\n  public init(px: Double, py: Double, pz: Double) {\n    (self.px, self.py, self.pz) = (px, py, pz)\n  }\n\n  public init?(array: [Double]) {\n    guard array.count == 3 else {\n      return nil\n    }\n\n    (self.px, self.py, self.pz) = (array[0], array[1], array[2])\n  }\n\n  public func mod() -> Double {\n    (px * px + py * py + pz * pz).squareRoot()\n  }\n\n  static func + (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      px: lhs.px + rhs.px,\n      py: lhs.py + rhs.py,\n      pz: lhs.pz + rhs.pz\n    )\n  }\n\n  static func - (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      px: lhs.px - rhs.px,\n      py: lhs.py - rhs.py,\n      pz: lhs.pz - rhs.pz\n    )\n  }\n\n  static func * (lhs: Vector, rhs: Double) -> Vector {\n    return Vector(\n      px: lhs.px * rhs,\n      py: lhs.py * rhs,\n      pz: lhs.pz * rhs\n    )\n  }\n}\n\nextension Vector {\n  public static let origin = Vector(px: 0, py: 0, pz: 0)\n}\n\nextension Vector: Equatable {\n  public static func == (lhs: Vector, rhs: Vector) -> Bool {\n    return lhs.px == rhs.px && lhs.py == rhs.py && lhs.pz == rhs.pz\n  }\n}\n\nextension Vector: CustomStringConvertible {\n  public var description: String {\n    return String(format: \"%.6f\\t%.6f\\t%.6f\", px, py, pz)\n  }\n}\n\npublic class NBody {\n  public let gravitationalConstant: Double\n  public let numBodies: Int\n  public let timeSteps: Int\n\n  public private(set) var masses: [Double]\n  public private(set) var positions: [Vector]\n  public private(set) var velocities: [Vector]\n  public private(set) var accelerations: [Vector]\n\n  public init?(file: String) {\n    guard let data = try? String(contentsOfFile: file) else {\n      return nil\n    }\n\n    print(\"Input file:\\n\\(data)\")\n\n    let lines = data.components(separatedBy: \"\\n\").map({ $0.components(separatedBy: \" \") })\n\n    let worldData = lines.first!\n\n    guard worldData.count == 3,\n          let gc = Double(worldData[0]),\n          let bodies = Int(worldData[1]),\n          let timeSteps = Int(worldData[2]) else {\n      return nil\n    }\n\n    let defaultState = Array(repeating: Vector.origin, count: bodies)\n\n    self.gravitationalConstant = gc\n    self.numBodies = bodies\n    self.timeSteps = timeSteps\n    self.masses = Array(repeating: 0, count: bodies)\n    self.positions = defaultState\n    self.accelerations = defaultState\n    self.velocities = defaultState\n\n    let bodyData = lines.dropFirst().map({ $0.compactMap(Double.init) })\n\n    guard bodyData.count == bodies * 3 else {\n      return nil\n    }\n\n    for n in 0..<bodies {\n      masses[n] = bodyData[0 + n * 3][0]\n\n      guard let position = Vector(array: bodyData[1 + n * 3]),\n            let velocity = Vector(array: bodyData[2 + n * 3]) else {\n        return nil\n      }\n\n      positions[n] = position\n      velocities[n] = velocity\n    }\n  }\n\n  private func computeAccelerations() {\n    for i in 0..<numBodies {\n      accelerations[i] = .origin\n\n      for j in 0..<numBodies where i != j {\n        let t = gravitationalConstant * masses[j] / pow((positions[i] - positions[j]).mod(), 3)\n        accelerations[i] = accelerations[i] + (positions[j] - positions[i]) * t\n      }\n    }\n  }\n\n  private func resolveCollisions() {\n    for i in 0..<numBodies {\n      for j in 0..<numBodies where positions[i] == positions[j] {\n        velocities.swapAt(i, j)\n      }\n    }\n  }\n\n  private func computeVelocities() {\n    for i in 0..<numBodies {\n      velocities[i] = velocities[i] + accelerations[i]\n    }\n  }\n\n  private func computePositions() {\n    for i in 0..<numBodies {\n      positions[i] = positions[i] + velocities[i] + accelerations[i] * 0.5\n    }\n  }\n\n  public func printState() {\n    for i in 0..<numBodies {\n      print(\"Body \\(i + 1): \\(positions[i])  |  \\(velocities[i])\")\n    }\n  }\n\n  public func simulate() {\n    computeAccelerations()\n    computePositions()\n    computeVelocities()\n    resolveCollisions()\n  }\n}\n\nguard let sim = NBody(file: \"input.txt\") else {\n  fatalError()\n}\n\nprint()\nprint(\"Body  \u00a0:      x          y          z    |     vx         vy         vz\")\n\nfor i in 0..<sim.timeSteps {\n  print(\"Step \\(i + 1)\")\n  sim.simulate()\n  sim.printState()\n  print()\n}\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class NBodySim {\n    private static class Vector3D {\n        double x, y, z;\n\n        public Vector3D(double x, double y, double z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        public Vector3D plus(Vector3D rhs) {\n            return new Vector3D(x + rhs.x, y + rhs.y, z + rhs.z);\n        }\n\n        public Vector3D minus(Vector3D rhs) {\n            return new Vector3D(x - rhs.x, y - rhs.y, z - rhs.z);\n        }\n\n        public Vector3D times(double s) {\n            return new Vector3D(s * x, s * y, s * z);\n        }\n\n        public double mod() {\n            return Math.sqrt(x * x + y * y + z * z);\n        }\n    }\n\n    private static final Vector3D origin = new Vector3D(0, 0, 0);\n\n    private static class NBody {\n        private double gc;\n        private int bodies;\n        public final int timeSteps;\n        private double[] masses;\n        private Vector3D[] positions;\n        private Vector3D[] velocities;\n        private Vector3D[] accelerations;\n\n        public NBody(String fileName) throws IOException {\n            Path path = Paths.get(fileName);\n            List<String> lines = Files.readAllLines(path);\n\n            String[] gbt = lines.get(0).split(\" \");\n            gc = Double.parseDouble(gbt[0]);\n            bodies = Integer.parseInt(gbt[1]);\n            timeSteps = Integer.parseInt(gbt[2]);\n            masses = new double[bodies];\n            positions = new Vector3D[bodies];\n            Arrays.fill(positions, origin);\n            velocities = new Vector3D[bodies];\n            Arrays.fill(velocities, origin);\n            accelerations = new Vector3D[bodies];\n            Arrays.fill(accelerations, origin);\n            for (int i = 0; i < bodies; ++i) {\n                masses[i] = Double.parseDouble(lines.get(i * 3 + 1));\n                positions[i] = decompose(lines.get(i * 3 + 2));\n                velocities[i] = decompose(lines.get(i * 3 + 3));\n            }\n            System.out.printf(\"Contents of %s\\n\", fileName);\n            for (String line : lines) {\n                System.out.println(line);\n            }\n            System.out.println();\n            System.out.print(\"Body  \u00a0:      x          y          z    |\");\n            System.out.println(\"     vx         vy         vz\");\n        }\n\n        private Vector3D decompose(String line) {\n            String[] xyz = line.split(\" \");\n            double x = Double.parseDouble(xyz[0]);\n            double y = Double.parseDouble(xyz[1]);\n            double z = Double.parseDouble(xyz[2]);\n            return new Vector3D(x, y, z);\n        }\n\n        private void resolveCollisions() {\n            for (int i = 0; i < bodies; ++i) {\n                for (int j = i + 1; j < bodies; ++j) {\n                    if (positions[i].x == positions[j].x\n                        && positions[i].y == positions[j].y\n                        && positions[i].z == positions[j].z) {\n                        Vector3D temp = velocities[i];\n                        velocities[i] = velocities[j];\n                        velocities[j] = temp;\n                    }\n                }\n            }\n        }\n\n        private void computeAccelerations() {\n            for (int i = 0; i < bodies; ++i) {\n                accelerations[i] = origin;\n                for (int j = 0; j < bodies; ++j) {\n                    if (i != j) {\n                        double temp = gc * masses[j] / Math.pow((positions[i].minus(positions[j])).mod(), 3);\n                        accelerations[i] = accelerations[i].plus(positions[j].minus(positions[i]).times(temp));\n                    }\n                }\n            }\n        }\n\n        private void computeVelocities() {\n            for (int i = 0; i < bodies; ++i) {\n                velocities[i] = velocities[i].plus(accelerations[i]);\n            }\n        }\n\n        private void computePositions() {\n            for (int i = 0; i < bodies; ++i) {\n                positions[i] = positions[i].plus(velocities[i]).plus(accelerations[i].times(0.5));\n            }\n        }\n\n        public void simulate() {\n            computeAccelerations();\n            computePositions();\n            computeVelocities();\n            resolveCollisions();\n        }\n\n        public void printResults() {\n            String fmt = \"Body %d\u00a0:\u00a0% 8.6f \u00a0% 8.6f \u00a0% 8.6f |\u00a0% 8.6f \u00a0% 8.6f \u00a0% 8.6f\\n\";\n            for (int i = 0; i < bodies; ++i) {\n                System.out.printf(\n                    fmt,\n                    i + 1,\n                    positions[i].x, positions[i].y, positions[i].z,\n                    velocities[i].x, velocities[i].y, velocities[i].z\n                );\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        String filename = \"nbody.txt\";\n        NBody nb = new NBody(filename);\n        for (int i = 0; i < nb.timeSteps; ++i) {\n            System.out.printf(\"\\nCycle %s\\n\", i + 1);\n            nb.simulate();\n            nb.printResults();\n        }\n    }\n}\n"}
{"id": 392599, "name": "Zumkeller numbers", "source": "Translate Swift to Java: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isZumkeller: Bool {\n    let divs = factors(sorted: false)\n    let sum = divs.reduce(0, +)\n\n    guard sum & 1 != 1 else {\n      return false\n    }\n\n    guard self & 1 != 1 else {\n      let abundance = sum - 2*self\n\n      return abundance > 0 && abundance & 1 == 0\n    }\n\n    return isPartSum(divs: divs[...], sum: sum / 2)\n  }\n\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@usableFromInline\nfunc isPartSum<T: BinaryInteger>(divs: ArraySlice<T>, sum: T) -> Bool {\n  guard sum != 0 else {\n    return true\n  }\n\n  guard !divs.isEmpty else {\n    return false\n  }\n\n  let last = divs.last!\n\n  if last > sum {\n    return isPartSum(divs: divs.dropLast(), sum: sum)\n  }\n\n  return isPartSum(divs: divs.dropLast(), sum: sum) || isPartSum(divs: divs.dropLast(), sum: sum - last)\n}\n\nlet zums = (2...).lazy.filter({ $0.isZumkeller })\nlet oddZums = zums.filter({ $0 & 1 == 1 })\nlet oddZumsWithout5 = oddZums.filter({ String($0).last! != \"5\" })\n\nprint(\"First 220 zumkeller numbers are \\(Array(zums.prefix(220)))\")\nprint(\"First 40 odd zumkeller numbers are \\(Array(oddZums.prefix(40)))\")\nprint(\"First 40 odd zumkeller numbers that don't end in a 5 are: \\(Array(oddZumsWithout5.prefix(40)))\")\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class ZumkellerNumbers {\n\n    public static void main(String[] args) {\n        int n = 1;\n        System.out.printf(\"First 220 Zumkeller numbers:%n\");\n        for ( int count = 1 ; count <= 220 ; n += 1 ) {\n            if ( isZumkeller(n) ) {\n                System.out.printf(\"%3d  \", n);\n                if ( count % 20 == 0 ) {\n                    System.out.printf(\"%n\");\n                }\n                count++;\n            }\n        }\n        \n        n = 1;\n        System.out.printf(\"%nFirst 40 odd Zumkeller numbers:%n\");\n        for ( int count = 1 ; count <= 40 ; n += 2 ) {\n            if ( isZumkeller(n) ) {\n                System.out.printf(\"%6d\", n);\n                if ( count % 10 == 0 ) {\n                    System.out.printf(\"%n\");\n                }\n                count++;\n            }\n        }\n        \n        n = 1;\n        System.out.printf(\"%nFirst 40 odd Zumkeller numbers that do not end in a 5:%n\");\n        for ( int count = 1 ; count <= 40 ; n += 2 ) {\n            if ( n % 5 != 0 && isZumkeller(n) ) {\n                System.out.printf(\"%8d\", n);\n                if ( count % 10 == 0 ) {\n                    System.out.printf(\"%n\");\n                }\n                count++;\n            }\n        }\n\n    }\n    \n    private static boolean isZumkeller(int n) {\n        \n        if ( n % 18 == 6 || n % 18 == 12 ) {\n            return true;\n        }\n        \n        List<Integer> divisors = getDivisors(n);        \n        int divisorSum = divisors.stream().mapToInt(i -> i.intValue()).sum();\n        \n        \n        if ( divisorSum % 2 == 1 ) {\n            return false;\n        }\n        \n        \n        int abundance = divisorSum - 2 * n;\n        if ( n % 2 == 1 && abundance > 0 && abundance % 2 == 0 ) {\n            return true;\n        }\n        \n        Collections.sort(divisors);\n        int j = divisors.size() - 1;\n        int sum = divisorSum/2;\n        \n        \n        if ( divisors.get(j) > sum ) {\n            return false;\n        }\n        \n        return canPartition(j, divisors, sum, new int[2]);\n    }\n    \n    private static boolean canPartition(int j, List<Integer> divisors, int sum, int[] buckets) {\n        if ( j < 0 ) {\n            return true;\n        }\n        for ( int i = 0 ; i < 2 ; i++ ) {\n            if ( buckets[i] + divisors.get(j) <= sum ) {\n                buckets[i] += divisors.get(j);\n                if ( canPartition(j-1, divisors, sum, buckets) ) {\n                    return true;\n                }\n                buckets[i] -= divisors.get(j);\n            }\n            if( buckets[i] == 0 ) {\n                break;\n            }\n        }\n        return false;\n    }\n    \n    private static final List<Integer> getDivisors(int number) {\n        List<Integer> divisors = new ArrayList<Integer>();\n        long sqrt = (long) Math.sqrt(number);\n        for ( int i = 1 ; i <= sqrt ; i++ ) {\n            if ( number % i == 0 ) {\n                divisors.add(i);\n                int div = number / i;\n                if ( div != i ) {\n                    divisors.add(div);\n                }\n            }\n        }\n        return divisors;\n    }\n\n}\n"}
{"id": 392600, "name": "Commatizing numbers", "source": "Translate Swift to Java: import Foundation\n\nextension String {\n  private static let commaReg = try! NSRegularExpression(pattern: \"(\\\\.[0-9]+|[1-9]([0-9]+)?(\\\\.[0-9]+)?)\")\n\n  public func commatize(start: Int = 0, period: Int = 3, separator: String = \",\") -> String {\n    guard separator != \"\" else {\n      return self\n    }\n\n    let sep = Array(separator)\n    let startIdx = index(startIndex, offsetBy: start)\n    let matches = String.commaReg.matches(in: self, range: NSRange(startIdx..., in: self))\n\n    guard !matches.isEmpty else {\n      return self\n    }\n\n    let fullMatch = String(self[Range(matches.first!.range(at: 0), in: self)!])\n    let splits = fullMatch.components(separatedBy: \".\")\n    var ip = splits[0]\n\n    if ip.count > period {\n      var builder = Array(ip.reversed())\n\n      for i in stride(from: (ip.count - 1) / period * period, through: period, by: -period) {\n        builder.insert(contentsOf: sep, at: i)\n      }\n\n      ip = String(builder.reversed())\n    }\n\n    if fullMatch.contains(\".\") {\n      var dp = splits[1]\n\n      if dp.count > period {\n        var builder = Array(dp)\n\n        for i in stride(from: (dp.count - 1) / period * period, through: period, by: -period) {\n          builder.insert(contentsOf: sep, at: i)\n        }\n\n        dp = String(builder)\n      }\n\n      ip += \".\" + dp\n    }\n\n    return String(prefix(start)) + String(dropFirst(start)).replacingOccurrences(of: fullMatch, with: ip)\n  }\n}\n\nlet tests = [\n  \"123456789.123456789\",\n  \".123456789\",\n  \"57256.1D-4\",\n  \"pi=3.14159265358979323846264338327950288419716939937510582097494459231\",\n  \"The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\",\n  \"-in Aus$+1411.8millions\",\n  \"===US$0017440 millions=== (in 2000 dollars)\",\n  \"123.e8000 is pretty big.\",\n  \"The land area of the earth is 57268900(29% of the surface) square miles.\",\n  \"Ain't no numbers in this here words, nohow, no way, Jose.\",\n  \"James was never known as 0000000007\",\n  \"Arthur Eddington wrote: I believe there are \" +\n      \"15747724136275002577605653961181555468044717914527116709366231425076185631031296\" +\n      \" protons in the universe.\",\n  \"   $-140000\u00b1100 millions.\",\n  \"6/9/1946 was a good year for some.\"\n]\n\nprint(tests[0].commatize(period: 2, separator: \"*\"))\nprint(tests[1].commatize(period: 3, separator: \"-\"))\nprint(tests[2].commatize(period: 4, separator: \"__\"))\nprint(tests[3].commatize(period: 5, separator: \" \"))\nprint(tests[4].commatize(separator: \".\"))\n\nfor testCase in tests.dropFirst(5) {\n  print(testCase.commatize())\n}\n", "target": "import java.io.File;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class CommatizingNumbers {\n\n    public static void main(String[] args) throws Exception {\n        commatize(\"pi=3.14159265358979323846264338327950288419716939937510582\"\n                + \"097494459231\", 6, 5, \" \");\n\n        commatize(\"The author has two Z$100000000000000 Zimbabwe notes (100 \"\n                + \"trillion).\", 0, 3, \".\");\n\n        try (Scanner sc = new Scanner(new File(\"input.txt\"))) {\n            while(sc.hasNext())\n                commatize(sc.nextLine());\n        }\n    }\n\n    static void commatize(String s) {\n        commatize(s, 0, 3, \",\");\n    }\n\n    static void commatize(String s, int start, int step, String ins) {\n        if (start < 0 || start > s.length() || step < 1 || step > s.length())\n            return;\n\n        Matcher m = Pattern.compile(\"([1-9][0-9]*)\").matcher(s.substring(start));\n        StringBuffer result = new StringBuffer(s.substring(0, start));\n\n        if (m.find()) {\n            StringBuilder sb = new StringBuilder(m.group(1)).reverse();\n            for (int i = step; i < sb.length(); i += step)\n                sb.insert(i++, ins);\n            m.appendReplacement(result, sb.reverse().toString());\n        }\n\n        System.out.println(m.appendTail(result));\n    }\n}\n"}
{"id": 392601, "name": "Kosaraju", "source": "Translate Swift to Java: func kosaraju(graph: [[Int]]) -> [Int] {\n  let size = graph.count\n  var x = size\n  var vis = [Bool](repeating: false, count: size)\n  var l = [Int](repeating: 0, count: size)\n  var c = [Int](repeating: 0, count: size)\n  var t = [[Int]](repeating: [], count: size)\n\n  func visit(_ u: Int) {\n    guard !vis[u] else {\n      return\n    }\n\n    vis[u] = true\n\n    for v in graph[u] {\n      visit(v)\n      t[v].append(u)\n    }\n\n    x -= 1\n    l[x] = u\n  }\n\n  for u in 0..<graph.count {\n    visit(u)\n  }\n\n  func assign(_ u: Int, root: Int) {\n    guard vis[u] else {\n      return\n    }\n\n    vis[u] = false\n    c[u] = root\n\n    for v in t[u] {\n      assign(v, root: root)\n    }\n  }\n\n  for u in l {\n    assign(u, root: u)\n  }\n\n  return c\n}\n\nlet graph = [\n  [1],\n  [2],\n  [0],\n  [1, 2, 4],\n  [3, 5],\n  [2, 6],\n  [5],\n  [4, 6, 7]\n]\n\nprint(kosaraju(graph: graph))\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.BiConsumer;\nimport java.util.function.IntConsumer;\nimport java.util.stream.Collectors;\n\npublic class Kosaraju {\n    static class Recursive<I> {\n        I func;\n    }\n\n    private static List<Integer> kosaraju(List<List<Integer>> g) {\n        \n        int size = g.size();\n        boolean[] vis = new boolean[size];\n        int[] l = new int[size];\n        AtomicInteger x = new AtomicInteger(size);\n\n        List<List<Integer>> t = new ArrayList<>();\n        for (int i = 0; i < size; ++i) {\n            t.add(new ArrayList<>());\n        }\n\n        Recursive<IntConsumer> visit = new Recursive<>();\n        visit.func = (int u) -> {\n            if (!vis[u]) {\n                vis[u] = true;\n                for (Integer v : g.get(u)) {\n                    visit.func.accept(v);\n                    t.get(v).add(u);\n                }\n                int xval = x.decrementAndGet();\n                l[xval] = u;\n            }\n        };\n\n        \n        for (int i = 0; i < size; ++i) {\n            visit.func.accept(i);\n        }\n        int[] c = new int[size];\n\n        Recursive<BiConsumer<Integer, Integer>> assign = new Recursive<>();\n        assign.func = (Integer u, Integer root) -> {\n            if (vis[u]) {  \n                vis[u] = false;\n                c[u] = root;\n                for (Integer v : t.get(u)) {\n                    assign.func.accept(v, root);\n                }\n            }\n        };\n\n        \n        for (int u : l) {\n            assign.func.accept(u, u);\n        }\n\n        return Arrays.stream(c).boxed().collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        List<List<Integer>> g = new ArrayList<>();\n        for (int i = 0; i < 8; ++i) {\n            g.add(new ArrayList<>());\n        }\n        g.get(0).add(1);\n        g.get(1).add(2);\n        g.get(2).add(0);\n        g.get(3).add(1);\n        g.get(3).add(2);\n        g.get(3).add(4);\n        g.get(4).add(3);\n        g.get(4).add(5);\n        g.get(5).add(2);\n        g.get(5).add(6);\n        g.get(6).add(5);\n        g.get(7).add(4);\n        g.get(7).add(6);\n        g.get(7).add(7);\n\n        List<Integer> output = kosaraju(g);\n        System.out.println(output);\n    }\n}\n"}
{"id": 392602, "name": "Markov chain text generator", "source": "Translate Swift to Java: import Foundation\n\nfunc makeRule(input: String, keyLength: Int) -> [String: [String]] {\n  let words = input.components(separatedBy: \" \")\n  var rules = [String: [String]]()\n  var i = keyLength\n  \n  for word in words[i...] {\n    let key = words[i-keyLength..<i].joined(separator: \" \")\n    \n    rules[key, default: []].append(word)\n    \n    i += 1\n  }\n  \n  return rules\n}\n\nfunc makeString(rule: [String: [String]], length: Int) -> String {\n  var oldWords = rule.keys.randomElement()!.components(separatedBy: \" \")\n  var string = oldWords.joined(separator: \" \") + \" \"\n  \n  for _ in 0..<length {\n    let key = oldWords.joined(separator: \" \")\n    guard let newWord = rule[key]?.randomElement() else { return string }\n    \n    string += newWord + \" \"\n    \n    for ii in 0..<oldWords.count {\n      oldWords[ii] = oldWords[(ii + 1) % oldWords.count]\n    }\n    \n    oldWords[oldWords.index(before: oldWords.endIndex)] = newWord\n  }\n  \n  return string\n}\n\nlet inputLoc = CommandLine.arguments.dropFirst().first!\nlet input = FileManager.default.contents(atPath: inputLoc)!\nlet inputStr = String(data: input, encoding: .utf8)!\nlet rule = makeRule(input: inputStr, keyLength: 3)\nlet str = makeString(rule: rule, length: 300)\n\nprint(str)\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Random;\n\npublic class MarkovChain {\n    private static Random r = new Random();\n\n    private static String markov(String filePath, int keySize, int outputSize) throws IOException {\n        if (keySize < 1) throw new IllegalArgumentException(\"Key size can't be less than 1\");\n        Path path = Paths.get(filePath);\n        byte[] bytes = Files.readAllBytes(path);\n        String[] words = new String(bytes).trim().split(\" \");\n        if (outputSize < keySize || outputSize >= words.length) {\n            throw new IllegalArgumentException(\"Output size is out of range\");\n        }\n        Map<String, List<String>> dict = new HashMap<>();\n\n        for (int i = 0; i < (words.length - keySize); ++i) {\n            StringBuilder key = new StringBuilder(words[i]);\n            for (int j = i + 1; j < i + keySize; ++j) {\n                key.append(' ').append(words[j]);\n            }\n            String value = (i + keySize < words.length) ? words[i + keySize] : \"\";\n            if (!dict.containsKey(key.toString())) {\n                ArrayList<String> list = new ArrayList<>();\n                list.add(value);\n                dict.put(key.toString(), list);\n            } else {\n                dict.get(key.toString()).add(value);\n            }\n        }\n\n        int n = 0;\n        int rn = r.nextInt(dict.size());\n        String prefix = (String) dict.keySet().toArray()[rn];\n        List<String> output = new ArrayList<>(Arrays.asList(prefix.split(\" \")));\n\n        while (true) {\n            List<String> suffix = dict.get(prefix);\n            if (suffix.size() == 1) {\n                if (Objects.equals(suffix.get(0), \"\")) return output.stream().reduce(\"\", (a, b) -> a + \" \" + b);\n                output.add(suffix.get(0));\n            } else {\n                rn = r.nextInt(suffix.size());\n                output.add(suffix.get(rn));\n            }\n            if (output.size() >= outputSize) return output.stream().limit(outputSize).reduce(\"\", (a, b) -> a + \" \" + b);\n            n++;\n            prefix = output.stream().skip(n).limit(keySize).reduce(\"\", (a, b) -> a + \" \" + b).trim();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        System.out.println(markov(\"alice_oz.txt\", 3, 200));\n    }\n}\n"}
{"id": 392603, "name": "Word break problem", "source": "Translate Swift to Java: infix operator ??= : AssignmentPrecedence\n\n@inlinable\npublic func ??= <T>(lhs: inout T?, rhs: T?) {\n  lhs = lhs ?? rhs\n}\n\nprivate func createString(_ from: String, _ v: [Int?]) -> String {\n  var idx = from.count\n  var sliceVec = [Substring]()\n\n  while let prev = v[idx] {\n    let s = from.index(from.startIndex, offsetBy: prev)\n    let e = from.index(from.startIndex, offsetBy: idx)\n    \n    sliceVec.append(from[s..<e])\n    idx = prev\n  }\n\n  return sliceVec.reversed().joined(separator: \" \")\n}\n\npublic func wordBreak(str: String, dict: Set<String>) -> String? {\n  let size = str.count + 1\n  var possible = [Int?](repeating: nil, count: size)\n\n  func checkWord(i: Int, j: Int) -> Int? {\n    let s = str.index(str.startIndex, offsetBy: i)\n    let e = str.index(str.startIndex, offsetBy: j)\n\n    return dict.contains(String(str[s..<e])) ? i : nil\n  }\n\n  for i in 1..<size {\n    possible[i] ??= checkWord(i: 0, j: i)\n\n    guard possible[i] != nil else {\n      continue\n    }\n\n    for j in i+1..<size {\n      possible[j] ??= checkWord(i: i, j: j)\n    }\n\n    if possible[str.count] != nil {\n      return createString(str, possible)\n    }\n  }\n\n  return nil\n}\n\nlet words = [\n  \"a\",\n  \"bc\",\n  \"abc\",\n  \"cd\",\n  \"b\"\n] as Set\n\nlet testCases = [\n  \"abcd\",\n  \"abbc\",\n  \"abcbcd\",\n  \"acdbc\",\n  \"abcdd\"\n]\n\nfor test in testCases {\n  print(\"\\(test):\")\n  print(\"  \\(wordBreak(str: test, dict: words) ?? \"did not parse with given words\")\")\n}\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class WordBreak {\n\n    public static void main(String[] args) {\n        List<String> dict = Arrays.asList(\"a\", \"aa\", \"b\", \"ab\", \"aab\");\n        for ( String testString : Arrays.asList(\"aab\", \"aa b\") ) {\n            List<List<String>> matches = wordBreak(testString, dict);\n            System.out.printf(\"String = %s, Dictionary = %s.  Solutions = %d:%n\", testString, dict, matches.size());\n            for ( List<String> match : matches ) {\n                System.out.printf(\" Word Break = %s%n\", match);\n            }\n            System.out.printf(\"%n\");\n        }\n        dict = Arrays.asList(\"abc\", \"a\", \"ac\", \"b\", \"c\", \"cb\", \"d\");\n        for ( String testString : Arrays.asList(\"abcd\", \"abbc\", \"abcbcd\", \"acdbc\", \"abcdd\") ) {\n            List<List<String>> matches = wordBreak(testString, dict);\n            System.out.printf(\"String = %s, Dictionary = %s.  Solutions = %d:%n\", testString, dict, matches.size());\n            for ( List<String> match : matches ) {\n                System.out.printf(\" Word Break = %s%n\", match);\n            }\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    private static List<List<String>> wordBreak(String s, List<String> dictionary) {\n        List<List<String>> matches = new ArrayList<>();\n        Queue<Node> queue = new LinkedList<>();\n        queue.add(new Node(s));\n        while ( ! queue.isEmpty() ) {\n            Node node = queue.remove();\n            \n            if ( node.val.length() == 0 ) {\n                matches.add(node.parsed);\n            }\n            else {\n                for ( String word : dictionary ) {\n                    \n                    if ( node.val.startsWith(word) ) {\n                        String valNew = node.val.substring(word.length(), node.val.length());\n                        List<String> parsedNew = new ArrayList<>();\n                        parsedNew.addAll(node.parsed);\n                        parsedNew.add(word);\n                        queue.add(new Node(valNew, parsedNew));\n                    }\n                }\n            }\n        }\n        return matches;\n    }\n    \n    private static class Node {\n        private String val;  \n        private List<String> parsed;  \n        public Node(String initial) {\n            val = initial;\n            parsed = new ArrayList<>();\n        }\n        public Node(String s, List<String> p) {\n            val = s;\n            parsed = p;\n        }\n    }\n\n}\n"}
{"id": 392604, "name": "Partition function P", "source": "Translate Swift to Java: import BigInt \n\nfunc partitions(n: Int) -> BigInt {\n  var p = [BigInt(1)]\n\n  for i in 1...n {\n    var num = BigInt(0)\n    var k = 1\n\n    while true {\n      var j = (k * (3 * k - 1)) / 2\n\n      if j > i {\n        break\n      }\n\n      if k & 1 == 1 {\n        num += p[i - j]\n      } else {\n        num -= p[i - j]\n      }\n\n      j += k\n\n      if j > i {\n        break\n      }\n\n      if k & 1 == 1 {\n        num += p[i - j]\n      } else {\n        num -= p[i - j]\n      }\n\n      k += 1\n    }\n\n    p.append(num)\n  }\n\n  return p[n]\n}\n\nprint(\"partitions(6666) = \\(partitions(n: 6666))\")\n", "target": "import java.math.BigInteger;\n\npublic class PartitionFunction {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        BigInteger result = partitions(6666);\n        long end = System.currentTimeMillis();\n        System.out.println(\"P(6666) = \" + result);\n        System.out.printf(\"elapsed time: %d milliseconds\\n\", end - start);\n    }\n\n    private static BigInteger partitions(int n) {\n        BigInteger[] p = new BigInteger[n + 1];\n        p[0] = BigInteger.ONE;\n        for (int i = 1; i <= n; ++i) {\n            p[i] = BigInteger.ZERO;\n            for (int k = 1; ; ++k) {\n                int j = (k * (3 * k - 1))/2;\n                if (j > i)\n                    break;\n                if ((k & 1) != 0)\n                    p[i] = p[i].add(p[i - j]);\n                else\n                    p[i] = p[i].subtract(p[i - j]);\n                j += k;\n                if (j > i)\n                    break;\n                if ((k & 1) != 0)\n                    p[i] = p[i].add(p[i - j]);\n                else\n                    p[i] = p[i].subtract(p[i - j]);\n            }\n        }\n        return p[n];\n    }\n}\n"}
{"id": 392605, "name": "Legendre prime counting function", "source": "Translate Swift to Java: import Foundation\n\nextension Numeric where Self: Strideable {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nfunc eratosthenes(limit: Int) -> [Int] {\n  guard limit >= 3 else {\n    return limit < 2 ? [] : [2]\n  }\n\n  let ndxLimit = (limit - 3) / 2 + 1\n  let bufSize = ((limit - 3) / 2) / 32 + 1\n  let sqrtNdxLimit = (Int(Double(limit).squareRoot()) - 3) / 2 + 1\n  var cmpsts = Array(repeating: 0, count: bufSize)\n\n  for ndx in 0..<sqrtNdxLimit where (cmpsts[ndx >> 5] & (1 << (ndx & 31))) == 0 {\n    let p = ndx + ndx + 3\n    var cullPos = (p * p - 3) / 2\n\n    while cullPos < ndxLimit {\n      cmpsts[cullPos >> 5] |= 1 << (cullPos & 31)\n\n      cullPos += p\n    }\n  }\n\n  return (-1..<ndxLimit).compactMap({i -> Int? in\n    if i < 0 {\n      return 2\n    } else {\n      if cmpsts[i >> 5] & (1 << (i & 31)) == 0 {\n        return .some(i + i + 3)\n      } else {\n        return nil\n      }\n    }\n  })\n}\n\nlet primes = eratosthenes(limit: 1_000_000_000)\n\nfunc \u03c6(_ x: Int, _ a: Int) -> Int {\n  struct Cache {\n    static var cache = [String: Int]()\n  }\n\n  guard a != 0 else {\n    return x\n  }\n\n  guard Cache.cache[\"\\(x),\\(a)\"] == nil else {\n    return Cache.cache[\"\\(x),\\(a)\"]!\n  }\n\n  Cache.cache[\"\\(x),\\(a)\"] = \u03c6(x, a - 1) - \u03c6(x / primes[a - 1], a - 1)\n\n  return Cache.cache[\"\\(x),\\(a)\"]!\n}\n\nfunc \u03c0(n: Int) -> Int {\n  guard n > 2 else {\n    return 0\n  }\n\n  let a = \u03c0(n: Int(Double(n).squareRoot()))\n\n  return \u03c6(n, a) + a - 1\n}\n\nfor i in 0..<10 {\n  let n = 10.power(i)\n\n  print(\"\u03c0(10^\\(i)) = \\(\u03c0(n: n))\")\n}\n", "target": "import java.util.*;\n\npublic class LegendrePrimeCounter {\n    public static void main(String[] args) {\n        LegendrePrimeCounter counter = new LegendrePrimeCounter(1000000000);\n        for (int i = 0, n = 1; i < 10; ++i, n *= 10)\n            System.out.printf(\"10^%d\\t%d\\n\", i, counter.primeCount((n)));\n    }\n\n    private List<Integer> primes;\n\n    public LegendrePrimeCounter(int limit) {\n        primes = generatePrimes((int)Math.sqrt((double)limit));\n    }\n\n    public int primeCount(int n) {\n        if (n < 2)\n            return 0;\n        int a = primeCount((int)Math.sqrt((double)n));\n        return phi(n, a) + a - 1;\n    }\n\n    private int phi(int x, int a) {\n        if (a == 0)\n            return x;\n        if (a == 1)\n            return x - (x >> 1);\n        int pa = primes.get(a - 1);\n        if (x <= pa)\n            return 1;\n        return phi(x, a - 1) - phi(x / pa, a - 1);\n    }\n\n    private static List<Integer> generatePrimes(int limit) {\n        boolean[] sieve = new boolean[limit >> 1];\n        Arrays.fill(sieve, true);\n        for (int p = 3, s = 9; s < limit; p += 2) {\n            if (sieve[p >> 1]) {\n                for (int q = s; q < limit; q += p << 1)\n                    sieve[q >> 1] = false;\n            }\n            s += (p + 1) << 2;\n        }\n        List<Integer> primes = new ArrayList<>();\n        if (limit > 2)\n            primes.add(2);\n        for (int i = 1; i < sieve.length; ++i) {\n            if (sieve[i])\n                primes.add((i << 1) + 1);\n        } \n        return primes;\n    }\n}\n"}
{"id": 392606, "name": "Permuted multiples", "source": "Translate Swift to Java: func getDigits(_ num: Int) -> Array<Int> {\n    var n = num\n    var digits = Array(repeating: 0, count: 10)\n    while true {\n        digits[n % 10] += 1\n        n /= 10\n        if n == 0 {\n            break\n        }\n    }\n    return digits\n}\n\n\nfunc sameDigits(_ n: Int) -> Bool {\n    let digits = getDigits(n)\n    for i in 2...6 {\n        if digits != getDigits(i * n) {\n            return false\n        }\n    }\n    return true\n}\n\nvar p = 100\nloop: while true {\n    for n in stride(from: p + 2, through: (p * 10) / 6, by: 3) {\n        if sameDigits(n) {\n            print(\" n = \\(n)\")\n            for i in 2...6 {\n                print(\"\\(i)n = \\(i * n)\")\n            }\n            break loop\n        }\n    }\n    p *= 10\n}\n", "target": "import java.util.*;\n\npublic class PermutedMultiples {\n    public static void main(String[] args) {\n        for (int p = 100; ; p *= 10) {\n            int max = (p * 10) / 6;\n            for (int n = p + 2; n <= max; n += 3) {\n                if (sameDigits(n)) {\n                    System.out.printf(\" n = %d\\n\", n);\n                    for (int i = 2; i <= 6; ++i)\n                        System.out.printf(\"%dn = %d\\n\", i, n * i);\n                    return;\n                }\n            }\n        }\n    }\n\n    \n    private static boolean sameDigits(int n) {\n        int[] digits = getDigits(n);\n        for (int i = 0, m = n; i < 5; ++i) {\n            m += n;\n            if (!Arrays.equals(getDigits(m), digits))\n                return false;\n        }\n        return true;\n    }\n\n    private static int[] getDigits(int n) {\n        int[] digits = new int[10];\n        do {\n            ++digits[n % 10];\n            n /= 10;\n        } while (n > 0);\n        return digits;\n    }\n}\n"}
{"id": 392607, "name": "Permuted multiples", "source": "Translate Swift to Java: func getDigits(_ num: Int) -> Array<Int> {\n    var n = num\n    var digits = Array(repeating: 0, count: 10)\n    while true {\n        digits[n % 10] += 1\n        n /= 10\n        if n == 0 {\n            break\n        }\n    }\n    return digits\n}\n\n\nfunc sameDigits(_ n: Int) -> Bool {\n    let digits = getDigits(n)\n    for i in 2...6 {\n        if digits != getDigits(i * n) {\n            return false\n        }\n    }\n    return true\n}\n\nvar p = 100\nloop: while true {\n    for n in stride(from: p + 2, through: (p * 10) / 6, by: 3) {\n        if sameDigits(n) {\n            print(\" n = \\(n)\")\n            for i in 2...6 {\n                print(\"\\(i)n = \\(i * n)\")\n            }\n            break loop\n        }\n    }\n    p *= 10\n}\n", "target": "import java.util.*;\n\npublic class PermutedMultiples {\n    public static void main(String[] args) {\n        for (int p = 100; ; p *= 10) {\n            int max = (p * 10) / 6;\n            for (int n = p + 2; n <= max; n += 3) {\n                if (sameDigits(n)) {\n                    System.out.printf(\" n = %d\\n\", n);\n                    for (int i = 2; i <= 6; ++i)\n                        System.out.printf(\"%dn = %d\\n\", i, n * i);\n                    return;\n                }\n            }\n        }\n    }\n\n    \n    private static boolean sameDigits(int n) {\n        int[] digits = getDigits(n);\n        for (int i = 0, m = n; i < 5; ++i) {\n            m += n;\n            if (!Arrays.equals(getDigits(m), digits))\n                return false;\n        }\n        return true;\n    }\n\n    private static int[] getDigits(int n) {\n        int[] digits = new int[10];\n        do {\n            ++digits[n % 10];\n            n /= 10;\n        } while (n > 0);\n        return digits;\n    }\n}\n"}
{"id": 392608, "name": "Prime triangle", "source": "Translate Swift to Java: import Foundation\n\nfunc isPrime(_ n: Int) -> Bool {\n    guard n > 0 && n < 64 else {\n        return false\n    }\n    return ((UInt64(1) << n) & 0x28208a20a08a28ac) != 0\n}\n\nfunc primeTriangleRow(_ a: inout [Int], start: Int, length: Int) -> Bool {\n    if length == 2 {\n        return isPrime(a[start] + a[start + 1])\n    }\n    for i in stride(from: 1, to: length - 1, by: 2) {\n        let index = start + i\n        if isPrime(a[start] + a[index]) {\n            a.swapAt(index, start + 1)\n            if primeTriangleRow(&a, start: start + 1, length: length - 1) {\n                return true\n            }\n            a.swapAt(index, start + 1)\n        }\n    }\n    return false\n}\n\nfunc primeTriangleCount(_ a: inout [Int], start: Int, length: Int) -> Int {\n    var count = 0\n    if length == 2 {\n        if isPrime(a[start] + a[start + 1]) {\n            count += 1\n        }\n    } else {\n        for i in stride(from: 1, to: length - 1, by: 2) {\n            let index = start + i\n            if isPrime(a[start] + a[index]) {\n                a.swapAt(index, start + 1)\n                count += primeTriangleCount(&a, start: start + 1, length: length - 1)\n                a.swapAt(index, start + 1)\n            }\n        }\n    }\n    return count\n}\n\nfunc printRow(_ a: [Int]) {\n    if a.count == 0 {\n        return\n    }\n    print(String(format: \"%2d\", a[0]), terminator: \"\")\n    for x in a[1...] {\n        print(String(format: \" %2d\", x), terminator: \"\")\n    }\n    print()\n}\n\nlet startTime = CFAbsoluteTimeGetCurrent()\n\nfor n in 2...20 {\n    var a = Array(1...n)\n    if primeTriangleRow(&a, start: 0, length: n) {\n        printRow(a)\n    }\n}\nprint()\n\nfor n in 2...20 {\n    var a = Array(1...n)\n    if n > 2 {\n        print(\" \", terminator: \"\")\n    }\n    print(\"\\(primeTriangleCount(&a, start: 0, length: n))\", terminator: \"\")\n}\nprint()\n\nlet endTime = CFAbsoluteTimeGetCurrent()\nprint(\"\\nElapsed time: \\(endTime - startTime) seconds\")\n", "target": "public class PrimeTriangle {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        for (int i = 2; i <= 20; ++i) {\n            int[] a = new int[i];\n            for (int j = 0; j < i; ++j)\n                a[j] = j + 1;\n            if (findRow(a, 0, i))\n                printRow(a);                \n        }\n        System.out.println();\n        StringBuilder s = new StringBuilder();\n        for (int i = 2; i <= 20; ++i) {\n            int[] a = new int[i];\n            for (int j = 0; j < i; ++j)\n                a[j] = j + 1;\n            if (i > 2)\n                s.append(\" \");\n            s.append(countRows(a, 0, i));\n        }\n        System.out.println(s);\n        long finish = System.currentTimeMillis();\n        System.out.printf(\"\\nElapsed time: %d milliseconds\\n\", finish - start);\n    }\n\n    private static void printRow(int[] a) {\n        for (int i = 0; i < a.length; ++i) {\n            if (i != 0)\n                System.out.print(\" \");\n            System.out.printf(\"%2d\", a[i]);\n        }\n        System.out.println();\n    }\n\n    private static boolean findRow(int[] a, int start, int length) {\n        if (length == 2)\n            return isPrime(a[start] + a[start + 1]);\n        for (int i = 1; i + 1 < length; i += 2) {\n            if (isPrime(a[start] + a[start + i])) {\n                swap(a, start + i, start + 1);\n                if (findRow(a, start + 1, length - 1))\n                    return true;\n                swap(a, start + i, start + 1);\n            }\n        }\n        return false;\n    }\n\n    private static int countRows(int[] a, int start, int length) {\n        int count = 0;\n        if (length == 2) {\n            if (isPrime(a[start] + a[start + 1]))\n                ++count;\n        } else {\n            for (int i = 1; i + 1 < length; i += 2) {\n                if (isPrime(a[start] + a[start + i])) {\n                    swap(a, start + i, start + 1);\n                    count += countRows(a, start + 1, length - 1);\n                    swap(a, start + i, start + 1);\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void swap(int[] a, int i, int j) {\n        int tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n    }\n\n    private static boolean isPrime(int n) {\n        return ((1L << n) & 0x28208a20a08a28acL) != 0;\n    }\n}\n"}
{"id": 392609, "name": "Word ladder", "source": "Translate Swift to Java: import Foundation\n\nfunc oneAway(string1: [Character], string2: [Character]) -> Bool {\n    if string1.count != string2.count {\n        return false\n    }\n    var result = false\n    var i = 0\n    while i < string1.count {\n        if string1[i] != string2[i] {\n            if result {\n                return false\n            }\n            result = true\n        }\n        i += 1\n    }\n    return result\n}\n\nfunc wordLadder(words: [[Character]], from: String, to: String) {\n    let fromCh = Array(from)\n    let toCh = Array(to)\n    var poss = words.filter{$0.count == fromCh.count}\n    var queue: [[[Character]]] = [[fromCh]]\n    while !queue.isEmpty {\n        var curr = queue[0]\n        let last = curr[curr.count - 1]\n        queue.removeFirst()\n        let next = poss.filter{oneAway(string1: $0, string2: last)}\n        if next.contains(toCh) {\n            curr.append(toCh)\n            print(curr.map{String($0)}.joined(separator: \" -> \"))\n            return\n        }\n        poss.removeAll(where: {next.contains($0)})\n        for str in next {\n            var temp = curr\n            temp.append(str)\n            queue.append(temp)\n        }\n    }\n    print(\"\\(from) into \\(to) cannot be done.\")\n}\n\ndo {\n    let words = try String(contentsOfFile: \"unixdict.txt\", encoding: String.Encoding.ascii)\n        .components(separatedBy: \"\\n\")\n        .filter{!$0.isEmpty}\n        .map{Array($0)}\n    wordLadder(words: words, from: \"man\", to: \"boy\")\n    wordLadder(words: words, from: \"girl\", to: \"lady\")\n    wordLadder(words: words, from: \"john\", to: \"jane\")\n    wordLadder(words: words, from: \"child\", to: \"adult\")\n    wordLadder(words: words, from: \"cat\", to: \"dog\")\n    wordLadder(words: words, from: \"lead\", to: \"gold\")\n    wordLadder(words: words, from: \"white\", to: \"black\")\n    wordLadder(words: words, from: \"bubble\", to: \"tickle\")\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class WordLadder {\n    private static int distance(String s1, String s2) {\n        assert s1.length() == s2.length();\n        return (int) IntStream.range(0, s1.length())\n            .filter(i -> s1.charAt(i) != s2.charAt(i))\n            .count();\n    }\n\n    private static void wordLadder(Map<Integer, Set<String>> words, String fw, String tw) {\n        wordLadder(words, fw, tw, 8);\n    }\n\n    private static void wordLadder(Map<Integer, Set<String>> words, String fw, String tw, int limit) {\n        if (fw.length() != tw.length()) {\n            throw new IllegalArgumentException(\"From word and to word must have the same length\");\n        }\n\n        Set<String> ws = words.get(fw.length());\n        if (ws.contains(fw)) {\n            List<String> primeList = new ArrayList<>();\n            primeList.add(fw);\n\n            PriorityQueue<List<String>> queue = new PriorityQueue<>((chain1, chain2) -> {\n                int cmp1 = Integer.compare(chain1.size(), chain2.size());\n                if (cmp1 == 0) {\n                    String last1 = chain1.get(chain1.size() - 1);\n                    int d1 = distance(last1, tw);\n\n                    String last2 = chain2.get(chain2.size() - 1);\n                    int d2 = distance(last2, tw);\n\n                    return Integer.compare(d1, d2);\n                }\n                return cmp1;\n            });\n            queue.add(primeList);\n\n            while (queue.size() > 0) {\n                List<String> curr = queue.remove();\n                if (curr.size() > limit) {\n                    continue;\n                }\n\n                String last = curr.get(curr.size() - 1);\n                for (String word : ws) {\n                    if (distance(last, word) == 1) {\n                        if (word.equals(tw)) {\n                            curr.add(word);\n                            System.out.println(String.join(\" -> \", curr));\n                            return;\n                        }\n\n                        if (!curr.contains(word)) {\n                            List<String> cp = new ArrayList<>(curr);\n                            cp.add(word);\n                            queue.add(cp);\n                        }\n                    }\n                }\n            }\n        }\n\n        System.err.printf(\"Cannot turn `%s` into `%s`%n\", fw, tw);\n    }\n\n    public static void main(String[] args) throws IOException {\n        Map<Integer, Set<String>> words = new HashMap<>();\n        for (String line : Files.readAllLines(Path.of(\"unixdict.txt\"))) {\n            Set<String> wl = words.computeIfAbsent(line.length(), HashSet::new);\n            wl.add(line);\n        }\n\n        wordLadder(words, \"boy\", \"man\");\n        wordLadder(words, \"girl\", \"lady\");\n        wordLadder(words, \"john\", \"jane\");\n        wordLadder(words, \"child\", \"adult\");\n        wordLadder(words, \"cat\", \"dog\");\n        wordLadder(words, \"lead\", \"gold\");\n        wordLadder(words, \"white\", \"black\");\n        wordLadder(words, \"bubble\", \"tickle\", 12);\n    }\n}\n"}
{"id": 392610, "name": "Rhonda numbers", "source": "Translate Swift to Java: func digitProduct(base: Int, num: Int) -> Int {\n    var product = 1\n    var n = num\n    while n != 0 {\n        product *= n % base\n        n /= base\n    }\n    return product\n}\n\nfunc primeFactorSum(_ num: Int) -> Int {\n    var sum = 0\n    var n = num\n    while (n & 1) == 0 {\n        sum += 2\n        n >>= 1\n    }\n    var p = 3\n    while p * p <= n {\n        while n % p == 0 {\n            sum += p\n            n /= p\n        }\n        p += 2\n    }\n    if n > 1 {\n        sum += n\n    }\n    return sum\n}\n\nfunc isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfunc isRhonda(base: Int, num: Int) -> Bool {\n    return digitProduct(base: base, num: num) == base * primeFactorSum(num)\n}\n\nlet limit = 15\nfor base in 2...36 {\n    if isPrime(base) {\n        continue\n    }\n    print(\"First \\(limit) Rhonda numbers to base \\(base):\")\n    let numbers = Array((1...).lazy.filter{ isRhonda(base: base, num: $0) }.prefix(limit))\n    print(\"In base 10:\", terminator: \"\")\n    for n in numbers {\n        print(\" \\(n)\", terminator: \"\")\n    }\n    print(\"\\nIn base \\(base):\", terminator: \"\")\n    for n in numbers {\n        print(\" \\(String(n, radix: base))\", terminator: \"\")\n    }\n    print(\"\\n\")\n}\n", "target": "public class RhondaNumbers {\n    public static void main(String[] args) {\n        final int limit = 15;\n        for (int base = 2; base <= 36; ++base) {\n            if (isPrime(base))\n                continue;\n            System.out.printf(\"First %d Rhonda numbers to base %d:\\n\", limit, base);\n            int numbers[] = new int[limit];\n            for (int n = 1, count = 0; count < limit; ++n) {\n                if (isRhonda(base, n))\n                    numbers[count++] = n;\n            }\n            System.out.printf(\"In base 10:\");\n            for (int i = 0; i < limit; ++i)\n                System.out.printf(\" %d\", numbers[i]);\n            System.out.printf(\"\\nIn base %d:\", base);\n            for (int i = 0; i < limit; ++i)\n                System.out.printf(\" %s\", Integer.toString(numbers[i], base));\n            System.out.printf(\"\\n\\n\");\n        }\n    }\n    \n    private static int digitProduct(int base, int n) {\n        int product = 1;\n        for (; n != 0; n /= base)\n            product *= n % base;\n        return product;\n    }\n     \n    private static int primeFactorSum(int n) {\n        int sum = 0;\n        for (; (n & 1) == 0; n >>= 1)\n            sum += 2;\n        for (int p = 3; p * p <= n; p += 2)\n            for (; n % p == 0; n /= p)\n                sum += p;\n        if (n > 1)\n            sum += n;\n        return sum;\n    }\n     \n    private static boolean isPrime(int n) {\n        if (n < 2)\n            return false;\n        if (n % 2 == 0)\n            return n == 2;\n        if (n % 3 == 0)\n            return n == 3;\n        for (int p = 5; p * p <= n; p += 4) {\n            if (n % p == 0)\n                return false;\n            p += 2;\n            if (n % p == 0)\n                return false;\n        }\n        return true;\n    }\n     \n    private static boolean isRhonda(int base, int n) {\n        return digitProduct(base, n) == base * primeFactorSum(n);\n    }\n}\n"}
{"id": 392611, "name": "Minimal steps down to 1", "source": "Translate Swift to Java: func minToOne(divs: [Int], subs: [Int], upTo n: Int) -> ([Int], [[String]]) {\n  var table = Array(repeating: n + 2, count: n + 1)\n  var how = Array(repeating: [\"\"], count: n + 2)\n\n  table[1] = 0\n  how[1] = [\"=\"]\n\n  for t in 1..<n {\n    let thisPlus1 = table[t] + 1\n\n    for div in divs {\n      let dt = div * t\n\n      if dt <= n && thisPlus1 < table[dt] {\n        table[dt] = thisPlus1\n        how[dt] = how[t] + [\"/\\(div)=>  \\(t)\"]\n      }\n    }\n\n    for sub in subs {\n      let st = sub + t\n\n      if st <= n && thisPlus1 < table[st] {\n        table[st] = thisPlus1\n        how[st] = how[t] + [\"-\\(sub)=> \\(t)\"]\n      }\n    }\n  }\n\n  return (table, how.map({ $0.reversed().dropLast() }))\n}\n\nfor (divs, subs) in [([2, 3], [1]), ([2, 3], [2])] {\n  print(\"\\nMINIMUM STEPS TO 1:\")\n  print(\"  Possible divisors:  \\(divs)\")\n  print(\"  Possible decrements: \\(subs)\")\n\n  let (table, hows) = minToOne(divs: divs, subs: subs, upTo: 10)\n\n  for n in 1...10 {\n    print(\"    mintab(  \\(n)) in {  \\(table[n])} by: \", hows[n].joined(separator: \", \"))\n  }\n\n  for upTo in [2_000, 50_000] {\n    print(\"\\n    Those numbers up to \\(upTo) that take the maximum, \\\"minimal steps down to 1\\\":\")\n    let (table, _) = minToOne(divs: divs, subs: subs, upTo: upTo)\n    let max = table.dropFirst().max()!\n    let maxNs = table.enumerated().filter({ $0.element == max })\n\n    print(\n      \"      Taking\", max, \"steps are the \\(maxNs.count) numbers:\",\n      maxNs.map({ String($0.offset) }).joined(separator: \", \")\n    )\n  }\n}\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class MinimalStepsDownToOne {\n\n    public static void main(String[] args) {\n        runTasks(getFunctions1());\n        runTasks(getFunctions2());\n        runTasks(getFunctions3());\n    }\n    \n    private static void runTasks(List<Function> functions) {\n        Map<Integer,List<String>> minPath = getInitialMap(functions, 5);\n\n        \n        int max = 10;\n        populateMap(minPath, functions, max);\n        System.out.printf(\"%nWith functions:  %s%n\", functions);\n        System.out.printf(\"  Minimum steps to 1:%n\");\n        for ( int n = 2 ; n <= max ; n++ ) {\n            int steps = minPath.get(n).size();\n            System.out.printf(\"    %2d: %d step%1s: %s%n\", n, steps, steps == 1 ? \"\" : \"s\", minPath.get(n));\n        }\n        \n        \n        displayMaxMin(minPath, functions, 2000);\n\n        \n        displayMaxMin(minPath, functions, 20000);\n\n        \n        displayMaxMin(minPath, functions, 100000);\n    }\n    \n    private static void displayMaxMin(Map<Integer,List<String>> minPath, List<Function> functions, int max) {\n        populateMap(minPath, functions, max);\n        List<Integer> maxIntegers = getMaxMin(minPath, max);\n        int maxSteps = maxIntegers.remove(0);\n        int numCount = maxIntegers.size();\n        System.out.printf(\"  There %s %d number%s in the range 1-%d that have maximum 'minimal steps' of %d:%n    %s%n\", numCount == 1 ? \"is\" : \"are\", numCount, numCount == 1 ? \"\" : \"s\", max, maxSteps, maxIntegers);\n        \n    }\n    \n    private static List<Integer> getMaxMin(Map<Integer,List<String>> minPath, int max) {\n        int maxSteps = Integer.MIN_VALUE;\n        List<Integer> maxIntegers = new ArrayList<Integer>();\n        for ( int n = 2 ; n <= max ; n++ ) {\n            int len = minPath.get(n).size();\n            if ( len > maxSteps ) {\n                maxSteps = len;\n                maxIntegers.clear();\n                maxIntegers.add(n);\n            }\n            else if ( len == maxSteps ) {\n                maxIntegers.add(n);\n            }\n        }\n        maxIntegers.add(0, maxSteps);\n        return maxIntegers;\n    }\n\n    private static void populateMap(Map<Integer,List<String>> minPath, List<Function> functions, int max) {\n        for ( int n = 2 ; n <= max ; n++ ) {\n            if ( minPath.containsKey(n) ) {\n                continue;\n            }\n            Function minFunction = null;\n            int minSteps = Integer.MAX_VALUE;\n            for ( Function f : functions ) {\n                if ( f.actionOk(n) ) {\n                    int result = f.action(n);\n                    int steps = 1 + minPath.get(result).size();\n                    if ( steps < minSteps ) {\n                        minFunction = f;\n                        minSteps = steps;\n                    }\n                }\n            }\n            int result = minFunction.action(n);\n            List<String> path = new ArrayList<String>();\n            path.add(minFunction.toString(n));\n            path.addAll(minPath.get(result));\n            minPath.put(n, path);\n        }\n        \n    }\n\n    private static Map<Integer,List<String>> getInitialMap(List<Function> functions, int max) {\n        Map<Integer,List<String>> minPath = new HashMap<>();\n        for ( int i = 2 ; i <= max ; i++ ) {\n            for ( Function f : functions ) {\n                if ( f.actionOk(i) ) {\n                    int result = f.action(i);\n                    if ( result == 1 ) {\n                        List<String> path = new ArrayList<String>();\n                        path.add(f.toString(i));\n                        minPath.put(i, path);\n                    }\n                }\n            }\n        }\n        return minPath;\n    }\n\n    private static List<Function> getFunctions3() {\n        List<Function> functions = new ArrayList<>();\n        functions.add(new Divide2Function());\n        functions.add(new Divide3Function());\n        functions.add(new Subtract2Function());\n        functions.add(new Subtract1Function());\n        return functions;\n    }\n\n    private static List<Function> getFunctions2() {\n        List<Function> functions = new ArrayList<>();\n        functions.add(new Divide3Function());\n        functions.add(new Divide2Function());\n        functions.add(new Subtract2Function());\n        return functions;\n    }\n\n    private static List<Function> getFunctions1() {\n        List<Function> functions = new ArrayList<>();\n        functions.add(new Divide3Function());\n        functions.add(new Divide2Function());\n        functions.add(new Subtract1Function());\n        return functions;\n    }\n    \n    public abstract static class Function {\n        abstract public int action(int n);\n        abstract public boolean actionOk(int n);\n        abstract public String toString(int n);\n    }\n    \n    public static class Divide2Function extends Function {\n        @Override public int action(int n) {\n            return n/2;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return n % 2 == 0;\n        }\n\n        @Override public String toString(int n) {\n            return \"/2 -> \" + n/2;\n        }\n        \n        @Override public String toString() {\n            return \"Divisor 2\";\n        }\n        \n    }\n\n    public static class Divide3Function extends Function {\n        @Override public int action(int n) {\n            return n/3;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return n % 3 == 0;\n        }\n\n        @Override public String toString(int n) {\n            return \"/3 -> \" + n/3;\n        }\n\n        @Override public String toString() {\n            return \"Divisor 3\";\n        }\n\n    }\n\n    public static class Subtract1Function extends Function {\n        @Override public int action(int n) {\n            return n-1;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return true;\n        }\n    \n        @Override public String toString(int n) {\n            return \"-1 -> \" + (n-1);\n        }\n\n        @Override public String toString() {\n            return \"Subtractor 1\";\n        }\n\n    }\n\n    public static class Subtract2Function extends Function {\n        @Override public int action(int n) {\n            return n-2;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return n > 2;\n        }\n    \n        @Override public String toString(int n) {\n            return \"-2 -> \" + (n-2);\n        }\n\n        @Override public String toString() {\n            return \"Subtractor 2\";\n        }\n\n    }\n\n}\n"}
{"id": 392612, "name": "Railway circuit", "source": "Translate Swift to Java: enum Track: Int, Hashable {\n  case left = -1, straight, right\n}\n\nextension Track: Comparable {\n  static func < (lhs: Track, rhs: Track) -> Bool {\n    return lhs.rawValue < rhs.rawValue\n  }\n}\n\nfunc < (lhs: [Track], rhs: [Track]) -> Bool {\n  for (l, r) in zip(lhs, rhs) where l != r {\n    return l < r\n  }\n\n  return false\n}\n\nfunc normalize(_ tracks: [Track]) -> [Track] {\n  let count = tracks.count\n  var workingTracks = tracks\n  var norm = tracks\n\n  for _ in 0..<count {\n    if workingTracks < norm {\n      norm = workingTracks\n    }\n\n    let temp = workingTracks[0]\n\n    for j in 1..<count {\n      workingTracks[j - 1] = workingTracks[j]\n    }\n\n    workingTracks[count - 1] = temp\n  }\n\n  return norm\n}\n\nfunc fullCircleStraight(tracks: [Track], nStraight: Int) -> Bool {\n  guard nStraight != 0 else {\n    return true\n  }\n\n  guard tracks.filter({ $0 == .straight }).count == nStraight else {\n    return false\n  }\n\n  var straight = [Int](repeating: 0, count: 12)\n  var i = 0\n  var idx = 0\n\n  while i < tracks.count && idx >= 0 {\n    if tracks[i] == .straight {\n      straight[idx % 12] += 1\n    }\n\n    idx += tracks[i].rawValue\n    i += 1\n  }\n\n  return !((0...5).contains(where: { straight[$0] != straight[$0 + 6] }) &&\n    (0...7).contains(where: { straight[$0] != straight[$0 + 4] })\n  )\n}\n\nfunc fullCircleRight(tracks: [Track]) -> Bool {\n  guard tracks.map({ $0.rawValue * 30 }).reduce(0, +) % 360 == 0 else {\n    return false\n  }\n\n  var rightTurns = [Int](repeating: 0, count: 12)\n  var i = 0\n  var idx = 0\n\n  while i < tracks.count && idx >= 0 {\n    if tracks[i] == .right {\n      rightTurns[idx % 12] += 1\n    }\n\n    idx += tracks[i].rawValue\n    i += 1\n  }\n\n  return !((0...5).contains(where: { rightTurns[$0] != rightTurns[$0 + 6] }) &&\n    (0...7).contains(where: { rightTurns[$0] != rightTurns[$0 + 4] })\n  )\n}\n\nfunc circuits(nCurved: Int, nStraight: Int) {\n  var solutions = Set<[Track]>()\n\n  for tracks in getPermutationsGen(nCurved: nCurved, nStraight: nStraight)\n      where fullCircleStraight(tracks: tracks, nStraight: nStraight) && fullCircleRight(tracks: tracks)  {\n    solutions.insert(normalize(tracks))\n  }\n\n  report(solutions: solutions, nCurved: nCurved, nStraight: nStraight)\n}\n\nfunc getPermutationsGen(nCurved: Int, nStraight: Int) -> PermutationsGen {\n  precondition((nCurved + nStraight - 12) % 4 == 0, \"input must be 12 + k * 4\")\n\n  let trackTypes: [Track]\n\n  if nStraight == 0 {\n    trackTypes = [.right, .left]\n  } else if nCurved == 12 {\n    trackTypes = [.right, .straight]\n  } else {\n    trackTypes = [.right, .left, .straight]\n  }\n\n  return PermutationsGen(numPositions: nCurved + nStraight, choices: trackTypes)\n}\n\nfunc report(solutions: Set<[Track]>, nCurved: Int, nStraight: Int) {\n  print(\"\\(solutions.count) solutions for C\\(nCurved),\\(nStraight)\")\n\n  if nCurved <= 20 {\n    for tracks in solutions {\n      for track in tracks {\n        print(track.rawValue, terminator: \" \")\n      }\n\n      print()\n    }\n  }\n}\n\nstruct PermutationsGen: Sequence, IteratorProtocol {\n  private let choices: [Track]\n  private var indices: [Int]\n  private var sequence: [Track]\n  private var carry = 0\n\n  init(numPositions: Int, choices: [Track]) {\n    self.choices = choices\n    self.indices = .init(repeating: 0, count: numPositions)\n    self.sequence = .init(repeating: choices.first!, count: numPositions)\n  }\n\n  mutating func next() -> [Track]? {\n    guard carry != 1 else {\n      return nil\n    }\n\n    carry = 1\n    var i = 1\n\n    while i < indices.count && carry > 0 {\n      indices[i] += carry\n      carry = 0\n\n      if indices[i] == choices.count {\n        carry = 1\n        indices[i] = 0\n      }\n\n      i += 1\n    }\n\n    for j in 0..<indices.count {\n      sequence[j] = choices[indices[j]]\n    }\n\n    return sequence\n  }\n}\n\nfor n in stride(from: 12, through: 32, by: 4) {\n  circuits(nCurved: n, nStraight: 0)\n}\n\ncircuits(nCurved: 12, nStraight: 4)\n", "target": "package railwaycircuit;\n\nimport static java.util.Arrays.stream;\nimport java.util.*;\nimport static java.util.stream.IntStream.range;\n\npublic class RailwayCircuit {\n    final static int RIGHT = 1, LEFT = -1, STRAIGHT = 0;\n\n    static String normalize(int[] tracks) {\n        char[] a = new char[tracks.length];\n        for (int i = 0; i < a.length; i++)\n            a[i] = \"abc\".charAt(tracks[i] + 1);\n\n        \n        String norm = new String(a);\n        for (int i = 0, len = a.length; i < len; i++) {\n\n            String s = new String(a);\n            if (s.compareTo(norm) < 0)\n                norm = s;\n\n            char tmp = a[0];\n            for (int j = 1; j < a.length; j++)\n                a[j - 1] = a[j];\n            a[len - 1] = tmp;\n        }\n        return norm;\n    }\n\n    static boolean fullCircleStraight(int[] tracks, int nStraight) {\n        if (nStraight == 0)\n            return true;\n\n        \n        if (stream(tracks).filter(i -> i == STRAIGHT).count() != nStraight)\n            return false;\n\n        \n        int[] straight = new int[12];\n        for (int i = 0, idx = 0; i < tracks.length && idx >= 0; i++) {\n            if (tracks[i] == STRAIGHT)\n                straight[idx % 12]++;\n            idx += tracks[i];\n        }\n\n        return !(range(0, 6).anyMatch(i -> straight[i] != straight[i + 6])\n                && range(0, 8).anyMatch(i -> straight[i] != straight[i + 4]));\n    }\n\n    static boolean fullCircleRight(int[] tracks) {\n\n        \n        if (stream(tracks).map(i -> i * 30).sum() % 360 != 0)\n            return false;\n\n        \n        int[] rTurns = new int[12];\n        for (int i = 0, idx = 0; i < tracks.length && idx >= 0; i++) {\n            if (tracks[i] == RIGHT)\n                rTurns[idx % 12]++;\n            idx += tracks[i];\n        }\n\n        return !(range(0, 6).anyMatch(i -> rTurns[i] != rTurns[i + 6])\n                && range(0, 8).anyMatch(i -> rTurns[i] != rTurns[i + 4]));\n    }\n\n    static void circuits(int nCurved, int nStraight) {\n        Map<String, int[]> solutions = new HashMap<>();\n\n        PermutationsGen gen = getPermutationsGen(nCurved, nStraight);\n        while (gen.hasNext()) {\n\n            int[] tracks = gen.next();\n\n            if (!fullCircleStraight(tracks, nStraight))\n                continue;\n\n            if (!fullCircleRight(tracks))\n                continue;\n\n            solutions.put(normalize(tracks), tracks.clone());\n        }\n        report(solutions, nCurved, nStraight);\n    }\n\n    static PermutationsGen getPermutationsGen(int nCurved, int nStraight) {\n        assert (nCurved + nStraight - 12) % 4 == 0 : \"input must be 12 + k * 4\";\n\n        int[] trackTypes = new int[]{RIGHT, LEFT};\n\n        if (nStraight != 0) {\n            if (nCurved == 12)\n                trackTypes = new int[]{RIGHT, STRAIGHT};\n            else\n                trackTypes = new int[]{RIGHT, LEFT, STRAIGHT};\n        }\n\n        return new PermutationsGen(nCurved + nStraight, trackTypes);\n    }\n\n    static void report(Map<String, int[]> sol, int numC, int numS) {\n\n        int size = sol.size();\n        System.out.printf(\"%n%d solution(s) for C%d,%d %n\", size, numC, numS);\n\n        if (size < 10)\n            sol.values().stream().forEach(tracks -> {\n                stream(tracks).forEach(i -> System.out.printf(\"%2d \", i));\n                System.out.println();\n            });\n    }\n\n    public static void main(String[] args) {\n        circuits(12, 0);\n        circuits(16, 0);\n        circuits(20, 0);\n        circuits(24, 0);\n        circuits(12, 4);\n    }\n}\n\nclass PermutationsGen {\n    \n    private int[] indices;\n    private int[] choices;\n    private int[] sequence;\n    private int carry;\n\n    PermutationsGen(int numPositions, int[] choices) {\n        indices = new int[numPositions];\n        sequence = new int[numPositions];\n        this.choices = choices;\n    }\n\n    int[] next() {\n        carry = 1;\n        \n        for (int i = 1; i < indices.length && carry > 0; i++) {\n            indices[i] += carry;\n            carry = 0;\n\n            if (indices[i] == choices.length) {\n                carry = 1;\n                indices[i] = 0;\n            }\n        }\n\n        for (int i = 0; i < indices.length; i++)\n            sequence[i] = choices[indices[i]];\n\n        return sequence;\n    }\n\n    boolean hasNext() {\n        return carry != 1;\n    }\n}\n"}
{"id": 399632, "name": "Angles (geometric), normalization and conversion", "source": "Translate Swift to C#: import Foundation\n\nfunc normalize(_ f: Double, N: Double) -> Double {\n  var a = f\n\n  while a < -N { a += N }\n  while a >= N { a -= N }\n\n  return a\n}\n\nfunc normalizeToDeg(_ f: Double) -> Double {\n  return normalize(f, N: 360)\n}\n\nfunc normalizeToGrad(_ f: Double) -> Double {\n  return normalize(f, N: 400)\n}\n\nfunc normalizeToMil(_ f: Double) -> Double {\n  return normalize(f, N: 6400)\n}\n\nfunc normalizeToRad(_ f: Double) -> Double {\n  return normalize(f, N: 2 * .pi)\n}\n\nfunc d2g(_ f: Double) -> Double { f * 10 / 9 }\nfunc d2m(_ f: Double) -> Double { f * 160 / 9 }\nfunc d2r(_ f: Double) -> Double { f * .pi / 180 }\n\nfunc g2d(_ f: Double) -> Double { f * 9 / 10 }\nfunc g2m(_ f: Double) -> Double { f * 16 }\nfunc g2r(_ f: Double) -> Double { f * .pi / 200 }\n\nfunc m2d(_ f: Double) -> Double { f * 9 / 160 }\nfunc m2g(_ f: Double) -> Double { f / 16 }\nfunc m2r(_ f: Double) -> Double { f * .pi / 3200 }\n\nfunc r2d(_ f: Double) -> Double { f * 180 / .pi }\nfunc r2g(_ f: Double) -> Double { f * 200 / .pi }\nfunc r2m(_ f: Double) -> Double { f * 3200 / .pi }\n\nlet angles = [-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 6399, 1_000_000]\nlet names = [\"Degrees\", \"Gradians\", \"Mils\", \"Radians\"]\nlet fmt = { String(format: \"%.4f\", $0) }\n\nlet normal = [normalizeToDeg, normalizeToGrad, normalizeToMil, normalizeToRad]\nlet convert = [\n  [{ $0 }, d2g, d2m, d2r],\n  [g2d, { $0 }, g2m, g2r],\n  [m2d, m2g, { $0 }, m2r],\n  [r2d, r2g, r2m, { $0 }]\n]\n\nlet ans =\n  angles.map({ angle in\n    (0..<4).map({ ($0, normal[$0](angle)) }).map({\n      (fmt(angle),\n        fmt($0.1),\n        names[$0.0],\n        fmt(convert[$0.0][0]($0.1)),\n        fmt(convert[$0.0][1]($0.1)),\n        fmt(convert[$0.0][2]($0.1)),\n        fmt(convert[$0.0][3]($0.1))\n      )\n    })\n  })\n\nprint(\"angle\", \"normalized\", \"unit\", \"degrees\", \"grads\", \"mils\", \"radians\")\n\nfor res in ans {\n  for unit in res {\n    print(unit)\n  }\n\n  print()\n}\n", "target": "using System;\n\npublic static class Angles\n{\n    public static void Main() => Print(-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 6399, 1_000_000);\n\n    public static void Print(params double[] angles) {\n        string[] names = { \"Degrees\", \"Gradians\", \"Mils\", \"Radians\" };\n        Func<double, double> rnd = a => Math.Round(a, 4);\n        Func<double, double>[] normal = { NormalizeDeg, NormalizeGrad, NormalizeMil, NormalizeRad };\n\n        Func<double, double>[,] convert = {\n            { a => a, DegToGrad, DegToMil, DegToRad },\n            { GradToDeg, a => a, GradToMil, GradToRad },\n            { MilToDeg, MilToGrad, a => a, MilToRad },\n            { RadToDeg, RadToGrad, RadToMil, a => a }\n        };\n\n        Console.WriteLine($@\"{\"Angle\",-12}{\"Normalized\",-12}{\"Unit\",-12}{\n            \"Degrees\",-12}{\"Gradians\",-12}{\"Mils\",-12}{\"Radians\",-12}\");\n\n        foreach (double angle in angles) {\n            for (int i = 0; i < 4; i++) {\n                double nAngle = normal[i](angle);\n\n                Console.WriteLine($@\"{\n                    rnd(angle),-12}{\n                    rnd(nAngle),-12}{\n                    names[i],-12}{\n                    rnd(convert[i, 0](nAngle)),-12}{\n                    rnd(convert[i, 1](nAngle)),-12}{\n                    rnd(convert[i, 2](nAngle)),-12}{\n                    rnd(convert[i, 3](nAngle)),-12}\");\n            }\n        }\n    }\n\n    public static double NormalizeDeg(double angle) => Normalize(angle, 360);\n    public static double NormalizeGrad(double angle) => Normalize(angle, 400);\n    public static double NormalizeMil(double angle) => Normalize(angle, 6400);\n    public static double NormalizeRad(double angle) => Normalize(angle, 2 * Math.PI);\n\n    private static double Normalize(double angle, double N) {\n        while (angle <= -N) angle += N;\n        while (angle >= N) angle -= N;\n        return angle;\n    }\n\n    public static double DegToGrad(double angle) => angle * 10 / 9;\n    public static double DegToMil(double angle) => angle * 160 / 9;\n    public static double DegToRad(double angle) => angle * Math.PI / 180;\n    \n    public static double GradToDeg(double angle) => angle * 9 / 10;\n    public static double GradToMil(double angle) => angle * 16;\n    public static double GradToRad(double angle) => angle * Math.PI / 200;\n    \n    public static double MilToDeg(double angle) => angle * 9 / 160;\n    public static double MilToGrad(double angle) => angle / 16;\n    public static double MilToRad(double angle) => angle * Math.PI / 3200;\n    \n    public static double RadToDeg(double angle) => angle * 180 / Math.PI;\n    public static double RadToGrad(double angle) => angle * 200 / Math.PI;\n    public static double RadToMil(double angle) => angle * 3200 / Math.PI;\n}\n"}
{"id": 399633, "name": "I before E except after C", "source": "Translate Swift to C#: import Foundation\n\nlet request = NSURLRequest(URL: NSURL(string: \"http:\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in\n    if (data != nil) {\n        if let fileAsString = NSString(data: data, encoding: NSUTF8StringEncoding) {\n            var firstCase = false\n            var secondCase = false\n            var cie = 0\n            var cei = 0\n            var not_c_ie = 0\n            var not_c_ei = 0\n            let words = fileAsString.componentsSeparatedByString(\"\\n\")\n            for word in words {\n                var wordRegex = RegexMutable(word as String)\n                if (wordRegex[\"cie\"]) {\n                    cie++\n                }\n                if (wordRegex[\"cei\"]) {\n                    cei++\n                }\n                if (wordRegex[\"(^ie|[^c]ie)\"].matches().count != 0) {\n                    not_c_ie++\n                }\n                if (wordRegex[\"(^ei|[^c]ei)\"].matches().count != 0) {\n                    not_c_ei++\n                }\n            }\n            \n            \n            if (not_c_ie > not_c_ei * 2) {\n                println(\"I before E when not preceded by C is plausable\")\n                firstCase = true\n            } else {\n                println(\"I before E when not preceded by C is not plausable\")\n            }\n            \n            if (cei > cie * 2) {\n                secondCase = true\n                println(\"E before I when preceded by C is plausable\")\n            } else {\n                println(\"E before I when preceded by C is not plausable\")\n            }\n            \n            if (firstCase && secondCase) {\n                println(\"I before E except after C is plausible\")\n            } else {\n                println(\"I before E except after C is not plausible\")\n            }\n        }\n    }\n}\n\nCFRunLoopRun()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace IBeforeE {\n    class Program {\n        static bool IsOppPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ei\")) {\n                return true;\n            }\n            if (word.Contains(\"cie\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ie\")) {\n                return true;\n            }\n            if (word.Contains(\"cei\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleRule(string filename) {\n            IEnumerable<string> wordSource = File.ReadLines(filename);\n            int trueCount = 0;\n            int falseCount = 0;\n\n            foreach (string word in wordSource) {\n                if (IsPlausibleWord(word)) {\n                    trueCount++;\n                }\n                else if (IsOppPlausibleWord(word)) {\n                    falseCount++;\n                }\n            }\n\n            Console.WriteLine(\"Plausible count: {0}\", trueCount);\n            Console.WriteLine(\"Implausible count: {0}\", falseCount);\n            return trueCount > 2 * falseCount;\n        }\n\n        static void Main(string[] args) {\n            if (IsPlausibleRule(\"unixdict.txt\")) {\n                Console.WriteLine(\"Rule is plausible.\");\n            }\n            else {\n                Console.WriteLine(\"Rule is not plausible.\");\n            }\n        }\n    }\n}\n"}
{"id": 399634, "name": "I before E except after C", "source": "Translate Swift to C#: import Foundation\n\nlet request = NSURLRequest(URL: NSURL(string: \"http:\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in\n    if (data != nil) {\n        if let fileAsString = NSString(data: data, encoding: NSUTF8StringEncoding) {\n            var firstCase = false\n            var secondCase = false\n            var cie = 0\n            var cei = 0\n            var not_c_ie = 0\n            var not_c_ei = 0\n            let words = fileAsString.componentsSeparatedByString(\"\\n\")\n            for word in words {\n                var wordRegex = RegexMutable(word as String)\n                if (wordRegex[\"cie\"]) {\n                    cie++\n                }\n                if (wordRegex[\"cei\"]) {\n                    cei++\n                }\n                if (wordRegex[\"(^ie|[^c]ie)\"].matches().count != 0) {\n                    not_c_ie++\n                }\n                if (wordRegex[\"(^ei|[^c]ei)\"].matches().count != 0) {\n                    not_c_ei++\n                }\n            }\n            \n            \n            if (not_c_ie > not_c_ei * 2) {\n                println(\"I before E when not preceded by C is plausable\")\n                firstCase = true\n            } else {\n                println(\"I before E when not preceded by C is not plausable\")\n            }\n            \n            if (cei > cie * 2) {\n                secondCase = true\n                println(\"E before I when preceded by C is plausable\")\n            } else {\n                println(\"E before I when preceded by C is not plausable\")\n            }\n            \n            if (firstCase && secondCase) {\n                println(\"I before E except after C is plausible\")\n            } else {\n                println(\"I before E except after C is not plausible\")\n            }\n        }\n    }\n}\n\nCFRunLoopRun()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace IBeforeE {\n    class Program {\n        static bool IsOppPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ei\")) {\n                return true;\n            }\n            if (word.Contains(\"cie\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ie\")) {\n                return true;\n            }\n            if (word.Contains(\"cei\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleRule(string filename) {\n            IEnumerable<string> wordSource = File.ReadLines(filename);\n            int trueCount = 0;\n            int falseCount = 0;\n\n            foreach (string word in wordSource) {\n                if (IsPlausibleWord(word)) {\n                    trueCount++;\n                }\n                else if (IsOppPlausibleWord(word)) {\n                    falseCount++;\n                }\n            }\n\n            Console.WriteLine(\"Plausible count: {0}\", trueCount);\n            Console.WriteLine(\"Implausible count: {0}\", falseCount);\n            return trueCount > 2 * falseCount;\n        }\n\n        static void Main(string[] args) {\n            if (IsPlausibleRule(\"unixdict.txt\")) {\n                Console.WriteLine(\"Rule is plausible.\");\n            }\n            else {\n                Console.WriteLine(\"Rule is not plausible.\");\n            }\n        }\n    }\n}\n"}
{"id": 399635, "name": "Line circle intersection", "source": "Translate Swift to C#: import Foundation\nimport CoreGraphics\n\nfunc lineCircleIntersection(start: NSPoint, end: NSPoint, center: NSPoint,\n                            radius: CGFloat, segment: Bool) -> [NSPoint] {\n    var result: [NSPoint] = []\n    let angle = atan2(end.y - start.y, end.x - start.x)\n    var at = AffineTransform(rotationByRadians: angle)\n    at.invert()\n    at.translate(x: -center.x, y: -center.y)\n    let p1 = at.transform(start)\n    let p2 = at.transform(end)\n    let minX = min(p1.x, p2.x), maxX = max(p1.x, p2.x)\n    let y = p1.y\n    at.invert()\n    func addPoint(x: CGFloat, y: CGFloat) {\n        if !segment || (x <= maxX && x >= minX) {\n            result.append(at.transform(NSMakePoint(x, y)))\n        }\n    }\n    if y == radius || y == -radius {\n        addPoint(x: 0, y: y)\n    } else if y < radius && y > -radius {\n        let x = (radius * radius - y * y).squareRoot()\n        addPoint(x: -x, y: y)\n        addPoint(x: x, y: y)\n    }\n    return result\n}\n\nfunc toString(points: [NSPoint]) -> String {\n    var result = \"[\"\n    result += points.map{String(format: \"(%.4f,\u00a0%.4f)\", $0.x, $0.y)}.joined(separator: \", \")\n    result += \"]\"\n    return result\n}\n\nvar center = NSMakePoint(3, -5)\nvar radius: CGFloat = 3\n\nprint(\"The intersection points (if any) between:\")\nprint(\"\\n  A circle, center (3, -5) with radius 3, and:\")\nprint(\"\\n    a line containing the points (-10, 11) and (10, -9) is/are:\")\nvar points = lineCircleIntersection(start: NSMakePoint(-10, 11), end: NSMakePoint(10, -9),\n                                    center: center, radius: radius,\n                                    segment: false)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a segment starting at (-10, 11) and ending at (-11, 12) is/are\")\npoints = lineCircleIntersection(start: NSMakePoint(-10, 11), end: NSMakePoint(-11, 12),\n                                center: center, radius: radius,\n                                segment: true)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a horizontal line containing the points (3, -2) and (7, -2) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(3, -2), end: NSMakePoint(7, -2),\n                                center: center, radius: radius,\n                                segment: false)\nprint(\"     \\(toString(points: points))\")\n\ncenter.x = 0\ncenter.y = 0\nradius = 4\n\nprint(\"\\n  A circle, center (0, 0) with radius 4, and:\")\nprint(\"\\n    a vertical line containing the points (0, -3) and (0, 6) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(0, -3), end: NSMakePoint(0, 6),\n                                center: center, radius: radius,\n                                segment: false)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a vertical segment starting at (0, -3) and ending at (0, 6) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(0, -3), end: NSMakePoint(0, 6),\n                                center: center, radius: radius,\n                                segment: true)\nprint(\"     \\(toString(points: points))\")\n\ncenter.x = 4\ncenter.y = 2\nradius = 5\n\nprint(\"\\n  A circle, center (4, 2) with radius 5, and:\")\nprint(\"\\n    a line containing the points (6, 3) and (10, 7) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(6, 3), end: NSMakePoint(10, 7),\n                                center: center, radius: radius,\n                                segment: false)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a segment starting at (7, 4) and ending at (11, 8) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(7, 4), end: NSMakePoint(11, 8),\n                                center: center, radius: radius,\n                                segment: true)\nprint(\"     \\(toString(points: points))\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Circle circle = ((3, -5), 3);\n        Line[] lines = {\n            ((-10, 11), (10, -9)),\n            ((-10, 11), (-11, 12), true),\n            ((3, -2), (7, -2))\n        };\n        Print(circle, lines);\n        \n        circle = ((0, 0), 4);\n        lines = new Line[] {\n            ((0, -3), (0, 6)),\n            ((0, -3), (0, 6), true)\n        };\n        Print(circle, lines);\n        \n        circle = ((4, 2), 5);\n        lines = new Line[] {\n            ((6, 3), (10, 7)),\n            ((7, 4), (11, 8), true)\n        };\n        Print(circle, lines);\n    }\n    \n    static void Print(Circle circle, Line[] lines)\n    {\n        Console.WriteLine($\"Circle: {circle}\");\n        foreach (var line in lines) {\n            Console.WriteLine($\"\\t{(line.IsSegment\u00a0? \"Segment:\"\u00a0: \"Line:\")} {line}\");\n            var points = Intersection(circle, line).ToList();\n            Console.WriteLine(points.Count == 0 ? \"\\t\\tdo not intersect\" : \"\\t\\tintersect at \" + string.Join(\" and \", points));\n        }\n        Console.WriteLine();\n    }\n    \n    static IEnumerable<Point> Intersection(Circle circle, Line line)\n    {\n        var intersection = LineIntersection(circle, line);\n        return line.IsSegment\n            ? intersection.Where(p => p.CompareTo(line.P1) >= 0 && p.CompareTo(line.P2) <= 0)\n            : intersection;\n\n        static IEnumerable<Point> LineIntersection(Circle circle, Line line)\n        {\n            double x, y, A, B, C, D;\n            var (m, c) = (line.Slope, line.YIntercept);\n            var (p, q, r) = (circle.X, circle.Y, circle.Radius);\n\n            if (line.IsVertical) {\n                x = line.P1.X;\n                B = -2 * q;\n                C = p * p + q * q - r * r + x * x - 2 * p * x;\n                D = B * B - 4 * C;\n                if (D == 0) yield return (x, -q);\n                else if (D > 0) {\n                    D = Math.Sqrt(D);\n                    yield return (x, (-B - D) / 2);\n                    yield return (x, (-B + D) / 2);\n                }\n            } else {\n                A = m * m + 1;\n                B = 2 * (m * c - m * q - p);\n                C = p * p + q * q - r * r + c * c - 2 * c * q;\n                D = B * B - 4 * A * C;\n                if (D == 0) {\n                    x = -B / (2 * A);\n                    y = m * x + c;\n                    yield return (x, y);\n                } else if (D > 0) {\n                    D = Math.Sqrt(D);\n                    x = (-B - D) / (2 * A);\n                    y = m * x + c;\n                    yield return (x, y);\n                    x = (-B + D) / (2 * A);\n                    y = m * x + c;\n                    yield return (x, y);\n                }\n            }\n        }\n\n    }\n    \n    readonly struct Point : IComparable<Point>\n    {\n        public Point(double x, double y) => (X, Y) = (x, y);\n        \n        public static implicit operator Point((double x, double y) p) => new Point(p.x, p.y);\n        \n        public double X { get; }\n        public double Y { get; }\n        \n        public int CompareTo(Point other)\n        {\n            int c = X.CompareTo(other.X);\n            if (c != 0) return c;\n            return Y.CompareTo(other.Y);\n        }\n        \n        public override string ToString() => $\"({X}, {Y})\";\n    }\n    \n    readonly struct Line\n    {\n        public Line(Point p1, Point p2, bool isSegment = false)\n        {\n            (P1, P2) = p2.CompareTo(p1) < 0 ? (p2, p1) : (p1, p2);\n            IsSegment = isSegment;\n            if (p1.X == p2.X) (Slope, YIntercept) = (double.PositiveInfinity, double.NaN);\n            else {\n                Slope = (P2.Y - P1.Y) / (P2.X - P1.X);\n                YIntercept = P2.Y - Slope * P2.X;\n            }\n        }\n        \n        public static implicit operator Line((Point p1, Point p2) l) => new Line(l.p1, l.p2);\n        public static implicit operator Line((Point p1, Point p2, bool isSegment) l) => new Line(l.p1, l.p2, l.isSegment);\n        \n        public Point P1 { get; }\n        public Point P2 { get; }\n        public double Slope { get; }\n        public double YIntercept { get; }\n        public bool IsSegment { get; }\n        public bool IsVertical => P1.X == P2.X;\n        \n        public override string ToString() => $\"[{P1}, {P2}]\";\n    }\n    \n    readonly struct Circle\n    {\n        public Circle(Point center, double radius) => (Center, Radius) = (center, radius);\n        \n        public static implicit operator Circle((Point center, double radius) c) => new Circle(c.center, c.radius);\n        \n        public Point Center { get; }\n        public double Radius { get; }\n        public double X => Center.X;\n        public double Y => Center.Y;\n        \n        public override string ToString() => $\"{{ C:{Center}, R:{Radius} }}\";\n    }   \n}\n"}
{"id": 399636, "name": "Farey sequence", "source": "Translate Swift to C#: class Farey {\n    let n: Int\n\n    init(_ x: Int) {\n        n = x\n    }\n\n    \n    var sequence: [(Int,Int)] {\n        var a = 0\n        var b = 1\n        var c = 1\n        var d = n\n        var results = [(a, b)]\n        while c <= n {\n            let k = (n + b) / d\n            let oldA = a\n            let oldB = b\n            a = c\n            b = d\n            c = k * c - oldA\n            d = k * d - oldB\n            results += [(a, b)]\n        }\n        return results\n    }\n\n    var formattedSequence: String {\n        var s = \"\\(n):\"\n        for pair in sequence {\n            s += \" \\(pair.0)/\\(pair.1)\"\n        }\n        return s\n    }\n\n}\n\nprint(\"Sequences\\n\")\n\nfor n in 1...11 {\n    print(Farey(n).formattedSequence)\n}\n\nprint(\"\\nSequence Lengths\\n\")\n\nfor n in 1...10 {\n    let m = n * 100\n    print(\"\\(m): \\(Farey(m).sequence.count)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class FareySequence\n{\n    public static void Main() {\n        for (int i = 1; i <= 11; i++) {\n            Console.WriteLine($\"F{i}: \" + string.Join(\", \", Generate(i).Select(f => $\"{f.num}/{f.den}\")));\n        }\n        for (int i = 100; i <= 1000; i+=100) {\n            Console.WriteLine($\"F{i} has {Generate(i).Count()} terms.\");\n        }\n    }\n\n    public static IEnumerable<(int num, int den)> Generate(int i) {\n        var comparer = Comparer<(int n, int d)>.Create((a, b) => (a.n * b.d).CompareTo(a.d * b.n));\n        var seq = new SortedSet<(int n, int d)>(comparer);\n        for (int d = 1; d <= i; d++) {\n            for (int n = 0; n <= d; n++) {\n                seq.Add((n, d));\n            }\n        }\n        return seq;\n    }\n}\n"}
{"id": 399637, "name": "Farey sequence", "source": "Translate Swift to C#: class Farey {\n    let n: Int\n\n    init(_ x: Int) {\n        n = x\n    }\n\n    \n    var sequence: [(Int,Int)] {\n        var a = 0\n        var b = 1\n        var c = 1\n        var d = n\n        var results = [(a, b)]\n        while c <= n {\n            let k = (n + b) / d\n            let oldA = a\n            let oldB = b\n            a = c\n            b = d\n            c = k * c - oldA\n            d = k * d - oldB\n            results += [(a, b)]\n        }\n        return results\n    }\n\n    var formattedSequence: String {\n        var s = \"\\(n):\"\n        for pair in sequence {\n            s += \" \\(pair.0)/\\(pair.1)\"\n        }\n        return s\n    }\n\n}\n\nprint(\"Sequences\\n\")\n\nfor n in 1...11 {\n    print(Farey(n).formattedSequence)\n}\n\nprint(\"\\nSequence Lengths\\n\")\n\nfor n in 1...10 {\n    let m = n * 100\n    print(\"\\(m): \\(Farey(m).sequence.count)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class FareySequence\n{\n    public static void Main() {\n        for (int i = 1; i <= 11; i++) {\n            Console.WriteLine($\"F{i}: \" + string.Join(\", \", Generate(i).Select(f => $\"{f.num}/{f.den}\")));\n        }\n        for (int i = 100; i <= 1000; i+=100) {\n            Console.WriteLine($\"F{i} has {Generate(i).Count()} terms.\");\n        }\n    }\n\n    public static IEnumerable<(int num, int den)> Generate(int i) {\n        var comparer = Comparer<(int n, int d)>.Create((a, b) => (a.n * b.d).CompareTo(a.d * b.n));\n        var seq = new SortedSet<(int n, int d)>(comparer);\n        for (int d = 1; d <= i; d++) {\n            for (int n = 0; n <= d; n++) {\n                seq.Add((n, d));\n            }\n        }\n        return seq;\n    }\n}\n"}
{"id": 399638, "name": "Magnanimous numbers", "source": "Translate Swift to C#: import Foundation\n\nfunc isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfunc isMagnanimous(_ n: Int) -> Bool {\n    var p = 10;\n    while n >= p {\n        if !isPrime(n % p + n / p) {\n            return false\n        }\n        p *= 10\n    }\n    return true\n}\n\nlet m = (0...).lazy.filter{isMagnanimous($0)}.prefix(400);\nprint(\"First 45 magnanimous numbers:\");\nfor (i, n) in m.prefix(45).enumerated() {\n    if i > 0 && i % 15 == 0 {\n        print()\n    }\n    print(String(format: \"%3d\", n), terminator: \" \")\n}\nprint(\"\\n\\n241st through 250th magnanimous numbers:\");\nfor n in m.dropFirst(240).prefix(10) {\n    print(n, terminator: \" \")\n}\nprint(\"\\n\\n391st through 400th magnanimous numbers:\");\nfor n in m.dropFirst(390) {\n    print(n, terminator: \" \")\n}\nprint()\n", "target": "using System; using static System.Console;\n\nclass Program {\n\n  static bool[] np; \n\n  static void ms(long lmt) { \n    np = new bool[lmt]; np[0] = np[1] = true;\n    for (long n = 2, j = 1; n < lmt; n += j, j = 2) if (!np[n])\n        for (long k = n * n; k < lmt; k += n) np[k] = true; }\n\n  static bool is_Mag(long n) { long res, rem;\n    for (long p = 10; n >= p; p *= 10) {\n      res = Math.DivRem (n, p, out rem);\n      if (np[res + rem]) return false; } return true; }\n\n  static void Main(string[] args) { ms(100_009); string mn;\n    WriteLine(\"First 45{0}\", mn = \" magnanimous numbers:\");\n    for (long l = 0, c = 0; c < 400; l++) if (is_Mag(l)) {\n      if (c++ < 45 || (c > 240 && c <= 250) || c > 390)\n        Write(c <= 45 ? \"{0,4} \" : \"{0,8:n0} \", l);\n      if (c < 45 && c % 15 == 0) WriteLine();\n      if (c == 240) WriteLine (\"\\n\\n241st through 250th{0}\", mn);\n      if (c == 390) WriteLine (\"\\n\\n391st through 400th{0}\", mn); } }\n}\n"}
{"id": 399639, "name": "Taxicab numbers", "source": "Translate Swift to C#: extension Array {\n  func combinations(_ k: Int) -> [[Element]] {\n    return Self._combinations(slice: self[startIndex...], k)\n  }\n\n  static func _combinations(slice: Self.SubSequence, _ k: Int) -> [[Element]] {\n    guard k != 1 else {\n      return slice.map({ [$0] })\n    }\n\n    guard k != slice.count else {\n      return [slice.map({ $0 })]\n    }\n\n    let chopped = slice[slice.index(after: slice.startIndex)...]\n\n    var res = _combinations(slice: chopped, k - 1).map({ [[slice.first!], $0].flatMap({ $0 }) })\n\n    res += _combinations(slice: chopped, k)\n\n    return res\n  }\n}\n\nlet cubes = (1...).lazy.map({ $0 * $0 * $0 })\nlet taxis =\n  Array(cubes.prefix(1201))\n    .combinations(2)\n    .reduce(into: [Int: [[Int]]](), { $0[$1[0] + $1[1], default: []].append($1) })\n\n\nlet res =\n  taxis\n    .lazy\n    .filter({ $0.value.count > 1 })\n    .sorted(by: { $0.key < $1.key })\n    .map({ ($0.key, $0.value) })\n    .prefix(2006)\n\nprint(\"First 25 taxicab numbers:\")\nfor taxi in res[..<25] {\n  print(taxi)\n}\n\nprint(\"\\n2000th through 2006th taxicab numbers:\")\nfor taxi in res[1999..<2006] {\n  print(taxi)\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace TaxicabNumber\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IDictionary<long, IList<Tuple<int, int>>> taxicabNumbers = GetTaxicabNumbers(2006);\n            PrintTaxicabNumbers(taxicabNumbers);\n            Console.ReadKey();\n        }\n\n        private static IDictionary<long, IList<Tuple<int, int>>> GetTaxicabNumbers(int length)\n        {\n            SortedList<long, IList<Tuple<int, int>>> sumsOfTwoCubes = new SortedList<long, IList<Tuple<int, int>>>();\n\n            for (int i = 1; i < int.MaxValue; i++)\n            {\n                for (int j = 1; j < int.MaxValue; j++)\n                {\n                    long sum = (long)(Math.Pow((double)i, 3) + Math.Pow((double)j, 3));\n\n                    if (!sumsOfTwoCubes.ContainsKey(sum))\n                    {\n                        sumsOfTwoCubes.Add(sum, new List<Tuple<int, int>>());\n                    }\n\n                    sumsOfTwoCubes[sum].Add(new Tuple<int, int>(i, j));\n\n                    if (j >= i)\n                    {\n                        break;\n                    }\n                }\n\n                \n                if (sumsOfTwoCubes.Count(t => t.Value.Count >= 2) >= length * 1.1)\n                {\n                    break;\n                }\n            }\n\n            IDictionary<long, IList<Tuple<int, int>>> values = (from t in sumsOfTwoCubes where t.Value.Count >= 2 select t)\n                .Take(2006)\n                .ToDictionary(u => u.Key, u => u.Value);\n\n            return values;\n        }\n\n        private static void PrintTaxicabNumbers(IDictionary<long, IList<Tuple<int, int>>> values)\n        {\n            int i = 1;\n\n            foreach (long taxicabNumber in values.Keys)\n            {\n                StringBuilder output = new StringBuilder().AppendFormat(\"{0,10}\\t{1,4}\", i, taxicabNumber);\n\n                foreach (Tuple<int, int> numbers in values[taxicabNumber])\n                {\n                    output.AppendFormat(\"\\t= {0}^3 + {1}^3\", numbers.Item1, numbers.Item2);\n                }\n\n                if (i <= 25 || (i >= 2000 && i <= 2006))\n                {\n                    Console.WriteLine(output.ToString());\n                }\n\n                i++;\n            }\n        }\n    }\n}\n"}
{"id": 399640, "name": "Strong and weak primes", "source": "Translate Swift to C#: import Foundation\n\nclass PrimeSieve {\n    var composite: [Bool]\n    \n    init(size: Int) {\n        composite = Array(repeating: false, count: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite[p/2 - 1] {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite[q/2 - 1] = true\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite[number/2 - 1]\n    }\n}\n\nfunc commatize(_ number: Int) -> String {\n    let n = NSNumber(value: number)\n    return NumberFormatter.localizedString(from: n, number: .decimal)\n}\n\nlet limit1 = 1000000\nlet limit2 = 10000000\n\nclass PrimeInfo {\n    let maxPrint: Int\n    var count1: Int\n    var count2: Int\n    var primes: [Int]\n    \n    init(maxPrint: Int) {\n        self.maxPrint = maxPrint\n        count1 = 0\n        count2 = 0\n        primes = []\n    }\n    \n    func addPrime(prime: Int) {\n        count2 += 1\n        if prime < limit1 {\n            count1 += 1\n        }\n        if count2 <= maxPrint {\n            primes.append(prime)\n        }\n    }\n    \n    func printInfo(name: String) {\n        print(\"First \\(maxPrint) \\(name) primes: \\(primes)\")\n        print(\"Number of \\(name) primes below \\(commatize(limit1)): \\(commatize(count1))\")\n        print(\"Number of \\(name) primes below \\(commatize(limit2)): \\(commatize(count2))\")\n    }\n}\n\nvar strongPrimes = PrimeInfo(maxPrint: 36)\nvar weakPrimes = PrimeInfo(maxPrint: 37)\n\nlet sieve = PrimeSieve(size: limit2 + 100)\n\nvar p1 = 2, p2 = 3, p3 = 5\nwhile p2 < limit2 {\n    if sieve.isPrime(number: p3) {\n        let diff = p1 + p3 - 2 * p2\n        if diff < 0 {\n            strongPrimes.addPrime(prime: p2)\n        } else if diff > 0 {\n            weakPrimes.addPrime(prime: p2)\n        }\n        p1 = p2\n        p2 = p3\n    }\n    p3 += 2\n}\n\nstrongPrimes.printInfo(name: \"strong\")\nweakPrimes.printInfo(name: \"weak\")\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\nusing System;\n\npublic static class StrongAndWeakPrimes\n{\n    public static void Main() {\n        var primes = PrimeGenerator(10_000_100).ToList();\n        var strongPrimes = from i in Range(1, primes.Count - 2) where primes[i] > (primes[i-1] + primes[i+1]) / 2 select primes[i];\n        var weakPrimes = from i in Range(1, primes.Count - 2) where primes[i] < (primes[i-1] + primes[i+1]) / 2.0 select primes[i];\n        WriteLine($\"First 36 strong primes: {string.Join(\", \", strongPrimes.Take(36))}\");\n        WriteLine($\"There are {strongPrimes.TakeWhile(p => p < 1_000_000).Count():N0} strong primes below {1_000_000:N0}\");\n        WriteLine($\"There are {strongPrimes.TakeWhile(p => p < 10_000_000).Count():N0} strong primes below {10_000_000:N0}\");\n        WriteLine($\"First 37 weak primes: {string.Join(\", \", weakPrimes.Take(37))}\");\n        WriteLine($\"There are {weakPrimes.TakeWhile(p => p < 1_000_000).Count():N0} weak primes below {1_000_000:N0}\");\n        WriteLine($\"There are {weakPrimes.TakeWhile(p => p < 10_000_000).Count():N0} weak primes below {1_000_000:N0}\");\n    }\n   \n}\n"}
{"id": 399641, "name": "Left factorials", "source": "Translate Swift to C#: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nprefix func ! <T: BinaryInteger>(n: T) -> T {\n  guard n != 0 else {\n    return 0\n  }\n\n  return stride(from: 0, to: n, by: 1).lazy.map(factorial).reduce(0, +)\n}\n\nfor i in 0...10 {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nfor i in stride(from: BigInt(20), through: 110, by: 10) {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nprint(\"!1000 = \\((!BigInt(1000)).description.count) digit number\")\n\nprint()\n\nfor i in stride(from: BigInt(2000), through: 10_000, by: 1000) {\n  print(\"!\\(i) = \\((!i).description.count) digit number\")\n}\n", "target": "using System;\nusing System.Numerics;\n\nnamespace LeftFactorial\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i <= 10; i++)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", i, LeftFactorial(i)));\n            }\n\n            for (int j = 20; j <= 110; j += 10)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", j, LeftFactorial(j)));\n            }\n\n            for (int k = 1000; k <= 10000; k += 1000)\n            {\n                Console.WriteLine(string.Format(\"!{0} has {1} digits\", k, LeftFactorial(k).ToString().Length));\n            }\n\n            Console.ReadKey();\n        }\n\n        private static BigInteger Factorial(int number)\n        {\n            BigInteger accumulator = 1;\n\n            for (int factor = 1; factor <= number; factor++)\n            {\n                accumulator *= factor;\n            }\n\n            return accumulator;\n        }\n\n        private static BigInteger LeftFactorial(int n)\n        {\n            BigInteger result = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                result += Factorial(i);\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 399642, "name": "Left factorials", "source": "Translate Swift to C#: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nprefix func ! <T: BinaryInteger>(n: T) -> T {\n  guard n != 0 else {\n    return 0\n  }\n\n  return stride(from: 0, to: n, by: 1).lazy.map(factorial).reduce(0, +)\n}\n\nfor i in 0...10 {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nfor i in stride(from: BigInt(20), through: 110, by: 10) {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nprint(\"!1000 = \\((!BigInt(1000)).description.count) digit number\")\n\nprint()\n\nfor i in stride(from: BigInt(2000), through: 10_000, by: 1000) {\n  print(\"!\\(i) = \\((!i).description.count) digit number\")\n}\n", "target": "using System;\nusing System.Numerics;\n\nnamespace LeftFactorial\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i <= 10; i++)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", i, LeftFactorial(i)));\n            }\n\n            for (int j = 20; j <= 110; j += 10)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", j, LeftFactorial(j)));\n            }\n\n            for (int k = 1000; k <= 10000; k += 1000)\n            {\n                Console.WriteLine(string.Format(\"!{0} has {1} digits\", k, LeftFactorial(k).ToString().Length));\n            }\n\n            Console.ReadKey();\n        }\n\n        private static BigInteger Factorial(int number)\n        {\n            BigInteger accumulator = 1;\n\n            for (int factor = 1; factor <= number; factor++)\n            {\n                accumulator *= factor;\n            }\n\n            return accumulator;\n        }\n\n        private static BigInteger LeftFactorial(int n)\n        {\n            BigInteger result = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                result += Factorial(i);\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 399643, "name": "Strange unique prime triplets", "source": "Translate Swift to C#: import Foundation\n\nfunc primeSieve(limit: Int) -> [Bool] {\n    guard limit > 0 else {\n        return []\n    }\n    var sieve = Array(repeating: true, count: limit)\n    sieve[0] = false\n    if limit > 1 {\n        sieve[1] = false\n    }\n    if limit > 4 {\n        for i in stride(from: 4, to: limit, by: 2) {\n            sieve[i] = false\n        }\n    }\n    var p = 3\n    while true {\n        var q = p * p\n        if q >= limit {\n            break\n        }\n        if sieve[p] {\n            let inc = 2 * p\n            while q < limit {\n                sieve[q] = false\n                q += inc\n            }\n        }\n        p += 2\n    }\n    return sieve\n}\n\nfunc strangeUniquePrimeTriplets(limit: Int, verbose: Bool) {\n    guard limit > 5 else {\n        return;\n    }\n    let sieve = primeSieve(limit: 3 * limit)\n    var primes: [Int] = []\n    for p in stride(from: 3, to: limit, by: 2) {\n        if sieve[p] {\n            primes.append(p)\n        }\n    }\n    let n = primes.count\n    var count = 0\n    if verbose {\n        print(\"Strange unique prime triplets < \\(limit):\")\n    }\n    for i in (0..<n - 2) {\n        for j in (i + 1..<n - 1) {\n            for k in (j + 1..<n) {\n                let sum = primes[i] + primes[j] + primes[k]\n                if sieve[sum] {\n                    count += 1\n                    if verbose {\n                        print(String(format: \"%2d + %2d + %2d = %2d\",\n                                     primes[i], primes[j], primes[k], sum))\n                    }\n                }\n            }\n        }\n    }\n    print(\"\\nCount of strange unique prime triplets < \\(limit) is \\(count).\")\n}\n\nstrangeUniquePrimeTriplets(limit: 30, verbose: true)\nstrangeUniquePrimeTriplets(limit: 1000, verbose: false)\n", "target": "using System; using System.Collections.Generic; using static System.Console; using System.Linq; using DT = System.DateTime;\n\nclass Program { static void Main(string[] args) { string s;\n  foreach (int lmt in new int[]{ 90, 300, 3000, 30000, 111000 }) {\n    var pr = PG.Primes(lmt).Skip(1).ToList(); DT st = DT.Now;\n    int d, f = 0; var r = new List<string>();\n    int i = -1, m, h = (m = lmt / 3), j, k, pra, prab;\n    while (i < 0) i = pr.IndexOf(h--); k = (j = i - 1) - 1;\n    for (int a = 0; a <= k; a++) { pra = pr[a];\n    for (int b = a + 1; b <= j; b++) { prab = pra + pr[b]; \n    for (int c = b + 1; c <= i; c++) {\n      if (PG.flags[d = prab + pr[c]]) continue; f++;\n      if (lmt < 100) r.Add(string.Format(\"{3,5} = {0,2} + {1,2} + {2,2}\", pra, pr[b], pr[c], d)); } } }\n    s = \"s.u.p.t.s under \"; r.Sort(); if (r.Count > 0) WriteLine(\"{0}{1}:\\n{2}\", s, m, string.Join(\"\\n\", r));\n    if (lmt > 100) WriteLine(\"Count of {0}{1,6:n0}: {2,13:n0}  {3} sec\", s, m, f, (DT.Now - st).ToString().Substring(6)); } } }\n\nclass PG { public static bool[] flags;\n  public static IEnumerable<int> Primes(int lim) {\n  flags = new bool[lim + 1]; int j = 2;\n  for (int d = 3, sq = 4; sq <= lim; j++, sq += d += 2)\n    if (!flags[j]) { yield return j;\n      for (int k = sq; k <= lim; k += j) flags[k] = true; }\n  for (; j <= lim; j++) if (!flags[j]) yield return j; } }\n"}
{"id": 399644, "name": "Strange unique prime triplets", "source": "Translate Swift to C#: import Foundation\n\nfunc primeSieve(limit: Int) -> [Bool] {\n    guard limit > 0 else {\n        return []\n    }\n    var sieve = Array(repeating: true, count: limit)\n    sieve[0] = false\n    if limit > 1 {\n        sieve[1] = false\n    }\n    if limit > 4 {\n        for i in stride(from: 4, to: limit, by: 2) {\n            sieve[i] = false\n        }\n    }\n    var p = 3\n    while true {\n        var q = p * p\n        if q >= limit {\n            break\n        }\n        if sieve[p] {\n            let inc = 2 * p\n            while q < limit {\n                sieve[q] = false\n                q += inc\n            }\n        }\n        p += 2\n    }\n    return sieve\n}\n\nfunc strangeUniquePrimeTriplets(limit: Int, verbose: Bool) {\n    guard limit > 5 else {\n        return;\n    }\n    let sieve = primeSieve(limit: 3 * limit)\n    var primes: [Int] = []\n    for p in stride(from: 3, to: limit, by: 2) {\n        if sieve[p] {\n            primes.append(p)\n        }\n    }\n    let n = primes.count\n    var count = 0\n    if verbose {\n        print(\"Strange unique prime triplets < \\(limit):\")\n    }\n    for i in (0..<n - 2) {\n        for j in (i + 1..<n - 1) {\n            for k in (j + 1..<n) {\n                let sum = primes[i] + primes[j] + primes[k]\n                if sieve[sum] {\n                    count += 1\n                    if verbose {\n                        print(String(format: \"%2d + %2d + %2d = %2d\",\n                                     primes[i], primes[j], primes[k], sum))\n                    }\n                }\n            }\n        }\n    }\n    print(\"\\nCount of strange unique prime triplets < \\(limit) is \\(count).\")\n}\n\nstrangeUniquePrimeTriplets(limit: 30, verbose: true)\nstrangeUniquePrimeTriplets(limit: 1000, verbose: false)\n", "target": "using System; using System.Collections.Generic; using static System.Console; using System.Linq; using DT = System.DateTime;\n\nclass Program { static void Main(string[] args) { string s;\n  foreach (int lmt in new int[]{ 90, 300, 3000, 30000, 111000 }) {\n    var pr = PG.Primes(lmt).Skip(1).ToList(); DT st = DT.Now;\n    int d, f = 0; var r = new List<string>();\n    int i = -1, m, h = (m = lmt / 3), j, k, pra, prab;\n    while (i < 0) i = pr.IndexOf(h--); k = (j = i - 1) - 1;\n    for (int a = 0; a <= k; a++) { pra = pr[a];\n    for (int b = a + 1; b <= j; b++) { prab = pra + pr[b]; \n    for (int c = b + 1; c <= i; c++) {\n      if (PG.flags[d = prab + pr[c]]) continue; f++;\n      if (lmt < 100) r.Add(string.Format(\"{3,5} = {0,2} + {1,2} + {2,2}\", pra, pr[b], pr[c], d)); } } }\n    s = \"s.u.p.t.s under \"; r.Sort(); if (r.Count > 0) WriteLine(\"{0}{1}:\\n{2}\", s, m, string.Join(\"\\n\", r));\n    if (lmt > 100) WriteLine(\"Count of {0}{1,6:n0}: {2,13:n0}  {3} sec\", s, m, f, (DT.Now - st).ToString().Substring(6)); } } }\n\nclass PG { public static bool[] flags;\n  public static IEnumerable<int> Primes(int lim) {\n  flags = new bool[lim + 1]; int j = 2;\n  for (int d = 3, sq = 4; sq <= lim; j++, sq += d += 2)\n    if (!flags[j]) { yield return j;\n      for (int k = sq; k <= lim; k += j) flags[k] = true; }\n  for (; j <= lim; j++) if (!flags[j]) yield return j; } }\n"}
{"id": 399645, "name": "Motzkin numbers", "source": "Translate Swift to C#: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n}\n\nfunc motzkin(_ n: Int) -> [Int] {\n  var m = Array(repeating: 0, count: n)\n\n  m[0] = 1\n  m[1] = 1\n\n  for i in 2..<n {\n    m[i] = (m[i - 1] * (2 * i + 1) + m[i - 2] * (3 * i - 3)) / (i + 2)\n  }\n\n  return m\n}\n\nlet m = motzkin(42)\n\nfor (i, n) in m.enumerated() {\n  print(\"\\(i): \\(n) \\(n.isPrime ? \"prime\" : \"\")\")\n}\n", "target": "using System;\nusing BI = System.Numerics.BigInteger;\n \nclass Program {\n \n  \n  static bool hmf(BI x) {\n    if (x < 4) return x == 1;\n    if ((x & 1) == 0 || x % 3 == 0) return true;\n    int l = (int)Math.Sqrt((double)x); \n    for (int j = 5, d = 4; j <= l; j += d = 6 - d)\n      if (x % j == 0) return x > j;\n    return false;\n  }\n \n  static void Main(string[] args) {\n    BI a = 0, b = 1, t;\n    int n = 1, s = 0, d = 1, c = 0, f = 1;\n    while (n <= 80)\n      Console.WriteLine(\"{0,46:n0} {1}\",\n        t = b / n++,\n        hmf(t) ? \"\" : \"is prime.\",\n        t = b,\n        b = ((c += d * 3 + 3) * a +\n             (f += d * 2 + 3) * b) /\n             (s += d += 2),\n        a = t);\n  }\n}\n"}
{"id": 399646, "name": "Pythagorean quadruples", "source": "Translate Swift to C#: func missingD(upTo n: Int) -> [Int] {\n  var a2 = 0, s = 3, s1 = 0, s2 = 0\n  var res = [Int](repeating: 0, count: n + 1)\n  var ab = [Int](repeating: 0, count: n * n * 2 + 1)\n\n  for a in 1...n {\n    a2 = a * a\n\n    for b in a...n {\n      ab[a2 + b * b] = 1\n    }\n  }\n\n  for c in 1..<n {\n    s1 = s\n    s += 2\n    s2 = s\n\n    for d in c+1...n {\n      if ab[s1] != 0 {\n        res[d] = 1\n      }\n\n      s1 += s2\n      s2 += 2\n    }\n  }\n\n  return (1...n).filter({ res[$0] == 0 })\n}\n\nprint(missingD(upTo: 2200))\n", "target": "using System;\n\nnamespace PythagoreanQuadruples {\n    class Program {\n        const int MAX = 2200;\n        const int MAX2 = MAX * MAX * 2;\n\n        static void Main(string[] args) {\n            bool[] found = new bool[MAX + 1]; \n            bool[] a2b2 = new bool[MAX2 + 1]; \n            int s = 3;\n\n            for(int a = 1; a <= MAX; a++) {\n                int a2 = a * a;\n                for (int b=a; b<=MAX; b++) {\n                    a2b2[a2 + b * b] = true;\n                }\n            }\n\n            for (int c = 1; c <= MAX; c++) {\n                int s1 = s;\n                s += 2;\n                int s2 = s;\n                for (int d = c + 1; d <= MAX; d++) {\n                    if (a2b2[s1]) found[d] = true;\n                    s1 += s2;\n                    s2 += 2;\n                }\n            }\n\n            Console.WriteLine(\"The values of d <= {0} which can't be represented:\", MAX);\n            for (int d = 1; d < MAX; d++) {\n                if (!found[d]) Console.Write(\"{0}  \", d);\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 399647, "name": "Safe primes and unsafe primes", "source": "Translate Swift to C#: import Foundation\n\nclass PrimeSieve {\n    var composite: [Bool]\n    \n    init(size: Int) {\n        composite = Array(repeating: false, count: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite[p/2 - 1] {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite[q/2 - 1] = true\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite[number/2 - 1]\n    }\n}\n\nfunc commatize(_ number: Int) -> String {\n    let n = NSNumber(value: number)\n    return NumberFormatter.localizedString(from: n, number: .decimal)\n}\n\nlet limit1 = 1000000\nlet limit2 = 10000000\n\nclass PrimeInfo {\n    let maxPrint: Int\n    var count1: Int\n    var count2: Int\n    var primes: [Int]\n    \n    init(maxPrint: Int) {\n        self.maxPrint = maxPrint\n        count1 = 0\n        count2 = 0\n        primes = []\n    }\n    \n    func addPrime(prime: Int) {\n        count2 += 1\n        if prime < limit1 {\n            count1 += 1\n        }\n        if count2 <= maxPrint {\n            primes.append(prime)\n        }\n    }\n    \n    func printInfo(name: String) {\n        print(\"First \\(maxPrint) \\(name) primes: \\(primes)\")\n        print(\"Number of \\(name) primes below \\(commatize(limit1)): \\(commatize(count1))\")\n        print(\"Number of \\(name) primes below \\(commatize(limit2)): \\(commatize(count2))\")\n    }\n}\n\nvar safePrimes = PrimeInfo(maxPrint: 35)\nvar unsafePrimes = PrimeInfo(maxPrint: 40)\n\nlet sieve = PrimeSieve(size: limit2)\n\nfor prime in 2..<limit2 {\n    if sieve.isPrime(number: prime) {\n        if sieve.isPrime(number: (prime - 1)/2) {\n            safePrimes.addPrime(prime: prime)\n        } else {\n            unsafePrimes.addPrime(prime: prime)\n        }\n    }\n}\n\nsafePrimes.printInfo(name: \"safe\")\nunsafePrimes.printInfo(name: \"unsafe\")\n", "target": "using static System.Console;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class SafePrimes\n{\n    public static void Main() {\n        HashSet<int> primes = Primes(10_000_000).ToHashSet();\n        WriteLine(\"First 35 safe primes:\");\n        WriteLine(string.Join(\" \", primes.Where(IsSafe).Take(35)));\n        WriteLine($\"There are {primes.TakeWhile(p => p < 1_000_000).Count(IsSafe):n0} safe primes below {1_000_000:n0}\");\n        WriteLine($\"There are {primes.TakeWhile(p => p < 10_000_000).Count(IsSafe):n0} safe primes below {10_000_000:n0}\");\n        WriteLine(\"First 40 unsafe primes:\");\n        WriteLine(string.Join(\" \", primes.Where(IsUnsafe).Take(40)));\n        WriteLine($\"There are {primes.TakeWhile(p => p < 1_000_000).Count(IsUnsafe):n0} unsafe primes below {1_000_000:n0}\");\n        WriteLine($\"There are {primes.TakeWhile(p => p < 10_000_000).Count(IsUnsafe):n0} unsafe primes below {10_000_000:n0}\");\n\n        bool IsSafe(int prime) => primes.Contains(prime / 2);\n        bool IsUnsafe(int prime) => !primes.Contains(prime / 2);\n    }\n\n    \n    static IEnumerable<int> Primes(int bound) {\n        if (bound < 2) yield break;\n        yield return 2;\n\n        BitArray composite = new BitArray((bound - 1) / 2);\n        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;\n        for (int i = 0; i < limit; i++) {\n            if (composite[i]) continue;\n            int prime = 2 * i + 3;\n            yield return prime;\n            for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime) composite[j] = true;\n        }\n        for (int i = limit; i < composite.Count; i++) {\n            if (!composite[i]) yield return 2 * i + 3;\n        }\n    }\n\n}\n"}
{"id": 399648, "name": "Hash join", "source": "Translate Swift to C#: func hashJoin<A, B, K: Hashable>(_ first: [(K, A)], _ second: [(K, B)]) -> [(A, K, B)] {\n  var map = [K: [B]]()\n\n  for (key, val) in second {\n    map[key, default: []].append(val)\n  }\n\n  var res = [(A, K, B)]()\n\n  for (key, val) in first {\n    guard let vals = map[key] else {\n      continue\n    }\n\n    res += vals.map({ (val, key, $0) })\n  }\n\n  return res\n}\n\nlet t1 = [\n  (\"Jonah\", 27), \n  (\"Alan\", 18), \n  (\"Glory\", 28), \n  (\"Popeye\", 18), \n  (\"Alan\", 28)\n]\n\nlet t2 = [\n  (\"Jonah\", \"Whales\"), \n  (\"Jonah\", \"Spiders\"),\n  (\"Alan\", \"Ghosts\"),\n  (\"Alan\", \"Zombies\"),\n  (\"Glory\", \"Buffy\")\n]\n\nprint(\"Age | Character Name | Nemesis\")\nprint(\"----|----------------|--------\")\n\nfor (age, name, nemesis) in hashJoin(t1, t2) {\n  print(\"\\(age) | \\(name) | \\(nemesis)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace HashJoin\n{\n    public class AgeName\n    {\n        public AgeName(byte age, string name)\n        {\n            Age = age;\n            Name = name;\n        }\n        public byte Age { get; private set; }\n        public string Name { get; private set; }\n    }\n\n    public class NameNemesis\n    {\n        public NameNemesis(string name, string nemesis)\n        {\n            Name = name;\n            Nemesis = nemesis;\n        }\n        public string Name { get; private set; }\n        public string Nemesis { get; private set; }\n    }\n\n    public class DataContext\n    {\n        public DataContext()\n        {\n            AgeName = new List<AgeName>();\n            NameNemesis = new List<NameNemesis>();\n        }\n        public List<AgeName> AgeName { get; set; }\n        public List<NameNemesis> NameNemesis { get; set; }\n    }\n\n    public class AgeNameNemesis\n    {\n        public AgeNameNemesis(byte age, string name, string nemesis)\n        {\n            Age = age;\n            Name = name;\n            Nemesis = nemesis;\n        }\n        public byte Age { get; private set; }\n        public string Name { get; private set; }\n        public string Nemesis { get; private set; }\n    }\n\n    class Program\n    {\n        public static void Main()\n        {\n            var data = GetData();\n            var result = ExecuteHashJoin(data);\n            WriteResultToConsole(result);\n        }\n\n        private static void WriteResultToConsole(List<AgeNameNemesis> result)\n        {\n            result.ForEach(ageNameNemesis => Console.WriteLine(\"Age: {0}, Name: {1}, Nemesis: {2}\",\n                ageNameNemesis.Age, ageNameNemesis.Name, ageNameNemesis.Nemesis));\n        }\n\n        private static List<AgeNameNemesis> ExecuteHashJoin(DataContext data)\n        {\n            return (data.AgeName.Join(data.NameNemesis, \n                ageName => ageName.Name, nameNemesis => nameNemesis.Name,\n                (ageName, nameNemesis) => new AgeNameNemesis(ageName.Age, ageName.Name, nameNemesis.Nemesis)))\n                .ToList();\n        }\n\n        private static DataContext GetData()\n        {\n            var context = new DataContext();\n\n            context.AgeName.AddRange(new [] {\n                    new AgeName(27, \"Jonah\"), \n                    new AgeName(18, \"Alan\"), \n                    new AgeName(28, \"Glory\"), \n                    new AgeName(18, \"Popeye\"), \n                    new AgeName(28, \"Alan\")\n                });\n\n            context.NameNemesis.AddRange(new[]\n            {\n                new NameNemesis(\"Jonah\", \"Whales\"),\n                new NameNemesis(\"Jonah\", \"Spiders\"),\n                new NameNemesis(\"Alan\", \"Ghosts\"),\n                new NameNemesis(\"Alan\", \"Zombies\"),\n                new NameNemesis(\"Glory\", \"Buffy\")\n            });\n\n            return context;\n        }\n    }\n}\n"}
{"id": 399649, "name": "Speech synthesis", "source": "Translate Swift to C#: import Foundation\n\nlet task = NSTask()\ntask.launchPath = \"/usr/bin/say\"\ntask.arguments = [\"This is an example of speech synthesis.\"]\ntask.launch()\n", "target": "using SpeechLib;\n\nnamespace Speaking_Computer\n{\n  public class Program\n  {\n    private static void Main()\n    {\n      var voice = new SpVoice();\n      voice.Speak(\"This is an example of speech synthesis.\");\n    }\n  }\n}\n"}
{"id": 399650, "name": "Super-d numbers", "source": "Translate Swift to C#: import BigInt\nimport Foundation\n\nlet rd = [\"22\", \"333\", \"4444\", \"55555\", \"666666\", \"7777777\", \"88888888\", \"999999999\"]\n\nfor d in 2...9 {\n  print(\"First 10 super-\\(d) numbers:\")\n\n  var count = 0\n  var n = BigInt(3)\n  var k = BigInt(0)\n\n  while true {\n    k = n.power(d)\n    k *= BigInt(d)\n\n    if let _ = String(k).range(of: rd[d - 2]) {\n      count += 1\n\n      print(n, terminator: \" \")\n      fflush(stdout)\n\n      guard count < 10 else {\n        break\n      }\n    }\n\n    n += 1\n  }\n\n  print()\n  print()\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing BI = System.Numerics.BigInteger;\nusing lbi = System.Collections.Generic.List<System.Numerics.BigInteger[]>;\nusing static System.Console;\n\nclass Program {\n\n    \n    struct LI { public UInt64 lo, ml, mh, hi, tp; }\n\n    const UInt64 Lm = 1_000_000_000_000_000_000UL;\n    const string Fm = \"D18\";\n\n    static void inc(ref LI d, LI s) { \n        d.lo += s.lo; while (d.lo >= Lm) { d.ml++; d.lo -= Lm; }\n        d.ml += s.ml; while (d.ml >= Lm) { d.mh++; d.ml -= Lm; }\n        d.mh += s.mh; while (d.mh >= Lm) { d.hi++; d.mh -= Lm; }\n        d.hi += s.hi; while (d.hi >= Lm) { d.tp++; d.hi -= Lm; }\n        d.tp += s.tp;\n    }\n\n    static void set(ref LI d, UInt64 s) { \n        d.lo = s; d.ml = d.mh = d.hi = d.tp = 0;\n    }\n\n    const int ls = 10;\n\n    static lbi co = new lbi { new BI[] { 0 } }; \n    static List<LI[]> Co = new List<LI[]> { new LI[1] }; \n\n    static Int64 ipow(Int64 bas, Int64 exp) { \n        Int64 res = 1; while (exp != 0) {\n            if ((exp & 1) != 0) res *= bas; exp >>= 1; bas *= bas;\n        }\n        return res;\n    }\n\n    \n    static void fin() { WriteLine(\"{0}s\", (DateTime.Now - st).TotalSeconds.ToString().Substring(0, 5)); }\n\n    static void funM(int d) { \n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++)\n            if ((BI.Pow((BI)i, d) * d).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n        fin();\n    }\n\n    static void funS(int d) { \n        BI[] m = co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++) {\n            if ((d * m[0]).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--) m[k] += m[j];\n        }\n        fin();\n    }\n\n    static string scale(uint s, ref LI x) { \n        ulong Lo = x.lo * s, Ml = x.ml * s, Mh = x.mh * s, Hi = x.hi * s, Tp = x.tp * s;\n        while (Lo >= Lm) { Lo -= Lm; Ml++; }\n        while (Ml >= Lm) { Ml -= Lm; Mh++; }\n        while (Mh >= Lm) { Mh -= Lm; Hi++; }\n        while (Hi >= Lm) { Hi -= Lm; Tp++; }\n        if (Tp > 0) return Tp.ToString() + Hi.ToString(Fm) + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Hi > 0) return Hi.ToString() + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Mh > 0) return Mh.ToString() + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Ml > 0) return Ml.ToString() + Lo.ToString(Fm);\n        return Lo.ToString();\n    }\n\n    static void funF(int d) { \n        LI[] m = Co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = d, c = 0; c < ls; i++) {\n            if (scale((uint)d, ref m[0]).Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--)\n                inc(ref m[k], m[j]);\n        }\n        fin();\n    }\n\n    static void init() { \n        for (int v = 1; v < 10; v++) {\n            BI[] res = new BI[v + 1];\n            long[] f = new long[v + 1], l = new long[v + 1];\n            for (int j = 0; j <= v; j++) {\n                if (j == v) {\n                    LI[] t = new LI[v + 1];\n                    for (int y = 0; y <= v; y++) set(ref t[y], (UInt64)f[y]);\n                    Co.Add(t);\n                }\n                res[j] = f[j];\n                l[0] = f[0]; f[0] = ipow(j + 1, v);\n                for (int a = 0, b = 1; b <= v; a = b++) {\n                    l[b] = f[b]; f[b] = f[a] - l[a];\n                }\n            }\n            for (int z = res.Length - 2; z > 0; z -= 2) res[z] *= -1;\n            co.Add(res);\n        }\n    }\n\n    static DateTime st;\n\n    static void doOne(string title, int top, Action<int> func) {\n        WriteLine('\\n' + title); st = DateTime.Now;\n        for (int i = 2; i <= top; i++) func(i);\n    }\n\n    static void Main(string[] args)\n    {\n        init(); const int top = 9;\n        doOne(\"BigInteger mostly addition:\", top, funS);\n        doOne(\"BigInteger.Pow():\", top, funM);\n        doOne(\"UInt64 structure mostly addition:\", top, funF);\n    }\n}\n"}
{"id": 399651, "name": "Super-d numbers", "source": "Translate Swift to C#: import BigInt\nimport Foundation\n\nlet rd = [\"22\", \"333\", \"4444\", \"55555\", \"666666\", \"7777777\", \"88888888\", \"999999999\"]\n\nfor d in 2...9 {\n  print(\"First 10 super-\\(d) numbers:\")\n\n  var count = 0\n  var n = BigInt(3)\n  var k = BigInt(0)\n\n  while true {\n    k = n.power(d)\n    k *= BigInt(d)\n\n    if let _ = String(k).range(of: rd[d - 2]) {\n      count += 1\n\n      print(n, terminator: \" \")\n      fflush(stdout)\n\n      guard count < 10 else {\n        break\n      }\n    }\n\n    n += 1\n  }\n\n  print()\n  print()\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing BI = System.Numerics.BigInteger;\nusing lbi = System.Collections.Generic.List<System.Numerics.BigInteger[]>;\nusing static System.Console;\n\nclass Program {\n\n    \n    struct LI { public UInt64 lo, ml, mh, hi, tp; }\n\n    const UInt64 Lm = 1_000_000_000_000_000_000UL;\n    const string Fm = \"D18\";\n\n    static void inc(ref LI d, LI s) { \n        d.lo += s.lo; while (d.lo >= Lm) { d.ml++; d.lo -= Lm; }\n        d.ml += s.ml; while (d.ml >= Lm) { d.mh++; d.ml -= Lm; }\n        d.mh += s.mh; while (d.mh >= Lm) { d.hi++; d.mh -= Lm; }\n        d.hi += s.hi; while (d.hi >= Lm) { d.tp++; d.hi -= Lm; }\n        d.tp += s.tp;\n    }\n\n    static void set(ref LI d, UInt64 s) { \n        d.lo = s; d.ml = d.mh = d.hi = d.tp = 0;\n    }\n\n    const int ls = 10;\n\n    static lbi co = new lbi { new BI[] { 0 } }; \n    static List<LI[]> Co = new List<LI[]> { new LI[1] }; \n\n    static Int64 ipow(Int64 bas, Int64 exp) { \n        Int64 res = 1; while (exp != 0) {\n            if ((exp & 1) != 0) res *= bas; exp >>= 1; bas *= bas;\n        }\n        return res;\n    }\n\n    \n    static void fin() { WriteLine(\"{0}s\", (DateTime.Now - st).TotalSeconds.ToString().Substring(0, 5)); }\n\n    static void funM(int d) { \n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++)\n            if ((BI.Pow((BI)i, d) * d).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n        fin();\n    }\n\n    static void funS(int d) { \n        BI[] m = co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++) {\n            if ((d * m[0]).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--) m[k] += m[j];\n        }\n        fin();\n    }\n\n    static string scale(uint s, ref LI x) { \n        ulong Lo = x.lo * s, Ml = x.ml * s, Mh = x.mh * s, Hi = x.hi * s, Tp = x.tp * s;\n        while (Lo >= Lm) { Lo -= Lm; Ml++; }\n        while (Ml >= Lm) { Ml -= Lm; Mh++; }\n        while (Mh >= Lm) { Mh -= Lm; Hi++; }\n        while (Hi >= Lm) { Hi -= Lm; Tp++; }\n        if (Tp > 0) return Tp.ToString() + Hi.ToString(Fm) + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Hi > 0) return Hi.ToString() + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Mh > 0) return Mh.ToString() + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Ml > 0) return Ml.ToString() + Lo.ToString(Fm);\n        return Lo.ToString();\n    }\n\n    static void funF(int d) { \n        LI[] m = Co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = d, c = 0; c < ls; i++) {\n            if (scale((uint)d, ref m[0]).Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--)\n                inc(ref m[k], m[j]);\n        }\n        fin();\n    }\n\n    static void init() { \n        for (int v = 1; v < 10; v++) {\n            BI[] res = new BI[v + 1];\n            long[] f = new long[v + 1], l = new long[v + 1];\n            for (int j = 0; j <= v; j++) {\n                if (j == v) {\n                    LI[] t = new LI[v + 1];\n                    for (int y = 0; y <= v; y++) set(ref t[y], (UInt64)f[y]);\n                    Co.Add(t);\n                }\n                res[j] = f[j];\n                l[0] = f[0]; f[0] = ipow(j + 1, v);\n                for (int a = 0, b = 1; b <= v; a = b++) {\n                    l[b] = f[b]; f[b] = f[a] - l[a];\n                }\n            }\n            for (int z = res.Length - 2; z > 0; z -= 2) res[z] *= -1;\n            co.Add(res);\n        }\n    }\n\n    static DateTime st;\n\n    static void doOne(string title, int top, Action<int> func) {\n        WriteLine('\\n' + title); st = DateTime.Now;\n        for (int i = 2; i <= top; i++) func(i);\n    }\n\n    static void Main(string[] args)\n    {\n        init(); const int top = 9;\n        doOne(\"BigInteger mostly addition:\", top, funS);\n        doOne(\"BigInteger.Pow():\", top, funM);\n        doOne(\"UInt64 structure mostly addition:\", top, funF);\n    }\n}\n"}
{"id": 399652, "name": "Monads_Maybe monad", "source": "Translate Swift to C#: precedencegroup MonadPrecedence {\n\thigherThan: BitwiseShiftPrecedence\n\tassociativity: left\n}\n\ninfix operator >>-: MonadPrecedence\t\n\ntypealias Maybe = Optional\n\nextension Maybe\n{\n\tstatic func unit(_ x: Wrapped) -> Maybe<Wrapped>\n\t{\n\t\treturn Maybe(x)\n\t}\n\n\tfunc bind<T>(_ f: (Wrapped) -> Maybe<T>) -> Maybe<T>\n\t{\n\t\treturn self.flatMap(f)\n\t}\n\n\tstatic func >>- <U>(_ m: Optional<Wrapped>, _ f: (Wrapped) -> Maybe<U>) -> Maybe<U>\n\t{\n\t\treturn m.flatMap(f)\n\t}\n}\n\nfunc dividedBy2IfEven(_ x: Int) -> Maybe<Int>\n{\n\tx.isMultiple(of: 2) ? x / 2 : nil\n}\n\nfunc lineOfAs(_ x: Int) -> Maybe<String>\n{\n\tguard x >= 0 else { return nil }\n\tlet chars = Array<Character>(repeating: \"A\", count: x)\n\treturn String(chars)\n}\n\nprint(\"\\(Maybe.unit(6).bind(dividedBy2IfEven).bind(lineOfAs) ?? \"nil\")\")\nprint(\"\\(Maybe.unit(4) >>- dividedBy2IfEven >>- lineOfAs ?? \"nil\")\")\nprint(\"\\(Maybe.unit(3) >>- dividedBy2IfEven >>- lineOfAs ?? \"nil\")\")\nprint(\"\\(Maybe.unit(-4) >>- dividedBy2IfEven >>- lineOfAs ?? \"nil\")\")\n", "target": "using System;\n\nnamespace RosettaMaybe\n{\n    \n    public abstract class Maybe<T>\n    {\n        public sealed class Some : Maybe<T>\n        {\n            public Some(T value) => Value = value;\n            public T Value { get; }\n        }\n        public sealed class None : Maybe<T> { }\n    }\n\n    class Program\n    {\n        static Maybe<double> MonadicSquareRoot(double x)\n        {\n            if (x >= 0)\n            {\n                return new Maybe<double>.Some(Math.Sqrt(x));\n            }\n            else\n            {\n                return new Maybe<double>.None();\n            }\n        }\n        static void Main(string[] args)\n        {\n            foreach (double x in new double[] { 4.0D, 8.0D, -15.0D, 16.23D, -42 })\n            {\n                Maybe<double> maybe = MonadicSquareRoot(x);\n                if (maybe is Maybe<double>.Some some)\n                {\n                    Console.WriteLine($\"The square root of {x} is \" + some.Value);\n                }\n                else\n                {\n                    Console.WriteLine($\"Square root of {x} is undefined.\");\n                }\n            }\n        }\n    }\n}\n"}
{"id": 399653, "name": "Church numerals", "source": "Translate Swift to C#: func succ<A, B, C>(_ n: @escaping (@escaping (A) -> B) -> (C) -> A) -> (@escaping (A) -> B) -> (C) -> B {\n  return {f in\n    return {x in\n      return f(n(f)(x))\n    }\n  }\n}\n\nfunc zero<A, B>(_ a: A) -> (B) -> B {\n  return {b in\n    return b\n  }\n}\n\nfunc three<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(zero)))(f)(x)\n  }\n}\n\nfunc four<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(succ(zero))))(f)(x)\n  }\n}\n\nfunc add<A, B, C>(_ m: @escaping (B) -> (A) -> C) -> (@escaping (B) -> (C) -> A) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return m(f)(n(f)(x))\n      }\n    }\n  }\n}\n\nfunc mult<A, B, C>(_ m: @escaping (A) -> B) -> (@escaping (C) -> A) -> (C) -> B {\n  return {n in\n    return {f in\n      return m(n(f))\n    }\n  }\n}\n\nfunc exp<A, B, C>(_ m: A) -> (@escaping (A) -> (B) -> (C) -> C) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return n(m)(f)(x)\n      }\n    }\n  }\n}\n\nfunc church<A>(_ x: Int) -> (@escaping (A) -> A) -> (A) -> A {\n  guard x != 0 else { return zero }\n\n  return {f in\n    return {a in\n      return f(church(x - 1)(f)(a))\n    }\n  }\n}\n\nfunc unchurch<A>(_ f: (@escaping (Int) -> Int) -> (Int) -> A) -> A {\n  return f({i in\n    return i + 1\n  })(0)\n}\n\nlet a = unchurch(add(three)(four))\nlet b = unchurch(mult(three)(four))\n\nlet c = unchurch(exp(mult(four)(church(1)))(three))\nlet d = unchurch(exp(mult(three)(church(1)))(four))\n\nprint(a, b, c, d)\n", "target": "using System;\n \npublic delegate Church Church(Church f);\n \npublic static class ChurchNumeral\n{\n    public static readonly Church ChurchZero = _ => x => x;\n    public static readonly Church ChurchOne = f => f;\n \n    public static Church Successor(this Church n) => f => x => f(n(f)(x));\n    public static Church Add(this Church m, Church n) => f => x => m(f)(n(f)(x));\n    public static Church Multiply(this Church m, Church n) => f => m(n(f));\n    public static Church Exponent(this Church m, Church n) => n(m);\n    public static Church IsZero(this Church n) => n(_ => ChurchZero)(ChurchOne);\n    public static Church Predecessor(this Church n) =>\n      f => x => n(g => h => h(g(f)))(_ => x)(a => a);\n    public static Church Subtract(this Church m, Church n) => n(Predecessor)(m);\n    static Church looper(this Church v, Church d) =>\n        v(_ => v.divr(d).Successor())(ChurchZero);\n    static Church divr(this Church n, Church d) =>\n        n.Subtract(d).looper(d);\n    public static Church Divide(this Church dvdnd, Church dvsr) =>\n        (dvdnd.Successor()).divr(dvsr);\n \n    public static Church FromInt(int i) =>\n      i <= 0 ? ChurchZero : Successor(FromInt(i - 1));\n \n    public static int ToInt(this Church ch) {\n        int count = 0;\n        ch(x => { count++; return x; })(null);\n        return count;\n    }\n \n    public static void Main() {\n        Church c3 = FromInt(3);\n        Church c4 = c3.Successor();\n        Church c11 = FromInt(11);\n        Church c12 = c11.Successor();\n        int sum = c3.Add(c4).ToInt();\n        int product = c3.Multiply(c4).ToInt();\n        int exp43 = c4.Exponent(c3).ToInt();\n        int exp34 = c3.Exponent(c4).ToInt();\n        int tst0 = ChurchZero.IsZero().ToInt();\n        int pred4 = c4.Predecessor().ToInt();\n        int sub43 = c4.Subtract(c3).ToInt();\n        int div11by3 = c11.Divide(c3).ToInt();\n        int div12by3 = c12.Divide(c3).ToInt();\n        Console.Write($\"{sum} {product} {exp43} {exp34} {tst0} \");\n        Console.WriteLine($\"{pred4} {sub43} {div11by3} {div12by3}\");\n    } \n}\n"}
{"id": 399654, "name": "Church numerals", "source": "Translate Swift to C#: func succ<A, B, C>(_ n: @escaping (@escaping (A) -> B) -> (C) -> A) -> (@escaping (A) -> B) -> (C) -> B {\n  return {f in\n    return {x in\n      return f(n(f)(x))\n    }\n  }\n}\n\nfunc zero<A, B>(_ a: A) -> (B) -> B {\n  return {b in\n    return b\n  }\n}\n\nfunc three<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(zero)))(f)(x)\n  }\n}\n\nfunc four<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(succ(zero))))(f)(x)\n  }\n}\n\nfunc add<A, B, C>(_ m: @escaping (B) -> (A) -> C) -> (@escaping (B) -> (C) -> A) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return m(f)(n(f)(x))\n      }\n    }\n  }\n}\n\nfunc mult<A, B, C>(_ m: @escaping (A) -> B) -> (@escaping (C) -> A) -> (C) -> B {\n  return {n in\n    return {f in\n      return m(n(f))\n    }\n  }\n}\n\nfunc exp<A, B, C>(_ m: A) -> (@escaping (A) -> (B) -> (C) -> C) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return n(m)(f)(x)\n      }\n    }\n  }\n}\n\nfunc church<A>(_ x: Int) -> (@escaping (A) -> A) -> (A) -> A {\n  guard x != 0 else { return zero }\n\n  return {f in\n    return {a in\n      return f(church(x - 1)(f)(a))\n    }\n  }\n}\n\nfunc unchurch<A>(_ f: (@escaping (Int) -> Int) -> (Int) -> A) -> A {\n  return f({i in\n    return i + 1\n  })(0)\n}\n\nlet a = unchurch(add(three)(four))\nlet b = unchurch(mult(three)(four))\n\nlet c = unchurch(exp(mult(four)(church(1)))(three))\nlet d = unchurch(exp(mult(three)(church(1)))(four))\n\nprint(a, b, c, d)\n", "target": "using System;\n \npublic delegate Church Church(Church f);\n \npublic static class ChurchNumeral\n{\n    public static readonly Church ChurchZero = _ => x => x;\n    public static readonly Church ChurchOne = f => f;\n \n    public static Church Successor(this Church n) => f => x => f(n(f)(x));\n    public static Church Add(this Church m, Church n) => f => x => m(f)(n(f)(x));\n    public static Church Multiply(this Church m, Church n) => f => m(n(f));\n    public static Church Exponent(this Church m, Church n) => n(m);\n    public static Church IsZero(this Church n) => n(_ => ChurchZero)(ChurchOne);\n    public static Church Predecessor(this Church n) =>\n      f => x => n(g => h => h(g(f)))(_ => x)(a => a);\n    public static Church Subtract(this Church m, Church n) => n(Predecessor)(m);\n    static Church looper(this Church v, Church d) =>\n        v(_ => v.divr(d).Successor())(ChurchZero);\n    static Church divr(this Church n, Church d) =>\n        n.Subtract(d).looper(d);\n    public static Church Divide(this Church dvdnd, Church dvsr) =>\n        (dvdnd.Successor()).divr(dvsr);\n \n    public static Church FromInt(int i) =>\n      i <= 0 ? ChurchZero : Successor(FromInt(i - 1));\n \n    public static int ToInt(this Church ch) {\n        int count = 0;\n        ch(x => { count++; return x; })(null);\n        return count;\n    }\n \n    public static void Main() {\n        Church c3 = FromInt(3);\n        Church c4 = c3.Successor();\n        Church c11 = FromInt(11);\n        Church c12 = c11.Successor();\n        int sum = c3.Add(c4).ToInt();\n        int product = c3.Multiply(c4).ToInt();\n        int exp43 = c4.Exponent(c3).ToInt();\n        int exp34 = c3.Exponent(c4).ToInt();\n        int tst0 = ChurchZero.IsZero().ToInt();\n        int pred4 = c4.Predecessor().ToInt();\n        int sub43 = c4.Subtract(c3).ToInt();\n        int div11by3 = c11.Divide(c3).ToInt();\n        int div12by3 = c12.Divide(c3).ToInt();\n        Console.Write($\"{sum} {product} {exp43} {exp34} {tst0} \");\n        Console.WriteLine($\"{pred4} {sub43} {div11by3} {div12by3}\");\n    } \n}\n"}
{"id": 399655, "name": "Send an unknown method call", "source": "Translate Swift to C#: import Foundation\n\nclass MyUglyClass: NSObject {\n  @objc\n  func myUglyFunction() {\n    print(\"called myUglyFunction\")\n  }\n}\n\nlet someObject: NSObject = MyUglyClass()\n\nsomeObject.perform(NSSelectorFromString(\"myUglyFunction\"))\n", "target": "using System;\n\nclass Example\n{\n    public int foo(int x)\n    {\n        return 42 + x;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var example = new Example();\n        var method = \"foo\";\n        \n        var result = (int)example.GetType().GetMethod(method).Invoke(example, new object[]{ 5 });\n        Console.WriteLine(\"{0}(5) = {1}\", method, result);\n    }\n}\n"}
{"id": 399656, "name": "Long primes", "source": "Translate Swift to C#: public struct Eratosthenes: Sequence, IteratorProtocol {\n  private let n: Int\n  private let limit: Int\n\n  private var i = 2\n  private var sieve: [Int]\n\n  public init(upTo: Int) {\n    if upTo <= 1 {\n      self.n = 0\n      self.limit = -1\n      self.sieve = []\n    } else {\n      self.n = upTo\n      self.limit = Int(Double(n).squareRoot())\n      self.sieve = Array(0...n)\n    }\n  }\n\n  public mutating func next() -> Int? {\n    while i < n {\n      defer { i += 1 }\n\n      if sieve[i] != 0 {\n        if i <= limit {\n          for notPrime in stride(from: i * i, through: n, by: i) {\n            sieve[notPrime] = 0\n          }\n        }\n\n        return i\n      }\n    }\n\n    return nil\n  }\n}\n\nfunc findPeriod(n: Int) -> Int {\n  let r = (1...n+1).reduce(1, {res, _ in (10 * res) % n })\n  var rr = r\n  var period = 0\n\n  repeat {\n    rr = (10 * rr) % n\n    period += 1\n  } while r != rr\n\n  return period\n}\n\nlet longPrimes = Eratosthenes(upTo: 64000).dropFirst().lazy.filter({ findPeriod(n: $0) == $0 - 1 })\n\nprint(\"Long primes less than 500: \\(Array(longPrimes.prefix(while: { $0 <= 500 })))\")\n\nlet counts =\n  longPrimes.reduce(into: [500: 0, 1000: 0, 2000: 0, 4000: 0, 8000: 0, 16000: 0, 32000: 0, 64000: 0], {counts, n in\n    for key in counts.keys where n < key {\n      counts[key]! += 1\n    }\n  })\n\nfor key in counts.keys.sorted() {\n  print(\"There are \\(counts[key]!) long primes less than \\(key)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class LongPrimes\n{\n    public static void Main() {\n        var primes = SomePrimeGenerator.Primes(64000).Skip(1).Where(p => Period(p) == p - 1).Append(99999);\n        Console.WriteLine(string.Join(\" \", primes.TakeWhile(p => p <= 500)));\n        int count = 0, limit = 500;\n        foreach (int prime in primes) {\n            if (prime > limit) {\n                Console.WriteLine($\"There are {count} long primes below {limit}\");\n                limit *= 2;\n            }\n            count++;\n        }\n\n        int Period(int n) {\n            int r = 1, rr;\n            for (int i = 0; i <= n; i++) r = 10 * r % n;\n            rr = r;\n            for (int period = 1;; period++) {\n                r = (10 * r) % n;\n                if (r == rr) return period;\n            }\n        }\n    }\n\n}\n\nstatic class SomePrimeGenerator {\n\n    public static IEnumerable<int> Primes(int lim) {\n        bool [] flags = new bool[lim + 1]; int j = 2;\n        for (int d = 3, sq = 4; sq <= lim; j++, sq += d += 2)\n            if (!flags[j]) {\n                yield return j; for (int k = sq; k <= lim; k += j)\n                    flags[k] = true;\n            }\n        for (; j<= lim; j++) if (!flags[j]) yield return j;\n    }\n}\n"}
{"id": 399657, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Swift to C#: \nimport Foundation\n\n\nstruct Stack<T> {\n\tprivate(set) var elements = [T]()\n\t\n\tvar isEmpty: Bool {\n\t\telements.isEmpty\n\t}\n\t\n\tvar top: T? {\n\t\telements.last\n\t}\n\t\n\tmutating func push(_ newElement: T) {\n\t\telements.append(newElement)\n\t}\n\t\n\tmutating func pop() -> T? {\n\t\tself.isEmpty ? nil : elements.removeLast()\n\t}\n}\n\nstruct Queue<T> {\n\tprivate(set) var elements = [T]()\n\t\n\tvar isEmpty: Bool {\n\t\telements.isEmpty\n\t}\n\t\n\tmutating func enqueue(_ newElement: T) {\n\t\telements.append(newElement)\n\t}\n\t\n\tmutating func dequeue() -> T {\n\t\treturn elements.removeFirst()\n\t}\n}\n\nenum Associativity {\n\tcase Left, Right\n}\n\n\nprotocol OperatorType: Comparable, Hashable {\n\tvar name: String { get }\n\tvar precedence: Int { get }\n\tvar associativity: Associativity { get }\n}\n\nstruct Operator: OperatorType {\n\tlet name: String\n\tlet precedence: Int\n\tlet associativity: Associativity\n\t\n\t\n\tfunc hash(into hasher: inout Hasher) {\n\t\thasher.combine(self.name)\n\t}\n\t\n\tinit(_ name: String, _ precedence: Int, _ associativity: Associativity) {\n\t\tself.name = name; self.precedence = precedence; self.associativity = associativity\n\t}\n}\n\nfunc ==(x: Operator, y: Operator) -> Bool {\n\t\n\tx.name == y.name\n}\n\nfunc <(x: Operator, y: Operator) -> Bool {\n\t\n\t(x.associativity == .Left && x.precedence == y.precedence) || x.precedence < y.precedence\n}\n\nextension Set where Element: OperatorType {\n\tfunc contains(_ operatorName: String) -> Bool {\n\t\tcontains { $0.name == operatorName }\n\t}\n\t\n\tsubscript (operatorName: String) -> Element? {\n\t\tget {\n\t\t\tfilter { $0.name == operatorName }.first\n\t\t}\n\t}\n}\n\n\nextension String {\n\tvar isNumber: Bool { return Double(self) != nil }\n}\n\nstruct ShuntingYard {\n\tenum ParseError: Error {\n\t\tcase MismatchedParenthesis(parenthesis: String, expression: String)\n\t\tcase UnrecognizedToken(token: String, expression: String)\n\t\tcase ExtraneousToken(token: String, expression: String)\n\t}\n\t\n\tstatic func parse(_ input: String, operators: Set<Operator>) throws -> String {\n\t\tvar stack = Stack<String>()\n\t\tvar output = Queue<String>()\n\t\tlet tokens = input.components(separatedBy: \" \")\n\t\t\n\t\tfor token in tokens {\n\t\t\t\n\t\t\tif token.isNumber {\n\t\t\t\t\n\t\t\t\toutput.enqueue(token)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif operators.contains(token) {\n\t\t\t\t\n\t\t\t\twhile let top = stack.top,\n\t\t\t\t\t  operators.contains(top) && Self.hasLowerPrecedence(token, top, operators) {\n\t\t\t\t\t\n\t\t\t\t\toutput.enqueue(stack.pop()!)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstack.push(token)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif token == \"(\" {\n\t\t\t\t\n\t\t\t\tstack.push(token)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif token == \")\" {\n\t\t\t\t\n\t\t\t\twhile let top = stack.top, top != \"(\" {\n\t\t\t\t\t\n\t\t\t\t\toutput.enqueue(stack.pop()!)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tguard let _ = stack.pop() else {\n\t\t\t\t\t\n\t\t\t\t\tthrow ParseError.MismatchedParenthesis(parenthesis: \")\", expression: input)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tthrow ParseError.UnrecognizedToken(token: token, expression: token)\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\twhile let top = stack.top,\n\t\t\t  operators.contains(top) {\n\t\t\t\n\t\t\toutput.enqueue(stack.pop()!)\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tif let top = stack.pop() {\n\t\t\tthrow (\n\t\t\t\ttop == \"(\"\n\t\t\t\t? ParseError.MismatchedParenthesis(parenthesis: \"(\", expression: input)\n\t\t\t\t: ParseError.ExtraneousToken(token: top, expression: input)\n\t\t\t)\n\t\t}\n\t\t\n\t\treturn output.elements.joined(separator: \" \")\n\t}\n\t\n\tstatic private func hasLowerPrecedence(_ firstToken: String, _ secondToken: String, _ operators: Set<Operator>) -> Bool {\n\t\tguard let firstOperator = operators[firstToken],\n\t\t\t  let secondOperator = operators[secondToken] else {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\treturn firstOperator < secondOperator\n\t}\n}\n\n\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        string infix = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\";\n        Console.WriteLine(infix.ToPostfix());\n    }\n}\n\npublic static class ShuntingYard\n{\n    private static readonly Dictionary<string, (string symbol, int precedence, bool rightAssociative)> operators\n        = new (string symbol, int precedence, bool rightAssociative) [] {\n            (\"^\", 4, true),\n            (\"*\", 3, false),\n            (\"/\", 3, false),\n            (\"+\", 2, false),\n            (\"-\", 2, false)\n    }.ToDictionary(op => op.symbol);\n\n    public static string ToPostfix(this string infix) {\n        string[] tokens = infix.Split(' ');\n        var stack = new Stack<string>();\n        var output = new List<string>();\n        foreach (string token in tokens) {\n            if (int.TryParse(token, out _)) {\n                output.Add(token);\n                Print(token);\n            } else if (operators.TryGetValue(token, out var op1)) {\n                while (stack.Count > 0 && operators.TryGetValue(stack.Peek(), out var op2)) {\n                    int c = op1.precedence.CompareTo(op2.precedence);\n                    if (c < 0 || !op1.rightAssociative && c <= 0) {\n                        output.Add(stack.Pop());\n                    } else {\n                        break;\n                    }\n                }\n                stack.Push(token);\n                Print(token);\n            } else if (token == \"(\") {\n                stack.Push(token);\n                Print(token);\n            } else if (token == \")\") {\n                string top = \"\";\n                while (stack.Count > 0 && (top = stack.Pop()) != \"(\") {\n                    output.Add(top);\n                }\n                if (top != \"(\") throw new ArgumentException(\"No matching left parenthesis.\");\n                Print(token);\n            }\n        }\n        while (stack.Count > 0) {\n            var top = stack.Pop();\n            if (!operators.ContainsKey(top)) throw new ArgumentException(\"No matching right parenthesis.\");\n            output.Add(top);\n        }\n        Print(\"pop\");\n        return string.Join(\" \", output);\n        \n        \n        void Print(string action) => Console.WriteLine($\"{action + \":\",-4} {$\"stack[ {string.Join(\" \", stack.Reverse())} ]\",-18} {$\"out[ {string.Join(\" \", output)} ]\"}\");\n        \n        void Print(string action) => Console.WriteLine(\"{0,-4} {1,-18} {2}\", action + \":\", $\"stack[ {string.Join(\" \", stack.Reverse())} ]\", $\"out[ {string.Join(\" \", output)} ]\");\n    }\n}\n"}
{"id": 399658, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Swift to C#: let ld10 = log(2.0) / log(10.0)\n\nfunc p(L: Int, n: Int) -> Int {\n  var l = L\n  var digits = 1\n\n  while l >= 10 {\n    digits *= 10\n    l /= 10\n  }\n\n  var count = 0\n  var i = 0\n\n  while count < n {\n    let rhs = (Double(i) * ld10).truncatingRemainder(dividingBy: 1)\n    let e = exp(log(10.0) * rhs)\n\n    if Int(e * Double(digits)) == L {\n      count += 1\n    }\n\n    i += 1\n  }\n\n  return i - 1\n}\n\nlet cases = [\n  (12, 1),\n  (12, 2),\n  (123, 45),\n  (123, 12345),\n  (123, 678910)\n]\n\nfor (l, n) in cases {\n  print(\"p(\\(l), \\(n)) = \\(p(L: l, n: n))\")\n}\n", "target": "\n\nusing System;\n\nclass Program {\n\n    \n    static long js(int l, int n) {\n        long res = 0, f = 1;\n        double lf = Math.Log10(2);\n        for (int i = l; i > 10; i /= 10) f *= 10;\n        while (n > 0)\n            if ((int)(f * Math.Pow(10, ++res * lf % 1)) == l) n--;\n        return res;\n    }\n\n    \n    static long gi(int ld, int n) {\n        string Ls = ld.ToString();\n        long res = 0, count = 0, f = 1;\n        for (int i = 1; i <= 18 - Ls.Length; i++) f *= 10;\n        const long ten18 = (long)1e18; long probe = 1;\n        do {\n            probe <<= 1; res++; if (probe >= ten18)\n                do {\n                    if (probe >= ten18) probe /= 10;\n                    if (probe / f == ld)\n                        if (++count >= n) { count--; break; }\n                    probe <<= 1; res++;\n                } while (true);\n            string ps = probe.ToString();\n            if (ps.Substring(0, Math.Min(Ls.Length, ps.Length)) == Ls)\n                if (++count >= n) break;\n        } while (true);\n        return res;\n    }\n\n    \n    static long pa(int ld, int n) {\n        double L_float64 = Math.Pow(2, 64);\n        ulong Log10_2_64 = (ulong)(L_float64 * Math.Log10(2));\n        double Log10Num; ulong LmtUpper, LmtLower, Frac64;\n        long res = 0, dgts = 1, cnt;\n        for (int i = ld; i >= 10; i /= 10) dgts *= 10;\n        Log10Num = Math.Log10((ld + 1.0) / dgts);\n        \n        if (Log10Num >= 0.5) {\n            LmtUpper = (ld + 1.0) / dgts < 10.0 ? (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2) : 0;\n            Log10Num = Math.Log10((double)ld / dgts);\n            LmtLower = (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2);\n        } else {\n            LmtUpper = (ulong)(Log10Num * L_float64);\n            LmtLower = (ulong)(Math.Log10((double)ld / dgts) * L_float64);\n        }\n        cnt = 0; Frac64 = 0; if (LmtUpper != 0)\n            do {\n                res++; Frac64 += Log10_2_64;\n                if ((Frac64 >= LmtLower) & (Frac64 < LmtUpper))\n                    if (++cnt >= n) break;\n            } while (true);\n        else \n            do {\n                res++; Frac64 += Log10_2_64;\n                if (Frac64 >= LmtLower) if (++cnt >= n) break;\n            } while (true);\n        return res;\n    }\n\n    static int[] values = new int[] { 12, 1, 12, 2, 123, 45, 123, 12345, 123, 678910, 99, 1 };\n\n    static void doOne(string name, Func<int, int, long> fun) {\n        Console.WriteLine(\"{0} version:\", name);\n        var start = DateTime.Now;\n        for (int i = 0; i < values.Length; i += 2)\n            Console.WriteLine(\"p({0,3}, {1,6}) = {2,11:n0}\", values[i], values[i + 1], fun(values[i], values[i + 1]));\n        Console.WriteLine(\"Took {0} seconds\\n\", DateTime.Now - start);\n    }\n\n    static void Main() {\n        doOne(\"java simple\", js);\n        doOne(\"go integer\", gi);\n        doOne(\"pascal alternative\", pa);\n    }\n}\n"}
{"id": 399659, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Swift to C#: let ld10 = log(2.0) / log(10.0)\n\nfunc p(L: Int, n: Int) -> Int {\n  var l = L\n  var digits = 1\n\n  while l >= 10 {\n    digits *= 10\n    l /= 10\n  }\n\n  var count = 0\n  var i = 0\n\n  while count < n {\n    let rhs = (Double(i) * ld10).truncatingRemainder(dividingBy: 1)\n    let e = exp(log(10.0) * rhs)\n\n    if Int(e * Double(digits)) == L {\n      count += 1\n    }\n\n    i += 1\n  }\n\n  return i - 1\n}\n\nlet cases = [\n  (12, 1),\n  (12, 2),\n  (123, 45),\n  (123, 12345),\n  (123, 678910)\n]\n\nfor (l, n) in cases {\n  print(\"p(\\(l), \\(n)) = \\(p(L: l, n: n))\")\n}\n", "target": "\n\nusing System;\n\nclass Program {\n\n    \n    static long js(int l, int n) {\n        long res = 0, f = 1;\n        double lf = Math.Log10(2);\n        for (int i = l; i > 10; i /= 10) f *= 10;\n        while (n > 0)\n            if ((int)(f * Math.Pow(10, ++res * lf % 1)) == l) n--;\n        return res;\n    }\n\n    \n    static long gi(int ld, int n) {\n        string Ls = ld.ToString();\n        long res = 0, count = 0, f = 1;\n        for (int i = 1; i <= 18 - Ls.Length; i++) f *= 10;\n        const long ten18 = (long)1e18; long probe = 1;\n        do {\n            probe <<= 1; res++; if (probe >= ten18)\n                do {\n                    if (probe >= ten18) probe /= 10;\n                    if (probe / f == ld)\n                        if (++count >= n) { count--; break; }\n                    probe <<= 1; res++;\n                } while (true);\n            string ps = probe.ToString();\n            if (ps.Substring(0, Math.Min(Ls.Length, ps.Length)) == Ls)\n                if (++count >= n) break;\n        } while (true);\n        return res;\n    }\n\n    \n    static long pa(int ld, int n) {\n        double L_float64 = Math.Pow(2, 64);\n        ulong Log10_2_64 = (ulong)(L_float64 * Math.Log10(2));\n        double Log10Num; ulong LmtUpper, LmtLower, Frac64;\n        long res = 0, dgts = 1, cnt;\n        for (int i = ld; i >= 10; i /= 10) dgts *= 10;\n        Log10Num = Math.Log10((ld + 1.0) / dgts);\n        \n        if (Log10Num >= 0.5) {\n            LmtUpper = (ld + 1.0) / dgts < 10.0 ? (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2) : 0;\n            Log10Num = Math.Log10((double)ld / dgts);\n            LmtLower = (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2);\n        } else {\n            LmtUpper = (ulong)(Log10Num * L_float64);\n            LmtLower = (ulong)(Math.Log10((double)ld / dgts) * L_float64);\n        }\n        cnt = 0; Frac64 = 0; if (LmtUpper != 0)\n            do {\n                res++; Frac64 += Log10_2_64;\n                if ((Frac64 >= LmtLower) & (Frac64 < LmtUpper))\n                    if (++cnt >= n) break;\n            } while (true);\n        else \n            do {\n                res++; Frac64 += Log10_2_64;\n                if (Frac64 >= LmtLower) if (++cnt >= n) break;\n            } while (true);\n        return res;\n    }\n\n    static int[] values = new int[] { 12, 1, 12, 2, 123, 45, 123, 12345, 123, 678910, 99, 1 };\n\n    static void doOne(string name, Func<int, int, long> fun) {\n        Console.WriteLine(\"{0} version:\", name);\n        var start = DateTime.Now;\n        for (int i = 0; i < values.Length; i += 2)\n            Console.WriteLine(\"p({0,3}, {1,6}) = {2,11:n0}\", values[i], values[i + 1], fun(values[i], values[i + 1]));\n        Console.WriteLine(\"Took {0} seconds\\n\", DateTime.Now - start);\n    }\n\n    static void Main() {\n        doOne(\"java simple\", js);\n        doOne(\"go integer\", gi);\n        doOne(\"pascal alternative\", pa);\n    }\n}\n"}
{"id": 399660, "name": "Pierpont primes", "source": "Translate Swift to C#: import BigInt\nimport Foundation\n\npublic func pierpoint(n: Int) -> (first: [BigInt], second: [BigInt]) {\n  var primes = (first: [BigInt](repeating: 0, count: n), second: [BigInt](repeating: 0, count: n))\n\n  primes.first[0] = 2\n\n  var count1 = 1, count2 = 0\n  var s = [BigInt(1)]\n  var i2 = 0, i3 = 0, k = 1\n  var n2 = BigInt(0), n3 = BigInt(0), t = BigInt(0)\n\n  while min(count1, count2) < n {\n    n2 = s[i2] * 2\n    n3 = s[i3] * 3\n\n    if n2 < n3 {\n      t = n2\n      i2 += 1\n    } else {\n      t = n3\n      i3 += 1\n    }\n\n    if t <= s[k - 1] {\n      continue\n    }\n\n    s.append(t)\n    k += 1\n    t += 1\n\n    if count1 < n && t.isPrime(rounds: 10) {\n      primes.first[count1] = t\n      count1 += 1\n    }\n\n    t -= 2\n\n    if count2 < n && t.isPrime(rounds: 10) {\n      primes.second[count2] = t\n      count2 += 1\n    }\n  }\n\n  return primes\n}\n\n\nlet primes = pierpoint(n: 250)\n\nprint(\"First 50 Pierpoint primes of the first kind: \\(Array(primes.first.prefix(50)))\\n\")\nprint(\"First 50 Pierpoint primes of the second kind: \\(Array(primes.second.prefix(50)))\")\nprint()\nprint(\"250th Pierpoint prime of the first kind: \\(primes.first[249])\")\nprint(\"250th Pierpoint prime of the second kind: \\(primes.second[249])\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace PierpontPrimes {\n    public static class Helper {\n        private static readonly Random rand = new Random();\n        private static readonly List<int> primeList = new List<int>() {\n              2,   3,   5,   7,  11,  13,  17,  19,  23,  29,  31,  37,  41,  43, 47,\n             53,  59,  61,  67,  71,  73,  79,  83,  89,  97, 101, 103, 107, 109, 113,\n            127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\n            199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\n            283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,\n            383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463,\n            467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571,\n            577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659,\n            661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761,\n            769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863,\n            877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\n        };\n\n        public static BigInteger GetRandom(BigInteger min, BigInteger max) {\n            var bytes = max.ToByteArray();\n            BigInteger r;\n\n            do {\n                rand.NextBytes(bytes);\n                bytes[bytes.Length - 1] &= (byte)0x7F; \n                r = new BigInteger(bytes);\n            } while (r < min || r >= max);\n\n            return r;\n        }\n\n        \n        public static bool IsProbablePrime(this BigInteger n) {\n            if (n == 0 || n == 1) {\n                return false;\n            }\n\n            bool Check(BigInteger num) {\n                foreach (var prime in primeList) {\n                    if (num == prime) {\n                        return true;\n                    }\n                    if (num % prime == 0) {\n                        return false;\n                    }\n                    if (prime * prime > num) {\n                        return true;\n                    }\n                }\n\n                return true;\n            }\n\n            if (Check(n)) {\n                var large = primeList[primeList.Count - 1];\n                if (n <= large) {\n                    return true;\n                }\n            }\n\n            var s = 0;\n            var d = n - 1;\n            while (d.IsEven) {\n                d >>= 1;\n                s++;\n            }\n\n            bool TrialComposite(BigInteger a) {\n                if (BigInteger.ModPow(a, d, n) == 1) {\n                    return false;\n                }\n                for (int i = 0; i < s; i++) {\n                    var t = BigInteger.Pow(2, i);\n                    if (BigInteger.ModPow(a, t * d, n) == n - 1) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            for (int i = 0; i < 8; i++) {\n                var a = GetRandom(2, n);\n                if (TrialComposite(a)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    class Program {\n        static List<List<BigInteger>> Pierpont(int n) {\n            var p = new List<List<BigInteger>> {\n                new List<BigInteger>(),\n                new List<BigInteger>()\n            };\n            for (int i = 0; i < n; i++) {\n                p[0].Add(0);\n                p[1].Add(0);\n            }\n            p[0][0] = 2;\n\n            var count = 0;\n            var count1 = 1;\n            var count2 = 0;\n            List<BigInteger> s = new List<BigInteger> { 1 };\n            var i2 = 0;\n            var i3 = 0;\n            var k = 1;\n            BigInteger n2;\n            BigInteger n3;\n            BigInteger t;\n\n            while (count < n) {\n                n2 = s[i2] * 2;\n                n3 = s[i3] * 3;\n                if (n2 < n3) {\n                    t = n2;\n                    i2++;\n                } else {\n                    t = n3;\n                    i3++;\n                }\n                if (t > s[k - 1]) {\n                    s.Add(t);\n                    k++;\n                    t += 1;\n                    if (count1 < n && t.IsProbablePrime()) {\n                        p[0][count1] = t;\n                        count1++;\n                    }\n                    t -= 2;\n                    if (count2 < n && t.IsProbablePrime()) {\n                        p[1][count2] = t;\n                        count2++;\n                    }\n                    count = Math.Min(count1, count2);\n                }\n            }\n\n            return p;\n        }\n\n        static void Main() {\n            var p = Pierpont(250);\n\n            Console.WriteLine(\"First 50 Pierpont primes of the first kind:\");\n            for (int i = 0; i < 50; i++) {\n                Console.Write(\"{0,8} \", p[0][i]);\n                if ((i - 9) % 10 == 0) {\n                    Console.WriteLine();\n                }\n            }\n            Console.WriteLine();\n\n            Console.WriteLine(\"First 50 Pierpont primes of the second kind:\");\n            for (int i = 0; i < 50; i++) {\n                Console.Write(\"{0,8} \", p[1][i]);\n                if ((i - 9) % 10 == 0) {\n                    Console.WriteLine();\n                }\n            }\n            Console.WriteLine();\n\n            Console.WriteLine(\"250th Pierpont prime of the first kind: {0}\", p[0][249]);\n            Console.WriteLine(\"250th Pierpont prime of the second kind: {0}\", p[1][249]);\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 399661, "name": "N-smooth numbers", "source": "Translate Swift to C#: import BigInt\nimport Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) {\n      if self % i == 0 {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\n@inlinable\npublic func smoothN<T: BinaryInteger>(n: T, count: Int) -> [T] {\n  let primes = stride(from: 2, to: n + 1, by: 1).filter({ $0.isPrime })\n  var next = primes\n  var indices = [Int](repeating: 0, count: primes.count)\n  var res = [T](repeating: 0, count: count)\n\n  res[0] = 1\n\n  guard count > 1 else {\n    return res\n  }\n\n  for m in 1..<count {\n    res[m] = next.min()!\n\n    for i in 0..<indices.count where res[m] == next[i] {\n      indices[i] += 1\n      next[i] = primes[i] * res[indices[i]]\n    }\n  }\n\n  return res\n}\n\nfor n in 2...29 where n.isPrime {\n  print(\"The first 25 \\(n)-smooth numbers are: \\(smoothN(n: n, count: 25))\")\n}\n\nprint()\n\nfor n in 3...29 where n.isPrime {\n  print(\"The 3000...3002 \\(n)-smooth numbers are: \\(smoothN(n: BigInt(n), count: 3002).dropFirst(2999).prefix(3))\")\n}\n\nprint()\n\nfor n in 503...521 where n.isPrime {\n  print(\"The 30,000...30,019 \\(n)-smooth numbers are: \\(smoothN(n: BigInt(n), count: 30_019).dropFirst(29999).prefix(20))\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace NSmooth {\n    class Program {\n        static readonly List<BigInteger> primes = new List<BigInteger>();\n        static readonly List<int> smallPrimes = new List<int>();\n\n        static Program() {\n            primes.Add(2);\n            smallPrimes.Add(2);\n\n            BigInteger i = 3;\n            while (i <= 521) {\n                if (IsPrime(i)) {\n                    primes.Add(i);\n                    if (i <= 29) {\n                        smallPrimes.Add((int)i);\n                    }\n                }\n                i += 2;\n            }\n        }\n\n        static bool IsPrime(BigInteger value) {\n            if (value < 2) return false;\n\n            if (value % 2 == 0) return value == 2;\n            if (value % 3 == 0) return value == 3;\n\n            if (value % 5 == 0) return value == 5;\n            if (value % 7 == 0) return value == 7;\n\n            if (value % 11 == 0) return value == 11;\n            if (value % 13 == 0) return value == 13;\n\n            if (value % 17 == 0) return value == 17;\n            if (value % 19 == 0) return value == 19;\n\n            if (value % 23 == 0) return value == 23;\n\n            BigInteger t = 29;\n            while (t * t < value) {\n                if (value % t == 0) return false;\n                value += 2;\n\n                if (value % t == 0) return false;\n                value += 4;\n            }\n\n            return true;\n        }\n\n        static List<BigInteger> NSmooth(int n, int size) {\n            if (n < 2 || n > 521) {\n                throw new ArgumentOutOfRangeException(\"n\");\n            }\n            if (size < 1) {\n                throw new ArgumentOutOfRangeException(\"size\");\n            }\n\n            BigInteger bn = n;\n            bool ok = false;\n            foreach (var prime in primes) {\n                if (bn == prime) {\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok) {\n                throw new ArgumentException(\"must be a prime number\", \"n\");\n            }\n\n            BigInteger[] ns = new BigInteger[size];\n            ns[0] = 1;\n            for (int i = 1; i < size; i++) {\n                ns[i] = 0;\n            }\n\n            List<BigInteger> next = new List<BigInteger>();\n            foreach (var prime in primes) {\n                if (prime > bn) {\n                    break;\n                }\n                next.Add(prime);\n            }\n\n            int[] indices = new int[next.Count];\n            for (int i = 0; i < indices.Length; i++) {\n                indices[i] = 0;\n            }\n            for (int m = 1; m < size; m++) {\n                ns[m] = next.Min();\n                for (int i = 0; i < indices.Length; i++) {\n                    if (ns[m] == next[i]) {\n                        indices[i]++;\n                        next[i] = primes[i] * ns[indices[i]];\n                    }\n                }\n            }\n\n            return ns.ToList();\n        }\n\n        static void Println<T>(IEnumerable<T> nums) {\n            Console.Write('[');\n\n            var it = nums.GetEnumerator();\n            if (it.MoveNext()) {\n                Console.Write(it.Current);\n            }\n            while (it.MoveNext()) {\n                Console.Write(\", \");\n                Console.Write(it.Current);\n            }\n\n            Console.WriteLine(']');\n        }\n\n        static void Main() {\n            foreach (var i in smallPrimes) {\n                Console.WriteLine(\"The first {0}-smooth numbers are:\", i);\n                Println(NSmooth(i, 25));\n                Console.WriteLine();\n            }\n            foreach (var i in smallPrimes.Skip(1)) {\n                Console.WriteLine(\"The 3,000 to 3,202 {0}-smooth numbers are:\", i);\n                Println(NSmooth(i, 3_002).Skip(2_999));\n                Console.WriteLine();\n            }\n            foreach (var i in new int[] { 503, 509, 521 }) {\n                Console.WriteLine(\"The 30,000 to 3,019 {0}-smooth numbers are:\", i);\n                Println(NSmooth(i, 30_019).Skip(29_999));\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 399662, "name": "Partition an integer x into n primes", "source": "Translate Swift to C#: import Foundation\n\nclass BitArray {\n    var array: [UInt32]\n\n    init(size: Int) {\n        array = Array(repeating: 0, count: (size + 31)/32)\n    }\n    \n    func get(index: Int) -> Bool {\n        let bit = UInt32(1) << (index & 31)\n        return (array[index >> 5] & bit) != 0\n    }\n    \n    func set(index: Int, value: Bool) {\n        let bit = UInt32(1) << (index & 31)\n        if value {\n            array[index >> 5] |= bit\n        } else {\n            array[index >> 5] &= ~bit\n        }\n    }\n}\n\nclass PrimeSieve {\n    let composite: BitArray\n    \n    init(size: Int) {\n        composite = BitArray(size: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite.get(index: p/2 - 1) {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite.set(index: q/2 - 1, value: true)\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite.get(index: number/2 - 1)\n    }\n}\n\nfunc findPrimePartition(sieve: PrimeSieve, number: Int,\n                        count: Int, minPrime: Int,\n                        primes: inout [Int], index: Int) -> Bool {\n    if count == 1 {\n        if number >= minPrime && sieve.isPrime(number: number) {\n            primes[index] = number\n            return true\n        }\n        return false\n    }\n    if minPrime >= number {\n        return false\n    }\n    for p in minPrime..<number {\n        if sieve.isPrime(number: p)\n            && findPrimePartition(sieve: sieve, number: number - p,\n                                  count: count - 1, minPrime: p + 1,\n                                  primes: &primes, index: index + 1) {\n            primes[index] = p\n            return true\n        }\n    }\n    return false\n}\n\nfunc printPrimePartition(sieve: PrimeSieve, number: Int, count: Int) {\n    var primes = Array(repeating: 0, count: count)\n    if !findPrimePartition(sieve: sieve, number: number, count: count,\n                           minPrime: 2, primes: &primes, index: 0) {\n        print(\"\\(number) cannot be partitioned into \\(count) primes.\")\n    } else {\n        print(\"\\(number) = \\(primes[0])\", terminator: \"\")\n        for i in 1..<count {\n            print(\" + \\(primes[i])\", terminator: \"\")\n        }\n        print()\n    }\n}\n\nlet sieve = PrimeSieve(size: 100000)\nprintPrimePartition(sieve: sieve, number: 99809, count: 1)\nprintPrimePartition(sieve: sieve, number: 18, count: 2)\nprintPrimePartition(sieve: sieve, number: 19, count: 3)\nprintPrimePartition(sieve: sieve, number: 20, count: 4)\nprintPrimePartition(sieve: sieve, number: 2017, count: 24)\nprintPrimePartition(sieve: sieve, number: 22699, count: 1)\nprintPrimePartition(sieve: sieve, number: 22699, count: 2)\nprintPrimePartition(sieve: sieve, number: 22699, count: 3)\nprintPrimePartition(sieve: sieve, number: 22699, count: 4)\nprintPrimePartition(sieve: sieve, number: 40355, count: 3)\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class Rosetta\n{\n    static void Main()\n    {\n        foreach ((int x, int n) in new [] {\n            (99809, 1),\n            (18, 2),\n            (19, 3),\n            (20, 4),\n            (2017, 24),\n            (22699, 1),\n            (22699, 2),\n            (22699, 3),\n            (22699, 4),\n            (40355, 3)\n        }) {\n            Console.WriteLine(Partition(x, n));\n        }\n    }\n\n    public static string Partition(int x, int n) {\n        if (x < 1 || n < 1) throw new ArgumentOutOfRangeException(\"Parameters must be positive.\");\n        string header = $\"{x} with {n} {(n == 1\u00a0? \"prime\"\u00a0: \"primes\")}: \";\n        int[] primes = SievePrimes(x).ToArray();\n        if (primes.Length < n) return header + \"not enough primes\";\n        int[] solution = CombinationsOf(n, primes).FirstOrDefault(c => c.Sum() == x);\n        return header + (solution == null ? \"not possible\" : string.Join(\"+\", solution);\n    }\n\n    static IEnumerable<int> SievePrimes(int bound) {\n        if (bound < 2) yield break;\n        yield return 2;\n\n        BitArray composite = new BitArray((bound - 1) / 2);\n        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;\n        for (int i = 0; i < limit; i++) {\n            if (composite[i]) continue;\n            int prime = 2 * i + 3;\n            yield return prime;\n            for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime) composite[j] = true;\n        }\n        for (int i = limit; i < composite.Count; i++) {\n            if (!composite[i]) yield return 2 * i + 3;\n        }\n    }\n\n    static IEnumerable<int[]> CombinationsOf(int count, int[] input) {\n        T[] result = new T[count];\n        foreach (int[] indices in Combinations(input.Length, count)) {\n            for (int i = 0; i < count; i++) result[i] = input[indices[i]];\n            yield return result;\n        }\n    }\n\n    static IEnumerable<int[]> Combinations(int n, int k) {\n        var result = new int[k];\n        var stack = new Stack<int>();\n        stack.Push(0);\n        while (stack.Count > 0) {\n            int index = stack.Count - 1;\n            int value = stack.Pop();\n            while (value < n) {\n                result[index++] = value++;\n                stack.Push(value);\n                if (index == k) {\n                    yield return result;\n                    break;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 399663, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Swift to C#: struct Point: CustomStringConvertible {\n    let x: Double, y: Double\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nfunc perpendicularDistance(p: Point, p1: Point, p2: Point) -> Double {\n    let dx = p2.x - p1.x\n    let dy = p2.y - p1.y\n    let d = (p.x * dy - p.y * dx + p2.x * p1.y - p2.y * p1.x)\n    return abs(d)/(dx * dx + dy * dy).squareRoot()\n}\n\nfunc ramerDouglasPeucker(points: [Point], epsilon: Double) -> [Point] {\n    var result : [Point] = []\n    func rdp(begin: Int, end: Int) {\n        guard end > begin else {\n            return\n        }\n        var maxDist = 0.0\n        var index = 0\n        for i in begin+1..<end {\n            let dist = perpendicularDistance(p: points[i], p1: points[begin],\n                                             p2: points[end])\n            if dist > maxDist {\n                maxDist = dist\n                index = i\n            }\n        }\n        if maxDist > epsilon {\n            rdp(begin: begin, end: index)\n            rdp(begin: index, end: end)\n        } else {\n            result.append(points[end])\n        }\n    }\n    if points.count > 0 && epsilon >= 0.0 {\n        result.append(points[0])\n        rdp(begin: 0, end: points.count - 1)\n    }\n    return result\n}\n\nlet points = [\n    Point(x: 0.0, y: 0.0),\n    Point(x: 1.0, y: 0.1),\n    Point(x: 2.0, y: -0.1),\n    Point(x: 3.0, y: 5.0),\n    Point(x: 4.0, y: 6.0),\n    Point(x: 5.0, y: 7.0),\n    Point(x: 6.0, y: 8.1),\n    Point(x: 7.0, y: 9.0),\n    Point(x: 8.0, y: 9.0),\n    Point(x: 9.0, y: 9.0)\n]\nprint(\"\\(ramerDouglasPeucker(points: points, epsilon: 1.0))\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace LineSimplification {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double PerpendicularDistance(Point pt, Point lineStart, Point lineEnd) {\n            double dx = lineEnd.Item1 - lineStart.Item1;\n            double dy = lineEnd.Item2 - lineStart.Item2;\n\n            \n            double mag = Math.Sqrt(dx * dx + dy * dy);\n            if (mag > 0.0) {\n                dx /= mag;\n                dy /= mag;\n            }\n            double pvx = pt.Item1 - lineStart.Item1;\n            double pvy = pt.Item2 - lineStart.Item2;\n\n            \n            double pvdot = dx * pvx + dy * pvy;\n\n            \n            double ax = pvx - pvdot * dx;\n            double ay = pvy - pvdot * dy;\n\n            return Math.Sqrt(ax * ax + ay * ay);\n        }\n\n        static void RamerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> output) {\n            if (pointList.Count < 2) {\n                throw new ArgumentOutOfRangeException(\"Not enough points to simplify\");\n            }\n\n            \n            double dmax = 0.0;\n            int index = 0;\n            int end = pointList.Count - 1;\n            for (int i = 1; i < end; ++i) {\n                double d = PerpendicularDistance(pointList[i], pointList[0], pointList[end]);\n                if (d > dmax) {\n                    index = i;\n                    dmax = d;\n                }\n            }\n\n            \n            if (dmax > epsilon) {\n                List<Point> recResults1 = new List<Point>();\n                List<Point> recResults2 = new List<Point>();\n                List<Point> firstLine = pointList.Take(index + 1).ToList();\n                List<Point> lastLine = pointList.Skip(index).ToList();\n                RamerDouglasPeucker(firstLine, epsilon, recResults1);\n                RamerDouglasPeucker(lastLine, epsilon, recResults2);\n\n                \n                output.AddRange(recResults1.Take(recResults1.Count - 1));\n                output.AddRange(recResults2);\n                if (output.Count < 2) throw new Exception(\"Problem assembling output\");\n            }\n            else {\n                \n                output.Clear();\n                output.Add(pointList[0]);\n                output.Add(pointList[pointList.Count - 1]);\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Point> pointList = new List<Point>() {\n                new Point(0.0,0.0),\n                new Point(1.0,0.1),\n                new Point(2.0,-0.1),\n                new Point(3.0,5.0),\n                new Point(4.0,6.0),\n                new Point(5.0,7.0),\n                new Point(6.0,8.1),\n                new Point(7.0,9.0),\n                new Point(8.0,9.0),\n                new Point(9.0,9.0),\n            };\n            List<Point> pointListOut = new List<Point>();\n            RamerDouglasPeucker(pointList, 1.0, pointListOut);\n            Console.WriteLine(\"Points remaining after simplification:\");\n            pointListOut.ForEach(p => Console.WriteLine(p));\n        }\n    }\n}\n"}
{"id": 399664, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Swift to C#: struct Point: CustomStringConvertible {\n    let x: Double, y: Double\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nfunc perpendicularDistance(p: Point, p1: Point, p2: Point) -> Double {\n    let dx = p2.x - p1.x\n    let dy = p2.y - p1.y\n    let d = (p.x * dy - p.y * dx + p2.x * p1.y - p2.y * p1.x)\n    return abs(d)/(dx * dx + dy * dy).squareRoot()\n}\n\nfunc ramerDouglasPeucker(points: [Point], epsilon: Double) -> [Point] {\n    var result : [Point] = []\n    func rdp(begin: Int, end: Int) {\n        guard end > begin else {\n            return\n        }\n        var maxDist = 0.0\n        var index = 0\n        for i in begin+1..<end {\n            let dist = perpendicularDistance(p: points[i], p1: points[begin],\n                                             p2: points[end])\n            if dist > maxDist {\n                maxDist = dist\n                index = i\n            }\n        }\n        if maxDist > epsilon {\n            rdp(begin: begin, end: index)\n            rdp(begin: index, end: end)\n        } else {\n            result.append(points[end])\n        }\n    }\n    if points.count > 0 && epsilon >= 0.0 {\n        result.append(points[0])\n        rdp(begin: 0, end: points.count - 1)\n    }\n    return result\n}\n\nlet points = [\n    Point(x: 0.0, y: 0.0),\n    Point(x: 1.0, y: 0.1),\n    Point(x: 2.0, y: -0.1),\n    Point(x: 3.0, y: 5.0),\n    Point(x: 4.0, y: 6.0),\n    Point(x: 5.0, y: 7.0),\n    Point(x: 6.0, y: 8.1),\n    Point(x: 7.0, y: 9.0),\n    Point(x: 8.0, y: 9.0),\n    Point(x: 9.0, y: 9.0)\n]\nprint(\"\\(ramerDouglasPeucker(points: points, epsilon: 1.0))\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace LineSimplification {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double PerpendicularDistance(Point pt, Point lineStart, Point lineEnd) {\n            double dx = lineEnd.Item1 - lineStart.Item1;\n            double dy = lineEnd.Item2 - lineStart.Item2;\n\n            \n            double mag = Math.Sqrt(dx * dx + dy * dy);\n            if (mag > 0.0) {\n                dx /= mag;\n                dy /= mag;\n            }\n            double pvx = pt.Item1 - lineStart.Item1;\n            double pvy = pt.Item2 - lineStart.Item2;\n\n            \n            double pvdot = dx * pvx + dy * pvy;\n\n            \n            double ax = pvx - pvdot * dx;\n            double ay = pvy - pvdot * dy;\n\n            return Math.Sqrt(ax * ax + ay * ay);\n        }\n\n        static void RamerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> output) {\n            if (pointList.Count < 2) {\n                throw new ArgumentOutOfRangeException(\"Not enough points to simplify\");\n            }\n\n            \n            double dmax = 0.0;\n            int index = 0;\n            int end = pointList.Count - 1;\n            for (int i = 1; i < end; ++i) {\n                double d = PerpendicularDistance(pointList[i], pointList[0], pointList[end]);\n                if (d > dmax) {\n                    index = i;\n                    dmax = d;\n                }\n            }\n\n            \n            if (dmax > epsilon) {\n                List<Point> recResults1 = new List<Point>();\n                List<Point> recResults2 = new List<Point>();\n                List<Point> firstLine = pointList.Take(index + 1).ToList();\n                List<Point> lastLine = pointList.Skip(index).ToList();\n                RamerDouglasPeucker(firstLine, epsilon, recResults1);\n                RamerDouglasPeucker(lastLine, epsilon, recResults2);\n\n                \n                output.AddRange(recResults1.Take(recResults1.Count - 1));\n                output.AddRange(recResults2);\n                if (output.Count < 2) throw new Exception(\"Problem assembling output\");\n            }\n            else {\n                \n                output.Clear();\n                output.Add(pointList[0]);\n                output.Add(pointList[pointList.Count - 1]);\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Point> pointList = new List<Point>() {\n                new Point(0.0,0.0),\n                new Point(1.0,0.1),\n                new Point(2.0,-0.1),\n                new Point(3.0,5.0),\n                new Point(4.0,6.0),\n                new Point(5.0,7.0),\n                new Point(6.0,8.1),\n                new Point(7.0,9.0),\n                new Point(8.0,9.0),\n                new Point(9.0,9.0),\n            };\n            List<Point> pointListOut = new List<Point>();\n            RamerDouglasPeucker(pointList, 1.0, pointListOut);\n            Console.WriteLine(\"Points remaining after simplification:\");\n            pointListOut.ForEach(p => Console.WriteLine(p));\n        }\n    }\n}\n"}
{"id": 399665, "name": "Chebyshev coefficients", "source": "Translate Swift to C#: import Foundation\n\ntypealias DFunc = (Double) -> Double\n\nfunc mapRange(x: Double, min: Double, max: Double, minTo: Double, maxTo: Double) -> Double {\n  return (x - min) / (max - min) * (maxTo - minTo) + minTo\n}\n\nfunc chebCoeffs(fun: DFunc, n: Int, min: Double, max: Double) -> [Double] {\n  var res = [Double](repeating: 0, count: n)\n\n  for i in 0..<n {\n    let dI = Double(i)\n    let dN = Double(n)\n    let f = fun(mapRange(x: cos(.pi * (dI + 0.5) / dN), min: -1, max: 1, minTo: min, maxTo: max)) * 2.0 / dN\n\n    for j in 0..<n {\n      res[j] += f * cos(.pi * Double(j) * (dI + 0.5) / dN)\n    }\n  }\n\n  return res\n}\n\nfunc chebApprox(x: Double, n: Int, min: Double, max: Double, coeffs: [Double]) -> Double {\n  var a = 1.0\n  var b = mapRange(x: x, min: min, max: max, minTo: -1, maxTo: 1)\n  var res = coeffs[0] / 2.0 + coeffs[1] * b\n  let xx = 2 * b\n  var i = 2\n\n  while i < n {\n    let c = xx * b - a\n    res += coeffs[i] * c\n    (a, b) = (b, c)\n    i += 1\n  }\n\n  return res\n}\n\nlet coeffs = chebCoeffs(fun: cos, n: 10, min: 0, max: 1)\n\nprint(\"Coefficients\")\n\nfor coeff in coeffs {\n  print(String(format: \"%+1.15g\", coeff))\n}\n\nprint(\"\\nApproximations:\\n  x      func(x)     approx       diff\")\n\nfor i in stride(from: 0.0, through: 20, by: 1) {\n  let x = mapRange(x: i, min: 0, max: 20, minTo: 0, maxTo: 1)\n  let f = cos(x)\n  let approx = chebApprox(x: x, n: 10, min: 0, max: 1, coeffs: coeffs)\n\n  print(String(format: \"%1.3f  %1.8f  %1.8f \u00a0% 4.1e\", x, f, approx, approx - f))\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Chebyshev {\n    class Program {\n        struct ChebyshevApprox {\n            public readonly List<double> coeffs;\n            public readonly Tuple<double, double> domain;\n\n            public ChebyshevApprox(Func<double, double> func, int n, Tuple<double, double> domain) {\n                coeffs = ChebCoef(func, n, domain);\n                this.domain = domain;\n            }\n\n            public double Call(double x) {\n                return ChebEval(coeffs, domain, x);\n            }\n        }\n\n        static double AffineRemap(Tuple<double, double> from, double x, Tuple<double, double> to) {\n            return to.Item1 + (x - from.Item1) * (to.Item2 - to.Item1) / (from.Item2 - from.Item1);\n        }\n\n        static List<double> ChebCoef(List<double> fVals) {\n            int n = fVals.Count;\n            double theta = Math.PI / n;\n            List<double> retval = new List<double>();\n            for (int i = 0; i < n; i++) {\n                retval.Add(0.0);\n            }\n            for (int ii = 0; ii < n; ii++) {\n                double f = fVals[ii] * 2.0 / n;\n                double phi = (ii + 0.5) * theta;\n                double c1 = Math.Cos(phi);\n                double s1 = Math.Sin(phi);\n                double c = 1.0;\n                double s = 0.0;\n                for (int j = 0; j < n; j++) {\n                    retval[j] += f * c;\n                    \n                    double cNext = c * c1 - s * s1;\n                    s = c * s1 + s * c1;\n                    c = cNext;\n                }\n            }\n            return retval;\n        }\n\n        static List<double> ChebCoef(Func<double, double> func, int n, Tuple<double, double> domain) {\n            double remap(double x) {\n                return AffineRemap(new Tuple<double, double>(-1.0, 1.0), x, domain);\n            }\n            double theta = Math.PI / n;\n            List<double> fVals = new List<double>();\n            for (int i = 0; i < n; i++) {\n                fVals.Add(0.0);\n            }\n            for (int ii = 0; ii < n; ii++) {\n                fVals[ii] = func(remap(Math.Cos((ii + 0.5) * theta)));\n            }\n            return ChebCoef(fVals);\n        }\n\n        static double ChebEval(List<double> coef, double x) {\n            double a = 1.0;\n            double b = x;\n            double c;\n            double retval = 0.5 * coef[0] + b * coef[1];\n            var it = coef.GetEnumerator();\n            it.MoveNext();\n            it.MoveNext();\n            while (it.MoveNext()) {\n                double pc = it.Current;\n                c = 2.0 * b * x - a;\n                retval += pc * c;\n                a = b;\n                b = c;\n            }\n            return retval;\n        }\n\n        static double ChebEval(List<double> coef, Tuple<double, double> domain, double x) {\n            return ChebEval(coef, AffineRemap(domain, x, new Tuple<double, double>(-1.0, 1.0)));\n        }\n\n        static void Main() {\n            const int N = 10;\n            ChebyshevApprox fApprox = new ChebyshevApprox(Math.Cos, N, new Tuple<double, double>(0.0, 1.0));\n            Console.WriteLine(\"Coefficients: \");\n            foreach (var c in fApprox.coeffs) {\n                Console.WriteLine(\"\\t{0: 0.00000000000000;-0.00000000000000;zero}\", c);\n            }\n\n            Console.WriteLine(\"\\nApproximation:\\n    x       func(x)        approx      diff\");\n            const int nX = 20;\n            const int min = 0;\n            const int max = 1;\n            for (int i = 0; i < nX; i++) {\n                double x = AffineRemap(new Tuple<double, double>(0, nX), i, new Tuple<double, double>(min, max));\n                double f = Math.Cos(x);\n                double approx = fApprox.Call(x);\n                Console.WriteLine(\"{0:0.000} {1:0.00000000000000} {2:0.00000000000000} {3:E}\", x, f, approx, approx - f);\n            }\n        }\n    }\n}\n"}
{"id": 399666, "name": "Chebyshev coefficients", "source": "Translate Swift to C#: import Foundation\n\ntypealias DFunc = (Double) -> Double\n\nfunc mapRange(x: Double, min: Double, max: Double, minTo: Double, maxTo: Double) -> Double {\n  return (x - min) / (max - min) * (maxTo - minTo) + minTo\n}\n\nfunc chebCoeffs(fun: DFunc, n: Int, min: Double, max: Double) -> [Double] {\n  var res = [Double](repeating: 0, count: n)\n\n  for i in 0..<n {\n    let dI = Double(i)\n    let dN = Double(n)\n    let f = fun(mapRange(x: cos(.pi * (dI + 0.5) / dN), min: -1, max: 1, minTo: min, maxTo: max)) * 2.0 / dN\n\n    for j in 0..<n {\n      res[j] += f * cos(.pi * Double(j) * (dI + 0.5) / dN)\n    }\n  }\n\n  return res\n}\n\nfunc chebApprox(x: Double, n: Int, min: Double, max: Double, coeffs: [Double]) -> Double {\n  var a = 1.0\n  var b = mapRange(x: x, min: min, max: max, minTo: -1, maxTo: 1)\n  var res = coeffs[0] / 2.0 + coeffs[1] * b\n  let xx = 2 * b\n  var i = 2\n\n  while i < n {\n    let c = xx * b - a\n    res += coeffs[i] * c\n    (a, b) = (b, c)\n    i += 1\n  }\n\n  return res\n}\n\nlet coeffs = chebCoeffs(fun: cos, n: 10, min: 0, max: 1)\n\nprint(\"Coefficients\")\n\nfor coeff in coeffs {\n  print(String(format: \"%+1.15g\", coeff))\n}\n\nprint(\"\\nApproximations:\\n  x      func(x)     approx       diff\")\n\nfor i in stride(from: 0.0, through: 20, by: 1) {\n  let x = mapRange(x: i, min: 0, max: 20, minTo: 0, maxTo: 1)\n  let f = cos(x)\n  let approx = chebApprox(x: x, n: 10, min: 0, max: 1, coeffs: coeffs)\n\n  print(String(format: \"%1.3f  %1.8f  %1.8f \u00a0% 4.1e\", x, f, approx, approx - f))\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Chebyshev {\n    class Program {\n        struct ChebyshevApprox {\n            public readonly List<double> coeffs;\n            public readonly Tuple<double, double> domain;\n\n            public ChebyshevApprox(Func<double, double> func, int n, Tuple<double, double> domain) {\n                coeffs = ChebCoef(func, n, domain);\n                this.domain = domain;\n            }\n\n            public double Call(double x) {\n                return ChebEval(coeffs, domain, x);\n            }\n        }\n\n        static double AffineRemap(Tuple<double, double> from, double x, Tuple<double, double> to) {\n            return to.Item1 + (x - from.Item1) * (to.Item2 - to.Item1) / (from.Item2 - from.Item1);\n        }\n\n        static List<double> ChebCoef(List<double> fVals) {\n            int n = fVals.Count;\n            double theta = Math.PI / n;\n            List<double> retval = new List<double>();\n            for (int i = 0; i < n; i++) {\n                retval.Add(0.0);\n            }\n            for (int ii = 0; ii < n; ii++) {\n                double f = fVals[ii] * 2.0 / n;\n                double phi = (ii + 0.5) * theta;\n                double c1 = Math.Cos(phi);\n                double s1 = Math.Sin(phi);\n                double c = 1.0;\n                double s = 0.0;\n                for (int j = 0; j < n; j++) {\n                    retval[j] += f * c;\n                    \n                    double cNext = c * c1 - s * s1;\n                    s = c * s1 + s * c1;\n                    c = cNext;\n                }\n            }\n            return retval;\n        }\n\n        static List<double> ChebCoef(Func<double, double> func, int n, Tuple<double, double> domain) {\n            double remap(double x) {\n                return AffineRemap(new Tuple<double, double>(-1.0, 1.0), x, domain);\n            }\n            double theta = Math.PI / n;\n            List<double> fVals = new List<double>();\n            for (int i = 0; i < n; i++) {\n                fVals.Add(0.0);\n            }\n            for (int ii = 0; ii < n; ii++) {\n                fVals[ii] = func(remap(Math.Cos((ii + 0.5) * theta)));\n            }\n            return ChebCoef(fVals);\n        }\n\n        static double ChebEval(List<double> coef, double x) {\n            double a = 1.0;\n            double b = x;\n            double c;\n            double retval = 0.5 * coef[0] + b * coef[1];\n            var it = coef.GetEnumerator();\n            it.MoveNext();\n            it.MoveNext();\n            while (it.MoveNext()) {\n                double pc = it.Current;\n                c = 2.0 * b * x - a;\n                retval += pc * c;\n                a = b;\n                b = c;\n            }\n            return retval;\n        }\n\n        static double ChebEval(List<double> coef, Tuple<double, double> domain, double x) {\n            return ChebEval(coef, AffineRemap(domain, x, new Tuple<double, double>(-1.0, 1.0)));\n        }\n\n        static void Main() {\n            const int N = 10;\n            ChebyshevApprox fApprox = new ChebyshevApprox(Math.Cos, N, new Tuple<double, double>(0.0, 1.0));\n            Console.WriteLine(\"Coefficients: \");\n            foreach (var c in fApprox.coeffs) {\n                Console.WriteLine(\"\\t{0: 0.00000000000000;-0.00000000000000;zero}\", c);\n            }\n\n            Console.WriteLine(\"\\nApproximation:\\n    x       func(x)        approx      diff\");\n            const int nX = 20;\n            const int min = 0;\n            const int max = 1;\n            for (int i = 0; i < nX; i++) {\n                double x = AffineRemap(new Tuple<double, double>(0, nX), i, new Tuple<double, double>(min, max));\n                double f = Math.Cos(x);\n                double approx = fApprox.Call(x);\n                Console.WriteLine(\"{0:0.000} {1:0.00000000000000} {2:0.00000000000000} {3:E}\", x, f, approx, approx - f);\n            }\n        }\n    }\n}\n"}
{"id": 399667, "name": "Burrows\u2013Wheeler transform", "source": "Translate Swift to C#: import Foundation\n\nprivate let stx = \"\\u{2}\"\nprivate let etx = \"\\u{3}\"\n\nfunc bwt(_ str: String) -> String? {\n  guard !str.contains(stx), !str.contains(etx) else {\n    return nil\n  }\n\n  let ss = stx + str + etx\n  let table = ss.indices.map({i in ss[i...] + ss[ss.startIndex..<i] }).sorted()\n\n  return String(table.map({str in str.last!}))\n}\n\nfunc ibwt(_ str: String) -> String? {\n  let len = str.count\n  var table = Array(repeating: \"\", count: len)\n\n  for _ in 0..<len {\n    for i in 0..<len {\n      table[i] = String(str[str.index(str.startIndex, offsetBy: i)]) + table[i]\n    }\n\n    table.sort()\n  }\n\n  for row in table where row.hasSuffix(etx) {\n    return String(row.dropFirst().dropLast())\n  }\n\n  return nil\n}\n\n\nfunc readableBwt(_ str: String) -> String {\n  return str.replacingOccurrences(of: \"\\u{2}\", with: \"^\").replacingOccurrences(of: \"\\u{3}\", with: \"|\")\n}\n\nlet testCases = [\n  \"banana\",\n  \"appellee\",\n  \"dogwood\",\n  \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n  \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n  \"\\u{2}ABC\\u{3}\"\n]\n\nfor test in testCases {\n  let b = bwt(test) ?? \"error\"\n  let c = ibwt(b) ?? \"error\"\n\n  print(\"\\(readableBwt(test)) -> \\(readableBwt(b)) -> \\(readableBwt(c))\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BurrowsWheeler {\n    class Program {\n        const char STX = (char)0x02;\n        const char ETX = (char)0x03;\n\n        private static void Rotate(ref char[] a) {\n            char t = a.Last();\n            for (int i = a.Length - 1; i > 0; --i) {\n                a[i] = a[i - 1];\n            }\n            a[0] = t;\n        }\n\n        \n        private static int Compare(string s1, string s2) {\n            for (int i = 0; i < s1.Length && i < s2.Length; ++i) {\n                if (s1[i] < s2[i]) {\n                    return -1;\n                }\n                if (s2[i] < s1[i]) {\n                    return 1;\n                }\n            }\n            if (s1.Length < s2.Length) {\n                return -1;\n            }\n            if (s2.Length < s1.Length) {\n                return 1;\n            }\n            return 0;\n        }\n\n        static string Bwt(string s) {\n            if (s.Any(a => a == STX || a == ETX)) {\n                throw new ArgumentException(\"Input can't contain STX or ETX\");\n            }\n            char[] ss = (STX + s + ETX).ToCharArray();\n            List<string> table = new List<string>();\n            for (int i = 0; i < ss.Length; ++i) {\n                table.Add(new string(ss));\n                Rotate(ref ss);\n            }\n            table.Sort(Compare);\n            return new string(table.Select(a => a.Last()).ToArray());\n        }\n\n        static string Ibwt(string r) {\n            int len = r.Length;\n            List<string> table = new List<string>(new string[len]);\n            for (int i = 0; i < len; ++i) {\n                for (int j = 0; j < len; ++j) {\n                    table[j] = r[j] + table[j];\n                }\n                table.Sort(Compare);\n            }\n            foreach (string row in table) {\n                if (row.Last() == ETX) {\n                    return row.Substring(1, len - 2);\n                }\n            }\n            return \"\";\n        }\n\n        static string MakePrintable(string s) {\n            return s.Replace(STX, '^').Replace(ETX, '|');\n        }\n\n        static void Main() {\n            string[] tests = new string[] {\n                \"banana\",\n                \"appellee\",\n                \"dogwood\",\n                \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n                \"\\u0002ABC\\u0003\"\n            };\n\n            foreach (string test in tests) {\n                Console.WriteLine(MakePrintable(test));\n                Console.Write(\" --> \");\n\n                string t = \"\";\n                try {\n                    t = Bwt(test);\n                    Console.WriteLine(MakePrintable(t));\n                } catch (Exception e) {\n                    Console.WriteLine(\"ERROR: {0}\", e.Message);\n                }\n\n                string r = Ibwt(t);\n                Console.WriteLine(\" --> {0}\", r);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 399668, "name": "Burrows\u2013Wheeler transform", "source": "Translate Swift to C#: import Foundation\n\nprivate let stx = \"\\u{2}\"\nprivate let etx = \"\\u{3}\"\n\nfunc bwt(_ str: String) -> String? {\n  guard !str.contains(stx), !str.contains(etx) else {\n    return nil\n  }\n\n  let ss = stx + str + etx\n  let table = ss.indices.map({i in ss[i...] + ss[ss.startIndex..<i] }).sorted()\n\n  return String(table.map({str in str.last!}))\n}\n\nfunc ibwt(_ str: String) -> String? {\n  let len = str.count\n  var table = Array(repeating: \"\", count: len)\n\n  for _ in 0..<len {\n    for i in 0..<len {\n      table[i] = String(str[str.index(str.startIndex, offsetBy: i)]) + table[i]\n    }\n\n    table.sort()\n  }\n\n  for row in table where row.hasSuffix(etx) {\n    return String(row.dropFirst().dropLast())\n  }\n\n  return nil\n}\n\n\nfunc readableBwt(_ str: String) -> String {\n  return str.replacingOccurrences(of: \"\\u{2}\", with: \"^\").replacingOccurrences(of: \"\\u{3}\", with: \"|\")\n}\n\nlet testCases = [\n  \"banana\",\n  \"appellee\",\n  \"dogwood\",\n  \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n  \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n  \"\\u{2}ABC\\u{3}\"\n]\n\nfor test in testCases {\n  let b = bwt(test) ?? \"error\"\n  let c = ibwt(b) ?? \"error\"\n\n  print(\"\\(readableBwt(test)) -> \\(readableBwt(b)) -> \\(readableBwt(c))\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BurrowsWheeler {\n    class Program {\n        const char STX = (char)0x02;\n        const char ETX = (char)0x03;\n\n        private static void Rotate(ref char[] a) {\n            char t = a.Last();\n            for (int i = a.Length - 1; i > 0; --i) {\n                a[i] = a[i - 1];\n            }\n            a[0] = t;\n        }\n\n        \n        private static int Compare(string s1, string s2) {\n            for (int i = 0; i < s1.Length && i < s2.Length; ++i) {\n                if (s1[i] < s2[i]) {\n                    return -1;\n                }\n                if (s2[i] < s1[i]) {\n                    return 1;\n                }\n            }\n            if (s1.Length < s2.Length) {\n                return -1;\n            }\n            if (s2.Length < s1.Length) {\n                return 1;\n            }\n            return 0;\n        }\n\n        static string Bwt(string s) {\n            if (s.Any(a => a == STX || a == ETX)) {\n                throw new ArgumentException(\"Input can't contain STX or ETX\");\n            }\n            char[] ss = (STX + s + ETX).ToCharArray();\n            List<string> table = new List<string>();\n            for (int i = 0; i < ss.Length; ++i) {\n                table.Add(new string(ss));\n                Rotate(ref ss);\n            }\n            table.Sort(Compare);\n            return new string(table.Select(a => a.Last()).ToArray());\n        }\n\n        static string Ibwt(string r) {\n            int len = r.Length;\n            List<string> table = new List<string>(new string[len]);\n            for (int i = 0; i < len; ++i) {\n                for (int j = 0; j < len; ++j) {\n                    table[j] = r[j] + table[j];\n                }\n                table.Sort(Compare);\n            }\n            foreach (string row in table) {\n                if (row.Last() == ETX) {\n                    return row.Substring(1, len - 2);\n                }\n            }\n            return \"\";\n        }\n\n        static string MakePrintable(string s) {\n            return s.Replace(STX, '^').Replace(ETX, '|');\n        }\n\n        static void Main() {\n            string[] tests = new string[] {\n                \"banana\",\n                \"appellee\",\n                \"dogwood\",\n                \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n                \"\\u0002ABC\\u0003\"\n            };\n\n            foreach (string test in tests) {\n                Console.WriteLine(MakePrintable(test));\n                Console.Write(\" --> \");\n\n                string t = \"\";\n                try {\n                    t = Bwt(test);\n                    Console.WriteLine(MakePrintable(t));\n                } catch (Exception e) {\n                    Console.WriteLine(\"ERROR: {0}\", e.Message);\n                }\n\n                string r = Ibwt(t);\n                Console.WriteLine(\" --> {0}\", r);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 399669, "name": "Peaceful chess queen armies", "source": "Translate Swift to C#: enum Piece {\n  case empty, black, white\n}\n\ntypealias Position = (Int, Int)\n\nfunc place(_ m: Int, _ n: Int, pBlackQueens: inout [Position], pWhiteQueens: inout [Position]) -> Bool {\n  guard m != 0 else {\n    return true\n  }\n\n  var placingBlack = true\n\n  for i in 0..<n {\n    inner: for j in 0..<n {\n      let pos = (i, j)\n\n      for queen in pBlackQueens where queen == pos || !placingBlack && isAttacking(queen, pos) {\n        continue inner\n      }\n\n      for queen in pWhiteQueens where queen == pos || placingBlack && isAttacking(queen, pos) {\n        continue inner\n      }\n\n      if placingBlack {\n        pBlackQueens.append(pos)\n        placingBlack = false\n      } else {\n        placingBlack = true\n\n        pWhiteQueens.append(pos)\n\n        if place(m - 1, n, pBlackQueens: &pBlackQueens, pWhiteQueens: &pWhiteQueens) {\n          return true\n        } else {\n          pBlackQueens.removeLast()\n          pWhiteQueens.removeLast()\n        }\n      }\n    }\n  }\n\n  if !placingBlack {\n    pBlackQueens.removeLast()\n  }\n\n  return false\n}\n\nfunc isAttacking(_ queen: Position, _ pos: Position) -> Bool {\n  queen.0 == pos.0 || queen.1 == pos.1 || abs(queen.0 - pos.0) == abs(queen.1 - pos.1)\n}\n\nfunc printBoard(n: Int, pBlackQueens: [Position], pWhiteQueens: [Position]) {\n  var board = Array(repeating: Piece.empty, count: n * n)\n\n  for queen in pBlackQueens {\n    board[queen.0 * n + queen.1] = .black\n  }\n\n  for queen in pWhiteQueens {\n    board[queen.0 * n + queen.1] = .white\n  }\n\n  for (i, p) in board.enumerated() {\n    if i != 0 && i % n == 0 {\n      print()\n    }\n\n    switch p {\n    case .black:\n      print(\"B \", terminator: \"\")\n    case .white:\n      print(\"W \", terminator: \"\")\n    case .empty:\n      let j = i / n\n      let k = i - j * n\n\n      if j % 2 == k % 2 {\n        print(\"\u2022 \", terminator: \"\")\n      } else {\n        print(\"\u25e6 \", terminator: \"\")\n      }\n    }\n  }\n\n  print(\"\\n\")\n}\n\nlet nms = [\n  (2, 1), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3),\n  (5, 1), (5, 2), (5, 3), (5, 4), (5, 5),\n  (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6),\n  (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7)\n]\n\nfor (n, m) in nms {\n  print(\"\\(m) black and white queens on \\(n) x \\(n) board\")\n\n  var blackQueens = [Position]()\n  var whiteQueens = [Position]()\n\n  if place(m, n, pBlackQueens: &blackQueens, pWhiteQueens: &whiteQueens) {\n    printBoard(n: n, pBlackQueens: blackQueens, pWhiteQueens: whiteQueens)\n  } else {\n    print(\"No solution\")\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PeacefulChessQueenArmies {\n    using Position = Tuple<int, int>;\n\n    enum Piece {\n        Empty,\n        Black,\n        White\n    }\n\n    class Program {\n        static bool IsAttacking(Position queen, Position pos) {\n            return queen.Item1 == pos.Item1\n                || queen.Item2 == pos.Item2\n                || Math.Abs(queen.Item1 - pos.Item1) == Math.Abs(queen.Item2 - pos.Item2);\n        }\n\n        static bool Place(int m, int n, List<Position> pBlackQueens, List<Position> pWhiteQueens) {\n            if (m == 0) {\n                return true;\n            }\n            bool placingBlack = true;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    var pos = new Position(i, j);\n                    foreach (var queen in pBlackQueens) {\n                        if (queen.Equals(pos) || !placingBlack && IsAttacking(queen, pos)) {\n                            goto inner;\n                        }\n                    }\n                    foreach (var queen in pWhiteQueens) {\n                        if (queen.Equals(pos) || placingBlack && IsAttacking(queen, pos)) {\n                            goto inner;\n                        }\n                    }\n                    if (placingBlack) {\n                        pBlackQueens.Add(pos);\n                        placingBlack = false;\n                    } else {\n                        pWhiteQueens.Add(pos);\n                        if (Place(m - 1, n, pBlackQueens, pWhiteQueens)) {\n                            return true;\n                        }\n                        pBlackQueens.RemoveAt(pBlackQueens.Count - 1);\n                        pWhiteQueens.RemoveAt(pWhiteQueens.Count - 1);\n                        placingBlack = true;\n                    }\n                inner: { }\n                }\n            }\n            if (!placingBlack) {\n                pBlackQueens.RemoveAt(pBlackQueens.Count - 1);\n            }\n            return false;\n        }\n\n        static void PrintBoard(int n, List<Position> blackQueens, List<Position> whiteQueens) {\n            var board = new Piece[n * n];\n\n            foreach (var queen in blackQueens) {\n                board[queen.Item1 * n + queen.Item2] = Piece.Black;\n            }\n            foreach (var queen in whiteQueens) {\n                board[queen.Item1 * n + queen.Item2] = Piece.White;\n            }\n\n            for (int i = 0; i < board.Length; i++) {\n                if (i != 0 && i % n == 0) {\n                    Console.WriteLine();\n                }\n                switch (board[i]) {\n                    case Piece.Black:\n                        Console.Write(\"B \");\n                        break;\n                    case Piece.White:\n                        Console.Write(\"W \");\n                        break;\n                    case Piece.Empty:\n                        int j = i / n;\n                        int k = i - j * n;\n                        if (j % 2 == k % 2) {\n                            Console.Write(\"  \");\n                        } else {\n                            Console.Write(\"# \");\n                        }\n                        break;\n                }\n            }\n\n            Console.WriteLine(\"\\n\");\n        }\n\n        static void Main() {\n            var nms = new int[,] {\n                {2, 1}, {3, 1}, {3, 2}, {4, 1}, {4, 2}, {4, 3},\n                {5, 1}, {5, 2}, {5, 3}, {5, 4}, {5, 5},\n                {6, 1}, {6, 2}, {6, 3}, {6, 4}, {6, 5}, {6, 6},\n                {7, 1}, {7, 2}, {7, 3}, {7, 4}, {7, 5}, {7, 6}, {7, 7},\n            };\n            for (int i = 0; i < nms.GetLength(0); i++) {\n                Console.WriteLine(\"{0} black and {0} white queens on a {1} x {1} board:\", nms[i, 1], nms[i, 0]);\n                List<Position> blackQueens = new List<Position>();\n                List<Position> whiteQueens = new List<Position>();\n                if (Place(nms[i, 1], nms[i, 0], blackQueens, whiteQueens)) {\n                    PrintBoard(nms[i, 0], blackQueens, whiteQueens);\n                } else {\n                    Console.WriteLine(\"No solution exists.\\n\");\n                }\n            }\n        }\n    }\n}\n"}
{"id": 399670, "name": "N-body problem", "source": "Translate Swift to C#: import Foundation\n\npublic struct Vector {\n  public var px = 0.0\n  public var py = 0.0\n  public var pz = 0.0\n\n  public init(px: Double, py: Double, pz: Double) {\n    (self.px, self.py, self.pz) = (px, py, pz)\n  }\n\n  public init?(array: [Double]) {\n    guard array.count == 3 else {\n      return nil\n    }\n\n    (self.px, self.py, self.pz) = (array[0], array[1], array[2])\n  }\n\n  public func mod() -> Double {\n    (px * px + py * py + pz * pz).squareRoot()\n  }\n\n  static func + (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      px: lhs.px + rhs.px,\n      py: lhs.py + rhs.py,\n      pz: lhs.pz + rhs.pz\n    )\n  }\n\n  static func - (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      px: lhs.px - rhs.px,\n      py: lhs.py - rhs.py,\n      pz: lhs.pz - rhs.pz\n    )\n  }\n\n  static func * (lhs: Vector, rhs: Double) -> Vector {\n    return Vector(\n      px: lhs.px * rhs,\n      py: lhs.py * rhs,\n      pz: lhs.pz * rhs\n    )\n  }\n}\n\nextension Vector {\n  public static let origin = Vector(px: 0, py: 0, pz: 0)\n}\n\nextension Vector: Equatable {\n  public static func == (lhs: Vector, rhs: Vector) -> Bool {\n    return lhs.px == rhs.px && lhs.py == rhs.py && lhs.pz == rhs.pz\n  }\n}\n\nextension Vector: CustomStringConvertible {\n  public var description: String {\n    return String(format: \"%.6f\\t%.6f\\t%.6f\", px, py, pz)\n  }\n}\n\npublic class NBody {\n  public let gravitationalConstant: Double\n  public let numBodies: Int\n  public let timeSteps: Int\n\n  public private(set) var masses: [Double]\n  public private(set) var positions: [Vector]\n  public private(set) var velocities: [Vector]\n  public private(set) var accelerations: [Vector]\n\n  public init?(file: String) {\n    guard let data = try? String(contentsOfFile: file) else {\n      return nil\n    }\n\n    print(\"Input file:\\n\\(data)\")\n\n    let lines = data.components(separatedBy: \"\\n\").map({ $0.components(separatedBy: \" \") })\n\n    let worldData = lines.first!\n\n    guard worldData.count == 3,\n          let gc = Double(worldData[0]),\n          let bodies = Int(worldData[1]),\n          let timeSteps = Int(worldData[2]) else {\n      return nil\n    }\n\n    let defaultState = Array(repeating: Vector.origin, count: bodies)\n\n    self.gravitationalConstant = gc\n    self.numBodies = bodies\n    self.timeSteps = timeSteps\n    self.masses = Array(repeating: 0, count: bodies)\n    self.positions = defaultState\n    self.accelerations = defaultState\n    self.velocities = defaultState\n\n    let bodyData = lines.dropFirst().map({ $0.compactMap(Double.init) })\n\n    guard bodyData.count == bodies * 3 else {\n      return nil\n    }\n\n    for n in 0..<bodies {\n      masses[n] = bodyData[0 + n * 3][0]\n\n      guard let position = Vector(array: bodyData[1 + n * 3]),\n            let velocity = Vector(array: bodyData[2 + n * 3]) else {\n        return nil\n      }\n\n      positions[n] = position\n      velocities[n] = velocity\n    }\n  }\n\n  private func computeAccelerations() {\n    for i in 0..<numBodies {\n      accelerations[i] = .origin\n\n      for j in 0..<numBodies where i != j {\n        let t = gravitationalConstant * masses[j] / pow((positions[i] - positions[j]).mod(), 3)\n        accelerations[i] = accelerations[i] + (positions[j] - positions[i]) * t\n      }\n    }\n  }\n\n  private func resolveCollisions() {\n    for i in 0..<numBodies {\n      for j in 0..<numBodies where positions[i] == positions[j] {\n        velocities.swapAt(i, j)\n      }\n    }\n  }\n\n  private func computeVelocities() {\n    for i in 0..<numBodies {\n      velocities[i] = velocities[i] + accelerations[i]\n    }\n  }\n\n  private func computePositions() {\n    for i in 0..<numBodies {\n      positions[i] = positions[i] + velocities[i] + accelerations[i] * 0.5\n    }\n  }\n\n  public func printState() {\n    for i in 0..<numBodies {\n      print(\"Body \\(i + 1): \\(positions[i])  |  \\(velocities[i])\")\n    }\n  }\n\n  public func simulate() {\n    computeAccelerations()\n    computePositions()\n    computeVelocities()\n    resolveCollisions()\n  }\n}\n\nguard let sim = NBody(file: \"input.txt\") else {\n  fatalError()\n}\n\nprint()\nprint(\"Body  \u00a0:      x          y          z    |     vx         vy         vz\")\n\nfor i in 0..<sim.timeSteps {\n  print(\"Step \\(i + 1)\")\n  sim.simulate()\n  sim.printState()\n  print()\n}\n", "target": "using System;\nusing System.IO;\n\nnamespace NBodyProblem {\n    class Vector3D {\n        public Vector3D(double x, double y, double z) {\n            X = x;\n            Y = y;\n            Z = z;\n        }\n\n        public double X { get; }\n        public double Y { get; }\n        public double Z { get; }\n\n        public double Mod() {\n            return Math.Sqrt(X * X + Y * Y + Z * Z);\n        }\n\n        public static Vector3D operator +(Vector3D lhs, Vector3D rhs) {\n            return new Vector3D(lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z);\n        }\n\n        public static Vector3D operator -(Vector3D lhs, Vector3D rhs) {\n            return new Vector3D(lhs.X - rhs.X, lhs.Y - rhs.Y, lhs.Z - rhs.Z);\n        }\n\n        public static Vector3D operator *(Vector3D lhs, double rhs) {\n            return new Vector3D(lhs.X * rhs, lhs.Y * rhs, lhs.Z * rhs);\n        }\n    }\n\n    class NBody {\n        private readonly double gc;\n        private readonly int bodies;\n        private readonly int timeSteps;\n        private readonly double[] masses;\n        private readonly Vector3D[] positions;\n        private readonly Vector3D[] velocities;\n        private readonly Vector3D[] accelerations;\n\n        public NBody(string fileName) {\n            string[] lines = File.ReadAllLines(fileName);\n\n            string[] gbt = lines[0].Split();\n            gc = double.Parse(gbt[0]);\n            bodies = int.Parse(gbt[1]);\n            timeSteps = int.Parse(gbt[2]);\n\n            masses = new double[bodies];\n            positions = new Vector3D[bodies];\n            velocities = new Vector3D[bodies];\n            accelerations = new Vector3D[bodies];\n            for (int i = 0; i < bodies; ++i) {\n                masses[i] = double.Parse(lines[i * 3 + 1]);\n                positions[i] = Decompose(lines[i * 3 + 2]);\n                velocities[i] = Decompose(lines[i * 3 + 3]);\n            }\n\n            Console.WriteLine(\"Contents of {0}\", fileName);\n            foreach (string line in lines) {\n                Console.WriteLine(line);\n            }\n            Console.WriteLine();\n            Console.Write(\"Body  \u00a0:      x          y          z    |\");\n            Console.WriteLine(\"     vx         vy         vz\");\n        }\n\n        public int GetTimeSteps() {\n            return timeSteps;\n        }\n\n        private Vector3D Decompose(string line) {\n            string[] xyz = line.Split();\n            double x = double.Parse(xyz[0]);\n            double y = double.Parse(xyz[1]);\n            double z = double.Parse(xyz[2]);\n            return new Vector3D(x, y, z);\n        }\n\n        private void ComputeAccelerations() {\n            for (int i = 0; i < bodies; ++i) {\n                accelerations[i] = new Vector3D(0, 0, 0);\n                for (int j = 0; j < bodies; ++j) {\n                    if (i != j) {\n                        double temp = gc * masses[j] / Math.Pow((positions[i] - positions[j]).Mod(), 3);\n                        accelerations[i] = accelerations[i] + (positions[j] - positions[i]) * temp;\n                    }\n                }\n            }\n        }\n\n        private void ComputeVelocities() {\n            for (int i = 0; i < bodies; ++i) {\n                velocities[i] = velocities[i] + accelerations[i];\n            }\n        }\n\n        private void ComputePositions() {\n            for (int i = 0; i < bodies; ++i) {\n                positions[i] = positions[i] + velocities[i] + accelerations[i] * 0.5;\n            }\n        }\n\n        private void ResolveCollisions() {\n            for (int i = 0; i < bodies; ++i) {\n                for (int j = i + 1; j < bodies; ++j) {\n                    if (positions[i].X == positions[j].X\n                     && positions[i].Y == positions[j].Y\n                     && positions[i].Z == positions[j].Z) {\n                        Vector3D temp = velocities[i];\n                        velocities[i] = velocities[j];\n                        velocities[j] = temp;\n                    }\n                }\n            }\n        }\n\n        public void Simulate() {\n            ComputeAccelerations();\n            ComputePositions();\n            ComputeVelocities();\n            ResolveCollisions();\n        }\n\n        public void PrintResults() {\n            for (int i = 0; i < bodies; ++i) {\n                Console.WriteLine(\n                    \"Body {0}\u00a0: {1,9:F6}  {2,9:F6}  {3,9:F6} | {4,9:F6}  {5,9:F6}  {6,9:F6}\",\n                    i + 1,\n                    positions[i].X, positions[i].Y, positions[i].Z,\n                    velocities[i].X, velocities[i].Y, velocities[i].Z\n                );\n            }\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            NBody nb = new NBody(\"nbody.txt\");\n\n            for (int i = 0; i < nb.GetTimeSteps(); ++i) {\n                Console.WriteLine();\n                Console.WriteLine(\"Cycle {0}\", i + 1);\n                nb.Simulate();\n                nb.PrintResults();\n            }\n        }\n    }\n}\n"}
{"id": 399671, "name": "Zumkeller numbers", "source": "Translate Swift to C#: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isZumkeller: Bool {\n    let divs = factors(sorted: false)\n    let sum = divs.reduce(0, +)\n\n    guard sum & 1 != 1 else {\n      return false\n    }\n\n    guard self & 1 != 1 else {\n      let abundance = sum - 2*self\n\n      return abundance > 0 && abundance & 1 == 0\n    }\n\n    return isPartSum(divs: divs[...], sum: sum / 2)\n  }\n\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@usableFromInline\nfunc isPartSum<T: BinaryInteger>(divs: ArraySlice<T>, sum: T) -> Bool {\n  guard sum != 0 else {\n    return true\n  }\n\n  guard !divs.isEmpty else {\n    return false\n  }\n\n  let last = divs.last!\n\n  if last > sum {\n    return isPartSum(divs: divs.dropLast(), sum: sum)\n  }\n\n  return isPartSum(divs: divs.dropLast(), sum: sum) || isPartSum(divs: divs.dropLast(), sum: sum - last)\n}\n\nlet zums = (2...).lazy.filter({ $0.isZumkeller })\nlet oddZums = zums.filter({ $0 & 1 == 1 })\nlet oddZumsWithout5 = oddZums.filter({ String($0).last! != \"5\" })\n\nprint(\"First 220 zumkeller numbers are \\(Array(zums.prefix(220)))\")\nprint(\"First 40 odd zumkeller numbers are \\(Array(oddZums.prefix(40)))\")\nprint(\"First 40 odd zumkeller numbers that don't end in a 5 are: \\(Array(oddZumsWithout5.prefix(40)))\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ZumkellerNumbers {\n    class Program {\n        static List<int> GetDivisors(int n) {\n            List<int> divs = new List<int> {\n                1, n\n            };\n            for (int i = 2; i * i <= n; i++) {\n                if (n % i == 0) {\n                    int j = n / i;\n                    divs.Add(i);\n                    if (i != j) {\n                        divs.Add(j);\n                    }\n                }\n            }\n            return divs;\n        }\n\n        static bool IsPartSum(List<int> divs, int sum) {\n            if (sum == 0) {\n                return true;\n            }\n            var le = divs.Count;\n            if (le == 0) {\n                return false;\n            }\n            var last = divs[le - 1];\n            List<int> newDivs = new List<int>();\n            for (int i = 0; i < le - 1; i++) {\n                newDivs.Add(divs[i]);\n            }\n            if (last > sum) {\n                return IsPartSum(newDivs, sum);\n            }\n            return IsPartSum(newDivs, sum) || IsPartSum(newDivs, sum - last);\n        }\n\n        static bool IsZumkeller(int n) {\n            var divs = GetDivisors(n);\n            var sum = divs.Sum();\n            \n            if (sum % 2 == 1) {\n                return false;\n            }\n            \n            if (n % 2 == 1) {\n                var abundance = sum - 2 * n;\n                return abundance > 0 && abundance % 2 == 0;\n            }\n            \n            return IsPartSum(divs, sum / 2);\n        }\n\n        static void Main() {\n            Console.WriteLine(\"The first 220 Zumkeller numbers are:\");\n            int i = 2;\n            for (int count = 0; count < 220; i++) {\n                if (IsZumkeller(i)) {\n                    Console.Write(\"{0,3} \", i);\n                    count++;\n                    if (count % 20 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine(\"\\nThe first 40 odd Zumkeller numbers are:\");\n            i = 3;\n            for (int count = 0; count < 40; i += 2) {\n                if (IsZumkeller(i)) {\n                    Console.Write(\"{0,5} \", i);\n                    count++;\n                    if (count % 10 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine(\"\\nThe first 40 odd Zumkeller numbers which don't end in 5 are:\");\n            i = 3;\n            for (int count = 0; count < 40; i += 2) {\n                if (i % 10 != 5 && IsZumkeller(i)) {\n                    Console.Write(\"{0,7} \", i);\n                    count++;\n                    if (count % 8 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 399672, "name": "Commatizing numbers", "source": "Translate Swift to C#: import Foundation\n\nextension String {\n  private static let commaReg = try! NSRegularExpression(pattern: \"(\\\\.[0-9]+|[1-9]([0-9]+)?(\\\\.[0-9]+)?)\")\n\n  public func commatize(start: Int = 0, period: Int = 3, separator: String = \",\") -> String {\n    guard separator != \"\" else {\n      return self\n    }\n\n    let sep = Array(separator)\n    let startIdx = index(startIndex, offsetBy: start)\n    let matches = String.commaReg.matches(in: self, range: NSRange(startIdx..., in: self))\n\n    guard !matches.isEmpty else {\n      return self\n    }\n\n    let fullMatch = String(self[Range(matches.first!.range(at: 0), in: self)!])\n    let splits = fullMatch.components(separatedBy: \".\")\n    var ip = splits[0]\n\n    if ip.count > period {\n      var builder = Array(ip.reversed())\n\n      for i in stride(from: (ip.count - 1) / period * period, through: period, by: -period) {\n        builder.insert(contentsOf: sep, at: i)\n      }\n\n      ip = String(builder.reversed())\n    }\n\n    if fullMatch.contains(\".\") {\n      var dp = splits[1]\n\n      if dp.count > period {\n        var builder = Array(dp)\n\n        for i in stride(from: (dp.count - 1) / period * period, through: period, by: -period) {\n          builder.insert(contentsOf: sep, at: i)\n        }\n\n        dp = String(builder)\n      }\n\n      ip += \".\" + dp\n    }\n\n    return String(prefix(start)) + String(dropFirst(start)).replacingOccurrences(of: fullMatch, with: ip)\n  }\n}\n\nlet tests = [\n  \"123456789.123456789\",\n  \".123456789\",\n  \"57256.1D-4\",\n  \"pi=3.14159265358979323846264338327950288419716939937510582097494459231\",\n  \"The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\",\n  \"-in Aus$+1411.8millions\",\n  \"===US$0017440 millions=== (in 2000 dollars)\",\n  \"123.e8000 is pretty big.\",\n  \"The land area of the earth is 57268900(29% of the surface) square miles.\",\n  \"Ain't no numbers in this here words, nohow, no way, Jose.\",\n  \"James was never known as 0000000007\",\n  \"Arthur Eddington wrote: I believe there are \" +\n      \"15747724136275002577605653961181555468044717914527116709366231425076185631031296\" +\n      \" protons in the universe.\",\n  \"   $-140000\u00b1100 millions.\",\n  \"6/9/1946 was a good year for some.\"\n]\n\nprint(tests[0].commatize(period: 2, separator: \"*\"))\nprint(tests[1].commatize(period: 3, separator: \"-\"))\nprint(tests[2].commatize(period: 4, separator: \"__\"))\nprint(tests[3].commatize(period: 5, separator: \" \"))\nprint(tests[4].commatize(separator: \".\"))\n\nfor testCase in tests.dropFirst(5) {\n  print(testCase.commatize())\n}\n", "target": "static string[] inputs = {\n\t\"pi=3.14159265358979323846264338327950288419716939937510582097494459231\",\n\t\"The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\",\n\t\"\\\"-in Aus$+1411.8millions\\\"\",\n\t\"===US$0017440 millions=== (in 2000 dollars)\"\n};\n\nvoid Main()\n{\n\tinputs.Select(s => Commatize(s, 0, 3, \",\"))\n              .ToList()\n              .ForEach(Console.WriteLine);\n}\n\nstring Commatize(string text, int startPosition, int interval, string separator)\n{\n\tvar matches = Regex.Matches(text.Substring(startPosition), \"[0-9]*\");\n\tvar x = matches.Cast<Match>().Select(match => Commatize(match, interval, separator, text)).ToList();\n\treturn string.Join(\"\", x);\n}\n\n\nstring Commatize(Match match, int interval, string separator, string original)\n{\n\tif (match.Length <= interval)\n\t\treturn original.Substring(match.Index, \n                match.Index == original.Length ? 0 : Math.Max(match.Length, 1));\n\t\n\treturn string.Join(separator, match.Value.Split(interval));\n}\n\npublic static class Extension\n{\n\tpublic static string[] Split(this string source, int interval)\n\t{\n\t\treturn SplitImpl(source, interval).ToArray();\n\t}\n\t\n\tstatic IEnumerable<string>SplitImpl(string source, int interval)\n\t{\n\t\tfor\t(int i = 1; i < source.Length; i++)\n\t\t{\n\t\t\tif (i % interval != 0) continue;\n\t\t\t\n\t\t\tyield return source.Substring(i - interval, interval);\n\t\t}\n\t}\n}\n"}
{"id": 399673, "name": "Kosaraju", "source": "Translate Swift to C#: func kosaraju(graph: [[Int]]) -> [Int] {\n  let size = graph.count\n  var x = size\n  var vis = [Bool](repeating: false, count: size)\n  var l = [Int](repeating: 0, count: size)\n  var c = [Int](repeating: 0, count: size)\n  var t = [[Int]](repeating: [], count: size)\n\n  func visit(_ u: Int) {\n    guard !vis[u] else {\n      return\n    }\n\n    vis[u] = true\n\n    for v in graph[u] {\n      visit(v)\n      t[v].append(u)\n    }\n\n    x -= 1\n    l[x] = u\n  }\n\n  for u in 0..<graph.count {\n    visit(u)\n  }\n\n  func assign(_ u: Int, root: Int) {\n    guard vis[u] else {\n      return\n    }\n\n    vis[u] = false\n    c[u] = root\n\n    for v in t[u] {\n      assign(v, root: root)\n    }\n  }\n\n  for u in l {\n    assign(u, root: u)\n  }\n\n  return c\n}\n\nlet graph = [\n  [1],\n  [2],\n  [0],\n  [1, 2, 4],\n  [3, 5],\n  [2, 6],\n  [5],\n  [4, 6, 7]\n]\n\nprint(kosaraju(graph: graph))\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Node\n{\n\tpublic enum Colors\n\t{\n\t\tBlack, White, Gray\n\t}\n\n\tpublic Colors color { get; set; }\n\tpublic int N { get; }\n\t\n\tpublic Node(int n)\n\t{\n\t\tN = n;\n\t\tcolor = Colors.White;\n\t}\n}\n\nclass Graph\n{\n\tpublic HashSet<Node> V { get; }\n\tpublic Dictionary<Node, HashSet<Node>> Adj { get; }\n\n\t\n\t\n\t\n\tpublic void Kosaraju()\n\t{\n\t\tvar L = new HashSet<Node>();\n\n\t\tAction<Node> Visit = null;\n\t\tVisit = (u) =>\n\t\t{\n\t\t\tif (u.color == Node.Colors.White)\n\t\t\t{\n\t\t\t\tu.color = Node.Colors.Gray;\n\n\t\t\t\tforeach (var v in Adj[u])\n\t\t\t\t\tVisit(v);\n\n\t\t\t\tL.Add(u);\n\t\t\t}\n\t\t};\n\n\t\tAction<Node, Node> Assign = null;\n\t\tAssign = (u, root) =>\n\t\t{\n\t\t\tif (u.color != Node.Colors.Black)\n\t\t\t{\n\t\t\t\tif (u == root)\n\t\t\t\t\tConsole.Write(\"SCC: \");\n\n\t\t\t\tConsole.Write(u.N + \" \");\n\t\t\t\tu.color = Node.Colors.Black;\n\n\t\t\t\tforeach (var v in Adj[u])\n\t\t\t\t\tAssign(v, root);\n\n\t\t\t\tif (u == root)\n\t\t\t\t\tConsole.WriteLine();\n\t\t\t}\n\t\t};\n\n\t\tforeach (var u in V)\n\t\t\tVisit(u);\n\n\t\tforeach (var u in L)\n\t\t\tAssign(u, u);\n\t}\n}\n"}
{"id": 399674, "name": "Markov chain text generator", "source": "Translate Swift to C#: import Foundation\n\nfunc makeRule(input: String, keyLength: Int) -> [String: [String]] {\n  let words = input.components(separatedBy: \" \")\n  var rules = [String: [String]]()\n  var i = keyLength\n  \n  for word in words[i...] {\n    let key = words[i-keyLength..<i].joined(separator: \" \")\n    \n    rules[key, default: []].append(word)\n    \n    i += 1\n  }\n  \n  return rules\n}\n\nfunc makeString(rule: [String: [String]], length: Int) -> String {\n  var oldWords = rule.keys.randomElement()!.components(separatedBy: \" \")\n  var string = oldWords.joined(separator: \" \") + \" \"\n  \n  for _ in 0..<length {\n    let key = oldWords.joined(separator: \" \")\n    guard let newWord = rule[key]?.randomElement() else { return string }\n    \n    string += newWord + \" \"\n    \n    for ii in 0..<oldWords.count {\n      oldWords[ii] = oldWords[(ii + 1) % oldWords.count]\n    }\n    \n    oldWords[oldWords.index(before: oldWords.endIndex)] = newWord\n  }\n  \n  return string\n}\n\nlet inputLoc = CommandLine.arguments.dropFirst().first!\nlet input = FileManager.default.contents(atPath: inputLoc)!\nlet inputStr = String(data: input, encoding: .utf8)!\nlet rule = makeRule(input: inputStr, keyLength: 3)\nlet str = makeString(rule: rule, length: 300)\n\nprint(str)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace MarkovChainTextGenerator {\n    class Program {\n        static string Join(string a, string b) {\n            return a + \" \" + b;\n        }\n\n        static string Markov(string filePath, int keySize, int outputSize) {\n            if (keySize < 1) throw new ArgumentException(\"Key size can't be less than 1\");\n\n            string body;\n            using (StreamReader sr = new StreamReader(filePath)) {\n                body = sr.ReadToEnd();\n            }\n            var words = body.Split();\n            if (outputSize < keySize || words.Length < outputSize) {\n                throw new ArgumentException(\"Output size is out of range\");\n            }\n\n            Dictionary<string, List<string>> dict = new Dictionary<string, List<string>>();\n            for (int i = 0; i < words.Length - keySize; i++) {\n                var key = words.Skip(i).Take(keySize).Aggregate(Join);\n                string value;\n                if (i + keySize < words.Length) {\n                    value = words[i + keySize];\n                } else {\n                    value = \"\";\n                }\n\n                if (dict.ContainsKey(key)) {\n                    dict[key].Add(value);\n                } else {\n                    dict.Add(key, new List<string>() { value });\n                }\n            }\n\n            Random rand = new Random();\n            List<string> output = new List<string>();\n            int n = 0;\n            int rn = rand.Next(dict.Count);\n            string prefix = dict.Keys.Skip(rn).Take(1).Single();\n            output.AddRange(prefix.Split());\n\n            while (true) {\n                var suffix = dict[prefix];\n                if (suffix.Count == 1) {\n                    if (suffix[0] == \"\") {\n                        return output.Aggregate(Join);\n                    }\n                    output.Add(suffix[0]);\n                } else {\n                    rn = rand.Next(suffix.Count);\n                    output.Add(suffix[rn]);\n                }\n                if (output.Count >= outputSize) {\n                    return output.Take(outputSize).Aggregate(Join);\n                }\n                n++;\n                prefix = output.Skip(n).Take(keySize).Aggregate(Join);\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(Markov(\"alice_oz.txt\", 3, 200));\n        }\n    }\n}\n"}
{"id": 399675, "name": "Partition function P", "source": "Translate Swift to C#: import BigInt \n\nfunc partitions(n: Int) -> BigInt {\n  var p = [BigInt(1)]\n\n  for i in 1...n {\n    var num = BigInt(0)\n    var k = 1\n\n    while true {\n      var j = (k * (3 * k - 1)) / 2\n\n      if j > i {\n        break\n      }\n\n      if k & 1 == 1 {\n        num += p[i - j]\n      } else {\n        num -= p[i - j]\n      }\n\n      j += k\n\n      if j > i {\n        break\n      }\n\n      if k & 1 == 1 {\n        num += p[i - j]\n      } else {\n        num -= p[i - j]\n      }\n\n      k += 1\n    }\n\n    p.append(num)\n  }\n\n  return p[n]\n}\n\nprint(\"partitions(6666) = \\(partitions(n: 6666))\")\n", "target": "using System;\n\nclass Program {\n\n    const long Lm = (long)1e18;\n    const string Fm = \"D18\";\n\n    \n    struct LI { public long lo, ml, mh, hi, tp; }\n\n    static void inc(ref LI d, LI s) { \n        if ((d.lo += s.lo) >= Lm) { d.ml++; d.lo -= Lm; }\n        if ((d.ml += s.ml) >= Lm) { d.mh++; d.ml -= Lm; }\n        if ((d.mh += s.mh) >= Lm) { d.hi++; d.mh -= Lm; }\n        if ((d.hi += s.hi) >= Lm) { d.tp++; d.hi -= Lm; }\n        d.tp += s.tp;\n    }\n \n    static void dec(ref LI d, LI s) { \n        if ((d.lo -= s.lo) < 0) { d.ml--; d.lo += Lm; }\n        if ((d.ml -= s.ml) < 0) { d.mh--; d.ml += Lm; }\n        if ((d.mh -= s.mh) < 0) { d.hi--; d.mh += Lm; }\n        if ((d.hi -= s.hi) < 0) { d.tp--; d.hi += Lm; }\n        d.tp -= s.tp;\n    }\n\n    static LI set(long s) { LI d;\n      d.lo = s; d.ml = d.mh = d.hi = d.tp = 0; return d; }\n\n  static string fmt(LI x) { \n    if (x.tp > 0) return x.tp.ToString() + x.hi.ToString(Fm) + x.mh.ToString(Fm) + x.ml.ToString(Fm) + x.lo.ToString(Fm);\n    if (x.hi > 0) return x.hi.ToString() + x.mh.ToString(Fm) + x.ml.ToString(Fm) + x.lo.ToString(Fm);\n    if (x.mh > 0) return x.mh.ToString() + x.ml.ToString(Fm) + x.lo.ToString(Fm);\n    if (x.ml > 0) return x.ml.ToString() + x.lo.ToString(Fm);\n    return x.lo.ToString();\n  }\n\n  static LI partcount(int n) {\n    var P = new LI[n + 1]; P[0] = set(1);\n    for (int i = 1; i <= n; i++) {\n      int k = 0, d = -2, j = i;\n      LI x = set(0);\n      while (true) {\n        if ((j -= (d += 3) -k) >= 0) inc(ref x, P[j]); else break;\n        if ((j -= ++k)         >= 0) inc(ref x, P[j]); else break;\n        if ((j -= (d += 3) -k) >= 0) dec(ref x, P[j]); else break;\n        if ((j -= ++k)         >= 0) dec(ref x, P[j]); else break;\n      }\n      P[i] = x;\n    }\n    return P[n];\n  }\n\n  static void Main(string[] args) {\n    var sw = System.Diagnostics.Stopwatch.StartNew ();\n    var res = partcount(6666); sw.Stop();\n    Console.Write(\"{0}  {1} ms\", fmt(res), sw.Elapsed.TotalMilliseconds);\n  }\n}\n"}
{"id": 399676, "name": "Special divisors", "source": "Translate Swift to C#: import Foundation\n\nfunc reverse(_ number: Int) -> Int {\n    var rev = 0\n    var n = number\n    while n > 0 {\n        rev = rev * 10 + n % 10\n        n /= 10\n    }\n    return rev\n}\n\nfunc special(_ number: Int) -> Bool {\n    var n = 2\n    let rev = reverse(number)\n    while n * n <= number {\n        if number % n == 0 {\n            if rev % reverse(n) != 0 {\n                return false\n            }\n            let m = number / n\n            if m != n && rev % reverse(m) != 0 {\n                return false\n            }\n        }\n        n += 1\n    }\n    return true\n}\n\nvar count = 0\nfor n in 1..<200 {\n    if special(n) {\n        count += 1\n        print(String(format: \"%3d\", n),\n              terminator: count % 10 == 0 ? \"\\n\" : \" \")\n    }\n}\nprint(\"\\n\\(count) numbers found.\")\n", "target": "using System;\n\nnamespace SpecialDivisors {\n    class Program {\n        static int Reverse(int n) {\n            int result = 0;\n            while (n > 0) {\n                result = 10 * result + n % 10;\n                n /= 10;\n            }\n            return result;\n        }\n\n        static void Main() {\n            const int LIMIT = 200;\n\n            int row = 0;\n            int num = 0;\n\n            for (int n = 1; n < LIMIT; n++) {\n                bool flag = true;\n                int revNum = Reverse(n);\n\n                for (int m = 1; m < n / 2; m++) {\n                    int revDiv = Reverse(m);\n                    if (n % m == 0) {\n                        if (revNum % revDiv == 0) {\n                            flag = true;\n                        } else {\n                            flag = false;\n                            break;\n                        }\n                    }\n                }\n\n                if (flag) {\n                    num++;\n                    row++;\n                    Console.Write(\"{0,4}\", n);\n                    if (row % 10 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine();\n            Console.WriteLine();\n            Console.WriteLine(\"Found {0} special divisors N that reverse(D) divides reverse(N) for all divisors D of N, where N < 200\", num);\n        }\n    }\n}\n"}
{"id": 399677, "name": "Minimal steps down to 1", "source": "Translate Swift to C#: func minToOne(divs: [Int], subs: [Int], upTo n: Int) -> ([Int], [[String]]) {\n  var table = Array(repeating: n + 2, count: n + 1)\n  var how = Array(repeating: [\"\"], count: n + 2)\n\n  table[1] = 0\n  how[1] = [\"=\"]\n\n  for t in 1..<n {\n    let thisPlus1 = table[t] + 1\n\n    for div in divs {\n      let dt = div * t\n\n      if dt <= n && thisPlus1 < table[dt] {\n        table[dt] = thisPlus1\n        how[dt] = how[t] + [\"/\\(div)=>  \\(t)\"]\n      }\n    }\n\n    for sub in subs {\n      let st = sub + t\n\n      if st <= n && thisPlus1 < table[st] {\n        table[st] = thisPlus1\n        how[st] = how[t] + [\"-\\(sub)=> \\(t)\"]\n      }\n    }\n  }\n\n  return (table, how.map({ $0.reversed().dropLast() }))\n}\n\nfor (divs, subs) in [([2, 3], [1]), ([2, 3], [2])] {\n  print(\"\\nMINIMUM STEPS TO 1:\")\n  print(\"  Possible divisors:  \\(divs)\")\n  print(\"  Possible decrements: \\(subs)\")\n\n  let (table, hows) = minToOne(divs: divs, subs: subs, upTo: 10)\n\n  for n in 1...10 {\n    print(\"    mintab(  \\(n)) in {  \\(table[n])} by: \", hows[n].joined(separator: \", \"))\n  }\n\n  for upTo in [2_000, 50_000] {\n    print(\"\\n    Those numbers up to \\(upTo) that take the maximum, \\\"minimal steps down to 1\\\":\")\n    let (table, _) = minToOne(divs: divs, subs: subs, upTo: upTo)\n    let max = table.dropFirst().max()!\n    let maxNs = table.enumerated().filter({ $0.element == max })\n\n    print(\n      \"      Taking\", max, \"steps are the \\(maxNs.count) numbers:\",\n      maxNs.map({ String($0.offset) }).joined(separator: \", \")\n    )\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class MinimalSteps\n{\n    public static void Main() {\n        var (divisors, subtractors) = (new int[] { 2, 3 }, new [] { 1 });\n        var lookup = CreateLookup(2_000, divisors, subtractors);\n        Console.WriteLine($\"Divisors: [{divisors.Delimit()}], Subtractors: [{subtractors.Delimit()}]\");\n        PrintRange(lookup, 10);\n        PrintMaxMins(lookup);\n        lookup = CreateLookup(20_000, divisors, subtractors);\n        PrintMaxMins(lookup);\n        Console.WriteLine();\n\n        subtractors = new [] { 2 };\n        lookup = CreateLookup(2_000, divisors, subtractors);\n        Console.WriteLine($\"Divisors: [{divisors.Delimit()}], Subtractors: [{subtractors.Delimit()}]\");\n        PrintRange(lookup, 10);\n        PrintMaxMins(lookup);\n        lookup = CreateLookup(20_000, divisors, subtractors);\n        PrintMaxMins(lookup);\n    }\n\n    private static void PrintRange((char op, int param, int steps)[] lookup, int limit) {\n        for (int goal = 1; goal <= limit; goal++) {\n            var x = lookup[goal];\n            if (x.param == 0) {\n                Console.WriteLine($\"{goal} cannot be reached with these numbers.\");\n                continue;\n            }\n            Console.Write($\"{goal} takes {x.steps} {(x.steps == 1\u00a0? \"step\"\u00a0: \"steps\")}: \");\n            for (int n = goal; n > 1; ) {\n                Console.Write($\"{n},{x.op}{x.param}=> \");\n                n = x.op == '/' ? n / x.param : n - x.param;\n                x = lookup[n];\n            }\n            Console.WriteLine(\"1\");\n        }\n    }\n\n    private static void PrintMaxMins((char op, int param, int steps)[] lookup) {\n        var maxSteps = lookup.Max(x => x.steps);\n        var items = lookup.Select((x, i) => (i, x)).Where(t => t.x.steps == maxSteps).ToList();\n        Console.WriteLine(items.Count == 1\n            ? $\"There is one number below {lookup.Length-1} that requires {maxSteps} steps: {items[0].i}\"\n            : $\"There are {items.Count} numbers below {lookup.Length-1} that require {maxSteps} steps: {items.Select(t => t.i).Delimit()}\"\n        );\n    }\n\n    private static (char op, int param, int steps)[] CreateLookup(int goal, int[] divisors, int[] subtractors)\n    {\n        var lookup = new (char op, int param, int steps)[goal+1];\n        lookup[1] = ('/', 1, 0);\n        for (int n = 1; n < lookup.Length; n++) {\n            var ln = lookup[n];\n            if (ln.param == 0) continue;\n            for (int d = 0; d < divisors.Length; d++) {\n                int target = n * divisors[d];\n                if (target > goal) break;\n                if (lookup[target].steps == 0 || lookup[target].steps > ln.steps) lookup[target] = ('/', divisors[d], ln.steps + 1);\n            }\n            for (int s = 0; s < subtractors.Length; s++) {\n                int target = n + subtractors[s];\n                if (target > goal) break;\n                if (lookup[target].steps == 0 || lookup[target].steps > ln.steps) lookup[target] = ('-', subtractors[s], ln.steps + 1);\n            }\n        }\n        return lookup;\n    }\n\n    private static string Delimit<T>(this IEnumerable<T> source) => string.Join(\", \", source);\n}\n"}
{"id": 399678, "name": "Idoneal numbers", "source": "Translate Swift to C#: import Foundation\n\nfunc isIdoneal(_ n: Int) -> Bool {\n    for a in 1..<n {\n        for b in a + 1..<n {\n            if a * b + a + b > n {\n                break\n            }\n            for c in b + 1..<n {\n                let sum = a * b + b * c + a * c\n                if sum == n {\n                    return false\n                }\n                if sum > n {\n                    break\n                }\n            }\n        }\n    }\n    return true\n}\n\nvar count = 0\nfor n in 1..<1850 {\n    if isIdoneal(n) {\n        count += 1\n        print(String(format: \"%4d\", n), terminator: count % 13 == 0 ? \"\\n\" : \" \")\n    }\n}\n", "target": "using System;\n\nclass Program {\n\n  static void Main(string[] args) {\n    var sw = System.Diagnostics.Stopwatch.StartNew();\n    int a, b, c, i, n, s3, ab; var res = new int[65];\n    for (n = 1, i = 0; n < 1850; n++) {\n      bool found = true;\n      for (a = 1; a < n; a++)\n         for (b = a + 1, ab = a * b + a + b; b < n; b++, ab += a + 1) {\n            if (ab > n) break;\n            for (c = b + 1, s3 = ab + (b + a) * b; c < n; c++, s3 += b + a) {\n                if (s3 == n) found = false;\n                if (s3 >= n) break;\n            }\n         }\n      if (found) res[i++] = n;\n    }\n    sw.Stop();\n    Console.WriteLine(\"The 65 known Idoneal numbers:\");\n    for (i = 0; i < res.Length; i++)\n      Console.Write(\"{0,5}{1}\", res[i], i % 13 == 12 ? \"\\n\" : \"\");\n    Console.Write(\"Calculations took {0} ms\", sw.Elapsed.TotalMilliseconds);\n  }\n}\n"}
{"id": 419531, "name": "Rep-string", "source": "Translate Swift to Python: import Foundation\n\nfunc repString(_ input: String) -> [String] {\n  return (1..<(1 + input.count / 2)).compactMap({x -> String? in\n    let i = input.index(input.startIndex, offsetBy: x)\n    return input.hasPrefix(input[i...]) ? String(input.prefix(x)) : nil\n  })\n}\n\nlet testCases = \"\"\"\n                1001110011\n                1110111011\n                0010010010\n                1010101010\n                1111111111\n                0100101101\n                0100100\n                101\n                11\n                00\n                1\n                \"\"\".components(separatedBy: \"\\n\")\n\nfor testCase in testCases {\n  print(\"\\(testCase) has reps: \\(repString(testCase))\")\n}\n", "target": "def is_repeated(text):\n    'check if the first part of the string is repeated throughout the string'\n    for x in range(len(text)//2, 0, -1):\n        if text.startswith(text[x:]): return x\n    return 0\n\nmatchstr = \nfor line in matchstr.split():\n    ln = is_repeated(line)\n    print('%r has a repetition length of %i i.e. %s' \n           % (line, ln, repr(line[:ln]) if ln else '*not* a rep-string'))\n"}
{"id": 419532, "name": "Sequence_ smallest number greater than previous term with exactly n divisors", "source": "Translate Swift to Python: \nfunc divisorCount(number: Int) -> Int {\n    var n = number\n    var total = 1\n    \n    while n % 2 == 0 {\n        total += 1\n        n /= 2\n    }\n    \n    var p = 3\n    while p * p <= n {\n        var count = 1\n        while n % p == 0 {\n            count += 1\n            n /= p\n        }\n        total *= count\n        p += 2\n    }\n    \n    if n > 1 {\n        total *= 2\n    }\n    return total\n}\n\nlet limit = 32\nvar n = 1\nvar next = 1\nwhile next <= limit {\n    if next == divisorCount(number: n) {\n        print(n, terminator: \" \")\n        next += 1\n        if next > 4 && divisorCount(number: next) == 2 {\n            n = 1 << (next - 1) - 1;\n        }\n    }\n    n += 1\n}\nprint()\n", "target": "def divisors(n):\n    divs = [1]\n    for ii in range(2, int(n ** 0.5) + 3):\n        if n % ii == 0:\n            divs.append(ii)\n            divs.append(int(n / ii))\n    divs.append(n)\n    return list(set(divs))\n\n\ndef sequence(max_n=None):\n    previous = 0\n    n = 0\n    while True:\n        n += 1\n        ii = previous\n        if max_n is not None:\n            if n > max_n:\n                break\n        while True:\n            ii += 1\n            if len(divisors(ii)) == n:\n                yield ii\n                previous = ii\n                break\n\n\nif __name__ == '__main__':\n    for item in sequence(15):\n        print(item)\n"}
{"id": 419533, "name": "McNuggets problem", "source": "Translate Swift to Python: func maxNugget(limit: Int) -> Int {\n  var (max, sixes, nines, twenties, i) = (0, 0, 0, 0, 0)\n\n  mainLoop: while i < limit {\n    sixes = 0\n\n    while sixes * 6 < i {\n      if sixes * 6 == i {\n        i += 1\n        continue mainLoop\n      }\n\n      nines = 0\n\n      while nines * 9 < i {\n        if sixes * 6 + nines * 9 == i {\n          i += 1\n          continue mainLoop\n        }\n\n        twenties = 0\n\n        while twenties * 20 < i {\n          if sixes * 6 + nines * 9 + twenties * 20 == i {\n            i += 1\n            continue mainLoop\n          }\n\n          twenties += 1\n        }\n\n        nines += 1\n      }\n\n      sixes += 1\n    }\n\n    max = i\n    i += 1\n  }\n\n  return max\n}\n\nprint(maxNugget(limit: 100))\n", "target": ">>> from itertools import product\n>>> nuggets = set(range(101))\n>>> for s, n, t in product(range(100//6+1), range(100//9+1), range(100//20+1)):\n\tnuggets.discard(6*s + 9*n + 20*t)\n\n\t\n>>> max(nuggets)\n43\n>>>\n"}
{"id": 419534, "name": "Jaro similarity", "source": "Translate Swift to Python:  func jaroWinklerMatch(_ s: String, _ t: String) -> Double {\n    let s_len: Int = s.count\n    let t_len: Int = t.count\n    \n    if s_len == 0 && t_len == 0 {\n        return 1.0\n    }\n    \n    if s_len == 0 || t_len == 0 {\n        return 0.0\n    }\n    \n    var match_distance: Int = 0\n    \n    if s_len == 1 && t_len == 1 {\n        match_distance = 1\n    } else {\n        match_distance = ([s_len, t_len].max()!/2) - 1\n    }\n    \n    \n    var s_matches = [Bool]()\n    var t_matches = [Bool]()\n    \n    for _ in 1...s_len {\n        s_matches.append(false)\n    }\n    \n    for _ in 1...t_len {\n        t_matches.append(false)\n    }\n    \n    var matches: Double = 0.0\n    var transpositions: Double = 0.0\n    \n    for i in 0...s_len-1 {\n        \n        let start = [0, (i-match_distance)].max()!\n        let end = [(i + match_distance), t_len-1].min()!\n        \n        if start > end {\n            break\n        }\n        \n        for j in start...end {\n\n            if t_matches[j] {\n                continue\n            }\n\n            if s[String.Index.init(encodedOffset: i)] != t[String.Index.init(encodedOffset: j)] {\n                continue\n            }\n            \n            s_matches[i] = true\n            t_matches[j] = true\n            matches += 1\n            break\n        }\n    }\n    \n    if matches == 0 {\n        return 0.0\n    }\n    \n    var k = 0\n    for i in 0...s_len-1 {\n        if !s_matches[i] {\n            continue\n        }\n        while !t_matches[k] {\n            k += 1\n        }\n        if s[String.Index.init(encodedOffset: i)] != t[String.Index.init(encodedOffset: k)] {\n            \n            transpositions += 1\n        }\n        \n        k += 1\n    }\n    \n    let top = (matches / Double(s_len)) + (matches / Double(t_len)) + (matches - (transpositions / 2)) / matches\n    return top/3\n}\n\nprint(\"DWAYNE/DUANE:\", jaroWinklerMatch(\"DWAYNE\", \"DUANE\"))\nprint(\"MARTHA/MARHTA:\", jaroWinklerMatch(\"MARTHA\", \"MARHTA\"))\nprint(\"DIXON/DICKSONX:\", jaroWinklerMatch(\"DIXON\", \"DICKSONX\"))\nprint(\"JELLYFISH/SMELLYFISH:\", jaroWinklerMatch(\"JELLYFISH\", \"SMELLYFISH\"))\n", "target": "\n\nfrom __future__ import division\n\n\ndef jaro(s, t):\n    \n    s_len = len(s)\n    t_len = len(t)\n\n    if s_len == 0 and t_len == 0:\n        return 1\n\n    match_distance = (max(s_len, t_len) // 2) - 1\n\n    s_matches = [False] * s_len\n    t_matches = [False] * t_len\n\n    matches = 0\n    transpositions = 0\n\n    for i in range(s_len):\n        start = max(0, i - match_distance)\n        end = min(i + match_distance + 1, t_len)\n\n        for j in range(start, end):\n            if t_matches[j]:\n                continue\n            if s[i] != t[j]:\n                continue\n            s_matches[i] = True\n            t_matches[j] = True\n            matches += 1\n            break\n\n    if matches == 0:\n        return 0\n\n    k = 0\n    for i in range(s_len):\n        if not s_matches[i]:\n            continue\n        while not t_matches[k]:\n            k += 1\n        if s[i] != t[k]:\n            transpositions += 1\n        k += 1\n\n    return ((matches / s_len) +\n            (matches / t_len) +\n            ((matches - transpositions / 2) / matches)) / 3\n\n\ndef main():\n    \n\n    for s, t in [('MARTHA', 'MARHTA'),\n                 ('DIXON', 'DICKSONX'),\n                 ('JELLYFISH', 'SMELLYFISH')]:\n        print(\"jaro(%r, %r) = %.10f\" % (s, t, jaro(s, t)))\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 419535, "name": "Largest proper divisor of n", "source": "Translate Swift to Python: import Foundation\n\nfunc largestProperDivisor(_ n : Int) -> Int? {\n    guard n > 0 else {\n        return nil\n    }\n    if (n & 1) == 0 {\n        return n >> 1\n    }\n    var p = 3\n    while p * p <= n {\n        if n % p == 0 {\n            return n / p\n        }\n        p += 2\n    }\n    return 1\n}\n\nfor n in (1..<101) {\n    print(String(format: \"%2d\", largestProperDivisor(n)!),\n          terminator: n % 10 == 0 ? \"\\n\" : \" \")\n}\n", "target": "def lpd(n):\n    for i in range(n-1,0,-1):\n        if n%i==0: return i\n    return 1\n\nfor i in range(1,101):\n    print(\"{:3}\".format(lpd(i)), end=i%10==0 and '\\n' or '')\n"}
{"id": 419536, "name": "Pseudo-random numbers_Xorshift star", "source": "Translate Swift to Python: import Foundation\n\nstruct XorshiftStar {\n  private let magic: UInt64 = 0x2545F4914F6CDD1D\n  private var state: UInt64\n\n  init(seed: UInt64) {\n    state = seed\n  }\n  \n  mutating func nextInt() -> UInt64 {\n    state ^= state &>> 12\n    state ^= state &<< 25\n    state ^= state &>> 27\n\n    return (state &* magic) &>> 32\n  }\n\n  mutating func nextFloat() -> Float {\n    return Float(nextInt()) / Float(1 << 32)\n  }\n}\n\nextension XorshiftStar: RandomNumberGenerator, IteratorProtocol, Sequence {\n  mutating func next() -> UInt64 {\n    return nextInt()\n  }\n\n  mutating func next() -> UInt64? {\n    return nextInt()\n  }\n}\n\nfor (i, n) in XorshiftStar(seed: 1234567).lazy.enumerated().prefix(5) {\n  print(\"\\(i): \\(n)\")\n}\n\nvar gen = XorshiftStar(seed: 987654321)\nvar counts = [Float: Int]()\n\nfor _ in 0..<100_000 {\n  counts[floorf(gen.nextFloat() * 5), default: 0] += 1\n}\n\nprint(counts)\n", "target": "mask64 = (1 << 64) - 1\nmask32 = (1 << 32) - 1\nconst = 0x2545F4914F6CDD1D\n\n\n\nclass Xorshift_star():\n    \n    def __init__(self, seed=0):\n        self.state = seed & mask64\n\n    def seed(self, num):\n        self.state =  num & mask64\n    \n    def next_int(self):\n        \"return random int between 0 and 2**32\"\n        x = self.state\n        x = (x ^ (x >> 12)) & mask64\n        x = (x ^ (x << 25)) & mask64\n        x = (x ^ (x >> 27)) & mask64\n        self.state = x\n        answer = (((x * const) & mask64) >> 32) & mask32 \n        return answer\n    \n    def  next_float(self):\n        \"return random float between 0 and 1\"\n        return self.next_int() / (1 << 32)\n    \n\nif __name__ == '__main__':\n    random_gen = Xorshift_star()\n    random_gen.seed(1234567)\n    for i in range(5):\n        print(random_gen.next_int())\n        \n    random_gen.seed(987654321)\n    hist = {i:0 for i in range(5)}\n    for i in range(100_000):\n        hist[int(random_gen.next_float() *5)] += 1\n    print(hist)\n"}
{"id": 419537, "name": "Numbers with equal rises and falls", "source": "Translate Swift to Python: import Foundation\n\nfunc equalRisesAndFalls(_ n: Int) -> Bool {\n    var total = 0\n    var previousDigit = -1\n    var m = n\n    while m > 0 {\n        let digit = m % 10\n        m /= 10\n        if previousDigit > digit {\n            total += 1\n        } else if previousDigit >= 0 && previousDigit < digit {\n            total -= 1\n        }\n        previousDigit = digit\n    }\n    return total == 0\n}\n\nvar count = 0\nvar n = 0\nlet limit1 = 200\nlet limit2 = 10000000\nprint(\"The first \\(limit1) numbers in the sequence are:\")\nwhile count < limit2 {\n    n += 1\n    if equalRisesAndFalls(n) {\n        count += 1\n        if count <= limit1 {\n            print(String(format: \"%3d\", n), terminator: count % 20 == 0 ? \"\\n\" : \" \")\n        }\n    }\n}\nprint(\"\\nThe \\(limit2)th number in the sequence is \\(n).\")\n", "target": "import itertools\n\ndef riseEqFall(num):\n    \n    height = 0\n    d1 = num % 10\n    num //= 10\n    while num:\n        d2 = num % 10\n        height += (d1<d2) - (d1>d2)\n        d1 = d2\n        num //= 10\n    return height == 0\n    \ndef sequence(start, fn):\n    \n    num=start-1\n    while True:\n        num += 1\n        while not fn(num): num += 1\n        yield num\n\na296712 = sequence(1, riseEqFall)\n\n\nprint(\"The first 200 numbers are:\")\nprint(*itertools.islice(a296712, 200))\n\n\nprint(\"The 10,000,000th number is:\")\nprint(*itertools.islice(a296712, 10000000-200-1, 10000000-200))\n\n\n"}
{"id": 419538, "name": "Self-describing numbers", "source": "Translate Swift to Python: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isSelfDescribing: Bool {\n    let stringChars = String(self).map({ String($0) })\n    let counts = stringChars.reduce(into: [Int: Int](), {res, char in res[Int(char), default: 0] += 1})\n\n    for (i, n) in stringChars.enumerated() where counts[i, default: 0] != Int(n) {\n      return false\n    }\n\n    return true\n  }\n}\n\nprint(\"Self-describing numbers less than 100,000,000:\")\n\nDispatchQueue.concurrentPerform(iterations: 100_000_000) {i in\n  defer {\n    if i == 100_000_000 - 1 {\n      exit(0)\n    }\n  }\n\n  guard i.isSelfDescribing else {\n    return\n  }\n\n  print(i)\n}\n\ndispatchMain()\n", "target": ">>> def isSelfDescribing(n):\n\ts = str(n)\n\treturn all(s.count(str(i)) == int(ch) for i, ch in enumerate(s))\n\n>>> [x for x in range(4000000) if isSelfDescribing(x)]\n[1210, 2020, 21200, 3211000]\n>>> [(x, isSelfDescribing(x)) for x in (1210, 2020, 21200, 3211000, 42101000, 521001000, 6210001000)]\n[(1210, True), (2020, True), (21200, True), (3211000, True), (42101000, True), (521001000, True), (6210001000, True)]\n"}
{"id": 419539, "name": "Find words which contains more than 3 e vowels", "source": "Translate Swift to Python: import Foundation\n\nfunc e3(_ word: String) -> Bool {\n    var ecount = 0\n    for ch in word {\n        switch (ch) {\n        case \"a\", \"A\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\":\n            return false\n        case \"e\", \"E\":\n            ecount += 1\n        default:\n            break\n        }\n    }\n    return ecount > 3\n}\n\ndo {\n    try String(contentsOfFile: \"unixdict.txt\", encoding: String.Encoding.ascii)\n        .components(separatedBy: \"\\n\")\n        .filter{e3($0)}\n        .enumerated()\n        .forEach{print(String(format: \"%2d.\u00a0%@\", $0.0 + 1, $0.1))}\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "with open('unixdict.txt', 'rt') as f:\n    for line in f.readlines():\n        if not any(c in 'aiou' for c in line) and sum(c=='e' for c in line)>3:\n            print(line.strip())\n"}
{"id": 419540, "name": "Find words with alternating vowels and consonants", "source": "Translate Swift to Python: import Foundation\n\nfunc isVowel(_ char: Character) -> Bool {\n    switch (char) {\n    case \"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\":\n        return true\n    default:\n        return false\n    }\n}\n\nfunc alternatingVowelsAndConsonants(word: String) -> Bool {\n    return zip(word, word.dropFirst()).allSatisfy{isVowel($0.0) != isVowel($0.1)}\n}\n\ndo {\n    try String(contentsOfFile: \"unixdict.txt\", encoding: String.Encoding.ascii)\n        .components(separatedBy: \"\\n\")\n        .filter{$0.count > 9 && alternatingVowelsAndConsonants(word: $0)}\n        .enumerated()\n        .forEach{print(String(format: \"%2d.\u00a0%@\", $0.0 + 1, $0.1))}\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "\n\n\n\ndef isLongAlternator(s):\n    \n    def p(a, b):\n        return isVowel(a) != isVowel(b)\n    return 9 < len(s) and all(map(p, s, s[1:]))\n\n\ndef isVowel(c):\n    \n    return c in 'aeiou'\n\n\n\n\ndef main():\n    \n    matches = [\n        x for x in readFile('unixdict.txt').splitlines()\n        if isLongAlternator(x)\n    ]\n    w = max(len(x) for x in matches)\n    print(str(len(matches)) + ' matching words:\\n')\n    print(\n        '\\n'.join(\n            ' '.join(s) for s in chunksOf(4)([\n                x.ljust(w, ' ') for x in matches\n            ])\n        )\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef readFile(fp):\n    \n    with open(fp, 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 419541, "name": "Air mass", "source": "Translate Swift to Python: import Foundation\n\nextension Double {\n  var radians: Double { self * .pi / 180 }\n}\n\nfunc columnDensity(_ a: Double, _ z: Double) -> Double {\n  func rho(_ a: Double) -> Double {\n    exp(-a / 8500)\n  }\n\n  func height(_ d: Double) -> Double {\n    let aa = 6_371_000 + a\n    let hh = aa * aa + d * d - 2 * d * aa * cos((180 - z).radians)\n\n    return hh.squareRoot() - 6_371_000\n  }\n\n  var sum = 0.0\n  var d = 0.0\n\n  while d < 1e7 {\n    let delta = max(0.001, 0.001 * d)\n\n    sum += rho(height(d + 0.5 * delta)) * delta\n    d += delta\n  }\n\n  return sum\n}\n\nfunc airMass(altitude: Double, zenith: Double) -> Double {\n  return columnDensity(altitude, zenith) / columnDensity(altitude, 0)\n}\n\nprint(\"Angle     0 m              13700 m\")\nprint(\"------------------------------------\")\n\nfor z in stride(from: 0.0, through: 90.0, by: 5.0) {\n  let air = String(\n    format: \"%2.0f      %11.8f      %11.8f\",\n    z,\n    airMass(altitude: 0, zenith: z),\n    airMass(altitude: 13700, zenith: z)\n  )\n\n  print(air)\n}\n", "target": "\n\nfrom math import sqrt, cos, exp\n\nDEG = 0.017453292519943295769236907684886127134  \nRE = 6371000                                     \ndd = 0.001      \nFIN = 10000000  \n \ndef rho(a):\n    \n    return exp(-a / 8500.0)\n \ndef height(a, z, d):\n     \n    return sqrt((RE + a)**2 + d**2 - 2 * d * (RE + a) * cos((180 - z) * DEG)) - RE\n \ndef column_density(a, z):\n    \n    dsum, d = 0.0, 0.0\n    while d < FIN:\n        delta = max(dd, (dd)*d)  \n        dsum += rho(height(a, z, d + 0.5 * delta)) * delta\n        d += delta\n    return dsum\n\ndef airmass(a, z):\n    return column_density(a, z) / column_density(a, 0)\n\nprint('Angle           0 m          13700 m\\n', '-' * 36)\nfor z in range(0, 91, 5):\n    print(f\"{z: 3d}      {airmass(0, z): 12.7f}    {airmass(13700, z): 12.7f}\")\n"}
{"id": 419542, "name": "Words containing _the_ substring", "source": "Translate Swift to Python: import Foundation\n\nlet minLength = 12\nlet substring = \"the\"\n\ndo {\n    try String(contentsOfFile: \"unixdict.txt\", encoding: String.Encoding.ascii)\n        .components(separatedBy: \"\\n\")\n        .filter{$0.count >= minLength && $0.contains(substring)}\n        .enumerated()\n        .forEach{print(String(format: \"%2d.\u00a0%@\", $0.0 + 1, $0.1))}\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import urllib.request as request\n\nwith request.urlopen(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\") as f:\n    a = f.read().decode(\"ASCII\").split()\n\nfor s in a:\n    if len(s) > 11 and \"the\" in s:\n        print(s)\n"}
{"id": 419543, "name": "Address of a variable", "source": "Translate Swift to Python: class MyClass { }\n\nfunc printAddress<T>(of pointer: UnsafePointer<T>) {\n    print(pointer)\n}\n\nfunc test() {\n    var x = 42\n    var y = 3.14\n    var z = \"foo\"\n    var obj = MyClass()\n\n    \n    withUnsafePointer(to: &x)   { print($0) }\n    withUnsafePointer(to: &y)   { print($0) }\n    withUnsafePointer(to: &z)   { print($0) }\n    withUnsafePointer(to: &obj) { print($0) }\n\n    \n    printAddress(of: &x)\n    printAddress(of: &y)\n    printAddress(of: &z)\n    printAddress(of: &obj)\n\n    \n    print(Unmanaged.passUnretained(obj).toOpaque())\n}\n\ntest()\n", "target": "var num = 12\nvar pointer = ptr(num) \n\nprint pointer \n\n@unsafe \npointer.addr = 0xFFFE \n"}
{"id": 419544, "name": "Find words whose first and last three letters are equal", "source": "Translate Swift to Python: import Foundation\n\ndo {\n    try String(contentsOfFile: \"unixdict.txt\", encoding: String.Encoding.ascii)\n        .components(separatedBy: \"\\n\")\n        .filter{$0.count > 5 && $0.prefix(3) == $0.suffix(3)}\n        .enumerated()\n        .forEach{print(\"\\($0.0 + 1). \\($0.1)\")}\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import urllib.request\nurllib.request.urlretrieve(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\", \"unixdict.txt\")\n\ndictionary = open(\"unixdict.txt\",\"r\")\n\nwordList = dictionary.read().split('\\n')\n\ndictionary.close()\n\nfor word in wordList:\n    if len(word)>5 and word[:3].lower()==word[-3:].lower():\n        print(word)\n"}
{"id": 419545, "name": "Find words which contains all the vowels", "source": "Translate Swift to Python: import Foundation\n\nfunc containsAllVowelsOnce(_ word: String) -> Bool {\n    var vowels = 0\n    for ch in word {\n        var bit = 0\n        switch (ch) {\n        case \"a\", \"A\":\n            bit = 1\n        case \"e\", \"E\":\n            bit = 2\n        case \"i\", \"I\":\n            bit = 4\n        case \"o\", \"O\":\n            bit = 8\n        case \"u\", \"U\":\n            bit = 16\n        default:\n            break\n        }\n        if bit == 0 {\n            continue\n        }\n        if ((vowels & bit) != 0) {\n            return false\n        }\n        vowels |= bit\n    }\n    return vowels == 31\n}\n\ndo {\n    try String(contentsOfFile: \"unixdict.txt\", encoding: String.Encoding.ascii)\n        .components(separatedBy: \"\\n\")\n        .filter{$0.count > 10 && containsAllVowelsOnce($0)}\n        .enumerated()\n        .forEach{print(String(format: \"%2d.\u00a0%@\", $0.0 + 1, $0.1))}\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import urllib.request\nfrom collections import Counter\n\nurllib.request.urlretrieve(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\", \"unixdict.txt\")\n\ndictionary = open(\"unixdict.txt\",\"r\")\n\nwordList = dictionary.read().split('\\n')\n\ndictionary.close()\n\nfor word in wordList:\n    if len(word)>10:\n        frequency = Counter(word.lower())\n        if frequency['a']==frequency['e']==frequency['i']==frequency['o']==frequency['u']==1:\n            print(word)\n"}
{"id": 419546, "name": "Odd words", "source": "Translate Swift to Python: import Foundation\n\nlet minLength = 5\n\nfunc loadDictionary(_ path: String) throws -> Set<String> {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return Set<String>(contents.components(separatedBy: \"\\n\").filter{$0.count >= minLength})\n}\n\nfunc pad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : string + String(repeating: \" \", count: width - string.count)\n}\n\nfunc printWords(words: [(String,String)]) {\n    for (n, (word1, word2)) in words.enumerated() {\n        print(\"\\(String(format: \"%2d\", n + 1)): \\(pad(string: word1, width: 14))\\(word2)\")\n    }\n}\n\ndo {\n    let dictionary = try loadDictionary(\"unixdict.txt\")\n    var oddWords: [(String, String)] = []\n    var evenWords: [(String, String)] = []\n    for word in dictionary {\n        if word.count < minLength + 2*(minLength/2) {\n            continue\n        }\n        var oddWord = \"\"\n        var evenWord = \"\"\n        for (i, c) in word.enumerated() {\n            if (i & 1) == 0 {\n                oddWord.append(c)\n            } else {\n                evenWord.append(c)\n            }\n        }\n        if dictionary.contains(oddWord) {\n            oddWords.append((word, oddWord))\n        }\n        if dictionary.contains(evenWord) {\n            evenWords.append((word, evenWord))\n        }\n    }\n    oddWords.sort(by: {$0.0 < $1.0})\n    evenWords.sort(by: {$0.0 < $1.0})\n    print(\"Odd words:\")\n    printWords(words: oddWords)\n    print(\"\\nEven words:\")\n    printWords(words: evenWords)\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "\n\nimport urllib.request\nurllib.request.urlretrieve(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\", \"unixdict.txt\")\n\ndictionary = open(\"unixdict.txt\",\"r\")\n\nwordList = dictionary.read().split('\\n')\n\ndictionary.close()\n\noddWordSet = set({})\n\nfor word in wordList:\n    if len(word)>=9 and word[::2] in wordList:\n        oddWordSet.add(word[::2])\n\n[print(i) for i in sorted(oddWordSet)]\n"}
{"id": 419547, "name": "Deming's funnel", "source": "Translate Swift to Python: import Foundation\n\nlet dxs = [\n  -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,\n  1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,\n  -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,\n  0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,\n  -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,\n  -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,\n  0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,\n  -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,\n  0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,\n  -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,\n  0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,\n  0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,\n  0.443, -0.521, -0.799,  0.087\n]\n\nlet dys = [\n  0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,\n  0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,\n  0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,\n  0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,\n  -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,\n  0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,\n  0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,\n  1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,\n  -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,\n  0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,\n  -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,\n  1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,\n  -0.947, -1.424, -0.542, -1.032\n]\n\nextension Collection where Element: FloatingPoint {\n  @inlinable\n  public func mean() -> Element {\n    return reduce(0, +) / Element(count)\n  }\n\n  @inlinable\n  public func stdDev() -> Element {\n    let m = mean()\n\n    return map({ ($0 - m) * ($0 - m) }).mean().squareRoot()\n  }\n}\n\ntypealias Rule = (Double, Double) -> Double\n\nfunc funnel(_ arr: [Double], rule: Rule) -> [Double] {\n  var x = 0.0\n  var res = [Double](repeating: 0, count: arr.count)\n\n  for (i, d) in arr.enumerated() {\n    res[i] = x + d\n    x = rule(x, d)\n  }\n\n  return res\n}\n\nfunc experiment(label: String, rule: Rule) {\n  let rxs = funnel(dxs, rule: rule)\n  let rys = funnel(dys, rule: rule)\n\n  print(\"\\(label)\\t:    x        y\")\n  print(\"Mean\\t:\\(String(format: \"%7.4f, %7.4f\", rxs.mean(), rys.mean()))\")\n  print(\"Std Dev\\t:\\(String(format: \"%7.4f, %7.4f\", rxs.stdDev(), rys.stdDev()))\")\n  print()\n}\n\nexperiment(label: \"Rule 1\", rule: {_, _ in 0 })\nexperiment(label: \"Rule 2\", rule: {_, dz in -dz })\nexperiment(label: \"Rule 3\", rule: {z, dz in -(z + dz) })\nexperiment(label: \"Rule 4\", rule: {z, dz in z + dz })\n", "target": "import math \n\ndxs = [-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251,\n       -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915,\n       2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193, \n       0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423,\n       -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201, \n       0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789,\n       0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853,\n       0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106,\n       0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749,\n       -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799, \n       0.087]\n\ndys = [0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682,\n       -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188, \n       -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199,\n       0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007, \n       0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038, \n       -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445, \n       -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044, \n       0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104, \n       -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901, \n       0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032]\n\ndef funnel(dxs, rule):\n    x, rxs = 0, []\n    for dx in dxs:\n        rxs.append(x + dx)\n        x = rule(x, dx)\n    return rxs\n\ndef mean(xs): return sum(xs) / len(xs)\n\ndef stddev(xs):\n    m = mean(xs)\n    return math.sqrt(sum((x-m)**2 for x in xs) / len(xs))\n\ndef experiment(label, rule):\n    rxs, rys = funnel(dxs, rule), funnel(dys, rule)\n    print label\n    print 'Mean x, y   \u00a0: %.4f, %.4f' % (mean(rxs), mean(rys))\n    print 'Std dev x, y\u00a0: %.4f, %.4f' % (stddev(rxs), stddev(rys))\n    print\n\n\nexperiment('Rule 1:', lambda z, dz: 0)\nexperiment('Rule 2:', lambda z, dz: -dz)\nexperiment('Rule 3:', lambda z, dz: -(z+dz))\nexperiment('Rule 4:', lambda z, dz: z+dz)\n"}
{"id": 419548, "name": "Deming's funnel", "source": "Translate Swift to Python: import Foundation\n\nlet dxs = [\n  -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,\n  1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,\n  -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,\n  0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,\n  -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,\n  -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,\n  0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,\n  -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,\n  0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,\n  -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,\n  0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,\n  0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,\n  0.443, -0.521, -0.799,  0.087\n]\n\nlet dys = [\n  0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,\n  0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,\n  0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,\n  0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,\n  -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,\n  0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,\n  0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,\n  1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,\n  -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,\n  0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,\n  -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,\n  1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,\n  -0.947, -1.424, -0.542, -1.032\n]\n\nextension Collection where Element: FloatingPoint {\n  @inlinable\n  public func mean() -> Element {\n    return reduce(0, +) / Element(count)\n  }\n\n  @inlinable\n  public func stdDev() -> Element {\n    let m = mean()\n\n    return map({ ($0 - m) * ($0 - m) }).mean().squareRoot()\n  }\n}\n\ntypealias Rule = (Double, Double) -> Double\n\nfunc funnel(_ arr: [Double], rule: Rule) -> [Double] {\n  var x = 0.0\n  var res = [Double](repeating: 0, count: arr.count)\n\n  for (i, d) in arr.enumerated() {\n    res[i] = x + d\n    x = rule(x, d)\n  }\n\n  return res\n}\n\nfunc experiment(label: String, rule: Rule) {\n  let rxs = funnel(dxs, rule: rule)\n  let rys = funnel(dys, rule: rule)\n\n  print(\"\\(label)\\t:    x        y\")\n  print(\"Mean\\t:\\(String(format: \"%7.4f, %7.4f\", rxs.mean(), rys.mean()))\")\n  print(\"Std Dev\\t:\\(String(format: \"%7.4f, %7.4f\", rxs.stdDev(), rys.stdDev()))\")\n  print()\n}\n\nexperiment(label: \"Rule 1\", rule: {_, _ in 0 })\nexperiment(label: \"Rule 2\", rule: {_, dz in -dz })\nexperiment(label: \"Rule 3\", rule: {z, dz in -(z + dz) })\nexperiment(label: \"Rule 4\", rule: {z, dz in z + dz })\n", "target": "import math \n\ndxs = [-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251,\n       -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915,\n       2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193, \n       0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423,\n       -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201, \n       0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789,\n       0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853,\n       0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106,\n       0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749,\n       -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799, \n       0.087]\n\ndys = [0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682,\n       -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188, \n       -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199,\n       0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007, \n       0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038, \n       -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445, \n       -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044, \n       0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104, \n       -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901, \n       0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032]\n\ndef funnel(dxs, rule):\n    x, rxs = 0, []\n    for dx in dxs:\n        rxs.append(x + dx)\n        x = rule(x, dx)\n    return rxs\n\ndef mean(xs): return sum(xs) / len(xs)\n\ndef stddev(xs):\n    m = mean(xs)\n    return math.sqrt(sum((x-m)**2 for x in xs) / len(xs))\n\ndef experiment(label, rule):\n    rxs, rys = funnel(dxs, rule), funnel(dys, rule)\n    print label\n    print 'Mean x, y   \u00a0: %.4f, %.4f' % (mean(rxs), mean(rys))\n    print 'Std dev x, y\u00a0: %.4f, %.4f' % (stddev(rxs), stddev(rys))\n    print\n\n\nexperiment('Rule 1:', lambda z, dz: 0)\nexperiment('Rule 2:', lambda z, dz: -dz)\nexperiment('Rule 3:', lambda z, dz: -(z+dz))\nexperiment('Rule 4:', lambda z, dz: z+dz)\n"}
{"id": 419549, "name": "Hunt the Wumpus", "source": "Translate Swift to Python: import Foundation\n\n\nvar cave: [Int:[Int]] = [\n    1: [2, 3, 4],\n    2: [1, 5, 6],\n    3: [1, 7, 8],\n    4: [1, 9, 10],\n    5: [2, 9, 11],\n    6: [2, 7, 12],\n    7: [3, 6, 13],\n    8: [3, 10, 14],\n    9: [4, 5, 15],\n    10: [4, 8, 16],\n    11: [5, 12, 17],\n    12: [6, 11, 18],\n    13: [7, 14, 18],\n    14: [8, 13, 19],\n    15: [9, 16, 17],\n    16: [10, 15, 19],\n    17: [11, 20, 15],\n    18: [12, 13, 20],\n    19: [14, 16, 20],\n    20: [17, 18, 19]\n]\n\n\nvar player: Int = 0, wumpus: Int = 0, bat1:Int = 0, bat2:Int = 0, pit1:Int = 0, pit2:Int = 0\n\n\nvar arrows = 5\n\n\nfunc isEmpty(r:Int)->Bool {\n    if r != player &&\n       r != wumpus &&\n       r != bat1 &&\n       r != bat2 &&\n       r != pit1 &&\n       r != pit2 {\n            return true\n        }\n        return false\n}\n\n\nfunc sense(adj: [Int]) {\n    var bat = false\n    var pit = false\n    for ar in adj {\n        if ar == wumpus {\n            print(\"You smell something terrible nearby.\")\n        }\n        switch ar {\n        case bat1, bat2:\n            if !bat {\n                print(\"You hear rustling.\")\n                bat = true\n            }\n        case pit1, pit2:\n            if !pit {\n                print(\"You feel a cold wind blowing from a nearby cavern.\")\n                pit = true\n            }\n        default:\n            print(\"\")\n        }\n    }\n}\n\n\nfunc plural(n: Int)->String {\n    if n != 1 {\n        return \"s\"\n    }\n    return \"\"\n}\n\n\nfunc game() {\n    \n    \n    player = 1\n    \n    \n    wumpus = Int.random(in: 2..<21)\n    bat1 = Int.random(in: 2..<21)\n    \n    \n    while true {\n        bat2 = Int.random(in: 2..<21)\n        if bat2 != bat1 {\n            break\n        }\n    }\n    \n    \n    while true {\n        pit1 = Int.random(in: 2..<21)\n        if pit1 != bat1 && pit1 != bat2 {\n            break\n        }\n    }\n    while true {\n        pit2 = Int.random(in: 0..<21)\n        if pit2 != bat1 && pit2 != bat2 && pit2 != pit1 {\n            break\n        }\n    }\n    \n    \n    while true {\n        print(\"\\nYou are in room \\(player) with \\(arrows) arrow\\(plural(n: arrows)) left\\n\")\n        \n        \n        let adj = cave[player]!\n        print(\"The adjacent rooms are \\(adj)\\n\")\n        \n        \n        sense(adj: adj)\n        \n        \n        var room: Int?\n        while true {\n            print(\"Choose an adjacent room: \")\n            \n            \n            if let roomInput = Int(readLine()!) {\n                room = roomInput\n                if !adj.contains(room!) {\n                    print(\"\\ninvalid response, try again\\n\")\n                    print(\"The adjacent rooms are \\(adj)\\n\")\n                } else {\n                    break\n                }\n            } else {\n                print(\"\\ninvalid response, try again\\n\")\n                print(\"The adjacent rooms are \\(adj)\\n\")\n            }\n        }\n        \n        \n        var action: String = \"\"\n        \n        \n        while true {\n            print(\"Walk or shoot w/s: \")\n            \n            if var reply = readLine() {\n                reply = reply.lowercased()\n                if reply.count != 1 || (reply.count == 1 && Array(reply)[0] != \"w\" && Array(reply)[0] != \"s\") {\n                    print(\"Invalid response, try again\")\n                } else {\n                    \n                    action = Array(arrayLiteral: reply)[0]\n                    break\n                }\n            } else {\n                print(\"Invalid response, try again\")\n            }\n        }\n        \n        if action == \"w\" {\n            \n            player = room!\n            switch player {\n                \n                case wumpus:\n                    print(\"You have been eaten by the wumpus and lost the game\")\n                    return\n                case pit1, pit2:\n                    print(\"You have fallen down a bottomless pit and lost the game!\")\n                    return\n                \n                case bat1, bat2:\n                    while true {\n                        room = Int.random(in: 2..<21)\n                        if isEmpty(r: room!) {\n                            print(\"A bat has transported you to a random empty room.\")\n                            player = room!            \n                            break\n                        }\n                    }\n                default:\n                    break\n            }\n        } else {\n            \n            if room == wumpus {\n                print(\"You have killed the wumpus and won the game!!\")\n                return\n            } else {\n                \n                let chance = Int.random(in: 0..<4)\n                if chance > 0 {\n                    wumpus = cave[wumpus]![Int.random(in: 0..<3)]\n                    \n                    if player == wumpus {\n                        print(\"You have been eaten by the wumpus and lost the game!\")\n                        return\n                    }\n                }\n            }\n            \n            arrows-=1\n            if arrows == 0 {\n                print(\"You have run out of arrows and lost the game!\")\n                return\n            }\n        }\n    }\n}\ngame()\n", "target": "import random\n\nclass WumpusGame(object):\n\n\n\tdef __init__(self, edges=[]):\n\t\t\n\t\t\n\t\tif edges:\n\t\t\tcave = {}\n\t\t\tN = max([edges[i][0] for i in range(len(edges))])\n\t\t\tfor i in range(N):\n\t\t\t\texits = [edge[1] for edge in edges if edge[0] == i]\n\t\t\t\tcave[i] = exits\n\n\t\t\n\t\telse:\n\t\t\tcave = {1: [2,3,4], 2: [1,5,6], 3: [1,7,8], 4: [1,9,10], 5:[2,9,11],\n\t\t\t\t6: [2,7,12], 7: [3,6,13], 8: [3,10,14], 9: [4,5,15], 10: [4,8,16], \n\t\t\t\t11: [5,12,17], 12: [6,11,18], 13: [7,14,18], 14: [8,13,19], \n\t\t\t\t15: [9,16,17], 16: [10,15,19], 17: [11,20,15], 18: [12,13,20], \n\t\t\t\t19: [14,16,20], 20: [17,18,19]}\n\n\t\tself.cave = cave\n\n\t\tself.threats = {}\n\n\t\tself.arrows = 5\n\n\t\tself.arrow_travel_distance = 5\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\tself.player_pos = -1\n\n\n\t\n\n\n\tdef get_safe_rooms(self):\n\t\t\n\t\treturn list(set(self.cave.keys()).difference(self.threats.keys()))\n\n\n\tdef populate_cave(self):\n\t\t\n\t\tfor threat in ['bat', 'bat', 'pit', 'pit', 'wumpus']:\n\t\t\tpos = random.choice(self.get_safe_rooms())\n\t\t\tself.threats[pos] = threat\n\t\tself.player_pos = random.choice(self.get_safe_rooms())\n\n\n\tdef breadth_first_search(self, source, target, max_depth=5):\n\t\t\n\t\t\n\t\tgraph = self.cave\n\t\tdepth = 0\n\n\t\tdef search(stack, visited, target, depth):\n\t\t\tif stack == []:\t\t\t\t\t\n\t\t\t\treturn False, -1\n\t\t\tif target in stack:\n\t\t\t\treturn True, depth\n\t\t\tvisited = visited + stack\n\t\t\tstack = list(set([graph[v][i] for v in stack for i in range(len(graph[v]))]).difference(visited))\n\t\t\tdepth += 1\n\t\t\tif depth > max_depth:\t\t\t\n\t\t\t\treturn False, depth\n\t\t\telse:\t\t\t\t\t\t\t\n\t\t\t\treturn search(stack, visited, target, depth)\n\n\t\treturn search([source], [], target, depth)\n\n\n\t\n\n\n\tdef print_warning(self, threat):\n\t\t\n\t\tif threat == 'bat':\n\t\t\tprint(\"You hear a rustling.\")\n\t\telif threat == 'pit':\n\t\t\tprint(\"You feel a cold wind blowing from a nearby cavern.\")\n\t\telif threat == 'wumpus':\n\t\t\tprint(\"You smell something terrible nearby.\")\n\n\n\tdef get_players_input(self):\n\t\t\n\t\twhile 1:\t\t\t\t\t\t\t\t\n\n\t\t\tinpt = input(\"Shoot or move (S-M)? \")\n\t\t\ttry:\t\t\t\t\t\t\t\t\n\t\t\t\tmode = str(inpt).lower()\n\t\t\t\tassert mode in ['s', 'm', 'q']\n\t\t\t\tbreak\n\t\t\texcept (ValueError, AssertionError):\n\t\t\t\tprint(\"This is not a valid action: pick 'S' to shoot and 'M' to move.\")\n\n\t\tif mode == 'q':\t\t\t\t\t\t\t\n\t\t\treturn 'q', 0\n\n\t\twhile 1:\t\t\t\t\t\t\t\t\n\n\t\t\tinpt = input(\"Where to? \")\n\t\t\ttry:\t\t\t\t\t\t\t\t\n\t\t\t\ttarget = int(inpt)\n\t\t\texcept ValueError:\n\t\t\t\tprint(\"This is not even a real number.\")\n\t\t\t\tcontinue\t\t\t\t\t\t\n\n\t\t\tif mode == 'm':\n\t\t\t\ttry:\t\t\t\t\t\t\t\n\t\t\t\t\tassert target in self.cave[self.player_pos]\n\t\t\t\t\tbreak\n\t\t\t\texcept AssertionError:\n\t\t\t\t\tprint(\"You cannot walk that far. Please use one of the tunnels.\")\n\n\t\t\telif mode == 's':\n\t\t\t\ttry:\t\t\t\t\t\t\t\n\t\t\t\t\tbfs = self.breadth_first_search(self.player_pos, target)\n\t\t\t\t\tassert bfs[0] == True\n\t\t\t\t\tbreak\n\t\t\t\texcept AssertionError:\n\t\t\t\t\tif bfs[1] == -1: \t\t\t\n\t\t\t\t\t\tprint(\"There is no room with this number in the cave. Your arrow travels randomly.\")\n\t\t\t\t\t\ttarget = random.choice(self.cave.keys())\n\t\t\t\t\tif bfs[1] > self.arrow_travel_distance:\t\t\t\t\n\t\t\t\t\t\tprint(\"Arrows aren't that croocked.\")\n\n\t\treturn mode, target\n\n\n\t\n\n\n\tdef enter_room(self, room_number):\n\t\t\t\n\t\tprint(\"Entering room {}...\".format(room_number))\n\t\t\n\t\tif self.threats.get(room_number) == 'bat':\n\t\t\t\n\t\t\tprint(\"You encounter a bat, it transports you to a random empty room.\")\n\t\t\tnew_pos = random.choice(self.get_safe_rooms())\n\t\t\treturn self.enter_room(new_pos)\n\t\telif self.threats.get(room_number) == 'wumpus':\n\t\t\tprint(\"Wumpus eats you.\")\n\t\t\treturn -1\n\t\telif self.threats.get(room_number) == 'pit':\n\t\t\tprint(\"You fall into a pit.\")\n\t\t\treturn -1\n\n\t\t\n\t\tfor i in self.cave[room_number]:\n\t\t\tself.print_warning(self.threats.get(i))\n\n\t\t\n\t\treturn room_number\n\n\n\tdef shoot_room(self, room_number):\n\t\t\n\t\tprint(\"Shooting an arrow into room {}...\".format(room_number))\n\t\t\n\t\tself.arrows -= 1\n\t\tthreat = self.threats.get(room_number)\n\t\tif threat in ['bat', 'wumpus']:\n\t\t\tdel self.threats[room_number]\t\t\n\t\t\tif threat == 'wumpus':\n\t\t\t\tprint(\"Hurra, you killed the wumpus!\")\n\t\t\t\treturn -1\n\t\t\telif threat == 'bat':\n\t\t\t\tprint(\"You killed a bat.\")\n\t\telif threat in ['pit', None]:\n\t\t\tprint(\"This arrow is lost.\")\n\t\t\n\t\t\n\t\tif self.arrows < 1:\t\t\n\t\t\tprint(\"Your quiver is empty.\")\n\t\t\treturn -1\n\n\t\t\n\t\tif random.random() < 0.75:\n\t\t\t\n\t\t\tfor room_number, threat in self.threats.items():\n\t\t\t\tif threat == 'wumpus':\n\t\t\t\t\twumpus_pos = room_number\t\t\t\t\t\n\t\t\tnew_pos = random.choice(list(set(self.cave[wumpus_pos]).difference(self.threats.keys())))\n\t\t\tdel self.threats[room_number]\n\t\t\tself.threats[new_pos] = 'wumpus'\t\t\t\n\t\t\tif new_pos == self.player_pos: \n\t\t\t\tprint(\"Wumpus enters your room and eats you!\")\n\t\t\t\treturn -1\n\n\t\treturn self.player_pos\n\n\t\t\n\tdef gameloop(self):\n\n\t\tprint(\"HUNT THE WUMPUS\")\n\t\tprint(\"===============\")\n\t\tprint()\n\t\tself.populate_cave()\n\t\tself.enter_room(self.player_pos)\n\n\t\twhile 1:\n\n\t\t\t\n\t\t\t\n\t\t\t\n\n\t\t\tprint(\"You are in room {}.\".format(self.player_pos), end=\" \")\n\t\t\tprint(\"Tunnels lead to:  {0}  {1}  {2}\".format(*self.cave[self.player_pos]))\n\t\t\t\n\t\t\t\n\t\t\tinpt = self.get_players_input()\t\t\n\t\t\tprint()\t\t\t\t\t\t\t\t\n\t\t\tif inpt[0] == 'm':\t\t\t\t\t\n\t\t\t\ttarget = inpt[1] \n\t\t\t\tself.player_pos = self.enter_room(target)\n\t\t\telif inpt[0] == 's':\t\t\t\t\n\t\t\t\ttarget = inpt[1]\n\t\t\t\tself.player_pos = self.shoot_room(target)\n\t\t\telif inpt[0] == 'q':\t\t\t\t\n\t\t\t\tself.player_pos = -1\n\n\t\t\tif self.player_pos == -1:\t\t\t\n\t\t\t\tbreak\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t\tprint()\n\t\tprint(\"Game over!\")\t\n\t\t\n\nif __name__ == '__main__':\t\t\t\t\t\t\n\t\n\t\n\t\n\t\n\n\t\n\n\tWG = WumpusGame()\n\tWG.gameloop()\n"}
{"id": 419550, "name": "MD5_Implementation", "source": "Translate Swift to Python:     import Foundation\n    public class MD5 {\n        \n        private let s: [UInt32] = [7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,\n                           5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,\n                           4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,\n                           6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21]\n        \n        \n        private let K: [UInt32] = (0 ..< 64).map { UInt32(0x100000000 * abs(sin(Double($0 + 1)))) }\n        \n        let a0: UInt32 = 0x67452301\n        let b0: UInt32 = 0xefcdab89\n        let c0: UInt32 = 0x98badcfe\n        let d0: UInt32 = 0x10325476\n        \n        private var message: NSData\n        \n        \n        \n        public init(_ message: NSData) {\n            self.message = message\n        }\n        \n        public func calculate() -> NSData? {\n            var tmpMessage: NSMutableData = NSMutableData(data: message)\n            let wordSize = sizeof(UInt32)\n            \n            var aa = a0\n            var bb = b0\n            var cc = c0\n            var dd = d0\n            \n            \n            tmpMessage.appendBytes([0x80]) \n            \n            \n            while tmpMessage.length % 64 != 56 {\n                tmpMessage.appendBytes([0x00])\n            }\n            \n            \n            var lengthInBits = (message.length * 8)\n            var lengthBytes = lengthInBits.bytes(64 / 8)\n            tmpMessage.appendBytes(reverse(lengthBytes));\n            \n            \n            let chunkSizeBytes = 512 / 8\n            var leftMessageBytes = tmpMessage.length\n            for var i = 0; i < tmpMessage.length; i = i + chunkSizeBytes, leftMessageBytes -= chunkSizeBytes {\n                let chunk = tmpMessage.subdataWithRange(NSRange(location: i, length: min(chunkSizeBytes,leftMessageBytes)))\n                \n                \n                \n                var M:[UInt32] = [UInt32](count: 16, repeatedValue: 0)\n                for x in 0..<M.count {\n                    var range = NSRange(location:x * wordSize, length: wordSize)\n                    chunk.getBytes(&M[x], range:range);\n                }\n                \n                \n                var A:UInt32 = a0\n                var B:UInt32 = b0\n                var C:UInt32 = c0\n                var D:UInt32 = d0\n                \n                var dTemp:UInt32 = 0\n                \n                \n                for j in 0...63 {\n                    var g = 0\n                    var F:UInt32 = 0\n                    \n                    switch (j) {\n                    case 0...15:\n                        F = (B & C) | ((~B) & D)\n                        g = j\n                        break\n                    case 16...31:\n                        F = (D & B) | (~D & C)\n                        g = (5 * j + 1) % 16\n                        break\n                    case 32...47:\n                        F = B ^ C ^ D\n                        g = (3 * j + 5) % 16\n                        break\n                    case 48...63:\n                        F = C ^ (B | (~D))\n                        g = (7 * j) % 16\n                        break\n                    default:\n                        break\n                    }\n                    dTemp = D\n                    D = C\n                    C = B\n                    B = B &+ rotateLeft((A &+ F &+ K[j] &+ M[g]), s[j])\n                    A = dTemp    \n                }\n                \n                aa = aa &+ A\n                bb = bb &+ B\n                cc = cc &+ C\n                dd = dd &+ D\n            }\n\n            var buf: NSMutableData = NSMutableData();\n            buf.appendBytes(&aa, length: wordSize)\n            buf.appendBytes(&bb, length: wordSize)\n            buf.appendBytes(&cc, length: wordSize)\n            buf.appendBytes(&dd, length: wordSize)\n            \n            return buf.copy() as? NSData;\n        }\n\n        \n        class func calculate(message: NSData) -> NSData?\n        {\n            return MD5(message).calculate();\n        }\n        \n        \n        private func rotateLeft(x:UInt32, _ n:UInt32) -> UInt32 {\n            return (x &<< n) | (x &>> (32 - n))\n        }\n    }\n", "target": "import math\n\nrotate_amounts = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,\n                  5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,\n                  4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,\n                  6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]\n\nconstants = [int(abs(math.sin(i+1)) * 2**32) & 0xFFFFFFFF for i in range(64)]\n\ninit_values = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]\n\nfunctions = 16*[lambda b, c, d: (b & c) | (~b & d)] + \\\n            16*[lambda b, c, d: (d & b) | (~d & c)] + \\\n            16*[lambda b, c, d: b ^ c ^ d] + \\\n            16*[lambda b, c, d: c ^ (b | ~d)]\n\nindex_functions = 16*[lambda i: i] + \\\n                  16*[lambda i: (5*i + 1)%16] + \\\n                  16*[lambda i: (3*i + 5)%16] + \\\n                  16*[lambda i: (7*i)%16]\n\ndef left_rotate(x, amount):\n    x &= 0xFFFFFFFF\n    return ((x<<amount) | (x>>(32-amount))) & 0xFFFFFFFF\n\ndef md5(message):\n\n    message = bytearray(message) \n    orig_len_in_bits = (8 * len(message)) & 0xffffffffffffffff\n    message.append(0x80)\n    while len(message)%64 != 56:\n        message.append(0)\n    message += orig_len_in_bits.to_bytes(8, byteorder='little')\n\n    hash_pieces = init_values[:]\n\n    for chunk_ofst in range(0, len(message), 64):\n        a, b, c, d = hash_pieces\n        chunk = message[chunk_ofst:chunk_ofst+64]\n        for i in range(64):\n            f = functions[i](b, c, d)\n            g = index_functions[i](i)\n            to_rotate = a + f + constants[i] + int.from_bytes(chunk[4*g:4*g+4], byteorder='little')\n            new_b = (b + left_rotate(to_rotate, rotate_amounts[i])) & 0xFFFFFFFF\n            a, b, c, d = d, new_b, b, c\n        for i, val in enumerate([a, b, c, d]):\n            hash_pieces[i] += val\n            hash_pieces[i] &= 0xFFFFFFFF\n    \n    return sum(x<<(32*i) for i, x in enumerate(hash_pieces))\n        \ndef md5_to_hex(digest):\n    raw = digest.to_bytes(16, byteorder='little')\n    return '{:032x}'.format(int.from_bytes(raw, byteorder='big'))\n\nif __name__=='__main__':\n    demo = [b\"\", b\"a\", b\"abc\", b\"message digest\", b\"abcdefghijklmnopqrstuvwxyz\",\n            b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n            b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"]\n    for message in demo:\n        print(md5_to_hex(md5(message)),' <= \"',message.decode('ascii'),'\"', sep='')\n"}
{"id": 419551, "name": "History variables", "source": "Translate Swift to Python: var historyOfHistory = [Int]()\nvar history:Int = 0 {\n    willSet {\n        historyOfHistory.append(history)\n    }\n}\n\nhistory = 2\nhistory = 3\nhistory = 4\nprintln(historyOfHistory)\n", "target": "import sys\n\nHIST = {}\n\ndef trace(frame, event, arg):\n    for name,val in frame.f_locals.items():\n        if name not in HIST:\n            HIST[name] = []\n        else:\n            if HIST[name][-1] is val:\n                continue\n        HIST[name].append(val)\n    return trace\n\ndef undo(name):\n    HIST[name].pop(-1)\n    return HIST[name][-1]\n\ndef main():\n    a = 10\n    a = 20\n\n    for i in range(5):\n        c = i\n\n    print \"c:\", c, \"-> undo x3 ->\",\n    c = undo('c')\n    c = undo('c')\n    c = undo('c')\n    print c\n    print 'HIST:', HIST\n\nsys.settrace(trace)\nmain()\n"}
{"id": 419552, "name": "Jacobi symbol", "source": "Translate Swift to Python: import Foundation\n\nfunc jacobi(a: Int, n: Int) -> Int {\n  var a = a % n\n  var n = n\n  var res = 1\n\n  while a != 0 {\n    while a & 1 == 0 {\n      a >>= 1\n\n      if n % 8 == 3 || n % 8 == 5 {\n        res = -res\n      }\n    }\n\n    (a, n) = (n, a)\n\n    if a % 4 == 3 && n % 4 == 3 {\n      res = -res\n    }\n    \n    a %= n\n  }\n\n  return n == 1 ? res : 0\n}\n\nprint(\"n/a  0  1  2  3  4  5  6  7  8  9\")\nprint(\"---------------------------------\")\n\nfor n in stride(from: 1, through: 17, by: 2) {\n  print(String(format: \"%2d\", n), terminator: \"\")\n\n  for a in 0..<10 {\n    print(String(format: \"\u00a0% d\", jacobi(a: a, n: n)), terminator: \"\")\n  }\n\n  print()\n}\n", "target": "def jacobi(a, n):\n    if n <= 0:\n        raise ValueError(\"'n' must be a positive integer.\")\n    if n % 2 == 0:\n        raise ValueError(\"'n' must be odd.\")\n    a %= n\n    result = 1\n    while a != 0:\n        while a % 2 == 0:\n            a /= 2\n            n_mod_8 = n % 8\n            if n_mod_8 in (3, 5):\n                result = -result\n        a, n = n, a\n        if a % 4 == 3 and n % 4 == 3:\n            result = -result\n        a %= n\n    if n == 1:\n        return result\n    else:\n        return 0\n"}
{"id": 419553, "name": "Jacobi symbol", "source": "Translate Swift to Python: import Foundation\n\nfunc jacobi(a: Int, n: Int) -> Int {\n  var a = a % n\n  var n = n\n  var res = 1\n\n  while a != 0 {\n    while a & 1 == 0 {\n      a >>= 1\n\n      if n % 8 == 3 || n % 8 == 5 {\n        res = -res\n      }\n    }\n\n    (a, n) = (n, a)\n\n    if a % 4 == 3 && n % 4 == 3 {\n      res = -res\n    }\n    \n    a %= n\n  }\n\n  return n == 1 ? res : 0\n}\n\nprint(\"n/a  0  1  2  3  4  5  6  7  8  9\")\nprint(\"---------------------------------\")\n\nfor n in stride(from: 1, through: 17, by: 2) {\n  print(String(format: \"%2d\", n), terminator: \"\")\n\n  for a in 0..<10 {\n    print(String(format: \"\u00a0% d\", jacobi(a: a, n: n)), terminator: \"\")\n  }\n\n  print()\n}\n", "target": "def jacobi(a, n):\n    if n <= 0:\n        raise ValueError(\"'n' must be a positive integer.\")\n    if n % 2 == 0:\n        raise ValueError(\"'n' must be odd.\")\n    a %= n\n    result = 1\n    while a != 0:\n        while a % 2 == 0:\n            a /= 2\n            n_mod_8 = n % 8\n            if n_mod_8 in (3, 5):\n                result = -result\n        a, n = n, a\n        if a % 4 == 3 and n % 4 == 3:\n            result = -result\n        a %= n\n    if n == 1:\n        return result\n    else:\n        return 0\n"}
{"id": 419554, "name": "Sattolo cycle", "source": "Translate Swift to Python: extension Array {\n  public mutating func satalloShuffle() {\n    for i in stride(from: index(before: endIndex), through: 1, by: -1) {\n      swapAt(i, .random(in: 0..<i))\n    }\n  }\n\n  public func satalloShuffled() -> [Element] {\n    var arr = Array(self)\n\n    arr.satalloShuffle()\n\n    return arr\n  }\n}\n\nlet testCases = [\n  [],\n  [10, 20],\n  [10, 20, 30],\n  [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n]\n\nfor testCase in testCases {\n  let shuffled = testCase.satalloShuffled()\n\n  guard zip(testCase, shuffled).allSatisfy(!=) else {\n    fatalError(\"satallo shuffle failed\")\n  }\n\n  print(\"\\(testCase) shuffled = \\(shuffled)\")\n}\n", "target": ">>> from random import randrange\n>>> def sattoloCycle(items):\n\tfor i in range(len(items) - 1, 0, -1):\n\t\tj = randrange(i)  \n\t\titems[j], items[i] = items[i], items[j]\n\n\t\t\n>>> \n>>> for _ in range(10):\n\tlst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\tsattoloCycle(lst)\n\tprint(lst)\n\n\t\n[5, 8, 1, 2, 6, 4, 3, 9, 10, 7]\n[5, 9, 8, 10, 4, 3, 6, 2, 1, 7]\n[10, 5, 8, 3, 9, 1, 4, 2, 6, 7]\n[10, 5, 2, 6, 9, 7, 8, 3, 1, 4]\n[7, 4, 8, 5, 10, 3, 2, 9, 1, 6]\n[2, 3, 10, 9, 4, 5, 8, 1, 7, 6]\n[5, 7, 4, 6, 2, 9, 3, 10, 8, 1]\n[3, 10, 7, 2, 9, 5, 8, 4, 1, 6]\n[2, 6, 5, 3, 9, 8, 10, 7, 1, 4]\n[3, 6, 2, 5, 10, 4, 1, 9, 7, 8]\n>>>\n"}
{"id": 419555, "name": "Sattolo cycle", "source": "Translate Swift to Python: extension Array {\n  public mutating func satalloShuffle() {\n    for i in stride(from: index(before: endIndex), through: 1, by: -1) {\n      swapAt(i, .random(in: 0..<i))\n    }\n  }\n\n  public func satalloShuffled() -> [Element] {\n    var arr = Array(self)\n\n    arr.satalloShuffle()\n\n    return arr\n  }\n}\n\nlet testCases = [\n  [],\n  [10, 20],\n  [10, 20, 30],\n  [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n]\n\nfor testCase in testCases {\n  let shuffled = testCase.satalloShuffled()\n\n  guard zip(testCase, shuffled).allSatisfy(!=) else {\n    fatalError(\"satallo shuffle failed\")\n  }\n\n  print(\"\\(testCase) shuffled = \\(shuffled)\")\n}\n", "target": ">>> from random import randrange\n>>> def sattoloCycle(items):\n\tfor i in range(len(items) - 1, 0, -1):\n\t\tj = randrange(i)  \n\t\titems[j], items[i] = items[i], items[j]\n\n\t\t\n>>> \n>>> for _ in range(10):\n\tlst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\tsattoloCycle(lst)\n\tprint(lst)\n\n\t\n[5, 8, 1, 2, 6, 4, 3, 9, 10, 7]\n[5, 9, 8, 10, 4, 3, 6, 2, 1, 7]\n[10, 5, 8, 3, 9, 1, 4, 2, 6, 7]\n[10, 5, 2, 6, 9, 7, 8, 3, 1, 4]\n[7, 4, 8, 5, 10, 3, 2, 9, 1, 6]\n[2, 3, 10, 9, 4, 5, 8, 1, 7, 6]\n[5, 7, 4, 6, 2, 9, 3, 10, 8, 1]\n[3, 10, 7, 2, 9, 5, 8, 4, 1, 6]\n[2, 6, 5, 3, 9, 8, 10, 7, 1, 4]\n[3, 6, 2, 5, 10, 4, 1, 9, 7, 8]\n>>>\n"}
{"id": 419556, "name": "Y combinator", "source": "Translate Swift to Python: struct RecursiveFunc<F> {\n  let o : RecursiveFunc<F> -> F\n}\n\nfunc Y<A, B>(f: (A -> B) -> A -> B) -> A -> B {\n  let r = RecursiveFunc<A -> B> { w in f { w.o(w)($0) } }\n  return r.o(r)\n}\n\nlet fac = Y { (f: Int -> Int) in\n  { $0 <= 1 ? 1 : $0 * f($0-1) }\n}\nlet fib = Y { (f: Int -> Int) in\n  { $0 <= 2 ? 1 : f($0-1)+f($0-2) }\n}\nprintln(\"fac(5) = \\(fac(5))\")\nprintln(\"fib(9) = \\(fib(9))\")\n", "target": ">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))\n>>> fac = lambda f: lambda n: (1 if n<2 else n*f(n-1))\n>>> [ Y(fac)(i) for i in range(10) ]\n[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\n>>> fib = lambda f: lambda n: 0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2))\n>>> [ Y(fib)(i) for i in range(10) ]\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n"}
{"id": 419557, "name": "Factorions", "source": "Translate Swift to Python: var fact = Array(repeating: 0, count: 12)\n\nfact[0] = 1\n\nfor n in 1..<12 {\n  fact[n] = fact[n - 1] * n\n}\n\nfor b in 9...12 {\n  print(\"The factorions for base \\(b) are:\")\n\n  for i in 1..<1500000 {\n    var sum = 0\n    var j = i\n\n    while j > 0 {\n      sum += fact[j % b]\n      j /= b\n    }\n\n    if sum == i {\n      print(\"\\(i)\", terminator: \" \")\n      fflush(stdout)\n    }\n  }\n\n  print(\"\\n\")\n}\n", "target": "fact = [1] \nfor n in range(1, 12):\n    fact.append(fact[n-1] * n)\n\nfor b in range(9, 12+1):\n    print(f\"The factorions for base {b} are:\")\n    for i in range(1, 1500000):\n        fact_sum = 0\n        j = i\n        while j > 0:\n            d = j % b\n            fact_sum += fact[d]\n            j = j//b\n        if fact_sum == i:\n            print(i, end=\" \")\n    print(\"\\n\")\n"}
{"id": 419558, "name": "Factorions", "source": "Translate Swift to Python: var fact = Array(repeating: 0, count: 12)\n\nfact[0] = 1\n\nfor n in 1..<12 {\n  fact[n] = fact[n - 1] * n\n}\n\nfor b in 9...12 {\n  print(\"The factorions for base \\(b) are:\")\n\n  for i in 1..<1500000 {\n    var sum = 0\n    var j = i\n\n    while j > 0 {\n      sum += fact[j % b]\n      j /= b\n    }\n\n    if sum == i {\n      print(\"\\(i)\", terminator: \" \")\n      fflush(stdout)\n    }\n  }\n\n  print(\"\\n\")\n}\n", "target": "fact = [1] \nfor n in range(1, 12):\n    fact.append(fact[n-1] * n)\n\nfor b in range(9, 12+1):\n    print(f\"The factorions for base {b} are:\")\n    for i in range(1, 1500000):\n        fact_sum = 0\n        j = i\n        while j > 0:\n            d = j % b\n            fact_sum += fact[d]\n            j = j//b\n        if fact_sum == i:\n            print(i, end=\" \")\n    print(\"\\n\")\n"}
{"id": 419559, "name": "Native shebang", "source": "Translate Swift to Python: #!/usr/bin/swift\n\nimport Foundation\n\nprint(Process.arguments[1..<Process.arguments.count].joinWithSeparator(\" \"))\n", "target": "\n\n\nimport sys\nprint \" \".join(sys.argv[1:])\n"}
{"id": 419560, "name": "Native shebang", "source": "Translate Swift to Python: #!/usr/bin/swift\n\nimport Foundation\n\nprint(Process.arguments[1..<Process.arguments.count].joinWithSeparator(\" \"))\n", "target": "\n\n\nimport sys\nprint \" \".join(sys.argv[1:])\n"}
{"id": 419561, "name": "Tau function", "source": "Translate Swift to Python: import Foundation\n\n\nfunc divisorCount(number: Int) -> Int {\n    var n = number\n    var total = 1\n    \n    while (n & 1) == 0 {\n        total += 1\n        n >>= 1\n    }\n    \n    var p = 3\n    while p * p <= n {\n        var count = 1\n        while n % p == 0 {\n            count += 1\n            n /= p\n        }\n        total *= count\n        p += 2\n    }\n    \n    if n > 1 {\n        total *= 2\n    }\n    return total\n}\n\nlet limit = 100\nprint(\"Count of divisors for the first \\(limit) positive integers:\")\nfor n in 1...limit {\n    print(String(format: \"%3d\", divisorCount(number: n)), terminator: \"\")\n    if n % 20 == 0 {\n        print()\n    }\n}\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef tau(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= 1 + k\n    return ans\n\nif __name__ == \"__main__\":\n    print(*map(tau, range(1, 101)))\n"}
{"id": 419562, "name": "Tau function", "source": "Translate Swift to Python: import Foundation\n\n\nfunc divisorCount(number: Int) -> Int {\n    var n = number\n    var total = 1\n    \n    while (n & 1) == 0 {\n        total += 1\n        n >>= 1\n    }\n    \n    var p = 3\n    while p * p <= n {\n        var count = 1\n        while n % p == 0 {\n            count += 1\n            n /= p\n        }\n        total *= count\n        p += 2\n    }\n    \n    if n > 1 {\n        total *= 2\n    }\n    return total\n}\n\nlet limit = 100\nprint(\"Count of divisors for the first \\(limit) positive integers:\")\nfor n in 1...limit {\n    print(String(format: \"%3d\", divisorCount(number: n)), terminator: \"\")\n    if n % 20 == 0 {\n        print()\n    }\n}\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef tau(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= 1 + k\n    return ans\n\nif __name__ == \"__main__\":\n    print(*map(tau, range(1, 101)))\n"}
{"id": 419563, "name": "Mertens function", "source": "Translate Swift to Python: import Foundation\n\nfunc mertensNumbers(max: Int) -> [Int] {\n    var mertens = Array(repeating: 1, count: max + 1)\n    for n in 2...max {\n        for k in 2...n {\n            mertens[n] -= mertens[n / k]\n        }\n    }\n    return mertens\n}\n\nlet max = 1000\nlet mertens = mertensNumbers(max: max)\n\nlet count = 200\nlet columns = 20\nprint(\"First \\(count - 1) Mertens numbers:\")\nfor i in 0..<count {\n    if i % columns > 0 {\n        print(\" \", terminator: \"\")\n    }\n    print(i == 0 ? \"  \" : String(format: \"%2d\", mertens[i]), terminator: \"\")\n    if (i + 1) % columns == 0 {\n        print()\n    }\n}\n\nvar zero = 0, cross = 0, previous = 0\nfor i in 1...max {\n    let m = mertens[i]\n    if m == 0 {\n        zero += 1\n        if previous != 0 {\n            cross += 1\n        }\n    }\n    previous = m\n}\nprint(\"M(n) is zero \\(zero) times for 1 <= n <= \\(max).\")\nprint(\"M(n) crosses zero \\(cross) times for 1 <= n <= \\(max).\")\n", "target": "def mertens(count):\n    \n    m = [None, 1]\n    for n in range(2, count+1):\n        m.append(1)\n        for k in range(2, n+1):\n            m[n] -= m[n//k]\n    return m\n    \n\nms = mertens(1000)\n\nprint(\"The first 99 Mertens numbers are:\")\nprint(\"  \", end=' ')\ncol = 1\nfor n in ms[1:100]:\n    print(\"{:2d}\".format(n), end=' ')\n    col += 1\n    if col == 10:\n        print()\n        col = 0\n        \nzeroes = sum(x==0 for x in ms)\ncrosses = sum(a!=0 and b==0 for a,b in zip(ms, ms[1:]))\nprint(\"M(N) equals zero {} times.\".format(zeroes))\nprint(\"M(N) crosses zero {} times.\".format(crosses))\n"}
{"id": 419564, "name": "Playing cards", "source": "Translate Swift to Python: struct Card: CustomStringConvertible\n{\n\tenum Suit: String, CaseIterable, CustomStringConvertible\n\t{\n\t\tcase clubs = \"\u2663\ufe0f\"\n\t\tcase diamonds = \"\u2666\ufe0f\"\n\t\tcase hearts = \"\u2665\ufe0f\"\n\t\tcase spades = \"\u2660\ufe0f\"\n\n\t\tvar description: String { rawValue }\n\t}\n\n\tlet suit: Suit\n\tlet value: Int\n\n\tvar description: String\n\t{\n\t\tlet valueAsString: String\n\t\tswitch value\n\t\t{\n\t\tcase 1:\n\t\t\tvalueAsString = \"A\"\n\t\tcase 11:\n\t\t\tvalueAsString = \"J\"\n\t\tcase 12:\n\t\t\tvalueAsString = \"Q\"\n\t\tcase 13:\n\t\t\tvalueAsString = \"K\"\n\t\tdefault:\n\t\t\tvalueAsString = \"\\(value)\"\n\t\t}\n\t\treturn valueAsString + suit.description\n\t}\n}\n\nstruct Deck: CustomStringConvertible\n{\n\tvar cards: [Card] = []\n\n\tinit()\n\t{\n\t\tfor suit in Card.Suit.allCases\n\t\t{\n\t\t\tfor faceValue in 1 ... 13\n\t\t\t{\n\t\t\t\tcards.append(Card(suit: suit, value: faceValue))\n\t\t\t}\n\t\t}\n\t}\n\n\tvar description: String\n\t{\n\t\tString(cards.map{ $0.description }.joined(separator: \", \"))\n\t}\n\n\tmutating func shuffle()\n\t{\n\t\tcards.shuffle()\n\t}\n\n\tmutating func dealCard() -> Card?\n\t{\n\t\tguard !cards.isEmpty else { return nil }\n\t\treturn cards.removeLast()\n\t}\n}\n\nvar deck = Deck()\nprint(\"New deck:\")\nprint(deck)\ndeck.shuffle()\nprint(\"Shuffled deck:\")\nprint(deck)\n\nvar hands: [[Card]] = [[], [], [], []]\n\nvar handIndex = 0\n\nwhile let card = deck.dealCard()\n{\n\thands[handIndex].append(card)\n\thandIndex = (handIndex + 1) % hands.count\n}\n\nprint (\"Hands:\")\nprint(hands.map({ $0.description }).joined(separator: \"\\n\"))\nprint(\"Remaining deck (should be empty):\")\nprint(deck)\n", "target": "import random\n\nclass Card(object):\n    suits = (\"Clubs\",\"Hearts\",\"Spades\",\"Diamonds\")\n    pips = (\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"Jack\",\"Queen\",\"King\",\"Ace\")\n\n    def __init__(self, pip,suit):\n        self.pip=pip\n        self.suit=suit\n\n    def __str__(self):\n        return \"%s %s\"%(self.pip,self.suit)\n\nclass Deck(object):\n    def __init__(self):\n        self.deck = [Card(pip,suit) for suit in Card.suits for pip in Card.pips]\n\n    def __str__(self):\n        return \"[%s]\"%\", \".join( (str(card) for card in self.deck))\n\n    def shuffle(self):\n        random.shuffle(self.deck)\n\n    def deal(self):\n        self.shuffle()  \n        return self.deck.pop(0)\n"}
{"id": 419565, "name": "Perfect totient numbers", "source": "Translate Swift to Python: public func totient(n: Int) -> Int {\n  var n = n\n  var i = 2\n  var tot = n\n\n  while i * i <= n {\n    if n % i == 0 {\n      while n % i == 0 {\n        n /= i\n      }\n\n      tot -= tot / i\n    }\n\n    if i == 2 {\n      i = 1\n    }\n\n    i += 2\n  }\n\n  if n > 1 {\n    tot -= tot / n\n  }\n\n  return tot\n}\n\npublic struct PerfectTotients: Sequence, IteratorProtocol {\n  private var m = 1\n\n  public init() { }\n\n  public mutating func next() -> Int? {\n    while true {\n      defer {\n        m += 1\n      }\n\n      var tot = m\n      var sum = 0\n\n      while tot != 1 {\n        tot = totient(n: tot)\n        sum += tot\n      }\n\n      if sum == m {\n        return m\n      }\n    }\n  }\n}\n\nprint(\"The first 20 perfect totient numbers are:\")\nprint(Array(PerfectTotients().prefix(20)))\n", "target": "from math import gcd\nfrom functools import lru_cache\nfrom itertools import islice, count\n\n@lru_cache(maxsize=None)\ndef  \u03c6(n):\n    return sum(1 for k in range(1, n + 1) if gcd(n, k) == 1)\n\ndef perfect_totient():\n    for n0 in count(1):\n        parts, n = 0, n0\n        while n != 1:\n            n = \u03c6(n)\n            parts += n\n        if parts == n0:\n            yield n0\n        \n\nif __name__ == '__main__':\n    print(list(islice(perfect_totient(), 20)))\n"}
{"id": 419566, "name": "Perfect totient numbers", "source": "Translate Swift to Python: public func totient(n: Int) -> Int {\n  var n = n\n  var i = 2\n  var tot = n\n\n  while i * i <= n {\n    if n % i == 0 {\n      while n % i == 0 {\n        n /= i\n      }\n\n      tot -= tot / i\n    }\n\n    if i == 2 {\n      i = 1\n    }\n\n    i += 2\n  }\n\n  if n > 1 {\n    tot -= tot / n\n  }\n\n  return tot\n}\n\npublic struct PerfectTotients: Sequence, IteratorProtocol {\n  private var m = 1\n\n  public init() { }\n\n  public mutating func next() -> Int? {\n    while true {\n      defer {\n        m += 1\n      }\n\n      var tot = m\n      var sum = 0\n\n      while tot != 1 {\n        tot = totient(n: tot)\n        sum += tot\n      }\n\n      if sum == m {\n        return m\n      }\n    }\n  }\n}\n\nprint(\"The first 20 perfect totient numbers are:\")\nprint(Array(PerfectTotients().prefix(20)))\n", "target": "from math import gcd\nfrom functools import lru_cache\nfrom itertools import islice, count\n\n@lru_cache(maxsize=None)\ndef  \u03c6(n):\n    return sum(1 for k in range(1, n + 1) if gcd(n, k) == 1)\n\ndef perfect_totient():\n    for n0 in count(1):\n        parts, n = 0, n0\n        while n != 1:\n            n = \u03c6(n)\n            parts += n\n        if parts == n0:\n            yield n0\n        \n\nif __name__ == '__main__':\n    print(list(islice(perfect_totient(), 20)))\n"}
{"id": 419567, "name": "Lah numbers", "source": "Translate Swift to Python: import BigInt\nimport Foundation\n\n@inlinable\npublic func factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\n@inlinable\npublic func lah<T: BinaryInteger>(n: T, k: T) -> T {\n  if k == 1 {\n    return factorial(n)\n  } else if k == n {\n    return 1\n  } else if k > n {\n    return 0\n  } else if k < 1 || n < 1 {\n    return 0\n  } else {\n    let a = (factorial(n) * factorial(n - 1))\n    let b = (factorial(k) * factorial(k - 1))\n    let c = factorial(n - k)\n\n    return a / b / c\n  }\n}\n\nprint(\"Unsigned Lah numbers: L(n, k):\")\nprint(\"n\\\\k\", terminator: \"\")\n\nfor i in 0...12 {\n  print(String(format: \"%10d\", i), terminator: \" \")\n}\n\nprint()\n\nfor row in 0...12 {\n  print(String(format: \"%-2d\", row), terminator: \"\")\n\n  for i in 0...row {\n    lah(n: BigInt(row), k: BigInt(i)).description.withCString {str in\n      print(String(format: \"%11s\", str), terminator: \"\")\n    }\n  }\n\n  print()\n}\n\nlet maxLah = (0...100).map({ lah(n: BigInt(100), k: BigInt($0)) }).max()!\n\nprint(\"Maximum value from the L(100, *) row: \\(maxLah)\")\n", "target": "from math import (comb,\n                  factorial)\n\n\ndef lah(n, k):\n    if k == 1:\n        return factorial(n)\n    if k == n:\n        return 1\n    if k > n:\n        return 0\n    if k < 1 or n < 1:\n        return 0\n    return comb(n, k) * factorial(n - 1) // factorial(k - 1)\n\n\ndef main():\n    print(\"Unsigned Lah numbers: L(n, k):\")\n    print(\"n/k \", end='\\t')\n    for i in range(13):\n        print(\"%11d\" % i, end='\\t')\n    print()\n    for row in range(13):\n        print(\"%-4d\" % row, end='\\t')\n        for i in range(row + 1):\n            l = lah(row, i)\n            print(\"%11d\" % l, end='\\t')\n        print()\n    print(\"\\nMaximum value from the L(100, *) row:\")\n    max_val = max(lah(100, a) for a in range(100))\n    print(max_val)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 419568, "name": "Lah numbers", "source": "Translate Swift to Python: import BigInt\nimport Foundation\n\n@inlinable\npublic func factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\n@inlinable\npublic func lah<T: BinaryInteger>(n: T, k: T) -> T {\n  if k == 1 {\n    return factorial(n)\n  } else if k == n {\n    return 1\n  } else if k > n {\n    return 0\n  } else if k < 1 || n < 1 {\n    return 0\n  } else {\n    let a = (factorial(n) * factorial(n - 1))\n    let b = (factorial(k) * factorial(k - 1))\n    let c = factorial(n - k)\n\n    return a / b / c\n  }\n}\n\nprint(\"Unsigned Lah numbers: L(n, k):\")\nprint(\"n\\\\k\", terminator: \"\")\n\nfor i in 0...12 {\n  print(String(format: \"%10d\", i), terminator: \" \")\n}\n\nprint()\n\nfor row in 0...12 {\n  print(String(format: \"%-2d\", row), terminator: \"\")\n\n  for i in 0...row {\n    lah(n: BigInt(row), k: BigInt(i)).description.withCString {str in\n      print(String(format: \"%11s\", str), terminator: \"\")\n    }\n  }\n\n  print()\n}\n\nlet maxLah = (0...100).map({ lah(n: BigInt(100), k: BigInt($0)) }).max()!\n\nprint(\"Maximum value from the L(100, *) row: \\(maxLah)\")\n", "target": "from math import (comb,\n                  factorial)\n\n\ndef lah(n, k):\n    if k == 1:\n        return factorial(n)\n    if k == n:\n        return 1\n    if k > n:\n        return 0\n    if k < 1 or n < 1:\n        return 0\n    return comb(n, k) * factorial(n - 1) // factorial(k - 1)\n\n\ndef main():\n    print(\"Unsigned Lah numbers: L(n, k):\")\n    print(\"n/k \", end='\\t')\n    for i in range(13):\n        print(\"%11d\" % i, end='\\t')\n    print()\n    for row in range(13):\n        print(\"%-4d\" % row, end='\\t')\n        for i in range(row + 1):\n            l = lah(row, i)\n            print(\"%11d\" % l, end='\\t')\n        print()\n    print(\"\\nMaximum value from the L(100, *) row:\")\n    max_val = max(lah(100, a) for a in range(100))\n    print(max_val)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 419569, "name": "Sorting algorithms_Cocktail sort with shifting bounds", "source": "Translate Swift to Python: func cocktailShakerSort<T: Comparable>(_ a: inout [T]) {\n    var begin = 0\n    var end = a.count\n    if end == 0 {\n        return\n    }\n    end -= 1\n    while begin < end {\n        var new_begin = end\n        var new_end = begin\n        var i = begin\n        while i < end {\n            if a[i + 1] < a[i] {\n                a.swapAt(i, i + 1)\n                new_end = i\n            }\n            i += 1\n        }\n        end = new_end\n        i = end\n        while i > begin {\n            if a[i] < a[i - 1] {\n                a.swapAt(i, i - 1)\n                new_begin = i\n            }\n            i -= 1\n        }\n        begin = new_begin\n    }\n}\n\nvar array = [5, 1, -6, 12, 3, 13, 2, 4, 0, 15]\nprint(\"before: \\(array)\")\ncocktailShakerSort(&array)\nprint(\" after: \\(array)\")\n\nvar array2 = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\"]\nprint(\"before: \\(array2)\")\ncocktailShakerSort(&array2)\nprint(\" after: \\(array2)\")\n", "target": "\n            \ndef cocktailshiftingbounds(A):\n    beginIdx = 0\n    endIdx = len(A) - 1\n    \n    while beginIdx <= endIdx:\n        newBeginIdx = endIdx\n        newEndIdx = beginIdx\n        for ii in range(beginIdx,endIdx):\n            if A[ii] > A[ii + 1]:\n                A[ii+1], A[ii] = A[ii], A[ii+1]\n                newEndIdx = ii\n                \n        endIdx = newEndIdx\n    \n        for ii in range(endIdx,beginIdx-1,-1):\n            if A[ii] > A[ii + 1]:\n                A[ii+1], A[ii] = A[ii], A[ii+1]\n                newBeginIdx = ii\n        \n        beginIdx = newBeginIdx + 1\n            \ntest1 = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]\ncocktailshiftingbounds(test1)\nprint(test1)\n \ntest2=list('big fjords vex quick waltz nymph')\ncocktailshiftingbounds(test2)\nprint(''.join(test2))\n"}
{"id": 419570, "name": "Unprimeable numbers", "source": "Translate Swift to Python: import Foundation\n\nclass BitArray {\n    var array: [UInt32]\n\n    init(size: Int) {\n        array = Array(repeating: 0, count: (size + 31)/32)\n    }\n    \n    func get(index: Int) -> Bool {\n        let bit = UInt32(1) << (index & 31)\n        return (array[index >> 5] & bit) != 0\n    }\n    \n    func set(index: Int, value: Bool) {\n        let bit = UInt32(1) << (index & 31)\n        if value {\n            array[index >> 5] |= bit\n        } else {\n            array[index >> 5] &= ~bit\n        }\n    }\n}\n\nclass PrimeSieve {\n    let composite: BitArray\n    \n    init(size: Int) {\n        composite = BitArray(size: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite.get(index: p/2 - 1) {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite.set(index: q/2 - 1, value: true)\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite.get(index: number/2 - 1)\n    }\n}\n\n\nfunc countDigits(number: Int) -> Int {\n    var digits = 0\n    var n = number\n    while n > 0 {\n        n /= 10\n        digits += 1\n    }\n    return digits\n}\n\n\nfunc changeDigit(number: Int, index: Int, digit: Int) -> Int {\n    var p = 1\n    var changed = 0\n    var n = number\n    var i = index\n    while i > 0 {\n        changed += p * (n % 10)\n        p *= 10\n        n /= 10\n        i -= 1\n    }\n    changed += (10 * (n / 10) + digit) * p\n    return changed\n}\n\nfunc unprimeable(sieve: PrimeSieve, number: Int) -> Bool {\n    if sieve.isPrime(number: number) {\n        return false\n    }\n    for i in 0..<countDigits(number: number) {\n        for j in 0..<10 {\n            let n = changeDigit(number: number, index: i, digit: j)\n            if n != number && sieve.isPrime(number: n) {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nvar count = 0\nvar n = 100\nvar lowest = Array(repeating: 0, count: 10)\nvar found = 0\nlet sieve = PrimeSieve(size: 10000000)\nprint(\"First 35 unprimeable numbers:\")\nwhile count < 600 || found < 10 {\n    if unprimeable(sieve: sieve, number: n) {\n        if count < 35 {\n            if count > 0 {\n                print(\", \", terminator: \"\")\n            }\n            print(n, terminator: \"\")\n        }\n        count += 1\n        if count == 600 {\n            print(\"\\n600th unprimeable number: \\(n)\")\n        }\n        let lastDigit = n % 10\n        if lowest[lastDigit] == 0 {\n            lowest[lastDigit] = n\n            found += 1\n        }\n    }\n    n += 1\n}\nfor i in 0..<10 {\n    let number = NSNumber(value: lowest[i])\n    let str = NumberFormatter.localizedString(from: number, number: .decimal)\n    print(\"Least unprimeable number ending in \\(i): \\(str)\")\n}\n", "target": "from itertools import count, islice\n\ndef primes(_cache=[2, 3]):\n    yield from _cache\n    for n in count(_cache[-1]+2, 2):\n        if isprime(n):\n            _cache.append(n)\n            yield n\n\ndef isprime(n, _seen={0: False, 1: False}):\n    def _isprime(n):\n        for p in primes():\n            if p*p > n:\n                return True\n            if n%p == 0:\n                return False\n\n    if n not in _seen:\n        _seen[n] = _isprime(n)\n    return _seen[n]\n\ndef unprime():\n    for a in count(1):\n        d = 1\n        while d <= a:\n            base = (a//(d*10))*(d*10) + (a%d) \n            if any(isprime(y) for y in range(base, base + d*10, d)):\n                break\n            d *= 10\n        else:\n            yield a\n\n\nprint('First 35:')\nprint(' '.join(str(i) for i in islice(unprime(), 35)))\n\nprint('\\nThe 600-th:')\nprint(list(islice(unprime(), 599, 600))[0])\nprint()\n\nfirst, need = [False]*10, 10\nfor p in unprime():\n    i = p%10\n    if first[i]: continue\n\n    first[i] = p\n    need -= 1\n    if not need:\n        break\n\nfor i,v in enumerate(first):\n    print(f'{i} ending: {v}')\n"}
{"id": 419571, "name": "Tau number", "source": "Translate Swift to Python: import Foundation\n\n\nfunc divisorCount(number: Int) -> Int {\n    var n = number\n    var total = 1\n    \n    while (n & 1) == 0 {\n        total += 1\n        n >>= 1\n    }\n    \n    var p = 3\n    while p * p <= n {\n        var count = 1\n        while n % p == 0 {\n            count += 1\n            n /= p\n        }\n        total *= count\n        p += 2\n    }\n    \n    if n > 1 {\n        total *= 2\n    }\n    return total\n}\n\nlet limit = 100\nprint(\"The first \\(limit) tau numbers are:\")\nvar count = 0\nvar n = 1\nwhile count < limit {\n    if n % divisorCount(number: n) == 0 {\n        print(String(format: \"%5d\", n), terminator: \"\")\n        count += 1\n        if count % 10 == 0 {\n            print()\n        }\n    }\n    n += 1\n}\n", "target": "def tau(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans, i, j = 0, 1, 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans += 1\n            j = n//i\n            if j != i:\n                ans += 1\n        i += 1\n    return ans\n\ndef is_tau_number(n):\n    assert(isinstance(n, int))\n    if n <= 0:\n        return False\n    return 0 == n%tau(n)\n\nif __name__ == \"__main__\":\n    n = 1\n    ans = []\n    while len(ans) < 100:\n        if is_tau_number(n):\n            ans.append(n)\n        n += 1\n    print(ans)\n"}
{"id": 419572, "name": "Modulinos", "source": "Translate Swift to Python: import Foundation\n\npublic class ScriptedMain {\n  public var meaningOfLife = 42\n\n  public init() {}\n\n  public class func main() {\n    var meaning = ScriptedMain().meaningOfLife\n\n    println(\"Main: The meaning of life is \\(meaning)\")\n  }\n}\n\n#if SCRIPTEDMAIN\n@objc class ScriptedMainAutoload {\n  @objc class func load() {\n    ScriptedMain.main()\n  }\n}\n#endif\n", "target": "\n\n\n\ndef meaning_of_life():\n  return 42\n\nif __name__ == \"__main__\":\n  print(\"Main: The meaning of life is %s\" % meaning_of_life())\n"}
{"id": 419573, "name": "Modulinos", "source": "Translate Swift to Python: import Foundation\n\npublic class ScriptedMain {\n  public var meaningOfLife = 42\n\n  public init() {}\n\n  public class func main() {\n    var meaning = ScriptedMain().meaningOfLife\n\n    println(\"Main: The meaning of life is \\(meaning)\")\n  }\n}\n\n#if SCRIPTEDMAIN\n@objc class ScriptedMainAutoload {\n  @objc class func load() {\n    ScriptedMain.main()\n  }\n}\n#endif\n", "target": "\n\n\n\ndef meaning_of_life():\n  return 42\n\nif __name__ == \"__main__\":\n  print(\"Main: The meaning of life is %s\" % meaning_of_life())\n"}
{"id": 419574, "name": "Find the last Sunday of each month", "source": "Translate Swift to Python: import Foundation\n\nfunc lastSundays(of year: Int) -> [Date] {\n\t\n\tlet calendar = Calendar.current\n\tvar dates = [Date]()\n\t\n\tfor month in 1...12 {\n\t\t\n\t\tvar dateComponents = DateComponents(calendar: calendar,\n\t\t                                    year: year,\n\t\t                                    month: month + 1,\n\t\t                                    day: 0,\n\t\t                                    hour: 12)\n\t\t\n\t\tlet date = calendar.date(from: dateComponents)!\n\t\tlet weekday = calendar.component(.weekday, from: date)\n\n\t\tif weekday != 1 {\n\t\t\tdateComponents.day! -= weekday - 1\n\t\t}\n\t\t\n\t\tdates.append(calendar.date(from: dateComponents)!)\n\t}\n\treturn dates\n}\n\nvar dateFormatter = DateFormatter()\ndateFormatter.dateStyle = .short\n\nprint(lastSundays(of: 2013).map(dateFormatter.string).joined(separator: \"\\n\"))\n", "target": "import sys\nimport calendar\n\nyear = 2013\nif len(sys.argv) > 1:\n    try:\n        year = int(sys.argv[-1])\n    except ValueError:\n        pass\n\nfor month in range(1, 13):\n    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))\n    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday))\n"}
{"id": 419575, "name": "Find the last Sunday of each month", "source": "Translate Swift to Python: import Foundation\n\nfunc lastSundays(of year: Int) -> [Date] {\n\t\n\tlet calendar = Calendar.current\n\tvar dates = [Date]()\n\t\n\tfor month in 1...12 {\n\t\t\n\t\tvar dateComponents = DateComponents(calendar: calendar,\n\t\t                                    year: year,\n\t\t                                    month: month + 1,\n\t\t                                    day: 0,\n\t\t                                    hour: 12)\n\t\t\n\t\tlet date = calendar.date(from: dateComponents)!\n\t\tlet weekday = calendar.component(.weekday, from: date)\n\n\t\tif weekday != 1 {\n\t\t\tdateComponents.day! -= weekday - 1\n\t\t}\n\t\t\n\t\tdates.append(calendar.date(from: dateComponents)!)\n\t}\n\treturn dates\n}\n\nvar dateFormatter = DateFormatter()\ndateFormatter.dateStyle = .short\n\nprint(lastSundays(of: 2013).map(dateFormatter.string).joined(separator: \"\\n\"))\n", "target": "import sys\nimport calendar\n\nyear = 2013\nif len(sys.argv) > 1:\n    try:\n        year = int(sys.argv[-1])\n    except ValueError:\n        pass\n\nfor month in range(1, 13):\n    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))\n    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday))\n"}
{"id": 419576, "name": "Teacup rim text", "source": "Translate Swift to Python: import Foundation\n\nfunc loadDictionary(_ path: String) throws -> Set<String> {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return Set<String>(contents.components(separatedBy: \"\\n\").filter{!$0.isEmpty})\n}\n\nfunc rotate<T>(_ array: inout [T]) {\n    guard array.count > 1 else {\n        return\n    }\n    let first = array[0]\n    array.replaceSubrange(0..<array.count-1, with: array[1...])\n    array[array.count - 1] = first\n}\n\nfunc findTeacupWords(_ dictionary: Set<String>) {\n    var teacupWords: [String] = []\n    var found = Set<String>()\n    for word in dictionary {\n        if word.count < 3 || found.contains(word) {\n            continue\n        }\n        teacupWords.removeAll()\n        var isTeacupWord = true\n        var chars = Array(word)\n        for _ in 1..<word.count {\n            rotate(&chars)\n            let w = String(chars)\n            if (!dictionary.contains(w)) {\n                isTeacupWord = false\n                break\n            }\n            if w != word && !teacupWords.contains(w) {\n                teacupWords.append(w)\n            }\n        }\n        if !isTeacupWord || teacupWords.isEmpty {\n            continue\n        }\n        print(word, terminator: \"\")\n        found.insert(word)\n        for w in teacupWords {\n            found.insert(w)\n            print(\" \\(w)\", terminator: \"\")\n        }\n        print()\n    }\n}\n\ndo {\n    let dictionary = try loadDictionary(\"unixdict.txt\")\n    findTeacupWords(dictionary)\n} catch {\n    print(error)\n}\n", "target": "\n\nfrom itertools import chain, groupby\nfrom os.path import expanduser\nfrom functools import reduce\n\n\n\ndef main():\n    \n    print('\\n'.join(\n        concatMap(circularGroup)(\n            anagrams(3)(\n                \n                lines(readFile('~/mitWords.txt'))\n            )\n        )\n    ))\n\n\n\ndef anagrams(n):\n    \n    def go(ws):\n        def f(xs):\n            return [\n                [snd(x) for x in xs]\n            ] if n <= len(xs) >= len(xs[0][0]) else []\n        return concatMap(f)(groupBy(fst)(sorted(\n            [(''.join(sorted(w)), w) for w in ws],\n            key=fst\n        )))\n    return go\n\n\n\ndef circularGroup(ws):\n    \n    lex = set(ws)\n    iLast = len(ws) - 1\n    \n    \n    (i, blnCircular) = until(\n        lambda tpl: tpl[1] or (tpl[0] > iLast)\n    )(\n        lambda tpl: (1 + tpl[0], isCircular(lex)(ws[tpl[0]]))\n    )(\n        (0, False)\n    )\n    return [' -> '.join(allRotations(ws[i]))] if blnCircular else []\n\n\n\ndef isCircular(lexicon):\n    \n    def go(w):\n        def f(tpl):\n            (i, _, x) = tpl\n            return (1 + i, x in lexicon, rotated(x))\n\n        iLast = len(w) - 1\n        return until(\n            lambda tpl: iLast < tpl[0] or (not tpl[1])\n        )(f)(\n            (0, True, rotated(w))\n        )[1]\n    return go\n\n\n\ndef allRotations(w):\n    \n    return takeIterate(len(w) - 1)(\n        rotated\n    )(w)\n\n\n\n\n\ndef concatMap(f):\n    \n    def go(xs):\n        return chain.from_iterable(map(f, xs))\n    return go\n\n\n\ndef fst(tpl):\n    \n    return tpl[0]\n\n\n\ndef groupBy(f):\n    \n    def go(xs):\n        return [\n            list(x[1]) for x in groupby(xs, key=f)\n        ]\n    return go\n\n\n\ndef lines(s):\n    \n    return s.splitlines()\n\n\n\ndef mapAccumL(f):\n    \n    def go(a, x):\n        tpl = f(a[0], x)\n        return (tpl[0], a[1] + [tpl[1]])\n    return lambda acc: lambda xs: (\n        reduce(go, xs, (acc, []))\n    )\n\n\n\ndef readFile(fp):\n    \n    with open(expanduser(fp), 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\ndef rotated(s):\n    \n    return s[1:] + s[0]\n\n\n\ndef snd(tpl):\n    \n    return tpl[1]\n\n\n\ndef takeIterate(n):\n    \n    def go(f):\n        def g(x):\n            def h(a, i):\n                v = f(a) if i else x\n                return (v, v)\n            return mapAccumL(h)(x)(\n                range(0, 1 + n)\n            )[1]\n        return g\n    return go\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 419577, "name": "Esthetic numbers", "source": "Translate Swift to Python: extension Sequence {\n  func take(_ n: Int) -> [Element] {\n    var res = [Element]()\n\n    for el in self {\n      guard res.count != n else {\n        return res\n      }\n\n      res.append(el)\n    }\n\n    return res\n  }\n}\n\nextension String {\n  func isEsthetic(base: Int = 10) -> Bool {\n    zip(dropFirst(0), dropFirst())\n      .lazy\n      .allSatisfy({ abs(Int(String($0.0), radix: base)! - Int(String($0.1), radix: base)!) == 1 })\n  }\n}\n\nfunc getEsthetics(from: Int, to: Int, base: Int = 10) -> [String] {\n  guard base >= 2, to >= from else {\n    return []\n  }\n\n  var start = \"\"\n  var end = \"\"\n\n  repeat {\n    if start.count & 1 == 1 {\n      start += \"0\"\n    } else {\n      start += \"1\"\n    }\n  } while Int(start, radix: base)! < from\n\n  let digiMax = String(base - 1, radix: base)\n  let lessThanDigiMax = String(base - 2, radix: base)\n  var count = 0\n\n  repeat {\n    if count != base - 1 {\n      end += String(count + 1, radix: base)\n      count += 1\n    } else {\n      if String(end.last!) == digiMax {\n        end += lessThanDigiMax\n      } else {\n        end += digiMax\n      }\n    }\n  } while Int(end, radix: base)! < to\n\n  if Int(start, radix: base)! >= Int(end, radix: base)! {\n    return []\n  }\n\n  var esthetics = [Int]()\n\n  func shimmer(_ n: Int, _ m: Int, _ i: Int) {\n    if (n...m).contains(i) {\n      esthetics.append(i)\n    } else if i == 0 || i > m {\n      return\n    }\n\n    let d = i % base\n    let i1 = i &* base &+ d &- 1\n    let i2 = i1 &+ 2\n\n    if (i1 < i || i2 < i) {\n      \n      return\n    }\n\n    switch d {\n    case 0: shimmer(n, m, i2)\n    case base-1: shimmer(n, m, i1)\n    case _:\n      shimmer(n, m, i1)\n      shimmer(n, m, i2)\n    }\n  }\n\n  for digit in 0..<base {\n    shimmer(Int(start, radix: base)!, Int(end, radix: base)!, digit)\n  }\n\n  return esthetics.filter({ $0 <= to }).map({ String($0, radix: base) })\n}\n\nfor base in 2...16 {\n  let esthetics = (0...)\n    .lazy\n    .map({ String($0, radix: base) })\n    .filter({ $0.isEsthetic(base: base) })\n    .dropFirst(base * 4)\n    .take((base * 6) - (base * 4) + 1)\n\n  print(\"Base \\(base) esthetics from \\(base * 4) to \\(base * 6)\")\n  print(esthetics)\n  print()\n}\n\nlet base10Esthetics = (1000...9999).filter({ String($0).isEsthetic() })\n\nprint(\"\\(base10Esthetics.count) esthetics between 1000 and 9999:\")\nprint(base10Esthetics)\nprint()\n\nfunc printSlice(of array: [String]) {\n  print(array.take(5))\n  print(\"...\")\n  print(Array(array.lazy.reversed().take(5).reversed()))\n  print(\"\\(array.count) total\\n\")\n}\n\nprint(\"Esthetics between \\(Int(1e8)) and \\(13 * Int(1e7)):\")\nprintSlice(of: getEsthetics(from: Int(1e8), to: 13 * Int(1e7)))\n\nprint(\"Esthetics between \\(Int(1e11)) and \\(13 * Int(1e10))\")\nprintSlice(of: getEsthetics(from: Int(1e11), to: 13 * Int(1e10)))\n\nprint(\"Esthetics between \\(Int(1e14)) and \\(13 * Int(1e13)):\")\nprintSlice(of: getEsthetics(from: Int(1e14), to: 13 * Int(1e13)))\n\nprint(\"Esthetics between \\(Int(1e17)) and \\(13 * Int(1e16)):\")\nprintSlice(of: getEsthetics(from: Int(1e17), to: 13 * Int(1e16)))\n", "target": "from collections import deque\nfrom itertools import dropwhile, islice, takewhile\nfrom textwrap import wrap\nfrom typing import Iterable, Iterator\n\n\nDigits = str  \n\n\ndef esthetic_nums(base: int) -> Iterator[int]:\n    \n    queue: deque[tuple[int, int]] = deque()\n    queue.extendleft((d, d) for d in range(1, base))\n    while True:\n        num, lsd = queue.pop()\n        yield num\n        new_lsds = (d for d in (lsd - 1, lsd + 1) if 0 <= d < base)\n        num *= base  \n        queue.extendleft((num + d, d) for d in new_lsds)\n\n\ndef to_digits(num: int, base: int) -> Digits:\n    \n    digits: list[str] = []\n    while num:\n        num, d = divmod(num, base)\n        digits.append(\"0123456789abcdef\"[d])\n    return \"\".join(reversed(digits)) if digits else \"0\"\n\n\ndef pprint_it(it: Iterable[str], indent: int = 4, width: int = 80) -> None:\n    \n    joined = \", \".join(it)\n    lines = wrap(joined, width=width - indent)\n    for line in lines:\n        print(f\"{indent*' '}{line}\")\n    print()\n\n\ndef task_2() -> None:\n    nums: Iterator[int]\n    for base in range(2, 16 + 1):\n        start, stop = 4 * base, 6 * base\n        nums = esthetic_nums(base)\n        nums = islice(nums, start - 1, stop)  \n        print(\n            f\"Base-{base} esthetic numbers from \"\n            f\"index {start} through index {stop} inclusive:\\n\"\n        )\n        pprint_it(to_digits(num, base) for num in nums)\n\n\ndef task_3(lower: int, upper: int, base: int = 10) -> None:\n    nums: Iterator[int] = esthetic_nums(base)\n    nums = dropwhile(lambda num: num < lower, nums)\n    nums = takewhile(lambda num: num <= upper, nums)\n    print(\n        f\"Base-{base} esthetic numbers with \"\n        f\"magnitude between {lower:,} and {upper:,}:\\n\"\n    )\n    pprint_it(to_digits(num, base) for num in nums)\n\n\nif __name__ == \"__main__\":\n    print(\"======\\nTask 2\\n======\\n\")\n    task_2()\n\n    print(\"======\\nTask 3\\n======\\n\")\n    task_3(1_000, 9_999)\n\n    print(\"======\\nTask 4\\n======\\n\")\n    task_3(100_000_000, 130_000_000)\n"}
{"id": 419578, "name": "Unicode strings", "source": "Translate Swift to Python: let flag = \"\ud83c\uddf5\ud83c\uddf7\"\nprint(flag.characters.count)\n\nprint(flag.unicodeScalars.count)\n\nprint(flag.utf16.count)\n\nprint(flag.utf8.count)\n\n\nlet nfc = \"\\u{01FA}\"\nlet nfd = \"\\u{0041}\\u{030A}\\u{0301}\"\nlet nfkx = \"\\u{FF21}\\u{030A}\\u{0301}\"\nprint(nfc == nfd) \nprint(nfc == nfkx) \n", "target": "\n\n\nu = 'abcd\u00e9'\nprint(ord(u[-1]))\n"}
{"id": 419579, "name": "Permutations by swapping", "source": "Translate Swift to Python: \n\nfunc generate<T>(array: inout [T], output: (_: [T], _: Int) -> Void) {\n    let n = array.count\n    var c = Array(repeating: 0, count: n)\n    var i = 1\n    var sign = 1\n    output(array, sign)\n    while i < n {\n        if c[i] < i {\n            if (i & 1) == 0 {\n                array.swapAt(0, i)\n            } else {\n                array.swapAt(c[i], i)\n            }\n            sign = -sign\n            output(array, sign)\n            c[i] += 1\n            i = 1\n        } else {\n            c[i] = 0\n            i += 1\n        }\n    }\n}\n\nfunc printPermutation<T>(array: [T], sign: Int) {\n    print(\"\\(array) \\(sign)\")\n}\n\nprint(\"Permutations and signs for three items:\")\nvar a = [0, 1, 2]\ngenerate(array: &a, output: printPermutation)\n\nprint(\"\\nPermutations and signs for four items:\")\nvar b = [0, 1, 2, 3]\ngenerate(array: &b, output: printPermutation)\n", "target": "from operator import itemgetter\n \nDEBUG = False \n \ndef spermutations(n):\n    \n    sign = 1\n    p = [[i, 0 if i == 0 else -1] \n         for i in range(n)]\n \n    if DEBUG: print ' \n    yield tuple(pp[0] for pp in p), sign\n \n    while any(pp[1] for pp in p): \n        i1, (n1, d1) = max(((i, pp) for i, pp in enumerate(p) if pp[1]),\n                           key=itemgetter(1))\n        sign *= -1\n        if d1 == -1:\n            \n            i2 = i1 - 1\n            p[i1], p[i2] = p[i2], p[i1]\n            \n            \n            \n            if i2 == 0 or p[i2 - 1][0] > n1:\n                \n                p[i2][1] = 0\n        elif d1 == 1:\n            \n            i2 = i1 + 1\n            p[i1], p[i2] = p[i2], p[i1]\n            \n            \n            \n            if i2 == n - 1 or p[i2 + 1][0] > n1:\n                \n                p[i2][1] = 0\n        if DEBUG: print ' \n        yield tuple(pp[0] for pp in p), sign\n \n        for i3, pp in enumerate(p):\n            n3, d3 = pp\n            if n3 > n1:\n                pp[1] = 1 if i3 < i2 else -1\n                if DEBUG: print ' \n \n \nif __name__ == '__main__':\n    from itertools import permutations\n \n    for n in (3, 4):\n        print '\\nPermutations and sign of %i items' % n\n        sp = set()\n        for i in spermutations(n):\n            sp.add(i[0])\n            print('Perm: %r Sign: %2i' % i)\n            \n        \n        p = set(permutations(range(n)))\n        assert sp == p, 'Two methods of generating permutations do not agree'\n"}
{"id": 419580, "name": "Sequence_ smallest number with exactly n divisors", "source": "Translate Swift to Python: \nfunc divisorCount(number: Int) -> Int {\n    var n = number\n    var total = 1\n    \n    while n % 2 == 0 {\n        total += 1\n        n /= 2\n    }\n    \n    var p = 3\n    while p * p <= n {\n        var count = 1\n        while n % p == 0 {\n            count += 1\n            n /= p\n        }\n        total *= count\n        p += 2\n    }\n    \n    if n > 1 {\n        total *= 2\n    }\n    return total\n}\n\nlet limit = 15\nvar sequence = Array(repeating: 0, count: limit)\nvar count = 0\nvar n = 1\nwhile count < limit {\n    let divisors = divisorCount(number: n)\n    if divisors <= limit && sequence[divisors - 1] == 0 {\n        sequence[divisors - 1] = n\n        count += 1\n    }\n    n += 1\n}\nfor n in sequence {\n    print(n, terminator: \" \")\n}\nprint()\n", "target": "def divisors(n):\n    divs = [1]\n    for ii in range(2, int(n ** 0.5) + 3):\n        if n % ii == 0:\n            divs.append(ii)\n            divs.append(int(n / ii))\n    divs.append(n)\n    return list(set(divs))\n\n\ndef sequence(max_n=None):\n    n = 0\n    while True:\n        n += 1\n        ii = 0\n        if max_n is not None:\n            if n > max_n:\n                break\n        while True:\n            ii += 1\n            if len(divisors(ii)) == n:\n                yield ii\n                break\n\n\nif __name__ == '__main__':\n    for item in sequence(15):\n        print(item)\n"}
{"id": 419581, "name": "Longest increasing subsequence", "source": "Translate Swift to Python: import Foundation\n\nextension Array where Element: Comparable {\n  @inlinable\n  public func longestIncreasingSubsequence() -> [Element] {\n    var startI = [Int](repeating: 0, count: count)\n    var endI = [Int](repeating: 0, count: count + 1)\n    var len = 0\n\n    for i in 0..<count {\n      var lo = 1\n      var hi = len\n\n      while lo <= hi {\n        let mid = Int(ceil((Double(lo + hi)) / 2))\n\n        if self[endI[mid]] <= self[i] {\n          lo = mid + 1\n        } else {\n          hi = mid - 1\n        }\n      }\n\n      startI[i] = endI[lo-1]\n      endI[lo] = i\n\n      if lo > len {\n        len = lo\n      }\n    }\n\n    var s = [Element]()\n    var k = endI[len]\n\n    for _ in 0..<len {\n      s.append(self[k])\n      k = startI[k]\n    }\n\n    return s.reversed()\n  }\n}\n\nlet l1 = [3, 2, 6, 4, 5, 1]\nlet l2 = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\n\nprint(\"\\(l1) = \\(l1.longestIncreasingSubsequence())\")\nprint(\"\\(l2) = \\(l2.longestIncreasingSubsequence())\")\n", "target": "def longest_increasing_subsequence(X):\n    \n    N = len(X)\n    P = [0] * N\n    M = [0] * (N+1)\n    L = 0\n    for i in range(N):\n       lo = 1\n       hi = L\n       while lo <= hi:\n           mid = (lo+hi)//2\n           if (X[M[mid]] < X[i]):\n               lo = mid+1\n           else:\n               hi = mid-1\n    \n       newL = lo\n       P[i] = M[newL-1]\n       M[newL] = i\n    \n       if (newL > L):\n           L = newL\n    \n    S = []\n    k = M[L]\n    for i in range(L-1, -1, -1):\n        S.append(X[k])\n        k = P[k]\n    return S[::-1]\n\nif __name__ == '__main__':\n    for d in [[3,2,6,4,5,1], [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]]:\n        print('a L.I.S. of %s is %s' % (d, longest_increasing_subsequence(d)))\n"}
{"id": 419582, "name": "Brilliant numbers", "source": "Translate Swift to Python: \n\n\n\n\n\nfunc primeArray(n: Int) -> [Bool] {\n    \n    var primeArr = [Bool](repeating: true, count: n + 1)\n    primeArr[0] = false \n    primeArr[1] = false \n    \n    \n    var p = 2\n    while (p * p) <= n {\n        if primeArr[p] == true {\n            for j in stride(from: p * 2, through: n, by: p) {\n                primeArr[j] = false\n            }\n        }\n        p += 1\n    }\n    \n    return primeArr\n}\n\n\nfunc digitsCount(n: Int) -> Int {\n    \n    \n    var num = n\n    var count = 0;\n    while num != 0 {\n        num = num/10\n        count += 1\n    }\n    \n    return count\n}\n\n\nfunc isBrilliant(n: Int) -> Bool {\n    \n    var isPrime = [Bool]()\n    isPrime = primeArray(n: n)\n    \n    \n    \n    for i in stride(from: 2, through: n, by: 1) { \n        let x = n / i \n        if (isPrime[i] && isPrime[x] && x * i == n) { \n            if (digitsCount(n: i) == digitsCount(n: x)) {\n                return true\n            }\n        }\n    }\n    \n    return false\n}\n\n\nfunc print100Brilliants() {\n    \n    var brilNums = [Int]()\n    var count = 4\n    while brilNums.count != 100 {\n        if isBrilliant(n: count) {\n            brilNums.append(count)\n        }\n        count += 1\n    }\n    \n    print(\"First 100 brilliant numbers:\\n\", brilNums)\n}\n\n\nfunc printBrilliantsOfMagnitude() {\n    \n    \n    var basePower = 10.0\n    var brilNums: [Double] = [0.0]\n    var count = 1.0\n    while basePower != pow(basePower, 6) {\n        if isBrilliant(n: Int(count)) {\n            brilNums.append(count)\n            if count >= basePower {\n                print(\"First brilliant number >= \\(Int(basePower)): \\(Int(count)) at position \\(brilNums.firstIndex(of: count)!)\")\n                basePower *= 10\n            }\n        }\n        count += 1\n    }\n}\n\n\nprint100Brilliants()\nprintBrilliantsOfMagnitude()\n", "target": "from primesieve.numpy import primes\nfrom math import isqrt\nimport numpy as np\n\nmax_order = 9\nblocks = [primes(10**n, 10**(n + 1)) for n in range(max_order)]\n\ndef smallest_brilliant(lb):\n    pos = 1\n    root = isqrt(lb)\n\n    for blk in blocks:\n        n = len(blk)\n        if blk[-1]*blk[-1] < lb:\n            pos += n*(n + 1)//2\n            continue\n\n        i = np.searchsorted(blk, root, 'left')\n        i += blk[i]*blk[i] < lb\n\n        if not i:\n            return blk[0]*blk[0], pos\n\n        p = blk[:i + 1]\n        q = (lb - 1)//p\n        idx = np.searchsorted(blk, q, 'right')\n\n        sel = idx < n\n        p, idx = p[sel], idx[sel]\n        q = blk[idx]\n\n        sel = q >= p\n        p, q, idx = p[sel], q[sel], idx[sel]\n\n        pos += np.sum(idx - np.arange(len(idx)))\n        return np.min(p*q), pos\n\nres = []\np = 0\nfor i in range(100):\n    p, _ = smallest_brilliant(p + 1)\n    res.append(p)\n\nprint(f'first 100 are {res}')\n\nfor i in range(max_order*2):\n    thresh = 10**i\n    p, pos = smallest_brilliant(thresh)\n    print(f'Above 10^{i:2d}: {p:20d} at \n"}
{"id": 419583, "name": "Brilliant numbers", "source": "Translate Swift to Python: \n\n\n\n\n\nfunc primeArray(n: Int) -> [Bool] {\n    \n    var primeArr = [Bool](repeating: true, count: n + 1)\n    primeArr[0] = false \n    primeArr[1] = false \n    \n    \n    var p = 2\n    while (p * p) <= n {\n        if primeArr[p] == true {\n            for j in stride(from: p * 2, through: n, by: p) {\n                primeArr[j] = false\n            }\n        }\n        p += 1\n    }\n    \n    return primeArr\n}\n\n\nfunc digitsCount(n: Int) -> Int {\n    \n    \n    var num = n\n    var count = 0;\n    while num != 0 {\n        num = num/10\n        count += 1\n    }\n    \n    return count\n}\n\n\nfunc isBrilliant(n: Int) -> Bool {\n    \n    var isPrime = [Bool]()\n    isPrime = primeArray(n: n)\n    \n    \n    \n    for i in stride(from: 2, through: n, by: 1) { \n        let x = n / i \n        if (isPrime[i] && isPrime[x] && x * i == n) { \n            if (digitsCount(n: i) == digitsCount(n: x)) {\n                return true\n            }\n        }\n    }\n    \n    return false\n}\n\n\nfunc print100Brilliants() {\n    \n    var brilNums = [Int]()\n    var count = 4\n    while brilNums.count != 100 {\n        if isBrilliant(n: count) {\n            brilNums.append(count)\n        }\n        count += 1\n    }\n    \n    print(\"First 100 brilliant numbers:\\n\", brilNums)\n}\n\n\nfunc printBrilliantsOfMagnitude() {\n    \n    \n    var basePower = 10.0\n    var brilNums: [Double] = [0.0]\n    var count = 1.0\n    while basePower != pow(basePower, 6) {\n        if isBrilliant(n: Int(count)) {\n            brilNums.append(count)\n            if count >= basePower {\n                print(\"First brilliant number >= \\(Int(basePower)): \\(Int(count)) at position \\(brilNums.firstIndex(of: count)!)\")\n                basePower *= 10\n            }\n        }\n        count += 1\n    }\n}\n\n\nprint100Brilliants()\nprintBrilliantsOfMagnitude()\n", "target": "from primesieve.numpy import primes\nfrom math import isqrt\nimport numpy as np\n\nmax_order = 9\nblocks = [primes(10**n, 10**(n + 1)) for n in range(max_order)]\n\ndef smallest_brilliant(lb):\n    pos = 1\n    root = isqrt(lb)\n\n    for blk in blocks:\n        n = len(blk)\n        if blk[-1]*blk[-1] < lb:\n            pos += n*(n + 1)//2\n            continue\n\n        i = np.searchsorted(blk, root, 'left')\n        i += blk[i]*blk[i] < lb\n\n        if not i:\n            return blk[0]*blk[0], pos\n\n        p = blk[:i + 1]\n        q = (lb - 1)//p\n        idx = np.searchsorted(blk, q, 'right')\n\n        sel = idx < n\n        p, idx = p[sel], idx[sel]\n        q = blk[idx]\n\n        sel = q >= p\n        p, q, idx = p[sel], q[sel], idx[sel]\n\n        pos += np.sum(idx - np.arange(len(idx)))\n        return np.min(p*q), pos\n\nres = []\np = 0\nfor i in range(100):\n    p, _ = smallest_brilliant(p + 1)\n    res.append(p)\n\nprint(f'first 100 are {res}')\n\nfor i in range(max_order*2):\n    thresh = 10**i\n    p, pos = smallest_brilliant(thresh)\n    print(f'Above 10^{i:2d}: {p:20d} at \n"}
{"id": 419584, "name": "Order disjoint list items", "source": "Translate Swift to Python: func disjointOrder<T: Hashable>(m: [T], n: [T]) -> [T] {\n  let replaceCounts = n.reduce(into: [T: Int](), { $0[$1, default: 0] += 1 })\n  let reduced = m.reduce(into: ([T](), n, replaceCounts), {cur, el in\n    cur.0.append(cur.2[el, default: 0] > 0 ? cur.1.removeFirst() : el)\n    cur.2[el]? -= 1\n  })\n\n  return reduced.0\n}\n\nprint(disjointOrder(m: [\"the\", \"cat\", \"sat\", \"on\", \"the\", \"mat\"], n: [\"mat\", \"cat\"]))\nprint(disjointOrder(m: [\"the\", \"cat\", \"sat\", \"on\", \"the\", \"mat\"], n: [\"cat\", \"mat\"]))\nprint(disjointOrder(m: [\"A\", \"B\", \"C\", \"A\", \"B\", \"C\", \"A\", \"B\", \"C\"], n: [\"C\", \"A\", \"C\", \"A\"]))\nprint(disjointOrder(m: [\"A\", \"B\", \"C\", \"A\", \"B\", \"D\", \"A\", \"B\", \"E\"], n: [\"E\", \"A\", \"D\", \"A\"]))\nprint(disjointOrder(m: [\"A\", \"B\"], n: [\"B\"]))\nprint(disjointOrder(m: [\"A\", \"B\"], n: [\"B\", \"A\"]))\nprint(disjointOrder(m: [\"A\", \"B\", \"B\", \"A\"], n: [\"B\", \"A\"]))\n", "target": "from __future__ import print_function\n\ndef order_disjoint_list_items(data, items):\n    \n    itemindices = []\n    for item in set(items):\n        itemcount = items.count(item)\n        \n        lastindex = [-1]\n        for i in range(itemcount):\n            lastindex.append(data.index(item, lastindex[-1] + 1))\n        itemindices += lastindex[1:]\n    itemindices.sort()\n    for index, item in zip(itemindices, items):\n        data[index] = item\n\nif __name__ == '__main__':\n    tostring = ' '.join\n    for data, items in [ (str.split('the cat sat on the mat'), str.split('mat cat')),\n                         (str.split('the cat sat on the mat'), str.split('cat mat')),\n                         (list('ABCABCABC'), list('CACA')),\n                         (list('ABCABDABE'), list('EADA')),\n                         (list('AB'), list('B')),\n                         (list('AB'), list('BA')),\n                         (list('ABBA'), list('BA')),\n                         (list(''), list('')),\n                         (list('A'), list('A')),\n                         (list('AB'), list('')),\n                         (list('ABBA'), list('AB')),\n                         (list('ABAB'), list('AB')),\n                         (list('ABAB'), list('BABA')),\n                         (list('ABCCBA'), list('ACAC')),\n                         (list('ABCCBA'), list('CACA')),\n                       ]:\n        print('Data M: %-24r Order N: %-9r' % (tostring(data), tostring(items)), end=' ')\n        order_disjoint_list_items(data, items)\n        print(\"-> M' %r\" % tostring(data))\n"}
{"id": 419585, "name": "Prime words", "source": "Translate Swift to Python: import Foundation\n\nclass BitArray {\n    var array: [UInt32]\n\n    init(size: Int) {\n        array = Array(repeating: 0, count: (size + 31)/32)\n    }\n    \n    func get(index: Int) -> Bool {\n        let bit = UInt32(1) << (index & 31)\n        return (array[index >> 5] & bit) != 0\n    }\n    \n    func set(index: Int, value: Bool) {\n        let bit = UInt32(1) << (index & 31)\n        if value {\n            array[index >> 5] |= bit\n        } else {\n            array[index >> 5] &= ~bit\n        }\n    }\n}\n\nclass PrimeSieve {\n    let composite: BitArray\n    \n    init(size: Int) {\n        composite = BitArray(size: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite.get(index: p/2 - 1) {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite.set(index: q/2 - 1, value: true)\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite.get(index: number/2 - 1)\n    }\n}\n\nfunc loadDictionary(_ path: String) throws -> [String] {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return contents.components(separatedBy: \"\\n\").filter{!$0.isEmpty}\n}\n\ndo {\n    let dictionary = try loadDictionary(\"unixdict.txt\")\n    let sieve = PrimeSieve(size: 255)\n    for word in dictionary {\n        if word.allSatisfy({$0.isASCII && sieve.isPrime(number: Int($0.asciiValue!))}) {\n            print(word)\n        }\n    }\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "for i in range(65,123):\n  check = 1\n  for j in range(2,i):\n    if i%j == 0:\n     check = 0\n  if check==1:\n   print(chr(i),end='')\n"}
{"id": 419586, "name": "Prime words", "source": "Translate Swift to Python: import Foundation\n\nclass BitArray {\n    var array: [UInt32]\n\n    init(size: Int) {\n        array = Array(repeating: 0, count: (size + 31)/32)\n    }\n    \n    func get(index: Int) -> Bool {\n        let bit = UInt32(1) << (index & 31)\n        return (array[index >> 5] & bit) != 0\n    }\n    \n    func set(index: Int, value: Bool) {\n        let bit = UInt32(1) << (index & 31)\n        if value {\n            array[index >> 5] |= bit\n        } else {\n            array[index >> 5] &= ~bit\n        }\n    }\n}\n\nclass PrimeSieve {\n    let composite: BitArray\n    \n    init(size: Int) {\n        composite = BitArray(size: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite.get(index: p/2 - 1) {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite.set(index: q/2 - 1, value: true)\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite.get(index: number/2 - 1)\n    }\n}\n\nfunc loadDictionary(_ path: String) throws -> [String] {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return contents.components(separatedBy: \"\\n\").filter{!$0.isEmpty}\n}\n\ndo {\n    let dictionary = try loadDictionary(\"unixdict.txt\")\n    let sieve = PrimeSieve(size: 255)\n    for word in dictionary {\n        if word.allSatisfy({$0.isASCII && sieve.isPrime(number: Int($0.asciiValue!))}) {\n            print(word)\n        }\n    }\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "for i in range(65,123):\n  check = 1\n  for j in range(2,i):\n    if i%j == 0:\n     check = 0\n  if check==1:\n   print(chr(i),end='')\n"}
{"id": 419587, "name": "Sylvester's sequence", "source": "Translate Swift to Python: import BigNumber\n\nfunc sylvester(n: Int) -> BInt {\n  var a = BInt(2)\n\n  for _ in 0..<n {\n    a = a * a - a + 1\n  }\n\n  return a\n}\n\nvar sum = BDouble(0)\n\nfor n in 0..<10 {\n  let syl = sylvester(n: n)\n  sum += BDouble(1) / BDouble(syl)\n  print(syl)\n}\n\nprint(\"Sum of the reciprocals of first ten in sequence: \\(sum)\")\n", "target": "\n\nfrom functools import reduce\nfrom itertools import count, islice\n\n\n\ndef sylvester():\n    \n    def go(n):\n        return 1 + reduce(\n            lambda a, x: a * go(x),\n            range(0, n),\n            1\n        ) if 0 != n else 2\n\n    return map(go, count(0))\n\n\n\n\ndef main():\n    \n\n    print(\"First 10 terms of OEIS A000058:\")\n    xs = list(islice(sylvester(), 10))\n    print('\\n'.join([\n        str(x) for x in xs\n    ]))\n\n    print(\"\\nSum of the reciprocals of the first 10 terms:\")\n    print(\n        reduce(lambda a, x: a + 1 / x, xs, 0)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 419588, "name": "Generate random numbers without repeating a value", "source": "Translate Swift to Python: var array = Array(1...20)\narray.shuffle()\nprint(array)\n", "target": "import random\n\nprint(random.sample(range(1, 21), 20))\n"}
{"id": 419589, "name": "Comments", "source": "Translate Swift to Python: \n\n */\n\n\n\n\n", "target": "\n\nvar x = 0 \n\nvar y = 0 \n\n\nThere are also multi-line comments\nEverything inside of \n]\n\n\n\ndiscard \n"}
{"id": 419590, "name": "Sorting Algorithms_Circle Sort", "source": "Translate Swift to Python: func circleSort<T: Comparable>(_ array: inout [T]) {\n    func circSort(low: Int, high: Int, swaps: Int) -> Int {\n        if low == high {\n            return swaps\n        }\n        var lo = low\n        var hi = high\n        let mid = (hi - lo) / 2\n        var s = swaps\n        while lo < hi {\n            if array[lo] > array[hi] {\n                array.swapAt(lo, hi)\n                s += 1\n            }\n            lo += 1\n            hi -= 1\n        }\n        if lo == hi {\n            if array[lo] > array[hi + 1] {\n                array.swapAt(lo, hi + 1)\n                s += 1\n            }\n        }\n        s = circSort(low: low, high: low + mid, swaps: s)\n        s = circSort(low: low + mid + 1, high: high, swaps: s)\n        return s\n    }\n    while circSort(low: 0, high: array.count - 1, swaps: 0) != 0 {}\n}\n\nvar array = [10, 8, 4, 3, 1, 9, 0, 2, 7, 5, 6]\nprint(\"before: \\(array)\")\ncircleSort(&array)\nprint(\" after: \\(array)\")\n\nvar array2 = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\"]\nprint(\"before: \\(array2)\")\ncircleSort(&array2)\nprint(\" after: \\(array2)\")\n", "target": "\n\n\n\n\ndef circle_sort_backend(A:list, L:int, R:int)->'sort A in place, returning the number of swaps':\n    \n    n = R-L\n    if n < 2:\n        return 0\n    swaps = 0\n    m = n//2\n    for i in range(m):\n        if A[R-(i+1)] < A[L+i]:\n            (A[R-(i+1)], A[L+i],) = (A[L+i], A[R-(i+1)],)\n            swaps += 1\n    if (n & 1) and (A[L+m] < A[L+m-1]):\n        (A[L+m-1], A[L+m],) = (A[L+m], A[L+m-1],)\n        swaps += 1\n    return swaps + circle_sort_backend(A, L, L+m) + circle_sort_backend(A, L+m, R)\n\ndef circle_sort(L:list)->'sort A in place, returning the number of swaps':\n    swaps = 0\n    s = 1\n    while s:\n        s = circle_sort_backend(L, 0, len(L))\n        swaps += s\n    return swaps\n\n\nif __name__ == '__main__':\n    from random import shuffle\n    for i in range(309):\n        L = list(range(i))\n        M = L[:]\n        shuffle(L)\n        N = L[:]\n        circle_sort(L)\n        if L != M:\n            print(len(L))\n            print(N)\n            print(L)\n"}
{"id": 419591, "name": "Circles of given radius through two points", "source": "Translate Swift to Python: import Foundation\n\nstruct Point: Equatable {\n    var x: Double\n    var y: Double\n}\n\nstruct Circle {\n  var center: Point\n  var radius: Double\n\n  static func circleBetween(\n    _ p1: Point,\n    _ p2: Point,\n    withRadius radius: Double\n  ) -> (Circle, Circle?)? {\n    func applyPoint(_ p1: Point, _ p2: Point, op: (Double, Double) -> Double) -> Point {\n      return Point(x: op(p1.x, p2.x), y: op(p1.y, p2.y))\n    }\n\n    func mul2(_ p: Point, mul: Double) -> Point {\n      return Point(x: p.x * mul, y: p.y * mul)\n    }\n\n    func div2(_ p: Point, div: Double) -> Point {\n      return Point(x: p.x / div, y: p.y / div)\n    }\n\n    func norm(_ p: Point) -> Point {\n      return div2(p, div: (p.x * p.x + p.y * p.y).squareRoot())\n    }\n\n    guard radius != 0, p1 != p2 else {\n      return nil\n    }\n\n    let diameter = 2 * radius\n    let pq = applyPoint(p1, p2, op: -)\n    let magPQ = (pq.x * pq.x + pq.y * pq.y).squareRoot()\n\n    guard diameter >= magPQ else {\n      return nil\n    }\n\n    let midpoint = div2(applyPoint(p1, p2, op: +), div: 2)\n    let halfPQ = magPQ / 2\n    let magMidC = abs(radius * radius - halfPQ * halfPQ).squareRoot()\n    let midC = mul2(norm(Point(x: -pq.y, y: pq.x)), mul: magMidC)\n    let center1 = applyPoint(midpoint, midC, op: +)\n    let center2 = applyPoint(midpoint, midC, op: -)\n\n    if center1 == center2 {\n      return (Circle(center: center1, radius: radius), nil)\n    } else {\n      return (Circle(center: center1, radius: radius), Circle(center: center2, radius: radius))\n    }\n  }\n}\n\nlet testCases = [\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 2.0),\n  (Point(x: 0.0000, y: 2.0000), Point(x: 0.0000, y: 0.0000), 1.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 2.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 0.5),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 0.0)\n]\n\nfor testCase in testCases {\n  switch Circle.circleBetween(testCase.0, testCase.1, withRadius: testCase.2) {\n  case nil:\n    print(\"No ans\")\n  case (let circle1, nil)?:\n    print(\"One ans: \\(circle1)\")\n  case (let circle1, let circle2?)?:\n    print(\"Two ans: \\(circle1) \\(circle2)\")\n  }\n}\n", "target": "from collections import namedtuple\nfrom math import sqrt\n\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if r == 0.0:\n        raise ValueError('radius of zero')\n    (x1, y1), (x2, y2) = p1, p2\n    if p1 == p2:\n        raise ValueError('coincident points gives infinite number of Circles')\n    \n    dx, dy = x2 - x1, y2 - y1\n    \n    q = sqrt(dx**2 + dy**2)\n    if q > 2.0*r:\n        raise ValueError('separation of points > diameter')\n    \n    x3, y3 = (x1+x2)/2, (y1+y2)/2\n    \n    d = sqrt(r**2-(q/2)**2)\n    \n    c1 = Cir(x = x3 - d*dy/q,\n             y = y3 + d*dx/q,\n             r = abs(r))\n    \n    c2 = Cir(x = x3 + d*dy/q,\n             y = y3 - d*dx/q,\n             r = abs(r))\n    return c1, c2\n\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\n              % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))\n"}
{"id": 419592, "name": "Circles of given radius through two points", "source": "Translate Swift to Python: import Foundation\n\nstruct Point: Equatable {\n    var x: Double\n    var y: Double\n}\n\nstruct Circle {\n  var center: Point\n  var radius: Double\n\n  static func circleBetween(\n    _ p1: Point,\n    _ p2: Point,\n    withRadius radius: Double\n  ) -> (Circle, Circle?)? {\n    func applyPoint(_ p1: Point, _ p2: Point, op: (Double, Double) -> Double) -> Point {\n      return Point(x: op(p1.x, p2.x), y: op(p1.y, p2.y))\n    }\n\n    func mul2(_ p: Point, mul: Double) -> Point {\n      return Point(x: p.x * mul, y: p.y * mul)\n    }\n\n    func div2(_ p: Point, div: Double) -> Point {\n      return Point(x: p.x / div, y: p.y / div)\n    }\n\n    func norm(_ p: Point) -> Point {\n      return div2(p, div: (p.x * p.x + p.y * p.y).squareRoot())\n    }\n\n    guard radius != 0, p1 != p2 else {\n      return nil\n    }\n\n    let diameter = 2 * radius\n    let pq = applyPoint(p1, p2, op: -)\n    let magPQ = (pq.x * pq.x + pq.y * pq.y).squareRoot()\n\n    guard diameter >= magPQ else {\n      return nil\n    }\n\n    let midpoint = div2(applyPoint(p1, p2, op: +), div: 2)\n    let halfPQ = magPQ / 2\n    let magMidC = abs(radius * radius - halfPQ * halfPQ).squareRoot()\n    let midC = mul2(norm(Point(x: -pq.y, y: pq.x)), mul: magMidC)\n    let center1 = applyPoint(midpoint, midC, op: +)\n    let center2 = applyPoint(midpoint, midC, op: -)\n\n    if center1 == center2 {\n      return (Circle(center: center1, radius: radius), nil)\n    } else {\n      return (Circle(center: center1, radius: radius), Circle(center: center2, radius: radius))\n    }\n  }\n}\n\nlet testCases = [\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 2.0),\n  (Point(x: 0.0000, y: 2.0000), Point(x: 0.0000, y: 0.0000), 1.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 2.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 0.5),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 0.0)\n]\n\nfor testCase in testCases {\n  switch Circle.circleBetween(testCase.0, testCase.1, withRadius: testCase.2) {\n  case nil:\n    print(\"No ans\")\n  case (let circle1, nil)?:\n    print(\"One ans: \\(circle1)\")\n  case (let circle1, let circle2?)?:\n    print(\"Two ans: \\(circle1) \\(circle2)\")\n  }\n}\n", "target": "from collections import namedtuple\nfrom math import sqrt\n\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if r == 0.0:\n        raise ValueError('radius of zero')\n    (x1, y1), (x2, y2) = p1, p2\n    if p1 == p2:\n        raise ValueError('coincident points gives infinite number of Circles')\n    \n    dx, dy = x2 - x1, y2 - y1\n    \n    q = sqrt(dx**2 + dy**2)\n    if q > 2.0*r:\n        raise ValueError('separation of points > diameter')\n    \n    x3, y3 = (x1+x2)/2, (y1+y2)/2\n    \n    d = sqrt(r**2-(q/2)**2)\n    \n    c1 = Cir(x = x3 - d*dy/q,\n             y = y3 + d*dx/q,\n             r = abs(r))\n    \n    c2 = Cir(x = x3 + d*dy/q,\n             y = y3 - d*dx/q,\n             r = abs(r))\n    return c1, c2\n\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\n              % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))\n"}
{"id": 419593, "name": "Vampire number", "source": "Translate Swift to Python: import Foundation\n\nfunc vampire<T>(n: T) -> [(T, T)] where T: BinaryInteger, T.Stride: SignedInteger {\n  let strN = String(n).sorted()\n  let fangLength = strN.count / 2\n  let start = T(pow(10, Double(fangLength - 1)))\n  let end = T(Double(n).squareRoot())\n\n  var fangs = [(T, T)]()\n\n  for i in start...end where n % i == 0 {\n    let quot = n / i\n\n    guard i % 10 != 0 || quot % 10 != 0 else {\n      continue\n    }\n\n    if \"\\(i)\\(quot)\".sorted() == strN {\n      fangs.append((i, quot))\n    }\n  }\n\n  return fangs\n}\n\nvar count = 0\nvar i = 1.0\n\nwhile count < 25 {\n  let start = Int(pow(10, i))\n  let end = start * 10\n\n  for num in start...end {\n    let fangs = vampire(n: num)\n\n    guard !fangs.isEmpty else { continue }\n\n    count += 1\n\n    print(\"\\(num) is a vampire number with fangs: \\(fangs)\")\n\n    guard count != 25 else { break }\n  }\n\n  i += 2\n}\n\nfor (vamp, fangs) in [16758243290880, 24959017348650, 14593825548650].lazy.map({ ($0, vampire(n: $0)) }) {\n  if fangs.isEmpty {\n    print(\"\\(vamp) is not a vampire number\")\n  } else {\n    print(\"\\(vamp) is a vampire number with fangs: \\(fangs)\")\n  }\n}\n", "target": "from __future__ import division\n\nimport math\nfrom operator import mul\nfrom itertools import product\nfrom functools import reduce\n\n\ndef fac(n):\n    \n    step = lambda x: 1 + x*4 - (x//2)*2\n    maxq = int(math.floor(math.sqrt(n)))\n    d = 1\n    q = n % 2 == 0 and 2 or 3 \n    while q <= maxq and n % q != 0:\n        q = step(d)\n        d += 1\n    res = []\n    if q <= maxq:\n        res.extend(fac(n//q))\n        res.extend(fac(q)) \n    else: res=[n]\n    return res\n\ndef fact(n):\n    \n    res = fac(n)\n    return [(c, res.count(c)) for c in set(res)]\n\ndef divisors(n):\n    'Returns all the divisors of n'\n    factors = fact(n)   \n    primes, maxpowers = zip(*factors)\n    powerranges = (range(m+1) for m in maxpowers)\n    powers = product(*powerranges)\n    return (\n        reduce(mul,\n               (prime**power for prime, power in zip(primes, powergroup)),\n               1)\n        for powergroup in powers)\n    \ndef vampire(n):\n    fangsets = set( frozenset([d, n//d])\n                    for d in divisors(n)\n                    if (len(str(d)) == len(str(n))/2.\n                        and sorted(str(d) + str(n//d)) == sorted(str(n))\n                        and (str(d)[-1] == 0) + (str(n//d)[-1] == 0) <=1) )\n    return sorted(tuple(sorted(fangs)) for fangs in fangsets)\n    \n\nif __name__ == '__main__':\n    print('First 25 vampire numbers')\n    count = n = 0\n    while count <25:\n        n += 1\n        fangpairs = vampire(n)\n        if fangpairs:\n            count += 1\n            print('%i: %r' % (n, fangpairs))\n    print('\\nSpecific checks for fangpairs')\n    for n in (16758243290880, 24959017348650, 14593825548650):\n        fangpairs = vampire(n)\n        print('%i: %r' % (n, fangpairs))\n"}
{"id": 419594, "name": "Play recorded sounds", "source": "Translate Swift to Python: import AVFoundation\n\n\n\n\n\n\nclass PlayerControl: NSObject, AVAudioPlayerDelegate {\n    let player1:AVAudioPlayer!\n    let player2:AVAudioPlayer!\n    var playedBoth = false\n    var volume:Float {\n        get {\n            return player1.volume\n        }\n        \n        set {\n            player1.volume = newValue\n            player2.volume = newValue\n        }\n    }\n    \n    init(player1:AVAudioPlayer, player2:AVAudioPlayer) {\n        super.init()\n        self.player1 = player1\n        self.player2 = player2\n        self.player1.delegate = self\n        self.player2.delegate = self\n    }\n    \n    func loop() {\n        player1.numberOfLoops = 1\n        player1.play()\n        \n        let time = Int64((Double(player1.duration) + 2.0) * Double(NSEC_PER_SEC))\n        \n        dispatch_after(dispatch_time(0, time), dispatch_get_main_queue()) {[weak self] in\n            println(\"Stopping track\")\n            self?.player1.stop()\n            exit(0)\n        }\n    }\n    \n    func playBoth() {\n        player1.play()\n        player2.play()\n    }\n    \n    func audioPlayerDidFinishPlaying(player:AVAudioPlayer!, successfully flag:Bool) {\n        if player === player2 && !playedBoth {\n            playBoth()\n            playedBoth = true\n        } else if player === player2 && playedBoth {\n            loop()\n        }\n    }\n}\n\nlet url1 = NSURL(string: \"file:\nlet url2 = NSURL(string: \"file:\n\nvar err:NSError?\nlet player1 = AVAudioPlayer(contentsOfURL: url1, error: &err)\nlet player2 = AVAudioPlayer(contentsOfURL: url2, error: &err)\n\nlet player = PlayerControl(player1: player1, player2: player2)\n\n\nplayer.volume = 0.5\n\n\n\n\n\n\nplayer.player2.play()\n\nCFRunLoopRun()\n", "target": "import time\nfrom pygame import mixer\n\nmixer.init(frequency=16000) \ns1 = mixer.Sound('test.wav')\ns2 = mixer.Sound('test2.wav')\n\n\ns1.play(-1)         \ntime.sleep(0.5)\n\n\ns2.play()          \ntime.sleep(2)\ns2.play(2)         \ntime.sleep(10)\n\n\ns1.set_volume(0.1)\ntime.sleep(5)\n\n\ns1.set_volume(1)\ntime.sleep(5)\n\ns1.stop()\ns2.stop()\nmixer.quit()\n"}
{"id": 419595, "name": "Nonoblock", "source": "Translate Swift to Python: import Foundation\n\nfunc nonoblock(cells: Int, blocks: [Int]) {\n    print(\"\\(cells) cells and blocks \\(blocks):\")\n    let totalBlockSize = blocks.reduce(0, +)\n    if cells < totalBlockSize + blocks.count - 1 {\n        print(\"no solution\")\n        return\n    }\n\n    func solve(cells: Int, index: Int, totalBlockSize: Int, offset: Int) {\n        if index == blocks.count {\n            count += 1\n            print(\"\\(String(format: \"%2d\", count))  \\(String(output))\")\n            return\n        }\n        let blockSize = blocks[index]\n        let maxPos = cells - (totalBlockSize + blocks.count - index - 1)\n        let t = totalBlockSize - blockSize\n        var c = cells - (blockSize + 1)\n        for pos in 0...maxPos {\n            fill(value: \".\", offset: offset, count: maxPos + blockSize)\n            fill(value: \"#\", offset: offset + pos, count: blockSize)\n            solve(cells: c, index: index + 1, totalBlockSize: t,\n                  offset: offset + blockSize + pos + 1)\n            c -= 1\n        }\n    }\n\n    func fill(value: Character, offset: Int, count: Int) {\n        output.replaceSubrange(offset..<offset+count,\n                               with: repeatElement(value, count: count))\n    }\n    \n    var output: [Character] = Array(repeating: \".\", count: cells)\n    var count = 0\n    solve(cells: cells, index: 0, totalBlockSize: totalBlockSize, offset: 0)\n}\n\nnonoblock(cells: 5, blocks: [2, 1])\nprint()\n\nnonoblock(cells: 5, blocks: [])\nprint()\n\nnonoblock(cells: 10, blocks: [8])\nprint()\n\nnonoblock(cells: 15, blocks: [2, 3, 2, 3])\nprint()\n\nnonoblock(cells: 5, blocks: [2, 3])\n", "target": "def nonoblocks(blocks, cells):\n    if not blocks or blocks[0] == 0:\n        yield [(0, 0)]\n    else:\n        assert sum(blocks) + len(blocks)-1 <= cells, \\\n            'Those blocks will not fit in those cells'\n        blength, brest = blocks[0], blocks[1:]      \n        minspace4rest = sum(1+b for b in brest)     \n        \n        for bpos in range(0, cells - minspace4rest - blength + 1):\n            if not brest:\n                \n                yield [(bpos, blength)]\n            else:\n                \n                \n                \n                offset = bpos + blength +1\n                nonoargs = (brest, cells - offset)  \n                \n                for subpos in nonoblocks(*nonoargs):\n                    \n                    rest = [(offset + bp, bl) for bp, bl in subpos]\n                    \n                    vec = [(bpos, blength)] + rest\n                    yield vec\n\ndef pblock(vec, cells):\n    'Prettyprints each run of blocks with a different letter A.. for each block of filled cells'\n    vector = ['_'] * cells\n    for ch, (bp, bl) in enumerate(vec, ord('A')):\n        for i in range(bp, bp + bl):\n            vector[i] = chr(ch) if vector[i] == '_' else'?'\n    return '|' + '|'.join(vector) + '|'\n\n\nif __name__ == '__main__':\n    for blocks, cells in (\n            ([2, 1], 5),\n            ([], 5),\n            ([8], 10),\n            ([2, 3, 2, 3], 15),\n           \n           \n           \n            ([2, 3], 5),\n            ):\n        print('\\nConfiguration:\\n    %s \n        print('  Possibilities:')\n        for i, vector in enumerate(nonoblocks(blocks, cells)):\n            print('   ', pblock(vector, cells))\n        print('  A total of %i Possible configurations.' % (i+1))\n"}
{"id": 419596, "name": "Nonoblock", "source": "Translate Swift to Python: import Foundation\n\nfunc nonoblock(cells: Int, blocks: [Int]) {\n    print(\"\\(cells) cells and blocks \\(blocks):\")\n    let totalBlockSize = blocks.reduce(0, +)\n    if cells < totalBlockSize + blocks.count - 1 {\n        print(\"no solution\")\n        return\n    }\n\n    func solve(cells: Int, index: Int, totalBlockSize: Int, offset: Int) {\n        if index == blocks.count {\n            count += 1\n            print(\"\\(String(format: \"%2d\", count))  \\(String(output))\")\n            return\n        }\n        let blockSize = blocks[index]\n        let maxPos = cells - (totalBlockSize + blocks.count - index - 1)\n        let t = totalBlockSize - blockSize\n        var c = cells - (blockSize + 1)\n        for pos in 0...maxPos {\n            fill(value: \".\", offset: offset, count: maxPos + blockSize)\n            fill(value: \"#\", offset: offset + pos, count: blockSize)\n            solve(cells: c, index: index + 1, totalBlockSize: t,\n                  offset: offset + blockSize + pos + 1)\n            c -= 1\n        }\n    }\n\n    func fill(value: Character, offset: Int, count: Int) {\n        output.replaceSubrange(offset..<offset+count,\n                               with: repeatElement(value, count: count))\n    }\n    \n    var output: [Character] = Array(repeating: \".\", count: cells)\n    var count = 0\n    solve(cells: cells, index: 0, totalBlockSize: totalBlockSize, offset: 0)\n}\n\nnonoblock(cells: 5, blocks: [2, 1])\nprint()\n\nnonoblock(cells: 5, blocks: [])\nprint()\n\nnonoblock(cells: 10, blocks: [8])\nprint()\n\nnonoblock(cells: 15, blocks: [2, 3, 2, 3])\nprint()\n\nnonoblock(cells: 5, blocks: [2, 3])\n", "target": "def nonoblocks(blocks, cells):\n    if not blocks or blocks[0] == 0:\n        yield [(0, 0)]\n    else:\n        assert sum(blocks) + len(blocks)-1 <= cells, \\\n            'Those blocks will not fit in those cells'\n        blength, brest = blocks[0], blocks[1:]      \n        minspace4rest = sum(1+b for b in brest)     \n        \n        for bpos in range(0, cells - minspace4rest - blength + 1):\n            if not brest:\n                \n                yield [(bpos, blength)]\n            else:\n                \n                \n                \n                offset = bpos + blength +1\n                nonoargs = (brest, cells - offset)  \n                \n                for subpos in nonoblocks(*nonoargs):\n                    \n                    rest = [(offset + bp, bl) for bp, bl in subpos]\n                    \n                    vec = [(bpos, blength)] + rest\n                    yield vec\n\ndef pblock(vec, cells):\n    'Prettyprints each run of blocks with a different letter A.. for each block of filled cells'\n    vector = ['_'] * cells\n    for ch, (bp, bl) in enumerate(vec, ord('A')):\n        for i in range(bp, bp + bl):\n            vector[i] = chr(ch) if vector[i] == '_' else'?'\n    return '|' + '|'.join(vector) + '|'\n\n\nif __name__ == '__main__':\n    for blocks, cells in (\n            ([2, 1], 5),\n            ([], 5),\n            ([8], 10),\n            ([2, 3, 2, 3], 15),\n           \n           \n           \n            ([2, 3], 5),\n            ):\n        print('\\nConfiguration:\\n    %s \n        print('  Possibilities:')\n        for i, vector in enumerate(nonoblocks(blocks, cells)):\n            print('   ', pblock(vector, cells))\n        print('  A total of %i Possible configurations.' % (i+1))\n"}
{"id": 419597, "name": "Knapsack problem_Bounded", "source": "Translate Swift to Python: public struct KnapsackItem: Hashable {\n  public var name: String\n  public var weight: Int\n  public var value: Int\n\n  public init(name: String, weight: Int, value: Int) {\n    self.name = name\n    self.weight = weight\n    self.value = value\n  }\n}\n\npublic func knapsack(items: [KnapsackItem], limit: Int) -> [KnapsackItem] {\n  var table = Array(repeating: Array(repeating: 0, count: limit + 1), count: items.count + 1)\n\n  for j in 1...items.count {\n    let item = items[j-1]\n\n    for w in 1...limit {\n      if item.weight > w {\n        table[j][w] = table[j-1][w]\n      } else {\n        table[j][w] = max(table[j-1][w], table[j-1][w-item.weight] + item.value)\n      }\n    }\n  }\n\n  var result = [KnapsackItem]()\n  var w = limit\n\n  for j in stride(from: items.count, to: 0, by: -1) where table[j][w] != table[j-1][w] {\n    let item = items[j-1]\n\n    result.append(item)\n\n    w -= item.weight\n  }\n\n  return result\n}\n\ntypealias GroupedItem = (name: String, weight: Int, val: Int, n: Int)\n\nlet groupedItems: [GroupedItem] = [\n  (\"map\", 9, 150, 1),\n  (\"compass\", 13, 35, 1),\n  (\"water\", 153, 200, 3),\n  (\"sandwich\", 50, 60, 2),\n  (\"glucose\", 15, 60, 2),\n  (\"tin\", 68, 45, 3),\n  (\"banana\", 27, 60, 3),\n  (\"apple\", 39, 40, 3),\n  (\"cheese\", 23, 30, 1),\n  (\"beer\", 52, 10, 3),\n  (\"suntan cream\", 11, 70, 1),\n  (\"camera\", 32, 30, 1),\n  (\"t-shirt\", 24, 15, 2),\n  (\"trousers\", 48, 10, 2),\n  (\"umbrella\", 73, 40, 1),\n  (\"waterproof trousers\", 42, 70, 1),\n  (\"waterproof overclothes\", 43, 75, 1),\n  (\"note-case\", 22, 80, 1),\n  (\"sunglasses\", 7, 20, 1),\n  (\"towel\", 18, 12, 2),\n  (\"socks\", 4, 50, 1),\n  (\"book\", 30, 10, 2)\n]\n\nlet items = groupedItems.flatMap({item in\n  (0..<item.n).map({_ in KnapsackItem(name: item.name, weight: item.weight, value: item.val) })\n})\n\nlet bagged = knapsack(items: items, limit: 400)\nlet (totalVal, totalWeight) = bagged.reduce((0, 0), {cur, item in (cur.0 + item.value, cur.1 + item.weight) })\n\nprint(\"Bagged the following \\(bagged.count) items:\")\n\nfor item in bagged {\n  print(\"\\t\\(item.name)\")\n}\n\nprint(\"For a total value of \\(totalVal) and weight of \\(totalWeight)\")\n", "target": "\n\nimport strformat\nimport tables\n\n\ntype Item = tuple[name: string; weight, value, pieces: int]\n\n\nconst Items: seq[Item] = @[(\"map\", 9, 150, 1),\n                           (\"compass\", 13, 35, 1),\n                           (\"water\", 153, 200, 2),\n                           (\"sandwich\", 50, 60, 2),\n                           (\"glucose\", 15, 60, 2),\n                           (\"tin\", 68, 45, 3),\n                           (\"banana\", 27, 60, 3),\n                           (\"apple\", 39, 40, 3),\n                           (\"cheese\", 23, 30, 1),\n                           (\"beer\", 52, 10, 3),\n                           (\"suntan cream\", 11, 70, 1),\n                           (\"camera\", 32, 30, 1),\n                           (\"T-shirt\", 24, 15, 2),\n                           (\"trousers\", 48, 10, 2),\n                           (\"umbrella\", 73, 40, 1),\n                           (\"waterproof trousers\", 42, 70, 1),\n                           (\"waterproof overclothes\", 43, 75, 1),\n                           (\"note-case\", 22, 80, 1),\n                           (\"sunglasses\", 7, 20, 1),\n                           (\"towel\", 18, 12, 2),\n                           (\"socks\", 4, 50, 1),\n                           (\"book\", 30, 10, 2)\n                          ]\n\ntype\n\n  \n  Number = range[0..Items.high]\n\n  \n  ExpandedItem = tuple[num: Number; weight, value: int]\n\n\n\n\nproc expandedItems(items: seq[Item]): seq[ExpandedItem] =\n  \n  for idx, item in Items:\n    for _ in 1..item.pieces:\n      result.add((idx.Number, item.weight, item.value))\n\nconst ItemList = expandedItems(Items)\n\ntype\n\n  \n  ExpandedIndex = 0..ItemList.high\n\n  \n  Choice = tuple[indexes: set[ExpandedIndex]; weight, value: int]\n\n\nvar cache: Table[tuple[index, weight: int], Choice]\n\n\n\n\nproc select(idx, weightLimit: int): Choice =\n  \n\n  if idx < 0 or weightLimit == 0:\n    return\n\n  if (idx, weightLimit) in cache:\n    return cache[(idx, weightLimit)]\n\n  let weight = ItemList[idx].weight\n  if weight > weightLimit:\n    return select(idx - 1, weightLimit)\n\n  \n  result = select(idx - 1, weightLimit)\n\n  \n  var result1 = select(idx - 1, weightLimit - weight)\n  inc result1.value, ItemList[idx].value\n\n  \n  if result1.value > result.value:\n    result = (result1.indexes + {idx.ExpandedIndex}, result1.weight + weight, result1.value)\n\n  cache[(idx, weightLimit)] = result\n\n\n\nlet (indexes, weight, value) = select(ItemList.high, 400)\n\n\nvar pieces = newSeq[int](Items.len)\nfor idx in indexes:\n  inc pieces[ItemList[idx].num]\n\necho \"List of items:\"\nfor num in 0..Items.high:\n  if pieces[num] > 0:\n    echo fmt\"\u2013 {pieces[num]} of {Items[num].pieces} {Items[num].name}\"\necho \"\"\necho \"Total weight: \", weight\necho \"Total value: \", value\n"}
{"id": 419598, "name": "Angles (geometric), normalization and conversion", "source": "Translate Swift to Python: import Foundation\n\nfunc normalize(_ f: Double, N: Double) -> Double {\n  var a = f\n\n  while a < -N { a += N }\n  while a >= N { a -= N }\n\n  return a\n}\n\nfunc normalizeToDeg(_ f: Double) -> Double {\n  return normalize(f, N: 360)\n}\n\nfunc normalizeToGrad(_ f: Double) -> Double {\n  return normalize(f, N: 400)\n}\n\nfunc normalizeToMil(_ f: Double) -> Double {\n  return normalize(f, N: 6400)\n}\n\nfunc normalizeToRad(_ f: Double) -> Double {\n  return normalize(f, N: 2 * .pi)\n}\n\nfunc d2g(_ f: Double) -> Double { f * 10 / 9 }\nfunc d2m(_ f: Double) -> Double { f * 160 / 9 }\nfunc d2r(_ f: Double) -> Double { f * .pi / 180 }\n\nfunc g2d(_ f: Double) -> Double { f * 9 / 10 }\nfunc g2m(_ f: Double) -> Double { f * 16 }\nfunc g2r(_ f: Double) -> Double { f * .pi / 200 }\n\nfunc m2d(_ f: Double) -> Double { f * 9 / 160 }\nfunc m2g(_ f: Double) -> Double { f / 16 }\nfunc m2r(_ f: Double) -> Double { f * .pi / 3200 }\n\nfunc r2d(_ f: Double) -> Double { f * 180 / .pi }\nfunc r2g(_ f: Double) -> Double { f * 200 / .pi }\nfunc r2m(_ f: Double) -> Double { f * 3200 / .pi }\n\nlet angles = [-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 6399, 1_000_000]\nlet names = [\"Degrees\", \"Gradians\", \"Mils\", \"Radians\"]\nlet fmt = { String(format: \"%.4f\", $0) }\n\nlet normal = [normalizeToDeg, normalizeToGrad, normalizeToMil, normalizeToRad]\nlet convert = [\n  [{ $0 }, d2g, d2m, d2r],\n  [g2d, { $0 }, g2m, g2r],\n  [m2d, m2g, { $0 }, m2r],\n  [r2d, r2g, r2m, { $0 }]\n]\n\nlet ans =\n  angles.map({ angle in\n    (0..<4).map({ ($0, normal[$0](angle)) }).map({\n      (fmt(angle),\n        fmt($0.1),\n        names[$0.0],\n        fmt(convert[$0.0][0]($0.1)),\n        fmt(convert[$0.0][1]($0.1)),\n        fmt(convert[$0.0][2]($0.1)),\n        fmt(convert[$0.0][3]($0.1))\n      )\n    })\n  })\n\nprint(\"angle\", \"normalized\", \"unit\", \"degrees\", \"grads\", \"mils\", \"radians\")\n\nfor res in ans {\n  for unit in res {\n    print(unit)\n  }\n\n  print()\n}\n", "target": "PI = 3.141592653589793\nTWO_PI = 6.283185307179586\n\ndef normalize2deg(a):\n  while a < 0: a += 360\n  while a >= 360: a -= 360\n  return a\ndef normalize2grad(a):\n  while a < 0: a += 400\n  while a >= 400: a -= 400\n  return a\ndef normalize2mil(a):\n  while a < 0: a += 6400\n  while a >= 6400: a -= 6400\n  return a\ndef normalize2rad(a):\n  while a < 0: a += TWO_PI\n  while a >= TWO_PI: a -= TWO_PI\n  return a\n\ndef deg2grad(a): return a * 10.0 / 9.0\ndef deg2mil(a): return a * 160.0 / 9.0\ndef deg2rad(a): return a * PI / 180.0\n\ndef grad2deg(a): return a * 9.0 / 10.0\ndef grad2mil(a): return a * 16.0\ndef grad2rad(a): return a * PI / 200.0\n\ndef mil2deg(a): return a * 9.0 / 160.0\ndef mil2grad(a): return a / 16.0\ndef mil2rad(a): return a * PI / 3200.0\n\ndef rad2deg(a): return a * 180.0 / PI\ndef rad2grad(a): return a * 200.0 / PI\ndef rad2mil(a): return a * 3200.0 / PI\n"}
{"id": 419599, "name": "I before E except after C", "source": "Translate Swift to Python: import Foundation\n\nlet request = NSURLRequest(URL: NSURL(string: \"http:\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in\n    if (data != nil) {\n        if let fileAsString = NSString(data: data, encoding: NSUTF8StringEncoding) {\n            var firstCase = false\n            var secondCase = false\n            var cie = 0\n            var cei = 0\n            var not_c_ie = 0\n            var not_c_ei = 0\n            let words = fileAsString.componentsSeparatedByString(\"\\n\")\n            for word in words {\n                var wordRegex = RegexMutable(word as String)\n                if (wordRegex[\"cie\"]) {\n                    cie++\n                }\n                if (wordRegex[\"cei\"]) {\n                    cei++\n                }\n                if (wordRegex[\"(^ie|[^c]ie)\"].matches().count != 0) {\n                    not_c_ie++\n                }\n                if (wordRegex[\"(^ei|[^c]ei)\"].matches().count != 0) {\n                    not_c_ei++\n                }\n            }\n            \n            \n            if (not_c_ie > not_c_ei * 2) {\n                println(\"I before E when not preceded by C is plausable\")\n                firstCase = true\n            } else {\n                println(\"I before E when not preceded by C is not plausable\")\n            }\n            \n            if (cei > cie * 2) {\n                secondCase = true\n                println(\"E before I when preceded by C is plausable\")\n            } else {\n                println(\"E before I when preceded by C is not plausable\")\n            }\n            \n            if (firstCase && secondCase) {\n                println(\"I before E except after C is plausible\")\n            } else {\n                println(\"I before E except after C is not plausible\")\n            }\n        }\n    }\n}\n\nCFRunLoopRun()\n", "target": "import urllib.request\nimport re\n\nPLAUSIBILITY_RATIO = 2\n\ndef plausibility_check(comment, x, y):\n    print('\\n  Checking plausibility of: %s' % comment)\n    if x > PLAUSIBILITY_RATIO * y:\n        print('    PLAUSIBLE. As we have counts of %i vs %i, a ratio of %4.1f times'\n              % (x, y, x / y))\n    else:\n        if x > y:\n            print('    IMPLAUSIBLE. As although we have counts of %i vs %i, a ratio of %4.1f times does not make it plausible'\n                  % (x, y, x / y))\n        else:\n            print('    IMPLAUSIBLE, probably contra-indicated. As we have counts of %i vs %i, a ratio of %4.1f times'\n                  % (x, y, x / y))\n    return x > PLAUSIBILITY_RATIO * y\n\ndef simple_stats(url='http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'):\n    words = urllib.request.urlopen(url).read().decode().lower().split()\n    cie = len({word for word in words if 'cie' in word})\n    cei = len({word for word in words if 'cei' in word})\n    not_c_ie = len({word for word in words if re.search(r'(^ie|[^c]ie)', word)})\n    not_c_ei = len({word for word in words if re.search(r'(^ei|[^c]ei)', word)})\n    return cei, cie, not_c_ie, not_c_ei\n\ndef print_result(cei, cie, not_c_ie, not_c_ei):\n    if ( plausibility_check('I before E when not preceded by C', not_c_ie, not_c_ei)\n         & plausibility_check('E before I when preceded by C', cei, cie) ):\n        print('\\nOVERALL IT IS PLAUSIBLE!')\n    else:\n        print('\\nOVERALL IT IS IMPLAUSIBLE!')\n    print('(To be plausible, one count must exceed another by %i times)' % PLAUSIBILITY_RATIO)\n\nprint('Checking plausibility of \"I before E except after C\":')\nprint_result(*simple_stats())\n"}
{"id": 419600, "name": "I before E except after C", "source": "Translate Swift to Python: import Foundation\n\nlet request = NSURLRequest(URL: NSURL(string: \"http:\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in\n    if (data != nil) {\n        if let fileAsString = NSString(data: data, encoding: NSUTF8StringEncoding) {\n            var firstCase = false\n            var secondCase = false\n            var cie = 0\n            var cei = 0\n            var not_c_ie = 0\n            var not_c_ei = 0\n            let words = fileAsString.componentsSeparatedByString(\"\\n\")\n            for word in words {\n                var wordRegex = RegexMutable(word as String)\n                if (wordRegex[\"cie\"]) {\n                    cie++\n                }\n                if (wordRegex[\"cei\"]) {\n                    cei++\n                }\n                if (wordRegex[\"(^ie|[^c]ie)\"].matches().count != 0) {\n                    not_c_ie++\n                }\n                if (wordRegex[\"(^ei|[^c]ei)\"].matches().count != 0) {\n                    not_c_ei++\n                }\n            }\n            \n            \n            if (not_c_ie > not_c_ei * 2) {\n                println(\"I before E when not preceded by C is plausable\")\n                firstCase = true\n            } else {\n                println(\"I before E when not preceded by C is not plausable\")\n            }\n            \n            if (cei > cie * 2) {\n                secondCase = true\n                println(\"E before I when preceded by C is plausable\")\n            } else {\n                println(\"E before I when preceded by C is not plausable\")\n            }\n            \n            if (firstCase && secondCase) {\n                println(\"I before E except after C is plausible\")\n            } else {\n                println(\"I before E except after C is not plausible\")\n            }\n        }\n    }\n}\n\nCFRunLoopRun()\n", "target": "import urllib.request\nimport re\n\nPLAUSIBILITY_RATIO = 2\n\ndef plausibility_check(comment, x, y):\n    print('\\n  Checking plausibility of: %s' % comment)\n    if x > PLAUSIBILITY_RATIO * y:\n        print('    PLAUSIBLE. As we have counts of %i vs %i, a ratio of %4.1f times'\n              % (x, y, x / y))\n    else:\n        if x > y:\n            print('    IMPLAUSIBLE. As although we have counts of %i vs %i, a ratio of %4.1f times does not make it plausible'\n                  % (x, y, x / y))\n        else:\n            print('    IMPLAUSIBLE, probably contra-indicated. As we have counts of %i vs %i, a ratio of %4.1f times'\n                  % (x, y, x / y))\n    return x > PLAUSIBILITY_RATIO * y\n\ndef simple_stats(url='http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'):\n    words = urllib.request.urlopen(url).read().decode().lower().split()\n    cie = len({word for word in words if 'cie' in word})\n    cei = len({word for word in words if 'cei' in word})\n    not_c_ie = len({word for word in words if re.search(r'(^ie|[^c]ie)', word)})\n    not_c_ei = len({word for word in words if re.search(r'(^ei|[^c]ei)', word)})\n    return cei, cie, not_c_ie, not_c_ei\n\ndef print_result(cei, cie, not_c_ie, not_c_ei):\n    if ( plausibility_check('I before E when not preceded by C', not_c_ie, not_c_ei)\n         & plausibility_check('E before I when preceded by C', cei, cie) ):\n        print('\\nOVERALL IT IS PLAUSIBLE!')\n    else:\n        print('\\nOVERALL IT IS IMPLAUSIBLE!')\n    print('(To be plausible, one count must exceed another by %i times)' % PLAUSIBILITY_RATIO)\n\nprint('Checking plausibility of \"I before E except after C\":')\nprint_result(*simple_stats())\n"}
{"id": 419601, "name": "Xiaolin Wu's line algorithm", "source": "Translate Swift to Python: import Darwin\n\npublic func pixel(color: Color, x: Int, y: Int) {\n    let idx = x + y * self.width\n    if idx >= 0 && idx < self.bitmap.count {\n        self.bitmap[idx] = self.blendColors(bot: self.bitmap[idx], top: color)\n    }\n}\n\n\nfunc fpart(_ x: Double) -> Double {\n    return modf(x).1\n}\n\n\nfunc rfpart(_ x: Double) -> Double {\n    return 1 - fpart(x)\n}\n\n\npublic func smoothLine(_ p0: Point, _ p1: Point) {\n    var x0 = p0.x, x1 = p1.x, y0 = p0.y, y1 = p1.y \n    let steep = abs(y1 - y0) > abs(x1 - x0)\n    if steep {\n        swap(&x0, &y0)\n        swap(&x1, &y1)\n    }\n    if x0 > x1 {\n        swap(&x0, &x1)\n        swap(&y0, &y1)\n    }\n    let dX = x1 - x0\n    let dY = y1 - y0\n    \n    var gradient: Double\n    if dX == 0.0 {\n        gradient = 1.0\n    }\n    else {\n        gradient = dY / dX\n    }\n    \n    \n    var xend = round(x0)\n    var yend = y0 + gradient * (xend - x0)\n    var xgap = self.rfpart(x0 + 0.5)\n    let xpxl1 = Int(xend)\n    let ypxl1 = Int(yend)\n    \n    \n    var intery = yend + gradient\n    \n    if steep {\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(yend) * xgap), x: ypxl1, y: xpxl1)\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(yend) * xgap), x: ypxl1 + 1, y: xpxl1)\n    }\n    else {\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(yend) * xgap), x: xpxl1, y: ypxl1)\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(yend) * xgap), x: xpxl1, y: ypxl1 + 1)\n    }\n    \n    xend = round(x1)\n    yend = y1 + gradient * (xend - x1)\n    xgap = self.fpart(x1 + 0.5)\n    let xpxl2 = Int(xend)\n    let ypxl2 = Int(yend)\n    \n    \n    if steep {\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(yend) * xgap), x: ypxl2, y: xpxl2)\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(yend) * xgap), x: ypxl2 + 1, y: xpxl2)\n    }\n    else {\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(yend) * xgap), x: xpxl2, y: ypxl2)\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(yend) * xgap), x: xpxl2, y: ypxl2 + 1)\n    }\n    \n    \n    if steep {\n        for x in xpxl1+1..<xpxl2 {\n            self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(intery)), x: Int(intery), y: x)\n            self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(intery)), x: Int(intery) + 1, y:x)\n            intery += gradient\n        }\n    }\n    else {\n        for x in xpxl1+1..<xpxl2 {\n            self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(intery)), x: x, y: Int(intery))\n            self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(intery)), x: x, y: Int(intery) + 1)\n            intery += gradient\n        }\n    }\n}\n", "target": "\nfrom __future__ import division\nimport sys\n\nfrom PIL import Image\n\n\ndef _fpart(x):\n    return x - int(x)\n\ndef _rfpart(x):\n    return 1 - _fpart(x)\n\ndef putpixel(img, xy, color, alpha=1):\n    \n    compose_color = lambda bg, fg: int(round(alpha * fg + (1-alpha) * bg))\n    c = compose_color(img.getpixel(xy), color)\n    img.putpixel(xy, c)\n\ndef draw_line(img, p1, p2, color):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    dx, dy = x2-x1, y2-y1\n    steep = abs(dx) < abs(dy)\n    p = lambda px, py: ((px,py), (py,px))[steep]\n\n    if steep:\n        x1, y1, x2, y2, dx, dy = y1, x1, y2, x2, dy, dx\n    if x2 < x1:\n        x1, x2, y1, y2 = x2, x1, y2, y1\n\n    grad = dy/dx\n    intery = y1 + _rfpart(x1) * grad\n    def draw_endpoint(pt):\n        x, y = pt\n        xend = round(x)\n        yend = y + grad * (xend - x)\n        xgap = _rfpart(x + 0.5)\n        px, py = int(xend), int(yend)\n        putpixel(img, p(px, py), color, _rfpart(yend) * xgap)\n        putpixel(img, p(px, py+1), color, _fpart(yend) * xgap)\n        return px\n\n    xstart = draw_endpoint(p(*p1)) + 1\n    xend = draw_endpoint(p(*p2))\n\n    for x in range(xstart, xend):\n        y = int(intery)\n        putpixel(img, p(x, y), color, _rfpart(intery))\n        putpixel(img, p(x, y+1), color, _fpart(intery))\n        intery += grad\n\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2:\n        print 'usage: python xiaolinwu.py [output-file]'\n        sys.exit(-1)\n\n    blue = (0, 0, 255)\n    yellow = (255, 255, 0)\n    img = Image.new(\"RGB\", (500,500), blue)\n    for a in range(10, 431, 60):\n        draw_line(img, (10, 10), (490, a), yellow)\n        draw_line(img, (10, 10), (a, 490), yellow)\n    draw_line(img, (10, 10), (490, 490), yellow)\n    filename = sys.argv[1]\n    img.save(filename)\n    print 'image saved to', filename\n"}
{"id": 419602, "name": "Four is magic", "source": "Translate Swift to Python: import Foundation\n\nfunc fourIsMagic(_ number: NSNumber) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .spellOut\n    formatter.locale = Locale(identifier: \"en_EN\")\n\n    var result: [String] = []\n\n    var numberString = formatter.string(from: number)!\n    result.append(numberString.capitalized)\n\n    while numberString != \"four\" {\n        numberString = formatter.string(from: NSNumber(value: numberString.count))!\n        result.append(contentsOf: [\" is \", numberString, \", \", numberString])\n    }\n\n    result.append(\" is magic.\")\n    return result.joined()\n}\n\nfor testInput in [23, 1000000000, 20140, 100, 130, 151, -7] { \n    print(fourIsMagic(testInput as NSNumber))\n}\n", "target": "import random\nfrom collections import OrderedDict\n\nnumbers = {  \n    1: 'one',\n    2: 'two',\n    3: 'three',\n    4: 'four',\n    5: 'five',\n    6: 'six',\n    7: 'seven',\n    8: 'eight',\n    9: 'nine',\n    10: 'ten',\n    11: 'eleven',\n    12: 'twelve',\n    13: 'thirteen',\n    14: 'fourteen',\n    15: 'fifteen',\n    16: 'sixteen',\n    17: 'seventeen',\n    18: 'eighteen',\n    19: 'nineteen',\n    20: 'twenty',\n    30: 'thirty',\n    40: 'forty',\n    50: 'fifty',\n    60: 'sixty',\n    70: 'seventy',\n    80: 'eighty',\n    90: 'ninety',\n    100: 'hundred',\n    1000: 'thousand',\n    10 ** 6: 'million',\n    10 ** 9: 'billion',\n    10 ** 12: 'trillion',\n    10 ** 15: 'quadrillion',\n    10 ** 18: 'quintillion',\n    10 ** 21: 'sextillion',\n    10 ** 24: 'septillion',\n    10 ** 27: 'octillion',\n    10 ** 30: 'nonillion',\n    10 ** 33: 'decillion',\n    10 ** 36: 'undecillion',\n    10 ** 39: 'duodecillion',\n    10 ** 42: 'tredecillion',\n    10 ** 45: 'quattuordecillion',\n    10 ** 48: 'quinquadecillion',\n    10 ** 51: 'sedecillion',\n    10 ** 54: 'septendecillion',\n    10 ** 57: 'octodecillion',\n    10 ** 60: 'novendecillion',\n    10 ** 63: 'vigintillion',\n    10 ** 66: 'unvigintillion',\n    10 ** 69: 'duovigintillion',\n    10 ** 72: 'tresvigintillion',\n    10 ** 75: 'quattuorvigintillion',\n    10 ** 78: 'quinquavigintillion',\n    10 ** 81: 'sesvigintillion',\n    10 ** 84: 'septemvigintillion',\n    10 ** 87: 'octovigintillion',\n    10 ** 90: 'novemvigintillion',\n    10 ** 93: 'trigintillion',\n    10 ** 96: 'untrigintillion',\n    10 ** 99: 'duotrigintillion',\n    10 ** 102: 'trestrigintillion',\n    10 ** 105: 'quattuortrigintillion',\n    10 ** 108: 'quinquatrigintillion',\n    10 ** 111: 'sestrigintillion',\n    10 ** 114: 'septentrigintillion',\n    10 ** 117: 'octotrigintillion',\n    10 ** 120: 'noventrigintillion',\n    10 ** 123: 'quadragintillion',\n    10 ** 153: 'quinquagintillion',\n    10 ** 183: 'sexagintillion',\n    10 ** 213: 'septuagintillion',\n    10 ** 243: 'octogintillion',\n    10 ** 273: 'nonagintillion',\n    10 ** 303: 'centillion',\n    10 ** 306: 'uncentillion',\n    10 ** 309: 'duocentillion',\n    10 ** 312: 'trescentillion',\n    10 ** 333: 'decicentillion',\n    10 ** 336: 'undecicentillion',\n    10 ** 363: 'viginticentillion',\n    10 ** 366: 'unviginticentillion',\n    10 ** 393: 'trigintacentillion',\n    10 ** 423: 'quadragintacentillion',\n    10 ** 453: 'quinquagintacentillion',\n    10 ** 483: 'sexagintacentillion',\n    10 ** 513: 'septuagintacentillion',\n    10 ** 543: 'octogintacentillion',\n    10 ** 573: 'nonagintacentillion',\n    10 ** 603: 'ducentillion',\n    10 ** 903: 'trecentillion',\n    10 ** 1203: 'quadringentillion',\n    10 ** 1503: 'quingentillion',\n    10 ** 1803: 'sescentillion',\n    10 ** 2103: 'septingentillion',\n    10 ** 2403: 'octingentillion',\n    10 ** 2703: 'nongentillion',\n    10 ** 3003: 'millinillion'\n}\nnumbers = OrderedDict(sorted(numbers.items(), key=lambda t: t[0], reverse=True))\n\n\ndef string_representation(i: int) -> str:\n    \n    if i == 0:\n        return 'zero'\n\n    words = ['negative'] if i < 0 else []\n    working_copy = abs(i)\n\n    for key, value in numbers.items():\n        if key <= working_copy:\n            times = int(working_copy / key)\n\n            if key >= 100:\n                words.append(string_representation(times))\n\n            words.append(value)\n            working_copy -= times * key\n\n        if working_copy == 0:\n            break\n\n    return ' '.join(words)\n\n\ndef next_phrase(i: int):\n    \n    while not i == 4:  \n        str_i = string_representation(i)\n        len_i = len(str_i)\n\n        yield str_i, 'is', string_representation(len_i)\n\n        i = len_i\n\n    \n    yield string_representation(i), 'is', 'magic'\n\n\ndef magic(i: int) -> str:\n    phrases = []\n\n    for phrase in next_phrase(i):\n        phrases.append(' '.join(phrase))\n\n    return f'{\", \".join(phrases)}.'.capitalize()\n\n\nif __name__ == '__main__':\n\n    for j in (random.randint(0, 10 ** 3) for i in range(5)):\n        print(j, ':\\n', magic(j), '\\n')\n\n    for j in (random.randint(-10 ** 24, 10 ** 24) for i in range(2)):\n        print(j, ':\\n', magic(j), '\\n')\n"}
{"id": 419603, "name": "Zhang-Suen thinning algorithm", "source": "Translate Swift to Python: import UIKit\n\n\nlet beforeTxt = \"\"\"\n1100111\n1100111\n1100111\n1100111\n1100110\n1100110\n1100110\n1100110\n1100110\n1100110\n1100110\n1100110\n1111110\n0000000\n\"\"\"\n\nlet smallrc01 = \"\"\"\n00000000000000000000000000000000\n01111111110000000111111110000000\n01110001111000001111001111000000\n01110000111000001110000111000000\n01110001111000001110000000000000\n01111111110000001110000000000000\n01110111100000001110000111000000\n01110011110011101111001111011100\n01110001111011100111111110011100\n00000000000000000000000000000000\n\"\"\"\n \nlet rc01 = \"\"\"\n00000000000000000000000000000000000000000000000000000000000\n01111111111111111100000000000000000001111111111111000000000\n01111111111111111110000000000000001111111111111111000000000\n01111111111111111111000000000000111111111111111111000000000\n01111111100000111111100000000001111111111111111111000000000\n00011111100000111111100000000011111110000000111111000000000\n00011111100000111111100000000111111100000000000000000000000\n00011111111111111111000000000111111100000000000000000000000\n00011111111111111110000000000111111100000000000000000000000\n00011111111111111111000000000111111100000000000000000000000\n00011111100000111111100000000111111100000000000000000000000\n00011111100000111111100000000111111100000000000000000000000\n00011111100000111111100000000011111110000000111111000000000\n01111111100000111111100000000001111111111111111111000000000\n01111111100000111111101111110000111111111111111111011111100\n01111111100000111111101111110000001111111111111111011111100\n01111111100000111111101111110000000001111111111111011111100\n00000000000000000000000000000000000000000000000000000000000\n\"\"\"\n\n\n\nfunc zhangSuen(image: inout [[Int]]) -> [[Int]] {\n    \n    var changing1, changing2: [(Int, Int)]\n    repeat {\n        \n        changing1 = []\n        changing2 = []\n        \n        \n        for y in 1..<image.count-1 {\n            \n            for x in 1..<image[0].count-1 {\n                \n                var nb = neighbours(x: x, y: y, image: image)\n                \n                let P2 = nb[0], P4 = nb[2], P6 = nb[4], P8 = nb[6]\n                \n                \n                if (image[y][x] == 1 &&                      \n                    (2...6).contains(nb.reduce(0, +)) &&     \n                    transitions(neighbours: &nb) == 1 &&     \n                    P2 * P4 * P6 == 0 &&                     \n                    P4 * P6 * P8 == 0                        \n                ) {\n                    \n                    changing1.append((x,y))\n                }\n            }\n        }\n        \n        for (x, y) in changing1 {\n            image[y][x] = 0\n        }\n        \n        \n        for y in 1..<image.count-1 {\n            \n            for x in 1..<image[0].count-1 {\n                \n                var nb = neighbours(x: x, y: y, image: image)\n                \n                let P2 = nb[0], P4 = nb[2], P6 = nb[4], P8 = nb[6]\n                if (image[y][x] == 1 &&                      \n                    (2...6).contains(nb.reduce(0, +)) &&     \n                    transitions(neighbours: &nb) == 1 &&     \n                    P2 * P4 * P8 == 0 &&                     \n                    P2 * P6 * P8 == 0                        \n                ) {\n                    \n                    changing2.append((x,y))\n                }\n            }\n        }\n        \n        for (x, y) in changing2 {\n            image[y][x] = 0\n        }\n        \n    } while !changing1.isEmpty && !changing2.isEmpty\n    \n    return image\n}\n\n\nfunc intarray(binstring: String) -> [[Int]] {\n    \n    \n    return binstring.split(separator: \"\\n\").map {$0.compactMap{$0.wholeNumberValue}}\n}\n\n\nfunc toTxt(intmatrix: [[Int]]) -> String {\n    \n    \n    return intmatrix.map {$0.map { $0 == 1 ? \"#\" : \".\"}.joined(separator: \"\")}.joined(separator: \"\\n\")\n}\n\n\nfunc neighbours(x: Int, y: Int, image: [[Int]]) -> [Int] {\n    let i = image\n    \n    let x1 = x+1, y1 = y-1, x_1 = x-1, y_1 = y+1\n    \n    return [i[y1][x],  i[y1][x1],   i[y][x1],  i[y_1][x1],  \n            i[y_1][x], i[y_1][x_1], i[y][x_1], i[y1][x_1]]  \n}\n\n\nfunc transitions(neighbours: inout [Int]) -> Int {\n    \n    let n = neighbours + [neighbours[0]]\n    var result = 0\n    \n    \n    for (n1, n2) in zip(n, n.suffix(n.count - 1)) {\n        \n        if (n1, n2) == (0, 1) { result += 1 }\n    }\n    \n    return result\n}\n\n\n\nlet testCases: [String] = [beforeTxt, smallrc01, rc01]\nfor picture in testCases {\n    \n    var image = intarray(binstring: picture)\n    \n    print(\"\\nFrom:\\n\\(toTxt(intmatrix: image))\")\n    \n    let after = zhangSuen(image: &image)\n    \n    print(\"\\nTo thinned:\\n\\(toTxt(intmatrix: after))\")\n}\n", "target": "\n\n\nbeforeTxt = \n\n\nsmallrc01 = \n\nrc01 = \n\ndef intarray(binstring):\n    \n    return [[1 if ch == '1' else 0 for ch in line] \n            for line in binstring.strip().split()]\n\ndef chararray(intmatrix):\n    \n    return '\\n'.join(''.join(str(p) for p in row) for row in intmatrix)\n\ndef toTxt(intmatrix):\n    Return 8-neighbours of point p1 of picture, in order'''\n    i = image\n    x1, y1, x_1, y_1 = x+1, y-1, x-1, y+1\n    \n    return [i[y1][x],  i[y1][x1],   i[y][x1],  i[y_1][x1],  \n            i[y_1][x], i[y_1][x_1], i[y][x_1], i[y1][x_1]]  \n\ndef transitions(neighbours):\n    n = neighbours + neighbours[0:1]    \n    return sum((n1, n2) == (0, 1) for n1, n2 in zip(n, n[1:]))\n\ndef zhangSuen(image):\n    changing1 = changing2 = [(-1, -1)]\n    while changing1 or changing2:\n        \n        changing1 = []\n        for y in range(1, len(image) - 1):\n            for x in range(1, len(image[0]) - 1):\n                P2,P3,P4,P5,P6,P7,P8,P9 = n = neighbours(x, y, image)\n                if (image[y][x] == 1 and    \n                    P4 * P6 * P8 == 0 and   \n                    P2 * P4 * P6 == 0 and   \n                    transitions(n) == 1 and \n                    2 <= sum(n) <= 6):      \n                    changing1.append((x,y))\n        for x, y in changing1: image[y][x] = 0\n        \n        changing2 = []\n        for y in range(1, len(image) - 1):\n            for x in range(1, len(image[0]) - 1):\n                P2,P3,P4,P5,P6,P7,P8,P9 = n = neighbours(x, y, image)\n                if (image[y][x] == 1 and    \n                    P2 * P6 * P8 == 0 and   \n                    P2 * P4 * P8 == 0 and   \n                    transitions(n) == 1 and \n                    2 <= sum(n) <= 6):      \n                    changing2.append((x,y))\n        for x, y in changing2: image[y][x] = 0\n        \n        \n    return image\n            \n\nif __name__ == '__main__':\n    for picture in (beforeTxt, smallrc01, rc01):\n        image = intarray(picture)\n        print('\\nFrom:\\n%s' % toTxt(image))\n        after = zhangSuen(image)\n        print('\\nTo thinned:\\n%s' % toTxt(after))\n"}
{"id": 419604, "name": "Generate Chess960 starting position", "source": "Translate Swift to Python: func isValid960Position(_ firstRank: String) -> Bool {\n  var rooksPlaced = 0\n  var bishopColor = -1\n\n  for (i, piece) in firstRank.enumerated() {\n    switch piece {\n    case \"\u265a\" where rooksPlaced != 1:\n      return false\n    case \"\u265c\":\n      rooksPlaced += 1\n    case \"\u265d\" where bishopColor == -1:\n      bishopColor = i & 1\n    case \"\u265d\" where bishopColor == i & 1:\n      return false\n    case _:\n      continue\n    }\n  }\n\n  return true\n}\n\nstruct Chess960Counts {\n  var king = 0, queen = 0, rook = 0, bishop = 0, knight = 0\n\n  subscript(_ piece: String) -> Int {\n    get {\n      switch piece {\n      case \"\u265a\": return king\n      case \"\u265b\": return queen\n      case \"\u265c\": return rook\n      case \"\u265d\": return bishop\n      case \"\u265e\": return knight\n      case _:   fatalError()\n      }\n    }\n\n    set {\n      switch piece {\n      case \"\u265a\": king = newValue\n      case \"\u265b\": queen = newValue\n      case \"\u265c\": rook = newValue\n      case \"\u265d\": bishop = newValue\n      case \"\u265e\": knight = newValue\n      case _:   fatalError()\n      }\n    }\n  }\n}\n\nfunc get960Position() -> String {\n  var counts = Chess960Counts()\n  var bishopColor = -1 \n  var output = \"\"\n\n  for i in 1...8 {\n    let validPieces = [\n      counts[\"\u265c\"] == 1 && counts[\"\u265a\"] == 0 ? \"\u265a\" : nil, \n      i == 1 || (counts[\"\u265b\"] == 0) ? \"\u265b\" : nil, \n      i == 1 || (counts[\"\u265c\"] == 0 || counts[\"\u265c\"] < 2 && counts[\"\u265a\"] == 1) ? \"\u265c\" : nil, \n      i == 1 || (counts[\"\u265d\"] < 2 && bishopColor == -1 || bishopColor != i & 1) ? \"\u265d\" : nil, \n      i == 1 || (counts[\"\u265e\"] < 2) ? \"\u265e\" : nil \n    ].lazy.compactMap({ $0 })\n\n    guard let chosenPiece = validPieces.randomElement() else {\n      \n      output.insert(\"\u265d\", at: output.index(before: output.endIndex))\n\n      break\n    }\n\n    counts[chosenPiece] += 1\n    output += chosenPiece\n\n    if bishopColor == -1 && chosenPiece == \"\u265d\" {\n      bishopColor = i & 1\n    }\n  }\n\n  assert(isValid960Position(output), \"invalid 960 position \\(output)\")\n\n  return output\n}\n\nvar positions = Set<String>()\n\nwhile positions.count != 960 {\n  positions.insert(get960Position())\n}\n\nprint(positions.count, positions.randomElement()!)\n", "target": ">>> from itertools import permutations\n>>> pieces = 'KQRrBbNN'\n>>> starts = {''.join(p).upper() for p in permutations(pieces)\n                     if p.index('B') % 2 != p.index('b') % 2 \t\t\n                     and ( p.index('r') < p.index('K') < p.index('R')\t\n                           or p.index('R') < p.index('K') < p.index('r') ) }\n>>> len(starts)\n960\n>>> starts.pop()\n'QNBRNKRB'\n>>>\n"}
{"id": 419605, "name": "Spelling of ordinal numbers", "source": "Translate Swift to Python: fileprivate class NumberNames {\n    let cardinal: String\n    let ordinal: String\n\n    init(cardinal: String, ordinal: String) {\n        self.cardinal = cardinal\n        self.ordinal = ordinal\n    }\n    \n    func getName(_ ordinal: Bool) -> String {\n        return ordinal ? self.ordinal : self.cardinal\n    }\n    \n    class func numberName(number: Int, ordinal: Bool) -> String {\n        guard number < 100 else {\n            return \"\"\n        }\n        if number < 20 {\n            return smallNames[number].getName(ordinal)\n        }\n        if number % 10 == 0 {\n            return tens[number/10 - 2].getName(ordinal)\n        }\n        var result = tens[number/10 - 2].getName(false)\n        result += \"-\"\n        result += smallNames[number % 10].getName(ordinal)\n        return result\n    }\n    \n    static let smallNames = [\n        NumberNames(cardinal: \"zero\", ordinal: \"zeroth\"),\n        NumberNames(cardinal: \"one\", ordinal: \"first\"),\n        NumberNames(cardinal: \"two\", ordinal: \"second\"),\n        NumberNames(cardinal: \"three\", ordinal: \"third\"),\n        NumberNames(cardinal: \"four\", ordinal: \"fourth\"),\n        NumberNames(cardinal: \"five\", ordinal: \"fifth\"),\n        NumberNames(cardinal: \"six\", ordinal: \"sixth\"),\n        NumberNames(cardinal: \"seven\", ordinal: \"seventh\"),\n        NumberNames(cardinal: \"eight\", ordinal: \"eighth\"),\n        NumberNames(cardinal: \"nine\", ordinal: \"ninth\"),\n        NumberNames(cardinal: \"ten\", ordinal: \"tenth\"),\n        NumberNames(cardinal: \"eleven\", ordinal: \"eleventh\"),\n        NumberNames(cardinal: \"twelve\", ordinal: \"twelfth\"),\n        NumberNames(cardinal: \"thirteen\", ordinal: \"thirteenth\"),\n        NumberNames(cardinal: \"fourteen\", ordinal: \"fourteenth\"),\n        NumberNames(cardinal: \"fifteen\", ordinal: \"fifteenth\"),\n        NumberNames(cardinal: \"sixteen\", ordinal: \"sixteenth\"),\n        NumberNames(cardinal: \"seventeen\", ordinal: \"seventeenth\"),\n        NumberNames(cardinal: \"eighteen\", ordinal: \"eighteenth\"),\n        NumberNames(cardinal: \"nineteen\", ordinal: \"nineteenth\")\n    ]\n\n    static let tens = [\n        NumberNames(cardinal: \"twenty\", ordinal: \"twentieth\"),\n        NumberNames(cardinal: \"thirty\", ordinal: \"thirtieth\"),\n        NumberNames(cardinal: \"forty\", ordinal: \"fortieth\"),\n        NumberNames(cardinal: \"fifty\", ordinal: \"fiftieth\"),\n        NumberNames(cardinal: \"sixty\", ordinal: \"sixtieth\"),\n        NumberNames(cardinal: \"seventy\", ordinal: \"seventieth\"),\n        NumberNames(cardinal: \"eighty\", ordinal: \"eightieth\"),\n        NumberNames(cardinal: \"ninety\", ordinal: \"ninetieth\")\n    ]\n}\n\nfileprivate class NamedPower {\n    let cardinal: String\n    let ordinal: String\n    let number: UInt64\n    \n    init(cardinal: String, ordinal: String, number: UInt64) {\n        self.cardinal = cardinal\n        self.ordinal = ordinal\n        self.number = number\n    }\n    \n    func getName(_ ordinal: Bool) -> String {\n        return ordinal ? self.ordinal : self.cardinal\n    }\n\n    class func getNamedPower(_ number: UInt64) -> NamedPower {\n        for i in 1..<namedPowers.count {\n            if number < namedPowers[i].number {\n                return namedPowers[i - 1]\n            }\n        }\n        return namedPowers[namedPowers.count - 1]\n    }\n\n    static let namedPowers = [\n        NamedPower(cardinal: \"hundred\", ordinal: \"hundredth\",\n                   number: 100),\n        NamedPower(cardinal: \"thousand\", ordinal: \"thousandth\",\n                   number: 1000),\n        NamedPower(cardinal: \"million\", ordinal: \"millionth\",\n                   number: 1000000),\n        NamedPower(cardinal: \"billion\", ordinal: \"billionth\",\n                   number: 1000000000),\n        NamedPower(cardinal: \"trillion\", ordinal: \"trillionth\",\n                   number: 1000000000000),\n        NamedPower(cardinal: \"quadrillion\", ordinal: \"quadrillionth\",\n                   number: 1000000000000000),\n        NamedPower(cardinal: \"quintillion\", ordinal: \"quintillionth\",\n                   number: 1000000000000000000)\n    ]\n}\n\npublic func numberName(number: UInt64, ordinal: Bool) -> String {\n    if number < 100 {\n        return NumberNames.numberName(number: Int(truncatingIfNeeded: number),\n                                      ordinal: ordinal)\n    }\n    let p = NamedPower.getNamedPower(number)\n    var result = numberName(number: number/p.number, ordinal: false)\n    result += \" \"\n    if number % p.number == 0 {\n        result += p.getName(ordinal)\n    } else {\n        result += p.getName(false)\n        result += \" \"\n        result += numberName(number: number % p.number, ordinal: ordinal)\n    }\n    return result\n}\n\nfunc printOrdinal(_ number: UInt64) {\n    print(\"\\(number): \\(numberName(number: number, ordinal: true))\")\n}\n\nprintOrdinal(1)\nprintOrdinal(2)\nprintOrdinal(3)\nprintOrdinal(4)\nprintOrdinal(5)\nprintOrdinal(11)\nprintOrdinal(15)\nprintOrdinal(21)\nprintOrdinal(42)\nprintOrdinal(65)\nprintOrdinal(98)\nprintOrdinal(100)\nprintOrdinal(101)\nprintOrdinal(272)\nprintOrdinal(300)\nprintOrdinal(750)\nprintOrdinal(23456)\nprintOrdinal(7891233)\nprintOrdinal(8007006005004003)\n", "target": "irregularOrdinals = {\n\t\"one\":    \"first\",\n\t\"two\":    \"second\",\n\t\"three\":  \"third\",\n\t\"five\":   \"fifth\",\n\t\"eight\":  \"eighth\",\n\t\"nine\":   \"ninth\",\n\t\"twelve\": \"twelfth\",\n}\n\ndef num2ordinal(n):\n    conversion = int(float(n))\n    num = spell_integer(conversion)\n    hyphen = num.rsplit(\"-\", 1)\n    num = num.rsplit(\" \", 1)\n    delim = \" \"\n    if len(num[-1]) > len(hyphen[-1]):\n        num = hyphen\n        delim = \"-\"\n    \n    if num[-1] in irregularOrdinals:\n        num[-1] = delim + irregularOrdinals[num[-1]]\n    elif num[-1].endswith(\"y\"):\n        num[-1] = delim + num[-1][:-1] + \"ieth\"\n    else:\n        num[-1] = delim + num[-1] + \"th\"\n    return \"\".join(num)\n    \nif __name__ == \"__main__\":\n    tests = \"1  2  3  4  5  11  65  100  101  272  23456  8007006005004003 123   00123.0   1.23e2\".split()\n    for num in tests:\n        print(\"{} => {}\".format(num, num2ordinal(num)))\n\n\n\n\nTENS = [None, None, \"twenty\", \"thirty\", \"forty\",\n        \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\nSMALL = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n         \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\",\n         \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n         \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\nHUGE = [None, None] + [h + \"illion\" \n                       for h in (\"m\", \"b\", \"tr\", \"quadr\", \"quint\", \"sext\", \n                                  \"sept\", \"oct\", \"non\", \"dec\")]\n \ndef nonzero(c, n, connect=''):\n    return \"\" if n == 0 else connect + c + spell_integer(n)\n \ndef last_and(num):\n    if ',' in num:\n        pre, last = num.rsplit(',', 1)\n        if ' and ' not in last:\n            last = ' and' + last\n        num = ''.join([pre, ',', last])\n    return num\n \ndef big(e, n):\n    if e == 0:\n        return spell_integer(n)\n    elif e == 1:\n        return spell_integer(n) + \" thousand\"\n    else:\n        return spell_integer(n) + \" \" + HUGE[e]\n \ndef base1000_rev(n):\n    \n    \n    while n != 0:\n        n, r = divmod(n, 1000)\n        yield r\n \ndef spell_integer(n):\n    if n < 0:\n        return \"minus \" + spell_integer(-n)\n    elif n < 20:\n        return SMALL[n]\n    elif n < 100:\n        a, b = divmod(n, 10)\n        return TENS[a] + nonzero(\"-\", b)\n    elif n < 1000:\n        a, b = divmod(n, 100)\n        return SMALL[a] + \" hundred\" + nonzero(\" \", b, ' and')\n    else:\n        num = \", \".join([big(e, x) for e, x in\n                         enumerate(base1000_rev(n)) if x][::-1])\n        return last_and(num)\n"}
{"id": 419606, "name": "Machine code", "source": "Translate Swift to Python: import Foundation\n\ntypealias TwoIntsOneInt = @convention(c) (Int, Int) -> Int\n\nlet code = [\n  144, \n  144,\n  106, 12, \n  184, 7, 0, 0, 0,\n  72, 193, 224, 32,\n  80,\n  139, 68, 36, 4, 3, 68, 36, 8, \n  76, 137, 227, \n  137, 195,\n  72, 193, 227, 4,\n  128, 203, 2,\n  72, 131, 196, 16, \n  195, \n] as [UInt8]\n\nfunc fudge(x: Int, y: Int) -> Int {\n  let buf = mmap(nil, code.count, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, -1, 0)\n\n  memcpy(buf, code, code.count)\n\n  let fun = unsafeBitCast(buf, to: TwoIntsOneInt.self)\n  let ret = fun(x, y)\n\n  munmap(buf, code.count)\n\n  return ret\n}\n\nprint(fudge(x: 7, y: 12))\n", "target": "import ctypes\nimport os\nfrom ctypes import c_ubyte, c_int\n\ncode = bytes([0x8b, 0x44, 0x24, 0x04, 0x03, 0x44, 0x24, 0x08, 0xc3])\n\ncode_size = len(code)\n\nif (os.name == 'posix'):\n    import mmap\n    executable_map = mmap.mmap(-1, code_size, mmap.MAP_PRIVATE | mmap.MAP_ANON, mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC)\n    \n    executable_map.write(code)\n    \n    \n    func_address = ctypes.addressof(c_ubyte.from_buffer(executable_map))\nelif (os.name == 'nt'):\n    \n    code_buffer = ctypes.create_string_buffer(code)\n    PAGE_EXECUTE_READWRITE = 0x40  \n    MEM_COMMIT = 0x1000\n    executable_buffer_address = ctypes.windll.kernel32.VirtualAlloc(0, code_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE)\n    if (executable_buffer_address == 0):\n        print('Warning: Failed to enable code execution, call will likely cause a protection fault.')\n        func_address = ctypes.addressof(code_buffer)\n    else:\n        ctypes.memmove(executable_buffer_address, code_buffer, code_size)\n        func_address = executable_buffer_address\nelse:\n    \n    code_buffer = ctypes.create_string_buffer(code)\n    func_address = ctypes.addressof(code_buffer)\n\nprototype = ctypes.CFUNCTYPE(c_int, c_ubyte, c_ubyte) \nfunc = prototype(func_address)                        \nres = func(7,12)\nprint(res)\n"}
{"id": 419607, "name": "Chemical calculator", "source": "Translate Swift to Python: import Foundation\n\nstruct Chem {\n  struct Molecule {\n    var formula: String\n    var parts: [Molecule]\n    var quantity = 1\n\n    var molarMass: Double {\n      switch parts.count {\n      case 0:\n        return Chem.atomicWeights[formula]! * Double(quantity)\n      case _:\n        return parts.lazy.map({ $0.molarMass }).reduce(0, +) * Double(quantity)\n      }\n    }\n\n    private init(formula: String, parts: [Molecule], quantity: Int) {\n      self.formula = formula\n      self.parts = parts\n      self.quantity = quantity\n    }\n\n    init?(fromString str: String) {\n      guard let mol = Molecule.parseString(str[...]) else {\n        return nil\n      }\n\n      self = mol\n    }\n\n    private static func parseString(_ str: Substring) -> Molecule? {\n      guard !str.isEmpty else {\n        return nil\n      }\n\n      var parts = [Molecule]()\n      var workingMol = \"\"\n      var idx = str.startIndex\n\n      func completeAtom() -> Bool {\n        guard Chem.atomicWeights.keys.contains(workingMol) else {\n          return false\n        }\n\n        parts.append(Molecule(formula: workingMol, parts: [], quantity: 1))\n        workingMol = \"\"\n\n        return true\n      }\n\n      while idx != str.endIndex {\n        let char = str[idx]\n\n        guard char.isASCII else {\n          return nil\n        }\n\n        if (char.isUppercase || char == \"(\" || char.isNumber) && !workingMol.isEmpty {\n          guard completeAtom() else {\n            return nil\n          }\n        }\n\n        if char == \"(\" {\n          var parenLevel = 1\n\n          let subMolStart = str.index(after: idx)\n          idx = subMolStart\n\n          while parenLevel != 0 {\n            guard idx != str.endIndex else {\n              return nil\n            }\n\n            if str[idx] == \"(\" {\n              parenLevel += 1\n            } else if str[idx] == \")\" {\n              parenLevel -= 1\n            }\n\n            if parenLevel != 0 {\n              idx = str.index(after: idx)\n            }\n          }\n\n          guard let subMol = parseString(str[subMolStart..<idx]) else {\n            return nil\n          }\n\n          parts.append(subMol)\n\n          idx = str.index(after: idx)\n\n          continue\n        } else if char == \")\" {\n          fatalError()\n        }\n\n        workingMol.append(char)\n\n        if char.isNumber {\n          guard !parts.isEmpty else {\n            return nil\n          }\n\n          var workNum = workingMol\n\n          idx = str.index(after: idx)\n\n          while idx != str.endIndex && str[idx].isNumber {\n            workNum.append(str[idx])\n            idx = str.index(after: idx)\n          }\n\n          parts[parts.count - 1].quantity = Int(workNum)!\n          workingMol = \"\"\n\n          continue\n        }\n\n        idx = str.index(after: idx)\n      }\n\n      guard workingMol.isEmpty || completeAtom() else {\n        return nil\n      }\n\n      return Molecule(formula: String(str), parts: parts, quantity: 1)\n    }\n  }\n\n  static func calculateMolarMass(of chem: String) -> Double? {\n    guard let mol = Molecule(fromString: chem) else {\n      return nil\n    }\n\n    return mol.molarMass\n  }\n\n  fileprivate static let atomicWeights = [\n    \"H\":  1.008,\n    \"He\": 4.002602,\n    \"Li\": 6.94,\n    \"Be\": 9.0121831,\n    \"B\": 10.81,\n    \"C\": 12.011,\n    \"N\": 14.007,\n    \"O\": 15.999,\n    \"F\": 18.998403163,\n    \"Ne\": 20.1797,\n    \"Na\": 22.98976928,\n    \"Mg\": 24.305,\n    \"Al\": 26.9815385,\n    \"Si\": 28.085,\n    \"P\": 30.973761998,\n    \"S\": 32.06,\n    \"Cl\": 35.45,\n    \"K\": 39.0983,\n    \"Ar\": 39.948,\n    \"Ca\": 40.078,\n    \"Sc\": 44.955908,\n    \"Ti\": 47.867,\n    \"V\": 50.9415,\n    \"Cr\": 51.9961,\n    \"Mn\": 54.938044,\n    \"Fe\": 55.845,\n    \"Ni\": 58.6934,\n    \"Co\": 58.933194,\n    \"Cu\": 63.546,\n    \"Zn\": 65.38,\n    \"Ga\": 69.723,\n    \"Ge\": 72.63,\n    \"As\": 74.921595,\n    \"Se\": 78.971,\n    \"Br\": 79.904,\n    \"Kr\": 83.798,\n    \"Rb\": 85.4678,\n    \"Sr\": 87.62,\n    \"Y\": 88.90584,\n    \"Zr\": 91.224,\n    \"Nb\": 92.90637,\n    \"Mo\": 95.95,\n    \"Ru\": 101.07,\n    \"Rh\": 102.9055,\n    \"Pd\": 106.42,\n    \"Ag\": 107.8682,\n    \"Cd\": 112.414,\n    \"In\": 114.818,\n    \"Sn\": 118.71,\n    \"Sb\": 121.76,\n    \"I\": 126.90447,\n    \"Te\": 127.6,\n    \"Xe\": 131.293,\n    \"Cs\": 132.90545196,\n    \"Ba\": 137.327,\n    \"La\": 138.90547,\n    \"Ce\": 140.116,\n    \"Pr\": 140.90766,\n    \"Nd\": 144.242,\n    \"Pm\": 145,\n    \"Sm\": 150.36,\n    \"Eu\": 151.964,\n    \"Gd\": 157.25,\n    \"Tb\": 158.92535,\n    \"Dy\": 162.5,\n    \"Ho\": 164.93033,\n    \"Er\": 167.259,\n    \"Tm\": 168.93422,\n    \"Yb\": 173.054,\n    \"Lu\": 174.9668,\n    \"Hf\": 178.49,\n    \"Ta\": 180.94788,\n    \"W\": 183.84,\n    \"Re\": 186.207,\n    \"Os\": 190.23,\n    \"Ir\": 192.217,\n    \"Pt\": 195.084,\n    \"Au\": 196.966569,\n    \"Hg\": 200.592,\n    \"Tl\": 204.38,\n    \"Pb\": 207.2,\n    \"Bi\": 208.9804,\n    \"Po\": 209,\n    \"At\": 210,\n    \"Rn\": 222,\n    \"Fr\": 223,\n    \"Ra\": 226,\n    \"Ac\": 227,\n    \"Pa\": 231.03588,\n    \"Th\": 232.0377,\n    \"Np\": 237,\n    \"U\": 238.02891,\n    \"Am\": 243,\n    \"Pu\": 244,\n    \"Cm\": 247,\n    \"Bk\": 247,\n    \"Cf\": 251,\n    \"Es\": 252,\n    \"Fm\": 257,\n    \"Ubn\": 299,\n    \"Uue\": 315\n  ]\n}\n\nlet testCases = [\n  (\"H\", \"1.008\"),\n  (\"H2\", \"2.016\"),\n  (\"H2O\", \"18.015\"),\n  (\"H2O2\", \"34.014\"),\n  (\"(HO)2\", \"34.014\"),\n  (\"Na2SO4\", \"142.036\"),\n  (\"C6H12\", \"84.162\"),\n  (\"COOH(C(CH3)2)3CH3\", \"186.295\"),\n  (\"C6H4O2(OH)4\", \"176.124\"),\n  (\"C27H46O\", \"386.664\"),\n  (\"Uue\", \"315.000\")\n]\n\nlet fmt = { String(format: \"%.3f\", $0) }\n\nfor (mol, expected) in testCases {\n  guard let mass = Chem.calculateMolarMass(of: mol) else {\n    fatalError(\"Bad formula \\(mol)\")\n  }\n\n  assert(fmt(mass) == expected, \"Incorrect result\")\n\n  print(\"\\(mol) => \\(fmt(mass))\")\n}\n", "target": "assert   1.008 == molar_mass('H')                  \nassert   2.016 == molar_mass('H2')                 \nassert  18.015 == molar_mass('H2O')                \nassert  34.014 == molar_mass('H2O2')               \nassert  34.014 == molar_mass('(HO)2')              \nassert 142.036 == molar_mass('Na2SO4')             \nassert  84.162 == molar_mass('C6H12')              \nassert 186.295 == molar_mass('COOH(C(CH3)2)3CH3')  \nassert 176.124 == molar_mass('C6H4O2(OH)4')        \nassert 386.664 == molar_mass('C27H46O')            \nassert 315     == molar_mass('Uue')                \n"}
{"id": 419608, "name": "Farey sequence", "source": "Translate Swift to Python: class Farey {\n    let n: Int\n\n    init(_ x: Int) {\n        n = x\n    }\n\n    \n    var sequence: [(Int,Int)] {\n        var a = 0\n        var b = 1\n        var c = 1\n        var d = n\n        var results = [(a, b)]\n        while c <= n {\n            let k = (n + b) / d\n            let oldA = a\n            let oldB = b\n            a = c\n            b = d\n            c = k * c - oldA\n            d = k * d - oldB\n            results += [(a, b)]\n        }\n        return results\n    }\n\n    var formattedSequence: String {\n        var s = \"\\(n):\"\n        for pair in sequence {\n            s += \" \\(pair.0)/\\(pair.1)\"\n        }\n        return s\n    }\n\n}\n\nprint(\"Sequences\\n\")\n\nfor n in 1...11 {\n    print(Farey(n).formattedSequence)\n}\n\nprint(\"\\nSequence Lengths\\n\")\n\nfor n in 1...10 {\n    let m = n * 100\n    print(\"\\(m): \\(Farey(m).sequence.count)\")\n}\n", "target": "from fractions import Fraction\n\n\nclass Fr(Fraction):\n    def __repr__(self):\n        return '(%s/%s)' % (self.numerator, self.denominator)\n\n\ndef farey(n, length=False):\n    if not length:\n        return [Fr(0, 1)] + sorted({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})\n    else:\n        \n        return  (n*(n+3))//2 - sum(farey(n//k, True) for k in range(2, n+1))\n        \nif __name__ == '__main__':\n    print('Farey sequence for order 1 through 11 (inclusive):')\n    for n in range(1, 12): \n        print(farey(n))\n    print('Number of fractions in the Farey sequence for order 100 through 1,000 (inclusive) by hundreds:')\n    print([farey(i, length=True) for i in range(100, 1001, 100)])\n"}
{"id": 419609, "name": "Farey sequence", "source": "Translate Swift to Python: class Farey {\n    let n: Int\n\n    init(_ x: Int) {\n        n = x\n    }\n\n    \n    var sequence: [(Int,Int)] {\n        var a = 0\n        var b = 1\n        var c = 1\n        var d = n\n        var results = [(a, b)]\n        while c <= n {\n            let k = (n + b) / d\n            let oldA = a\n            let oldB = b\n            a = c\n            b = d\n            c = k * c - oldA\n            d = k * d - oldB\n            results += [(a, b)]\n        }\n        return results\n    }\n\n    var formattedSequence: String {\n        var s = \"\\(n):\"\n        for pair in sequence {\n            s += \" \\(pair.0)/\\(pair.1)\"\n        }\n        return s\n    }\n\n}\n\nprint(\"Sequences\\n\")\n\nfor n in 1...11 {\n    print(Farey(n).formattedSequence)\n}\n\nprint(\"\\nSequence Lengths\\n\")\n\nfor n in 1...10 {\n    let m = n * 100\n    print(\"\\(m): \\(Farey(m).sequence.count)\")\n}\n", "target": "from fractions import Fraction\n\n\nclass Fr(Fraction):\n    def __repr__(self):\n        return '(%s/%s)' % (self.numerator, self.denominator)\n\n\ndef farey(n, length=False):\n    if not length:\n        return [Fr(0, 1)] + sorted({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})\n    else:\n        \n        return  (n*(n+3))//2 - sum(farey(n//k, True) for k in range(2, n+1))\n        \nif __name__ == '__main__':\n    print('Farey sequence for order 1 through 11 (inclusive):')\n    for n in range(1, 12): \n        print(farey(n))\n    print('Number of fractions in the Farey sequence for order 100 through 1,000 (inclusive) by hundreds:')\n    print([farey(i, length=True) for i in range(100, 1001, 100)])\n"}
{"id": 419610, "name": "Aliquot sequence classifications", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\nstruct SeqClass: CustomStringConvertible {\n  var seq: [Int]\n  var desc: String\n\n  var description: String {\n    return \"\\(desc):    \\(seq)\"\n  }\n}\n\nfunc classifySequence(k: Int, threshold: Int = 1 << 47) -> SeqClass {\n  var last = k\n  var seq = [k]\n\n  while true {\n    last = last.factors().dropLast().reduce(0, +)\n    seq.append(last)\n\n    let n = seq.count\n\n    if last == 0 {\n      return SeqClass(seq: seq, desc: \"Terminating\")\n    } else if n == 2 && last == k {\n      return SeqClass(seq: seq, desc: \"Perfect\")\n    } else if n == 3 && last == k {\n      return SeqClass(seq: seq, desc: \"Amicable\")\n    } else if n >= 4 && last == k {\n      return SeqClass(seq: seq, desc: \"Sociable[\\(n - 1)]\")\n    } else if last == seq[n - 2] {\n      return SeqClass(seq: seq, desc: \"Aspiring\")\n    } else if seq.dropFirst().dropLast(2).contains(last) {\n      return SeqClass(seq: seq, desc: \"Cyclic[\\(n - 1 - seq.firstIndex(of: last)!)]\")\n    } else if n == 16 || last > threshold {\n      return SeqClass(seq: seq, desc: \"Non-terminating\")\n    }\n  }\n\n  fatalError()\n}\n\nfor i in 1...10 {\n  print(\"\\(i): \\(classifySequence(k: i))\")\n}\n\nprint()\n\nfor i in [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488] {\n  print(\"\\(i): \\(classifySequence(k: i))\")\n}\n\nprint()\n\nprint(\"\\(15355717786080): \\(classifySequence(k: 15355717786080))\")\n", "target": "from proper_divisors import proper_divs\nfrom functools import lru_cache\n\n\n@lru_cache()\ndef pdsum(n): \n    return sum(proper_divs(n))\n    \n    \ndef aliquot(n, maxlen=16, maxterm=2**47):\n    if n == 0:\n        return 'terminating', [0]\n    s, slen, new = [n], 1, n\n    while slen <= maxlen and new < maxterm:\n        new = pdsum(s[-1])\n        if new in s:\n            if s[0] == new:\n                if slen == 1:\n                    return 'perfect', s\n                elif slen == 2:\n                    return 'amicable', s\n                else:\n                    return 'sociable of length %i' % slen, s\n            elif s[-1] == new:\n                return 'aspiring', s\n            else:\n                return 'cyclic back to %i' % new, s\n        elif new == 0:\n            return 'terminating', s + [0]\n        else:\n            s.append(new)\n            slen += 1\n    else:\n        return 'non-terminating', s\n                \nif __name__ == '__main__':\n    for n in range(1, 11): \n        print('%s: %r' % aliquot(n))\n    print()\n    for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]: \n        print('%s: %r' % aliquot(n))\n"}
{"id": 419611, "name": "Aliquot sequence classifications", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\nstruct SeqClass: CustomStringConvertible {\n  var seq: [Int]\n  var desc: String\n\n  var description: String {\n    return \"\\(desc):    \\(seq)\"\n  }\n}\n\nfunc classifySequence(k: Int, threshold: Int = 1 << 47) -> SeqClass {\n  var last = k\n  var seq = [k]\n\n  while true {\n    last = last.factors().dropLast().reduce(0, +)\n    seq.append(last)\n\n    let n = seq.count\n\n    if last == 0 {\n      return SeqClass(seq: seq, desc: \"Terminating\")\n    } else if n == 2 && last == k {\n      return SeqClass(seq: seq, desc: \"Perfect\")\n    } else if n == 3 && last == k {\n      return SeqClass(seq: seq, desc: \"Amicable\")\n    } else if n >= 4 && last == k {\n      return SeqClass(seq: seq, desc: \"Sociable[\\(n - 1)]\")\n    } else if last == seq[n - 2] {\n      return SeqClass(seq: seq, desc: \"Aspiring\")\n    } else if seq.dropFirst().dropLast(2).contains(last) {\n      return SeqClass(seq: seq, desc: \"Cyclic[\\(n - 1 - seq.firstIndex(of: last)!)]\")\n    } else if n == 16 || last > threshold {\n      return SeqClass(seq: seq, desc: \"Non-terminating\")\n    }\n  }\n\n  fatalError()\n}\n\nfor i in 1...10 {\n  print(\"\\(i): \\(classifySequence(k: i))\")\n}\n\nprint()\n\nfor i in [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488] {\n  print(\"\\(i): \\(classifySequence(k: i))\")\n}\n\nprint()\n\nprint(\"\\(15355717786080): \\(classifySequence(k: 15355717786080))\")\n", "target": "from proper_divisors import proper_divs\nfrom functools import lru_cache\n\n\n@lru_cache()\ndef pdsum(n): \n    return sum(proper_divs(n))\n    \n    \ndef aliquot(n, maxlen=16, maxterm=2**47):\n    if n == 0:\n        return 'terminating', [0]\n    s, slen, new = [n], 1, n\n    while slen <= maxlen and new < maxterm:\n        new = pdsum(s[-1])\n        if new in s:\n            if s[0] == new:\n                if slen == 1:\n                    return 'perfect', s\n                elif slen == 2:\n                    return 'amicable', s\n                else:\n                    return 'sociable of length %i' % slen, s\n            elif s[-1] == new:\n                return 'aspiring', s\n            else:\n                return 'cyclic back to %i' % new, s\n        elif new == 0:\n            return 'terminating', s + [0]\n        else:\n            s.append(new)\n            slen += 1\n    else:\n        return 'non-terminating', s\n                \nif __name__ == '__main__':\n    for n in range(1, 11): \n        print('%s: %r' % aliquot(n))\n    print()\n    for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]: \n        print('%s: %r' % aliquot(n))\n"}
{"id": 419612, "name": "Taxicab numbers", "source": "Translate Swift to Python: extension Array {\n  func combinations(_ k: Int) -> [[Element]] {\n    return Self._combinations(slice: self[startIndex...], k)\n  }\n\n  static func _combinations(slice: Self.SubSequence, _ k: Int) -> [[Element]] {\n    guard k != 1 else {\n      return slice.map({ [$0] })\n    }\n\n    guard k != slice.count else {\n      return [slice.map({ $0 })]\n    }\n\n    let chopped = slice[slice.index(after: slice.startIndex)...]\n\n    var res = _combinations(slice: chopped, k - 1).map({ [[slice.first!], $0].flatMap({ $0 }) })\n\n    res += _combinations(slice: chopped, k)\n\n    return res\n  }\n}\n\nlet cubes = (1...).lazy.map({ $0 * $0 * $0 })\nlet taxis =\n  Array(cubes.prefix(1201))\n    .combinations(2)\n    .reduce(into: [Int: [[Int]]](), { $0[$1[0] + $1[1], default: []].append($1) })\n\n\nlet res =\n  taxis\n    .lazy\n    .filter({ $0.value.count > 1 })\n    .sorted(by: { $0.key < $1.key })\n    .map({ ($0.key, $0.value) })\n    .prefix(2006)\n\nprint(\"First 25 taxicab numbers:\")\nfor taxi in res[..<25] {\n  print(taxi)\n}\n\nprint(\"\\n2000th through 2006th taxicab numbers:\")\nfor taxi in res[1999..<2006] {\n  print(taxi)\n}\n", "target": "from collections import defaultdict\nfrom itertools import product\nfrom pprint import pprint as pp\n\ncube2n = {x**3:x for x in range(1, 1201)}\nsum2cubes = defaultdict(set)\nfor c1, c2 in product(cube2n, cube2n):\n\tif c1 >= c2: sum2cubes[c1 + c2].add((cube2n[c1], cube2n[c2]))\n\t\ntaxied = sorted((k, v) for k,v in sum2cubes.items() if len(v) >= 2)\n\n\nfor t in enumerate(taxied[:25], 1):\n    pp(t)\nprint('...')    \nfor t in enumerate(taxied[2000-1:2000+6], 2000):\n    pp(t)\n"}
{"id": 419613, "name": "Strong and weak primes", "source": "Translate Swift to Python: import Foundation\n\nclass PrimeSieve {\n    var composite: [Bool]\n    \n    init(size: Int) {\n        composite = Array(repeating: false, count: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite[p/2 - 1] {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite[q/2 - 1] = true\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite[number/2 - 1]\n    }\n}\n\nfunc commatize(_ number: Int) -> String {\n    let n = NSNumber(value: number)\n    return NumberFormatter.localizedString(from: n, number: .decimal)\n}\n\nlet limit1 = 1000000\nlet limit2 = 10000000\n\nclass PrimeInfo {\n    let maxPrint: Int\n    var count1: Int\n    var count2: Int\n    var primes: [Int]\n    \n    init(maxPrint: Int) {\n        self.maxPrint = maxPrint\n        count1 = 0\n        count2 = 0\n        primes = []\n    }\n    \n    func addPrime(prime: Int) {\n        count2 += 1\n        if prime < limit1 {\n            count1 += 1\n        }\n        if count2 <= maxPrint {\n            primes.append(prime)\n        }\n    }\n    \n    func printInfo(name: String) {\n        print(\"First \\(maxPrint) \\(name) primes: \\(primes)\")\n        print(\"Number of \\(name) primes below \\(commatize(limit1)): \\(commatize(count1))\")\n        print(\"Number of \\(name) primes below \\(commatize(limit2)): \\(commatize(count2))\")\n    }\n}\n\nvar strongPrimes = PrimeInfo(maxPrint: 36)\nvar weakPrimes = PrimeInfo(maxPrint: 37)\n\nlet sieve = PrimeSieve(size: limit2 + 100)\n\nvar p1 = 2, p2 = 3, p3 = 5\nwhile p2 < limit2 {\n    if sieve.isPrime(number: p3) {\n        let diff = p1 + p3 - 2 * p2\n        if diff < 0 {\n            strongPrimes.addPrime(prime: p2)\n        } else if diff > 0 {\n            weakPrimes.addPrime(prime: p2)\n        }\n        p1 = p2\n        p2 = p3\n    }\n    p3 += 2\n}\n\nstrongPrimes.printInfo(name: \"strong\")\nweakPrimes.printInfo(name: \"weak\")\n", "target": "import numpy as np\n\ndef primesfrom2to(n):\n    \n    \n    sieve = np.ones(n//3 + (n%6==2), dtype=np.bool)\n    sieve[0] = False\n    for i in range(int(n**0.5)//3+1):\n        if sieve[i]:\n            k=3*i+1|1\n            sieve[      ((k*k)//3)      ::2*k] = False\n            sieve[(k*k+4*k-2*k*(i&1))//3::2*k] = False\n    return np.r_[2,3,((3*np.nonzero(sieve)[0]+1)|1)]\n\np = primes10m   = primesfrom2to(10_000_000)\ns = strong10m   = [t for s, t, u in zip(p, p[1:], p[2:]) \n                   if t > (s + u) / 2]\nw = weak10m     = [t for s, t, u in zip(p, p[1:], p[2:]) \n                   if t < (s + u) / 2]\nb = balanced10m = [t for s, t, u in zip(p, p[1:], p[2:]) \n                   if t == (s + u) / 2]\n\nprint('The first   36   strong primes:', s[:36])\nprint('The   count   of the strong primes below   1,000,000:',\n      sum(1 for p in s if p < 1_000_000))\nprint('The   count   of the strong primes below  10,000,000:', len(s))\nprint('\\nThe first   37   weak primes:', w[:37])\nprint('The   count   of the weak   primes below   1,000,000:',\n      sum(1 for p in w if p < 1_000_000))\nprint('The   count   of the weak   primes below  10,000,000:', len(w))\nprint('\\n\\nThe first   10 balanced primes:', b[:10])\nprint('The   count   of balanced   primes below   1,000,000:',\n      sum(1 for p in b if p < 1_000_000))\nprint('The   count   of balanced   primes below  10,000,000:', len(b))\nprint('\\nTOTAL primes below   1,000,000:',\n      sum(1 for pr in p if pr < 1_000_000))\nprint('TOTAL primes below  10,000,000:', len(p))\n"}
{"id": 419614, "name": "Left factorials", "source": "Translate Swift to Python: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nprefix func ! <T: BinaryInteger>(n: T) -> T {\n  guard n != 0 else {\n    return 0\n  }\n\n  return stride(from: 0, to: n, by: 1).lazy.map(factorial).reduce(0, +)\n}\n\nfor i in 0...10 {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nfor i in stride(from: BigInt(20), through: 110, by: 10) {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nprint(\"!1000 = \\((!BigInt(1000)).description.count) digit number\")\n\nprint()\n\nfor i in stride(from: BigInt(2000), through: 10_000, by: 1000) {\n  print(\"!\\(i) = \\((!i).description.count) digit number\")\n}\n", "target": "from itertools import islice\n\ndef lfact():\n    yield 0\n    fact, summ, n = 1, 0, 1 \n    while 1:\n        fact, summ, n = fact*n, summ + fact, n + 1\n        yield summ\n\nprint('first 11:\\n  %r' % [lf for i, lf in zip(range(11), lfact())])\nprint('20 through 110 (inclusive) by tens:')\nfor lf in islice(lfact(), 20, 111, 10):\n    print(lf)\nprint('Digits in 1,000 through 10,000 (inclusive) by thousands:\\n  %r' \n      % [len(str(lf)) for lf in islice(lfact(), 1000, 10001, 1000)] )\n"}
{"id": 419615, "name": "Left factorials", "source": "Translate Swift to Python: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nprefix func ! <T: BinaryInteger>(n: T) -> T {\n  guard n != 0 else {\n    return 0\n  }\n\n  return stride(from: 0, to: n, by: 1).lazy.map(factorial).reduce(0, +)\n}\n\nfor i in 0...10 {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nfor i in stride(from: BigInt(20), through: 110, by: 10) {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nprint(\"!1000 = \\((!BigInt(1000)).description.count) digit number\")\n\nprint()\n\nfor i in stride(from: BigInt(2000), through: 10_000, by: 1000) {\n  print(\"!\\(i) = \\((!i).description.count) digit number\")\n}\n", "target": "from itertools import islice\n\ndef lfact():\n    yield 0\n    fact, summ, n = 1, 0, 1 \n    while 1:\n        fact, summ, n = fact*n, summ + fact, n + 1\n        yield summ\n\nprint('first 11:\\n  %r' % [lf for i, lf in zip(range(11), lfact())])\nprint('20 through 110 (inclusive) by tens:')\nfor lf in islice(lfact(), 20, 111, 10):\n    print(lf)\nprint('Digits in 1,000 through 10,000 (inclusive) by thousands:\\n  %r' \n      % [len(str(lf)) for lf in islice(lfact(), 1000, 10001, 1000)] )\n"}
{"id": 419616, "name": "Strange unique prime triplets", "source": "Translate Swift to Python: import Foundation\n\nfunc primeSieve(limit: Int) -> [Bool] {\n    guard limit > 0 else {\n        return []\n    }\n    var sieve = Array(repeating: true, count: limit)\n    sieve[0] = false\n    if limit > 1 {\n        sieve[1] = false\n    }\n    if limit > 4 {\n        for i in stride(from: 4, to: limit, by: 2) {\n            sieve[i] = false\n        }\n    }\n    var p = 3\n    while true {\n        var q = p * p\n        if q >= limit {\n            break\n        }\n        if sieve[p] {\n            let inc = 2 * p\n            while q < limit {\n                sieve[q] = false\n                q += inc\n            }\n        }\n        p += 2\n    }\n    return sieve\n}\n\nfunc strangeUniquePrimeTriplets(limit: Int, verbose: Bool) {\n    guard limit > 5 else {\n        return;\n    }\n    let sieve = primeSieve(limit: 3 * limit)\n    var primes: [Int] = []\n    for p in stride(from: 3, to: limit, by: 2) {\n        if sieve[p] {\n            primes.append(p)\n        }\n    }\n    let n = primes.count\n    var count = 0\n    if verbose {\n        print(\"Strange unique prime triplets < \\(limit):\")\n    }\n    for i in (0..<n - 2) {\n        for j in (i + 1..<n - 1) {\n            for k in (j + 1..<n) {\n                let sum = primes[i] + primes[j] + primes[k]\n                if sieve[sum] {\n                    count += 1\n                    if verbose {\n                        print(String(format: \"%2d + %2d + %2d = %2d\",\n                                     primes[i], primes[j], primes[k], sum))\n                    }\n                }\n            }\n        }\n    }\n    print(\"\\nCount of strange unique prime triplets < \\(limit) is \\(count).\")\n}\n\nstrangeUniquePrimeTriplets(limit: 30, verbose: true)\nstrangeUniquePrimeTriplets(limit: 1000, verbose: false)\n", "target": "from sympy import primerange\n\ndef strange_triplets(mx: int = 30) -> None:\n    primes = list(primerange(0, mx))\n    primes3 = set(primerange(0, 3 * mx))\n    for i, n in enumerate(primes):\n        for j, m in enumerate(primes[i + 1:], i + 1):\n            for p in primes[j + 1:]:\n                if n + m + p in primes3:\n                    yield n, m, p\n\nfor c, (n, m, p) in enumerate(strange_triplets(), 1):\n    print(f\"{c:2}: {n:2}+{m:2}+{p:2} = {n + m + p}\")\n\nmx = 1_000\nprint(f\"\\nIf n, m, p < {mx:_} finds {sum(1 for _ in strange_triplets(mx)):_}\")\n"}
{"id": 419617, "name": "Strange unique prime triplets", "source": "Translate Swift to Python: import Foundation\n\nfunc primeSieve(limit: Int) -> [Bool] {\n    guard limit > 0 else {\n        return []\n    }\n    var sieve = Array(repeating: true, count: limit)\n    sieve[0] = false\n    if limit > 1 {\n        sieve[1] = false\n    }\n    if limit > 4 {\n        for i in stride(from: 4, to: limit, by: 2) {\n            sieve[i] = false\n        }\n    }\n    var p = 3\n    while true {\n        var q = p * p\n        if q >= limit {\n            break\n        }\n        if sieve[p] {\n            let inc = 2 * p\n            while q < limit {\n                sieve[q] = false\n                q += inc\n            }\n        }\n        p += 2\n    }\n    return sieve\n}\n\nfunc strangeUniquePrimeTriplets(limit: Int, verbose: Bool) {\n    guard limit > 5 else {\n        return;\n    }\n    let sieve = primeSieve(limit: 3 * limit)\n    var primes: [Int] = []\n    for p in stride(from: 3, to: limit, by: 2) {\n        if sieve[p] {\n            primes.append(p)\n        }\n    }\n    let n = primes.count\n    var count = 0\n    if verbose {\n        print(\"Strange unique prime triplets < \\(limit):\")\n    }\n    for i in (0..<n - 2) {\n        for j in (i + 1..<n - 1) {\n            for k in (j + 1..<n) {\n                let sum = primes[i] + primes[j] + primes[k]\n                if sieve[sum] {\n                    count += 1\n                    if verbose {\n                        print(String(format: \"%2d + %2d + %2d = %2d\",\n                                     primes[i], primes[j], primes[k], sum))\n                    }\n                }\n            }\n        }\n    }\n    print(\"\\nCount of strange unique prime triplets < \\(limit) is \\(count).\")\n}\n\nstrangeUniquePrimeTriplets(limit: 30, verbose: true)\nstrangeUniquePrimeTriplets(limit: 1000, verbose: false)\n", "target": "from sympy import primerange\n\ndef strange_triplets(mx: int = 30) -> None:\n    primes = list(primerange(0, mx))\n    primes3 = set(primerange(0, 3 * mx))\n    for i, n in enumerate(primes):\n        for j, m in enumerate(primes[i + 1:], i + 1):\n            for p in primes[j + 1:]:\n                if n + m + p in primes3:\n                    yield n, m, p\n\nfor c, (n, m, p) in enumerate(strange_triplets(), 1):\n    print(f\"{c:2}: {n:2}+{m:2}+{p:2} = {n + m + p}\")\n\nmx = 1_000\nprint(f\"\\nIf n, m, p < {mx:_} finds {sum(1 for _ in strange_triplets(mx)):_}\")\n"}
{"id": 419618, "name": "Motzkin numbers", "source": "Translate Swift to Python: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n}\n\nfunc motzkin(_ n: Int) -> [Int] {\n  var m = Array(repeating: 0, count: n)\n\n  m[0] = 1\n  m[1] = 1\n\n  for i in 2..<n {\n    m[i] = (m[i - 1] * (2 * i + 1) + m[i - 2] * (3 * i - 3)) / (i + 2)\n  }\n\n  return m\n}\n\nlet m = motzkin(42)\n\nfor (i, n) in m.enumerated() {\n  print(\"\\(i): \\(n) \\(n.isPrime ? \"prime\" : \"\")\")\n}\n", "target": "\n\nfrom sympy import isprime\n\n\ndef motzkin(num_wanted):\n    \n    mot = [1] * (num_wanted + 1)\n    for i in range(2, num_wanted + 1):\n        mot[i] = (mot[i-1]*(2*i+1) + mot[i-2]*(3*i-3)) // (i + 2)\n    return mot\n\n\ndef print_motzkin_table(N=41):\n    \n    print(\n        \" n          M[n]             Prime?\\n-----------------------------------\")\n    for i, e in enumerate(motzkin(N)):\n        print(f'{i : 3}{e : 24,}', isprime(e))\n\n\nprint_motzkin_table()\n"}
{"id": 419619, "name": "Smarandache prime-digital sequence", "source": "Translate Swift to Python: func isPrime(number: Int) -> Bool {\n    if number < 2 {\n        return false\n    }\n    if number % 2 == 0 {\n        return number == 2\n    }\n    if number % 3 == 0 {\n        return number == 3\n    }\n    if number % 5 == 0 {\n        return number == 5\n    }\n    var p = 7\n    let wheel = [4,2,4,2,4,6,2,6]\n    while true {\n        for w in wheel {\n            if p * p > number {\n                return true\n            }\n            if number % p == 0 {\n                return false\n            }\n            p += w\n        }\n    }\n}\n\nfunc nextPrimeDigitNumber(number: Int) -> Int {\n    if number == 0 {\n        return 2\n    }\n    switch number % 10 {\n    case 2:\n        return number + 1\n    case 3, 5:\n        return number + 2\n    default:\n        return 2 + nextPrimeDigitNumber(number: number/10) * 10\n    }\n}\n\nlet limit = 1000000000\nvar n = 0\nvar max = 0\nvar count = 0\nprint(\"First 25 SPDS primes:\")\nwhile n < limit {\n    n = nextPrimeDigitNumber(number: n)\n    if !isPrime(number: n) {\n        continue\n    }\n    if count < 25 {\n        print(n, terminator: \" \")\n    } else if count == 25 {\n        print()\n    }\n    count += 1\n    if (count == 100) {\n        print(\"Hundredth SPDS prime: \\(n)\")\n    } else if (count == 1000) {\n        print(\"Thousandth SPDS prime: \\(n)\")\n    } else if (count == 10000) {\n        print(\"Ten thousandth SPDS prime: \\(n)\")\n    }\n    max = n\n}\nprint(\"Largest SPDS prime less than \\(limit): \\(max)\")\n", "target": "def divisors(n):\n    divs = [1]\n    for ii in range(2, int(n ** 0.5) + 3):\n        if n % ii == 0:\n            divs.append(ii)\n            divs.append(int(n / ii))\n    divs.append(n)\n    return list(set(divs))\n\n\ndef is_prime(n):\n    return len(divisors(n)) == 2\n\n\ndef digit_check(n):\n    if len(str(n))<2:\n        return True\n    else:\n        for digit in str(n):\n            if not is_prime(int(digit)):\n                return False\n        return True\n\n\ndef sequence(max_n=None):\n    ii = 0\n    n = 0\n    while True:\n        ii += 1\n        if is_prime(ii):\n            if max_n is not None:\n                if n>max_n:\n                    break\n            if digit_check(ii):\n                n += 1\n                yield ii\n\n\nif __name__ == '__main__':\n    generator = sequence(100)\n    for index, item in zip(range(1, 16), generator):\n        print(index, item)\n    for index, item in zip(range(16, 100), generator):\n        pass\n    print(100, generator.__next__())\n"}
{"id": 419620, "name": "Minimum multiple of m where digital sum equals m", "source": "Translate Swift to Python: import Foundation\n\nfunc digitSum(_ num: Int) -> Int {\n    var sum = 0\n    var n = num\n    while n > 0 {\n        sum += n % 10\n        n /= 10\n    }\n    return sum\n}\n\nfor n in 1...70 {\n    for m in 1... {\n        if digitSum(m * n) == n {\n            print(String(format: \"%8d\", m), terminator: n % 10 == 0 ? \"\\n\" : \" \")\n            break\n        }\n    }\n}\n", "target": "\n\nfrom itertools import count, islice\n\n\n\ndef a131382():\n    \n    return (\n        elemIndex(x)(\n            productDigitSums(x)\n        ) for x in count(1)\n    )\n\n\n\ndef productDigitSums(n):\n    \n    return (digitSum(n * x) for x in count(0))\n\n\n\n\ndef main():\n    \n\n    print(\n        table(10)([\n            str(x) for x in islice(\n                a131382(),\n                40\n            )\n        ])\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digitSum(n):\n    \n    return sum(int(x) for x in list(str(n)))\n\n\n\ndef elemIndex(x):\n    \n    def go(xs):\n        try:\n            return next(\n                i for i, v in enumerate(xs) if x == v\n            )\n        except StopIteration:\n            return None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 419621, "name": "Pythagorean quadruples", "source": "Translate Swift to Python: func missingD(upTo n: Int) -> [Int] {\n  var a2 = 0, s = 3, s1 = 0, s2 = 0\n  var res = [Int](repeating: 0, count: n + 1)\n  var ab = [Int](repeating: 0, count: n * n * 2 + 1)\n\n  for a in 1...n {\n    a2 = a * a\n\n    for b in a...n {\n      ab[a2 + b * b] = 1\n    }\n  }\n\n  for c in 1..<n {\n    s1 = s\n    s += 2\n    s2 = s\n\n    for d in c+1...n {\n      if ab[s1] != 0 {\n        res[d] = 1\n      }\n\n      s1 += s2\n      s2 += 2\n    }\n  }\n\n  return (1...n).filter({ res[$0] == 0 })\n}\n\nprint(missingD(upTo: 2200))\n", "target": "def quad(top=2200):\n    r = [False] * top\n    ab = [False] * (top * 2)**2\n    for a in range(1, top):\n        for b in range(a, top):\n            ab[a * a + b * b] = True\n    s = 3\n    for c in range(1, top):\n        s1, s, s2 = s, s + 2, s + 2\n        for d in range(c + 1, top):\n            if ab[s1]:\n                r[d] = True\n            s1 += s2\n            s2 += 2\n    return [i for i, val in enumerate(r) if not val and i]\n    \nif __name__ == '__main__':\n    n = 2200\n    print(f\"Those values of d in 1..{n} that can't be represented: {quad(n)}\")\n"}
{"id": 419622, "name": "Safe primes and unsafe primes", "source": "Translate Swift to Python: import Foundation\n\nclass PrimeSieve {\n    var composite: [Bool]\n    \n    init(size: Int) {\n        composite = Array(repeating: false, count: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite[p/2 - 1] {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite[q/2 - 1] = true\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite[number/2 - 1]\n    }\n}\n\nfunc commatize(_ number: Int) -> String {\n    let n = NSNumber(value: number)\n    return NumberFormatter.localizedString(from: n, number: .decimal)\n}\n\nlet limit1 = 1000000\nlet limit2 = 10000000\n\nclass PrimeInfo {\n    let maxPrint: Int\n    var count1: Int\n    var count2: Int\n    var primes: [Int]\n    \n    init(maxPrint: Int) {\n        self.maxPrint = maxPrint\n        count1 = 0\n        count2 = 0\n        primes = []\n    }\n    \n    func addPrime(prime: Int) {\n        count2 += 1\n        if prime < limit1 {\n            count1 += 1\n        }\n        if count2 <= maxPrint {\n            primes.append(prime)\n        }\n    }\n    \n    func printInfo(name: String) {\n        print(\"First \\(maxPrint) \\(name) primes: \\(primes)\")\n        print(\"Number of \\(name) primes below \\(commatize(limit1)): \\(commatize(count1))\")\n        print(\"Number of \\(name) primes below \\(commatize(limit2)): \\(commatize(count2))\")\n    }\n}\n\nvar safePrimes = PrimeInfo(maxPrint: 35)\nvar unsafePrimes = PrimeInfo(maxPrint: 40)\n\nlet sieve = PrimeSieve(size: limit2)\n\nfor prime in 2..<limit2 {\n    if sieve.isPrime(number: prime) {\n        if sieve.isPrime(number: (prime - 1)/2) {\n            safePrimes.addPrime(prime: prime)\n        } else {\n            unsafePrimes.addPrime(prime: prime)\n        }\n    }\n}\n\nsafePrimes.printInfo(name: \"safe\")\nunsafePrimes.printInfo(name: \"unsafe\")\n", "target": "primes =[]\nsp =[]\nusp=[]\nn = 10000000\nif 2<n:\n    primes.append(2)\nfor i in range(3,n+1,2):\n    for j in primes:\n        if(j>i/2) or (j==primes[-1]):\n            primes.append(i)\n            if((i-1)/2) in primes:\n                sp.append(i)\n                break\n            else:\n                usp.append(i)\n                break\n        if (i%j==0):\n            break\n\nprint('First 35 safe primes are:\\n' , sp[:35])\nprint('There are '+str(len(sp[:1000000]))+' safe primes below 1,000,000')\nprint('There are '+str(len(sp))+' safe primes below 10,000,000')\nprint('First 40 unsafe primes:\\n',usp[:40])\nprint('There are '+str(len(usp[:1000000]))+' unsafe primes below 1,000,000')\nprint('There are '+str(len(usp))+' safe primes below 10,000,000')\n"}
{"id": 419623, "name": "Hash join", "source": "Translate Swift to Python: func hashJoin<A, B, K: Hashable>(_ first: [(K, A)], _ second: [(K, B)]) -> [(A, K, B)] {\n  var map = [K: [B]]()\n\n  for (key, val) in second {\n    map[key, default: []].append(val)\n  }\n\n  var res = [(A, K, B)]()\n\n  for (key, val) in first {\n    guard let vals = map[key] else {\n      continue\n    }\n\n    res += vals.map({ (val, key, $0) })\n  }\n\n  return res\n}\n\nlet t1 = [\n  (\"Jonah\", 27), \n  (\"Alan\", 18), \n  (\"Glory\", 28), \n  (\"Popeye\", 18), \n  (\"Alan\", 28)\n]\n\nlet t2 = [\n  (\"Jonah\", \"Whales\"), \n  (\"Jonah\", \"Spiders\"),\n  (\"Alan\", \"Ghosts\"),\n  (\"Alan\", \"Zombies\"),\n  (\"Glory\", \"Buffy\")\n]\n\nprint(\"Age | Character Name | Nemesis\")\nprint(\"----|----------------|--------\")\n\nfor (age, name, nemesis) in hashJoin(t1, t2) {\n  print(\"\\(age) | \\(name) | \\(nemesis)\")\n}\n", "target": "from collections import defaultdict\n\ndef hashJoin(table1, index1, table2, index2):\n    h = defaultdict(list)\n    \n    for s in table1:\n        h[s[index1]].append(s)\n    \n    return [(s, r) for r in table2 for s in h[r[index2]]]\n\ntable1 = [(27, \"Jonah\"),\n          (18, \"Alan\"),\n          (28, \"Glory\"),\n          (18, \"Popeye\"),\n          (28, \"Alan\")]\ntable2 = [(\"Jonah\", \"Whales\"),\n          (\"Jonah\", \"Spiders\"),\n          (\"Alan\", \"Ghosts\"),\n          (\"Alan\", \"Zombies\"),\n          (\"Glory\", \"Buffy\")]\n\nfor row in hashJoin(table1, 1, table2, 0):\n    print(row)\n"}
{"id": 419624, "name": "Terminal control_Preserve screen", "source": "Translate Swift to Python: public let CSI = ESC+\"[\"   \nfunc write(_ text: String...) {\n  for txt in text { write(STDOUT_FILENO, txt, txt.utf8.count) }\n}\nwrite(CSI,\"?1049h\") \nprint(\"Alternate screen buffer\\n\")\nfor n in (1...5).reversed() {\n    print(\"Going back in \\(n)...\")\n    sleep(1)\n}\nwrite(CSI,\"?1049l\") \n", "target": "\n\nimport time\n\nprint \"\\033[?1049h\\033[H\"\nprint \"Alternate buffer!\"\n\nfor i in xrange(5, 0, -1):\n    print \"Going back in:\", i\n    time.sleep(1)\n\nprint \"\\033[?1049l\"\n"}
{"id": 419625, "name": "Speech synthesis", "source": "Translate Swift to Python: import Foundation\n\nlet task = NSTask()\ntask.launchPath = \"/usr/bin/say\"\ntask.arguments = [\"This is an example of speech synthesis.\"]\ntask.launch()\n", "target": "import pyttsx\n\nengine = pyttsx.init()\nengine.say(\"It was all a dream.\")\nengine.runAndWait()\n"}
{"id": 419626, "name": "24 game_Solve", "source": "Translate Swift to Python: import Darwin\nimport Foundation\n\nvar solution = \"\"\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> [Int] {\n  var result = [Int]()\n  for i in 0 ..< 4 {\n    result.append(Int(arc4random_uniform(9)+1))\n  }\n  return result\n}\n\n\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits\u00a0: \")\n\nfor digit in digits {\n  print(\"\\(digit) \")\n}\nprintln()\n\n\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)!\n\nvar enteredDigits = [Double]()\n\nvar enteredOperations = [Character]()\n\nlet inputString = input as String\n\n\nfor character in inputString {\n  switch character {\n  case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n    let digit = String(character)\n    enteredDigits.append(Double(digit.toInt()!))\n  case \"+\", \"-\", \"*\", \"/\":\n    enteredOperations.append(character)\n  case \"\\n\":\n    println()\n  default:\n    println(\"Invalid expression\")\n  }\n}\n\n\nvar value = 0.0\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n  value = enteredDigits[0]\n  for (i, operation) in enumerate(enteredOperations) {\n    switch operation {\n    case \"+\":\n      value = value + enteredDigits[i+1]\n    case \"-\":\n      value = value - enteredDigits[i+1]\n    case \"*\":\n      value = value * enteredDigits[i+1]\n    case \"/\":\n      value = value / enteredDigits[i+1]\n    default:\n      println(\"This message should never happen!\")\n    }\n  }\n}\n\nfunc evaluate(dPerm: [Double], oPerm: [String]) -> Bool {\n  var value = 0.0\n  \n  if dPerm.count == 4 && oPerm.count == 3 {\n    value = dPerm[0]\n    for (i, operation) in enumerate(oPerm) {\n      switch operation {\n      case \"+\":\n        value = value + dPerm[i+1]\n      case \"-\":\n        value = value - dPerm[i+1]\n      case \"*\":\n        value = value * dPerm[i+1]\n      case \"/\":\n        value = value / dPerm[i+1]\n      default:\n        println(\"This message should never happen!\")\n      }\n    }\n  }\n  return (abs(24 - value) < 0.001)\n}\n\nfunc isSolvable(inout digits: [Double]) -> Bool {\n  \n  var result = false\n  var dPerms = [[Double]]()\n  permute(&digits, &dPerms, 0)\n  \n  let total = 4 * 4 * 4\n  var oPerms = [[String]]()\n  permuteOperators(&oPerms, 4, total)\n  \n  \n  for dig in dPerms {\n    for opr in oPerms {\n      var expression = \"\"\n      \n      if evaluate(dig, opr) {\n        for digit in dig {\n          expression += \"\\(digit)\"\n        }\n        \n        for oper in opr {\n          expression += oper\n        }\n        \n        solution = beautify(expression)\n        result = true\n      }\n    }\n  }\n  return result\n}\n\nfunc permute(inout lst: [Double], inout res: [[Double]], k: Int) -> Void {\n  for i in k ..< lst.count {\n    swap(&lst[i], &lst[k])\n    permute(&lst, &res, k + 1)\n    swap(&lst[k], &lst[i])\n  }\n  if k == lst.count {\n    res.append(lst)\n  }\n}\n\n\nfunc permuteOperators(inout res: [[String]], n: Int, total: Int) -> Void {\n  let posOperations = [\"+\", \"-\", \"*\", \"/\"]\n  let npow = n * n\n  for i in 0 ..< total {\n    res.append([posOperations[(i / npow)], posOperations[((i % npow) / n)], posOperations[(i % n)]])\n  }\n}\n\nfunc beautify(infix: String) -> String {\n  let newString = infix as NSString\n  \n  var solution = \"\"\n  \n  solution += newString.substringWithRange(NSMakeRange(0, 1))\n  solution += newString.substringWithRange(NSMakeRange(12, 1))\n  solution += newString.substringWithRange(NSMakeRange(3, 1))\n  solution += newString.substringWithRange(NSMakeRange(13, 1))\n  solution += newString.substringWithRange(NSMakeRange(6, 1))\n  solution += newString.substringWithRange(NSMakeRange(14, 1))\n  solution += newString.substringWithRange(NSMakeRange(9, 1))\n  \n  return solution\n}\n\nif value != 24 {\n  println(\"The value of the provided expression is \\(value) instead of 24!\")\n  if isSolvable(&enteredDigits) {\n    println(\"A possible solution could have been \" + solution)\n  } else {\n    println(\"Anyway, there was no known solution to this one.\")\n  }\n} else {\n  println(\"Congratulations, you found a solution!\")\n}\n", "target": "\n \nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n \n \ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n \ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n \ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n \ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n \ndef solve(digits):\n    \n    digilen = len(digits)\n    \n    exprlen = 2 * digilen - 1\n    \n    digiperm = sorted(set(permutations(digits)))\n    \n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    \n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) \n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] \n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))            \n    return '!'\n \ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                \n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n \nmain()\n"}
{"id": 419627, "name": "24 game_Solve", "source": "Translate Swift to Python: import Darwin\nimport Foundation\n\nvar solution = \"\"\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> [Int] {\n  var result = [Int]()\n  for i in 0 ..< 4 {\n    result.append(Int(arc4random_uniform(9)+1))\n  }\n  return result\n}\n\n\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits\u00a0: \")\n\nfor digit in digits {\n  print(\"\\(digit) \")\n}\nprintln()\n\n\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)!\n\nvar enteredDigits = [Double]()\n\nvar enteredOperations = [Character]()\n\nlet inputString = input as String\n\n\nfor character in inputString {\n  switch character {\n  case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n    let digit = String(character)\n    enteredDigits.append(Double(digit.toInt()!))\n  case \"+\", \"-\", \"*\", \"/\":\n    enteredOperations.append(character)\n  case \"\\n\":\n    println()\n  default:\n    println(\"Invalid expression\")\n  }\n}\n\n\nvar value = 0.0\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n  value = enteredDigits[0]\n  for (i, operation) in enumerate(enteredOperations) {\n    switch operation {\n    case \"+\":\n      value = value + enteredDigits[i+1]\n    case \"-\":\n      value = value - enteredDigits[i+1]\n    case \"*\":\n      value = value * enteredDigits[i+1]\n    case \"/\":\n      value = value / enteredDigits[i+1]\n    default:\n      println(\"This message should never happen!\")\n    }\n  }\n}\n\nfunc evaluate(dPerm: [Double], oPerm: [String]) -> Bool {\n  var value = 0.0\n  \n  if dPerm.count == 4 && oPerm.count == 3 {\n    value = dPerm[0]\n    for (i, operation) in enumerate(oPerm) {\n      switch operation {\n      case \"+\":\n        value = value + dPerm[i+1]\n      case \"-\":\n        value = value - dPerm[i+1]\n      case \"*\":\n        value = value * dPerm[i+1]\n      case \"/\":\n        value = value / dPerm[i+1]\n      default:\n        println(\"This message should never happen!\")\n      }\n    }\n  }\n  return (abs(24 - value) < 0.001)\n}\n\nfunc isSolvable(inout digits: [Double]) -> Bool {\n  \n  var result = false\n  var dPerms = [[Double]]()\n  permute(&digits, &dPerms, 0)\n  \n  let total = 4 * 4 * 4\n  var oPerms = [[String]]()\n  permuteOperators(&oPerms, 4, total)\n  \n  \n  for dig in dPerms {\n    for opr in oPerms {\n      var expression = \"\"\n      \n      if evaluate(dig, opr) {\n        for digit in dig {\n          expression += \"\\(digit)\"\n        }\n        \n        for oper in opr {\n          expression += oper\n        }\n        \n        solution = beautify(expression)\n        result = true\n      }\n    }\n  }\n  return result\n}\n\nfunc permute(inout lst: [Double], inout res: [[Double]], k: Int) -> Void {\n  for i in k ..< lst.count {\n    swap(&lst[i], &lst[k])\n    permute(&lst, &res, k + 1)\n    swap(&lst[k], &lst[i])\n  }\n  if k == lst.count {\n    res.append(lst)\n  }\n}\n\n\nfunc permuteOperators(inout res: [[String]], n: Int, total: Int) -> Void {\n  let posOperations = [\"+\", \"-\", \"*\", \"/\"]\n  let npow = n * n\n  for i in 0 ..< total {\n    res.append([posOperations[(i / npow)], posOperations[((i % npow) / n)], posOperations[(i % n)]])\n  }\n}\n\nfunc beautify(infix: String) -> String {\n  let newString = infix as NSString\n  \n  var solution = \"\"\n  \n  solution += newString.substringWithRange(NSMakeRange(0, 1))\n  solution += newString.substringWithRange(NSMakeRange(12, 1))\n  solution += newString.substringWithRange(NSMakeRange(3, 1))\n  solution += newString.substringWithRange(NSMakeRange(13, 1))\n  solution += newString.substringWithRange(NSMakeRange(6, 1))\n  solution += newString.substringWithRange(NSMakeRange(14, 1))\n  solution += newString.substringWithRange(NSMakeRange(9, 1))\n  \n  return solution\n}\n\nif value != 24 {\n  println(\"The value of the provided expression is \\(value) instead of 24!\")\n  if isSolvable(&enteredDigits) {\n    println(\"A possible solution could have been \" + solution)\n  } else {\n    println(\"Anyway, there was no known solution to this one.\")\n  }\n} else {\n  println(\"Congratulations, you found a solution!\")\n}\n", "target": "\n \nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n \n \ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n \ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n \ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n \ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n \ndef solve(digits):\n    \n    digilen = len(digits)\n    \n    exprlen = 2 * digilen - 1\n    \n    digiperm = sorted(set(permutations(digits)))\n    \n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    \n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) \n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] \n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))            \n    return '!'\n \ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                \n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n \nmain()\n"}
{"id": 419628, "name": "Super-d numbers", "source": "Translate Swift to Python: import BigInt\nimport Foundation\n\nlet rd = [\"22\", \"333\", \"4444\", \"55555\", \"666666\", \"7777777\", \"88888888\", \"999999999\"]\n\nfor d in 2...9 {\n  print(\"First 10 super-\\(d) numbers:\")\n\n  var count = 0\n  var n = BigInt(3)\n  var k = BigInt(0)\n\n  while true {\n    k = n.power(d)\n    k *= BigInt(d)\n\n    if let _ = String(k).range(of: rd[d - 2]) {\n      count += 1\n\n      print(n, terminator: \" \")\n      fflush(stdout)\n\n      guard count < 10 else {\n        break\n      }\n    }\n\n    n += 1\n  }\n\n  print()\n  print()\n}\n", "target": "from itertools import islice, count\n\ndef superd(d):\n    if d != int(d) or not 2 <= d <= 9:\n        raise ValueError(\"argument must be integer from 2 to 9 inclusive\")\n    tofind = str(d) * d\n    for n in count(2):\n        if tofind in str(d * n ** d):\n            yield n\n\nif __name__ == '__main__':\n    for d in range(2, 9):\n        print(f\"{d}:\", ', '.join(str(n) for n in islice(superd(d), 10)))\n"}
{"id": 419629, "name": "Padovan sequence", "source": "Translate Swift to Python: import Foundation\n\nclass PadovanRecurrence: Sequence, IteratorProtocol {\n    private var p = [1, 1, 1]\n    private var n = 0\n    \n    func next() -> Int? {\n        let pn = n < 3 ? p[n] : p[0] + p[1]\n        p[0] = p[1]\n        p[1] = p[2]\n        p[2] = pn\n        n += 1\n        return pn\n    }\n}\n\nclass PadovanFloor: Sequence, IteratorProtocol {\n    private let P = 1.324717957244746025960908854\n    private let S = 1.0453567932525329623\n    private var n = 0\n    \n    func next() -> Int? {\n        let p = Int(floor(pow(P, Double(n - 1)) / S + 0.5))\n        n += 1\n        return p\n    }\n}\n\nclass PadovanLSystem: Sequence, IteratorProtocol {\n    private var str = \"A\"\n    \n    func next() -> String? {\n        let result = str\n        var next = \"\"\n        for ch in str {\n            switch (ch) {\n            case \"A\": next.append(\"B\")\n            case \"B\": next.append(\"C\")\n            default: next.append(\"AB\")\n            }\n        }\n        str = next\n        return result\n    }\n}\n\nprint(\"First 20 terms of the Padovan sequence:\")\nfor p in PadovanRecurrence().prefix(20) {\n    print(\"\\(p)\", terminator: \" \")\n}\nprint()\n\nvar b = PadovanRecurrence().prefix(64)\n    .elementsEqual(PadovanFloor().prefix(64))\nprint(\"\\nRecurrence and floor functions agree for first 64 terms? \\(b)\")\n\nprint(\"\\nFirst 10 strings produced from the L-system:\");\nfor p in PadovanLSystem().prefix(10) {\n    print(p, terminator: \" \")\n}\nprint()\n\nb = PadovanLSystem().prefix(32).map{$0.count}\n    .elementsEqual(PadovanRecurrence().prefix(32))\nprint(\"\\nLength of first 32 strings produced from the L-system = Padovan sequence? \\(b)\")\n", "target": "from math import floor\nfrom collections import deque\nfrom typing import Dict, Generator\n\n\ndef padovan_r() -> Generator[int, None, None]:\n    last = deque([1, 1, 1], 4)\n    while True:\n        last.append(last[-2] + last[-3])\n        yield last.popleft()\n\n_p, _s = 1.324717957244746025960908854, 1.0453567932525329623\n\ndef padovan_f(n: int) -> int:\n    return floor(_p**(n-1) / _s + .5)\n\ndef padovan_l(start: str='A',\n             rules: Dict[str, str]=dict(A='B', B='C', C='AB')\n             ) -> Generator[str, None, None]:\n    axiom = start\n    while True:\n        yield axiom\n        axiom = ''.join(rules[ch] for ch in axiom)\n\n\nif __name__ == \"__main__\":\n    from itertools import islice\n\n    print(\"The first twenty terms of the sequence.\")\n    print(str([padovan_f(n) for n in range(20)])[1:-1])\n\n    r_generator = padovan_r()\n    if all(next(r_generator) == padovan_f(n) for n in range(64)):\n        print(\"\\nThe recurrence and floor based algorithms match to n=63 .\")\n    else:\n        print(\"\\nThe recurrence and floor based algorithms DIFFER!\")\n\n    print(\"\\nThe first 10 L-system string-lengths and strings\")\n    l_generator = padovan_l(start='A', rules=dict(A='B', B='C', C='AB'))\n    print('\\n'.join(f\"  {len(string):3} {repr(string)}\"\n                    for string in islice(l_generator, 10)))\n\n    r_generator = padovan_r()\n    l_generator = padovan_l(start='A', rules=dict(A='B', B='C', C='AB'))\n    if all(len(next(l_generator)) == padovan_f(n) == next(r_generator)\n           for n in range(32)):\n        print(\"\\nThe L-system, recurrence and floor based algorithms match to n=31 .\")\n    else:\n        print(\"\\nThe L-system, recurrence and floor based algorithms DIFFER!\")\n"}
{"id": 419630, "name": "Monads_Maybe monad", "source": "Translate Swift to Python: precedencegroup MonadPrecedence {\n\thigherThan: BitwiseShiftPrecedence\n\tassociativity: left\n}\n\ninfix operator >>-: MonadPrecedence\t\n\ntypealias Maybe = Optional\n\nextension Maybe\n{\n\tstatic func unit(_ x: Wrapped) -> Maybe<Wrapped>\n\t{\n\t\treturn Maybe(x)\n\t}\n\n\tfunc bind<T>(_ f: (Wrapped) -> Maybe<T>) -> Maybe<T>\n\t{\n\t\treturn self.flatMap(f)\n\t}\n\n\tstatic func >>- <U>(_ m: Optional<Wrapped>, _ f: (Wrapped) -> Maybe<U>) -> Maybe<U>\n\t{\n\t\treturn m.flatMap(f)\n\t}\n}\n\nfunc dividedBy2IfEven(_ x: Int) -> Maybe<Int>\n{\n\tx.isMultiple(of: 2) ? x / 2 : nil\n}\n\nfunc lineOfAs(_ x: Int) -> Maybe<String>\n{\n\tguard x >= 0 else { return nil }\n\tlet chars = Array<Character>(repeating: \"A\", count: x)\n\treturn String(chars)\n}\n\nprint(\"\\(Maybe.unit(6).bind(dividedBy2IfEven).bind(lineOfAs) ?? \"nil\")\")\nprint(\"\\(Maybe.unit(4) >>- dividedBy2IfEven >>- lineOfAs ?? \"nil\")\")\nprint(\"\\(Maybe.unit(3) >>- dividedBy2IfEven >>- lineOfAs ?? \"nil\")\")\nprint(\"\\(Maybe.unit(-4) >>- dividedBy2IfEven >>- lineOfAs ?? \"nil\")\")\n", "target": "\nfrom __future__ import annotations\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Optional\nfrom typing import TypeVar\nfrom typing import Union\n\n\nT = TypeVar(\"T\")\n\n\nclass Maybe(Generic[T]):\n    def __init__(self, value: Union[Optional[T], Maybe[T]] = None):\n        if isinstance(value, Maybe):\n            self.value: Optional[T] = value.value\n        else:\n            self.value = value\n\n    def __rshift__(self, func: Callable[[Optional[T]], Maybe[Any]]):\n        return self.bind(func)\n\n    def bind(self, func: Callable[[Optional[T]], Maybe[Any]]) -> Maybe[Any]:\n        return func(self.value)\n\n    def __str__(self):\n        return f\"{self.__class__.__name__}({self.value!r})\"\n\n\ndef plus_one(value: Optional[int]) -> Maybe[int]:\n    if value is not None:\n        return Maybe[int](value + 1)\n    return Maybe[int](None)\n\n\ndef currency(value: Optional[int]) -> Maybe[str]:\n    if value is not None:\n        return Maybe[str](f\"${value}.00\")\n    return Maybe[str](None)\n\n\nif __name__ == \"__main__\":\n    test_cases = [1, 99, None, 4]\n\n    for case in test_cases:\n        m_int = Maybe[int](case)\n        result = m_int >> plus_one >> currency\n        \n        \n        print(f\"{str(case):<4} -> {result}\")\n"}
{"id": 419631, "name": "Monads_List monad", "source": "Translate Swift to Python: precedencegroup MonadPrecedence {\n\thigherThan: BitwiseShiftPrecedence\n\tassociativity: left\n}\n\ninfix operator >>-: MonadPrecedence\t\n\nextension Array\n{\n\tstatic func unit(_ x: Element) -> [Element]\n\t{\n\t\treturn [x]\n\t}\n\n\tfunc bind<T>(_ f: (Element) -> [T]) -> [T]\n\t{\n\t\treturn flatMap(f)\n\t}\n\n\tstatic func >>- <U>(_ m: [Element], _ f: (Element) -> [U]) -> [U]\n\t{\n\t\treturn m.flatMap(f)\n\t}\n}\n\nfunc adjacent(_ x: Int) -> [Int]\n{\n\t[x - 1, x + 1]\n}\n\nfunc squareRoots(_ x: Int) -> [Double]\n{\n\tguard x >= 0 else { return [] }\n\treturn [Double(x).squareRoot(), -(Double(x).squareRoot())]\n}\n\nprint(\"\\([Int].unit(8).bind(adjacent).bind(squareRoots))\")\nprint(\"\\([Int].unit(8) >>- adjacent >>- squareRoots)\")\nprint(\"\\([Int].unit(0) >>- adjacent >>- squareRoots)\")\n", "target": "\nfrom __future__ import annotations\nfrom itertools import chain\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import TypeVar\n\n\nT = TypeVar(\"T\")\n\n\nclass MList(List[T]):\n    @classmethod\n    def unit(cls, value: Iterable[T]) -> MList[T]:\n        return cls(value)\n\n    def bind(self, func: Callable[[T], MList[Any]]) -> MList[Any]:\n        return MList(chain.from_iterable(map(func, self)))\n\n    def __rshift__(self, func: Callable[[T], MList[Any]]) -> MList[Any]:\n        return self.bind(func)\n\n\nif __name__ == \"__main__\":\n    \n    print(\n        MList([1, 99, 4])\n        .bind(lambda val: MList([val + 1]))\n        .bind(lambda val: MList([f\"${val}.00\"]))\n    )\n\n    \n    print(\n        MList([1, 99, 4])\n        >> (lambda val: MList([val + 1]))\n        >> (lambda val: MList([f\"${val}.00\"]))\n    )\n\n    \n    print(\n        MList(range(1, 6)).bind(\n            lambda x: MList(range(6, 11)).bind(lambda y: MList([(x, y)]))\n        )\n    )\n\n    \n    print(\n        MList(range(1, 26)).bind(\n            lambda x: MList(range(x + 1, 26)).bind(\n                lambda y: MList(range(y + 1, 26)).bind(\n                    lambda z: MList([(x, y, z)])\n                    if x * x + y * y == z * z\n                    else MList([])\n                )\n            )\n        )\n    )\n"}
{"id": 419632, "name": "Textonyms", "source": "Translate Swift to Python: import Foundation\n\nfunc textCharacter(_ ch: Character) -> Character? {\n    switch (ch) {\n    case \"a\", \"b\", \"c\":\n        return \"2\"\n    case \"d\", \"e\", \"f\":\n        return \"3\"\n    case \"g\", \"h\", \"i\":\n        return \"4\"\n    case \"j\", \"k\", \"l\":\n        return \"5\"\n    case \"m\", \"n\", \"o\":\n        return \"6\"\n    case \"p\", \"q\", \"r\", \"s\":\n        return \"7\"\n    case \"t\", \"u\", \"v\":\n        return \"8\"\n    case \"w\", \"x\", \"y\", \"z\":\n        return \"9\"\n    default:\n        return nil\n    }\n}\n\nfunc textString(_ string: String) -> String? {\n    var result = String()\n    result.reserveCapacity(string.count)\n    for ch in string {\n        if let tch = textCharacter(ch) {\n            result.append(tch)\n        } else {\n            return nil\n        }\n    }\n    return result\n}\n\nfunc compareByWordCount(pair1: (key: String, value: [String]),\n                        pair2: (key: String, value: [String])) -> Bool {\n    if pair1.value.count == pair2.value.count {\n        return pair1.key < pair2.key\n    }\n    return pair1.value.count > pair2.value.count\n}\n\nfunc compareByTextLength(pair1: (key: String, value: [String]),\n                         pair2: (key: String, value: [String])) -> Bool {\n    if pair1.key.count == pair2.key.count {\n        return pair1.key < pair2.key\n    }\n    return pair1.key.count > pair2.key.count\n}\n\nfunc findTextonyms(_ path: String) throws {\n    var dict = Dictionary<String, [String]>()\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    var count = 0\n    for line in contents.components(separatedBy: \"\\n\") {\n        if line.isEmpty {\n            continue\n        }\n        let word = line.lowercased()\n        if let text = textString(word) {\n            dict[text, default: []].append(word)\n            count += 1\n        }\n    }\n    var textonyms = Array(dict.filter{$0.1.count > 1})\n    print(\"There are \\(count) words in '\\(path)' which can be represented by the digit key mapping.\")\n    print(\"They require \\(dict.count) digit combinations to represent them.\")\n    print(\"\\(textonyms.count) digit combinations represent Textonyms.\")\n\n    let top = min(5, textonyms.count)\n    print(\"\\nTop \\(top) by number of words:\")\n    textonyms.sort(by: compareByWordCount)\n    for (text, words) in textonyms.prefix(top) {\n        print(\"\\(text) = \\(words.joined(separator: \", \"))\")\n    }\n\n    print(\"\\nTop \\(top) by length:\")\n    textonyms.sort(by: compareByTextLength)\n    for (text, words) in textonyms.prefix(top) {\n        print(\"\\(text) = \\(words.joined(separator: \", \"))\")\n    }\n}\n\ndo {\n    try findTextonyms(\"unixdict.txt\")\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "from collections import defaultdict\nimport urllib.request\n\nCH2NUM = {ch: str(num) for num, chars in enumerate('abc def ghi jkl mno pqrs tuv wxyz'.split(), 2) for ch in chars}\nURL = 'http://www.puzzlers.org/pub/wordlists/unixdict.txt'\n\n\ndef getwords(url):\n return urllib.request.urlopen(url).read().decode(\"utf-8\").lower().split()\n\ndef mapnum2words(words):\n    number2words = defaultdict(list)\n    reject = 0\n    for word in words:\n        try:\n            number2words[''.join(CH2NUM[ch] for ch in word)].append(word)\n        except KeyError:\n            \n            reject += 1\n    return dict(number2words), reject\n\ndef interactiveconversions():\n    global inp, ch, num\n    while True:\n        inp = input(\"\\nType a number or a word to get the translation and textonyms: \").strip().lower()\n        if inp:\n            if all(ch in '23456789' for ch in inp):\n                if inp in num2words:\n                    print(\"  Number {0} has the following textonyms in the dictionary: {1}\".format(inp, ', '.join(\n                        num2words[inp])))\n                else:\n                    print(\"  Number {0} has no textonyms in the dictionary.\".format(inp))\n            elif all(ch in CH2NUM for ch in inp):\n                num = ''.join(CH2NUM[ch] for ch in inp)\n                print(\"  Word {0} is{1} in the dictionary and is number {2} with textonyms: {3}\".format(\n                    inp, ('' if inp in wordset else \"n't\"), num, ', '.join(num2words[num])))\n            else:\n                print(\"  I don't understand %r\" % inp)\n        else:\n            print(\"Thank you\")\n            break\n\n\nif __name__ == '__main__':\n    words = getwords(URL)\n    print(\"Read %i words from %r\" % (len(words), URL))\n    wordset = set(words)\n    num2words, reject = mapnum2words(words)\n    morethan1word = sum(1 for w in num2words if len(num2words[w]) > 1)\n    maxwordpernum = max(len(values) for values in num2words.values())\n    print(.format(len(words) - reject, URL, len(num2words), morethan1word))\n\n    print(\"\\nThe numbers mapping to the most words map to %i words each:\" % maxwordpernum)\n    maxwpn = sorted((key, val) for key, val in num2words.items() if len(val) == maxwordpernum)\n    for num, wrds in maxwpn:\n        print(\"  %s maps to: %s\" % (num, ', '.join(wrds)))\n\n    interactiveconversions()\n"}
{"id": 419633, "name": "Church numerals", "source": "Translate Swift to Python: func succ<A, B, C>(_ n: @escaping (@escaping (A) -> B) -> (C) -> A) -> (@escaping (A) -> B) -> (C) -> B {\n  return {f in\n    return {x in\n      return f(n(f)(x))\n    }\n  }\n}\n\nfunc zero<A, B>(_ a: A) -> (B) -> B {\n  return {b in\n    return b\n  }\n}\n\nfunc three<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(zero)))(f)(x)\n  }\n}\n\nfunc four<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(succ(zero))))(f)(x)\n  }\n}\n\nfunc add<A, B, C>(_ m: @escaping (B) -> (A) -> C) -> (@escaping (B) -> (C) -> A) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return m(f)(n(f)(x))\n      }\n    }\n  }\n}\n\nfunc mult<A, B, C>(_ m: @escaping (A) -> B) -> (@escaping (C) -> A) -> (C) -> B {\n  return {n in\n    return {f in\n      return m(n(f))\n    }\n  }\n}\n\nfunc exp<A, B, C>(_ m: A) -> (@escaping (A) -> (B) -> (C) -> C) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return n(m)(f)(x)\n      }\n    }\n  }\n}\n\nfunc church<A>(_ x: Int) -> (@escaping (A) -> A) -> (A) -> A {\n  guard x != 0 else { return zero }\n\n  return {f in\n    return {a in\n      return f(church(x - 1)(f)(a))\n    }\n  }\n}\n\nfunc unchurch<A>(_ f: (@escaping (Int) -> Int) -> (Int) -> A) -> A {\n  return f({i in\n    return i + 1\n  })(0)\n}\n\nlet a = unchurch(add(three)(four))\nlet b = unchurch(mult(three)(four))\n\nlet c = unchurch(exp(mult(four)(church(1)))(three))\nlet d = unchurch(exp(mult(three)(church(1)))(four))\n\nprint(a, b, c, d)\n", "target": "\n\nfrom itertools import repeat\nfrom functools import reduce\n\n\n\n\ndef churchZero():\n    \n    return lambda f: identity\n\n\ndef churchSucc(cn):\n    \n    return lambda f: compose(f)(cn(f))\n\n\ndef churchAdd(m):\n    \n    return lambda n: lambda f: compose(m(f))(n(f))\n\n\ndef churchMult(m):\n    \n    return lambda n: compose(m)(n)\n\n\ndef churchExp(m):\n    \n    return lambda n: n(m)\n\n\ndef churchFromInt(n):\n    \n    return lambda f: (\n        foldl\n        (compose)\n        (identity)\n        (replicate(n)(f))\n    )\n\n\n\ndef churchFromInt_(n):\n    \n    if 0 == n:\n        return churchZero()\n    else:\n        return churchSucc(churchFromInt(n - 1))\n\n\ndef intFromChurch(cn):\n    \n    return cn(succ)(0)\n\n\n\n\ndef main():\n    'Tests'\n\n    cThree = churchFromInt(3)\n    cFour = churchFromInt(4)\n\n    print(list(map(intFromChurch, [\n        churchAdd(cThree)(cFour),\n        churchMult(cThree)(cFour),\n        churchExp(cFour)(cThree),\n        churchExp(cThree)(cFour),\n    ])))\n\n\n\n\n\ndef compose(f):\n    \n    return lambda g: lambda x: g(f(x))\n\n\n\ndef foldl(f):\n    \n    def go(acc, xs):\n        return reduce(lambda a, x: f(a)(x), xs, acc)\n    return lambda acc: lambda xs: go(acc, xs)\n\n\n\ndef identity(x):\n    \n    return x\n\n\n\ndef replicate(n):\n    \n    return lambda x: repeat(x, n)\n\n\n\ndef succ(x):\n    \n    return 1 + x if isinstance(x, int) else (\n        chr(1 + ord(x))\n    )\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 419634, "name": "Church numerals", "source": "Translate Swift to Python: func succ<A, B, C>(_ n: @escaping (@escaping (A) -> B) -> (C) -> A) -> (@escaping (A) -> B) -> (C) -> B {\n  return {f in\n    return {x in\n      return f(n(f)(x))\n    }\n  }\n}\n\nfunc zero<A, B>(_ a: A) -> (B) -> B {\n  return {b in\n    return b\n  }\n}\n\nfunc three<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(zero)))(f)(x)\n  }\n}\n\nfunc four<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(succ(zero))))(f)(x)\n  }\n}\n\nfunc add<A, B, C>(_ m: @escaping (B) -> (A) -> C) -> (@escaping (B) -> (C) -> A) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return m(f)(n(f)(x))\n      }\n    }\n  }\n}\n\nfunc mult<A, B, C>(_ m: @escaping (A) -> B) -> (@escaping (C) -> A) -> (C) -> B {\n  return {n in\n    return {f in\n      return m(n(f))\n    }\n  }\n}\n\nfunc exp<A, B, C>(_ m: A) -> (@escaping (A) -> (B) -> (C) -> C) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return n(m)(f)(x)\n      }\n    }\n  }\n}\n\nfunc church<A>(_ x: Int) -> (@escaping (A) -> A) -> (A) -> A {\n  guard x != 0 else { return zero }\n\n  return {f in\n    return {a in\n      return f(church(x - 1)(f)(a))\n    }\n  }\n}\n\nfunc unchurch<A>(_ f: (@escaping (Int) -> Int) -> (Int) -> A) -> A {\n  return f({i in\n    return i + 1\n  })(0)\n}\n\nlet a = unchurch(add(three)(four))\nlet b = unchurch(mult(three)(four))\n\nlet c = unchurch(exp(mult(four)(church(1)))(three))\nlet d = unchurch(exp(mult(three)(church(1)))(four))\n\nprint(a, b, c, d)\n", "target": "\n\nfrom itertools import repeat\nfrom functools import reduce\n\n\n\n\ndef churchZero():\n    \n    return lambda f: identity\n\n\ndef churchSucc(cn):\n    \n    return lambda f: compose(f)(cn(f))\n\n\ndef churchAdd(m):\n    \n    return lambda n: lambda f: compose(m(f))(n(f))\n\n\ndef churchMult(m):\n    \n    return lambda n: compose(m)(n)\n\n\ndef churchExp(m):\n    \n    return lambda n: n(m)\n\n\ndef churchFromInt(n):\n    \n    return lambda f: (\n        foldl\n        (compose)\n        (identity)\n        (replicate(n)(f))\n    )\n\n\n\ndef churchFromInt_(n):\n    \n    if 0 == n:\n        return churchZero()\n    else:\n        return churchSucc(churchFromInt(n - 1))\n\n\ndef intFromChurch(cn):\n    \n    return cn(succ)(0)\n\n\n\n\ndef main():\n    'Tests'\n\n    cThree = churchFromInt(3)\n    cFour = churchFromInt(4)\n\n    print(list(map(intFromChurch, [\n        churchAdd(cThree)(cFour),\n        churchMult(cThree)(cFour),\n        churchExp(cFour)(cThree),\n        churchExp(cThree)(cFour),\n    ])))\n\n\n\n\n\ndef compose(f):\n    \n    return lambda g: lambda x: g(f(x))\n\n\n\ndef foldl(f):\n    \n    def go(acc, xs):\n        return reduce(lambda a, x: f(a)(x), xs, acc)\n    return lambda acc: lambda xs: go(acc, xs)\n\n\n\ndef identity(x):\n    \n    return x\n\n\n\ndef replicate(n):\n    \n    return lambda x: repeat(x, n)\n\n\n\ndef succ(x):\n    \n    return 1 + x if isinstance(x, int) else (\n        chr(1 + ord(x))\n    )\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 419635, "name": "Send an unknown method call", "source": "Translate Swift to Python: import Foundation\n\nclass MyUglyClass: NSObject {\n  @objc\n  func myUglyFunction() {\n    print(\"called myUglyFunction\")\n  }\n}\n\nlet someObject: NSObject = MyUglyClass()\n\nsomeObject.perform(NSSelectorFromString(\"myUglyFunction\"))\n", "target": "class Example(object):\n     def foo(self, x):\n             return 42 + x\n\nname = \"foo\"\ngetattr(Example(), name)(5)      \n"}
{"id": 419636, "name": "Sequence of primorial primes", "source": "Translate Swift to Python: import BigInt \nimport Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n}\n\nlet limit = 20\nvar primorial = 1\nvar count = 1\nvar p = 3\nvar prod = BigInt(2)\n\nprint(1, terminator: \" \")\n\nwhile true {\n  defer {\n    p += 2\n  }\n\n  guard p.isPrime else {\n    continue\n  }\n\n  prod *= BigInt(p)\n  primorial += 1\n\n  if (prod + 1).isPrime() || (prod - 1).isPrime() {\n    print(primorial, terminator: \" \")\n\n    count += 1\n\n    fflush(stdout)\n\n    if count == limit {\n      break\n    }\n  }\n}\n", "target": "import pyprimes\n\ndef primorial_prime(_pmax=500):\n    isprime = pyprimes.isprime\n    n, primo = 0, 1\n    for prime in pyprimes.nprimes(_pmax):\n        n, primo = n+1, primo * prime\n        if isprime(primo-1) or isprime(primo+1):\n            yield n\n        \nif __name__ == '__main__':\n    \n    pyprimes.warn_probably = False  \n    for i, n in zip(range(20), primorial_prime()):\n        print('Primorial prime %2i at primorial index: %3i' % (i+1, n))\n"}
{"id": 419637, "name": "Combinations and permutations", "source": "Translate Swift to Python: import BigInt\n\nfunc permutations(n: Int, k: Int) -> BigInt {\n  let l = n - k + 1\n\n  guard l <= n else {\n    return 1\n  }\n\n  return (l...n).reduce(BigInt(1), { $0 * BigInt($1) })\n}\n\nfunc combinations(n: Int, k: Int) -> BigInt {\n  let fact = {() -> BigInt in\n    guard k > 1 else {\n      return 1\n    }\n\n    return (2...k).map({ BigInt($0) }).reduce(1, *)\n  }()\n\n  return permutations(n: n, k: k) / fact\n}\n\nprint(\"Sample of permutations from 1 to 12\")\n\nfor i in 1...12 {\n  print(\"\\(i) P \\(i / 3) = \\(permutations(n: i, k: i / 3))\")\n}\n\nprint(\"\\nSample of combinations from 10 to 60\")\n\nfor i in stride(from: 10, through: 60, by: 10) {\n  print(\"\\(i) C \\(i / 3) = \\(combinations(n: i, k: i / 3))\")\n}\n\nprint(\"\\nSample of permutations from 5 to 15,000\")\n\nfor i in [5, 50, 500, 1000, 5000, 15000] {\n  let k = i / 3\n  let res = permutations(n: i, k: k).description\n  let extra = res.count > 40 ? \"... (\\(res.count - 40) more digits)\" : \"\"\n\n  print(\"\\(i) P \\(k) = \\(res.prefix(40))\\(extra)\")\n}\n\nprint(\"\\nSample of combinations from 100 to 1000\")\n\nfor i in stride(from: 100, through: 1000, by: 100) {\n  let k = i / 3\n  let res = combinations(n: i, k: k).description\n  let extra = res.count > 40 ? \"... (\\(res.count - 40) more digits)\" : \"\"\n\n  print(\"\\(i) C \\(k) = \\(res.prefix(40))\\(extra)\")\n}\n", "target": "from __future__ import print_function\n\nfrom scipy.misc import factorial as fact\nfrom scipy.misc import comb\n\ndef perm(N, k, exact=0):\n    return comb(N, k, exact) * fact(k, exact)\n\nexact=True\nprint('Sample Perms 1..12')\nfor N in range(1, 13):\n    k = max(N-2, 1)\n    print('%iP%i =' % (N, k), perm(N, k, exact), end=', ' if N % 5 else '\\n')\n          \nprint('\\n\\nSample Combs 10..60')\nfor N in range(10, 61, 10):\n    k = N-2\n    print('%iC%i =' % (N, k), comb(N, k, exact), end=', ' if N % 50 else '\\n')\n\nexact=False\nprint('\\n\\nSample Perms 5..1500 Using FP approximations')\nfor N in [5, 15, 150, 1500, 15000]:\n    k = N-2\n    print('%iP%i =' % (N, k), perm(N, k, exact))\n          \nprint('\\nSample Combs 100..1000 Using FP approximations')\nfor N in range(100, 1001, 100):\n    k = N-2\n    print('%iC%i =' % (N, k), comb(N, k, exact))\n"}
{"id": 419638, "name": "Long primes", "source": "Translate Swift to Python: public struct Eratosthenes: Sequence, IteratorProtocol {\n  private let n: Int\n  private let limit: Int\n\n  private var i = 2\n  private var sieve: [Int]\n\n  public init(upTo: Int) {\n    if upTo <= 1 {\n      self.n = 0\n      self.limit = -1\n      self.sieve = []\n    } else {\n      self.n = upTo\n      self.limit = Int(Double(n).squareRoot())\n      self.sieve = Array(0...n)\n    }\n  }\n\n  public mutating func next() -> Int? {\n    while i < n {\n      defer { i += 1 }\n\n      if sieve[i] != 0 {\n        if i <= limit {\n          for notPrime in stride(from: i * i, through: n, by: i) {\n            sieve[notPrime] = 0\n          }\n        }\n\n        return i\n      }\n    }\n\n    return nil\n  }\n}\n\nfunc findPeriod(n: Int) -> Int {\n  let r = (1...n+1).reduce(1, {res, _ in (10 * res) % n })\n  var rr = r\n  var period = 0\n\n  repeat {\n    rr = (10 * rr) % n\n    period += 1\n  } while r != rr\n\n  return period\n}\n\nlet longPrimes = Eratosthenes(upTo: 64000).dropFirst().lazy.filter({ findPeriod(n: $0) == $0 - 1 })\n\nprint(\"Long primes less than 500: \\(Array(longPrimes.prefix(while: { $0 <= 500 })))\")\n\nlet counts =\n  longPrimes.reduce(into: [500: 0, 1000: 0, 2000: 0, 4000: 0, 8000: 0, 16000: 0, 32000: 0, 64000: 0], {counts, n in\n    for key in counts.keys where n < key {\n      counts[key]! += 1\n    }\n  })\n\nfor key in counts.keys.sorted() {\n  print(\"There are \\(counts[key]!) long primes less than \\(key)\")\n}\n", "target": "def sieve(limit):\n    primes = []\n    c = [False] * (limit + 1) \n    \n    p = 3\n    while True:\n        p2 = p * p\n        if p2 > limit: break\n        for i in range(p2, limit, 2 * p): c[i] = True\n        while True:\n            p += 2\n            if not c[p]: break\n\n    for i in range(3, limit, 2):\n        if not c[i]: primes.append(i)\n    return primes\n\n\ndef findPeriod(n):\n    r = 1\n    for i in range(1, n): r = (10 * r) % n\n    rr = r\n    period = 0\n    while True:\n        r = (10 * r) % n\n        period += 1\n        if r == rr: break\n    return period\n\nprimes = sieve(64000)\nlongPrimes = []\nfor prime in primes:\n    if findPeriod(prime) == prime - 1:\n        longPrimes.append(prime)\nnumbers = [500, 1000, 2000, 4000, 8000, 16000, 32000, 64000]\ncount = 0\nindex = 0\ntotals = [0] * len(numbers)\nfor longPrime in longPrimes:\n    if longPrime > numbers[index]:\n        totals[index] = count\n        index += 1\n    count += 1\ntotals[-1] = count\nprint('The long primes up to 500 are:')\nprint(str(longPrimes[:totals[0]]).replace(',', ''))\nprint('\\nThe number of long primes up to:')\nfor (i, total) in enumerate(totals):\n    print('  %5d is %d' % (numbers[i], total))\n"}
{"id": 419639, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Swift to Python: \nimport Foundation\n\n\nstruct Stack<T> {\n\tprivate(set) var elements = [T]()\n\t\n\tvar isEmpty: Bool {\n\t\telements.isEmpty\n\t}\n\t\n\tvar top: T? {\n\t\telements.last\n\t}\n\t\n\tmutating func push(_ newElement: T) {\n\t\telements.append(newElement)\n\t}\n\t\n\tmutating func pop() -> T? {\n\t\tself.isEmpty ? nil : elements.removeLast()\n\t}\n}\n\nstruct Queue<T> {\n\tprivate(set) var elements = [T]()\n\t\n\tvar isEmpty: Bool {\n\t\telements.isEmpty\n\t}\n\t\n\tmutating func enqueue(_ newElement: T) {\n\t\telements.append(newElement)\n\t}\n\t\n\tmutating func dequeue() -> T {\n\t\treturn elements.removeFirst()\n\t}\n}\n\nenum Associativity {\n\tcase Left, Right\n}\n\n\nprotocol OperatorType: Comparable, Hashable {\n\tvar name: String { get }\n\tvar precedence: Int { get }\n\tvar associativity: Associativity { get }\n}\n\nstruct Operator: OperatorType {\n\tlet name: String\n\tlet precedence: Int\n\tlet associativity: Associativity\n\t\n\t\n\tfunc hash(into hasher: inout Hasher) {\n\t\thasher.combine(self.name)\n\t}\n\t\n\tinit(_ name: String, _ precedence: Int, _ associativity: Associativity) {\n\t\tself.name = name; self.precedence = precedence; self.associativity = associativity\n\t}\n}\n\nfunc ==(x: Operator, y: Operator) -> Bool {\n\t\n\tx.name == y.name\n}\n\nfunc <(x: Operator, y: Operator) -> Bool {\n\t\n\t(x.associativity == .Left && x.precedence == y.precedence) || x.precedence < y.precedence\n}\n\nextension Set where Element: OperatorType {\n\tfunc contains(_ operatorName: String) -> Bool {\n\t\tcontains { $0.name == operatorName }\n\t}\n\t\n\tsubscript (operatorName: String) -> Element? {\n\t\tget {\n\t\t\tfilter { $0.name == operatorName }.first\n\t\t}\n\t}\n}\n\n\nextension String {\n\tvar isNumber: Bool { return Double(self) != nil }\n}\n\nstruct ShuntingYard {\n\tenum ParseError: Error {\n\t\tcase MismatchedParenthesis(parenthesis: String, expression: String)\n\t\tcase UnrecognizedToken(token: String, expression: String)\n\t\tcase ExtraneousToken(token: String, expression: String)\n\t}\n\t\n\tstatic func parse(_ input: String, operators: Set<Operator>) throws -> String {\n\t\tvar stack = Stack<String>()\n\t\tvar output = Queue<String>()\n\t\tlet tokens = input.components(separatedBy: \" \")\n\t\t\n\t\tfor token in tokens {\n\t\t\t\n\t\t\tif token.isNumber {\n\t\t\t\t\n\t\t\t\toutput.enqueue(token)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif operators.contains(token) {\n\t\t\t\t\n\t\t\t\twhile let top = stack.top,\n\t\t\t\t\t  operators.contains(top) && Self.hasLowerPrecedence(token, top, operators) {\n\t\t\t\t\t\n\t\t\t\t\toutput.enqueue(stack.pop()!)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstack.push(token)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif token == \"(\" {\n\t\t\t\t\n\t\t\t\tstack.push(token)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif token == \")\" {\n\t\t\t\t\n\t\t\t\twhile let top = stack.top, top != \"(\" {\n\t\t\t\t\t\n\t\t\t\t\toutput.enqueue(stack.pop()!)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tguard let _ = stack.pop() else {\n\t\t\t\t\t\n\t\t\t\t\tthrow ParseError.MismatchedParenthesis(parenthesis: \")\", expression: input)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tthrow ParseError.UnrecognizedToken(token: token, expression: token)\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\twhile let top = stack.top,\n\t\t\t  operators.contains(top) {\n\t\t\t\n\t\t\toutput.enqueue(stack.pop()!)\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tif let top = stack.pop() {\n\t\t\tthrow (\n\t\t\t\ttop == \"(\"\n\t\t\t\t? ParseError.MismatchedParenthesis(parenthesis: \"(\", expression: input)\n\t\t\t\t: ParseError.ExtraneousToken(token: top, expression: input)\n\t\t\t)\n\t\t}\n\t\t\n\t\treturn output.elements.joined(separator: \" \")\n\t}\n\t\n\tstatic private func hasLowerPrecedence(_ firstToken: String, _ secondToken: String, _ operators: Set<Operator>) -> Bool {\n\t\tguard let firstOperator = operators[firstToken],\n\t\t\t  let secondOperator = operators[secondToken] else {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\treturn firstOperator < secondOperator\n\t}\n}\n\n\n", "target": "from collections import namedtuple\nfrom pprint import pprint as pp\n\nOpInfo = namedtuple('OpInfo', 'prec assoc')\nL, R = 'Left Right'.split()\n\nops = {\n '^': OpInfo(prec=4, assoc=R),\n '*': OpInfo(prec=3, assoc=L),\n '/': OpInfo(prec=3, assoc=L),\n '+': OpInfo(prec=2, assoc=L),\n '-': OpInfo(prec=2, assoc=L),\n '(': OpInfo(prec=9, assoc=L),\n ')': OpInfo(prec=0, assoc=L),\n }\n\nNUM, LPAREN, RPAREN = 'NUMBER ( )'.split()\n\n\ndef get_input(inp = None):\n    'Inputs an expression and returns list of (TOKENTYPE, tokenvalue)'\n    \n    if inp is None:\n        inp = input('expression: ')\n    tokens = inp.strip().split()\n    tokenvals = []\n    for token in tokens:\n        if token in ops:\n            tokenvals.append((token, ops[token]))\n        \n        \n        else:    \n            tokenvals.append((NUM, token))\n    return tokenvals\n\ndef shunting(tokenvals):\n    outq, stack = [], []\n    table = ['TOKEN,ACTION,RPN OUTPUT,OP STACK,NOTES'.split(',')]\n    for token, val in tokenvals:\n        note = action = ''\n        if token is NUM:\n            action = 'Add number to output'\n            outq.append(val)\n            table.append( (val, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n        elif token in ops:\n            t1, (p1, a1) = token, val\n            v = t1\n            note = 'Pop ops from stack to output' \n            while stack:\n                t2, (p2, a2) = stack[-1]\n                if (a1 == L and p1 <= p2) or (a1 == R and p1 < p2):\n                    if t1 != RPAREN:\n                        if t2 != LPAREN:\n                            stack.pop()\n                            action = '(Pop op)'\n                            outq.append(t2)\n                        else:    \n                            break\n                    else:        \n                        if t2 != LPAREN:\n                            stack.pop()\n                            action = '(Pop op)'\n                            outq.append(t2)\n                        else:    \n                            stack.pop()\n                            action = '(Pop & discard \"(\")'\n                            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n                            break\n                    table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n                    v = note = ''\n                else:\n                    note = ''\n                    break\n                note = '' \n            note = '' \n            if t1 != RPAREN:\n                stack.append((token, val))\n                action = 'Push op token to stack'\n            else:\n                action = 'Discard \")\"'\n            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n    note = 'Drain stack to output'\n    while stack:\n        v = ''\n        t2, (p2, a2) = stack[-1]\n        action = '(Pop op)'\n        stack.pop()\n        outq.append(t2)\n        table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n        v = note = ''\n    return table\n\nif __name__ == '__main__':\n    infix = '3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3'\n    print( 'For infix expression: %r\\n' % infix )\n    rp = shunting(get_input(infix))\n    maxcolwidths = [len(max(x, key=len)) for x in zip(*rp)]\n    row = rp[0]\n    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n    for row in rp[1:]:\n        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n\n    print('\\n The final output RPN is: %r' % rp[-1][2])\n"}
{"id": 419640, "name": "Perlin noise", "source": "Translate Swift to Python: import Foundation\n\nstruct Perlin {\n  private static let permutation = [\n    151, 160, 137,  91,  90,  15, 131,  13, 201,  95,  96,  53, 194, 233,   7, 225,\n    140,  36, 103,  30,  69, 142,   8,  99,  37, 240,  21,  10,  23, 190,   6, 148,\n    247, 120, 234,  75,   0,  26, 197,  62,  94, 252, 219, 203, 117,  35,  11,  32,\n    57, 177,  33,  88, 237, 149,  56,  87, 174,  20, 125, 136, 171, 168,  68, 175,\n    74, 165,  71, 134, 139,  48,  27, 166,  77, 146, 158, 231,  83, 111, 229, 122,\n    60, 211, 133, 230, 220, 105,  92,  41,  55,  46, 245,  40, 244, 102, 143,  54,\n    65,  25,  63, 161,   1, 216,  80,  73, 209,  76, 132, 187, 208,  89,  18, 169,\n    200, 196, 135, 130, 116, 188, 159,  86, 164, 100, 109, 198, 173, 186,   3,  64,\n    52, 217, 226, 250, 124, 123,   5, 202,  38, 147, 118, 126, 255,  82,  85, 212,\n    207, 206,  59, 227,  47,  16,  58,  17, 182, 189,  28,  42, 223, 183, 170, 213,\n    119, 248, 152,   2,  44, 154, 163,  70, 221, 153, 101, 155, 167,  43, 172,   9,\n    129,  22,  39, 253,  19,  98, 108, 110,  79, 113, 224, 232, 178, 185, 112, 104,\n    218, 246,  97, 228, 251,  34, 242, 193, 238, 210, 144,  12, 191, 179, 162, 241,\n    81,  51, 145, 235, 249,  14, 239, 107,  49, 192, 214,  31, 181, 199, 106, 157,\n    184,  84, 204, 176, 115, 121,  50,  45, 127,   4, 150, 254, 138, 236, 205,  93,\n    222, 114,  67,  29,  24,  72, 243, 141, 128, 195,  78,  66, 215,  61, 156, 180\n  ]\n\n  private static let p = (0..<512).map({i -> Int in\n    if i < 256 {\n      return permutation[i]\n    } else {\n      return permutation[i - 256]\n    }\n  })\n\n  private static func fade(_ t: Double) -> Double { t * t * t * (t * (t * 6 - 15) + 10) }\n\n  private static func lerp(_ t: Double, _ a: Double, _ b: Double) -> Double { a + t * (b - a) }\n\n  private static func grad(_ hash: Int, _ x: Double, _ y: Double, _ z: Double) -> Double {\n    let h = hash & 15\n    let u = h < 8 ? x : y\n    let v = h < 4 ? y : h == 12 || h == 14 ? x : z\n\n    return (h & 1 == 0 ? u : -u) + (h & 2 == 0 ? v : -v)\n  }\n\n  static func noise(x: Double, y: Double, z: Double) -> Double {\n    let xi = Int(x) & 255\n    let yi = Int(y) & 255\n    let zi = Int(z) & 255\n\n    let xx = x - floor(x)\n    let yy = y - floor(y)\n    let zz = z - floor(z)\n\n    let u = fade(xx)\n    let v = fade(yy)\n    let w = fade(zz)\n\n    let a  = p[xi] + yi\n    let aa = p[a] + zi\n    let b  = p[xi + 1] + yi\n    let ba = p[b] + zi\n    let ab = p[a + 1] + zi\n    let bb = p[b + 1] + zi\n\n    return lerp(w, lerp(v, lerp(u, grad(p[aa], xx, yy, zz),\n      grad(p[ba], xx - 1, yy, zz)),\n      lerp(u, grad(p[ab], xx, yy - 1, zz),\n        grad(p[bb], xx - 1, yy - 1, zz))),\n      lerp(v, lerp(u, grad(p[aa + 1], xx, yy, zz - 1),\n        grad(p[ba + 1], xx - 1, yy, zz - 1)),\n        lerp(u, grad(p[ab + 1], xx, yy - 1, zz - 1),\n          grad(p[bb + 1], xx - 1, yy - 1, zz - 1))))\n  }\n}\n\nprint(Perlin.noise(x: 3.14, y: 42, z: 7))\n", "target": "import math\n\ndef perlin_noise(x, y, z):\n    X = math.floor(x) & 255                  \n    Y = math.floor(y) & 255                  \n    Z = math.floor(z) & 255\n    x -= math.floor(x)                                \n    y -= math.floor(y)                                \n    z -= math.floor(z)\n    u = fade(x)                                \n    v = fade(y)                                \n    w = fade(z)\n    A = p[X  ]+Y; AA = p[A]+Z; AB = p[A+1]+Z      \n    B = p[X+1]+Y; BA = p[B]+Z; BB = p[B+1]+Z      \n \n    return lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z   ),  \n                                   grad(p[BA  ], x-1, y  , z   )), \n                           lerp(u, grad(p[AB  ], x  , y-1, z   ),  \n                                   grad(p[BB  ], x-1, y-1, z   ))),\n                   lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1 ),  \n                                   grad(p[BA+1], x-1, y  , z-1 )), \n                           lerp(u, grad(p[AB+1], x  , y-1, z-1 ),\n                                   grad(p[BB+1], x-1, y-1, z-1 ))))\n                                   \ndef fade(t): \n    return t ** 3 * (t * (t * 6 - 15) + 10)\n    \ndef lerp(t, a, b):\n    return a + t * (b - a)\n    \ndef grad(hash, x, y, z):\n    h = hash & 15                      \n    u = x if h<8 else y                \n    v = y if h<4 else (x if h in (12, 14) else z)\n    return (u if (h&1) == 0 else -u) + (v if (h&2) == 0 else -v)\n\np = [None] * 512\npermutation = [151,160,137,91,90,15,\n   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]\nfor i in range(256):\n    p[256+i] = p[i] = permutation[i]\n\nif __name__ == '__main__':\n    print(\"%1.17f\" % perlin_noise(3.14, 42, 7))\n"}
{"id": 419641, "name": "Lychrel numbers", "source": "Translate Swift to Python: import BigInt\n\npublic struct Lychrel<T: ReversibleNumeric & CustomStringConvertible>: Sequence, IteratorProtocol {\n  @usableFromInline\n  let seed: T\n\n  @usableFromInline\n  var done = false\n\n  @usableFromInline\n  var n: T\n\n  @usableFromInline\n  var iterations: T\n\n  @inlinable\n  public init(seed: T, iterations: T = 500) {\n    self.seed = seed\n    self.n = seed\n    self.iterations = iterations\n  }\n\n  @inlinable\n  public mutating func next() -> T? {\n    guard !done && iterations != 0 else {\n      return nil\n    }\n\n    guard !isPalindrome(n) || n == seed else {\n      done = true\n\n      return n\n    }\n\n    defer {\n      n += n.reversed()\n      iterations -= 1\n    }\n\n    return n\n  }\n}\n\n@inlinable\npublic func isPalindrome<T: CustomStringConvertible>(_ x: T) -> Bool {\n  let asString = String(describing: x)\n\n  for (c, c1) in zip(asString, asString.reversed()) where c != c1 {\n    return false\n  }\n\n  return true\n}\n\npublic protocol ReversibleNumeric: Numeric {\n  func reversed() -> Self\n}\n\nextension BigInt: ReversibleNumeric {\n  public func reversed() -> BigInt {\n    return BigInt(String(description.reversed()))!\n  }\n}\n\ntypealias LychrelReduce = (seen: Set<BigInt>, seeds: Set<BigInt>, related: Set<BigInt>)\n\nlet (seen, seeds, related): LychrelReduce =\n  (1...10_000)\n    .map({ BigInt($0) })\n    .reduce(into: LychrelReduce(seen: Set(), seeds: Set(), related: Set()), {res, cur in\n      guard !res.seen.contains(cur) else {\n        res.related.insert(cur)\n\n        return\n      }\n\n      var seen = false\n\n      let seq = Lychrel(seed: cur).prefix(while: { seen = res.seen.contains($0); return !seen })\n      let last = seq.last!\n\n      guard !isPalindrome(last) || seen else {\n        return\n      }\n\n      res.seen.formUnion(seq)\n\n      if seq.count == 500 {\n        res.seeds.insert(cur)\n      } else {\n        res.related.insert(cur)\n      }\n  })\n\nprint(\"Found \\(seeds.count + related.count) Lychrel numbers between 1...10_000 when limited to 500 iterations\")\nprint(\"Number of Lychrel seeds found: \\(seeds.count)\")\nprint(\"Lychrel seeds found: \\(seeds.sorted())\")\nprint(\"Number of related Lychrel nums found: \\(related.count)\")\nprint(\"Lychrel palindromes found: \\(seeds.union(related).filter(isPalindrome).sorted())\")\n", "target": "from __future__ import print_function\n\ndef add_reverse(num, max_iter=1000):\n    i, nums = 0, {num}\n    while True:\n        i, num = i+1, num + reverse_int(num)\n        nums.add(num)\n        if reverse_int(num) == num or i >= max_iter:\n            break\n    return nums\n    \n\ndef reverse_int(num):\n    return int(str(num)[::-1])\n\ndef split_roots_from_relateds(roots_and_relateds):\n    roots = roots_and_relateds[::]\n    i = 1\n    while i < len(roots):\n        this = roots[i]\n        if any(this.intersection(prev) for prev in roots[:i]):\n            del roots[i]\n        else:\n            i += 1\n    root = [min(each_set) for each_set in roots]\n    related = [min(each_set) for each_set in roots_and_relateds]\n    related = [n for n in related if n not in root]\n    return root, related\n\ndef find_lychrel(maxn, max_reversions):\n    'Lychrel number generator'\n    series = [add_reverse(n, max_reversions*2) for n in range(1, maxn + 1)]\n    roots_and_relateds = [s for s in series if len(s) > max_reversions]\n    return split_roots_from_relateds(roots_and_relateds)\n\n\nif __name__ == '__main__':\n    maxn, reversion_limit = 10000, 500\n    print(\"Calculations using n = 1..%i and limiting each search to 2*%i reverse-digits-and-adds\"\n          % (maxn, reversion_limit))\n    lychrel, l_related = find_lychrel(maxn, reversion_limit)\n    print('  Number of Lychrel numbers:', len(lychrel))\n    print('    Lychrel numbers:', ', '.join(str(n) for n in lychrel))\n    print('  Number of Lychrel related:', len(l_related))\n    \n    pals = [x for x in lychrel + l_related  if x == reverse_int(x)]\n    print('  Number of Lychrel palindromes:', len(pals))\n    print('    Lychrel palindromes:', ', '.join(str(n) for n in pals))\n"}
{"id": 419642, "name": "Lychrel numbers", "source": "Translate Swift to Python: import BigInt\n\npublic struct Lychrel<T: ReversibleNumeric & CustomStringConvertible>: Sequence, IteratorProtocol {\n  @usableFromInline\n  let seed: T\n\n  @usableFromInline\n  var done = false\n\n  @usableFromInline\n  var n: T\n\n  @usableFromInline\n  var iterations: T\n\n  @inlinable\n  public init(seed: T, iterations: T = 500) {\n    self.seed = seed\n    self.n = seed\n    self.iterations = iterations\n  }\n\n  @inlinable\n  public mutating func next() -> T? {\n    guard !done && iterations != 0 else {\n      return nil\n    }\n\n    guard !isPalindrome(n) || n == seed else {\n      done = true\n\n      return n\n    }\n\n    defer {\n      n += n.reversed()\n      iterations -= 1\n    }\n\n    return n\n  }\n}\n\n@inlinable\npublic func isPalindrome<T: CustomStringConvertible>(_ x: T) -> Bool {\n  let asString = String(describing: x)\n\n  for (c, c1) in zip(asString, asString.reversed()) where c != c1 {\n    return false\n  }\n\n  return true\n}\n\npublic protocol ReversibleNumeric: Numeric {\n  func reversed() -> Self\n}\n\nextension BigInt: ReversibleNumeric {\n  public func reversed() -> BigInt {\n    return BigInt(String(description.reversed()))!\n  }\n}\n\ntypealias LychrelReduce = (seen: Set<BigInt>, seeds: Set<BigInt>, related: Set<BigInt>)\n\nlet (seen, seeds, related): LychrelReduce =\n  (1...10_000)\n    .map({ BigInt($0) })\n    .reduce(into: LychrelReduce(seen: Set(), seeds: Set(), related: Set()), {res, cur in\n      guard !res.seen.contains(cur) else {\n        res.related.insert(cur)\n\n        return\n      }\n\n      var seen = false\n\n      let seq = Lychrel(seed: cur).prefix(while: { seen = res.seen.contains($0); return !seen })\n      let last = seq.last!\n\n      guard !isPalindrome(last) || seen else {\n        return\n      }\n\n      res.seen.formUnion(seq)\n\n      if seq.count == 500 {\n        res.seeds.insert(cur)\n      } else {\n        res.related.insert(cur)\n      }\n  })\n\nprint(\"Found \\(seeds.count + related.count) Lychrel numbers between 1...10_000 when limited to 500 iterations\")\nprint(\"Number of Lychrel seeds found: \\(seeds.count)\")\nprint(\"Lychrel seeds found: \\(seeds.sorted())\")\nprint(\"Number of related Lychrel nums found: \\(related.count)\")\nprint(\"Lychrel palindromes found: \\(seeds.union(related).filter(isPalindrome).sorted())\")\n", "target": "from __future__ import print_function\n\ndef add_reverse(num, max_iter=1000):\n    i, nums = 0, {num}\n    while True:\n        i, num = i+1, num + reverse_int(num)\n        nums.add(num)\n        if reverse_int(num) == num or i >= max_iter:\n            break\n    return nums\n    \n\ndef reverse_int(num):\n    return int(str(num)[::-1])\n\ndef split_roots_from_relateds(roots_and_relateds):\n    roots = roots_and_relateds[::]\n    i = 1\n    while i < len(roots):\n        this = roots[i]\n        if any(this.intersection(prev) for prev in roots[:i]):\n            del roots[i]\n        else:\n            i += 1\n    root = [min(each_set) for each_set in roots]\n    related = [min(each_set) for each_set in roots_and_relateds]\n    related = [n for n in related if n not in root]\n    return root, related\n\ndef find_lychrel(maxn, max_reversions):\n    'Lychrel number generator'\n    series = [add_reverse(n, max_reversions*2) for n in range(1, maxn + 1)]\n    roots_and_relateds = [s for s in series if len(s) > max_reversions]\n    return split_roots_from_relateds(roots_and_relateds)\n\n\nif __name__ == '__main__':\n    maxn, reversion_limit = 10000, 500\n    print(\"Calculations using n = 1..%i and limiting each search to 2*%i reverse-digits-and-adds\"\n          % (maxn, reversion_limit))\n    lychrel, l_related = find_lychrel(maxn, reversion_limit)\n    print('  Number of Lychrel numbers:', len(lychrel))\n    print('    Lychrel numbers:', ', '.join(str(n) for n in lychrel))\n    print('  Number of Lychrel related:', len(l_related))\n    \n    pals = [x for x in lychrel + l_related  if x == reverse_int(x)]\n    print('  Number of Lychrel palindromes:', len(pals))\n    print('    Lychrel palindromes:', ', '.join(str(n) for n in pals))\n"}
{"id": 419643, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Swift to Python: let ld10 = log(2.0) / log(10.0)\n\nfunc p(L: Int, n: Int) -> Int {\n  var l = L\n  var digits = 1\n\n  while l >= 10 {\n    digits *= 10\n    l /= 10\n  }\n\n  var count = 0\n  var i = 0\n\n  while count < n {\n    let rhs = (Double(i) * ld10).truncatingRemainder(dividingBy: 1)\n    let e = exp(log(10.0) * rhs)\n\n    if Int(e * Double(digits)) == L {\n      count += 1\n    }\n\n    i += 1\n  }\n\n  return i - 1\n}\n\nlet cases = [\n  (12, 1),\n  (12, 2),\n  (123, 45),\n  (123, 12345),\n  (123, 678910)\n]\n\nfor (l, n) in cases {\n  print(\"p(\\(l), \\(n)) = \\(p(L: l, n: n))\")\n}\n", "target": "from math import log, modf, floor\n\ndef p(l, n, pwr=2):\n    l = int(abs(l))\n    digitcount = floor(log(l, 10))\n    log10pwr = log(pwr, 10)\n    raised, found = -1, 0\n    while found < n:\n        raised += 1\n        firstdigits = floor(10**(modf(log10pwr * raised)[0] + digitcount))\n        if firstdigits == l:\n            found += 1\n    return raised\n\n\nif __name__ == '__main__':\n    for l, n in [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]:\n        print(f\"p({l}, {n}) =\", p(l, n))\n"}
{"id": 419644, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Swift to Python: let ld10 = log(2.0) / log(10.0)\n\nfunc p(L: Int, n: Int) -> Int {\n  var l = L\n  var digits = 1\n\n  while l >= 10 {\n    digits *= 10\n    l /= 10\n  }\n\n  var count = 0\n  var i = 0\n\n  while count < n {\n    let rhs = (Double(i) * ld10).truncatingRemainder(dividingBy: 1)\n    let e = exp(log(10.0) * rhs)\n\n    if Int(e * Double(digits)) == L {\n      count += 1\n    }\n\n    i += 1\n  }\n\n  return i - 1\n}\n\nlet cases = [\n  (12, 1),\n  (12, 2),\n  (123, 45),\n  (123, 12345),\n  (123, 678910)\n]\n\nfor (l, n) in cases {\n  print(\"p(\\(l), \\(n)) = \\(p(L: l, n: n))\")\n}\n", "target": "from math import log, modf, floor\n\ndef p(l, n, pwr=2):\n    l = int(abs(l))\n    digitcount = floor(log(l, 10))\n    log10pwr = log(pwr, 10)\n    raised, found = -1, 0\n    while found < n:\n        raised += 1\n        firstdigits = floor(10**(modf(log10pwr * raised)[0] + digitcount))\n        if firstdigits == l:\n            found += 1\n    return raised\n\n\nif __name__ == '__main__':\n    for l, n in [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]:\n        print(f\"p({l}, {n}) =\", p(l, n))\n"}
{"id": 419645, "name": "Pierpont primes", "source": "Translate Swift to Python: import BigInt\nimport Foundation\n\npublic func pierpoint(n: Int) -> (first: [BigInt], second: [BigInt]) {\n  var primes = (first: [BigInt](repeating: 0, count: n), second: [BigInt](repeating: 0, count: n))\n\n  primes.first[0] = 2\n\n  var count1 = 1, count2 = 0\n  var s = [BigInt(1)]\n  var i2 = 0, i3 = 0, k = 1\n  var n2 = BigInt(0), n3 = BigInt(0), t = BigInt(0)\n\n  while min(count1, count2) < n {\n    n2 = s[i2] * 2\n    n3 = s[i3] * 3\n\n    if n2 < n3 {\n      t = n2\n      i2 += 1\n    } else {\n      t = n3\n      i3 += 1\n    }\n\n    if t <= s[k - 1] {\n      continue\n    }\n\n    s.append(t)\n    k += 1\n    t += 1\n\n    if count1 < n && t.isPrime(rounds: 10) {\n      primes.first[count1] = t\n      count1 += 1\n    }\n\n    t -= 2\n\n    if count2 < n && t.isPrime(rounds: 10) {\n      primes.second[count2] = t\n      count2 += 1\n    }\n  }\n\n  return primes\n}\n\n\nlet primes = pierpoint(n: 250)\n\nprint(\"First 50 Pierpoint primes of the first kind: \\(Array(primes.first.prefix(50)))\\n\")\nprint(\"First 50 Pierpoint primes of the second kind: \\(Array(primes.second.prefix(50)))\")\nprint()\nprint(\"250th Pierpoint prime of the first kind: \\(primes.first[249])\")\nprint(\"250th Pierpoint prime of the second kind: \\(primes.second[249])\")\n", "target": "import random\n\n\ndef is_Prime(n):\n    \n    if n!=int(n):\n        return False\n    n=int(n)\n    \n    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:\n        return False\n\n    if n==2 or n==3 or n==5 or n==7:\n        return True\n    s = 0\n    d = n-1\n    while d%2==0:\n        d>>=1\n        s+=1\n    assert(2**s * d == n-1)\n\n    def trial_composite(a):\n        if pow(a, d, n) == 1:\n            return False\n        for i in range(s):\n            if pow(a, 2**i * d, n) == n-1:\n                return False\n        return True  \n\n    for i in range(8):\n        a = random.randrange(2, n)\n        if trial_composite(a):\n            return False\n\n    return True\n\ndef pierpont(ulim, vlim, first):\n    p = 0\n    p2 = 1\n    p3 = 1\n    pp = []\n    for v in xrange(vlim):\n        for u in xrange(ulim):\n            p = p2 * p3\n            if first:\n                p = p + 1\n            else:\n                p = p - 1\n            if is_Prime(p):\n                pp.append(p)\n            p2 = p2 * 2\n        p3 = p3 * 3\n        p2 = 1\n    pp.sort()\n    return pp\n\ndef main():\n    print \"First 50 Pierpont primes of the first kind:\"\n    pp = pierpont(120, 80, True)\n    for i in xrange(50):\n        print \"%8d \" % pp[i],\n        if (i - 9) % 10 == 0:\n            print\n    print \"First 50 Pierpont primes of the second kind:\"\n    pp2 = pierpont(120, 80, False)\n    for i in xrange(50):\n        print \"%8d \" % pp2[i],\n        if (i - 9) % 10 == 0:\n            print\n    print \"250th Pierpont prime of the first kind:\", pp[249]\n    print \"250th Pierpont prime of the second kind:\", pp2[249]\n\nmain()\n"}
{"id": 419646, "name": "N-smooth numbers", "source": "Translate Swift to Python: import BigInt\nimport Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) {\n      if self % i == 0 {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\n@inlinable\npublic func smoothN<T: BinaryInteger>(n: T, count: Int) -> [T] {\n  let primes = stride(from: 2, to: n + 1, by: 1).filter({ $0.isPrime })\n  var next = primes\n  var indices = [Int](repeating: 0, count: primes.count)\n  var res = [T](repeating: 0, count: count)\n\n  res[0] = 1\n\n  guard count > 1 else {\n    return res\n  }\n\n  for m in 1..<count {\n    res[m] = next.min()!\n\n    for i in 0..<indices.count where res[m] == next[i] {\n      indices[i] += 1\n      next[i] = primes[i] * res[indices[i]]\n    }\n  }\n\n  return res\n}\n\nfor n in 2...29 where n.isPrime {\n  print(\"The first 25 \\(n)-smooth numbers are: \\(smoothN(n: n, count: 25))\")\n}\n\nprint()\n\nfor n in 3...29 where n.isPrime {\n  print(\"The 3000...3002 \\(n)-smooth numbers are: \\(smoothN(n: BigInt(n), count: 3002).dropFirst(2999).prefix(3))\")\n}\n\nprint()\n\nfor n in 503...521 where n.isPrime {\n  print(\"The 30,000...30,019 \\(n)-smooth numbers are: \\(smoothN(n: BigInt(n), count: 30_019).dropFirst(29999).prefix(20))\")\n}\n", "target": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]\n\ndef isPrime(n):\n    if n < 2:\n        return False\n\n    for i in primes:\n        if n == i:\n            return True\n        if n % i == 0:\n            return False\n        if i * i > n:\n            return True\n    print \"Oops,\", n, \" is too large\"\n\ndef init():\n    s = 24\n    while s < 600:\n        if isPrime(s - 1) and s - 1 > primes[-1]:\n            primes.append(s - 1)\n        if isPrime(s + 1) and s + 1 > primes[-1]:\n            primes.append(s + 1)\n        s += 6\n\ndef nsmooth(n, size):\n    if n < 2 or n > 521:\n        raise Exception(\"n\")\n    if size < 1:\n        raise Exception(\"n\")\n\n    bn = n\n    ok = False\n    for prime in primes:\n        if bn == prime:\n            ok = True\n            break\n    if not ok:\n        raise Exception(\"must be a prime number: n\")\n\n    ns = [0] * size\n    ns[0] = 1\n\n    next = []\n    for prime in primes:\n        if prime > bn:\n            break\n        next.append(prime)\n\n    indicies = [0] * len(next)\n    for m in xrange(1, size):\n        ns[m] = min(next)\n        for i in xrange(0, len(indicies)):\n            if ns[m] == next[i]:\n                indicies[i] += 1\n                next[i] = primes[i] * ns[indicies[i]]\n\n    return ns\n\ndef main():\n    init()\n\n    for p in primes:\n        if p >= 30:\n            break\n        print \"The first\", p, \"-smooth numbers are:\"\n        print nsmooth(p, 25)\n        print\n\n    for p in primes[1:]:\n        if p >= 30:\n            break\n        print \"The 3000 to 3202\", p, \"-smooth numbers are:\"\n        print nsmooth(p, 3002)[2999:]\n        print\n\n    for p in [503, 509, 521]:\n        print \"The 30000 to 3019\", p, \"-smooth numbers are:\"\n        print nsmooth(p, 30019)[29999:]\n        print\n\nmain()\n"}
{"id": 419647, "name": "Partition an integer x into n primes", "source": "Translate Swift to Python: import Foundation\n\nclass BitArray {\n    var array: [UInt32]\n\n    init(size: Int) {\n        array = Array(repeating: 0, count: (size + 31)/32)\n    }\n    \n    func get(index: Int) -> Bool {\n        let bit = UInt32(1) << (index & 31)\n        return (array[index >> 5] & bit) != 0\n    }\n    \n    func set(index: Int, value: Bool) {\n        let bit = UInt32(1) << (index & 31)\n        if value {\n            array[index >> 5] |= bit\n        } else {\n            array[index >> 5] &= ~bit\n        }\n    }\n}\n\nclass PrimeSieve {\n    let composite: BitArray\n    \n    init(size: Int) {\n        composite = BitArray(size: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite.get(index: p/2 - 1) {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite.set(index: q/2 - 1, value: true)\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite.get(index: number/2 - 1)\n    }\n}\n\nfunc findPrimePartition(sieve: PrimeSieve, number: Int,\n                        count: Int, minPrime: Int,\n                        primes: inout [Int], index: Int) -> Bool {\n    if count == 1 {\n        if number >= minPrime && sieve.isPrime(number: number) {\n            primes[index] = number\n            return true\n        }\n        return false\n    }\n    if minPrime >= number {\n        return false\n    }\n    for p in minPrime..<number {\n        if sieve.isPrime(number: p)\n            && findPrimePartition(sieve: sieve, number: number - p,\n                                  count: count - 1, minPrime: p + 1,\n                                  primes: &primes, index: index + 1) {\n            primes[index] = p\n            return true\n        }\n    }\n    return false\n}\n\nfunc printPrimePartition(sieve: PrimeSieve, number: Int, count: Int) {\n    var primes = Array(repeating: 0, count: count)\n    if !findPrimePartition(sieve: sieve, number: number, count: count,\n                           minPrime: 2, primes: &primes, index: 0) {\n        print(\"\\(number) cannot be partitioned into \\(count) primes.\")\n    } else {\n        print(\"\\(number) = \\(primes[0])\", terminator: \"\")\n        for i in 1..<count {\n            print(\" + \\(primes[i])\", terminator: \"\")\n        }\n        print()\n    }\n}\n\nlet sieve = PrimeSieve(size: 100000)\nprintPrimePartition(sieve: sieve, number: 99809, count: 1)\nprintPrimePartition(sieve: sieve, number: 18, count: 2)\nprintPrimePartition(sieve: sieve, number: 19, count: 3)\nprintPrimePartition(sieve: sieve, number: 20, count: 4)\nprintPrimePartition(sieve: sieve, number: 2017, count: 24)\nprintPrimePartition(sieve: sieve, number: 22699, count: 1)\nprintPrimePartition(sieve: sieve, number: 22699, count: 2)\nprintPrimePartition(sieve: sieve, number: 22699, count: 3)\nprintPrimePartition(sieve: sieve, number: 22699, count: 4)\nprintPrimePartition(sieve: sieve, number: 40355, count: 3)\n", "target": "from itertools import combinations as cmb\n\n\ndef isP(n):\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    return all(n % x > 0 for x in range(3, int(n ** 0.5) + 1, 2))\n\n\ndef genP(n):\n    p = [2]\n    p.extend([x for x in range(3, n + 1, 2) if isP(x)])\n    return p\n\n\ndata = [\n    (99809, 1), (18, 2), (19, 3), (20, 4), (2017, 24),\n    (22699, 1), (22699, 2), (22699, 3), (22699, 4), (40355, 3)]\n\n\nfor n, cnt in data:\n    ci = iter(cmb(genP(n), cnt))\n    while True:\n        try:\n            c = next(ci)\n            if sum(c) == n:\n                print(' '.join(\n                    [repr((n, cnt)), \"->\", '+'.join(str(s) for s in c)]\n                ))\n                break\n        except StopIteration:\n            print(repr((n, cnt)) + \" -> Not possible\")\n            break\n"}
{"id": 419648, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Swift to Python: struct Point: CustomStringConvertible {\n    let x: Double, y: Double\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nfunc perpendicularDistance(p: Point, p1: Point, p2: Point) -> Double {\n    let dx = p2.x - p1.x\n    let dy = p2.y - p1.y\n    let d = (p.x * dy - p.y * dx + p2.x * p1.y - p2.y * p1.x)\n    return abs(d)/(dx * dx + dy * dy).squareRoot()\n}\n\nfunc ramerDouglasPeucker(points: [Point], epsilon: Double) -> [Point] {\n    var result : [Point] = []\n    func rdp(begin: Int, end: Int) {\n        guard end > begin else {\n            return\n        }\n        var maxDist = 0.0\n        var index = 0\n        for i in begin+1..<end {\n            let dist = perpendicularDistance(p: points[i], p1: points[begin],\n                                             p2: points[end])\n            if dist > maxDist {\n                maxDist = dist\n                index = i\n            }\n        }\n        if maxDist > epsilon {\n            rdp(begin: begin, end: index)\n            rdp(begin: index, end: end)\n        } else {\n            result.append(points[end])\n        }\n    }\n    if points.count > 0 && epsilon >= 0.0 {\n        result.append(points[0])\n        rdp(begin: 0, end: points.count - 1)\n    }\n    return result\n}\n\nlet points = [\n    Point(x: 0.0, y: 0.0),\n    Point(x: 1.0, y: 0.1),\n    Point(x: 2.0, y: -0.1),\n    Point(x: 3.0, y: 5.0),\n    Point(x: 4.0, y: 6.0),\n    Point(x: 5.0, y: 7.0),\n    Point(x: 6.0, y: 8.1),\n    Point(x: 7.0, y: 9.0),\n    Point(x: 8.0, y: 9.0),\n    Point(x: 9.0, y: 9.0)\n]\nprint(\"\\(ramerDouglasPeucker(points: points, epsilon: 1.0))\")\n", "target": "from __future__ import print_function\nfrom shapely.geometry import LineString\n \nif __name__==\"__main__\":\n\tline = LineString([(0,0),(1,0.1),(2,-0.1),(3,5),(4,6),(5,7),(6,8.1),(7,9),(8,9),(9,9)])\n\tprint (line.simplify(1.0, preserve_topology=False))\n"}
{"id": 419649, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Swift to Python: struct Point: CustomStringConvertible {\n    let x: Double, y: Double\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nfunc perpendicularDistance(p: Point, p1: Point, p2: Point) -> Double {\n    let dx = p2.x - p1.x\n    let dy = p2.y - p1.y\n    let d = (p.x * dy - p.y * dx + p2.x * p1.y - p2.y * p1.x)\n    return abs(d)/(dx * dx + dy * dy).squareRoot()\n}\n\nfunc ramerDouglasPeucker(points: [Point], epsilon: Double) -> [Point] {\n    var result : [Point] = []\n    func rdp(begin: Int, end: Int) {\n        guard end > begin else {\n            return\n        }\n        var maxDist = 0.0\n        var index = 0\n        for i in begin+1..<end {\n            let dist = perpendicularDistance(p: points[i], p1: points[begin],\n                                             p2: points[end])\n            if dist > maxDist {\n                maxDist = dist\n                index = i\n            }\n        }\n        if maxDist > epsilon {\n            rdp(begin: begin, end: index)\n            rdp(begin: index, end: end)\n        } else {\n            result.append(points[end])\n        }\n    }\n    if points.count > 0 && epsilon >= 0.0 {\n        result.append(points[0])\n        rdp(begin: 0, end: points.count - 1)\n    }\n    return result\n}\n\nlet points = [\n    Point(x: 0.0, y: 0.0),\n    Point(x: 1.0, y: 0.1),\n    Point(x: 2.0, y: -0.1),\n    Point(x: 3.0, y: 5.0),\n    Point(x: 4.0, y: 6.0),\n    Point(x: 5.0, y: 7.0),\n    Point(x: 6.0, y: 8.1),\n    Point(x: 7.0, y: 9.0),\n    Point(x: 8.0, y: 9.0),\n    Point(x: 9.0, y: 9.0)\n]\nprint(\"\\(ramerDouglasPeucker(points: points, epsilon: 1.0))\")\n", "target": "from __future__ import print_function\nfrom shapely.geometry import LineString\n \nif __name__==\"__main__\":\n\tline = LineString([(0,0),(1,0.1),(2,-0.1),(3,5),(4,6),(5,7),(6,8.1),(7,9),(8,9),(9,9)])\n\tprint (line.simplify(1.0, preserve_topology=False))\n"}
{"id": 419650, "name": "Chebyshev coefficients", "source": "Translate Swift to Python: import Foundation\n\ntypealias DFunc = (Double) -> Double\n\nfunc mapRange(x: Double, min: Double, max: Double, minTo: Double, maxTo: Double) -> Double {\n  return (x - min) / (max - min) * (maxTo - minTo) + minTo\n}\n\nfunc chebCoeffs(fun: DFunc, n: Int, min: Double, max: Double) -> [Double] {\n  var res = [Double](repeating: 0, count: n)\n\n  for i in 0..<n {\n    let dI = Double(i)\n    let dN = Double(n)\n    let f = fun(mapRange(x: cos(.pi * (dI + 0.5) / dN), min: -1, max: 1, minTo: min, maxTo: max)) * 2.0 / dN\n\n    for j in 0..<n {\n      res[j] += f * cos(.pi * Double(j) * (dI + 0.5) / dN)\n    }\n  }\n\n  return res\n}\n\nfunc chebApprox(x: Double, n: Int, min: Double, max: Double, coeffs: [Double]) -> Double {\n  var a = 1.0\n  var b = mapRange(x: x, min: min, max: max, minTo: -1, maxTo: 1)\n  var res = coeffs[0] / 2.0 + coeffs[1] * b\n  let xx = 2 * b\n  var i = 2\n\n  while i < n {\n    let c = xx * b - a\n    res += coeffs[i] * c\n    (a, b) = (b, c)\n    i += 1\n  }\n\n  return res\n}\n\nlet coeffs = chebCoeffs(fun: cos, n: 10, min: 0, max: 1)\n\nprint(\"Coefficients\")\n\nfor coeff in coeffs {\n  print(String(format: \"%+1.15g\", coeff))\n}\n\nprint(\"\\nApproximations:\\n  x      func(x)     approx       diff\")\n\nfor i in stride(from: 0.0, through: 20, by: 1) {\n  let x = mapRange(x: i, min: 0, max: 20, minTo: 0, maxTo: 1)\n  let f = cos(x)\n  let approx = chebApprox(x: x, n: 10, min: 0, max: 1, coeffs: coeffs)\n\n  print(String(format: \"%1.3f  %1.8f  %1.8f \u00a0% 4.1e\", x, f, approx, approx - f))\n}\n", "target": "import math\n\ndef test_func(x):\n    return math.cos(x)\n\ndef mapper(x, min_x, max_x, min_to, max_to):\n    return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to\n\ndef cheb_coef(func, n, min, max):\n    coef = [0.0] * n\n    for i in xrange(n):\n        f = func(mapper(math.cos(math.pi * (i + 0.5) / n), -1, 1, min, max)) * 2 / n\n        for j in xrange(n):\n            coef[j] += f * math.cos(math.pi * j * (i + 0.5) / n)\n    return coef\n\ndef cheb_approx(x, n, min, max, coef):\n    a = 1\n    b = mapper(x, min, max, -1, 1)\n    c = float('nan')\n    res = coef[0] / 2 + coef[1] * b\n\n    x = 2 * b\n    i = 2\n    while i < n:\n        c = x * b - a\n        res = res + coef[i] * c\n        (a, b) = (b, c)\n        i += 1\n\n    return res\n\ndef main():\n    N = 10\n    min = 0\n    max = 1\n    c = cheb_coef(test_func, N, min, max)\n\n    print \"Coefficients:\"\n    for i in xrange(N):\n        print \" % lg\" % c[i]\n\n    print \"\\n\\nApproximation:\\n    x      func(x)       approx      diff\"\n    for i in xrange(20):\n        x = mapper(i, 0.0, 20.0, min, max)\n        f = test_func(x)\n        approx = cheb_approx(x, N, min, max, c)\n        print \"%1.3f %10.10f %10.10f % 4.2e\" % (x, f, approx, approx - f)\n\n    return None\n\nmain()\n"}
{"id": 419651, "name": "Chebyshev coefficients", "source": "Translate Swift to Python: import Foundation\n\ntypealias DFunc = (Double) -> Double\n\nfunc mapRange(x: Double, min: Double, max: Double, minTo: Double, maxTo: Double) -> Double {\n  return (x - min) / (max - min) * (maxTo - minTo) + minTo\n}\n\nfunc chebCoeffs(fun: DFunc, n: Int, min: Double, max: Double) -> [Double] {\n  var res = [Double](repeating: 0, count: n)\n\n  for i in 0..<n {\n    let dI = Double(i)\n    let dN = Double(n)\n    let f = fun(mapRange(x: cos(.pi * (dI + 0.5) / dN), min: -1, max: 1, minTo: min, maxTo: max)) * 2.0 / dN\n\n    for j in 0..<n {\n      res[j] += f * cos(.pi * Double(j) * (dI + 0.5) / dN)\n    }\n  }\n\n  return res\n}\n\nfunc chebApprox(x: Double, n: Int, min: Double, max: Double, coeffs: [Double]) -> Double {\n  var a = 1.0\n  var b = mapRange(x: x, min: min, max: max, minTo: -1, maxTo: 1)\n  var res = coeffs[0] / 2.0 + coeffs[1] * b\n  let xx = 2 * b\n  var i = 2\n\n  while i < n {\n    let c = xx * b - a\n    res += coeffs[i] * c\n    (a, b) = (b, c)\n    i += 1\n  }\n\n  return res\n}\n\nlet coeffs = chebCoeffs(fun: cos, n: 10, min: 0, max: 1)\n\nprint(\"Coefficients\")\n\nfor coeff in coeffs {\n  print(String(format: \"%+1.15g\", coeff))\n}\n\nprint(\"\\nApproximations:\\n  x      func(x)     approx       diff\")\n\nfor i in stride(from: 0.0, through: 20, by: 1) {\n  let x = mapRange(x: i, min: 0, max: 20, minTo: 0, maxTo: 1)\n  let f = cos(x)\n  let approx = chebApprox(x: x, n: 10, min: 0, max: 1, coeffs: coeffs)\n\n  print(String(format: \"%1.3f  %1.8f  %1.8f \u00a0% 4.1e\", x, f, approx, approx - f))\n}\n", "target": "import math\n\ndef test_func(x):\n    return math.cos(x)\n\ndef mapper(x, min_x, max_x, min_to, max_to):\n    return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to\n\ndef cheb_coef(func, n, min, max):\n    coef = [0.0] * n\n    for i in xrange(n):\n        f = func(mapper(math.cos(math.pi * (i + 0.5) / n), -1, 1, min, max)) * 2 / n\n        for j in xrange(n):\n            coef[j] += f * math.cos(math.pi * j * (i + 0.5) / n)\n    return coef\n\ndef cheb_approx(x, n, min, max, coef):\n    a = 1\n    b = mapper(x, min, max, -1, 1)\n    c = float('nan')\n    res = coef[0] / 2 + coef[1] * b\n\n    x = 2 * b\n    i = 2\n    while i < n:\n        c = x * b - a\n        res = res + coef[i] * c\n        (a, b) = (b, c)\n        i += 1\n\n    return res\n\ndef main():\n    N = 10\n    min = 0\n    max = 1\n    c = cheb_coef(test_func, N, min, max)\n\n    print \"Coefficients:\"\n    for i in xrange(N):\n        print \" % lg\" % c[i]\n\n    print \"\\n\\nApproximation:\\n    x      func(x)       approx      diff\"\n    for i in xrange(20):\n        x = mapper(i, 0.0, 20.0, min, max)\n        f = test_func(x)\n        approx = cheb_approx(x, N, min, max, c)\n        print \"%1.3f %10.10f %10.10f % 4.2e\" % (x, f, approx, approx - f)\n\n    return None\n\nmain()\n"}
{"id": 419652, "name": "Burrows\u2013Wheeler transform", "source": "Translate Swift to Python: import Foundation\n\nprivate let stx = \"\\u{2}\"\nprivate let etx = \"\\u{3}\"\n\nfunc bwt(_ str: String) -> String? {\n  guard !str.contains(stx), !str.contains(etx) else {\n    return nil\n  }\n\n  let ss = stx + str + etx\n  let table = ss.indices.map({i in ss[i...] + ss[ss.startIndex..<i] }).sorted()\n\n  return String(table.map({str in str.last!}))\n}\n\nfunc ibwt(_ str: String) -> String? {\n  let len = str.count\n  var table = Array(repeating: \"\", count: len)\n\n  for _ in 0..<len {\n    for i in 0..<len {\n      table[i] = String(str[str.index(str.startIndex, offsetBy: i)]) + table[i]\n    }\n\n    table.sort()\n  }\n\n  for row in table where row.hasSuffix(etx) {\n    return String(row.dropFirst().dropLast())\n  }\n\n  return nil\n}\n\n\nfunc readableBwt(_ str: String) -> String {\n  return str.replacingOccurrences(of: \"\\u{2}\", with: \"^\").replacingOccurrences(of: \"\\u{3}\", with: \"|\")\n}\n\nlet testCases = [\n  \"banana\",\n  \"appellee\",\n  \"dogwood\",\n  \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n  \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n  \"\\u{2}ABC\\u{3}\"\n]\n\nfor test in testCases {\n  let b = bwt(test) ?? \"error\"\n  let c = ibwt(b) ?? \"error\"\n\n  print(\"\\(readableBwt(test)) -> \\(readableBwt(b)) -> \\(readableBwt(c))\")\n}\n", "target": "def bwt(s):\n    \n    assert \"\\002\" not in s and \"\\003\" not in s, \"Input string cannot contain STX and ETX characters\"\n    s = \"\\002\" + s + \"\\003\"  \n    table = sorted(s[i:] + s[:i] for i in range(len(s)))  \n    last_column = [row[-1:] for row in table]  \n    return \"\".join(last_column)  \n\n\ndef ibwt(r):\n    \n    table = [\"\"] * len(r)  \n    for i in range(len(r)):\n        table = sorted(r[i] + table[i] for i in range(len(r)))  \n    s = [row for row in table if row.endswith(\"\\003\")][0]  \n    return s.rstrip(\"\\003\").strip(\"\\002\")  \n"}
{"id": 419653, "name": "Burrows\u2013Wheeler transform", "source": "Translate Swift to Python: import Foundation\n\nprivate let stx = \"\\u{2}\"\nprivate let etx = \"\\u{3}\"\n\nfunc bwt(_ str: String) -> String? {\n  guard !str.contains(stx), !str.contains(etx) else {\n    return nil\n  }\n\n  let ss = stx + str + etx\n  let table = ss.indices.map({i in ss[i...] + ss[ss.startIndex..<i] }).sorted()\n\n  return String(table.map({str in str.last!}))\n}\n\nfunc ibwt(_ str: String) -> String? {\n  let len = str.count\n  var table = Array(repeating: \"\", count: len)\n\n  for _ in 0..<len {\n    for i in 0..<len {\n      table[i] = String(str[str.index(str.startIndex, offsetBy: i)]) + table[i]\n    }\n\n    table.sort()\n  }\n\n  for row in table where row.hasSuffix(etx) {\n    return String(row.dropFirst().dropLast())\n  }\n\n  return nil\n}\n\n\nfunc readableBwt(_ str: String) -> String {\n  return str.replacingOccurrences(of: \"\\u{2}\", with: \"^\").replacingOccurrences(of: \"\\u{3}\", with: \"|\")\n}\n\nlet testCases = [\n  \"banana\",\n  \"appellee\",\n  \"dogwood\",\n  \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n  \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n  \"\\u{2}ABC\\u{3}\"\n]\n\nfor test in testCases {\n  let b = bwt(test) ?? \"error\"\n  let c = ibwt(b) ?? \"error\"\n\n  print(\"\\(readableBwt(test)) -> \\(readableBwt(b)) -> \\(readableBwt(c))\")\n}\n", "target": "def bwt(s):\n    \n    assert \"\\002\" not in s and \"\\003\" not in s, \"Input string cannot contain STX and ETX characters\"\n    s = \"\\002\" + s + \"\\003\"  \n    table = sorted(s[i:] + s[:i] for i in range(len(s)))  \n    last_column = [row[-1:] for row in table]  \n    return \"\".join(last_column)  \n\n\ndef ibwt(r):\n    \n    table = [\"\"] * len(r)  \n    for i in range(len(r)):\n        table = sorted(r[i] + table[i] for i in range(len(r)))  \n    s = [row for row in table if row.endswith(\"\\003\")][0]  \n    return s.rstrip(\"\\003\").strip(\"\\002\")  \n"}
{"id": 419654, "name": "Lucky and even lucky numbers", "source": "Translate Swift to Python: struct LuckyNumbers : Sequence, IteratorProtocol {\n  let even: Bool\n  let through: Int\n  \n  private var drainI = 0\n  private var n = 0\n  private var lst: [Int]\n  \n  init(even: Bool = false, through: Int = 1_000_000) {\n    self.even = even\n    self.through = through\n    self.lst = Array(stride(from: even ? 2 : 1, through: through, by: 2))\n  }\n  \n  mutating func next() -> Int? {\n    guard n != 0 else {\n      defer { n += 1 }\n      \n      return lst[0]\n    }\n    \n    while n < lst.count && lst[n] < lst.count {\n      let retVal = lst[n]\n      \n      lst = lst.enumerated().filter({ ($0.offset + 1) % lst[n] != 0  }).map({ $0.element })\n      n += 1\n      \n      return retVal\n    }\n    \n    if drainI == 0 {\n      lst = Array(lst.dropFirst(n))\n    }\n\n    while drainI < lst.count {\n      defer { drainI += 1 }\n      \n      return lst[drainI]\n    }\n    \n    return nil\n  }\n}\n", "target": "from __future__ import print_function\n\ndef lgen(even=False, nmax=1000000):\n    start = 2 if even else 1\n    n, lst = 1, list(range(start, nmax + 1, 2))\n    lenlst = len(lst)\n    yield lst[0]\n    while n < lenlst and lst[n] < lenlst:\n        yield lst[n]\n        n, lst = n + 1, [j for i,j in enumerate(lst, 1) if i % lst[n]]\n        lenlst = len(lst)\n    \n    for i in lst[n:]:\n        yield i\n"}
{"id": 419655, "name": "Peaceful chess queen armies", "source": "Translate Swift to Python: enum Piece {\n  case empty, black, white\n}\n\ntypealias Position = (Int, Int)\n\nfunc place(_ m: Int, _ n: Int, pBlackQueens: inout [Position], pWhiteQueens: inout [Position]) -> Bool {\n  guard m != 0 else {\n    return true\n  }\n\n  var placingBlack = true\n\n  for i in 0..<n {\n    inner: for j in 0..<n {\n      let pos = (i, j)\n\n      for queen in pBlackQueens where queen == pos || !placingBlack && isAttacking(queen, pos) {\n        continue inner\n      }\n\n      for queen in pWhiteQueens where queen == pos || placingBlack && isAttacking(queen, pos) {\n        continue inner\n      }\n\n      if placingBlack {\n        pBlackQueens.append(pos)\n        placingBlack = false\n      } else {\n        placingBlack = true\n\n        pWhiteQueens.append(pos)\n\n        if place(m - 1, n, pBlackQueens: &pBlackQueens, pWhiteQueens: &pWhiteQueens) {\n          return true\n        } else {\n          pBlackQueens.removeLast()\n          pWhiteQueens.removeLast()\n        }\n      }\n    }\n  }\n\n  if !placingBlack {\n    pBlackQueens.removeLast()\n  }\n\n  return false\n}\n\nfunc isAttacking(_ queen: Position, _ pos: Position) -> Bool {\n  queen.0 == pos.0 || queen.1 == pos.1 || abs(queen.0 - pos.0) == abs(queen.1 - pos.1)\n}\n\nfunc printBoard(n: Int, pBlackQueens: [Position], pWhiteQueens: [Position]) {\n  var board = Array(repeating: Piece.empty, count: n * n)\n\n  for queen in pBlackQueens {\n    board[queen.0 * n + queen.1] = .black\n  }\n\n  for queen in pWhiteQueens {\n    board[queen.0 * n + queen.1] = .white\n  }\n\n  for (i, p) in board.enumerated() {\n    if i != 0 && i % n == 0 {\n      print()\n    }\n\n    switch p {\n    case .black:\n      print(\"B \", terminator: \"\")\n    case .white:\n      print(\"W \", terminator: \"\")\n    case .empty:\n      let j = i / n\n      let k = i - j * n\n\n      if j % 2 == k % 2 {\n        print(\"\u2022 \", terminator: \"\")\n      } else {\n        print(\"\u25e6 \", terminator: \"\")\n      }\n    }\n  }\n\n  print(\"\\n\")\n}\n\nlet nms = [\n  (2, 1), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3),\n  (5, 1), (5, 2), (5, 3), (5, 4), (5, 5),\n  (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6),\n  (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7)\n]\n\nfor (n, m) in nms {\n  print(\"\\(m) black and white queens on \\(n) x \\(n) board\")\n\n  var blackQueens = [Position]()\n  var whiteQueens = [Position]()\n\n  if place(m, n, pBlackQueens: &blackQueens, pWhiteQueens: &whiteQueens) {\n    printBoard(n: n, pBlackQueens: blackQueens, pWhiteQueens: whiteQueens)\n  } else {\n    print(\"No solution\")\n  }\n}\n", "target": "from itertools import combinations, product, count\nfrom functools import lru_cache, reduce\n\n\n_bbullet, _wbullet = '\\u2022\\u25E6'\n_or = set.__or__\n\ndef place(m, n):\n    \"Place m black and white queens, peacefully, on an n-by-n board\"\n    board = set(product(range(n), repeat=2))  \n    placements = {frozenset(c) for c in combinations(board, m)}\n    for blacks in placements:\n        black_attacks = reduce(_or, \n                               (queen_attacks_from(pos, n) for pos in blacks), \n                               set())\n        for whites in {frozenset(c)     \n                       for c in combinations(board - black_attacks, m)}:\n            if not black_attacks & whites:\n                return blacks, whites\n    return set(), set()\n\n@lru_cache(maxsize=None)\ndef queen_attacks_from(pos, n):\n    x0, y0 = pos\n    a = set([pos])    \n    a.update((x, y0) for x in range(n))    \n    a.update((x0, y) for y in range(n))    \n    \n    for x1 in range(n):\n        \n        y1 = y0 -x0 +x1\n        if 0 <= y1 < n: \n            a.add((x1, y1))\n        \n        y1 = y0 +x0 -x1\n        if 0 <= y1 < n: \n            a.add((x1, y1))\n    return a\n\ndef pboard(black_white, n):\n    \"Print board\"\n    if black_white is None: \n        blk, wht = set(), set()\n    else:\n        blk, wht = black_white\n    print(f\"\n          f\"on a {n}-by-{n} board:\", end='')\n    for x, y in product(range(n), repeat=2):\n        if y == 0:\n            print()\n        xy = (x, y)\n        ch = ('?' if xy in blk and xy in wht \n              else 'B' if xy in blk\n              else 'W' if xy in wht\n              else _bbullet if (x + y)%2 else _wbullet)\n        print('%s' % ch, end='')\n    print()\n\nif __name__ == '__main__':\n    n=2\n    for n in range(2, 7):\n        print()\n        for m in count(1):\n            ans = place(m, n)\n            if ans[0]:\n                pboard(ans, n)\n            else:\n                print (f\"\n                break\n    \n    print('\\n')\n    m, n = 5, 7\n    ans = place(m, n)\n    pboard(ans, n)\n"}
{"id": 419656, "name": "N-body problem", "source": "Translate Swift to Python: import Foundation\n\npublic struct Vector {\n  public var px = 0.0\n  public var py = 0.0\n  public var pz = 0.0\n\n  public init(px: Double, py: Double, pz: Double) {\n    (self.px, self.py, self.pz) = (px, py, pz)\n  }\n\n  public init?(array: [Double]) {\n    guard array.count == 3 else {\n      return nil\n    }\n\n    (self.px, self.py, self.pz) = (array[0], array[1], array[2])\n  }\n\n  public func mod() -> Double {\n    (px * px + py * py + pz * pz).squareRoot()\n  }\n\n  static func + (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      px: lhs.px + rhs.px,\n      py: lhs.py + rhs.py,\n      pz: lhs.pz + rhs.pz\n    )\n  }\n\n  static func - (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      px: lhs.px - rhs.px,\n      py: lhs.py - rhs.py,\n      pz: lhs.pz - rhs.pz\n    )\n  }\n\n  static func * (lhs: Vector, rhs: Double) -> Vector {\n    return Vector(\n      px: lhs.px * rhs,\n      py: lhs.py * rhs,\n      pz: lhs.pz * rhs\n    )\n  }\n}\n\nextension Vector {\n  public static let origin = Vector(px: 0, py: 0, pz: 0)\n}\n\nextension Vector: Equatable {\n  public static func == (lhs: Vector, rhs: Vector) -> Bool {\n    return lhs.px == rhs.px && lhs.py == rhs.py && lhs.pz == rhs.pz\n  }\n}\n\nextension Vector: CustomStringConvertible {\n  public var description: String {\n    return String(format: \"%.6f\\t%.6f\\t%.6f\", px, py, pz)\n  }\n}\n\npublic class NBody {\n  public let gravitationalConstant: Double\n  public let numBodies: Int\n  public let timeSteps: Int\n\n  public private(set) var masses: [Double]\n  public private(set) var positions: [Vector]\n  public private(set) var velocities: [Vector]\n  public private(set) var accelerations: [Vector]\n\n  public init?(file: String) {\n    guard let data = try? String(contentsOfFile: file) else {\n      return nil\n    }\n\n    print(\"Input file:\\n\\(data)\")\n\n    let lines = data.components(separatedBy: \"\\n\").map({ $0.components(separatedBy: \" \") })\n\n    let worldData = lines.first!\n\n    guard worldData.count == 3,\n          let gc = Double(worldData[0]),\n          let bodies = Int(worldData[1]),\n          let timeSteps = Int(worldData[2]) else {\n      return nil\n    }\n\n    let defaultState = Array(repeating: Vector.origin, count: bodies)\n\n    self.gravitationalConstant = gc\n    self.numBodies = bodies\n    self.timeSteps = timeSteps\n    self.masses = Array(repeating: 0, count: bodies)\n    self.positions = defaultState\n    self.accelerations = defaultState\n    self.velocities = defaultState\n\n    let bodyData = lines.dropFirst().map({ $0.compactMap(Double.init) })\n\n    guard bodyData.count == bodies * 3 else {\n      return nil\n    }\n\n    for n in 0..<bodies {\n      masses[n] = bodyData[0 + n * 3][0]\n\n      guard let position = Vector(array: bodyData[1 + n * 3]),\n            let velocity = Vector(array: bodyData[2 + n * 3]) else {\n        return nil\n      }\n\n      positions[n] = position\n      velocities[n] = velocity\n    }\n  }\n\n  private func computeAccelerations() {\n    for i in 0..<numBodies {\n      accelerations[i] = .origin\n\n      for j in 0..<numBodies where i != j {\n        let t = gravitationalConstant * masses[j] / pow((positions[i] - positions[j]).mod(), 3)\n        accelerations[i] = accelerations[i] + (positions[j] - positions[i]) * t\n      }\n    }\n  }\n\n  private func resolveCollisions() {\n    for i in 0..<numBodies {\n      for j in 0..<numBodies where positions[i] == positions[j] {\n        velocities.swapAt(i, j)\n      }\n    }\n  }\n\n  private func computeVelocities() {\n    for i in 0..<numBodies {\n      velocities[i] = velocities[i] + accelerations[i]\n    }\n  }\n\n  private func computePositions() {\n    for i in 0..<numBodies {\n      positions[i] = positions[i] + velocities[i] + accelerations[i] * 0.5\n    }\n  }\n\n  public func printState() {\n    for i in 0..<numBodies {\n      print(\"Body \\(i + 1): \\(positions[i])  |  \\(velocities[i])\")\n    }\n  }\n\n  public func simulate() {\n    computeAccelerations()\n    computePositions()\n    computeVelocities()\n    resolveCollisions()\n  }\n}\n\nguard let sim = NBody(file: \"input.txt\") else {\n  fatalError()\n}\n\nprint()\nprint(\"Body  \u00a0:      x          y          z    |     vx         vy         vz\")\n\nfor i in 0..<sim.timeSteps {\n  print(\"Step \\(i + 1)\")\n  sim.simulate()\n  sim.printState()\n  print()\n}\n", "target": "import math\n\nclass Vector:\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y, self.z + other.z)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y, self.z - other.z)\n\n    def __mul__(self, other):\n        return Vector(self.x * other, self.y * other, self.z * other)\n\n    def __div__(self, other):\n        return Vector(self.x / other, self.y / other, self.z / other)\n\n    def __eq__(self, other):\n        if isinstance(other, Vector):\n            return self.x == other.x and self.y == other.y and self.z == other.z\n        return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __str__(self):\n        return '({x}, {y}, {z})'.format(x=self.x, y=self.y, z=self.z)\n\n    def abs(self):\n        return math.sqrt(self.x*self.x + self.y*self.y + self.z*self.z)\n\norigin = Vector(0, 0, 0)\n\nclass NBody:\n    def __init__(self, fileName):\n        with open(fileName, \"r\") as fh:\n            lines = fh.readlines()\n            gbt = lines[0].split()\n            self.gc = float(gbt[0])\n            self.bodies = int(gbt[1])\n            self.timeSteps = int(gbt[2])\n            self.masses = [0.0 for i in range(self.bodies)]\n            self.positions = [origin for i in range(self.bodies)]\n            self.velocities = [origin for i in range(self.bodies)]\n            self.accelerations = [origin for i in range(self.bodies)]\n            for i in range(self.bodies):\n                self.masses[i] = float(lines[i*3 + 1])\n                self.positions[i] = self.__decompose(lines[i*3 + 2])\n                self.velocities[i] = self.__decompose(lines[i*3 + 3])\n\n            print \"Contents of\", fileName\n            for line in lines:\n                print line.rstrip()\n            print\n            print \"Body  \u00a0:      x          y          z    |\",\n            print \"     vx         vy         vz\"\n\n    def __decompose(self, line):\n        xyz = line.split()\n        x = float(xyz[0])\n        y = float(xyz[1])\n        z = float(xyz[2])\n        return Vector(x, y, z)\n\n    def __computeAccelerations(self):\n        for i in xrange(self.bodies):\n            self.accelerations[i] = origin\n            for j in xrange(self.bodies):\n                if i != j:\n                    temp = self.gc * self.masses[j] / math.pow((self.positions[i] - self.positions[j]).abs(), 3)\n                    self.accelerations[i] += (self.positions[j] - self.positions[i]) * temp\n        return None\n\n    def __computePositions(self):\n        for i in xrange(self.bodies):\n            self.positions[i] += self.velocities[i] + self.accelerations[i] * 0.5\n        return None\n\n    def __computeVelocities(self):\n        for i in xrange(self.bodies):\n            self.velocities[i] += self.accelerations[i]\n        return None\n\n    def __resolveCollisions(self):\n        for i in xrange(self.bodies):\n            for j in xrange(self.bodies):\n                if self.positions[i] == self.positions[j]:\n                    (self.velocities[i], self.velocities[j]) = (self.velocities[j], self.velocities[i])\n        return None\n\n    def simulate(self):\n        self.__computeAccelerations()\n        self.__computePositions()\n        self.__computeVelocities()\n        self.__resolveCollisions()\n        return None\n\n    def printResults(self):\n        fmt = \"Body %d\u00a0: % 8.6f  % 8.6f  % 8.6f | % 8.6f  % 8.6f  % 8.6f\"\n        for i in xrange(self.bodies):\n            print fmt % (i+1, self.positions[i].x, self.positions[i].y, self.positions[i].z, self.velocities[i].x, self.velocities[i].y, self.velocities[i].z)\n        return None\n\nnb = NBody(\"nbody.txt\")\nfor i in xrange(nb.timeSteps):\n    print \"\\nCycle %d\" % (i + 1)\n    nb.simulate()\n    nb.printResults()\n"}
{"id": 419657, "name": "Zumkeller numbers", "source": "Translate Swift to Python: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isZumkeller: Bool {\n    let divs = factors(sorted: false)\n    let sum = divs.reduce(0, +)\n\n    guard sum & 1 != 1 else {\n      return false\n    }\n\n    guard self & 1 != 1 else {\n      let abundance = sum - 2*self\n\n      return abundance > 0 && abundance & 1 == 0\n    }\n\n    return isPartSum(divs: divs[...], sum: sum / 2)\n  }\n\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@usableFromInline\nfunc isPartSum<T: BinaryInteger>(divs: ArraySlice<T>, sum: T) -> Bool {\n  guard sum != 0 else {\n    return true\n  }\n\n  guard !divs.isEmpty else {\n    return false\n  }\n\n  let last = divs.last!\n\n  if last > sum {\n    return isPartSum(divs: divs.dropLast(), sum: sum)\n  }\n\n  return isPartSum(divs: divs.dropLast(), sum: sum) || isPartSum(divs: divs.dropLast(), sum: sum - last)\n}\n\nlet zums = (2...).lazy.filter({ $0.isZumkeller })\nlet oddZums = zums.filter({ $0 & 1 == 1 })\nlet oddZumsWithout5 = oddZums.filter({ String($0).last! != \"5\" })\n\nprint(\"First 220 zumkeller numbers are \\(Array(zums.prefix(220)))\")\nprint(\"First 40 odd zumkeller numbers are \\(Array(oddZums.prefix(40)))\")\nprint(\"First 40 odd zumkeller numbers that don't end in a 5 are: \\(Array(oddZumsWithout5.prefix(40)))\")\n", "target": "from sympy import divisors\n\nfrom sympy.combinatorics.subsets import Subset\n\ndef isZumkeller(n):\n    d = divisors(n)\n    s = sum(d)\n    if not s % 2 and max(d) <= s/2:\n        for x in range(1, 2**len(d)):\n            if sum(Subset.unrank_binary(x, d).subset) == s/2:\n                return True\n\n    return False\n\n\n\ndef printZumkellers(N, oddonly=False):\n    nprinted = 0\n    for n in range(1, 10**5):\n        if (oddonly == False or n % 2) and isZumkeller(n):\n            print(f'{n:>8}', end='')\n            nprinted += 1\n            if nprinted % 10 == 0:\n                print()\n            if nprinted >= N:\n                return\n\n\nprint(\"220 Zumkeller numbers:\")\nprintZumkellers(220)\nprint(\"\\n\\n40 odd Zumkeller numbers:\")\nprintZumkellers(40, True)\n"}
{"id": 419658, "name": "Commatizing numbers", "source": "Translate Swift to Python: import Foundation\n\nextension String {\n  private static let commaReg = try! NSRegularExpression(pattern: \"(\\\\.[0-9]+|[1-9]([0-9]+)?(\\\\.[0-9]+)?)\")\n\n  public func commatize(start: Int = 0, period: Int = 3, separator: String = \",\") -> String {\n    guard separator != \"\" else {\n      return self\n    }\n\n    let sep = Array(separator)\n    let startIdx = index(startIndex, offsetBy: start)\n    let matches = String.commaReg.matches(in: self, range: NSRange(startIdx..., in: self))\n\n    guard !matches.isEmpty else {\n      return self\n    }\n\n    let fullMatch = String(self[Range(matches.first!.range(at: 0), in: self)!])\n    let splits = fullMatch.components(separatedBy: \".\")\n    var ip = splits[0]\n\n    if ip.count > period {\n      var builder = Array(ip.reversed())\n\n      for i in stride(from: (ip.count - 1) / period * period, through: period, by: -period) {\n        builder.insert(contentsOf: sep, at: i)\n      }\n\n      ip = String(builder.reversed())\n    }\n\n    if fullMatch.contains(\".\") {\n      var dp = splits[1]\n\n      if dp.count > period {\n        var builder = Array(dp)\n\n        for i in stride(from: (dp.count - 1) / period * period, through: period, by: -period) {\n          builder.insert(contentsOf: sep, at: i)\n        }\n\n        dp = String(builder)\n      }\n\n      ip += \".\" + dp\n    }\n\n    return String(prefix(start)) + String(dropFirst(start)).replacingOccurrences(of: fullMatch, with: ip)\n  }\n}\n\nlet tests = [\n  \"123456789.123456789\",\n  \".123456789\",\n  \"57256.1D-4\",\n  \"pi=3.14159265358979323846264338327950288419716939937510582097494459231\",\n  \"The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\",\n  \"-in Aus$+1411.8millions\",\n  \"===US$0017440 millions=== (in 2000 dollars)\",\n  \"123.e8000 is pretty big.\",\n  \"The land area of the earth is 57268900(29% of the surface) square miles.\",\n  \"Ain't no numbers in this here words, nohow, no way, Jose.\",\n  \"James was never known as 0000000007\",\n  \"Arthur Eddington wrote: I believe there are \" +\n      \"15747724136275002577605653961181555468044717914527116709366231425076185631031296\" +\n      \" protons in the universe.\",\n  \"   $-140000\u00b1100 millions.\",\n  \"6/9/1946 was a good year for some.\"\n]\n\nprint(tests[0].commatize(period: 2, separator: \"*\"))\nprint(tests[1].commatize(period: 3, separator: \"-\"))\nprint(tests[2].commatize(period: 4, separator: \"__\"))\nprint(tests[3].commatize(period: 5, separator: \" \"))\nprint(tests[4].commatize(separator: \".\"))\n\nfor testCase in tests.dropFirst(5) {\n  print(testCase.commatize())\n}\n", "target": "import re as RegEx\n\n\ndef Commatize( _string, _startPos=0, _periodLen=3, _separator=\",\" ):\n\toutString = \"\"\n\tstrPos = 0\n\tmatches = RegEx.findall( \"[0-9]*\", _string )\n\n\tfor match in matches[:-1]:\n\t\tif not match:\n\t\t\toutString += _string[ strPos ]\n\t\t\tstrPos += 1\n\t\telse:\n\t\t\tif len(match) > _periodLen:\n\t\t\t\tleadIn = match[:_startPos]\n\t\t\t\tperiods =  [ match [ i:i + _periodLen ] for i in range ( _startPos, len ( match ), _periodLen ) ]\n\t\t\t\toutString += leadIn + _separator.join( periods )\n\t\t\telse:\n\t\t\t\toutString += match\n\n\t\t\tstrPos += len( match )\n\n\treturn outString\n\n\n\nprint ( Commatize( \"pi=3.14159265358979323846264338327950288419716939937510582097494459231\", 0, 5, \" \" ) )\nprint ( Commatize( \"The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\", 0, 3, \".\" ))\nprint ( Commatize( \"\\\"-in Aus$+1411.8millions\\\"\" ))\nprint ( Commatize( \"===US$0017440 millions=== (in 2000 dollars)\" ))\nprint ( Commatize( \"123.e8000 is pretty big.\" ))\nprint ( Commatize( \"The land area of the earth is 57268900(29% of the surface) square miles.\" ))\nprint ( Commatize( \"Ain't no numbers in this here words, nohow, no way, Jose.\" ))\nprint ( Commatize( \"James was never known as 0000000007\" ))\nprint ( Commatize( \"Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe.\" ))\nprint ( Commatize( \"\u2422\u2422\u2422$-140000\u00b1100 millions.\" ))\nprint ( Commatize( \"6/9/1946 was a good year for some.\" ))\n"}
{"id": 419659, "name": "Kosaraju", "source": "Translate Swift to Python: func kosaraju(graph: [[Int]]) -> [Int] {\n  let size = graph.count\n  var x = size\n  var vis = [Bool](repeating: false, count: size)\n  var l = [Int](repeating: 0, count: size)\n  var c = [Int](repeating: 0, count: size)\n  var t = [[Int]](repeating: [], count: size)\n\n  func visit(_ u: Int) {\n    guard !vis[u] else {\n      return\n    }\n\n    vis[u] = true\n\n    for v in graph[u] {\n      visit(v)\n      t[v].append(u)\n    }\n\n    x -= 1\n    l[x] = u\n  }\n\n  for u in 0..<graph.count {\n    visit(u)\n  }\n\n  func assign(_ u: Int, root: Int) {\n    guard vis[u] else {\n      return\n    }\n\n    vis[u] = false\n    c[u] = root\n\n    for v in t[u] {\n      assign(v, root: root)\n    }\n  }\n\n  for u in l {\n    assign(u, root: u)\n  }\n\n  return c\n}\n\nlet graph = [\n  [1],\n  [2],\n  [0],\n  [1, 2, 4],\n  [3, 5],\n  [2, 6],\n  [5],\n  [4, 6, 7]\n]\n\nprint(kosaraju(graph: graph))\n", "target": "def kosaraju(g):\n    class nonlocal: pass\n\n    \n    size = len(g)\n\n    vis = [False]*size \n    l = [0]*size\n    nonlocal.x = size\n    t = [[]]*size   \n\n    def visit(u):\n        if not vis[u]:\n            vis[u] = True\n            for v in g[u]:\n                visit(v)\n                t[v] = t[v] + [u]\n            nonlocal.x = nonlocal.x - 1\n            l[nonlocal.x] = u\n\n    \n    for u in range(len(g)):\n        visit(u)\n    c = [0]*size\n\n    def assign(u, root):\n        if vis[u]:\n            vis[u] = False\n            c[u] = root\n            for v in t[u]:\n                assign(v, root)\n\n    \n    for u in l:\n        assign(u, u)\n\n    return c\n\ng = [[1], [2], [0], [1,2,4], [3,5], [2,6], [5], [4,6,7]]\nprint kosaraju(g)\n"}
{"id": 419660, "name": "Markov chain text generator", "source": "Translate Swift to Python: import Foundation\n\nfunc makeRule(input: String, keyLength: Int) -> [String: [String]] {\n  let words = input.components(separatedBy: \" \")\n  var rules = [String: [String]]()\n  var i = keyLength\n  \n  for word in words[i...] {\n    let key = words[i-keyLength..<i].joined(separator: \" \")\n    \n    rules[key, default: []].append(word)\n    \n    i += 1\n  }\n  \n  return rules\n}\n\nfunc makeString(rule: [String: [String]], length: Int) -> String {\n  var oldWords = rule.keys.randomElement()!.components(separatedBy: \" \")\n  var string = oldWords.joined(separator: \" \") + \" \"\n  \n  for _ in 0..<length {\n    let key = oldWords.joined(separator: \" \")\n    guard let newWord = rule[key]?.randomElement() else { return string }\n    \n    string += newWord + \" \"\n    \n    for ii in 0..<oldWords.count {\n      oldWords[ii] = oldWords[(ii + 1) % oldWords.count]\n    }\n    \n    oldWords[oldWords.index(before: oldWords.endIndex)] = newWord\n  }\n  \n  return string\n}\n\nlet inputLoc = CommandLine.arguments.dropFirst().first!\nlet input = FileManager.default.contents(atPath: inputLoc)!\nlet inputStr = String(data: input, encoding: .utf8)!\nlet rule = makeRule(input: inputStr, keyLength: 3)\nlet str = makeString(rule: rule, length: 300)\n\nprint(str)\n", "target": "import random, sys\n\ndef makerule(data, context):\n    \n    rule = {}\n    words = data.split(' ')\n    index = context\n    \n    for word in words[index:]:\n        key = ' '.join(words[index-context:index])\n        if key in rule:\n            rule[key].append(word)\n        else:\n            rule[key] = [word]\n        index += 1\n\n    return rule\n\n\ndef makestring(rule, length):    \n    \n    oldwords = random.choice(list(rule.keys())).split(' ') \n    string = ' '.join(oldwords) + ' '\n    \n    for i in range(length):\n        try:\n            key = ' '.join(oldwords)\n            newword = random.choice(rule[key])\n            string += newword + ' '\n\n            for word in range(len(oldwords)):\n                oldwords[word] = oldwords[(word + 1) % len(oldwords)]\n            oldwords[-1] = newword\n\n        except KeyError:\n            return string\n    return string\n\n\nif __name__ == '__main__':\n    with open(sys.argv[1], encoding='utf8') as f:\n        data = f.read()\n    rule = makerule(data, int(sys.argv[2]))\n    string = makestring(rule, int(sys.argv[3]))\n    print(string)\n"}
{"id": 419661, "name": "Word break problem", "source": "Translate Swift to Python: infix operator ??= : AssignmentPrecedence\n\n@inlinable\npublic func ??= <T>(lhs: inout T?, rhs: T?) {\n  lhs = lhs ?? rhs\n}\n\nprivate func createString(_ from: String, _ v: [Int?]) -> String {\n  var idx = from.count\n  var sliceVec = [Substring]()\n\n  while let prev = v[idx] {\n    let s = from.index(from.startIndex, offsetBy: prev)\n    let e = from.index(from.startIndex, offsetBy: idx)\n    \n    sliceVec.append(from[s..<e])\n    idx = prev\n  }\n\n  return sliceVec.reversed().joined(separator: \" \")\n}\n\npublic func wordBreak(str: String, dict: Set<String>) -> String? {\n  let size = str.count + 1\n  var possible = [Int?](repeating: nil, count: size)\n\n  func checkWord(i: Int, j: Int) -> Int? {\n    let s = str.index(str.startIndex, offsetBy: i)\n    let e = str.index(str.startIndex, offsetBy: j)\n\n    return dict.contains(String(str[s..<e])) ? i : nil\n  }\n\n  for i in 1..<size {\n    possible[i] ??= checkWord(i: 0, j: i)\n\n    guard possible[i] != nil else {\n      continue\n    }\n\n    for j in i+1..<size {\n      possible[j] ??= checkWord(i: i, j: j)\n    }\n\n    if possible[str.count] != nil {\n      return createString(str, possible)\n    }\n  }\n\n  return nil\n}\n\nlet words = [\n  \"a\",\n  \"bc\",\n  \"abc\",\n  \"cd\",\n  \"b\"\n] as Set\n\nlet testCases = [\n  \"abcd\",\n  \"abbc\",\n  \"abcbcd\",\n  \"acdbc\",\n  \"abcdd\"\n]\n\nfor test in testCases {\n  print(\"\\(test):\")\n  print(\"  \\(wordBreak(str: test, dict: words) ?? \"did not parse with given words\")\")\n}\n", "target": "\n\nfrom itertools import (chain)\n\n\n\ndef stringParse(lexicon):\n    \n    return lambda s: Node(s)(\n        tokenTrees(lexicon)(s)\n    )\n\n\n\ndef tokenTrees(wds):\n    \n    def go(s):\n        return [Node(s)([])] if s in wds else (\n            concatMap(nxt(s))(wds)\n        )\n\n    def nxt(s):\n        return lambda w: parse(\n            w, go(s[len(w):])\n        ) if s.startswith(w) else []\n\n    def parse(w, xs):\n        return [Node(w)(xs)] if xs else xs\n\n    return lambda s: go(s)\n\n\n\ndef showParse(tree):\n    \n    def showTokens(x):\n        xs = x['nest']\n        return ' ' + x['root'] + (showTokens(xs[0]) if xs else '')\n    parses = tree['nest']\n    return tree['root'] + ':\\n' + (\n        '\\n'.join(\n            map(showTokens, parses)\n        ) if parses else ' ( Not parseable in terms of these words )'\n    )\n\n\n\n\ndef main():\n    \n\n    lexicon = 'a bc abc cd b'.split()\n    testSamples = 'abcd abbc abcbcd acdbc abcdd'.split()\n\n    print(unlines(\n        map(\n            showParse,\n            map(\n                stringParse(lexicon),\n                testSamples\n            )\n        )\n    ))\n\n\n\n\n\ndef Node(v):\n    \n    return lambda xs: {'type': 'Node', 'root': v, 'nest': xs}\n\n\n\ndef concatMap(f):\n    \n    return lambda xs: list(\n        chain.from_iterable(map(f, xs))\n    )\n\n\n\ndef unlines(xs):\n    \n    return '\\n'.join(xs)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 419662, "name": "OpenWebNet password", "source": "Translate Swift to Python: func openAuthenticationResponse(_password: String, operations: String) -> String? {\n    var num1 = UInt32(0)\n    var num2 = UInt32(0)\n    var start = true\n    let password = UInt32(_password)!\n    for c in operations {\n        if (c != \"0\") {\n            if start {\n                num2 = password\n            }\n            start = false\n        }\n        switch c {\n        case \"1\":\n            num1 = (num2 & 0xffffff80) >> 7\n            num2 = num2 << 25\n        case \"2\":\n            num1 = (num2 & 0xfffffff0) >> 4\n            num2 = num2 << 28\n        case \"3\":\n            num1 = (num2 & 0xfffffff8) >> 3\n            num2 = num2 << 29\n        case \"4\":\n            num1 = num2 << 1\n            num2 = num2 >> 31\n        case \"5\":\n            num1 = num1 << 5\n            num2 = num2 >> 27\n        case \"6\":\n            num1 = num2 << 12\n            num2 = num2 >> 20\n        case \"7\":\n            num1 = (num2 & 0x0000ff00) | ((num2 & 0x000000ff) << 24) | ((num2 & 0x00ff0000) >> 16)\n            num2 = (num2 & 0xff000000) >> 8\n        case \"8\":\n            num1 = ((num2 & 0x0000ffff) << 16) | (num2 >> 24)\n            num2 = (num2 & 0x00ff0000) >> 8\n        case \"9\":\n            num1 = ~num2\n        case \"0\":\n            num1 = num2\n        default:\n            print(\"unexpected char \\(c)\")\n            return nil\n        }\n        if (c != \"9\") && (c != \"0\") {\n            num1 |= num2\n        }\n        num2 = num1\n    }\n    return String(num1)\n}\n", "target": "def ownCalcPass (password, nonce, test=False) :\n    start = True    \n    num1 = 0\n    num2 = 0\n    password = int(password)\n    if test:\n        print(\"password: %08x\" % (password))\n    for c in nonce :\n        if c != \"0\":\n            if start:\n                num2 = password\n            start = False\n        if test:\n            print(\"c: %s num1: %08x num2: %08x\" % (c, num1, num2))\n        if c == '1':\n            num1 = (num2 & 0xFFFFFF80) >> 7\n            num2 = num2 << 25\n        elif c == '2':\n            num1 = (num2 & 0xFFFFFFF0) >> 4\n            num2 = num2 << 28\n        elif c == '3':\n            num1 = (num2 & 0xFFFFFFF8) >> 3\n            num2 = num2 << 29\n        elif c == '4':\n            num1 = num2 << 1\n            num2 = num2 >> 31\n        elif c == '5':\n            num1 = num2 << 5\n            num2 = num2 >> 27\n        elif c == '6':\n            num1 = num2 << 12\n            num2 = num2 >> 20\n        elif c == '7':\n            num1 = num2 & 0x0000FF00 | (( num2 & 0x000000FF ) << 24 ) | (( num2 & 0x00FF0000 ) >> 16 )\n            num2 = ( num2 & 0xFF000000 ) >> 8\n        elif c == '8':\n            num1 = (num2 & 0x0000FFFF) << 16 | ( num2 >> 24 )\n            num2 = (num2 & 0x00FF0000) >> 8\n        elif c == '9':\n            num1 = ~num2\n        else :\n            num1 = num2\n\n        num1 &= 0xFFFFFFFF\n        num2 &= 0xFFFFFFFF\n        if (c not in \"09\"):\n            num1 |= num2\n        if test:\n            print(\"     num1: %08x num2: %08x\" % (num1, num2))\n        num2 = num1\n    return num1\n\ndef test_passwd_calc(passwd, nonce, expected):\n    res = ownCalcPass(passwd, nonce, False)\n    m = passwd+' '+nonce+' '+str(res)+' '+str(expected)\n    if res == int(expected) :\n        print('PASS '+m)\n    else :\n        print('FAIL '+m)\n\nif __name__ == '__main__':\n    test_passwd_calc('12345','603356072','25280520')\n    test_passwd_calc('12345','410501656','119537670')\n    test_passwd_calc('12345','630292165','4269684735')\n"}
{"id": 419663, "name": "Partition function P", "source": "Translate Swift to Python: import BigInt \n\nfunc partitions(n: Int) -> BigInt {\n  var p = [BigInt(1)]\n\n  for i in 1...n {\n    var num = BigInt(0)\n    var k = 1\n\n    while true {\n      var j = (k * (3 * k - 1)) / 2\n\n      if j > i {\n        break\n      }\n\n      if k & 1 == 1 {\n        num += p[i - j]\n      } else {\n        num -= p[i - j]\n      }\n\n      j += k\n\n      if j > i {\n        break\n      }\n\n      if k & 1 == 1 {\n        num += p[i - j]\n      } else {\n        num -= p[i - j]\n      }\n\n      k += 1\n    }\n\n    p.append(num)\n  }\n\n  return p[n]\n}\n\nprint(\"partitions(6666) = \\(partitions(n: 6666))\")\n", "target": "from itertools import islice\n\ndef posd():\n    \"diff between position numbers. 1, 2, 3... interleaved with  3, 5, 7...\"\n    count, odd = 1, 3\n    while True:\n        yield count\n        yield odd\n        count, odd = count + 1, odd + 2\n\ndef pos_gen():\n    \"position numbers. 1 3 2 5 7 4 9 ...\"\n    val = 1\n    diff = posd()\n    while True:\n        yield val\n        val += next(diff)\n                \ndef plus_minus():\n    \"yield (list_offset, sign) or zero for Partition calc\"\n    n, sign = 0, [1, 1]\n    p_gen = pos_gen()\n    out_on = next(p_gen)\n    while True:\n        n += 1\n        if n == out_on:\n            next_sign = sign.pop(0)\n            if not sign:\n                sign = [-next_sign] * 2\n            yield -n, next_sign\n            out_on = next(p_gen)\n        else:\n            yield 0\n            \ndef part(n):\n    \"Partition numbers\"\n    p = [1]\n    p_m = plus_minus()\n    mods = []\n    for _ in range(n):\n        next_plus_minus = next(p_m)\n        if next_plus_minus:\n            mods.append(next_plus_minus)\n        p.append(sum(p[offset] * sign for offset, sign in mods))\n    return p[-1]\n        \nprint(\"(Intermediaries):\")\nprint(\"    posd:\", list(islice(posd(), 10)))\nprint(\"    pos_gen:\", list(islice(pos_gen(), 10)))\nprint(\"    plus_minus:\", list(islice(plus_minus(), 15)))\nprint(\"\\nPartitions:\", [part(x) for x in range(15)])\n"}
{"id": 419664, "name": "Special divisors", "source": "Translate Swift to Python: import Foundation\n\nfunc reverse(_ number: Int) -> Int {\n    var rev = 0\n    var n = number\n    while n > 0 {\n        rev = rev * 10 + n % 10\n        n /= 10\n    }\n    return rev\n}\n\nfunc special(_ number: Int) -> Bool {\n    var n = 2\n    let rev = reverse(number)\n    while n * n <= number {\n        if number % n == 0 {\n            if rev % reverse(n) != 0 {\n                return false\n            }\n            let m = number / n\n            if m != n && rev % reverse(m) != 0 {\n                return false\n            }\n        }\n        n += 1\n    }\n    return true\n}\n\nvar count = 0\nfor n in 1..<200 {\n    if special(n) {\n        count += 1\n        print(String(format: \"%3d\", n),\n              terminator: count % 10 == 0 ? \"\\n\" : \" \")\n    }\n}\nprint(\"\\n\\(count) numbers found.\")\n", "target": "\n\ndef reverse(n):\n    u = 0\n    while n:\n        u = 10 * u + n % 10\n        n = int(n / 10)\n    return u\n\nc = 0\nfor n in range(1, 200):\n    u = reverse(n)\n    s = True\n    \n    for d in range (1, n):\n        if n % d == 0:\n            b = reverse(d)\n            if u % b != 0:\n                s = False\n    if s:\n        c = c + 1\n        print(n, end='\\t')\n                \nprint(\"\\nEncontrados \", c, \"divisores especiales.\")\n"}
{"id": 419665, "name": "Nimber arithmetic", "source": "Translate Swift to Python: import Foundation\n\n\nfunc hpo2(_ n: Int) -> Int {\n    n & -n\n}\n\n\nfunc lhpo2(_ n: Int) -> Int {\n    var q: Int = 0\n    var m: Int = hpo2(n)\n    while m % 2 == 0 {\n        m >>= 1\n        q += 1\n    }\n    return q\n}\n\n\nfunc nimSum(x: Int, y: Int) -> Int {\n    x ^ y\n}\n\n\nfunc nimProduct(x: Int, y: Int) -> Int {\n    if x < 2 || y < 2 {\n        return x * y\n    }\n    var h = hpo2(x);\n    if x > h {\n        return nimProduct(x: h, y: y) ^ nimProduct(x: x ^ h, y: y)\n    }\n    if hpo2(y) < y {\n        return nimProduct(x: y, y: x)\n    }\n    let xp = lhpo2(x)\n    let yp = lhpo2(y)\n    let comp = xp & yp\n    if comp == 0 {\n        return x * y\n    }\n    h = hpo2(comp)\n    return nimProduct(x: nimProduct(x: x >> h, y: y >> h), y: 3 << (h - 1))\n}\n\nfunc printTable(n: Int, op: Character, function: (Int, Int) -> Int) {\n    print(\" \\(op) |\", terminator: \"\")\n    for a in 0...n {\n        print(String(format: \"%3d\", a), terminator: \"\")\n    }\n    print(\"\\n--- -\", terminator: \"\")\n    for _ in 0...n {\n        print(\"---\", terminator: \"\")\n    }\n    print()\n    for b in 0...n {\n        print(\"\\(String(format: \"%2d\", b)) |\", terminator: \"\")\n        for a in 0...n {\n            print(String(format: \"%3d\", function(a, b)), terminator: \"\")\n        }\n        print()\n    }\n}\n\nprintTable(n: 15, op: \"+\", function: nimSum)\nprint()\nprintTable(n: 15, op: \"*\", function: nimProduct)\nlet a: Int = 21508\nlet b: Int = 42689\nprint(\"\\n\\(a) + \\(b) = \\(nimSum(x: a, y: b))\")\nprint(\"\\(a) * \\(b) = \\(nimProduct(x: a, y: b))\")\n", "target": "\ndef hpo2(n): return n & (-n)\n\n\ndef lhpo2(n):\n    q = 0\n    m = hpo2(n)\n    while m%2 == 0:\n        m = m >> 1\n        q += 1\n    return q\n\ndef nimsum(x,y): return x ^ y\n\ndef nimprod(x,y):\n    if x < 2 or y < 2:\n        return x * y\n    h = hpo2(x)\n    if x > h:\n        return nimprod(h, y) ^ nimprod(x^h, y) \n    if hpo2(y) < y:\n        return nimprod(y, x) \n    xp, yp = lhpo2(x), lhpo2(y)\n    comp = xp & yp\n    if comp == 0:\n        return x * y \n    h = hpo2(comp)\n    \n    return nimprod(nimprod(x>>h, y>>h), 3<<(h-1))\n\nif __name__ == '__main__':\n    for f, op in ((nimsum, '+'), (nimprod, '*')):\n        print(f\" {op} |\", end='')\n        for i in range(16):\n            print(f\"{i:3d}\", end='')\n        print(\"\\n--- \" + \"-\"*48)\n        for i in range(16):\n            print(f\"{i:2d} |\", end='')\n            for j in range(16):\n                print(f\"{f(i,j):3d}\", end='')\n            print()\n        print()\n\n    a, b = 21508, 42689\n    print(f\"{a} + {b} = {nimsum(a,b)}\")\n    print(f\"{a} * {b} = {nimprod(a,b)}\")\n"}
{"id": 419666, "name": "Legendre prime counting function", "source": "Translate Swift to Python: import Foundation\n\nextension Numeric where Self: Strideable {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nfunc eratosthenes(limit: Int) -> [Int] {\n  guard limit >= 3 else {\n    return limit < 2 ? [] : [2]\n  }\n\n  let ndxLimit = (limit - 3) / 2 + 1\n  let bufSize = ((limit - 3) / 2) / 32 + 1\n  let sqrtNdxLimit = (Int(Double(limit).squareRoot()) - 3) / 2 + 1\n  var cmpsts = Array(repeating: 0, count: bufSize)\n\n  for ndx in 0..<sqrtNdxLimit where (cmpsts[ndx >> 5] & (1 << (ndx & 31))) == 0 {\n    let p = ndx + ndx + 3\n    var cullPos = (p * p - 3) / 2\n\n    while cullPos < ndxLimit {\n      cmpsts[cullPos >> 5] |= 1 << (cullPos & 31)\n\n      cullPos += p\n    }\n  }\n\n  return (-1..<ndxLimit).compactMap({i -> Int? in\n    if i < 0 {\n      return 2\n    } else {\n      if cmpsts[i >> 5] & (1 << (i & 31)) == 0 {\n        return .some(i + i + 3)\n      } else {\n        return nil\n      }\n    }\n  })\n}\n\nlet primes = eratosthenes(limit: 1_000_000_000)\n\nfunc \u03c6(_ x: Int, _ a: Int) -> Int {\n  struct Cache {\n    static var cache = [String: Int]()\n  }\n\n  guard a != 0 else {\n    return x\n  }\n\n  guard Cache.cache[\"\\(x),\\(a)\"] == nil else {\n    return Cache.cache[\"\\(x),\\(a)\"]!\n  }\n\n  Cache.cache[\"\\(x),\\(a)\"] = \u03c6(x, a - 1) - \u03c6(x / primes[a - 1], a - 1)\n\n  return Cache.cache[\"\\(x),\\(a)\"]!\n}\n\nfunc \u03c0(n: Int) -> Int {\n  guard n > 2 else {\n    return 0\n  }\n\n  let a = \u03c0(n: Int(Double(n).squareRoot()))\n\n  return \u03c6(n, a) + a - 1\n}\n\nfor i in 0..<10 {\n  let n = 10.power(i)\n\n  print(\"\u03c0(10^\\(i)) = \\(\u03c0(n: n))\")\n}\n", "target": "from primesieve import primes\nfrom math import isqrt\nfrom functools import cache\n\np = primes(isqrt(1_000_000_000))\n\n@cache\ndef phi(x, a):\n    res = 0\n    while True:\n        if not a or not x:\n            return x + res\n    \n        a -= 1\n        res -= phi(x//p[a], a) \n\ndef legpi(n):\n    if n < 2: return 0\n\n    a = legpi(isqrt(n))\n    return phi(n, a) + a - 1\n\nfor e in range(10):\n    print(f'10^{e}', legpi(10**e))\n"}
{"id": 419667, "name": "Prime triangle", "source": "Translate Swift to Python: import Foundation\n\nfunc isPrime(_ n: Int) -> Bool {\n    guard n > 0 && n < 64 else {\n        return false\n    }\n    return ((UInt64(1) << n) & 0x28208a20a08a28ac) != 0\n}\n\nfunc primeTriangleRow(_ a: inout [Int], start: Int, length: Int) -> Bool {\n    if length == 2 {\n        return isPrime(a[start] + a[start + 1])\n    }\n    for i in stride(from: 1, to: length - 1, by: 2) {\n        let index = start + i\n        if isPrime(a[start] + a[index]) {\n            a.swapAt(index, start + 1)\n            if primeTriangleRow(&a, start: start + 1, length: length - 1) {\n                return true\n            }\n            a.swapAt(index, start + 1)\n        }\n    }\n    return false\n}\n\nfunc primeTriangleCount(_ a: inout [Int], start: Int, length: Int) -> Int {\n    var count = 0\n    if length == 2 {\n        if isPrime(a[start] + a[start + 1]) {\n            count += 1\n        }\n    } else {\n        for i in stride(from: 1, to: length - 1, by: 2) {\n            let index = start + i\n            if isPrime(a[start] + a[index]) {\n                a.swapAt(index, start + 1)\n                count += primeTriangleCount(&a, start: start + 1, length: length - 1)\n                a.swapAt(index, start + 1)\n            }\n        }\n    }\n    return count\n}\n\nfunc printRow(_ a: [Int]) {\n    if a.count == 0 {\n        return\n    }\n    print(String(format: \"%2d\", a[0]), terminator: \"\")\n    for x in a[1...] {\n        print(String(format: \" %2d\", x), terminator: \"\")\n    }\n    print()\n}\n\nlet startTime = CFAbsoluteTimeGetCurrent()\n\nfor n in 2...20 {\n    var a = Array(1...n)\n    if primeTriangleRow(&a, start: 0, length: n) {\n        printRow(a)\n    }\n}\nprint()\n\nfor n in 2...20 {\n    var a = Array(1...n)\n    if n > 2 {\n        print(\" \", terminator: \"\")\n    }\n    print(\"\\(primeTriangleCount(&a, start: 0, length: n))\", terminator: \"\")\n}\nprint()\n\nlet endTime = CFAbsoluteTimeGetCurrent()\nprint(\"\\nElapsed time: \\(endTime - startTime) seconds\")\n", "target": "from numpy import array\n\ndef is_prime(n: int) -> bool:\n    assert n < 64\n    return ((1 << n) & 0x28208a20a08a28ac) != 0\n\ndef prime_triangle_row(a: array, start: int, length: int) -> bool:\n    if length == 2:\n        return is_prime(a[0] + a[1])\n    for i in range(1, length - 1, 1):\n        if is_prime(a[start] + a[start + i]):\n            a[start + i], a[start + 1] = a[start + 1], a[start + i]\n            if prime_triangle_row(a, start + 1, length - 1):\n                return True\n            a[start + i], a[start + 1] = a[start + 1], a[start + i]\n    return False\n\ndef prime_triangle_count(a: array, start: int, length: int) -> int:\n    count: int = 0\n    if length == 2:\n        if is_prime(a[start] + a[start + 1]):\n            count += 1\n    else:\n        for i in range(1, length - 1, 1):\n            if is_prime(a[start] + a[start + i]):\n                a[start + i], a[start + 1] = a[start + 1], a[start + i]\n                count += prime_triangle_count(a, start + 1, length - 1)\n                a[start + i], a[start + 1] = a[start + 1], a[start + i]\n    return count\n\ndef print_row(a: array):\n    if a == []:\n        return\n    print(\"%2d\"% a[0], end=\" \")\n    for x in a[1:]:\n        print(\"%2d\"% x, end=\" \")\n    print()\n\nfor n in range(2, 21):\n    tr: array = [_ for _ in range(1, n + 1)]\n    if prime_triangle_row(tr, 0, n):\n        print_row(tr)\nprint()\nfor n in range(2, 21):\n    tr: array = [_ for _ in range(1, n + 1)]\n    if n > 2:\n        print(\" \", end=\"\")\n    print(prime_triangle_count(tr, 0, n), end=\"\")\nprint()\n"}
{"id": 419668, "name": "Word ladder", "source": "Translate Swift to Python: import Foundation\n\nfunc oneAway(string1: [Character], string2: [Character]) -> Bool {\n    if string1.count != string2.count {\n        return false\n    }\n    var result = false\n    var i = 0\n    while i < string1.count {\n        if string1[i] != string2[i] {\n            if result {\n                return false\n            }\n            result = true\n        }\n        i += 1\n    }\n    return result\n}\n\nfunc wordLadder(words: [[Character]], from: String, to: String) {\n    let fromCh = Array(from)\n    let toCh = Array(to)\n    var poss = words.filter{$0.count == fromCh.count}\n    var queue: [[[Character]]] = [[fromCh]]\n    while !queue.isEmpty {\n        var curr = queue[0]\n        let last = curr[curr.count - 1]\n        queue.removeFirst()\n        let next = poss.filter{oneAway(string1: $0, string2: last)}\n        if next.contains(toCh) {\n            curr.append(toCh)\n            print(curr.map{String($0)}.joined(separator: \" -> \"))\n            return\n        }\n        poss.removeAll(where: {next.contains($0)})\n        for str in next {\n            var temp = curr\n            temp.append(str)\n            queue.append(temp)\n        }\n    }\n    print(\"\\(from) into \\(to) cannot be done.\")\n}\n\ndo {\n    let words = try String(contentsOfFile: \"unixdict.txt\", encoding: String.Encoding.ascii)\n        .components(separatedBy: \"\\n\")\n        .filter{!$0.isEmpty}\n        .map{Array($0)}\n    wordLadder(words: words, from: \"man\", to: \"boy\")\n    wordLadder(words: words, from: \"girl\", to: \"lady\")\n    wordLadder(words: words, from: \"john\", to: \"jane\")\n    wordLadder(words: words, from: \"child\", to: \"adult\")\n    wordLadder(words: words, from: \"cat\", to: \"dog\")\n    wordLadder(words: words, from: \"lead\", to: \"gold\")\n    wordLadder(words: words, from: \"white\", to: \"black\")\n    wordLadder(words: words, from: \"bubble\", to: \"tickle\")\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import os,sys,zlib,urllib.request\n\ndef h ( str,x=9 ):\n    for c in str :\n        x = ( x*33 + ord( c )) & 0xffffffffff\n    return x  \n\ndef cache ( func,*param ):\n    n = 'cache_%x.bin'%abs( h( repr( param )))\n    try    : return eval( zlib.decompress( open( n,'rb' ).read()))\n    except : pass\n    s = func( *param )\n    open( n,'wb' ).write( zlib.compress( bytes( repr( s ),'ascii' )))\n    return s\n\ndico_url  = 'https://raw.githubusercontent.com/quinnj/Rosetta-Julia/master/unixdict.txt'\nread_url  = lambda url   : urllib.request.urlopen( url ).read()\nload_dico = lambda url   : tuple( cache( read_url,url ).split( b'\\n'))\nisnext    = lambda w1,w2 : len( w1 ) == len( w2 ) and len( list( filter( lambda l : l[0]!=l[1] , zip( w1,w2 )))) == 1\n\ndef build_map ( words ):\n    map = [(w.decode('ascii'),[]) for w in words]\n    for i1,(w1,n1) in enumerate( map ):\n        for i2,(w2,n2) in enumerate( map[i1+1:],i1+1 ):\n            if isnext( w1,w2 ):\n                n1.append( i2 )\n                n2.append( i1 )\n    return map\n\ndef find_path ( words,w1,w2 ):\n    i = [w[0] for w in words].index( w1 )\n    front,done,res  = [i],{i:-1},[]\n    while front :\n        i = front.pop(0)\n        word,next = words[i]\n        for n in next :\n            if n in done : continue\n            done[n] = i\n            if words[n][0] == w2 :\n                while n >= 0 :\n                    res = [words[n][0]] + res\n                    n = done[n]\n                return ' '.join( res )\n            front.append( n )\n    return '%s can not be turned into %s'%( w1,w2 )\n\nfor w in ('boy man','girl lady','john jane','alien drool','child adult'):\n    print( find_path( cache( build_map,load_dico( dico_url )),*w.split()))\n"}
{"id": 419669, "name": "Geohash", "source": "Translate Swift to Python: let base32 = \"0123456789bcdefghjkmnpqrstuvwxyz\" \n\nextension String {\n  subscript(i: Int) -> String {\n    String(self[index(startIndex, offsetBy: i)])\n  }\n}\n\nstruct Coordinate {\n  var latitude: Double\n  var longitude: Double\n\n  func toString() -> String {\n    var latitudeHemisphere = \"\"\n    var longitudeHemisphere = \"\"\n\n    latitudeHemisphere = latitude < 0 ? \" S\" : \" N\"\n    longitudeHemisphere = longitude < 0 ? \" W\" : \" E\"\n\n    return \"\\(abs(latitude))\\(latitudeHemisphere), \\(abs(longitude))\\(longitudeHemisphere)\"\n  }\n}\n\nfunc encodeGeohash (for coordinate: Coordinate, withPrecision precision: Int = 9) -> String {\n  var latitudeRange = -90.0...90.0\n  var longitudeRange = -180...180.0\n\n  var hash = \"\"\n  var hashVal = 0\n  var bits = 0\n  var even = true\n\n  while (hash.count < precision) {\n    let val     = even ? coordinate.longitude: coordinate.latitude\n    var range   = even ? longitudeRange : latitudeRange\n    let mid     = (range.lowerBound + range.upperBound) / 2\n\n    if (val > mid) {\n      hashVal = (hashVal << 1) + 1\n      range = mid...range.upperBound\n\n      if even { longitudeRange = mid...longitudeRange.upperBound }\n      else    {  latitudeRange = mid...latitudeRange.upperBound }\n    } else {\n      hashVal = (hashVal << 1) + 0\n      range   = range.lowerBound...mid\n\n      if even { longitudeRange = longitudeRange.lowerBound...mid }\n      else    {  latitudeRange =  latitudeRange.lowerBound...mid }\n    }\n\n    even = !even\n\n    if (bits < 4) {\n      bits += 1\n    } else {\n      bits = 0\n      hash += base32[hashVal]\n      hashVal = 0\n    }\n  }\n  return hash\n}\n\nlet coordinate1 = Coordinate(latitude: 51.433718, longitude: -0.214126)\nlet coordinate2 = Coordinate(latitude: 57.649110, longitude: 10.407440)\n\nprint (\"Geohash for: \\(coordinate1.toString()), precision = 5\u00a0: \\(encodeGeohash(for: coordinate, withPrecision: 5))\")\nprint (\"Geohash for: \\(coordinate1.toString()), precision = 9\u00a0: \\(encodeGeohash(for: coordinate))\")\nprint (\"Geohash for: \\(coordinate2.toString()), precision = 11\u00a0: \\(encodeGeohash(for: coordinate, withPrecision: 11))\")\n", "target": "ch32 = \"0123456789bcdefghjkmnpqrstuvwxyz\"\nbool2ch = {f\"{i:05b}\": ch for i, ch in enumerate(ch32)}\nch2bool = {v : k for k, v in bool2ch.items()}\n\ndef bisect(val, mn, mx, bits):\n    mid = (mn + mx) / 2\n    if val < mid:\n        bits <<= 1                        \n        mx = mid                          \n    else:\n        bits = bits << 1 | 1              \n        mn = mid                          \n\n    return mn, mx, bits\n\ndef encoder(lat, lng, pre):\n    latmin, latmax = -90, 90\n    lngmin, lngmax = -180, 180\n    bits = 0\n    for i in range(pre * 5):\n        if i % 2:\n            \n            latmin, latmax, bits = bisect(lat, latmin, latmax, bits)\n        else:\n            \n            lngmin, lngmax, bits = bisect(lng, lngmin, lngmax, bits)\n    \n    b = f\"{bits:0{pre * 5}b}\"\n    geo = (bool2ch[b[i*5: (i+1)*5]] for i in range(pre))\n\n    return ''.join(geo)\n\ndef decoder(geo):\n    minmaxes, latlong = [[-90.0, 90.0], [-180.0, 180.0]], True\n    for c in geo:\n        for bit in ch2bool[c]:\n            minmaxes[latlong][bit != '1'] = sum(minmaxes[latlong]) / 2\n            latlong = not latlong\n\n    return minmaxes\n\nif __name__ == '__main__':\n    for (lat, lng), pre in [([51.433718, -0.214126],  2),\n                            ([51.433718, -0.214126],  9),\n                            ([57.64911,  10.40744] , 11),\n                            ([57.64911,  10.40744] , 22)]:\n        print(\"encoder(lat=%f, lng=%f, pre=%i) = %r\"\n              % (lat, lng, pre, encoder(lat, lng, pre)))\n"}
{"id": 419670, "name": "Super-Poulet numbers", "source": "Translate Swift to Python: func divisors(number: UInt32) -> [UInt32] {\n    var result: [UInt32] = [1]\n    var power: UInt32 = 2\n    var n = number\n    while (n & 1) == 0 {\n        result.append(power)\n        power <<= 1\n        n >>= 1\n    }\n    var p: UInt32 = 3\n    while p * p <= n {\n        let size = result.count\n        power = p\n        while n % p == 0 {\n            for i in 0..<size {\n                result.append(power * result[i])\n            }\n            n /= p\n            power *= p\n        }\n        p += 2\n    }\n    if n > 1 {\n        let size = result.count\n        for i in 0..<size {\n            result.append(n * result[i])\n        }\n    }\n    return result\n}\n\nfunc modPow(base: UInt64, exponent: UInt32, mod: UInt32) -> UInt64 {\n    if mod == 1 {\n        return 0\n    }\n    var result: UInt64 = 1\n    var exp = exponent\n    var b = base\n    let m = UInt64(mod)\n    b %= m\n    while exp > 0 {\n        if (exp & 1) == 1 {\n            result = (result * b) % m\n        }\n        b = (b * b) % m\n        exp >>= 1\n    }\n    return result\n}\n\nfunc isPrime(number: UInt32) -> Bool {\n    if number < 2 {\n        return false\n    }\n    if number % 2 == 0 {\n        return number == 2\n    }\n    if number % 3 == 0 {\n        return number == 3\n    }\n    if number % 5 == 0 {\n        return number == 5\n    }\n    var p: UInt32 = 7\n    let wheel: [UInt32] = [4,2,4,2,4,6,2,6]\n    while true {\n        for w in wheel {\n            if p * p > number {\n                return true\n            }\n            if number % p == 0 {\n                return false\n            }\n            p += w\n        }\n    }\n}\n\nfunc isPouletNumber(_ n: UInt32) -> Bool {\n    return modPow(base: 2, exponent: n - 1, mod: n) == 1 && !isPrime(number: n)\n}\n\nfunc isSuperPouletNumber(_ n: UInt32) -> Bool {\n    if (!isPouletNumber(n)) {\n        return false\n    }\n    let div = divisors(number: n)\n    return div[1...].allSatisfy({modPow(base: 2, exponent: $0, mod: $0) == 2})\n}\n\nvar n: UInt32 = 1\nvar count = 0\n\nprint(\"First 20 super-Poulet numbers:\")\nwhile count < 20 {\n    if (isSuperPouletNumber(n)) {\n        count += 1\n        print(\"\\(n)\", terminator: \" \")\n    }\n    n += 2\n}\nprint()\n\nvar limit = 1000000\nwhile limit <= 10000000 {\n    while true {\n        n += 2\n        if (isSuperPouletNumber(n)) {\n            count += 1\n            if (n > limit) {\n                break\n            }\n        }\n    }\n    print(\"\\nIndex and value of first super-Poulet greater than \\(limit):\\n#\\(count) is \\(n)\")\n    limit *= 10\n}\n", "target": "from sympy import isprime, divisors\n \ndef is_super_Poulet(n):\n    return not isprime(n) and 2**(n - 1) % n == 1 and all((2**d - 2) % d == 0 for d in divisors(n))\n\nspoulets = [n for n in range(1, 1_100_000) if is_super_Poulet(n)]\n\nprint('The first 20 super-Poulet numbers are:', spoulets[:20])\n\nidx1m, val1m = next((i, v) for i, v in enumerate(spoulets) if v > 1_000_000)\nprint(f'The first super-Poulet number over 1 million is the {idx1m}th one, which is {val1m}')\n"}
{"id": 419671, "name": "Wordle comparison", "source": "Translate Swift to Python: enum Colour : CustomStringConvertible {\n  case grey\n  case yellow\n  case green\n  \n  var description : String {\n    switch self {\n    case .grey: return \"grey\"\n    case .yellow: return \"yellow\"\n    case .green: return \"green\"\n    }\n  }\n}\n\nfunc wordle(answer: String, guess: String) -> [Colour]? {\n    guard answer.count == guess.count else {\n        return nil\n    }\n    var a = Array(answer)\n    let g = Array(guess)\n    let n = a.count\n    var result = Array(repeating: Colour.grey, count: n)\n    for i in 0..<n {\n        if g[i] == a[i] {\n            a[i] = \"\\0\"\n            result[i] = Colour.green\n        }\n    }\n    for i in 0..<n {\n        if let j = a.firstIndex(of: g[i]) {\n            a[j] = \"\\0\"\n            result[i] = Colour.yellow\n        }\n    }\n    return result\n}\n\nlet pairs = [(\"ALLOW\", \"LOLLY\"), (\"BULLY\", \"LOLLY\"),\n              (\"ROBIN\", \"ALERT\"), (\"ROBIN\", \"SONIC\"),\n              (\"ROBIN\", \"ROBIN\")]\n\nfor pair in pairs {\n    if let result = wordle(answer: pair.0, guess: pair.1) {\n        print(\"\\(pair.0) v \\(pair.1) => \\(result)\")\n    }\n}\n", "target": "\n\nfrom functools import reduce\nfrom operator import add\n\n\n\ndef wordleScore(target, guess):\n    \n    return mapAccumL(amber)(\n        *first(charCounts)(\n            mapAccumL(green)(\n                [], zip(target, guess)\n            )\n        )\n    )[1]\n\n\n\ndef green(residue, tg):\n    \n    t, g = tg\n    return (residue, (g, 2)) if t == g else (\n        [t] + residue, (g, 0)\n    )\n\n\n\ndef amber(tally, cn):\n    \n    c, n = cn\n    return (tally, 2) if 2 == n else (\n        adjust(\n            lambda x: x - 1,\n            c, tally\n        ),\n        1\n    ) if 0 < tally.get(c, 0) else (tally, 0)\n\n\n\n\ndef main():\n    \n    print(' -> '.join(['Target', 'Guess', 'Scores']))\n    print()\n    print(\n        '\\n'.join([\n            wordleReport(*tg) for tg in [\n                (\"ALLOW\", \"LOLLY\"),\n                (\"CHANT\", \"LATTE\"),\n                (\"ROBIN\", \"ALERT\"),\n                (\"ROBIN\", \"SONIC\"),\n                (\"ROBIN\", \"ROBIN\"),\n                (\"BULLY\", \"LOLLY\"),\n                (\"ADAPT\", \"S\u00c5L\u00c5D\"),\n                (\"Ukraine\", \"Ukra\u00edne\"),\n                (\"BBAAB\", \"BBBBBAA\"),\n                (\"BBAABBB\", \"AABBBAA\")\n            ]\n        ])\n    )\n\n\n\ndef wordleReport(target, guess):\n    \n    scoreName = {2: 'green', 1: 'amber', 0: 'gray'}\n\n    if 5 != len(target):\n        return f'{target}: Expected 5 character target.'\n    elif 5 != len(guess):\n        return f'{guess}: Expected 5 character guess.'\n    else:\n        scores = wordleScore(target, guess)\n        return ' -> '.join([\n            target, guess, repr(scores),\n            ' '.join([\n                scoreName[n] for n in scores\n            ])\n        ])\n\n\n\n\n\ndef adjust(f, k, dct):\n    \n    return dict(\n        dct,\n        **{k: f(dct[k]) if k in dct else None}\n    )\n\n\n\ndef charCounts(s):\n    \n    return reduce(\n        lambda a, c: insertWith(add)(c)(1)(a),\n        list(s),\n        {}\n    )\n\n\n\ndef first(f):\n    \n    return lambda xy: (f(xy[0]), xy[1])\n\n\n\n\ndef insertWith(f):\n    \n    return lambda k: lambda x: lambda dct: dict(\n        dct,\n        **{k: f(dct[k], x) if k in dct else x}\n    )\n\n\n\n\ndef mapAccumL(f):\n    \n    def nxt(a, x):\n        return second(lambda v: a[1] + [v])(\n            f(a[0], x)\n        )\n    return lambda acc, xs: reduce(\n        nxt, xs, (acc, [])\n    )\n\n\n\ndef second(f):\n    \n    return lambda xy: (xy[0], f(xy[1]))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 419672, "name": "Minimal steps down to 1", "source": "Translate Swift to Python: func minToOne(divs: [Int], subs: [Int], upTo n: Int) -> ([Int], [[String]]) {\n  var table = Array(repeating: n + 2, count: n + 1)\n  var how = Array(repeating: [\"\"], count: n + 2)\n\n  table[1] = 0\n  how[1] = [\"=\"]\n\n  for t in 1..<n {\n    let thisPlus1 = table[t] + 1\n\n    for div in divs {\n      let dt = div * t\n\n      if dt <= n && thisPlus1 < table[dt] {\n        table[dt] = thisPlus1\n        how[dt] = how[t] + [\"/\\(div)=>  \\(t)\"]\n      }\n    }\n\n    for sub in subs {\n      let st = sub + t\n\n      if st <= n && thisPlus1 < table[st] {\n        table[st] = thisPlus1\n        how[st] = how[t] + [\"-\\(sub)=> \\(t)\"]\n      }\n    }\n  }\n\n  return (table, how.map({ $0.reversed().dropLast() }))\n}\n\nfor (divs, subs) in [([2, 3], [1]), ([2, 3], [2])] {\n  print(\"\\nMINIMUM STEPS TO 1:\")\n  print(\"  Possible divisors:  \\(divs)\")\n  print(\"  Possible decrements: \\(subs)\")\n\n  let (table, hows) = minToOne(divs: divs, subs: subs, upTo: 10)\n\n  for n in 1...10 {\n    print(\"    mintab(  \\(n)) in {  \\(table[n])} by: \", hows[n].joined(separator: \", \"))\n  }\n\n  for upTo in [2_000, 50_000] {\n    print(\"\\n    Those numbers up to \\(upTo) that take the maximum, \\\"minimal steps down to 1\\\":\")\n    let (table, _) = minToOne(divs: divs, subs: subs, upTo: upTo)\n    let max = table.dropFirst().max()!\n    let maxNs = table.enumerated().filter({ $0.element == max })\n\n    print(\n      \"      Taking\", max, \"steps are the \\(maxNs.count) numbers:\",\n      maxNs.map({ String($0.offset) }).joined(separator: \", \")\n    )\n  }\n}\n", "target": "from functools import lru_cache\n\n\n\n\nDIVS = {2, 3}\nSUBS = {1}\n\nclass Minrec():\n    \"Recursive, memoised minimised steps to 1\"\n\n    def __init__(self, divs=DIVS, subs=SUBS):\n        self.divs, self.subs = divs, subs\n\n    @lru_cache(maxsize=None)\n    def _minrec(self, n):\n        \"Recursive, memoised\"\n        if n == 1:\n            return 0, ['=1']\n        possibles = {}\n        for d in self.divs:\n            if n % d == 0:\n                possibles[f'/{d}=>{n // d:2}'] = self._minrec(n // d)\n        for s in self.subs:\n            if n > s:\n                possibles[f'-{s}=>{n - s:2}'] = self._minrec(n - s)\n        thiskind, (count, otherkinds) = min(possibles.items(), key=lambda x: x[1])\n        ret = 1 + count, [thiskind] + otherkinds\n        return ret\n\n    def __call__(self, n):\n        \"Recursive, memoised\"\n        ans = self._minrec(n)[1][:-1]\n        return len(ans), ans\n\n\nif __name__ == '__main__':\n    for DIVS, SUBS in [({2, 3}, {1}), ({2, 3}, {2})]:\n        minrec = Minrec(DIVS, SUBS)\n        print('\\nMINIMUM STEPS TO 1: Recursive algorithm')\n        print('  Possible divisors:  ', DIVS)\n        print('  Possible decrements:', SUBS)\n        for n in range(1, 11):\n            steps, how = minrec(n)\n            print(f'    minrec({n:2}) in {steps:2} by: ', ', '.join(how))\n\n        upto = 2000\n        print(f'\\n    Those numbers up to {upto} that take the maximum, \"minimal steps down to 1\":')\n        stepn = sorted((minrec(n)[0], n) for n in range(upto, 0, -1))\n        mx = stepn[-1][0]\n        ans = [x[1] for x in stepn if x[0] == mx]\n        print('      Taking', mx, f'steps is/are the {len(ans)} numbers:',\n              ', '.join(str(n) for n in sorted(ans)))\n        \n        print()\n"}
{"id": 419673, "name": "Functional coverage tree", "source": "Translate Swift to Python: import Foundation\n\nextension String {\n  func paddedLeft(totalLen: Int) -> String {\n    let needed = totalLen - count\n\n    guard needed > 0 else {\n      return self\n    }\n\n    return String(repeating: \" \", count: needed) + self\n  }\n}\n\nclass FCNode {\n  let name: String\n  let weight: Int\n\n  var coverage: Double {\n    didSet {\n      if oldValue != coverage {\n        parent?.updateCoverage()\n      }\n    }\n  }\n\n  weak var parent: FCNode?\n  var children = [FCNode]()\n\n  init(name: String, weight: Int = 1, coverage: Double = 0) {\n    self.name = name\n    self.weight = weight\n    self.coverage = coverage\n  }\n\n  func addChildren(_ children: [FCNode]) {\n    for child in children {\n      child.parent = self\n    }\n\n    self.children += children\n\n    updateCoverage()\n  }\n\n  func show(level: Int = 0) {\n    let indent = level * 4\n    let nameLen = name.count + indent\n\n    print(name.paddedLeft(totalLen: nameLen), terminator: \"\")\n    print(\"|\".paddedLeft(totalLen: 32 - nameLen), terminator: \"\")\n    print(String(format: \"  %3d   |\", weight), terminator: \"\")\n    print(String(format: \" %8.6f |\", coverage))\n    \n    for child in children {\n      child.show(level: level + 1)\n    }\n  }\n\n  func updateCoverage() {\n    let v1 = children.reduce(0.0, { $0 + $1.coverage * Double($1.weight) })\n    let v2 = children.reduce(0.0, { $0 + Double($1.weight) })\n\n    coverage = v1 / v2\n  }\n}\n\nlet houses = [\n  FCNode(name: \"house1\", weight: 40),\n  FCNode(name: \"house2\", weight: 60)\n]\n\nlet house1 = [\n  FCNode(name: \"bedrooms\", weight: 1, coverage: 0.25),\n  FCNode(name: \"bathrooms\"),\n  FCNode(name: \"attic\", weight: 1, coverage: 0.75),\n  FCNode(name: \"kitchen\", weight: 1, coverage: 0.1),\n  FCNode(name: \"living_rooms\"),\n  FCNode(name: \"basement\"),\n  FCNode(name: \"garage\"),\n  FCNode(name: \"garden\", weight: 1, coverage: 0.8)\n]\n\nlet house2 = [\n  FCNode(name: \"upstairs\"),\n  FCNode(name: \"groundfloor\"),\n  FCNode(name: \"basement\")\n]\n\nlet h1Bathrooms = [\n  FCNode(name: \"bathroom1\", weight: 1, coverage: 0.5),\n  FCNode(name: \"bathroom2\"),\n  FCNode(name: \"outside_lavatory\", weight: 1, coverage: 1.0)\n]\n\nlet h1LivingRooms = [\n  FCNode(name: \"lounge\"),\n  FCNode(name: \"dining_room\"),\n  FCNode(name: \"conservatory\"),\n  FCNode(name: \"playroom\", weight: 1, coverage: 1.0)\n]\n\nlet h2Upstairs = [\n  FCNode(name: \"bedrooms\"),\n  FCNode(name: \"bathroom\"),\n  FCNode(name: \"toilet\"),\n  FCNode(name: \"attics\", weight: 1, coverage: 0.6)\n]\n\nlet h2Groundfloor = [\n  FCNode(name: \"kitchen\"),\n  FCNode(name: \"living_rooms\"),\n  FCNode(name: \"wet_room_&_toilet\"),\n  FCNode(name: \"garage\"),\n  FCNode(name: \"garden\", weight: 1, coverage: 0.9),\n  FCNode(name: \"hot_tub_suite\", weight: 1, coverage: 1.0)\n]\n\nlet h2Basement = [\n  FCNode(name: \"cellars\", weight: 1, coverage: 1.0),\n  FCNode(name: \"wine_cellar\", weight: 1, coverage: 1.0),\n  FCNode(name: \"cinema\", weight: 1, coverage: 0.75)\n]\n\nlet h2UpstairsBedrooms = [\n  FCNode(name: \"suite_1\"),\n  FCNode(name: \"suite_2\"),\n  FCNode(name: \"bedroom_3\"),\n  FCNode(name: \"bedroom_4\")\n]\n\nlet h2GroundfloorLivingRooms = [\n  FCNode(name: \"lounge\"),\n  FCNode(name: \"dining_room\"),\n  FCNode(name: \"conservatory\"),\n  FCNode(name: \"playroom\")\n]\n\nlet cleaning = FCNode(name: \"cleaning\")\n\nhouse1[1].addChildren(h1Bathrooms)\nhouse1[4].addChildren(h1LivingRooms)\nhouses[0].addChildren(house1)\n\nh2Upstairs[0].addChildren(h2UpstairsBedrooms)\nhouse2[0].addChildren(h2Upstairs)\nh2Groundfloor[1].addChildren(h2GroundfloorLivingRooms)\nhouse2[1].addChildren(h2Groundfloor)\nhouse2[2].addChildren(h2Basement)\nhouses[1].addChildren(house2)\n\ncleaning.addChildren(houses)\n\nlet top = cleaning.coverage\n\nprint(\"Top Coverage: \\(String(format: \"%8.6f\", top))\")\nprint(\"Name Hierarchy                 | Weight | Coverage |\")\n\ncleaning.show()\n\nh2Basement[2].coverage = 1.0\n\nlet diff = cleaning.coverage - top\n\nprint(\"\\nIf the coverage of the Cinema node were increased from 0.75 to 1.0\")\nprint(\"the top level coverage would increase by \")\nprint(\"\\(String(format: \"%8.6f\", diff)) to \\(String(format: \"%8.6f\", top))\")\n", "target": "from itertools import zip_longest\n\n\nfc2 = \n\nNAME, WT, COV = 0, 1, 2\n\ndef right_type(txt):\n    try:\n        return float(txt)\n    except ValueError:\n        return txt\n\ndef commas_to_list(the_list, lines, start_indent=0):\n    \n    for n, line in lines:\n        indent = 0\n        while line.startswith(' ' * (4 * indent)):\n            indent += 1\n        indent -= 1\n        fields = [right_type(f) for f in line.strip().split(',')]\n        if indent == start_indent:\n            the_list.append(fields)\n        elif indent > start_indent:\n            lst = [fields]\n            sub = commas_to_list(lst, lines, indent)\n            the_list[-1] = (the_list[-1], lst)\n            if sub not in (None, ['']) :\n                the_list.append(sub)\n        else:\n            return fields if fields else None\n    return None\n\n\ndef pptreefields(lst, indent=0, widths=['%-32s', '%-8g', '%-10g']):\n    \n    lhs = ' ' * (4 * indent)\n    for item in lst:\n        if type(item) != tuple:\n            name, *rest = item\n            print(widths[0] % (lhs + name), end='|')\n            for width, item in zip_longest(widths[1:len(rest)], rest, fillvalue=widths[-1]):\n                if type(item) == str:\n                    width = width[:-1] + 's'\n                print(width % item, end='|')\n            print()\n        else:\n            item, children = item\n            name, *rest = item\n            print(widths[0] % (lhs + name), end='|')\n            for width, item in zip_longest(widths[1:len(rest)], rest, fillvalue=widths[-1]):\n                if type(item) == str:\n                    width = width[:-1] + 's'\n                print(width % item, end='|')\n            print()\n            pptreefields(children, indent+1)\n\n\ndef default_field(node_list):\n    node_list[WT] = node_list[WT] if node_list[WT] else 1.0\n    node_list[COV] = node_list[COV] if node_list[COV] else 0.0\n\ndef depth_first(tree, visitor=default_field):\n    for item in tree:\n        if type(item) == tuple:\n            item, children = item\n            depth_first(children, visitor)\n        visitor(item)\n            \n\ndef covercalc(tree):\n    \n    sum_covwt, sum_wt = 0, 0\n    for item in tree:\n        if type(item) == tuple:\n            item, children = item\n            item[COV] = covercalc(children)\n        sum_wt  += item[WT]\n        sum_covwt += item[COV] * item[WT]\n    cov = sum_covwt / sum_wt\n    return cov\n\nif __name__ == '__main__':        \n    lstc = []\n    commas_to_list(lstc, ((n, ln) for n, ln in enumerate(fc2.split('\\n'))))\n    \n    \n    \n    depth_first(lstc)\n    \n    \n    print('\\n\\nTOP COVERAGE = %f\\n' % covercalc(lstc))\n    depth_first(lstc)\n    pptreefields(['NAME_HIERARCHY WEIGHT COVERAGE'.split()] + lstc)\n"}
{"id": 419674, "name": "Banker's algorithm", "source": "Translate Swift to Python: import Foundation\n\nprint(\"Enter the number of resources: \", terminator: \"\")\n\nguard let resources = Int(readLine(strippingNewline: true)!) else {\n  fatalError()\n}\n\nprint(\"Enter the number of processes: \", terminator: \"\")\n\nguard let processes = Int(readLine(strippingNewline: true)!) else {\n  fatalError()\n}\n\nvar running = Array(repeating: true, count: processes)\nvar curr = Array(repeating: [Int](), count: processes)\nvar alloc = Array(repeating: 0, count: resources)\nvar available = Array(repeating: 0, count: resources)\nvar maxClaims = Array(repeating: [Int](), count: processes)\nvar count = processes\n\nprint(\"Enter the \\(resources)-item claim vector: \", terminator: \"\")\n\nguard let maxRes = readLine(strippingNewline: true)?.components(separatedBy: \" \").compactMap(Int.init),\n      maxRes.count == resources else {\n  fatalError()\n}\n\nprint(\"Enter the \\(processes)-line \\(resources)-column allocated-resource table:\")\n\nfor i in 0..<processes {\n  print(\"Row \\(i + 1): \", terminator: \"\")\n\n  guard let allc = readLine(strippingNewline: true)?.components(separatedBy: \" \").compactMap(Int.init),\n        maxRes.count == resources else {\n    fatalError()\n  }\n\n  curr[i] = allc\n}\n\nprint(\"Enter the \\(processes)-line \\(resources)-column maximum-claim table:\")\n\nfor i in 0..<processes {\n  print(\"Row \\(i + 1): \", terminator: \"\")\n\n  guard let clms = readLine(strippingNewline: true)?.components(separatedBy: \" \").compactMap(Int.init),\n        maxRes.count == resources else {\n    fatalError()\n  }\n\n  maxClaims[i] = clms\n}\n\nfor i in 0..<processes {\n  for j in 0..<resources {\n    alloc[j] += curr[i][j]\n  }\n}\n\nfor i in 0..<resources {\n  available[i] = maxRes[i] - alloc[i]\n}\n\nprint(\"The claim vector is: \\(maxRes)\")\nprint(\"The allocated resources table is: \\(curr)\")\nprint(\"The maximum claims table is: \\(maxClaims)\")\nprint(\"The allocated resources are: \\(alloc)\")\nprint(\"The available resources are: \\(available)\")\n\nwhile count != 0 {\n  var safe = false\n\n  for i in 0..<processes where running[i] {\n    var exec = true\n\n    for j in 0..<resources where maxClaims[i][j] - curr[i][j] > available[j] {\n      exec = false\n      break\n    }\n\n    if exec {\n      print(\"Process \\(i + 1) is executing.\")\n      running[i] = false\n      count -= 1\n      safe = true\n\n      for j in 0..<resources {\n        available[j] += curr[i][j]\n      }\n\n      break\n    }\n  }\n\n  if safe {\n    print(\"The process is in safe state.\")\n  } else {\n    print(\"The processes are in unsafe state.\")\n    break\n  }\n\n  print(\"The available vector is: \\(available)\")\n}\n", "target": "def main():\n    resources = int(input(\"Cantidad de recursos: \"))\n    processes = int(input(\"Cantidad de procesos: \"))\n    max_resources = [int(i) for i in input(\"Recursos m\u00e1ximos: \").split()]\n\n    print(\"\\n-- recursos asignados para cada proceso  --\")\n    currently_allocated = [[int(i) for i in input(f\"proceso {j + 1}: \").split()] for j in range(processes)]\n\n    print(\"\\n--- recursos m\u00e1ximos para cada proceso  ---\")\n    max_need = [[int(i) for i in input(f\"proceso {j + 1}: \").split()] for j in range(processes)]\n\n    allocated = [0] * resources\n    for i in range(processes):\n        for j in range(resources):\n            allocated[j] += currently_allocated[i][j]\n    print(f\"\\nRecursos totales asignados \u00a0: {allocated}\")\n\n    available = [max_resources[i] - allocated[i] for i in range(resources)]\n    print(f\"Recursos totales disponibles: {available}\\n\")\n\n    running = [True] * processes\n    count = processes\n    while count != 0:\n        safe = False\n        for i in range(processes):\n            if running[i]:\n                executing = True\n                for j in range(resources):\n                    if max_need[i][j] - currently_allocated[i][j] > available[j]:\n                        executing = False\n                        break\n                if executing:\n                    print(f\"proceso {i + 1} ejecut\u00e1ndose\")\n                    running[i] = False\n                    count -= 1\n                    safe = True\n                    for j in range(resources):\n                        available[j] += currently_allocated[i][j]\n                    break\n        if not safe:\n            print(\"El proceso est\u00e1 en un estado inseguro.\")\n            break\n\n        print(f\"El proceso est\u00e1 en un estado seguro.\\nRecursos disponibles: {available}\\n\")\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 419675, "name": "Idoneal numbers", "source": "Translate Swift to Python: import Foundation\n\nfunc isIdoneal(_ n: Int) -> Bool {\n    for a in 1..<n {\n        for b in a + 1..<n {\n            if a * b + a + b > n {\n                break\n            }\n            for c in b + 1..<n {\n                let sum = a * b + b * c + a * c\n                if sum == n {\n                    return false\n                }\n                if sum > n {\n                    break\n                }\n            }\n        }\n    }\n    return true\n}\n\nvar count = 0\nfor n in 1..<1850 {\n    if isIdoneal(n) {\n        count += 1\n        print(String(format: \"%4d\", n), terminator: count % 13 == 0 ? \"\\n\" : \" \")\n    }\n}\n", "target": "\n\n\ndef is_idoneal(num):\n    \n    for a in range(1, num):\n        for b in range(a + 1, num):\n            if a * b + a + b > num:\n                break\n            for c in range(b + 1, num):\n                sum3 = a * b + b * c + a * c\n                if sum3 == num:\n                    return False\n                if sum3 > num:\n                    break\n    return True\n\n\nrow = 0\nfor n in range(1, 2000):\n    if is_idoneal(n):\n        row += 1\n        print(f'{n:5}', end='\\n' if row % 13 == 0 else '')\n"}
{"id": 419676, "name": "Railway circuit", "source": "Translate Swift to Python: enum Track: Int, Hashable {\n  case left = -1, straight, right\n}\n\nextension Track: Comparable {\n  static func < (lhs: Track, rhs: Track) -> Bool {\n    return lhs.rawValue < rhs.rawValue\n  }\n}\n\nfunc < (lhs: [Track], rhs: [Track]) -> Bool {\n  for (l, r) in zip(lhs, rhs) where l != r {\n    return l < r\n  }\n\n  return false\n}\n\nfunc normalize(_ tracks: [Track]) -> [Track] {\n  let count = tracks.count\n  var workingTracks = tracks\n  var norm = tracks\n\n  for _ in 0..<count {\n    if workingTracks < norm {\n      norm = workingTracks\n    }\n\n    let temp = workingTracks[0]\n\n    for j in 1..<count {\n      workingTracks[j - 1] = workingTracks[j]\n    }\n\n    workingTracks[count - 1] = temp\n  }\n\n  return norm\n}\n\nfunc fullCircleStraight(tracks: [Track], nStraight: Int) -> Bool {\n  guard nStraight != 0 else {\n    return true\n  }\n\n  guard tracks.filter({ $0 == .straight }).count == nStraight else {\n    return false\n  }\n\n  var straight = [Int](repeating: 0, count: 12)\n  var i = 0\n  var idx = 0\n\n  while i < tracks.count && idx >= 0 {\n    if tracks[i] == .straight {\n      straight[idx % 12] += 1\n    }\n\n    idx += tracks[i].rawValue\n    i += 1\n  }\n\n  return !((0...5).contains(where: { straight[$0] != straight[$0 + 6] }) &&\n    (0...7).contains(where: { straight[$0] != straight[$0 + 4] })\n  )\n}\n\nfunc fullCircleRight(tracks: [Track]) -> Bool {\n  guard tracks.map({ $0.rawValue * 30 }).reduce(0, +) % 360 == 0 else {\n    return false\n  }\n\n  var rightTurns = [Int](repeating: 0, count: 12)\n  var i = 0\n  var idx = 0\n\n  while i < tracks.count && idx >= 0 {\n    if tracks[i] == .right {\n      rightTurns[idx % 12] += 1\n    }\n\n    idx += tracks[i].rawValue\n    i += 1\n  }\n\n  return !((0...5).contains(where: { rightTurns[$0] != rightTurns[$0 + 6] }) &&\n    (0...7).contains(where: { rightTurns[$0] != rightTurns[$0 + 4] })\n  )\n}\n\nfunc circuits(nCurved: Int, nStraight: Int) {\n  var solutions = Set<[Track]>()\n\n  for tracks in getPermutationsGen(nCurved: nCurved, nStraight: nStraight)\n      where fullCircleStraight(tracks: tracks, nStraight: nStraight) && fullCircleRight(tracks: tracks)  {\n    solutions.insert(normalize(tracks))\n  }\n\n  report(solutions: solutions, nCurved: nCurved, nStraight: nStraight)\n}\n\nfunc getPermutationsGen(nCurved: Int, nStraight: Int) -> PermutationsGen {\n  precondition((nCurved + nStraight - 12) % 4 == 0, \"input must be 12 + k * 4\")\n\n  let trackTypes: [Track]\n\n  if nStraight == 0 {\n    trackTypes = [.right, .left]\n  } else if nCurved == 12 {\n    trackTypes = [.right, .straight]\n  } else {\n    trackTypes = [.right, .left, .straight]\n  }\n\n  return PermutationsGen(numPositions: nCurved + nStraight, choices: trackTypes)\n}\n\nfunc report(solutions: Set<[Track]>, nCurved: Int, nStraight: Int) {\n  print(\"\\(solutions.count) solutions for C\\(nCurved),\\(nStraight)\")\n\n  if nCurved <= 20 {\n    for tracks in solutions {\n      for track in tracks {\n        print(track.rawValue, terminator: \" \")\n      }\n\n      print()\n    }\n  }\n}\n\nstruct PermutationsGen: Sequence, IteratorProtocol {\n  private let choices: [Track]\n  private var indices: [Int]\n  private var sequence: [Track]\n  private var carry = 0\n\n  init(numPositions: Int, choices: [Track]) {\n    self.choices = choices\n    self.indices = .init(repeating: 0, count: numPositions)\n    self.sequence = .init(repeating: choices.first!, count: numPositions)\n  }\n\n  mutating func next() -> [Track]? {\n    guard carry != 1 else {\n      return nil\n    }\n\n    carry = 1\n    var i = 1\n\n    while i < indices.count && carry > 0 {\n      indices[i] += carry\n      carry = 0\n\n      if indices[i] == choices.count {\n        carry = 1\n        indices[i] = 0\n      }\n\n      i += 1\n    }\n\n    for j in 0..<indices.count {\n      sequence[j] = choices[indices[j]]\n    }\n\n    return sequence\n  }\n}\n\nfor n in stride(from: 12, through: 32, by: 4) {\n  circuits(nCurved: n, nStraight: 0)\n}\n\ncircuits(nCurved: 12, nStraight: 4)\n", "target": "from itertools import count, islice\nimport numpy as np\nfrom numpy import sin, cos, pi\n\n\nANGDIV = 12\nANG = 2*pi/ANGDIV\n\ndef draw_all(sols):\n    import matplotlib.pyplot as plt\n\n    def draw_track(ax, s):\n        turn, xend, yend = 0, [0], [0]\n\n        for d in s:\n            x0, y0 = xend[-1], yend[-1]\n            a = turn*ANG\n            cs, sn = cos(a), sin(a)\n            ang = a + d*pi/2\n            cx, cy = x0 + cos(ang), y0 + sin(ang)\n\n            da = np.linspace(ang, ang + d*ANG, 10)\n            xs = cx - cos(da)\n            ys = cy - sin(da)\n            ax.plot(xs, ys, 'green' if d == -1 else 'orange')\n\n            xend.append(xs[-1])\n            yend.append(ys[-1])\n            turn += d\n\n        ax.plot(xend, yend, 'k.', markersize=1)\n        ax.set_aspect(1)\n\n    ls = len(sols)\n    if ls == 0: return\n\n    w, h = min((abs(w*2 - h*3) + w*h - ls, w, h)\n        for w, h in ((w, (ls + w - 1)//w)\n            for w in range(1, ls + 1)))[1:]\n\n    fig, ax = plt.subplots(h, w, squeeze=False)\n    for a in ax.ravel(): a.set_axis_off()\n\n    for i, s in enumerate(sols):\n        draw_track(ax[i//w, i%w], s)\n\n    plt.show()\n\n\ndef match_up(this, that, equal_lr, seen):\n    if not this or not that: return\n\n    n = len(this[0][-1])\n    n2 = n*2\n\n    l_lo, l_hi, r_lo, r_hi = 0, 0, 0, 0\n\n    def record(m):\n        for _ in range(n2):\n            seen[m] = True\n            m = (m&1) << (n2 - 1) | (m >> 1)\n\n        if equal_lr:\n            m ^= (1<<n2) - 1\n            for _ in range(n2):\n                seen[m] = True\n                m = (m&1) << (n2 - 1) | (m >> 1)\n\n    l_n, r_n = len(this), len(that)\n    tol = 1e-3\n\n    while l_lo < l_n:\n        while l_hi < l_n and this[l_hi][0] - this[l_lo][0] <= tol:\n            l_hi += 1\n\n        while r_lo < r_n and that[r_lo][0] < this[l_lo][0] - tol:\n            r_lo += 1\n\n        r_hi = r_lo\n        while r_hi < r_n and that[r_hi][0] < this[l_lo][0] + tol:\n            r_hi += 1\n\n        for a in this[l_lo:l_hi]:\n            m_left = a[-2]<<n\n            for b in that[r_lo:r_hi]:\n                if (m := m_left | b[-2]) not in seen:\n                    if np.abs(a[1] + b[2]) < tol:\n                        record(m)\n                        record(int(f'{m:b}'[::-1], base=2))\n                        yield(a[-1] + b[-1])\n\n        l_lo, r_lo = l_hi, r_hi\n\ndef track_combo(left, right):\n    n = (left + right)//2\n    n1 = left + right - n\n\n    alphas = np.exp(1j*ANG*np.arange(ANGDIV))\n    def half_track(m, n):\n        turns = tuple(1 - 2*(m>>i & 1) for i in range(n))\n        rcnt = np.cumsum(turns)%ANGDIV\n        asum = np.sum(alphas[rcnt])\n        want = asum/alphas[rcnt[-1]]\n        return np.abs(asum), asum, want, m, turns\n\n    res = [[] for _ in range(right + 1)]\n    for i in range(1<<n):\n        b = i.bit_count()\n        if b <= right:\n            res[b].append(half_track(i, n))\n\n    for v in res: v.sort()\n    if n1 == n:\n        return res, res\n\n    res1 = [[] for _ in range(right + 1)]\n    for i in range(1<<n1):\n        b = i.bit_count()\n        if b <= right:\n            res1[b].append(half_track(i, n1))\n\n    for v in res: v.sort()\n    return res, res1\n\ndef railway(n):\n    seen = {}\n\n    for l in range(n//2, n + 1):\n        r = n - l\n        if not l >= r: continue\n\n        if (l - r)%ANGDIV == 0:\n            res_l, res_r = track_combo(l, r)\n\n            for i, this in enumerate(res_l):\n                if 2*i < r: continue\n                that = res_r[r - i]\n                for s in match_up(this, that, l == r, seen):\n                    yield s\n\nsols = []\nfor i, s in enumerate(railway(30)):\n    \n    print(i + 1, s)\n    sols.append(s)\n\ndraw_all(sols[:40])\n"}
{"id": 419677, "name": "Strassen's algorithm", "source": "Translate Swift to Python: \nfunc strassenMultiply(matrix1: Matrix, matrix2: Matrix) -> Matrix {\n    precondition(matrix1.columns == matrix2.columns,\n             \"Two matrices can only be matrix multiplied if one has dimensions mxn & the other has dimensions nxp where m, n, p are in R\")\n\n    \n    let maxColumns = Swift.max(matrix1.rows, matrix1.columns, matrix2.rows, matrix2.columns)\n    let pwr2 = nextPowerOfTwo(num: maxColumns)\n    var sqrMatrix1 = Matrix(rows: pwr2, columns: pwr2)\n    var sqrMatrix2 = Matrix(rows: pwr2, columns: pwr2)\n    \n    \n    for i in 0..<matrix1.rows {\n        for j in 0..<matrix1.columns{\n            sqrMatrix1[i, j] = matrix1[i, j]\n        }\n    }\n    \n    for i in 0..<matrix2.rows {\n        for j in 0..<matrix2.columns{\n            sqrMatrix2[i, j] = matrix2[i, j]\n        }\n    }\n    \n    \n    let formulaResult = strassenFormula(matrix1: sqrMatrix1, matrix2: sqrMatrix2)\n    var finalResult = Matrix(rows: matrix1.rows, columns: matrix2.columns)\n    for i in 0..<finalResult.rows{\n        for j in 0..<finalResult.columns {\n            finalResult[i, j] = formulaResult[i, j]\n        }\n    }\n    return finalResult\n}\n\n\nfunc nextPowerOfTwo(num: Int) -> Int {\n               \n    return Int(pow(2,(ceil(log2(Double(num))))))\n}\n\n\nfunc strassenFormula(matrix1: Matrix, matrix2: Matrix) -> Matrix {\n    precondition(matrix1.rows == matrix1.columns && matrix2.rows == matrix2.columns, \"Matrices need to be square\")\n    guard matrix1.rows > 1 && matrix2.rows > 1 else { return matrix1 * matrix2 }\n\n    let rowHalf = matrix1.rows / 2\n    \n    \n    \n    \n    \n    |a b|  x  |e f|  =  |(p5+p4-p2+p6) (p1+p2)|  \n    |c d|     |g h|     |(p3+p4) (p1+p5-p3-p7)|\n   Matrix 1  Matrix 2          Result\n\n    \n    var a = Matrix(rows: rowHalf, columns: rowHalf)\n    var b = Matrix(rows: rowHalf, columns: rowHalf)\n    var c = Matrix(rows: rowHalf, columns: rowHalf)\n    var d = Matrix(rows: rowHalf, columns: rowHalf)\n    var e = Matrix(rows: rowHalf, columns: rowHalf)\n    var f = Matrix(rows: rowHalf, columns: rowHalf)\n    var g = Matrix(rows: rowHalf, columns: rowHalf)\n    var h = Matrix(rows: rowHalf, columns: rowHalf)\n    \n    \n    for i in 0..<rowHalf {\n      for j in 0..<rowHalf {\n        a[i, j] = matrix1[i, j]\n        b[i, j] = matrix1[i, j+rowHalf]\n        c[i, j] = matrix1[i+rowHalf, j]\n        d[i, j] = matrix1[i+rowHalf, j+rowHalf]\n        e[i, j] = matrix2[i, j]\n        f[i, j] = matrix2[i, j+rowHalf]\n        g[i, j] = matrix2[i+rowHalf, j]\n        h[i, j] = matrix2[i+rowHalf, j+rowHalf]\n      }\n    }\n    \n     \n    let p1 = strassenFormula(matrix1: a, matrix2: (f - h))      \n    \n    let p2 = strassenFormula(matrix1: (a + b), matrix2: h)  \n    \n    let p3 = strassenFormula(matrix1: (c + d), matrix2: e)  \n    \n    let p4 = strassenFormula(matrix1: d, matrix2: (g - e))\n    \n    let p5 = strassenFormula(matrix1: (a + d), matrix2: (e + h)) \n    \n    let p6 = strassenFormula(matrix1: (b - d), matrix2: (g + h))\n    \n    let p7 = strassenFormula(matrix1: (a - c), matrix2: (e + f))   \n    \n    \n    let result11 = p5 + p4 - p2 + p6 \n    \n    let result12 = p1 + p2\n    \n    let result21 = p3 + p4         \n    \n    let result22 = p1 + p5 - p3 - p7         \n\n    \n    var result = Matrix(rows: matrix1.rows, columns: matrix1.rows)\n    for i in 0..<rowHalf {\n      for j in 0..<rowHalf {\n        result[i, j]           = result11[i, j]\n        result[i, j+rowHalf]      = result12[i, j]\n        result[i+rowHalf, j]      = result21[i, j]\n        result[i+rowHalf, j+rowHalf] = result22[i, j]\n      }\n    }\n\n    return result\n}\n\nfunc main(){\n    \n    var a = Matrix(rows: 2, columns: 2)\n    a[row: 0] = [1, 2]\n    a[row: 1] = [3, 4]\n\n    var b = Matrix(rows: 2, columns: 2)\n    b[row: 0] = [5, 6]\n    b[row: 1] = [7, 8]\n    \n    var c = Matrix(rows: 4, columns: 4)\n    c[row: 0] = [1, 1, 1,1]\n    c[row: 1] = [2, 4, 8, 16]\n    c[row: 2] = [3, 9, 27, 81]\n    c[row: 3] = [4, 16, 64, 256]\n    \n    var d = Matrix(rows: 4, columns: 4)\n    d[row: 0] = [4, -3, Double(4/3), Double(-1/4)]\n    d[row: 1] = [Double(-13/3), Double(19/4), Double(-7/3), Double(11/24)]\n    d[row: 2] = [Double(3/2), Double(-2), Double(7/6), Double(-1/4)]\n    d[row: 3] = [Double(-1/6), Double(1/4), Double(-1/6), Double(1/24)]\n    \n    var e = Matrix(rows: 4, columns: 4)\n    e[row: 0] = [1, 2, 3, 4]\n    e[row: 1] = [5, 6, 7, 8]\n    e[row: 2] = [9, 10, 11, 12]\n    e[row: 3] = [13, 14, 15, 16]\n    \n    var f = Matrix(rows: 4, columns: 4)\n    f[row: 0] = [1, 0, 0, 0]\n    f[row: 1] = [0, 1, 0 ,0]\n    f[row: 2] = [0 ,0 ,1, 0]\n    f[row: 3] = [0, 0 ,0 ,1]\n    \n    let result1 = strassenMultiply(matrix1: a, matrix2: b)\n    print(\"AxB\")\n    print(result1.description)\n    let result2 = strassenMultiply(matrix1: c, matrix2: d)\n    print(\"CxD\")\n    print(result2.description)\n    let result3 = strassenMultiply(matrix1: e, matrix2: f)\n    print(\"ExF\")\n    print(result3.description)\n}\nmain()\n", "target": "\n\nfrom __future__ import annotations\nfrom itertools import chain\nfrom typing import List\nfrom typing import NamedTuple\nfrom typing import Optional\n\n\nclass Shape(NamedTuple):\n    rows: int\n    cols: int\n\n\nclass Matrix(List):\n    \n\n    @classmethod\n    def block(cls, blocks) -> Matrix:\n        \n        m = Matrix()\n        for hblock in blocks:\n            for row in zip(*hblock):\n                m.append(list(chain.from_iterable(row)))\n\n        return m\n\n    def dot(self, b: Matrix) -> Matrix:\n        \n        assert self.shape.cols == b.shape.rows\n        m = Matrix()\n        for row in self:\n            new_row = []\n            for c in range(len(b[0])):\n                col = [b[r][c] for r in range(len(b))]\n                new_row.append(sum(x * y for x, y in zip(row, col)))\n            m.append(new_row)\n        return m\n\n    def __matmul__(self, b: Matrix) -> Matrix:\n        return self.dot(b)\n\n    def __add__(self, b: Matrix) -> Matrix:\n        \n        assert self.shape == b.shape\n        rows, cols = self.shape\n        return Matrix(\n            [[self[i][j] + b[i][j] for j in range(cols)] for i in range(rows)]\n        )\n\n    def __sub__(self, b: Matrix) -> Matrix:\n        \n        assert self.shape == b.shape\n        rows, cols = self.shape\n        return Matrix(\n            [[self[i][j] - b[i][j] for j in range(cols)] for i in range(rows)]\n        )\n\n    def strassen(self, b: Matrix) -> Matrix:\n        \n        rows, cols = self.shape\n\n        assert rows == cols, \"matrices must be square\"\n        assert self.shape == b.shape, \"matrices must be the same shape\"\n        assert rows and (rows & rows - 1) == 0, \"shape must be a power of 2\"\n\n        if rows == 1:\n            return self.dot(b)\n\n        p = rows // 2  \n\n        a11 = Matrix([n[:p] for n in self[:p]])\n        a12 = Matrix([n[p:] for n in self[:p]])\n        a21 = Matrix([n[:p] for n in self[p:]])\n        a22 = Matrix([n[p:] for n in self[p:]])\n\n        b11 = Matrix([n[:p] for n in b[:p]])\n        b12 = Matrix([n[p:] for n in b[:p]])\n        b21 = Matrix([n[:p] for n in b[p:]])\n        b22 = Matrix([n[p:] for n in b[p:]])\n\n        m1 = (a11 + a22).strassen(b11 + b22)\n        m2 = (a21 + a22).strassen(b11)\n        m3 = a11.strassen(b12 - b22)\n        m4 = a22.strassen(b21 - b11)\n        m5 = (a11 + a12).strassen(b22)\n        m6 = (a21 - a11).strassen(b11 + b12)\n        m7 = (a12 - a22).strassen(b21 + b22)\n\n        c11 = m1 + m4 - m5 + m7\n        c12 = m3 + m5\n        c21 = m2 + m4\n        c22 = m1 - m2 + m3 + m6\n\n        return Matrix.block([[c11, c12], [c21, c22]])\n\n    def round(self, ndigits: Optional[int] = None) -> Matrix:\n        return Matrix([[round(i, ndigits) for i in row] for row in self])\n\n    @property\n    def shape(self) -> Shape:\n        cols = len(self[0]) if self else 0\n        return Shape(len(self), cols)\n\n\ndef examples():\n    a = Matrix(\n        [\n            [1, 2],\n            [3, 4],\n        ]\n    )\n    b = Matrix(\n        [\n            [5, 6],\n            [7, 8],\n        ]\n    )\n    c = Matrix(\n        [\n            [1, 1, 1, 1],\n            [2, 4, 8, 16],\n            [3, 9, 27, 81],\n            [4, 16, 64, 256],\n        ]\n    )\n    d = Matrix(\n        [\n            [4, -3, 4 / 3, -1 / 4],\n            [-13 / 3, 19 / 4, -7 / 3, 11 / 24],\n            [3 / 2, -2, 7 / 6, -1 / 4],\n            [-1 / 6, 1 / 4, -1 / 6, 1 / 24],\n        ]\n    )\n    e = Matrix(\n        [\n            [1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12],\n            [13, 14, 15, 16],\n        ]\n    )\n    f = Matrix(\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n        ]\n    )\n\n    print(\"Naive matrix multiplication:\")\n    print(f\"  a * b = {a @ b}\")\n    print(f\"  c * d = {(c @ d).round()}\")\n    print(f\"  e * f = {e @ f}\")\n\n    print(\"Strassen's matrix multiplication:\")\n    print(f\"  a * b = {a.strassen(b)}\")\n    print(f\"  c * d = {c.strassen(d).round()}\")\n    print(f\"  e * f = {e.strassen(f)}\")\n\n\nif __name__ == \"__main__\":\n    examples()\n"}

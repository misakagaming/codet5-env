{"id": 234, "name": "Arithmetic_Integer", "source": "Translate Swift to C#: let a = 6 \nlet b = 4\n\nprint(\"sum =\\(a+b)\")\nprint(\"difference = \\(a-b)\")\nprint(\"product = \\(a*b)\")\nprint(\"Integer quotient = \\(a/b)\")\nprint(\"Remainder = (a%b)\")\nprint(\"No operator for Exponential\")\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int a = Convert.ToInt32(args[0]);\n        int b = Convert.ToInt32(args[1]);\n\n        Console.WriteLine(\"{0} + {1} = {2}\", a, b, a + b);\n        Console.WriteLine(\"{0} - {1} = {2}\", a, b, a - b);\n        Console.WriteLine(\"{0} * {1} = {2}\", a, b, a * b);\n        Console.WriteLine(\"{0} / {1} = {2}\", a, b, a / b); \n        Console.WriteLine(\"{0}\u00a0% {1} = {2}\", a, b, a % b); \n        Console.WriteLine(\"{0} to the power of {1} = {2}\", a, b, Math.Pow(a, b));\n    }\n}\n"}
{"id": 236, "name": "Arithmetic_Integer", "source": "Translate Swift to Java: let a = 6 \nlet b = 4\n\nprint(\"sum =\\(a+b)\")\nprint(\"difference = \\(a-b)\")\nprint(\"product = \\(a*b)\")\nprint(\"Integer quotient = \\(a/b)\")\nprint(\"Remainder = (a%b)\")\nprint(\"No operator for Exponential\")\n", "target": "import java.util.Scanner;\n\npublic class IntegerArithmetic {\n    public static void main(String[] args) {\n        \n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n\n        int sum = a + b;        \n        int difference = a - b; \n        int product = a * b;    \n        int division = a / b;   \n        int remainder = a % b;  \n\n        System.out.println(\"a + b = \" + sum);\n        System.out.println(\"a - b = \" + difference);\n        System.out.println(\"a * b = \" + product);\n        System.out.println(\"quotient of a / b = \" + division);   \n        System.out.println(\"remainder of a / b = \" + remainder);   \n    }\n}\n"}
{"id": 237, "name": "Arithmetic_Integer", "source": "Translate Swift to Python: let a = 6 \nlet b = 4\n\nprint(\"sum =\\(a+b)\")\nprint(\"difference = \\(a-b)\")\nprint(\"product = \\(a*b)\")\nprint(\"Integer quotient = \\(a/b)\")\nprint(\"Remainder = (a%b)\")\nprint(\"No operator for Exponential\")\n", "target": "x = int(raw_input(\"Number 1: \"))\ny = int(raw_input(\"Number 2: \"))\n\nprint \"Sum: %d\" % (x + y)\nprint \"Difference: %d\" % (x - y)\nprint \"Product: %d\" % (x * y)\nprint \"Quotient: %d\" % (x / y)     \n                                   \nprint \"Remainder: %d\" % (x % y)    \nprint \"Quotient: %d with Remainder: %d\" % divmod(x, y)\nprint \"Power: %d\" % x**y\n\n\nraw_input( )\n"}
{"id": 475, "name": "Null object", "source": "Translate Swift to Java: let maybeInt: Int? = nil\n", "target": "module NullObject\n    {\n    void run()\n        {\n        @Inject Console console;\n        console.print($\"Null value={Null}, Null.toString()={Null.toString()}\");\n\n     \n        String? s = Null;       \n        String s2 = \"test\";\n        console.print($\"s={s}, s2={s2}, (s==s2)={s==s2}\");\n\n     \n        Int len = s?.size : 0;\n        console.print($\"len={len}\");\n\n        if (String test ?= s)\n            {\n            \n            }\n        else\n            {\n            s = \"a non-null value\";\n            }\n\n     \n        s2 = s;                 \n        console.print($\"s={s}, s2={s2}, (s==s2)={s==s2}\");\n        }\n    }\n"}
{"id": 476, "name": "Null object", "source": "Translate Swift to Python: let maybeInt: Int? = nil\n", "target": "x = None\nif x is None:\n  print \"x is None\"\nelse:\n  print \"x is not None\"\n"}
{"id": 726, "name": "Percentage difference between images", "source": "Translate Swift to C#: func pixelValues(fromCGImage imageRef: CGImage?) -> [UInt8]?\n{\n    var width = 0\n    var height = 0\n    var pixelValues: [UInt8]?\n    \n    if let imageRef = imageRef {\n        width = imageRef.width\n        height = imageRef.height\n        let bitsPerComponent = imageRef.bitsPerComponent\n        let bytesPerRow = imageRef.bytesPerRow\n        let totalBytes = height * bytesPerRow\n        let bitmapInfo = imageRef.bitmapInfo\n        \n        let colorSpace = CGColorSpaceCreateDeviceRGB()\n        var intensities = [UInt8](repeating: 0, count: totalBytes)\n        \n        let contextRef = CGContext(data: &intensities,\n                                  width: width,\n                                 height: height,\n                       bitsPerComponent: bitsPerComponent,\n                            bytesPerRow: bytesPerRow,\n                                  space: colorSpace,\n                             bitmapInfo: bitmapInfo.rawValue)\n        contextRef?.draw(imageRef, in: CGRect(x: 0.0, y: 0.0, width: CGFloat(width), height: CGFloat(height)))\n        \n        pixelValues = intensities\n    }\n    \n    return pixelValues\n}\n\nfunc compareImages(image1: UIImage, image2: UIImage) -> Double? {\n    guard let data1 = pixelValues(fromCGImage: image1.cgImage),\n        let data2 = pixelValues(fromCGImage: image2.cgImage),\n        data1.count == data2.count else {\n            return nil\n    }\n    \n    let width = Double(image1.size.width)\n    let height = Double(image1.size.height)\n    \n    return zip(data1, data2)\n        .enumerated()\n        .reduce(0.0) {\n            $1.offset % 4 == 3 ? $0 : $0 + abs(Double($1.element.0) - Double($1.element.1))\n        }\n        * 100 / (width * height * 3.0) / 255.0\n}\n\nlet image1 = UIImage(named: \"Lenna50\")\nlet image2 = UIImage(named: \"Lenna100\")\n\ncompareImages(image1: image1, image2: image2)\n", "target": "using System;\nusing System.Drawing;\n\nclass Program\n{\n    static void Main()\n    {\n        Bitmap img1 = new Bitmap(\"Lenna50.jpg\");\n        Bitmap img2 = new Bitmap(\"Lenna100.jpg\");\n\n        if (img1.Size != img2.Size)\n        {\n            Console.Error.WriteLine(\"Images are of different sizes\");\n            return;\n        }\n\n        float diff = 0;\n\n        for (int y = 0; y < img1.Height; y++)\n        {\n            for (int x = 0; x < img1.Width; x++)\n            {\n                Color pixel1 = img1.GetPixel(x, y);\n                Color pixel2 = img2.GetPixel(x, y);\n\n                diff += Math.Abs(pixel1.R - pixel2.R);\n                diff += Math.Abs(pixel1.G - pixel2.G);\n                diff += Math.Abs(pixel1.B - pixel2.B);\n            }\n        }\n\n        Console.WriteLine(\"diff: {0}\u00a0%\", 100 * (diff / 255) / (img1.Width * img1.Height * 3));\n    }\n}\n"}
{"id": 728, "name": "Percentage difference between images", "source": "Translate Swift to Java: func pixelValues(fromCGImage imageRef: CGImage?) -> [UInt8]?\n{\n    var width = 0\n    var height = 0\n    var pixelValues: [UInt8]?\n    \n    if let imageRef = imageRef {\n        width = imageRef.width\n        height = imageRef.height\n        let bitsPerComponent = imageRef.bitsPerComponent\n        let bytesPerRow = imageRef.bytesPerRow\n        let totalBytes = height * bytesPerRow\n        let bitmapInfo = imageRef.bitmapInfo\n        \n        let colorSpace = CGColorSpaceCreateDeviceRGB()\n        var intensities = [UInt8](repeating: 0, count: totalBytes)\n        \n        let contextRef = CGContext(data: &intensities,\n                                  width: width,\n                                 height: height,\n                       bitsPerComponent: bitsPerComponent,\n                            bytesPerRow: bytesPerRow,\n                                  space: colorSpace,\n                             bitmapInfo: bitmapInfo.rawValue)\n        contextRef?.draw(imageRef, in: CGRect(x: 0.0, y: 0.0, width: CGFloat(width), height: CGFloat(height)))\n        \n        pixelValues = intensities\n    }\n    \n    return pixelValues\n}\n\nfunc compareImages(image1: UIImage, image2: UIImage) -> Double? {\n    guard let data1 = pixelValues(fromCGImage: image1.cgImage),\n        let data2 = pixelValues(fromCGImage: image2.cgImage),\n        data1.count == data2.count else {\n            return nil\n    }\n    \n    let width = Double(image1.size.width)\n    let height = Double(image1.size.height)\n    \n    return zip(data1, data2)\n        .enumerated()\n        .reduce(0.0) {\n            $1.offset % 4 == 3 ? $0 : $0 + abs(Double($1.element.0) - Double($1.element.1))\n        }\n        * 100 / (width * height * 3.0) / 255.0\n}\n\nlet image1 = UIImage(named: \"Lenna50\")\nlet image2 = UIImage(named: \"Lenna100\")\n\ncompareImages(image1: image1, image2: image2)\n", "target": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic enum ImgDiffPercent {\n    ;\n\n    public static void main(String[] args) throws IOException {\n        \n        \n        BufferedImage img1 = ImageIO.read(new File(\"Lenna50.jpg\"));\n        BufferedImage img2 = ImageIO.read(new File(\"Lenna100.jpg\"));\n\n        double p = getDifferencePercent(img1, img2);\n        System.out.println(\"diff percent: \" + p);\n    }\n\n    private static double getDifferencePercent(BufferedImage img1, BufferedImage img2) {\n        int width = img1.getWidth();\n        int height = img1.getHeight();\n        int width2 = img2.getWidth();\n        int height2 = img2.getHeight();\n        if (width != width2 || height != height2) {\n            throw new IllegalArgumentException(String.format(\"Images must have the same dimensions: (%d,%d) vs. (%d,%d)\", width, height, width2, height2));\n        }\n\n        long diff = 0;\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                diff += pixelDiff(img1.getRGB(x, y), img2.getRGB(x, y));\n            }\n        }\n        long maxDiff = 3L * 255 * width * height;\n\n        return 100.0 * diff / maxDiff;\n    }\n\n    private static int pixelDiff(int rgb1, int rgb2) {\n        int r1 = (rgb1 >> 16) & 0xff;\n        int g1 = (rgb1 >>  8) & 0xff;\n        int b1 =  rgb1        & 0xff;\n        int r2 = (rgb2 >> 16) & 0xff;\n        int g2 = (rgb2 >>  8) & 0xff;\n        int b2 =  rgb2        & 0xff;\n        return Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);\n    }\n}\n"}
{"id": 729, "name": "Percentage difference between images", "source": "Translate Swift to Python: func pixelValues(fromCGImage imageRef: CGImage?) -> [UInt8]?\n{\n    var width = 0\n    var height = 0\n    var pixelValues: [UInt8]?\n    \n    if let imageRef = imageRef {\n        width = imageRef.width\n        height = imageRef.height\n        let bitsPerComponent = imageRef.bitsPerComponent\n        let bytesPerRow = imageRef.bytesPerRow\n        let totalBytes = height * bytesPerRow\n        let bitmapInfo = imageRef.bitmapInfo\n        \n        let colorSpace = CGColorSpaceCreateDeviceRGB()\n        var intensities = [UInt8](repeating: 0, count: totalBytes)\n        \n        let contextRef = CGContext(data: &intensities,\n                                  width: width,\n                                 height: height,\n                       bitsPerComponent: bitsPerComponent,\n                            bytesPerRow: bytesPerRow,\n                                  space: colorSpace,\n                             bitmapInfo: bitmapInfo.rawValue)\n        contextRef?.draw(imageRef, in: CGRect(x: 0.0, y: 0.0, width: CGFloat(width), height: CGFloat(height)))\n        \n        pixelValues = intensities\n    }\n    \n    return pixelValues\n}\n\nfunc compareImages(image1: UIImage, image2: UIImage) -> Double? {\n    guard let data1 = pixelValues(fromCGImage: image1.cgImage),\n        let data2 = pixelValues(fromCGImage: image2.cgImage),\n        data1.count == data2.count else {\n            return nil\n    }\n    \n    let width = Double(image1.size.width)\n    let height = Double(image1.size.height)\n    \n    return zip(data1, data2)\n        .enumerated()\n        .reduce(0.0) {\n            $1.offset % 4 == 3 ? $0 : $0 + abs(Double($1.element.0) - Double($1.element.1))\n        }\n        * 100 / (width * height * 3.0) / 255.0\n}\n\nlet image1 = UIImage(named: \"Lenna50\")\nlet image2 = UIImage(named: \"Lenna100\")\n\ncompareImages(image1: image1, image2: image2)\n", "target": "from PIL import Image\n\ni1 = Image.open(\"image1.jpg\")\ni2 = Image.open(\"image2.jpg\")\nassert i1.mode == i2.mode, \"Different kinds of images.\"\nassert i1.size == i2.size, \"Different sizes.\"\n\npairs = zip(i1.getdata(), i2.getdata())\nif len(i1.getbands()) == 1:\n    \n    dif = sum(abs(p1-p2) for p1,p2 in pairs)\nelse:\n    dif = sum(abs(c1-c2) for p1,p2 in pairs for c1,c2 in zip(p1,p2))\n\nncomponents = i1.size[0] * i1.size[1] * 3\nprint (\"Difference (percentage):\", (dif / 255.0 * 100) / ncomponents)\n"}
{"id": 966, "name": "Bitwise operations", "source": "Translate Swift to C#: func bitwise(a: Int, b: Int) {\n  \n  \n  println(\"a AND b: \\(a & b)\")\n  println(\"a OR b: \\(a | b)\")\n  println(\"a XOR b: \\(a ^ b)\")\n  println(\"NOT a: \\(~a)\")\n  println(\"a << b: \\(a << b)\") \n  \n  \n  println(\"a >> b: \\(a >> b)\") \n  println(\"a lsr b: \\(Int(bitPattern: UInt(bitPattern: a) >> UInt(bitPattern: b)))\") \n}\n\nbitwise(-15,3)\n", "target": "static void bitwise(int a, int b)\n        {\n            Console.WriteLine(\"a and b is {0}\", a & b);\n            Console.WriteLine(\"a or b is {0}\", a | b);\n            Console.WriteLine(\"a xor b is {0}\", a ^ b);\n            Console.WriteLine(\"not a is {0}\", ~a);\n            Console.WriteLine(\"a lshift b is {0}\", a << b);\n            Console.WriteLine(\"a arshift b is {0}\", a >> b); \n                                                             \n            uint c = (uint)a;\n            Console.WriteLine(\"c rshift b is {0}\", c >> b); \n                                                            \n            \n        }\n"}
{"id": 968, "name": "Bitwise operations", "source": "Translate Swift to Java: func bitwise(a: Int, b: Int) {\n  \n  \n  println(\"a AND b: \\(a & b)\")\n  println(\"a OR b: \\(a | b)\")\n  println(\"a XOR b: \\(a ^ b)\")\n  println(\"NOT a: \\(~a)\")\n  println(\"a << b: \\(a << b)\") \n  \n  \n  println(\"a >> b: \\(a >> b)\") \n  println(\"a lsr b: \\(Int(bitPattern: UInt(bitPattern: a) >> UInt(bitPattern: b)))\") \n}\n\nbitwise(-15,3)\n", "target": "module BitwiseOps\n    {\n    @Inject Console console;\n    void run()\n        {\n        for ((Int64 n1, Int64 n2) : [0=7, 1=5, 42=2, 0x123456789ABCDEF=0xFF])  \n            {\n            static String hex(Int64 n)   \n                {\n                \n                return n.toByteArray() [(n.leadingZeroCount / 8).minOf(7) ..< 8].toString();\n                }\n\n            console.print($|For values {n1} ({hex(n1)}) and {n2} ({hex(n2)}):\n                           |  {hex(n1)} AND {hex(n2)} = {hex(n1 & n2)}\n                           |  {hex(n1)} OR {hex(n2)} = {hex(n1 | n2)}\n                           |  {hex(n1)} XOR {hex(n2)} = {hex(n1 ^ n2)}\n                           |  NOT {hex(n1)} = {hex(~n1)}\n                           |  left shift {hex(n1)} by {n2} = {hex(n1 << n2)}\n                           |  right shift {hex(n1)} by {n2} = {hex(n1 >> n2)}\n                           |  right arithmetic shift {hex(n1)} by {n2} = {hex(n1 >>> n2)}\n                           |  left rotate {hex(n1)} by {n2} = {hex(n1.rotateLeft(n2))}\n                           |  right rotate {hex(n1)} by {n2} = {hex(n1.rotateRight(n2))}\n                           |  leftmost bit of {hex(n1)} = {hex(n1.leftmostBit)}\n                           |  rightmost bit of {hex(n1)} = {hex(n1.rightmostBit)}\n                           |  leading zero count of {hex(n1)} = {n1.leadingZeroCount}\n                           |  trailing zero count of {hex(n1)} = {n1.trailingZeroCount}\n                           |  bit count (aka \"population\") of {hex(n1)} = {n1.bitCount}\n                           |  reversed bits of {hex(n1)} = {hex(n1.reverseBits())}\n                           |  reverse bytes of {hex(n1)} = {hex(n1.reverseBytes())}\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 969, "name": "Bitwise operations", "source": "Translate Swift to Python: func bitwise(a: Int, b: Int) {\n  \n  \n  println(\"a AND b: \\(a & b)\")\n  println(\"a OR b: \\(a | b)\")\n  println(\"a XOR b: \\(a ^ b)\")\n  println(\"NOT a: \\(~a)\")\n  println(\"a << b: \\(a << b)\") \n  \n  \n  println(\"a >> b: \\(a >> b)\") \n  println(\"a lsr b: \\(Int(bitPattern: UInt(bitPattern: a) >> UInt(bitPattern: b)))\") \n}\n\nbitwise(-15,3)\n", "target": "def bitwise_built_ins(width, a, b):\n    mask = (1 << width) - 1\n    print(f)\n\ndef rotr(width, a, n):\n    \"Rotate a, n times to the right\"\n    if n < 0:\n        return rotl(width, a, -n)\n    elif n == 0:\n        return a\n    else:\n        mask = (1 << width) - 1\n        a, n = a & mask, n % width\n        return ((a >> n)    \n                | ((a & ((1 << n) - 1))   \n                   << (width - n)))  \n\ndef rotl(width, a, n):\n    \"Rotate a, n times to the left\"\n    if n < 0:\n        return rotr(width, a, -n)\n    elif n == 0:\n        return a\n    else:\n        mask = (1 << width) - 1\n        a, n = a & mask, n % width\n        return (((a << n) & mask)      \n                | (a >> (width - n)))  \n    \ndef asr(width, a, n):\n    \"Arithmetic shift a, n times to the right. (sign preserving).\"\n    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)\n    if n < 0:\n        return  (a << -n) & mask\n    elif n == 0:\n        return a\n    elif n >= width:\n        return mask if a & top_bit_mask else 0\n    else:\n        a = a & mask\n        if a & top_bit_mask:    \n            signs = (1 << n) - 1\n            return a >> n | (signs << width - n)\n        else:\n            return a >> n\n    \n      \ndef helper_funcs(width, a):\n    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)\n    aa = a | top_bit_mask  \n    print(f)\n\nif __name__ == '__main__':\n    bitwise_built_ins(8, 27, 125)\n    helper_funcs(8, 27)\n"}
{"id": 1564, "name": "Flatten a list", "source": "Translate Swift to C#: func list(s: Any...) -> [Any] {\n  return s\n}\n\nfunc flatten<T>(s: [Any]) -> [T] {\n  var r = [T]()\n  for e in s {\n    switch e {\n    case let a as [Any]:\n      r += flatten(a)\n    case let x as T:\n      r.append(x)\n    default:\n      assert(false, \"value of wrong type\")\n    }\n  }\n  return r\n}\n\nlet s = list(list(1),\n  2,\n  list(list(3, 4), 5),\n  list(list(list())),\n  list(list(list(6))),\n  7,\n  8,\n  list()\n)\nprintln(s)\nlet result : [Int] = flatten(s)\nprintln(result)\n", "target": "using System;\nusing System.Collections;\nusing System.Linq;\n\nnamespace RosettaCodeTasks\n{\n\tstatic class FlattenList\n\t{\n\t\tpublic static ArrayList Flatten(this ArrayList List)\n\t\t{\n\t\t\tArrayList NewList = new ArrayList ( );\n\n\t\t\tNewList.AddRange ( List );\n\n\t\t\twhile ( NewList.OfType<ArrayList> ( ).Count ( ) > 0 )\n\t\t\t{\n\t\t\t\tint index = NewList.IndexOf ( NewList.OfType<ArrayList> ( ).ElementAt ( 0 ) );\n\t\t\t\tArrayList Temp = (ArrayList)NewList[index];\n\t\t\t\tNewList.RemoveAt ( index );\n\t\t\t\tNewList.InsertRange ( index, Temp );\n\t\t\t}\n\t\t\t\n\t\t\treturn NewList;\n\t\t}\n\t}\n}\n"}
{"id": 1565, "name": "Flatten a list", "source": "Translate Swift to C#: func list(s: Any...) -> [Any] {\n  return s\n}\n\nfunc flatten<T>(s: [Any]) -> [T] {\n  var r = [T]()\n  for e in s {\n    switch e {\n    case let a as [Any]:\n      r += flatten(a)\n    case let x as T:\n      r.append(x)\n    default:\n      assert(false, \"value of wrong type\")\n    }\n  }\n  return r\n}\n\nlet s = list(list(1),\n  2,\n  list(list(3, 4), 5),\n  list(list(list())),\n  list(list(list(6))),\n  7,\n  8,\n  list()\n)\nprintln(s)\nlet result : [Int] = flatten(s)\nprintln(result)\n", "target": "using System;\nusing System.Collections;\nusing System.Linq;\n\nnamespace RosettaCodeTasks\n{\n\tstatic class FlattenList\n\t{\n\t\tpublic static ArrayList Flatten(this ArrayList List)\n\t\t{\n\t\t\tArrayList NewList = new ArrayList ( );\n\n\t\t\tNewList.AddRange ( List );\n\n\t\t\twhile ( NewList.OfType<ArrayList> ( ).Count ( ) > 0 )\n\t\t\t{\n\t\t\t\tint index = NewList.IndexOf ( NewList.OfType<ArrayList> ( ).ElementAt ( 0 ) );\n\t\t\t\tArrayList Temp = (ArrayList)NewList[index];\n\t\t\t\tNewList.RemoveAt ( index );\n\t\t\t\tNewList.InsertRange ( index, Temp );\n\t\t\t}\n\t\t\t\n\t\t\treturn NewList;\n\t\t}\n\t}\n}\n"}
{"id": 1568, "name": "Flatten a list", "source": "Translate Swift to Java: func list(s: Any...) -> [Any] {\n  return s\n}\n\nfunc flatten<T>(s: [Any]) -> [T] {\n  var r = [T]()\n  for e in s {\n    switch e {\n    case let a as [Any]:\n      r += flatten(a)\n    case let x as T:\n      r.append(x)\n    default:\n      assert(false, \"value of wrong type\")\n    }\n  }\n  return r\n}\n\nlet s = list(list(1),\n  2,\n  list(list(3, 4), 5),\n  list(list(list())),\n  list(list(list(6))),\n  7,\n  8,\n  list()\n)\nprintln(s)\nlet result : [Int] = flatten(s)\nprintln(result)\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\n\npublic final class FlattenUtil {\n\n\tpublic static List<Object> flatten(List<?> list) {\n\t\tList<Object> retVal = new LinkedList<Object>();\n\t\tflatten(list, retVal);\n\t\treturn retVal;\n\t}\n\n\tpublic static void flatten(List<?> fromTreeList, List<Object> toFlatList) {\n\t\tfor (Object item : fromTreeList) {\n\t\t\tif (item instanceof List<?>) {\n\t\t\t\tflatten((List<?>) item, toFlatList);\n\t\t\t} else {\n\t\t\t\ttoFlatList.add(item);\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 1569, "name": "Flatten a list", "source": "Translate Swift to Java: func list(s: Any...) -> [Any] {\n  return s\n}\n\nfunc flatten<T>(s: [Any]) -> [T] {\n  var r = [T]()\n  for e in s {\n    switch e {\n    case let a as [Any]:\n      r += flatten(a)\n    case let x as T:\n      r.append(x)\n    default:\n      assert(false, \"value of wrong type\")\n    }\n  }\n  return r\n}\n\nlet s = list(list(1),\n  2,\n  list(list(3, 4), 5),\n  list(list(list())),\n  list(list(list(6))),\n  7,\n  8,\n  list()\n)\nprintln(s)\nlet result : [Int] = flatten(s)\nprintln(result)\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\n\npublic final class FlattenUtil {\n\n\tpublic static List<Object> flatten(List<?> list) {\n\t\tList<Object> retVal = new LinkedList<Object>();\n\t\tflatten(list, retVal);\n\t\treturn retVal;\n\t}\n\n\tpublic static void flatten(List<?> fromTreeList, List<Object> toFlatList) {\n\t\tfor (Object item : fromTreeList) {\n\t\t\tif (item instanceof List<?>) {\n\t\t\t\tflatten((List<?>) item, toFlatList);\n\t\t\t} else {\n\t\t\t\ttoFlatList.add(item);\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 1570, "name": "Flatten a list", "source": "Translate Swift to Python: func list(s: Any...) -> [Any] {\n  return s\n}\n\nfunc flatten<T>(s: [Any]) -> [T] {\n  var r = [T]()\n  for e in s {\n    switch e {\n    case let a as [Any]:\n      r += flatten(a)\n    case let x as T:\n      r.append(x)\n    default:\n      assert(false, \"value of wrong type\")\n    }\n  }\n  return r\n}\n\nlet s = list(list(1),\n  2,\n  list(list(3, 4), 5),\n  list(list(list())),\n  list(list(list(6))),\n  7,\n  8,\n  list()\n)\nprintln(s)\nlet result : [Int] = flatten(s)\nprintln(result)\n", "target": ">>> def flatten(lst):\n\treturn sum( ([x] if not isinstance(x, list) else flatten(x)\n\t\t     for x in lst), [] )\n\n>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\n>>> flatten(lst)\n[1, 2, 3, 4, 5, 6, 7, 8]\n"}
{"id": 1571, "name": "Flatten a list", "source": "Translate Swift to Python: func list(s: Any...) -> [Any] {\n  return s\n}\n\nfunc flatten<T>(s: [Any]) -> [T] {\n  var r = [T]()\n  for e in s {\n    switch e {\n    case let a as [Any]:\n      r += flatten(a)\n    case let x as T:\n      r.append(x)\n    default:\n      assert(false, \"value of wrong type\")\n    }\n  }\n  return r\n}\n\nlet s = list(list(1),\n  2,\n  list(list(3, 4), 5),\n  list(list(list())),\n  list(list(list(6))),\n  7,\n  8,\n  list()\n)\nprintln(s)\nlet result : [Int] = flatten(s)\nprintln(result)\n", "target": ">>> def flatten(lst):\n\treturn sum( ([x] if not isinstance(x, list) else flatten(x)\n\t\t     for x in lst), [] )\n\n>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\n>>> flatten(lst)\n[1, 2, 3, 4, 5, 6, 7, 8]\n"}
{"id": 1842, "name": "Calendar", "source": "Translate Swift to C#: import Foundation\n\nlet monthWidth = 20\nlet monthGap = 2\nlet dayNames = \"Su Mo Tu We Th Fr Sa\"\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"MMMM\"\n\nfunc rpad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc lpad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : string + String(repeating: \" \", count: width - string.count)\n}\n\nfunc centre(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    let c = (width - string.count)/2\n    return String(repeating: \" \", count: c) + string\n        + String(repeating: \" \", count: width - string.count - c)\n}\n\nfunc formatMonth(year: Int, month: Int) -> [String] {\n    let calendar = Calendar.current\n    let dc = DateComponents(year: year, month: month, day: 1)\n    let date = calendar.date(from: dc)!\n    let firstDay = calendar.component(.weekday, from: date) - 1\n    let range = calendar.range(of: .day, in: .month, for: date)!\n    let daysInMonth = range.count\n    var lines: [String] = []\n    lines.append(centre(string: dateFormatter.string(from: date), width: monthWidth))\n    lines.append(dayNames)\n    var padWidth = 2\n    var line = String(repeating: \" \", count: 3 * firstDay)\n    for day in 1...daysInMonth {\n        line += rpad(string: String(day), width: padWidth)\n        padWidth = 3\n        if (firstDay + day) % 7 == 0 {\n            lines.append(line)\n            line = \"\"\n            padWidth = 2\n        }\n    }\n    if line.count > 0 {\n        lines.append(lpad(string: line, width: monthWidth))\n    }\n    return lines\n}\n\nfunc printCentred(string: String, width: Int) {\n    print(rpad(string: string, width: (width + string.count)/2))\n}\n\npublic func printCalendar(year: Int, width: Int) {\n    let months = min(12, max(1, (width + monthGap)/(monthWidth + monthGap)))\n    let lineWidth = monthWidth * months + monthGap * (months - 1)\n    printCentred(string: \"[Snoopy]\", width: lineWidth)\n    printCentred(string: String(year), width: lineWidth)\n    var firstMonth = 1\n    while firstMonth <= 12 {\n        if firstMonth > 1 {\n            print()\n        }\n        let lastMonth = min(12, firstMonth + months - 1)\n        let monthCount = lastMonth - firstMonth + 1\n        var lines: [[String]] = []\n        var lineCount = 0\n        for month in firstMonth...lastMonth {\n            let monthLines = formatMonth(year: year, month: month)\n            lineCount = max(lineCount, monthLines.count)\n            lines.append(monthLines)\n        }\n        for i in 0..<lineCount {\n            var line = \"\"\n            for month in 0..<monthCount {\n                if month > 0 {\n                    line.append(String(repeating: \" \", count: monthGap))\n                }\n                line.append(i < lines[month].count ? lines[month][i]\n                            : String(repeating: \" \", count: monthWidth))\n            }\n            print(line)\n        }\n        firstMonth = lastMonth + 1\n    }\n}\n\nprintCalendar(year: 1969, width: 80)\n", "target": "using System;\nusing System.Collections.Generic; \nusing System.Linq;\nusing System.Text;\n\nnamespace CalendarStuff\n{\n \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WindowHeight = 46;\n            Console.Write(buildMonths(new DateTime(1969, 1, 1)));\n            Console.Read(); \n        }\n        private static string buildMonths(DateTime date)\n        {\n            StringBuilder sb = new StringBuilder();\n            sb.AppendLine(center(\"[Snoop]\", 24 * 3));\n            sb.AppendLine();\n            sb.AppendLine(center(date.Year.ToString(), 24 * 3));\n\n            List<DateTime> dts = new List<DateTime>();\n            while (true)\n            {\n                dts.Add(date);\n                if (date.Year != ((date = date.AddMonths(1)).Year))\n                {\n                    break;\n                }\n            }\n            var jd = dts.Select(a => buildMonth(a).GetEnumerator()).ToArray();\n            \n            int sCur=0;\n            while (sCur<dts.Count)\n            {\n                sb.AppendLine();\n                int curMonth=0; \n                var j = jd.Where(a => curMonth++ >= sCur && curMonth - 1 < sCur + 3).ToArray(); \n                sCur += j.Length; \n                bool breakOut = false;\n                while (!breakOut)\n                {\n                    int inj = 1;\n                    foreach (var cd in j)\n                    {\n                        if (cd.MoveNext())\n                        {\n                            sb.Append((cd.Current.Length == 21 ? cd.Current : cd.Current.PadRight(21, ' ')) + \"     \");\n                        }\n                        else\n                        {\n                            sb.Append(\"\".PadRight(21, ' ') + \"     \");\n                            breakOut = true;\n                        }\n                        if (inj++ % 3 == 0) sb.AppendLine();\n                    }\n                }\n\n            }\n            return sb.ToString();\n        }\n\n\n        private static IEnumerable<string> buildMonth(DateTime date)\n        {\n            yield return center(date.ToString(\"MMMM\"),7*3);\n            var j = DateTime.DaysInMonth(date.Year, date.Month);\n            yield return Enum.GetNames(typeof(DayOfWeek)).Aggregate(\"\", (current, result) => current + (result.Substring(0, 2).ToUpper() + \" \"));\n            string cur = \"\";\n            int total = 0;\n\n            foreach (var day in Enumerable.Range(-((int)date.DayOfWeek),j + (int)date.DayOfWeek))\n            {\n                cur += (day < 0 ? \"  \" : ((day < 9 ? \" \" : \"\") + (day + 1))) +\" \";\n                if (total++ > 0 && (total ) % 7 == 0)\n                {\n                    yield return cur;\n                    cur = \"\";\n                }\n            }\n            yield return cur;\n        }\n        private static string center(string s, int len)\n        {\n            return (s.PadLeft((len - s.Length) / 2 + s.Length, ' ').PadRight((len), ' '));\n        } \n    }\n}\n"}
{"id": 1844, "name": "Calendar", "source": "Translate Swift to Java: import Foundation\n\nlet monthWidth = 20\nlet monthGap = 2\nlet dayNames = \"Su Mo Tu We Th Fr Sa\"\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"MMMM\"\n\nfunc rpad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc lpad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : string + String(repeating: \" \", count: width - string.count)\n}\n\nfunc centre(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    let c = (width - string.count)/2\n    return String(repeating: \" \", count: c) + string\n        + String(repeating: \" \", count: width - string.count - c)\n}\n\nfunc formatMonth(year: Int, month: Int) -> [String] {\n    let calendar = Calendar.current\n    let dc = DateComponents(year: year, month: month, day: 1)\n    let date = calendar.date(from: dc)!\n    let firstDay = calendar.component(.weekday, from: date) - 1\n    let range = calendar.range(of: .day, in: .month, for: date)!\n    let daysInMonth = range.count\n    var lines: [String] = []\n    lines.append(centre(string: dateFormatter.string(from: date), width: monthWidth))\n    lines.append(dayNames)\n    var padWidth = 2\n    var line = String(repeating: \" \", count: 3 * firstDay)\n    for day in 1...daysInMonth {\n        line += rpad(string: String(day), width: padWidth)\n        padWidth = 3\n        if (firstDay + day) % 7 == 0 {\n            lines.append(line)\n            line = \"\"\n            padWidth = 2\n        }\n    }\n    if line.count > 0 {\n        lines.append(lpad(string: line, width: monthWidth))\n    }\n    return lines\n}\n\nfunc printCentred(string: String, width: Int) {\n    print(rpad(string: string, width: (width + string.count)/2))\n}\n\npublic func printCalendar(year: Int, width: Int) {\n    let months = min(12, max(1, (width + monthGap)/(monthWidth + monthGap)))\n    let lineWidth = monthWidth * months + monthGap * (months - 1)\n    printCentred(string: \"[Snoopy]\", width: lineWidth)\n    printCentred(string: String(year), width: lineWidth)\n    var firstMonth = 1\n    while firstMonth <= 12 {\n        if firstMonth > 1 {\n            print()\n        }\n        let lastMonth = min(12, firstMonth + months - 1)\n        let monthCount = lastMonth - firstMonth + 1\n        var lines: [[String]] = []\n        var lineCount = 0\n        for month in firstMonth...lastMonth {\n            let monthLines = formatMonth(year: year, month: month)\n            lineCount = max(lineCount, monthLines.count)\n            lines.append(monthLines)\n        }\n        for i in 0..<lineCount {\n            var line = \"\"\n            for month in 0..<monthCount {\n                if month > 0 {\n                    line.append(String(repeating: \" \", count: monthGap))\n                }\n                line.append(i < lines[month].count ? lines[month][i]\n                            : String(repeating: \" \", count: monthWidth))\n            }\n            print(line)\n        }\n        firstMonth = lastMonth + 1\n    }\n}\n\nprintCalendar(year: 1969, width: 80)\n", "target": "import java.text.*;\nimport java.util.*;\n\npublic class CalendarTask {\n\n    public static void main(String[] args) {\n        printCalendar(1969, 3);\n    }\n\n    static void printCalendar(int year, int nCols) {\n        if (nCols < 1 || nCols > 12)\n            throw new IllegalArgumentException(\"Illegal column width.\");\n\n        Calendar date = new GregorianCalendar(year, 0, 1);\n\n        int nRows = (int) Math.ceil(12.0 / nCols);\n        int offs = date.get(Calendar.DAY_OF_WEEK) - 1;\n        int w = nCols * 24;\n\n        String[] monthNames = new DateFormatSymbols(Locale.US).getMonths();\n\n        String[][] mons = new String[12][8];\n        for (int m = 0; m < 12; m++) {\n\n            String name = monthNames[m];\n            int len = 11 + name.length() / 2;\n            String format = MessageFormat.format(\"%{0}s%{1}s\", len, 21 - len);\n\n            mons[m][0] = String.format(format, name, \"\");\n            mons[m][1] = \" Su Mo Tu We Th Fr Sa\";\n            int dim = date.getActualMaximum(Calendar.DAY_OF_MONTH);\n\n            for (int d = 1; d < 43; d++) {\n                boolean isDay = d > offs && d <= offs + dim;\n                String entry = isDay ? String.format(\" %2s\", d - offs) : \"   \";\n                if (d % 7 == 1)\n                    mons[m][2 + (d - 1) / 7] = entry;\n                else\n                    mons[m][2 + (d - 1) / 7] += entry;\n            }\n            offs = (offs + dim) % 7;\n            date.add(Calendar.MONTH, 1);\n        }\n\n        System.out.printf(\"%\" + (w / 2 + 10) + \"s%n\", \"[Snoopy Picture]\");\n        System.out.printf(\"%\" + (w / 2 + 4) + \"s%n%n\", year);\n\n        for (int r = 0; r < nRows; r++) {\n            for (int i = 0; i < 8; i++) {\n                for (int c = r * nCols; c < (r + 1) * nCols && c < 12; c++)\n                    System.out.printf(\"   %s\", mons[c][i]);\n                System.out.println();\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 1845, "name": "Calendar", "source": "Translate Swift to Python: import Foundation\n\nlet monthWidth = 20\nlet monthGap = 2\nlet dayNames = \"Su Mo Tu We Th Fr Sa\"\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"MMMM\"\n\nfunc rpad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc lpad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : string + String(repeating: \" \", count: width - string.count)\n}\n\nfunc centre(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    let c = (width - string.count)/2\n    return String(repeating: \" \", count: c) + string\n        + String(repeating: \" \", count: width - string.count - c)\n}\n\nfunc formatMonth(year: Int, month: Int) -> [String] {\n    let calendar = Calendar.current\n    let dc = DateComponents(year: year, month: month, day: 1)\n    let date = calendar.date(from: dc)!\n    let firstDay = calendar.component(.weekday, from: date) - 1\n    let range = calendar.range(of: .day, in: .month, for: date)!\n    let daysInMonth = range.count\n    var lines: [String] = []\n    lines.append(centre(string: dateFormatter.string(from: date), width: monthWidth))\n    lines.append(dayNames)\n    var padWidth = 2\n    var line = String(repeating: \" \", count: 3 * firstDay)\n    for day in 1...daysInMonth {\n        line += rpad(string: String(day), width: padWidth)\n        padWidth = 3\n        if (firstDay + day) % 7 == 0 {\n            lines.append(line)\n            line = \"\"\n            padWidth = 2\n        }\n    }\n    if line.count > 0 {\n        lines.append(lpad(string: line, width: monthWidth))\n    }\n    return lines\n}\n\nfunc printCentred(string: String, width: Int) {\n    print(rpad(string: string, width: (width + string.count)/2))\n}\n\npublic func printCalendar(year: Int, width: Int) {\n    let months = min(12, max(1, (width + monthGap)/(monthWidth + monthGap)))\n    let lineWidth = monthWidth * months + monthGap * (months - 1)\n    printCentred(string: \"[Snoopy]\", width: lineWidth)\n    printCentred(string: String(year), width: lineWidth)\n    var firstMonth = 1\n    while firstMonth <= 12 {\n        if firstMonth > 1 {\n            print()\n        }\n        let lastMonth = min(12, firstMonth + months - 1)\n        let monthCount = lastMonth - firstMonth + 1\n        var lines: [[String]] = []\n        var lineCount = 0\n        for month in firstMonth...lastMonth {\n            let monthLines = formatMonth(year: year, month: month)\n            lineCount = max(lineCount, monthLines.count)\n            lines.append(monthLines)\n        }\n        for i in 0..<lineCount {\n            var line = \"\"\n            for month in 0..<monthCount {\n                if month > 0 {\n                    line.append(String(repeating: \" \", count: monthGap))\n                }\n                line.append(i < lines[month].count ? lines[month][i]\n                            : String(repeating: \" \", count: monthWidth))\n            }\n            print(line)\n        }\n        firstMonth = lastMonth + 1\n    }\n}\n\nprintCalendar(year: 1969, width: 80)\n", "target": ">>> import calendar\n>>> help(calendar.prcal)\nHelp on method pryear in module calendar:\n\npryear(self, theyear, w=0, l=0, c=6, m=3) method of calendar.TextCalendar instance\n    Print a years calendar.\n\n>>> calendar.prcal(1969)\n                                  1969\n\n      January                   February                   March\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n       1  2  3  4  5                      1  2                      1  2\n 6  7  8  9 10 11 12       3  4  5  6  7  8  9       3  4  5  6  7  8  9\n13 14 15 16 17 18 19      10 11 12 13 14 15 16      10 11 12 13 14 15 16\n20 21 22 23 24 25 26      17 18 19 20 21 22 23      17 18 19 20 21 22 23\n27 28 29 30 31            24 25 26 27 28            24 25 26 27 28 29 30\n                                                    31\n\n       April                      May                       June\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n    1  2  3  4  5  6                1  2  3  4                         1\n 7  8  9 10 11 12 13       5  6  7  8  9 10 11       2  3  4  5  6  7  8\n14 15 16 17 18 19 20      12 13 14 15 16 17 18       9 10 11 12 13 14 15\n21 22 23 24 25 26 27      19 20 21 22 23 24 25      16 17 18 19 20 21 22\n28 29 30                  26 27 28 29 30 31         23 24 25 26 27 28 29\n                                                    30\n\n        July                     August                  September\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n    1  2  3  4  5  6                   1  2  3       1  2  3  4  5  6  7\n 7  8  9 10 11 12 13       4  5  6  7  8  9 10       8  9 10 11 12 13 14\n14 15 16 17 18 19 20      11 12 13 14 15 16 17      15 16 17 18 19 20 21\n21 22 23 24 25 26 27      18 19 20 21 22 23 24      22 23 24 25 26 27 28\n28 29 30 31               25 26 27 28 29 30 31      29 30\n\n      October                   November                  December\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n       1  2  3  4  5                      1  2       1  2  3  4  5  6  7\n 6  7  8  9 10 11 12       3  4  5  6  7  8  9       8  9 10 11 12 13 14\n13 14 15 16 17 18 19      10 11 12 13 14 15 16      15 16 17 18 19 20 21\n20 21 22 23 24 25 26      17 18 19 20 21 22 23      22 23 24 25 26 27 28\n27 28 29 30 31            24 25 26 27 28 29 30      29 30 31\n"}
{"id": 2268, "name": "String interpolation (included)", "source": "Translate Swift to C#: let extra = \"little\"\nprintln(\"Mary had a \\(extra) lamb.\")\n", "target": "class Program\n{\n    static void Main()\n    {\n        string extra = \"little\";\n        string formatted = $\"Mary had a {extra} lamb.\";\n        System.Console.WriteLine(formatted);\n    }\n}\n"}
{"id": 2270, "name": "String interpolation (included)", "source": "Translate Swift to Java: let extra = \"little\"\nprintln(\"Mary had a \\(extra) lamb.\")\n", "target": "String original = \"Mary had a X lamb\";\nString little = \"little\";\nString replaced = original.replace(\"X\", little); \nSystem.out.println(replaced);\n\nSystem.out.printf(\"Mary had a %s lamb.\", little);\n\nString formatted = String.format(\"Mary had a %s lamb.\", little);\nSystem.out.println(formatted);\n"}
{"id": 2271, "name": "String interpolation (included)", "source": "Translate Swift to Python: let extra = \"little\"\nprintln(\"Mary had a \\(extra) lamb.\")\n", "target": ">>> original = 'Mary had a %s lamb.'\n>>> extra = 'little'\n>>> original % extra\n'Mary had a little lamb.'\n"}
{"id": 2739, "name": "Babbage problem", "source": "Translate Swift to C#: import Swift\n\nfor i in 2...Int.max {\n\tif i * i % 1000000 == 269696 {\n\t\tprint(i, \"is the smallest number that ends with 269696\")\n\t\tbreak\n\t}\n}\n", "target": "namespace Babbage_Problem\n{\n    class iterateNumbers\n    {\n        public iterateNumbers()\n        {\n            long baseNumberSquared = 0; \n            long baseNumber = 0;  \n\n            do  \n            {\n                baseNumber += 1; \n                baseNumberSquared = baseNumber * baseNumber; \n            }\n            while (Right6Digits(baseNumberSquared) != 269696); \n\n            Console.WriteLine(\"The smallest integer whose square ends in 269,696 is \" + baseNumber);\n            Console.WriteLine(\"The square is \" + baseNumberSquared);\n\n        }\n\n        private long Right6Digits(long baseNumberSquared)\n        {\n\n            string numberAsString = baseNumberSquared.ToString(); \n\n            if (numberAsString.Length < 6) { return baseNumberSquared; }; \n\n            numberAsString = numberAsString.Substring(numberAsString.Length - 6);  \n\n            return long.Parse(numberAsString); \n\n        }\n    }\n}}\n"}
{"id": 2742, "name": "Babbage problem", "source": "Translate Swift to Java: import Swift\n\nfor i in 2...Int.max {\n\tif i * i % 1000000 == 269696 {\n\t\tprint(i, \"is the smallest number that ends with 269696\")\n\t\tbreak\n\t}\n}\n", "target": "public class Test {\n\n    public static void main(String[] args) {\n\n        \n        int n = 0;\n\n        \n        do {\n\n            \n            n++;\n\n        \n        } while (n * n % 1000_000 != 269696);\n\n        \n        System.out.println(n);\n    }\n}\n"}
{"id": 2743, "name": "Babbage problem", "source": "Translate Swift to Java: import Swift\n\nfor i in 2...Int.max {\n\tif i * i % 1000000 == 269696 {\n\t\tprint(i, \"is the smallest number that ends with 269696\")\n\t\tbreak\n\t}\n}\n", "target": "public class Test {\n\n    public static void main(String[] args) {\n\n        \n        int n = 0;\n\n        \n        do {\n\n            \n            n++;\n\n        \n        } while (n * n % 1000_000 != 269696);\n\n        \n        System.out.println(n);\n    }\n}\n"}
{"id": 2744, "name": "Babbage problem", "source": "Translate Swift to Python: import Swift\n\nfor i in 2...Int.max {\n\tif i * i % 1000000 == 269696 {\n\t\tprint(i, \"is the smallest number that ends with 269696\")\n\t\tbreak\n\t}\n}\n", "target": "\n\n\nn=0 \n\n\n\n\nwhile n**2 % 1000000 != 269696:\n\n    \n    \n    \n    \n    n += 1 \n\nprint(n) \n"}
{"id": 2745, "name": "Babbage problem", "source": "Translate Swift to Python: import Swift\n\nfor i in 2...Int.max {\n\tif i * i % 1000000 == 269696 {\n\t\tprint(i, \"is the smallest number that ends with 269696\")\n\t\tbreak\n\t}\n}\n", "target": "\n\n\nn=0 \n\n\n\n\nwhile n**2 % 1000000 != 269696:\n\n    \n    \n    \n    \n    n += 1 \n\nprint(n) \n"}
{"id": 3442, "name": "Find limit of recursion", "source": "Translate Swift to C#: var n = 1\n\nfunc recurse() {\n    print(n)\n    n += 1\n    recurse()\n}\n\nrecurse()\n", "target": "using System;\nclass RecursionLimit\n{\n  static void Main(string[] args)\n  {\n    Recur(0);\n  }\n \n  private static void Recur(int i) \n  {\n    Console.WriteLine(i);\n    Recur(i + 1);\n  }\n}\n"}
{"id": 3443, "name": "Find limit of recursion", "source": "Translate Swift to C#: var n = 1\n\nfunc recurse() {\n    print(n)\n    n += 1\n    recurse()\n}\n\nrecurse()\n", "target": "using System;\nclass RecursionLimit\n{\n  static void Main(string[] args)\n  {\n    Recur(0);\n  }\n \n  private static void Recur(int i) \n  {\n    Console.WriteLine(i);\n    Recur(i + 1);\n  }\n}\n"}
{"id": 3446, "name": "Find limit of recursion", "source": "Translate Swift to Java: var n = 1\n\nfunc recurse() {\n    print(n)\n    n += 1\n    recurse()\n}\n\nrecurse()\n", "target": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}\n"}
{"id": 3447, "name": "Find limit of recursion", "source": "Translate Swift to Java: var n = 1\n\nfunc recurse() {\n    print(n)\n    n += 1\n    recurse()\n}\n\nrecurse()\n", "target": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}\n"}
{"id": 3448, "name": "Find limit of recursion", "source": "Translate Swift to Python: var n = 1\n\nfunc recurse() {\n    print(n)\n    n += 1\n    recurse()\n}\n\nrecurse()\n", "target": "import sys\nprint(sys.getrecursionlimit())\n"}
{"id": 3449, "name": "Find limit of recursion", "source": "Translate Swift to Python: var n = 1\n\nfunc recurse() {\n    print(n)\n    n += 1\n    recurse()\n}\n\nrecurse()\n", "target": "import sys\nprint(sys.getrecursionlimit())\n"}
{"id": 5061, "name": "Read entire file", "source": "Translate Swift to C#: import Foundation\n\nlet path = \"~/input.txt\".stringByExpandingTildeInPath\nif let string = String(contentsOfFile: path, encoding: NSUTF8StringEncoding) {\n  println(string) \n}\n", "target": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var fileContents = File.ReadAllText(\"c:\\\\autoexec.bat\");  \n        \n    }\n}\n"}
{"id": 5063, "name": "Read entire file", "source": "Translate Swift to Java: import Foundation\n\nlet path = \"~/input.txt\".stringByExpandingTildeInPath\nif let string = String(contentsOfFile: path, encoding: NSUTF8StringEncoding) {\n  println(string) \n}\n", "target": "static Byte[] contentsOf(File file)\n    {\n    return file.contents;\n    }\n"}
{"id": 5064, "name": "Read entire file", "source": "Translate Swift to Python: import Foundation\n\nlet path = \"~/input.txt\".stringByExpandingTildeInPath\nif let string = String(contentsOfFile: path, encoding: NSUTF8StringEncoding) {\n  println(string) \n}\n", "target": "open(filename).read()\n"}
{"id": 6185, "name": "Man or boy test", "source": "Translate Swift to C#: func A(_ k: Int,                          \n       _ x1: @escaping () -> Int,         \n       _ x2: @escaping () -> Int,         \n       _ x3: @escaping () -> Int,         \n       _ x4: @escaping () -> Int,         \n       _ x5: @escaping () -> Int) -> Int {\n    var k1 = k                            \n                                          \n    func B() -> Int {                     \n        k1 -= 1                           \n        return A(k1, B, x1, x2, x3, x4)   \n    }                                     \n                                          \n    if k1 <= 0 {                          \n        return x4() + x5()                \n    } else {                              \n        return B()                        \n    }                                     \n}                                         \n                                          \nprint(A(10, {1}, {-1}, {-1}, {1}, {0}))\n", "target": "using System;\n \ndelegate T Func<T>();\n \nclass ManOrBoy\n{\n    static void Main()\n    {\n        Console.WriteLine(A(10, C(1), C(-1), C(-1), C(1), C(0)));\n    }\n \n    static Func<int> C(int i)\n    {\n        return delegate { return i; };\n    }\n \n    static int A(int k, Func<int> x1, Func<int> x2, Func<int> x3, Func<int> x4, Func<int> x5)\n    {\n        Func<int> b = null;\n        b = delegate { k--; return A(k, b, x1, x2, x3, x4); };\n        return k <= 0 ? x4() + x5() : b();\n    }\n}\n"}
{"id": 6187, "name": "Man or boy test", "source": "Translate Swift to Java: func A(_ k: Int,                          \n       _ x1: @escaping () -> Int,         \n       _ x2: @escaping () -> Int,         \n       _ x3: @escaping () -> Int,         \n       _ x4: @escaping () -> Int,         \n       _ x5: @escaping () -> Int) -> Int {\n    var k1 = k                            \n                                          \n    func B() -> Int {                     \n        k1 -= 1                           \n        return A(k1, B, x1, x2, x3, x4)   \n    }                                     \n                                          \n    if k1 <= 0 {                          \n        return x4() + x5()                \n    } else {                              \n        return B()                        \n    }                                     \n}                                         \n                                          \nprint(A(10, {1}, {-1}, {-1}, {1}, {0}))\n", "target": "import java.util.function.DoubleSupplier;\n\npublic class ManOrBoy {\n    \n    static double A(int k, DoubleSupplier x1, DoubleSupplier x2,\n                 DoubleSupplier x3, DoubleSupplier x4, DoubleSupplier x5) {\n        \n        DoubleSupplier B = new DoubleSupplier() {\n            int m = k;\n            public double getAsDouble() {\n                return A(--m, this, x1, x2, x3, x4);\n            }\n        };\n                \n        return k <= 0 ? x4.getAsDouble() + x5.getAsDouble() : B.getAsDouble();\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(A(10, () -> 1.0, () -> -1.0, () -> -1.0, () -> 1.0, () -> 0.0));\n    }\n}\n"}
{"id": 6188, "name": "Man or boy test", "source": "Translate Swift to Python: func A(_ k: Int,                          \n       _ x1: @escaping () -> Int,         \n       _ x2: @escaping () -> Int,         \n       _ x3: @escaping () -> Int,         \n       _ x4: @escaping () -> Int,         \n       _ x5: @escaping () -> Int) -> Int {\n    var k1 = k                            \n                                          \n    func B() -> Int {                     \n        k1 -= 1                           \n        return A(k1, B, x1, x2, x3, x4)   \n    }                                     \n                                          \n    if k1 <= 0 {                          \n        return x4() + x5()                \n    } else {                              \n        return B()                        \n    }                                     \n}                                         \n                                          \nprint(A(10, {1}, {-1}, {-1}, {1}, {0}))\n", "target": "\nimport sys\nsys.setrecursionlimit(1025)\n\ndef a(in_k, x1, x2, x3, x4, x5):\n    k = [in_k]\n    def b():\n        k[0] -= 1\n        return a(k[0], b, x1, x2, x3, x4)\n    return x4() + x5() if k[0] <= 0 else b()\n\nx = lambda i: lambda: i\nprint(a(10, x(1), x(-1), x(-1), x(1), x(0)))\n"}
{"id": 6423, "name": "Assertions", "source": "Translate Swift to C#: var a = 5\n\nassert(a == 42) \nassert(a == 42, \"Error message\") \n       \n       \n", "target": "using System.Diagnostics; \n\nstatic class Program\n{\n    static void Main()\n    {\n        int a = 0;\n\n        Console.WriteLine(\"Before\");\n\n        \n        Trace.Assert(a == 42, \"Trace assertion failed\");\n\n        Console.WriteLine(\"After Trace.Assert\");\n\n        \n        Debug.Assert(a == 42, \"Debug assertion failed\");\n\n        Console.WriteLine(\"After Debug.Assert\");\n    }\n}\n"}
{"id": 6425, "name": "Assertions", "source": "Translate Swift to Java: var a = 5\n\nassert(a == 42) \nassert(a == 42, \"Error message\") \n       \n       \n", "target": "public class Assertions {\n\n    public static void main(String[] args) {\n        int a = 13;\n\n        \n\n        assert a == 42;\n        \n\n        assert a == 42 : \"Error message\";\n        \n        \n        \n    }\n}\n"}
{"id": 6426, "name": "Assertions", "source": "Translate Swift to Python: var a = 5\n\nassert(a == 42) \nassert(a == 42, \"Error message\") \n       \n       \n", "target": "a = 5\n\nassert a == 42 \nassert a == 42, \"Error message\" \n       \n       \n"}
{"id": 7054, "name": "Tree traversal", "source": "Translate Swift to C#: class TreeNode<T> {\n    let value: T\n    let left: TreeNode?\n    let right: TreeNode?\n    \n    init(value: T, left: TreeNode? = nil, right: TreeNode? = nil) {\n        self.value = value\n        self.left = left\n        self.right = right\n    }\n\n    func preOrder(function: (T) -> Void) {\n        function(value)\n        if left != nil {\n            left!.preOrder(function: function)\n        }\n        if right != nil {\n            right!.preOrder(function: function)\n        }\n    }\n    \n    func inOrder(function: (T) -> Void) {\n        if left != nil {\n            left!.inOrder(function: function)\n        }\n        function(value)\n        if right != nil {\n            right!.inOrder(function: function)\n        }\n    }\n    \n    func postOrder(function: (T) -> Void) {\n        if left != nil {\n            left!.postOrder(function: function)\n        }\n        if right != nil {\n            right!.postOrder(function: function)\n        }\n        function(value)\n    }\n    \n    func levelOrder(function: (T) -> Void) {\n        var queue: [TreeNode] = []\n        queue.append(self)\n        while queue.count > 0 {\n            let node = queue.removeFirst()\n            function(node.value)\n            if node.left != nil {\n                queue.append(node.left!)\n            }\n            if node.right != nil {\n                queue.append(node.right!)\n            }\n        }\n    }\n}\n\ntypealias Node = TreeNode<Int>\n\nlet n = Node(value: 1,\n             left: Node(value: 2,\n                        left: Node(value: 4,\n                                   left: Node(value: 7)),\n                        right: Node(value: 5)),\n             right: Node(value: 3,\n                         left: Node(value: 6,\n                                    left: Node(value: 8),\n                                    right: Node(value: 9))))\n\nlet fn = { print($0, terminator: \" \") }\n\nprint(\"pre-order:   \", terminator: \"\")\nn.preOrder(function: fn)\nprint()\n\nprint(\"in-order:    \", terminator: \"\")\nn.inOrder(function: fn)\nprint()\n\nprint(\"post-order:  \", terminator: \"\")\nn.postOrder(function: fn)\nprint()\n\nprint(\"level-order: \", terminator: \"\")\nn.levelOrder(function: fn)\nprint()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Node\n{\n    int Value;\n    Node Left;\n    Node Right;\n\n    Node(int value = default(int), Node left = default(Node), Node right = default(Node))\n    {\n        Value = value;\n        Left = left;\n        Right = right;\n    }\n\n    IEnumerable<int> Preorder()\n    {\n        yield return Value;\n        if (Left != null)\n            foreach (var value in Left.Preorder())\n                yield return value;\n        if (Right != null)\n            foreach (var value in Right.Preorder())\n                yield return value;\n    }\n\n    IEnumerable<int> Inorder()\n    {\n        if (Left != null)\n            foreach (var value in Left.Inorder())\n                yield return value;\n        yield return Value;\n        if (Right != null)\n            foreach (var value in Right.Inorder())\n                yield return value;\n    }\n\n    IEnumerable<int> Postorder()\n    {\n        if (Left != null)\n            foreach (var value in Left.Postorder())\n                yield return value;\n        if (Right != null)\n            foreach (var value in Right.Postorder())\n                yield return value;\n        yield return Value;\n    }\n\n    IEnumerable<int> LevelOrder()\n    {\n        var queue = new Queue<Node>();\n        queue.Enqueue(this);\n        while (queue.Any())\n        {\n            var node = queue.Dequeue();\n            yield return node.Value;\n            if (node.Left != null)\n                queue.Enqueue(node.Left);\n            if (node.Right != null)\n                queue.Enqueue(node.Right);\n        }\n    }\n\n    static void Main()\n    {\n        var tree = new Node(1, new Node(2, new Node(4, new Node(7)), new Node(5)), new Node(3, new Node(6, new Node(8), new Node(9))));\n        foreach (var traversal in new Func<IEnumerable<int>>[] { tree.Preorder, tree.Inorder, tree.Postorder, tree.LevelOrder })\n            Console.WriteLine(\"{0}:\\t{1}\", traversal.Method.Name, string.Join(\" \", traversal()));\n    }\n}\n"}
{"id": 7056, "name": "Tree traversal", "source": "Translate Swift to Java: class TreeNode<T> {\n    let value: T\n    let left: TreeNode?\n    let right: TreeNode?\n    \n    init(value: T, left: TreeNode? = nil, right: TreeNode? = nil) {\n        self.value = value\n        self.left = left\n        self.right = right\n    }\n\n    func preOrder(function: (T) -> Void) {\n        function(value)\n        if left != nil {\n            left!.preOrder(function: function)\n        }\n        if right != nil {\n            right!.preOrder(function: function)\n        }\n    }\n    \n    func inOrder(function: (T) -> Void) {\n        if left != nil {\n            left!.inOrder(function: function)\n        }\n        function(value)\n        if right != nil {\n            right!.inOrder(function: function)\n        }\n    }\n    \n    func postOrder(function: (T) -> Void) {\n        if left != nil {\n            left!.postOrder(function: function)\n        }\n        if right != nil {\n            right!.postOrder(function: function)\n        }\n        function(value)\n    }\n    \n    func levelOrder(function: (T) -> Void) {\n        var queue: [TreeNode] = []\n        queue.append(self)\n        while queue.count > 0 {\n            let node = queue.removeFirst()\n            function(node.value)\n            if node.left != nil {\n                queue.append(node.left!)\n            }\n            if node.right != nil {\n                queue.append(node.right!)\n            }\n        }\n    }\n}\n\ntypealias Node = TreeNode<Int>\n\nlet n = Node(value: 1,\n             left: Node(value: 2,\n                        left: Node(value: 4,\n                                   left: Node(value: 7)),\n                        right: Node(value: 5)),\n             right: Node(value: 3,\n                         left: Node(value: 6,\n                                    left: Node(value: 8),\n                                    right: Node(value: 9))))\n\nlet fn = { print($0, terminator: \" \") }\n\nprint(\"pre-order:   \", terminator: \"\")\nn.preOrder(function: fn)\nprint()\n\nprint(\"in-order:    \", terminator: \"\")\nn.inOrder(function: fn)\nprint()\n\nprint(\"post-order:  \", terminator: \"\")\nn.postOrder(function: fn)\nprint()\n\nprint(\"level-order: \", terminator: \"\")\nn.levelOrder(function: fn)\nprint()\n", "target": "import java.util.*;\n\npublic class TreeTraversal {\n\n        static class Node<T> {\n\t\tT value;\n\t\tNode<T> left;\n\t\tNode<T> right;\n\n\t\tNode(T value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tvoid visit() {\n\t\t\tSystem.out.print(this.value + \" \");\n\t\t}\n\t}\n\n\tstatic enum ORDER {\n\t\tPREORDER, INORDER, POSTORDER, LEVEL\n\t}\n        \n        static <T> void traverse(Node<T> node, ORDER order) {\n\t\tif (node == null) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (order) {\n\t\tcase PREORDER:\n\t\t\tnode.visit();\n\t\t\ttraverse(node.left, order);\n\t\t\ttraverse(node.right, order);\n\t\t\tbreak;\n\t\tcase INORDER:\n\t\t\ttraverse(node.left, order);\n\t\t\tnode.visit();\n\t\t\ttraverse(node.right, order);\n\t\t\tbreak;\n\t\tcase POSTORDER:\n\t\t\ttraverse(node.left, order);\n\t\t\ttraverse(node.right, order);\n\t\t\tnode.visit();\n\t\t\tbreak;\n\t\tcase LEVEL:\n\t\t\tQueue<Node<T>> queue = new LinkedList<>();\n\t\t\tqueue.add(node);\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tNode<T> next = queue.remove();\n\t\t\t\tnext.visit();\n\t\t\t\tif(next.left!=null)\n\t\t\t\t\tqueue.add(next.left);\n\t\t\t\tif(next.right!=null)\n\t\t\t\t\tqueue.add(next.right);\n\t\t\t}\n\t\t}\n\t}\t\n\n\tpublic static void main(String[] args) {\n\n\t\tNode<Integer> one = new Node<Integer>(1);\n\t\tNode<Integer> two = new Node<Integer>(2);\n\t\tNode<Integer> three = new Node<Integer>(3);\n\t\tNode<Integer> four = new Node<Integer>(4);\n\t\tNode<Integer> five = new Node<Integer>(5);\n\t\tNode<Integer> six = new Node<Integer>(6);\n\t\tNode<Integer> seven = new Node<Integer>(7);\n\t\tNode<Integer> eight = new Node<Integer>(8);\n\t\tNode<Integer> nine = new Node<Integer>(9);\n\t\t\n\t\tone.left = two;\n\t\tone.right = three;\n\t\ttwo.left = four;\n\t\ttwo.right = five;\n\t\tthree.left = six;\n\t\tfour.left = seven;\n\t\tsix.left = eight;\n\t\tsix.right = nine;\n\n\t\ttraverse(one, ORDER.PREORDER);\n\t\tSystem.out.println(); \n\t\ttraverse(one, ORDER.INORDER);\n\t\tSystem.out.println();\n\t\ttraverse(one, ORDER.POSTORDER);\n\t\tSystem.out.println();\n\t\ttraverse(one, ORDER.LEVEL);\n\t\t\n\t}\n}\n"}
{"id": 7057, "name": "Tree traversal", "source": "Translate Swift to Python: class TreeNode<T> {\n    let value: T\n    let left: TreeNode?\n    let right: TreeNode?\n    \n    init(value: T, left: TreeNode? = nil, right: TreeNode? = nil) {\n        self.value = value\n        self.left = left\n        self.right = right\n    }\n\n    func preOrder(function: (T) -> Void) {\n        function(value)\n        if left != nil {\n            left!.preOrder(function: function)\n        }\n        if right != nil {\n            right!.preOrder(function: function)\n        }\n    }\n    \n    func inOrder(function: (T) -> Void) {\n        if left != nil {\n            left!.inOrder(function: function)\n        }\n        function(value)\n        if right != nil {\n            right!.inOrder(function: function)\n        }\n    }\n    \n    func postOrder(function: (T) -> Void) {\n        if left != nil {\n            left!.postOrder(function: function)\n        }\n        if right != nil {\n            right!.postOrder(function: function)\n        }\n        function(value)\n    }\n    \n    func levelOrder(function: (T) -> Void) {\n        var queue: [TreeNode] = []\n        queue.append(self)\n        while queue.count > 0 {\n            let node = queue.removeFirst()\n            function(node.value)\n            if node.left != nil {\n                queue.append(node.left!)\n            }\n            if node.right != nil {\n                queue.append(node.right!)\n            }\n        }\n    }\n}\n\ntypealias Node = TreeNode<Int>\n\nlet n = Node(value: 1,\n             left: Node(value: 2,\n                        left: Node(value: 4,\n                                   left: Node(value: 7)),\n                        right: Node(value: 5)),\n             right: Node(value: 3,\n                         left: Node(value: 6,\n                                    left: Node(value: 8),\n                                    right: Node(value: 9))))\n\nlet fn = { print($0, terminator: \" \") }\n\nprint(\"pre-order:   \", terminator: \"\")\nn.preOrder(function: fn)\nprint()\n\nprint(\"in-order:    \", terminator: \"\")\nn.inOrder(function: fn)\nprint()\n\nprint(\"post-order:  \", terminator: \"\")\nn.postOrder(function: fn)\nprint()\n\nprint(\"level-order: \", terminator: \"\")\nn.levelOrder(function: fn)\nprint()\n", "target": "from collections import namedtuple\n \nNode = namedtuple('Node', 'data, left, right')\ntree = Node(1,\n            Node(2,\n                 Node(4,\n                      Node(7, None, None),\n                      None),\n                 Node(5, None, None)),\n            Node(3,\n                 Node(6,\n                      Node(8, None, None),\n                      Node(9, None, None)),\n                 None))\n \ndef printwithspace(i):\n    print(i, end=' ')\n\ndef dfs(order, node, visitor):\n    if node is not None:\n        for action in order:\n            if action == 'N':\n                visitor(node.data)\n            elif action == 'L':\n                dfs(order, node.left, visitor)\n            elif action == 'R':\n                dfs(order, node.right, visitor)\n                \ndef preorder(node, visitor = printwithspace):\n    dfs('NLR', node, visitor)\n \ndef inorder(node, visitor = printwithspace):\n    dfs('LNR', node, visitor)\n \ndef postorder(node, visitor = printwithspace):\n    dfs('LRN', node, visitor)\n \ndef ls(node, more, visitor, order='TB'):\n    \"Level-based Top-to-Bottom or Bottom-to-Top tree search\"\n    if node:\n        if more is None:\n            more = []\n        more += [node.left, node.right]\n    for action in order:\n        if action == 'B' and more:\n            ls(more[0], more[1:], visitor, order)\n        elif action == 'T' and node:\n            visitor(node.data)\n\ndef levelorder(node, more=None, visitor = printwithspace):\n    ls(node, more, visitor, 'TB') \n \n\ndef reverse_preorder(node, visitor = printwithspace):\n    dfs('RLN', node, visitor)\n    \ndef bottom_up_order(node, more=None, visitor = printwithspace, order='BT'):\n    ls(node, more, visitor, 'BT')\n\n\nif __name__ == '__main__':\n    w = 10\n    for traversal in [preorder, inorder, postorder, levelorder, \n                      reverse_preorder, bottom_up_order]:\n        if traversal == reverse_preorder:\n            w = 20\n            print('\\nThe generalisation of function dfs allows:')\n        if traversal == bottom_up_order:\n            print('The generalisation of function ls allows:')\n        print(f\"{traversal.__name__:>{w}}:\", end=' ')\n        traversal(tree)\n        print()\n"}
{"id": 7272, "name": "List comprehensions", "source": "Translate Swift to C#: typealias F1 = (Int) -> [(Int, Int, Int)]\ntypealias F2 = (Int) -> Bool\n\nfunc pythagoreanTriples(n: Int) -> [(Int, Int, Int)] {\n  (1...n).flatMap({x in\n    (x...n).flatMap({y in\n      (y...n).filter({z in\n        x * x + y * y == z * z\n      } as F2).map({ (x, y, $0) })\n    } as F1)\n  } as F1)\n}\n\nprint(pythagoreanTriples(n: 20))\n", "target": "using System.Linq;\n\nstatic class Program\n{\n  static void Main()\n  {\n    var ts =\n      from a in Enumerable.Range(1, 20)\n      from b in Enumerable.Range(a, 21 - a)\n      from c in Enumerable.Range(b, 21 - b)\n      where a * a + b * b == c * c\n      select new { a, b, c };\n\n      foreach (var t in ts)\n        System.Console.WriteLine(\"{0}, {1}, {2}\", t.a, t.b, t.c);\n  }\n}\n"}
{"id": 7274, "name": "List comprehensions", "source": "Translate Swift to Java: typealias F1 = (Int) -> [(Int, Int, Int)]\ntypealias F2 = (Int) -> Bool\n\nfunc pythagoreanTriples(n: Int) -> [(Int, Int, Int)] {\n  (1...n).flatMap({x in\n    (x...n).flatMap({y in\n      (y...n).filter({z in\n        x * x + y * y == z * z\n      } as F2).map({ (x, y, $0) })\n    } as F1)\n  } as F1)\n}\n\nprint(pythagoreanTriples(n: 20))\n", "target": "\nimport java.util.Arrays;\nimport java.util.List;\nimport static java.util.function.Function.identity;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\npublic interface PythagComp{\n    static void main(String... args){\n        System.out.println(run(20));\n    }\n\n    static List<List<Integer>> run(int n){\n        return\n            \n            \n            range(1, n).mapToObj(\n                x -> range(x, n).mapToObj(\n                    y -> range(y, n).mapToObj(\n                        z -> new Integer[]{x, y, z}\n                    )\n                )\n            )\n                .flatMap(identity())\n                .flatMap(identity())\n                \n                .filter(a -> a[0]*a[0] + a[1]*a[1] == a[2]*a[2])\n                \n                .map(Arrays::asList)\n                \n                .collect(toList())\n        ;\n    }\n}\n"}
{"id": 7275, "name": "List comprehensions", "source": "Translate Swift to Python: typealias F1 = (Int) -> [(Int, Int, Int)]\ntypealias F2 = (Int) -> Bool\n\nfunc pythagoreanTriples(n: Int) -> [(Int, Int, Int)] {\n  (1...n).flatMap({x in\n    (x...n).flatMap({y in\n      (y...n).filter({z in\n        x * x + y * y == z * z\n      } as F2).map({ (x, y, $0) })\n    } as F1)\n  } as F1)\n}\n\nprint(pythagoreanTriples(n: 20))\n", "target": "[(x,y,z) for x in xrange(1,n+1) for y in xrange(x,n+1) for z in xrange(y,n+1) if x**2 + y**2 == z**2]\n"}
{"id": 7392, "name": "Literals_Floating point", "source": "Translate Swift to C#: let double = 1.0 as Double  \nlet float = 1.0 as Float \nlet scientific = 1.0E-12\n\n\nlet sum = double + float \n\nlet div = 1.1 / 2 \nlet div1 = 1 / 2 \n", "target": "double d = 1;\nd = 1d;\nd = 1D;\nd = 1.2; \nd = 1.2d; \nd = .2;\nd = 12e-12;\nd = 12E-12;\nd = 1_234e-1_2; \nfloat f = 1;\nf = 1f;\nf = 1F;\nf = 1.2f;\nf = .2f;\nf = 12e-12f;\nf = 12E-12f;\nf = 1_234e-1_2f;\ndecimal m = 1;\nm = 1m;\nm = 1m;\nm = 1.2m;\nm = .2m;\nm = 12e-12m;\nm = 12E-12m;\nm = 1_234e-1_2m;\n"}
{"id": 7394, "name": "Literals_Floating point", "source": "Translate Swift to Java: let double = 1.0 as Double  \nlet float = 1.0 as Float \nlet scientific = 1.0E-12\n\n\nlet sum = double + float \n\nlet div = 1.1 / 2 \nlet div1 = 1 / 2 \n", "target": "1. \n1.0 \n2432311.7567374 \n1.234E-10 \n1.234e-10 \n758832d \n728832f \n1.0f \n758832D \n728832F \n1.0F \n1 / 2. \n1 / 2 \n"}
{"id": 7395, "name": "Literals_Floating point", "source": "Translate Swift to Python: let double = 1.0 as Double  \nlet float = 1.0 as Float \nlet scientific = 1.0E-12\n\n\nlet sum = double + float \n\nlet div = 1.1 / 2 \nlet div1 = 1 / 2 \n", "target": "2.3    \n.3     \n.3e4   \n.3e+34 \n.3e-34 \n2.e34  \n"}
{"id": 7743, "name": "Abundant odd numbers", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@inlinable\npublic func isAbundant<T: BinaryInteger>(n: T) -> (Bool, [T]) {\n  let divs = n.factors().dropLast()\n\n  return (divs.reduce(0, +) > n, Array(divs))\n}\n\nlet oddAbundant = (0...).lazy.filter({ $0 & 1 == 1 }).map({ ($0, isAbundant(n: $0)) }).filter({ $1.0 })\n\nfor (n, (_, factors)) in oddAbundant.prefix(25) {\n  print(\"n: \\(n); sigma: \\(factors.reduce(0, +))\")\n}\n\nlet (bigA, (_, bigFactors)) =\n  (1_000_000_000...)\n    .lazy\n    .filter({ $0 & 1 == 1 })\n    .map({ ($0, isAbundant(n: $0)) })\n    .first(where: { $1.0 })!\n\nprint(\"first odd abundant number over 1 billion: \\(bigA), sigma: \\(bigFactors.reduce(0, +))\")\n", "target": "using static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class AbundantOddNumbers\n{\n    public static void Main() {\n        WriteLine(\"First 25 abundant odd numbers:\");\n        foreach (var x in AbundantNumbers().Take(25)) WriteLine(x.Format());\n        WriteLine();\n        WriteLine($\"The 1000th abundant odd number: {AbundantNumbers().ElementAt(999).Format()}\");\n        WriteLine();\n        WriteLine($\"First abundant odd number > 1b: {AbundantNumbers(1_000_000_001).First().Format()}\");\n    }\n\n    static IEnumerable<(int n, int sum)> AbundantNumbers(int start = 3) =>\n        start.UpBy(2).Select(n => (n, sum: n.DivisorSum())).Where(x => x.sum > x.n);\n\n    static int DivisorSum(this int n) => 3.UpBy(2).TakeWhile(i => i * i <= n).Where(i => n % i == 0)\n        .Select(i => (a:i, b:n/i)).Sum(p => p.a == p.b ? p.a : p.a + p.b) + 1;\n\n    static IEnumerable<int> UpBy(this int n, int step) {\n        for (int i = n; ; i+=step) yield return i;\n    }\n\n    static string Format(this (int n, int sum) pair) => $\"{pair.n:N0} with sum {pair.sum:N0}\";\n}\n"}
{"id": 7744, "name": "Abundant odd numbers", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@inlinable\npublic func isAbundant<T: BinaryInteger>(n: T) -> (Bool, [T]) {\n  let divs = n.factors().dropLast()\n\n  return (divs.reduce(0, +) > n, Array(divs))\n}\n\nlet oddAbundant = (0...).lazy.filter({ $0 & 1 == 1 }).map({ ($0, isAbundant(n: $0)) }).filter({ $1.0 })\n\nfor (n, (_, factors)) in oddAbundant.prefix(25) {\n  print(\"n: \\(n); sigma: \\(factors.reduce(0, +))\")\n}\n\nlet (bigA, (_, bigFactors)) =\n  (1_000_000_000...)\n    .lazy\n    .filter({ $0 & 1 == 1 })\n    .map({ ($0, isAbundant(n: $0)) })\n    .first(where: { $1.0 })!\n\nprint(\"first odd abundant number over 1 billion: \\(bigA), sigma: \\(bigFactors.reduce(0, +))\")\n", "target": "using static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class AbundantOddNumbers\n{\n    public static void Main() {\n        WriteLine(\"First 25 abundant odd numbers:\");\n        foreach (var x in AbundantNumbers().Take(25)) WriteLine(x.Format());\n        WriteLine();\n        WriteLine($\"The 1000th abundant odd number: {AbundantNumbers().ElementAt(999).Format()}\");\n        WriteLine();\n        WriteLine($\"First abundant odd number > 1b: {AbundantNumbers(1_000_000_001).First().Format()}\");\n    }\n\n    static IEnumerable<(int n, int sum)> AbundantNumbers(int start = 3) =>\n        start.UpBy(2).Select(n => (n, sum: n.DivisorSum())).Where(x => x.sum > x.n);\n\n    static int DivisorSum(this int n) => 3.UpBy(2).TakeWhile(i => i * i <= n).Where(i => n % i == 0)\n        .Select(i => (a:i, b:n/i)).Sum(p => p.a == p.b ? p.a : p.a + p.b) + 1;\n\n    static IEnumerable<int> UpBy(this int n, int step) {\n        for (int i = n; ; i+=step) yield return i;\n    }\n\n    static string Format(this (int n, int sum) pair) => $\"{pair.n:N0} with sum {pair.sum:N0}\";\n}\n"}
{"id": 7747, "name": "Abundant odd numbers", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@inlinable\npublic func isAbundant<T: BinaryInteger>(n: T) -> (Bool, [T]) {\n  let divs = n.factors().dropLast()\n\n  return (divs.reduce(0, +) > n, Array(divs))\n}\n\nlet oddAbundant = (0...).lazy.filter({ $0 & 1 == 1 }).map({ ($0, isAbundant(n: $0)) }).filter({ $1.0 })\n\nfor (n, (_, factors)) in oddAbundant.prefix(25) {\n  print(\"n: \\(n); sigma: \\(factors.reduce(0, +))\")\n}\n\nlet (bigA, (_, bigFactors)) =\n  (1_000_000_000...)\n    .lazy\n    .filter({ $0 & 1 == 1 })\n    .map({ ($0, isAbundant(n: $0)) })\n    .first(where: { $1.0 })!\n\nprint(\"first odd abundant number over 1 billion: \\(bigA), sigma: \\(bigFactors.reduce(0, +))\")\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class AbundantOddNumbers {\n    private static List<Integer> list = new ArrayList<>();\n    private static List<Integer> result = new ArrayList<>();\n\n    public static void main(String[] args) {\n        System.out.println(\"First 25: \");\n        abundantOdd(1,100000, 25, false);\n\n        System.out.println(\"\\n\\nThousandth: \");\n        abundantOdd(1,2500000, 1000, true);\n\n        System.out.println(\"\\n\\nFirst over 1bn:\"); \n        abundantOdd(1000000001, 2147483647, 1, false);\n    }\n    private static void abundantOdd(int start, int finish, int listSize, boolean printOne) {\n        for (int oddNum = start; oddNum < finish; oddNum += 2) {\n            list.clear();\n            for (int toDivide = 1; toDivide < oddNum; toDivide+=2) {\n                if (oddNum % toDivide == 0)\n                    list.add(toDivide);\n            }\n            if (sumList(list) > oddNum) {\n                if(!printOne)\n                    System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n                result.add(oddNum);\n            }\n            if(printOne && result.size() >= listSize)\n                System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n\n            if(result.size() >= listSize) break;\n        }\n    }\n    private static int sumList(List list) {\n        int sum = 0;\n        for (int i = 0; i < list.size(); i++) {\n            String temp = list.get(i).toString();\n            sum += Integer.parseInt(temp);\n        }\n        return sum;\n    }\n}\n"}
{"id": 7748, "name": "Abundant odd numbers", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@inlinable\npublic func isAbundant<T: BinaryInteger>(n: T) -> (Bool, [T]) {\n  let divs = n.factors().dropLast()\n\n  return (divs.reduce(0, +) > n, Array(divs))\n}\n\nlet oddAbundant = (0...).lazy.filter({ $0 & 1 == 1 }).map({ ($0, isAbundant(n: $0)) }).filter({ $1.0 })\n\nfor (n, (_, factors)) in oddAbundant.prefix(25) {\n  print(\"n: \\(n); sigma: \\(factors.reduce(0, +))\")\n}\n\nlet (bigA, (_, bigFactors)) =\n  (1_000_000_000...)\n    .lazy\n    .filter({ $0 & 1 == 1 })\n    .map({ ($0, isAbundant(n: $0)) })\n    .first(where: { $1.0 })!\n\nprint(\"first odd abundant number over 1 billion: \\(bigA), sigma: \\(bigFactors.reduce(0, +))\")\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class AbundantOddNumbers {\n    private static List<Integer> list = new ArrayList<>();\n    private static List<Integer> result = new ArrayList<>();\n\n    public static void main(String[] args) {\n        System.out.println(\"First 25: \");\n        abundantOdd(1,100000, 25, false);\n\n        System.out.println(\"\\n\\nThousandth: \");\n        abundantOdd(1,2500000, 1000, true);\n\n        System.out.println(\"\\n\\nFirst over 1bn:\"); \n        abundantOdd(1000000001, 2147483647, 1, false);\n    }\n    private static void abundantOdd(int start, int finish, int listSize, boolean printOne) {\n        for (int oddNum = start; oddNum < finish; oddNum += 2) {\n            list.clear();\n            for (int toDivide = 1; toDivide < oddNum; toDivide+=2) {\n                if (oddNum % toDivide == 0)\n                    list.add(toDivide);\n            }\n            if (sumList(list) > oddNum) {\n                if(!printOne)\n                    System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n                result.add(oddNum);\n            }\n            if(printOne && result.size() >= listSize)\n                System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n\n            if(result.size() >= listSize) break;\n        }\n    }\n    private static int sumList(List list) {\n        int sum = 0;\n        for (int i = 0; i < list.size(); i++) {\n            String temp = list.get(i).toString();\n            sum += Integer.parseInt(temp);\n        }\n        return sum;\n    }\n}\n"}
{"id": 7749, "name": "Abundant odd numbers", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@inlinable\npublic func isAbundant<T: BinaryInteger>(n: T) -> (Bool, [T]) {\n  let divs = n.factors().dropLast()\n\n  return (divs.reduce(0, +) > n, Array(divs))\n}\n\nlet oddAbundant = (0...).lazy.filter({ $0 & 1 == 1 }).map({ ($0, isAbundant(n: $0)) }).filter({ $1.0 })\n\nfor (n, (_, factors)) in oddAbundant.prefix(25) {\n  print(\"n: \\(n); sigma: \\(factors.reduce(0, +))\")\n}\n\nlet (bigA, (_, bigFactors)) =\n  (1_000_000_000...)\n    .lazy\n    .filter({ $0 & 1 == 1 })\n    .map({ ($0, isAbundant(n: $0)) })\n    .first(where: { $1.0 })!\n\nprint(\"first odd abundant number over 1 billion: \\(bigA), sigma: \\(bigFactors.reduce(0, +))\")\n", "target": "\n\n\noddNumber  = 1\naCount  = 0\ndSum  = 0\n \nfrom math import sqrt\n \ndef divisorSum(n):\n    sum = 1\n    i = int(sqrt(n)+1)\n \n    for d in range (2, i):\n        if n % d == 0:\n            sum += d\n            otherD = n // d\n            if otherD != d:\n                sum += otherD\n    return sum\n \nprint (\"The first 25 abundant odd numbers:\")\nwhile aCount  < 25:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n        print(\"{0:5} proper divisor sum: {1}\". format(oddNumber ,dSum ))\n    oddNumber  += 2\n \nwhile aCount  < 1000:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n    oddNumber  += 2\nprint (\"\\n1000th abundant odd number:\")\nprint (\"    \",(oddNumber - 2),\" proper divisor sum: \",dSum)\n \noddNumber  = 1000000001\nfound  = False\nwhile not found :\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        found  = True\n        print (\"\\nFirst abundant odd number > 1 000 000 000:\")\n        print (\"    \",oddNumber,\" proper divisor sum: \",dSum)\n    oddNumber  += 2\n"}
{"id": 7750, "name": "Abundant odd numbers", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@inlinable\npublic func isAbundant<T: BinaryInteger>(n: T) -> (Bool, [T]) {\n  let divs = n.factors().dropLast()\n\n  return (divs.reduce(0, +) > n, Array(divs))\n}\n\nlet oddAbundant = (0...).lazy.filter({ $0 & 1 == 1 }).map({ ($0, isAbundant(n: $0)) }).filter({ $1.0 })\n\nfor (n, (_, factors)) in oddAbundant.prefix(25) {\n  print(\"n: \\(n); sigma: \\(factors.reduce(0, +))\")\n}\n\nlet (bigA, (_, bigFactors)) =\n  (1_000_000_000...)\n    .lazy\n    .filter({ $0 & 1 == 1 })\n    .map({ ($0, isAbundant(n: $0)) })\n    .first(where: { $1.0 })!\n\nprint(\"first odd abundant number over 1 billion: \\(bigA), sigma: \\(bigFactors.reduce(0, +))\")\n", "target": "\n\n\noddNumber  = 1\naCount  = 0\ndSum  = 0\n \nfrom math import sqrt\n \ndef divisorSum(n):\n    sum = 1\n    i = int(sqrt(n)+1)\n \n    for d in range (2, i):\n        if n % d == 0:\n            sum += d\n            otherD = n // d\n            if otherD != d:\n                sum += otherD\n    return sum\n \nprint (\"The first 25 abundant odd numbers:\")\nwhile aCount  < 25:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n        print(\"{0:5} proper divisor sum: {1}\". format(oddNumber ,dSum ))\n    oddNumber  += 2\n \nwhile aCount  < 1000:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n    oddNumber  += 2\nprint (\"\\n1000th abundant odd number:\")\nprint (\"    \",(oddNumber - 2),\" proper divisor sum: \",dSum)\n \noddNumber  = 1000000001\nfound  = False\nwhile not found :\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        found  = True\n        print (\"\\nFirst abundant odd number > 1 000 000 000:\")\n        print (\"    \",oddNumber,\" proper divisor sum: \",dSum)\n    oddNumber  += 2\n"}
{"id": 8215, "name": "Combinations", "source": "Translate Swift to C#: func addCombo(prevCombo: [Int], var pivotList: [Int]) -> [([Int], [Int])] {\n\n  return (0..<pivotList.count)\n    .map {\n      _ -> ([Int], [Int]) in\n      (prevCombo + [pivotList.removeAtIndex(0)], pivotList)\n    }\n}\nfunc combosOfLength(n: Int, m: Int) -> [[Int]] {\n\n  return [Int](1...m)\n    .reduce([([Int](), [Int](0..<n))]) {\n      (accum, _) in\n      accum.flatMap(addCombo)\n    }.map {\n      $0.0\n    }\n}\n\nprintln(combosOfLength(5, 3))\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static IEnumerable<int[]> Combinations(int m, int n)\n    {\n            int[] result = new int[m];\n            Stack<int> stack = new Stack<int>();\n            stack.Push(0);\n\n            while (stack.Count > 0)\n           {\n                int index = stack.Count - 1;\n                int value = stack.Pop();\n\n                while (value < n) \n               {\n                    result[index++] = ++value;\n                    stack.Push(value);\n\n                    if (index == m) \n                    {\n                        yield return result;\n                        break;\n                    }\n                }\n            }\n    }\n\n    static void Main()\n    {\n        foreach (int[] c in Combinations(3, 5))\n        {\n            Console.WriteLine(string.Join(\",\", c));\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 8217, "name": "Combinations", "source": "Translate Swift to Java: func addCombo(prevCombo: [Int], var pivotList: [Int]) -> [([Int], [Int])] {\n\n  return (0..<pivotList.count)\n    .map {\n      _ -> ([Int], [Int]) in\n      (prevCombo + [pivotList.removeAtIndex(0)], pivotList)\n    }\n}\nfunc combosOfLength(n: Int, m: Int) -> [[Int]] {\n\n  return [Int](1...m)\n    .reduce([([Int](), [Int](0..<n))]) {\n      (accum, _) in\n      accum.flatMap(addCombo)\n    }.map {\n      $0.0\n    }\n}\n\nprintln(combosOfLength(5, 3))\n", "target": "import java.util.Collections;\nimport java.util.LinkedList;\n\npublic class Comb{\n\n        public static void main(String[] args){\n                System.out.println(comb(3,5));\n        }\n\n        public static String bitprint(int u){\n                String s= \"\";\n                for(int n= 0;u > 0;++n, u>>= 1)\n                        if((u & 1) > 0) s+= n + \" \";\n                return s;\n        }\n\n        public static int bitcount(int u){\n                int n;\n                for(n= 0;u > 0;++n, u&= (u - 1));\n                return n;\n        }\n\n        public static LinkedList<String> comb(int c, int n){\n                LinkedList<String> s= new LinkedList<String>();\n                for(int u= 0;u < 1 << n;u++)\n                        if(bitcount(u) == c) s.push(bitprint(u));\n                Collections.sort(s);\n                return s;\n        }\n}\n"}
{"id": 8218, "name": "Combinations", "source": "Translate Swift to Python: func addCombo(prevCombo: [Int], var pivotList: [Int]) -> [([Int], [Int])] {\n\n  return (0..<pivotList.count)\n    .map {\n      _ -> ([Int], [Int]) in\n      (prevCombo + [pivotList.removeAtIndex(0)], pivotList)\n    }\n}\nfunc combosOfLength(n: Int, m: Int) -> [[Int]] {\n\n  return [Int](1...m)\n    .reduce([([Int](), [Int](0..<n))]) {\n      (accum, _) in\n      accum.flatMap(addCombo)\n    }.map {\n      $0.0\n    }\n}\n\nprintln(combosOfLength(5, 3))\n", "target": ">>> from itertools import combinations\n>>> list(combinations(range(5),3))\n[(0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]\n"}
{"id": 8838, "name": "Department numbers", "source": "Translate Swift to C#: let res = [2, 4, 6].map({x in\n  return (1...7)\n      .filter({ $0 != x })\n      .map({y -> (Int, Int, Int)? in\n        let z = 12 - (x + y)\n\n        guard y != z && 1 <= z && z <= 7 else {\n          return nil\n        }\n\n        return (x, y, z)\n      }).compactMap({ $0 })\n}).flatMap({ $0 })\n\nfor result in res {\n  print(result)\n}\n", "target": "using System;\npublic class Program\n{\n    public static void Main() {\n        for (int p = 2; p <= 7; p+=2) {\n            for (int s = 1; s <= 7; s++) {\n                int f = 12 - p - s;\n                if (s >= f) break;\n                if (f > 7) continue;\n                if (s == p || f == p) continue; \n                Console.WriteLine($\"Police:{p}, Sanitation:{s}, Fire:{f}\");\n                Console.WriteLine($\"Police:{p}, Sanitation:{f}, Fire:{s}\");\n            }\n        }\n    }\n}\n"}
{"id": 8839, "name": "Department numbers", "source": "Translate Swift to C#: let res = [2, 4, 6].map({x in\n  return (1...7)\n      .filter({ $0 != x })\n      .map({y -> (Int, Int, Int)? in\n        let z = 12 - (x + y)\n\n        guard y != z && 1 <= z && z <= 7 else {\n          return nil\n        }\n\n        return (x, y, z)\n      }).compactMap({ $0 })\n}).flatMap({ $0 })\n\nfor result in res {\n  print(result)\n}\n", "target": "using System;\npublic class Program\n{\n    public static void Main() {\n        for (int p = 2; p <= 7; p+=2) {\n            for (int s = 1; s <= 7; s++) {\n                int f = 12 - p - s;\n                if (s >= f) break;\n                if (f > 7) continue;\n                if (s == p || f == p) continue; \n                Console.WriteLine($\"Police:{p}, Sanitation:{s}, Fire:{f}\");\n                Console.WriteLine($\"Police:{p}, Sanitation:{f}, Fire:{s}\");\n            }\n        }\n    }\n}\n"}
{"id": 8842, "name": "Department numbers", "source": "Translate Swift to Java: let res = [2, 4, 6].map({x in\n  return (1...7)\n      .filter({ $0 != x })\n      .map({y -> (Int, Int, Int)? in\n        let z = 12 - (x + y)\n\n        guard y != z && 1 <= z && z <= 7 else {\n          return nil\n        }\n\n        return (x, y, z)\n      }).compactMap({ $0 })\n}).flatMap({ $0 })\n\nfor result in res {\n  print(result)\n}\n", "target": "public class DepartmentNumbers {\n    public static void main(String[] args) {\n        System.out.println(\"Police  Sanitation  Fire\");\n        System.out.println(\"------  ----------  ----\");\n        int count = 0;\n        for (int i = 2; i <= 6; i += 2) {\n            for (int j = 1; j <= 7; ++j) {\n                if (j == i) continue;\n                for (int k = 1; k <= 7; ++k) {\n                    if (k == i || k == j) continue;\n                    if (i + j + k != 12) continue;\n                    System.out.printf(\"  %d         %d         %d\\n\", i, j, k);\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"\\n%d valid combinations\", count);\n    }\n}\n"}
{"id": 8843, "name": "Department numbers", "source": "Translate Swift to Java: let res = [2, 4, 6].map({x in\n  return (1...7)\n      .filter({ $0 != x })\n      .map({y -> (Int, Int, Int)? in\n        let z = 12 - (x + y)\n\n        guard y != z && 1 <= z && z <= 7 else {\n          return nil\n        }\n\n        return (x, y, z)\n      }).compactMap({ $0 })\n}).flatMap({ $0 })\n\nfor result in res {\n  print(result)\n}\n", "target": "public class DepartmentNumbers {\n    public static void main(String[] args) {\n        System.out.println(\"Police  Sanitation  Fire\");\n        System.out.println(\"------  ----------  ----\");\n        int count = 0;\n        for (int i = 2; i <= 6; i += 2) {\n            for (int j = 1; j <= 7; ++j) {\n                if (j == i) continue;\n                for (int k = 1; k <= 7; ++k) {\n                    if (k == i || k == j) continue;\n                    if (i + j + k != 12) continue;\n                    System.out.printf(\"  %d         %d         %d\\n\", i, j, k);\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"\\n%d valid combinations\", count);\n    }\n}\n"}
{"id": 8844, "name": "Department numbers", "source": "Translate Swift to Python: let res = [2, 4, 6].map({x in\n  return (1...7)\n      .filter({ $0 != x })\n      .map({y -> (Int, Int, Int)? in\n        let z = 12 - (x + y)\n\n        guard y != z && 1 <= z && z <= 7 else {\n          return nil\n        }\n\n        return (x, y, z)\n      }).compactMap({ $0 })\n}).flatMap({ $0 })\n\nfor result in res {\n  print(result)\n}\n", "target": "from itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n"}
{"id": 8845, "name": "Department numbers", "source": "Translate Swift to Python: let res = [2, 4, 6].map({x in\n  return (1...7)\n      .filter({ $0 != x })\n      .map({y -> (Int, Int, Int)? in\n        let z = 12 - (x + y)\n\n        guard y != z && 1 <= z && z <= 7 else {\n          return nil\n        }\n\n        return (x, y, z)\n      }).compactMap({ $0 })\n}).flatMap({ $0 })\n\nfor result in res {\n  print(result)\n}\n", "target": "from itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n"}
{"id": 9250, "name": "Fusc sequence", "source": "Translate Swift to C#: struct FuscSeq: Sequence, IteratorProtocol {\n  private var arr = [0, 1]\n  private var i = 0\n\n  mutating func next() -> Int? {\n    defer {\n      i += 1\n    }\n\n    guard i > 1 else {\n      return arr[i]\n    }\n\n    switch i & 1 {\n    case 0:\n      arr.append(arr[i / 2])\n    case 1:\n      arr.append(arr[(i - 1) / 2] + arr[(i + 1) / 2])\n    case _:\n      fatalError()\n    }\n\n    return arr.last!\n  }\n}\n\nlet first = FuscSeq().prefix(61)\n\nprint(\"First 61: \\(Array(first))\")\n\nvar max = -1\n\nfor (i, n) in FuscSeq().prefix(20_000_000).enumerated() {\n  let f = String(n).count\n\n  if f > max {\n    max = f\n\n    print(\"New max: \\(i): \\(n)\")\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nstatic class program\n{\n    static int n = 61;\n    static List<int> l = new List<int>() { 0, 1 };\n\n    static int fusc(int n)\n    {\n        if (n < l.Count) return l[n];\n        int f = (n & 1) == 0 ? l[n >> 1] : l[(n - 1) >> 1] + l[(n + 1) >> 1];\n        l.Add(f); return f;\n    }\n\n    static void Main(string[] args)\n    {\n        bool lst = true; int w = -1, c = 0, t;\n        string fs = \"{0,11:n0}  {1,-9:n0}\", res = \"\";\n        Console.WriteLine(\"First {0} numbers in the fusc sequence:\", n);\n        for (int i = 0; i < int.MaxValue; i++)\n        {\n            int f = fusc(i); if (lst)\n            {\n                if (i < 61) Console.Write(\"{0} \", f);\n                else\n                {\n                    lst = false;\n                    Console.WriteLine();\n                    Console.WriteLine(\"Points in the sequence where an item has more digits than any previous items:\");\n                    Console.WriteLine(fs, \"Index\\\\\", \"/Value\"); Console.WriteLine(res); res = \"\";\n                }\n            }\n            if ((t = f.ToString().Length) > w)\n            {\n                w = t; res += (res == \"\" ? \"\" : \"\\n\") + string.Format(fs, i, f);\n                if (!lst) { Console.WriteLine(res); res = \"\"; } if (++c > 5) break;\n            }\n        }\n        l.Clear();\n    }\n}\n"}
{"id": 9251, "name": "Fusc sequence", "source": "Translate Swift to C#: struct FuscSeq: Sequence, IteratorProtocol {\n  private var arr = [0, 1]\n  private var i = 0\n\n  mutating func next() -> Int? {\n    defer {\n      i += 1\n    }\n\n    guard i > 1 else {\n      return arr[i]\n    }\n\n    switch i & 1 {\n    case 0:\n      arr.append(arr[i / 2])\n    case 1:\n      arr.append(arr[(i - 1) / 2] + arr[(i + 1) / 2])\n    case _:\n      fatalError()\n    }\n\n    return arr.last!\n  }\n}\n\nlet first = FuscSeq().prefix(61)\n\nprint(\"First 61: \\(Array(first))\")\n\nvar max = -1\n\nfor (i, n) in FuscSeq().prefix(20_000_000).enumerated() {\n  let f = String(n).count\n\n  if f > max {\n    max = f\n\n    print(\"New max: \\(i): \\(n)\")\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nstatic class program\n{\n    static int n = 61;\n    static List<int> l = new List<int>() { 0, 1 };\n\n    static int fusc(int n)\n    {\n        if (n < l.Count) return l[n];\n        int f = (n & 1) == 0 ? l[n >> 1] : l[(n - 1) >> 1] + l[(n + 1) >> 1];\n        l.Add(f); return f;\n    }\n\n    static void Main(string[] args)\n    {\n        bool lst = true; int w = -1, c = 0, t;\n        string fs = \"{0,11:n0}  {1,-9:n0}\", res = \"\";\n        Console.WriteLine(\"First {0} numbers in the fusc sequence:\", n);\n        for (int i = 0; i < int.MaxValue; i++)\n        {\n            int f = fusc(i); if (lst)\n            {\n                if (i < 61) Console.Write(\"{0} \", f);\n                else\n                {\n                    lst = false;\n                    Console.WriteLine();\n                    Console.WriteLine(\"Points in the sequence where an item has more digits than any previous items:\");\n                    Console.WriteLine(fs, \"Index\\\\\", \"/Value\"); Console.WriteLine(res); res = \"\";\n                }\n            }\n            if ((t = f.ToString().Length) > w)\n            {\n                w = t; res += (res == \"\" ? \"\" : \"\\n\") + string.Format(fs, i, f);\n                if (!lst) { Console.WriteLine(res); res = \"\"; } if (++c > 5) break;\n            }\n        }\n        l.Clear();\n    }\n}\n"}
{"id": 9254, "name": "Fusc sequence", "source": "Translate Swift to Java: struct FuscSeq: Sequence, IteratorProtocol {\n  private var arr = [0, 1]\n  private var i = 0\n\n  mutating func next() -> Int? {\n    defer {\n      i += 1\n    }\n\n    guard i > 1 else {\n      return arr[i]\n    }\n\n    switch i & 1 {\n    case 0:\n      arr.append(arr[i / 2])\n    case 1:\n      arr.append(arr[(i - 1) / 2] + arr[(i + 1) / 2])\n    case _:\n      fatalError()\n    }\n\n    return arr.last!\n  }\n}\n\nlet first = FuscSeq().prefix(61)\n\nprint(\"First 61: \\(Array(first))\")\n\nvar max = -1\n\nfor (i, n) in FuscSeq().prefix(20_000_000).enumerated() {\n  let f = String(n).count\n\n  if f > max {\n    max = f\n\n    print(\"New max: \\(i): \\(n)\")\n  }\n}\n", "target": "public class FuscSequence {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the first 61 fusc numbers (starting at zero) in a horizontal format\");\n        for ( int n = 0 ; n < 61 ; n++ ) {\n            System.out.printf(\"%,d \", fusc[n]);\n        }\n        \n        System.out.printf(\"%n%nShow the fusc number (and its index) whose length is greater than any previous fusc number length.%n\");\n        int start = 0;\n        for (int i = 0 ; i <= 5 ; i++ ) {\n            int val = i != 0 ? (int) Math.pow(10, i) : -1;\n            for ( int j = start ; j < FUSC_MAX ; j++ ) {\n                if ( fusc[j] > val ) {\n                    System.out.printf(\"fusc[%,d] =\u00a0%,d%n\", j, fusc[j] );\n                    start = j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    private static final int FUSC_MAX = 30000000;\n    private static int[] fusc = new int[FUSC_MAX];\n\n    static {\n        fusc[0] = 0;\n        fusc[1] = 1;\n        for ( int n = 2 ; n < FUSC_MAX ; n++ ) {\n            fusc[n] = (n % 2 == 0 ? fusc[n/2] : fusc[(n-1)/2] + fusc[(n+1)/2]);\n        }\n    }\n}\n"}
{"id": 9255, "name": "Fusc sequence", "source": "Translate Swift to Java: struct FuscSeq: Sequence, IteratorProtocol {\n  private var arr = [0, 1]\n  private var i = 0\n\n  mutating func next() -> Int? {\n    defer {\n      i += 1\n    }\n\n    guard i > 1 else {\n      return arr[i]\n    }\n\n    switch i & 1 {\n    case 0:\n      arr.append(arr[i / 2])\n    case 1:\n      arr.append(arr[(i - 1) / 2] + arr[(i + 1) / 2])\n    case _:\n      fatalError()\n    }\n\n    return arr.last!\n  }\n}\n\nlet first = FuscSeq().prefix(61)\n\nprint(\"First 61: \\(Array(first))\")\n\nvar max = -1\n\nfor (i, n) in FuscSeq().prefix(20_000_000).enumerated() {\n  let f = String(n).count\n\n  if f > max {\n    max = f\n\n    print(\"New max: \\(i): \\(n)\")\n  }\n}\n", "target": "public class FuscSequence {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the first 61 fusc numbers (starting at zero) in a horizontal format\");\n        for ( int n = 0 ; n < 61 ; n++ ) {\n            System.out.printf(\"%,d \", fusc[n]);\n        }\n        \n        System.out.printf(\"%n%nShow the fusc number (and its index) whose length is greater than any previous fusc number length.%n\");\n        int start = 0;\n        for (int i = 0 ; i <= 5 ; i++ ) {\n            int val = i != 0 ? (int) Math.pow(10, i) : -1;\n            for ( int j = start ; j < FUSC_MAX ; j++ ) {\n                if ( fusc[j] > val ) {\n                    System.out.printf(\"fusc[%,d] =\u00a0%,d%n\", j, fusc[j] );\n                    start = j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    private static final int FUSC_MAX = 30000000;\n    private static int[] fusc = new int[FUSC_MAX];\n\n    static {\n        fusc[0] = 0;\n        fusc[1] = 1;\n        for ( int n = 2 ; n < FUSC_MAX ; n++ ) {\n            fusc[n] = (n % 2 == 0 ? fusc[n/2] : fusc[(n-1)/2] + fusc[(n+1)/2]);\n        }\n    }\n}\n"}
{"id": 9256, "name": "Fusc sequence", "source": "Translate Swift to Python: struct FuscSeq: Sequence, IteratorProtocol {\n  private var arr = [0, 1]\n  private var i = 0\n\n  mutating func next() -> Int? {\n    defer {\n      i += 1\n    }\n\n    guard i > 1 else {\n      return arr[i]\n    }\n\n    switch i & 1 {\n    case 0:\n      arr.append(arr[i / 2])\n    case 1:\n      arr.append(arr[(i - 1) / 2] + arr[(i + 1) / 2])\n    case _:\n      fatalError()\n    }\n\n    return arr.last!\n  }\n}\n\nlet first = FuscSeq().prefix(61)\n\nprint(\"First 61: \\(Array(first))\")\n\nvar max = -1\n\nfor (i, n) in FuscSeq().prefix(20_000_000).enumerated() {\n  let f = String(n).count\n\n  if f > max {\n    max = f\n\n    print(\"New max: \\(i): \\(n)\")\n  }\n}\n", "target": "from collections import deque\nfrom itertools import islice, count\n\n\ndef fusc():\n    q = deque([1])\n    yield 0\n    yield 1\n\n    while True:\n        x = q.popleft()\n        q.append(x)\n        yield x\n\n        x += q[0]\n        q.append(x)\n        yield x\n\n\ndef longest_fusc():\n    sofar = 0\n    for i, f in zip(count(), fusc()):\n        if f >= sofar:\n            yield(i, f)\n            sofar = 10 * sofar or 10\n\n\nprint('First 61:')\nprint(list(islice(fusc(), 61)))\n\nprint('\\nLength records:')\nfor i, f in islice(longest_fusc(), 6):\n    print(f'fusc({i}) = {f}')\n"}
{"id": 9257, "name": "Fusc sequence", "source": "Translate Swift to Python: struct FuscSeq: Sequence, IteratorProtocol {\n  private var arr = [0, 1]\n  private var i = 0\n\n  mutating func next() -> Int? {\n    defer {\n      i += 1\n    }\n\n    guard i > 1 else {\n      return arr[i]\n    }\n\n    switch i & 1 {\n    case 0:\n      arr.append(arr[i / 2])\n    case 1:\n      arr.append(arr[(i - 1) / 2] + arr[(i + 1) / 2])\n    case _:\n      fatalError()\n    }\n\n    return arr.last!\n  }\n}\n\nlet first = FuscSeq().prefix(61)\n\nprint(\"First 61: \\(Array(first))\")\n\nvar max = -1\n\nfor (i, n) in FuscSeq().prefix(20_000_000).enumerated() {\n  let f = String(n).count\n\n  if f > max {\n    max = f\n\n    print(\"New max: \\(i): \\(n)\")\n  }\n}\n", "target": "from collections import deque\nfrom itertools import islice, count\n\n\ndef fusc():\n    q = deque([1])\n    yield 0\n    yield 1\n\n    while True:\n        x = q.popleft()\n        q.append(x)\n        yield x\n\n        x += q[0]\n        q.append(x)\n        yield x\n\n\ndef longest_fusc():\n    sofar = 0\n    for i, f in zip(count(), fusc()):\n        if f >= sofar:\n            yield(i, f)\n            sofar = 10 * sofar or 10\n\n\nprint('First 61:')\nprint(list(islice(fusc(), 61)))\n\nprint('\\nLength records:')\nfor i, f in islice(longest_fusc(), 6):\n    print(f'fusc({i}) = {f}')\n"}
{"id": 9914, "name": "Haversine formula", "source": "Translate Swift to C#: import Foundation\n\nfunc haversine(lat1:Double, lon1:Double, lat2:Double, lon2:Double) -> Double {\n    let lat1rad = lat1 * Double.pi/180\n    let lon1rad = lon1 * Double.pi/180\n    let lat2rad = lat2 * Double.pi/180\n    let lon2rad = lon2 * Double.pi/180\n    \n    let dLat = lat2rad - lat1rad\n    let dLon = lon2rad - lon1rad\n    let a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1rad) * cos(lat2rad)\n    let c = 2 * asin(sqrt(a))\n    let R = 6372.8\n    \n    return R * c\n}\n\nprint(haversine(lat1:36.12, lon1:-86.67, lat2:33.94, lon2:-118.40))\n", "target": "public static class Haversine {\n  public static double calculate(double lat1, double lon1, double lat2, double lon2) {\n    var R = 6372.8; \n    var dLat = toRadians(lat2 - lat1);\n    var dLon = toRadians(lon2 - lon1);\n    lat1 = toRadians(lat1);\n    lat2 = toRadians(lat2);\n   \n    var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Sin(dLon / 2) * Math.Sin(dLon / 2) * Math.Cos(lat1) * Math.Cos(lat2);\n    var c = 2 * Math.Asin(Math.Sqrt(a));\n    return R * 2 * Math.Asin(Math.Sqrt(a));\n  }\n  \n  public static double toRadians(double angle) {\n    return Math.PI * angle / 180.0;\n  }\n}\n\nvoid Main() {\n  Console.WriteLine(String.Format(\"The distance between coordinates {0},{1} and {2},{3} is: {4}\", 36.12, -86.67, 33.94, -118.40, Haversine.calculate(36.12, -86.67, 33.94, -118.40)));\n}\n\n\n"}
{"id": 9915, "name": "Haversine formula", "source": "Translate Swift to C#: import Foundation\n\nfunc haversine(lat1:Double, lon1:Double, lat2:Double, lon2:Double) -> Double {\n    let lat1rad = lat1 * Double.pi/180\n    let lon1rad = lon1 * Double.pi/180\n    let lat2rad = lat2 * Double.pi/180\n    let lon2rad = lon2 * Double.pi/180\n    \n    let dLat = lat2rad - lat1rad\n    let dLon = lon2rad - lon1rad\n    let a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1rad) * cos(lat2rad)\n    let c = 2 * asin(sqrt(a))\n    let R = 6372.8\n    \n    return R * c\n}\n\nprint(haversine(lat1:36.12, lon1:-86.67, lat2:33.94, lon2:-118.40))\n", "target": "public static class Haversine {\n  public static double calculate(double lat1, double lon1, double lat2, double lon2) {\n    var R = 6372.8; \n    var dLat = toRadians(lat2 - lat1);\n    var dLon = toRadians(lon2 - lon1);\n    lat1 = toRadians(lat1);\n    lat2 = toRadians(lat2);\n   \n    var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Sin(dLon / 2) * Math.Sin(dLon / 2) * Math.Cos(lat1) * Math.Cos(lat2);\n    var c = 2 * Math.Asin(Math.Sqrt(a));\n    return R * 2 * Math.Asin(Math.Sqrt(a));\n  }\n  \n  public static double toRadians(double angle) {\n    return Math.PI * angle / 180.0;\n  }\n}\n\nvoid Main() {\n  Console.WriteLine(String.Format(\"The distance between coordinates {0},{1} and {2},{3} is: {4}\", 36.12, -86.67, 33.94, -118.40, Haversine.calculate(36.12, -86.67, 33.94, -118.40)));\n}\n\n\n"}
{"id": 9918, "name": "Haversine formula", "source": "Translate Swift to Java: import Foundation\n\nfunc haversine(lat1:Double, lon1:Double, lat2:Double, lon2:Double) -> Double {\n    let lat1rad = lat1 * Double.pi/180\n    let lon1rad = lon1 * Double.pi/180\n    let lat2rad = lat2 * Double.pi/180\n    let lon2rad = lon2 * Double.pi/180\n    \n    let dLat = lat2rad - lat1rad\n    let dLon = lon2rad - lon1rad\n    let a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1rad) * cos(lat2rad)\n    let c = 2 * asin(sqrt(a))\n    let R = 6372.8\n    \n    return R * c\n}\n\nprint(haversine(lat1:36.12, lon1:-86.67, lat2:33.94, lon2:-118.40))\n", "target": "public class Haversine {\n    public static final double R = 6372.8; \n\n    public static double haversine(double lat1, double lon1, double lat2, double lon2) {\n        lat1 = Math.toRadians(lat1);\n        lat2 = Math.toRadians(lat2);\n        double dLat = lat2 - lat1;\n        double dLon = Math.toRadians(lon2 - lon1);\n\n        double a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n        double c = 2 * Math.asin(Math.sqrt(a));\n        return R * c;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(haversine(36.12, -86.67, 33.94, -118.40));\n    }\n}\n"}
{"id": 9919, "name": "Haversine formula", "source": "Translate Swift to Java: import Foundation\n\nfunc haversine(lat1:Double, lon1:Double, lat2:Double, lon2:Double) -> Double {\n    let lat1rad = lat1 * Double.pi/180\n    let lon1rad = lon1 * Double.pi/180\n    let lat2rad = lat2 * Double.pi/180\n    let lon2rad = lon2 * Double.pi/180\n    \n    let dLat = lat2rad - lat1rad\n    let dLon = lon2rad - lon1rad\n    let a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1rad) * cos(lat2rad)\n    let c = 2 * asin(sqrt(a))\n    let R = 6372.8\n    \n    return R * c\n}\n\nprint(haversine(lat1:36.12, lon1:-86.67, lat2:33.94, lon2:-118.40))\n", "target": "public class Haversine {\n    public static final double R = 6372.8; \n\n    public static double haversine(double lat1, double lon1, double lat2, double lon2) {\n        lat1 = Math.toRadians(lat1);\n        lat2 = Math.toRadians(lat2);\n        double dLat = lat2 - lat1;\n        double dLon = Math.toRadians(lon2 - lon1);\n\n        double a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n        double c = 2 * Math.asin(Math.sqrt(a));\n        return R * c;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(haversine(36.12, -86.67, 33.94, -118.40));\n    }\n}\n"}
{"id": 9920, "name": "Haversine formula", "source": "Translate Swift to Python: import Foundation\n\nfunc haversine(lat1:Double, lon1:Double, lat2:Double, lon2:Double) -> Double {\n    let lat1rad = lat1 * Double.pi/180\n    let lon1rad = lon1 * Double.pi/180\n    let lat2rad = lat2 * Double.pi/180\n    let lon2rad = lon2 * Double.pi/180\n    \n    let dLat = lat2rad - lat1rad\n    let dLon = lon2rad - lon1rad\n    let a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1rad) * cos(lat2rad)\n    let c = 2 * asin(sqrt(a))\n    let R = 6372.8\n    \n    return R * c\n}\n\nprint(haversine(lat1:36.12, lon1:-86.67, lat2:33.94, lon2:-118.40))\n", "target": "from math import radians, sin, cos, sqrt, asin\n\n\ndef haversine(lat1, lon1, lat2, lon2):\n    R = 6372.8  \n\n    dLat = radians(lat2 - lat1)\n    dLon = radians(lon2 - lon1)\n    lat1 = radians(lat1)\n    lat2 = radians(lat2)\n\n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n\n    return R * c\n\n>>> haversine(36.12, -86.67, 33.94, -118.40)\n2887.2599506071106\n>>>\n"}
{"id": 9921, "name": "Haversine formula", "source": "Translate Swift to Python: import Foundation\n\nfunc haversine(lat1:Double, lon1:Double, lat2:Double, lon2:Double) -> Double {\n    let lat1rad = lat1 * Double.pi/180\n    let lon1rad = lon1 * Double.pi/180\n    let lat2rad = lat2 * Double.pi/180\n    let lon2rad = lon2 * Double.pi/180\n    \n    let dLat = lat2rad - lat1rad\n    let dLon = lon2rad - lon1rad\n    let a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1rad) * cos(lat2rad)\n    let c = 2 * asin(sqrt(a))\n    let R = 6372.8\n    \n    return R * c\n}\n\nprint(haversine(lat1:36.12, lon1:-86.67, lat2:33.94, lon2:-118.40))\n", "target": "from math import radians, sin, cos, sqrt, asin\n\n\ndef haversine(lat1, lon1, lat2, lon2):\n    R = 6372.8  \n\n    dLat = radians(lat2 - lat1)\n    dLon = radians(lon2 - lon1)\n    lat1 = radians(lat1)\n    lat2 = radians(lat2)\n\n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n\n    return R * c\n\n>>> haversine(36.12, -86.67, 33.94, -118.40)\n2887.2599506071106\n>>>\n"}
{"id": 10551, "name": "Nth root", "source": "Translate Swift to C#: extension FloatingPoint where Self: ExpressibleByFloatLiteral {\n  @inlinable\n  public func power(_ e: Int) -> Self {\n    var res = Self(1)\n\n    for _ in 0..<e {\n      res *= self\n    }\n\n    return res\n  }\n\n  @inlinable\n  public func root(n: Int, epsilon: Self = 2.220446049250313e-16) -> Self {\n    var d = Self(0)\n    var res = Self(1)\n\n    guard self != 0 else {\n      return 0\n    }\n\n    guard n >= 1 else {\n      return .nan\n    }\n\n    repeat {\n      d = (self / res.power(n - 1) - res) / Self(n)\n      res += d\n    } while d >= epsilon * 10 || d <= -epsilon * 10\n\n    return res\n  }\n}\n\nprint(81.root(n: 4))\nprint(13.root(n: 5))\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(NthRoot(81,2,.001));\n        Console.WriteLine(NthRoot(1000,3,.001));\n        Console.ReadLine();\n}\n\npublic static double NthRoot(double A,int n,  double p)\n{\n\tdouble _n= (double) n;\n\tdouble[] x = new double[2];\t\t\n\tx[0] = A;\n\tx[1] = A/_n;\n\twhile(Math.Abs(x[0] -x[1] ) > p)\n\t{\n\t\tx[1] = x[0];\n\t\tx[0] = (1/_n)*(((_n-1)*x[1]) + (A/Math.Pow(x[1],_n-1)));\n\t\t\t\n\t}\n\treturn x[0];\n}\n"}
{"id": 10553, "name": "Nth root", "source": "Translate Swift to Java: extension FloatingPoint where Self: ExpressibleByFloatLiteral {\n  @inlinable\n  public func power(_ e: Int) -> Self {\n    var res = Self(1)\n\n    for _ in 0..<e {\n      res *= self\n    }\n\n    return res\n  }\n\n  @inlinable\n  public func root(n: Int, epsilon: Self = 2.220446049250313e-16) -> Self {\n    var d = Self(0)\n    var res = Self(1)\n\n    guard self != 0 else {\n      return 0\n    }\n\n    guard n >= 1 else {\n      return .nan\n    }\n\n    repeat {\n      d = (self / res.power(n - 1) - res) / Self(n)\n      res += d\n    } while d >= epsilon * 10 || d <= -epsilon * 10\n\n    return res\n  }\n}\n\nprint(81.root(n: 4))\nprint(13.root(n: 5))\n", "target": "public static double nthroot(int n, double A) {\n\treturn nthroot(n, A, .001);\n}\npublic static double nthroot(int n, double A, double p) {\n\tif(A < 0) {\n\t\tSystem.err.println(\"A < 0\");\n\t\treturn -1;\n\t} else if(A == 0) {\n\t\treturn 0;\n\t}\n\tdouble x_prev = A;\n\tdouble x = A / n;  \n\twhile(Math.abs(x - x_prev) > p) {\n\t\tx_prev = x;\n\t\tx = ((n - 1.0) * x + A / Math.pow(x, n - 1.0)) / n;\n\t}\n\treturn x;\n}\n"}
{"id": 10554, "name": "Nth root", "source": "Translate Swift to Python: extension FloatingPoint where Self: ExpressibleByFloatLiteral {\n  @inlinable\n  public func power(_ e: Int) -> Self {\n    var res = Self(1)\n\n    for _ in 0..<e {\n      res *= self\n    }\n\n    return res\n  }\n\n  @inlinable\n  public func root(n: Int, epsilon: Self = 2.220446049250313e-16) -> Self {\n    var d = Self(0)\n    var res = Self(1)\n\n    guard self != 0 else {\n      return 0\n    }\n\n    guard n >= 1 else {\n      return .nan\n    }\n\n    repeat {\n      d = (self / res.power(n - 1) - res) / Self(n)\n      res += d\n    } while d >= epsilon * 10 || d <= -epsilon * 10\n\n    return res\n  }\n}\n\nprint(81.root(n: 4))\nprint(13.root(n: 5))\n", "target": "from decimal import Decimal, getcontext\n\ndef nthroot (n, A, precision):\n    getcontext().prec = precision\n    \n    n = Decimal(n)\n    x_0 = A / n \n    x_1 = 1     \n    while True:\n        \n        x_0, x_1 = x_1, (1 / n)*((n - 1)*x_0 + (A / (x_0 ** (n - 1))))\n        if x_0 == x_1:\n            return x_1\n"}
{"id": 10986, "name": "Priority queue", "source": "Translate Swift to C#: class Task : Comparable, CustomStringConvertible {\n  var priority : Int\n  var name: String\n  init(priority: Int, name: String) {\n    self.priority = priority\n    self.name = name\n  }\n  var description: String {\n    return \"\\(priority), \\(name)\"\n  }\n}\nfunc ==(t1: Task, t2: Task) -> Bool {\n  return t1.priority == t2.priority\n}\nfunc <(t1: Task, t2: Task) -> Bool {\n  return t1.priority < t2.priority\n}\n\nstruct TaskPriorityQueue {\n  let heap : CFBinaryHeapRef = {\n    var callBacks = CFBinaryHeapCallBacks(version: 0, retain: {\n      UnsafePointer(Unmanaged<Task>.fromOpaque(COpaquePointer($1)).retain().toOpaque())\n      }, release: {\n        Unmanaged<Task>.fromOpaque(COpaquePointer($1)).release()\n      }, copyDescription: nil, compare: { (ptr1, ptr2, _) in\n        let t1 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr1)).takeUnretainedValue()\n        let t2 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr2)).takeUnretainedValue()\n        return t1 == t2 ? CFComparisonResult.CompareEqualTo : t1 < t2 ? CFComparisonResult.CompareLessThan : CFComparisonResult.CompareGreaterThan\n    })\n    return CFBinaryHeapCreate(nil, 0, &callBacks, nil)\n  }()\n  var count : Int { return CFBinaryHeapGetCount(heap) }\n  mutating func push(t: Task) {\n    CFBinaryHeapAddValue(heap, UnsafePointer(Unmanaged.passUnretained(t).toOpaque()))\n  }\n  func peek() -> Task {\n    return Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n  }\n  mutating func pop() -> Task {\n    let result = Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n    CFBinaryHeapRemoveMinimumValue(heap)\n    return result\n  }\n}\n\nvar pq = TaskPriorityQueue()\n\npq.push(Task(priority: 3, name: \"Clear drains\"))\npq.push(Task(priority: 4, name: \"Feed cat\"))\npq.push(Task(priority: 5, name: \"Make tea\"))\npq.push(Task(priority: 1, name: \"Solve RC tasks\"))\npq.push(Task(priority: 2, name: \"Tax return\"))\n\nwhile pq.count != 0 {\n  print(pq.pop())\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PriorityQueueExample\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\t\n\t\t\tvar p = new PriorityQueue<string, int>();\n\t\t\tp.Enqueue(\"Clear drains\", 3);\n\t\t\tp.Enqueue(\"Feed cat\", 4);\n\t\t\tp.Enqueue(\"Make tea\", 5);\n\t\t\tp.Enqueue(\"Solve RC tasks\", 1);\n\t\t\tp.Enqueue(\"Tax return\", 2);\n\t\t\twhile (p.TryDequeue(out string task, out int priority))\n\t\t\t{\n\t\t\t\tConsole.WriteLine($\"{priority}\\t{task}\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"}
{"id": 10987, "name": "Priority queue", "source": "Translate Swift to C#: class Task : Comparable, CustomStringConvertible {\n  var priority : Int\n  var name: String\n  init(priority: Int, name: String) {\n    self.priority = priority\n    self.name = name\n  }\n  var description: String {\n    return \"\\(priority), \\(name)\"\n  }\n}\nfunc ==(t1: Task, t2: Task) -> Bool {\n  return t1.priority == t2.priority\n}\nfunc <(t1: Task, t2: Task) -> Bool {\n  return t1.priority < t2.priority\n}\n\nstruct TaskPriorityQueue {\n  let heap : CFBinaryHeapRef = {\n    var callBacks = CFBinaryHeapCallBacks(version: 0, retain: {\n      UnsafePointer(Unmanaged<Task>.fromOpaque(COpaquePointer($1)).retain().toOpaque())\n      }, release: {\n        Unmanaged<Task>.fromOpaque(COpaquePointer($1)).release()\n      }, copyDescription: nil, compare: { (ptr1, ptr2, _) in\n        let t1 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr1)).takeUnretainedValue()\n        let t2 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr2)).takeUnretainedValue()\n        return t1 == t2 ? CFComparisonResult.CompareEqualTo : t1 < t2 ? CFComparisonResult.CompareLessThan : CFComparisonResult.CompareGreaterThan\n    })\n    return CFBinaryHeapCreate(nil, 0, &callBacks, nil)\n  }()\n  var count : Int { return CFBinaryHeapGetCount(heap) }\n  mutating func push(t: Task) {\n    CFBinaryHeapAddValue(heap, UnsafePointer(Unmanaged.passUnretained(t).toOpaque()))\n  }\n  func peek() -> Task {\n    return Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n  }\n  mutating func pop() -> Task {\n    let result = Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n    CFBinaryHeapRemoveMinimumValue(heap)\n    return result\n  }\n}\n\nvar pq = TaskPriorityQueue()\n\npq.push(Task(priority: 3, name: \"Clear drains\"))\npq.push(Task(priority: 4, name: \"Feed cat\"))\npq.push(Task(priority: 5, name: \"Make tea\"))\npq.push(Task(priority: 1, name: \"Solve RC tasks\"))\npq.push(Task(priority: 2, name: \"Tax return\"))\n\nwhile pq.count != 0 {\n  print(pq.pop())\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PriorityQueueExample\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\t\n\t\t\tvar p = new PriorityQueue<string, int>();\n\t\t\tp.Enqueue(\"Clear drains\", 3);\n\t\t\tp.Enqueue(\"Feed cat\", 4);\n\t\t\tp.Enqueue(\"Make tea\", 5);\n\t\t\tp.Enqueue(\"Solve RC tasks\", 1);\n\t\t\tp.Enqueue(\"Tax return\", 2);\n\t\t\twhile (p.TryDequeue(out string task, out int priority))\n\t\t\t{\n\t\t\t\tConsole.WriteLine($\"{priority}\\t{task}\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"}
{"id": 10990, "name": "Priority queue", "source": "Translate Swift to Java: class Task : Comparable, CustomStringConvertible {\n  var priority : Int\n  var name: String\n  init(priority: Int, name: String) {\n    self.priority = priority\n    self.name = name\n  }\n  var description: String {\n    return \"\\(priority), \\(name)\"\n  }\n}\nfunc ==(t1: Task, t2: Task) -> Bool {\n  return t1.priority == t2.priority\n}\nfunc <(t1: Task, t2: Task) -> Bool {\n  return t1.priority < t2.priority\n}\n\nstruct TaskPriorityQueue {\n  let heap : CFBinaryHeapRef = {\n    var callBacks = CFBinaryHeapCallBacks(version: 0, retain: {\n      UnsafePointer(Unmanaged<Task>.fromOpaque(COpaquePointer($1)).retain().toOpaque())\n      }, release: {\n        Unmanaged<Task>.fromOpaque(COpaquePointer($1)).release()\n      }, copyDescription: nil, compare: { (ptr1, ptr2, _) in\n        let t1 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr1)).takeUnretainedValue()\n        let t2 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr2)).takeUnretainedValue()\n        return t1 == t2 ? CFComparisonResult.CompareEqualTo : t1 < t2 ? CFComparisonResult.CompareLessThan : CFComparisonResult.CompareGreaterThan\n    })\n    return CFBinaryHeapCreate(nil, 0, &callBacks, nil)\n  }()\n  var count : Int { return CFBinaryHeapGetCount(heap) }\n  mutating func push(t: Task) {\n    CFBinaryHeapAddValue(heap, UnsafePointer(Unmanaged.passUnretained(t).toOpaque()))\n  }\n  func peek() -> Task {\n    return Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n  }\n  mutating func pop() -> Task {\n    let result = Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n    CFBinaryHeapRemoveMinimumValue(heap)\n    return result\n  }\n}\n\nvar pq = TaskPriorityQueue()\n\npq.push(Task(priority: 3, name: \"Clear drains\"))\npq.push(Task(priority: 4, name: \"Feed cat\"))\npq.push(Task(priority: 5, name: \"Make tea\"))\npq.push(Task(priority: 1, name: \"Solve RC tasks\"))\npq.push(Task(priority: 2, name: \"Tax return\"))\n\nwhile pq.count != 0 {\n  print(pq.pop())\n}\n", "target": "import java.util.PriorityQueue;\n\nclass Task implements Comparable<Task> {\n    final int priority;\n    final String name;\n\n    public Task(int p, String n) {\n        priority = p;\n        name = n;\n    }\n\n    public String toString() {\n        return priority + \", \" + name;\n    }\n\n    public int compareTo(Task other) {\n        return priority < other.priority ? -1 : priority > other.priority ? 1 : 0;\n    }\n\n    public static void main(String[] args) {\n        PriorityQueue<Task> pq = new PriorityQueue<Task>();\n        pq.add(new Task(3, \"Clear drains\"));\n        pq.add(new Task(4, \"Feed cat\"));\n        pq.add(new Task(5, \"Make tea\"));\n        pq.add(new Task(1, \"Solve RC tasks\"));\n        pq.add(new Task(2, \"Tax return\"));\n\n        while (!pq.isEmpty())\n            System.out.println(pq.remove());\n    }\n}\n"}
{"id": 10991, "name": "Priority queue", "source": "Translate Swift to Java: class Task : Comparable, CustomStringConvertible {\n  var priority : Int\n  var name: String\n  init(priority: Int, name: String) {\n    self.priority = priority\n    self.name = name\n  }\n  var description: String {\n    return \"\\(priority), \\(name)\"\n  }\n}\nfunc ==(t1: Task, t2: Task) -> Bool {\n  return t1.priority == t2.priority\n}\nfunc <(t1: Task, t2: Task) -> Bool {\n  return t1.priority < t2.priority\n}\n\nstruct TaskPriorityQueue {\n  let heap : CFBinaryHeapRef = {\n    var callBacks = CFBinaryHeapCallBacks(version: 0, retain: {\n      UnsafePointer(Unmanaged<Task>.fromOpaque(COpaquePointer($1)).retain().toOpaque())\n      }, release: {\n        Unmanaged<Task>.fromOpaque(COpaquePointer($1)).release()\n      }, copyDescription: nil, compare: { (ptr1, ptr2, _) in\n        let t1 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr1)).takeUnretainedValue()\n        let t2 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr2)).takeUnretainedValue()\n        return t1 == t2 ? CFComparisonResult.CompareEqualTo : t1 < t2 ? CFComparisonResult.CompareLessThan : CFComparisonResult.CompareGreaterThan\n    })\n    return CFBinaryHeapCreate(nil, 0, &callBacks, nil)\n  }()\n  var count : Int { return CFBinaryHeapGetCount(heap) }\n  mutating func push(t: Task) {\n    CFBinaryHeapAddValue(heap, UnsafePointer(Unmanaged.passUnretained(t).toOpaque()))\n  }\n  func peek() -> Task {\n    return Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n  }\n  mutating func pop() -> Task {\n    let result = Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n    CFBinaryHeapRemoveMinimumValue(heap)\n    return result\n  }\n}\n\nvar pq = TaskPriorityQueue()\n\npq.push(Task(priority: 3, name: \"Clear drains\"))\npq.push(Task(priority: 4, name: \"Feed cat\"))\npq.push(Task(priority: 5, name: \"Make tea\"))\npq.push(Task(priority: 1, name: \"Solve RC tasks\"))\npq.push(Task(priority: 2, name: \"Tax return\"))\n\nwhile pq.count != 0 {\n  print(pq.pop())\n}\n", "target": "import java.util.PriorityQueue;\n\nclass Task implements Comparable<Task> {\n    final int priority;\n    final String name;\n\n    public Task(int p, String n) {\n        priority = p;\n        name = n;\n    }\n\n    public String toString() {\n        return priority + \", \" + name;\n    }\n\n    public int compareTo(Task other) {\n        return priority < other.priority ? -1 : priority > other.priority ? 1 : 0;\n    }\n\n    public static void main(String[] args) {\n        PriorityQueue<Task> pq = new PriorityQueue<Task>();\n        pq.add(new Task(3, \"Clear drains\"));\n        pq.add(new Task(4, \"Feed cat\"));\n        pq.add(new Task(5, \"Make tea\"));\n        pq.add(new Task(1, \"Solve RC tasks\"));\n        pq.add(new Task(2, \"Tax return\"));\n\n        while (!pq.isEmpty())\n            System.out.println(pq.remove());\n    }\n}\n"}
{"id": 10992, "name": "Priority queue", "source": "Translate Swift to Python: class Task : Comparable, CustomStringConvertible {\n  var priority : Int\n  var name: String\n  init(priority: Int, name: String) {\n    self.priority = priority\n    self.name = name\n  }\n  var description: String {\n    return \"\\(priority), \\(name)\"\n  }\n}\nfunc ==(t1: Task, t2: Task) -> Bool {\n  return t1.priority == t2.priority\n}\nfunc <(t1: Task, t2: Task) -> Bool {\n  return t1.priority < t2.priority\n}\n\nstruct TaskPriorityQueue {\n  let heap : CFBinaryHeapRef = {\n    var callBacks = CFBinaryHeapCallBacks(version: 0, retain: {\n      UnsafePointer(Unmanaged<Task>.fromOpaque(COpaquePointer($1)).retain().toOpaque())\n      }, release: {\n        Unmanaged<Task>.fromOpaque(COpaquePointer($1)).release()\n      }, copyDescription: nil, compare: { (ptr1, ptr2, _) in\n        let t1 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr1)).takeUnretainedValue()\n        let t2 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr2)).takeUnretainedValue()\n        return t1 == t2 ? CFComparisonResult.CompareEqualTo : t1 < t2 ? CFComparisonResult.CompareLessThan : CFComparisonResult.CompareGreaterThan\n    })\n    return CFBinaryHeapCreate(nil, 0, &callBacks, nil)\n  }()\n  var count : Int { return CFBinaryHeapGetCount(heap) }\n  mutating func push(t: Task) {\n    CFBinaryHeapAddValue(heap, UnsafePointer(Unmanaged.passUnretained(t).toOpaque()))\n  }\n  func peek() -> Task {\n    return Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n  }\n  mutating func pop() -> Task {\n    let result = Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n    CFBinaryHeapRemoveMinimumValue(heap)\n    return result\n  }\n}\n\nvar pq = TaskPriorityQueue()\n\npq.push(Task(priority: 3, name: \"Clear drains\"))\npq.push(Task(priority: 4, name: \"Feed cat\"))\npq.push(Task(priority: 5, name: \"Make tea\"))\npq.push(Task(priority: 1, name: \"Solve RC tasks\"))\npq.push(Task(priority: 2, name: \"Tax return\"))\n\nwhile pq.count != 0 {\n  print(pq.pop())\n}\n", "target": ">>> import queue\n>>> pq = queue.PriorityQueue()\n>>> for item in ((3, \"Clear drains\"), (4, \"Feed cat\"), (5, \"Make tea\"), (1, \"Solve RC tasks\"), (2, \"Tax return\")):\n  pq.put(item)\n\n  \n>>> while not pq.empty():\n  print(pq.get_nowait())\n\n  \n(1, 'Solve RC tasks')\n(2, 'Tax return')\n(3, 'Clear drains')\n(4, 'Feed cat')\n(5, 'Make tea')\n>>>\n"}
{"id": 10993, "name": "Priority queue", "source": "Translate Swift to Python: class Task : Comparable, CustomStringConvertible {\n  var priority : Int\n  var name: String\n  init(priority: Int, name: String) {\n    self.priority = priority\n    self.name = name\n  }\n  var description: String {\n    return \"\\(priority), \\(name)\"\n  }\n}\nfunc ==(t1: Task, t2: Task) -> Bool {\n  return t1.priority == t2.priority\n}\nfunc <(t1: Task, t2: Task) -> Bool {\n  return t1.priority < t2.priority\n}\n\nstruct TaskPriorityQueue {\n  let heap : CFBinaryHeapRef = {\n    var callBacks = CFBinaryHeapCallBacks(version: 0, retain: {\n      UnsafePointer(Unmanaged<Task>.fromOpaque(COpaquePointer($1)).retain().toOpaque())\n      }, release: {\n        Unmanaged<Task>.fromOpaque(COpaquePointer($1)).release()\n      }, copyDescription: nil, compare: { (ptr1, ptr2, _) in\n        let t1 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr1)).takeUnretainedValue()\n        let t2 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr2)).takeUnretainedValue()\n        return t1 == t2 ? CFComparisonResult.CompareEqualTo : t1 < t2 ? CFComparisonResult.CompareLessThan : CFComparisonResult.CompareGreaterThan\n    })\n    return CFBinaryHeapCreate(nil, 0, &callBacks, nil)\n  }()\n  var count : Int { return CFBinaryHeapGetCount(heap) }\n  mutating func push(t: Task) {\n    CFBinaryHeapAddValue(heap, UnsafePointer(Unmanaged.passUnretained(t).toOpaque()))\n  }\n  func peek() -> Task {\n    return Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n  }\n  mutating func pop() -> Task {\n    let result = Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n    CFBinaryHeapRemoveMinimumValue(heap)\n    return result\n  }\n}\n\nvar pq = TaskPriorityQueue()\n\npq.push(Task(priority: 3, name: \"Clear drains\"))\npq.push(Task(priority: 4, name: \"Feed cat\"))\npq.push(Task(priority: 5, name: \"Make tea\"))\npq.push(Task(priority: 1, name: \"Solve RC tasks\"))\npq.push(Task(priority: 2, name: \"Tax return\"))\n\nwhile pq.count != 0 {\n  print(pq.pop())\n}\n", "target": ">>> import queue\n>>> pq = queue.PriorityQueue()\n>>> for item in ((3, \"Clear drains\"), (4, \"Feed cat\"), (5, \"Make tea\"), (1, \"Solve RC tasks\"), (2, \"Tax return\")):\n  pq.put(item)\n\n  \n>>> while not pq.empty():\n  print(pq.get_nowait())\n\n  \n(1, 'Solve RC tasks')\n(2, 'Tax return')\n(3, 'Clear drains')\n(4, 'Feed cat')\n(5, 'Make tea')\n>>>\n"}
{"id": 11550, "name": "Hailstone sequence", "source": "Translate Swift to C#: func hailstone(var n:Int) -> [Int] {\n\n    var arr = [n]\n    \n    while n != 1 {\n\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = (3 * n) + 1\n        }    \n\n        arr.append(n)\n    }\n    \n    return arr\n}\n\nlet n = hailstone(27)\n\nprintln(\"hailstone(27): \\(n[0...3]) ... \\(n[n.count-4...n.count-1]) for a count of \\(n.count).\")\n\nvar longest = (n: 1, len: 1)\n\nfor i in 1...100_000 {\n\n    let new = hailstone(i)\n    \n    if new.count > longest.len {\n        longest = (i, new.count)\n    }\n}\n\nprintln(\"Longest sequence for numbers under 100,000 is with \\(longest.n). Which has \\(longest.len) items.\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Hailstone\n{\n    class Program\n    {\n        public static List<int> hs(int n,List<int> seq)\n        {\n            List<int> sequence = seq;\n            sequence.Add(n);\n            if (n == 1)\n            {\n                return sequence;\n            }else{\n                int newn = (n % 2 == 0) ? n / 2 : (3 * n) + 1;\n                return hs(newn, sequence);\n            }                        \n        }\n\n        static void Main(string[] args)\n        {\n            int n = 27;\n            List<int> sequence = hs(n,new List<int>());\n            Console.WriteLine(sequence.Count + \" Elements\");\n            List<int> start = sequence.GetRange(0, 4);\n            List<int> end = sequence.GetRange(sequence.Count - 4, 4);\n            Console.WriteLine(\"Starting with\u00a0: \" + string.Join(\",\", start) + \" and ending with\u00a0: \" + string.Join(\",\", end));            \n            int number = 0, longest = 0;            \n            for (int i = 1; i < 100000; i++)\n            {\n                int count = (hs(i, new List<int>())).Count;\n                if (count > longest)\n                {\n                    longest = count;\n                    number = i;\n                }\n            }\n            Console.WriteLine(\"Number < 100000 with longest Hailstone seq.: \" + number + \" with length of \" + longest);\n       }\n    }\n}\n"}
{"id": 11553, "name": "Hailstone sequence", "source": "Translate Swift to Java: func hailstone(var n:Int) -> [Int] {\n\n    var arr = [n]\n    \n    while n != 1 {\n\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = (3 * n) + 1\n        }    \n\n        arr.append(n)\n    }\n    \n    return arr\n}\n\nlet n = hailstone(27)\n\nprintln(\"hailstone(27): \\(n[0...3]) ... \\(n[n.count-4...n.count-1]) for a count of \\(n.count).\")\n\nvar longest = (n: 1, len: 1)\n\nfor i in 1...100_000 {\n\n    let new = hailstone(i)\n    \n    if new.count > longest.len {\n        longest = (i, new.count)\n    }\n}\n\nprintln(\"Longest sequence for numbers under 100,000 is with \\(longest.n). Which has \\(longest.len) items.\")\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Hailstone {\n\n  public static List<Long> getHailstoneSequence(long n) {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid starting sequence number\");\n    List<Long> list = new ArrayList<Long>();\n    list.add(Long.valueOf(n));\n    while (n != 1) {\n      if ((n & 1) == 0)\n        n = n / 2;\n      else\n        n = 3 * n + 1;\n      list.add(Long.valueOf(n));\n    }\n    return list;\n  }\n  \n  public static void main(String[] args) {\n    List<Long> sequence27 = getHailstoneSequence(27);\n    System.out.println(\"Sequence for 27 has \" + sequence27.size() + \" elements: \" + sequence27);\n    \n    long MAX = 100000;\n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = getHailstoneSequence(i).size();\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 1, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = 1;\n        long n = i;\n        while (n != 1) {\n          if ((n & 1) == 0)\n            n = n / 2;\n          else\n            n = 3 * n + 1;\n          count++;\n        }\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 2, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      long highestCount = 1;\n      Map<Long, Integer> sequenceMap = new HashMap<Long, Integer>();\n      sequenceMap.put(Long.valueOf(1), Integer.valueOf(1));\n      \n      List<Long> currentList = new ArrayList<Long>();\n      for (long i = 2; i < MAX; i++) {\n        currentList.clear();\n        Long n = Long.valueOf(i);\n        Integer count = null;\n        while ((count = sequenceMap.get(n)) == null) {\n          currentList.add(n);\n          long nValue = n.longValue();\n          if ((nValue & 1) == 0)\n            n = Long.valueOf(nValue / 2);\n          else\n            n = Long.valueOf(3 * nValue + 1);\n        }\n        int curCount = count.intValue();\n        for (int j = currentList.size() - 1; j >= 0; j--)\n          sequenceMap.put(currentList.get(j), Integer.valueOf(++curCount));\n        if (curCount > highestCount) {\n          highestCount = curCount;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 3, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    return;\n  }\n}\n"}
{"id": 11554, "name": "Hailstone sequence", "source": "Translate Swift to Java: func hailstone(var n:Int) -> [Int] {\n\n    var arr = [n]\n    \n    while n != 1 {\n\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = (3 * n) + 1\n        }    \n\n        arr.append(n)\n    }\n    \n    return arr\n}\n\nlet n = hailstone(27)\n\nprintln(\"hailstone(27): \\(n[0...3]) ... \\(n[n.count-4...n.count-1]) for a count of \\(n.count).\")\n\nvar longest = (n: 1, len: 1)\n\nfor i in 1...100_000 {\n\n    let new = hailstone(i)\n    \n    if new.count > longest.len {\n        longest = (i, new.count)\n    }\n}\n\nprintln(\"Longest sequence for numbers under 100,000 is with \\(longest.n). Which has \\(longest.len) items.\")\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Hailstone {\n\n  public static List<Long> getHailstoneSequence(long n) {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid starting sequence number\");\n    List<Long> list = new ArrayList<Long>();\n    list.add(Long.valueOf(n));\n    while (n != 1) {\n      if ((n & 1) == 0)\n        n = n / 2;\n      else\n        n = 3 * n + 1;\n      list.add(Long.valueOf(n));\n    }\n    return list;\n  }\n  \n  public static void main(String[] args) {\n    List<Long> sequence27 = getHailstoneSequence(27);\n    System.out.println(\"Sequence for 27 has \" + sequence27.size() + \" elements: \" + sequence27);\n    \n    long MAX = 100000;\n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = getHailstoneSequence(i).size();\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 1, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = 1;\n        long n = i;\n        while (n != 1) {\n          if ((n & 1) == 0)\n            n = n / 2;\n          else\n            n = 3 * n + 1;\n          count++;\n        }\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 2, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      long highestCount = 1;\n      Map<Long, Integer> sequenceMap = new HashMap<Long, Integer>();\n      sequenceMap.put(Long.valueOf(1), Integer.valueOf(1));\n      \n      List<Long> currentList = new ArrayList<Long>();\n      for (long i = 2; i < MAX; i++) {\n        currentList.clear();\n        Long n = Long.valueOf(i);\n        Integer count = null;\n        while ((count = sequenceMap.get(n)) == null) {\n          currentList.add(n);\n          long nValue = n.longValue();\n          if ((nValue & 1) == 0)\n            n = Long.valueOf(nValue / 2);\n          else\n            n = Long.valueOf(3 * nValue + 1);\n        }\n        int curCount = count.intValue();\n        for (int j = currentList.size() - 1; j >= 0; j--)\n          sequenceMap.put(currentList.get(j), Integer.valueOf(++curCount));\n        if (curCount > highestCount) {\n          highestCount = curCount;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 3, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    return;\n  }\n}\n"}
{"id": 11555, "name": "Hailstone sequence", "source": "Translate Swift to Python: func hailstone(var n:Int) -> [Int] {\n\n    var arr = [n]\n    \n    while n != 1 {\n\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = (3 * n) + 1\n        }    \n\n        arr.append(n)\n    }\n    \n    return arr\n}\n\nlet n = hailstone(27)\n\nprintln(\"hailstone(27): \\(n[0...3]) ... \\(n[n.count-4...n.count-1]) for a count of \\(n.count).\")\n\nvar longest = (n: 1, len: 1)\n\nfor i in 1...100_000 {\n\n    let new = hailstone(i)\n    \n    if new.count > longest.len {\n        longest = (i, new.count)\n    }\n}\n\nprintln(\"Longest sequence for numbers under 100,000 is with \\(longest.n). Which has \\(longest.len) items.\")\n", "target": "def hailstone(n):\n    seq = [n]\n    while n > 1:\n        n = 3 * n + 1 if n & 1 else n // 2\n        seq.append(n)\n    return seq\n\n\nif __name__ == '__main__':\n    h = hailstone(27)\n    assert (len(h) == 112\n            and h[:4] == [27, 82, 41, 124]\n            and h[-4:] == [8, 4, 2, 1])\n    max_length, n = max((len(hailstone(i)), i) for i in range(1, 100_000))\n    print(f\"Maximum length {max_length} was found for hailstone({n}) \"\n          f\"for numbers <100,000\")\n"}
{"id": 11556, "name": "Hailstone sequence", "source": "Translate Swift to Python: func hailstone(var n:Int) -> [Int] {\n\n    var arr = [n]\n    \n    while n != 1 {\n\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = (3 * n) + 1\n        }    \n\n        arr.append(n)\n    }\n    \n    return arr\n}\n\nlet n = hailstone(27)\n\nprintln(\"hailstone(27): \\(n[0...3]) ... \\(n[n.count-4...n.count-1]) for a count of \\(n.count).\")\n\nvar longest = (n: 1, len: 1)\n\nfor i in 1...100_000 {\n\n    let new = hailstone(i)\n    \n    if new.count > longest.len {\n        longest = (i, new.count)\n    }\n}\n\nprintln(\"Longest sequence for numbers under 100,000 is with \\(longest.n). Which has \\(longest.len) items.\")\n", "target": "def hailstone(n):\n    seq = [n]\n    while n > 1:\n        n = 3 * n + 1 if n & 1 else n // 2\n        seq.append(n)\n    return seq\n\n\nif __name__ == '__main__':\n    h = hailstone(27)\n    assert (len(h) == 112\n            and h[:4] == [27, 82, 41, 124]\n            and h[-4:] == [8, 4, 2, 1])\n    max_length, n = max((len(hailstone(i)), i) for i in range(1, 100_000))\n    print(f\"Maximum length {max_length} was found for hailstone({n}) \"\n          f\"for numbers <100,000\")\n"}
{"id": 11996, "name": "Multifactorial", "source": "Translate Swift to C#: func multiFactorial(_ n: Int, k: Int) -> Int {\n  return stride(from: n, to: 0, by: -k).reduce(1, *)\n}\n\nlet multis = (1...5).map({degree in\n  (1...10).map({member in\n    multiFactorial(member, k: degree)\n  })\n})\n\nfor (i, degree) in multis.enumerated() {\n  print(\"Degree \\(i + 1): \\(degree)\")\n}\n", "target": "namespace RosettaCode.Multifactorial\n{\n    using System;\n    using System.Linq;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            Console.WriteLine(string.Join(Environment.NewLine,\n                                          Enumerable.Range(1, 5)\n                                                    .Select(\n                                                        degree =>\n                                                        string.Join(\" \",\n                                                                    Enumerable.Range(1, 10)\n                                                                              .Select(\n                                                                                  number =>\n                                                                                  Multifactorial(number, degree))))));\n        }\n\n        private static int Multifactorial(int number, int degree)\n        {\n            if (degree < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"degree\");\n            }\n\n            var count = 1 + (number - 1) / degree;\n            if (count < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"number\");\n            }\n\n            return Enumerable.Range(0, count)\n                             .Aggregate(1, (accumulator, index) => accumulator * (number - degree * index));\n        }\n    }\n}\n"}
{"id": 11997, "name": "Multifactorial", "source": "Translate Swift to C#: func multiFactorial(_ n: Int, k: Int) -> Int {\n  return stride(from: n, to: 0, by: -k).reduce(1, *)\n}\n\nlet multis = (1...5).map({degree in\n  (1...10).map({member in\n    multiFactorial(member, k: degree)\n  })\n})\n\nfor (i, degree) in multis.enumerated() {\n  print(\"Degree \\(i + 1): \\(degree)\")\n}\n", "target": "namespace RosettaCode.Multifactorial\n{\n    using System;\n    using System.Linq;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            Console.WriteLine(string.Join(Environment.NewLine,\n                                          Enumerable.Range(1, 5)\n                                                    .Select(\n                                                        degree =>\n                                                        string.Join(\" \",\n                                                                    Enumerable.Range(1, 10)\n                                                                              .Select(\n                                                                                  number =>\n                                                                                  Multifactorial(number, degree))))));\n        }\n\n        private static int Multifactorial(int number, int degree)\n        {\n            if (degree < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"degree\");\n            }\n\n            var count = 1 + (number - 1) / degree;\n            if (count < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"number\");\n            }\n\n            return Enumerable.Range(0, count)\n                             .Aggregate(1, (accumulator, index) => accumulator * (number - degree * index));\n        }\n    }\n}\n"}
{"id": 12000, "name": "Multifactorial", "source": "Translate Swift to Java: func multiFactorial(_ n: Int, k: Int) -> Int {\n  return stride(from: n, to: 0, by: -k).reduce(1, *)\n}\n\nlet multis = (1...5).map({degree in\n  (1...10).map({member in\n    multiFactorial(member, k: degree)\n  })\n})\n\nfor (i, degree) in multis.enumerated() {\n  print(\"Degree \\(i + 1): \\(degree)\")\n}\n", "target": "public class MultiFact {\n\tprivate static long multiFact(long n, int deg){\n\t\tlong ans = 1;\n\t\tfor(long i = n; i > 0; i -= deg){\n\t\t\tans *= i;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int deg = 1; deg <= 5; deg++){\n\t\t\tSystem.out.print(\"degree \" + deg + \":\");\n\t\t\tfor(long n = 1; n <= 10; n++){\n\t\t\t\tSystem.out.print(\" \" + multiFact(n, deg));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 12001, "name": "Multifactorial", "source": "Translate Swift to Java: func multiFactorial(_ n: Int, k: Int) -> Int {\n  return stride(from: n, to: 0, by: -k).reduce(1, *)\n}\n\nlet multis = (1...5).map({degree in\n  (1...10).map({member in\n    multiFactorial(member, k: degree)\n  })\n})\n\nfor (i, degree) in multis.enumerated() {\n  print(\"Degree \\(i + 1): \\(degree)\")\n}\n", "target": "public class MultiFact {\n\tprivate static long multiFact(long n, int deg){\n\t\tlong ans = 1;\n\t\tfor(long i = n; i > 0; i -= deg){\n\t\t\tans *= i;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int deg = 1; deg <= 5; deg++){\n\t\t\tSystem.out.print(\"degree \" + deg + \":\");\n\t\t\tfor(long n = 1; n <= 10; n++){\n\t\t\t\tSystem.out.print(\" \" + multiFact(n, deg));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 12002, "name": "Multifactorial", "source": "Translate Swift to Python: func multiFactorial(_ n: Int, k: Int) -> Int {\n  return stride(from: n, to: 0, by: -k).reduce(1, *)\n}\n\nlet multis = (1...5).map({degree in\n  (1...10).map({member in\n    multiFactorial(member, k: degree)\n  })\n})\n\nfor (i, degree) in multis.enumerated() {\n  print(\"Degree \\(i + 1): \\(degree)\")\n}\n", "target": ">>> from functools import reduce\n>>> from operator import mul\n>>> def mfac(n, m): return reduce(mul, range(n, 0, -m))\n\n>>> for m in range(1, 11): print(\"%2i: %r\" % (m, [mfac(n, m) for n in range(1, 11)]))\n\n 1: [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n 2: [1, 2, 3, 8, 15, 48, 105, 384, 945, 3840]\n 3: [1, 2, 3, 4, 10, 18, 28, 80, 162, 280]\n 4: [1, 2, 3, 4, 5, 12, 21, 32, 45, 120]\n 5: [1, 2, 3, 4, 5, 6, 14, 24, 36, 50]\n 6: [1, 2, 3, 4, 5, 6, 7, 16, 27, 40]\n 7: [1, 2, 3, 4, 5, 6, 7, 8, 18, 30]\n 8: [1, 2, 3, 4, 5, 6, 7, 8, 9, 20]\n 9: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n10: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>>\n"}
{"id": 12003, "name": "Multifactorial", "source": "Translate Swift to Python: func multiFactorial(_ n: Int, k: Int) -> Int {\n  return stride(from: n, to: 0, by: -k).reduce(1, *)\n}\n\nlet multis = (1...5).map({degree in\n  (1...10).map({member in\n    multiFactorial(member, k: degree)\n  })\n})\n\nfor (i, degree) in multis.enumerated() {\n  print(\"Degree \\(i + 1): \\(degree)\")\n}\n", "target": ">>> from functools import reduce\n>>> from operator import mul\n>>> def mfac(n, m): return reduce(mul, range(n, 0, -m))\n\n>>> for m in range(1, 11): print(\"%2i: %r\" % (m, [mfac(n, m) for n in range(1, 11)]))\n\n 1: [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n 2: [1, 2, 3, 8, 15, 48, 105, 384, 945, 3840]\n 3: [1, 2, 3, 4, 10, 18, 28, 80, 162, 280]\n 4: [1, 2, 3, 4, 5, 12, 21, 32, 45, 120]\n 5: [1, 2, 3, 4, 5, 6, 14, 24, 36, 50]\n 6: [1, 2, 3, 4, 5, 6, 7, 16, 27, 40]\n 7: [1, 2, 3, 4, 5, 6, 7, 8, 18, 30]\n 8: [1, 2, 3, 4, 5, 6, 7, 8, 9, 20]\n 9: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n10: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>>\n"}
{"id": 12373, "name": "Shoelace formula for polygonal area", "source": "Translate Swift to C#: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n}\n\nextension Point: CustomStringConvertible {\n  var description: String {\n    return \"Point(x: \\(x), y: \\(y))\"\n  }\n}\n\nstruct Polygon {\n  var points: [Point]\n\n  var area: Double {\n    let xx = points.map({ $0.x })\n    let yy = points.map({ $0.y })\n    let overlace = zip(xx, yy.dropFirst() + yy.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n    let underlace = zip(yy, xx.dropFirst() + xx.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n\n    return abs(overlace - underlace) / 2\n  }\n\n  init(points: [Point]) {\n    self.points = points\n  }\n\n  init(points: [(Double, Double)]) {\n    self.init(points: points.map({ Point(x: $0.0, y: $0.1) }))\n  }\n}\n\nlet poly = Polygon(points: [\n  (3,4),\n  (5,11),\n  (12,8),\n  (9,5),\n  (5,6)\n])\n\nprint(\"\\(poly) area = \\(poly.area)\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ShoelaceFormula {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double ShoelaceArea(List<Point> v) {\n            int n = v.Count;\n            double a = 0.0;\n            for (int i = 0; i < n - 1; i++) {\n                a += v[i].Item1 * v[i + 1].Item2 - v[i + 1].Item1 * v[i].Item2;\n            }\n            return Math.Abs(a + v[n - 1].Item1 * v[0].Item2 - v[0].Item1 * v[n - 1].Item2) / 2.0;\n        }\n\n        static void Main(string[] args) {\n            List<Point> v = new List<Point>() {\n                new Point(3,4),\n                new Point(5,11),\n                new Point(12,8),\n                new Point(9,5),\n                new Point(5,6),\n            };\n            double area = ShoelaceArea(v);\n            Console.WriteLine(\"Given a polygon with vertices [{0}],\", string.Join(\", \", v));\n            Console.WriteLine(\"its area is {0}.\", area);\n        }\n    }\n}\n"}
{"id": 12374, "name": "Shoelace formula for polygonal area", "source": "Translate Swift to C#: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n}\n\nextension Point: CustomStringConvertible {\n  var description: String {\n    return \"Point(x: \\(x), y: \\(y))\"\n  }\n}\n\nstruct Polygon {\n  var points: [Point]\n\n  var area: Double {\n    let xx = points.map({ $0.x })\n    let yy = points.map({ $0.y })\n    let overlace = zip(xx, yy.dropFirst() + yy.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n    let underlace = zip(yy, xx.dropFirst() + xx.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n\n    return abs(overlace - underlace) / 2\n  }\n\n  init(points: [Point]) {\n    self.points = points\n  }\n\n  init(points: [(Double, Double)]) {\n    self.init(points: points.map({ Point(x: $0.0, y: $0.1) }))\n  }\n}\n\nlet poly = Polygon(points: [\n  (3,4),\n  (5,11),\n  (12,8),\n  (9,5),\n  (5,6)\n])\n\nprint(\"\\(poly) area = \\(poly.area)\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ShoelaceFormula {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double ShoelaceArea(List<Point> v) {\n            int n = v.Count;\n            double a = 0.0;\n            for (int i = 0; i < n - 1; i++) {\n                a += v[i].Item1 * v[i + 1].Item2 - v[i + 1].Item1 * v[i].Item2;\n            }\n            return Math.Abs(a + v[n - 1].Item1 * v[0].Item2 - v[0].Item1 * v[n - 1].Item2) / 2.0;\n        }\n\n        static void Main(string[] args) {\n            List<Point> v = new List<Point>() {\n                new Point(3,4),\n                new Point(5,11),\n                new Point(12,8),\n                new Point(9,5),\n                new Point(5,6),\n            };\n            double area = ShoelaceArea(v);\n            Console.WriteLine(\"Given a polygon with vertices [{0}],\", string.Join(\", \", v));\n            Console.WriteLine(\"its area is {0}.\", area);\n        }\n    }\n}\n"}
{"id": 12377, "name": "Shoelace formula for polygonal area", "source": "Translate Swift to Java: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n}\n\nextension Point: CustomStringConvertible {\n  var description: String {\n    return \"Point(x: \\(x), y: \\(y))\"\n  }\n}\n\nstruct Polygon {\n  var points: [Point]\n\n  var area: Double {\n    let xx = points.map({ $0.x })\n    let yy = points.map({ $0.y })\n    let overlace = zip(xx, yy.dropFirst() + yy.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n    let underlace = zip(yy, xx.dropFirst() + xx.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n\n    return abs(overlace - underlace) / 2\n  }\n\n  init(points: [Point]) {\n    self.points = points\n  }\n\n  init(points: [(Double, Double)]) {\n    self.init(points: points.map({ Point(x: $0.0, y: $0.1) }))\n  }\n}\n\nlet poly = Polygon(points: [\n  (3,4),\n  (5,11),\n  (12,8),\n  (9,5),\n  (5,6)\n])\n\nprint(\"\\(poly) area = \\(poly.area)\")\n", "target": "import java.util.List;\n\npublic class ShoelaceFormula {\n    private static class Point {\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%d, %d)\", x, y);\n        }\n    }\n\n    private static double shoelaceArea(List<Point> v) {\n        int n = v.size();\n        double a = 0.0;\n        for (int i = 0; i < n - 1; i++) {\n            a += v.get(i).x * v.get(i + 1).y - v.get(i + 1).x * v.get(i).y;\n        }\n        return Math.abs(a + v.get(n - 1).x * v.get(0).y - v.get(0).x * v.get(n - 1).y) / 2.0;\n    }\n\n    public static void main(String[] args) {\n        List<Point> v = List.of(\n            new Point(3, 4),\n            new Point(5, 11),\n            new Point(12, 8),\n            new Point(9, 5),\n            new Point(5, 6)\n        );\n        double area = shoelaceArea(v);\n        System.out.printf(\"Given a polygon with vertices %s,%n\", v);\n        System.out.printf(\"its area is %f,%n\", area);\n    }\n}\n"}
{"id": 12378, "name": "Shoelace formula for polygonal area", "source": "Translate Swift to Java: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n}\n\nextension Point: CustomStringConvertible {\n  var description: String {\n    return \"Point(x: \\(x), y: \\(y))\"\n  }\n}\n\nstruct Polygon {\n  var points: [Point]\n\n  var area: Double {\n    let xx = points.map({ $0.x })\n    let yy = points.map({ $0.y })\n    let overlace = zip(xx, yy.dropFirst() + yy.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n    let underlace = zip(yy, xx.dropFirst() + xx.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n\n    return abs(overlace - underlace) / 2\n  }\n\n  init(points: [Point]) {\n    self.points = points\n  }\n\n  init(points: [(Double, Double)]) {\n    self.init(points: points.map({ Point(x: $0.0, y: $0.1) }))\n  }\n}\n\nlet poly = Polygon(points: [\n  (3,4),\n  (5,11),\n  (12,8),\n  (9,5),\n  (5,6)\n])\n\nprint(\"\\(poly) area = \\(poly.area)\")\n", "target": "import java.util.List;\n\npublic class ShoelaceFormula {\n    private static class Point {\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%d, %d)\", x, y);\n        }\n    }\n\n    private static double shoelaceArea(List<Point> v) {\n        int n = v.size();\n        double a = 0.0;\n        for (int i = 0; i < n - 1; i++) {\n            a += v.get(i).x * v.get(i + 1).y - v.get(i + 1).x * v.get(i).y;\n        }\n        return Math.abs(a + v.get(n - 1).x * v.get(0).y - v.get(0).x * v.get(n - 1).y) / 2.0;\n    }\n\n    public static void main(String[] args) {\n        List<Point> v = List.of(\n            new Point(3, 4),\n            new Point(5, 11),\n            new Point(12, 8),\n            new Point(9, 5),\n            new Point(5, 6)\n        );\n        double area = shoelaceArea(v);\n        System.out.printf(\"Given a polygon with vertices %s,%n\", v);\n        System.out.printf(\"its area is %f,%n\", area);\n    }\n}\n"}
{"id": 12379, "name": "Shoelace formula for polygonal area", "source": "Translate Swift to Python: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n}\n\nextension Point: CustomStringConvertible {\n  var description: String {\n    return \"Point(x: \\(x), y: \\(y))\"\n  }\n}\n\nstruct Polygon {\n  var points: [Point]\n\n  var area: Double {\n    let xx = points.map({ $0.x })\n    let yy = points.map({ $0.y })\n    let overlace = zip(xx, yy.dropFirst() + yy.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n    let underlace = zip(yy, xx.dropFirst() + xx.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n\n    return abs(overlace - underlace) / 2\n  }\n\n  init(points: [Point]) {\n    self.points = points\n  }\n\n  init(points: [(Double, Double)]) {\n    self.init(points: points.map({ Point(x: $0.0, y: $0.1) }))\n  }\n}\n\nlet poly = Polygon(points: [\n  (3,4),\n  (5,11),\n  (12,8),\n  (9,5),\n  (5,6)\n])\n\nprint(\"\\(poly) area = \\(poly.area)\")\n", "target": ">>> def area_by_shoelace(x, y):\n    \"Assumes x,y points go around the polygon in one direction\"\n    return abs( sum(i * j for i, j in zip(x,             y[1:] + y[:1]))\n               -sum(i * j for i, j in zip(x[1:] + x[:1], y            ))) / 2\n\n>>> points = [(3,4), (5,11), (12,8), (9,5), (5,6)]\n>>> x, y = zip(*points)\n>>> area_by_shoelace(x, y)\n30.0\n>>>\n"}
{"id": 12380, "name": "Shoelace formula for polygonal area", "source": "Translate Swift to Python: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n}\n\nextension Point: CustomStringConvertible {\n  var description: String {\n    return \"Point(x: \\(x), y: \\(y))\"\n  }\n}\n\nstruct Polygon {\n  var points: [Point]\n\n  var area: Double {\n    let xx = points.map({ $0.x })\n    let yy = points.map({ $0.y })\n    let overlace = zip(xx, yy.dropFirst() + yy.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n    let underlace = zip(yy, xx.dropFirst() + xx.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n\n    return abs(overlace - underlace) / 2\n  }\n\n  init(points: [Point]) {\n    self.points = points\n  }\n\n  init(points: [(Double, Double)]) {\n    self.init(points: points.map({ Point(x: $0.0, y: $0.1) }))\n  }\n}\n\nlet poly = Polygon(points: [\n  (3,4),\n  (5,11),\n  (12,8),\n  (9,5),\n  (5,6)\n])\n\nprint(\"\\(poly) area = \\(poly.area)\")\n", "target": ">>> def area_by_shoelace(x, y):\n    \"Assumes x,y points go around the polygon in one direction\"\n    return abs( sum(i * j for i, j in zip(x,             y[1:] + y[:1]))\n               -sum(i * j for i, j in zip(x[1:] + x[:1], y            ))) / 2\n\n>>> points = [(3,4), (5,11), (12,8), (9,5), (5,6)]\n>>> x, y = zip(*points)\n>>> area_by_shoelace(x, y)\n30.0\n>>>\n"}
{"id": 12746, "name": "Sudoku", "source": "Translate Swift to C#: import Foundation\n\ntypealias SodukuPuzzle = [[Int]]\n\nclass Soduku {\n    let mBoardSize:Int!\n    let mBoxSize:Int!\n    var mBoard:SodukuPuzzle!\n    var mRowSubset:[[Bool]]!\n    var mColSubset:[[Bool]]!\n    var mBoxSubset:[[Bool]]!\n    \n    init(board:SodukuPuzzle) {\n        mBoard = board\n        mBoardSize = board.count\n        mBoxSize = Int(sqrt(Double(mBoardSize)))\n        mRowSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        mColSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        mBoxSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        initSubsets()\n    }\n    \n    func computeBoxNo(i:Int, _ j:Int) -> Int {\n        let boxRow = i / mBoxSize\n        let boxCol = j / mBoxSize\n        \n        return boxRow * mBoxSize + boxCol\n    }\n    \n    func initSubsets() {\n        for i in 0..<mBoard.count {\n            for j in 0..<mBoard.count {\n                let value = mBoard[i][j]\n                \n                if value != 0 {\n                    setSubsetValue(i, j, value, true);\n                }\n            }\n        }\n    }\n    \n    func isValid(i:Int, _ j:Int, var _ val:Int) -> Bool {\n        val--\n        let isPresent = mRowSubset[i][val] || mColSubset[j][val] || mBoxSubset[computeBoxNo(i, j)][val]\n        return !isPresent\n    }\n    \n    func printBoard() {\n        for i in 0..<mBoardSize {\n            if i % mBoxSize == 0 {\n                println(\" -----------------------\")\n            }\n            \n            for j in 0..<mBoardSize {\n                if j % mBoxSize == 0 {\n                    print(\"| \")\n                }\n                \n                print(mBoard[i][j] != 0 ? String(mBoard[i][j]) : \" \")\n                print(\" \")\n            }\n            \n            println(\"|\")\n        }\n        \n        println(\" -----------------------\")\n    }\n    \n    func setSubsetValue(i:Int, _ j:Int, _ value:Int, _ present:Bool) {\n        mRowSubset[i][value - 1] = present\n        mColSubset[j][value - 1] = present\n        mBoxSubset[computeBoxNo(i, j)][value - 1] = present\n    }\n    \n    func solve() {\n        solve(0, 0)\n    }\n    \n    func solve(var i:Int, var _ j:Int) -> Bool {\n        if i == mBoardSize {\n            i = 0\n            j++\n            if j == mBoardSize {\n                return true\n            }\n        }\n        \n        if mBoard[i][j] != 0 {\n            return solve(i + 1, j)\n        }\n        \n        for value in 1...mBoardSize {\n            if isValid(i, j, value) {\n                mBoard[i][j] = value\n                setSubsetValue(i, j, value, true)\n                \n                if solve(i + 1, j) {\n                    return true\n                }\n                \n                setSubsetValue(i, j, value, false)\n            }\n        }\n        \n        mBoard[i][j] = 0\n        return false\n    }\n}\n\nlet board = [\n    [4, 0, 0, 0, 0, 0, 0, 6, 0],\n    [5, 0, 0, 0, 8, 0, 9, 0, 0],\n    [3, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 2, 0, 7, 0, 0, 0, 0, 1],\n    [0, 9, 0, 0, 0, 0, 0, 4, 0],\n    [8, 0, 0, 0, 0, 3, 0, 5, 0],\n    [0, 0, 0, 2, 0, 0, 0, 0, 7],\n    [0, 0, 6, 0, 5, 0, 0, 0, 8],\n    [0, 1, 0, 0, 0, 0, 0, 0, 6]\n]\n\nlet puzzle = Soduku(board: board)\npuzzle.solve()\npuzzle.printBoard()\n", "target": "using System;\n\nclass SudokuSolver\n{\n    private int[] grid;\n\n    public SudokuSolver(String s)\n    {\n        grid = new int[81];\n        for (int i = 0; i < s.Length; i++)\n        {\n            grid[i] = int.Parse(s[i].ToString());\n        }\n    }\n\n    public void solve()\n    {\n        try\n        {\n            placeNumber(0);\n            Console.WriteLine(\"Unsolvable!\");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine(ex.Message);\n            Console.WriteLine(this);\n        }\n    }\n\n    public void placeNumber(int pos)\n    {\n        if (pos == 81)\n        {\n            throw new Exception(\"Finished!\");\n        }\n        if (grid[pos] > 0)\n        {\n            placeNumber(pos + 1);\n            return;\n        }\n        for (int n = 1; n <= 9; n++)\n        {\n            if (checkValidity(n, pos % 9, pos / 9))\n            {\n                grid[pos] = n;\n                placeNumber(pos + 1);\n                grid[pos] = 0;\n            }\n        }\n    }\n\n    public bool checkValidity(int val, int x, int y)\n    {\n        for (int i = 0; i < 9; i++)\n        {\n            if (grid[y * 9 + i] == val || grid[i * 9 + x] == val)\n                return false;\n        }\n        int startX = (x / 3) * 3;\n        int startY = (y / 3) * 3;\n        for (int i = startY; i < startY + 3; i++)\n        {\n            for (int j = startX; j < startX + 3; j++)\n            {\n                if (grid[i * 9 + j] == val)\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    public override string ToString()\n    {\n        string sb = \"\";\n        for (int i = 0; i < 9; i++)\n        {\n            for (int j = 0; j < 9; j++)\n            {\n                sb += (grid[i * 9 + j] + \" \");\n                if (j == 2 || j == 5)\n                    sb += (\"| \");\n            }\n            sb += ('\\n');\n            if (i == 2 || i == 5)\n                sb += (\"------+-------+------\\n\");\n        }\n        return sb;\n    }\n\n    public static void Main(String[] args)\n    {\n        new SudokuSolver(\"850002400\" +\n                         \"720000009\" +\n                         \"004000000\" +\n                         \"000107002\" +\n                         \"305000900\" +\n                         \"040000000\" +\n                         \"000080070\" +\n                         \"017000000\" +\n                         \"000036040\").solve();\n        Console.Read();\n    }\n}\n"}
{"id": 12748, "name": "Sudoku", "source": "Translate Swift to Java: import Foundation\n\ntypealias SodukuPuzzle = [[Int]]\n\nclass Soduku {\n    let mBoardSize:Int!\n    let mBoxSize:Int!\n    var mBoard:SodukuPuzzle!\n    var mRowSubset:[[Bool]]!\n    var mColSubset:[[Bool]]!\n    var mBoxSubset:[[Bool]]!\n    \n    init(board:SodukuPuzzle) {\n        mBoard = board\n        mBoardSize = board.count\n        mBoxSize = Int(sqrt(Double(mBoardSize)))\n        mRowSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        mColSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        mBoxSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        initSubsets()\n    }\n    \n    func computeBoxNo(i:Int, _ j:Int) -> Int {\n        let boxRow = i / mBoxSize\n        let boxCol = j / mBoxSize\n        \n        return boxRow * mBoxSize + boxCol\n    }\n    \n    func initSubsets() {\n        for i in 0..<mBoard.count {\n            for j in 0..<mBoard.count {\n                let value = mBoard[i][j]\n                \n                if value != 0 {\n                    setSubsetValue(i, j, value, true);\n                }\n            }\n        }\n    }\n    \n    func isValid(i:Int, _ j:Int, var _ val:Int) -> Bool {\n        val--\n        let isPresent = mRowSubset[i][val] || mColSubset[j][val] || mBoxSubset[computeBoxNo(i, j)][val]\n        return !isPresent\n    }\n    \n    func printBoard() {\n        for i in 0..<mBoardSize {\n            if i % mBoxSize == 0 {\n                println(\" -----------------------\")\n            }\n            \n            for j in 0..<mBoardSize {\n                if j % mBoxSize == 0 {\n                    print(\"| \")\n                }\n                \n                print(mBoard[i][j] != 0 ? String(mBoard[i][j]) : \" \")\n                print(\" \")\n            }\n            \n            println(\"|\")\n        }\n        \n        println(\" -----------------------\")\n    }\n    \n    func setSubsetValue(i:Int, _ j:Int, _ value:Int, _ present:Bool) {\n        mRowSubset[i][value - 1] = present\n        mColSubset[j][value - 1] = present\n        mBoxSubset[computeBoxNo(i, j)][value - 1] = present\n    }\n    \n    func solve() {\n        solve(0, 0)\n    }\n    \n    func solve(var i:Int, var _ j:Int) -> Bool {\n        if i == mBoardSize {\n            i = 0\n            j++\n            if j == mBoardSize {\n                return true\n            }\n        }\n        \n        if mBoard[i][j] != 0 {\n            return solve(i + 1, j)\n        }\n        \n        for value in 1...mBoardSize {\n            if isValid(i, j, value) {\n                mBoard[i][j] = value\n                setSubsetValue(i, j, value, true)\n                \n                if solve(i + 1, j) {\n                    return true\n                }\n                \n                setSubsetValue(i, j, value, false)\n            }\n        }\n        \n        mBoard[i][j] = 0\n        return false\n    }\n}\n\nlet board = [\n    [4, 0, 0, 0, 0, 0, 0, 6, 0],\n    [5, 0, 0, 0, 8, 0, 9, 0, 0],\n    [3, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 2, 0, 7, 0, 0, 0, 0, 1],\n    [0, 9, 0, 0, 0, 0, 0, 4, 0],\n    [8, 0, 0, 0, 0, 3, 0, 5, 0],\n    [0, 0, 0, 2, 0, 0, 0, 0, 7],\n    [0, 0, 6, 0, 5, 0, 0, 0, 8],\n    [0, 1, 0, 0, 0, 0, 0, 0, 6]\n]\n\nlet puzzle = Soduku(board: board)\npuzzle.solve()\npuzzle.printBoard()\n", "target": "public class Sudoku\n{\n    private int mBoard[][];\n    private int mBoardSize;\n    private int mBoxSize;\n    private boolean mRowSubset[][];\n    private boolean mColSubset[][];\n    private boolean mBoxSubset[][];\n \n    public Sudoku(int board[][]) {\n        mBoard = board;\n        mBoardSize = mBoard.length;\n        mBoxSize = (int)Math.sqrt(mBoardSize);\n        initSubsets();\n    }\n \n    public void initSubsets() {\n        mRowSubset = new boolean[mBoardSize][mBoardSize];\n        mColSubset = new boolean[mBoardSize][mBoardSize];\n        mBoxSubset = new boolean[mBoardSize][mBoardSize];\n        for(int i = 0; i < mBoard.length; i++) {\n            for(int j = 0; j < mBoard.length; j++) {\n                int value = mBoard[i][j];\n                if(value != 0) {\n                    setSubsetValue(i, j, value, true);\n                }\n            }\n        }\n    }\n \n    private void setSubsetValue(int i, int j, int value, boolean present) {\n        mRowSubset[i][value - 1] = present;\n        mColSubset[j][value - 1] = present;\n        mBoxSubset[computeBoxNo(i, j)][value - 1] = present;\n    }\n \n    public boolean solve() {\n        return solve(0, 0);\n    }\n \n    public boolean solve(int i, int j) {\n        if(i == mBoardSize) {\n            i = 0;\n            if(++j == mBoardSize) {\n                return true;\n            }\n        }\n        if(mBoard[i][j] != 0) {\n            return solve(i + 1, j);\n        }\n        for(int value = 1; value <= mBoardSize; value++) {\n            if(isValid(i, j, value)) {\n                mBoard[i][j] = value;\n                setSubsetValue(i, j, value, true);\n                if(solve(i + 1, j)) {\n                    return true;\n                }\n                setSubsetValue(i, j, value, false);\n            }\n        }\n \n        mBoard[i][j] = 0;\n        return false;\n    }\n \n    private boolean isValid(int i, int j, int val) {\n        val--;\n        boolean isPresent = mRowSubset[i][val] || mColSubset[j][val] || mBoxSubset[computeBoxNo(i, j)][val];\n        return !isPresent;\n    }\n \n    private int computeBoxNo(int i, int j) {\n        int boxRow = i / mBoxSize;\n        int boxCol = j / mBoxSize;\n        return boxRow * mBoxSize + boxCol;\n    }\n \n    public void print() {\n        for(int i = 0; i < mBoardSize; i++) {\n            if(i % mBoxSize == 0) {\n                System.out.println(\" -----------------------\");\n            }\n            for(int j = 0; j < mBoardSize; j++) {\n                if(j % mBoxSize == 0) {\n                    System.out.print(\"| \");\n                }\n                System.out.print(mBoard[i][j] != 0 ? ((Object) (Integer.valueOf(mBoard[i][j]))) : \"-\");\n                System.out.print(' ');\n            }\n \n            System.out.println(\"|\");\n        }\n \n        System.out.println(\" -----------------------\");\n    }\n\n    public static void main(String[] args) {\n        int[][] board = { \n            {8, 5, 0, 0, 0, 2, 4, 0, 0},\n            {7, 2, 0, 0, 0, 0, 0, 0, 9},\n            {0, 0, 4, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 1, 0, 7, 0, 0, 2},\n            {3, 0, 5, 0, 0, 0, 9, 0, 0},\n            {0, 4, 0, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 8, 0, 0, 7, 0},\n            {0, 1, 7, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 3, 6, 0, 4, 0}\n        };\n        Sudoku s = new Sudoku(board);\n        System.out.print(\"Starting grid:\\n\");\n        s.print();        \n        if (s.solve()) {\n            System.out.print(\"\\nSolution:\\n\");\n            s.print();\n        } else {\n            System.out.println(\"\\nUnsolvable!\");\n        }\n    }\n}\n"}
{"id": 12749, "name": "Sudoku", "source": "Translate Swift to Python: import Foundation\n\ntypealias SodukuPuzzle = [[Int]]\n\nclass Soduku {\n    let mBoardSize:Int!\n    let mBoxSize:Int!\n    var mBoard:SodukuPuzzle!\n    var mRowSubset:[[Bool]]!\n    var mColSubset:[[Bool]]!\n    var mBoxSubset:[[Bool]]!\n    \n    init(board:SodukuPuzzle) {\n        mBoard = board\n        mBoardSize = board.count\n        mBoxSize = Int(sqrt(Double(mBoardSize)))\n        mRowSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        mColSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        mBoxSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        initSubsets()\n    }\n    \n    func computeBoxNo(i:Int, _ j:Int) -> Int {\n        let boxRow = i / mBoxSize\n        let boxCol = j / mBoxSize\n        \n        return boxRow * mBoxSize + boxCol\n    }\n    \n    func initSubsets() {\n        for i in 0..<mBoard.count {\n            for j in 0..<mBoard.count {\n                let value = mBoard[i][j]\n                \n                if value != 0 {\n                    setSubsetValue(i, j, value, true);\n                }\n            }\n        }\n    }\n    \n    func isValid(i:Int, _ j:Int, var _ val:Int) -> Bool {\n        val--\n        let isPresent = mRowSubset[i][val] || mColSubset[j][val] || mBoxSubset[computeBoxNo(i, j)][val]\n        return !isPresent\n    }\n    \n    func printBoard() {\n        for i in 0..<mBoardSize {\n            if i % mBoxSize == 0 {\n                println(\" -----------------------\")\n            }\n            \n            for j in 0..<mBoardSize {\n                if j % mBoxSize == 0 {\n                    print(\"| \")\n                }\n                \n                print(mBoard[i][j] != 0 ? String(mBoard[i][j]) : \" \")\n                print(\" \")\n            }\n            \n            println(\"|\")\n        }\n        \n        println(\" -----------------------\")\n    }\n    \n    func setSubsetValue(i:Int, _ j:Int, _ value:Int, _ present:Bool) {\n        mRowSubset[i][value - 1] = present\n        mColSubset[j][value - 1] = present\n        mBoxSubset[computeBoxNo(i, j)][value - 1] = present\n    }\n    \n    func solve() {\n        solve(0, 0)\n    }\n    \n    func solve(var i:Int, var _ j:Int) -> Bool {\n        if i == mBoardSize {\n            i = 0\n            j++\n            if j == mBoardSize {\n                return true\n            }\n        }\n        \n        if mBoard[i][j] != 0 {\n            return solve(i + 1, j)\n        }\n        \n        for value in 1...mBoardSize {\n            if isValid(i, j, value) {\n                mBoard[i][j] = value\n                setSubsetValue(i, j, value, true)\n                \n                if solve(i + 1, j) {\n                    return true\n                }\n                \n                setSubsetValue(i, j, value, false)\n            }\n        }\n        \n        mBoard[i][j] = 0\n        return false\n    }\n}\n\nlet board = [\n    [4, 0, 0, 0, 0, 0, 0, 6, 0],\n    [5, 0, 0, 0, 8, 0, 9, 0, 0],\n    [3, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 2, 0, 7, 0, 0, 0, 0, 1],\n    [0, 9, 0, 0, 0, 0, 0, 4, 0],\n    [8, 0, 0, 0, 0, 3, 0, 5, 0],\n    [0, 0, 0, 2, 0, 0, 0, 0, 7],\n    [0, 0, 6, 0, 5, 0, 0, 0, 8],\n    [0, 1, 0, 0, 0, 0, 0, 0, 6]\n]\n\nlet puzzle = Soduku(board: board)\npuzzle.solve()\npuzzle.printBoard()\n", "target": "def initiate():\n    box.append([0, 1, 2, 9, 10, 11, 18, 19, 20])\n    box.append([3, 4, 5, 12, 13, 14, 21, 22, 23])\n    box.append([6, 7, 8, 15, 16, 17, 24, 25, 26])\n    box.append([27, 28, 29, 36, 37, 38, 45, 46, 47])\n    box.append([30, 31, 32, 39, 40, 41, 48, 49, 50])\n    box.append([33, 34, 35, 42, 43, 44, 51, 52, 53])\n    box.append([54, 55, 56, 63, 64, 65, 72, 73, 74])\n    box.append([57, 58, 59, 66, 67, 68, 75, 76, 77])\n    box.append([60, 61, 62, 69, 70, 71, 78, 79, 80])\n    for i in range(0, 81, 9):\n        row.append(range(i, i+9))\n    for i in range(9):\n        column.append(range(i, 80+i, 9))\n\ndef valid(n, pos):\n    current_row = pos/9\n    current_col = pos%9\n    current_box = (current_row/3)*3 + (current_col/3)\n    for i in row[current_row]:\n        if (grid[i] == n):\n            return False\n    for i in column[current_col]:\n        if (grid[i] == n):\n            return False\n    for i in box[current_box]:\n        if (grid[i] == n):\n            return False\n    return True\n\ndef solve():\n    i = 0\n    proceed = 1\n    while(i < 81):\n        if given[i]:\n            if proceed:\n                    i += 1\n            else:\n                i -= 1\n        else:\n            n = grid[i]\n            prev = grid[i]\n            while(n < 9):\n              if (n < 9):\n                  n += 1\n              if valid(n, i):\n                  grid[i] = n\n                  proceed = 1\n                  break\n            if (grid[i] == prev):\n               grid[i] = 0\n               proceed = 0\n            if proceed:\n               i += 1\n            else:\n               i -=1\n\ndef inputs():\n    nextt = 'T'\n    number = 0\n    pos = 0\n    while(not(nextt == 'N' or nextt == 'n')):\n        print \"Enter the position:\",\n        pos = int(raw_input())\n        given[pos - 1] = True\n        print \"Enter the numerical:\",\n        number = int(raw_input())\n        grid[pos - 1] = number\n        print \"Do you want to enter another given?(Y, for yes: N, for no)\"\n        nextt = raw_input()\n\n\ngrid = [0]*81\ngiven = [False]*81\nbox = []\nrow = []\ncolumn = []\ninitiate()\ninputs()\nsolve()\nfor i in range(9):\n    print grid[i*9:i*9+9]\nraw_input()\n"}
{"id": 12990, "name": "Hello world_Newline omission", "source": "Translate Swift to C#: print(\"Goodbye, World!\", terminator: \"\")\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        Console.WriteLine(\"Goodbye, World!\");\n\n        \n        Console.Write(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 12992, "name": "Hello world_Newline omission", "source": "Translate Swift to Java: print(\"Goodbye, World!\", terminator: \"\")\n", "target": "public class HelloWorld\n{\n public static void main(String[] args)\n {\n  System.out.print(\"Goodbye, World!\");\n }\n}\n"}
{"id": 13446, "name": "Vector products", "source": "Translate Swift to C#: import Foundation\n\ninfix operator \u2022 : MultiplicationPrecedence\ninfix operator \u00d7 : MultiplicationPrecedence\n\npublic struct Vector {\n  public var x = 0.0\n  public var y = 0.0\n  public var z = 0.0\n\n  public init(x: Double, y: Double, z: Double) {\n    (self.x, self.y, self.z) = (x, y, z)\n  }\n\n  public static func \u2022 (lhs: Vector, rhs: Vector) -> Double {\n    return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z\n  }\n\n  public static func \u00d7 (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      x: lhs.y * rhs.z - lhs.z * rhs.y,\n      y: lhs.z * rhs.x - lhs.x * rhs.z,\n      z: lhs.x * rhs.y - lhs.y * rhs.x\n    )\n  }\n}\n\nlet a = Vector(x: 3, y: 4, z: 5)\nlet b = Vector(x: 4, y: 3, z: 5)\nlet c = Vector(x: -5, y: -12, z: -13)\n\nprint(\"a: \\(a)\")\nprint(\"b: \\(b)\")\nprint(\"c: \\(c)\")\nprint()\nprint(\"a \u2022 b = \\(a \u2022 b)\")\nprint(\"a \u00d7 b = \\(a \u00d7 b)\")\nprint(\"a \u2022 (b \u00d7 c) = \\(a \u2022 (b \u00d7 c))\")\nprint(\"a \u00d7 (b \u00d7 c) = \\(a \u00d7 (b \u00d7 c))\")\n", "target": "using System;\nusing System.Windows.Media.Media3D;\n\nclass VectorProducts\n{\n    static double ScalarTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.DotProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static Vector3D VectorTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.CrossProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static void Main()\n    {\n        var a = new Vector3D(3, 4, 5);\n        var b = new Vector3D(4, 3, 5);\n        var c = new Vector3D(-5, -12, -13);\n\n        Console.WriteLine(Vector3D.DotProduct(a, b));\n        Console.WriteLine(Vector3D.CrossProduct(a, b));\n        Console.WriteLine(ScalarTripleProduct(a, b, c));\n        Console.WriteLine(VectorTripleProduct(a, b, c));\n    }\n}\n"}
{"id": 13447, "name": "Vector products", "source": "Translate Swift to C#: import Foundation\n\ninfix operator \u2022 : MultiplicationPrecedence\ninfix operator \u00d7 : MultiplicationPrecedence\n\npublic struct Vector {\n  public var x = 0.0\n  public var y = 0.0\n  public var z = 0.0\n\n  public init(x: Double, y: Double, z: Double) {\n    (self.x, self.y, self.z) = (x, y, z)\n  }\n\n  public static func \u2022 (lhs: Vector, rhs: Vector) -> Double {\n    return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z\n  }\n\n  public static func \u00d7 (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      x: lhs.y * rhs.z - lhs.z * rhs.y,\n      y: lhs.z * rhs.x - lhs.x * rhs.z,\n      z: lhs.x * rhs.y - lhs.y * rhs.x\n    )\n  }\n}\n\nlet a = Vector(x: 3, y: 4, z: 5)\nlet b = Vector(x: 4, y: 3, z: 5)\nlet c = Vector(x: -5, y: -12, z: -13)\n\nprint(\"a: \\(a)\")\nprint(\"b: \\(b)\")\nprint(\"c: \\(c)\")\nprint()\nprint(\"a \u2022 b = \\(a \u2022 b)\")\nprint(\"a \u00d7 b = \\(a \u00d7 b)\")\nprint(\"a \u2022 (b \u00d7 c) = \\(a \u2022 (b \u00d7 c))\")\nprint(\"a \u00d7 (b \u00d7 c) = \\(a \u00d7 (b \u00d7 c))\")\n", "target": "using System;\nusing System.Windows.Media.Media3D;\n\nclass VectorProducts\n{\n    static double ScalarTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.DotProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static Vector3D VectorTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.CrossProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static void Main()\n    {\n        var a = new Vector3D(3, 4, 5);\n        var b = new Vector3D(4, 3, 5);\n        var c = new Vector3D(-5, -12, -13);\n\n        Console.WriteLine(Vector3D.DotProduct(a, b));\n        Console.WriteLine(Vector3D.CrossProduct(a, b));\n        Console.WriteLine(ScalarTripleProduct(a, b, c));\n        Console.WriteLine(VectorTripleProduct(a, b, c));\n    }\n}\n"}
{"id": 13450, "name": "Vector products", "source": "Translate Swift to Java: import Foundation\n\ninfix operator \u2022 : MultiplicationPrecedence\ninfix operator \u00d7 : MultiplicationPrecedence\n\npublic struct Vector {\n  public var x = 0.0\n  public var y = 0.0\n  public var z = 0.0\n\n  public init(x: Double, y: Double, z: Double) {\n    (self.x, self.y, self.z) = (x, y, z)\n  }\n\n  public static func \u2022 (lhs: Vector, rhs: Vector) -> Double {\n    return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z\n  }\n\n  public static func \u00d7 (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      x: lhs.y * rhs.z - lhs.z * rhs.y,\n      y: lhs.z * rhs.x - lhs.x * rhs.z,\n      z: lhs.x * rhs.y - lhs.y * rhs.x\n    )\n  }\n}\n\nlet a = Vector(x: 3, y: 4, z: 5)\nlet b = Vector(x: 4, y: 3, z: 5)\nlet c = Vector(x: -5, y: -12, z: -13)\n\nprint(\"a: \\(a)\")\nprint(\"b: \\(b)\")\nprint(\"c: \\(c)\")\nprint()\nprint(\"a \u2022 b = \\(a \u2022 b)\")\nprint(\"a \u00d7 b = \\(a \u00d7 b)\")\nprint(\"a \u2022 (b \u00d7 c) = \\(a \u2022 (b \u00d7 c))\")\nprint(\"a \u00d7 (b \u00d7 c) = \\(a \u00d7 (b \u00d7 c))\")\n", "target": "public class VectorProds{\n    public static class Vector3D<T extends Number>{\n        private T a, b, c;\n\n        public Vector3D(T a, T b, T c){\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        public double dot(Vector3D<?> vec){\n            return (a.doubleValue() * vec.a.doubleValue() +\n                    b.doubleValue() * vec.b.doubleValue() +\n                    c.doubleValue() * vec.c.doubleValue());\n        }\n\n        public Vector3D<Double> cross(Vector3D<?> vec){\n            Double newA = b.doubleValue()*vec.c.doubleValue() - c.doubleValue()*vec.b.doubleValue();\n            Double newB = c.doubleValue()*vec.a.doubleValue() - a.doubleValue()*vec.c.doubleValue();\n            Double newC = a.doubleValue()*vec.b.doubleValue() - b.doubleValue()*vec.a.doubleValue();\n            return new Vector3D<Double>(newA, newB, newC);\n        }\n\n        public double scalTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.dot(vecB.cross(vecC));\n        }\n\n        public Vector3D<Double> vecTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.cross(vecB.cross(vecC));\n        }\n\n        @Override\n        public String toString(){\n            return \"<\" + a.toString() + \", \" + b.toString() + \", \" + c.toString() + \">\";\n        }\n    }\n\n    public static void main(String[] args){\n        Vector3D<Integer> a = new Vector3D<Integer>(3, 4, 5);\n        Vector3D<Integer> b = new Vector3D<Integer>(4, 3, 5);\n        Vector3D<Integer> c = new Vector3D<Integer>(-5, -12, -13);\n\n        System.out.println(a.dot(b));\n        System.out.println(a.cross(b));\n        System.out.println(a.scalTrip(b, c));\n        System.out.println(a.vecTrip(b, c));\n    }\n}\n"}
{"id": 13451, "name": "Vector products", "source": "Translate Swift to Java: import Foundation\n\ninfix operator \u2022 : MultiplicationPrecedence\ninfix operator \u00d7 : MultiplicationPrecedence\n\npublic struct Vector {\n  public var x = 0.0\n  public var y = 0.0\n  public var z = 0.0\n\n  public init(x: Double, y: Double, z: Double) {\n    (self.x, self.y, self.z) = (x, y, z)\n  }\n\n  public static func \u2022 (lhs: Vector, rhs: Vector) -> Double {\n    return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z\n  }\n\n  public static func \u00d7 (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      x: lhs.y * rhs.z - lhs.z * rhs.y,\n      y: lhs.z * rhs.x - lhs.x * rhs.z,\n      z: lhs.x * rhs.y - lhs.y * rhs.x\n    )\n  }\n}\n\nlet a = Vector(x: 3, y: 4, z: 5)\nlet b = Vector(x: 4, y: 3, z: 5)\nlet c = Vector(x: -5, y: -12, z: -13)\n\nprint(\"a: \\(a)\")\nprint(\"b: \\(b)\")\nprint(\"c: \\(c)\")\nprint()\nprint(\"a \u2022 b = \\(a \u2022 b)\")\nprint(\"a \u00d7 b = \\(a \u00d7 b)\")\nprint(\"a \u2022 (b \u00d7 c) = \\(a \u2022 (b \u00d7 c))\")\nprint(\"a \u00d7 (b \u00d7 c) = \\(a \u00d7 (b \u00d7 c))\")\n", "target": "public class VectorProds{\n    public static class Vector3D<T extends Number>{\n        private T a, b, c;\n\n        public Vector3D(T a, T b, T c){\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        public double dot(Vector3D<?> vec){\n            return (a.doubleValue() * vec.a.doubleValue() +\n                    b.doubleValue() * vec.b.doubleValue() +\n                    c.doubleValue() * vec.c.doubleValue());\n        }\n\n        public Vector3D<Double> cross(Vector3D<?> vec){\n            Double newA = b.doubleValue()*vec.c.doubleValue() - c.doubleValue()*vec.b.doubleValue();\n            Double newB = c.doubleValue()*vec.a.doubleValue() - a.doubleValue()*vec.c.doubleValue();\n            Double newC = a.doubleValue()*vec.b.doubleValue() - b.doubleValue()*vec.a.doubleValue();\n            return new Vector3D<Double>(newA, newB, newC);\n        }\n\n        public double scalTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.dot(vecB.cross(vecC));\n        }\n\n        public Vector3D<Double> vecTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.cross(vecB.cross(vecC));\n        }\n\n        @Override\n        public String toString(){\n            return \"<\" + a.toString() + \", \" + b.toString() + \", \" + c.toString() + \">\";\n        }\n    }\n\n    public static void main(String[] args){\n        Vector3D<Integer> a = new Vector3D<Integer>(3, 4, 5);\n        Vector3D<Integer> b = new Vector3D<Integer>(4, 3, 5);\n        Vector3D<Integer> c = new Vector3D<Integer>(-5, -12, -13);\n\n        System.out.println(a.dot(b));\n        System.out.println(a.cross(b));\n        System.out.println(a.scalTrip(b, c));\n        System.out.println(a.vecTrip(b, c));\n    }\n}\n"}
{"id": 13452, "name": "Vector products", "source": "Translate Swift to Python: import Foundation\n\ninfix operator \u2022 : MultiplicationPrecedence\ninfix operator \u00d7 : MultiplicationPrecedence\n\npublic struct Vector {\n  public var x = 0.0\n  public var y = 0.0\n  public var z = 0.0\n\n  public init(x: Double, y: Double, z: Double) {\n    (self.x, self.y, self.z) = (x, y, z)\n  }\n\n  public static func \u2022 (lhs: Vector, rhs: Vector) -> Double {\n    return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z\n  }\n\n  public static func \u00d7 (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      x: lhs.y * rhs.z - lhs.z * rhs.y,\n      y: lhs.z * rhs.x - lhs.x * rhs.z,\n      z: lhs.x * rhs.y - lhs.y * rhs.x\n    )\n  }\n}\n\nlet a = Vector(x: 3, y: 4, z: 5)\nlet b = Vector(x: 4, y: 3, z: 5)\nlet c = Vector(x: -5, y: -12, z: -13)\n\nprint(\"a: \\(a)\")\nprint(\"b: \\(b)\")\nprint(\"c: \\(c)\")\nprint()\nprint(\"a \u2022 b = \\(a \u2022 b)\")\nprint(\"a \u00d7 b = \\(a \u00d7 b)\")\nprint(\"a \u2022 (b \u00d7 c) = \\(a \u2022 (b \u00d7 c))\")\nprint(\"a \u00d7 (b \u00d7 c) = \\(a \u00d7 (b \u00d7 c))\")\n", "target": "def crossp(a, b):\n    \n    assert len(a) == len(b) == 3, 'For 3D vectors only'\n    a1, a2, a3 = a\n    b1, b2, b3 = b\n    return (a2*b3 - a3*b2, a3*b1 - a1*b3, a1*b2 - a2*b1)\n \ndef dotp(a,b):\n    \n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n \ndef scalartriplep(a, b, c):\n    \n    return dotp(a, crossp(b, c))\n \ndef vectortriplep(a, b, c):\n    \n    return crossp(a, crossp(b, c))\n \nif __name__ == '__main__':\n    a, b, c = (3, 4, 5), (4, 3, 5), (-5, -12, -13)\n    print(\"a = %r;  b = %r;  c = %r\" % (a, b, c))\n    print(\"a . b = %r\" % dotp(a,b))\n    print(\"a x b = %r\"  % (crossp(a,b),))\n    print(\"a . (b x c) = %r\" % scalartriplep(a, b, c))\n    print(\"a x (b x c) = %r\" % (vectortriplep(a, b, c),))\n"}
{"id": 13453, "name": "Vector products", "source": "Translate Swift to Python: import Foundation\n\ninfix operator \u2022 : MultiplicationPrecedence\ninfix operator \u00d7 : MultiplicationPrecedence\n\npublic struct Vector {\n  public var x = 0.0\n  public var y = 0.0\n  public var z = 0.0\n\n  public init(x: Double, y: Double, z: Double) {\n    (self.x, self.y, self.z) = (x, y, z)\n  }\n\n  public static func \u2022 (lhs: Vector, rhs: Vector) -> Double {\n    return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z\n  }\n\n  public static func \u00d7 (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      x: lhs.y * rhs.z - lhs.z * rhs.y,\n      y: lhs.z * rhs.x - lhs.x * rhs.z,\n      z: lhs.x * rhs.y - lhs.y * rhs.x\n    )\n  }\n}\n\nlet a = Vector(x: 3, y: 4, z: 5)\nlet b = Vector(x: 4, y: 3, z: 5)\nlet c = Vector(x: -5, y: -12, z: -13)\n\nprint(\"a: \\(a)\")\nprint(\"b: \\(b)\")\nprint(\"c: \\(c)\")\nprint()\nprint(\"a \u2022 b = \\(a \u2022 b)\")\nprint(\"a \u00d7 b = \\(a \u00d7 b)\")\nprint(\"a \u2022 (b \u00d7 c) = \\(a \u2022 (b \u00d7 c))\")\nprint(\"a \u00d7 (b \u00d7 c) = \\(a \u00d7 (b \u00d7 c))\")\n", "target": "def crossp(a, b):\n    \n    assert len(a) == len(b) == 3, 'For 3D vectors only'\n    a1, a2, a3 = a\n    b1, b2, b3 = b\n    return (a2*b3 - a3*b2, a3*b1 - a1*b3, a1*b2 - a2*b1)\n \ndef dotp(a,b):\n    \n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n \ndef scalartriplep(a, b, c):\n    \n    return dotp(a, crossp(b, c))\n \ndef vectortriplep(a, b, c):\n    \n    return crossp(a, crossp(b, c))\n \nif __name__ == '__main__':\n    a, b, c = (3, 4, 5), (4, 3, 5), (-5, -12, -13)\n    print(\"a = %r;  b = %r;  c = %r\" % (a, b, c))\n    print(\"a . b = %r\" % dotp(a,b))\n    print(\"a x b = %r\"  % (crossp(a,b),))\n    print(\"a . (b x c) = %r\" % scalartriplep(a, b, c))\n    print(\"a x (b x c) = %r\" % (vectortriplep(a, b, c),))\n"}
{"id": 13724, "name": "Hello world_Standard error", "source": "Translate Swift to C#: import Foundation\n\nlet out = NSOutputStream(toFileAtPath: \"/dev/stderr\", append: true)\nlet err = \"Goodbye, World!\".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nout?.open()\nlet success = out?.write(UnsafePointer<UInt8>(err!.bytes), maxLength: err!.length)\nout?.close()\n\nif let bytes = success {\n    println(\"\\nWrote \\(bytes) bytes\")\n}\n", "target": "static class StdErr\n{\n    static void Main(string[] args)\n    {\n        Console.Error.WriteLine(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 13726, "name": "Hello world_Standard error", "source": "Translate Swift to Java: import Foundation\n\nlet out = NSOutputStream(toFileAtPath: \"/dev/stderr\", append: true)\nlet err = \"Goodbye, World!\".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nout?.open()\nlet success = out?.write(UnsafePointer<UInt8>(err!.bytes), maxLength: err!.length)\nout?.close()\n\nif let bytes = success {\n    println(\"\\nWrote \\(bytes) bytes\")\n}\n", "target": "public class Err{\n   public static void main(String[] args){\n      System.err.println(\"Goodbye, World!\");\n   }\n}\n"}
{"id": 13727, "name": "Hello world_Standard error", "source": "Translate Swift to Python: import Foundation\n\nlet out = NSOutputStream(toFileAtPath: \"/dev/stderr\", append: true)\nlet err = \"Goodbye, World!\".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nout?.open()\nlet success = out?.write(UnsafePointer<UInt8>(err!.bytes), maxLength: err!.length)\nout?.close()\n\nif let bytes = success {\n    println(\"\\nWrote \\(bytes) bytes\")\n}\n", "target": "import sys\n\nprint >> sys.stderr, \"Goodbye, World!\"\n"}
{"id": 14822, "name": "Cholesky decomposition", "source": "Translate Swift to C#: func cholesky(matrix: [Double], n: Int) -> [Double] {\n  var res = [Double](repeating: 0, count: matrix.count)\n\n  for i in 0..<n {\n    for j in 0..<i+1 {\n      var s = 0.0\n\n      for k in 0..<j {\n        s += res[i * n + k] * res[j * n + k]\n      }\n\n      if i == j {\n        res[i * n + j] = (matrix[i * n + i] - s).squareRoot()\n      } else {\n        res[i * n + j] = (1.0 / res[j * n + j] * (matrix[i * n + j] - s))\n      }\n    }\n  }\n\n  return res\n}\n\nfunc printMatrix(_ matrix: [Double], n: Int) {\n  for i in 0..<n {\n    for j in 0..<n {\n      print(matrix[i * n + j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\nlet res1 = cholesky(\n  matrix: [25.0, 15.0, -5.0,\n           15.0, 18.0,  0.0,\n           -5.0,  0.0, 11.0],\n  n: 3\n)\n\nlet res2 = cholesky(\n  matrix: [18.0, 22.0,  54.0,  42.0,\n           22.0, 70.0,  86.0,  62.0,\n           54.0, 86.0, 174.0, 134.0,\n           42.0, 62.0, 134.0, 106.0],\n  n: 4\n)\n\nprintMatrix(res1, n: 3)\nprint()\nprintMatrix(res2, n: 4)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Cholesky\n{\n    class Program\n    {\n        \n        \n        \n        \n        static void Main(string[] args)\n        {\n            double[,] test1 = new double[,]\n            {\n                {25, 15, -5},\n                {15, 18, 0},\n                {-5, 0, 11},\n            };\n\n            double[,] test2 = new double[,]\n            {\n                {18, 22, 54, 42},\n                {22, 70, 86, 62},\n                {54, 86, 174, 134},\n                {42, 62, 134, 106},\n            };\n\n            double[,] chol1 = Cholesky(test1);\n            double[,] chol2 = Cholesky(test2);\n\n            Console.WriteLine(\"Test 1: \");\n            Print(test1);\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Lower Cholesky 1: \");\n            Print(chol1);\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Test 2: \");\n            Print(test2);\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Lower Cholesky 2: \");\n            Print(chol2);\n\n        }\n\n        public static void Print(double[,] a)\n        {\n            int n = (int)Math.Sqrt(a.Length);\n\n            StringBuilder sb = new StringBuilder();\n            for (int r = 0; r < n; r++)\n            {\n                string s = \"\";\n                for (int c = 0; c < n; c++)\n                {\n                    s += a[r, c].ToString(\"f5\").PadLeft(9) + \",\";\n                }\n                sb.AppendLine(s);\n            }\n\n            Console.WriteLine(sb.ToString());\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        public static double[,] Cholesky(double[,] a)\n        {\n            int n = (int)Math.Sqrt(a.Length);\n\n            double[,] ret = new double[n, n];\n            for (int r = 0; r < n; r++)\n                for (int c = 0; c <= r; c++)\n                {\n                    if (c == r)\n                    {\n                        double sum = 0;\n                        for (int j = 0; j < c; j++)\n                        {\n                            sum += ret[c, j] * ret[c, j];\n                        }\n                        ret[c, c] = Math.Sqrt(a[c, c] - sum);\n                    }\n                    else\n                    {\n                        double sum = 0;\n                        for (int j = 0; j < c; j++)\n                            sum += ret[r, j] * ret[c, j];\n                        ret[r, c] = 1.0 / ret[c, c] * (a[r, c] - sum);\n                    }\n                }\n\n            return ret;\n        }\n    }\n}\n"}
{"id": 14824, "name": "Cholesky decomposition", "source": "Translate Swift to Java: func cholesky(matrix: [Double], n: Int) -> [Double] {\n  var res = [Double](repeating: 0, count: matrix.count)\n\n  for i in 0..<n {\n    for j in 0..<i+1 {\n      var s = 0.0\n\n      for k in 0..<j {\n        s += res[i * n + k] * res[j * n + k]\n      }\n\n      if i == j {\n        res[i * n + j] = (matrix[i * n + i] - s).squareRoot()\n      } else {\n        res[i * n + j] = (1.0 / res[j * n + j] * (matrix[i * n + j] - s))\n      }\n    }\n  }\n\n  return res\n}\n\nfunc printMatrix(_ matrix: [Double], n: Int) {\n  for i in 0..<n {\n    for j in 0..<n {\n      print(matrix[i * n + j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\nlet res1 = cholesky(\n  matrix: [25.0, 15.0, -5.0,\n           15.0, 18.0,  0.0,\n           -5.0,  0.0, 11.0],\n  n: 3\n)\n\nlet res2 = cholesky(\n  matrix: [18.0, 22.0,  54.0,  42.0,\n           22.0, 70.0,  86.0,  62.0,\n           54.0, 86.0, 174.0, 134.0,\n           42.0, 62.0, 134.0, 106.0],\n  n: 4\n)\n\nprintMatrix(res1, n: 3)\nprint()\nprintMatrix(res2, n: 4)\n", "target": "import java.util.Arrays;\n\npublic class Cholesky {\n\tpublic static double[][] chol(double[][] a){\n\t\tint m = a.length;\n\t\tdouble[][] l = new double[m][m]; \n\t\tfor(int i = 0; i< m;i++){\n\t\t\tfor(int k = 0; k < (i+1); k++){\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tsum += l[i][j] * l[k][j];\n\t\t\t\t}\n\t\t\t\tl[i][k] = (i == k) ? Math.sqrt(a[i][i] - sum) :\n\t\t\t\t\t(1.0 / l[k][k] * (a[i][k] - sum));\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tdouble[][] test1 = {{25, 15, -5},\n\t\t\t\t\t\t\t{15, 18, 0},\n\t\t\t\t\t\t\t{-5, 0, 11}};\n\t\tSystem.out.println(Arrays.deepToString(chol(test1)));\n\t\tdouble[][] test2 = {{18, 22, 54, 42},\n\t\t\t\t\t\t\t{22, 70, 86, 62},\n\t\t\t\t\t\t\t{54, 86, 174, 134},\n\t\t\t\t\t\t\t{42, 62, 134, 106}};\n\t\tSystem.out.println(Arrays.deepToString(chol(test2)));\n\t}\n}\n"}
{"id": 14825, "name": "Cholesky decomposition", "source": "Translate Swift to Python: func cholesky(matrix: [Double], n: Int) -> [Double] {\n  var res = [Double](repeating: 0, count: matrix.count)\n\n  for i in 0..<n {\n    for j in 0..<i+1 {\n      var s = 0.0\n\n      for k in 0..<j {\n        s += res[i * n + k] * res[j * n + k]\n      }\n\n      if i == j {\n        res[i * n + j] = (matrix[i * n + i] - s).squareRoot()\n      } else {\n        res[i * n + j] = (1.0 / res[j * n + j] * (matrix[i * n + j] - s))\n      }\n    }\n  }\n\n  return res\n}\n\nfunc printMatrix(_ matrix: [Double], n: Int) {\n  for i in 0..<n {\n    for j in 0..<n {\n      print(matrix[i * n + j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\nlet res1 = cholesky(\n  matrix: [25.0, 15.0, -5.0,\n           15.0, 18.0,  0.0,\n           -5.0,  0.0, 11.0],\n  n: 3\n)\n\nlet res2 = cholesky(\n  matrix: [18.0, 22.0,  54.0,  42.0,\n           22.0, 70.0,  86.0,  62.0,\n           54.0, 86.0, 174.0, 134.0,\n           42.0, 62.0, 134.0, 106.0],\n  n: 4\n)\n\nprintMatrix(res1, n: 3)\nprint()\nprintMatrix(res2, n: 4)\n", "target": "from __future__ import print_function\n\nfrom pprint import pprint\nfrom math import sqrt\n\n\ndef cholesky(A):\n    L = [[0.0] * len(A) for _ in xrange(len(A))]\n    for i in xrange(len(A)):\n        for j in xrange(i+1):\n            s = sum(L[i][k] * L[j][k] for k in xrange(j))\n            L[i][j] = sqrt(A[i][i] - s) if (i == j) else \\\n                      (1.0 / L[j][j] * (A[i][j] - s))\n    return L\n\nif __name__ == \"__main__\":\n    m1 = [[25, 15, -5],\n          [15, 18,  0],\n          [-5,  0, 11]]\n    pprint(cholesky(m1))\n    print()\n    \n    m2 = [[18, 22,  54,  42],\n          [22, 70,  86,  62],\n          [54, 86, 174, 134],\n          [42, 62, 134, 106]]\n    pprint(cholesky(m2), width=120)\n"}
{"id": 15031, "name": "Almost prime", "source": "Translate Swift to C#: struct KPrimeGen: Sequence, IteratorProtocol {\n  let k: Int\n  private(set) var n: Int\n\n  private func isKPrime() -> Bool {\n    var primes = 0\n    var f = 2\n    var rem = n\n\n    while primes < k && rem > 1 {\n      while rem % f == 0 && rem > 1 {\n        rem /= f\n        primes += 1\n      }\n\n      f += 1\n    }\n\n    return rem == 1 && primes == k\n  }\n\n  mutating func next() -> Int? {\n    n += 1\n\n    while !isKPrime() {\n      n += 1\n    }\n\n    return n\n  }\n}\n\nfor k in 1..<6 {\n  print(\"\\(k): \\(Array(KPrimeGen(k: k, n: 1).lazy.prefix(10)))\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AlmostPrime\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            foreach (int k in Enumerable.Range(1, 5))\n            {\n                KPrime kprime = new KPrime() { K = k };\n                Console.WriteLine(\"k = {0}: {1}\",\n                    k, string.Join<int>(\" \", kprime.GetFirstN(10)));\n            }\n        }\n    }\n\n    class KPrime\n    {\n        public int K { get; set; }\n\n        public bool IsKPrime(int number)\n        {\n            int primes = 0;\n            for (int p = 2; p * p <= number && primes < K; ++p)\n            {\n                while (number % p == 0 && primes < K)\n                {\n                    number /= p;\n                    ++primes;\n                }\n            }\n            if (number > 1)\n            {\n                ++primes;\n            }\n            return primes == K;\n        }\n\n        public List<int> GetFirstN(int n)\n        {\n            List<int> result = new List<int>();\n            for (int number = 2; result.Count < n; ++number)\n            {\n                if (IsKPrime(number))\n                {\n                    result.Add(number);\n                }\n            }\n            return result;\n        }\n    }\n}\n"}
{"id": 15033, "name": "Almost prime", "source": "Translate Swift to Java: struct KPrimeGen: Sequence, IteratorProtocol {\n  let k: Int\n  private(set) var n: Int\n\n  private func isKPrime() -> Bool {\n    var primes = 0\n    var f = 2\n    var rem = n\n\n    while primes < k && rem > 1 {\n      while rem % f == 0 && rem > 1 {\n        rem /= f\n        primes += 1\n      }\n\n      f += 1\n    }\n\n    return rem == 1 && primes == k\n  }\n\n  mutating func next() -> Int? {\n    n += 1\n\n    while !isKPrime() {\n      n += 1\n    }\n\n    return n\n  }\n}\n\nfor k in 1..<6 {\n  print(\"\\(k): \\(Array(KPrimeGen(k: k, n: 1).lazy.prefix(10)))\")\n}\n", "target": "public class AlmostPrime {\n    public static void main(String[] args) {\n        for (int k = 1; k <= 5; k++) {\n            System.out.print(\"k = \" + k + \":\");\n\n            for (int i = 2, c = 0; c < 10; i++) {\n                if (kprime(i, k)) {\n                    System.out.print(\" \" + i);\n                    c++;\n                }\n            }\n\n            System.out.println(\"\");\n        }\n    }\n\n    public static boolean kprime(int n, int k) {\n        int f = 0;\n        for (int p = 2; f < k && p * p <= n; p++) {\n            while (n % p == 0) {\n                n /= p;\n                f++;\n            }\n        }\n        return f + ((n > 1) ? 1 : 0) == k;\n    }\n}\n"}
{"id": 15034, "name": "Almost prime", "source": "Translate Swift to Python: struct KPrimeGen: Sequence, IteratorProtocol {\n  let k: Int\n  private(set) var n: Int\n\n  private func isKPrime() -> Bool {\n    var primes = 0\n    var f = 2\n    var rem = n\n\n    while primes < k && rem > 1 {\n      while rem % f == 0 && rem > 1 {\n        rem /= f\n        primes += 1\n      }\n\n      f += 1\n    }\n\n    return rem == 1 && primes == k\n  }\n\n  mutating func next() -> Int? {\n    n += 1\n\n    while !isKPrime() {\n      n += 1\n    }\n\n    return n\n  }\n}\n\nfor k in 1..<6 {\n  print(\"\\(k): \\(Array(KPrimeGen(k: k, n: 1).lazy.prefix(10)))\")\n}\n", "target": "from prime_decomposition import decompose\nfrom itertools import islice, count\ntry: \n    from functools import reduce\nexcept: \n    pass\n\n\ndef almostprime(n, k=2):\n    d = decompose(n)\n    try:\n        terms = [next(d) for i in range(k)]\n        return reduce(int.__mul__, terms, 1) == n\n    except:\n        return False\n\nif __name__ == '__main__':\n    for k in range(1,6):\n        print('%i: %r' % (k, list(islice((n for n in count() if almostprime(n, k)), 10))))\n"}
{"id": 15311, "name": "Integer comparison", "source": "Translate Swift to C#: import Cocoa\n\nvar input = NSFileHandle.fileHandleWithStandardInput()\n\nprintln(\"Enter two integers separated by a space: \")\n\nlet data = input.availableData\nlet stringArray = NSString(data: data, encoding: NSUTF8StringEncoding)?.componentsSeparatedByString(\" \")\nvar a:Int!\nvar b:Int!\nif (stringArray?.count == 2) {\n    a = stringArray![0].integerValue\n    b = stringArray![1].integerValue\n}\nif (a==b)  {println(\"\\(a) equals \\(b)\")}\nif (a < b) {println(\"\\(a) is less than \\(b)\")}\nif (a > b) {println(\"\\(a) is greater than \\(b)\")}\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        int a = int.Parse(Console.ReadLine());\n        int b = int.Parse(Console.ReadLine());\n        if (a < b)\n            Console.WriteLine(\"{0} is less than {1}\", a, b);\n        if (a == b)\n            Console.WriteLine(\"{0} equals {1}\", a, b);\n        if (a > b)\n            Console.WriteLine(\"{0} is greater than {1}\", a, b);\n    }\n}\n"}
{"id": 15313, "name": "Integer comparison", "source": "Translate Swift to Java: import Cocoa\n\nvar input = NSFileHandle.fileHandleWithStandardInput()\n\nprintln(\"Enter two integers separated by a space: \")\n\nlet data = input.availableData\nlet stringArray = NSString(data: data, encoding: NSUTF8StringEncoding)?.componentsSeparatedByString(\" \")\nvar a:Int!\nvar b:Int!\nif (stringArray?.count == 2) {\n    a = stringArray![0].integerValue\n    b = stringArray![1].integerValue\n}\nif (a==b)  {println(\"\\(a) equals \\(b)\")}\nif (a < b) {println(\"\\(a) is less than \\(b)\")}\nif (a > b) {println(\"\\(a) is greater than \\(b)\")}\n", "target": "import java.io.*;\n\npublic class compInt {\n   public static void main(String[] args) {\n       try {\n           BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n           int nbr1 = Integer.parseInt(in.readLine());\n           int nbr2 = Integer.parseInt(in.readLine());\n\n           if(nbr1<nbr2)\n               System.out.println(nbr1 + \" is less than \" + nbr2);\n\n           if(nbr1>nbr2)\n                System.out.println(nbr1 + \" is greater than \" + nbr2);\n\n           if(nbr1==nbr2)\n                System.out.println(nbr1 + \" is equal to \" + nbr2);\n       } catch(IOException e) { }\n   }\n}\n"}
{"id": 15314, "name": "Integer comparison", "source": "Translate Swift to Python: import Cocoa\n\nvar input = NSFileHandle.fileHandleWithStandardInput()\n\nprintln(\"Enter two integers separated by a space: \")\n\nlet data = input.availableData\nlet stringArray = NSString(data: data, encoding: NSUTF8StringEncoding)?.componentsSeparatedByString(\" \")\nvar a:Int!\nvar b:Int!\nif (stringArray?.count == 2) {\n    a = stringArray![0].integerValue\n    b = stringArray![1].integerValue\n}\nif (a==b)  {println(\"\\(a) equals \\(b)\")}\nif (a < b) {println(\"\\(a) is less than \\(b)\")}\nif (a > b) {println(\"\\(a) is greater than \\(b)\")}\n", "target": "let a = input('Enter value of a: ')\nlet b = input('Enter value of b: ')\n\nif a < b:\n    print 'a is less than b'\nelif a > b:\n    print 'a is greater than b'\nelif a == b:\n    print 'a is equal to b'\n"}
{"id": 15524, "name": "Environment variables", "source": "Translate Swift to C#: print(\"USER: \\(ProcessInfo.processInfo.environment[\"USER\"] ?? \"Not set\")\")\nprint(\"PATH: \\(ProcessInfo.processInfo.environment[\"PATH\"] ?? \"Not set\")\")\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main() {\n            string temp = Environment.GetEnvironmentVariable(\"TEMP\");\n            Console.WriteLine(\"TEMP is \" + temp);\n        }\n    }\n}\n"}
{"id": 15526, "name": "Environment variables", "source": "Translate Swift to Java: print(\"USER: \\(ProcessInfo.processInfo.environment[\"USER\"] ?? \"Not set\")\")\nprint(\"PATH: \\(ProcessInfo.processInfo.environment[\"PATH\"] ?? \"Not set\")\")\n", "target": "System.getenv(\"HOME\") \nSystem.getenv()       \n"}
{"id": 15527, "name": "Environment variables", "source": "Translate Swift to Python: print(\"USER: \\(ProcessInfo.processInfo.environment[\"USER\"] ?? \"Not set\")\")\nprint(\"PATH: \\(ProcessInfo.processInfo.environment[\"PATH\"] ?? \"Not set\")\")\n", "target": "import os\nos.environ['HOME']\n"}
{"id": 15774, "name": "Substring", "source": "Translate Swift to C#: let string = \"Hello, Swift language\"\nlet (n, m) = (5, 4)\n\n\ndo {\n  let start = string.startIndex.advancedBy(n)\n  let end = start.advancedBy(m)\n  \n  _ = string[start..<end]\n  \n  string.substringWithRange(start..<end)\n}\n\n\ndo {\n  \n  _ = String(\n    string.characters.suffix(string.characters.count - n)\n  )\n  \n  _ = string.substringFromIndex(string.startIndex.advancedBy(n))\n}\n\n\ndo {\n  \n  _ = String(\n    string.characters.prefix(\n      string.characters.count.predecessor()\n    )\n  )\n  \n  _ = string.substringToIndex(string.endIndex.predecessor())\n}\n\n\ndo {\n  \n  let character = Character(\"l\")\n  guard let characterIndex = string.characters.indexOf(character) else {\n    fatalError(\"Index of '\\(character)' character not found.\")\n  }\n  let endIndex = characterIndex.advancedBy(m)\n  _ = string[characterIndex..<endIndex]\n}\n\n\ndo {\n  \n  let substring = \"Swift\"\n  guard let range = string.rangeOfString(substring) else {\n    fatalError(\"Range of substring \\(substring) not found\")\n  }\n  let start = range.startIndex\n  let end = start.advancedBy(m)\n  string[start..<end]\n}\n", "target": "using System;\nnamespace SubString\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string s = \"0123456789\";\n            const int n = 3;\n            const int m = 2;\n            const char c = '3';\n            const string z = \"345\";\n\n            \n            Console.WriteLine(s.Substring(n, m));\n            \n            Console.WriteLine(s.Substring(n, s.Length - n));\n            \n            Console.WriteLine(s.Substring(0, s.Length - 1));\n            \n            Console.WriteLine(s.Substring(s.IndexOf(c), m));\n            \n            Console.WriteLine(s.Substring(s.IndexOf(z), m));\n        }\n    }\n}\n"}
{"id": 15776, "name": "Substring", "source": "Translate Swift to Java: let string = \"Hello, Swift language\"\nlet (n, m) = (5, 4)\n\n\ndo {\n  let start = string.startIndex.advancedBy(n)\n  let end = start.advancedBy(m)\n  \n  _ = string[start..<end]\n  \n  string.substringWithRange(start..<end)\n}\n\n\ndo {\n  \n  _ = String(\n    string.characters.suffix(string.characters.count - n)\n  )\n  \n  _ = string.substringFromIndex(string.startIndex.advancedBy(n))\n}\n\n\ndo {\n  \n  _ = String(\n    string.characters.prefix(\n      string.characters.count.predecessor()\n    )\n  )\n  \n  _ = string.substringToIndex(string.endIndex.predecessor())\n}\n\n\ndo {\n  \n  let character = Character(\"l\")\n  guard let characterIndex = string.characters.indexOf(character) else {\n    fatalError(\"Index of '\\(character)' character not found.\")\n  }\n  let endIndex = characterIndex.advancedBy(m)\n  _ = string[characterIndex..<endIndex]\n}\n\n\ndo {\n  \n  let substring = \"Swift\"\n  guard let range = string.rangeOfString(substring) else {\n    fatalError(\"Range of substring \\(substring) not found\")\n  }\n  let start = range.startIndex\n  let end = start.advancedBy(m)\n  string[start..<end]\n}\n", "target": "public static String Substring(String str, int n, int m){\n    return str.substring(n, n+m);\n}\npublic static String Substring(String str, int n){\n    return str.substring(n);\n}\npublic static String Substring(String str){\n    return str.substring(0, str.length()-1);\n}\npublic static String Substring(String str, char c, int m){\n    return str.substring(str.indexOf(c), str.indexOf(c)+m+1);\n}\npublic static String Substring(String str, String sub, int m){\n    return str.substring(str.indexOf(sub), str.indexOf(sub)+m+1);\n}\n"}
{"id": 15777, "name": "Substring", "source": "Translate Swift to Python: let string = \"Hello, Swift language\"\nlet (n, m) = (5, 4)\n\n\ndo {\n  let start = string.startIndex.advancedBy(n)\n  let end = start.advancedBy(m)\n  \n  _ = string[start..<end]\n  \n  string.substringWithRange(start..<end)\n}\n\n\ndo {\n  \n  _ = String(\n    string.characters.suffix(string.characters.count - n)\n  )\n  \n  _ = string.substringFromIndex(string.startIndex.advancedBy(n))\n}\n\n\ndo {\n  \n  _ = String(\n    string.characters.prefix(\n      string.characters.count.predecessor()\n    )\n  )\n  \n  _ = string.substringToIndex(string.endIndex.predecessor())\n}\n\n\ndo {\n  \n  let character = Character(\"l\")\n  guard let characterIndex = string.characters.indexOf(character) else {\n    fatalError(\"Index of '\\(character)' character not found.\")\n  }\n  let endIndex = characterIndex.advancedBy(m)\n  _ = string[characterIndex..<endIndex]\n}\n\n\ndo {\n  \n  let substring = \"Swift\"\n  guard let range = string.rangeOfString(substring) else {\n    fatalError(\"Range of substring \\(substring) not found\")\n  }\n  let start = range.startIndex\n  let end = start.advancedBy(m)\n  string[start..<end]\n}\n", "target": ">>> s = 'abcdefgh'\n>>> n, m, char, chars = 2, 3, 'd', 'cd'\n>>> \n>>> s[n-1:n+m-1]\n'bcd'\n>>> \n>>> s[n-1:]\n'bcdefgh'\n>>> \n>>> s[:-1]\n'abcdefg'\n>>> \n>>> indx = s.index(char)\n>>> s[indx:indx+m]\n'def'\n>>> \n>>> indx = s.index(chars)\n>>> s[indx:indx+m]\n'cde'\n>>>\n"}
{"id": 16054, "name": "Evaluate binomial coefficients", "source": "Translate Swift to C#: func factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nfunc binomial<T: BinaryInteger>(_ x: (n: T, k: T)) -> T {\n  let nFac = factorial(x.n)\n  let kFac = factorial(x.k)\n\n  return nFac / (factorial(x.n - x.k) * kFac)\n}\n\nprint(\"binomial(\\(5), \\(3)) = \\(binomial((5, 3)))\")\nprint(\"binomial(\\(20), \\(11)) = \\(binomial((20, 11)))\")\n", "target": "using System;\n\nnamespace BinomialCoefficients\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ulong n = 1000000, k = 3;\n            ulong result = biCoefficient(n, k);\n            Console.WriteLine(\"The Binomial Coefficient of {0}, and {1}, is equal to: {2}\", n, k, result);\n            Console.ReadLine();\n        }\n\n        static int fact(int n)\n        {\n            if (n == 0) return 1;\n            else return n * fact(n - 1);\n        }\n\n        static ulong biCoefficient(ulong n, ulong k)\n        {\n            if (k > n - k)\n            {\n                k = n - k;\n            }\n\n            ulong c = 1;\n            for (uint i = 0; i < k; i++)\n            {\n                c = c * (n - i);\n                c = c / (i + 1);\n            }\n            return c;\n        }\n    }\n}\n"}
{"id": 16056, "name": "Evaluate binomial coefficients", "source": "Translate Swift to Java: func factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nfunc binomial<T: BinaryInteger>(_ x: (n: T, k: T)) -> T {\n  let nFac = factorial(x.n)\n  let kFac = factorial(x.k)\n\n  return nFac / (factorial(x.n - x.k) * kFac)\n}\n\nprint(\"binomial(\\(5), \\(3)) = \\(binomial((5, 3)))\")\nprint(\"binomial(\\(20), \\(11)) = \\(binomial((20, 11)))\")\n", "target": "public class Binomial {\n\n    \n    private static long binomialInt(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        long binom = 1;\n        for (int i = 1; i <= k; i++)\n            binom = binom * (n + 1 - i) / i;\n        return binom;\n    }\n\n    \n    private static Object binomialIntReliable(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        long binom = 1;\n        for (int i = 1; i <= k; i++) {\n            try {\n                binom = Math.multiplyExact(binom, n + 1 - i) / i;\n            } catch (ArithmeticException e) {\n                return \"overflow\";\n            }\n        }\n        return binom;\n    }\n\n    \n    \n    private static double binomialFloat(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        double binom = 1.0;\n        for (int i = 1; i <= k; i++)\n            binom = binom * (n + 1 - i) / i;\n        return binom;\n    }\n\n    \n    private static BigInteger binomialBigInt(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        BigInteger binom = BigInteger.ONE;\n        for (int i = 1; i <= k; i++) {\n            binom = binom.multiply(BigInteger.valueOf(n + 1 - i));\n            binom = binom.divide(BigInteger.valueOf(i));\n        }\n        return binom;\n    }\n\n    private static void demo(int n, int k) {\n        List<Object> data = Arrays.asList(\n                n,\n                k,\n                binomialInt(n, k),\n                binomialIntReliable(n, k),\n                binomialFloat(n, k),\n                binomialBigInt(n, k));\n\n        System.out.println(data.stream().map(Object::toString).collect(Collectors.joining(\"\\t\")));\n    }\n\n    public static void main(String[] args) {\n        demo(5, 3);\n        demo(1000, 300);\n    }\n}\n"}
{"id": 16057, "name": "Evaluate binomial coefficients", "source": "Translate Swift to Python: func factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nfunc binomial<T: BinaryInteger>(_ x: (n: T, k: T)) -> T {\n  let nFac = factorial(x.n)\n  let kFac = factorial(x.k)\n\n  return nFac / (factorial(x.n - x.k) * kFac)\n}\n\nprint(\"binomial(\\(5), \\(3)) = \\(binomial((5, 3)))\")\nprint(\"binomial(\\(20), \\(11)) = \\(binomial((20, 11)))\")\n", "target": "def binomialCoeff(n, k):\n    result = 1\n    for i in range(1, k+1):\n        result = result * (n-i+1) / i\n    return result\n\nif __name__ == \"__main__\":\n    print(binomialCoeff(5, 3))\n"}
{"id": 16662, "name": "Perfect numbers", "source": "Translate Swift to C#: func perfect(n:Int) -> Bool {\n    var sum = 0\n    for i in 1..<n {\n        if n % i == 0 {\n            sum += i\n        }\n    }\n    return sum == n\n}\n\nfor i in 1..<10000 {\n    if perfect(i) {\n        println(i)\n    }\n}\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(\"Perfect numbers from 1 to 33550337:\");\n\n\tfor (int x = 0; x < 33550337; x++)\n\t{\n\t\tif (IsPerfect(x))\n\t\t\tConsole.WriteLine(x + \" is perfect.\");\n\t}\n\n\tConsole.ReadLine();\n}\n\nstatic bool IsPerfect(int num) \n{\n\tint sum = 0;\n\tfor (int i = 1; i < num; i++)\n\t{\n\t\tif (num % i == 0)\n\t\t\tsum += i;\n\t}\n\n\treturn sum == num ;\n}\n"}
{"id": 16664, "name": "Perfect numbers", "source": "Translate Swift to Java: func perfect(n:Int) -> Bool {\n    var sum = 0\n    for i in 1..<n {\n        if n % i == 0 {\n            sum += i\n        }\n    }\n    return sum == n\n}\n\nfor i in 1..<10000 {\n    if perfect(i) {\n        println(i)\n    }\n}\n", "target": "public static boolean perf(int n){\n\tint sum= 0;\n\tfor(int i= 1;i < n;i++){\n\t\tif(n % i == 0){\n\t\t\tsum+= i;\n\t\t}\n\t}\n\treturn sum == n;\n}\n"}
{"id": 16665, "name": "Perfect numbers", "source": "Translate Swift to Python: func perfect(n:Int) -> Bool {\n    var sum = 0\n    for i in 1..<n {\n        if n % i == 0 {\n            sum += i\n        }\n    }\n    return sum == n\n}\n\nfor i in 1..<10000 {\n    if perfect(i) {\n        println(i)\n    }\n}\n", "target": "def perf1(n):\n    sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum += i\n    return sum == n\n"}
{"id": 18153, "name": "Munchausen numbers", "source": "Translate Swift to C#: import Foundation\n\nfunc isM\u00fcnchhausen(_ n: Int) -> Bool {\n  let nums = String(n).map(String.init).compactMap(Int.init)\n\n  return Int(nums.map({ pow(Double($0), Double($0)) }).reduce(0, +)) == n\n}\n\nfor i in 1...5000 where isM\u00fcnchhausen(i) {\n  print(i)\n}\n", "target": "Func<char, int> toInt = c => c-'0';\n\nforeach (var i in Enumerable.Range(1,5000)\n\t.Where(n => n == n.ToString()\n\t\t.Sum(x => Math.Pow(toInt(x), toInt(x)))))\n\tConsole.WriteLine(i);\n"}
{"id": 18154, "name": "Munchausen numbers", "source": "Translate Swift to C#: import Foundation\n\nfunc isM\u00fcnchhausen(_ n: Int) -> Bool {\n  let nums = String(n).map(String.init).compactMap(Int.init)\n\n  return Int(nums.map({ pow(Double($0), Double($0)) }).reduce(0, +)) == n\n}\n\nfor i in 1...5000 where isM\u00fcnchhausen(i) {\n  print(i)\n}\n", "target": "Func<char, int> toInt = c => c-'0';\n\nforeach (var i in Enumerable.Range(1,5000)\n\t.Where(n => n == n.ToString()\n\t\t.Sum(x => Math.Pow(toInt(x), toInt(x)))))\n\tConsole.WriteLine(i);\n"}
{"id": 18157, "name": "Munchausen numbers", "source": "Translate Swift to Java: import Foundation\n\nfunc isM\u00fcnchhausen(_ n: Int) -> Bool {\n  let nums = String(n).map(String.init).compactMap(Int.init)\n\n  return Int(nums.map({ pow(Double($0), Double($0)) }).reduce(0, +)) == n\n}\n\nfor i in 1...5000 where isM\u00fcnchhausen(i) {\n  print(i)\n}\n", "target": "public class Main {\n    public static void main(String[] args) {\n        for(int i = 0 ; i <= 5000 ; i++ ){\n            int val = String.valueOf(i).chars().map(x -> (int) Math.pow( x-48 ,x-48)).sum();\n            if( i == val){\n                System.out.println( i + \" (munchausen)\");\n            }\n        }\n    }\n}\n"}
{"id": 18158, "name": "Munchausen numbers", "source": "Translate Swift to Java: import Foundation\n\nfunc isM\u00fcnchhausen(_ n: Int) -> Bool {\n  let nums = String(n).map(String.init).compactMap(Int.init)\n\n  return Int(nums.map({ pow(Double($0), Double($0)) }).reduce(0, +)) == n\n}\n\nfor i in 1...5000 where isM\u00fcnchhausen(i) {\n  print(i)\n}\n", "target": "public class Main {\n    public static void main(String[] args) {\n        for(int i = 0 ; i <= 5000 ; i++ ){\n            int val = String.valueOf(i).chars().map(x -> (int) Math.pow( x-48 ,x-48)).sum();\n            if( i == val){\n                System.out.println( i + \" (munchausen)\");\n            }\n        }\n    }\n}\n"}
{"id": 18159, "name": "Munchausen numbers", "source": "Translate Swift to Python: import Foundation\n\nfunc isM\u00fcnchhausen(_ n: Int) -> Bool {\n  let nums = String(n).map(String.init).compactMap(Int.init)\n\n  return Int(nums.map({ pow(Double($0), Double($0)) }).reduce(0, +)) == n\n}\n\nfor i in 1...5000 where isM\u00fcnchhausen(i) {\n  print(i)\n}\n", "target": "for i in range(5000):\n    if i == sum(int(x) ** int(x) for x in str(i)):\n        print(i)\n"}
{"id": 18160, "name": "Munchausen numbers", "source": "Translate Swift to Python: import Foundation\n\nfunc isM\u00fcnchhausen(_ n: Int) -> Bool {\n  let nums = String(n).map(String.init).compactMap(Int.init)\n\n  return Int(nums.map({ pow(Double($0), Double($0)) }).reduce(0, +)) == n\n}\n\nfor i in 1...5000 where isM\u00fcnchhausen(i) {\n  print(i)\n}\n", "target": "for i in range(5000):\n    if i == sum(int(x) ** int(x) for x in str(i)):\n        print(i)\n"}
{"id": 18402, "name": "Strip block comments", "source": "Translate Swift to C#: import Foundation\n\nfunc stripBlocks(from str: String, open: String = \"\") -> String {\n  guard !open.isEmpty && !close.isEmpty else {\n    return str\n  }\n\n  var ret = str\n\n  while let begin = ret.range(of: open), let end = ret[begin.upperBound...].range(of: close) {\n    ret.replaceSubrange(Range(uncheckedBounds: (begin.lowerBound, end.upperBound)), with: \"\")\n  }\n\n  return ret\n}\n\nlet test = \"\"\"\n             \n           function subroutine() {\n            a =  b + c\u00a0;\n           }\n           \n\n           \n            function something() {\n            }\n           \"\"\"\n\nprint(stripBlocks(from: test))\n", "target": "using System;\n\n    class Program\n    {\n        private static string BlockCommentStrip(string commentStart, string commentEnd, string sampleText)\n        {\n            while (sampleText.IndexOf(commentStart) > -1 && sampleText.IndexOf(commentEnd, sampleText.IndexOf(commentStart) + commentStart.Length) > -1)\n            {\n                int start = sampleText.IndexOf(commentStart);\n                int end = sampleText.IndexOf(commentEnd, start + commentStart.Length);\n                sampleText = sampleText.Remove(\n                    start,\n                    (end + commentEnd.Length) - start\n                    );\n            }\n            return sampleText;\n        }\n    }\n"}
{"id": 18404, "name": "Strip block comments", "source": "Translate Swift to Java: import Foundation\n\nfunc stripBlocks(from str: String, open: String = \"\") -> String {\n  guard !open.isEmpty && !close.isEmpty else {\n    return str\n  }\n\n  var ret = str\n\n  while let begin = ret.range(of: open), let end = ret[begin.upperBound...].range(of: close) {\n    ret.replaceSubrange(Range(uncheckedBounds: (begin.lowerBound, end.upperBound)), with: \"\")\n  }\n\n  return ret\n}\n\nlet test = \"\"\"\n             \n           function subroutine() {\n            a =  b + c\u00a0;\n           }\n           \n\n           \n            function something() {\n            }\n           \"\"\"\n\nprint(stripBlocks(from: test))\n", "target": "import java.io.*;\n\npublic class StripBlockComments{\n    public static String readFile(String filename) {\n\tBufferedReader reader = new BufferedReader(new FileReader(filename));\n\ttry {\n\t    StringBuilder fileContents = new StringBuilder();\n\t    char[] buffer = new char[4096];\n\t    while (reader.read(buffer, 0, 4096) > 0) {\n\t\tfileContents.append(buffer);\n\t    }\n\t    return fileContents.toString();\n\t} finally {\n\t    reader.close();\n\t}\n    }\n\n    public static String stripComments(String beginToken, String endToken,\n\t\t\t\t       String input) {\n\tStringBuilder output = new StringBuilder();\n\twhile (true) {\n\t    int begin = input.indexOf(beginToken);\n\t    int end = input.indexOf(endToken, begin+beginToken.length());\n\t    if (begin == -1 || end == -1) {\n\t\toutput.append(input);\n\t\treturn output.toString();\n\t    }\n\t    output.append(input.substring(0, begin));\n\t    input = input.substring(end + endToken.length());\n\t}\n    }\n\n    public static void main(String[] args) {\n\tif (args.length < 3) {\n\t    System.out.println(\"Usage: BeginToken EndToken FileToProcess\");\n\t    System.exit(1);\n\t}\n\n\tString begin = args[0];\n\tString end = args[1];\n\tString input = args[2];\n\n\ttry {\n\t    System.out.println(stripComments(begin, end, readFile(input)));\n\t} catch (Exception e) {\n\t    e.printStackTrace();\n\t    System.exit(1);\n\t}\n    }\n}\n"}
{"id": 18405, "name": "Strip block comments", "source": "Translate Swift to Python: import Foundation\n\nfunc stripBlocks(from str: String, open: String = \"\") -> String {\n  guard !open.isEmpty && !close.isEmpty else {\n    return str\n  }\n\n  var ret = str\n\n  while let begin = ret.range(of: open), let end = ret[begin.upperBound...].range(of: close) {\n    ret.replaceSubrange(Range(uncheckedBounds: (begin.lowerBound, end.upperBound)), with: \"\")\n  }\n\n  return ret\n}\n\nlet test = \"\"\"\n             \n           function subroutine() {\n            a =  b + c\u00a0;\n           }\n           \n\n           \n            function something() {\n            }\n           \"\"\"\n\nprint(stripBlocks(from: test))\n", "target": "def _commentstripper(txt, delim):\n    'Strips first nest of block comments'\n    \n    deliml, delimr = delim\n    out = ''\n    if deliml in txt:\n        indx = txt.index(deliml)\n        out += txt[:indx]\n        txt = txt[indx+len(deliml):]\n        txt = _commentstripper(txt, delim)\n        assert delimr in txt, 'Cannot find closing comment delimiter in ' + txt\n        indx = txt.index(delimr)\n        out += txt[(indx+len(delimr)):]\n    else:\n        out = txt\n    return out\n\ndef commentstripper(txt, delim=('/*', '*/')):\n    'Strips nests of block comments'\n    \n    deliml, delimr = delim\n    while deliml in txt:\n        txt = _commentstripper(txt, delim)\n    return txt\n"}
{"id": 18729, "name": "Arithmetic_Complex", "source": "Translate Swift to C#: public struct Complex {\n    \n    public let real : Double\n    public let imaginary : Double\n    \n    public init(real inReal:Double, imaginary inImaginary:Double) {\n        real = inReal\n        imaginary = inImaginary\n    }\n    \n    public static var i : Complex = Complex(real:0, imaginary: 1)\n    public static var zero : Complex = Complex(real: 0, imaginary: 0)\n    \n    public var negate : Complex {\n        return Complex(real: -real, imaginary: -imaginary)\n    }\n    \n    public var invert : Complex {\n        let d = (real*real + imaginary*imaginary)\n        return Complex(real: real/d, imaginary: -imaginary/d)\n    }\n    \n    public var conjugate : Complex {\n        return Complex(real: real, imaginary: -imaginary)\n    }\n    \n}\npublic func + (left: Complex, right: Complex) -> Complex {\n    \n    return Complex(real: left.real+right.real, imaginary: left.imaginary+right.imaginary)\n}\npublic func * (left: Complex, right: Complex) -> Complex {\n    \n    return Complex(real: left.real*right.real - left.imaginary*right.imaginary,\n        imaginary: left.real*right.imaginary+left.imaginary*right.real)\n}\npublic prefix func - (right:Complex) -> Complex {\n    return right.negate\n}\n\n\nextension Complex : Equatable {}\npublic func == (left:Complex, right:Complex) -> Bool {\n    return left.real == right.real && left.imaginary == right.imaginary\n}\n", "target": "namespace RosettaCode.Arithmetic.Complex\n{\n    using System;\n    using System.Numerics;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            var number = Complex.ImaginaryOne;\n            foreach (var result in new[] { number + number, number * number, -number, 1 / number, Complex.Conjugate(number) })\n            {\n                Console.WriteLine(result);\n            }\n        }\n    }\n}\n"}
{"id": 18731, "name": "Arithmetic_Complex", "source": "Translate Swift to Java: public struct Complex {\n    \n    public let real : Double\n    public let imaginary : Double\n    \n    public init(real inReal:Double, imaginary inImaginary:Double) {\n        real = inReal\n        imaginary = inImaginary\n    }\n    \n    public static var i : Complex = Complex(real:0, imaginary: 1)\n    public static var zero : Complex = Complex(real: 0, imaginary: 0)\n    \n    public var negate : Complex {\n        return Complex(real: -real, imaginary: -imaginary)\n    }\n    \n    public var invert : Complex {\n        let d = (real*real + imaginary*imaginary)\n        return Complex(real: real/d, imaginary: -imaginary/d)\n    }\n    \n    public var conjugate : Complex {\n        return Complex(real: real, imaginary: -imaginary)\n    }\n    \n}\npublic func + (left: Complex, right: Complex) -> Complex {\n    \n    return Complex(real: left.real+right.real, imaginary: left.imaginary+right.imaginary)\n}\npublic func * (left: Complex, right: Complex) -> Complex {\n    \n    return Complex(real: left.real*right.real - left.imaginary*right.imaginary,\n        imaginary: left.real*right.imaginary+left.imaginary*right.real)\n}\npublic prefix func - (right:Complex) -> Complex {\n    return right.negate\n}\n\n\nextension Complex : Equatable {}\npublic func == (left:Complex, right:Complex) -> Bool {\n    return left.real == right.real && left.imaginary == right.imaginary\n}\n", "target": "public class Complex {\n    public final double real;\n    public final double imag;\n\n    public Complex() {\n        this(0, 0);\n    }\n\n    public Complex(double r, double i) {\n        real = r;\n        imag = i;\n    }\n\n    public Complex add(Complex b) {\n        return new Complex(this.real + b.real, this.imag + b.imag);\n    }\n\n    public Complex mult(Complex b) {\n        \n        return new Complex(this.real * b.real - this.imag * b.imag,\n                this.real * b.imag + this.imag * b.real);\n    }\n\n    public Complex inv() {\n        \n        double denom = real * real + imag * imag;\n        return new Complex(real / denom, -imag / denom);\n    }\n\n    public Complex neg() {\n        return new Complex(-real, -imag);\n    }\n\n    public Complex conj() {\n        return new Complex(real, -imag);\n    }\n\n    @Override\n    public String toString() {\n        return real + \" + \" + imag + \" * i\";\n    }\n\n    public static void main(String[] args) {\n        Complex a = new Complex(Math.PI, -5); \n        Complex b = new Complex(-1, 2.5);\n        System.out.println(a.neg());\n        System.out.println(a.add(b));\n        System.out.println(a.inv());\n        System.out.println(a.mult(b));\n        System.out.println(a.conj());\n    }\n}\n"}
{"id": 18732, "name": "Arithmetic_Complex", "source": "Translate Swift to Python: public struct Complex {\n    \n    public let real : Double\n    public let imaginary : Double\n    \n    public init(real inReal:Double, imaginary inImaginary:Double) {\n        real = inReal\n        imaginary = inImaginary\n    }\n    \n    public static var i : Complex = Complex(real:0, imaginary: 1)\n    public static var zero : Complex = Complex(real: 0, imaginary: 0)\n    \n    public var negate : Complex {\n        return Complex(real: -real, imaginary: -imaginary)\n    }\n    \n    public var invert : Complex {\n        let d = (real*real + imaginary*imaginary)\n        return Complex(real: real/d, imaginary: -imaginary/d)\n    }\n    \n    public var conjugate : Complex {\n        return Complex(real: real, imaginary: -imaginary)\n    }\n    \n}\npublic func + (left: Complex, right: Complex) -> Complex {\n    \n    return Complex(real: left.real+right.real, imaginary: left.imaginary+right.imaginary)\n}\npublic func * (left: Complex, right: Complex) -> Complex {\n    \n    return Complex(real: left.real*right.real - left.imaginary*right.imaginary,\n        imaginary: left.real*right.imaginary+left.imaginary*right.real)\n}\npublic prefix func - (right:Complex) -> Complex {\n    return right.negate\n}\n\n\nextension Complex : Equatable {}\npublic func == (left:Complex, right:Complex) -> Bool {\n    return left.real == right.real && left.imaginary == right.imaginary\n}\n", "target": ">>> z1 = 1.5 + 3j\n>>> z2 = 1.5 + 1.5j\n>>> z1 + z2\n(3+4.5j)\n>>> z1 - z2\n1.5j\n>>> z1 * z2\n(-2.25+6.75j)\n>>> z1 / z2\n(1.5+0.5j)\n>>> - z1\n(-1.5-3j)\n>>> z1.conjugate()\n(1.5-3j)\n>>> abs(z1)\n3.3541019662496847\n>>> z1 ** z2\n(-1.1024829553277784-0.38306415117199333j)\n>>> z1.real\n1.5\n>>> z1.imag\n3.0\n>>>\n"}
{"id": 18949, "name": "Walk a directory_Recursively", "source": "Translate Swift to C#: import Foundation\n\nlet fileSystem = FileManager.default\nlet rootPath = \"/\"\n\n\n\nif let fsTree = fileSystem.enumerator(atPath: rootPath) {\n\t\n    while let fsNodeName = fsTree.nextObject() as? NSString {\n\t\t\t\t\n        let fullPath = \"\\(rootPath)/\\(fsNodeName)\"\n\t\t\t\t\n        var isDir: ObjCBool = false\n        fileSystem.fileExists(atPath: fullPath, isDirectory: &isDir)\n\t\t\t\t\n        if !isDir.boolValue && fsNodeName.pathExtension == \"txt\" {\n            print(fsNodeName)\n        }\n    }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace RosettaRecursiveDirectory\n{\n    class Program\n    {\n        static IEnumerable<FileInfo> TraverseDirectory(string rootPath, Func<FileInfo, bool> Pattern)\n        {\n            var directoryStack = new Stack<DirectoryInfo>();\n            directoryStack.Push(new DirectoryInfo(rootPath));\n            while (directoryStack.Count > 0)\n            {\n                var dir = directoryStack.Pop();\n                try\n                {\n                    foreach (var i in dir.GetDirectories())\n                        directoryStack.Push(i);\n                }\n                catch (UnauthorizedAccessException) {\n                    continue; \n                }\n                foreach (var f in dir.GetFiles().Where(Pattern)) \n                    yield return f;\n            }\n        }\n        static void Main(string[] args)\n        {\n            \n            foreach (var file in TraverseDirectory(@\"C:\\Windows\", f => f.Extension == \".wmv\"))\n                Console.WriteLine(file.FullName);\n            Console.WriteLine(\"Done.\");\n        }\n    }\n}\n"}
{"id": 18951, "name": "Walk a directory_Recursively", "source": "Translate Swift to Java: import Foundation\n\nlet fileSystem = FileManager.default\nlet rootPath = \"/\"\n\n\n\nif let fsTree = fileSystem.enumerator(atPath: rootPath) {\n\t\n    while let fsNodeName = fsTree.nextObject() as? NSString {\n\t\t\t\t\n        let fullPath = \"\\(rootPath)/\\(fsNodeName)\"\n\t\t\t\t\n        var isDir: ObjCBool = false\n        fileSystem.fileExists(atPath: fullPath, isDirectory: &isDir)\n\t\t\t\t\n        if !isDir.boolValue && fsNodeName.pathExtension == \"txt\" {\n            print(fsNodeName)\n        }\n    }\n}\n", "target": "import java.io.File;\n\npublic class MainEntry {\n    public static void main(String[] args) {\n        walkin(new File(\"/home/user\")); \n    }\n    \n    \n    public static void walkin(File dir) {\n        String pattern = \".mp3\";\n        \n        File listFile[] = dir.listFiles();\n        if (listFile != null) {\n            for (int i=0; i<listFile.length; i++) {\n                if (listFile[i].isDirectory()) {\n                    walkin(listFile[i]);\n                } else {\n                    if (listFile[i].getName().endsWith(pattern)) {\n                        System.out.println(listFile[i].getPath());\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 18952, "name": "Walk a directory_Recursively", "source": "Translate Swift to Python: import Foundation\n\nlet fileSystem = FileManager.default\nlet rootPath = \"/\"\n\n\n\nif let fsTree = fileSystem.enumerator(atPath: rootPath) {\n\t\n    while let fsNodeName = fsTree.nextObject() as? NSString {\n\t\t\t\t\n        let fullPath = \"\\(rootPath)/\\(fsNodeName)\"\n\t\t\t\t\n        var isDir: ObjCBool = false\n        fileSystem.fileExists(atPath: fullPath, isDirectory: &isDir)\n\t\t\t\t\n        if !isDir.boolValue && fsNodeName.pathExtension == \"txt\" {\n            print(fsNodeName)\n        }\n    }\n}\n", "target": "from pathlib import Path\n\nfor path in Path('.').rglob('*.*'):\n    print(path)\n"}
{"id": 19274, "name": "Deal cards for FreeCell", "source": "Translate Swift to C#: enum Suit : String, CustomStringConvertible, CaseIterable {\n    case clubs = \"C\", diamonds = \"D\", hearts = \"H\", spades = \"S\"\n    var description: String {\n        return self.rawValue\n    }\n}\nenum Rank : Int, CustomStringConvertible, CaseIterable {\n    case ace=1, two, three, four, five, six, seven\n    case eight, nine, ten, jack, queen, king\n    var description: String {\n        let d : [Rank:String] = [.ace:\"A\", .king:\"K\", .queen:\"Q\", .jack:\"J\", .ten:\"T\"]\n        return d[self] ?? String(self.rawValue)\n    }\n}\nstruct Card : CustomStringConvertible {\n    let rank : Rank, suit : Suit\n    var description : String {\n        return String(describing:self.rank) + String(describing:self.suit)\n    }\n    init(rank:Rank, suit:Suit) {\n        self.rank = rank; self.suit = suit\n    }\n    init(sequence n:Int) {\n        self.init(rank:Rank.allCases[n/4], suit:Suit.allCases[n%4])\n    }\n}\nstruct Deck : CustomStringConvertible {\n    var cards = [Card]()\n    init(seed:Int) {\n        for i in (0..<52).reversed() {\n            self.cards.append(Card(sequence:i))\n        }\n        struct MicrosoftLinearCongruentialGenerator {\n            var seed : Int\n            mutating func next() -> Int {\n                self.seed = (self.seed * 214013 + 2531011) % (Int(Int32.max)+1)\n                return self.seed >> 16\n            }\n        }\n        var r = MicrosoftLinearCongruentialGenerator(seed: seed)\n        for i in 0..<51 {\n            self.cards.swapAt(i, 51-r.next()%(52-i))\n        }\n    }\n    var description : String {\n        var s = \"\"\n        for (ix,c) in self.cards.enumerated() {\n            s.write(String(describing:c))\n            s.write(ix % 8 == 7 ? \"\\n\" : \" \")\n        }\n        return s\n    }\n}\nlet d1 = Deck(seed: 1)\nprint(d1)\nlet d617 = Deck(seed: 617)\nprint(d617)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace FreeCellDeals\n{\n    public class RNG\n    {\n        private int _state;\n\n        public RNG()\n        {\n            _state = (int)DateTime.Now.Ticks;\n        }\n\n        public RNG(int n)\n        {\n            _state = n;\n        }\n        public int Next()\n        {\n            return ((_state = 214013 * _state + 2531011) & int.MaxValue) >> 16;\n        }\n    }\n\n    public enum Rank\n    {\n        Ace,\n        One,\n        Two,\n        Three,\n        Four,\n        Five,\n        Six,\n        Seven,\n        Eight,\n        Nine,\n        Ten,\n        Jack,\n        Queen,\n        King\n    }\n\n    public enum Suit\n    {\n        Clubs,\n        Diamonds,\n        Hearts,\n        Spades\n    }\n\n    public class Card\n    {\n        private const string Ranks = \"A23456789TJQK\";\n        private const string Suits = \"CDHS\";\n\n        private Rank _rank;\n        public Rank Rank\n        {\n            get\n            {\n                return _rank;\n            }\n            set\n            {\n                if ((int)value < 0 || (int)value > 12)\n                {\n                    throw new InvalidOperationException(\"Setting card rank out of range\");\n                }\n                _rank = value;\n            }\n        }\n\n        private Suit _suit;\n        public Suit Suit\n        {\n            get\n            {\n                return _suit;\n            }\n            set\n            {\n                if ((int)value < 0 || (int)value > 3)\n                {\n                    throw new InvalidOperationException(\"Setting card rank out of range\");\n                }\n                _suit = value;\n            }\n        }\n\n        public Card(Rank rank, Suit suit)\n        {\n            Rank = rank;\n            Suit = suit;\n        }\n\n        public int NRank()\n        {\n            return (int) Rank;\n        }\n\n        public int NSuit()\n        {\n            return (int) Suit;\n        }\n\n        public override string ToString()\n        {\n            return new string(new[] {Ranks[NRank()], Suits[NSuit()]});\n        }\n    }\n\n    public class FreeCellDeal\n    {\n        public List<Card> Deck { get; private set; }\n\n        public FreeCellDeal(int iDeal)\n        {\n            RNG rng = new RNG(iDeal);\n\n            List<Card> rDeck = new List<Card>();\n            Deck = new List<Card>();\n\n            for (int rank = 0; rank < 13; rank++)\n            {\n                for (int suit = 0; suit < 4; suit++)\n                {\n                    rDeck.Add(new Card((Rank)rank, (Suit)suit));\n                }\n            }\n\n            \n            \n            for (int iCard = 51; iCard >= 0; iCard--)\n            {\n                int iSwap = rng.Next() % (iCard + 1);\n                Deck.Add(rDeck[iSwap]);\n                rDeck[iSwap] = rDeck[iCard];\n            }\n        }\n\n        public override string ToString()\n        {\n            StringBuilder sb = new StringBuilder();\n            for (int iRow = 0; iRow < 6; iRow++ )\n            {\n                for (int iCol = 0; iCol < 8; iCol++)\n                {\n                    sb.AppendFormat(\"{0} \", Deck[iRow * 8 + iCol]);\n                }\n                sb.Append(\"\\n\");\n            }\n            for (int iCard = 48; iCard < 52; iCard++)\n            {\n                sb.AppendFormat(\"{0} \", Deck[iCard]);\n            }\n            return sb.ToString();\n        }\n    }\n\n    class Program\n    {\n        static void Main()\n        {\n            Console.WriteLine(new FreeCellDeal(1));\n            Console.WriteLine();\n            Console.WriteLine(new FreeCellDeal(617));\n        }\n    }\n}\n"}
{"id": 19276, "name": "Deal cards for FreeCell", "source": "Translate Swift to Java: enum Suit : String, CustomStringConvertible, CaseIterable {\n    case clubs = \"C\", diamonds = \"D\", hearts = \"H\", spades = \"S\"\n    var description: String {\n        return self.rawValue\n    }\n}\nenum Rank : Int, CustomStringConvertible, CaseIterable {\n    case ace=1, two, three, four, five, six, seven\n    case eight, nine, ten, jack, queen, king\n    var description: String {\n        let d : [Rank:String] = [.ace:\"A\", .king:\"K\", .queen:\"Q\", .jack:\"J\", .ten:\"T\"]\n        return d[self] ?? String(self.rawValue)\n    }\n}\nstruct Card : CustomStringConvertible {\n    let rank : Rank, suit : Suit\n    var description : String {\n        return String(describing:self.rank) + String(describing:self.suit)\n    }\n    init(rank:Rank, suit:Suit) {\n        self.rank = rank; self.suit = suit\n    }\n    init(sequence n:Int) {\n        self.init(rank:Rank.allCases[n/4], suit:Suit.allCases[n%4])\n    }\n}\nstruct Deck : CustomStringConvertible {\n    var cards = [Card]()\n    init(seed:Int) {\n        for i in (0..<52).reversed() {\n            self.cards.append(Card(sequence:i))\n        }\n        struct MicrosoftLinearCongruentialGenerator {\n            var seed : Int\n            mutating func next() -> Int {\n                self.seed = (self.seed * 214013 + 2531011) % (Int(Int32.max)+1)\n                return self.seed >> 16\n            }\n        }\n        var r = MicrosoftLinearCongruentialGenerator(seed: seed)\n        for i in 0..<51 {\n            self.cards.swapAt(i, 51-r.next()%(52-i))\n        }\n    }\n    var description : String {\n        var s = \"\"\n        for (ix,c) in self.cards.enumerated() {\n            s.write(String(describing:c))\n            s.write(ix % 8 == 7 ? \"\\n\" : \" \")\n        }\n        return s\n    }\n}\nlet d1 = Deck(seed: 1)\nprint(d1)\nlet d617 = Deck(seed: 617)\nprint(d617)\n", "target": "import java.util.Arrays;\n\npublic class Shuffler {\n\t\n\tprivate int seed;\n\t\n\tprivate String[] deck = {\n\t\t\t\"AC\", \"AD\", \"AH\", \"AS\",\n\t\t\t\"2C\", \"2D\", \"2H\", \"2S\",\n\t\t\t\"3C\", \"3D\", \"3H\", \"3S\",\n\t\t\t\"4C\", \"4D\", \"4H\", \"4S\",\n\t\t\t\"5C\", \"5D\", \"5H\", \"5S\",\n\t\t\t\"6C\", \"6D\", \"6H\", \"6S\",\n\t\t\t\"7C\", \"7D\", \"7H\", \"7S\",\n\t\t\t\"8C\", \"8D\", \"8H\", \"8S\",\n\t\t\t\"9C\", \"9D\", \"9H\", \"9S\",\n\t\t\t\"TC\", \"TD\", \"TH\", \"TS\",\n\t\t\t\"JC\", \"JD\", \"JH\", \"JS\",\n\t\t\t\"QC\", \"QD\", \"QH\", \"QS\",\n\t\t\t\"KC\", \"KD\", \"KH\", \"KS\",\n\t};\n\t\n\tprivate int random() {\n\t\tseed = (214013 * seed + 2531011) & Integer.MAX_VALUE;\n\t\treturn seed >> 16;\n\t}\n\t\n\t\n\tprivate String[] getShuffledDeck() {\n\t\tString[] deck = Arrays.copyOf(this.deck, this.deck.length);\n\t\tfor(int i = deck.length - 1; i > 0; i--) {\n\t\t\tint r = random() % (i + 1);\n\t\t\tString card = deck[r];\n\t\t\tdeck[r] = deck[i];\n\t\t\tdeck[i] = card;\n\t\t}\n\t\treturn deck;\n\t}\n\t\n\t\n\tpublic void dealGame(int seed) {\n\t\tthis.seed = seed;\n\t\tString[] shuffledDeck = getShuffledDeck();\n\t\tfor(int count = 1, i = shuffledDeck.length - 1; i >= 0; count++, i--) {\n\t\t\tSystem.out.print(shuffledDeck[i]);\n\t\t\tif(count % 8 == 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tShuffler s = new Shuffler();\n\t\ts.dealGame(1);\n\t\tSystem.out.println();\n\t\ts.dealGame(617);\n\t}\n\t\n}\n"}
{"id": 19277, "name": "Deal cards for FreeCell", "source": "Translate Swift to Python: enum Suit : String, CustomStringConvertible, CaseIterable {\n    case clubs = \"C\", diamonds = \"D\", hearts = \"H\", spades = \"S\"\n    var description: String {\n        return self.rawValue\n    }\n}\nenum Rank : Int, CustomStringConvertible, CaseIterable {\n    case ace=1, two, three, four, five, six, seven\n    case eight, nine, ten, jack, queen, king\n    var description: String {\n        let d : [Rank:String] = [.ace:\"A\", .king:\"K\", .queen:\"Q\", .jack:\"J\", .ten:\"T\"]\n        return d[self] ?? String(self.rawValue)\n    }\n}\nstruct Card : CustomStringConvertible {\n    let rank : Rank, suit : Suit\n    var description : String {\n        return String(describing:self.rank) + String(describing:self.suit)\n    }\n    init(rank:Rank, suit:Suit) {\n        self.rank = rank; self.suit = suit\n    }\n    init(sequence n:Int) {\n        self.init(rank:Rank.allCases[n/4], suit:Suit.allCases[n%4])\n    }\n}\nstruct Deck : CustomStringConvertible {\n    var cards = [Card]()\n    init(seed:Int) {\n        for i in (0..<52).reversed() {\n            self.cards.append(Card(sequence:i))\n        }\n        struct MicrosoftLinearCongruentialGenerator {\n            var seed : Int\n            mutating func next() -> Int {\n                self.seed = (self.seed * 214013 + 2531011) % (Int(Int32.max)+1)\n                return self.seed >> 16\n            }\n        }\n        var r = MicrosoftLinearCongruentialGenerator(seed: seed)\n        for i in 0..<51 {\n            self.cards.swapAt(i, 51-r.next()%(52-i))\n        }\n    }\n    var description : String {\n        var s = \"\"\n        for (ix,c) in self.cards.enumerated() {\n            s.write(String(describing:c))\n            s.write(ix % 8 == 7 ? \"\\n\" : \" \")\n        }\n        return s\n    }\n}\nlet d1 = Deck(seed: 1)\nprint(d1)\nlet d617 = Deck(seed: 617)\nprint(d617)\n", "target": "def randomGenerator(seed=1):\n    max_int32 = (1 << 31) - 1\n    seed = seed & max_int32\n\n    while True:\n        seed = (seed * 214013 + 2531011) & max_int32\n        yield seed >> 16\n\ndef deal(seed):\n    nc = 52\n    cards = list(range(nc - 1, -1, -1))\n    rnd = randomGenerator(seed)\n    for i, r in zip(range(nc), rnd):\n        j = (nc - 1) - r % (nc - i)\n        cards[i], cards[j] = cards[j], cards[i]\n    return cards\n\ndef show(cards):\n    l = [\"A23456789TJQK\"[int(c/4)] + \"CDHS\"[c%4] for c in cards]\n    for i in range(0, len(cards), 8):\n        print(\" \".join(l[i : i+8]))\n\nif __name__ == '__main__':\n    from sys import argv\n    seed = int(argv[1]) if len(argv) == 2 else 11982\n    print(\"Hand {}\".format(seed))\n    deck = deal(seed)\n    show(deck)\n"}
{"id": 19474, "name": "Handle a signal", "source": "Translate Swift to C#: import Foundation\n\nlet startTime = NSDate()\nvar signalReceived: sig_atomic_t = 0\n\nsignal(SIGINT) { signal in signalReceived = 1 }\n\nfor var i = 0;; {\n    if signalReceived == 1 { break }\n    usleep(500_000)\n    if signalReceived == 1 { break }\n    print(++i)\n}\n\nlet endTime = NSDate()\nprint(\"Program has run for \\(endTime.timeIntervalSinceDate(startTime)) seconds\")\n", "target": "using System; \nclass Program\n{\n    static DateTime start;\n    static void Main(string[] args)\n    {\n        start = DateTime.Now;\n        \n        Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);\n        int counter = 0;\n        while (true)\n        {\n            Console.WriteLine(++counter);\n            System.Threading.Thread.Sleep(500);\n        }\n    }\n    static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n    {\n        var end = DateTime.Now;\n        Console.WriteLine(\"This program ran for {0:000.000} seconds.\", (end - start).TotalMilliseconds / 1000);\n        Environment.Exit(0);\n    }\n}\n"}
{"id": 19476, "name": "Handle a signal", "source": "Translate Swift to Java: import Foundation\n\nlet startTime = NSDate()\nvar signalReceived: sig_atomic_t = 0\n\nsignal(SIGINT) { signal in signalReceived = 1 }\n\nfor var i = 0;; {\n    if signalReceived == 1 { break }\n    usleep(500_000)\n    if signalReceived == 1 { break }\n    print(++i)\n}\n\nlet endTime = NSDate()\nprint(\"Program has run for \\(endTime.timeIntervalSinceDate(startTime)) seconds\")\n", "target": "import sun.misc.Signal;\nimport sun.misc.SignalHandler;\n\npublic class ExampleSignalHandler {\n    public static void main(String... args) throws InterruptedException {\n        final long start = System.nanoTime();\n        Signal.handle(new Signal(\"INT\"), new SignalHandler() {\n            public void handle(Signal sig) {\n                System.out.format(\"\\nProgram execution took %f seconds\\n\", (System.nanoTime() - start) / 1e9f);\n                System.exit(0);\n            }\n        });\n        int counter = 0;\n        while(true) {\n            System.out.println(counter++);\n            Thread.sleep(500);\n        }\n    }\n}\n"}
{"id": 19477, "name": "Handle a signal", "source": "Translate Swift to Python: import Foundation\n\nlet startTime = NSDate()\nvar signalReceived: sig_atomic_t = 0\n\nsignal(SIGINT) { signal in signalReceived = 1 }\n\nfor var i = 0;; {\n    if signalReceived == 1 { break }\n    usleep(500_000)\n    if signalReceived == 1 { break }\n    print(++i)\n}\n\nlet endTime = NSDate()\nprint(\"Program has run for \\(endTime.timeIntervalSinceDate(startTime)) seconds\")\n", "target": "import time\n\ndef counter():\n    n = 0\n    t1 = time.time()\n    while True:\n        try:\n            time.sleep(0.5)\n            n += 1\n            print n\n        except KeyboardInterrupt, e:\n            print 'Program has run for %5.3f seconds.' % (time.time() - t1)\n            break\n\ncounter()\n"}
{"id": 20034, "name": "Huffman coding", "source": "Translate Swift to C#: enum HuffmanTree<T> {\n  case Leaf(T)\n  indirect case Node(HuffmanTree<T>, HuffmanTree<T>)\n  \n  func printCodes(prefix: String) {\n    switch(self) {\n    case let .Leaf(c):\n      print(\"\\(c)\\t\\(prefix)\")\n    case let .Node(l, r):\n      l.printCodes(prefix + \"0\")\n      r.printCodes(prefix + \"1\")\n    }\n  }\n}\n\nfunc buildTree<T>(freqs: [(T, Int)]) -> HuffmanTree<T> {\n  assert(freqs.count > 0, \"must contain at least one character\")\n  \n  let leaves : [(Int, HuffmanTree<T>)] = freqs.sort { (p1, p2) in p1.1 < p2.1 }.map { (x, w) in (w, .Leaf(x)) }\n  \n  var nodes = [(Int, HuffmanTree<T>)]()\n  \n  for var i = 0, j = 0; ; {\n    assert(i < leaves.count || j < nodes.count)\n    \n    var e1 : (Int, HuffmanTree<T>)\n    if j == nodes.count || i < leaves.count && leaves[i].0 < nodes[j].0 {\n      e1 = leaves[i]\n      i++\n    } else {\n      e1 = nodes[j]\n      j++\n    }\n    \n    \n    if i == leaves.count && j == nodes.count {\n      return e1.1\n    }\n    \n    \n    var e2 : (Int, HuffmanTree<T>)\n    if j == nodes.count || i < leaves.count && leaves[i].0 < nodes[j].0 {\n      e2 = leaves[i]\n      i++\n    } else {\n      e2 = nodes[j]\n      j++\n    }\n    \n    nodes.append((e1.0 + e2.0, .Node(e1.1, e2.1)))\n  }\n}\n\nfunc getFreqs<S : SequenceType where S.Generator.Element : Hashable>(seq: S) -> [(S.Generator.Element, Int)] {\n  var freqs : [S.Generator.Element : Int] = [:]\n  for c in seq {\n    freqs[c] = (freqs[c] ?? 0) + 1\n  }\n  return Array(freqs)\n}\n\nlet str = \"this is an example for huffman encoding\"\nlet charFreqs = getFreqs(str.characters)\nlet tree = buildTree(charFreqs)\nprint(\"Symbol\\tHuffman code\")\ntree.printCodes(\"\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Huffman_Encoding\n{\n    public class PriorityQueue<T> where T : IComparable\n    {\n        protected List<T> LstHeap = new List<T>();\n\n        public virtual int Count\n        {\n            get { return LstHeap.Count; }\n        }\n\n        public virtual void Add(T val)\n        {\n            LstHeap.Add(val);\n            SetAt(LstHeap.Count - 1, val);\n            UpHeap(LstHeap.Count - 1);\n        }\n\n        public virtual T Peek()\n        {\n            if (LstHeap.Count == 0)\n            {\n                throw new IndexOutOfRangeException(\"Peeking at an empty priority queue\");\n            }\n\n            return LstHeap[0];\n        }\n\n        public virtual T Pop()\n        {\n            if (LstHeap.Count == 0)\n            {\n                throw new IndexOutOfRangeException(\"Popping an empty priority queue\");\n            }\n\n            T valRet = LstHeap[0];\n\n            SetAt(0, LstHeap[LstHeap.Count - 1]);\n            LstHeap.RemoveAt(LstHeap.Count - 1);\n            DownHeap(0);\n            return valRet;\n        }\n\n        protected virtual void SetAt(int i, T val)\n        {\n            LstHeap[i] = val;\n        }\n\n        protected bool RightSonExists(int i)\n        {\n            return RightChildIndex(i) < LstHeap.Count;\n        }\n\n        protected bool LeftSonExists(int i)\n        {\n            return LeftChildIndex(i) < LstHeap.Count;\n        }\n\n        protected int ParentIndex(int i)\n        {\n            return (i - 1) / 2;\n        }\n\n        protected int LeftChildIndex(int i)\n        {\n            return 2 * i + 1;\n        }\n\n        protected int RightChildIndex(int i)\n        {\n            return 2 * (i + 1);\n        }\n\n        protected T ArrayVal(int i)\n        {\n            return LstHeap[i];\n        }\n\n        protected T Parent(int i)\n        {\n            return LstHeap[ParentIndex(i)];\n        }\n\n        protected T Left(int i)\n        {\n            return LstHeap[LeftChildIndex(i)];\n        }\n\n        protected T Right(int i)\n        {\n            return LstHeap[RightChildIndex(i)];\n        }\n\n        protected void Swap(int i, int j)\n        {\n            T valHold = ArrayVal(i);\n            SetAt(i, LstHeap[j]);\n            SetAt(j, valHold);\n        }\n\n        protected void UpHeap(int i)\n        {\n            while (i > 0 && ArrayVal(i).CompareTo(Parent(i)) > 0)\n            {\n                Swap(i, ParentIndex(i));\n                i = ParentIndex(i);\n            }\n        }\n\n        protected void DownHeap(int i)\n        {\n            while (i >= 0)\n            {\n                int iContinue = -1;\n\n                if (RightSonExists(i) && Right(i).CompareTo(ArrayVal(i)) > 0)\n                {\n                    iContinue = Left(i).CompareTo(Right(i)) < 0 ? RightChildIndex(i) : LeftChildIndex(i);\n                }\n                else if (LeftSonExists(i) && Left(i).CompareTo(ArrayVal(i)) > 0)\n                {\n                    iContinue = LeftChildIndex(i);\n                }\n\n                if (iContinue >= 0 && iContinue < LstHeap.Count)\n                {\n                    Swap(i, iContinue);\n                }\n\n                i = iContinue;\n            }\n        }\n    }\n\n    internal class HuffmanNode<T> : IComparable\n    {\n        internal HuffmanNode(double probability, T value)\n        {\n            Probability = probability;\n            LeftSon = RightSon = Parent = null;\n            Value = value;\n            IsLeaf = true;\n        }\n\n        internal HuffmanNode(HuffmanNode<T> leftSon, HuffmanNode<T> rightSon)\n        {\n            LeftSon = leftSon;\n            RightSon = rightSon;\n            Probability = leftSon.Probability + rightSon.Probability;\n            leftSon.IsZero = true;\n            rightSon.IsZero = false;\n            leftSon.Parent = rightSon.Parent = this;\n            IsLeaf = false;\n        }\n\n        internal HuffmanNode<T> LeftSon { get; set; }\n        internal HuffmanNode<T> RightSon { get; set; }\n        internal HuffmanNode<T> Parent { get; set; }\n        internal T Value { get; set; }\n        internal bool IsLeaf { get; set; }\n\n        internal bool IsZero { get; set; }\n\n        internal int Bit\n        {\n            get { return IsZero ? 0 : 1; }\n        }\n\n        internal bool IsRoot\n        {\n            get { return Parent == null; }\n        }\n\n        internal double Probability { get; set; }\n\n        public int CompareTo(object obj)\n        {\n            return -Probability.CompareTo(((HuffmanNode<T>) obj).Probability);\n        }\n    }\n\n    public class Huffman<T> where T : IComparable\n    {\n        private readonly Dictionary<T, HuffmanNode<T>> _leafDictionary = new Dictionary<T, HuffmanNode<T>>();\n        private readonly HuffmanNode<T> _root;\n\n        public Huffman(IEnumerable<T> values)\n        {\n            var counts = new Dictionary<T, int>();\n            var priorityQueue = new PriorityQueue<HuffmanNode<T>>();\n            int valueCount = 0;\n\n            foreach (T value in values)\n            {\n                if (!counts.ContainsKey(value))\n                {\n                    counts[value] = 0;\n                }\n                counts[value]++;\n                valueCount++;\n            }\n\n            foreach (T value in counts.Keys)\n            {\n                var node = new HuffmanNode<T>((double) counts[value] / valueCount, value);\n                priorityQueue.Add(node);\n                _leafDictionary[value] = node;\n            }\n\n            while (priorityQueue.Count > 1)\n            {\n                HuffmanNode<T> leftSon = priorityQueue.Pop();\n                HuffmanNode<T> rightSon = priorityQueue.Pop();\n                var parent = new HuffmanNode<T>(leftSon, rightSon);\n                priorityQueue.Add(parent);\n            }\n\n            _root = priorityQueue.Pop();\n            _root.IsZero = false;\n        }\n\n        public List<int> Encode(T value)\n        {\n            var returnValue = new List<int>();\n            Encode(value, returnValue);\n            return returnValue;\n        }\n\n        public void Encode(T value, List<int> encoding)\n        {\n            if (!_leafDictionary.ContainsKey(value))\n            {\n                throw new ArgumentException(\"Invalid value in Encode\");\n            }\n            HuffmanNode<T> nodeCur = _leafDictionary[value];\n            var reverseEncoding = new List<int>();\n            while (!nodeCur.IsRoot)\n            {\n                reverseEncoding.Add(nodeCur.Bit);\n                nodeCur = nodeCur.Parent;\n            }\n\n            reverseEncoding.Reverse();\n            encoding.AddRange(reverseEncoding);\n        }\n\n        public List<int> Encode(IEnumerable<T> values)\n        {\n            var returnValue = new List<int>();\n\n            foreach (T value in values)\n            {\n                Encode(value, returnValue);\n            }\n            return returnValue;\n        }\n\n        public T Decode(List<int> bitString, ref int position)\n        {\n            HuffmanNode<T> nodeCur = _root;\n            while (!nodeCur.IsLeaf)\n            {\n                if (position > bitString.Count)\n                {\n                    throw new ArgumentException(\"Invalid bitstring in Decode\");\n                }\n                nodeCur = bitString[position++] == 0 ? nodeCur.LeftSon : nodeCur.RightSon;\n            }\n            return nodeCur.Value;\n        }\n\n        public List<T> Decode(List<int> bitString)\n        {\n            int position = 0;\n            var returnValue = new List<T>();\n\n            while (position != bitString.Count)\n            {\n                returnValue.Add(Decode(bitString, ref position));\n            }\n            return returnValue;\n        }\n    }\n\n    internal class Program\n    {\n        private const string Example = \"this is an example for huffman encoding\";\n\n        private static void Main()\n        {\n            var huffman = new Huffman<char>(Example);\n            List<int> encoding = huffman.Encode(Example);\n            List<char> decoding = huffman.Decode(encoding);\n            var outString = new string(decoding.ToArray());\n            Console.WriteLine(outString == Example ? \"Encoding/decoding worked\" : \"Encoding/Decoding failed\");\n\n            var chars = new HashSet<char>(Example);\n            foreach (char c in chars)\n            {\n                encoding = huffman.Encode(c);\n                Console.Write(\"{0}:  \", c);\n                foreach (int bit in encoding)\n                {\n                    Console.Write(\"{0}\", bit);\n                }\n                Console.WriteLine();\n            }\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 20036, "name": "Huffman coding", "source": "Translate Swift to Java: enum HuffmanTree<T> {\n  case Leaf(T)\n  indirect case Node(HuffmanTree<T>, HuffmanTree<T>)\n  \n  func printCodes(prefix: String) {\n    switch(self) {\n    case let .Leaf(c):\n      print(\"\\(c)\\t\\(prefix)\")\n    case let .Node(l, r):\n      l.printCodes(prefix + \"0\")\n      r.printCodes(prefix + \"1\")\n    }\n  }\n}\n\nfunc buildTree<T>(freqs: [(T, Int)]) -> HuffmanTree<T> {\n  assert(freqs.count > 0, \"must contain at least one character\")\n  \n  let leaves : [(Int, HuffmanTree<T>)] = freqs.sort { (p1, p2) in p1.1 < p2.1 }.map { (x, w) in (w, .Leaf(x)) }\n  \n  var nodes = [(Int, HuffmanTree<T>)]()\n  \n  for var i = 0, j = 0; ; {\n    assert(i < leaves.count || j < nodes.count)\n    \n    var e1 : (Int, HuffmanTree<T>)\n    if j == nodes.count || i < leaves.count && leaves[i].0 < nodes[j].0 {\n      e1 = leaves[i]\n      i++\n    } else {\n      e1 = nodes[j]\n      j++\n    }\n    \n    \n    if i == leaves.count && j == nodes.count {\n      return e1.1\n    }\n    \n    \n    var e2 : (Int, HuffmanTree<T>)\n    if j == nodes.count || i < leaves.count && leaves[i].0 < nodes[j].0 {\n      e2 = leaves[i]\n      i++\n    } else {\n      e2 = nodes[j]\n      j++\n    }\n    \n    nodes.append((e1.0 + e2.0, .Node(e1.1, e2.1)))\n  }\n}\n\nfunc getFreqs<S : SequenceType where S.Generator.Element : Hashable>(seq: S) -> [(S.Generator.Element, Int)] {\n  var freqs : [S.Generator.Element : Int] = [:]\n  for c in seq {\n    freqs[c] = (freqs[c] ?? 0) + 1\n  }\n  return Array(freqs)\n}\n\nlet str = \"this is an example for huffman encoding\"\nlet charFreqs = getFreqs(str.characters)\nlet tree = buildTree(charFreqs)\nprint(\"Symbol\\tHuffman code\")\ntree.printCodes(\"\")\n", "target": "import java.util.*;\n\nabstract class HuffmanTree implements Comparable<HuffmanTree> {\n    public final int frequency; \n    public HuffmanTree(int freq) { frequency = freq; }\n\n    \n    public int compareTo(HuffmanTree tree) {\n        return frequency - tree.frequency;\n    }\n}\n\nclass HuffmanLeaf extends HuffmanTree {\n    public final char value; \n   \n    public HuffmanLeaf(int freq, char val) {\n        super(freq);\n        value = val;\n    }\n}\n\nclass HuffmanNode extends HuffmanTree {\n    public final HuffmanTree left, right; \n   \n    public HuffmanNode(HuffmanTree l, HuffmanTree r) {\n        super(l.frequency + r.frequency);\n        left = l;\n        right = r;\n    }\n}\n\npublic class HuffmanCode {\n    \n    public static HuffmanTree buildTree(int[] charFreqs) {\n        PriorityQueue<HuffmanTree> trees = new PriorityQueue<HuffmanTree>();\n        \n        \n        for (int i = 0; i < charFreqs.length; i++)\n            if (charFreqs[i] > 0)\n                trees.offer(new HuffmanLeaf(charFreqs[i], (char)i));\n\n        assert trees.size() > 0;\n        \n        while (trees.size() > 1) {\n            \n            HuffmanTree a = trees.poll();\n            HuffmanTree b = trees.poll();\n\n            \n            trees.offer(new HuffmanNode(a, b));\n        }\n        return trees.poll();\n    }\n\n    public static void printCodes(HuffmanTree tree, StringBuffer prefix) {\n        assert tree != null;\n        if (tree instanceof HuffmanLeaf) {\n            HuffmanLeaf leaf = (HuffmanLeaf)tree;\n\n            \n            System.out.println(leaf.value + \"\\t\" + leaf.frequency + \"\\t\" + prefix);\n\n        } else if (tree instanceof HuffmanNode) {\n            HuffmanNode node = (HuffmanNode)tree;\n\n            \n            prefix.append('0');\n            printCodes(node.left, prefix);\n            prefix.deleteCharAt(prefix.length()-1);\n\n            \n            prefix.append('1');\n            printCodes(node.right, prefix);\n            prefix.deleteCharAt(prefix.length()-1);\n        }\n    }\n\n    public static void main(String[] args) {\n        String test = \"this is an example for huffman encoding\";\n\n        \n        \n        int[] charFreqs = new int[256];\n        \n        for (char c : test.toCharArray())\n            charFreqs[c]++;\n\n        \n        HuffmanTree tree = buildTree(charFreqs);\n\n        \n        System.out.println(\"SYMBOL\\tWEIGHT\\tHUFFMAN CODE\");\n        printCodes(tree, new StringBuffer());\n    }\n}\n"}
{"id": 20037, "name": "Huffman coding", "source": "Translate Swift to Python: enum HuffmanTree<T> {\n  case Leaf(T)\n  indirect case Node(HuffmanTree<T>, HuffmanTree<T>)\n  \n  func printCodes(prefix: String) {\n    switch(self) {\n    case let .Leaf(c):\n      print(\"\\(c)\\t\\(prefix)\")\n    case let .Node(l, r):\n      l.printCodes(prefix + \"0\")\n      r.printCodes(prefix + \"1\")\n    }\n  }\n}\n\nfunc buildTree<T>(freqs: [(T, Int)]) -> HuffmanTree<T> {\n  assert(freqs.count > 0, \"must contain at least one character\")\n  \n  let leaves : [(Int, HuffmanTree<T>)] = freqs.sort { (p1, p2) in p1.1 < p2.1 }.map { (x, w) in (w, .Leaf(x)) }\n  \n  var nodes = [(Int, HuffmanTree<T>)]()\n  \n  for var i = 0, j = 0; ; {\n    assert(i < leaves.count || j < nodes.count)\n    \n    var e1 : (Int, HuffmanTree<T>)\n    if j == nodes.count || i < leaves.count && leaves[i].0 < nodes[j].0 {\n      e1 = leaves[i]\n      i++\n    } else {\n      e1 = nodes[j]\n      j++\n    }\n    \n    \n    if i == leaves.count && j == nodes.count {\n      return e1.1\n    }\n    \n    \n    var e2 : (Int, HuffmanTree<T>)\n    if j == nodes.count || i < leaves.count && leaves[i].0 < nodes[j].0 {\n      e2 = leaves[i]\n      i++\n    } else {\n      e2 = nodes[j]\n      j++\n    }\n    \n    nodes.append((e1.0 + e2.0, .Node(e1.1, e2.1)))\n  }\n}\n\nfunc getFreqs<S : SequenceType where S.Generator.Element : Hashable>(seq: S) -> [(S.Generator.Element, Int)] {\n  var freqs : [S.Generator.Element : Int] = [:]\n  for c in seq {\n    freqs[c] = (freqs[c] ?? 0) + 1\n  }\n  return Array(freqs)\n}\n\nlet str = \"this is an example for huffman encoding\"\nlet charFreqs = getFreqs(str.characters)\nlet tree = buildTree(charFreqs)\nprint(\"Symbol\\tHuffman code\")\ntree.printCodes(\"\")\n", "target": "from heapq import heappush, heappop, heapify\nfrom collections import defaultdict\n\ndef encode(symb2freq):\n    \n    heap = [[wt, [sym, \"\"]] for sym, wt in symb2freq.items()]\n    heapify(heap)\n    while len(heap) > 1:\n        lo = heappop(heap)\n        hi = heappop(heap)\n        for pair in lo[1:]:\n            pair[1] = '0' + pair[1]\n        for pair in hi[1:]:\n            pair[1] = '1' + pair[1]\n        heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])\n    return sorted(heappop(heap)[1:], key=lambda p: (len(p[-1]), p))\n\ntxt = \"this is an example for huffman encoding\"\nsymb2freq = defaultdict(int)\nfor ch in txt:\n    symb2freq[ch] += 1\n\n\nhuff = encode(symb2freq)\nprint \"Symbol\\tWeight\\tHuffman Code\"\nfor p in huff:\n    print \"%s\\t%s\\t%s\" % (p[0], symb2freq[p[0]], p[1])\n"}
{"id": 20192, "name": "Primality by Wilson's theorem", "source": "Translate Swift to C#: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\n\nfunc isWilsonPrime<T: BinaryInteger>(_ n: T) -> Bool {\n  guard n >= 2 else {\n    return false\n  }\n\n  return (factorial(n - 1) + 1) % n == 0\n}\n\nprint((1...100).map({ BigInt($0) }).filter(isWilsonPrime))\n", "target": "using System;\nusing System.Linq;\nusing System.Collections;\nusing static System.Console;\nusing System.Collections.Generic;\nusing BI = System.Numerics.BigInteger;\n\nclass Program {\n\n  \n    const int fst = 120, skp = 1000, max = 1015; static double et1, et2; static DateTime st;\n    static string ms1 = \"Wilson's theorem method\", ms2 = \"Sieve of Eratosthenes method\", \n       fmt = \"--- {0} ---\\n\\nThe first {1} primes are:\", fm2 = \"{0} prime thru the {1} prime:\";\n    static List<int> lst = new List<int>();\n\n  \n    static void Dump(int s, int t, string f) {\n        foreach (var item in lst.Skip(s).Take(t)) Write(f, item); WriteLine(\"\\n\"); }\n\n  \n    static string Ord(int x, string fmt = \"{0:n0}\") {\n      var y = x % 10; if ((x % 100) / 10 == 10 || y > 3) y = 0;\n      return string.Format(fmt, x) + \"thstndrd\".Substring(y << 1, 2); }\n\n  \n    static void ShowOne(string title, ref double et) {\n        WriteLine(fmt, title, fst); Dump(0, fst, \"{0,-3} \");\n        WriteLine(fm2, Ord(skp), Ord(max)); Dump(skp - 1, max - skp + 1, \"{0,4} \");\n        WriteLine(\"Time taken: {0}ms\\n\", et = (DateTime.Now - st).TotalMilliseconds); }\n\n  \n    static BI factorial(int n) { BI res = 1; if (n < 2) return res;\n        while (n > 0) res *= n--; return res; }\n\n    static bool WTisPrimeSA(int n) { return ((factorial(n - 1) + 1) % n) == 0; }\n\n    static BI[] facts;\n\n    static void initFacts(int n) {\n        facts = new BI[n]; facts[0] = facts[1] = 1;\n        for (int i = 1, j = 2; j < n; i = j++)\n            facts[j] = facts[i] * j; }\n\n    static bool WTisPrime(int n) { return ((facts[n - 1] + 1) % n) == 0; }\n  \n\n    static void Main(string[] args) { st = DateTime.Now;\n        BI f = 1; for (int n = 2; lst.Count < max; f *= n++) if ((f + 1) % n == 0) lst.Add(n);\n        ShowOne(ms1, ref et1);\n        st = DateTime.Now; int lmt = lst.Last(); lst.Clear(); BitArray flags = new BitArray(lmt + 1);\n        for (int n = 2; n <= lmt; n+=n==2?1:2) if (!flags[n]) {\n                lst.Add(n); for (int k = n * n, n2=n<<1; k <= lmt; k += n2) flags[k] = true; }\n        ShowOne(ms2, ref et2);\n        WriteLine(\"{0} was {1:0.0} times slower than the {2}.\", ms1, et1 / et2, ms2);\n\n      \n        WriteLine(\"\\n\" + ms1 + \" stand-alone computation:\");\n        WriteLine(\"factorial computed for each item\");\n        st = DateTime.Now;\n        for (int x = lst[skp - 1]; x <= lst[max - 1]; x++) if (WTisPrimeSA(x)) Write(\"{0,4} \", x);\n        WriteLine(); WriteLine(\"\\nTime taken: {0}ms\\n\", (DateTime.Now - st).TotalMilliseconds);\n\n        WriteLine(\"factorials precomputed up to highest item\");\n        st = DateTime.Now; initFacts(lst[max - 1]);\n        for (int x = lst[skp - 1]; x <= lst[max - 1]; x++) if (WTisPrime(x)) Write(\"{0,4} \", x);\n        WriteLine(); WriteLine(\"\\nTime taken: {0}ms\\n\", (DateTime.Now - st).TotalMilliseconds);\n    }\n}\n"}
{"id": 20194, "name": "Primality by Wilson's theorem", "source": "Translate Swift to Java: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\n\nfunc isWilsonPrime<T: BinaryInteger>(_ n: T) -> Bool {\n  guard n >= 2 else {\n    return false\n  }\n\n  return (factorial(n - 1) + 1) % n == 0\n}\n\nprint((1...100).map({ BigInt($0) }).filter(isWilsonPrime))\n", "target": "import java.math.BigInteger;\n\npublic class PrimaltyByWilsonsTheorem {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Primes less than 100 testing by Wilson's Theorem%n\");\n        for ( int i = 0 ; i <= 100 ; i++ ) {\n            if ( isPrime(i) ) {\n                System.out.printf(\"%d \", i);\n            }\n        }\n    }\n    \n    \n    private static boolean isPrime(long p) {\n        if ( p <= 1) {\n            return false;\n        }\n        return fact(p-1).add(BigInteger.ONE).mod(BigInteger.valueOf(p)).compareTo(BigInteger.ZERO) == 0;\n    }\n    \n    private static BigInteger fact(long n) {\n        BigInteger fact = BigInteger.ONE;\n        for ( int i = 2 ; i <= n ; i++ ) {\n            fact = fact.multiply(BigInteger.valueOf(i));\n        }\n        return fact;\n    }\n\n}\n"}
{"id": 20195, "name": "Primality by Wilson's theorem", "source": "Translate Swift to Python: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\n\nfunc isWilsonPrime<T: BinaryInteger>(_ n: T) -> Bool {\n  guard n >= 2 else {\n    return false\n  }\n\n  return (factorial(n - 1) + 1) % n == 0\n}\n\nprint((1...100).map({ BigInt($0) }).filter(isWilsonPrime))\n", "target": "from math import factorial\n\ndef is_wprime(n):\n    return n == 2 or (\n        n > 1\n        and n % 2 != 0\n        and (factorial(n - 1) + 1) % n == 0\n    )\n\nif __name__ == '__main__':\n    c = int(input('Enter upper limit: '))\n    print(f'Primes under {c}:')\n    print([n for n in range(c) if is_wprime(n)])\n"}
{"id": 20565, "name": "Parallel calculations", "source": "Translate Swift to C#: import BigInt\nimport Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nlet numbers = [\n  112272537195293,\n  112582718962171,\n  112272537095293,\n  115280098190773,\n  115797840077099,\n  1099726829285419,\n  1275792312878611,\n  BigInt(\"64921987050997300559\")\n]\n\nfunc findLargestMinFactor<T: BinaryInteger>(for nums: [T], then: @escaping ((n: T, factors: [T])) -> ()) {\n  let waiter = DispatchSemaphore(value: 0)\n  let lock = DispatchSemaphore(value: 1)\n  var factors = [(n: T, factors: [T])]()\n\n  DispatchQueue.concurrentPerform(iterations: nums.count) {i in\n    let n = nums[i]\n\n    print(\"Factoring \\(n)\")\n\n    let nFacs = n.primeDecomposition().sorted()\n\n    print(\"Factored \\(n)\")\n\n    lock.wait()\n    factors.append((n, nFacs))\n\n    if factors.count == nums.count {\n      waiter.signal()\n    }\n\n    lock.signal()\n  }\n\n  waiter.wait()\n\n  then(factors.sorted(by: { $0.factors.first! > $1.factors.first! }).first!)\n}\n\nfindLargestMinFactor(for: numbers) {res in\n  let (n, factors) = res\n\n  print(\"Number with largest min prime factor: \\(n); factors: \\(factors)\")\n\n  exit(0)\n}\n\ndispatchMain()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    public static List<int> PrimeFactors(int number)\n    {\n        var primes = new List<int>();\n        for (int div = 2; div <= number; div++)\n        {\n            while (number % div == 0)\n            {\n                primes.Add(div);\n                number = number / div;\n            }\n        }\n        return primes;\n    }\n\n    static void Main(string[] args)\n    {\n        int[] n = { 12757923, 12878611, 12757923, 15808973, 15780709, 197622519 };\n        \n        var factors = n.AsParallel().Select(PrimeFactors).ToList();\n        \n        var smallestFactors = factors.Select(thisNumbersFactors => thisNumbersFactors.Min()).ToList();\n        \n        int biggestFactor = smallestFactors.Max();\n        int whatIndexIsThat = smallestFactors.IndexOf(biggestFactor);\n        Console.WriteLine(\"{0} has the largest minimum prime factor: {1}\", n[whatIndexIsThat], biggestFactor);\n        Console.WriteLine(string.Join(\" \", factors[whatIndexIsThat]));\n    }\n}\n"}
{"id": 20567, "name": "Parallel calculations", "source": "Translate Swift to Java: import BigInt\nimport Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nlet numbers = [\n  112272537195293,\n  112582718962171,\n  112272537095293,\n  115280098190773,\n  115797840077099,\n  1099726829285419,\n  1275792312878611,\n  BigInt(\"64921987050997300559\")\n]\n\nfunc findLargestMinFactor<T: BinaryInteger>(for nums: [T], then: @escaping ((n: T, factors: [T])) -> ()) {\n  let waiter = DispatchSemaphore(value: 0)\n  let lock = DispatchSemaphore(value: 1)\n  var factors = [(n: T, factors: [T])]()\n\n  DispatchQueue.concurrentPerform(iterations: nums.count) {i in\n    let n = nums[i]\n\n    print(\"Factoring \\(n)\")\n\n    let nFacs = n.primeDecomposition().sorted()\n\n    print(\"Factored \\(n)\")\n\n    lock.wait()\n    factors.append((n, nFacs))\n\n    if factors.count == nums.count {\n      waiter.signal()\n    }\n\n    lock.signal()\n  }\n\n  waiter.wait()\n\n  then(factors.sorted(by: { $0.factors.first! > $1.factors.first! }).first!)\n}\n\nfindLargestMinFactor(for: numbers) {res in\n  let (n, factors) = res\n\n  print(\"Number with largest min prime factor: \\(n); factors: \\(factors)\")\n\n  exit(0)\n}\n\ndispatchMain()\n", "target": "import static java.lang.System.out; \nimport static java.util.Arrays.stream;\nimport static java.util.Comparator.comparing;\n \npublic interface ParallelCalculations {\n    public static final long[] NUMBERS = {\n      12757923,\n      12878611,\n      12878893,\n      12757923,\n      15808973,\n      15780709,\n      197622519\n    };\n \n    public static void main(String... arguments) {\n      stream(NUMBERS)\n        .unordered()\n        .parallel()\n        .mapToObj(ParallelCalculations::minimalPrimeFactor)\n        .max(comparing(a -> a[0]))\n        .ifPresent(res -> out.printf(\n          \"%d has the largest minimum prime factor: %d%n\",\n          res[1],\n          res[0]\n        ));\n    }\n \n    public static long[] minimalPrimeFactor(long n) {\n      for (long i = 2; n >= i * i; i++) {\n        if (n % i == 0) {\n          return new long[]{i, n};\n        }\n      }\n      return new long[]{n, n};\n    }\n}\n"}
{"id": 20568, "name": "Parallel calculations", "source": "Translate Swift to Python: import BigInt\nimport Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nlet numbers = [\n  112272537195293,\n  112582718962171,\n  112272537095293,\n  115280098190773,\n  115797840077099,\n  1099726829285419,\n  1275792312878611,\n  BigInt(\"64921987050997300559\")\n]\n\nfunc findLargestMinFactor<T: BinaryInteger>(for nums: [T], then: @escaping ((n: T, factors: [T])) -> ()) {\n  let waiter = DispatchSemaphore(value: 0)\n  let lock = DispatchSemaphore(value: 1)\n  var factors = [(n: T, factors: [T])]()\n\n  DispatchQueue.concurrentPerform(iterations: nums.count) {i in\n    let n = nums[i]\n\n    print(\"Factoring \\(n)\")\n\n    let nFacs = n.primeDecomposition().sorted()\n\n    print(\"Factored \\(n)\")\n\n    lock.wait()\n    factors.append((n, nFacs))\n\n    if factors.count == nums.count {\n      waiter.signal()\n    }\n\n    lock.signal()\n  }\n\n  waiter.wait()\n\n  then(factors.sorted(by: { $0.factors.first! > $1.factors.first! }).first!)\n}\n\nfindLargestMinFactor(for: numbers) {res in\n  let (n, factors) = res\n\n  print(\"Number with largest min prime factor: \\(n); factors: \\(factors)\")\n\n  exit(0)\n}\n\ndispatchMain()\n", "target": "from concurrent import futures\nfrom math import floor, sqrt\n \nNUMBERS = [\n    112272537195293,\n    112582718962171,\n    112272537095293,\n    115280098190773,\n    115797840077099,\n    1099726829285419]\n\n \ndef lowest_factor(n, _start=3):\n    if n % 2 == 0:\n        return 2\n    search_max = int(floor(sqrt(n))) + 1\n    for i in range(_start, search_max, 2):\n        if n % i == 0:\n            return i\n    return n\n\ndef prime_factors(n, lowest):\n    pf = []\n    while n > 1:\n        pf.append(lowest)\n        n //= lowest\n        lowest = lowest_factor(n, max(lowest, 3))\n    return pf\n\ndef prime_factors_of_number_with_lowest_prime_factor(NUMBERS):\n    with futures.ProcessPoolExecutor() as executor:\n        low_factor, number = max( (l, f) for l, f in zip(executor.map(lowest_factor, NUMBERS), NUMBERS) )\n        all_factors = prime_factors(number, low_factor)\n        return number, all_factors\n\n \ndef main():\n    print('For these numbers:')\n    print('\\n  '.join(str(p) for p in NUMBERS))\n    number, all_factors = prime_factors_of_number_with_lowest_prime_factor(NUMBERS)\n    print('    The one with the largest minimum prime factor is {}:'.format(number))\n    print('      All its prime factors in order are: {}'.format(all_factors))\n \nif __name__ == '__main__':\n    main()\n"}
{"id": 20865, "name": "Reduced row echelon form", "source": "Translate Swift to C#:         var lead = 0\n        for r in 0..<rows {\n            if (cols <= lead) { break }\n            var i = r\n            while (m[i][lead] == 0) {\n                i += 1\n                if (i == rows) {\n                    i = r\n                    lead += 1\n                    if (cols == lead) {\n                        lead -= 1\n                        break\n                    }\n                }\n            }\n            for j in 0..<cols {\n                let temp = m[r][j]\n                m[r][j] = m[i][j]\n                m[i][j] = temp\n            }\n            let div = m[r][lead]\n            if (div != 0) {\n                for j in 0..<cols {\n                    m[r][j] /= div\n                }\n            }\n            for j in 0..<rows {\n                if (j != r) {\n                    let sub = m[j][lead]\n                    for k in 0..<cols {\n                        m[j][k] -= (sub * m[r][k])\n                    }\n                }\n            }\n            lead += 1\n        }\n", "target": "using System;\n\nnamespace rref\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[,] matrix = new int[3, 4]{\n                {  1, 2, -1,  -4 },\n                {  2, 3, -1, -11 },\n                { -2, 0, -3,  22 }\n            };\n            matrix = rref(matrix);   \n        }\n\n        private static int[,] rref(int[,] matrix)\n        {            \n            int lead = 0, rowCount = matrix.GetLength(0), columnCount = matrix.GetLength(1);\n            for (int r = 0; r < rowCount; r++)\n            {\n                if (columnCount <= lead) break;\n                int i = r;\n                while (matrix[i, lead] == 0)\n                {\n                    i++;\n                    if (i == rowCount)\n                    {\n                        i = r;\n                        lead++;\n                        if (columnCount == lead)\n                        {\n                        lead--;\n                        break;\n                        }\n                    }\n                }\n                for (int j = 0; j < columnCount; j++)\n                {\n                    int temp = matrix[r, j];\n                    matrix[r, j] = matrix[i, j];\n                    matrix[i, j] = temp;\n                }\n                int div = matrix[r, lead];\n                if(div != 0)\n                    for (int j = 0; j < columnCount; j++) matrix[r, j] /= div;                \n                for (int j = 0; j < rowCount; j++)\n                {\n                    if (j != r)\n                    {\n                        int sub = matrix[j, lead];\n                        for (int k = 0; k < columnCount; k++) matrix[j, k] -= (sub * matrix[r, k]);\n                    }\n                }\n                lead++;\n            }\n            return matrix;\n        }\n    }\n}\n"}
{"id": 20867, "name": "Reduced row echelon form", "source": "Translate Swift to Java:         var lead = 0\n        for r in 0..<rows {\n            if (cols <= lead) { break }\n            var i = r\n            while (m[i][lead] == 0) {\n                i += 1\n                if (i == rows) {\n                    i = r\n                    lead += 1\n                    if (cols == lead) {\n                        lead -= 1\n                        break\n                    }\n                }\n            }\n            for j in 0..<cols {\n                let temp = m[r][j]\n                m[r][j] = m[i][j]\n                m[i][j] = temp\n            }\n            let div = m[r][lead]\n            if (div != 0) {\n                for j in 0..<cols {\n                    m[r][j] /= div\n                }\n            }\n            for j in 0..<rows {\n                if (j != r) {\n                    let sub = m[j][lead]\n                    for k in 0..<cols {\n                        m[j][k] -= (sub * m[r][k])\n                    }\n                }\n            }\n            lead += 1\n        }\n", "target": "import java.util.*;\nimport java.lang.Math;\nimport org.apache.commons.math.fraction.Fraction;\nimport org.apache.commons.math.fraction.FractionConversionException;\n\n\nclass Matrix {\n\tLinkedList<LinkedList<Fraction>> matrix;\n\tint numRows;\n\tint numCols;\t\n\t\n\tstatic class Coordinate {\n\t\tint row;\n\t\tint col;\n\n\t\tCoordinate(int r, int c) {\n\t\t\trow = r;\n\t\t\tcol = c;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + row + \", \" + col + \")\";\n\t\t}\n\t}\n\n\tMatrix(double [][] m) {\n\t\tnumRows = m.length;\t\n\t\tnumCols = m[0].length;\n\n\t\tmatrix = new LinkedList<LinkedList<Fraction>>();\n\n\t\tfor (int i = 0; i < numRows; i++) {\n\t\t\tmatrix.add(new LinkedList<Fraction>());\n\t\t\tfor (int j = 0; j < numCols; j++) {\n\t\t\t\ttry {\n\t\t\t\t\tmatrix.get(i).add(new Fraction(m[i][j]));\n\t\t\t\t} catch (FractionConversionException e) {\n\t\t\t\t\tSystem.err.println(\"Fraction could not be converted from double by apache commons . . .\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void Interchange(Coordinate a, Coordinate b) {\n\t\tLinkedList<Fraction> temp = matrix.get(a.row);\n\t\tmatrix.set(a.row, matrix.get(b.row));\t\t\n\t\tmatrix.set(b.row, temp);\n\n\t\tint t = a.row;\n\t\ta.row = b.row;\n\t\tb.row = t;\n\t} \n\n\tpublic void Scale(Coordinate x, Fraction d) {\n\t\tLinkedList<Fraction> row = matrix.get(x.row);\n\t\tfor (int i = 0; i < numCols; i++) {\n\t\t\trow.set(i, row.get(i).multiply(d));\n\t\t}\n\t}\n\n\tpublic void MultiplyAndAdd(Coordinate to, Coordinate from, Fraction scalar) {\n\t\tLinkedList<Fraction> row = matrix.get(to.row);\n\t\tLinkedList<Fraction> rowMultiplied = matrix.get(from.row);\n\n\t\tfor (int i = 0; i < numCols; i++) {\n\t\t\trow.set(i, row.get(i).add((rowMultiplied.get(i).multiply(scalar))));\n\t\t}\n\t}\n\n\tpublic void RREF() {\n\t\tCoordinate pivot = new Coordinate(0,0);\n\n\t\tint submatrix = 0;\n\t\tfor (int x = 0; x < numCols; x++) {\n\t\t\tpivot = new Coordinate(pivot.row, x);\n\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int i = x; i < numCols; i++) {\n\t\t\t\t\tif (isColumnZeroes(pivot) == false) {\n\t\t\t\t\t\tbreak;\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpivot.col = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\tpivot = findPivot(pivot);\n\t\t\t\n\t\t\t\tif (getCoordinate(pivot).doubleValue() == 0.0) {\n\t\t\t\t\tpivot.row++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (pivot.row != submatrix) {\n\t\t\t\t\tInterchange(new Coordinate(submatrix, pivot.col), pivot);\n\t\t\t\t}\n\t\t\n\t\t\t\t\n\t\t\t\tif (getCoordinate(pivot).doubleValue() != 1) {\n\t\t\t\t\t\n\t\t\t\t\tFraction scalar = getCoordinate(pivot).reciprocal();\n\t\t\t\t\tScale(pivot, scalar);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int i = pivot.row; i < numRows; i++) {\n\t\t\t\t\tif (i == pivot.row) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tCoordinate belowPivot = new Coordinate(i, pivot.col);\n\t\t\t\t\tFraction complement = (getCoordinate(belowPivot).negate().divide(getCoordinate(pivot)));\n\t\t\t\t\tMultiplyAndAdd(belowPivot, pivot, complement);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\tfor (int i = pivot.row; i >= 0; i--) {\n\t\t\t\t\tif (i == pivot.row) {\n\t\t\t\t\t\tif (getCoordinate(pivot).doubleValue() != 1.0) {\n\t\t\t\t\t\t\tScale(pivot, getCoordinate(pivot).reciprocal());\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i == pivot.row) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tCoordinate abovePivot = new Coordinate(i, pivot.col);\n\t\t\t\t\tFraction complement = (getCoordinate(abovePivot).negate().divide(getCoordinate(pivot)));\n\t\t\t\t\tMultiplyAndAdd(abovePivot, pivot, complement);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif ((pivot.row + 1) >= numRows || isRowZeroes(new Coordinate(pivot.row+1, pivot.col))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsubmatrix++;\n\t\t\t\tpivot.row++;\n\t\t}\n\t}\n\t\n\tpublic boolean isColumnZeroes(Coordinate a) {\n\t\tfor (int i = 0; i < numRows; i++) {\n\t\t\tif (matrix.get(i).get(a.col).doubleValue() != 0.0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic boolean isRowZeroes(Coordinate a) {\n\t\tfor (int i = 0; i < numCols; i++) {\n\t\t\tif (matrix.get(a.row).get(i).doubleValue() != 0.0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic Coordinate findPivot(Coordinate a) {\n\t\tint first_row = a.row;\n\t\tCoordinate pivot = new Coordinate(a.row, a.col);\n\t\tCoordinate current = new Coordinate(a.row, a.col);\t\n\n\t\tfor (int i = a.row; i < (numRows - first_row); i++) {\n\t\t\tcurrent.row = i;\n\t\t\tif (getCoordinate(current).doubleValue() == 1.0) {\n\t\t\t\tInterchange(current, a);\n\t\t\t}\n\t\t}\n\n\t\tcurrent.row = a.row;\n\t\tfor (int i = current.row; i < (numRows - first_row); i++) {\n\t\t\tcurrent.row = i;\n\t\t\tif (getCoordinate(current).doubleValue() != 0) {\n\t\t\t\tpivot.row = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\t\n\t\treturn pivot;\t\n\t}\t\n\n\tpublic Fraction getCoordinate(Coordinate a) {\n\t\treturn matrix.get(a.row).get(a.col);\n\t}\n\n\tpublic String toString() {\n\t\treturn matrix.toString().replace(\"], \", \"]\\n\");\n\t}\n\n\tpublic static void main (String[] args) {\n        \tdouble[][] matrix_1 = {\n\t\t\t{1, 2, -1, -4},\n\t\t\t{2, 3, -1, -11},\n\t\t\t{-2, 0, -3, 22}\n\t\t};\n\n\t\tMatrix x = new Matrix(matrix_1);\n\t\tSystem.out.println(\"before\\n\" + x.toString() + \"\\n\");\n\t\tx.RREF();\n\t\tSystem.out.println(\"after\\n\" + x.toString() + \"\\n\");\n\n\t\tdouble matrix_2 [][] = {\n\t\t\t{2, 0, -1, 0, 0},\n\t\t\t{1, 0, 0, -1, 0},\n\t\t\t{3, 0, 0, -2, -1},\n\t\t\t{0, 1, 0, 0, -2},\n\t\t\t{0, 1, -1, 0, 0}\n\t\t};\n\t\n\t\tMatrix y = new Matrix(matrix_2);\n\t\tSystem.out.println(\"before\\n\" + y.toString() + \"\\n\");\n\t\ty.RREF();\n\t\tSystem.out.println(\"after\\n\" + y.toString() + \"\\n\");\n\n\t\tdouble matrix_3 [][] = {\n\t\t\t{1, 2, 3, 4, 3, 1},\n\t\t\t{2, 4, 6, 2, 6, 2},\n\t\t\t{3, 6, 18, 9, 9, -6},\n\t\t\t{4, 8, 12, 10, 12, 4},\n\t\t\t{5, 10, 24, 11, 15, -4}\n\t\t};\n\n\t\tMatrix z = new Matrix(matrix_3);\n\t\tSystem.out.println(\"before\\n\" + z.toString() + \"\\n\");\n\t\tz.RREF();\n\t\tSystem.out.println(\"after\\n\" + z.toString() + \"\\n\");\n\n\t\tdouble matrix_4 [][] = {\n\t\t\t{0, 1},\n\t\t\t{1, 2},\n\t\t\t{0,5}\n\t\t};\n\n\t\tMatrix a = new Matrix(matrix_4);\n\t\tSystem.out.println(\"before\\n\" + a.toString() + \"\\n\");\n\t\ta.RREF();\n\t\tSystem.out.println(\"after\\n\" + a.toString() + \"\\n\");\n\t}\t\n}\n"}
{"id": 20868, "name": "Reduced row echelon form", "source": "Translate Swift to Python:         var lead = 0\n        for r in 0..<rows {\n            if (cols <= lead) { break }\n            var i = r\n            while (m[i][lead] == 0) {\n                i += 1\n                if (i == rows) {\n                    i = r\n                    lead += 1\n                    if (cols == lead) {\n                        lead -= 1\n                        break\n                    }\n                }\n            }\n            for j in 0..<cols {\n                let temp = m[r][j]\n                m[r][j] = m[i][j]\n                m[i][j] = temp\n            }\n            let div = m[r][lead]\n            if (div != 0) {\n                for j in 0..<cols {\n                    m[r][j] /= div\n                }\n            }\n            for j in 0..<rows {\n                if (j != r) {\n                    let sub = m[j][lead]\n                    for k in 0..<cols {\n                        m[j][k] -= (sub * m[r][k])\n                    }\n                }\n            }\n            lead += 1\n        }\n", "target": "def ToReducedRowEchelonForm( M):\n    if not M: return\n    lead = 0\n    rowCount = len(M)\n    columnCount = len(M[0])\n    for r in range(rowCount):\n        if lead >= columnCount:\n            return\n        i = r\n        while M[i][lead] == 0:\n            i += 1\n            if i == rowCount:\n                i = r\n                lead += 1\n                if columnCount == lead:\n                    return\n        M[i],M[r] = M[r],M[i]\n        lv = M[r][lead]\n        M[r] = [ mrx / float(lv) for mrx in M[r]]\n        for i in range(rowCount):\n            if i != r:\n                lv = M[i][lead]\n                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]\n        lead += 1\n\n\nmtx = [\n   [ 1, 2, -1, -4],\n   [ 2, 3, -1, -11],\n   [-2, 0, -3, 22],]\n\nToReducedRowEchelonForm( mtx )\n\nfor rw in mtx:\n  print ', '.join( (str(rv) for rv in rw) )\n"}
{"id": 21124, "name": "Power set", "source": "Translate Swift to C#: func powersetFrom<T>(_ elements: Set<T>) -> Set<Set<T>> {\n  guard elements.count > 0 else {\n    return [[]]\n  }\n  var powerset: Set<Set<T>> = [[]]\n  for element in elements {\n    for subset in powerset {\n      powerset.insert(subset.union([element]))\n    }\n  }\n  return powerset\n}\n\n\npowersetFrom([1, 2, 4])\n", "target": "public IEnumerable<IEnumerable<T>> GetPowerSet<T>(List<T> list)\n{\n    return from m in Enumerable.Range(0, 1 << list.Count)\n                  select\n                      from i in Enumerable.Range(0, list.Count)\n                      where (m & (1 << i)) != 0\n                      select list[i];\n}\n\npublic void PowerSetofColors()\n{\n    var colors = new List<KnownColor> { KnownColor.Red, KnownColor.Green, \n        KnownColor.Blue, KnownColor.Yellow };\n    \n    var result = GetPowerSet(colors);\n    \n    Console.Write( string.Join( Environment.NewLine, \n        result.Select(subset => \n            string.Join(\",\", subset.Select(clr => clr.ToString()).ToArray())).ToArray()));\n}\n"}
{"id": 21126, "name": "Power set", "source": "Translate Swift to Java: func powersetFrom<T>(_ elements: Set<T>) -> Set<Set<T>> {\n  guard elements.count > 0 else {\n    return [[]]\n  }\n  var powerset: Set<Set<T>> = [[]]\n  for element in elements {\n    for subset in powerset {\n      powerset.insert(subset.union([element]))\n    }\n  }\n  return powerset\n}\n\n\npowersetFrom([1, 2, 4])\n", "target": "public static ArrayList<String> getpowerset(int a[],int n,ArrayList<String> ps)\n    {\n        if(n<0)\n        {\n            return null;\n        }\n        if(n==0)\n        {\n            if(ps==null)\n                ps=new ArrayList<String>();\n            ps.add(\" \");\n            return ps;\n        }\n        ps=getpowerset(a, n-1, ps);\n        ArrayList<String> tmp=new ArrayList<String>();\n        for(String s:ps)\n        {\n            if(s.equals(\" \"))\n                tmp.add(\"\"+a[n-1]);\n            else\n                tmp.add(s+a[n-1]);\n        }\n        ps.addAll(tmp);\n        return ps;\n    }\n"}
{"id": 21127, "name": "Power set", "source": "Translate Swift to Python: func powersetFrom<T>(_ elements: Set<T>) -> Set<Set<T>> {\n  guard elements.count > 0 else {\n    return [[]]\n  }\n  var powerset: Set<Set<T>> = [[]]\n  for element in elements {\n    for subset in powerset {\n      powerset.insert(subset.union([element]))\n    }\n  }\n  return powerset\n}\n\n\npowersetFrom([1, 2, 4])\n", "target": "def list_powerset(lst):\n    \n    result = [[]]\n    for x in lst:\n        \n        \n        \n        \n        \n        \n        result.extend([subset + [x] for subset in result])\n    return result\n\n\ndef list_powerset2(lst):\n    return reduce(lambda result, x: result + [subset + [x] for subset in result],\n                  lst, [[]])\n\ndef powerset(s):\n    return frozenset(map(frozenset, list_powerset(list(s))))\n"}
{"id": 21552, "name": "Topological sort", "source": "Translate Swift to C#: let libs = [\n  (\"des_system_lib\", [\"std\", \"synopsys\", \"std_cell_lib\", \"des_system_lib\", \"dw02\", \"dw01\", \"ramlib\", \"ieee\"]),\n  (\"dw01\", [\"ieee\", \"dw01\", \"dware\", \"gtech\"]),\n  (\"dw02\", [\"ieee\", \"dw02\", \"dware\"]),\n  (\"dw03\", [\"std\", \"synopsys\", \"dware\", \"dw03\", \"dw02\", \"dw01\", \"ieee\", \"gtech\"]),\n  (\"dw04\", [\"dw04\", \"ieee\", \"dw01\", \"dware\", \"gtech\"]),\n  (\"dw05\", [\"dw05\", \"ieee\", \"dware\"]),\n  (\"dw06\", [\"dw06\", \"ieee\", \"dware\"]),\n  (\"dw07\", [\"ieee\", \"dware\"]),\n  (\"dware\", [\"ieee\", \"dware\"]),\n  (\"gtech\", [\"ieee\", \"gtech\"]),\n  (\"ramlib\", [\"std\", \"ieee\"]),\n  (\"std_cell_lib\", [\"ieee\", \"std_cell_lib\"]),\n  (\"synopsys\", [])\n]\n\nstruct Library {\n  var name: String\n  var children: [String]\n  var numParents: Int\n}\n\nfunc buildLibraries(_ input: [(String, [String])]) -> [String: Library] {\n  var libraries = [String: Library]()\n\n  for (name, parents) in input {\n    var numParents = 0\n\n    for parent in parents where parent != name {\n      numParents += 1\n\n      libraries[parent, default: Library(name: parent, children: [], numParents: 0)].children.append(name)\n    }\n\n    libraries[name, default: Library(name: name, children: [], numParents: numParents)].numParents = numParents\n  }\n\n  return libraries\n}\n\nfunc topologicalSort(libs: [String: Library]) -> [String]? {\n  var libs = libs\n  var needsProcessing = Set(libs.keys)\n  var options = libs.compactMap({ $0.value.numParents == 0 ? $0.key : nil })\n  var sorted = [String]()\n\n  while let cur = options.popLast() {\n    for children in libs[cur]?.children ?? [] {\n      libs[children]?.numParents -= 1\n\n      if libs[children]?.numParents == 0 {\n        options.append(libs[children]!.name)\n      }\n    }\n\n    libs[cur]?.children.removeAll()\n\n    sorted.append(cur)\n    needsProcessing.remove(cur)\n  }\n\n  guard needsProcessing.isEmpty else {\n    return nil\n  }\n\n  return sorted\n}\n\nprint(topologicalSort(libs: buildLibraries(libs))!)\n", "target": "namespace Algorithms\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    public class TopologicalSorter<ValueType>\n    {\n        private class Relations\n        {\n            public int Dependencies = 0;\n            public HashSet<ValueType> Dependents = new HashSet<ValueType>();\n        }\n\n        private Dictionary<ValueType, Relations> _map = new Dictionary<ValueType, Relations>();\n\n        public void Add(ValueType obj)\n        {\n            if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());\n        }\n\n        public void Add(ValueType obj, ValueType dependency)\n        {\n            if (dependency.Equals(obj)) return;\n\n            if (!_map.ContainsKey(dependency)) _map.Add(dependency, new Relations());\n\n            var dependents = _map[dependency].Dependents;\n\n            if (!dependents.Contains(obj))\n            {\n                dependents.Add(obj);\n\n                if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());\n\n                ++_map[obj].Dependencies;\n            }\n        }\n\n        public void Add(ValueType obj, IEnumerable<ValueType> dependencies)\n        {\n            foreach (var dependency in dependencies) Add(obj, dependency);\n        }\n\n        public void Add(ValueType obj, params ValueType[] dependencies)\n        {\n            Add(obj, dependencies as IEnumerable<ValueType>);\n        }\n\n        public Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>> Sort()\n        {\n            List<ValueType> sorted = new List<ValueType>(), cycled = new List<ValueType>();\n            var map = _map.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);\n\n            sorted.AddRange(map.Where(kvp => kvp.Value.Dependencies == 0).Select(kvp => kvp.Key));\n\n            for (int idx = 0; idx < sorted.Count; ++idx) sorted.AddRange(map[sorted[idx]].Dependents.Where(k => --map[k].Dependencies == 0));\n\n            cycled.AddRange(map.Where(kvp => kvp.Value.Dependencies != 0).Select(kvp => kvp.Key));\n\n            return new Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>>(sorted, cycled);\n        }\n\n        public void Clear()\n        {\n            _map.Clear();\n        }\n    }\n\n}\n\n\n\nnamespace ExampleApplication\n{\n    using Algorithms;\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    public class Task\n    {\n        public string Message;\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<Task> tasks = new List<Task>\n            {\n                new Task{ Message = \"A - depends on B and C\" },    \n                new Task{ Message = \"B - depends on none\" },       \n                new Task{ Message = \"C - depends on D and E\" },    \n                new Task{ Message = \"D - depends on none\" },       \n                new Task{ Message = \"E - depends on F, G and H\" }, \n                new Task{ Message = \"F - depends on I\" },          \n                new Task{ Message = \"G - depends on none\" },       \n                new Task{ Message = \"H - depends on none\" },       \n                new Task{ Message = \"I - depends on none\" },       \n            };\n\n            TopologicalSorter<Task> resolver = new TopologicalSorter<Task>();\n\n            \n            resolver.Add(tasks[0], new[] { tasks[1], tasks[2] });\n            \n            resolver.Add(tasks[2], new[] { tasks[3], tasks[4] });\n            \n            resolver.Add(tasks[4], tasks[5], tasks[6], tasks[7]);\n            resolver.Add(tasks[5], tasks[8]);\n            \n            \n\n            \n\n            var result = resolver.Sort();\n            var sorted = result.Item1;\n            var cycled = result.Item2;\n\n            if (!cycled.Any())\n            {\n                foreach (var d in sorted) Console.WriteLine(d.Message);\n            }\n            else\n            {\n                Console.Write(\"Cycled dependencies detected: \");\n\n                foreach (var d in cycled) Console.Write($\"{d.Message[0]} \");\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine(\"exiting...\");\n        }\n    }\n}\n"}
{"id": 21554, "name": "Topological sort", "source": "Translate Swift to Java: let libs = [\n  (\"des_system_lib\", [\"std\", \"synopsys\", \"std_cell_lib\", \"des_system_lib\", \"dw02\", \"dw01\", \"ramlib\", \"ieee\"]),\n  (\"dw01\", [\"ieee\", \"dw01\", \"dware\", \"gtech\"]),\n  (\"dw02\", [\"ieee\", \"dw02\", \"dware\"]),\n  (\"dw03\", [\"std\", \"synopsys\", \"dware\", \"dw03\", \"dw02\", \"dw01\", \"ieee\", \"gtech\"]),\n  (\"dw04\", [\"dw04\", \"ieee\", \"dw01\", \"dware\", \"gtech\"]),\n  (\"dw05\", [\"dw05\", \"ieee\", \"dware\"]),\n  (\"dw06\", [\"dw06\", \"ieee\", \"dware\"]),\n  (\"dw07\", [\"ieee\", \"dware\"]),\n  (\"dware\", [\"ieee\", \"dware\"]),\n  (\"gtech\", [\"ieee\", \"gtech\"]),\n  (\"ramlib\", [\"std\", \"ieee\"]),\n  (\"std_cell_lib\", [\"ieee\", \"std_cell_lib\"]),\n  (\"synopsys\", [])\n]\n\nstruct Library {\n  var name: String\n  var children: [String]\n  var numParents: Int\n}\n\nfunc buildLibraries(_ input: [(String, [String])]) -> [String: Library] {\n  var libraries = [String: Library]()\n\n  for (name, parents) in input {\n    var numParents = 0\n\n    for parent in parents where parent != name {\n      numParents += 1\n\n      libraries[parent, default: Library(name: parent, children: [], numParents: 0)].children.append(name)\n    }\n\n    libraries[name, default: Library(name: name, children: [], numParents: numParents)].numParents = numParents\n  }\n\n  return libraries\n}\n\nfunc topologicalSort(libs: [String: Library]) -> [String]? {\n  var libs = libs\n  var needsProcessing = Set(libs.keys)\n  var options = libs.compactMap({ $0.value.numParents == 0 ? $0.key : nil })\n  var sorted = [String]()\n\n  while let cur = options.popLast() {\n    for children in libs[cur]?.children ?? [] {\n      libs[children]?.numParents -= 1\n\n      if libs[children]?.numParents == 0 {\n        options.append(libs[children]!.name)\n      }\n    }\n\n    libs[cur]?.children.removeAll()\n\n    sorted.append(cur)\n    needsProcessing.remove(cur)\n  }\n\n  guard needsProcessing.isEmpty else {\n    return nil\n  }\n\n  return sorted\n}\n\nprint(topologicalSort(libs: buildLibraries(libs))!)\n", "target": "import java.util.*;\n\npublic class TopologicalSort {\n\n    public static void main(String[] args) {\n        String s = \"std, ieee, des_system_lib, dw01, dw02, dw03, dw04, dw05,\"\n                + \"dw06, dw07, dware, gtech, ramlib, std_cell_lib, synopsys\";\n\n        Graph g = new Graph(s, new int[][]{\n            {2, 0}, {2, 14}, {2, 13}, {2, 4}, {2, 3}, {2, 12}, {2, 1},\n            {3, 1}, {3, 10}, {3, 11},\n            {4, 1}, {4, 10},\n            {5, 0}, {5, 14}, {5, 10}, {5, 4}, {5, 3}, {5, 1}, {5, 11},\n            {6, 1}, {6, 3}, {6, 10}, {6, 11},\n            {7, 1}, {7, 10},\n            {8, 1}, {8, 10},\n            {9, 1}, {9, 10},\n            {10, 1},\n            {11, 1},\n            {12, 0}, {12, 1},\n            {13, 1}\n        });\n\n        System.out.println(\"Topologically sorted order: \");\n        System.out.println(g.topoSort());\n    }\n}\n\nclass Graph {\n    String[] vertices;\n    boolean[][] adjacency;\n    int numVertices;\n\n    public Graph(String s, int[][] edges) {\n        vertices = s.split(\",\");\n        numVertices = vertices.length;\n        adjacency = new boolean[numVertices][numVertices];\n\n        for (int[] edge : edges)\n            adjacency[edge[0]][edge[1]] = true;\n    }\n\n    List<String> topoSort() {\n        List<String> result = new ArrayList<>();\n        List<Integer> todo = new LinkedList<>();\n\n        for (int i = 0; i < numVertices; i++)\n            todo.add(i);\n\n        try {\n            outer:\n            while (!todo.isEmpty()) {\n                for (Integer r : todo) {\n                    if (!hasDependency(r, todo)) {\n                        todo.remove(r);\n                        result.add(vertices[r]);\n                         \n                        continue outer;\n                    }\n                }\n                throw new Exception(\"Graph has cycles\");\n            }\n        } catch (Exception e) {\n            System.out.println(e);\n            return null;\n        }\n        return result;\n    }\n\n    boolean hasDependency(Integer r, List<Integer> todo) {\n        for (Integer c : todo) {\n            if (adjacency[r][c])\n                return true;\n        }\n        return false;\n    }\n}\n"}
{"id": 21555, "name": "Topological sort", "source": "Translate Swift to Python: let libs = [\n  (\"des_system_lib\", [\"std\", \"synopsys\", \"std_cell_lib\", \"des_system_lib\", \"dw02\", \"dw01\", \"ramlib\", \"ieee\"]),\n  (\"dw01\", [\"ieee\", \"dw01\", \"dware\", \"gtech\"]),\n  (\"dw02\", [\"ieee\", \"dw02\", \"dware\"]),\n  (\"dw03\", [\"std\", \"synopsys\", \"dware\", \"dw03\", \"dw02\", \"dw01\", \"ieee\", \"gtech\"]),\n  (\"dw04\", [\"dw04\", \"ieee\", \"dw01\", \"dware\", \"gtech\"]),\n  (\"dw05\", [\"dw05\", \"ieee\", \"dware\"]),\n  (\"dw06\", [\"dw06\", \"ieee\", \"dware\"]),\n  (\"dw07\", [\"ieee\", \"dware\"]),\n  (\"dware\", [\"ieee\", \"dware\"]),\n  (\"gtech\", [\"ieee\", \"gtech\"]),\n  (\"ramlib\", [\"std\", \"ieee\"]),\n  (\"std_cell_lib\", [\"ieee\", \"std_cell_lib\"]),\n  (\"synopsys\", [])\n]\n\nstruct Library {\n  var name: String\n  var children: [String]\n  var numParents: Int\n}\n\nfunc buildLibraries(_ input: [(String, [String])]) -> [String: Library] {\n  var libraries = [String: Library]()\n\n  for (name, parents) in input {\n    var numParents = 0\n\n    for parent in parents where parent != name {\n      numParents += 1\n\n      libraries[parent, default: Library(name: parent, children: [], numParents: 0)].children.append(name)\n    }\n\n    libraries[name, default: Library(name: name, children: [], numParents: numParents)].numParents = numParents\n  }\n\n  return libraries\n}\n\nfunc topologicalSort(libs: [String: Library]) -> [String]? {\n  var libs = libs\n  var needsProcessing = Set(libs.keys)\n  var options = libs.compactMap({ $0.value.numParents == 0 ? $0.key : nil })\n  var sorted = [String]()\n\n  while let cur = options.popLast() {\n    for children in libs[cur]?.children ?? [] {\n      libs[children]?.numParents -= 1\n\n      if libs[children]?.numParents == 0 {\n        options.append(libs[children]!.name)\n      }\n    }\n\n    libs[cur]?.children.removeAll()\n\n    sorted.append(cur)\n    needsProcessing.remove(cur)\n  }\n\n  guard needsProcessing.isEmpty else {\n    return nil\n  }\n\n  return sorted\n}\n\nprint(topologicalSort(libs: buildLibraries(libs))!)\n", "target": "try:\n    from functools import reduce\nexcept:\n    pass\n\ndata = {\n    'des_system_lib':   set('std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee'.split()),\n    'dw01':             set('ieee dw01 dware gtech'.split()),\n    'dw02':             set('ieee dw02 dware'.split()),\n    'dw03':             set('std synopsys dware dw03 dw02 dw01 ieee gtech'.split()),\n    'dw04':             set('dw04 ieee dw01 dware gtech'.split()),\n    'dw05':             set('dw05 ieee dware'.split()),\n    'dw06':             set('dw06 ieee dware'.split()),\n    'dw07':             set('ieee dware'.split()),\n    'dware':            set('ieee dware'.split()),\n    'gtech':            set('ieee gtech'.split()),\n    'ramlib':           set('std ieee'.split()),\n    'std_cell_lib':     set('ieee std_cell_lib'.split()),\n    'synopsys':         set(),\n    }\n\ndef toposort2(data):\n    for k, v in data.items():\n        v.discard(k) \n    extra_items_in_deps = reduce(set.union, data.values()) - set(data.keys())\n    data.update({item:set() for item in extra_items_in_deps})\n    while True:\n        ordered = set(item for item,dep in data.items() if not dep)\n        if not ordered:\n            break\n        yield ' '.join(sorted(ordered))\n        data = {item: (dep - ordered) for item,dep in data.items()\n                if item not in ordered}\n    assert not data, \"A cyclic dependency exists amongst %r\" % data\n\nprint ('\\n'.join( toposort2(data) ))\n"}
{"id": 21970, "name": "Doubly-linked list_Element definition", "source": "Translate Swift to C#: typealias NodePtr<T> = UnsafeMutablePointer<Node<T>>\n\nclass Node<T> {\n  var value: T\n  fileprivate var prev: NodePtr<T>?\n  fileprivate var next: NodePtr<T>?\n\n  init(value: T, prev: NodePtr<T>? = nil, next: NodePtr<T>? = nil) {\n    self.value = value\n    self.prev = prev\n    self.next = next\n  }\n}\n", "target": "class Link\n{\n    public int Item { get; set; }\n    public Link Prev { get; set; }\n    public Link Next { get; set; }\n\n    \n    public Link(int item, Link prev = null, Link next = null) {\n        Item = item;\n        Prev = prev;\n        Next = next;\n    }\n}\n"}
{"id": 21972, "name": "Doubly-linked list_Element definition", "source": "Translate Swift to Java: typealias NodePtr<T> = UnsafeMutablePointer<Node<T>>\n\nclass Node<T> {\n  var value: T\n  fileprivate var prev: NodePtr<T>?\n  fileprivate var next: NodePtr<T>?\n\n  init(value: T, prev: NodePtr<T>? = nil, next: NodePtr<T>? = nil) {\n    self.value = value\n    self.prev = prev\n    self.next = next\n  }\n}\n", "target": "public class Node<T> {\n   private T element;\n   private Node<T> next, prev;\n\n   public Node<T>(){\n      next = prev = element = null;\n   }\n\n   public Node<T>(Node<T> n, Node<T> p, T elem){\n      next = n;\n      prev = p;\n      element = elem;\n   }\n\n   public void setNext(Node<T> n){\n      next = n;\n   }\n\n   public Node<T> getNext(){\n      return next;\n   }\n\n   public void setElem(T elem){\n      element = elem;\n   }\n\n   public T getElem(){\n      return element;\n   }\n\n   public void setNext(Node<T> n){\n      next = n;\n   }\n\n   public Node<T> setPrev(Node<T> p){\n      prev = p;\n   }\n\n   public getPrev(){\n      return prev;\n   }\n}\n"}
{"id": 21973, "name": "Doubly-linked list_Element definition", "source": "Translate Swift to Python: typealias NodePtr<T> = UnsafeMutablePointer<Node<T>>\n\nclass Node<T> {\n  var value: T\n  fileprivate var prev: NodePtr<T>?\n  fileprivate var next: NodePtr<T>?\n\n  init(value: T, prev: NodePtr<T>? = nil, next: NodePtr<T>? = nil) {\n    self.value = value\n    self.prev = prev\n    self.next = next\n  }\n}\n", "target": "class Node(object):\n     def __init__(self, data = None, prev = None, next = None):\n         self.prev = prev\n         self.next = next\n         self.data = data\n     def __str__(self):\n         return str(self.data)\n     def __repr__(self):\n         return repr(self.data)\n     def iter_forward(self):\n         c = self\n         while c != None:\n             yield c\n             c = c.next\n     def iter_backward(self):\n         c = self\n         while c != None:\n             yield c\n             c = c.prev\n"}
{"id": 22436, "name": "Dot product", "source": "Translate Swift to C#: func dot(v1: [Double], v2: [Double]) -> Double {\n  return reduce(lazy(zip(v1, v2)).map(*), 0, +)\n}\n\nprintln(dot([1, 3, -5], [4, -2, -1]))\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(DotProduct(new decimal[] { 1, 3, -5 }, new decimal[] { 4, -2, -1 }));\n\tConsole.Read();\n}\n\nprivate static decimal DotProduct(decimal[] vec1, decimal[] vec2) \n{\n\tif (vec1 == null)\n\t\treturn 0;\n\n\tif (vec2 == null)\n\t\treturn 0;\n\n\tif (vec1.Length != vec2.Length)\n\t\treturn 0;\n\n\tdecimal tVal = 0;\n\tfor (int x = 0; x < vec1.Length; x++)\n\t{\n\t\ttVal += vec1[x] * vec2[x];\n\t}\n\n\treturn tVal;\n}\n"}
{"id": 22437, "name": "Dot product", "source": "Translate Swift to C#: func dot(v1: [Double], v2: [Double]) -> Double {\n  return reduce(lazy(zip(v1, v2)).map(*), 0, +)\n}\n\nprintln(dot([1, 3, -5], [4, -2, -1]))\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(DotProduct(new decimal[] { 1, 3, -5 }, new decimal[] { 4, -2, -1 }));\n\tConsole.Read();\n}\n\nprivate static decimal DotProduct(decimal[] vec1, decimal[] vec2) \n{\n\tif (vec1 == null)\n\t\treturn 0;\n\n\tif (vec2 == null)\n\t\treturn 0;\n\n\tif (vec1.Length != vec2.Length)\n\t\treturn 0;\n\n\tdecimal tVal = 0;\n\tfor (int x = 0; x < vec1.Length; x++)\n\t{\n\t\ttVal += vec1[x] * vec2[x];\n\t}\n\n\treturn tVal;\n}\n"}
{"id": 22440, "name": "Dot product", "source": "Translate Swift to Java: func dot(v1: [Double], v2: [Double]) -> Double {\n  return reduce(lazy(zip(v1, v2)).map(*), 0, +)\n}\n\nprintln(dot([1, 3, -5], [4, -2, -1]))\n", "target": "public class DotProduct {\n\t\n\tpublic static void main(String[] args) {\n\t\tdouble[] a = {1, 3, -5};\n\t\tdouble[] b = {4, -2, -1};\n\t\t\n\t\tSystem.out.println(dotProd(a,b));\n\t}\n\t\n\tpublic static double dotProd(double[] a, double[] b){\n\t\tif(a.length != b.length){\n\t\t\tthrow new IllegalArgumentException(\"The dimensions have to be equal!\");\n\t\t}\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tsum += a[i] * b[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n"}
{"id": 22441, "name": "Dot product", "source": "Translate Swift to Java: func dot(v1: [Double], v2: [Double]) -> Double {\n  return reduce(lazy(zip(v1, v2)).map(*), 0, +)\n}\n\nprintln(dot([1, 3, -5], [4, -2, -1]))\n", "target": "public class DotProduct {\n\t\n\tpublic static void main(String[] args) {\n\t\tdouble[] a = {1, 3, -5};\n\t\tdouble[] b = {4, -2, -1};\n\t\t\n\t\tSystem.out.println(dotProd(a,b));\n\t}\n\t\n\tpublic static double dotProd(double[] a, double[] b){\n\t\tif(a.length != b.length){\n\t\t\tthrow new IllegalArgumentException(\"The dimensions have to be equal!\");\n\t\t}\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tsum += a[i] * b[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n"}
{"id": 22442, "name": "Dot product", "source": "Translate Swift to Python: func dot(v1: [Double], v2: [Double]) -> Double {\n  return reduce(lazy(zip(v1, v2)).map(*), 0, +)\n}\n\nprintln(dot([1, 3, -5], [4, -2, -1]))\n", "target": "def dotp(a,b):\n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n\nif __name__ == '__main__':\n    a, b = [1, 3, -5], [4, -2, -1]\n    assert dotp(a,b) == 3\n"}
{"id": 22443, "name": "Dot product", "source": "Translate Swift to Python: func dot(v1: [Double], v2: [Double]) -> Double {\n  return reduce(lazy(zip(v1, v2)).map(*), 0, +)\n}\n\nprintln(dot([1, 3, -5], [4, -2, -1]))\n", "target": "def dotp(a,b):\n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n\nif __name__ == '__main__':\n    a, b = [1, 3, -5], [4, -2, -1]\n    assert dotp(a,b) == 3\n"}
{"id": 22756, "name": "Count in factors", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nfor i in 1...20 {\n  if i == 1 {\n    print(\"1 = 1\")\n  } else {\n    print(\"\\(i) = \\(i.primeDecomposition().map(String.init).joined(separator: \" x \"))\")\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfor( int i=1; i<=22; i++ )\n\t\t\t{\t\t\t\t\n\t\t\t\tList<int> f = Factorize(i);\n\t\t\t\tConsole.Write( i + \":  \" + f[0] );\n\t\t\t\tfor( int j=1; j<f.Count; j++ )\n\t\t\t\t{\n\t\t\t\t\tConsole.Write( \" * \" + f[j] );\n\t\t\t\t}\n\t\t\t\tConsole.WriteLine();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static List<int> Factorize( int n )\n\t\t{\n\t\t\tList<int> l = new List<int>();\n\t\t    \n\t\t\tif ( n == 1 )\n\t\t\t{\n\t\t\t\tl.Add(1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint k = 2;\n\t\t\t\twhile( n > 1 ) \n\t\t\t\t{\n\t\t\t\t\twhile( n % k == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tl.Add( k );\n\t\t\t\t\t\tn /= k;\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\treturn l;\n\t\t}\t\n\t}\n}\n"}
{"id": 22758, "name": "Count in factors", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nfor i in 1...20 {\n  if i == 1 {\n    print(\"1 = 1\")\n  } else {\n    print(\"\\(i) = \\(i.primeDecomposition().map(String.init).joined(separator: \" x \"))\")\n  }\n}\n", "target": "public class CountingInFactors{ \n    public static void main(String[] args){\n        for(int i = 1; i<= 10; i++){\n            System.out.println(i + \" = \"+ countInFactors(i));\n        }\n \n        for(int i = 9991; i <= 10000; i++){\n        \tSystem.out.println(i + \" = \"+ countInFactors(i));\n        }\n    }\n \n    private static String countInFactors(int n){\n        if(n == 1) return \"1\";\n \n        StringBuilder sb = new StringBuilder();\n \n        n = checkFactor(2, n, sb);\n        if(n == 1) return sb.toString();\n \n        n = checkFactor(3, n, sb);\n        if(n == 1) return sb.toString();\n \n        for(int i = 5; i <= n; i+= 2){\n            if(i % 3 == 0)continue;\n \n            n = checkFactor(i, n, sb);\n            if(n == 1)break;\n        }\n \n        return sb.toString();\n    }\n \n    private static int checkFactor(int mult, int n, StringBuilder sb){\n        while(n % mult == 0 ){\n            if(sb.length() > 0) sb.append(\" x \");\n            sb.append(mult);\n            n /= mult;\n        }\n        return n;\n    }\n}\n"}
{"id": 22759, "name": "Count in factors", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nfor i in 1...20 {\n  if i == 1 {\n    print(\"1 = 1\")\n  } else {\n    print(\"\\(i) = \\(i.primeDecomposition().map(String.init).joined(separator: \" x \"))\")\n  }\n}\n", "target": "from functools import lru_cache\n\nprimes = [2, 3, 5, 7, 11, 13, 17]    \n\n@lru_cache(maxsize=2000)\ndef pfactor(n):\n    if n == 1:\n        return [1]\n    n2 = n // 2 + 1\n    for p in primes:\n        if p <= n2:\n            d, m = divmod(n, p)\n            if m == 0:\n                if d > 1:\n                    return [p] + pfactor(d)\n                else:\n                    return [p]\n        else:\n            if n > primes[-1]:\n                primes.append(n)\n            return [n]\n        \nif __name__ == '__main__':\n    mx = 5000\n    for n in range(1, mx + 1):\n        factors = pfactor(n)\n        if n <= 10 or n >= mx - 20:\n            print( '%4i %5s %s' % (n,\n                                   '' if factors != [n] or n == 1 else 'prime',\n                                   'x'.join(str(i) for i in factors)) )\n        if n == 11:\n            print('...')\n            \n    print('\\nNumber of primes gathered up to', n, 'is', len(primes))\n    print(pfactor.cache_info())\n"}
{"id": 23647, "name": "String case", "source": "Translate Swift to C#: import Foundation\n\nprintln(\"alphaBETA\".uppercaseString)\nprintln(\"alphaBETA\".lowercaseString)\nprintln(\"foO BAr\".capitalizedString)\n", "target": "using System;\n\nnamespace StringCase\n{\n  class Program\n  {\n    public static void Main()\n    {\n      String input = scope .(\"alphaBETA\");\n      input.ToUpper();\n      Console.WriteLine(input);\n      input.ToLower();\n      Console.WriteLine(input);\n    }\n  }\n}\n"}
{"id": 23649, "name": "String case", "source": "Translate Swift to Java: import Foundation\n\nprintln(\"alphaBETA\".uppercaseString)\nprintln(\"alphaBETA\".lowercaseString)\nprintln(\"foO BAr\".capitalizedString)\n", "target": "String str = \"alphaBETA\";\nSystem.out.println(str.toUpperCase());\nSystem.out.println(str.toLowerCase());\n\nSystem.out.println(\"\u00e4\u00e0\u00e2\u00e1\u00e7\u00f1\u00df\u00e6\u03b5\u0431\u1ebf\".toUpperCase());\nSystem.out.println(\"\u00c4\u00c0\u00c2\u00c1\u00c7\u00d1SS\u00c6\u0395\u0411\u1ebe\".toLowerCase()); \n"}
{"id": 23650, "name": "String case", "source": "Translate Swift to Python: import Foundation\n\nprintln(\"alphaBETA\".uppercaseString)\nprintln(\"alphaBETA\".lowercaseString)\nprintln(\"foO BAr\".capitalizedString)\n", "target": "s = \"alphaBETA\"\nprint s.upper() \nprint s.lower() \n\nprint s.swapcase() \n\nprint \"fOo bAR\".capitalize() \nprint \"fOo bAR\".title() \n\nimport string\nprint string.capwords(\"fOo bAR\") \n"}
{"id": 24516, "name": "Arithmetic-geometric mean", "source": "Translate Swift to C#: import Darwin\n\nenum AGRError : Error {\n\tcase undefined\n}\n\nfunc agm(_ a: Double, _ g: Double, _ iota: Double = 1e-8) throws -> Double {\n\tvar a = a\n\tvar g = g\n\tvar a1: Double = 0\n\tvar g1: Double = 0\n\t\n\tguard a * g >= 0 else {\n\t\tthrow AGRError.undefined\n\t}\n\t\n\twhile abs(a - g) > iota {\n\t\ta1 = (a + g) / 2\n\t\tg1 = sqrt(a * g)\n\t\ta = a1\n\t\tg = g1\n\t}\n\t\n\treturn a\n}\n\ndo {\n\ttry print(agm(1, 1 / sqrt(2)))\n} catch {\n\tprint(\"agr is undefined when a * g < 0\")\n}\n", "target": "namespace RosettaCode.ArithmeticGeometricMean\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n\n    internal static class Program\n    {\n        private static double ArithmeticGeometricMean(double number,\n                                                      double otherNumber,\n                                                      IEqualityComparer<double>\n                                                          comparer)\n        {\n            return comparer.Equals(number, otherNumber)\n                       ? number\n                       : ArithmeticGeometricMean(\n                           ArithmeticMean(number, otherNumber),\n                           GeometricMean(number, otherNumber), comparer);\n        }\n\n        private static double ArithmeticMean(double number, double otherNumber)\n        {\n            return 0.5 * (number + otherNumber);\n        }\n\n        private static double GeometricMean(double number, double otherNumber)\n        {\n            return Math.Sqrt(number * otherNumber);\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),\n                                        new RelativeDifferenceComparer(1e-5)).\n                    ToString(CultureInfo.InvariantCulture));\n        }\n\n        private class RelativeDifferenceComparer : IEqualityComparer<double>\n        {\n            private readonly double _maximumRelativeDifference;\n\n            internal RelativeDifferenceComparer(double maximumRelativeDifference)\n            {\n                _maximumRelativeDifference = maximumRelativeDifference;\n            }\n\n            public bool Equals(double number, double otherNumber)\n            {\n                return RelativeDifference(number, otherNumber) <=\n                       _maximumRelativeDifference;\n            }\n\n            public int GetHashCode(double number)\n            {\n                return number.GetHashCode();\n            }\n\n            private static double RelativeDifference(double number,\n                                                     double otherNumber)\n            {\n                return AbsoluteDifference(number, otherNumber) /\n                       Norm(number, otherNumber);\n            }\n\n            private static double AbsoluteDifference(double number,\n                                                     double otherNumber)\n            {\n                return Math.Abs(number - otherNumber);\n            }\n\n            private static double Norm(double number, double otherNumber)\n            {\n                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));\n            }\n        }\n    }\n}\n"}
{"id": 24517, "name": "Arithmetic-geometric mean", "source": "Translate Swift to C#: import Darwin\n\nenum AGRError : Error {\n\tcase undefined\n}\n\nfunc agm(_ a: Double, _ g: Double, _ iota: Double = 1e-8) throws -> Double {\n\tvar a = a\n\tvar g = g\n\tvar a1: Double = 0\n\tvar g1: Double = 0\n\t\n\tguard a * g >= 0 else {\n\t\tthrow AGRError.undefined\n\t}\n\t\n\twhile abs(a - g) > iota {\n\t\ta1 = (a + g) / 2\n\t\tg1 = sqrt(a * g)\n\t\ta = a1\n\t\tg = g1\n\t}\n\t\n\treturn a\n}\n\ndo {\n\ttry print(agm(1, 1 / sqrt(2)))\n} catch {\n\tprint(\"agr is undefined when a * g < 0\")\n}\n", "target": "namespace RosettaCode.ArithmeticGeometricMean\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n\n    internal static class Program\n    {\n        private static double ArithmeticGeometricMean(double number,\n                                                      double otherNumber,\n                                                      IEqualityComparer<double>\n                                                          comparer)\n        {\n            return comparer.Equals(number, otherNumber)\n                       ? number\n                       : ArithmeticGeometricMean(\n                           ArithmeticMean(number, otherNumber),\n                           GeometricMean(number, otherNumber), comparer);\n        }\n\n        private static double ArithmeticMean(double number, double otherNumber)\n        {\n            return 0.5 * (number + otherNumber);\n        }\n\n        private static double GeometricMean(double number, double otherNumber)\n        {\n            return Math.Sqrt(number * otherNumber);\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),\n                                        new RelativeDifferenceComparer(1e-5)).\n                    ToString(CultureInfo.InvariantCulture));\n        }\n\n        private class RelativeDifferenceComparer : IEqualityComparer<double>\n        {\n            private readonly double _maximumRelativeDifference;\n\n            internal RelativeDifferenceComparer(double maximumRelativeDifference)\n            {\n                _maximumRelativeDifference = maximumRelativeDifference;\n            }\n\n            public bool Equals(double number, double otherNumber)\n            {\n                return RelativeDifference(number, otherNumber) <=\n                       _maximumRelativeDifference;\n            }\n\n            public int GetHashCode(double number)\n            {\n                return number.GetHashCode();\n            }\n\n            private static double RelativeDifference(double number,\n                                                     double otherNumber)\n            {\n                return AbsoluteDifference(number, otherNumber) /\n                       Norm(number, otherNumber);\n            }\n\n            private static double AbsoluteDifference(double number,\n                                                     double otherNumber)\n            {\n                return Math.Abs(number - otherNumber);\n            }\n\n            private static double Norm(double number, double otherNumber)\n            {\n                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));\n            }\n        }\n    }\n}\n"}
{"id": 24520, "name": "Arithmetic-geometric mean", "source": "Translate Swift to Java: import Darwin\n\nenum AGRError : Error {\n\tcase undefined\n}\n\nfunc agm(_ a: Double, _ g: Double, _ iota: Double = 1e-8) throws -> Double {\n\tvar a = a\n\tvar g = g\n\tvar a1: Double = 0\n\tvar g1: Double = 0\n\t\n\tguard a * g >= 0 else {\n\t\tthrow AGRError.undefined\n\t}\n\t\n\twhile abs(a - g) > iota {\n\t\ta1 = (a + g) / 2\n\t\tg1 = sqrt(a * g)\n\t\ta = a1\n\t\tg = g1\n\t}\n\t\n\treturn a\n}\n\ndo {\n\ttry print(agm(1, 1 / sqrt(2)))\n} catch {\n\tprint(\"agr is undefined when a * g < 0\")\n}\n", "target": "\npublic class ArithmeticGeometricMean {\n\n    public static double agm(double a, double g) {\n        double a1 = a;\n        double g1 = g;\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\n            double arith = (a1 + g1) / 2.0;\n            double geom = Math.sqrt(a1 * g1);\n            a1 = arith;\n            g1 = geom;\n        }\n        return a1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\n    }\n}\n"}
{"id": 24521, "name": "Arithmetic-geometric mean", "source": "Translate Swift to Java: import Darwin\n\nenum AGRError : Error {\n\tcase undefined\n}\n\nfunc agm(_ a: Double, _ g: Double, _ iota: Double = 1e-8) throws -> Double {\n\tvar a = a\n\tvar g = g\n\tvar a1: Double = 0\n\tvar g1: Double = 0\n\t\n\tguard a * g >= 0 else {\n\t\tthrow AGRError.undefined\n\t}\n\t\n\twhile abs(a - g) > iota {\n\t\ta1 = (a + g) / 2\n\t\tg1 = sqrt(a * g)\n\t\ta = a1\n\t\tg = g1\n\t}\n\t\n\treturn a\n}\n\ndo {\n\ttry print(agm(1, 1 / sqrt(2)))\n} catch {\n\tprint(\"agr is undefined when a * g < 0\")\n}\n", "target": "\npublic class ArithmeticGeometricMean {\n\n    public static double agm(double a, double g) {\n        double a1 = a;\n        double g1 = g;\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\n            double arith = (a1 + g1) / 2.0;\n            double geom = Math.sqrt(a1 * g1);\n            a1 = arith;\n            g1 = geom;\n        }\n        return a1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\n    }\n}\n"}
{"id": 24522, "name": "Arithmetic-geometric mean", "source": "Translate Swift to Python: import Darwin\n\nenum AGRError : Error {\n\tcase undefined\n}\n\nfunc agm(_ a: Double, _ g: Double, _ iota: Double = 1e-8) throws -> Double {\n\tvar a = a\n\tvar g = g\n\tvar a1: Double = 0\n\tvar g1: Double = 0\n\t\n\tguard a * g >= 0 else {\n\t\tthrow AGRError.undefined\n\t}\n\t\n\twhile abs(a - g) > iota {\n\t\ta1 = (a + g) / 2\n\t\tg1 = sqrt(a * g)\n\t\ta = a1\n\t\tg = g1\n\t}\n\t\n\treturn a\n}\n\ndo {\n\ttry print(agm(1, 1 / sqrt(2)))\n} catch {\n\tprint(\"agr is undefined when a * g < 0\")\n}\n", "target": "from math import sqrt\n\ndef agm(a0, g0, tolerance=1e-10):\n    \n    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)\n    while abs(an - gn) > tolerance:\n        an, gn = (an + gn) / 2.0, sqrt(an * gn)\n    return an\n\nprint agm(1, 1 / sqrt(2))\n"}
{"id": 24523, "name": "Arithmetic-geometric mean", "source": "Translate Swift to Python: import Darwin\n\nenum AGRError : Error {\n\tcase undefined\n}\n\nfunc agm(_ a: Double, _ g: Double, _ iota: Double = 1e-8) throws -> Double {\n\tvar a = a\n\tvar g = g\n\tvar a1: Double = 0\n\tvar g1: Double = 0\n\t\n\tguard a * g >= 0 else {\n\t\tthrow AGRError.undefined\n\t}\n\t\n\twhile abs(a - g) > iota {\n\t\ta1 = (a + g) / 2\n\t\tg1 = sqrt(a * g)\n\t\ta = a1\n\t\tg = g1\n\t}\n\t\n\treturn a\n}\n\ndo {\n\ttry print(agm(1, 1 / sqrt(2)))\n} catch {\n\tprint(\"agr is undefined when a * g < 0\")\n}\n", "target": "from math import sqrt\n\ndef agm(a0, g0, tolerance=1e-10):\n    \n    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)\n    while abs(an - gn) > tolerance:\n        an, gn = (an + gn) / 2.0, sqrt(an * gn)\n    return an\n\nprint agm(1, 1 / sqrt(2))\n"}
{"id": 24983, "name": "Chinese remainder theorem", "source": "Translate Swift to C#: import Darwin\n\n\n\nfunc euclid(_ m:Int, _ n:Int) -> (Int,Int) {\n    if m % n == 0 {\n        return (0,1)\n    } else {\n        let rs = euclid(n % m, m)\n        let r = rs.1 - rs.0 * (n / m)\n        let s = rs.0\n\n        return (r,s)\n    }\n}\n\n\n\nfunc gcd(_ m:Int, _ n:Int) -> Int {\n    let rs = euclid(m, n)\n    return m * rs.0 + n * rs.1\n}\n\n\n\nfunc coprime(_ m:Int, _ n:Int) -> Bool {\n    return gcd(m,n) == 1 ? true : false\n}\n\ncoprime(14,26)\n\n\n\n\nfunc crt(_ a_i:[Int], _ n_i:[Int]) -> Int {\n    \n    \n    \n    \n    let divs = n_i.enumerated()\n    \n    \n    divs.forEach{\n        n in divs.filter{ $0.0 < n.0 }.forEach{\n            assert(coprime(n.1, $0.1))\n        }\n    }\n    \n    \n    let N = n_i.map{$0}.reduce(1, *)\n    \n    \n    var s:[Int] = []\n    \n    \n    n_i.forEach{ s += [euclid($0, N / $0).1] }\n    \n    \n    var x = 0\n    a_i.enumerated().forEach{\n        x += $0.1 * s[$0.0] * N / n_i[$0.0]\n    }\n\n    \n    return x % N\n}\n\nlet a = [2,3,2]\nlet n = [3,5,7]\n\nlet x = crt(a,n)\n\nprint(x)\n", "target": "using System;\nusing System.Linq;\n\nnamespace ChineseRemainderTheorem\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] n = { 3, 5, 7 };\n            int[] a = { 2, 3, 2 };\n\n            int result = ChineseRemainderTheorem.Solve(n, a);\n\n            int counter = 0;\n            int maxCount = n.Length - 1;\n            while (counter <= maxCount)\n            {\n                Console.WriteLine($\"{result} \u2261 {a[counter]} (mod {n[counter]})\");\n                counter++;\n            }\n        }\n    }\n\n    public static class ChineseRemainderTheorem\n    {\n        public static int Solve(int[] n, int[] a)\n        {\n            int prod = n.Aggregate(1, (i, j) => i * j);\n            int p;\n            int sm = 0;\n            for (int i = 0; i < n.Length; i++)\n            {\n                p = prod / n[i];\n                sm += a[i] * ModularMultiplicativeInverse(p, n[i]) * p;\n            }\n            return sm % prod;\n        }\n\n        private static int ModularMultiplicativeInverse(int a, int mod)\n        {\n            int b = a % mod;\n            for (int x = 1; x < mod; x++)\n            {\n                if ((b * x) % mod == 1)\n                {\n                    return x;\n                }\n            }\n            return 1;\n        }\n    }\n}\n"}
{"id": 24984, "name": "Chinese remainder theorem", "source": "Translate Swift to C#: import Darwin\n\n\n\nfunc euclid(_ m:Int, _ n:Int) -> (Int,Int) {\n    if m % n == 0 {\n        return (0,1)\n    } else {\n        let rs = euclid(n % m, m)\n        let r = rs.1 - rs.0 * (n / m)\n        let s = rs.0\n\n        return (r,s)\n    }\n}\n\n\n\nfunc gcd(_ m:Int, _ n:Int) -> Int {\n    let rs = euclid(m, n)\n    return m * rs.0 + n * rs.1\n}\n\n\n\nfunc coprime(_ m:Int, _ n:Int) -> Bool {\n    return gcd(m,n) == 1 ? true : false\n}\n\ncoprime(14,26)\n\n\n\n\nfunc crt(_ a_i:[Int], _ n_i:[Int]) -> Int {\n    \n    \n    \n    \n    let divs = n_i.enumerated()\n    \n    \n    divs.forEach{\n        n in divs.filter{ $0.0 < n.0 }.forEach{\n            assert(coprime(n.1, $0.1))\n        }\n    }\n    \n    \n    let N = n_i.map{$0}.reduce(1, *)\n    \n    \n    var s:[Int] = []\n    \n    \n    n_i.forEach{ s += [euclid($0, N / $0).1] }\n    \n    \n    var x = 0\n    a_i.enumerated().forEach{\n        x += $0.1 * s[$0.0] * N / n_i[$0.0]\n    }\n\n    \n    return x % N\n}\n\nlet a = [2,3,2]\nlet n = [3,5,7]\n\nlet x = crt(a,n)\n\nprint(x)\n", "target": "using System;\nusing System.Linq;\n\nnamespace ChineseRemainderTheorem\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] n = { 3, 5, 7 };\n            int[] a = { 2, 3, 2 };\n\n            int result = ChineseRemainderTheorem.Solve(n, a);\n\n            int counter = 0;\n            int maxCount = n.Length - 1;\n            while (counter <= maxCount)\n            {\n                Console.WriteLine($\"{result} \u2261 {a[counter]} (mod {n[counter]})\");\n                counter++;\n            }\n        }\n    }\n\n    public static class ChineseRemainderTheorem\n    {\n        public static int Solve(int[] n, int[] a)\n        {\n            int prod = n.Aggregate(1, (i, j) => i * j);\n            int p;\n            int sm = 0;\n            for (int i = 0; i < n.Length; i++)\n            {\n                p = prod / n[i];\n                sm += a[i] * ModularMultiplicativeInverse(p, n[i]) * p;\n            }\n            return sm % prod;\n        }\n\n        private static int ModularMultiplicativeInverse(int a, int mod)\n        {\n            int b = a % mod;\n            for (int x = 1; x < mod; x++)\n            {\n                if ((b * x) % mod == 1)\n                {\n                    return x;\n                }\n            }\n            return 1;\n        }\n    }\n}\n"}
{"id": 24987, "name": "Chinese remainder theorem", "source": "Translate Swift to Java: import Darwin\n\n\n\nfunc euclid(_ m:Int, _ n:Int) -> (Int,Int) {\n    if m % n == 0 {\n        return (0,1)\n    } else {\n        let rs = euclid(n % m, m)\n        let r = rs.1 - rs.0 * (n / m)\n        let s = rs.0\n\n        return (r,s)\n    }\n}\n\n\n\nfunc gcd(_ m:Int, _ n:Int) -> Int {\n    let rs = euclid(m, n)\n    return m * rs.0 + n * rs.1\n}\n\n\n\nfunc coprime(_ m:Int, _ n:Int) -> Bool {\n    return gcd(m,n) == 1 ? true : false\n}\n\ncoprime(14,26)\n\n\n\n\nfunc crt(_ a_i:[Int], _ n_i:[Int]) -> Int {\n    \n    \n    \n    \n    let divs = n_i.enumerated()\n    \n    \n    divs.forEach{\n        n in divs.filter{ $0.0 < n.0 }.forEach{\n            assert(coprime(n.1, $0.1))\n        }\n    }\n    \n    \n    let N = n_i.map{$0}.reduce(1, *)\n    \n    \n    var s:[Int] = []\n    \n    \n    n_i.forEach{ s += [euclid($0, N / $0).1] }\n    \n    \n    var x = 0\n    a_i.enumerated().forEach{\n        x += $0.1 * s[$0.0] * N / n_i[$0.0]\n    }\n\n    \n    return x % N\n}\n\nlet a = [2,3,2]\nlet n = [3,5,7]\n\nlet x = crt(a,n)\n\nprint(x)\n", "target": "import static java.util.Arrays.stream;\n\npublic class ChineseRemainderTheorem {\n\n    public static int chineseRemainder(int[] n, int[] a) {\n\n        int prod = stream(n).reduce(1, (i, j) -> i * j);\n\n        int p, sm = 0;\n        for (int i = 0; i < n.length; i++) {\n            p = prod / n[i];\n            sm += a[i] * mulInv(p, n[i]) * p;\n        }\n        return sm % prod;\n    }\n\n    private static int mulInv(int a, int b) {\n        int b0 = b;\n        int x0 = 0;\n        int x1 = 1;\n\n        if (b == 1)\n            return 1;\n\n        while (a > 1) {\n            int q = a / b;\n            int amb = a % b;\n            a = b;\n            b = amb;\n            int xqx = x1 - q * x0;\n            x1 = x0;\n            x0 = xqx;\n        }\n\n        if (x1 < 0)\n            x1 += b0;\n\n        return x1;\n    }\n\n    public static void main(String[] args) {\n        int[] n = {3, 5, 7};\n        int[] a = {2, 3, 2};\n        System.out.println(chineseRemainder(n, a));\n    }\n}\n"}
{"id": 24988, "name": "Chinese remainder theorem", "source": "Translate Swift to Java: import Darwin\n\n\n\nfunc euclid(_ m:Int, _ n:Int) -> (Int,Int) {\n    if m % n == 0 {\n        return (0,1)\n    } else {\n        let rs = euclid(n % m, m)\n        let r = rs.1 - rs.0 * (n / m)\n        let s = rs.0\n\n        return (r,s)\n    }\n}\n\n\n\nfunc gcd(_ m:Int, _ n:Int) -> Int {\n    let rs = euclid(m, n)\n    return m * rs.0 + n * rs.1\n}\n\n\n\nfunc coprime(_ m:Int, _ n:Int) -> Bool {\n    return gcd(m,n) == 1 ? true : false\n}\n\ncoprime(14,26)\n\n\n\n\nfunc crt(_ a_i:[Int], _ n_i:[Int]) -> Int {\n    \n    \n    \n    \n    let divs = n_i.enumerated()\n    \n    \n    divs.forEach{\n        n in divs.filter{ $0.0 < n.0 }.forEach{\n            assert(coprime(n.1, $0.1))\n        }\n    }\n    \n    \n    let N = n_i.map{$0}.reduce(1, *)\n    \n    \n    var s:[Int] = []\n    \n    \n    n_i.forEach{ s += [euclid($0, N / $0).1] }\n    \n    \n    var x = 0\n    a_i.enumerated().forEach{\n        x += $0.1 * s[$0.0] * N / n_i[$0.0]\n    }\n\n    \n    return x % N\n}\n\nlet a = [2,3,2]\nlet n = [3,5,7]\n\nlet x = crt(a,n)\n\nprint(x)\n", "target": "import static java.util.Arrays.stream;\n\npublic class ChineseRemainderTheorem {\n\n    public static int chineseRemainder(int[] n, int[] a) {\n\n        int prod = stream(n).reduce(1, (i, j) -> i * j);\n\n        int p, sm = 0;\n        for (int i = 0; i < n.length; i++) {\n            p = prod / n[i];\n            sm += a[i] * mulInv(p, n[i]) * p;\n        }\n        return sm % prod;\n    }\n\n    private static int mulInv(int a, int b) {\n        int b0 = b;\n        int x0 = 0;\n        int x1 = 1;\n\n        if (b == 1)\n            return 1;\n\n        while (a > 1) {\n            int q = a / b;\n            int amb = a % b;\n            a = b;\n            b = amb;\n            int xqx = x1 - q * x0;\n            x1 = x0;\n            x0 = xqx;\n        }\n\n        if (x1 < 0)\n            x1 += b0;\n\n        return x1;\n    }\n\n    public static void main(String[] args) {\n        int[] n = {3, 5, 7};\n        int[] a = {2, 3, 2};\n        System.out.println(chineseRemainder(n, a));\n    }\n}\n"}
{"id": 24989, "name": "Chinese remainder theorem", "source": "Translate Swift to Python: import Darwin\n\n\n\nfunc euclid(_ m:Int, _ n:Int) -> (Int,Int) {\n    if m % n == 0 {\n        return (0,1)\n    } else {\n        let rs = euclid(n % m, m)\n        let r = rs.1 - rs.0 * (n / m)\n        let s = rs.0\n\n        return (r,s)\n    }\n}\n\n\n\nfunc gcd(_ m:Int, _ n:Int) -> Int {\n    let rs = euclid(m, n)\n    return m * rs.0 + n * rs.1\n}\n\n\n\nfunc coprime(_ m:Int, _ n:Int) -> Bool {\n    return gcd(m,n) == 1 ? true : false\n}\n\ncoprime(14,26)\n\n\n\n\nfunc crt(_ a_i:[Int], _ n_i:[Int]) -> Int {\n    \n    \n    \n    \n    let divs = n_i.enumerated()\n    \n    \n    divs.forEach{\n        n in divs.filter{ $0.0 < n.0 }.forEach{\n            assert(coprime(n.1, $0.1))\n        }\n    }\n    \n    \n    let N = n_i.map{$0}.reduce(1, *)\n    \n    \n    var s:[Int] = []\n    \n    \n    n_i.forEach{ s += [euclid($0, N / $0).1] }\n    \n    \n    var x = 0\n    a_i.enumerated().forEach{\n        x += $0.1 * s[$0.0] * N / n_i[$0.0]\n    }\n\n    \n    return x % N\n}\n\nlet a = [2,3,2]\nlet n = [3,5,7]\n\nlet x = crt(a,n)\n\nprint(x)\n", "target": "\ndef chinese_remainder(n, a):\n    sum = 0\n    prod = reduce(lambda a, b: a*b, n)\n\n    for n_i, a_i in zip(n, a):\n        p = prod / n_i\n        sum += a_i * mul_inv(p, n_i) * p\n    return sum % prod\n\n\ndef mul_inv(a, b):\n    b0 = b\n    x0, x1 = 0, 1\n    if b == 1: return 1\n    while a > 1:\n        q = a / b\n        a, b = b, a%b\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0: x1 += b0\n    return x1\n\nif __name__ == '__main__':\n    n = [3, 5, 7]\n    a = [2, 3, 2]\n    print chinese_remainder(n, a)\n"}
{"id": 24990, "name": "Chinese remainder theorem", "source": "Translate Swift to Python: import Darwin\n\n\n\nfunc euclid(_ m:Int, _ n:Int) -> (Int,Int) {\n    if m % n == 0 {\n        return (0,1)\n    } else {\n        let rs = euclid(n % m, m)\n        let r = rs.1 - rs.0 * (n / m)\n        let s = rs.0\n\n        return (r,s)\n    }\n}\n\n\n\nfunc gcd(_ m:Int, _ n:Int) -> Int {\n    let rs = euclid(m, n)\n    return m * rs.0 + n * rs.1\n}\n\n\n\nfunc coprime(_ m:Int, _ n:Int) -> Bool {\n    return gcd(m,n) == 1 ? true : false\n}\n\ncoprime(14,26)\n\n\n\n\nfunc crt(_ a_i:[Int], _ n_i:[Int]) -> Int {\n    \n    \n    \n    \n    let divs = n_i.enumerated()\n    \n    \n    divs.forEach{\n        n in divs.filter{ $0.0 < n.0 }.forEach{\n            assert(coprime(n.1, $0.1))\n        }\n    }\n    \n    \n    let N = n_i.map{$0}.reduce(1, *)\n    \n    \n    var s:[Int] = []\n    \n    \n    n_i.forEach{ s += [euclid($0, N / $0).1] }\n    \n    \n    var x = 0\n    a_i.enumerated().forEach{\n        x += $0.1 * s[$0.0] * N / n_i[$0.0]\n    }\n\n    \n    return x % N\n}\n\nlet a = [2,3,2]\nlet n = [3,5,7]\n\nlet x = crt(a,n)\n\nprint(x)\n", "target": "\ndef chinese_remainder(n, a):\n    sum = 0\n    prod = reduce(lambda a, b: a*b, n)\n\n    for n_i, a_i in zip(n, a):\n        p = prod / n_i\n        sum += a_i * mul_inv(p, n_i) * p\n    return sum % prod\n\n\ndef mul_inv(a, b):\n    b0 = b\n    x0, x1 = 0, 1\n    if b == 1: return 1\n    while a > 1:\n        q = a / b\n        a, b = b, a%b\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0: x1 += b0\n    return x1\n\nif __name__ == '__main__':\n    n = [3, 5, 7]\n    a = [2, 3, 2]\n    print chinese_remainder(n, a)\n"}
{"id": 25277, "name": "Stable marriage problem", "source": "Translate Swift to C#: class Person {\n    let name:String\n    var candidateIndex = 0\n    var fiance:Person?\n    var candidates = [Person]()\n    \n    init(name:String) {\n        self.name = name\n    }\n    \n    func rank(p:Person) -> Int {\n        for (i, candidate) in enumerate(self.candidates) {\n            if candidate === p {\n                return i\n            }\n        }\n        return self.candidates.count + 1\n    }\n    \n    func prefers(p:Person) -> Bool {\n        if let fiance = self.fiance {\n            return self.rank(p) < self.rank(fiance)\n        }\n        return false\n    }\n    \n    func nextCandidate() -> Person? {\n        if self.candidateIndex >= self.candidates.count {\n            return nil\n        }\n        return self.candidates[candidateIndex++]\n    }\n    \n    func engageTo(p:Person) {\n        p.fiance?.fiance = nil\n        p.fiance = self\n        self.fiance?.fiance = nil\n        self.fiance = p\n    }\n    \n    func swapWith(p:Person) {\n        let thisFiance = self.fiance\n        let pFiance = p.fiance\n        println(\"\\(self.name) swapped partners with \\(p.name)\")\n        if pFiance != nil && thisFiance != nil {\n            self.engageTo(pFiance!)\n            p.engageTo(thisFiance!)\n        }\n    }\n}\n\nfunc isStable(guys:[Person], gals:[Person]) -> Bool {\n    for guy in guys {\n        for gal in gals {\n            if guy.prefers(gal) && gal.prefers(guy) {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunc engageEveryone(guys:[Person]) {\n    var done = false\n    while !done {\n        done = true\n        for guy in guys {\n            if guy.fiance == nil {\n                done = false\n                if let gal = guy.nextCandidate() {\n                    if gal.fiance == nil || gal.prefers(guy) {\n                        guy.engageTo(gal)\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunc doMarriage() {\n    let abe  = Person(name: \"Abe\")\n    let bob  = Person(name: \"Bob\")\n    let col  = Person(name: \"Col\")\n    let dan  = Person(name: \"Dan\")\n    let ed   = Person(name: \"Ed\")\n    let fred = Person(name: \"Fred\")\n    let gav  = Person(name: \"Gav\")\n    let hal  = Person(name: \"Hal\")\n    let ian  = Person(name: \"Ian\")\n    let jon  = Person(name: \"Jon\")\n    let abi  = Person(name: \"Abi\")\n    let bea  = Person(name: \"Bea\")\n    let cath = Person(name: \"Cath\")\n    let dee  = Person(name: \"Dee\")\n    let eve  = Person(name: \"Eve\")\n    let fay  = Person(name: \"Fay\")\n    let gay  = Person(name: \"Gay\")\n    let hope = Person(name: \"Hope\")\n    let ivy  = Person(name: \"Ivy\")\n    let jan  = Person(name: \"Jan\")\n    \n    abe.candidates  = [abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay]\n    bob.candidates  = [cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay]\n    col.candidates  = [hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan]\n    dan.candidates  = [ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi]\n    ed.candidates   = [jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay]\n    fred.candidates = [bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay]\n    gav.candidates  = [gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay]\n    hal.candidates  = [abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee]\n    ian.candidates  = [hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve]\n    jon.candidates  = [abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope]\n    abi.candidates  = [bob, fred, jon, gav, ian, abe, dan, ed, col, hal]\n    bea.candidates  = [bob, abe, col, fred, gav, dan, ian, ed, jon, hal]\n    cath.candidates = [fred, bob, ed, gav, hal, col, ian, abe, dan, jon]\n    dee.candidates  = [fred, jon, col, abe, ian, hal, gav, dan, bob, ed]\n    eve.candidates  = [jon, hal, fred, dan, abe, gav, col, ed, ian, bob]\n    fay.candidates  = [bob, abe, ed, ian, jon, dan, fred, gav, col, hal]\n    gay.candidates  = [jon, gav, hal, fred, bob, abe, col, ed, dan, ian]\n    hope.candidates = [gav, jon, bob, abe, ian, dan, hal, ed, col, fred]\n    ivy.candidates  = [ian, col, hal, gav, fred, bob, abe, ed, jon, dan]\n    jan.candidates  = [ed, hal, gav, abe, bob, jon, col, ian, fred, dan]\n    \n    let guys = [abe, bob, col, dan, ed, fred, gav, hal, ian, jon]\n    let gals = [abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan]\n    \n    engageEveryone(guys)\n    \n    for guy in guys {\n        println(\"\\(guy.name) is engaged to \\(guy.fiance!.name)\")\n    }\n    \n    println(\"Stable = \\(isStable(guys, gals))\")\n    jon.swapWith(fred)\n    println(\"Stable = \\(isStable(guys, gals))\")\n    \n}\n\ndoMarriage()\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace StableMarriage\n{\n    class Person\n    {\n        private int _candidateIndex;\n        public string Name { get; set; }\n        public List<Person> Prefs { get; set; }\n        public Person Fiance { get; set; }\n        \n        public Person(string name) {\n            Name = name;\n            Prefs = null;\n            Fiance = null;\n            _candidateIndex = 0;\n        }\n        public bool Prefers(Person p) {\n            return Prefs.FindIndex(o => o == p) < Prefs.FindIndex(o => o == Fiance);\n        }\n        public Person NextCandidateNotYetProposedTo() {\n            if (_candidateIndex >= Prefs.Count) return null;\n            return Prefs[_candidateIndex++];\n        }\n        public void EngageTo(Person p) {\n            if (p.Fiance != null) p.Fiance.Fiance = null;\n            p.Fiance = this;\n            if (Fiance != null) Fiance.Fiance = null;\n            Fiance = p;\n        }\n    }\n    \n    static class MainClass\n    {\n        static public bool IsStable(List<Person> men) {\n            List<Person> women = men[0].Prefs;\n            foreach (Person guy in men) {\n                foreach (Person gal in women) {\n                    if (guy.Prefers(gal) && gal.Prefers(guy))\n                        return false;\n                }\n            }\n            return true;\n        }\n        \n        static void DoMarriage() {\n            Person abe  = new Person(\"abe\");\n            Person bob  = new Person(\"bob\");\n            Person col  = new Person(\"col\");\n            Person dan  = new Person(\"dan\");\n            Person ed   = new Person(\"ed\");\n            Person fred = new Person(\"fred\");\n            Person gav  = new Person(\"gav\");\n            Person hal  = new Person(\"hal\");\n            Person ian  = new Person(\"ian\");\n            Person jon  = new Person(\"jon\");\n            Person abi  = new Person(\"abi\");\n            Person bea  = new Person(\"bea\");\n            Person cath = new Person(\"cath\");\n            Person dee  = new Person(\"dee\");\n            Person eve  = new Person(\"eve\");\n            Person fay  = new Person(\"fay\");\n            Person gay  = new Person(\"gay\");\n            Person hope = new Person(\"hope\");\n            Person ivy  = new Person(\"ivy\");\n            Person jan  = new Person(\"jan\");\n            \n            abe.Prefs  = new List<Person>() {abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay};\n            bob.Prefs  = new List<Person>() {cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay};\n            col.Prefs  = new List<Person>() {hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan};\n            dan.Prefs  = new List<Person>() {ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi};\n            ed.Prefs   = new List<Person>() {jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay};\n            fred.Prefs = new List<Person>() {bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay};\n            gav.Prefs  = new List<Person>() {gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay};\n            hal.Prefs  = new List<Person>() {abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee};\n            ian.Prefs  = new List<Person>() {hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve};\n            jon.Prefs  = new List<Person>() {abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope};\n            abi.Prefs  = new List<Person>() {bob, fred, jon, gav, ian, abe, dan, ed, col, hal};\n            bea.Prefs  = new List<Person>() {bob, abe, col, fred, gav, dan, ian, ed, jon, hal};\n            cath.Prefs = new List<Person>() {fred, bob, ed, gav, hal, col, ian, abe, dan, jon};\n            dee.Prefs  = new List<Person>() {fred, jon, col, abe, ian, hal, gav, dan, bob, ed};\n            eve.Prefs  = new List<Person>() {jon, hal, fred, dan, abe, gav, col, ed, ian, bob};\n            fay.Prefs  = new List<Person>() {bob, abe, ed, ian, jon, dan, fred, gav, col, hal};\n            gay.Prefs  = new List<Person>() {jon, gav, hal, fred, bob, abe, col, ed, dan, ian};\n            hope.Prefs = new List<Person>() {gav, jon, bob, abe, ian, dan, hal, ed, col, fred};\n            ivy.Prefs  = new List<Person>() {ian, col, hal, gav, fred, bob, abe, ed, jon, dan};\n            jan.Prefs  = new List<Person>() {ed, hal, gav, abe, bob, jon, col, ian, fred, dan};\n            \n            List<Person> men = new List<Person>(abi.Prefs);\n            \n            int freeMenCount = men.Count;\n            while (freeMenCount > 0) {\n                foreach (Person guy in men) {\n                    if (guy.Fiance == null) {\n                        Person gal = guy.NextCandidateNotYetProposedTo();\n                        if (gal.Fiance == null) {\n                            guy.EngageTo(gal);\n                            freeMenCount--;\n                        } else if (gal.Prefers(guy)) {\n                            guy.EngageTo(gal);\n                        }\n                    }\n                }\n            }\n            \n            foreach (Person guy in men) {\n                Console.WriteLine(\"{0} is engaged to {1}\", guy.Name, guy.Fiance.Name);\n            }\n            Console.WriteLine(\"Stable = {0}\", IsStable(men));\n            \n            Console.WriteLine(\"\\nSwitching fred & jon's partners\");\n            Person jonsFiance = jon.Fiance;\n            Person fredsFiance = fred.Fiance;\n            fred.EngageTo(jonsFiance);\n            jon.EngageTo(fredsFiance);\n            Console.WriteLine(\"Stable = {0}\", IsStable(men));\n        }\n        \n        public static void Main(string[] args)\n        {\n            DoMarriage();\n        }\n    }\n}\n"}
{"id": 25279, "name": "Stable marriage problem", "source": "Translate Swift to Python: class Person {\n    let name:String\n    var candidateIndex = 0\n    var fiance:Person?\n    var candidates = [Person]()\n    \n    init(name:String) {\n        self.name = name\n    }\n    \n    func rank(p:Person) -> Int {\n        for (i, candidate) in enumerate(self.candidates) {\n            if candidate === p {\n                return i\n            }\n        }\n        return self.candidates.count + 1\n    }\n    \n    func prefers(p:Person) -> Bool {\n        if let fiance = self.fiance {\n            return self.rank(p) < self.rank(fiance)\n        }\n        return false\n    }\n    \n    func nextCandidate() -> Person? {\n        if self.candidateIndex >= self.candidates.count {\n            return nil\n        }\n        return self.candidates[candidateIndex++]\n    }\n    \n    func engageTo(p:Person) {\n        p.fiance?.fiance = nil\n        p.fiance = self\n        self.fiance?.fiance = nil\n        self.fiance = p\n    }\n    \n    func swapWith(p:Person) {\n        let thisFiance = self.fiance\n        let pFiance = p.fiance\n        println(\"\\(self.name) swapped partners with \\(p.name)\")\n        if pFiance != nil && thisFiance != nil {\n            self.engageTo(pFiance!)\n            p.engageTo(thisFiance!)\n        }\n    }\n}\n\nfunc isStable(guys:[Person], gals:[Person]) -> Bool {\n    for guy in guys {\n        for gal in gals {\n            if guy.prefers(gal) && gal.prefers(guy) {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunc engageEveryone(guys:[Person]) {\n    var done = false\n    while !done {\n        done = true\n        for guy in guys {\n            if guy.fiance == nil {\n                done = false\n                if let gal = guy.nextCandidate() {\n                    if gal.fiance == nil || gal.prefers(guy) {\n                        guy.engageTo(gal)\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunc doMarriage() {\n    let abe  = Person(name: \"Abe\")\n    let bob  = Person(name: \"Bob\")\n    let col  = Person(name: \"Col\")\n    let dan  = Person(name: \"Dan\")\n    let ed   = Person(name: \"Ed\")\n    let fred = Person(name: \"Fred\")\n    let gav  = Person(name: \"Gav\")\n    let hal  = Person(name: \"Hal\")\n    let ian  = Person(name: \"Ian\")\n    let jon  = Person(name: \"Jon\")\n    let abi  = Person(name: \"Abi\")\n    let bea  = Person(name: \"Bea\")\n    let cath = Person(name: \"Cath\")\n    let dee  = Person(name: \"Dee\")\n    let eve  = Person(name: \"Eve\")\n    let fay  = Person(name: \"Fay\")\n    let gay  = Person(name: \"Gay\")\n    let hope = Person(name: \"Hope\")\n    let ivy  = Person(name: \"Ivy\")\n    let jan  = Person(name: \"Jan\")\n    \n    abe.candidates  = [abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay]\n    bob.candidates  = [cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay]\n    col.candidates  = [hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan]\n    dan.candidates  = [ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi]\n    ed.candidates   = [jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay]\n    fred.candidates = [bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay]\n    gav.candidates  = [gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay]\n    hal.candidates  = [abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee]\n    ian.candidates  = [hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve]\n    jon.candidates  = [abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope]\n    abi.candidates  = [bob, fred, jon, gav, ian, abe, dan, ed, col, hal]\n    bea.candidates  = [bob, abe, col, fred, gav, dan, ian, ed, jon, hal]\n    cath.candidates = [fred, bob, ed, gav, hal, col, ian, abe, dan, jon]\n    dee.candidates  = [fred, jon, col, abe, ian, hal, gav, dan, bob, ed]\n    eve.candidates  = [jon, hal, fred, dan, abe, gav, col, ed, ian, bob]\n    fay.candidates  = [bob, abe, ed, ian, jon, dan, fred, gav, col, hal]\n    gay.candidates  = [jon, gav, hal, fred, bob, abe, col, ed, dan, ian]\n    hope.candidates = [gav, jon, bob, abe, ian, dan, hal, ed, col, fred]\n    ivy.candidates  = [ian, col, hal, gav, fred, bob, abe, ed, jon, dan]\n    jan.candidates  = [ed, hal, gav, abe, bob, jon, col, ian, fred, dan]\n    \n    let guys = [abe, bob, col, dan, ed, fred, gav, hal, ian, jon]\n    let gals = [abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan]\n    \n    engageEveryone(guys)\n    \n    for guy in guys {\n        println(\"\\(guy.name) is engaged to \\(guy.fiance!.name)\")\n    }\n    \n    println(\"Stable = \\(isStable(guys, gals))\")\n    jon.swapWith(fred)\n    println(\"Stable = \\(isStable(guys, gals))\")\n    \n}\n\ndoMarriage()\n", "target": "import copy\n\nguyprefers = {\n 'abe':  ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'],\n 'bob':  ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'],\n 'col':  ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'],\n 'dan':  ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'],\n 'ed':   ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'],\n 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'],\n 'gav':  ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'],\n 'hal':  ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'],\n 'ian':  ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'],\n 'jon':  ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {\n 'abi':  ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'],\n 'bea':  ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'],\n 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'],\n 'dee':  ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'],\n 'eve':  ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'],\n 'fay':  ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'],\n 'gay':  ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'],\n 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'],\n 'ivy':  ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'],\n 'jan':  ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\n\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\n\n\ndef check(engaged):\n    inverseengaged = dict((v,k) for k,v in engaged.items())\n    for she, he in engaged.items():\n        shelikes = galprefers[she]\n        shelikesbetter = shelikes[:shelikes.index(he)]\n        helikes = guyprefers[he]\n        helikesbetter = helikes[:helikes.index(she)]\n        for guy in shelikesbetter:\n            guysgirl = inverseengaged[guy]\n            guylikes = guyprefers[guy]\n            if guylikes.index(guysgirl) > guylikes.index(she):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (she, guy, he, guysgirl))\n                return False\n        for gal in helikesbetter:\n            girlsguy = engaged[gal]\n            gallikes = galprefers[gal]\n            if gallikes.index(girlsguy) > gallikes.index(he):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (he, gal, she, girlsguy))\n                return False\n    return True\n\ndef matchmaker():\n    guysfree = guys[:]\n    engaged  = {}\n    guyprefers2 = copy.deepcopy(guyprefers)\n    galprefers2 = copy.deepcopy(galprefers)\n    while guysfree:\n        guy = guysfree.pop(0)\n        guyslist = guyprefers2[guy]\n        gal = guyslist.pop(0)\n        fiance = engaged.get(gal)\n        if not fiance:\n            \n            engaged[gal] = guy\n            print(\"  %s and %s\" % (guy, gal))\n        else:\n            \n            galslist = galprefers2[gal]\n            if galslist.index(fiance) > galslist.index(guy):\n                \n                engaged[gal] = guy\n                print(\"  %s dumped %s for %s\" % (gal, fiance, guy))\n                if guyprefers2[fiance]:\n                    \n                    guysfree.append(fiance)\n            else:\n                \n                if guyslist:\n                    \n                    guysfree.append(guy)\n    return engaged\n\n\nprint('\\nEngagements:')\nengaged = matchmaker()\n\nprint('\\nCouples:')\nprint('  ' + ',\\n  '.join('%s is engaged to %s' % couple\n                          for couple in sorted(engaged.items())))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n\nprint('\\n\\nSwapping two fiances to introduce an error')\nengaged[gals[0]], engaged[gals[1]] = engaged[gals[1]], engaged[gals[0]]\nfor gal in gals[:2]:\n    print('  %s is now engaged to %s' % (gal, engaged[gal]))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n"}
{"id": 25650, "name": "Day of the week", "source": "Translate Swift to C#: import Cocoa\n\nvar year=2008\nlet formatter=DateFormatter()\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nlet gregorian:NSCalendar! = NSCalendar(calendarIdentifier: NSCalendar.Identifier.gregorian)\nwhile (year<2122){\n    var date:NSDate!=formatter.date(from: String(year)+\"-12-25\") as NSDate?\n    var components=gregorian.components(NSCalendar.Unit.weekday, from: date as Date)\n    var dayOfWeek:NSInteger=components.weekday!\n    if(dayOfWeek==1){\n        print(year)\n    }\n    year+=1 \n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 2008; i <= 2121; i++)\n        {\n            DateTime date = new DateTime(i, 12, 25);\n            if (date.DayOfWeek == DayOfWeek.Sunday)\n            {\n                Console.WriteLine(date.ToString(\"dd MMM yyyy\"));\n            }\n        }\n    }\n}\n"}
{"id": 25652, "name": "Day of the week", "source": "Translate Swift to Java: import Cocoa\n\nvar year=2008\nlet formatter=DateFormatter()\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nlet gregorian:NSCalendar! = NSCalendar(calendarIdentifier: NSCalendar.Identifier.gregorian)\nwhile (year<2122){\n    var date:NSDate!=formatter.date(from: String(year)+\"-12-25\") as NSDate?\n    var components=gregorian.components(NSCalendar.Unit.weekday, from: date as Date)\n    var dayOfWeek:NSInteger=components.weekday!\n    if(dayOfWeek==1){\n        print(year)\n    }\n    year+=1 \n}\n", "target": "import java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\n\npublic class Yuletide{\n\tpublic static void main(String[] args) {\n\t\tfor(int i = 2008;i<=2121;i++){\n\t\t\tCalendar cal = new GregorianCalendar(i, Calendar.DECEMBER,\n\t\t\t\t\t25);\n\t\t\tif(cal.get(Calendar.DAY_OF_WEEK)==Calendar.SUNDAY){\n\t\t\t\tSystem.out.println(cal.getTime());\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 25653, "name": "Day of the week", "source": "Translate Swift to Python: import Cocoa\n\nvar year=2008\nlet formatter=DateFormatter()\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nlet gregorian:NSCalendar! = NSCalendar(calendarIdentifier: NSCalendar.Identifier.gregorian)\nwhile (year<2122){\n    var date:NSDate!=formatter.date(from: String(year)+\"-12-25\") as NSDate?\n    var components=gregorian.components(NSCalendar.Unit.weekday, from: date as Date)\n    var dayOfWeek:NSInteger=components.weekday!\n    if(dayOfWeek==1){\n        print(year)\n    }\n    year+=1 \n}\n", "target": "from calendar import weekday, SUNDAY\n\n[year for year in range(2008, 2122) if weekday(year, 12, 25) == SUNDAY]\n"}
{"id": 26364, "name": "Short-circuit evaluation", "source": "Translate Swift to C#: func a(v: Bool) -> Bool {\n  print(\"a\")\n  return v\n}\n\nfunc b(v: Bool) -> Bool {\n  print(\"b\")\n  return v\n}\n\nfunc test(i: Bool, j: Bool) {\n  println(\"Testing a(\\(i)) && b(\\(j))\")\n  print(\"Trace:  \")\n  println(\"\\nResult: \\(a(i) && b(j))\")\n  \n  println(\"Testing a(\\(i)) || b(\\(j))\")\n  print(\"Trace:  \")\n  println(\"\\nResult: \\(a(i) || b(j))\")\n  \n  println()\n}\n\ntest(false, false)\ntest(false, true)\ntest(true, false)\ntest(true, true)\n", "target": "using System;\n\nclass Program\n{\n    static bool a(bool value)\n    {\n        Console.WriteLine(\"a\");\n        return value;\n    }\n\n    static bool b(bool value)\n    {\n        Console.WriteLine(\"b\");\n        return value;\n    }\n\n    static void Main()\n    {\n        foreach (var i in new[] { false, true })\n        {\n            foreach (var j in new[] { false, true })\n            {\n                Console.WriteLine(\"{0} and {1} = {2}\", i, j, a(i) && b(j));\n                Console.WriteLine();\n                Console.WriteLine(\"{0} or {1} = {2}\", i, j, a(i) || b(j));\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 26366, "name": "Short-circuit evaluation", "source": "Translate Swift to Java: func a(v: Bool) -> Bool {\n  print(\"a\")\n  return v\n}\n\nfunc b(v: Bool) -> Bool {\n  print(\"b\")\n  return v\n}\n\nfunc test(i: Bool, j: Bool) {\n  println(\"Testing a(\\(i)) && b(\\(j))\")\n  print(\"Trace:  \")\n  println(\"\\nResult: \\(a(i) && b(j))\")\n  \n  println(\"Testing a(\\(i)) || b(\\(j))\")\n  print(\"Trace:  \")\n  println(\"\\nResult: \\(a(i) || b(j))\")\n  \n  println()\n}\n\ntest(false, false)\ntest(false, true)\ntest(true, false)\ntest(true, true)\n", "target": "module test\n    {\n    @Inject Console console;\n\n    static Boolean show(String name, Boolean value)\n        {\n        console.print($\"{name}()={value}\");\n        return value;\n        }\n\n    void run()\n        {\n        val a = show(\"a\", _);\n        val b = show(\"b\", _);\n\n        for (Boolean v1 : False..True)\n            {\n            for (Boolean v2 : False..True)\n                {\n                console.print($\"a({v1}) && b({v2}) == {a(v1) && b(v2)}\");\n                console.print();\n                console.print($\"a({v1}) || b({v2}) == {a(v1) || b(v2)}\");\n                console.print();\n                }\n            }\n        }\n    }\n"}
{"id": 26367, "name": "Short-circuit evaluation", "source": "Translate Swift to Python: func a(v: Bool) -> Bool {\n  print(\"a\")\n  return v\n}\n\nfunc b(v: Bool) -> Bool {\n  print(\"b\")\n  return v\n}\n\nfunc test(i: Bool, j: Bool) {\n  println(\"Testing a(\\(i)) && b(\\(j))\")\n  print(\"Trace:  \")\n  println(\"\\nResult: \\(a(i) && b(j))\")\n  \n  println(\"Testing a(\\(i)) || b(\\(j))\")\n  print(\"Trace:  \")\n  println(\"\\nResult: \\(a(i) || b(j))\")\n  \n  println()\n}\n\ntest(false, false)\ntest(false, true)\ntest(true, false)\ntest(true, true)\n", "target": ">>> def a(answer):\n\tprint(\"  \n\treturn answer\n\n>>> def b(answer):\n\tprint(\"  \n\treturn answer\n\n>>> for i in (False, True):\n\tfor j in (False, True):\n\t\tprint (\"\\nCalculating: x = a(i) and b(j)\")\n\t\tx = a(i) and b(j)\n\t\tprint (\"Calculating: y = a(i) or  b(j)\")\n\t\ty = a(i) or  b(j)\n\n\t\t\n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)\n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)\n  \n"}
{"id": 26744, "name": "ISBN13 check digit", "source": "Translate Swift to C#: func checkISBN(isbn: String) -> Bool {\n  guard !isbn.isEmpty else {\n    return false\n  }\n\n  let sum = isbn\n    .compactMap({ $0.wholeNumberValue })\n    .enumerated()\n    .map({ $0.offset & 1 == 1 ? 3 * $0.element : $0.element })\n    .reduce(0, +)\n\n  return sum % 10 == 0\n}\n\nlet cases = [\n  \"978-1734314502\",\n  \"978-1734314509\",\n  \"978-1788399081\",\n  \"978-1788399083\"\n]\n\nfor isbn in cases {\n  print(\"\\(isbn) => \\(checkISBN(isbn: isbn) ? \"good\" : \"bad\")\")\n}\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(CheckISBN13(\"978-1734314502\"));\n        Console.WriteLine(CheckISBN13(\"978-1734314509\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399081\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399083\"));\n\n        static bool CheckISBN13(string code) {\n            code = code.Replace(\"-\", \"\").Replace(\" \", \"\");\n            if (code.Length != 13) return false;\n            int sum = 0;\n            foreach (var (index, digit) in code.Select((digit, index) => (index, digit))) {\n                if (char.IsDigit(digit)) sum += (digit - '0') * (index % 2 == 0 ? 1 : 3);\n                else return false;\n            }\n            return sum % 10 == 0;\n        }\n    }\n}\n"}
{"id": 26745, "name": "ISBN13 check digit", "source": "Translate Swift to C#: func checkISBN(isbn: String) -> Bool {\n  guard !isbn.isEmpty else {\n    return false\n  }\n\n  let sum = isbn\n    .compactMap({ $0.wholeNumberValue })\n    .enumerated()\n    .map({ $0.offset & 1 == 1 ? 3 * $0.element : $0.element })\n    .reduce(0, +)\n\n  return sum % 10 == 0\n}\n\nlet cases = [\n  \"978-1734314502\",\n  \"978-1734314509\",\n  \"978-1788399081\",\n  \"978-1788399083\"\n]\n\nfor isbn in cases {\n  print(\"\\(isbn) => \\(checkISBN(isbn: isbn) ? \"good\" : \"bad\")\")\n}\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(CheckISBN13(\"978-1734314502\"));\n        Console.WriteLine(CheckISBN13(\"978-1734314509\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399081\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399083\"));\n\n        static bool CheckISBN13(string code) {\n            code = code.Replace(\"-\", \"\").Replace(\" \", \"\");\n            if (code.Length != 13) return false;\n            int sum = 0;\n            foreach (var (index, digit) in code.Select((digit, index) => (index, digit))) {\n                if (char.IsDigit(digit)) sum += (digit - '0') * (index % 2 == 0 ? 1 : 3);\n                else return false;\n            }\n            return sum % 10 == 0;\n        }\n    }\n}\n"}
{"id": 26748, "name": "ISBN13 check digit", "source": "Translate Swift to Java: func checkISBN(isbn: String) -> Bool {\n  guard !isbn.isEmpty else {\n    return false\n  }\n\n  let sum = isbn\n    .compactMap({ $0.wholeNumberValue })\n    .enumerated()\n    .map({ $0.offset & 1 == 1 ? 3 * $0.element : $0.element })\n    .reduce(0, +)\n\n  return sum % 10 == 0\n}\n\nlet cases = [\n  \"978-1734314502\",\n  \"978-1734314509\",\n  \"978-1788399081\",\n  \"978-1788399083\"\n]\n\nfor isbn in cases {\n  print(\"\\(isbn) => \\(checkISBN(isbn: isbn) ? \"good\" : \"bad\")\")\n}\n", "target": "public static void main(){\n        System.out.println(isISBN13(\"978-1734314502\"));\n        System.out.println(isISBN13(\"978-1734314509\"));\n        System.out.println(isISBN13(\"978-1788399081\"));\n        System.out.println(isISBN13(\"978-1788399083\"));\n    }\npublic static boolean isISBN13(String in){\n        int pre = Integer.parseInt(in.substring(0,3));\n        if (pre!=978)return false;\n        String postStr = in.substring(4);\n        if (postStr.length()!=10)return false;\n        int post = Integer.parseInt(postStr);\n        int sum = 38;\n        for(int x = 0; x<10;x+=2)\n        sum += (postStr.charAt(x)-48)*3 + ((postStr.charAt(x+1)-48));\n        if(sum%10==0) return true;\n        return false;\n    }\n"}
{"id": 26749, "name": "ISBN13 check digit", "source": "Translate Swift to Java: func checkISBN(isbn: String) -> Bool {\n  guard !isbn.isEmpty else {\n    return false\n  }\n\n  let sum = isbn\n    .compactMap({ $0.wholeNumberValue })\n    .enumerated()\n    .map({ $0.offset & 1 == 1 ? 3 * $0.element : $0.element })\n    .reduce(0, +)\n\n  return sum % 10 == 0\n}\n\nlet cases = [\n  \"978-1734314502\",\n  \"978-1734314509\",\n  \"978-1788399081\",\n  \"978-1788399083\"\n]\n\nfor isbn in cases {\n  print(\"\\(isbn) => \\(checkISBN(isbn: isbn) ? \"good\" : \"bad\")\")\n}\n", "target": "public static void main(){\n        System.out.println(isISBN13(\"978-1734314502\"));\n        System.out.println(isISBN13(\"978-1734314509\"));\n        System.out.println(isISBN13(\"978-1788399081\"));\n        System.out.println(isISBN13(\"978-1788399083\"));\n    }\npublic static boolean isISBN13(String in){\n        int pre = Integer.parseInt(in.substring(0,3));\n        if (pre!=978)return false;\n        String postStr = in.substring(4);\n        if (postStr.length()!=10)return false;\n        int post = Integer.parseInt(postStr);\n        int sum = 38;\n        for(int x = 0; x<10;x+=2)\n        sum += (postStr.charAt(x)-48)*3 + ((postStr.charAt(x+1)-48));\n        if(sum%10==0) return true;\n        return false;\n    }\n"}
{"id": 26750, "name": "ISBN13 check digit", "source": "Translate Swift to Python: func checkISBN(isbn: String) -> Bool {\n  guard !isbn.isEmpty else {\n    return false\n  }\n\n  let sum = isbn\n    .compactMap({ $0.wholeNumberValue })\n    .enumerated()\n    .map({ $0.offset & 1 == 1 ? 3 * $0.element : $0.element })\n    .reduce(0, +)\n\n  return sum % 10 == 0\n}\n\nlet cases = [\n  \"978-1734314502\",\n  \"978-1734314509\",\n  \"978-1788399081\",\n  \"978-1788399083\"\n]\n\nfor isbn in cases {\n  print(\"\\(isbn) => \\(checkISBN(isbn: isbn) ? \"good\" : \"bad\")\")\n}\n", "target": "def is_isbn13(n):\n    n = n.replace('-','').replace(' ', '')\n    if len(n) != 13:\n        return False\n    product = (sum(int(ch) for ch in n[::2]) \n               + sum(int(ch) * 3 for ch in n[1::2]))\n    return product % 10 == 0\n\nif __name__ == '__main__':\n    tests = .strip().split()\n    for t in tests:\n        print(f\"ISBN13 {t} validates {is_isbn13(t)}\")\n"}
{"id": 26751, "name": "ISBN13 check digit", "source": "Translate Swift to Python: func checkISBN(isbn: String) -> Bool {\n  guard !isbn.isEmpty else {\n    return false\n  }\n\n  let sum = isbn\n    .compactMap({ $0.wholeNumberValue })\n    .enumerated()\n    .map({ $0.offset & 1 == 1 ? 3 * $0.element : $0.element })\n    .reduce(0, +)\n\n  return sum % 10 == 0\n}\n\nlet cases = [\n  \"978-1734314502\",\n  \"978-1734314509\",\n  \"978-1788399081\",\n  \"978-1788399083\"\n]\n\nfor isbn in cases {\n  print(\"\\(isbn) => \\(checkISBN(isbn: isbn) ? \"good\" : \"bad\")\")\n}\n", "target": "def is_isbn13(n):\n    n = n.replace('-','').replace(' ', '')\n    if len(n) != 13:\n        return False\n    product = (sum(int(ch) for ch in n[::2]) \n               + sum(int(ch) * 3 for ch in n[1::2]))\n    return product % 10 == 0\n\nif __name__ == '__main__':\n    tests = .strip().split()\n    for t in tests:\n        print(f\"ISBN13 {t} validates {is_isbn13(t)}\")\n"}
{"id": 27050, "name": "Days between dates", "source": "Translate Swift to C#: import Foundation\n\nfunc daysFromTimeInterval(_ interval: Double) -> Int {\n  return Int(interval) / 86400\n}\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nprint(\"Enter date one (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date1Str = readLine(strippingNewline: true), let date1 = formatter.date(from: date1Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nprint(\"Enter date two (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date2Str = readLine(strippingNewline: true), let date2 = formatter.date(from: date2Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nlet (start, end) = date1 > date2 ? (date2, date1) : (date1, date2)\nlet days = daysFromTimeInterval(DateInterval(start: start, end: end).duration)\n\nprint(\"There are \\(days) days between \\(start) and \\(end)\")\n", "target": "using System;\nusing System.Globalization;\n\npublic class Program\n{\n    public static void Main() => WriteLine(DateDiff(\"1970-01-01\", \"2019-10-18\"));\n\n    public static int DateDiff(string d1, string d2) {\n        var a = DateTime.ParseExact(d1, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        var b = DateTime.ParseExact(d2, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        return (int)(b - a).TotalDays;\n    }\n}\n"}
{"id": 27051, "name": "Days between dates", "source": "Translate Swift to C#: import Foundation\n\nfunc daysFromTimeInterval(_ interval: Double) -> Int {\n  return Int(interval) / 86400\n}\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nprint(\"Enter date one (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date1Str = readLine(strippingNewline: true), let date1 = formatter.date(from: date1Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nprint(\"Enter date two (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date2Str = readLine(strippingNewline: true), let date2 = formatter.date(from: date2Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nlet (start, end) = date1 > date2 ? (date2, date1) : (date1, date2)\nlet days = daysFromTimeInterval(DateInterval(start: start, end: end).duration)\n\nprint(\"There are \\(days) days between \\(start) and \\(end)\")\n", "target": "using System;\nusing System.Globalization;\n\npublic class Program\n{\n    public static void Main() => WriteLine(DateDiff(\"1970-01-01\", \"2019-10-18\"));\n\n    public static int DateDiff(string d1, string d2) {\n        var a = DateTime.ParseExact(d1, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        var b = DateTime.ParseExact(d2, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        return (int)(b - a).TotalDays;\n    }\n}\n"}
{"id": 27054, "name": "Days between dates", "source": "Translate Swift to Java: import Foundation\n\nfunc daysFromTimeInterval(_ interval: Double) -> Int {\n  return Int(interval) / 86400\n}\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nprint(\"Enter date one (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date1Str = readLine(strippingNewline: true), let date1 = formatter.date(from: date1Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nprint(\"Enter date two (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date2Str = readLine(strippingNewline: true), let date2 = formatter.date(from: date2Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nlet (start, end) = date1 > date2 ? (date2, date1) : (date1, date2)\nlet days = daysFromTimeInterval(DateInterval(start: start, end: end).duration)\n\nprint(\"There are \\(days) days between \\(start) and \\(end)\")\n", "target": "import java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class DaysBetweenDates {\n    public static void main(String[] args) {\n        LocalDate fromDate = LocalDate.parse(\"2019-01-01\");\n        LocalDate toDate = LocalDate.parse(\"2019-10-19\");\n        long diff = ChronoUnit.DAYS.between(fromDate, toDate);\n        System.out.printf(\"Number of days between %s and %s: %d\\n\", fromDate, toDate, diff);\n    }\n}\n"}
{"id": 27055, "name": "Days between dates", "source": "Translate Swift to Java: import Foundation\n\nfunc daysFromTimeInterval(_ interval: Double) -> Int {\n  return Int(interval) / 86400\n}\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nprint(\"Enter date one (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date1Str = readLine(strippingNewline: true), let date1 = formatter.date(from: date1Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nprint(\"Enter date two (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date2Str = readLine(strippingNewline: true), let date2 = formatter.date(from: date2Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nlet (start, end) = date1 > date2 ? (date2, date1) : (date1, date2)\nlet days = daysFromTimeInterval(DateInterval(start: start, end: end).duration)\n\nprint(\"There are \\(days) days between \\(start) and \\(end)\")\n", "target": "import java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class DaysBetweenDates {\n    public static void main(String[] args) {\n        LocalDate fromDate = LocalDate.parse(\"2019-01-01\");\n        LocalDate toDate = LocalDate.parse(\"2019-10-19\");\n        long diff = ChronoUnit.DAYS.between(fromDate, toDate);\n        System.out.printf(\"Number of days between %s and %s: %d\\n\", fromDate, toDate, diff);\n    }\n}\n"}
{"id": 27056, "name": "Days between dates", "source": "Translate Swift to Python: import Foundation\n\nfunc daysFromTimeInterval(_ interval: Double) -> Int {\n  return Int(interval) / 86400\n}\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nprint(\"Enter date one (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date1Str = readLine(strippingNewline: true), let date1 = formatter.date(from: date1Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nprint(\"Enter date two (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date2Str = readLine(strippingNewline: true), let date2 = formatter.date(from: date2Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nlet (start, end) = date1 > date2 ? (date2, date1) : (date1, date2)\nlet days = daysFromTimeInterval(DateInterval(start: start, end: end).duration)\n\nprint(\"There are \\(days) days between \\(start) and \\(end)\")\n", "target": "\nimport sys\n\n\n\ndef days( y,m,d ):\n  \n  m = (m + 9) % 12 \n  y = y - m/10\n\n  \n  result = 365*y + y/4 - y/100 + y/400 + (m*306 + 5)/10 + ( d - 1 )\n  return result\n\ndef diff(one,two):\n  [y1,m1,d1] = one.split('-')\n  [y2,m2,d2] = two.split('-')\n  \n  year2 = days( int(y2),int(m2),int(d2))\n  year1 = days( int(y1), int(m1), int(d1) )\n  return year2 - year1\n\nif __name__ == \"__main__\":\n  one = sys.argv[1]\n  two = sys.argv[2]\n  print diff(one,two)\n"}
{"id": 27057, "name": "Days between dates", "source": "Translate Swift to Python: import Foundation\n\nfunc daysFromTimeInterval(_ interval: Double) -> Int {\n  return Int(interval) / 86400\n}\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nprint(\"Enter date one (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date1Str = readLine(strippingNewline: true), let date1 = formatter.date(from: date1Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nprint(\"Enter date two (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date2Str = readLine(strippingNewline: true), let date2 = formatter.date(from: date2Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nlet (start, end) = date1 > date2 ? (date2, date1) : (date1, date2)\nlet days = daysFromTimeInterval(DateInterval(start: start, end: end).duration)\n\nprint(\"There are \\(days) days between \\(start) and \\(end)\")\n", "target": "\nimport sys\n\n\n\ndef days( y,m,d ):\n  \n  m = (m + 9) % 12 \n  y = y - m/10\n\n  \n  result = 365*y + y/4 - y/100 + y/400 + (m*306 + 5)/10 + ( d - 1 )\n  return result\n\ndef diff(one,two):\n  [y1,m1,d1] = one.split('-')\n  [y2,m2,d2] = two.split('-')\n  \n  year2 = days( int(y2),int(m2),int(d2))\n  year1 = days( int(y1), int(m1), int(d1) )\n  return year2 - year1\n\nif __name__ == \"__main__\":\n  one = sys.argv[1]\n  two = sys.argv[2]\n  print diff(one,two)\n"}
{"id": 27297, "name": "Look-and-say sequence", "source": "Translate Swift to C#: func lookAndSay(_ seq: [Int]) -> [Int] {\n  var result = [Int]()\n  var cur = seq[0]\n  var curRunLength = 1\n\n  for i in seq.dropFirst() {\n    if cur == i {\n      curRunLength += 1\n    } else {\n      result.append(curRunLength)\n      result.append(cur)\n      curRunLength = 1\n      cur = i\n    }\n  }\n\n  result.append(curRunLength)\n  result.append(cur)\n\n  return result\n}\n\nvar seq = [1]\n\nfor i in 0..<10 {\n  print(\"Seq \\(i): \\(seq)\")\n  seq = lookAndSay(seq)\n}\n", "target": "using System;\nusing System.Text;\nusing System.Linq;\n\nclass Program\n{\n    static string lookandsay(string number)\n    {\n        StringBuilder result = new StringBuilder();\n\n        char repeat = number[0];\n        number = number.Substring(1, number.Length-1)+\" \";\n        int times = 1;\n      \n        foreach (char actual in number)\n        {\n            if (actual != repeat)\n            {\n                result.Append(Convert.ToString(times)+repeat);\n                times = 1;\n                repeat = actual;\n            }\n            else\n            {\n                times += 1;\n            }\n        }\n        return result.ToString();\n    }\n\n    static void Main(string[] args)\n    {\n        string num = \"1\"; \n\n        foreach (int i in Enumerable.Range(1, 10)) {\n             Console.WriteLine(num);\n             num = lookandsay(num);             \n        }\n    }\n}\n"}
{"id": 27299, "name": "Look-and-say sequence", "source": "Translate Swift to Java: func lookAndSay(_ seq: [Int]) -> [Int] {\n  var result = [Int]()\n  var cur = seq[0]\n  var curRunLength = 1\n\n  for i in seq.dropFirst() {\n    if cur == i {\n      curRunLength += 1\n    } else {\n      result.append(curRunLength)\n      result.append(cur)\n      curRunLength = 1\n      cur = i\n    }\n  }\n\n  result.append(curRunLength)\n  result.append(cur)\n\n  return result\n}\n\nvar seq = [1]\n\nfor i in 0..<10 {\n  print(\"Seq \\(i): \\(seq)\")\n  seq = lookAndSay(seq)\n}\n", "target": "public static String lookandsay(String number){\n\tStringBuilder result= new StringBuilder();\n\n\tchar repeat= number.charAt(0);\n\tnumber= number.substring(1) + \" \";\n\tint times= 1;\n\n\tfor(char actual: number.toCharArray()){\n\t\tif(actual != repeat){\n\t\t\tresult.append(times + \"\" + repeat);\n\t\t\ttimes= 1;\n\t\t\trepeat= actual;\n\t\t}else{\n\t\t\ttimes+= 1;\n\t\t}\n\t}\n\treturn result.toString();\n}\n"}
{"id": 27300, "name": "Look-and-say sequence", "source": "Translate Swift to Python: func lookAndSay(_ seq: [Int]) -> [Int] {\n  var result = [Int]()\n  var cur = seq[0]\n  var curRunLength = 1\n\n  for i in seq.dropFirst() {\n    if cur == i {\n      curRunLength += 1\n    } else {\n      result.append(curRunLength)\n      result.append(cur)\n      curRunLength = 1\n      cur = i\n    }\n  }\n\n  result.append(curRunLength)\n  result.append(cur)\n\n  return result\n}\n\nvar seq = [1]\n\nfor i in 0..<10 {\n  print(\"Seq \\(i): \\(seq)\")\n  seq = lookAndSay(seq)\n}\n", "target": "def lookandsay(number):\n    result = \"\"\n\n    repeat = number[0]\n    number = number[1:]+\" \"\n    times = 1\n\n    for actual in number:\n        if actual != repeat:\n            result += str(times)+repeat\n            times = 1\n            repeat = actual\n        else:\n            times += 1\n\n    return result\n\nnum = \"1\"\n\nfor i in range(10):\n    print num\n    num = lookandsay(num)\n"}
{"id": 27652, "name": "Closures_Value capture", "source": "Translate Swift to C#: var funcs: [() -> Int] = []\nfor var i = 0; i < 10; i++ {\n  funcs.append({ i * i })\n}\nprintln(funcs[3]()) \n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        var captor = (Func<int, Func<int>>)(number => () => number * number);\n        var functions = Enumerable.Range(0, 10).Select(captor);\n        foreach (var function in functions.Take(9))\n        {\n            Console.WriteLine(function());\n        }\n    }\n}\n"}
{"id": 27653, "name": "Closures_Value capture", "source": "Translate Swift to C#: var funcs: [() -> Int] = []\nfor var i = 0; i < 10; i++ {\n  funcs.append({ i * i })\n}\nprintln(funcs[3]()) \n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        var captor = (Func<int, Func<int>>)(number => () => number * number);\n        var functions = Enumerable.Range(0, 10).Select(captor);\n        foreach (var function in functions.Take(9))\n        {\n            Console.WriteLine(function());\n        }\n    }\n}\n"}
{"id": 27656, "name": "Closures_Value capture", "source": "Translate Swift to Java: var funcs: [() -> Int] = []\nfor var i = 0; i < 10; i++ {\n  funcs.append({ i * i })\n}\nprintln(funcs[3]()) \n", "target": "import java.util.function.Supplier;\nimport java.util.ArrayList;\n\npublic class ValueCapture {\n    public static void main(String[] args) {\n\tArrayList<Supplier<Integer>> funcs = new ArrayList<>();\n\tfor (int i = 0; i < 10; i++) {\n\t    int j = i;\n\t    funcs.add(() -> j * j);\n\t}\n\n\tSupplier<Integer> foo = funcs.get(3);\n\tSystem.out.println(foo.get()); \n    }\n}\n"}
{"id": 27657, "name": "Closures_Value capture", "source": "Translate Swift to Java: var funcs: [() -> Int] = []\nfor var i = 0; i < 10; i++ {\n  funcs.append({ i * i })\n}\nprintln(funcs[3]()) \n", "target": "import java.util.function.Supplier;\nimport java.util.ArrayList;\n\npublic class ValueCapture {\n    public static void main(String[] args) {\n\tArrayList<Supplier<Integer>> funcs = new ArrayList<>();\n\tfor (int i = 0; i < 10; i++) {\n\t    int j = i;\n\t    funcs.add(() -> j * j);\n\t}\n\n\tSupplier<Integer> foo = funcs.get(3);\n\tSystem.out.println(foo.get()); \n    }\n}\n"}
{"id": 27658, "name": "Closures_Value capture", "source": "Translate Swift to Python: var funcs: [() -> Int] = []\nfor var i = 0; i < 10; i++ {\n  funcs.append({ i * i })\n}\nprintln(funcs[3]()) \n", "target": "funcs = []\nfor i in range(10):\n    funcs.append(lambda: i * i)\nprint funcs[3]() \n"}
{"id": 27659, "name": "Closures_Value capture", "source": "Translate Swift to Python: var funcs: [() -> Int] = []\nfor var i = 0; i < 10; i++ {\n  funcs.append({ i * i })\n}\nprintln(funcs[3]()) \n", "target": "funcs = []\nfor i in range(10):\n    funcs.append(lambda: i * i)\nprint funcs[3]() \n"}
{"id": 28393, "name": "Caesar cipher", "source": "Translate Swift to C#: func usage(_ e:String) {\n  print(\"error: \\(e)\")\n  print(\"./caeser -e 19 a-secret-string\")\n  print(\"./caeser -d 19 tskxvjxlskljafz\")\n}\n\nfunc charIsValid(_ c:Character) -> Bool {\n  return c.isASCII && ( c.isLowercase || 45 == c.asciiValue ) \n}\n\nfunc charRotate(_ c:Character, _ by:Int) -> Character {\n  var cv:UInt8! = c.asciiValue\n  if 45 == cv { cv = 96 }  \n  cv += UInt8(by)\n  if 122 < cv { cv -= 27 } \n  if 96 == cv { cv = 45 }  \n  return Character(UnicodeScalar(cv))\n}\n\nfunc caesar(_ enc:Bool, _ key:Int, _ word:String) -> String {\n  let r = enc ? key : 27 - key\n  func charRotateWithKey(_ c:Character) -> Character {\n    return charRotate(c,r)\n  }\n  return String(word.map(charRotateWithKey))\n}\n\nfunc main() {\n  var encrypt = true\n\n  if 4 != CommandLine.arguments.count {\n    return usage(\"caesar expects exactly three arguments\")\n  }\n\n  switch ( CommandLine.arguments[1] ) {\n  case \"-e\":\n    encrypt = true\n  case \"-d\":\n    encrypt = false\n  default:\n    return usage(\"first argument must be -e (encrypt) or -d (decrypt)\")\n  }\n\n  guard let key = Int(CommandLine.arguments[2]) else {\n    return usage(\"second argument not a number (must be in range 0-26)\")\n  }\n\n  if key < 0 || 26 < key {\n    return usage(\"second argument not in range 0-26\")\n  }\n\n  if !CommandLine.arguments[3].allSatisfy(charIsValid) {\n    return usage(\"third argument must only be lowercase ascii characters, or -\")\n  }\n\n  let ans = caesar(encrypt,key,CommandLine.arguments[3])\n  print(\"\\(ans)\")\n}\n\nfunc test() {\n  if ( Character(\"a\") != charRotate(Character(\"a\"),0) ) {\n    print(\"Test Fail 1\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"-\"),0) ) {\n    print(\"Test Fail 2\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"z\"),1) ) {\n    print(\"Test Fail 3\")\n  }\n  if ( Character(\"z\") != charRotate(Character(\"-\"),26)) {\n    print(\"Test Fail 4\")\n  }\n  if ( \"ihgmkzma\" != caesar(true,8,\"a-zecret\") ) {\n    print(\"Test Fail 5\")\n  }\n  if ( \"a-zecret\" != caesar(false,8,\"ihgmkzma\") ) {\n    print(\"Test Fail 6\")\n  }\n}\n\ntest()\nmain()\n", "target": "using System;\nusing System.Linq;\n\nnamespace CaesarCypher\n{\n    class Program\n    {\n        static char Encrypt(char ch, int code)\n        {\n            if (!char.IsLetter(ch)) return ch;\n\n            char offset = char.IsUpper(ch) ? 'A' : 'a';\n            return (char)((ch + code - offset) % 26 + offset);\n        }\n\n        static string Encrypt(string input, int code)\n        {\n            return new string(input.Select(ch => Encrypt(ch, code)).ToArray());\n        }\n\n        static string Decrypt(string input, int code)\n        {\n            return Encrypt(input, 26 - code);\n        }\n\n        const string TestCase = \"Pack my box with five dozen liquor jugs.\";\n\n        static void Main()\n        {\n            string str = TestCase;\n\n            Console.WriteLine(str);\n            str = Encrypt(str, 5);\n            Console.WriteLine(\"Encrypted: \" + str);\n            str = Decrypt(str, 5);\n            Console.WriteLine(\"Decrypted: \" + str);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 28395, "name": "Caesar cipher", "source": "Translate Swift to Java: func usage(_ e:String) {\n  print(\"error: \\(e)\")\n  print(\"./caeser -e 19 a-secret-string\")\n  print(\"./caeser -d 19 tskxvjxlskljafz\")\n}\n\nfunc charIsValid(_ c:Character) -> Bool {\n  return c.isASCII && ( c.isLowercase || 45 == c.asciiValue ) \n}\n\nfunc charRotate(_ c:Character, _ by:Int) -> Character {\n  var cv:UInt8! = c.asciiValue\n  if 45 == cv { cv = 96 }  \n  cv += UInt8(by)\n  if 122 < cv { cv -= 27 } \n  if 96 == cv { cv = 45 }  \n  return Character(UnicodeScalar(cv))\n}\n\nfunc caesar(_ enc:Bool, _ key:Int, _ word:String) -> String {\n  let r = enc ? key : 27 - key\n  func charRotateWithKey(_ c:Character) -> Character {\n    return charRotate(c,r)\n  }\n  return String(word.map(charRotateWithKey))\n}\n\nfunc main() {\n  var encrypt = true\n\n  if 4 != CommandLine.arguments.count {\n    return usage(\"caesar expects exactly three arguments\")\n  }\n\n  switch ( CommandLine.arguments[1] ) {\n  case \"-e\":\n    encrypt = true\n  case \"-d\":\n    encrypt = false\n  default:\n    return usage(\"first argument must be -e (encrypt) or -d (decrypt)\")\n  }\n\n  guard let key = Int(CommandLine.arguments[2]) else {\n    return usage(\"second argument not a number (must be in range 0-26)\")\n  }\n\n  if key < 0 || 26 < key {\n    return usage(\"second argument not in range 0-26\")\n  }\n\n  if !CommandLine.arguments[3].allSatisfy(charIsValid) {\n    return usage(\"third argument must only be lowercase ascii characters, or -\")\n  }\n\n  let ans = caesar(encrypt,key,CommandLine.arguments[3])\n  print(\"\\(ans)\")\n}\n\nfunc test() {\n  if ( Character(\"a\") != charRotate(Character(\"a\"),0) ) {\n    print(\"Test Fail 1\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"-\"),0) ) {\n    print(\"Test Fail 2\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"z\"),1) ) {\n    print(\"Test Fail 3\")\n  }\n  if ( Character(\"z\") != charRotate(Character(\"-\"),26)) {\n    print(\"Test Fail 4\")\n  }\n  if ( \"ihgmkzma\" != caesar(true,8,\"a-zecret\") ) {\n    print(\"Test Fail 5\")\n  }\n  if ( \"a-zecret\" != caesar(false,8,\"ihgmkzma\") ) {\n    print(\"Test Fail 6\")\n  }\n}\n\ntest()\nmain()\n", "target": "public class Cipher {\n    public static void main(String[] args) {\n\n        String str = \"The quick brown fox Jumped over the lazy Dog\";\n\n        System.out.println( Cipher.encode( str, 12 ));\n        System.out.println( Cipher.decode( Cipher.encode( str, 12), 12 ));\n    }\n\n    public static String decode(String enc, int offset) {\n        return encode(enc, 26-offset);\n    }\n\n    public static String encode(String enc, int offset) {\n        offset = offset % 26 + 26;\n        StringBuilder encoded = new StringBuilder();\n        for (char i : enc.toCharArray()) {\n            if (Character.isLetter(i)) {\n                if (Character.isUpperCase(i)) {\n                    encoded.append((char) ('A' + (i - 'A' + offset) % 26 ));\n                } else {\n                    encoded.append((char) ('a' + (i - 'a' + offset) % 26 ));\n                }\n            } else {\n                encoded.append(i);\n            }\n        }\n        return encoded.toString();\n    }\n}\n"}
{"id": 28396, "name": "Caesar cipher", "source": "Translate Swift to Python: func usage(_ e:String) {\n  print(\"error: \\(e)\")\n  print(\"./caeser -e 19 a-secret-string\")\n  print(\"./caeser -d 19 tskxvjxlskljafz\")\n}\n\nfunc charIsValid(_ c:Character) -> Bool {\n  return c.isASCII && ( c.isLowercase || 45 == c.asciiValue ) \n}\n\nfunc charRotate(_ c:Character, _ by:Int) -> Character {\n  var cv:UInt8! = c.asciiValue\n  if 45 == cv { cv = 96 }  \n  cv += UInt8(by)\n  if 122 < cv { cv -= 27 } \n  if 96 == cv { cv = 45 }  \n  return Character(UnicodeScalar(cv))\n}\n\nfunc caesar(_ enc:Bool, _ key:Int, _ word:String) -> String {\n  let r = enc ? key : 27 - key\n  func charRotateWithKey(_ c:Character) -> Character {\n    return charRotate(c,r)\n  }\n  return String(word.map(charRotateWithKey))\n}\n\nfunc main() {\n  var encrypt = true\n\n  if 4 != CommandLine.arguments.count {\n    return usage(\"caesar expects exactly three arguments\")\n  }\n\n  switch ( CommandLine.arguments[1] ) {\n  case \"-e\":\n    encrypt = true\n  case \"-d\":\n    encrypt = false\n  default:\n    return usage(\"first argument must be -e (encrypt) or -d (decrypt)\")\n  }\n\n  guard let key = Int(CommandLine.arguments[2]) else {\n    return usage(\"second argument not a number (must be in range 0-26)\")\n  }\n\n  if key < 0 || 26 < key {\n    return usage(\"second argument not in range 0-26\")\n  }\n\n  if !CommandLine.arguments[3].allSatisfy(charIsValid) {\n    return usage(\"third argument must only be lowercase ascii characters, or -\")\n  }\n\n  let ans = caesar(encrypt,key,CommandLine.arguments[3])\n  print(\"\\(ans)\")\n}\n\nfunc test() {\n  if ( Character(\"a\") != charRotate(Character(\"a\"),0) ) {\n    print(\"Test Fail 1\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"-\"),0) ) {\n    print(\"Test Fail 2\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"z\"),1) ) {\n    print(\"Test Fail 3\")\n  }\n  if ( Character(\"z\") != charRotate(Character(\"-\"),26)) {\n    print(\"Test Fail 4\")\n  }\n  if ( \"ihgmkzma\" != caesar(true,8,\"a-zecret\") ) {\n    print(\"Test Fail 5\")\n  }\n  if ( \"a-zecret\" != caesar(false,8,\"ihgmkzma\") ) {\n    print(\"Test Fail 6\")\n  }\n}\n\ntest()\nmain()\n", "target": "fun caesar(s, k, decode: false):\n    if decode:\n        k = 26 - k\n    result = ''\n    for i in s.uppercase() where 65 <= ord(i) <= 90:\n        result.push! char(ord(i) - 65 + k) mod 26 + 65\n    return result\n\nlet message = \"The quick brown fox jumped over the lazy dogs\"\nlet encrypted = caesar(msg, 11)\nlet decrypted = caesar(enc, 11, decode: true)\n\nprint(message, encrypted, decrypted, sep: '\\n')\n"}
{"id": 28725, "name": "Lucas-Lehmer test", "source": "Translate Swift to C#: import BigInt         \nimport Darwin\n\nfunc Eratosthenes(upTo: Int) -> [Int] {\n    \n    let maxroot = Int(sqrt(Double(upTo)))\n    \n    var isprime = [Bool](repeating: true, count: upTo+1 )\n    for i in 2...maxroot {\n        if isprime[i] {\n            for k in stride(from: upTo/i, through: i, by: -1) {\n                if isprime[k] {\n                    isprime[i*k] = false }\n            }\n        }\n    }\n    var result = [Int]()\n    for i in 2...upTo {\n        if isprime[i] {\n            result.append( i)\n        }\n    }\n    return result\n}\n\nfunc lucasLehmer(_ p: Int) -> Bool {\n    let m = BigInt(2).power(p) - 1\n    var s = BigInt(4)\n    \n    for _ in 0..<p-2 {\n        s = ((s * s) - 2) % m\n    }\n    \n    return s == 0\n}\n\nfor prime in Eratosthenes(upTo: 128) where lucasLehmer(prime) {\n    let mprime = BigInt(2).power(prime) - 1\n    print(\"2^\\(prime) - 1 = \\(mprime) is prime\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\nusing System.Threading.Tasks;\n\nnamespace LucasLehmerTestForRosettaCode\n{\n    public class LucasLehmerTest\n    {\n        static BigInteger ZERO = new BigInteger(0);\n        static BigInteger ONE = new BigInteger(1);\n        static BigInteger TWO = new BigInteger(2);\n        static BigInteger FOUR = new BigInteger(4);\n\n        private static bool isMersennePrime(int p) \n        {\n            if (p % 2 == 0) return (p == 2);\n            else {\n                for (int i = 3; i <= (int)Math.Sqrt(p); i += 2)\n                    if (p % i == 0) return false; \n                BigInteger m_p = BigInteger.Pow(TWO, p) - ONE;\n                BigInteger s = FOUR;\n                for (int i = 3; i <= p; i++)\n                    s = (s * s - TWO) % m_p;\n                return s == ZERO;\n            } \n        }\n\n        public static int[] GetMersennePrimeNumbers(int upTo)\n        {\n            List<int> response = new List<int>();\n            Parallel.For(2, upTo + 1, i => {\n                if (isMersennePrime(i)) response.Add(i);\n            });\n            response.Sort();\n            return response.ToArray();\n        }\n\n        static void Main(string[] args)\n        {\n            int[] mersennePrimes = LucasLehmerTest.GetMersennePrimeNumbers(11213);\n            foreach (int mp in mersennePrimes)\n                Console.Write(\"M\" + mp+\" \");\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 28727, "name": "Lucas-Lehmer test", "source": "Translate Swift to Java: import BigInt         \nimport Darwin\n\nfunc Eratosthenes(upTo: Int) -> [Int] {\n    \n    let maxroot = Int(sqrt(Double(upTo)))\n    \n    var isprime = [Bool](repeating: true, count: upTo+1 )\n    for i in 2...maxroot {\n        if isprime[i] {\n            for k in stride(from: upTo/i, through: i, by: -1) {\n                if isprime[k] {\n                    isprime[i*k] = false }\n            }\n        }\n    }\n    var result = [Int]()\n    for i in 2...upTo {\n        if isprime[i] {\n            result.append( i)\n        }\n    }\n    return result\n}\n\nfunc lucasLehmer(_ p: Int) -> Bool {\n    let m = BigInt(2).power(p) - 1\n    var s = BigInt(4)\n    \n    for _ in 0..<p-2 {\n        s = ((s * s) - 2) % m\n    }\n    \n    return s == 0\n}\n\nfor prime in Eratosthenes(upTo: 128) where lucasLehmer(prime) {\n    let mprime = BigInt(2).power(prime) - 1\n    print(\"2^\\(prime) - 1 = \\(mprime) is prime\")\n}\n", "target": "import java.math.BigInteger;\npublic class Mersenne\n{\n\n    public static boolean isPrime(int p) {\n        if (p == 2)\n            return true;\n        else if (p <= 1 || p % 2 == 0)\n            return false;\n        else {\n            int to = (int)Math.sqrt(p);\n            for (int i = 3; i <= to; i += 2)\n                if (p % i == 0)\n                    return false;\n            return true;\n        }\n    }\n\n    public static boolean isMersennePrime(int p) {\n        if (p == 2)\n            return true;\n        else {\n            BigInteger m_p = BigInteger.ONE.shiftLeft(p).subtract(BigInteger.ONE);\n            BigInteger s = BigInteger.valueOf(4);\n            for (int i = 3; i <= p; i++)\n                s = s.multiply(s).subtract(BigInteger.valueOf(2)).mod(m_p);\n            return s.equals(BigInteger.ZERO);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        int upb;\n        if (args.length == 0)\n            upb = 500;\n        else\n            upb = Integer.parseInt(args[0]);\n\n        System.out.print(\" Finding Mersenne primes in M[2..\" + upb + \"]:\\nM2 \");\n        for (int p = 3; p <= upb; p += 2)\n            if (isPrime(p) && isMersennePrime(p))\n                System.out.print(\" M\" + p);\n        System.out.println();\n    }\n}\n"}
{"id": 28728, "name": "Lucas-Lehmer test", "source": "Translate Swift to Python: import BigInt         \nimport Darwin\n\nfunc Eratosthenes(upTo: Int) -> [Int] {\n    \n    let maxroot = Int(sqrt(Double(upTo)))\n    \n    var isprime = [Bool](repeating: true, count: upTo+1 )\n    for i in 2...maxroot {\n        if isprime[i] {\n            for k in stride(from: upTo/i, through: i, by: -1) {\n                if isprime[k] {\n                    isprime[i*k] = false }\n            }\n        }\n    }\n    var result = [Int]()\n    for i in 2...upTo {\n        if isprime[i] {\n            result.append( i)\n        }\n    }\n    return result\n}\n\nfunc lucasLehmer(_ p: Int) -> Bool {\n    let m = BigInt(2).power(p) - 1\n    var s = BigInt(4)\n    \n    for _ in 0..<p-2 {\n        s = ((s * s) - 2) % m\n    }\n    \n    return s == 0\n}\n\nfor prime in Eratosthenes(upTo: 128) where lucasLehmer(prime) {\n    let mprime = BigInt(2).power(prime) - 1\n    print(\"2^\\(prime) - 1 = \\(mprime) is prime\")\n}\n", "target": "from sys import stdout\nfrom math import sqrt, log\n\ndef is_prime ( p ):\n  if p == 2: return True \n  elif p <= 1 or p % 2 == 0: return False\n  else:\n    for i in range(3, int(sqrt(p))+1, 2 ): \n      if p % i == 0: return False\n    return True\n\ndef is_mersenne_prime ( p ):\n  if p == 2:\n    return True\n  else:\n    m_p = ( 1 << p ) - 1\n    s = 4\n    for i in range(3, p+1): \n      s = (s ** 2 - 2) % m_p\n    return s == 0\n\nprecision = 20000   \nlong_bits_width = precision * log(10, 2)\nupb_prime = int( long_bits_width - 1 ) / 2    \nupb_count = 45      \n\nprint (\" Finding Mersenne primes in M[2..%d]:\"%upb_prime)\n\ncount=0\nfor p in range(2, int(upb_prime+1)): \n  if is_prime(p) and is_mersenne_prime(p):\n    print(\"M%d\"%p),\n    stdout.flush()\n    count += 1\n  if count >= upb_count: break\nprint\n"}
{"id": 28963, "name": "FizzBuzz", "source": "Translate Swift to C#: for i in 1...100 {\n    switch (i % 3, i % 5) {\n    case (0, 0):\n        print(\"FizzBuzz\")\n    case (0, _):\n        print(\"Fizz\")\n    case (_, 0):\n        print(\"Buzz\")\n    default:\n        print(i)\n    }\n}\n", "target": "class Program\n{\n    public void FizzBuzzGo()\n    {\n        Boolean Fizz = false;\n        Boolean Buzz = false;\n        for (int count = 1; count <= 100; count ++)\n        {\n            Fizz = count % 3 == 0;\n            Buzz = count % 5 == 0;\n            if (Fizz && Buzz)\n            {\n                Console.WriteLine(\"Fizz Buzz\");\n                listBox1.Items.Add(\"Fizz Buzz\");\n            }\n            else if (Fizz)\n            {\n                Console.WriteLine(\"Fizz\");\n                listBox1.Items.Add(\"Fizz\");\n            }\n            else if (Buzz)\n            {\n                Console.WriteLine(\"Buzz\");\n                listBox1.Items.Add(\"Buzz\");\n            }\n            else\n            {\n                Console.WriteLine(count);\n                listBox1.Items.Add(count);\n            }\n        }\n    }\n}\n"}
{"id": 28965, "name": "FizzBuzz", "source": "Translate Swift to Java: for i in 1...100 {\n    switch (i % 3, i % 5) {\n    case (0, 0):\n        print(\"FizzBuzz\")\n    case (0, _):\n        print(\"Fizz\")\n    case (_, 0):\n        print(\"Buzz\")\n    default:\n        print(i)\n    }\n}\n", "target": "module FizzBuzz\n    {\n    void run()\n        {\n        @Inject Console console;\n        for (Int x : 1..100)\n            {\n            console.print(switch (x % 3, x % 5)\n                {\n                case (0, 0): \"FizzBuzz\";\n                case (0, _): \"Fizz\";\n                case (_, 0): \"Buzz\";\n                case (_, _): x.toString();\n                });\n            }\n        }\n    }\n"}
{"id": 28966, "name": "FizzBuzz", "source": "Translate Swift to Python: for i in 1...100 {\n    switch (i % 3, i % 5) {\n    case (0, 0):\n        print(\"FizzBuzz\")\n    case (0, _):\n        print(\"Fizz\")\n    case (_, 0):\n        print(\"Buzz\")\n    default:\n        print(i)\n    }\n}\n", "target": "for i in xrange(1, 101):\n    if i % 15 == 0:\n        print \"FizzBuzz\"\n    elif i % 3 == 0:\n        print \"Fizz\"\n    elif i % 5 == 0:\n        print \"Buzz\"\n    else:\n        print i\n"}
{"id": 29197, "name": "Monty Hall problem", "source": "Translate Swift to C#: import Foundation\n\nfunc montyHall(doors: Int = 3, guess: Int, switch: Bool) -> Bool {\n  guard doors > 2, guess > 0, guess <= doors else { fatalError() }\n\n  let winningDoor = Int.random(in: 1...doors)\n\n  return winningDoor == guess ? !`switch` : `switch`\n}\n\nvar switchResults = [Bool]()\n\nfor _ in 0..<1_000 {\n  let guess = Int.random(in: 1...3)\n  let wasRight = montyHall(guess: guess, switch: true)\n\n  switchResults.append(wasRight)\n}\n\nlet switchWins = switchResults.filter({ $0 }).count\n\nprint(\"Switching would've won \\((Double(switchWins) / Double(switchResults.count)) * 100)% of games\")\nprint(\"Not switching would've won \\(((Double(switchResults.count - switchWins)) / Double(switchResults.count)) * 100)% of games\")\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int switchWins = 0;\n        int stayWins = 0;\n\n        Random gen = new Random();\n\t\t    \n        for(int plays = 0; plays < 1000000; plays++ )\n        {\n            int[] doors = {0,0,0};\n\n            var winner = gen.Next(3);\n            doors[winner] = 1; \n                \n\t    int choice = gen.Next(3); \n\t    int shown; \n\t    do\n            {\n\t        shown = gen.Next(3);\n\t    }\n            while (doors[shown] == 1 || shown == choice); \n     \n\t    stayWins += doors[choice]; \n     \n            \n            switchWins += doors[3 - choice - shown];\n        }\n\n        Console.Out.WriteLine(\"Staying wins \" + stayWins + \" times.\");\n        Console.Out.WriteLine(\"Switching wins \" + switchWins + \" times.\");\n    }\n}\n"}
{"id": 29199, "name": "Monty Hall problem", "source": "Translate Swift to Java: import Foundation\n\nfunc montyHall(doors: Int = 3, guess: Int, switch: Bool) -> Bool {\n  guard doors > 2, guess > 0, guess <= doors else { fatalError() }\n\n  let winningDoor = Int.random(in: 1...doors)\n\n  return winningDoor == guess ? !`switch` : `switch`\n}\n\nvar switchResults = [Bool]()\n\nfor _ in 0..<1_000 {\n  let guess = Int.random(in: 1...3)\n  let wasRight = montyHall(guess: guess, switch: true)\n\n  switchResults.append(wasRight)\n}\n\nlet switchWins = switchResults.filter({ $0 }).count\n\nprint(\"Switching would've won \\((Double(switchWins) / Double(switchResults.count)) * 100)% of games\")\nprint(\"Not switching would've won \\(((Double(switchResults.count - switchWins)) / Double(switchResults.count)) * 100)% of games\")\n", "target": "import java.util.Random;\npublic class Monty{\n\tpublic static void main(String[] args){\n\t\tint switchWins = 0;\n\t\tint stayWins = 0;\n\t\tRandom gen = new Random();\n\t\tfor(int plays = 0;plays < 32768;plays++ ){\n\t\t\tint[] doors = {0,0,0};\n\t\t\tdoors[gen.nextInt(3)] = 1;\n\t\t\tint choice = gen.nextInt(3); \n\t\t\tint shown; \n\t\t\tdo{\n\t\t\t\tshown = gen.nextInt(3);\n\t\t\t\n\t\t\t}while(doors[shown] == 1 || shown == choice);\n\t\t\t\n\t\t\tstayWins += doors[choice];\n\t\t\t\n\t\t\t\n\t\t\tswitchWins += doors[3 - choice - shown];\n\t\t}\n\t\tSystem.out.println(\"Switching wins \" + switchWins + \" times.\");\n\t\tSystem.out.println(\"Staying wins \" + stayWins + \" times.\");\n\t}\n}\n"}
{"id": 29200, "name": "Monty Hall problem", "source": "Translate Swift to Python: import Foundation\n\nfunc montyHall(doors: Int = 3, guess: Int, switch: Bool) -> Bool {\n  guard doors > 2, guess > 0, guess <= doors else { fatalError() }\n\n  let winningDoor = Int.random(in: 1...doors)\n\n  return winningDoor == guess ? !`switch` : `switch`\n}\n\nvar switchResults = [Bool]()\n\nfor _ in 0..<1_000 {\n  let guess = Int.random(in: 1...3)\n  let wasRight = montyHall(guess: guess, switch: true)\n\n  switchResults.append(wasRight)\n}\n\nlet switchWins = switchResults.filter({ $0 }).count\n\nprint(\"Switching would've won \\((Double(switchWins) / Double(switchResults.count)) * 100)% of games\")\nprint(\"Not switching would've won \\(((Double(switchResults.count - switchWins)) / Double(switchResults.count)) * 100)% of games\")\n", "target": "\nfrom random import randrange\n\ndoors, iterations = 3,100000  \n\ndef monty_hall(choice, switch=False, doorCount=doors):\n  \n  door = [False]*doorCount\n  \n  door[randrange(doorCount)] = True\n\n  chosen = door[choice]\n\n  unpicked = door\n  del unpicked[choice]\n\n  \n  \n  \n  alternative = True in unpicked\n\n  if switch:\n    return alternative\n  else:\n    return chosen\n\nprint \"\\nMonty Hall problem simulation:\"\nprint doors, \"doors,\", iterations, \"iterations.\\n\"\n\nprint \"Not switching allows you to win\",\nprint sum(monty_hall(randrange(3), switch=False)\n          for x in range(iterations)),\nprint \"out of\", iterations, \"times.\"\nprint \"Switching allows you to win\",\nprint sum(monty_hall(randrange(3), switch=True)\n          for x in range(iterations)),\nprint \"out of\", iterations, \"times.\\n\"\n"}
{"id": 29360, "name": "Polymorphic copy", "source": "Translate Swift to C#: class T {\n  required init() { } \n  func identify() {\n    println(\"I am a genuine T\")\n  }\n  func copy() -> T {\n    let newObj : T = self.dynamicType() \n    \n    \n    \n    return newObj\n  }\n}\n\nclass S : T {\n  override func identify()  {\n    println(\"I am an S\")\n  }\n}\n\nlet original : T = S()\nlet another : T = original.copy()\nprintln(original === another) \nanother.identify() \n", "target": "using System;\n\nclass T\n{\n    public virtual string Name()\n    {\n        return \"T\";\n    }\n\n    public virtual T Clone()\n    {\n        return new T();\n    }\n}\n\nclass S : T\n{\n    public override string Name()\n    {\n        return \"S\";\n    }\n\n    public override T Clone()\n    {\n        return new S();\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        T original = new S();\n        T clone = original.Clone();\n\n        Console.WriteLine(original.Name());\n        Console.WriteLine(clone.Name());\n    }\n}\n"}
{"id": 29362, "name": "Polymorphic copy", "source": "Translate Swift to Java: class T {\n  required init() { } \n  func identify() {\n    println(\"I am a genuine T\")\n  }\n  func copy() -> T {\n    let newObj : T = self.dynamicType() \n    \n    \n    \n    return newObj\n  }\n}\n\nclass S : T {\n  override func identify()  {\n    println(\"I am an S\")\n  }\n}\n\nlet original : T = S()\nlet another : T = original.copy()\nprintln(original === another) \nanother.identify() \n", "target": "class T implements Cloneable {\n    public String name() { return \"T\"; }\n    public T copy() {\n        try {\n            return (T)super.clone();\n        } catch (CloneNotSupportedException e) {\n            return null;\n        }\n    }\n}\n\nclass S extends T {\n    public String name() { return \"S\"; }\n}\n\npublic class PolymorphicCopy {\n    public static T copier(T x) { return x.copy(); }\n    public static void main(String[] args) {\n        T obj1 = new T();\n        S obj2 = new S();\n        System.out.println(copier(obj1).name()); \n        System.out.println(copier(obj2).name()); \n    }\n}\n"}
{"id": 29363, "name": "Polymorphic copy", "source": "Translate Swift to Python: class T {\n  required init() { } \n  func identify() {\n    println(\"I am a genuine T\")\n  }\n  func copy() -> T {\n    let newObj : T = self.dynamicType() \n    \n    \n    \n    return newObj\n  }\n}\n\nclass S : T {\n  override func identify()  {\n    println(\"I am an S\")\n  }\n}\n\nlet original : T = S()\nlet another : T = original.copy()\nprintln(original === another) \nanother.identify() \n", "target": "import copy\n\nclass T:\n   def classname(self): \n      return self.__class__.__name__\n\n   def __init__(self):\n      self.myValue = \"I'm a T.\"\n\n   def speak(self):\n      print self.classname(), 'Hello', self.myValue\n\n   def clone(self):\n      return copy.copy(self)\n\nclass S1(T):\n   def speak(self):\n      print self.classname(),\"Meow\", self.myValue\n\nclass S2(T):\n   def speak(self):\n      print self.classname(),\"Woof\", self.myValue\n\n\nprint \"creating initial objects of types S1, S2, and T\"\na = S1()\na.myValue = 'Green'\na.speak()\n\nb = S2()\nb.myValue = 'Blue'\nb.speak()\n\nu = T()\nu.myValue = 'Purple'\nu.speak()\n\nprint \"Making copy of a as u, colors and types should match\"\nu = a.clone()\nu.speak()\na.speak()\nprint \"Assigning new color to u, A's color should be unchanged.\"\nu.myValue = \"Orange\"\nu.speak()\na.speak()\n\nprint \"Assigning u to reference same object as b, colors and types should match\"\nu = b\nu.speak()\nb.speak()\nprint \"Assigning new color to u. Since u,b references same object b's color changes as well\"\nu.myValue = \"Yellow\"\nu.speak()\nb.speak()\n"}
{"id": 29616, "name": "User input_Text", "source": "Translate Swift to C#: print(\"Enter a string: \", terminator: \"\")\nif let str = readLine() {\n  print(str)\n}\n", "target": "using System;\n\nnamespace C_Sharp_Console {\n\n    class example {\n\n        static void Main() {\n            string word;\n            int num;\n            \n            Console.Write(\"Enter an integer: \");\n            num = Console.Read();\n            Console.Write(\"Enter a String: \");\n            word = Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 29618, "name": "User input_Text", "source": "Translate Swift to Java: print(\"Enter a string: \", terminator: \"\")\nif let str = readLine() {\n  print(str)\n}\n", "target": "import java.util.Scanner;\n\npublic class GetInput {\n    public static void main(String[] args) throws Exception {\n        Scanner s = new Scanner(System.in);\n        System.out.print(\"Enter a string: \");\n        String str = s.nextLine();\n        System.out.print(\"Enter an integer: \");\n        int i = Integer.parseInt(s.next());\n    }\n}\n"}
{"id": 29619, "name": "User input_Text", "source": "Translate Swift to Python: print(\"Enter a string: \", terminator: \"\")\nif let str = readLine() {\n  print(str)\n}\n", "target": "   string = raw_input(\"Input a string: \")\n"}
{"id": 30658, "name": "Sorting algorithms_Sleep sort", "source": "Translate Swift to C#: import Foundation\n\nfor i in [5, 2, 4, 6, 1, 7, 20, 14] {\n    let time = dispatch_time(DISPATCH_TIME_NOW,\n        Int64(i * Int(NSEC_PER_SEC)))\n    \n    dispatch_after(time, dispatch_get_main_queue()) {\n        print(i)\n    }\n}\n\nCFRunLoopRun()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\n\nclass Program\n{\n    static void ThreadStart(object item)\n    {\n        Thread.Sleep(1000 * (int)item);\n        Console.WriteLine(item);\n    }\n\n    static void SleepSort(IEnumerable<int> items)\n    {\n        foreach (var item in items)\n        {\n            new Thread(ThreadStart).Start(item);\n        }\n    }\n\n    static void Main(string[] arguments)\n    {\n        SleepSort(arguments.Select(int.Parse));\n    }\n}\n"}
{"id": 30660, "name": "Sorting algorithms_Sleep sort", "source": "Translate Swift to Java: import Foundation\n\nfor i in [5, 2, 4, 6, 1, 7, 20, 14] {\n    let time = dispatch_time(DISPATCH_TIME_NOW,\n        Int64(i * Int(NSEC_PER_SEC)))\n    \n    dispatch_after(time, dispatch_get_main_queue()) {\n        print(i)\n    }\n}\n\nCFRunLoopRun()\n", "target": "import java.util.concurrent.CountDownLatch;\n\npublic class SleepSort {\n\tpublic static void sleepSortAndPrint(int[] nums) {\n\t\tfinal CountDownLatch doneSignal = new CountDownLatch(nums.length);\n\t\tfor (final int num : nums) {\n\t\t\tnew Thread(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tdoneSignal.countDown();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdoneSignal.await();\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tThread.sleep(num * 1000);\n\t\t\t\t\t\tSystem.out.println(num);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}).start();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tint[] nums = new int[args.length];\n\t\tfor (int i = 0; i < args.length; i++)\n\t\t\tnums[i] = Integer.parseInt(args[i]);\n\t\tsleepSortAndPrint(nums);\n\t}\n}\n"}
{"id": 30661, "name": "Sorting algorithms_Sleep sort", "source": "Translate Swift to Python: import Foundation\n\nfor i in [5, 2, 4, 6, 1, 7, 20, 14] {\n    let time = dispatch_time(DISPATCH_TIME_NOW,\n        Int64(i * Int(NSEC_PER_SEC)))\n    \n    dispatch_after(time, dispatch_get_main_queue()) {\n        print(i)\n    }\n}\n\nCFRunLoopRun()\n", "target": "from time import sleep\nfrom threading import Timer\n\ndef sleepsort(values):\n    sleepsort.result = []\n    def add1(x):\n        sleepsort.result.append(x)\n    mx = values[0]\n    for v in values:\n        if mx < v: mx = v\n        Timer(v, add1, [v]).start()\n    sleep(mx+1)\n    return sleepsort.result\n\nif __name__ == '__main__':\n    x = [3,2,4,7,3,6,9,1]\n    if sleepsort(x) == sorted(x):\n        print('sleep sort worked for:',x)\n    else:\n        print('sleep sort FAILED for:',x)\n"}
{"id": 31233, "name": "Sort numbers lexicographically", "source": "Translate Swift to C#: func lex(n: Int) -> [Int] {\n  return stride(from: 1, through: n, by: n.signum()).map({ String($0) }).sorted().compactMap(Int.init)\n}\n\nprint(\"13: \\(lex(n: 13))\")\nprint(\"21: \\(lex(n: 21))\")\nprint(\"-22: \\(lex(n: -22))\")\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    public static void Main() {\n        foreach (int n in new [] { 0, 5, 13, 21, -22 }) WriteLine($\"{n}: {string.Join(\", \", LexOrder(n))}\");\n    }\n\n    public static IEnumerable<int> LexOrder(int n) => (n < 1 ? Range(n, 2 - n) : Range(1, n)).OrderBy(i => i.ToString());\n}\n"}
{"id": 31235, "name": "Sort numbers lexicographically", "source": "Translate Swift to Java: func lex(n: Int) -> [Int] {\n  return stride(from: 1, through: n, by: n.signum()).map({ String($0) }).sorted().compactMap(Int.init)\n}\n\nprint(\"13: \\(lex(n: 13))\")\nprint(\"21: \\(lex(n: 21))\")\nprint(\"-22: \\(lex(n: -22))\")\n", "target": "import java.util.List;\nimport java.util.stream.*;\n\npublic class LexicographicalNumbers {\n\n    static List<Integer> lexOrder(int n) {\n        int first = 1, last = n;\n        if (n < 1) {\n            first = n;\n            last = 1;\n        }\n        return IntStream.rangeClosed(first, last)\n                        .mapToObj(Integer::toString)\n                        .sorted()\n                        .map(Integer::valueOf)\n                        .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"In lexicographical order:\\n\");\n        int[] ints = {0, 5, 13, 21, -22};\n        for (int n : ints) {\n           System.out.printf(\"%3d: %s\\n\", n, lexOrder(n));\n        }\n    }\n}\n"}
{"id": 31236, "name": "Sort numbers lexicographically", "source": "Translate Swift to Python: func lex(n: Int) -> [Int] {\n  return stride(from: 1, through: n, by: n.signum()).map({ String($0) }).sorted().compactMap(Int.init)\n}\n\nprint(\"13: \\(lex(n: 13))\")\nprint(\"21: \\(lex(n: 21))\")\nprint(\"-22: \\(lex(n: -22))\")\n", "target": "n=13\nprint(sorted(range(1,n+1), key=str))\n"}
{"id": 31566, "name": "Remove vowels from a string", "source": "Translate Swift to C#: func isVowel(_ char: Character) -> Bool {\n    switch (char) {\n    case \"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\":\n        return true\n    default:\n        return false\n    }\n}\n\nfunc removeVowels(string: String) -> String {\n    return string.filter{!isVowel($0)}\n}\n\nlet str = \"The Swift Programming Language\"\nprint(str)\nprint(removeVowels(string: str))\n", "target": "static string remove_vowels(string value)\n{\n    var stripped = from c in value.ToCharArray()\n                   where !\"aeiouAEIOU\".Contains(c)\n                   select c;\n\n    return new string(stripped.ToArray());\n}\n\nstatic void test(string value)\n{\n    Console.WriteLine(\"Input:  \" + value);\n    Console.WriteLine(\"Output: \" + remove_vowels(value));\n}\n\nstatic void Main(string[] args)\n{\n    test(\"CSharp Programming Language\");\n}\n"}
{"id": 31567, "name": "Remove vowels from a string", "source": "Translate Swift to C#: func isVowel(_ char: Character) -> Bool {\n    switch (char) {\n    case \"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\":\n        return true\n    default:\n        return false\n    }\n}\n\nfunc removeVowels(string: String) -> String {\n    return string.filter{!isVowel($0)}\n}\n\nlet str = \"The Swift Programming Language\"\nprint(str)\nprint(removeVowels(string: str))\n", "target": "static string remove_vowels(string value)\n{\n    var stripped = from c in value.ToCharArray()\n                   where !\"aeiouAEIOU\".Contains(c)\n                   select c;\n\n    return new string(stripped.ToArray());\n}\n\nstatic void test(string value)\n{\n    Console.WriteLine(\"Input:  \" + value);\n    Console.WriteLine(\"Output: \" + remove_vowels(value));\n}\n\nstatic void Main(string[] args)\n{\n    test(\"CSharp Programming Language\");\n}\n"}
{"id": 31570, "name": "Remove vowels from a string", "source": "Translate Swift to Java: func isVowel(_ char: Character) -> Bool {\n    switch (char) {\n    case \"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\":\n        return true\n    default:\n        return false\n    }\n}\n\nfunc removeVowels(string: String) -> String {\n    return string.filter{!isVowel($0)}\n}\n\nlet str = \"The Swift Programming Language\"\nprint(str)\nprint(removeVowels(string: str))\n", "target": "public static String removeVowelse(String str){\n    String re = \"\";\n    char c;\n    for(int x = 0; x<str.length(); x++){\n        c = str.charAt(x);\n        if(!(c=='a'||c=='e'||c=='i'||c=='o'||c=='u'))\n        re+=c;\n    }\n    return re;\n}\n"}
{"id": 31571, "name": "Remove vowels from a string", "source": "Translate Swift to Java: func isVowel(_ char: Character) -> Bool {\n    switch (char) {\n    case \"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\":\n        return true\n    default:\n        return false\n    }\n}\n\nfunc removeVowels(string: String) -> String {\n    return string.filter{!isVowel($0)}\n}\n\nlet str = \"The Swift Programming Language\"\nprint(str)\nprint(removeVowels(string: str))\n", "target": "public static String removeVowelse(String str){\n    String re = \"\";\n    char c;\n    for(int x = 0; x<str.length(); x++){\n        c = str.charAt(x);\n        if(!(c=='a'||c=='e'||c=='i'||c=='o'||c=='u'))\n        re+=c;\n    }\n    return re;\n}\n"}
{"id": 31572, "name": "Remove vowels from a string", "source": "Translate Swift to Python: func isVowel(_ char: Character) -> Bool {\n    switch (char) {\n    case \"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\":\n        return true\n    default:\n        return false\n    }\n}\n\nfunc removeVowels(string: String) -> String {\n    return string.filter{!isVowel($0)}\n}\n\nlet str = \"The Swift Programming Language\"\nprint(str)\nprint(removeVowels(string: str))\n", "target": "\n\n\n\ndef exceptGlyphs(exclusions):\n    \n    def go(s):\n        return ''.join(\n            c for c in s if c not in exclusions\n        )\n    return go\n\n\n\n\ndef main():\n    \n\n    txt = \n\n    print(\n        exceptGlyphs('eau')(txt)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 31573, "name": "Remove vowels from a string", "source": "Translate Swift to Python: func isVowel(_ char: Character) -> Bool {\n    switch (char) {\n    case \"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\":\n        return true\n    default:\n        return false\n    }\n}\n\nfunc removeVowels(string: String) -> String {\n    return string.filter{!isVowel($0)}\n}\n\nlet str = \"The Swift Programming Language\"\nprint(str)\nprint(removeVowels(string: str))\n", "target": "\n\n\n\ndef exceptGlyphs(exclusions):\n    \n    def go(s):\n        return ''.join(\n            c for c in s if c not in exclusions\n        )\n    return go\n\n\n\n\ndef main():\n    \n\n    txt = \n\n    print(\n        exceptGlyphs('eau')(txt)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 31801, "name": "Forward difference", "source": "Translate Swift to C#: func forwardsDifference<T: SignedNumeric>(of arr: [T]) -> [T] {\n  return zip(arr.dropFirst(), arr).map({ $0.0 - $0.1 })\n}\n\nfunc nthForwardsDifference<T: SignedNumeric>(of arr: [T], n: Int) -> [T] {\n  assert(n >= 0)\n\n  switch (arr, n) {\n  case ([], _):\n    return []\n  case let (arr, 0):\n    return arr\n  case let (arr, i):\n    return nthForwardsDifference(of: forwardsDifference(of: arr), n: i - 1)\n  }\n}\n\nfor diff in (0...9).map({ nthForwardsDifference(of: [90, 47, 58, 29, 22, 32, 55, 5, 55, 73], n: $0) }) {\n  print(diff)\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static IEnumerable<int> ForwardDifference(IEnumerable<int> sequence, uint order = 1u)\n    {\n        switch (order)\n        {\n            case 0u:\n                return sequence;\n            case 1u:\n                return sequence.Skip(1).Zip(sequence, (next, current) => next - current);\n            default:\n                return ForwardDifference(ForwardDifference(sequence), order - 1u);\n        }\n    }\n\n    static void Main()\n    {\n        IEnumerable<int> sequence = new[] { 90, 47, 58, 29, 22, 32, 55, 5, 55, 73 };\n        do\n        {\n            Console.WriteLine(string.Join(\", \", sequence));\n        } while ((sequence = ForwardDifference(sequence)).Any());\n    }\n}\n"}
{"id": 31803, "name": "Forward difference", "source": "Translate Swift to Java: func forwardsDifference<T: SignedNumeric>(of arr: [T]) -> [T] {\n  return zip(arr.dropFirst(), arr).map({ $0.0 - $0.1 })\n}\n\nfunc nthForwardsDifference<T: SignedNumeric>(of arr: [T], n: Int) -> [T] {\n  assert(n >= 0)\n\n  switch (arr, n) {\n  case ([], _):\n    return []\n  case let (arr, 0):\n    return arr\n  case let (arr, i):\n    return nthForwardsDifference(of: forwardsDifference(of: arr), n: i - 1)\n  }\n}\n\nfor diff in (0...9).map({ nthForwardsDifference(of: [90, 47, 58, 29, 22, 32, 55, 5, 55, 73], n: $0) }) {\n  print(diff)\n}\n", "target": "import java.util.Arrays;\npublic class FD {\n    public static void main(String args[]) {\n        double[] a = {90, 47, 58, 29, 22, 32, 55, 5, 55, 73};\n        System.out.println(Arrays.toString(dif(a, 1)));\n        System.out.println(Arrays.toString(dif(a, 2)));\n        System.out.println(Arrays.toString(dif(a, 9)));\n        System.out.println(Arrays.toString(dif(a, 10)));      \n        System.out.println(Arrays.toString(dif(a, 11)));\n        System.out.println(Arrays.toString(dif(a, -1)));\n        System.out.println(Arrays.toString(dif(a, 0)));\n    }\n\n    public static double[] dif(double[] a, int n) {\n        if (n < 0)\n            return null; \n\n        for (int i = 0; i < n && a.length > 0; i++) {\n            double[] b = new double[a.length - 1];\n            for (int j = 0; j < b.length; j++){\n                b[j] = a[j+1] - a[j];\n            }\n            a = b; \n        }\n        return a;\n    }\n}\n"}
{"id": 31804, "name": "Forward difference", "source": "Translate Swift to Python: func forwardsDifference<T: SignedNumeric>(of arr: [T]) -> [T] {\n  return zip(arr.dropFirst(), arr).map({ $0.0 - $0.1 })\n}\n\nfunc nthForwardsDifference<T: SignedNumeric>(of arr: [T], n: Int) -> [T] {\n  assert(n >= 0)\n\n  switch (arr, n) {\n  case ([], _):\n    return []\n  case let (arr, 0):\n    return arr\n  case let (arr, i):\n    return nthForwardsDifference(of: forwardsDifference(of: arr), n: i - 1)\n  }\n}\n\nfor diff in (0...9).map({ nthForwardsDifference(of: [90, 47, 58, 29, 22, 32, 55, 5, 55, 73], n: $0) }) {\n  print(diff)\n}\n", "target": ">>> dif = lambda s: [x-s[i] for i,x in enumerate(s[1:])]\n>>> \n>>> difn = lambda s, n: difn(dif(s), n-1) if n else s\n\n>>> s = [90, 47, 58, 29, 22, 32, 55, 5, 55, 73]\n>>> difn(s, 0)\n[90, 47, 58, 29, 22, 32, 55, 5, 55, 73]\n>>> difn(s, 1)\n[-43, 11, -29, -7, 10, 23, -50, 50, 18]\n>>> difn(s, 2)\n[54, -40, 22, 17, 13, -73, 100, -32]\n\n>>> from pprint import pprint\n>>> pprint( [difn(s, i) for i in xrange(10)] )\n[[90, 47, 58, 29, 22, 32, 55, 5, 55, 73],\n [-43, 11, -29, -7, 10, 23, -50, 50, 18],\n [54, -40, 22, 17, 13, -73, 100, -32],\n [-94, 62, -5, -4, -86, 173, -132],\n [156, -67, 1, -82, 259, -305],\n [-223, 68, -83, 341, -564],\n [291, -151, 424, -905],\n [-442, 575, -1329],\n [1017, -1904],\n [-2921]]\n"}
{"id": 32064, "name": "Guess the number_With feedback", "source": "Translate Swift to C#: import Cocoa\n\nvar found = false\n\nlet randomNum = Int(arc4random_uniform(100) + 1)\n\nprintln(\"Guess a number between 1 and 100\\n\")\n\nwhile (!found) {\n    var fh = NSFileHandle.fileHandleWithStandardInput()\n    \n    println(\"Enter a number: \")\n    let data = fh.availableData\n    let str = NSString(data: data, encoding: NSUTF8StringEncoding)\n    if (str?.integerValue == randomNum) {\n        found = true\n        println(\"Well guessed!\")\n    } else if (str?.integerValue < randomNum) {\n        println(\"Good try but the number is more than that!\")\n    } else if (str?.integerValue > randomNum) {\n        println(\"Good try but the number is less than that!\")\n    }\n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        const int from = 1;\n        const int to = 10;\n\n        int randomNumber = new Random().Next(from, to);\n        int guessedNumber;\n\n        Console.Write(\"The number is between {0} and {1}. \", from, to);\n        while (true)\n        {\n            Console.Write(\"Make a guess: \");\n            if (int.TryParse(Console.ReadLine(), out guessedNumber))\n            {\n                if (guessedNumber == randomNumber)\n                {\n                    Console.WriteLine(\"You guessed the right number!\");\n                    break;\n                }\n                else\n                {\n                    Console.WriteLine(\"Your guess was too {0}.\", (guessedNumber > randomNumber) ? \"high\" : \"low\");\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"Input was not an integer.\");\n            }\n        }\n\n        Console.WriteLine();\n        Console.WriteLine(\"Press any key to exit.\");\n        Console.ReadKey();\n    }\n}\n"}
{"id": 32066, "name": "Guess the number_With feedback", "source": "Translate Swift to Java: import Cocoa\n\nvar found = false\n\nlet randomNum = Int(arc4random_uniform(100) + 1)\n\nprintln(\"Guess a number between 1 and 100\\n\")\n\nwhile (!found) {\n    var fh = NSFileHandle.fileHandleWithStandardInput()\n    \n    println(\"Enter a number: \")\n    let data = fh.availableData\n    let str = NSString(data: data, encoding: NSUTF8StringEncoding)\n    if (str?.integerValue == randomNum) {\n        found = true\n        println(\"Well guessed!\")\n    } else if (str?.integerValue < randomNum) {\n        println(\"Good try but the number is more than that!\")\n    } else if (str?.integerValue > randomNum) {\n        println(\"Good try but the number is less than that!\")\n    }\n}\n", "target": "import java.util.Random;\nimport java.util.Scanner;\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        Scanner scan = new Scanner(System.in);\n        Random random = new Random();\n        long from = 1;\n        long to = 100;\n        int randomNumber = random.nextInt(to - from + 1) + from;\n        int guessedNumber = 0;\n\n        System.out.printf(\"The number is between %d and %d.\\n\", from, to);\n\n        do\n        {\n            System.out.print(\"Guess what the number is: \");\n            guessedNumber = scan.nextInt();\n            if (guessedNumber > randomNumber)\n                System.out.println(\"Your guess is too high!\");\n            else if (guessedNumber < randomNumber)\n                System.out.println(\"Your guess is too low!\");\n            else\n                System.out.println(\"You got it!\");\n        } while (guessedNumber != randomNumber);\n    }\n}\n"}
{"id": 32067, "name": "Guess the number_With feedback", "source": "Translate Swift to Python: import Cocoa\n\nvar found = false\n\nlet randomNum = Int(arc4random_uniform(100) + 1)\n\nprintln(\"Guess a number between 1 and 100\\n\")\n\nwhile (!found) {\n    var fh = NSFileHandle.fileHandleWithStandardInput()\n    \n    println(\"Enter a number: \")\n    let data = fh.availableData\n    let str = NSString(data: data, encoding: NSUTF8StringEncoding)\n    if (str?.integerValue == randomNum) {\n        found = true\n        println(\"Well guessed!\")\n    } else if (str?.integerValue < randomNum) {\n        println(\"Good try but the number is more than that!\")\n    } else if (str?.integerValue > randomNum) {\n        println(\"Good try but the number is less than that!\")\n    }\n}\n", "target": "import random\n\ninclusive_range = (1, 100)\n\nprint(\"Guess my target number that is between %i and %i (inclusive).\\n\"\n      % inclusive_range)\ntarget = random.randint(*inclusive_range)\nanswer, i = None, 0\nwhile answer != target:\n    i += 1\n    txt = input(\"Your guess(%i): \" % i)\n    try:\n        answer = int(txt)\n    except ValueError:\n        print(\"  I don't understand your input of '%s'\u00a0?\" % txt)\n        continue\n    if answer < inclusive_range[0] or answer > inclusive_range[1]:\n        print(\"  Out of range!\")\n        continue\n    if answer == target:\n        print(\"  Ye-Haw!!\")\n        break\n    if answer < target: print(\"  Too low.\")\n    if answer > target: print(\"  Too high.\")\n\nprint(\"\\nThanks for playing.\")\n"}
{"id": 32306, "name": "Compound data type", "source": "Translate Swift to C#: \nstruct Point {\n    var x:Int\n    var y:Int\n}\n\n\ntypealias PointTuple = (Int, Int)\n\n\nclass PointClass {\n    var x:Int!\n    var y:Int!\n    \n    init(x:Int, y:Int) {\n        self.x = x\n        self.y = y\n    }\n}\n", "target": "struct Point\n{\n  public int x, y;\n  public Point(int x, int y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n"}
{"id": 32308, "name": "Compound data type", "source": "Translate Swift to Java: \nstruct Point {\n    var x:Int\n    var y:Int\n}\n\n\ntypealias PointTuple = (Int, Int)\n\n\nclass PointClass {\n    var x:Int!\n    var y:Int!\n    \n    init(x:Int, y:Int) {\n        self.x = x\n        self.y = y\n    }\n}\n", "target": "public class Point\n{\n  public int x, y;\n  public Point() { this(0); }\n  public Point(int x0) { this(x0,0); }\n  public Point(int x0, int y0) { x = x0; y = y0; }\n\n  public static void main(String args[])\n  {\n    Point point = new Point(1,2);\n    System.out.println(\"x = \" + point.x );\n    System.out.println(\"y = \" + point.y );\n  }\n}\n"}
{"id": 32309, "name": "Compound data type", "source": "Translate Swift to Python: \nstruct Point {\n    var x:Int\n    var y:Int\n}\n\n\ntypealias PointTuple = (Int, Int)\n\n\nclass PointClass {\n    var x:Int!\n    var y:Int!\n    \n    init(x:Int, y:Int) {\n        self.x = x\n        self.y = y\n    }\n}\n", "target": "X, Y = 0, 1\np = (3, 4)\np = [3, 4]\n\nprint p[X]\n"}
{"id": 32573, "name": "Sorting algorithms_Bogosort", "source": "Translate Swift to C#: import Darwin\n\nfunc shuffle<T>(inout array: [T]) {\n  for i in 1..<array.count {\n    let j = Int(arc4random_uniform(UInt32(i)))\n    (array[i], array[j]) = (array[j], array[i])\n  }\n}\n\nfunc issorted<T:Comparable>(ary: [T]) -> Bool {\n  for i in 0..<(ary.count-1) {\n    if ary[i] > ary[i+1] {\n      return false\n    }\n  }\n  return true\n}\n\nfunc bogosort<T:Comparable>(inout ary: [T]) {\n  while !issorted(ary) {\n    shuffle(&ary)\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.BogoSort\n{\n    public static class BogoSorter\n    {\n        public static void Sort<T>(List<T> list) where T:IComparable\n        {\n            while (!list.isSorted())\n            {\n                list.Shuffle();\n            }\n        }\n\n        private static bool isSorted<T>(this IList<T> list) where T:IComparable\n        {\n            if(list.Count<=1)\n                return true;\n            for (int i = 1 ; i < list.Count; i++)\n                if(list[i].CompareTo(list[i-1])<0) return false;\n            return true;\n        }\n\n        private static void Shuffle<T>(this IList<T> list)\n        {\n            Random rand = new Random();\n            for (int i = 0; i < list.Count; i++)\n            {\n                int swapIndex = rand.Next(list.Count);\n                T temp = list[swapIndex];\n                list[swapIndex] = list[i];\n                list[i] = temp;\n            }\n        }\n    }\n\n    class TestProgram\n    {\n        static void Main()\n        {\n            List<int> testList = new List<int> { 3, 4, 1, 8, 7, 4, -2 };\n            BogoSorter.Sort(testList);\n            foreach (int i in testList) Console.Write(i + \" \");\n        }\n\n    }\n}\n"}
{"id": 32575, "name": "Sorting algorithms_Bogosort", "source": "Translate Swift to Java: import Darwin\n\nfunc shuffle<T>(inout array: [T]) {\n  for i in 1..<array.count {\n    let j = Int(arc4random_uniform(UInt32(i)))\n    (array[i], array[j]) = (array[j], array[i])\n  }\n}\n\nfunc issorted<T:Comparable>(ary: [T]) -> Bool {\n  for i in 0..<(ary.count-1) {\n    if ary[i] > ary[i+1] {\n      return false\n    }\n  }\n  return true\n}\n\nfunc bogosort<T:Comparable>(inout ary: [T]) {\n  while !issorted(ary) {\n    shuffle(&ary)\n  }\n}\n", "target": "public class BogoSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tint[] arr={4,5,6,0,7,8,9,1,2,3};\n\t\t\n\t\tBogoSort now=new BogoSort();\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tnow.bogo(arr);\n\t\t\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(arr);\n\t}\n\tvoid bogo(int[] arr)\n\t{\n\t\t\n\t\tint shuffle=1;\n\t\tfor(;!isSorted(arr);shuffle++)\n\t\t\tshuffle(arr);\n\t\t\n\t\tSystem.out.println(\"This took \"+shuffle+\" shuffles.\");\n\t}\n\tvoid shuffle(int[] arr)\n\t{\n\t\t\n\t\tint i=arr.length-1;\n\t\twhile(i>0)\n\t\t\tswap(arr,i--,(int)(Math.random()*i));\n\t}\n\tvoid swap(int[] arr,int i,int j)\n\t{\n\t\tint temp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=temp;\n\t}\n\tboolean isSorted(int[] arr)\n\t{\n\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]<arr[i-1])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\n}\n"}
{"id": 32576, "name": "Sorting algorithms_Bogosort", "source": "Translate Swift to Python: import Darwin\n\nfunc shuffle<T>(inout array: [T]) {\n  for i in 1..<array.count {\n    let j = Int(arc4random_uniform(UInt32(i)))\n    (array[i], array[j]) = (array[j], array[i])\n  }\n}\n\nfunc issorted<T:Comparable>(ary: [T]) -> Bool {\n  for i in 0..<(ary.count-1) {\n    if ary[i] > ary[i+1] {\n      return false\n    }\n  }\n  return true\n}\n\nfunc bogosort<T:Comparable>(inout ary: [T]) {\n  while !issorted(ary) {\n    shuffle(&ary)\n  }\n}\n", "target": "import random\n\ndef bogosort(l):\n    while not in_order(l):\n        random.shuffle(l)\n    return l\n\ndef in_order(l):\n    if not l:\n        return True\n    last = l[0]\n    for x in l[1:]:\n        if x < last:\n            return False\n        last = x\n    return True\n"}
{"id": 32843, "name": "Cumulative standard deviation", "source": "Translate Swift to C#: import Darwin\nclass stdDev{\n    \n    var n:Double = 0.0\n    var sum:Double = 0.0\n    var sum2:Double = 0.0\n    \n    init(){\n        \n        let testData:[Double] = [2,4,4,4,5,5,7,9];\n        for x in testData{\n            \n            var a:Double = calcSd(x)\n            println(\"value \\(Int(x)) SD = \\(a)\");\n        }\n        \n    }\n    \n    func calcSd(x:Double)->Double{\n        \n        n += 1\n        sum += x\n        sum2 += x*x\n        return sqrt( sum2 / n - sum*sum / n / n)\n    }\n    \n}\nvar aa = stdDev()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace standardDeviation\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<double> nums = new List<double> { 2, 4, 4, 4, 5, 5, 7, 9 };\n            for (int i = 1; i <= nums.Count; i++)            \n                Console.WriteLine(sdev(nums.GetRange(0, i)));\n        }\n\n        static double sdev(List<double> nums)\n        {\n            List<double> store = new List<double>();\n            foreach (double n in nums)\n                store.Add((n - nums.Average()) * (n - nums.Average()));           \n\n            return Math.Sqrt(store.Sum() / store.Count);\n        }\n    }\n}\n"}
{"id": 32845, "name": "Cumulative standard deviation", "source": "Translate Swift to Java: import Darwin\nclass stdDev{\n    \n    var n:Double = 0.0\n    var sum:Double = 0.0\n    var sum2:Double = 0.0\n    \n    init(){\n        \n        let testData:[Double] = [2,4,4,4,5,5,7,9];\n        for x in testData{\n            \n            var a:Double = calcSd(x)\n            println(\"value \\(Int(x)) SD = \\(a)\");\n        }\n        \n    }\n    \n    func calcSd(x:Double)->Double{\n        \n        n += 1\n        sum += x\n        sum2 += x*x\n        return sqrt( sum2 / n - sum*sum / n / n)\n    }\n    \n}\nvar aa = stdDev()\n", "target": "public class StdDev {\n    int n = 0;\n    double sum = 0;\n    double sum2 = 0;\n\n    public double sd(double x) {\n\tn++;\n\tsum += x;\n\tsum2 += x*x;\n\n\treturn Math.sqrt(sum2/n - sum*sum/n/n);\n    }\n\n    public static void main(String[] args) {\n        double[] testData = {2,4,4,4,5,5,7,9};\n        StdDev sd = new StdDev();\n\n        for (double x : testData) {\n            System.out.println(sd.sd(x));\n        }\n    }\n}\n"}
{"id": 32846, "name": "Cumulative standard deviation", "source": "Translate Swift to Python: import Darwin\nclass stdDev{\n    \n    var n:Double = 0.0\n    var sum:Double = 0.0\n    var sum2:Double = 0.0\n    \n    init(){\n        \n        let testData:[Double] = [2,4,4,4,5,5,7,9];\n        for x in testData{\n            \n            var a:Double = calcSd(x)\n            println(\"value \\(Int(x)) SD = \\(a)\");\n        }\n        \n    }\n    \n    func calcSd(x:Double)->Double{\n        \n        n += 1\n        sum += x\n        sum2 += x*x\n        return sqrt( sum2 / n - sum*sum / n / n)\n    }\n    \n}\nvar aa = stdDev()\n", "target": ">>> from math import sqrt\n>>> def sd(x):\n    sd.sum  += x\n    sd.sum2 += x*x\n    sd.n    += 1.0\n    sum, sum2, n = sd.sum, sd.sum2, sd.n\n    return sqrt(sum2/n - sum*sum/n/n)\n\n>>> sd.sum = sd.sum2 = sd.n = 0\n>>> for value in (2,4,4,4,5,5,7,9):\n    print (value, sd(value))\n\n    \n(2, 0.0)\n(4, 1.0)\n(4, 0.94280904158206258)\n(4, 0.8660254037844386)\n(5, 0.97979589711327075)\n(5, 1.0)\n(7, 1.3997084244475311)\n(9, 2.0)\n>>>\n"}
{"id": 33123, "name": "Palindrome detection", "source": "Translate Swift to C#: import Foundation\n\n\nextension String {\n    subscript (i: Int) -> String {\n        return String(Array(self)[i])\n    }\n}\n\nfunc isPalindrome(str:String) -> Bool {\n    if (count(str) == 0 || count(str) == 1) {\n        return true\n    }\n    let removeRange = Range<String.Index>(start: advance(str.startIndex, 1), end: advance(str.endIndex, -1))\n    if (str[0] == str[count(str) - 1]) {\n        return isPalindrome(str.substringWithRange(removeRange))\n    }\n    return false\n}\n", "target": "using System;\n\nclass Program\n{\n    static string Reverse(string value)\n    {\n        char[] chars = value.ToCharArray();\n        Array.Reverse(chars);\n        return new string(chars);\n    }\n\n    static bool IsPalindrome(string value)\n    {\n        return value == Reverse(value);\n    }\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(IsPalindrome(\"ingirumimusnocteetconsumimurigni\"));\n    }\n}\n"}
{"id": 33125, "name": "Palindrome detection", "source": "Translate Swift to Java: import Foundation\n\n\nextension String {\n    subscript (i: Int) -> String {\n        return String(Array(self)[i])\n    }\n}\n\nfunc isPalindrome(str:String) -> Bool {\n    if (count(str) == 0 || count(str) == 1) {\n        return true\n    }\n    let removeRange = Range<String.Index>(start: advance(str.startIndex, 1), end: advance(str.endIndex, -1))\n    if (str[0] == str[count(str) - 1]) {\n        return isPalindrome(str.substringWithRange(removeRange))\n    }\n    return false\n}\n", "target": "public static boolean pali(String testMe){\n\tStringBuilder sb = new StringBuilder(testMe);\n\treturn testMe.equals(sb.reverse().toString());\n}\n"}
{"id": 33126, "name": "Palindrome detection", "source": "Translate Swift to Python: import Foundation\n\n\nextension String {\n    subscript (i: Int) -> String {\n        return String(Array(self)[i])\n    }\n}\n\nfunc isPalindrome(str:String) -> Bool {\n    if (count(str) == 0 || count(str) == 1) {\n        return true\n    }\n    let removeRange = Range<String.Index>(start: advance(str.startIndex, 1), end: advance(str.endIndex, -1))\n    if (str[0] == str[count(str) - 1]) {\n        return isPalindrome(str.substringWithRange(removeRange))\n    }\n    return false\n}\n", "target": "def is_palindrome(s):\n  return s == s[::-1]\n"}
{"id": 33402, "name": "Loop over multiple arrays simultaneously", "source": "Translate Swift to C#: let a1 = [\"a\", \"b\", \"c\"]\nlet a2 = [\"A\", \"B\", \"C\"]\nlet a3 = [1, 2, 3]\n\nfor i in 0 ..< a1.count {\n    println(\"\\(a1[i])\\(a2[i])\\(a3[i])\")\n}\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        char[] a = { 'a', 'b', 'c' };\n        char[] b = { 'A', 'B', 'C' };\n        int[] c = { 1, 2, 3 };\n        int min = Math.Min(a.Length, b.Length);\n        min = Math.Min(min, c.Length);\n        for (int i = 0; i < min; i++)\n            Console.WriteLine(\"{0}{1}{2}\", a[i], b[i], c[i]);\n    }             \n}\n"}
{"id": 33404, "name": "Loop over multiple arrays simultaneously", "source": "Translate Swift to Java: let a1 = [\"a\", \"b\", \"c\"]\nlet a2 = [\"A\", \"B\", \"C\"]\nlet a3 = [1, 2, 3]\n\nfor i in 0 ..< a1.count {\n    println(\"\\(a1[i])\\(a2[i])\\(a3[i])\")\n}\n", "target": "module LoopOverMultipleArrays\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Char[]   chars   = ['a', 'b', 'c'];\n        String[] strings = [\"A\", \"B\", \"C\"];\n        Int[]    ints    = [ 1,   2,   3 ];\n\n        console.print(\"Using array indexing:\");\n        for (Int i = 0, Int longest = chars.size.maxOf(strings.size.maxOf(ints.size)); i < longest; ++i)\n            {\n            console.print($|{i < chars.size   ? chars[i].toString() : \"\"}\\\n                           |{i < strings.size ? strings[i]          : \"\"}\\\n                           |{i < ints.size    ? ints[i].toString()  : \"\"}\n                         );\n            }\n\n        console.print(\"\\nUsing array iterators:\");\n        val charIter   = chars.iterator();\n        val stringIter = strings.iterator();\n        val intIter    = ints.iterator();\n        while (True)\n            {\n            StringBuffer buf = new StringBuffer();\n            if (Char ch := charIter.next())\n                {\n                buf.add(ch);\n                }\n            if (String s := stringIter.next())\n                {\n                s.appendTo(buf);\n                }\n            if (Int n := intIter.next())\n                {\n                n.appendTo(buf);\n                }\n            if (buf.size == 0)\n                {\n                break;\n                }\n            console.print(buf);\n            }\n        }\n    }\n"}
{"id": 33405, "name": "Loop over multiple arrays simultaneously", "source": "Translate Swift to Python: let a1 = [\"a\", \"b\", \"c\"]\nlet a2 = [\"A\", \"B\", \"C\"]\nlet a3 = [1, 2, 3]\n\nfor i in 0 ..< a1.count {\n    println(\"\\(a1[i])\\(a2[i])\\(a3[i])\")\n}\n", "target": ">>> print ( '\\n'.join(''.join(x) for x in \nzip('abc', 'ABC', '123')) )\naA1\nbB2\ncC3\n>>>\n"}
{"id": 33653, "name": "Sorting algorithms_Cocktail sort", "source": "Translate Swift to C#: extension Collection where Element: Comparable {\n  public func cocktailSorted() -> [Element] {\n    var swapped = false\n    var ret = Array(self)\n\n    guard count > 1 else {\n      return ret\n    }\n    \n    repeat {\n      for i in 0...ret.count-2 where ret[i] > ret[i + 1] {\n        (ret[i], ret[i + 1]) = (ret[i + 1], ret[i])\n        swapped = true\n      }\n\n      guard swapped else { \n        break \n      }\n\n      swapped = false\n\n      for i in stride(from: ret.count - 2, through: 0, by: -1) where ret[i] > ret[i + 1] {\n        (ret[i], ret[i + 1]) = (ret[i + 1], ret[i])\n        swapped = true\n      }\n    } while swapped\n\n    return ret\n  }\n}\n\nlet arr = (1...10).shuffled()\n\nprint(\"Before: \\(arr)\")\nprint(\"Cocktail sort: \\(arr.cocktailSorted())\")\n", "target": "public static void cocktailSort(int[] A)\n    {\n        bool swapped;\n        do\n        {\n            swapped = false;\n            for (int i = 0; i <= A.Length - 2; i++)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    \n                    int temp = A[i];\n                    A[i] = A[i + 1];\n                    A[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            if (!swapped)\n            {\n                \n                break;\n            }\n            swapped = false;\n            for (int i = A.Length - 2; i >= 0; i--)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    int temp = A[i];\n                    A[i] = A[i + 1];\n                    A[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            \n        } while (swapped);\n    }\n"}
{"id": 33655, "name": "Sorting algorithms_Cocktail sort", "source": "Translate Swift to Java: extension Collection where Element: Comparable {\n  public func cocktailSorted() -> [Element] {\n    var swapped = false\n    var ret = Array(self)\n\n    guard count > 1 else {\n      return ret\n    }\n    \n    repeat {\n      for i in 0...ret.count-2 where ret[i] > ret[i + 1] {\n        (ret[i], ret[i + 1]) = (ret[i + 1], ret[i])\n        swapped = true\n      }\n\n      guard swapped else { \n        break \n      }\n\n      swapped = false\n\n      for i in stride(from: ret.count - 2, through: 0, by: -1) where ret[i] > ret[i + 1] {\n        (ret[i], ret[i + 1]) = (ret[i + 1], ret[i])\n        swapped = true\n      }\n    } while swapped\n\n    return ret\n  }\n}\n\nlet arr = (1...10).shuffled()\n\nprint(\"Before: \\(arr)\")\nprint(\"Cocktail sort: \\(arr.cocktailSorted())\")\n", "target": "public static void cocktailSort( int[] A ){\n\tboolean swapped;\n\tdo {\n\t\tswapped = false;\n\t\tfor (int i =0; i<=  A.length  - 2;i++) {\n\t\t\tif (A[ i ] > A[ i + 1 ]) {\n\t\t\t\t\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i+1];\n\t\t\t\tA[i+1]=temp;\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!swapped) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tswapped = false;\n\t\tfor (int i= A.length - 2;i>=0;i--) {\n\t\t\tif (A[ i ] > A[ i + 1 ]) {\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i+1];\n\t\t\t\tA[i+1]=temp;\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\t\t\n\t} while (swapped);\n}\n"}
{"id": 33656, "name": "Sorting algorithms_Cocktail sort", "source": "Translate Swift to Python: extension Collection where Element: Comparable {\n  public func cocktailSorted() -> [Element] {\n    var swapped = false\n    var ret = Array(self)\n\n    guard count > 1 else {\n      return ret\n    }\n    \n    repeat {\n      for i in 0...ret.count-2 where ret[i] > ret[i + 1] {\n        (ret[i], ret[i + 1]) = (ret[i + 1], ret[i])\n        swapped = true\n      }\n\n      guard swapped else { \n        break \n      }\n\n      swapped = false\n\n      for i in stride(from: ret.count - 2, through: 0, by: -1) where ret[i] > ret[i + 1] {\n        (ret[i], ret[i + 1]) = (ret[i + 1], ret[i])\n        swapped = true\n      }\n    } while swapped\n\n    return ret\n  }\n}\n\nlet arr = (1...10).shuffled()\n\nprint(\"Before: \\(arr)\")\nprint(\"Cocktail sort: \\(arr.cocktailSorted())\")\n", "target": "def cocktailSort(A):\n    up = range(len(A)-1)\n    while True:\n        for indices in (up, reversed(up)):\n            swapped = False\n            for i in indices:\n                if A[i] > A[i+1]:  \n                    A[i], A[i+1] =  A[i+1], A[i]\n                    swapped = True\n            if not swapped:\n                return\n"}
{"id": 34534, "name": "Heronian triangles", "source": "Translate Swift to C#: import Foundation\n\ntypealias PrimitiveHeronianTriangle = (s1:Int, s2:Int, s3:Int, p:Int, a:Int)\n\nfunc heronianArea(side1 s1:Int, side2 s2:Int, side3 s3:Int) -> Int? {\n    let d1 = Double(s1)\n    let d2 = Double(s2)\n    let d3 = Double(s3)\n    \n    let s = (d1 + d2 + d3) / 2.0\n    let a = sqrt(s * (s - d1) * (s - d2) * (s - d3))\n    \n    if a % 1 != 0 || a <= 0 {\n        return nil\n    } else {\n        return Int(a)\n    }\n}\n\nfunc gcd(a:Int, b:Int) -> Int {\n    if b != 0 {\n        return gcd(b, a % b)\n    } else {\n        return abs(a)\n    }\n}\n\nvar triangles = [PrimitiveHeronianTriangle]()\n\nfor s1 in 1...200 {\n    for s2 in 1...s1 {\n        for s3 in 1...s2 {\n            if gcd(s1, gcd(s2, s3)) == 1, let a = heronianArea(side1: s1, side2: s2, side3: s3) {\n                triangles.append((s3, s2, s1, s1 + s2 + s3, a))\n            }\n        }\n    }\n}\n\nsort(&triangles) {t1, t2 in\n    if t1.a < t2.a || t1.a == t2.a && t1.p < t2.p {\n        return true\n    } else {\n        return false\n    }\n}\n\nprintln(\"Number of primitive Heronian triangles with sides up to 200: \\(triangles.count)\\n\")\nprintln(\"First ten sorted by area, then perimeter, then maximum side:\\n\")\nprintln(\"Sides\\t\\t\\tPerimeter\\tArea\")\n\nfor t in triangles[0...9] {\n    println(\"\\(t.s1)\\t\\(t.s2)\\t\\(t.s3)\\t\\t\\(t.p)\\t\\t\\(t.a)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace heron\n{\n    class Program{\n        static void Main(string[] args){           \n            List<int[]> list = new List<int[]>();\n            for (int c = 1; c <= 200; c++)\n                for (int b = 1; b <= c; b++)\n                    for (int a = 1; a <= b; a++)\n                        if (gcd(a, gcd(b, c)) == 1 && isHeron(heronArea(a, b, c)))\n                            list.Add(new int[] { a, b, c, a + b + c, (int)heronArea(a, b, c)});\n            sort(list);\n            Console.WriteLine(\"Number of primitive Heronian triangles with sides up to 200: \" + list.Count + \"\\n\\nFirst ten when ordered by increasing area, then perimeter,then maximum sides:\\nSides\\t\\t\\tPerimeter\\tArea\");\n            for(int i = 0; i < 10; i++)\n                Console.WriteLine(list[i][0] + \"\\t\" + list[i][1] + \"\\t\" + list[i][2] + \"\\t\" + list[i][3] + \"\\t\\t\" + list[i][4]);\n            Console.WriteLine(\"\\nPerimeter = 210\\nSides\\t\\t\\tPerimeter\\tArea\");\n            foreach (int[] i in list)\n                if (i[4] == 210)\n                    Console.WriteLine(i[0] + \"\\t\" + i[1] + \"\\t\" + i[2] + \"\\t\" + i[3] + \"\\t\\t\" + i[4]);     \n        }\n        static bool isHeron(double heronArea){\n            return heronArea % 1 == 0 && heronArea != 0;\n        }\n        static double heronArea(int a, int b, int c){\n            double s = (a + b + c) / 2d;\n            return Math.Sqrt(s * (s - a) * (s - b) * (s - c));\n        }\n        static int gcd(int a, int b){\n            int remainder = 1, dividend, divisor;\n            dividend = a > b ? a : b;\n            divisor = a > b ? b : a;\n            while (remainder != 0){\n                remainder = dividend % divisor;\n                if (remainder != 0){\n                    dividend = divisor;\n                    divisor = remainder;\n                }\n            }\n            return divisor;\n        }\n        static void sort(List<int[]> list){\n            int[] temp = new int[5];\n            bool changed = true;\n            while(changed){\n                changed = false;\n                for (int i = 1; i < list.Count; i++)\n                    if (list[i][4] < list[i - 1][4] || list[i][4] == list[i - 1][4] && list[i][3] < list[i - 1][3]){\n                        temp = list[i];\n                        list[i] = list[i - 1];\n                        list[i - 1] = temp;\n                        changed = true;\n                    }                \n            }\n        }\n    }\n}\n"}
{"id": 34535, "name": "Heronian triangles", "source": "Translate Swift to C#: import Foundation\n\ntypealias PrimitiveHeronianTriangle = (s1:Int, s2:Int, s3:Int, p:Int, a:Int)\n\nfunc heronianArea(side1 s1:Int, side2 s2:Int, side3 s3:Int) -> Int? {\n    let d1 = Double(s1)\n    let d2 = Double(s2)\n    let d3 = Double(s3)\n    \n    let s = (d1 + d2 + d3) / 2.0\n    let a = sqrt(s * (s - d1) * (s - d2) * (s - d3))\n    \n    if a % 1 != 0 || a <= 0 {\n        return nil\n    } else {\n        return Int(a)\n    }\n}\n\nfunc gcd(a:Int, b:Int) -> Int {\n    if b != 0 {\n        return gcd(b, a % b)\n    } else {\n        return abs(a)\n    }\n}\n\nvar triangles = [PrimitiveHeronianTriangle]()\n\nfor s1 in 1...200 {\n    for s2 in 1...s1 {\n        for s3 in 1...s2 {\n            if gcd(s1, gcd(s2, s3)) == 1, let a = heronianArea(side1: s1, side2: s2, side3: s3) {\n                triangles.append((s3, s2, s1, s1 + s2 + s3, a))\n            }\n        }\n    }\n}\n\nsort(&triangles) {t1, t2 in\n    if t1.a < t2.a || t1.a == t2.a && t1.p < t2.p {\n        return true\n    } else {\n        return false\n    }\n}\n\nprintln(\"Number of primitive Heronian triangles with sides up to 200: \\(triangles.count)\\n\")\nprintln(\"First ten sorted by area, then perimeter, then maximum side:\\n\")\nprintln(\"Sides\\t\\t\\tPerimeter\\tArea\")\n\nfor t in triangles[0...9] {\n    println(\"\\(t.s1)\\t\\(t.s2)\\t\\(t.s3)\\t\\t\\(t.p)\\t\\t\\(t.a)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace heron\n{\n    class Program{\n        static void Main(string[] args){           \n            List<int[]> list = new List<int[]>();\n            for (int c = 1; c <= 200; c++)\n                for (int b = 1; b <= c; b++)\n                    for (int a = 1; a <= b; a++)\n                        if (gcd(a, gcd(b, c)) == 1 && isHeron(heronArea(a, b, c)))\n                            list.Add(new int[] { a, b, c, a + b + c, (int)heronArea(a, b, c)});\n            sort(list);\n            Console.WriteLine(\"Number of primitive Heronian triangles with sides up to 200: \" + list.Count + \"\\n\\nFirst ten when ordered by increasing area, then perimeter,then maximum sides:\\nSides\\t\\t\\tPerimeter\\tArea\");\n            for(int i = 0; i < 10; i++)\n                Console.WriteLine(list[i][0] + \"\\t\" + list[i][1] + \"\\t\" + list[i][2] + \"\\t\" + list[i][3] + \"\\t\\t\" + list[i][4]);\n            Console.WriteLine(\"\\nPerimeter = 210\\nSides\\t\\t\\tPerimeter\\tArea\");\n            foreach (int[] i in list)\n                if (i[4] == 210)\n                    Console.WriteLine(i[0] + \"\\t\" + i[1] + \"\\t\" + i[2] + \"\\t\" + i[3] + \"\\t\\t\" + i[4]);     \n        }\n        static bool isHeron(double heronArea){\n            return heronArea % 1 == 0 && heronArea != 0;\n        }\n        static double heronArea(int a, int b, int c){\n            double s = (a + b + c) / 2d;\n            return Math.Sqrt(s * (s - a) * (s - b) * (s - c));\n        }\n        static int gcd(int a, int b){\n            int remainder = 1, dividend, divisor;\n            dividend = a > b ? a : b;\n            divisor = a > b ? b : a;\n            while (remainder != 0){\n                remainder = dividend % divisor;\n                if (remainder != 0){\n                    dividend = divisor;\n                    divisor = remainder;\n                }\n            }\n            return divisor;\n        }\n        static void sort(List<int[]> list){\n            int[] temp = new int[5];\n            bool changed = true;\n            while(changed){\n                changed = false;\n                for (int i = 1; i < list.Count; i++)\n                    if (list[i][4] < list[i - 1][4] || list[i][4] == list[i - 1][4] && list[i][3] < list[i - 1][3]){\n                        temp = list[i];\n                        list[i] = list[i - 1];\n                        list[i - 1] = temp;\n                        changed = true;\n                    }                \n            }\n        }\n    }\n}\n"}
{"id": 34538, "name": "Heronian triangles", "source": "Translate Swift to Java: import Foundation\n\ntypealias PrimitiveHeronianTriangle = (s1:Int, s2:Int, s3:Int, p:Int, a:Int)\n\nfunc heronianArea(side1 s1:Int, side2 s2:Int, side3 s3:Int) -> Int? {\n    let d1 = Double(s1)\n    let d2 = Double(s2)\n    let d3 = Double(s3)\n    \n    let s = (d1 + d2 + d3) / 2.0\n    let a = sqrt(s * (s - d1) * (s - d2) * (s - d3))\n    \n    if a % 1 != 0 || a <= 0 {\n        return nil\n    } else {\n        return Int(a)\n    }\n}\n\nfunc gcd(a:Int, b:Int) -> Int {\n    if b != 0 {\n        return gcd(b, a % b)\n    } else {\n        return abs(a)\n    }\n}\n\nvar triangles = [PrimitiveHeronianTriangle]()\n\nfor s1 in 1...200 {\n    for s2 in 1...s1 {\n        for s3 in 1...s2 {\n            if gcd(s1, gcd(s2, s3)) == 1, let a = heronianArea(side1: s1, side2: s2, side3: s3) {\n                triangles.append((s3, s2, s1, s1 + s2 + s3, a))\n            }\n        }\n    }\n}\n\nsort(&triangles) {t1, t2 in\n    if t1.a < t2.a || t1.a == t2.a && t1.p < t2.p {\n        return true\n    } else {\n        return false\n    }\n}\n\nprintln(\"Number of primitive Heronian triangles with sides up to 200: \\(triangles.count)\\n\")\nprintln(\"First ten sorted by area, then perimeter, then maximum side:\\n\")\nprintln(\"Sides\\t\\t\\tPerimeter\\tArea\")\n\nfor t in triangles[0...9] {\n    println(\"\\(t.s1)\\t\\(t.s2)\\t\\(t.s3)\\t\\t\\(t.p)\\t\\t\\(t.a)\")\n}\n", "target": "import java.util.ArrayList;\n\npublic class Heron {\n    public static void main(String[] args) {\n        ArrayList<int[]> list = new ArrayList<>();\n\n        for (int c = 1; c <= 200; c++) {\n            for (int b = 1; b <= c; b++) {\n                for (int a = 1; a <= b; a++) {\n\n                    if (gcd(gcd(a, b), c) == 1 && isHeron(heronArea(a, b, c))){\n                        int area = (int) heronArea(a, b, c);\n                        list.add(new int[]{a, b, c, a + b + c, area});\n                    }\n                }\n            }\n        }\n        sort(list);\n\n        System.out.printf(\"Number of primitive Heronian triangles with sides up \"\n                + \"to 200: %d\\n\\nFirst ten when ordered by increasing area, then\"\n                + \" perimeter:\\nSides       Perimeter   Area\", list.size());\n\n        for (int i = 0; i < 10; i++) {\n            System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                    list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                    list.get(i)[3], list.get(i)[4]);\n        }\n\n        System.out.printf(\"\\n\\nArea = 210\\nSides        Perimeter   Area\");\n        for (int i = 0; i < list.size(); i++) {\n            if (list.get(i)[4] == 210)\n                System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                        list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                        list.get(i)[3], list.get(i)[4]);\n        }\n    }\n\n    public static double heronArea(int a, int b, int c) {\n        double s = (a + b + c) / 2f;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    }\n\n    public static boolean isHeron(double h) {\n        return h % 1 == 0 && h > 0;\n    }\n\n    public static int gcd(int a, int b) {\n        int leftover = 1, dividend = a > b ? a : b, divisor = a > b ? b : a;\n        while (leftover != 0) {\n            leftover = dividend % divisor;\n            if (leftover > 0) {\n                dividend = divisor;\n                divisor = leftover;\n            }\n        }\n        return divisor;\n    }\n\n    public static void sort(ArrayList<int[]> list) {\n        boolean swapped = true;\n        int[] temp;\n        while (swapped) {\n            swapped = false;\n            for (int i = 1; i < list.size(); i++) {\n                if (list.get(i)[4] < list.get(i - 1)[4] ||\n                        list.get(i)[4] == list.get(i - 1)[4] &&\n                        list.get(i)[3] < list.get(i - 1)[3]) {\n                    temp = list.get(i);\n                    list.set(i, list.get(i - 1));\n                    list.set(i - 1, temp);\n                    swapped = true;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 34539, "name": "Heronian triangles", "source": "Translate Swift to Java: import Foundation\n\ntypealias PrimitiveHeronianTriangle = (s1:Int, s2:Int, s3:Int, p:Int, a:Int)\n\nfunc heronianArea(side1 s1:Int, side2 s2:Int, side3 s3:Int) -> Int? {\n    let d1 = Double(s1)\n    let d2 = Double(s2)\n    let d3 = Double(s3)\n    \n    let s = (d1 + d2 + d3) / 2.0\n    let a = sqrt(s * (s - d1) * (s - d2) * (s - d3))\n    \n    if a % 1 != 0 || a <= 0 {\n        return nil\n    } else {\n        return Int(a)\n    }\n}\n\nfunc gcd(a:Int, b:Int) -> Int {\n    if b != 0 {\n        return gcd(b, a % b)\n    } else {\n        return abs(a)\n    }\n}\n\nvar triangles = [PrimitiveHeronianTriangle]()\n\nfor s1 in 1...200 {\n    for s2 in 1...s1 {\n        for s3 in 1...s2 {\n            if gcd(s1, gcd(s2, s3)) == 1, let a = heronianArea(side1: s1, side2: s2, side3: s3) {\n                triangles.append((s3, s2, s1, s1 + s2 + s3, a))\n            }\n        }\n    }\n}\n\nsort(&triangles) {t1, t2 in\n    if t1.a < t2.a || t1.a == t2.a && t1.p < t2.p {\n        return true\n    } else {\n        return false\n    }\n}\n\nprintln(\"Number of primitive Heronian triangles with sides up to 200: \\(triangles.count)\\n\")\nprintln(\"First ten sorted by area, then perimeter, then maximum side:\\n\")\nprintln(\"Sides\\t\\t\\tPerimeter\\tArea\")\n\nfor t in triangles[0...9] {\n    println(\"\\(t.s1)\\t\\(t.s2)\\t\\(t.s3)\\t\\t\\(t.p)\\t\\t\\(t.a)\")\n}\n", "target": "import java.util.ArrayList;\n\npublic class Heron {\n    public static void main(String[] args) {\n        ArrayList<int[]> list = new ArrayList<>();\n\n        for (int c = 1; c <= 200; c++) {\n            for (int b = 1; b <= c; b++) {\n                for (int a = 1; a <= b; a++) {\n\n                    if (gcd(gcd(a, b), c) == 1 && isHeron(heronArea(a, b, c))){\n                        int area = (int) heronArea(a, b, c);\n                        list.add(new int[]{a, b, c, a + b + c, area});\n                    }\n                }\n            }\n        }\n        sort(list);\n\n        System.out.printf(\"Number of primitive Heronian triangles with sides up \"\n                + \"to 200: %d\\n\\nFirst ten when ordered by increasing area, then\"\n                + \" perimeter:\\nSides       Perimeter   Area\", list.size());\n\n        for (int i = 0; i < 10; i++) {\n            System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                    list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                    list.get(i)[3], list.get(i)[4]);\n        }\n\n        System.out.printf(\"\\n\\nArea = 210\\nSides        Perimeter   Area\");\n        for (int i = 0; i < list.size(); i++) {\n            if (list.get(i)[4] == 210)\n                System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                        list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                        list.get(i)[3], list.get(i)[4]);\n        }\n    }\n\n    public static double heronArea(int a, int b, int c) {\n        double s = (a + b + c) / 2f;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    }\n\n    public static boolean isHeron(double h) {\n        return h % 1 == 0 && h > 0;\n    }\n\n    public static int gcd(int a, int b) {\n        int leftover = 1, dividend = a > b ? a : b, divisor = a > b ? b : a;\n        while (leftover != 0) {\n            leftover = dividend % divisor;\n            if (leftover > 0) {\n                dividend = divisor;\n                divisor = leftover;\n            }\n        }\n        return divisor;\n    }\n\n    public static void sort(ArrayList<int[]> list) {\n        boolean swapped = true;\n        int[] temp;\n        while (swapped) {\n            swapped = false;\n            for (int i = 1; i < list.size(); i++) {\n                if (list.get(i)[4] < list.get(i - 1)[4] ||\n                        list.get(i)[4] == list.get(i - 1)[4] &&\n                        list.get(i)[3] < list.get(i - 1)[3]) {\n                    temp = list.get(i);\n                    list.set(i, list.get(i - 1));\n                    list.set(i - 1, temp);\n                    swapped = true;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 34540, "name": "Heronian triangles", "source": "Translate Swift to Python: import Foundation\n\ntypealias PrimitiveHeronianTriangle = (s1:Int, s2:Int, s3:Int, p:Int, a:Int)\n\nfunc heronianArea(side1 s1:Int, side2 s2:Int, side3 s3:Int) -> Int? {\n    let d1 = Double(s1)\n    let d2 = Double(s2)\n    let d3 = Double(s3)\n    \n    let s = (d1 + d2 + d3) / 2.0\n    let a = sqrt(s * (s - d1) * (s - d2) * (s - d3))\n    \n    if a % 1 != 0 || a <= 0 {\n        return nil\n    } else {\n        return Int(a)\n    }\n}\n\nfunc gcd(a:Int, b:Int) -> Int {\n    if b != 0 {\n        return gcd(b, a % b)\n    } else {\n        return abs(a)\n    }\n}\n\nvar triangles = [PrimitiveHeronianTriangle]()\n\nfor s1 in 1...200 {\n    for s2 in 1...s1 {\n        for s3 in 1...s2 {\n            if gcd(s1, gcd(s2, s3)) == 1, let a = heronianArea(side1: s1, side2: s2, side3: s3) {\n                triangles.append((s3, s2, s1, s1 + s2 + s3, a))\n            }\n        }\n    }\n}\n\nsort(&triangles) {t1, t2 in\n    if t1.a < t2.a || t1.a == t2.a && t1.p < t2.p {\n        return true\n    } else {\n        return false\n    }\n}\n\nprintln(\"Number of primitive Heronian triangles with sides up to 200: \\(triangles.count)\\n\")\nprintln(\"First ten sorted by area, then perimeter, then maximum side:\\n\")\nprintln(\"Sides\\t\\t\\tPerimeter\\tArea\")\n\nfor t in triangles[0...9] {\n    println(\"\\(t.s1)\\t\\(t.s2)\\t\\(t.s3)\\t\\t\\(t.p)\\t\\t\\(t.a)\")\n}\n", "target": "from __future__ import division, print_function\nfrom math import gcd, sqrt\n\n\ndef hero(a, b, c):\n    s = (a + b + c) / 2\n    a2 = s * (s - a) * (s - b) * (s - c)\n    return sqrt(a2) if a2 > 0 else 0\n\n\ndef is_heronian(a, b, c):\n    a = hero(a, b, c)\n    return a > 0 and a.is_integer()\n\n\ndef gcd3(x, y, z):\n    return gcd(gcd(x, y), z)\n\n\nif __name__ == '__main__':\n    MAXSIDE = 200\n\n    N = 1 + MAXSIDE\n    h = [(x, y, z)\n         for x in range(1, N)\n         for y in range(x, N)\n         for z in range(y, N) if (x + y > z) and\n         1 == gcd3(x, y, z) and\n         is_heronian(x, y, z)]\n\n    \n    h.sort(key=lambda x: (hero(*x), sum(x), x[::-1]))\n\n    print(\n        'Primitive Heronian triangles with sides up to %i:' % MAXSIDE, len(h)\n    )\n    print('\\nFirst ten when ordered by increasing area, then perimeter,',\n          'then maximum sides:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h[:10]))\n    print('\\nAll with area 210 subject to the previous ordering:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h\n                    if hero(*sides) == 210))\n"}
{"id": 34541, "name": "Heronian triangles", "source": "Translate Swift to Python: import Foundation\n\ntypealias PrimitiveHeronianTriangle = (s1:Int, s2:Int, s3:Int, p:Int, a:Int)\n\nfunc heronianArea(side1 s1:Int, side2 s2:Int, side3 s3:Int) -> Int? {\n    let d1 = Double(s1)\n    let d2 = Double(s2)\n    let d3 = Double(s3)\n    \n    let s = (d1 + d2 + d3) / 2.0\n    let a = sqrt(s * (s - d1) * (s - d2) * (s - d3))\n    \n    if a % 1 != 0 || a <= 0 {\n        return nil\n    } else {\n        return Int(a)\n    }\n}\n\nfunc gcd(a:Int, b:Int) -> Int {\n    if b != 0 {\n        return gcd(b, a % b)\n    } else {\n        return abs(a)\n    }\n}\n\nvar triangles = [PrimitiveHeronianTriangle]()\n\nfor s1 in 1...200 {\n    for s2 in 1...s1 {\n        for s3 in 1...s2 {\n            if gcd(s1, gcd(s2, s3)) == 1, let a = heronianArea(side1: s1, side2: s2, side3: s3) {\n                triangles.append((s3, s2, s1, s1 + s2 + s3, a))\n            }\n        }\n    }\n}\n\nsort(&triangles) {t1, t2 in\n    if t1.a < t2.a || t1.a == t2.a && t1.p < t2.p {\n        return true\n    } else {\n        return false\n    }\n}\n\nprintln(\"Number of primitive Heronian triangles with sides up to 200: \\(triangles.count)\\n\")\nprintln(\"First ten sorted by area, then perimeter, then maximum side:\\n\")\nprintln(\"Sides\\t\\t\\tPerimeter\\tArea\")\n\nfor t in triangles[0...9] {\n    println(\"\\(t.s1)\\t\\(t.s2)\\t\\(t.s3)\\t\\t\\(t.p)\\t\\t\\(t.a)\")\n}\n", "target": "from __future__ import division, print_function\nfrom math import gcd, sqrt\n\n\ndef hero(a, b, c):\n    s = (a + b + c) / 2\n    a2 = s * (s - a) * (s - b) * (s - c)\n    return sqrt(a2) if a2 > 0 else 0\n\n\ndef is_heronian(a, b, c):\n    a = hero(a, b, c)\n    return a > 0 and a.is_integer()\n\n\ndef gcd3(x, y, z):\n    return gcd(gcd(x, y), z)\n\n\nif __name__ == '__main__':\n    MAXSIDE = 200\n\n    N = 1 + MAXSIDE\n    h = [(x, y, z)\n         for x in range(1, N)\n         for y in range(x, N)\n         for z in range(y, N) if (x + y > z) and\n         1 == gcd3(x, y, z) and\n         is_heronian(x, y, z)]\n\n    \n    h.sort(key=lambda x: (hero(*x), sum(x), x[::-1]))\n\n    print(\n        'Primitive Heronian triangles with sides up to %i:' % MAXSIDE, len(h)\n    )\n    print('\\nFirst ten when ordered by increasing area, then perimeter,',\n          'then maximum sides:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h[:10]))\n    print('\\nAll with area 210 subject to the previous ordering:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h\n                    if hero(*sides) == 210))\n"}
{"id": 36209, "name": "Continued fraction", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\npublic struct CycledSequence<WrappedSequence: Sequence> {\n  private var seq: WrappedSequence\n  private var iter: WrappedSequence.Iterator\n\n  init(seq: WrappedSequence) {\n    self.seq = seq\n    self.iter = seq.makeIterator()\n  }\n}\n\nextension CycledSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> WrappedSequence.Element? {\n    if let ele = iter.next() {\n      return ele\n    } else {\n      iter = seq.makeIterator()\n\n      return iter.next()\n    }\n  }\n}\n\nextension Sequence {\n  public func cycled() -> CycledSequence<Self> {\n    return CycledSequence(seq: self)\n  }\n}\n\npublic struct ChainedSequence<Element> {\n  private var sequences: [AnySequence<Element>]\n  private var iter: AnyIterator<Element>\n  private var curSeq = 0\n\n  init(chain: ChainedSequence) {\n    self.sequences = chain.sequences\n    self.iter = chain.iter\n    self.curSeq = chain.curSeq\n  }\n\n  init<Seq: Sequence>(_ seq: Seq) where Seq.Element == Element {\n    sequences = [AnySequence(seq)]\n    iter = sequences[curSeq].makeIterator()\n  }\n\n  func chained<Seq: Sequence>(with seq: Seq) -> ChainedSequence where Seq.Element == Element {\n    var res = ChainedSequence(chain: self)\n\n    res.sequences.append(AnySequence(seq))\n\n    return res\n  }\n}\n\nextension ChainedSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> Element? {\n    if let el = iter.next() {\n      return el\n    }\n\n    curSeq += 1\n\n    guard curSeq != sequences.endIndex else {\n      return nil\n    }\n\n    iter = sequences[curSeq].makeIterator()\n\n    return iter.next()\n  }\n}\n\nextension Sequence {\n  public func chained<Seq: Sequence>(with other: Seq) -> ChainedSequence<Element> where Seq.Element == Element {\n    return ChainedSequence(self).chained(with: other)\n  }\n}\n\nfunc continuedFraction<T: Sequence, V: Sequence>(\n  _ seq1: T,\n  _ seq2: V,\n  iterations: Int = 1000\n) -> Double where T.Element: BinaryInteger, T.Element == V.Element {\n  return zip(seq1, seq2).prefix(iterations).reversed().reduce(0.0, { Double($1.0) + (Double($1.1) / $0) })\n}\n\nlet sqrtA = [1].chained(with: [2].cycled())\nlet sqrtB = [1].cycled()\n\nprint(\"\u221a2 \u2248 \\(continuedFraction(sqrtA, sqrtB))\")\n\nlet napierA = [2].chained(with: 1...)\nlet napierB = [1].chained(with: 1...)\n\nprint(\"e \u2248 \\(continuedFraction(napierA, napierB))\")\n\nlet piA = [3].chained(with: [6].cycled())\nlet piB = (1...).lazy.map({ (2 * $0 - 1).power(2) })\n\nprint(\"\u03c0 \u2248 \\(continuedFraction(piA, piB))\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ContinuedFraction {\n    class Program {\n        static double Calc(Func<int, int[]> f, int n) {\n            double temp = 0.0;\n            for (int ni = n; ni >= 1; ni--) {\n                int[] p = f(ni);\n                temp = p[1] / (p[0] + temp);\n            }\n            return f(0)[0] + temp;\n        }\n\n        static void Main(string[] args) {\n            List<Func<int, int[]>> fList = new List<Func<int, int[]>>();\n            fList.Add(n => new int[] { n > 0 ? 2 : 1, 1 });\n            fList.Add(n => new int[] { n > 0 ? n : 2, n > 1 ? (n - 1) : 1 });\n            fList.Add(n => new int[] { n > 0 ? 6 : 3, (int) Math.Pow(2 * n - 1, 2) });\n\n            foreach (var f in fList) {\n                Console.WriteLine(Calc(f, 200));\n            }\n        }\n    }\n}\n"}
{"id": 36210, "name": "Continued fraction", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\npublic struct CycledSequence<WrappedSequence: Sequence> {\n  private var seq: WrappedSequence\n  private var iter: WrappedSequence.Iterator\n\n  init(seq: WrappedSequence) {\n    self.seq = seq\n    self.iter = seq.makeIterator()\n  }\n}\n\nextension CycledSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> WrappedSequence.Element? {\n    if let ele = iter.next() {\n      return ele\n    } else {\n      iter = seq.makeIterator()\n\n      return iter.next()\n    }\n  }\n}\n\nextension Sequence {\n  public func cycled() -> CycledSequence<Self> {\n    return CycledSequence(seq: self)\n  }\n}\n\npublic struct ChainedSequence<Element> {\n  private var sequences: [AnySequence<Element>]\n  private var iter: AnyIterator<Element>\n  private var curSeq = 0\n\n  init(chain: ChainedSequence) {\n    self.sequences = chain.sequences\n    self.iter = chain.iter\n    self.curSeq = chain.curSeq\n  }\n\n  init<Seq: Sequence>(_ seq: Seq) where Seq.Element == Element {\n    sequences = [AnySequence(seq)]\n    iter = sequences[curSeq].makeIterator()\n  }\n\n  func chained<Seq: Sequence>(with seq: Seq) -> ChainedSequence where Seq.Element == Element {\n    var res = ChainedSequence(chain: self)\n\n    res.sequences.append(AnySequence(seq))\n\n    return res\n  }\n}\n\nextension ChainedSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> Element? {\n    if let el = iter.next() {\n      return el\n    }\n\n    curSeq += 1\n\n    guard curSeq != sequences.endIndex else {\n      return nil\n    }\n\n    iter = sequences[curSeq].makeIterator()\n\n    return iter.next()\n  }\n}\n\nextension Sequence {\n  public func chained<Seq: Sequence>(with other: Seq) -> ChainedSequence<Element> where Seq.Element == Element {\n    return ChainedSequence(self).chained(with: other)\n  }\n}\n\nfunc continuedFraction<T: Sequence, V: Sequence>(\n  _ seq1: T,\n  _ seq2: V,\n  iterations: Int = 1000\n) -> Double where T.Element: BinaryInteger, T.Element == V.Element {\n  return zip(seq1, seq2).prefix(iterations).reversed().reduce(0.0, { Double($1.0) + (Double($1.1) / $0) })\n}\n\nlet sqrtA = [1].chained(with: [2].cycled())\nlet sqrtB = [1].cycled()\n\nprint(\"\u221a2 \u2248 \\(continuedFraction(sqrtA, sqrtB))\")\n\nlet napierA = [2].chained(with: 1...)\nlet napierB = [1].chained(with: 1...)\n\nprint(\"e \u2248 \\(continuedFraction(napierA, napierB))\")\n\nlet piA = [3].chained(with: [6].cycled())\nlet piB = (1...).lazy.map({ (2 * $0 - 1).power(2) })\n\nprint(\"\u03c0 \u2248 \\(continuedFraction(piA, piB))\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ContinuedFraction {\n    class Program {\n        static double Calc(Func<int, int[]> f, int n) {\n            double temp = 0.0;\n            for (int ni = n; ni >= 1; ni--) {\n                int[] p = f(ni);\n                temp = p[1] / (p[0] + temp);\n            }\n            return f(0)[0] + temp;\n        }\n\n        static void Main(string[] args) {\n            List<Func<int, int[]>> fList = new List<Func<int, int[]>>();\n            fList.Add(n => new int[] { n > 0 ? 2 : 1, 1 });\n            fList.Add(n => new int[] { n > 0 ? n : 2, n > 1 ? (n - 1) : 1 });\n            fList.Add(n => new int[] { n > 0 ? 6 : 3, (int) Math.Pow(2 * n - 1, 2) });\n\n            foreach (var f in fList) {\n                Console.WriteLine(Calc(f, 200));\n            }\n        }\n    }\n}\n"}
{"id": 36213, "name": "Continued fraction", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\npublic struct CycledSequence<WrappedSequence: Sequence> {\n  private var seq: WrappedSequence\n  private var iter: WrappedSequence.Iterator\n\n  init(seq: WrappedSequence) {\n    self.seq = seq\n    self.iter = seq.makeIterator()\n  }\n}\n\nextension CycledSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> WrappedSequence.Element? {\n    if let ele = iter.next() {\n      return ele\n    } else {\n      iter = seq.makeIterator()\n\n      return iter.next()\n    }\n  }\n}\n\nextension Sequence {\n  public func cycled() -> CycledSequence<Self> {\n    return CycledSequence(seq: self)\n  }\n}\n\npublic struct ChainedSequence<Element> {\n  private var sequences: [AnySequence<Element>]\n  private var iter: AnyIterator<Element>\n  private var curSeq = 0\n\n  init(chain: ChainedSequence) {\n    self.sequences = chain.sequences\n    self.iter = chain.iter\n    self.curSeq = chain.curSeq\n  }\n\n  init<Seq: Sequence>(_ seq: Seq) where Seq.Element == Element {\n    sequences = [AnySequence(seq)]\n    iter = sequences[curSeq].makeIterator()\n  }\n\n  func chained<Seq: Sequence>(with seq: Seq) -> ChainedSequence where Seq.Element == Element {\n    var res = ChainedSequence(chain: self)\n\n    res.sequences.append(AnySequence(seq))\n\n    return res\n  }\n}\n\nextension ChainedSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> Element? {\n    if let el = iter.next() {\n      return el\n    }\n\n    curSeq += 1\n\n    guard curSeq != sequences.endIndex else {\n      return nil\n    }\n\n    iter = sequences[curSeq].makeIterator()\n\n    return iter.next()\n  }\n}\n\nextension Sequence {\n  public func chained<Seq: Sequence>(with other: Seq) -> ChainedSequence<Element> where Seq.Element == Element {\n    return ChainedSequence(self).chained(with: other)\n  }\n}\n\nfunc continuedFraction<T: Sequence, V: Sequence>(\n  _ seq1: T,\n  _ seq2: V,\n  iterations: Int = 1000\n) -> Double where T.Element: BinaryInteger, T.Element == V.Element {\n  return zip(seq1, seq2).prefix(iterations).reversed().reduce(0.0, { Double($1.0) + (Double($1.1) / $0) })\n}\n\nlet sqrtA = [1].chained(with: [2].cycled())\nlet sqrtB = [1].cycled()\n\nprint(\"\u221a2 \u2248 \\(continuedFraction(sqrtA, sqrtB))\")\n\nlet napierA = [2].chained(with: 1...)\nlet napierB = [1].chained(with: 1...)\n\nprint(\"e \u2248 \\(continuedFraction(napierA, napierB))\")\n\nlet piA = [3].chained(with: [6].cycled())\nlet piB = (1...).lazy.map({ (2 * $0 - 1).power(2) })\n\nprint(\"\u03c0 \u2248 \\(continuedFraction(piA, piB))\")\n", "target": "import static java.lang.Math.pow;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Test {\n    static double calc(Function<Integer, Integer[]> f, int n) {\n        double temp = 0;\n\n        for (int ni = n; ni >= 1; ni--) {\n            Integer[] p = f.apply(ni);\n            temp = p[1] / (double) (p[0] + temp);\n        }\n        return f.apply(0)[0] + temp;\n    }\n\n    public static void main(String[] args) {\n        List<Function<Integer, Integer[]>> fList = new ArrayList<>();\n        fList.add(n -> new Integer[]{n > 0 ? 2 : 1, 1});\n        fList.add(n -> new Integer[]{n > 0 ? n : 2, n > 1 ? (n - 1) : 1});\n        fList.add(n -> new Integer[]{n > 0 ? 6 : 3, (int) pow(2 * n - 1, 2)});\n\n        for (Function<Integer, Integer[]> f : fList)\n            System.out.println(calc(f, 200));\n    }\n}\n"}
{"id": 36214, "name": "Continued fraction", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\npublic struct CycledSequence<WrappedSequence: Sequence> {\n  private var seq: WrappedSequence\n  private var iter: WrappedSequence.Iterator\n\n  init(seq: WrappedSequence) {\n    self.seq = seq\n    self.iter = seq.makeIterator()\n  }\n}\n\nextension CycledSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> WrappedSequence.Element? {\n    if let ele = iter.next() {\n      return ele\n    } else {\n      iter = seq.makeIterator()\n\n      return iter.next()\n    }\n  }\n}\n\nextension Sequence {\n  public func cycled() -> CycledSequence<Self> {\n    return CycledSequence(seq: self)\n  }\n}\n\npublic struct ChainedSequence<Element> {\n  private var sequences: [AnySequence<Element>]\n  private var iter: AnyIterator<Element>\n  private var curSeq = 0\n\n  init(chain: ChainedSequence) {\n    self.sequences = chain.sequences\n    self.iter = chain.iter\n    self.curSeq = chain.curSeq\n  }\n\n  init<Seq: Sequence>(_ seq: Seq) where Seq.Element == Element {\n    sequences = [AnySequence(seq)]\n    iter = sequences[curSeq].makeIterator()\n  }\n\n  func chained<Seq: Sequence>(with seq: Seq) -> ChainedSequence where Seq.Element == Element {\n    var res = ChainedSequence(chain: self)\n\n    res.sequences.append(AnySequence(seq))\n\n    return res\n  }\n}\n\nextension ChainedSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> Element? {\n    if let el = iter.next() {\n      return el\n    }\n\n    curSeq += 1\n\n    guard curSeq != sequences.endIndex else {\n      return nil\n    }\n\n    iter = sequences[curSeq].makeIterator()\n\n    return iter.next()\n  }\n}\n\nextension Sequence {\n  public func chained<Seq: Sequence>(with other: Seq) -> ChainedSequence<Element> where Seq.Element == Element {\n    return ChainedSequence(self).chained(with: other)\n  }\n}\n\nfunc continuedFraction<T: Sequence, V: Sequence>(\n  _ seq1: T,\n  _ seq2: V,\n  iterations: Int = 1000\n) -> Double where T.Element: BinaryInteger, T.Element == V.Element {\n  return zip(seq1, seq2).prefix(iterations).reversed().reduce(0.0, { Double($1.0) + (Double($1.1) / $0) })\n}\n\nlet sqrtA = [1].chained(with: [2].cycled())\nlet sqrtB = [1].cycled()\n\nprint(\"\u221a2 \u2248 \\(continuedFraction(sqrtA, sqrtB))\")\n\nlet napierA = [2].chained(with: 1...)\nlet napierB = [1].chained(with: 1...)\n\nprint(\"e \u2248 \\(continuedFraction(napierA, napierB))\")\n\nlet piA = [3].chained(with: [6].cycled())\nlet piB = (1...).lazy.map({ (2 * $0 - 1).power(2) })\n\nprint(\"\u03c0 \u2248 \\(continuedFraction(piA, piB))\")\n", "target": "import static java.lang.Math.pow;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Test {\n    static double calc(Function<Integer, Integer[]> f, int n) {\n        double temp = 0;\n\n        for (int ni = n; ni >= 1; ni--) {\n            Integer[] p = f.apply(ni);\n            temp = p[1] / (double) (p[0] + temp);\n        }\n        return f.apply(0)[0] + temp;\n    }\n\n    public static void main(String[] args) {\n        List<Function<Integer, Integer[]>> fList = new ArrayList<>();\n        fList.add(n -> new Integer[]{n > 0 ? 2 : 1, 1});\n        fList.add(n -> new Integer[]{n > 0 ? n : 2, n > 1 ? (n - 1) : 1});\n        fList.add(n -> new Integer[]{n > 0 ? 6 : 3, (int) pow(2 * n - 1, 2)});\n\n        for (Function<Integer, Integer[]> f : fList)\n            System.out.println(calc(f, 200));\n    }\n}\n"}
{"id": 36215, "name": "Continued fraction", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\npublic struct CycledSequence<WrappedSequence: Sequence> {\n  private var seq: WrappedSequence\n  private var iter: WrappedSequence.Iterator\n\n  init(seq: WrappedSequence) {\n    self.seq = seq\n    self.iter = seq.makeIterator()\n  }\n}\n\nextension CycledSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> WrappedSequence.Element? {\n    if let ele = iter.next() {\n      return ele\n    } else {\n      iter = seq.makeIterator()\n\n      return iter.next()\n    }\n  }\n}\n\nextension Sequence {\n  public func cycled() -> CycledSequence<Self> {\n    return CycledSequence(seq: self)\n  }\n}\n\npublic struct ChainedSequence<Element> {\n  private var sequences: [AnySequence<Element>]\n  private var iter: AnyIterator<Element>\n  private var curSeq = 0\n\n  init(chain: ChainedSequence) {\n    self.sequences = chain.sequences\n    self.iter = chain.iter\n    self.curSeq = chain.curSeq\n  }\n\n  init<Seq: Sequence>(_ seq: Seq) where Seq.Element == Element {\n    sequences = [AnySequence(seq)]\n    iter = sequences[curSeq].makeIterator()\n  }\n\n  func chained<Seq: Sequence>(with seq: Seq) -> ChainedSequence where Seq.Element == Element {\n    var res = ChainedSequence(chain: self)\n\n    res.sequences.append(AnySequence(seq))\n\n    return res\n  }\n}\n\nextension ChainedSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> Element? {\n    if let el = iter.next() {\n      return el\n    }\n\n    curSeq += 1\n\n    guard curSeq != sequences.endIndex else {\n      return nil\n    }\n\n    iter = sequences[curSeq].makeIterator()\n\n    return iter.next()\n  }\n}\n\nextension Sequence {\n  public func chained<Seq: Sequence>(with other: Seq) -> ChainedSequence<Element> where Seq.Element == Element {\n    return ChainedSequence(self).chained(with: other)\n  }\n}\n\nfunc continuedFraction<T: Sequence, V: Sequence>(\n  _ seq1: T,\n  _ seq2: V,\n  iterations: Int = 1000\n) -> Double where T.Element: BinaryInteger, T.Element == V.Element {\n  return zip(seq1, seq2).prefix(iterations).reversed().reduce(0.0, { Double($1.0) + (Double($1.1) / $0) })\n}\n\nlet sqrtA = [1].chained(with: [2].cycled())\nlet sqrtB = [1].cycled()\n\nprint(\"\u221a2 \u2248 \\(continuedFraction(sqrtA, sqrtB))\")\n\nlet napierA = [2].chained(with: 1...)\nlet napierB = [1].chained(with: 1...)\n\nprint(\"e \u2248 \\(continuedFraction(napierA, napierB))\")\n\nlet piA = [3].chained(with: [6].cycled())\nlet piB = (1...).lazy.map({ (2 * $0 - 1).power(2) })\n\nprint(\"\u03c0 \u2248 \\(continuedFraction(piA, piB))\")\n", "target": "from fractions import Fraction\nimport itertools\ntry: zip = itertools.izip\nexcept: pass\n \n\ndef CF(a, b, t):\n  terms = list(itertools.islice(zip(a, b), t))\n  z = Fraction(1,1)\n  for a, b in reversed(terms):\n    z = a + b / z\n  return z\n \n\ndef pRes(x, d):\n  q, x = divmod(x, 1)\n  res = str(q)\n  res += \".\"\n  for i in range(d):\n    x *= 10\n    q, x = divmod(x, 1)\n    res += str(q)\n  return res\n \n\ndef sqrt2_a():\n  yield 1\n  for x in itertools.repeat(2):\n    yield x\n \ndef sqrt2_b():\n  for x in itertools.repeat(1):\n    yield x\n \ncf = CF(sqrt2_a(), sqrt2_b(), 950)\nprint(pRes(cf, 200))\n\n \n \n\ndef Napier_a():\n  yield 2\n  for x in itertools.count(1):\n    yield x\n \ndef Napier_b():\n  yield 1\n  for x in itertools.count(1):\n    yield x\n \ncf = CF(Napier_a(), Napier_b(), 950)\nprint(pRes(cf, 200))\n\n \n\ndef Pi_a():\n  yield 3\n  for x in itertools.repeat(6):\n    yield x\n \ndef Pi_b():\n  for x in itertools.count(1,2):\n    yield x*x\n \ncf = CF(Pi_a(), Pi_b(), 950)\nprint(pRes(cf, 10))\n\n"}
{"id": 36216, "name": "Continued fraction", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\npublic struct CycledSequence<WrappedSequence: Sequence> {\n  private var seq: WrappedSequence\n  private var iter: WrappedSequence.Iterator\n\n  init(seq: WrappedSequence) {\n    self.seq = seq\n    self.iter = seq.makeIterator()\n  }\n}\n\nextension CycledSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> WrappedSequence.Element? {\n    if let ele = iter.next() {\n      return ele\n    } else {\n      iter = seq.makeIterator()\n\n      return iter.next()\n    }\n  }\n}\n\nextension Sequence {\n  public func cycled() -> CycledSequence<Self> {\n    return CycledSequence(seq: self)\n  }\n}\n\npublic struct ChainedSequence<Element> {\n  private var sequences: [AnySequence<Element>]\n  private var iter: AnyIterator<Element>\n  private var curSeq = 0\n\n  init(chain: ChainedSequence) {\n    self.sequences = chain.sequences\n    self.iter = chain.iter\n    self.curSeq = chain.curSeq\n  }\n\n  init<Seq: Sequence>(_ seq: Seq) where Seq.Element == Element {\n    sequences = [AnySequence(seq)]\n    iter = sequences[curSeq].makeIterator()\n  }\n\n  func chained<Seq: Sequence>(with seq: Seq) -> ChainedSequence where Seq.Element == Element {\n    var res = ChainedSequence(chain: self)\n\n    res.sequences.append(AnySequence(seq))\n\n    return res\n  }\n}\n\nextension ChainedSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> Element? {\n    if let el = iter.next() {\n      return el\n    }\n\n    curSeq += 1\n\n    guard curSeq != sequences.endIndex else {\n      return nil\n    }\n\n    iter = sequences[curSeq].makeIterator()\n\n    return iter.next()\n  }\n}\n\nextension Sequence {\n  public func chained<Seq: Sequence>(with other: Seq) -> ChainedSequence<Element> where Seq.Element == Element {\n    return ChainedSequence(self).chained(with: other)\n  }\n}\n\nfunc continuedFraction<T: Sequence, V: Sequence>(\n  _ seq1: T,\n  _ seq2: V,\n  iterations: Int = 1000\n) -> Double where T.Element: BinaryInteger, T.Element == V.Element {\n  return zip(seq1, seq2).prefix(iterations).reversed().reduce(0.0, { Double($1.0) + (Double($1.1) / $0) })\n}\n\nlet sqrtA = [1].chained(with: [2].cycled())\nlet sqrtB = [1].cycled()\n\nprint(\"\u221a2 \u2248 \\(continuedFraction(sqrtA, sqrtB))\")\n\nlet napierA = [2].chained(with: 1...)\nlet napierB = [1].chained(with: 1...)\n\nprint(\"e \u2248 \\(continuedFraction(napierA, napierB))\")\n\nlet piA = [3].chained(with: [6].cycled())\nlet piB = (1...).lazy.map({ (2 * $0 - 1).power(2) })\n\nprint(\"\u03c0 \u2248 \\(continuedFraction(piA, piB))\")\n", "target": "from fractions import Fraction\nimport itertools\ntry: zip = itertools.izip\nexcept: pass\n \n\ndef CF(a, b, t):\n  terms = list(itertools.islice(zip(a, b), t))\n  z = Fraction(1,1)\n  for a, b in reversed(terms):\n    z = a + b / z\n  return z\n \n\ndef pRes(x, d):\n  q, x = divmod(x, 1)\n  res = str(q)\n  res += \".\"\n  for i in range(d):\n    x *= 10\n    q, x = divmod(x, 1)\n    res += str(q)\n  return res\n \n\ndef sqrt2_a():\n  yield 1\n  for x in itertools.repeat(2):\n    yield x\n \ndef sqrt2_b():\n  for x in itertools.repeat(1):\n    yield x\n \ncf = CF(sqrt2_a(), sqrt2_b(), 950)\nprint(pRes(cf, 200))\n\n \n \n\ndef Napier_a():\n  yield 2\n  for x in itertools.count(1):\n    yield x\n \ndef Napier_b():\n  yield 1\n  for x in itertools.count(1):\n    yield x\n \ncf = CF(Napier_a(), Napier_b(), 950)\nprint(pRes(cf, 200))\n\n \n\ndef Pi_a():\n  yield 3\n  for x in itertools.repeat(6):\n    yield x\n \ndef Pi_b():\n  for x in itertools.count(1,2):\n    yield x*x\n \ncf = CF(Pi_a(), Pi_b(), 950)\nprint(pRes(cf, 10))\n\n"}
{"id": 36700, "name": "Quine", "source": "Translate Swift to C#: ({print($0+$0.debugDescription+\")\")})(\"({print($0+$0.debugDescription+\\\")\\\")})(\")\n", "target": "class Program { static void Main() { var s = \"class Program {{ static void Main() {{ var s = {0}{1}{0}; System.Console.WriteLine(s, (char)34, s); }} }}\"; System.Console.WriteLine(s, (char)34, s); } }\n"}
{"id": 36701, "name": "Quine", "source": "Translate Swift to C#: ({print($0+$0.debugDescription+\")\")})(\"({print($0+$0.debugDescription+\\\")\\\")})(\")\n", "target": "class Program { static void Main() { var s = \"class Program {{ static void Main() {{ var s = {0}{1}{0}; System.Console.WriteLine(s, (char)34, s); }} }}\"; System.Console.WriteLine(s, (char)34, s); } }\n"}
{"id": 36704, "name": "Quine", "source": "Translate Swift to Java: ({print($0+$0.debugDescription+\")\")})(\"({print($0+$0.debugDescription+\\\")\\\")})(\")\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        console.print($./test.x);\n        }\n    }\n"}
{"id": 36705, "name": "Quine", "source": "Translate Swift to Java: ({print($0+$0.debugDescription+\")\")})(\"({print($0+$0.debugDescription+\\\")\\\")})(\")\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        console.print($./test.x);\n        }\n    }\n"}
{"id": 36706, "name": "Quine", "source": "Translate Swift to Python: ({print($0+$0.debugDescription+\")\")})(\"({print($0+$0.debugDescription+\\\")\\\")})(\")\n", "target": "w = \"print('w = ' + chr(34) + w + chr(34) + chr(10) + w)\"\nprint('w = ' + chr(34) + w + chr(34) + chr(10) + w)\n"}
{"id": 36707, "name": "Quine", "source": "Translate Swift to Python: ({print($0+$0.debugDescription+\")\")})(\"({print($0+$0.debugDescription+\\\")\\\")})(\")\n", "target": "w = \"print('w = ' + chr(34) + w + chr(34) + chr(10) + w)\"\nprint('w = ' + chr(34) + w + chr(34) + chr(10) + w)\n"}
{"id": 37091, "name": "Problem of Apollonius", "source": "Translate Swift to C#: import Foundation\n\nstruct Circle {\n    let center:[Double]!\n    let radius:Double!\n    \n    init(center:[Double], radius:Double) {\n        self.center = center\n        self.radius = radius\n    }\n    \n    func toString() -> String {\n        return \"Circle[x=\\(center[0]),y=\\(center[1]),r=\\(radius)]\"\n    }\n}\n\nfunc solveApollonius(c1:Circle, c2:Circle, c3:Circle,\n    s1:Double, s2:Double, s3:Double) -> Circle {\n    \n        let x1 = c1.center[0]\n        let y1 = c1.center[1]\n        let r1 = c1.radius\n        let x2 = c2.center[0]\n        let y2 = c2.center[1]\n        let r2 = c2.radius\n        let x3 = c3.center[0]\n        let y3 = c3.center[1]\n        let r3 = c3.radius\n        \n        let v11 = 2*x2 - 2*x1\n        let v12 = 2*y2 - 2*y1\n        let v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n        let v14 = 2*s2*r2 - 2*s1*r1\n        \n        let v21 = 2*x3 - 2*x2\n        let v22 = 2*y3 - 2*y2\n        let v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n        let v24 = 2*s3*r3 - 2*s2*r2\n        \n        let w12 = v12/v11\n        let w13 = v13/v11\n        let w14 = v14/v11\n        \n        let w22 = v22/v21-w12\n        let w23 = v23/v21-w13\n        let w24 = v24/v21-w14\n        \n        let P = -w23/w22\n        let Q = w24/w22\n        let M = -w12*P-w13\n        let N = w14 - w12*Q\n        \n        let a = N*N + Q*Q - 1\n        let b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1\n        let c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1\n        \n        let D = b*b-4*a*c\n        \n        let rs = (-b - sqrt(D)) / (2*a)\n        let xs = M + N * rs\n        let ys = P + Q * rs\n        \n        return  Circle(center: [xs,ys], radius: rs)\n        \n}\n\nlet c1 = Circle(center: [0,0], radius: 1)\nlet c2 = Circle(center: [4,0], radius: 1)\nlet c3 = Circle(center: [2,4], radius: 2)\n\nprintln(solveApollonius(c1,c2,c3,1,1,1).toString())\nprintln(solveApollonius(c1,c2,c3,-1,-1,-1).toString())\n", "target": "using System;\n\nnamespace ApolloniusProblemCalc\n{\n    class Program\n    {\n        static float rs = 0;\n        static float xs = 0;\n        static float ys = 0;\n\n        public static void Main(string[] args)\n        {\n            float gx1;\n            float gy1;\n            float gr1;\n            float gx2;\n            float gy2;\n            float gr2;\n            float gx3;\n            float gy3;\n            float gr3;\n\n            \n            gx1 = 0;\n            gy1 = 0;\n            gr1 = 1;\n            gx2 = 4;\n            gy2 = 0;\n            gr2 = 1;\n            gx3 = 2;\n            gy3 = 4;\n            gr3 = 2;\n            \n\n            for (int i = 1; i <= 8; i++)\n            {\n                SolveTheApollonius(i, gx1, gy1, gr1, gx2, gy2, gr2, gx3, gy3, gr3);\n\n\n                if (i == 1)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"st solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"st solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"st Solution circle's radius: \" + rs.ToString());\n                }\n                else if (i == 2)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"ed solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"ed solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"ed Solution circle's radius: \" + rs.ToString());\n                }\n                else if(i == 3)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"rd solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"rd solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"rd Solution circle's radius: \" + rs.ToString());\n                }\n                else\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"th solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"th solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"th Solution circle's radius: \" + rs.ToString());\n                }\n\n                Console.WriteLine();\n            }\n\n\n            Console.ReadKey(true);\n        }\n\n        private static void SolveTheApollonius(int calcCounter, float x1, float y1, float r1, float x2, float y2, float r2, float x3, float y3, float r3)\n        {\n            float s1 = 1;\n            float s2 = 1;\n            float s3 = 1;\n\n            if (calcCounter == 2)\n            {\n                s1 = -1;\n                s2 = -1;\n                s3 = -1;\n            }\n            else if (calcCounter == 3)\n            {\n                s1 = 1;\n                s2 = -1;\n                s3 = -1;\n            }\n            else if (calcCounter == 4)\n            {\n                s1 = -1;\n                s2 = 1;\n                s3 = -1;\n            }\n            else if (calcCounter == 5)\n            {\n                s1 = -1;\n                s2 = -1;\n                s3 = 1;\n            }\n            else if (calcCounter == 6)\n            {\n                s1 = 1;\n                s2 = 1;\n                s3 = -1;\n            }\n            else if (calcCounter == 7)\n            {\n                s1 = -1;\n                s2 = 1;\n                s3 = 1;\n            }\n            else if (calcCounter == 8)\n            {\n                s1 = 1;\n                s2 = -1;\n                s3 = 1;\n            }\n\n            \n            float v11 = 2 * x2 - 2 * x1;\n            float v12 = 2 * y2 - 2 * y1;\n            float v13 = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2 - r1 * r1 + r2 * r2;\n            float v14 = 2 * s2 * r2 - 2 * s1 * r1;\n\n            float v21 = 2 * x3 - 2 * x2;\n            float v22 = 2 * y3 - 2 * y2;\n            float v23 = x2 * x2 - x3 * x3 + y2 * y2 - y3 * y3 - r2 * r2 + r3 * r3;\n            float v24 = 2 * s3 * r3 - 2 * s2 * r2;\n\n            float w12 = v12 / v11;\n            float w13 = v13 / v11;\n            float w14 = v14 / v11;\n\n            float w22 = v22 / v21 - w12;\n            float w23 = v23 / v21 - w13;\n            float w24 = v24 / v21 - w14;\n\n            float P = -w23 / w22;\n            float Q = w24 / w22;\n            float M = -w12 * P - w13;\n            float N = w14 - w12 * Q;\n\n            float a = N * N + Q * Q - 1;\n            float b = 2 * M * N - 2 * N * x1 + 2 * P * Q - 2 * Q * y1 + 2 * s1 * r1;\n            float c = x1 * x1 + M * M - 2 * M * x1 + P * P + y1 * y1 - 2 * P * y1 - r1 * r1;\n\n            float D = b * b - 4 * a * c;\n\n            rs = (-b - float.Parse(Math.Sqrt(D).ToString())) / (2 * float.Parse(a.ToString()));\n            xs = M + N * rs;\n            ys = P + Q * rs;\n        }\n    }\n}\n"}
{"id": 37092, "name": "Problem of Apollonius", "source": "Translate Swift to Java: import Foundation\n\nstruct Circle {\n    let center:[Double]!\n    let radius:Double!\n    \n    init(center:[Double], radius:Double) {\n        self.center = center\n        self.radius = radius\n    }\n    \n    func toString() -> String {\n        return \"Circle[x=\\(center[0]),y=\\(center[1]),r=\\(radius)]\"\n    }\n}\n\nfunc solveApollonius(c1:Circle, c2:Circle, c3:Circle,\n    s1:Double, s2:Double, s3:Double) -> Circle {\n    \n        let x1 = c1.center[0]\n        let y1 = c1.center[1]\n        let r1 = c1.radius\n        let x2 = c2.center[0]\n        let y2 = c2.center[1]\n        let r2 = c2.radius\n        let x3 = c3.center[0]\n        let y3 = c3.center[1]\n        let r3 = c3.radius\n        \n        let v11 = 2*x2 - 2*x1\n        let v12 = 2*y2 - 2*y1\n        let v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n        let v14 = 2*s2*r2 - 2*s1*r1\n        \n        let v21 = 2*x3 - 2*x2\n        let v22 = 2*y3 - 2*y2\n        let v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n        let v24 = 2*s3*r3 - 2*s2*r2\n        \n        let w12 = v12/v11\n        let w13 = v13/v11\n        let w14 = v14/v11\n        \n        let w22 = v22/v21-w12\n        let w23 = v23/v21-w13\n        let w24 = v24/v21-w14\n        \n        let P = -w23/w22\n        let Q = w24/w22\n        let M = -w12*P-w13\n        let N = w14 - w12*Q\n        \n        let a = N*N + Q*Q - 1\n        let b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1\n        let c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1\n        \n        let D = b*b-4*a*c\n        \n        let rs = (-b - sqrt(D)) / (2*a)\n        let xs = M + N * rs\n        let ys = P + Q * rs\n        \n        return  Circle(center: [xs,ys], radius: rs)\n        \n}\n\nlet c1 = Circle(center: [0,0], radius: 1)\nlet c2 = Circle(center: [4,0], radius: 1)\nlet c3 = Circle(center: [2,4], radius: 2)\n\nprintln(solveApollonius(c1,c2,c3,1,1,1).toString())\nprintln(solveApollonius(c1,c2,c3,-1,-1,-1).toString())\n", "target": "public class Circle\n{\n public double[] center;\n public double radius;\n public Circle(double[] center, double radius)\n {\n  this.center = center;\n  this.radius = radius;\n }\n public String toString()\n {\n  return String.format(\"Circle[x=%.2f,y=%.2f,r=%.2f]\",center[0],center[1],\n\t\t       radius);\n }\n}\n\npublic class ApolloniusSolver\n{\n\n public static Circle solveApollonius(Circle c1, Circle c2, Circle c3, int s1,\n\t\t\t\t      int s2, int s3)\n {\n  float x1 = c1.center[0];\n  float y1 = c1.center[1];\n  float r1 = c1.radius;\n  float x2 = c2.center[0];\n  float y2 = c2.center[1];\n  float r2 = c2.radius;\n  float x3 = c3.center[0];\n  float y3 = c3.center[1];\n  float r3 = c3.radius;\n\n  \n  \n  float v11 = 2*x2 - 2*x1;\n  float v12 = 2*y2 - 2*y1;\n  float v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2;\n  float v14 = 2*s2*r2 - 2*s1*r1;\n\n  float v21 = 2*x3 - 2*x2;\n  float v22 = 2*y3 - 2*y2;\n  float v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3;\n  float v24 = 2*s3*r3 - 2*s2*r2;\n\n  float w12 = v12/v11;\n  float w13 = v13/v11;\n  float w14 = v14/v11;\n\n  float w22 = v22/v21-w12;\n  float w23 = v23/v21-w13;\n  float w24 = v24/v21-w14;\n\n  float P = -w23/w22;\n  float Q = w24/w22;\n  float M = -w12*P-w13;\n  float N = w14 - w12*Q;\n\n  float a = N*N + Q*Q - 1;\n  float b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1;\n  float c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1;\n\n  \n  \n  float D = b*b-4*a*c;\n  float rs = (-b-Math.sqrt(D))/(2*a);\n  float xs = M + N * rs;\n  float ys = P + Q * rs;\n  return new Circle(new double[]{xs,ys}, rs);\n }\n public static void main(final String[] args)\n {\n  Circle c1 = new Circle(new double[]{0,0}, 1);\n  Circle c2 = new Circle(new double[]{4,0}, 1);\n  Circle c3 = new Circle(new double[]{2,4}, 2);\n  \n  System.out.println(solveApollonius(c1,c2,c3,1,1,1));\n  \n  System.out.println(solveApollonius(c1,c2,c3,-1,-1,-1));\n }\n}\n"}
{"id": 37093, "name": "Problem of Apollonius", "source": "Translate Swift to Python: import Foundation\n\nstruct Circle {\n    let center:[Double]!\n    let radius:Double!\n    \n    init(center:[Double], radius:Double) {\n        self.center = center\n        self.radius = radius\n    }\n    \n    func toString() -> String {\n        return \"Circle[x=\\(center[0]),y=\\(center[1]),r=\\(radius)]\"\n    }\n}\n\nfunc solveApollonius(c1:Circle, c2:Circle, c3:Circle,\n    s1:Double, s2:Double, s3:Double) -> Circle {\n    \n        let x1 = c1.center[0]\n        let y1 = c1.center[1]\n        let r1 = c1.radius\n        let x2 = c2.center[0]\n        let y2 = c2.center[1]\n        let r2 = c2.radius\n        let x3 = c3.center[0]\n        let y3 = c3.center[1]\n        let r3 = c3.radius\n        \n        let v11 = 2*x2 - 2*x1\n        let v12 = 2*y2 - 2*y1\n        let v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n        let v14 = 2*s2*r2 - 2*s1*r1\n        \n        let v21 = 2*x3 - 2*x2\n        let v22 = 2*y3 - 2*y2\n        let v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n        let v24 = 2*s3*r3 - 2*s2*r2\n        \n        let w12 = v12/v11\n        let w13 = v13/v11\n        let w14 = v14/v11\n        \n        let w22 = v22/v21-w12\n        let w23 = v23/v21-w13\n        let w24 = v24/v21-w14\n        \n        let P = -w23/w22\n        let Q = w24/w22\n        let M = -w12*P-w13\n        let N = w14 - w12*Q\n        \n        let a = N*N + Q*Q - 1\n        let b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1\n        let c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1\n        \n        let D = b*b-4*a*c\n        \n        let rs = (-b - sqrt(D)) / (2*a)\n        let xs = M + N * rs\n        let ys = P + Q * rs\n        \n        return  Circle(center: [xs,ys], radius: rs)\n        \n}\n\nlet c1 = Circle(center: [0,0], radius: 1)\nlet c2 = Circle(center: [4,0], radius: 1)\nlet c3 = Circle(center: [2,4], radius: 2)\n\nprintln(solveApollonius(c1,c2,c3,1,1,1).toString())\nprintln(solveApollonius(c1,c2,c3,-1,-1,-1).toString())\n", "target": "from collections import namedtuple\nimport math\n\nCircle = namedtuple('Circle', 'x, y, r')\n \ndef solveApollonius(c1, c2, c3, s1, s2, s3):\n    \n    x1, y1, r1 = c1\n    x2, y2, r2 = c2\n    x3, y3, r3 = c3\n\n    v11 = 2*x2 - 2*x1\n    v12 = 2*y2 - 2*y1\n    v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n    v14 = 2*s2*r2 - 2*s1*r1\n \n    v21 = 2*x3 - 2*x2\n    v22 = 2*y3 - 2*y2\n    v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n    v24 = 2*s3*r3 - 2*s2*r2\n \n    w12 = v12/v11\n    w13 = v13/v11\n    w14 = v14/v11\n \n    w22 = v22/v21-w12\n    w23 = v23/v21-w13\n    w24 = v24/v21-w14\n \n    P = -w23/w22\n    Q = w24/w22\n    M = -w12*P-w13\n    N = w14 - w12*Q\n \n    a = N*N + Q*Q - 1\n    b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1\n    c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1\n \n    \n    D = b*b-4*a*c\n    rs = (-b-math.sqrt(D))/(2*a)\n \n    xs = M+N*rs\n    ys = P+Q*rs\n \n    return Circle(xs, ys, rs)\n\nif __name__ == '__main__':\n    c1, c2, c3 = Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2)\n    print(solveApollonius(c1, c2, c3, 1, 1, 1))    \n    print(solveApollonius(c1, c2, c3, -1, -1, -1)) \n"}
{"id": 37718, "name": "Quaternion type", "source": "Translate Swift to C#: import Foundation\n\nstruct Quaternion {\n  var a, b, c, d: Double\n  \n  static let i = Quaternion(a: 0, b: 1, c: 0, d: 0)\n  static let j = Quaternion(a: 0, b: 0, c: 1, d: 0)\n  static let k = Quaternion(a: 0, b: 0, c: 0, d: 1)\n}\nextension Quaternion: Equatable {\n  static func ==(lhs: Quaternion, rhs: Quaternion) -> Bool {\n    return (lhs.a, lhs.b, lhs.c, lhs.d) == (rhs.a, rhs.b, rhs.c, rhs.d)\n  }\n}\nextension Quaternion: ExpressibleByIntegerLiteral {\n  init(integerLiteral: Double) {\n    a = integerLiteral\n    b = 0\n    c = 0\n    d = 0\n  }\n}\nextension Quaternion: Numeric {\n  var magnitude: Double {\n    return norm\n  }\n  init?<T>(exactly: T) { \n    return nil\n  }\n  public static func + (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func - (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func * (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n  public static func += (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func -= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func *= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n}\nextension Quaternion: CustomStringConvertible {\n  var description: String {\n    let formatter = NumberFormatter()\n    formatter.positivePrefix = \"+\"\n    let f: (Double) -> String = { formatter.string(from: $0 as NSNumber)! }\n    return [f(a), f(b), \"i\", f(c), \"j\", f(d), \"k\"].joined()\n  }\n}\nextension Quaternion {\n  var norm: Double {\n    return sqrt(a*a + b*b + c*c + d*d)\n  }\n  var conjugate: Quaternion {\n    return Quaternion(a: a, b: -b, c: -c, d: -d)\n  }\n  public static func + (lhs: Double, rhs: Quaternion) -> Quaternion {\n    var result = rhs\n    result.a += lhs\n    return result\n  }\n  public static func + (lhs: Quaternion, rhs: Double) -> Quaternion {\n    var result = lhs\n    result.a += rhs\n    return result\n  }\n  public static func * (lhs: Double, rhs: Quaternion) -> Quaternion {\n    return Quaternion(a: lhs*rhs.a, b: lhs*rhs.b, c: lhs*rhs.c, d: lhs*rhs.d)\n  }\n  public static func * (lhs: Quaternion, rhs: Double) -> Quaternion {\n    return Quaternion(a: lhs.a*rhs, b: lhs.b*rhs, c: lhs.c*rhs, d: lhs.d*rhs)\n  }\n  public static prefix func - (x: Quaternion) -> Quaternion {\n    return Quaternion(a: -x.a, b: -x.b, c: -x.c, d: -x.d)\n  }\n}\n\nlet q:  Quaternion = 1 + 2 * .i + 3 * .j + 4 * .k \nlet q1: Quaternion = 2 + 3 * .i + 4 * .j + 5 * .k \nlet q2: Quaternion = 3 + 4 * .i + 5 * .j + 6 * .k \nlet r: Double = 7\n\nprint(\"\"\"\n  q  = \\(q)\n  q1 = \\(q1)\n  q2 = \\(q2)\n  r = \\(r)\n  -q = \\(-q)\n  \u2016q\u2016 = \\(q.norm)\n  conjugate of q = \\(q.conjugate)\n  r + q = q + r = \\(r+q) = \\(q+r)\n  q\u2081 + q\u2082 = \\(q1 + q2) = \\(q2 + q1)\n  qr = rq = \\(q*r) = \\(r*q)\n  q\u2081q\u2082 = \\(q1 * q2)\n  q\u2082q\u2081 = \\(q2 * q1)\n  q\u2081q\u2082 \u2260 q\u2082q\u2081 is \\(q1*q2 != q2*q1)\n\"\"\")\n", "target": "using System;\n\nstruct Quaternion : IEquatable<Quaternion>\n{\n    public readonly double A, B, C, D;\n\n    public Quaternion(double a, double b, double c, double d)\n    {\n        this.A = a;\n        this.B = b;\n        this.C = c;\n        this.D = d;\n    }\n\n    public double Norm()\n    {\n        return Math.Sqrt(A * A + B * B + C * C + D * D);\n    }\n\n    public static Quaternion operator -(Quaternion q)\n    {\n        return new Quaternion(-q.A, -q.B, -q.C, -q.D);\n    }\n\n    public Quaternion Conjugate()\n    {\n        return new Quaternion(A, -B, -C, -D);\n    }\n\n    \n    public static implicit operator Quaternion(double d)\n    {\n        return new Quaternion(d, 0, 0, 0);\n    }\n\n    public static Quaternion operator +(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(q1.A + q2.A, q1.B + q2.B, q1.C + q2.C, q1.D + q2.D);\n    }\n\n    public static Quaternion operator *(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(\n            q1.A * q2.A - q1.B * q2.B - q1.C * q2.C - q1.D * q2.D,\n            q1.A * q2.B + q1.B * q2.A + q1.C * q2.D - q1.D * q2.C,\n            q1.A * q2.C - q1.B * q2.D + q1.C * q2.A + q1.D * q2.B,\n            q1.A * q2.D + q1.B * q2.C - q1.C * q2.B + q1.D * q2.A);\n    }\n\n    public static bool operator ==(Quaternion q1, Quaternion q2)\n    {\n        return q1.A == q2.A && q1.B == q2.B && q1.C == q2.C && q1.D == q2.D;\n    }\n\n    public static bool operator !=(Quaternion q1, Quaternion q2)\n    {\n        return !(q1 == q2);\n    }\n\n    #region Object Members\n\n    public override bool Equals(object obj)\n    {\n        if (obj is Quaternion)\n            return Equals((Quaternion)obj);\n\n        return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"Q({0}, {1}, {2}, {3})\", A, B, C, D);\n    }\n\n    #endregion\n\n    #region IEquatable<Quaternion> Members\n\n    public bool Equals(Quaternion other)\n    {\n        return other == this;\n    }\n\n    #endregion\n}\n"}
{"id": 37719, "name": "Quaternion type", "source": "Translate Swift to C#: import Foundation\n\nstruct Quaternion {\n  var a, b, c, d: Double\n  \n  static let i = Quaternion(a: 0, b: 1, c: 0, d: 0)\n  static let j = Quaternion(a: 0, b: 0, c: 1, d: 0)\n  static let k = Quaternion(a: 0, b: 0, c: 0, d: 1)\n}\nextension Quaternion: Equatable {\n  static func ==(lhs: Quaternion, rhs: Quaternion) -> Bool {\n    return (lhs.a, lhs.b, lhs.c, lhs.d) == (rhs.a, rhs.b, rhs.c, rhs.d)\n  }\n}\nextension Quaternion: ExpressibleByIntegerLiteral {\n  init(integerLiteral: Double) {\n    a = integerLiteral\n    b = 0\n    c = 0\n    d = 0\n  }\n}\nextension Quaternion: Numeric {\n  var magnitude: Double {\n    return norm\n  }\n  init?<T>(exactly: T) { \n    return nil\n  }\n  public static func + (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func - (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func * (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n  public static func += (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func -= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func *= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n}\nextension Quaternion: CustomStringConvertible {\n  var description: String {\n    let formatter = NumberFormatter()\n    formatter.positivePrefix = \"+\"\n    let f: (Double) -> String = { formatter.string(from: $0 as NSNumber)! }\n    return [f(a), f(b), \"i\", f(c), \"j\", f(d), \"k\"].joined()\n  }\n}\nextension Quaternion {\n  var norm: Double {\n    return sqrt(a*a + b*b + c*c + d*d)\n  }\n  var conjugate: Quaternion {\n    return Quaternion(a: a, b: -b, c: -c, d: -d)\n  }\n  public static func + (lhs: Double, rhs: Quaternion) -> Quaternion {\n    var result = rhs\n    result.a += lhs\n    return result\n  }\n  public static func + (lhs: Quaternion, rhs: Double) -> Quaternion {\n    var result = lhs\n    result.a += rhs\n    return result\n  }\n  public static func * (lhs: Double, rhs: Quaternion) -> Quaternion {\n    return Quaternion(a: lhs*rhs.a, b: lhs*rhs.b, c: lhs*rhs.c, d: lhs*rhs.d)\n  }\n  public static func * (lhs: Quaternion, rhs: Double) -> Quaternion {\n    return Quaternion(a: lhs.a*rhs, b: lhs.b*rhs, c: lhs.c*rhs, d: lhs.d*rhs)\n  }\n  public static prefix func - (x: Quaternion) -> Quaternion {\n    return Quaternion(a: -x.a, b: -x.b, c: -x.c, d: -x.d)\n  }\n}\n\nlet q:  Quaternion = 1 + 2 * .i + 3 * .j + 4 * .k \nlet q1: Quaternion = 2 + 3 * .i + 4 * .j + 5 * .k \nlet q2: Quaternion = 3 + 4 * .i + 5 * .j + 6 * .k \nlet r: Double = 7\n\nprint(\"\"\"\n  q  = \\(q)\n  q1 = \\(q1)\n  q2 = \\(q2)\n  r = \\(r)\n  -q = \\(-q)\n  \u2016q\u2016 = \\(q.norm)\n  conjugate of q = \\(q.conjugate)\n  r + q = q + r = \\(r+q) = \\(q+r)\n  q\u2081 + q\u2082 = \\(q1 + q2) = \\(q2 + q1)\n  qr = rq = \\(q*r) = \\(r*q)\n  q\u2081q\u2082 = \\(q1 * q2)\n  q\u2082q\u2081 = \\(q2 * q1)\n  q\u2081q\u2082 \u2260 q\u2082q\u2081 is \\(q1*q2 != q2*q1)\n\"\"\")\n", "target": "using System;\n\nstruct Quaternion : IEquatable<Quaternion>\n{\n    public readonly double A, B, C, D;\n\n    public Quaternion(double a, double b, double c, double d)\n    {\n        this.A = a;\n        this.B = b;\n        this.C = c;\n        this.D = d;\n    }\n\n    public double Norm()\n    {\n        return Math.Sqrt(A * A + B * B + C * C + D * D);\n    }\n\n    public static Quaternion operator -(Quaternion q)\n    {\n        return new Quaternion(-q.A, -q.B, -q.C, -q.D);\n    }\n\n    public Quaternion Conjugate()\n    {\n        return new Quaternion(A, -B, -C, -D);\n    }\n\n    \n    public static implicit operator Quaternion(double d)\n    {\n        return new Quaternion(d, 0, 0, 0);\n    }\n\n    public static Quaternion operator +(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(q1.A + q2.A, q1.B + q2.B, q1.C + q2.C, q1.D + q2.D);\n    }\n\n    public static Quaternion operator *(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(\n            q1.A * q2.A - q1.B * q2.B - q1.C * q2.C - q1.D * q2.D,\n            q1.A * q2.B + q1.B * q2.A + q1.C * q2.D - q1.D * q2.C,\n            q1.A * q2.C - q1.B * q2.D + q1.C * q2.A + q1.D * q2.B,\n            q1.A * q2.D + q1.B * q2.C - q1.C * q2.B + q1.D * q2.A);\n    }\n\n    public static bool operator ==(Quaternion q1, Quaternion q2)\n    {\n        return q1.A == q2.A && q1.B == q2.B && q1.C == q2.C && q1.D == q2.D;\n    }\n\n    public static bool operator !=(Quaternion q1, Quaternion q2)\n    {\n        return !(q1 == q2);\n    }\n\n    #region Object Members\n\n    public override bool Equals(object obj)\n    {\n        if (obj is Quaternion)\n            return Equals((Quaternion)obj);\n\n        return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"Q({0}, {1}, {2}, {3})\", A, B, C, D);\n    }\n\n    #endregion\n\n    #region IEquatable<Quaternion> Members\n\n    public bool Equals(Quaternion other)\n    {\n        return other == this;\n    }\n\n    #endregion\n}\n"}
{"id": 37722, "name": "Quaternion type", "source": "Translate Swift to Java: import Foundation\n\nstruct Quaternion {\n  var a, b, c, d: Double\n  \n  static let i = Quaternion(a: 0, b: 1, c: 0, d: 0)\n  static let j = Quaternion(a: 0, b: 0, c: 1, d: 0)\n  static let k = Quaternion(a: 0, b: 0, c: 0, d: 1)\n}\nextension Quaternion: Equatable {\n  static func ==(lhs: Quaternion, rhs: Quaternion) -> Bool {\n    return (lhs.a, lhs.b, lhs.c, lhs.d) == (rhs.a, rhs.b, rhs.c, rhs.d)\n  }\n}\nextension Quaternion: ExpressibleByIntegerLiteral {\n  init(integerLiteral: Double) {\n    a = integerLiteral\n    b = 0\n    c = 0\n    d = 0\n  }\n}\nextension Quaternion: Numeric {\n  var magnitude: Double {\n    return norm\n  }\n  init?<T>(exactly: T) { \n    return nil\n  }\n  public static func + (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func - (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func * (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n  public static func += (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func -= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func *= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n}\nextension Quaternion: CustomStringConvertible {\n  var description: String {\n    let formatter = NumberFormatter()\n    formatter.positivePrefix = \"+\"\n    let f: (Double) -> String = { formatter.string(from: $0 as NSNumber)! }\n    return [f(a), f(b), \"i\", f(c), \"j\", f(d), \"k\"].joined()\n  }\n}\nextension Quaternion {\n  var norm: Double {\n    return sqrt(a*a + b*b + c*c + d*d)\n  }\n  var conjugate: Quaternion {\n    return Quaternion(a: a, b: -b, c: -c, d: -d)\n  }\n  public static func + (lhs: Double, rhs: Quaternion) -> Quaternion {\n    var result = rhs\n    result.a += lhs\n    return result\n  }\n  public static func + (lhs: Quaternion, rhs: Double) -> Quaternion {\n    var result = lhs\n    result.a += rhs\n    return result\n  }\n  public static func * (lhs: Double, rhs: Quaternion) -> Quaternion {\n    return Quaternion(a: lhs*rhs.a, b: lhs*rhs.b, c: lhs*rhs.c, d: lhs*rhs.d)\n  }\n  public static func * (lhs: Quaternion, rhs: Double) -> Quaternion {\n    return Quaternion(a: lhs.a*rhs, b: lhs.b*rhs, c: lhs.c*rhs, d: lhs.d*rhs)\n  }\n  public static prefix func - (x: Quaternion) -> Quaternion {\n    return Quaternion(a: -x.a, b: -x.b, c: -x.c, d: -x.d)\n  }\n}\n\nlet q:  Quaternion = 1 + 2 * .i + 3 * .j + 4 * .k \nlet q1: Quaternion = 2 + 3 * .i + 4 * .j + 5 * .k \nlet q2: Quaternion = 3 + 4 * .i + 5 * .j + 6 * .k \nlet r: Double = 7\n\nprint(\"\"\"\n  q  = \\(q)\n  q1 = \\(q1)\n  q2 = \\(q2)\n  r = \\(r)\n  -q = \\(-q)\n  \u2016q\u2016 = \\(q.norm)\n  conjugate of q = \\(q.conjugate)\n  r + q = q + r = \\(r+q) = \\(q+r)\n  q\u2081 + q\u2082 = \\(q1 + q2) = \\(q2 + q1)\n  qr = rq = \\(q*r) = \\(r*q)\n  q\u2081q\u2082 = \\(q1 * q2)\n  q\u2082q\u2081 = \\(q2 * q1)\n  q\u2081q\u2082 \u2260 q\u2082q\u2081 is \\(q1*q2 != q2*q1)\n\"\"\")\n", "target": "public class Quaternion {\n    private final double a, b, c, d;\n\n    public Quaternion(double a, double b, double c, double d) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n    public Quaternion(double r) {\n        this(r, 0.0, 0.0, 0.0);\n    }\n\n    public double norm() {\n        return Math.sqrt(a * a + b * b + c * c + d * d);\n    }\n\n    public Quaternion negative() {\n        return new Quaternion(-a, -b, -c, -d);\n    }\n\n    public Quaternion conjugate() {\n        return new Quaternion(a, -b, -c, -d);\n    }\n\n    public Quaternion add(double r) {\n        return new Quaternion(a + r, b, c, d);\n    }\n    public static Quaternion add(Quaternion q, double r) {\n        return q.add(r);\n    }\n    public static Quaternion add(double r, Quaternion q) {\n        return q.add(r);\n    }\n    public Quaternion add(Quaternion q) {\n        return new Quaternion(a + q.a, b + q.b, c + q.c, d + q.d);\n    }\n    public static Quaternion add(Quaternion q1, Quaternion q2) {\n        return q1.add(q2);\n    }\n\n    public Quaternion times(double r) {\n        return new Quaternion(a * r, b * r, c * r, d * r);\n    }\n    public static Quaternion times(Quaternion q, double r) {\n        return q.times(r);\n    }\n    public static Quaternion times(double r, Quaternion q) {\n        return q.times(r);\n    }\n    public Quaternion times(Quaternion q) {\n        return new Quaternion(\n            a * q.a - b * q.b - c * q.c - d * q.d,\n            a * q.b + b * q.a + c * q.d - d * q.c,\n            a * q.c - b * q.d + c * q.a + d * q.b,\n            a * q.d + b * q.c - c * q.b + d * q.a\n        );\n    }\n    public static Quaternion times(Quaternion q1, Quaternion q2) {\n        return q1.times(q2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (!(obj instanceof Quaternion)) return false;\n        final Quaternion other = (Quaternion) obj;\n        if (Double.doubleToLongBits(this.a) != Double.doubleToLongBits(other.a)) return false;\n        if (Double.doubleToLongBits(this.b) != Double.doubleToLongBits(other.b)) return false;\n        if (Double.doubleToLongBits(this.c) != Double.doubleToLongBits(other.c)) return false;\n        if (Double.doubleToLongBits(this.d) != Double.doubleToLongBits(other.d)) return false;\n        return true;\n    }\n    @Override\n    public String toString() {\n        return String.format(\"%.2f +\u00a0%.2fi +\u00a0%.2fj +\u00a0%.2fk\", a, b, c, d).replaceAll(\"\\\\+ -\", \"- \");\n    }\n\n    public String toQuadruple() {\n        return String.format(\"(%.2f,\u00a0%.2f,\u00a0%.2f,\u00a0%.2f)\", a, b, c, d);\n    }\n\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion(1.0, 2.0, 3.0, 4.0);\n        Quaternion q1 = new Quaternion(2.0, 3.0, 4.0, 5.0);\n        Quaternion q2 = new Quaternion(3.0, 4.0, 5.0, 6.0);\n        double r = 7.0;\n        System.out.format(\"q       = %s%n\", q);\n        System.out.format(\"q1      = %s%n\", q1);\n        System.out.format(\"q2      = %s%n\", q2);\n        System.out.format(\"r       =\u00a0%.2f%n%n\", r);\n        System.out.format(\"\\u2016q\\u2016     =\u00a0%.2f%n\", q.norm());\n        System.out.format(\"-q      = %s%n\", q.negative());\n        System.out.format(\"q*      = %s%n\", q.conjugate());\n        System.out.format(\"q + r   = %s%n\", q.add(r));\n        System.out.format(\"q1 + q2 = %s%n\", q1.add(q2));\n        System.out.format(\"q \\u00d7 r   = %s%n\", q.times(r));\n        Quaternion q1q2 = q1.times(q2);\n        Quaternion q2q1 = q2.times(q1);\n        System.out.format(\"q1 \\u00d7 q2 = %s%n\", q1q2);\n        System.out.format(\"q2 \\u00d7 q1 = %s%n\", q2q1);\n        System.out.format(\"q1 \\u00d7 q2 %s q2 \\u00d7 q1%n\", (q1q2.equals(q2q1) ? \"=\" : \"\\u2260\"));\n    }\n}\n"}
{"id": 37723, "name": "Quaternion type", "source": "Translate Swift to Java: import Foundation\n\nstruct Quaternion {\n  var a, b, c, d: Double\n  \n  static let i = Quaternion(a: 0, b: 1, c: 0, d: 0)\n  static let j = Quaternion(a: 0, b: 0, c: 1, d: 0)\n  static let k = Quaternion(a: 0, b: 0, c: 0, d: 1)\n}\nextension Quaternion: Equatable {\n  static func ==(lhs: Quaternion, rhs: Quaternion) -> Bool {\n    return (lhs.a, lhs.b, lhs.c, lhs.d) == (rhs.a, rhs.b, rhs.c, rhs.d)\n  }\n}\nextension Quaternion: ExpressibleByIntegerLiteral {\n  init(integerLiteral: Double) {\n    a = integerLiteral\n    b = 0\n    c = 0\n    d = 0\n  }\n}\nextension Quaternion: Numeric {\n  var magnitude: Double {\n    return norm\n  }\n  init?<T>(exactly: T) { \n    return nil\n  }\n  public static func + (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func - (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func * (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n  public static func += (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func -= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func *= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n}\nextension Quaternion: CustomStringConvertible {\n  var description: String {\n    let formatter = NumberFormatter()\n    formatter.positivePrefix = \"+\"\n    let f: (Double) -> String = { formatter.string(from: $0 as NSNumber)! }\n    return [f(a), f(b), \"i\", f(c), \"j\", f(d), \"k\"].joined()\n  }\n}\nextension Quaternion {\n  var norm: Double {\n    return sqrt(a*a + b*b + c*c + d*d)\n  }\n  var conjugate: Quaternion {\n    return Quaternion(a: a, b: -b, c: -c, d: -d)\n  }\n  public static func + (lhs: Double, rhs: Quaternion) -> Quaternion {\n    var result = rhs\n    result.a += lhs\n    return result\n  }\n  public static func + (lhs: Quaternion, rhs: Double) -> Quaternion {\n    var result = lhs\n    result.a += rhs\n    return result\n  }\n  public static func * (lhs: Double, rhs: Quaternion) -> Quaternion {\n    return Quaternion(a: lhs*rhs.a, b: lhs*rhs.b, c: lhs*rhs.c, d: lhs*rhs.d)\n  }\n  public static func * (lhs: Quaternion, rhs: Double) -> Quaternion {\n    return Quaternion(a: lhs.a*rhs, b: lhs.b*rhs, c: lhs.c*rhs, d: lhs.d*rhs)\n  }\n  public static prefix func - (x: Quaternion) -> Quaternion {\n    return Quaternion(a: -x.a, b: -x.b, c: -x.c, d: -x.d)\n  }\n}\n\nlet q:  Quaternion = 1 + 2 * .i + 3 * .j + 4 * .k \nlet q1: Quaternion = 2 + 3 * .i + 4 * .j + 5 * .k \nlet q2: Quaternion = 3 + 4 * .i + 5 * .j + 6 * .k \nlet r: Double = 7\n\nprint(\"\"\"\n  q  = \\(q)\n  q1 = \\(q1)\n  q2 = \\(q2)\n  r = \\(r)\n  -q = \\(-q)\n  \u2016q\u2016 = \\(q.norm)\n  conjugate of q = \\(q.conjugate)\n  r + q = q + r = \\(r+q) = \\(q+r)\n  q\u2081 + q\u2082 = \\(q1 + q2) = \\(q2 + q1)\n  qr = rq = \\(q*r) = \\(r*q)\n  q\u2081q\u2082 = \\(q1 * q2)\n  q\u2082q\u2081 = \\(q2 * q1)\n  q\u2081q\u2082 \u2260 q\u2082q\u2081 is \\(q1*q2 != q2*q1)\n\"\"\")\n", "target": "public class Quaternion {\n    private final double a, b, c, d;\n\n    public Quaternion(double a, double b, double c, double d) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n    public Quaternion(double r) {\n        this(r, 0.0, 0.0, 0.0);\n    }\n\n    public double norm() {\n        return Math.sqrt(a * a + b * b + c * c + d * d);\n    }\n\n    public Quaternion negative() {\n        return new Quaternion(-a, -b, -c, -d);\n    }\n\n    public Quaternion conjugate() {\n        return new Quaternion(a, -b, -c, -d);\n    }\n\n    public Quaternion add(double r) {\n        return new Quaternion(a + r, b, c, d);\n    }\n    public static Quaternion add(Quaternion q, double r) {\n        return q.add(r);\n    }\n    public static Quaternion add(double r, Quaternion q) {\n        return q.add(r);\n    }\n    public Quaternion add(Quaternion q) {\n        return new Quaternion(a + q.a, b + q.b, c + q.c, d + q.d);\n    }\n    public static Quaternion add(Quaternion q1, Quaternion q2) {\n        return q1.add(q2);\n    }\n\n    public Quaternion times(double r) {\n        return new Quaternion(a * r, b * r, c * r, d * r);\n    }\n    public static Quaternion times(Quaternion q, double r) {\n        return q.times(r);\n    }\n    public static Quaternion times(double r, Quaternion q) {\n        return q.times(r);\n    }\n    public Quaternion times(Quaternion q) {\n        return new Quaternion(\n            a * q.a - b * q.b - c * q.c - d * q.d,\n            a * q.b + b * q.a + c * q.d - d * q.c,\n            a * q.c - b * q.d + c * q.a + d * q.b,\n            a * q.d + b * q.c - c * q.b + d * q.a\n        );\n    }\n    public static Quaternion times(Quaternion q1, Quaternion q2) {\n        return q1.times(q2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (!(obj instanceof Quaternion)) return false;\n        final Quaternion other = (Quaternion) obj;\n        if (Double.doubleToLongBits(this.a) != Double.doubleToLongBits(other.a)) return false;\n        if (Double.doubleToLongBits(this.b) != Double.doubleToLongBits(other.b)) return false;\n        if (Double.doubleToLongBits(this.c) != Double.doubleToLongBits(other.c)) return false;\n        if (Double.doubleToLongBits(this.d) != Double.doubleToLongBits(other.d)) return false;\n        return true;\n    }\n    @Override\n    public String toString() {\n        return String.format(\"%.2f +\u00a0%.2fi +\u00a0%.2fj +\u00a0%.2fk\", a, b, c, d).replaceAll(\"\\\\+ -\", \"- \");\n    }\n\n    public String toQuadruple() {\n        return String.format(\"(%.2f,\u00a0%.2f,\u00a0%.2f,\u00a0%.2f)\", a, b, c, d);\n    }\n\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion(1.0, 2.0, 3.0, 4.0);\n        Quaternion q1 = new Quaternion(2.0, 3.0, 4.0, 5.0);\n        Quaternion q2 = new Quaternion(3.0, 4.0, 5.0, 6.0);\n        double r = 7.0;\n        System.out.format(\"q       = %s%n\", q);\n        System.out.format(\"q1      = %s%n\", q1);\n        System.out.format(\"q2      = %s%n\", q2);\n        System.out.format(\"r       =\u00a0%.2f%n%n\", r);\n        System.out.format(\"\\u2016q\\u2016     =\u00a0%.2f%n\", q.norm());\n        System.out.format(\"-q      = %s%n\", q.negative());\n        System.out.format(\"q*      = %s%n\", q.conjugate());\n        System.out.format(\"q + r   = %s%n\", q.add(r));\n        System.out.format(\"q1 + q2 = %s%n\", q1.add(q2));\n        System.out.format(\"q \\u00d7 r   = %s%n\", q.times(r));\n        Quaternion q1q2 = q1.times(q2);\n        Quaternion q2q1 = q2.times(q1);\n        System.out.format(\"q1 \\u00d7 q2 = %s%n\", q1q2);\n        System.out.format(\"q2 \\u00d7 q1 = %s%n\", q2q1);\n        System.out.format(\"q1 \\u00d7 q2 %s q2 \\u00d7 q1%n\", (q1q2.equals(q2q1) ? \"=\" : \"\\u2260\"));\n    }\n}\n"}
{"id": 37724, "name": "Quaternion type", "source": "Translate Swift to Python: import Foundation\n\nstruct Quaternion {\n  var a, b, c, d: Double\n  \n  static let i = Quaternion(a: 0, b: 1, c: 0, d: 0)\n  static let j = Quaternion(a: 0, b: 0, c: 1, d: 0)\n  static let k = Quaternion(a: 0, b: 0, c: 0, d: 1)\n}\nextension Quaternion: Equatable {\n  static func ==(lhs: Quaternion, rhs: Quaternion) -> Bool {\n    return (lhs.a, lhs.b, lhs.c, lhs.d) == (rhs.a, rhs.b, rhs.c, rhs.d)\n  }\n}\nextension Quaternion: ExpressibleByIntegerLiteral {\n  init(integerLiteral: Double) {\n    a = integerLiteral\n    b = 0\n    c = 0\n    d = 0\n  }\n}\nextension Quaternion: Numeric {\n  var magnitude: Double {\n    return norm\n  }\n  init?<T>(exactly: T) { \n    return nil\n  }\n  public static func + (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func - (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func * (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n  public static func += (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func -= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func *= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n}\nextension Quaternion: CustomStringConvertible {\n  var description: String {\n    let formatter = NumberFormatter()\n    formatter.positivePrefix = \"+\"\n    let f: (Double) -> String = { formatter.string(from: $0 as NSNumber)! }\n    return [f(a), f(b), \"i\", f(c), \"j\", f(d), \"k\"].joined()\n  }\n}\nextension Quaternion {\n  var norm: Double {\n    return sqrt(a*a + b*b + c*c + d*d)\n  }\n  var conjugate: Quaternion {\n    return Quaternion(a: a, b: -b, c: -c, d: -d)\n  }\n  public static func + (lhs: Double, rhs: Quaternion) -> Quaternion {\n    var result = rhs\n    result.a += lhs\n    return result\n  }\n  public static func + (lhs: Quaternion, rhs: Double) -> Quaternion {\n    var result = lhs\n    result.a += rhs\n    return result\n  }\n  public static func * (lhs: Double, rhs: Quaternion) -> Quaternion {\n    return Quaternion(a: lhs*rhs.a, b: lhs*rhs.b, c: lhs*rhs.c, d: lhs*rhs.d)\n  }\n  public static func * (lhs: Quaternion, rhs: Double) -> Quaternion {\n    return Quaternion(a: lhs.a*rhs, b: lhs.b*rhs, c: lhs.c*rhs, d: lhs.d*rhs)\n  }\n  public static prefix func - (x: Quaternion) -> Quaternion {\n    return Quaternion(a: -x.a, b: -x.b, c: -x.c, d: -x.d)\n  }\n}\n\nlet q:  Quaternion = 1 + 2 * .i + 3 * .j + 4 * .k \nlet q1: Quaternion = 2 + 3 * .i + 4 * .j + 5 * .k \nlet q2: Quaternion = 3 + 4 * .i + 5 * .j + 6 * .k \nlet r: Double = 7\n\nprint(\"\"\"\n  q  = \\(q)\n  q1 = \\(q1)\n  q2 = \\(q2)\n  r = \\(r)\n  -q = \\(-q)\n  \u2016q\u2016 = \\(q.norm)\n  conjugate of q = \\(q.conjugate)\n  r + q = q + r = \\(r+q) = \\(q+r)\n  q\u2081 + q\u2082 = \\(q1 + q2) = \\(q2 + q1)\n  qr = rq = \\(q*r) = \\(r*q)\n  q\u2081q\u2082 = \\(q1 * q2)\n  q\u2082q\u2081 = \\(q2 * q1)\n  q\u2081q\u2082 \u2260 q\u2082q\u2081 is \\(q1*q2 != q2*q1)\n\"\"\")\n", "target": "from collections import namedtuple\nimport math\n\nclass Q(namedtuple('Quaternion', 'real, i, j, k')):\n    'Quaternion type: Q(real=0.0, i=0.0, j=0.0, k=0.0)' \n\n    __slots__ = () \n\n    def __new__(_cls, real=0.0, i=0.0, j=0.0, k=0.0):\n        'Defaults all parts of quaternion to zero'\n        return super().__new__(_cls, float(real), float(i), float(j), float(k))\n\n    def conjugate(self):\n        return Q(self.real, -self.i, -self.j, -self.k)\n\n    def _norm2(self):\n        return sum( x*x for x in self)\n\n    def norm(self):\n        return math.sqrt(self._norm2())\n\n    def reciprocal(self):\n        n2 = self._norm2()\n        return Q(*(x / n2 for x in self.conjugate())) \n\n    def __str__(self):\n        'Shorter form of Quaternion as string'\n        return 'Q(%g, %g, %g, %g)' % self\n\n    def __neg__(self):\n        return Q(-self.real, -self.i, -self.j, -self.k)\n\n    def __add__(self, other):\n        if type(other) == Q:\n            return Q( *(s+o for s,o in zip(self, other)) )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real + f, self.i, self.j, self.k)\n\n    def __radd__(self, other):\n        return Q.__add__(self, other)\n\n    def __mul__(self, other):\n        if type(other) == Q:\n            a1,b1,c1,d1 = self\n            a2,b2,c2,d2 = other\n            return Q(\n                 a1*a2 - b1*b2 - c1*c2 - d1*d2,\n                 a1*b2 + b1*a2 + c1*d2 - d1*c2,\n                 a1*c2 - b1*d2 + c1*a2 + d1*b2,\n                 a1*d2 + b1*c2 - c1*b2 + d1*a2 )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real * f, self.i * f, self.j * f, self.k * f)\n\n    def __rmul__(self, other):\n        return Q.__mul__(self, other)\n\n    def __truediv__(self, other):\n        if type(other) == Q:\n            return self.__mul__(other.reciprocal())\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real / f, self.i / f, self.j / f, self.k / f)\n\n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n\n    __div__, __rdiv__ = __truediv__, __rtruediv__\n\nQuaternion = Q       \n\nq  = Q(1, 2, 3, 4)\nq1 = Q(2, 3, 4, 5)\nq2 = Q(3, 4, 5, 6)\nr  = 7\n"}
{"id": 37725, "name": "Quaternion type", "source": "Translate Swift to Python: import Foundation\n\nstruct Quaternion {\n  var a, b, c, d: Double\n  \n  static let i = Quaternion(a: 0, b: 1, c: 0, d: 0)\n  static let j = Quaternion(a: 0, b: 0, c: 1, d: 0)\n  static let k = Quaternion(a: 0, b: 0, c: 0, d: 1)\n}\nextension Quaternion: Equatable {\n  static func ==(lhs: Quaternion, rhs: Quaternion) -> Bool {\n    return (lhs.a, lhs.b, lhs.c, lhs.d) == (rhs.a, rhs.b, rhs.c, rhs.d)\n  }\n}\nextension Quaternion: ExpressibleByIntegerLiteral {\n  init(integerLiteral: Double) {\n    a = integerLiteral\n    b = 0\n    c = 0\n    d = 0\n  }\n}\nextension Quaternion: Numeric {\n  var magnitude: Double {\n    return norm\n  }\n  init?<T>(exactly: T) { \n    return nil\n  }\n  public static func + (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func - (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func * (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n  public static func += (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func -= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func *= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n}\nextension Quaternion: CustomStringConvertible {\n  var description: String {\n    let formatter = NumberFormatter()\n    formatter.positivePrefix = \"+\"\n    let f: (Double) -> String = { formatter.string(from: $0 as NSNumber)! }\n    return [f(a), f(b), \"i\", f(c), \"j\", f(d), \"k\"].joined()\n  }\n}\nextension Quaternion {\n  var norm: Double {\n    return sqrt(a*a + b*b + c*c + d*d)\n  }\n  var conjugate: Quaternion {\n    return Quaternion(a: a, b: -b, c: -c, d: -d)\n  }\n  public static func + (lhs: Double, rhs: Quaternion) -> Quaternion {\n    var result = rhs\n    result.a += lhs\n    return result\n  }\n  public static func + (lhs: Quaternion, rhs: Double) -> Quaternion {\n    var result = lhs\n    result.a += rhs\n    return result\n  }\n  public static func * (lhs: Double, rhs: Quaternion) -> Quaternion {\n    return Quaternion(a: lhs*rhs.a, b: lhs*rhs.b, c: lhs*rhs.c, d: lhs*rhs.d)\n  }\n  public static func * (lhs: Quaternion, rhs: Double) -> Quaternion {\n    return Quaternion(a: lhs.a*rhs, b: lhs.b*rhs, c: lhs.c*rhs, d: lhs.d*rhs)\n  }\n  public static prefix func - (x: Quaternion) -> Quaternion {\n    return Quaternion(a: -x.a, b: -x.b, c: -x.c, d: -x.d)\n  }\n}\n\nlet q:  Quaternion = 1 + 2 * .i + 3 * .j + 4 * .k \nlet q1: Quaternion = 2 + 3 * .i + 4 * .j + 5 * .k \nlet q2: Quaternion = 3 + 4 * .i + 5 * .j + 6 * .k \nlet r: Double = 7\n\nprint(\"\"\"\n  q  = \\(q)\n  q1 = \\(q1)\n  q2 = \\(q2)\n  r = \\(r)\n  -q = \\(-q)\n  \u2016q\u2016 = \\(q.norm)\n  conjugate of q = \\(q.conjugate)\n  r + q = q + r = \\(r+q) = \\(q+r)\n  q\u2081 + q\u2082 = \\(q1 + q2) = \\(q2 + q1)\n  qr = rq = \\(q*r) = \\(r*q)\n  q\u2081q\u2082 = \\(q1 * q2)\n  q\u2082q\u2081 = \\(q2 * q1)\n  q\u2081q\u2082 \u2260 q\u2082q\u2081 is \\(q1*q2 != q2*q1)\n\"\"\")\n", "target": "from collections import namedtuple\nimport math\n\nclass Q(namedtuple('Quaternion', 'real, i, j, k')):\n    'Quaternion type: Q(real=0.0, i=0.0, j=0.0, k=0.0)' \n\n    __slots__ = () \n\n    def __new__(_cls, real=0.0, i=0.0, j=0.0, k=0.0):\n        'Defaults all parts of quaternion to zero'\n        return super().__new__(_cls, float(real), float(i), float(j), float(k))\n\n    def conjugate(self):\n        return Q(self.real, -self.i, -self.j, -self.k)\n\n    def _norm2(self):\n        return sum( x*x for x in self)\n\n    def norm(self):\n        return math.sqrt(self._norm2())\n\n    def reciprocal(self):\n        n2 = self._norm2()\n        return Q(*(x / n2 for x in self.conjugate())) \n\n    def __str__(self):\n        'Shorter form of Quaternion as string'\n        return 'Q(%g, %g, %g, %g)' % self\n\n    def __neg__(self):\n        return Q(-self.real, -self.i, -self.j, -self.k)\n\n    def __add__(self, other):\n        if type(other) == Q:\n            return Q( *(s+o for s,o in zip(self, other)) )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real + f, self.i, self.j, self.k)\n\n    def __radd__(self, other):\n        return Q.__add__(self, other)\n\n    def __mul__(self, other):\n        if type(other) == Q:\n            a1,b1,c1,d1 = self\n            a2,b2,c2,d2 = other\n            return Q(\n                 a1*a2 - b1*b2 - c1*c2 - d1*d2,\n                 a1*b2 + b1*a2 + c1*d2 - d1*c2,\n                 a1*c2 - b1*d2 + c1*a2 + d1*b2,\n                 a1*d2 + b1*c2 - c1*b2 + d1*a2 )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real * f, self.i * f, self.j * f, self.k * f)\n\n    def __rmul__(self, other):\n        return Q.__mul__(self, other)\n\n    def __truediv__(self, other):\n        if type(other) == Q:\n            return self.__mul__(other.reciprocal())\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real / f, self.i / f, self.j / f, self.k / f)\n\n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n\n    __div__, __rdiv__ = __truediv__, __rtruediv__\n\nQuaternion = Q       \n\nq  = Q(1, 2, 3, 4)\nq1 = Q(2, 3, 4, 5)\nq2 = Q(3, 4, 5, 6)\nr  = 7\n"}
{"id": 38095, "name": "Character codes", "source": "Translate Swift to C#: let c1: UnicodeScalar = \"a\"\nprintln(c1.value) \nlet c2: UnicodeScalar = \"\u03c0\"\nprintln(c2.value) \n", "target": "using System;\n\nnamespace RosettaCode.CharacterCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine((int) 'a');   \n            Console.WriteLine((char) 97);   \n        }\n    }\n}\n"}
{"id": 38097, "name": "Character codes", "source": "Translate Swift to Java: let c1: UnicodeScalar = \"a\"\nprintln(c1.value) \nlet c2: UnicodeScalar = \"\u03c0\"\nprintln(c2.value) \n", "target": "module CharacterCodes\n    {\n    @Inject Console console;\n    void run()\n        {\n        for (Char char : ['\\0', '\\d', 'A', '$', '\u00a2', '~', '\u02dc'])\n            {\n            \n            UInt32 codepoint = char.codepoint;\n\n            \n            Char fromCodePoint = codepoint.toChar();   \n\n            console.print($|Character {char.quoted()}:\\\n                           | Unicode codepoint={char.codepoint},\\\n                           | ASCII={char.ascii},\\\n                           | UTF8 bytes={char.utf8()},\\\n                           | char from codepoint={fromCodePoint.quoted()}\n                         );\n            }\n        }\n    }\n"}
{"id": 38098, "name": "Character codes", "source": "Translate Swift to Python: let c1: UnicodeScalar = \"a\"\nprintln(c1.value) \nlet c2: UnicodeScalar = \"\u03c0\"\nprintln(c2.value) \n", "target": "print ord('a') \nprint chr(97)  \n"}
{"id": 38916, "name": "Generic swap", "source": "Translate Swift to C#: func swap<T>(inout a: T, inout b: T) {\n  (a, b) = (b, a)\n}\n", "target": "static void Swap<T>(ref T a, ref T b)\n{\n    T temp = a;\n    a = b;\n    b = temp;\n}\n"}
{"id": 38918, "name": "Generic swap", "source": "Translate Swift to Java: func swap<T>(inout a: T, inout b: T) {\n  (a, b) = (b, a)\n}\n", "target": "class Pair<T> {\n    T first;\n    T second;\n}\npublic static <T> void swap(Pair<T> p) {\n   T temp = p.first;\n   p.first = p.second;\n   p.second = temp;\n}\n"}
{"id": 38919, "name": "Generic swap", "source": "Translate Swift to Python: func swap<T>(inout a: T, inout b: T) {\n  (a, b) = (b, a)\n}\n", "target": "a, b = b, a\n"}
{"id": 39428, "name": "Modular arithmetic", "source": "Translate Swift to C#: precedencegroup ExponentiationGroup {\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationGroup\n\nprotocol Ring {\n  associatedtype RingType: Numeric\n\n  var one: Self { get }\n\n  static func +(_ lhs: Self, _ rhs: Self) -> Self\n  static func *(_ lhs: Self, _ rhs: Self) -> Self\n  static func **(_ lhs: Self, _ rhs: Int) -> Self\n}\n\nextension Ring  {\n  static func **(_ lhs: Self, _ rhs: Int) -> Self {\n    var ret = lhs.one\n\n    for _ in stride(from: rhs, to: 0, by: -1) {\n      ret = ret * lhs\n    }\n\n    return ret\n  }\n}\n\nstruct ModInt: Ring {\n  typealias RingType = Int\n\n  var value: Int\n  var modulo: Int\n\n  var one: ModInt { ModInt(1, modulo: modulo) }\n\n  init(_ value: Int, modulo: Int) {\n    self.value = value\n    self.modulo = modulo\n  }\n\n  static func +(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value + rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n\n  static func *(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value * rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n}\n\nfunc f<T: Ring>(_ x: T) -> T { (x ** 100) + x + x.one }\n\nlet x = ModInt(10, modulo: 13)\nlet y = f(x)\n\nprint(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \\(y)\")\n", "target": "using System;\n\nnamespace ModularArithmetic {\n    interface IAddition<T> {\n        T Add(T rhs);\n    }\n    interface IMultiplication<T> {\n        T Multiply(T rhs);\n    }\n    interface IPower<T> {\n        T Power(int pow);\n    }\n    interface IOne<T> {\n        T One();\n    }\n\n    class ModInt : IAddition<ModInt>, IMultiplication<ModInt>, IPower<ModInt>, IOne<ModInt> {\n        private int modulo;\n\n        public ModInt(int value, int modulo) {\n            Value = value;\n            this.modulo = modulo;\n        }\n\n        public int Value { get; }\n\n        public ModInt One() {\n            return new ModInt(1, modulo);\n        }\n\n        public ModInt Add(ModInt rhs) {\n            return this + rhs;\n        }\n\n        public ModInt Multiply(ModInt rhs) {\n            return this * rhs;\n        }\n\n        public ModInt Power(int pow) {\n            return Pow(this, pow);\n        }\n\n        public override string ToString() {\n            return string.Format(\"ModInt({0}, {1})\", Value, modulo);\n        }\n\n        public static ModInt operator +(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value + rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt operator *(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value * rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt Pow(ModInt self, int p) {\n            if (p < 0) {\n                throw new ArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            ModInt pwr = self.One();\n            while (pp-- > 0) {\n                pwr *= self;\n            }\n            return pwr;\n        }\n    }\n\n    class Program {\n        static T F<T>(T x) where T : IAddition<T>, IMultiplication<T>, IPower<T>, IOne<T> {\n            return x.Power(100).Add(x).Add(x.One());\n        }\n\n        static void Main(string[] args) {\n            ModInt x = new ModInt(10, 13);\n            ModInt y = F(x);\n            Console.WriteLine(\"x ^ 100 + x + 1 for x = {0} is {1}\", x, y);\n        }\n    }\n}\n"}
{"id": 39429, "name": "Modular arithmetic", "source": "Translate Swift to C#: precedencegroup ExponentiationGroup {\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationGroup\n\nprotocol Ring {\n  associatedtype RingType: Numeric\n\n  var one: Self { get }\n\n  static func +(_ lhs: Self, _ rhs: Self) -> Self\n  static func *(_ lhs: Self, _ rhs: Self) -> Self\n  static func **(_ lhs: Self, _ rhs: Int) -> Self\n}\n\nextension Ring  {\n  static func **(_ lhs: Self, _ rhs: Int) -> Self {\n    var ret = lhs.one\n\n    for _ in stride(from: rhs, to: 0, by: -1) {\n      ret = ret * lhs\n    }\n\n    return ret\n  }\n}\n\nstruct ModInt: Ring {\n  typealias RingType = Int\n\n  var value: Int\n  var modulo: Int\n\n  var one: ModInt { ModInt(1, modulo: modulo) }\n\n  init(_ value: Int, modulo: Int) {\n    self.value = value\n    self.modulo = modulo\n  }\n\n  static func +(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value + rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n\n  static func *(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value * rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n}\n\nfunc f<T: Ring>(_ x: T) -> T { (x ** 100) + x + x.one }\n\nlet x = ModInt(10, modulo: 13)\nlet y = f(x)\n\nprint(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \\(y)\")\n", "target": "using System;\n\nnamespace ModularArithmetic {\n    interface IAddition<T> {\n        T Add(T rhs);\n    }\n    interface IMultiplication<T> {\n        T Multiply(T rhs);\n    }\n    interface IPower<T> {\n        T Power(int pow);\n    }\n    interface IOne<T> {\n        T One();\n    }\n\n    class ModInt : IAddition<ModInt>, IMultiplication<ModInt>, IPower<ModInt>, IOne<ModInt> {\n        private int modulo;\n\n        public ModInt(int value, int modulo) {\n            Value = value;\n            this.modulo = modulo;\n        }\n\n        public int Value { get; }\n\n        public ModInt One() {\n            return new ModInt(1, modulo);\n        }\n\n        public ModInt Add(ModInt rhs) {\n            return this + rhs;\n        }\n\n        public ModInt Multiply(ModInt rhs) {\n            return this * rhs;\n        }\n\n        public ModInt Power(int pow) {\n            return Pow(this, pow);\n        }\n\n        public override string ToString() {\n            return string.Format(\"ModInt({0}, {1})\", Value, modulo);\n        }\n\n        public static ModInt operator +(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value + rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt operator *(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value * rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt Pow(ModInt self, int p) {\n            if (p < 0) {\n                throw new ArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            ModInt pwr = self.One();\n            while (pp-- > 0) {\n                pwr *= self;\n            }\n            return pwr;\n        }\n    }\n\n    class Program {\n        static T F<T>(T x) where T : IAddition<T>, IMultiplication<T>, IPower<T>, IOne<T> {\n            return x.Power(100).Add(x).Add(x.One());\n        }\n\n        static void Main(string[] args) {\n            ModInt x = new ModInt(10, 13);\n            ModInt y = F(x);\n            Console.WriteLine(\"x ^ 100 + x + 1 for x = {0} is {1}\", x, y);\n        }\n    }\n}\n"}
{"id": 39432, "name": "Modular arithmetic", "source": "Translate Swift to Java: precedencegroup ExponentiationGroup {\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationGroup\n\nprotocol Ring {\n  associatedtype RingType: Numeric\n\n  var one: Self { get }\n\n  static func +(_ lhs: Self, _ rhs: Self) -> Self\n  static func *(_ lhs: Self, _ rhs: Self) -> Self\n  static func **(_ lhs: Self, _ rhs: Int) -> Self\n}\n\nextension Ring  {\n  static func **(_ lhs: Self, _ rhs: Int) -> Self {\n    var ret = lhs.one\n\n    for _ in stride(from: rhs, to: 0, by: -1) {\n      ret = ret * lhs\n    }\n\n    return ret\n  }\n}\n\nstruct ModInt: Ring {\n  typealias RingType = Int\n\n  var value: Int\n  var modulo: Int\n\n  var one: ModInt { ModInt(1, modulo: modulo) }\n\n  init(_ value: Int, modulo: Int) {\n    self.value = value\n    self.modulo = modulo\n  }\n\n  static func +(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value + rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n\n  static func *(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value * rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n}\n\nfunc f<T: Ring>(_ x: T) -> T { (x ** 100) + x + x.one }\n\nlet x = ModInt(10, modulo: 13)\nlet y = f(x)\n\nprint(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \\(y)\")\n", "target": "public class ModularArithmetic {\n    private interface Ring<T> {\n        Ring<T> plus(Ring<T> rhs);\n\n        Ring<T> times(Ring<T> rhs);\n\n        int value();\n\n        Ring<T> one();\n\n        default Ring<T> pow(int p) {\n            if (p < 0) {\n                throw new IllegalArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            Ring<T> pwr = this.one();\n            while (pp-- > 0) {\n                pwr = pwr.times(this);\n            }\n            return pwr;\n        }\n    }\n\n    private static class ModInt implements Ring<ModInt> {\n        private int value;\n        private int modulo;\n\n        private ModInt(int value, int modulo) {\n            this.value = value;\n            this.modulo = modulo;\n        }\n\n        @Override\n        public Ring<ModInt> plus(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot add an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((value + rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public Ring<ModInt> times(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot multiple an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot multiply rings with different modulus\");\n            }\n            return new ModInt((value * rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public int value() {\n            return value;\n        }\n\n        @Override\n        public Ring<ModInt> one() {\n            return new ModInt(1, modulo);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"ModInt(%d, %d)\", value, modulo);\n        }\n    }\n\n    private static <T> Ring<T> f(Ring<T> x) {\n        return x.pow(100).plus(x).plus(x.one());\n    }\n\n    public static void main(String[] args) {\n        ModInt x = new ModInt(10, 13);\n        Ring<ModInt> y = f(x);\n        System.out.print(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \");\n        System.out.println(y);\n        System.out.flush();\n    }\n}\n"}
{"id": 39433, "name": "Modular arithmetic", "source": "Translate Swift to Java: precedencegroup ExponentiationGroup {\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationGroup\n\nprotocol Ring {\n  associatedtype RingType: Numeric\n\n  var one: Self { get }\n\n  static func +(_ lhs: Self, _ rhs: Self) -> Self\n  static func *(_ lhs: Self, _ rhs: Self) -> Self\n  static func **(_ lhs: Self, _ rhs: Int) -> Self\n}\n\nextension Ring  {\n  static func **(_ lhs: Self, _ rhs: Int) -> Self {\n    var ret = lhs.one\n\n    for _ in stride(from: rhs, to: 0, by: -1) {\n      ret = ret * lhs\n    }\n\n    return ret\n  }\n}\n\nstruct ModInt: Ring {\n  typealias RingType = Int\n\n  var value: Int\n  var modulo: Int\n\n  var one: ModInt { ModInt(1, modulo: modulo) }\n\n  init(_ value: Int, modulo: Int) {\n    self.value = value\n    self.modulo = modulo\n  }\n\n  static func +(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value + rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n\n  static func *(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value * rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n}\n\nfunc f<T: Ring>(_ x: T) -> T { (x ** 100) + x + x.one }\n\nlet x = ModInt(10, modulo: 13)\nlet y = f(x)\n\nprint(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \\(y)\")\n", "target": "public class ModularArithmetic {\n    private interface Ring<T> {\n        Ring<T> plus(Ring<T> rhs);\n\n        Ring<T> times(Ring<T> rhs);\n\n        int value();\n\n        Ring<T> one();\n\n        default Ring<T> pow(int p) {\n            if (p < 0) {\n                throw new IllegalArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            Ring<T> pwr = this.one();\n            while (pp-- > 0) {\n                pwr = pwr.times(this);\n            }\n            return pwr;\n        }\n    }\n\n    private static class ModInt implements Ring<ModInt> {\n        private int value;\n        private int modulo;\n\n        private ModInt(int value, int modulo) {\n            this.value = value;\n            this.modulo = modulo;\n        }\n\n        @Override\n        public Ring<ModInt> plus(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot add an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((value + rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public Ring<ModInt> times(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot multiple an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot multiply rings with different modulus\");\n            }\n            return new ModInt((value * rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public int value() {\n            return value;\n        }\n\n        @Override\n        public Ring<ModInt> one() {\n            return new ModInt(1, modulo);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"ModInt(%d, %d)\", value, modulo);\n        }\n    }\n\n    private static <T> Ring<T> f(Ring<T> x) {\n        return x.pow(100).plus(x).plus(x.one());\n    }\n\n    public static void main(String[] args) {\n        ModInt x = new ModInt(10, 13);\n        Ring<ModInt> y = f(x);\n        System.out.print(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \");\n        System.out.println(y);\n        System.out.flush();\n    }\n}\n"}
{"id": 39434, "name": "Modular arithmetic", "source": "Translate Swift to Python: precedencegroup ExponentiationGroup {\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationGroup\n\nprotocol Ring {\n  associatedtype RingType: Numeric\n\n  var one: Self { get }\n\n  static func +(_ lhs: Self, _ rhs: Self) -> Self\n  static func *(_ lhs: Self, _ rhs: Self) -> Self\n  static func **(_ lhs: Self, _ rhs: Int) -> Self\n}\n\nextension Ring  {\n  static func **(_ lhs: Self, _ rhs: Int) -> Self {\n    var ret = lhs.one\n\n    for _ in stride(from: rhs, to: 0, by: -1) {\n      ret = ret * lhs\n    }\n\n    return ret\n  }\n}\n\nstruct ModInt: Ring {\n  typealias RingType = Int\n\n  var value: Int\n  var modulo: Int\n\n  var one: ModInt { ModInt(1, modulo: modulo) }\n\n  init(_ value: Int, modulo: Int) {\n    self.value = value\n    self.modulo = modulo\n  }\n\n  static func +(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value + rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n\n  static func *(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value * rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n}\n\nfunc f<T: Ring>(_ x: T) -> T { (x ** 100) + x + x.one }\n\nlet x = ModInt(10, modulo: 13)\nlet y = f(x)\n\nprint(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \\(y)\")\n", "target": "import operator\nimport functools\n\n@functools.total_ordering\nclass Mod:\n    __slots__ = ['val','mod']\n\n    def __init__(self, val, mod):\n        if not isinstance(val, int):\n            raise ValueError('Value must be integer')\n        if not isinstance(mod, int) or mod<=0:\n            raise ValueError('Modulo must be positive integer')\n        self.val = val % mod\n        self.mod = mod\n\n    def __repr__(self):\n        return 'Mod({}, {})'.format(self.val, self.mod)\n\n    def __int__(self):\n        return self.val\n\n    def __eq__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val==other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val == other\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val<other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val < other\n        else:\n            return NotImplemented\n\n    def _check_operand(self, other):\n        if not isinstance(other, (int, Mod)):\n            raise TypeError('Only integer and Mod operands are supported')\n        if isinstance(other, Mod) and self.mod != other.mod:\n            raise ValueError('Inconsistent modulus: {} vs. {}'.format(self.mod, other.mod))\n\n    def __pow__(self, other):\n        self._check_operand(other)\n        \n        return Mod(pow(self.val, int(other), self.mod), self.mod)\n\n    def __neg__(self):\n        return Mod(self.mod - self.val, self.mod)\n\n    def __pos__(self):\n        return self \n\n    def __abs__(self):\n        return self \n\n\n\ndef _make_op(opname):\n    op_fun = getattr(operator, opname)  \n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(self.val, int(other)) % self.mod, self.mod)\n    return op\n\ndef _make_reflected_op(opname):\n    op_fun = getattr(operator, opname)\n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(int(other), self.val) % self.mod, self.mod)\n    return op\n\n\nfor opname, reflected_opname in [('__add__', '__radd__'), ('__sub__', '__rsub__'), ('__mul__', '__rmul__')]:\n    setattr(Mod, opname, _make_op(opname))\n    setattr(Mod, reflected_opname, _make_reflected_op(opname))\n\ndef f(x):\n    return x**100+x+1\n\nprint(f(Mod(10,13)))\n\n"}
{"id": 39435, "name": "Modular arithmetic", "source": "Translate Swift to Python: precedencegroup ExponentiationGroup {\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationGroup\n\nprotocol Ring {\n  associatedtype RingType: Numeric\n\n  var one: Self { get }\n\n  static func +(_ lhs: Self, _ rhs: Self) -> Self\n  static func *(_ lhs: Self, _ rhs: Self) -> Self\n  static func **(_ lhs: Self, _ rhs: Int) -> Self\n}\n\nextension Ring  {\n  static func **(_ lhs: Self, _ rhs: Int) -> Self {\n    var ret = lhs.one\n\n    for _ in stride(from: rhs, to: 0, by: -1) {\n      ret = ret * lhs\n    }\n\n    return ret\n  }\n}\n\nstruct ModInt: Ring {\n  typealias RingType = Int\n\n  var value: Int\n  var modulo: Int\n\n  var one: ModInt { ModInt(1, modulo: modulo) }\n\n  init(_ value: Int, modulo: Int) {\n    self.value = value\n    self.modulo = modulo\n  }\n\n  static func +(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value + rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n\n  static func *(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value * rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n}\n\nfunc f<T: Ring>(_ x: T) -> T { (x ** 100) + x + x.one }\n\nlet x = ModInt(10, modulo: 13)\nlet y = f(x)\n\nprint(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \\(y)\")\n", "target": "import operator\nimport functools\n\n@functools.total_ordering\nclass Mod:\n    __slots__ = ['val','mod']\n\n    def __init__(self, val, mod):\n        if not isinstance(val, int):\n            raise ValueError('Value must be integer')\n        if not isinstance(mod, int) or mod<=0:\n            raise ValueError('Modulo must be positive integer')\n        self.val = val % mod\n        self.mod = mod\n\n    def __repr__(self):\n        return 'Mod({}, {})'.format(self.val, self.mod)\n\n    def __int__(self):\n        return self.val\n\n    def __eq__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val==other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val == other\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val<other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val < other\n        else:\n            return NotImplemented\n\n    def _check_operand(self, other):\n        if not isinstance(other, (int, Mod)):\n            raise TypeError('Only integer and Mod operands are supported')\n        if isinstance(other, Mod) and self.mod != other.mod:\n            raise ValueError('Inconsistent modulus: {} vs. {}'.format(self.mod, other.mod))\n\n    def __pow__(self, other):\n        self._check_operand(other)\n        \n        return Mod(pow(self.val, int(other), self.mod), self.mod)\n\n    def __neg__(self):\n        return Mod(self.mod - self.val, self.mod)\n\n    def __pos__(self):\n        return self \n\n    def __abs__(self):\n        return self \n\n\n\ndef _make_op(opname):\n    op_fun = getattr(operator, opname)  \n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(self.val, int(other)) % self.mod, self.mod)\n    return op\n\ndef _make_reflected_op(opname):\n    op_fun = getattr(operator, opname)\n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(int(other), self.val) % self.mod, self.mod)\n    return op\n\n\nfor opname, reflected_opname in [('__add__', '__radd__'), ('__sub__', '__rsub__'), ('__mul__', '__rmul__')]:\n    setattr(Mod, opname, _make_op(opname))\n    setattr(Mod, reflected_opname, _make_reflected_op(opname))\n\ndef f(x):\n    return x**100+x+1\n\nprint(f(Mod(10,13)))\n\n"}
{"id": 39641, "name": "String append", "source": "Translate Swift to C#: var s = \"foo\"              \ns += \"bar\"                 \nprint(s)                   \ns.appendContentsOf(\"baz\")  \nprint(s)                   \n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        string x = \"foo\";\n        x += \"bar\";\n        System.Console.WriteLine(x);\n    }\n}\n"}
{"id": 39643, "name": "String append", "source": "Translate Swift to Java: var s = \"foo\"              \ns += \"bar\"                 \nprint(s)                   \ns.appendContentsOf(\"baz\")  \nprint(s)                   \n", "target": "String sa = \"Hello\";\nsa += \", World!\";\nSystem.out.println(sa);\n\nStringBuilder ba = new StringBuilder();\nba.append(\"Hello\");\nba.append(\", World!\");\nSystem.out.println(ba.toString());\n"}
{"id": 39644, "name": "String append", "source": "Translate Swift to Python: var s = \"foo\"              \ns += \"bar\"                 \nprint(s)                   \ns.appendContentsOf(\"baz\")  \nprint(s)                   \n", "target": "\n\n\nstr = \"12345678\";\nstr += \"9!\";\nprint(str)\n"}
{"id": 39875, "name": "Count in octal", "source": "Translate Swift to C#: import Foundation\n\nfunc octalSuccessor(value: String) -> String {\n   if value.isEmpty {\n        return \"1\"\n   } else {\n     let i = value.startIndex, j = value.endIndex.predecessor()\n     switch (value[j]) {\n       case \"0\": return value[i..<j] + \"1\"\n       case \"1\": return value[i..<j] + \"2\"\n       case \"2\": return value[i..<j] + \"3\"\n       case \"3\": return value[i..<j] + \"4\"\n       case \"4\": return value[i..<j] + \"5\"\n       case \"5\": return value[i..<j] + \"6\"\n       case \"6\": return value[i..<j] + \"7\"\n       case \"7\": return octalSuccessor(value[i..<j]) + \"0\"\n       default:\n         NSException(name:\"InvalidDigit\", reason: \"InvalidOctalDigit\", userInfo: nil).raise();\n         return \"\"\n     }\n  }\n}\n\nvar n = \"0\"\nwhile strtoul(n, nil, 8) < UInt.max {\n  println(n)\n  n = octalSuccessor(n)\n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        var number = 0;\n        do\n        {\n            Console.WriteLine(Convert.ToString(number, 8));\n        } while (++number > 0);\n    }\n}\n"}
{"id": 39877, "name": "Count in octal", "source": "Translate Swift to Java: import Foundation\n\nfunc octalSuccessor(value: String) -> String {\n   if value.isEmpty {\n        return \"1\"\n   } else {\n     let i = value.startIndex, j = value.endIndex.predecessor()\n     switch (value[j]) {\n       case \"0\": return value[i..<j] + \"1\"\n       case \"1\": return value[i..<j] + \"2\"\n       case \"2\": return value[i..<j] + \"3\"\n       case \"3\": return value[i..<j] + \"4\"\n       case \"4\": return value[i..<j] + \"5\"\n       case \"5\": return value[i..<j] + \"6\"\n       case \"6\": return value[i..<j] + \"7\"\n       case \"7\": return octalSuccessor(value[i..<j]) + \"0\"\n       default:\n         NSException(name:\"InvalidDigit\", reason: \"InvalidOctalDigit\", userInfo: nil).raise();\n         return \"\"\n     }\n  }\n}\n\nvar n = \"0\"\nwhile strtoul(n, nil, 8) < UInt.max {\n  println(n)\n  n = octalSuccessor(n)\n}\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(int i = 0;i >= 0;i++){\n            System.out.println(Integer.toOctalString(i)); \n        }\n    }\n}\n"}
{"id": 39878, "name": "Count in octal", "source": "Translate Swift to Python: import Foundation\n\nfunc octalSuccessor(value: String) -> String {\n   if value.isEmpty {\n        return \"1\"\n   } else {\n     let i = value.startIndex, j = value.endIndex.predecessor()\n     switch (value[j]) {\n       case \"0\": return value[i..<j] + \"1\"\n       case \"1\": return value[i..<j] + \"2\"\n       case \"2\": return value[i..<j] + \"3\"\n       case \"3\": return value[i..<j] + \"4\"\n       case \"4\": return value[i..<j] + \"5\"\n       case \"5\": return value[i..<j] + \"6\"\n       case \"6\": return value[i..<j] + \"7\"\n       case \"7\": return octalSuccessor(value[i..<j]) + \"0\"\n       default:\n         NSException(name:\"InvalidDigit\", reason: \"InvalidOctalDigit\", userInfo: nil).raise();\n         return \"\"\n     }\n  }\n}\n\nvar n = \"0\"\nwhile strtoul(n, nil, 8) < UInt.max {\n  println(n)\n  n = octalSuccessor(n)\n}\n", "target": "import sys\nfor n in xrange(sys.maxint):\n    print oct(n)\n"}
{"id": 40428, "name": "Sum of a series", "source": "Translate Swift to C#: func sumSeries(var n: Int) -> Double {\n    var ret: Double = 0\n    \n    for i in 1...n {\n        ret += (1 / pow(Double(i), 2))\n    }\n    \n    return ret\n}\n\noutput: 1.64393456668156\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        \n\n        List<double> myList = new List<double>();\n        for (double i = 1; i < 1001; i++)\n        {\n            myList.Add(i);\n        }\n        \n\n        var sum = myList.Sum(x => 1/(x*x));\n\n        Console.WriteLine(sum);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 40430, "name": "Sum of a series", "source": "Translate Swift to Java: func sumSeries(var n: Int) -> Double {\n    var ret: Double = 0\n    \n    for i in 1...n {\n        ret += (1 / pow(Double(i), 2))\n    }\n    \n    return ret\n}\n\noutput: 1.64393456668156\n", "target": "public class Sum{\n    public static double f(double x){\n       return 1/(x*x);\n    }\n \n    public static void main(String[] args){\n       double start = 1;\n       double end = 1000;\n       double sum = 0;\n \n       for(double x = start;x <= end;x++) sum += f(x);\n \n       System.out.println(\"Sum of f(x) from \" + start + \" to \" + end +\" is \" + sum);\n    }\n}\n"}
{"id": 40431, "name": "Sum of a series", "source": "Translate Swift to Python: func sumSeries(var n: Int) -> Double {\n    var ret: Double = 0\n    \n    for i in 1...n {\n        ret += (1 / pow(Double(i), 2))\n    }\n    \n    return ret\n}\n\noutput: 1.64393456668156\n", "target": "print ( sum(1.0 / (x * x) for x in range(1, 1001)) )\n"}
{"id": 40715, "name": "Sierpinski carpet", "source": "Translate Swift to C#: import Foundation\nfunc sierpinski_carpet(n:Int) -> String {\n    func middle(str:String) -> String {\n        let spacer = str.stringByReplacingOccurrencesOfString(\"#\", withString:\" \", options:nil, range:nil)\n        return str + spacer + str\n    }\n    \n    var carpet = [\"#\"]\n    for i in 1...n {\n        let a = carpet.map{$0 + $0 + $0}\n        let b = carpet.map(middle)\n        carpet = a + b + a\n    }\n    return \"\\n\".join(carpet)\n}\n\nprintln(sierpinski_carpet(3))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static List<string> NextCarpet(List<string> carpet)\n    {\n        return carpet.Select(x => x + x + x)\n                     .Concat(carpet.Select(x => x + x.Replace('#', ' ') + x))\n                     .Concat(carpet.Select(x => x + x + x)).ToList();\n    }\n\n    static List<string> SierpinskiCarpet(int n)\n    {\n        return Enumerable.Range(1, n).Aggregate(new List<string> { \"#\" }, (carpet, _) => NextCarpet(carpet));\n    }\n\n    static void Main(string[] args)\n    {\n        foreach (string s in SierpinskiCarpet(3))\n            Console.WriteLine(s);\n    }\n}\n"}
{"id": 40717, "name": "Sierpinski carpet", "source": "Translate Swift to Java: import Foundation\nfunc sierpinski_carpet(n:Int) -> String {\n    func middle(str:String) -> String {\n        let spacer = str.stringByReplacingOccurrencesOfString(\"#\", withString:\" \", options:nil, range:nil)\n        return str + spacer + str\n    }\n    \n    var carpet = [\"#\"]\n    for i in 1...n {\n        let a = carpet.map{$0 + $0 + $0}\n        let b = carpet.map(middle)\n        carpet = a + b + a\n    }\n    return \"\\n\".join(carpet)\n}\n\nprintln(sierpinski_carpet(3))\n", "target": "public static boolean inCarpet(long x, long y) {\n    while (x!=0 && y!=0) {\n        if (x % 3 == 1 && y % 3 == 1)\n            return false;\n        x /= 3;\n        y /= 3;\n    }\n    return true;\n}\n \npublic static void carpet(final int n) {\n    final double power = Math.pow(3,n);\n    for(long i = 0; i < power; i++) {\n        for(long j = 0; j < power; j++) {\n            System.out.print(inCarpet(i, j) ? \"*\" : \" \");\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 40718, "name": "Sierpinski carpet", "source": "Translate Swift to Python: import Foundation\nfunc sierpinski_carpet(n:Int) -> String {\n    func middle(str:String) -> String {\n        let spacer = str.stringByReplacingOccurrencesOfString(\"#\", withString:\" \", options:nil, range:nil)\n        return str + spacer + str\n    }\n    \n    var carpet = [\"#\"]\n    for i in 1...n {\n        let a = carpet.map{$0 + $0 + $0}\n        let b = carpet.map(middle)\n        carpet = a + b + a\n    }\n    return \"\\n\".join(carpet)\n}\n\nprintln(sierpinski_carpet(3))\n", "target": "def setup():\n    size(729, 729)\n    fill(0)\n    background(255)\n    noStroke()\n    rect(width / 3, height / 3, width / 3, width / 3)\n    rectangles(width / 3, height / 3, width / 3)\n\ndef rectangles(x, y, s):\n    if s < 1: return\n    xc, yc = x - s, y - s\n    for row in range(3):\n        for col in range(3):\n            if not (row == 1 and col == 1):\n                xx, yy = xc + row * s, yc + col * s\n                delta = s / 3\n                rect(xx + delta, yy + delta, delta, delta)\n                rectangles(xx + s / 3, yy + s / 3, s / 3)\n"}
{"id": 41052, "name": "Associative array_Creation", "source": "Translate Swift to C#: \nvar a = [String: Int]()\n\nvar b: [String: Int] = [:]\n\n\nvar c = [String: Int](minimumCapacity: 42)\n\n\nc[\"foo\"] = 3\n\n\nvar d = [\"foo\": 2, \"bar\": 42, \"baz\": -1]\n", "target": "System.Collections.HashTable map = new System.Collections.HashTable();\nmap[\"key1\"] = \"foo\";\n"}
{"id": 41054, "name": "Associative array_Creation", "source": "Translate Swift to Java: \nvar a = [String: Int]()\n\nvar b: [String: Int] = [:]\n\n\nvar c = [String: Int](minimumCapacity: 42)\n\n\nc[\"foo\"] = 3\n\n\nvar d = [\"foo\": 2, \"bar\": 42, \"baz\": -1]\n", "target": "Map<String, Int> map = new HashMap();\nmap[\"foo\"] = 5;      \nmap[\"bar\"] = 10;\nmap[\"baz\"] = 15;\nmap[\"foo\"] = 6;      \n"}
{"id": 41055, "name": "Associative array_Creation", "source": "Translate Swift to Python: \nvar a = [String: Int]()\n\nvar b: [String: Int] = [:]\n\n\nvar c = [String: Int](minimumCapacity: 42)\n\n\nc[\"foo\"] = 3\n\n\nvar d = [\"foo\": 2, \"bar\": 42, \"baz\": -1]\n", "target": "hash = dict()  \nhash = dict(red=\"FF0000\", green=\"00FF00\", blue=\"0000FF\")\nhash = { 'key1':1, 'key2':2, }\nvalue = hash[key]\n"}
{"id": 42177, "name": "Mutual recursion", "source": "Translate Swift to C#: func F(n: Int) -> Int {\n  return n == 0 ? 1 : n - M(F(n-1))\n}\n\nfunc M(n: Int) -> Int {\n  return n == 0 ? 0 : n - F(M(n-1))\n}\n\nfor i in 0..20 {\n  print(\"\\(F(i)) \")\n}\nprintln()\nfor i in 0..20 {\n  print(\"\\(M(i)) \")\n}\nprintln()\n", "target": "namespace RosettaCode {\n    class Hofstadter {\n        static public int F(int n) {\n            int result = 1;\n            if (n > 0) {\n                result = n - M(F(n-1));\n            }\n\n            return result;\n        }\n\n        static public int M(int n) {\n            int result = 0;\n            if (n > 0) {\n                result = n - F(M(n - 1));\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 42179, "name": "Mutual recursion", "source": "Translate Swift to Java: func F(n: Int) -> Int {\n  return n == 0 ? 1 : n - M(F(n-1))\n}\n\nfunc M(n: Int) -> Int {\n  return n == 0 ? 0 : n - F(M(n-1))\n}\n\nfor i in 0..20 {\n  print(\"\\(F(i)) \")\n}\nprintln()\nfor i in 0..20 {\n  print(\"\\(M(i)) \")\n}\nprintln()\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class MutualRecursion {\n\n    public static void main(final String args[]) {\n        int max = 20;\n        System.out.printf(\"First %d values of the Female sequence:  %n\", max);\n        for (int i = 0; i < max; i++) {\n            System.out.printf(\"  f(%d) = %d%n\", i, f(i));\n        }\n        System.out.printf(\"First %d values of the Male sequence:  %n\", max);\n        for (int i = 0; i < 20; i++) {\n            System.out.printf(\"  m(%d) = %d%n\", i, m(i));\n        }\n    }\n\n    private static Map<Integer,Integer> F_MAP = new HashMap<>();\n\n    private static int f(final int n) {\n        if ( F_MAP.containsKey(n) ) {\n            return F_MAP.get(n);\n        }\n        int fn = n == 0 ? 1 : n - m(f(n - 1));\n        F_MAP.put(n, fn);\n        return fn;\n    }\n\n    private static Map<Integer,Integer> M_MAP = new HashMap<>();\n\n    private static int m(final int n) {\n        if ( M_MAP.containsKey(n) ) {\n            return M_MAP.get(n);\n        }\n        int mn = n == 0 ? 0 : n - f(m(n - 1));\n        M_MAP.put(n, mn);\n        return mn;\n    }\n     \n\n}\n"}
{"id": 42180, "name": "Mutual recursion", "source": "Translate Swift to Python: func F(n: Int) -> Int {\n  return n == 0 ? 1 : n - M(F(n-1))\n}\n\nfunc M(n: Int) -> Int {\n  return n == 0 ? 0 : n - F(M(n-1))\n}\n\nfor i in 0..20 {\n  print(\"\\(F(i)) \")\n}\nprintln()\nfor i in 0..20 {\n  print(\"\\(M(i)) \")\n}\nprintln()\n", "target": "def F(n): return 1 if n == 0 else n - M(F(n-1))\ndef M(n): return 0 if n == 0 else n - F(M(n-1))\n\nprint ([ F(n) for n in range(20) ])\nprint ([ M(n) for n in range(20) ])\n"}
{"id": 42594, "name": "Narcissistic decimal number", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public var isNarcissistic: Bool {\n    let digits = String(self).map({ Int(String($0))! })\n    let m = digits.count\n\n    guard m != 1 else {\n      return true\n    }\n\n    return digits.map({ $0.power(m) }).reduce(0, +) == self\n  }\n\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n\n}\n\nlet narcs = Array((0...).lazy.filter({ $0.isNarcissistic }).prefix(25))\n\nprint(\"First 25 narcissistic numbers are \\(narcs)\")\n", "target": "using System;\n\nnamespace Narcissistic\n{\n    class Narcissistic\n    {\n        public bool isNarcissistic(int z)\n        {\n            if (z < 0) return false;\n            string n = z.ToString();\n            int t = 0, l = n.Length;\n            foreach (char c in n)\n                t += Convert.ToInt32(Math.Pow(Convert.ToDouble(c - 48), l));\n\n            return t == z;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Narcissistic n = new Narcissistic();\n            int c = 0, x = 0;\n            while (c < 25)\n            {\n                if (n.isNarcissistic(x))\n                {\n                    if (c % 5 == 0) Console.WriteLine();\n                    Console.Write(\"{0,7} \", x);\n                    c++;\n                }\n                x++;\n            }\n            Console.WriteLine(\"\\n\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 42595, "name": "Narcissistic decimal number", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public var isNarcissistic: Bool {\n    let digits = String(self).map({ Int(String($0))! })\n    let m = digits.count\n\n    guard m != 1 else {\n      return true\n    }\n\n    return digits.map({ $0.power(m) }).reduce(0, +) == self\n  }\n\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n\n}\n\nlet narcs = Array((0...).lazy.filter({ $0.isNarcissistic }).prefix(25))\n\nprint(\"First 25 narcissistic numbers are \\(narcs)\")\n", "target": "using System;\n\nnamespace Narcissistic\n{\n    class Narcissistic\n    {\n        public bool isNarcissistic(int z)\n        {\n            if (z < 0) return false;\n            string n = z.ToString();\n            int t = 0, l = n.Length;\n            foreach (char c in n)\n                t += Convert.ToInt32(Math.Pow(Convert.ToDouble(c - 48), l));\n\n            return t == z;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Narcissistic n = new Narcissistic();\n            int c = 0, x = 0;\n            while (c < 25)\n            {\n                if (n.isNarcissistic(x))\n                {\n                    if (c % 5 == 0) Console.WriteLine();\n                    Console.Write(\"{0,7} \", x);\n                    c++;\n                }\n                x++;\n            }\n            Console.WriteLine(\"\\n\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 42598, "name": "Narcissistic decimal number", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public var isNarcissistic: Bool {\n    let digits = String(self).map({ Int(String($0))! })\n    let m = digits.count\n\n    guard m != 1 else {\n      return true\n    }\n\n    return digits.map({ $0.power(m) }).reduce(0, +) == self\n  }\n\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n\n}\n\nlet narcs = Array((0...).lazy.filter({ $0.isNarcissistic }).prefix(25))\n\nprint(\"First 25 narcissistic numbers are \\(narcs)\")\n", "target": "public class Narc{\n\tpublic static boolean isNarc(long x){\n\t\tif(x < 0) return false;\n\t\t\n\t\tString xStr = Long.toString(x);\n\t\tint m = xStr.length();\n\t\tlong sum = 0;\n\t\t\n\t\tfor(char c : xStr.toCharArray()){\n\t\t\tsum += Math.pow(Character.digit(c, 10), m);\n\t\t}\n\t\treturn sum == x;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(long x = 0, count = 0; count < 25; x++){\n\t\t\tif(isNarc(x)){\n\t\t\t\tSystem.out.print(x + \" \");\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 42599, "name": "Narcissistic decimal number", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public var isNarcissistic: Bool {\n    let digits = String(self).map({ Int(String($0))! })\n    let m = digits.count\n\n    guard m != 1 else {\n      return true\n    }\n\n    return digits.map({ $0.power(m) }).reduce(0, +) == self\n  }\n\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n\n}\n\nlet narcs = Array((0...).lazy.filter({ $0.isNarcissistic }).prefix(25))\n\nprint(\"First 25 narcissistic numbers are \\(narcs)\")\n", "target": "public class Narc{\n\tpublic static boolean isNarc(long x){\n\t\tif(x < 0) return false;\n\t\t\n\t\tString xStr = Long.toString(x);\n\t\tint m = xStr.length();\n\t\tlong sum = 0;\n\t\t\n\t\tfor(char c : xStr.toCharArray()){\n\t\t\tsum += Math.pow(Character.digit(c, 10), m);\n\t\t}\n\t\treturn sum == x;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(long x = 0, count = 0; count < 25; x++){\n\t\t\tif(isNarc(x)){\n\t\t\t\tSystem.out.print(x + \" \");\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 42600, "name": "Narcissistic decimal number", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public var isNarcissistic: Bool {\n    let digits = String(self).map({ Int(String($0))! })\n    let m = digits.count\n\n    guard m != 1 else {\n      return true\n    }\n\n    return digits.map({ $0.power(m) }).reduce(0, +) == self\n  }\n\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n\n}\n\nlet narcs = Array((0...).lazy.filter({ $0.isNarcissistic }).prefix(25))\n\nprint(\"First 25 narcissistic numbers are \\(narcs)\")\n", "target": "from __future__ import print_function\nfrom itertools import count, islice\n\ndef narcissists():\n    for digits in count(0):\n        digitpowers = [i**digits for i in range(10)]\n        for n in range(int(10**(digits-1)), 10**digits):\n            div, digitpsum = n, 0\n            while div:\n                div, mod = divmod(div, 10)\n                digitpsum += digitpowers[mod]\n            if n == digitpsum:\n                yield n\n\nfor i, n in enumerate(islice(narcissists(), 25), 1):\n    print(n, end=' ')\n    if i % 5 == 0: print() \nprint()\n"}
{"id": 42601, "name": "Narcissistic decimal number", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public var isNarcissistic: Bool {\n    let digits = String(self).map({ Int(String($0))! })\n    let m = digits.count\n\n    guard m != 1 else {\n      return true\n    }\n\n    return digits.map({ $0.power(m) }).reduce(0, +) == self\n  }\n\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n\n}\n\nlet narcs = Array((0...).lazy.filter({ $0.isNarcissistic }).prefix(25))\n\nprint(\"First 25 narcissistic numbers are \\(narcs)\")\n", "target": "from __future__ import print_function\nfrom itertools import count, islice\n\ndef narcissists():\n    for digits in count(0):\n        digitpowers = [i**digits for i in range(10)]\n        for n in range(int(10**(digits-1)), 10**digits):\n            div, digitpsum = n, 0\n            while div:\n                div, mod = divmod(div, 10)\n                digitpsum += digitpowers[mod]\n            if n == digitpsum:\n                yield n\n\nfor i, n in enumerate(islice(narcissists(), 25), 1):\n    print(n, end=' ')\n    if i % 5 == 0: print() \nprint()\n"}
{"id": 43281, "name": "First-class functions", "source": "Translate Swift to C#: import Darwin\nfunc compose<A,B,C>(f: (B) -> C, g: (A) -> B) -> (A) -> C {\n  return { f(g($0)) }\n}\nlet funclist = [ { (x: Double) in sin(x) }, { (x: Double) in cos(x) }, { (x: Double) in pow(x, 3) } ]\nlet funclisti = [ { (x: Double) in asin(x) }, { (x: Double) in acos(x) }, { (x: Double) in cbrt(x) } ]\nprintln(map(zip(funclist, funclisti)) { f, inversef in compose(f, inversef)(0.5) })\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var cube = new Func<double, double>(x => Math.Pow(x, 3.0));\n        var croot = new Func<double, double>(x => Math.Pow(x, 1 / 3.0));\n\n        var functionTuples = new[]\n        {\n            (forward: Math.Sin, backward: Math.Asin),\n            (forward: Math.Cos, backward: Math.Acos),\n            (forward: cube,     backward: croot)\n        };\n\n        foreach (var ft in functionTuples)\n        {\n            Console.WriteLine(ft.backward(ft.forward(0.5)));\n        }\n    }\n}\n"}
{"id": 43283, "name": "First-class functions", "source": "Translate Swift to Java: import Darwin\nfunc compose<A,B,C>(f: (B) -> C, g: (A) -> B) -> (A) -> C {\n  return { f(g($0)) }\n}\nlet funclist = [ { (x: Double) in sin(x) }, { (x: Double) in cos(x) }, { (x: Double) in pow(x, 3) } ]\nlet funclisti = [ { (x: Double) in asin(x) }, { (x: Double) in acos(x) }, { (x: Double) in cbrt(x) } ]\nprintln(map(zip(funclist, funclisti)) { f, inversef in compose(f, inversef)(0.5) })\n", "target": "import java.util.ArrayList;\n\npublic class FirstClass{\n\t\n\tpublic interface Function<A,B>{\n\t\tB apply(A x);\n\t}\n\t\n\tpublic static <A,B,C> Function<A, C> compose(\n\t\t\tfinal Function<B, C> f, final Function<A, B> g) {\n\t\treturn new Function<A, C>() {\n\t\t\t@Override public C apply(A x) {\n\t\t\t\treturn f.apply(g.apply(x));\n\t\t\t}\n\t\t};\n\t}\n\t \n\tpublic static void main(String[] args){\n\t\tArrayList<Function<Double, Double>> functions =\n\t\t\tnew ArrayList<Function<Double,Double>>();\n\t\t\n\t\tfunctions.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn Math.cos(x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tfunctions.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn Math.tan(x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tfunctions.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn x * x;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\n\t\tArrayList<Function<Double, Double>> inverse = new ArrayList<Function<Double,Double>>();\n\t\t\n\t\tinverse.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn Math.acos(x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tinverse.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn Math.atan(x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tinverse.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn Math.sqrt(x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tSystem.out.println(\"Compositions:\");\n\t\tfor(int i = 0; i < functions.size(); i++){\n\t\t\tSystem.out.println(compose(functions.get(i), inverse.get(i)).apply(0.5));\n\t\t}\n\t\tSystem.out.println(\"Hard-coded compositions:\");\n\t\tSystem.out.println(Math.cos(Math.acos(0.5)));\n\t\tSystem.out.println(Math.tan(Math.atan(0.5)));\n\t\tSystem.out.println(Math.pow(Math.sqrt(0.5), 2));\n\t}\n}\n"}
{"id": 43284, "name": "First-class functions", "source": "Translate Swift to Python: import Darwin\nfunc compose<A,B,C>(f: (B) -> C, g: (A) -> B) -> (A) -> C {\n  return { f(g($0)) }\n}\nlet funclist = [ { (x: Double) in sin(x) }, { (x: Double) in cos(x) }, { (x: Double) in pow(x, 3) } ]\nlet funclisti = [ { (x: Double) in asin(x) }, { (x: Double) in acos(x) }, { (x: Double) in cbrt(x) } ]\nprintln(map(zip(funclist, funclisti)) { f, inversef in compose(f, inversef)(0.5) })\n", "target": ">>> \n>>> from math import sin, cos, acos, asin\n>>> \n>>> cube = lambda x: x * x * x\n>>> croot = lambda x: x ** (1/3.0)\n>>> \n>>> \n>>> compose = lambda f1, f2: ( lambda x: f1(f2(x)) )\n>>> \n>>> funclist = [sin, cos, cube]\n>>> funclisti = [asin, acos, croot]\n>>> \n>>> [compose(inversef, f)(.5) for f, inversef in zip(funclist, funclisti)]\n[0.5, 0.4999999999999999, 0.5]\n>>>\n"}
{"id": 43606, "name": "Test a function", "source": "Translate Swift to C#: import Cocoa\nimport XCTest\n\nclass PalindromTests: XCTestCase {\n    \n    override func setUp() {\n        super.setUp()\n        \n    }\n    \n    override func tearDown() {\n        super.tearDown()\n    }\n    \n    func testPalindrome() {\n        \n        XCTAssert(isPalindrome(\"abcba\"), \"Pass\")\n        XCTAssert(isPalindrome(\"aa\"), \"Pass\")\n        XCTAssert(isPalindrome(\"a\"), \"Pass\")\n        XCTAssert(isPalindrome(\"\"), \"Pass\")\n        XCTAssert(isPalindrome(\"ab\"), \"Pass\") \n        XCTAssert(isPalindrome(\"aa\"), \"Pass\")\n        XCTAssert(isPalindrome(\"abcdba\"), \"Pass\") \n    }\n    \n    func testPalindromePerformance() {\n        \n        self.measureBlock() {\n            var _is = isPalindrome(\"abcba\")\n        }\n    }\n}\n", "target": "using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing PalindromeDetector.ConsoleApp;\n\nnamespace PalindromeDetector.VisualStudioTests\n{\n    [TestClass]\n    public class VSTests\n    {\n        [TestMethod]\n        public void PalindromeDetectorCanUnderstandPalindrome()\n        {\n            \n            bool expected = true;\n            bool actual;\n            actual = Program.IsPalindrome(\"1\");\n            Assert.AreEqual(expected, actual);\n            actual = Program.IsPalindromeNonRecursive(\"1\");\n            Assert.AreEqual(expected, actual);\n            actual = Program.IsPalindrome(\"ingirumimusnocteetconsumimurigni\");\n            Assert.AreEqual(expected, actual);\n            actual = Program.IsPalindromeNonRecursive(\"ingirumimusnocteetconsumimurigni\");\n            Assert.AreEqual(expected, actual);\n        }\n        [TestMethod]\n        public void PalindromeDetecotryCanUnderstandNonPalindrome()\n        {\n            bool notExpected = true;\n            bool actual = Program.IsPalindrome(\"ThisIsNotAPalindrome\");\n            Assert.AreNotEqual(notExpected, actual);\n            actual = Program.IsPalindromeNonRecursive(\"ThisIsNotAPalindrome\");\n            Assert.AreNotEqual(notExpected, actual);\n        }\n    }\n}\n"}
{"id": 43608, "name": "Test a function", "source": "Translate Swift to Java: import Cocoa\nimport XCTest\n\nclass PalindromTests: XCTestCase {\n    \n    override func setUp() {\n        super.setUp()\n        \n    }\n    \n    override func tearDown() {\n        super.tearDown()\n    }\n    \n    func testPalindrome() {\n        \n        XCTAssert(isPalindrome(\"abcba\"), \"Pass\")\n        XCTAssert(isPalindrome(\"aa\"), \"Pass\")\n        XCTAssert(isPalindrome(\"a\"), \"Pass\")\n        XCTAssert(isPalindrome(\"\"), \"Pass\")\n        XCTAssert(isPalindrome(\"ab\"), \"Pass\") \n        XCTAssert(isPalindrome(\"aa\"), \"Pass\")\n        XCTAssert(isPalindrome(\"abcdba\"), \"Pass\") \n    }\n    \n    func testPalindromePerformance() {\n        \n        self.measureBlock() {\n            var _is = isPalindrome(\"abcba\")\n        }\n    }\n}\n", "target": "import static ExampleClass.pali; \nimport static ExampleClass.rPali; \nimport org.junit.*;\npublic class PalindromeTest extends junit.framework.TestCase {\n    @Before\n    public void setUp(){\n        \n        \n    }\n    @After\n    public void tearDown(){\n        \n        \n    }\n\n    \n    @Test\n    public void testNonrecursivePali() throws Exception {\n        assertTrue(pali(\"abcba\"));\n        assertTrue(pali(\"aa\"));\n        assertTrue(pali(\"a\"));\n        assertTrue(pali(\"\"));\n        assertFalse(pali(\"ab\"));\n        assertFalse(pali(\"abcdba\"));\n    }\n    \n    @Test\n    public void testRecursivePali() throws Exception {\n        assertTrue(rPali(\"abcba\"));\n        assertTrue(rPali(\"aa\"));\n        assertTrue(rPali(\"a\"));\n        assertTrue(rPali(\"\"));\n        assertFalse(rPali(\"ab\"));\n        assertFalse(rPali(\"abcdba\"));\n    }\n\n    \n    @Test(expected=WhateverException.class)\n    public void except(){\n        \n    }\n}\n"}
{"id": 43609, "name": "Test a function", "source": "Translate Swift to Python: import Cocoa\nimport XCTest\n\nclass PalindromTests: XCTestCase {\n    \n    override func setUp() {\n        super.setUp()\n        \n    }\n    \n    override func tearDown() {\n        super.tearDown()\n    }\n    \n    func testPalindrome() {\n        \n        XCTAssert(isPalindrome(\"abcba\"), \"Pass\")\n        XCTAssert(isPalindrome(\"aa\"), \"Pass\")\n        XCTAssert(isPalindrome(\"a\"), \"Pass\")\n        XCTAssert(isPalindrome(\"\"), \"Pass\")\n        XCTAssert(isPalindrome(\"ab\"), \"Pass\") \n        XCTAssert(isPalindrome(\"aa\"), \"Pass\")\n        XCTAssert(isPalindrome(\"abcdba\"), \"Pass\") \n    }\n    \n    func testPalindromePerformance() {\n        \n        self.measureBlock() {\n            var _is = isPalindrome(\"abcba\")\n        }\n    }\n}\n", "target": "def is_palindrome(s):\n    \n    return s == s[::-1]\n\ndef _test():\n    import doctest\n    doctest.testmod()\n    \n\nif __name__ == \"__main__\":\n    _test()\n"}
{"id": 43993, "name": "Determine if a string is numeric", "source": "Translate Swift to C#: func isNumeric(a: String) -> Bool {\n  return Double(a) != nil\n}\n", "target": "public static bool IsNumeric(string s)\n{\n    double Result;\n    return double.TryParse(s, out Result);  \n}        \n\nstring value = \"123\";\nif (IsNumeric(value)) \n{\n  \n}\n"}
{"id": 43995, "name": "Determine if a string is numeric", "source": "Translate Swift to Java: func isNumeric(a: String) -> Bool {\n  return Double(a) != nil\n}\n", "target": "public boolean isNumeric(String input) {\n  try {\n    Integer.parseInt(input);\n    return true;\n  }\n  catch (NumberFormatException e) {\n    \n    return false;\n  }\n}\n"}
{"id": 43996, "name": "Determine if a string is numeric", "source": "Translate Swift to Python: func isNumeric(a: String) -> Bool {\n  return Double(a) != nil\n}\n", "target": "def is_numeric(s):\n    try:\n        float(s)\n        return True\n    except (ValueError, TypeError):\n        return False\n\nis_numeric('123.0')\n"}
{"id": 44562, "name": "Determine if a string is collapsible", "source": "Translate Swift to C#: let strings = [\n\t\"\",\n\t#\"\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln \"#,\n\t\"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n\t\"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n\t\"                                                   ---  Harry S Truman  \",\n\t\"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n\t\"headmistressship\",\n\t\"aardvark\",\n\t\"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\"\n]\n\nlet collapsedStrings = strings.map { $0.replacingOccurrences( of: #\"(.)\\1*\"#, with: \"$1\", options: .regularExpression)}\n\nfor (original, collapsed) in zip(strings, collapsedStrings) {\n\tprint (String(format: \"%03d \u00ab%@\u00bb\\n%03d \u00ab%@\u00bb\\n\", original.count, original, collapsed.count, collapsed))\n}\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        string[] input = {\n            \"\",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \",\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                    --- Harry S Truman  \"\n        };\n        foreach (string s in input) {\n            Console.WriteLine($\"old: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n            string c = Collapse(s);\n            Console.WriteLine($\"new: {c.Length} \u00ab\u00ab\u00ab{c}\u00bb\u00bb\u00bb\");\n        }\n    }\n\n    static string Collapse(string s) => string.IsNullOrEmpty(s) ? \"\" :\n        s[0] + new string(Range(1, s.Length - 1).Where(i => s[i] != s[i - 1]).Select(i => s[i]).ToArray());\n}\n"}
{"id": 44563, "name": "Determine if a string is collapsible", "source": "Translate Swift to C#: let strings = [\n\t\"\",\n\t#\"\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln \"#,\n\t\"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n\t\"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n\t\"                                                   ---  Harry S Truman  \",\n\t\"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n\t\"headmistressship\",\n\t\"aardvark\",\n\t\"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\"\n]\n\nlet collapsedStrings = strings.map { $0.replacingOccurrences( of: #\"(.)\\1*\"#, with: \"$1\", options: .regularExpression)}\n\nfor (original, collapsed) in zip(strings, collapsedStrings) {\n\tprint (String(format: \"%03d \u00ab%@\u00bb\\n%03d \u00ab%@\u00bb\\n\", original.count, original, collapsed.count, collapsed))\n}\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        string[] input = {\n            \"\",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \",\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                    --- Harry S Truman  \"\n        };\n        foreach (string s in input) {\n            Console.WriteLine($\"old: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n            string c = Collapse(s);\n            Console.WriteLine($\"new: {c.Length} \u00ab\u00ab\u00ab{c}\u00bb\u00bb\u00bb\");\n        }\n    }\n\n    static string Collapse(string s) => string.IsNullOrEmpty(s) ? \"\" :\n        s[0] + new string(Range(1, s.Length - 1).Where(i => s[i] != s[i - 1]).Select(i => s[i]).ToArray());\n}\n"}
{"id": 44566, "name": "Determine if a string is collapsible", "source": "Translate Swift to Java: let strings = [\n\t\"\",\n\t#\"\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln \"#,\n\t\"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n\t\"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n\t\"                                                   ---  Harry S Truman  \",\n\t\"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n\t\"headmistressship\",\n\t\"aardvark\",\n\t\"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\"\n]\n\nlet collapsedStrings = strings.map { $0.replacingOccurrences( of: #\"(.)\\1*\"#, with: \"$1\", options: .regularExpression)}\n\nfor (original, collapsed) in zip(strings, collapsedStrings) {\n\tprint (String(format: \"%03d \u00ab%@\u00bb\\n%03d \u00ab%@\u00bb\\n\", original.count, original, collapsed.count, collapsed))\n}\n", "target": "\n\npublic class StringCollapsible {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\n              \"\", \n              \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", \n              \"..1111111111111111111111111111111111111111111111111111111111111117777888\", \n              \"I never give 'em hell, I just tell the truth, and they think it's hell. \", \n              \"                                                    --- Harry S Truman  \",\n              \"122333444455555666666777777788888888999999999\",\n              \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n              \"headmistressship\"}) {\n            String result = collapse(s);\n            System.out.printf(\"old:  %2d <<<%s>>>%nnew:  %2d <<<%s>>>%n%n\", s.length(), s, result.length(), result);\n        }\n    }\n    \n    private static String collapse(String in) {\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < in.length() ; i++ ) {\n            if ( i == 0 || in.charAt(i-1) != in.charAt(i) ) {\n                sb.append(in.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 44567, "name": "Determine if a string is collapsible", "source": "Translate Swift to Java: let strings = [\n\t\"\",\n\t#\"\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln \"#,\n\t\"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n\t\"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n\t\"                                                   ---  Harry S Truman  \",\n\t\"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n\t\"headmistressship\",\n\t\"aardvark\",\n\t\"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\"\n]\n\nlet collapsedStrings = strings.map { $0.replacingOccurrences( of: #\"(.)\\1*\"#, with: \"$1\", options: .regularExpression)}\n\nfor (original, collapsed) in zip(strings, collapsedStrings) {\n\tprint (String(format: \"%03d \u00ab%@\u00bb\\n%03d \u00ab%@\u00bb\\n\", original.count, original, collapsed.count, collapsed))\n}\n", "target": "\n\npublic class StringCollapsible {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\n              \"\", \n              \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", \n              \"..1111111111111111111111111111111111111111111111111111111111111117777888\", \n              \"I never give 'em hell, I just tell the truth, and they think it's hell. \", \n              \"                                                    --- Harry S Truman  \",\n              \"122333444455555666666777777788888888999999999\",\n              \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n              \"headmistressship\"}) {\n            String result = collapse(s);\n            System.out.printf(\"old:  %2d <<<%s>>>%nnew:  %2d <<<%s>>>%n%n\", s.length(), s, result.length(), result);\n        }\n    }\n    \n    private static String collapse(String in) {\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < in.length() ; i++ ) {\n            if ( i == 0 || in.charAt(i-1) != in.charAt(i) ) {\n                sb.append(in.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 44568, "name": "Determine if a string is collapsible", "source": "Translate Swift to Python: let strings = [\n\t\"\",\n\t#\"\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln \"#,\n\t\"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n\t\"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n\t\"                                                   ---  Harry S Truman  \",\n\t\"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n\t\"headmistressship\",\n\t\"aardvark\",\n\t\"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\"\n]\n\nlet collapsedStrings = strings.map { $0.replacingOccurrences( of: #\"(.)\\1*\"#, with: \"$1\", options: .regularExpression)}\n\nfor (original, collapsed) in zip(strings, collapsedStrings) {\n\tprint (String(format: \"%03d \u00ab%@\u00bb\\n%03d \u00ab%@\u00bb\\n\", original.count, original, collapsed.count, collapsed))\n}\n", "target": "from itertools import groupby\n\ndef collapser(txt):\n    return ''.join(item for item, grp in groupby(txt))\n\nif __name__ == '__main__':\n    strings = [\n            \"\",\n            '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                   ---  Harry S Truman  \",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"aardvark\",\n            \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",\n            ]\n    for txt in strings:\n        this = \"Original\"\n        print(f\"\\n{this:14} Size: {len(txt)} \u00ab\u00ab\u00ab{txt}\u00bb\u00bb\u00bb\" )\n        this = \"Collapsed\"\n        sqz = collapser(txt)\n        print(f\"{this:>14} Size: {len(sqz)} \u00ab\u00ab\u00ab{sqz}\u00bb\u00bb\u00bb\" )\n"}
{"id": 44569, "name": "Determine if a string is collapsible", "source": "Translate Swift to Python: let strings = [\n\t\"\",\n\t#\"\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln \"#,\n\t\"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n\t\"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n\t\"                                                   ---  Harry S Truman  \",\n\t\"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n\t\"headmistressship\",\n\t\"aardvark\",\n\t\"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\"\n]\n\nlet collapsedStrings = strings.map { $0.replacingOccurrences( of: #\"(.)\\1*\"#, with: \"$1\", options: .regularExpression)}\n\nfor (original, collapsed) in zip(strings, collapsedStrings) {\n\tprint (String(format: \"%03d \u00ab%@\u00bb\\n%03d \u00ab%@\u00bb\\n\", original.count, original, collapsed.count, collapsed))\n}\n", "target": "from itertools import groupby\n\ndef collapser(txt):\n    return ''.join(item for item, grp in groupby(txt))\n\nif __name__ == '__main__':\n    strings = [\n            \"\",\n            '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                   ---  Harry S Truman  \",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"aardvark\",\n            \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",\n            ]\n    for txt in strings:\n        this = \"Original\"\n        print(f\"\\n{this:14} Size: {len(txt)} \u00ab\u00ab\u00ab{txt}\u00bb\u00bb\u00bb\" )\n        this = \"Collapsed\"\n        sqz = collapser(txt)\n        print(f\"{this:>14} Size: {len(sqz)} \u00ab\u00ab\u00ab{sqz}\u00bb\u00bb\u00bb\" )\n"}
{"id": 44774, "name": "Inheritance_Multiple", "source": "Translate Swift to C#: protocol Camera {\n    \n}\n\nprotocol Phone {\n    \n}\n\nclass CameraPhone: Camera, Phone {\n    \n}\n", "target": "interface ICamera {\n    \n}\n\nclass MobilePhone {\n    \n}\n\nclass CameraPhone: ICamera, MobilePhone {\n    \n}\n"}
{"id": 44776, "name": "Inheritance_Multiple", "source": "Translate Swift to Java: protocol Camera {\n    \n}\n\nprotocol Phone {\n    \n}\n\nclass CameraPhone: Camera, Phone {\n    \n}\n", "target": "public interface Camera{\n   \n   \n   \n}\n"}
{"id": 45133, "name": "Zero to the zero power", "source": "Translate Swift to C#: import Darwin\nprint(pow(0.0,0.0))\n", "target": "using System;\n\nnamespace ZeroToTheZeroeth\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double k = Math.Pow(0, 0);\n            Console.Write(\"0^0 is {0}\", k);           \n        }\n    }\n}\n"}
{"id": 45134, "name": "Zero to the zero power", "source": "Translate Swift to C#: import Darwin\nprint(pow(0.0,0.0))\n", "target": "using System;\n\nnamespace ZeroToTheZeroeth\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double k = Math.Pow(0, 0);\n            Console.Write(\"0^0 is {0}\", k);           \n        }\n    }\n}\n"}
{"id": 45137, "name": "Zero to the zero power", "source": "Translate Swift to Python: import Darwin\nprint(pow(0.0,0.0))\n", "target": "from decimal import Decimal\nfrom fractions import Fraction\nfrom itertools import product\n\nzeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]\nfor i, j in product(zeroes, repeat=2):\n    try:\n        ans = i**j\n    except:\n        ans = '<Exception raised>'\n    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')\n"}
{"id": 45138, "name": "Zero to the zero power", "source": "Translate Swift to Python: import Darwin\nprint(pow(0.0,0.0))\n", "target": "from decimal import Decimal\nfrom fractions import Fraction\nfrom itertools import product\n\nzeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]\nfor i, j in product(zeroes, repeat=2):\n    try:\n        ans = i**j\n    except:\n        ans = '<Exception raised>'\n    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')\n"}
{"id": 45497, "name": "Runge-Kutta method", "source": "Translate Swift to C#: import Foundation\n\nfunc rk4(dx: Double, x: Double, y: Double, f: (Double, Double) -> Double) -> Double {\n    let k1 = dx * f(x, y)\n    let k2 = dx * f(x + dx / 2, y + k1 / 2)\n    let k3 = dx * f(x + dx / 2, y + k2 / 2)\n    let k4 = dx * f(x + dx, y + k3)\n\n    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6\n}\n\nvar y = [Double]()\nvar x: Double = 0.0\nvar y2: Double = 0.0\n\nvar x0: Double = 0.0\nvar x1: Double = 10.0\nvar dx: Double = 0.1\n\nvar i = 0\nvar n = Int(1 + (x1 - x0) / dx)\n\ny.append(1)\nfor i in 1..<n {\n    y.append(rk4(dx, x: x0 + dx * (Double(i) - 1), y: y[i - 1]) { (x: Double, y: Double) -> Double in\n        return x * sqrt(y)\n    })\n}\n\nprint(\" x         y        rel. err.\")\nprint(\"------------------------------\")\n\nfor (var i = 0; i < n; i += 10) {\n    x = x0 + dx * Double(i)\n    y2 = pow(x * x / 4 + 1, 2)\n\n    print(String(format: \"%2g  %11.6g    %11.5g\", x, y[i], y[i]/y2 - 1))\n}\n", "target": "using System;\n\nnamespace RungeKutta\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            double t = 0.0;\n            double T = 10.0;\n            double dt = 0.1;\n\n            \n            int n = (int)(((T - t) / dt)) + 1;\n\n            \n            double[] y = new double[n];\n            double[] s = new double[n];\n\n            \n            double dy1;\n            double dy2;\n            double dy3;\n            double dy4;\n\n            \n            int i = 0;\n            s[i] = 0.0;\n            y[i] = 1.0;\n\n            Console.WriteLine(\" ===================================== \");\n            Console.WriteLine(\" Beging 4th Order Runge Kutta Method \");\n            Console.WriteLine(\" ===================================== \");\n\n            Console.WriteLine();\n            Console.WriteLine(\" Given the example Differential equation: \\n\");\n            Console.WriteLine(\"     y' = t*sqrt(y) \\n\");\n            Console.WriteLine(\" With the initial conditions: \\n\");\n            Console.WriteLine(\"     t0 = 0\" + \", y(0) = 1.0 \\n\");\n            Console.WriteLine(\" Whose exact solution is known to be: \\n\");\n            Console.WriteLine(\"     y(t) = 1/16*(t^2 + 4)^2 \\n\");\n            Console.WriteLine(\" Solve the given equations over the range t = 0...10 with a step value dt = 0.1 \\n\");\n            Console.WriteLine(\" Print the calculated values of y at whole numbered t's (0.0,1.0,...10.0) along with the error \\n\");\n            Console.WriteLine();\n\n            Console.WriteLine(\" y(t) \" +\"RK4\" + \" \".PadRight(18) + \"Absolute Error\");\n            Console.WriteLine(\" -------------------------------------------------\");\n            Console.WriteLine(\" y(0) \" + y[i] + \" \".PadRight(20) + (y[i] - solution(s[i])));\n\n            \n            while (i < y.Length - 1)\n            {\n\n                dy1 = dt * equation(s[i], y[i]);\n                dy2 = dt * equation(s[i] + dt / 2, y[i] + dy1 / 2);\n                dy3 = dt * equation(s[i] + dt / 2, y[i] + dy2 / 2);\n                dy4 = dt * equation(s[i] + dt, y[i] + dy3);\n\n                s[i + 1] = s[i] + dt;\n                y[i + 1] = y[i] + (dy1 + 2 * dy2 + 2 * dy3 + dy4) / 6;\n\n                double error = Math.Abs(y[i + 1] - solution(s[i + 1]));\n                double t_rounded = Math.Round(t + dt, 2);\n\n                if (t_rounded % 1 == 0)\n                {\n                    Console.WriteLine(\" y(\" + t_rounded + \")\" + \" \" + y[i + 1] + \" \".PadRight(5) + (error));\n                }\n\n                i++;\n                t += dt;\n\n            };\n\n            Console.ReadLine();\n        }\n\n        \n        public static double equation(double t, double y)\n        {\n            double y_prime;\n            return y_prime = t*Math.Sqrt(y);\n        }\n\n        \n        public static double solution(double t)\n        {\n            double actual;\n            actual = Math.Pow((Math.Pow(t, 2) + 4), 2)/16;\n            return actual;\n        }\n    }\n}\n"}
{"id": 45498, "name": "Runge-Kutta method", "source": "Translate Swift to C#: import Foundation\n\nfunc rk4(dx: Double, x: Double, y: Double, f: (Double, Double) -> Double) -> Double {\n    let k1 = dx * f(x, y)\n    let k2 = dx * f(x + dx / 2, y + k1 / 2)\n    let k3 = dx * f(x + dx / 2, y + k2 / 2)\n    let k4 = dx * f(x + dx, y + k3)\n\n    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6\n}\n\nvar y = [Double]()\nvar x: Double = 0.0\nvar y2: Double = 0.0\n\nvar x0: Double = 0.0\nvar x1: Double = 10.0\nvar dx: Double = 0.1\n\nvar i = 0\nvar n = Int(1 + (x1 - x0) / dx)\n\ny.append(1)\nfor i in 1..<n {\n    y.append(rk4(dx, x: x0 + dx * (Double(i) - 1), y: y[i - 1]) { (x: Double, y: Double) -> Double in\n        return x * sqrt(y)\n    })\n}\n\nprint(\" x         y        rel. err.\")\nprint(\"------------------------------\")\n\nfor (var i = 0; i < n; i += 10) {\n    x = x0 + dx * Double(i)\n    y2 = pow(x * x / 4 + 1, 2)\n\n    print(String(format: \"%2g  %11.6g    %11.5g\", x, y[i], y[i]/y2 - 1))\n}\n", "target": "using System;\n\nnamespace RungeKutta\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            double t = 0.0;\n            double T = 10.0;\n            double dt = 0.1;\n\n            \n            int n = (int)(((T - t) / dt)) + 1;\n\n            \n            double[] y = new double[n];\n            double[] s = new double[n];\n\n            \n            double dy1;\n            double dy2;\n            double dy3;\n            double dy4;\n\n            \n            int i = 0;\n            s[i] = 0.0;\n            y[i] = 1.0;\n\n            Console.WriteLine(\" ===================================== \");\n            Console.WriteLine(\" Beging 4th Order Runge Kutta Method \");\n            Console.WriteLine(\" ===================================== \");\n\n            Console.WriteLine();\n            Console.WriteLine(\" Given the example Differential equation: \\n\");\n            Console.WriteLine(\"     y' = t*sqrt(y) \\n\");\n            Console.WriteLine(\" With the initial conditions: \\n\");\n            Console.WriteLine(\"     t0 = 0\" + \", y(0) = 1.0 \\n\");\n            Console.WriteLine(\" Whose exact solution is known to be: \\n\");\n            Console.WriteLine(\"     y(t) = 1/16*(t^2 + 4)^2 \\n\");\n            Console.WriteLine(\" Solve the given equations over the range t = 0...10 with a step value dt = 0.1 \\n\");\n            Console.WriteLine(\" Print the calculated values of y at whole numbered t's (0.0,1.0,...10.0) along with the error \\n\");\n            Console.WriteLine();\n\n            Console.WriteLine(\" y(t) \" +\"RK4\" + \" \".PadRight(18) + \"Absolute Error\");\n            Console.WriteLine(\" -------------------------------------------------\");\n            Console.WriteLine(\" y(0) \" + y[i] + \" \".PadRight(20) + (y[i] - solution(s[i])));\n\n            \n            while (i < y.Length - 1)\n            {\n\n                dy1 = dt * equation(s[i], y[i]);\n                dy2 = dt * equation(s[i] + dt / 2, y[i] + dy1 / 2);\n                dy3 = dt * equation(s[i] + dt / 2, y[i] + dy2 / 2);\n                dy4 = dt * equation(s[i] + dt, y[i] + dy3);\n\n                s[i + 1] = s[i] + dt;\n                y[i + 1] = y[i] + (dy1 + 2 * dy2 + 2 * dy3 + dy4) / 6;\n\n                double error = Math.Abs(y[i + 1] - solution(s[i + 1]));\n                double t_rounded = Math.Round(t + dt, 2);\n\n                if (t_rounded % 1 == 0)\n                {\n                    Console.WriteLine(\" y(\" + t_rounded + \")\" + \" \" + y[i + 1] + \" \".PadRight(5) + (error));\n                }\n\n                i++;\n                t += dt;\n\n            };\n\n            Console.ReadLine();\n        }\n\n        \n        public static double equation(double t, double y)\n        {\n            double y_prime;\n            return y_prime = t*Math.Sqrt(y);\n        }\n\n        \n        public static double solution(double t)\n        {\n            double actual;\n            actual = Math.Pow((Math.Pow(t, 2) + 4), 2)/16;\n            return actual;\n        }\n    }\n}\n"}
{"id": 45501, "name": "Runge-Kutta method", "source": "Translate Swift to Java: import Foundation\n\nfunc rk4(dx: Double, x: Double, y: Double, f: (Double, Double) -> Double) -> Double {\n    let k1 = dx * f(x, y)\n    let k2 = dx * f(x + dx / 2, y + k1 / 2)\n    let k3 = dx * f(x + dx / 2, y + k2 / 2)\n    let k4 = dx * f(x + dx, y + k3)\n\n    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6\n}\n\nvar y = [Double]()\nvar x: Double = 0.0\nvar y2: Double = 0.0\n\nvar x0: Double = 0.0\nvar x1: Double = 10.0\nvar dx: Double = 0.1\n\nvar i = 0\nvar n = Int(1 + (x1 - x0) / dx)\n\ny.append(1)\nfor i in 1..<n {\n    y.append(rk4(dx, x: x0 + dx * (Double(i) - 1), y: y[i - 1]) { (x: Double, y: Double) -> Double in\n        return x * sqrt(y)\n    })\n}\n\nprint(\" x         y        rel. err.\")\nprint(\"------------------------------\")\n\nfor (var i = 0; i < n; i += 10) {\n    x = x0 + dx * Double(i)\n    y2 = pow(x * x / 4 + 1, 2)\n\n    print(String(format: \"%2g  %11.6g    %11.5g\", x, y[i], y[i]/y2 - 1))\n}\n", "target": "import static java.lang.Math.*;\nimport java.util.function.BiFunction;\n\npublic class RungeKutta {\n\n    static void runge(BiFunction<Double, Double, Double> yp_func, double[] t,\n            double[] y, double dt) {\n\n        for (int n = 0; n < t.length - 1; n++) {\n            double dy1 = dt * yp_func.apply(t[n], y[n]);\n            double dy2 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy1 / 2.0);\n            double dy3 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy2 / 2.0);\n            double dy4 = dt * yp_func.apply(t[n] + dt, y[n] + dy3);\n            t[n + 1] = t[n] + dt;\n            y[n + 1] = y[n] + (dy1 + 2.0 * (dy2 + dy3) + dy4) / 6.0;\n        }\n    }\n\n    static double calc_err(double t, double calc) {\n        double actual = pow(pow(t, 2.0) + 4.0, 2) / 16.0;\n        return abs(actual - calc);\n    }\n\n    public static void main(String[] args) {\n        double dt = 0.10;\n        double[] t_arr = new double[101];\n        double[] y_arr = new double[101];\n        y_arr[0] = 1.0;\n\n        runge((t, y) -> t * sqrt(y), t_arr, y_arr, dt);\n\n        for (int i = 0; i < t_arr.length; i++)\n            if (i % 10 == 0)\n                System.out.printf(\"y(%.1f) =\u00a0%.8f Error:\u00a0%.6f%n\",\n                        t_arr[i], y_arr[i],\n                        calc_err(t_arr[i], y_arr[i]));\n    }\n}\n"}
{"id": 45502, "name": "Runge-Kutta method", "source": "Translate Swift to Java: import Foundation\n\nfunc rk4(dx: Double, x: Double, y: Double, f: (Double, Double) -> Double) -> Double {\n    let k1 = dx * f(x, y)\n    let k2 = dx * f(x + dx / 2, y + k1 / 2)\n    let k3 = dx * f(x + dx / 2, y + k2 / 2)\n    let k4 = dx * f(x + dx, y + k3)\n\n    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6\n}\n\nvar y = [Double]()\nvar x: Double = 0.0\nvar y2: Double = 0.0\n\nvar x0: Double = 0.0\nvar x1: Double = 10.0\nvar dx: Double = 0.1\n\nvar i = 0\nvar n = Int(1 + (x1 - x0) / dx)\n\ny.append(1)\nfor i in 1..<n {\n    y.append(rk4(dx, x: x0 + dx * (Double(i) - 1), y: y[i - 1]) { (x: Double, y: Double) -> Double in\n        return x * sqrt(y)\n    })\n}\n\nprint(\" x         y        rel. err.\")\nprint(\"------------------------------\")\n\nfor (var i = 0; i < n; i += 10) {\n    x = x0 + dx * Double(i)\n    y2 = pow(x * x / 4 + 1, 2)\n\n    print(String(format: \"%2g  %11.6g    %11.5g\", x, y[i], y[i]/y2 - 1))\n}\n", "target": "import static java.lang.Math.*;\nimport java.util.function.BiFunction;\n\npublic class RungeKutta {\n\n    static void runge(BiFunction<Double, Double, Double> yp_func, double[] t,\n            double[] y, double dt) {\n\n        for (int n = 0; n < t.length - 1; n++) {\n            double dy1 = dt * yp_func.apply(t[n], y[n]);\n            double dy2 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy1 / 2.0);\n            double dy3 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy2 / 2.0);\n            double dy4 = dt * yp_func.apply(t[n] + dt, y[n] + dy3);\n            t[n + 1] = t[n] + dt;\n            y[n + 1] = y[n] + (dy1 + 2.0 * (dy2 + dy3) + dy4) / 6.0;\n        }\n    }\n\n    static double calc_err(double t, double calc) {\n        double actual = pow(pow(t, 2.0) + 4.0, 2) / 16.0;\n        return abs(actual - calc);\n    }\n\n    public static void main(String[] args) {\n        double dt = 0.10;\n        double[] t_arr = new double[101];\n        double[] y_arr = new double[101];\n        y_arr[0] = 1.0;\n\n        runge((t, y) -> t * sqrt(y), t_arr, y_arr, dt);\n\n        for (int i = 0; i < t_arr.length; i++)\n            if (i % 10 == 0)\n                System.out.printf(\"y(%.1f) =\u00a0%.8f Error:\u00a0%.6f%n\",\n                        t_arr[i], y_arr[i],\n                        calc_err(t_arr[i], y_arr[i]));\n    }\n}\n"}
{"id": 45503, "name": "Runge-Kutta method", "source": "Translate Swift to Python: import Foundation\n\nfunc rk4(dx: Double, x: Double, y: Double, f: (Double, Double) -> Double) -> Double {\n    let k1 = dx * f(x, y)\n    let k2 = dx * f(x + dx / 2, y + k1 / 2)\n    let k3 = dx * f(x + dx / 2, y + k2 / 2)\n    let k4 = dx * f(x + dx, y + k3)\n\n    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6\n}\n\nvar y = [Double]()\nvar x: Double = 0.0\nvar y2: Double = 0.0\n\nvar x0: Double = 0.0\nvar x1: Double = 10.0\nvar dx: Double = 0.1\n\nvar i = 0\nvar n = Int(1 + (x1 - x0) / dx)\n\ny.append(1)\nfor i in 1..<n {\n    y.append(rk4(dx, x: x0 + dx * (Double(i) - 1), y: y[i - 1]) { (x: Double, y: Double) -> Double in\n        return x * sqrt(y)\n    })\n}\n\nprint(\" x         y        rel. err.\")\nprint(\"------------------------------\")\n\nfor (var i = 0; i < n; i += 10) {\n    x = x0 + dx * Double(i)\n    y2 = pow(x * x / 4 + 1, 2)\n\n    print(String(format: \"%2g  %11.6g    %11.5g\", x, y[i], y[i]/y2 - 1))\n}\n", "target": "from math import sqrt\n \ndef rk4(f, x0, y0, x1, n):\n    vx = [0] * (n + 1)\n    vy = [0] * (n + 1)\n    h = (x1 - x0) / float(n)\n    vx[0] = x = x0\n    vy[0] = y = y0\n    for i in range(1, n + 1):\n        k1 = h * f(x, y)\n        k2 = h * f(x + 0.5 * h, y + 0.5 * k1)\n        k3 = h * f(x + 0.5 * h, y + 0.5 * k2)\n        k4 = h * f(x + h, y + k3)\n        vx[i] = x = x0 + i * h\n        vy[i] = y = y + (k1 + k2 + k2 + k3 + k3 + k4) / 6\n    return vx, vy\n \ndef f(x, y):\n    return x * sqrt(y)\n \nvx, vy = rk4(f, 0, 1, 10, 100)\nfor x, y in list(zip(vx, vy))[::10]:\n    print(\"%4.1f %10.5f %+12.4e\" % (x, y, y - (4 + x * x)**2 / 16))\n\n 0.0    1.00000  +0.0000e+00\n 1.0    1.56250  -1.4572e-07\n 2.0    4.00000  -9.1948e-07\n 3.0   10.56250  -2.9096e-06\n 4.0   24.99999  -6.2349e-06\n 5.0   52.56249  -1.0820e-05\n 6.0   99.99998  -1.6595e-05\n 7.0  175.56248  -2.3518e-05\n 8.0  288.99997  -3.1565e-05\n 9.0  451.56246  -4.0723e-05\n10.0  675.99995  -5.0983e-05\n"}
{"id": 45504, "name": "Runge-Kutta method", "source": "Translate Swift to Python: import Foundation\n\nfunc rk4(dx: Double, x: Double, y: Double, f: (Double, Double) -> Double) -> Double {\n    let k1 = dx * f(x, y)\n    let k2 = dx * f(x + dx / 2, y + k1 / 2)\n    let k3 = dx * f(x + dx / 2, y + k2 / 2)\n    let k4 = dx * f(x + dx, y + k3)\n\n    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6\n}\n\nvar y = [Double]()\nvar x: Double = 0.0\nvar y2: Double = 0.0\n\nvar x0: Double = 0.0\nvar x1: Double = 10.0\nvar dx: Double = 0.1\n\nvar i = 0\nvar n = Int(1 + (x1 - x0) / dx)\n\ny.append(1)\nfor i in 1..<n {\n    y.append(rk4(dx, x: x0 + dx * (Double(i) - 1), y: y[i - 1]) { (x: Double, y: Double) -> Double in\n        return x * sqrt(y)\n    })\n}\n\nprint(\" x         y        rel. err.\")\nprint(\"------------------------------\")\n\nfor (var i = 0; i < n; i += 10) {\n    x = x0 + dx * Double(i)\n    y2 = pow(x * x / 4 + 1, 2)\n\n    print(String(format: \"%2g  %11.6g    %11.5g\", x, y[i], y[i]/y2 - 1))\n}\n", "target": "from math import sqrt\n \ndef rk4(f, x0, y0, x1, n):\n    vx = [0] * (n + 1)\n    vy = [0] * (n + 1)\n    h = (x1 - x0) / float(n)\n    vx[0] = x = x0\n    vy[0] = y = y0\n    for i in range(1, n + 1):\n        k1 = h * f(x, y)\n        k2 = h * f(x + 0.5 * h, y + 0.5 * k1)\n        k3 = h * f(x + 0.5 * h, y + 0.5 * k2)\n        k4 = h * f(x + h, y + k3)\n        vx[i] = x = x0 + i * h\n        vy[i] = y = y + (k1 + k2 + k2 + k3 + k3 + k4) / 6\n    return vx, vy\n \ndef f(x, y):\n    return x * sqrt(y)\n \nvx, vy = rk4(f, 0, 1, 10, 100)\nfor x, y in list(zip(vx, vy))[::10]:\n    print(\"%4.1f %10.5f %+12.4e\" % (x, y, y - (4 + x * x)**2 / 16))\n\n 0.0    1.00000  +0.0000e+00\n 1.0    1.56250  -1.4572e-07\n 2.0    4.00000  -9.1948e-07\n 3.0   10.56250  -2.9096e-06\n 4.0   24.99999  -6.2349e-06\n 5.0   52.56249  -1.0820e-05\n 6.0   99.99998  -1.6595e-05\n 7.0  175.56248  -2.3518e-05\n 8.0  288.99997  -3.1565e-05\n 9.0  451.56246  -4.0723e-05\n10.0  675.99995  -5.0983e-05\n"}
{"id": 45754, "name": "Multiplication tables", "source": "Translate Swift to C#: import Foundation\n\nlet size = 12\n \nfunc printRow(with:Int, upto:Int) {\n    \n    print(String(repeating: \" \", count: (with-1)*4), terminator: \"\")\n\n    for i in with...upto {\n            print(String(format: \"%l4d\", i*with), terminator: \"\")\n    }\n    print()\n}\n\nprint(\"    \", terminator: \"\"); printRow( with: 1, upto: size)\nprint( String(repeating: \"\u2013\", count: (size+1)*4 ))\nfor i in 1...size {\n    print(String(format: \"%l4d\",i), terminator:\"\")\n    printRow( with: i, upto: size)\n }\n", "target": "using System;\n\nnamespace multtbl\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Write(\" X\".PadRight(4));\n            for (int i = 1; i <= 12; i++)\n                Console.Write(i.ToString(\"####\").PadLeft(4));\n\n            Console.WriteLine();\n            Console.Write(\" ___\");\n\n            for (int i = 1; i <= 12; i++)\n                Console.Write(\" ___\");\n\n            Console.WriteLine();\n            for (int row = 1; row <= 12; row++)\n            {\n                Console.Write(row.ToString(\"###\").PadLeft(3).PadRight(4));\n                for (int col = 1; col <= 12; col++)\n                {\n                    if (row <= col)\n                        Console.Write((row * col).ToString(\"###\").PadLeft(4));\n                    else\n                        Console.Write(\"\".PadLeft(4));\n                }\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine();\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 45756, "name": "Multiplication tables", "source": "Translate Swift to Java: import Foundation\n\nlet size = 12\n \nfunc printRow(with:Int, upto:Int) {\n    \n    print(String(repeating: \" \", count: (with-1)*4), terminator: \"\")\n\n    for i in with...upto {\n            print(String(format: \"%l4d\", i*with), terminator: \"\")\n    }\n    print()\n}\n\nprint(\"    \", terminator: \"\"); printRow( with: 1, upto: size)\nprint( String(repeating: \"\u2013\", count: (size+1)*4 ))\nfor i in 1...size {\n    print(String(format: \"%l4d\",i), terminator:\"\")\n    printRow( with: i, upto: size)\n }\n", "target": "public class MultiplicationTable {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 12; i++)\n            System.out.print(\"\\t\" + i);\n        \n        System.out.println();\n        for (int i = 0; i < 100; i++)\n            System.out.print(\"-\");\n        System.out.println();\n        for (int i = 1; i <= 12; i++) {\n            System.out.print(i + \"|\");\n            for(int j = 1; j <= 12; j++) {\n                System.out.print(\"\\t\");\n                if (j >= i)\n                    System.out.print(\"\\t\" + i * j);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 45757, "name": "Multiplication tables", "source": "Translate Swift to Python: import Foundation\n\nlet size = 12\n \nfunc printRow(with:Int, upto:Int) {\n    \n    print(String(repeating: \" \", count: (with-1)*4), terminator: \"\")\n\n    for i in with...upto {\n            print(String(format: \"%l4d\", i*with), terminator: \"\")\n    }\n    print()\n}\n\nprint(\"    \", terminator: \"\"); printRow( with: 1, upto: size)\nprint( String(repeating: \"\u2013\", count: (size+1)*4 ))\nfor i in 1...size {\n    print(String(format: \"%l4d\",i), terminator:\"\")\n    printRow( with: i, upto: size)\n }\n", "target": ">>> size = 12\n>>> width = len(str(size**2))\n>>> for row in range(-1,size+1):\n\tif row==0:\n\t\tprint(\"\u2500\"*width + \"\u253c\"+\"\u2500\"*((width+1)*size-1))\n\telse:\n\t\tprint(\"\".join(\"%*s%1s\" % ((width,) + ((\"x\",\"\u2502\")      if row==-1 and col==0\n\t\t\t\t\t              else (row,\"\u2502\") if row>0   and col==0\n\t\t\t\t\t              else (col,\"\")  if row==-1\n\t\t\t\t\t              else (\"\",\"\")   if row>col\n\t\t\t\t\t              else (row*col,\"\")))\n\t\t\t       for col in range(size+1)))\n\n\t\t\n  x\u2502  1   2   3   4   5   6   7   8   9  10  11  12 \n\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  1\u2502  1   2   3   4   5   6   7   8   9  10  11  12 \n  2\u2502      4   6   8  10  12  14  16  18  20  22  24 \n  3\u2502          9  12  15  18  21  24  27  30  33  36 \n  4\u2502             16  20  24  28  32  36  40  44  48 \n  5\u2502                 25  30  35  40  45  50  55  60 \n  6\u2502                     36  42  48  54  60  66  72 \n  7\u2502                         49  56  63  70  77  84 \n  8\u2502                             64  72  80  88  96 \n  9\u2502                                 81  90  99 108 \n 10\u2502                                    100 110 120 \n 11\u2502                                        121 132 \n 12\u2502                                            144 \n>>>\n"}
{"id": 46165, "name": "Comma quibbling", "source": "Translate Swift to C#: let inputs = [[], [\"ABC\"], [\"ABC\", \"DEF\"], [\"ABC\", \"DEF\", \"G\", \"H\"]]\n\nfunc quibbling(var words:[String]) {\n    if words.count == 0 {\n        println(\"{}\")\n    } else if words.count == 1 {\n        println(\"{\\(words[0])}\")\n    } else if words.count == 2 {\n        println(\"{\\(words[0]) and \\(words[1])}\")\n    } else {\n        var output = \"{\"\n        while words.count != 2 {\n            output += words.removeAtIndex(0) + \", \"\n        }\n        output += \"\\(words.removeAtIndex(0)) and \\(words.removeAtIndex(0))}\"\n        \n        println(output)\n    }\n}\n\nfor word in inputs {\n    quibbling(word)\n}\n", "target": "using System;\nusing System.Linq;\n\nnamespace CommaQuibbling\n{\n    internal static class Program\n    {\n        #region Static Members\n\tprivate static string Quibble(string[] input)\n\t{\n            return\n                String.Format(\"{{{0}}}\",\n                    String.Join(\"\",\n                        input.Reverse().Zip(\n                            new [] { \"\", \" and \" }.Concat(Enumerable.Repeat(\", \", int.MaxValue)),\n                            (x, y) => x + y).Reverse()));\n\t}\n\n\n        private static void Main()\n        {\n            Console.WriteLine( Quibble( new string[] {} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\", \"G\", \"H\"} ) );\n\n            Console.WriteLine( \"< Press Any Key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 46166, "name": "Comma quibbling", "source": "Translate Swift to C#: let inputs = [[], [\"ABC\"], [\"ABC\", \"DEF\"], [\"ABC\", \"DEF\", \"G\", \"H\"]]\n\nfunc quibbling(var words:[String]) {\n    if words.count == 0 {\n        println(\"{}\")\n    } else if words.count == 1 {\n        println(\"{\\(words[0])}\")\n    } else if words.count == 2 {\n        println(\"{\\(words[0]) and \\(words[1])}\")\n    } else {\n        var output = \"{\"\n        while words.count != 2 {\n            output += words.removeAtIndex(0) + \", \"\n        }\n        output += \"\\(words.removeAtIndex(0)) and \\(words.removeAtIndex(0))}\"\n        \n        println(output)\n    }\n}\n\nfor word in inputs {\n    quibbling(word)\n}\n", "target": "using System;\nusing System.Linq;\n\nnamespace CommaQuibbling\n{\n    internal static class Program\n    {\n        #region Static Members\n\tprivate static string Quibble(string[] input)\n\t{\n            return\n                String.Format(\"{{{0}}}\",\n                    String.Join(\"\",\n                        input.Reverse().Zip(\n                            new [] { \"\", \" and \" }.Concat(Enumerable.Repeat(\", \", int.MaxValue)),\n                            (x, y) => x + y).Reverse()));\n\t}\n\n\n        private static void Main()\n        {\n            Console.WriteLine( Quibble( new string[] {} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\", \"G\", \"H\"} ) );\n\n            Console.WriteLine( \"< Press Any Key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 46169, "name": "Comma quibbling", "source": "Translate Swift to Java: let inputs = [[], [\"ABC\"], [\"ABC\", \"DEF\"], [\"ABC\", \"DEF\", \"G\", \"H\"]]\n\nfunc quibbling(var words:[String]) {\n    if words.count == 0 {\n        println(\"{}\")\n    } else if words.count == 1 {\n        println(\"{\\(words[0])}\")\n    } else if words.count == 2 {\n        println(\"{\\(words[0]) and \\(words[1])}\")\n    } else {\n        var output = \"{\"\n        while words.count != 2 {\n            output += words.removeAtIndex(0) + \", \"\n        }\n        output += \"\\(words.removeAtIndex(0)) and \\(words.removeAtIndex(0))}\"\n        \n        println(output)\n    }\n}\n\nfor word in inputs {\n    quibbling(word)\n}\n", "target": "public class Quibbler {\n\n\tpublic static String quibble(String[] words) {\n\t\tString qText = \"{\";\n\t\tfor(int wIndex = 0; wIndex < words.length; wIndex++) {\n\t\t\tqText += words[wIndex] + (wIndex == words.length-1 ? \"\" : \n\t\t\t\t\t\t  wIndex == words.length-2 ? \" and \" :\n\t\t\t\t\t\t  \", \";\n\t\t}\n\t\tqText += \"}\";\n\t\treturn qText;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(quibble(new String[]{}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\", \"H\"}));\n\t}\n}\n"}
{"id": 46170, "name": "Comma quibbling", "source": "Translate Swift to Java: let inputs = [[], [\"ABC\"], [\"ABC\", \"DEF\"], [\"ABC\", \"DEF\", \"G\", \"H\"]]\n\nfunc quibbling(var words:[String]) {\n    if words.count == 0 {\n        println(\"{}\")\n    } else if words.count == 1 {\n        println(\"{\\(words[0])}\")\n    } else if words.count == 2 {\n        println(\"{\\(words[0]) and \\(words[1])}\")\n    } else {\n        var output = \"{\"\n        while words.count != 2 {\n            output += words.removeAtIndex(0) + \", \"\n        }\n        output += \"\\(words.removeAtIndex(0)) and \\(words.removeAtIndex(0))}\"\n        \n        println(output)\n    }\n}\n\nfor word in inputs {\n    quibbling(word)\n}\n", "target": "public class Quibbler {\n\n\tpublic static String quibble(String[] words) {\n\t\tString qText = \"{\";\n\t\tfor(int wIndex = 0; wIndex < words.length; wIndex++) {\n\t\t\tqText += words[wIndex] + (wIndex == words.length-1 ? \"\" : \n\t\t\t\t\t\t  wIndex == words.length-2 ? \" and \" :\n\t\t\t\t\t\t  \", \";\n\t\t}\n\t\tqText += \"}\";\n\t\treturn qText;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(quibble(new String[]{}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\", \"H\"}));\n\t}\n}\n"}
{"id": 46171, "name": "Comma quibbling", "source": "Translate Swift to Python: let inputs = [[], [\"ABC\"], [\"ABC\", \"DEF\"], [\"ABC\", \"DEF\", \"G\", \"H\"]]\n\nfunc quibbling(var words:[String]) {\n    if words.count == 0 {\n        println(\"{}\")\n    } else if words.count == 1 {\n        println(\"{\\(words[0])}\")\n    } else if words.count == 2 {\n        println(\"{\\(words[0]) and \\(words[1])}\")\n    } else {\n        var output = \"{\"\n        while words.count != 2 {\n            output += words.removeAtIndex(0) + \", \"\n        }\n        output += \"\\(words.removeAtIndex(0)) and \\(words.removeAtIndex(0))}\"\n        \n        println(output)\n    }\n}\n\nfor word in inputs {\n    quibbling(word)\n}\n", "target": "fun quibble(s):\n    let result = s.join(' and ').replace(|| and ||, \", \", length(s) - 1)\n    return \"{ $result }\"\n\nlet s = [\n    []\n    [\"ABC\"]\n    [\"ABC\", \"DEF\"]\n    [\"ABC\", \"DEF\", \"G\", \"H\"]\n]\n\nfor i in s:\n    print(quibble i)\n"}
{"id": 46172, "name": "Comma quibbling", "source": "Translate Swift to Python: let inputs = [[], [\"ABC\"], [\"ABC\", \"DEF\"], [\"ABC\", \"DEF\", \"G\", \"H\"]]\n\nfunc quibbling(var words:[String]) {\n    if words.count == 0 {\n        println(\"{}\")\n    } else if words.count == 1 {\n        println(\"{\\(words[0])}\")\n    } else if words.count == 2 {\n        println(\"{\\(words[0]) and \\(words[1])}\")\n    } else {\n        var output = \"{\"\n        while words.count != 2 {\n            output += words.removeAtIndex(0) + \", \"\n        }\n        output += \"\\(words.removeAtIndex(0)) and \\(words.removeAtIndex(0))}\"\n        \n        println(output)\n    }\n}\n\nfor word in inputs {\n    quibbling(word)\n}\n", "target": "fun quibble(s):\n    let result = s.join(' and ').replace(|| and ||, \", \", length(s) - 1)\n    return \"{ $result }\"\n\nlet s = [\n    []\n    [\"ABC\"]\n    [\"ABC\", \"DEF\"]\n    [\"ABC\", \"DEF\", \"G\", \"H\"]\n]\n\nfor i in s:\n    print(quibble i)\n"}
{"id": 46659, "name": "Count the coins", "source": "Translate Swift to C#: import BigInt\n\nfunc countCoins(amountCents cents: Int, coins: [Int]) -> BigInt {\n  let cycle = coins.filter({ $0 <= cents }).map({ $0 + 1 }).max()! * coins.count\n  var table = [BigInt](repeating: 0, count: cycle)\n\n  for x in 0..<coins.count {\n    table[x] = 1\n  }\n\n  var pos = coins.count\n\n  for s in 1..<cents+1 {\n    for i in 0..<coins.count {\n      if i == 0 && pos >= cycle {\n        pos = 0\n      }\n\n      if coins[i] <= s {\n        let q = pos - coins[i] * coins.count\n        table[pos] = q >= 0 ? table[q] : table[q + cycle]\n      }\n\n      if i != 0 {\n        table[pos] += table[pos - 1]\n      }\n\n      pos += 1\n    }\n  }\n\n  return table[pos - 1]\n}\n\nlet usCoins = [100, 50, 25, 10, 5, 1]\nlet euCoins = [200, 100, 50, 20, 10, 5, 2, 1]\n\nfor set in [usCoins, euCoins] {\n  print(countCoins(amountCents: 100, coins: Array(set.dropFirst(2))))\n  print(countCoins(amountCents: 100000, coins: set))\n  print(countCoins(amountCents: 1000000, coins: set))\n  print(countCoins(amountCents: 10000000, coins: set))\n  print()\n}\n", "target": "    \n    class Program\n    {\n        static long Count(int[] C, int m, int n)\n        {\n            var table = new long[n + 1];\n            table[0] = 1;\n            for (int i = 0; i < m; i++)\n                for (int j = C[i]; j <= n; j++)\n                    table[j] += table[j - C[i]];\n            return table[n];\n        }\n        static void Main(string[] args)\n        {\n            var C = new int[] { 1, 5, 10, 25 };\n            int m = C.Length;\n            int n = 100;\n            Console.WriteLine(Count(C, m, n));  \n            Console.ReadLine();\n        }\n    }\n"}
{"id": 46660, "name": "Count the coins", "source": "Translate Swift to C#: import BigInt\n\nfunc countCoins(amountCents cents: Int, coins: [Int]) -> BigInt {\n  let cycle = coins.filter({ $0 <= cents }).map({ $0 + 1 }).max()! * coins.count\n  var table = [BigInt](repeating: 0, count: cycle)\n\n  for x in 0..<coins.count {\n    table[x] = 1\n  }\n\n  var pos = coins.count\n\n  for s in 1..<cents+1 {\n    for i in 0..<coins.count {\n      if i == 0 && pos >= cycle {\n        pos = 0\n      }\n\n      if coins[i] <= s {\n        let q = pos - coins[i] * coins.count\n        table[pos] = q >= 0 ? table[q] : table[q + cycle]\n      }\n\n      if i != 0 {\n        table[pos] += table[pos - 1]\n      }\n\n      pos += 1\n    }\n  }\n\n  return table[pos - 1]\n}\n\nlet usCoins = [100, 50, 25, 10, 5, 1]\nlet euCoins = [200, 100, 50, 20, 10, 5, 2, 1]\n\nfor set in [usCoins, euCoins] {\n  print(countCoins(amountCents: 100, coins: Array(set.dropFirst(2))))\n  print(countCoins(amountCents: 100000, coins: set))\n  print(countCoins(amountCents: 1000000, coins: set))\n  print(countCoins(amountCents: 10000000, coins: set))\n  print()\n}\n", "target": "    \n    class Program\n    {\n        static long Count(int[] C, int m, int n)\n        {\n            var table = new long[n + 1];\n            table[0] = 1;\n            for (int i = 0; i < m; i++)\n                for (int j = C[i]; j <= n; j++)\n                    table[j] += table[j - C[i]];\n            return table[n];\n        }\n        static void Main(string[] args)\n        {\n            var C = new int[] { 1, 5, 10, 25 };\n            int m = C.Length;\n            int n = 100;\n            Console.WriteLine(Count(C, m, n));  \n            Console.ReadLine();\n        }\n    }\n"}
{"id": 46663, "name": "Count the coins", "source": "Translate Swift to Java: import BigInt\n\nfunc countCoins(amountCents cents: Int, coins: [Int]) -> BigInt {\n  let cycle = coins.filter({ $0 <= cents }).map({ $0 + 1 }).max()! * coins.count\n  var table = [BigInt](repeating: 0, count: cycle)\n\n  for x in 0..<coins.count {\n    table[x] = 1\n  }\n\n  var pos = coins.count\n\n  for s in 1..<cents+1 {\n    for i in 0..<coins.count {\n      if i == 0 && pos >= cycle {\n        pos = 0\n      }\n\n      if coins[i] <= s {\n        let q = pos - coins[i] * coins.count\n        table[pos] = q >= 0 ? table[q] : table[q + cycle]\n      }\n\n      if i != 0 {\n        table[pos] += table[pos - 1]\n      }\n\n      pos += 1\n    }\n  }\n\n  return table[pos - 1]\n}\n\nlet usCoins = [100, 50, 25, 10, 5, 1]\nlet euCoins = [200, 100, 50, 20, 10, 5, 2, 1]\n\nfor set in [usCoins, euCoins] {\n  print(countCoins(amountCents: 100, coins: Array(set.dropFirst(2))))\n  print(countCoins(amountCents: 100000, coins: set))\n  print(countCoins(amountCents: 1000000, coins: set))\n  print(countCoins(amountCents: 10000000, coins: set))\n  print()\n}\n", "target": "import java.util.Arrays;\nimport java.math.BigInteger;\n\nclass CountTheCoins {\n    private static BigInteger countChanges(int amount, int[] coins){\n        final int n = coins.length;\n        int cycle = 0;\n        for (int c : coins)\n            if (c <= amount && c >= cycle)\n                cycle = c + 1;\n        cycle *= n;\n        BigInteger[] table = new BigInteger[cycle];\n        Arrays.fill(table, 0, n, BigInteger.ONE);\n        Arrays.fill(table, n, cycle, BigInteger.ZERO);\n\n        int pos = n;\n        for (int s = 1; s <= amount; s++) {\n            for (int i = 0; i < n; i++) {\n                if (i == 0 && pos >= cycle)\n                    pos = 0;\n                if (coins[i] <= s) {\n                    final int q = pos - (coins[i] * n);\n                    table[pos] = (q >= 0) ? table[q] : table[q + cycle];\n                }\n                if (i != 0)\n                    table[pos] = table[pos].add(table[pos - 1]);\n                pos++;\n            }\n        }\n\n        return table[pos - 1];\n    }\n\n    public static void main(String[] args) {\n        final int[][] coinsUsEu = {{100, 50, 25, 10, 5, 1},\n                                   {200, 100, 50, 20, 10, 5, 2, 1}};\n\n        for (int[] coins : coinsUsEu) {\n            System.out.println(countChanges(     100,\n                Arrays.copyOfRange(coins, 2, coins.length)));\n            System.out.println(countChanges(  100000, coins));\n            System.out.println(countChanges( 1000000, coins));\n            System.out.println(countChanges(10000000, coins) + \"\\n\");\n        }\n    }\n}\n"}
{"id": 46664, "name": "Count the coins", "source": "Translate Swift to Java: import BigInt\n\nfunc countCoins(amountCents cents: Int, coins: [Int]) -> BigInt {\n  let cycle = coins.filter({ $0 <= cents }).map({ $0 + 1 }).max()! * coins.count\n  var table = [BigInt](repeating: 0, count: cycle)\n\n  for x in 0..<coins.count {\n    table[x] = 1\n  }\n\n  var pos = coins.count\n\n  for s in 1..<cents+1 {\n    for i in 0..<coins.count {\n      if i == 0 && pos >= cycle {\n        pos = 0\n      }\n\n      if coins[i] <= s {\n        let q = pos - coins[i] * coins.count\n        table[pos] = q >= 0 ? table[q] : table[q + cycle]\n      }\n\n      if i != 0 {\n        table[pos] += table[pos - 1]\n      }\n\n      pos += 1\n    }\n  }\n\n  return table[pos - 1]\n}\n\nlet usCoins = [100, 50, 25, 10, 5, 1]\nlet euCoins = [200, 100, 50, 20, 10, 5, 2, 1]\n\nfor set in [usCoins, euCoins] {\n  print(countCoins(amountCents: 100, coins: Array(set.dropFirst(2))))\n  print(countCoins(amountCents: 100000, coins: set))\n  print(countCoins(amountCents: 1000000, coins: set))\n  print(countCoins(amountCents: 10000000, coins: set))\n  print()\n}\n", "target": "import java.util.Arrays;\nimport java.math.BigInteger;\n\nclass CountTheCoins {\n    private static BigInteger countChanges(int amount, int[] coins){\n        final int n = coins.length;\n        int cycle = 0;\n        for (int c : coins)\n            if (c <= amount && c >= cycle)\n                cycle = c + 1;\n        cycle *= n;\n        BigInteger[] table = new BigInteger[cycle];\n        Arrays.fill(table, 0, n, BigInteger.ONE);\n        Arrays.fill(table, n, cycle, BigInteger.ZERO);\n\n        int pos = n;\n        for (int s = 1; s <= amount; s++) {\n            for (int i = 0; i < n; i++) {\n                if (i == 0 && pos >= cycle)\n                    pos = 0;\n                if (coins[i] <= s) {\n                    final int q = pos - (coins[i] * n);\n                    table[pos] = (q >= 0) ? table[q] : table[q + cycle];\n                }\n                if (i != 0)\n                    table[pos] = table[pos].add(table[pos - 1]);\n                pos++;\n            }\n        }\n\n        return table[pos - 1];\n    }\n\n    public static void main(String[] args) {\n        final int[][] coinsUsEu = {{100, 50, 25, 10, 5, 1},\n                                   {200, 100, 50, 20, 10, 5, 2, 1}};\n\n        for (int[] coins : coinsUsEu) {\n            System.out.println(countChanges(     100,\n                Arrays.copyOfRange(coins, 2, coins.length)));\n            System.out.println(countChanges(  100000, coins));\n            System.out.println(countChanges( 1000000, coins));\n            System.out.println(countChanges(10000000, coins) + \"\\n\");\n        }\n    }\n}\n"}
{"id": 46665, "name": "Count the coins", "source": "Translate Swift to Python: import BigInt\n\nfunc countCoins(amountCents cents: Int, coins: [Int]) -> BigInt {\n  let cycle = coins.filter({ $0 <= cents }).map({ $0 + 1 }).max()! * coins.count\n  var table = [BigInt](repeating: 0, count: cycle)\n\n  for x in 0..<coins.count {\n    table[x] = 1\n  }\n\n  var pos = coins.count\n\n  for s in 1..<cents+1 {\n    for i in 0..<coins.count {\n      if i == 0 && pos >= cycle {\n        pos = 0\n      }\n\n      if coins[i] <= s {\n        let q = pos - coins[i] * coins.count\n        table[pos] = q >= 0 ? table[q] : table[q + cycle]\n      }\n\n      if i != 0 {\n        table[pos] += table[pos - 1]\n      }\n\n      pos += 1\n    }\n  }\n\n  return table[pos - 1]\n}\n\nlet usCoins = [100, 50, 25, 10, 5, 1]\nlet euCoins = [200, 100, 50, 20, 10, 5, 2, 1]\n\nfor set in [usCoins, euCoins] {\n  print(countCoins(amountCents: 100, coins: Array(set.dropFirst(2))))\n  print(countCoins(amountCents: 100000, coins: set))\n  print(countCoins(amountCents: 1000000, coins: set))\n  print(countCoins(amountCents: 10000000, coins: set))\n  print()\n}\n", "target": "def changes(amount, coins):\n    ways = [0] * (amount + 1)\n    ways[0] = 1\n    for coin in coins:\n        for j in xrange(coin, amount + 1):\n            ways[j] += ways[j - coin]\n    return ways[amount]\n\nprint changes(100, [1, 5, 10, 25])\nprint changes(100000, [1, 5, 10, 25, 50, 100])\n"}
{"id": 46666, "name": "Count the coins", "source": "Translate Swift to Python: import BigInt\n\nfunc countCoins(amountCents cents: Int, coins: [Int]) -> BigInt {\n  let cycle = coins.filter({ $0 <= cents }).map({ $0 + 1 }).max()! * coins.count\n  var table = [BigInt](repeating: 0, count: cycle)\n\n  for x in 0..<coins.count {\n    table[x] = 1\n  }\n\n  var pos = coins.count\n\n  for s in 1..<cents+1 {\n    for i in 0..<coins.count {\n      if i == 0 && pos >= cycle {\n        pos = 0\n      }\n\n      if coins[i] <= s {\n        let q = pos - coins[i] * coins.count\n        table[pos] = q >= 0 ? table[q] : table[q + cycle]\n      }\n\n      if i != 0 {\n        table[pos] += table[pos - 1]\n      }\n\n      pos += 1\n    }\n  }\n\n  return table[pos - 1]\n}\n\nlet usCoins = [100, 50, 25, 10, 5, 1]\nlet euCoins = [200, 100, 50, 20, 10, 5, 2, 1]\n\nfor set in [usCoins, euCoins] {\n  print(countCoins(amountCents: 100, coins: Array(set.dropFirst(2))))\n  print(countCoins(amountCents: 100000, coins: set))\n  print(countCoins(amountCents: 1000000, coins: set))\n  print(countCoins(amountCents: 10000000, coins: set))\n  print()\n}\n", "target": "def changes(amount, coins):\n    ways = [0] * (amount + 1)\n    ways[0] = 1\n    for coin in coins:\n        for j in xrange(coin, amount + 1):\n            ways[j] += ways[j - coin]\n    return ways[amount]\n\nprint changes(100, [1, 5, 10, 25])\nprint changes(100000, [1, 5, 10, 25, 50, 100])\n"}
{"id": 47136, "name": "Ackermann function", "source": "Translate Swift to C#: func ackerman(m:Int, n:Int) -> Int {\n    if m == 0 {\n        return n+1\n    } else if n == 0 {\n        return ackerman(m-1, 1)\n    } else {\n        return ackerman(m-1, ackerman(m, n-1))\n    }\n}\n", "target": "using System;\nclass Program\n{\n    public static long Ackermann(long m, long n)\n    {\n        if(m > 0)\n        {\n            if (n > 0)\n                return Ackermann(m - 1, Ackermann(m, n - 1));\n            else if (n == 0)\n                return Ackermann(m - 1, 1);\n        }\n        else if(m == 0)\n        {\n            if(n >= 0) \n                return n + 1;\n        }\n\n        throw new System.ArgumentOutOfRangeException();\n    }\n    \n    static void Main()\n    {\n        for (long m = 0; m <= 3; ++m)\n        {\n            for (long n = 0; n <= 4; ++n)\n            {\n                Console.WriteLine(\"Ackermann({0}, {1}) = {2}\", m, n, Ackermann(m, n));\n            }\n        }\n    }\n}\n"}
{"id": 47138, "name": "Ackermann function", "source": "Translate Swift to Java: func ackerman(m:Int, n:Int) -> Int {\n    if m == 0 {\n        return n+1\n    } else if n == 0 {\n        return ackerman(m-1, 1)\n    } else {\n        return ackerman(m-1, ackerman(m, n-1))\n    }\n}\n", "target": "import java.math.BigInteger;\n\npublic static BigInteger ack(BigInteger m, BigInteger n) {\n    return m.equals(BigInteger.ZERO)\n            ? n.add(BigInteger.ONE)\n            : ack(m.subtract(BigInteger.ONE),\n                        n.equals(BigInteger.ZERO) ? BigInteger.ONE : ack(m, n.subtract(BigInteger.ONE)));\n}\n"}
{"id": 47139, "name": "Ackermann function", "source": "Translate Swift to Python: func ackerman(m:Int, n:Int) -> Int {\n    if m == 0 {\n        return n+1\n    } else if n == 0 {\n        return ackerman(m-1, 1)\n    } else {\n        return ackerman(m-1, ackerman(m, n-1))\n    }\n}\n", "target": "from __future__ import print_function\n\ndef setup():\n    for m in range(4):\n        for n in range(7):\n            print(\"{} \".format(ackermann(m, n)), end = \"\")\n        print()\n    \n\ndef ackermann(m, n):\n    if m == 0:\n        return n + 1\n    elif m > 0 and n == 0:\n        return ackermann(m - 1, 1)\n    else:\n        return ackermann(m - 1, ackermann(m, n - 1))\n"}
{"id": 47404, "name": "Enumerations", "source": "Translate Swift to C#: enum Fruit {\n    case Apple\n    case Banana\n    case Cherry\n}\n\nenum Fruit {\n    case Apple, Banana, Cherry\n}\n \nenum Season : Int {\n    case Winter = 1\n    case Spring = 2\n    case Summer = 3\n    case Autumn = 4\n}\n", "target": "enum fruits { apple, banana, cherry }\n\nenum fruits { apple = 0, banana = 1, cherry = 2 }\n\nenum fruits : int { apple = 0, banana = 1, cherry = 2 }\n\n[FlagsAttribute]\nenum Colors { Red = 1, Green = 2, Blue = 4, Yellow = 8 }\n"}
{"id": 47406, "name": "Enumerations", "source": "Translate Swift to Java: enum Fruit {\n    case Apple\n    case Banana\n    case Cherry\n}\n\nenum Fruit {\n    case Apple, Banana, Cherry\n}\n \nenum Season : Int {\n    case Winter = 1\n    case Spring = 2\n    case Summer = 3\n    case Autumn = 4\n}\n", "target": "enum Fruits{\n   APPLE, BANANA, CHERRY\n}\n"}
{"id": 47407, "name": "Enumerations", "source": "Translate Swift to Python: enum Fruit {\n    case Apple\n    case Banana\n    case Cherry\n}\n\nenum Fruit {\n    case Apple, Banana, Cherry\n}\n \nenum Season : Int {\n    case Winter = 1\n    case Spring = 2\n    case Summer = 3\n    case Autumn = 4\n}\n", "target": ">>> from enum import Enum\n>>> Contact = Enum('Contact', 'FIRST_NAME, LAST_NAME, PHONE')\n>>> Contact.__members__\nmappingproxy(OrderedDict([('FIRST_NAME', <Contact.FIRST_NAME: 1>), ('LAST_NAME', <Contact.LAST_NAME: 2>), ('PHONE', <Contact.PHONE: 3>)]))\n>>> \n>>> \n>>> class Contact2(Enum):\n\tFIRST_NAME = 1\n\tLAST_NAME = 2\n\tPHONE = 3\n\n\t\n>>> Contact2.__members__\nmappingproxy(OrderedDict([('FIRST_NAME', <Contact2.FIRST_NAME: 1>), ('LAST_NAME', <Contact2.LAST_NAME: 2>), ('PHONE', <Contact2.PHONE: 3>)]))\n>>>\n"}
{"id": 47940, "name": "Hello world_Text", "source": "Translate Swift to C#: print(\"Hello world!\")\n", "target": "Using System;\nnamespace HelloWorld {\n  class Program\n  {\n    static void Main()\n    {\n      Console.Writeln(\"Hello World!\");\n    }\n  }\n}\n"}
{"id": 47942, "name": "Hello world_Text", "source": "Translate Swift to Java: print(\"Hello world!\")\n", "target": "module HelloWorld\n    {\n    void run()\n        {\n        @Inject Console console;\n        console.print(\"Hello World!\");\n        }\n    }\n"}
{"id": 48161, "name": "Hash from two arrays", "source": "Translate Swift to C#: let keys = [\"a\",\"b\",\"c\"]\nlet vals = [1,2,3]\nvar hash = [String: Int]()\nfor (key, val) in zip(keys, vals) {\n  hash[key] = val\n}\n", "target": "static class Program\n{\n    static void Main()\n    {\n        System.Collections.Hashtable h = new System.Collections.Hashtable();\n\n        string[] keys = { \"foo\", \"bar\", \"val\" };\n        string[] values = { \"little\", \"miss\", \"muffet\" };\n\n        System.Diagnostics.Trace.Assert(keys.Length == values.Length, \"Arrays are not same length.\");\n\n        for (int i = 0; i < keys.Length; i++)\n        {\n            h.Add(keys[i], values[i]);\n        }\n    }\n}\n"}
{"id": 48163, "name": "Hash from two arrays", "source": "Translate Swift to Java: let keys = [\"a\",\"b\",\"c\"]\nlet vals = [1,2,3]\nvar hash = [String: Int]()\nfor (key, val) in zip(keys, vals) {\n  hash[key] = val\n}\n", "target": "import java.util.HashMap;\npublic static void main(String[] args){\n\tString[] keys= {\"a\", \"b\", \"c\"};\n\tint[] vals= {1, 2, 3};\n\tHashMap<String, Integer> hash= new HashMap<String, Integer>();\n\n\tfor(int i= 0; i < keys.length; i++){\n\t   hash.put(keys[i], vals[i]);\n\t}\n}\n"}
{"id": 48164, "name": "Hash from two arrays", "source": "Translate Swift to Python: let keys = [\"a\",\"b\",\"c\"]\nlet vals = [1,2,3]\nvar hash = [String: Int]()\nfor (key, val) in zip(keys, vals) {\n  hash[key] = val\n}\n", "target": "keys = ['a', 'b', 'c']\nvalues = [1, 2, 3]\nhash = {key: value for key, value in zip(keys, values)}\n"}
{"id": 49418, "name": "Loops_Continue", "source": "Translate Swift to C#: for i in 1...10 {\n    print(i, terminator: \"\")\n    if i % 5 == 0 {\n        print()\n        continue\n    }\n    print(\", \", terminator: \"\")\n}\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        for (int i = 1; i <= 10; i++) {\n            Console.Write(i);\n\n            if (i % 5 == 0) {\n                Console.WriteLine();\n                continue;\n            }\n\n            Console.Write(\", \");\n        }\n    }\n}\n"}
{"id": 49420, "name": "Loops_Continue", "source": "Translate Swift to Java: for i in 1...10 {\n    print(i, terminator: \"\")\n    if i % 5 == 0 {\n        print()\n        continue\n    }\n    print(\", \", terminator: \"\")\n}\n", "target": "for(int i = 1;i <= 10; i++){\n   System.out.print(i);\n   if(i % 5 == 0){\n      System.out.println();\n      continue;\n   }\n   System.out.print(\", \");\n}\n"}
{"id": 49421, "name": "Loops_Continue", "source": "Translate Swift to Python: for i in 1...10 {\n    print(i, terminator: \"\")\n    if i % 5 == 0 {\n        print()\n        continue\n    }\n    print(\", \", terminator: \"\")\n}\n", "target": "for i in range(1, 11):\n    if i % 5 == 0:\n        print(i)\n        continue\n    print(i, end=', ')\n"}
{"id": 49704, "name": "Filter", "source": "Translate Swift to C#: let numbers = [1,2,3,4,5,6]\nlet even_numbers = numbers.filter { $0 % 2 == 0 }\nprintln(even_numbers)\n", "target": "ArrayList array = new ArrayList( new int[] { 1, 2, 3, 4, 5 } );\nArrayList evens = new ArrayList();\nforeach( int i in array )\n{\n        if( (i%2) == 0 )\n                evens.Add( i );\n}\nforeach( int i in evens )\n       System.Console.WriteLine( i.ToString() );\n"}
{"id": 49706, "name": "Filter", "source": "Translate Swift to Java: let numbers = [1,2,3,4,5,6]\nlet even_numbers = numbers.filter { $0 % 2 == 0 }\nprintln(even_numbers)\n", "target": "int[] array = {1, 2, 3, 4, 5 };\nList<Integer> evensList = new ArrayList<Integer>();\nfor (int  i: array) {\n    if (i % 2 == 0) evensList.add(i);\n}\nint[] evens = evensList.toArray(new int[0]);\n"}
{"id": 49707, "name": "Filter", "source": "Translate Swift to Python: let numbers = [1,2,3,4,5,6]\nlet even_numbers = numbers.filter { $0 % 2 == 0 }\nprintln(even_numbers)\n", "target": "values = range(10)\nevens = [x for x in values if not x & 1]\nievens = (x for x in values if not x & 1) \n\nevens = filter(lambda x: not x & 1, values)\n"}
{"id": 50161, "name": "Sieve of Eratosthenes", "source": "Translate Swift to C#: import Foundation \n\nlet max = 1_000_000\nlet maxroot = Int(sqrt(Double(max)))\nlet startingPoint = Date()\n\nvar isprime = [Bool](repeating: true, count: max+1 )\nfor i in 2...maxroot {\n    if isprime[i] {\n        for k in stride(from: max/i, through: i, by: -1) {\n            if isprime[k] {\n                isprime[i*k] = false }\n        }\n    }\n}\n\nvar count = 0\nfor i in 2...max {\n    if isprime[i] {\n        count += 1\n    }\n}\nprint(\"\\(count) primes found under \\(max)\")\n\nprint(\"\\(startingPoint.timeIntervalSinceNow * -1) seconds\")\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace SieveOfEratosthenes\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int maxprime = int.Parse(args[0]);\n            var primelist = GetAllPrimesLessThan(maxprime);\n            foreach (int prime in primelist)\n            {\n                Console.WriteLine(prime);\n            }\n            Console.WriteLine(\"Count = \" + primelist.Count);\n            Console.ReadLine();\n        }\n\n        private static List<int> GetAllPrimesLessThan(int maxPrime)\n        {\n            var primes = new List<int>();\n            var maxSquareRoot = (int)Math.Sqrt(maxPrime);\n            var eliminated = new BitArray(maxPrime + 1);\n\n            for (int i = 2; i <= maxPrime; ++i)\n            {\n                if (!eliminated[i])\n                {\n                    primes.Add(i);\n                    if (i <= maxSquareRoot)\n                    {\n                        for (int j = i * i; j <= maxPrime; j += i)\n                        {\n                            eliminated[j] = true;\n                        }\n                    }\n                }\n            }\n            return primes;\n        }\n    }\n}\n"}
{"id": 50163, "name": "Sieve of Eratosthenes", "source": "Translate Swift to Java: import Foundation \n\nlet max = 1_000_000\nlet maxroot = Int(sqrt(Double(max)))\nlet startingPoint = Date()\n\nvar isprime = [Bool](repeating: true, count: max+1 )\nfor i in 2...maxroot {\n    if isprime[i] {\n        for k in stride(from: max/i, through: i, by: -1) {\n            if isprime[k] {\n                isprime[i*k] = false }\n        }\n    }\n}\n\nvar count = 0\nfor i in 2...max {\n    if isprime[i] {\n        count += 1\n    }\n}\nprint(\"\\(count) primes found under \\(max)\")\n\nprint(\"\\(startingPoint.timeIntervalSinceNow * -1) seconds\")\n", "target": "import java.util.LinkedList;\n\npublic class Sieve{\n       public static LinkedList<Integer> sieve(int n){\n               if(n < 2) return new LinkedList<Integer>();\n               LinkedList<Integer> primes = new LinkedList<Integer>();\n               LinkedList<Integer> nums = new LinkedList<Integer>();\n\n               for(int i = 2;i <= n;i++){ \n                       nums.add(i);\n               }\n\n               while(nums.size() > 0){\n                       int nextPrime = nums.remove();\n                       for(int i = nextPrime * nextPrime;i <= n;i += nextPrime){\n                               nums.removeFirstOccurrence(i);\n                       }\n                       primes.add(nextPrime);\n               }\n               return primes;\n       }\n}\n"}
{"id": 50164, "name": "Sieve of Eratosthenes", "source": "Translate Swift to Python: import Foundation \n\nlet max = 1_000_000\nlet maxroot = Int(sqrt(Double(max)))\nlet startingPoint = Date()\n\nvar isprime = [Bool](repeating: true, count: max+1 )\nfor i in 2...maxroot {\n    if isprime[i] {\n        for k in stride(from: max/i, through: i, by: -1) {\n            if isprime[k] {\n                isprime[i*k] = false }\n        }\n    }\n}\n\nvar count = 0\nfor i in 2...max {\n    if isprime[i] {\n        count += 1\n    }\n}\nprint(\"\\(count) primes found under \\(max)\")\n\nprint(\"\\(startingPoint.timeIntervalSinceNow * -1) seconds\")\n", "target": "from __future__ import print_function\n\ni = 2\n\ndef setup():\n    size(1000, 1000)\n    \n    global maxx, maxy, max_num, sieve\n    maxx = width\n    maxy = height\n    max_num = width * height\n    sieve = [False] * (max_num + 1)\n\n    sieve[1] = False\n    plot(0, False)\n    plot(1, False)\n    for i in range(2, max_num + 1):\n        sieve[i] = True\n        plot(i, True)\n\n\ndef draw():\n    global i\n    if not sieve[i]:\n        while (i * i < max_num and not sieve[i]):\n            i += 1\n\n    if sieve[i]:\n        print(\"{} \".format(i), end = '')\n        for j in range(i * i, max_num + 1, i):\n            if sieve[j]:\n                sieve[j] = False\n                plot(j, False)\n\n    if i * i < max_num:\n        i += 1\n    else:\n        noLoop()\n        println(\"finished\")\n\n\ndef plot(pos, active):\n    set(pos % maxx, pos / maxx, color(0) if active else color(255))\n"}
{"id": 50543, "name": "Sort disjoint sublist", "source": "Translate Swift to C#: struct DisjointSublistView<T> : MutableCollectionType {\n  let array : UnsafeMutablePointer<T>\n  let indexes : [Int]\n  \n  subscript (position: Int) -> T {\n    get {\n      return array[indexes[position]]\n    }\n    set {\n      array[indexes[position]] = newValue\n    }\n  }\n  var startIndex : Int { return 0 }\n  var endIndex : Int { return indexes.count }\n  func generate() -> IndexingGenerator<DisjointSublistView<T>> { return IndexingGenerator(self) }\n}\n\nfunc sortDisjointSublist<T : Comparable>(inout array: [T], indexes: [Int]) {\n  var d = DisjointSublistView(array: &array, indexes: sorted(indexes))\n  sort(&d)\n}\n\nvar a = [7, 6, 5, 4, 3, 2, 1, 0]\nlet ind = [6, 1, 7]\nsortDisjointSublist(&a, ind)\nprintln(a)\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n     \npublic class Test\n{\n    public static void Main()\n    {\n        var list = new List<int>{ 7, 6, 5, 4, 3, 2, 1, 0 };\n        list.SortSublist(6, 1, 7);\n        Console.WriteLine(string.Join(\", \", list));\n    }\n}\n     \npublic static class Extensions\n{\n    public static void SortSublist<T>(this List<T> list, params int[] indices)\n        where T : IComparable<T>\n    {\n        var sublist = indices.OrderBy(i => i)\n            .Zip(indices.Select(i => list[i]).OrderBy(v => v),\n                (Index, Value) => new { Index, Value });\n     \n        foreach (var entry in sublist) {\n            list[entry.Index] = entry.Value;\n        }\n    }\n     \n}\n"}
{"id": 50545, "name": "Sort disjoint sublist", "source": "Translate Swift to Java: struct DisjointSublistView<T> : MutableCollectionType {\n  let array : UnsafeMutablePointer<T>\n  let indexes : [Int]\n  \n  subscript (position: Int) -> T {\n    get {\n      return array[indexes[position]]\n    }\n    set {\n      array[indexes[position]] = newValue\n    }\n  }\n  var startIndex : Int { return 0 }\n  var endIndex : Int { return indexes.count }\n  func generate() -> IndexingGenerator<DisjointSublistView<T>> { return IndexingGenerator(self) }\n}\n\nfunc sortDisjointSublist<T : Comparable>(inout array: [T], indexes: [Int]) {\n  var d = DisjointSublistView(array: &array, indexes: sorted(indexes))\n  sort(&d)\n}\n\nvar a = [7, 6, 5, 4, 3, 2, 1, 0]\nlet ind = [6, 1, 7]\nsortDisjointSublist(&a, ind)\nprintln(a)\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Disjoint {\n    public static <T extends Comparable<? super T>> void sortDisjoint(\n            List<T> array, int[] idxs) {\n        Arrays.sort(idxs);\n        List<T> disjoint = new ArrayList<T>();\n        for (int idx : idxs) {\n            disjoint.add(array.get(idx));\n        }\n        Collections.sort(disjoint);\n        int i = 0;\n        for (int idx : idxs) {\n            array.set(idx, disjoint.get(i++));\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(7, 6, 5, 4, 3, 2, 1, 0);\n        int[] indices = {6, 1, 7};\n        System.out.println(list);\n        sortDisjoint(list, indices);\n        System.out.println(list);\n    }\n}\n"}
{"id": 50546, "name": "Sort disjoint sublist", "source": "Translate Swift to Python: struct DisjointSublistView<T> : MutableCollectionType {\n  let array : UnsafeMutablePointer<T>\n  let indexes : [Int]\n  \n  subscript (position: Int) -> T {\n    get {\n      return array[indexes[position]]\n    }\n    set {\n      array[indexes[position]] = newValue\n    }\n  }\n  var startIndex : Int { return 0 }\n  var endIndex : Int { return indexes.count }\n  func generate() -> IndexingGenerator<DisjointSublistView<T>> { return IndexingGenerator(self) }\n}\n\nfunc sortDisjointSublist<T : Comparable>(inout array: [T], indexes: [Int]) {\n  var d = DisjointSublistView(array: &array, indexes: sorted(indexes))\n  sort(&d)\n}\n\nvar a = [7, 6, 5, 4, 3, 2, 1, 0]\nlet ind = [6, 1, 7]\nsortDisjointSublist(&a, ind)\nprintln(a)\n", "target": ">>> def sort_disjoint_sublist(data, indices):\n\tindices = sorted(indices)\n\tvalues  = sorted(data[i] for i in indices)\n\tfor index, value in zip(indices, values):\n\t\tdata[index] = value\n\n\t\t\n>>> d = [7, 6, 5, 4, 3, 2, 1, 0]\n>>> i = set([6, 1, 7])\n>>> sort_disjoint_sublist(d, i)\n>>> d\n[7, 0, 5, 4, 3, 2, 1, 6]\n>>> \n>>> def sort_disjoint_sublist(data, indices):\n\tfor index, value in zip(sorted(indices), sorted(data[i] for i in indices)): data[index] = value\n\n\t\n>>>\n"}
{"id": 50691, "name": "Kronecker product", "source": "Translate Swift to C#: func kronecker(m1: [[Int]], m2: [[Int]]) -> [[Int]] {\n  let m = m1.count\n  let n = m1[0].count\n  let p = m2.count\n  let q = m2[0].count\n  let rtn = m * p\n  let ctn = n * q\n\n  var res = Array(repeating: Array(repeating: 0, count: ctn), count: rtn)\n\n  for i in 0..<m {\n    for j in 0..<n {\n      for k in 0..<p {\n        for l in 0..<q {\n          res[p * i + k][q * j + l] = m1[i][j] * m2[k][l]\n        }\n      }\n    }\n  }\n\n  return res\n}\n\nfunc printMatrix<T>(_ matrix: [[T]]) {\n  guard !matrix.isEmpty else {\n    print()\n\n    return\n  }\n\n  let rows = matrix.count\n  let cols = matrix[0].count\n\n  for i in 0..<rows {\n    for j in 0..<cols {\n      print(matrix[i][j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\n\nfunc printProducts(a: [[Int]], b: [[Int]]) {\n  print(\"Matrix A:\")\n  printMatrix(a)\n  print(\"Matrix B:\")\n  printMatrix(b)\n  print(\"kronecker a b:\")\n  printMatrix(kronecker(m1: a, m2: b))\n  print()\n}\n\nlet a = [\n  [1, 2],\n  [3, 4]\n]\n\nlet b = [\n  [0, 5],\n  [6, 7]\n]\n\nprintProducts(a: a, b: b)\n\nlet a2 = [\n  [0, 1, 0],\n  [1, 1, 1],\n  [0, 1, 0]\n]\n\nlet b2 = [\n  [1, 1, 1, 1],\n  [1, 0, 0, 1],\n  [1, 1, 1, 1]\n]\n\nprintProducts(a: a2, b: b2)\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class KroneckerProduct\n{\n    public static void Main() {\n        int[,] left = { {1, 2}, {3, 4} };\n        int[,] right = { {0, 5}, {6, 7} };\n        Print(Multiply(left, right));\n\n        left = new [,] { {0, 1, 0}, {1, 1, 1}, {0, 1, 0} };\n        right = new [,] { {1, 1, 1, 1}, {1, 0, 0, 1}, {1, 1, 1, 1} };\n        Print(Multiply(left, right));\n    }\n\n    static int[,] Multiply(int[,] left, int[,] right) {\n        (int lRows, int lColumns) = (left.GetLength(0), left.GetLength(1));\n        (int rRows, int rColumns) = (right.GetLength(0), right.GetLength(1));\n        int[,] result = new int[lRows * rRows, lColumns * rColumns];\n\n        foreach (var (r, c) in from r in Range(0, lRows) from c in Range(0, lColumns) select (r, c)) {\n            Copy(r * rRows, c * rColumns, left[r, c]);\n        }\n        return result;\n        \n        void Copy(int startRow, int startColumn, int multiplier) {\n            foreach (var (r, c) in from r in Range(0, rRows) from c in Range(0, rColumns) select (r, c)) {\n                result[startRow + r, startColumn + c] = right[r, c] * multiplier;\n            }\n        }\n    }\n\n    static void Print(int[,] matrix) {\n        (int rows, int columns) = (matrix.GetLength(0), matrix.GetLength(1));\n        int width = matrix.Cast<int>().Select(LengthOf).Max();\n        for (int row = 0; row < rows; row++) {\n            Console.WriteLine(\"| \" + string.Join(\" \", Range(0, columns).Select(column => (matrix[row, column] + \"\").PadLeft(width, ' '))) + \" |\");\n        }\n        Console.WriteLine();\n    }\n\n    private static int LengthOf(int i) {\n        if (i < 0) return LengthOf(-i) + 1;\n        int length = 0;\n        while (i > 0) {\n            length++;\n            i /= 10;\n        }\n        return length;\n    }\n\n}\n"}
{"id": 50693, "name": "Kronecker product", "source": "Translate Swift to Java: func kronecker(m1: [[Int]], m2: [[Int]]) -> [[Int]] {\n  let m = m1.count\n  let n = m1[0].count\n  let p = m2.count\n  let q = m2[0].count\n  let rtn = m * p\n  let ctn = n * q\n\n  var res = Array(repeating: Array(repeating: 0, count: ctn), count: rtn)\n\n  for i in 0..<m {\n    for j in 0..<n {\n      for k in 0..<p {\n        for l in 0..<q {\n          res[p * i + k][q * j + l] = m1[i][j] * m2[k][l]\n        }\n      }\n    }\n  }\n\n  return res\n}\n\nfunc printMatrix<T>(_ matrix: [[T]]) {\n  guard !matrix.isEmpty else {\n    print()\n\n    return\n  }\n\n  let rows = matrix.count\n  let cols = matrix[0].count\n\n  for i in 0..<rows {\n    for j in 0..<cols {\n      print(matrix[i][j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\n\nfunc printProducts(a: [[Int]], b: [[Int]]) {\n  print(\"Matrix A:\")\n  printMatrix(a)\n  print(\"Matrix B:\")\n  printMatrix(b)\n  print(\"kronecker a b:\")\n  printMatrix(kronecker(m1: a, m2: b))\n  print()\n}\n\nlet a = [\n  [1, 2],\n  [3, 4]\n]\n\nlet b = [\n  [0, 5],\n  [6, 7]\n]\n\nprintProducts(a: a, b: b)\n\nlet a2 = [\n  [0, 1, 0],\n  [1, 1, 1],\n  [0, 1, 0]\n]\n\nlet b2 = [\n  [1, 1, 1, 1],\n  [1, 0, 0, 1],\n  [1, 1, 1, 1]\n]\n\nprintProducts(a: a2, b: b2)\n", "target": "package kronecker;\n\n\npublic class Product {\n  \n  public static int[][] product(final int[][] a, final int[][] b) {\n    \n    \n    final int[][] c = new int[a.length*b.length][];\n    \n    \n    for (int ix = 0; ix < c.length; ix++) {\n      final int num_cols = a[0].length*b[0].length;\n      c[ix] = new int[num_cols];\n    }\n    \n    \n    for (int ia = 0; ia < a.length; ia++) {\n      for (int ja = 0; ja < a[ia].length; ja++) {\n        \n        for (int ib = 0; ib < b.length; ib++) {\n          for (int jb = 0; jb < b[ib].length; jb++) {\n             c[b.length*ia+ib][b[ib].length*ja+jb] = a[ia][ja] * b[ib][jb];\n          }\n        }\n      }\n    }\n\n    \n    return c;\n  }\n\n  \n  public static void print_matrix(final int[][] m) {\n    \n    \n    \n    \n    final String[][] sts = new String[m.length][];\n    int max_length = 0;  \n    for (int im = 0; im < m.length; im++) {\n      sts[im] = new String[m[im].length];\n      for (int jm = 0; jm < m[im].length; jm++) {\n        final String st = String.valueOf(m[im][jm]);\n        if (st.length() > max_length) {\n          max_length = st.length();\n        }\n        sts[im][jm] = st;\n      }\n    }\n\n    \n    \n    \n    final String format = String.format(\"%%%ds\", max_length);\n    for (int im = 0; im < m.length; im++) {\n      System.out.print(\"|\");\n      \n      for (int jm = 0; jm < m[im].length - 1; jm++) {\n        System.out.format(format, m[im][jm]);\n        System.out.print(\" \");\n      }\n      System.out.format(format, m[im][m[im].length - 1]);\n      System.out.println(\"|\");\n    }\n  }\n\n  \n  private static void test(final int[][] a, final int[][] b) {\n    \n    System.out.println(\"Testing Kronecker product\");\n    System.out.println(\"Size of matrix a: \" + a.length + \" by \" + a[0].length);\n    System.out.println(\"Matrix a:\");\n    print_matrix(a);\n    System.out.println(\"Size of matrix b: \" + b.length + \" by \" + b[0].length);\n    System.out.println(\"Matrix b:\");\n    print_matrix(b);\n    System.out.println(\"Calculating matrix c as Kronecker product\");\n    final int[][] c = product(a, b);\n    System.out.println(\"Size of matrix c: \" + c.length + \" by \" + c[0].length);\n    System.out.println(\"Matrix c:\");\n    print_matrix(c);\n  }\n\n  \n  private static void test1() {\n    \n    final int[][] a = new int[2][];  \n    a[0] = new int[]{1, 2};\n    a[1] = new int[]{3, 4};\n    final int[][] b = new int[2][];  \n    b[0] = new int[]{0, 5};\n    b[1] = new int[]{6, 7};\n    \n    test(a, b);\n  }\n\n  \n  private static void test2() {\n    \n    final int[][] a = new int[3][];  \n    a[0] = new int[]{0, 1, 0};\n    a[1] = new int[]{1, 1, 1};\n    a[2] = new int[]{0, 1, 0};\n    final int[][] b = new int[3][];  \n    b[0] = new int[]{1, 1, 1, 1};\n    b[1] = new int[]{1, 0, 0, 1};\n    b[2] = new int[]{1, 1, 1, 1};\n    \n    test(a, b);\n  }\n\n  \n  public static void main(final String[] args) {\n    \n    test1();\n    test2();\n  }\n\n}\n"}
{"id": 50694, "name": "Kronecker product", "source": "Translate Swift to Python: func kronecker(m1: [[Int]], m2: [[Int]]) -> [[Int]] {\n  let m = m1.count\n  let n = m1[0].count\n  let p = m2.count\n  let q = m2[0].count\n  let rtn = m * p\n  let ctn = n * q\n\n  var res = Array(repeating: Array(repeating: 0, count: ctn), count: rtn)\n\n  for i in 0..<m {\n    for j in 0..<n {\n      for k in 0..<p {\n        for l in 0..<q {\n          res[p * i + k][q * j + l] = m1[i][j] * m2[k][l]\n        }\n      }\n    }\n  }\n\n  return res\n}\n\nfunc printMatrix<T>(_ matrix: [[T]]) {\n  guard !matrix.isEmpty else {\n    print()\n\n    return\n  }\n\n  let rows = matrix.count\n  let cols = matrix[0].count\n\n  for i in 0..<rows {\n    for j in 0..<cols {\n      print(matrix[i][j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\n\nfunc printProducts(a: [[Int]], b: [[Int]]) {\n  print(\"Matrix A:\")\n  printMatrix(a)\n  print(\"Matrix B:\")\n  printMatrix(b)\n  print(\"kronecker a b:\")\n  printMatrix(kronecker(m1: a, m2: b))\n  print()\n}\n\nlet a = [\n  [1, 2],\n  [3, 4]\n]\n\nlet b = [\n  [0, 5],\n  [6, 7]\n]\n\nprintProducts(a: a, b: b)\n\nlet a2 = [\n  [0, 1, 0],\n  [1, 1, 1],\n  [0, 1, 0]\n]\n\nlet b2 = [\n  [1, 1, 1, 1],\n  [1, 0, 0, 1],\n  [1, 1, 1, 1]\n]\n\nprintProducts(a: a2, b: b2)\n", "target": "\n\n\na1 = [[1, 2], [3, 4]]\nb1 = [[0, 5], [6, 7]]\n\n\na2 = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\nb2 = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]]\n\ndef kronecker(matrix1, matrix2):\n    final_list = []\n    sub_list = []\n\n    count = len(matrix2)\n\n    for elem1 in matrix1:\n        counter = 0\n        check = 0\n        while check < count:\n            for num1 in elem1:\n                for num2 in matrix2[counter]:\n                    sub_list.append(num1 * num2)\n            counter += 1\n            final_list.append(sub_list)\n            sub_list = []\n            check +=1\n            \n    return final_list\n\n\nresult1 = kronecker(a1, b1)\nfor elem in result1:\n    print(elem)\n\nprint(\"\")\n\n\nresult2 = kronecker(a2, b2)\nfor elem in result2:\n    print(elem)\n"}
{"id": 51088, "name": "Split a character string based on change of character", "source": "Translate Swift to C#: public extension String {\n  func splitOnChanges() -> [String] {\n    guard !isEmpty else {\n      return []\n    }\n\n    var res = [String]()\n    var workingChar = first!\n    var workingStr = \"\\(workingChar)\"\n\n    for char in dropFirst() {\n      if char != workingChar {\n        res.append(workingStr)\n        workingStr = \"\\(char)\"\n        workingChar = char\n      } else {\n        workingStr += String(char)\n      }\n    }\n\n    res.append(workingStr)\n\n    return res\n  }\n}\n\nprint(\"gHHH5YY++\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    string s = @\"gHHH5YY++\n    Console.WriteLine(s.RunLengthSplit().Delimit(\", \"));\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> RunLengthSplit(this string source) {\n        using (var enumerator = source.GetEnumerator()) {\n            if (!enumerator.MoveNext()) yield break;\n            char previous = enumerator.Current;\n            int count = 1;\n            while (enumerator.MoveNext()) {\n                if (previous == enumerator.Current) {\n                    count++;\n                } else {\n                    yield return new string(Enumerable.Repeat(previous, count).ToArray());\n                    previous = enumerator.Current;\n                    count = 1;\n                }\n            }\n            yield return new string(Enumerable.Repeat(previous, count).ToArray());\n        }\n    }\n\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = \"\") => string.Join(separator ?? \"\", source);\n}\n"}
{"id": 51089, "name": "Split a character string based on change of character", "source": "Translate Swift to C#: public extension String {\n  func splitOnChanges() -> [String] {\n    guard !isEmpty else {\n      return []\n    }\n\n    var res = [String]()\n    var workingChar = first!\n    var workingStr = \"\\(workingChar)\"\n\n    for char in dropFirst() {\n      if char != workingChar {\n        res.append(workingStr)\n        workingStr = \"\\(char)\"\n        workingChar = char\n      } else {\n        workingStr += String(char)\n      }\n    }\n\n    res.append(workingStr)\n\n    return res\n  }\n}\n\nprint(\"gHHH5YY++\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    string s = @\"gHHH5YY++\n    Console.WriteLine(s.RunLengthSplit().Delimit(\", \"));\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> RunLengthSplit(this string source) {\n        using (var enumerator = source.GetEnumerator()) {\n            if (!enumerator.MoveNext()) yield break;\n            char previous = enumerator.Current;\n            int count = 1;\n            while (enumerator.MoveNext()) {\n                if (previous == enumerator.Current) {\n                    count++;\n                } else {\n                    yield return new string(Enumerable.Repeat(previous, count).ToArray());\n                    previous = enumerator.Current;\n                    count = 1;\n                }\n            }\n            yield return new string(Enumerable.Repeat(previous, count).ToArray());\n        }\n    }\n\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = \"\") => string.Join(separator ?? \"\", source);\n}\n"}
{"id": 51092, "name": "Split a character string based on change of character", "source": "Translate Swift to Java: public extension String {\n  func splitOnChanges() -> [String] {\n    guard !isEmpty else {\n      return []\n    }\n\n    var res = [String]()\n    var workingChar = first!\n    var workingStr = \"\\(workingChar)\"\n\n    for char in dropFirst() {\n      if char != workingChar {\n        res.append(workingStr)\n        workingStr = \"\\(char)\"\n        workingChar = char\n      } else {\n        workingStr += String(char)\n      }\n    }\n\n    res.append(workingStr)\n\n    return res\n  }\n}\n\nprint(\"gHHH5YY++\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SplitStringByCharacterChange {\n    \n    public static void main(String... args){\n        for (String string : args){\n            \n            List<String> resultStrings = splitStringByCharacter(string);\n            String output = formatList(resultStrings);\n            System.out.println(output);\n        }\n    }\n    \n    \n    public static List<String> splitStringByCharacter(String string){\n        \n        List<String> resultStrings = new ArrayList<>();\n        StringBuilder currentString = new StringBuilder();\n        \n        for (int pointer = 0; pointer < string.length(); pointer++){\n            \n            currentString.append(string.charAt(pointer));\n            \n            if (pointer == string.length() - 1 \n                    || currentString.charAt(0) != string.charAt(pointer + 1)) {\n                resultStrings.add(currentString.toString());\n                currentString = new StringBuilder();\n            }\n        }\n        \n        return resultStrings;\n    }\n    \n    \n    public static String formatList(List<String> list){\n        \n        StringBuilder output = new StringBuilder();\n        \n        for (int pointer = 0; pointer < list.size(); pointer++){\n            output.append(list.get(pointer));\n            \n            if (pointer != list.size() - 1){\n                output.append(\", \");\n            }\n        }\n        \n        return output.toString();\n    }\n}\n"}
{"id": 51093, "name": "Split a character string based on change of character", "source": "Translate Swift to Java: public extension String {\n  func splitOnChanges() -> [String] {\n    guard !isEmpty else {\n      return []\n    }\n\n    var res = [String]()\n    var workingChar = first!\n    var workingStr = \"\\(workingChar)\"\n\n    for char in dropFirst() {\n      if char != workingChar {\n        res.append(workingStr)\n        workingStr = \"\\(char)\"\n        workingChar = char\n      } else {\n        workingStr += String(char)\n      }\n    }\n\n    res.append(workingStr)\n\n    return res\n  }\n}\n\nprint(\"gHHH5YY++\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SplitStringByCharacterChange {\n    \n    public static void main(String... args){\n        for (String string : args){\n            \n            List<String> resultStrings = splitStringByCharacter(string);\n            String output = formatList(resultStrings);\n            System.out.println(output);\n        }\n    }\n    \n    \n    public static List<String> splitStringByCharacter(String string){\n        \n        List<String> resultStrings = new ArrayList<>();\n        StringBuilder currentString = new StringBuilder();\n        \n        for (int pointer = 0; pointer < string.length(); pointer++){\n            \n            currentString.append(string.charAt(pointer));\n            \n            if (pointer == string.length() - 1 \n                    || currentString.charAt(0) != string.charAt(pointer + 1)) {\n                resultStrings.add(currentString.toString());\n                currentString = new StringBuilder();\n            }\n        }\n        \n        return resultStrings;\n    }\n    \n    \n    public static String formatList(List<String> list){\n        \n        StringBuilder output = new StringBuilder();\n        \n        for (int pointer = 0; pointer < list.size(); pointer++){\n            output.append(list.get(pointer));\n            \n            if (pointer != list.size() - 1){\n                output.append(\", \");\n            }\n        }\n        \n        return output.toString();\n    }\n}\n"}
{"id": 51094, "name": "Split a character string based on change of character", "source": "Translate Swift to Python: public extension String {\n  func splitOnChanges() -> [String] {\n    guard !isEmpty else {\n      return []\n    }\n\n    var res = [String]()\n    var workingChar = first!\n    var workingStr = \"\\(workingChar)\"\n\n    for char in dropFirst() {\n      if char != workingChar {\n        res.append(workingStr)\n        workingStr = \"\\(char)\"\n        workingChar = char\n      } else {\n        workingStr += String(char)\n      }\n    }\n\n    res.append(workingStr)\n\n    return res\n  }\n}\n\nprint(\"gHHH5YY++\n", "target": "from itertools import groupby\n\ndef splitter(text):\n    return ', '.join(''.join(group) for key, group in groupby(text))\n\nif __name__ == '__main__':\n    txt = 'gHHH5YY++///\\\\'      \n    print(f'Input: {txt}\\nSplit: {splitter(txt)}')\n"}
{"id": 51095, "name": "Split a character string based on change of character", "source": "Translate Swift to Python: public extension String {\n  func splitOnChanges() -> [String] {\n    guard !isEmpty else {\n      return []\n    }\n\n    var res = [String]()\n    var workingChar = first!\n    var workingStr = \"\\(workingChar)\"\n\n    for char in dropFirst() {\n      if char != workingChar {\n        res.append(workingStr)\n        workingStr = \"\\(char)\"\n        workingChar = char\n      } else {\n        workingStr += String(char)\n      }\n    }\n\n    res.append(workingStr)\n\n    return res\n  }\n}\n\nprint(\"gHHH5YY++\n", "target": "from itertools import groupby\n\ndef splitter(text):\n    return ', '.join(''.join(group) for key, group in groupby(text))\n\nif __name__ == '__main__':\n    txt = 'gHHH5YY++///\\\\'      \n    print(f'Input: {txt}\\nSplit: {splitter(txt)}')\n"}
{"id": 51297, "name": "Truncatable primes", "source": "Translate Swift to C#: func isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfunc isLeftTruncatable(_ p: Int) -> Bool {\n    var n = 10\n    var q = p\n    while p > n {\n        if !isPrime(p % n) || q == p % n {\n            return false\n        }\n        q = p % n\n        n *= 10\n    }\n    return true\n}\n\nfunc isRightTruncatable(_ p: Int) -> Bool {\n    var q = p / 10\n    while q > 0 {\n        if !isPrime(q) {\n            return false\n        }\n        q /= 10\n    }\n    return true\n}\n\nlet limit = 1000000\nvar largestLeft = 0\nvar largestRight = 0\nvar p = limit\nwhile p >= 2 {\n    if isPrime(p) && isLeftTruncatable(p) {\n        largestLeft = p\n        break\n    }\n    p -= 1\n}\nprint(\"Largest left truncatable prime is \\(largestLeft)\")\np = limit\nwhile p >= 2 {\n    if isPrime(p) && isRightTruncatable(p) {\n        largestRight = p\n        break\n    }\n    p -= 1\n}\nprint(\"Largest right truncatable prime is \\(largestRight)\")\n", "target": "using System;  \nusing System.Collections.Generic;\nclass truncatable_primes\n{\n    static void Main()\n    {\n        uint m = 1000000;\n        Console.Write(\"L \" + L(m) + \" R \" + R(m) + \"  \");\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        for (int i = 1000; i > 0; i--) { L(m); R(m); }\n        Console.Write(sw.Elapsed); Console.Read();\n    }\n\n    static uint L(uint n)\n    {\n        n -= n & 1; n--;\n        for (uint d, d1 = 100; ; n -= 2)\n        {\n            while (n % 3 == 0 || n % 5 == 0 || n % 7 == 0) n -= 2;\n            if ((d = n % 10) == 3 || d == 7)\n            {\n                while (d1 < n && d < (d = n % d1) && isP(d)) d1 *= 10;\n                if (d1 > n && isP(n)) return n; d1 = 100;\n            }\n        }\n    }\n\n    static uint R(uint m)\n    {\n        var p = new List<uint>() { 2, 3, 5, 7 }; uint n = 20, np;\n        for (int i = 1; i < p.Count; n = 10 * p[i++])\n        {\n            if ((np = n + 1) >= m) break; if (isP(np)) p.Add(np);\n            if ((np = n + 3) >= m) break; if (isP(np)) p.Add(np);\n            if ((np = n + 7) >= m) break; if (isP(np)) p.Add(np);\n            if ((np = n + 9) >= m) break; if (isP(np)) p.Add(np);\n        }\n        return p[p.Count - 1];\n    }\n\n    static bool isP(uint n)\n    {\n        if (n < 7) return n == 2 || n == 3 || n == 5;\n        if ((n & 1) == 0 || n % 3 == 0 || n % 5 == 0) return false;\n        for (uint r = (uint)Math.Sqrt(n), d = 7; d <= r; d += 30)\n            if (n % (d + 00) == 0 || n % (d + 04) == 0 ||\n                n % (d + 06) == 0 || n % (d + 10) == 0 ||\n                n % (d + 12) == 0 || n % (d + 16) == 0 ||\n                n % (d + 22) == 0 || n % (d + 24) == 0) return false;\n        return true;\n    }\n}\n"}
{"id": 51299, "name": "Truncatable primes", "source": "Translate Swift to Java: func isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfunc isLeftTruncatable(_ p: Int) -> Bool {\n    var n = 10\n    var q = p\n    while p > n {\n        if !isPrime(p % n) || q == p % n {\n            return false\n        }\n        q = p % n\n        n *= 10\n    }\n    return true\n}\n\nfunc isRightTruncatable(_ p: Int) -> Bool {\n    var q = p / 10\n    while q > 0 {\n        if !isPrime(q) {\n            return false\n        }\n        q /= 10\n    }\n    return true\n}\n\nlet limit = 1000000\nvar largestLeft = 0\nvar largestRight = 0\nvar p = limit\nwhile p >= 2 {\n    if isPrime(p) && isLeftTruncatable(p) {\n        largestLeft = p\n        break\n    }\n    p -= 1\n}\nprint(\"Largest left truncatable prime is \\(largestLeft)\")\np = limit\nwhile p >= 2 {\n    if isPrime(p) && isRightTruncatable(p) {\n        largestRight = p\n        break\n    }\n    p -= 1\n}\nprint(\"Largest right truncatable prime is \\(largestRight)\")\n", "target": "import java.util.BitSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args){\n\n\t\tfinal int MAX = 1000000;\n\n\t\t\n\t\tBitSet primeList = new BitSet(MAX>>1); \n\t\tprimeList.set(0,primeList.size(),true); \n\n\t\tint sqroot = (int) Math.sqrt(MAX); \n\t\tprimeList.clear(0); \n\t\tfor(int num = 3; num <= sqroot; num+=2) \n\t\t{ \n\t\t\tif( primeList.get(num >> 1) ) \n\t\t\t{ \n\t\t\t\tint inc = num << 1;\n\t\t\t\tfor(int factor = num * num; factor < MAX; factor += inc) \n\t\t\t\t{ \n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tprimeList.clear(factor >> 1); \n\t\t\t\t\t\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t\n\n\t\t\n\t\tint rightTrunc = -1, leftTrunc = -1;\n\t\tfor(int prime = (MAX - 1) | 1; prime >= 3; prime -= 2)\n\t\t{\n\t\t\tif(primeList.get(prime>>1))\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(rightTrunc == -1)\n\t\t\t\t{\n\t\t\t\t\tint right = prime;\n\t\t\t\t\twhile(right > 0 && right % 2 != 0 && primeList.get(right >> 1)) right /= 10;\n\t\t\t\t\tif(right == 0) rightTrunc = prime;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tif(leftTrunc == -1 )\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tString left = Integer.toString(prime);\n\t\t\t\t\tif(!left.contains(\"0\"))\n\t\t\t\t\t{\n\t\t\t\t\t\twhile( left.length() > 0 ){\n\t\t\t\t\t\t\tint iLeft = Integer.parseInt(left);\n\t\t\t\t\t\t\tif(!primeList.get( iLeft >> 1)) break;\n\t\t\t\t\t\t\tleft = left.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(left.length() == 0) leftTrunc = prime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(leftTrunc != -1 && rightTrunc != -1) \n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Left  Truncatable\u00a0: \" + leftTrunc);\n\t\tSystem.out.println(\"Right Truncatable\u00a0: \" + rightTrunc);\n\t}\n}\n"}
{"id": 51300, "name": "Truncatable primes", "source": "Translate Swift to Python: func isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfunc isLeftTruncatable(_ p: Int) -> Bool {\n    var n = 10\n    var q = p\n    while p > n {\n        if !isPrime(p % n) || q == p % n {\n            return false\n        }\n        q = p % n\n        n *= 10\n    }\n    return true\n}\n\nfunc isRightTruncatable(_ p: Int) -> Bool {\n    var q = p / 10\n    while q > 0 {\n        if !isPrime(q) {\n            return false\n        }\n        q /= 10\n    }\n    return true\n}\n\nlet limit = 1000000\nvar largestLeft = 0\nvar largestRight = 0\nvar p = limit\nwhile p >= 2 {\n    if isPrime(p) && isLeftTruncatable(p) {\n        largestLeft = p\n        break\n    }\n    p -= 1\n}\nprint(\"Largest left truncatable prime is \\(largestLeft)\")\np = limit\nwhile p >= 2 {\n    if isPrime(p) && isRightTruncatable(p) {\n        largestRight = p\n        break\n    }\n    p -= 1\n}\nprint(\"Largest right truncatable prime is \\(largestRight)\")\n", "target": "maxprime = 1000000\n\ndef primes(n):\n    multiples = set()\n    prime = []\n    for i in range(2, n+1):\n        if i not in multiples:\n            prime.append(i)\n            multiples.update(set(range(i*i, n+1, i)))\n    return prime\n\ndef truncatableprime(n):\n    'Return a longest left and right truncatable primes below n'\n    primelist = [str(x) for x in primes(n)[::-1]]\n    primeset = set(primelist)\n    for n in primelist:\n        \n        alltruncs = set(n[i:] for i in range(len(n)))\n        if alltruncs.issubset(primeset):\n            truncateleft = int(n)\n            break\n    for n in primelist:\n        \n        alltruncs = set([n[:i+1] for i in range(len(n))])\n        if alltruncs.issubset(primeset):\n            truncateright = int(n)\n            break\n    return truncateleft, truncateright\n\nprint(truncatableprime(maxprime))\n"}
{"id": 51414, "name": "Singleton", "source": "Translate Swift to C#: class SingletonClass {\n\nstatic let sharedInstance = SingletonClass()\n\n    \n    private override init(){\n    \n    }\n}\n\nlet sharedObject = SingletonClass.sharedInstance\n", "target": "public sealed class Singleton1 \n{\n    private static Singleton1 instance;\n    private static readonly object lockObj = new object();\n    \n    public static Singleton1 Instance {\n        get {\n            lock(lockObj) {\n                if (instance == null) {\n                    instance = new Singleton1();\n                }\n            }\n            return instance;\n        }\n    }\n}\n"}
{"id": 51416, "name": "Singleton", "source": "Translate Swift to Java: class SingletonClass {\n\nstatic let sharedInstance = SingletonClass()\n\n    \n    private override init(){\n    \n    }\n}\n\nlet sharedObject = SingletonClass.sharedInstance\n", "target": "class Singleton\n{\n    private static Singleton myInstance;\n    public static Singleton getInstance()\n    {\n        if (myInstance == null)\n        {\n            synchronized(Singleton.class)\n            {\n                if (myInstance == null)\n                {\n                    myInstance = new Singleton();\n                }\n            }\n        }\n\n        return myInstance;\n    }\n\n    protected Singleton()\n    {\n        \n    }\n\n    \n}\n"}
{"id": 51417, "name": "Singleton", "source": "Translate Swift to Python: class SingletonClass {\n\nstatic let sharedInstance = SingletonClass()\n\n    \n    private override init(){\n    \n    }\n}\n\nlet sharedObject = SingletonClass.sharedInstance\n", "target": ">>> class Borg(object):\n\t__state = {}\n\tdef __init__(self):\n\t\tself.__dict__ = self.__state\n\t\n\n\t\n>>> b1 = Borg()\n>>> b2 = Borg()\n>>> b1 is b2\nFalse\n>>> b1.datum = range(5)\n>>> b1.datum\n[0, 1, 2, 3, 4]\n>>> b2.datum\n[0, 1, 2, 3, 4]\n>>> b1.datum is b2.datum\nTrue\n>>> \n"}
{"id": 51739, "name": "Nested function", "source": "Translate Swift to C#: func makeList(_ separator: String) -> String {\n  var counter = 1\n  \n  func makeItem(_ item: String) -> String {\n    let result = String(counter) + separator + item + \"\\n\"\n    counter += 1\n    return result\n  }\n  \n  return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n}\n\nprint(makeList(\". \"))\n", "target": "string MakeList(string separator)\n{\n    int counter = 1;\n\n    Func<string, string> makeItem = item => counter++ + separator + item + \"\\n\";\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\");\n}\n\nConsole.WriteLine(MakeList(\". \"));\n"}
{"id": 51740, "name": "Nested function", "source": "Translate Swift to C#: func makeList(_ separator: String) -> String {\n  var counter = 1\n  \n  func makeItem(_ item: String) -> String {\n    let result = String(counter) + separator + item + \"\\n\"\n    counter += 1\n    return result\n  }\n  \n  return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n}\n\nprint(makeList(\". \"))\n", "target": "string MakeList(string separator)\n{\n    int counter = 1;\n\n    Func<string, string> makeItem = item => counter++ + separator + item + \"\\n\";\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\");\n}\n\nConsole.WriteLine(MakeList(\". \"));\n"}
{"id": 51743, "name": "Nested function", "source": "Translate Swift to Java: func makeList(_ separator: String) -> String {\n  var counter = 1\n  \n  func makeItem(_ item: String) -> String {\n    let result = String(counter) + separator + item + \"\\n\"\n    counter += 1\n    return result\n  }\n  \n  return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n}\n\nprint(makeList(\". \"))\n", "target": "module NestedFunction\n    {\n    static String makeList(String separator)\n        {\n        Int counter = 1;\n\n        function String(String) makeItem = item -> $\"{counter++}{separator}{item}\\n\";\n\n        return makeItem(\"first\")\n             + makeItem(\"second\")\n             + makeItem(\"third\");\n        }\n\n    void run()\n        {\n        @Inject Console console;\n        console.print(makeList(\". \"));\n        }\n    }\n"}
{"id": 51744, "name": "Nested function", "source": "Translate Swift to Java: func makeList(_ separator: String) -> String {\n  var counter = 1\n  \n  func makeItem(_ item: String) -> String {\n    let result = String(counter) + separator + item + \"\\n\"\n    counter += 1\n    return result\n  }\n  \n  return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n}\n\nprint(makeList(\". \"))\n", "target": "module NestedFunction\n    {\n    static String makeList(String separator)\n        {\n        Int counter = 1;\n\n        function String(String) makeItem = item -> $\"{counter++}{separator}{item}\\n\";\n\n        return makeItem(\"first\")\n             + makeItem(\"second\")\n             + makeItem(\"third\");\n        }\n\n    void run()\n        {\n        @Inject Console console;\n        console.print(makeList(\". \"));\n        }\n    }\n"}
{"id": 51745, "name": "Nested function", "source": "Translate Swift to Python: func makeList(_ separator: String) -> String {\n  var counter = 1\n  \n  func makeItem(_ item: String) -> String {\n    let result = String(counter) + separator + item + \"\\n\"\n    counter += 1\n    return result\n  }\n  \n  return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n}\n\nprint(makeList(\". \"))\n", "target": "def makeList(separator):\n    counter = 1\n\n    def makeItem(item):\n        nonlocal counter\n        result = str(counter) + separator + item + \"\\n\"\n        counter += 1\n        return result\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n\nprint(makeList(\". \"))\n"}
{"id": 51746, "name": "Nested function", "source": "Translate Swift to Python: func makeList(_ separator: String) -> String {\n  var counter = 1\n  \n  func makeItem(_ item: String) -> String {\n    let result = String(counter) + separator + item + \"\\n\"\n    counter += 1\n    return result\n  }\n  \n  return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n}\n\nprint(makeList(\". \"))\n", "target": "def makeList(separator):\n    counter = 1\n\n    def makeItem(item):\n        nonlocal counter\n        result = str(counter) + separator + item + \"\\n\"\n        counter += 1\n        return result\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n\nprint(makeList(\". \"))\n"}
{"id": 52007, "name": "Sorting algorithms_Merge sort", "source": "Translate Swift to C#: \n\n\n\n\nimport Foundation\n\nfunc mergeSort(_ array: [Int]) -> [Int] {\n  guard array.count > 1 else { return array }\n\n  let middleIndex = array.count / 2\n\n  let leftPart = mergeSort(Array(array[0..<middleIndex]))\n  let rightPart = mergeSort(Array(array[middleIndex..<array.count]))\n\n  func merge(left: [Int], right: [Int]) -> [Int] {\n    var leftIndex = 0\n    var rightIndex = 0\n  \n    var merged = [Int]()\n    merged.reserveCapacity(left.count + right.count)\n  \n    while leftIndex < left.count && rightIndex < right.count {\n      if left[leftIndex] < right[rightIndex] {\n        merged.append(left[leftIndex])\n        leftIndex += 1\n      } else if left[leftIndex] > right[rightIndex] {\n        merged.append(right[rightIndex])\n        rightIndex += 1\n      } else {\n        merged.append(left[leftIndex])\n        leftIndex += 1\n        merged.append(right[rightIndex])\n        rightIndex += 1\n      }\n    }\n  \n    while leftIndex < left.count {\n      merged.append(left[leftIndex])\n      leftIndex += 1\n    }\n  \n    while rightIndex < right.count {\n      merged.append(right[rightIndex])\n      rightIndex += 1\n    }\n  \n    return merged\n  }\n\n  return merge(left: leftPart, right: rightPart)\n}\n", "target": "namespace RosettaCode {\n  using System;\n\n  public class MergeSort<T> where T : IComparable {\n    #region Constants\n    public const UInt32 INSERTION_LIMIT_DEFAULT = 12;\n    public const Int32 MERGES_DEFAULT = 6;\n    #endregion\n\n    #region Properties\n    public UInt32 InsertionLimit { get; }\n    protected UInt32[] Positions { get; set; }\n\n    private Int32 merges;\n    public Int32 Merges {\n      get { return merges; }\n      set {\n        \n        if (value > 1)\n          merges = value;\n        else\n          throw new ArgumentOutOfRangeException($\"value = {value} must be greater than one\", nameof(Merges));\n\n        if (Positions == null || Positions.Length != merges)\n          Positions = new UInt32[merges];\n      }\n    }\n    #endregion\n\n    #region Constructors\n    public MergeSort(UInt32 insertionLimit, Int32 merges) {\n      InsertionLimit = insertionLimit;\n      Merges = merges;\n    }\n\n    public MergeSort()\n      : this(INSERTION_LIMIT_DEFAULT, MERGES_DEFAULT) {\n    }\n    #endregion\n\n    #region Sort Methods\n    public void Sort(T[] entries) {\n      \n      var entries2 = new T[entries.Length];\n      Sort(entries, entries2, 0, entries.Length - 1);\n    }\n\n    \n    public void Sort(T[] entries1, T[] entries2, Int32 first, Int32 last) {\n      var length = last + 1 - first;\n      if (length < 2) return;      \n      if (length < Merges || length < InsertionLimit) {\n        InsertionSort<T>.Sort(entries1, first, last);\n        return;\n      }\n\n      var left = first;\n      var size = ceiling(length, Merges);\n      for (var remaining = length; remaining > 0; remaining -= size, left += size) {\n        var right = left + Math.Min(remaining, size) - 1;\n        Sort(entries1, entries2, left, right);\n      }\n\n      Merge(entries1, entries2, first, last);\n      Array.Copy(entries2, first, entries1, first, length);\n    }\n    #endregion\n\n    #region Merge Methods\n    public void Merge(T[] entries1, T[] entries2, Int32 first, Int32 last) {\n      Array.Clear(Positions, 0, Merges);\n      \n      for (var index = first; index <= last; index++)\n        entries2[index] = remove(entries1, first, last);\n    }\n\n    private T remove(T[] entries, Int32 first, Int32 last) {\n      T entry = default;\n      Int32? found = default;\n      var length = last + 1 - first;\n\n      var index = 0;\n      var left = first;\n      var size = ceiling(length, Merges);\n      for (var remaining = length; remaining > 0; remaining -= size, left += size, index++) {\n        var position = Positions[index];\n        if (position < Math.Min(remaining, size)) {\n          var next = entries[left + position];\n          if (!found.HasValue || entry.CompareTo(next) > 0) {\n            found = index;\n            entry = next;\n          }\n        }\n      }\n\n      \n      Positions[found.Value]++;\n      return entry;\n    }\n    #endregion\n\n    #region Math Methods\n    private static Int32 ceiling(Int32 numerator, Int32 denominator) {\n      return (numerator + denominator - 1) / denominator;\n    }\n    #endregion\n  }\n\n  #region Insertion Sort\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var next = first + 1; next <= last; next++)\n        insert(entries, first, next);\n    }\n\n    \n    private static void insert(T[] entries, Int32 first, Int32 next) {\n      var entry = entries[next];\n      while (next > first && entries[next - 1].CompareTo(entry) > 0)\n        entries[next] = entries[--next];\n      entries[next] = entry;\n    }\n  }\n  #endregion\n}\n"}
{"id": 52009, "name": "Sorting algorithms_Merge sort", "source": "Translate Swift to Java: \n\n\n\n\nimport Foundation\n\nfunc mergeSort(_ array: [Int]) -> [Int] {\n  guard array.count > 1 else { return array }\n\n  let middleIndex = array.count / 2\n\n  let leftPart = mergeSort(Array(array[0..<middleIndex]))\n  let rightPart = mergeSort(Array(array[middleIndex..<array.count]))\n\n  func merge(left: [Int], right: [Int]) -> [Int] {\n    var leftIndex = 0\n    var rightIndex = 0\n  \n    var merged = [Int]()\n    merged.reserveCapacity(left.count + right.count)\n  \n    while leftIndex < left.count && rightIndex < right.count {\n      if left[leftIndex] < right[rightIndex] {\n        merged.append(left[leftIndex])\n        leftIndex += 1\n      } else if left[leftIndex] > right[rightIndex] {\n        merged.append(right[rightIndex])\n        rightIndex += 1\n      } else {\n        merged.append(left[leftIndex])\n        leftIndex += 1\n        merged.append(right[rightIndex])\n        rightIndex += 1\n      }\n    }\n  \n    while leftIndex < left.count {\n      merged.append(left[leftIndex])\n      leftIndex += 1\n    }\n  \n    while rightIndex < right.count {\n      merged.append(right[rightIndex])\n      rightIndex += 1\n    }\n  \n    return merged\n  }\n\n  return merge(left: leftPart, right: rightPart)\n}\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Merge{\n    public static <E extends Comparable<? super E>> List<E> mergeSort(List<E> m){\n        if(m.size() <= 1) return m;\n\n        int middle = m.size() / 2;\n        List<E> left = m.subList(0, middle);\n        List<E> right = m.subList(middle, m.size());\n\n        right = mergeSort(right);\n        left = mergeSort(left);\n        List<E> result = merge(left, right);\n\n        return result;\n    }\n\n    public static <E extends Comparable<? super E>> List<E> merge(List<E> left, List<E> right){\n        List<E> result = new ArrayList<E>();\n        Iterator<E> it1 = left.iterator();\n        Iterator<E> it2 = right.iterator();\n\n\tE x = it1.next();\n\tE y = it2.next();\n        while (true){\n            \n            if(x.compareTo(y) <= 0){\n\t\tresult.add(x);\n\t\tif(it1.hasNext()){\n\t\t    x = it1.next();\n\t\t}else{\n\t\t    result.add(y);\n\t\t    while(it2.hasNext()){\n\t\t\tresult.add(it2.next());\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }else{\n\t\tresult.add(y);\n\t\tif(it2.hasNext()){\n\t\t    y = it2.next();\n\t\t}else{\n\t\t    result.add(x);\n\t\t    while (it1.hasNext()){\n\t\t\tresult.add(it1.next());\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n        }\n        return result;\n    }\n}\n"}
{"id": 52010, "name": "Sorting algorithms_Merge sort", "source": "Translate Swift to Python: \n\n\n\n\nimport Foundation\n\nfunc mergeSort(_ array: [Int]) -> [Int] {\n  guard array.count > 1 else { return array }\n\n  let middleIndex = array.count / 2\n\n  let leftPart = mergeSort(Array(array[0..<middleIndex]))\n  let rightPart = mergeSort(Array(array[middleIndex..<array.count]))\n\n  func merge(left: [Int], right: [Int]) -> [Int] {\n    var leftIndex = 0\n    var rightIndex = 0\n  \n    var merged = [Int]()\n    merged.reserveCapacity(left.count + right.count)\n  \n    while leftIndex < left.count && rightIndex < right.count {\n      if left[leftIndex] < right[rightIndex] {\n        merged.append(left[leftIndex])\n        leftIndex += 1\n      } else if left[leftIndex] > right[rightIndex] {\n        merged.append(right[rightIndex])\n        rightIndex += 1\n      } else {\n        merged.append(left[leftIndex])\n        leftIndex += 1\n        merged.append(right[rightIndex])\n        rightIndex += 1\n      }\n    }\n  \n    while leftIndex < left.count {\n      merged.append(left[leftIndex])\n      leftIndex += 1\n    }\n  \n    while rightIndex < right.count {\n      merged.append(right[rightIndex])\n      rightIndex += 1\n    }\n  \n    return merged\n  }\n\n  return merge(left: leftPart, right: rightPart)\n}\n", "target": "fun mergesort(m):\n    if m.lenght <= 1: return m\n    let middle = floor m.lenght / 2\n    let left = merge(m[:middle])\n    let right = merge(m[middle-1:]);\n\nfun merge(left, right):\n    let result = []\n    while not (left.isempty or right.isempty):\n        if left[1] <= right[1]:\n            result.push! left.shift!()\n        else:\n            result.push! right.shift!()\n    result.push! left.push! right\n\nlet arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]\nprint mergesort arr\n"}
{"id": 52727, "name": "Word frequency", "source": "Translate Swift to C#: import Foundation\n\nfunc printTopWords(path: String, count: Int) throws {\n    \n    let text = try String(contentsOfFile: path, encoding: String.Encoding.utf8)\n    var dict = Dictionary<String, Int>()\n    \n    let regex = try NSRegularExpression(pattern: \"\\\\w+\")\n    regex.enumerateMatches(in: text, range: NSRange(text.startIndex..., in: text)) {\n        (match, _, _) in\n        guard let match = match else { return }\n        let word = String(text[Range(match.range, in: text)!]).lowercased()\n        dict[word, default: 0] += 1\n    }\n    \n    let wordCounts = dict.sorted(by: {$0.1 > $1.1})\n    \n    print(\"Rank\\tWord\\tCount\")\n    for (i, (word, n)) in wordCounts.prefix(count).enumerated() {\n        print(\"\\(i + 1)\\t\\(word)\\t\\(n)\")\n    }\n}\n\ndo {\n    try printTopWords(path: \"135-0.txt\", count: 10)\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace WordCount {\n    class Program {\n        static void Main(string[] args) {\n            var text = File.ReadAllText(\"135-0.txt\").ToLower();\n\n            var match = Regex.Match(text, \"\\\\w+\");\n            Dictionary<string, int> freq = new Dictionary<string, int>();\n            while (match.Success) {\n                string word = match.Value;\n                if (freq.ContainsKey(word)) {\n                    freq[word]++;\n                } else {\n                    freq.Add(word, 1);\n                }\n\n                match = match.NextMatch();\n            }\n\n            Console.WriteLine(\"Rank  Word  Frequency\");\n            Console.WriteLine(\"====  ====  =========\");\n            int rank = 1;\n            foreach (var elem in freq.OrderByDescending(a => a.Value).Take(10)) {\n                Console.WriteLine(\"{0,2}    {1,-4}    {2,5}\", rank++, elem.Key, elem.Value);\n            }\n        }\n    }\n}\n"}
{"id": 52728, "name": "Word frequency", "source": "Translate Swift to C#: import Foundation\n\nfunc printTopWords(path: String, count: Int) throws {\n    \n    let text = try String(contentsOfFile: path, encoding: String.Encoding.utf8)\n    var dict = Dictionary<String, Int>()\n    \n    let regex = try NSRegularExpression(pattern: \"\\\\w+\")\n    regex.enumerateMatches(in: text, range: NSRange(text.startIndex..., in: text)) {\n        (match, _, _) in\n        guard let match = match else { return }\n        let word = String(text[Range(match.range, in: text)!]).lowercased()\n        dict[word, default: 0] += 1\n    }\n    \n    let wordCounts = dict.sorted(by: {$0.1 > $1.1})\n    \n    print(\"Rank\\tWord\\tCount\")\n    for (i, (word, n)) in wordCounts.prefix(count).enumerated() {\n        print(\"\\(i + 1)\\t\\(word)\\t\\(n)\")\n    }\n}\n\ndo {\n    try printTopWords(path: \"135-0.txt\", count: 10)\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace WordCount {\n    class Program {\n        static void Main(string[] args) {\n            var text = File.ReadAllText(\"135-0.txt\").ToLower();\n\n            var match = Regex.Match(text, \"\\\\w+\");\n            Dictionary<string, int> freq = new Dictionary<string, int>();\n            while (match.Success) {\n                string word = match.Value;\n                if (freq.ContainsKey(word)) {\n                    freq[word]++;\n                } else {\n                    freq.Add(word, 1);\n                }\n\n                match = match.NextMatch();\n            }\n\n            Console.WriteLine(\"Rank  Word  Frequency\");\n            Console.WriteLine(\"====  ====  =========\");\n            int rank = 1;\n            foreach (var elem in freq.OrderByDescending(a => a.Value).Take(10)) {\n                Console.WriteLine(\"{0,2}    {1,-4}    {2,5}\", rank++, elem.Key, elem.Value);\n            }\n        }\n    }\n}\n"}
{"id": 52731, "name": "Word frequency", "source": "Translate Swift to Java: import Foundation\n\nfunc printTopWords(path: String, count: Int) throws {\n    \n    let text = try String(contentsOfFile: path, encoding: String.Encoding.utf8)\n    var dict = Dictionary<String, Int>()\n    \n    let regex = try NSRegularExpression(pattern: \"\\\\w+\")\n    regex.enumerateMatches(in: text, range: NSRange(text.startIndex..., in: text)) {\n        (match, _, _) in\n        guard let match = match else { return }\n        let word = String(text[Range(match.range, in: text)!]).lowercased()\n        dict[word, default: 0] += 1\n    }\n    \n    let wordCounts = dict.sorted(by: {$0.1 > $1.1})\n    \n    print(\"Rank\\tWord\\tCount\")\n    for (i, (word, n)) in wordCounts.prefix(count).enumerated() {\n        print(\"\\(i + 1)\\t\\(word)\\t\\(n)\")\n    }\n}\n\ndo {\n    try printTopWords(path: \"135-0.txt\", count: 10)\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class WordCount {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"135-0.txt\");\n        byte[] bytes = Files.readAllBytes(path);\n        String text = new String(bytes);\n        text = text.toLowerCase();\n\n        Pattern r = Pattern.compile(\"\\\\p{javaLowerCase}+\");\n        Matcher matcher = r.matcher(text);\n        Map<String, Integer> freq = new HashMap<>();\n        while (matcher.find()) {\n            String word = matcher.group();\n            Integer current = freq.getOrDefault(word, 0);\n            freq.put(word, current + 1);\n        }\n\n        List<Map.Entry<String, Integer>> entries = freq.entrySet()\n            .stream()\n            .sorted((i1, i2) -> Integer.compare(i2.getValue(), i1.getValue()))\n            .limit(10)\n            .collect(Collectors.toList());\n\n        System.out.println(\"Rank  Word  Frequency\");\n        System.out.println(\"====  ====  =========\");\n        int rank = 1;\n        for (Map.Entry<String, Integer> entry : entries) {\n            String word = entry.getKey();\n            Integer count = entry.getValue();\n            System.out.printf(\"%2d   \u00a0%-4s    %5d\\n\", rank++, word, count);\n        }\n    }\n}\n"}
{"id": 52732, "name": "Word frequency", "source": "Translate Swift to Java: import Foundation\n\nfunc printTopWords(path: String, count: Int) throws {\n    \n    let text = try String(contentsOfFile: path, encoding: String.Encoding.utf8)\n    var dict = Dictionary<String, Int>()\n    \n    let regex = try NSRegularExpression(pattern: \"\\\\w+\")\n    regex.enumerateMatches(in: text, range: NSRange(text.startIndex..., in: text)) {\n        (match, _, _) in\n        guard let match = match else { return }\n        let word = String(text[Range(match.range, in: text)!]).lowercased()\n        dict[word, default: 0] += 1\n    }\n    \n    let wordCounts = dict.sorted(by: {$0.1 > $1.1})\n    \n    print(\"Rank\\tWord\\tCount\")\n    for (i, (word, n)) in wordCounts.prefix(count).enumerated() {\n        print(\"\\(i + 1)\\t\\(word)\\t\\(n)\")\n    }\n}\n\ndo {\n    try printTopWords(path: \"135-0.txt\", count: 10)\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class WordCount {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"135-0.txt\");\n        byte[] bytes = Files.readAllBytes(path);\n        String text = new String(bytes);\n        text = text.toLowerCase();\n\n        Pattern r = Pattern.compile(\"\\\\p{javaLowerCase}+\");\n        Matcher matcher = r.matcher(text);\n        Map<String, Integer> freq = new HashMap<>();\n        while (matcher.find()) {\n            String word = matcher.group();\n            Integer current = freq.getOrDefault(word, 0);\n            freq.put(word, current + 1);\n        }\n\n        List<Map.Entry<String, Integer>> entries = freq.entrySet()\n            .stream()\n            .sorted((i1, i2) -> Integer.compare(i2.getValue(), i1.getValue()))\n            .limit(10)\n            .collect(Collectors.toList());\n\n        System.out.println(\"Rank  Word  Frequency\");\n        System.out.println(\"====  ====  =========\");\n        int rank = 1;\n        for (Map.Entry<String, Integer> entry : entries) {\n            String word = entry.getKey();\n            Integer count = entry.getValue();\n            System.out.printf(\"%2d   \u00a0%-4s    %5d\\n\", rank++, word, count);\n        }\n    }\n}\n"}
{"id": 52733, "name": "Word frequency", "source": "Translate Swift to Python: import Foundation\n\nfunc printTopWords(path: String, count: Int) throws {\n    \n    let text = try String(contentsOfFile: path, encoding: String.Encoding.utf8)\n    var dict = Dictionary<String, Int>()\n    \n    let regex = try NSRegularExpression(pattern: \"\\\\w+\")\n    regex.enumerateMatches(in: text, range: NSRange(text.startIndex..., in: text)) {\n        (match, _, _) in\n        guard let match = match else { return }\n        let word = String(text[Range(match.range, in: text)!]).lowercased()\n        dict[word, default: 0] += 1\n    }\n    \n    let wordCounts = dict.sorted(by: {$0.1 > $1.1})\n    \n    print(\"Rank\\tWord\\tCount\")\n    for (i, (word, n)) in wordCounts.prefix(count).enumerated() {\n        print(\"\\(i + 1)\\t\\(word)\\t\\(n)\")\n    }\n}\n\ndo {\n    try printTopWords(path: \"135-0.txt\", count: 10)\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import collections\nimport re\nimport string\nimport sys\n\ndef main():\n  counter = collections.Counter(re.findall(r\"\\w+\",open(sys.argv[1]).read().lower()))\n  print counter.most_common(int(sys.argv[2]))\n\nif __name__ == \"__main__\":\n  main()\n"}
{"id": 52734, "name": "Word frequency", "source": "Translate Swift to Python: import Foundation\n\nfunc printTopWords(path: String, count: Int) throws {\n    \n    let text = try String(contentsOfFile: path, encoding: String.Encoding.utf8)\n    var dict = Dictionary<String, Int>()\n    \n    let regex = try NSRegularExpression(pattern: \"\\\\w+\")\n    regex.enumerateMatches(in: text, range: NSRange(text.startIndex..., in: text)) {\n        (match, _, _) in\n        guard let match = match else { return }\n        let word = String(text[Range(match.range, in: text)!]).lowercased()\n        dict[word, default: 0] += 1\n    }\n    \n    let wordCounts = dict.sorted(by: {$0.1 > $1.1})\n    \n    print(\"Rank\\tWord\\tCount\")\n    for (i, (word, n)) in wordCounts.prefix(count).enumerated() {\n        print(\"\\(i + 1)\\t\\(word)\\t\\(n)\")\n    }\n}\n\ndo {\n    try printTopWords(path: \"135-0.txt\", count: 10)\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import collections\nimport re\nimport string\nimport sys\n\ndef main():\n  counter = collections.Counter(re.findall(r\"\\w+\",open(sys.argv[1]).read().lower()))\n  print counter.most_common(int(sys.argv[2]))\n\nif __name__ == \"__main__\":\n  main()\n"}
{"id": 53242, "name": "Tic-tac-toe", "source": "Translate Swift to C#: import Darwin\n\nenum Token : CustomStringConvertible {\n\tcase cross, circle\n\t\n\tfunc matches(tokens: [Token?]) -> Bool {\n\t\tfor token in tokens {\n\t\t\tguard let t = token, t == self else { \n\t\t\t\treturn false \n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\t\n\tfunc emptyCell(in tokens: [Token?]) -> Int? {\n\t\tif tokens[0] == nil \n\t\t&& tokens[1] == self \n\t\t&& tokens[2] == self {\n\t\t\treturn 0\n\t\t} else\n\t\tif tokens[0] == self \n\t\t&& tokens[1] == nil \n\t\t&& tokens[2] == self {\n\t\t\treturn 1\n\t\t} else\n\t\tif tokens[0] == self \n\t\t&& tokens[1] == self \n\t\t&& tokens[2] == nil {\n\t\t\treturn 2\n\t\t}\n\t\treturn nil\n\t}\n\t\n\tvar description: String {\n\t\tswitch self {\n\t\t\tcase .cross: return \"x\" \n\t\t\tcase .circle: return \"o\"\n\t\t}\n\t}\n}\n\nstruct Board {\n\tvar cells: [Token?] = [nil, nil, nil, nil, nil, nil, nil, nil, nil]\n\t\n\tfunc cells(atCol col: Int) -> [Token?] {\n\t\treturn [cells[col], cells[col + 3], cells[col + 6]]\n\t}\n\t\n\tfunc cells(atRow row: Int) -> [Token?] {\n\t\treturn [cells[row * 3], cells[row * 3 + 1], cells[row * 3 + 2]]\n\t}\n\t\n\tfunc cellsTopLeft() -> [Token?] {\n\t\treturn [cells[0], cells[4], cells[8]]\n\t}\n\t\n\tfunc cellsBottomLeft() -> [Token?] {\n\t\treturn [cells[6], cells[4], cells[2]]\n\t}\n\t\n\tfunc winner() -> Token? {\n\t\tlet r0 = cells(atRow: 0)\n\t\tlet r1 = cells(atRow: 1)\n\t\tlet r2 = cells(atRow: 2)\n\t\tlet c0 = cells(atCol: 0)\n\t\tlet c1 = cells(atCol: 1)\n\t\tlet c2 = cells(atCol: 2)\n\t\tlet tl = cellsTopLeft()\n\t\tlet bl = cellsBottomLeft()\n\t\t\n\t\tif Token.cross.matches(tokens: r0)\n\t\t|| Token.cross.matches(tokens: r1)\n\t\t|| Token.cross.matches(tokens: r2)\n\t\t|| Token.cross.matches(tokens: c0)\n\t\t|| Token.cross.matches(tokens: c1)\n\t\t|| Token.cross.matches(tokens: c2)\n\t\t|| Token.cross.matches(tokens: tl)\n\t\t|| Token.cross.matches(tokens: bl) {\n\t\t\treturn .cross\n\t\t} else \n\t\tif Token.circle.matches(tokens: r0)\n\t\t|| Token.circle.matches(tokens: r1)\n\t\t|| Token.circle.matches(tokens: r2)\n\t\t|| Token.circle.matches(tokens: c0)\n\t\t|| Token.circle.matches(tokens: c1)\n\t\t|| Token.circle.matches(tokens: c2)\n\t\t|| Token.circle.matches(tokens: tl)\n\t\t|| Token.circle.matches(tokens: bl) {\n\t\t\treturn .circle\n\t\t}\n\t\treturn nil\n\t}\n\t\n\tfunc atCapacity() -> Bool {\n\t\treturn cells.filter { $0 == nil }.count == 0\n\t}\n\t\n\tmutating func play(token: Token, at location: Int) {\n\t\tcells[location] = token\n\t}\n\t\n\tfunc findBestLocation(for player: Token) -> Int? {\n\t\tlet r0 = cells(atRow: 0)\n\t\tlet r1 = cells(atRow: 1)\n\t\tlet r2 = cells(atRow: 2)\n\t\tlet c0 = cells(atCol: 0)\n\t\tlet c1 = cells(atCol: 1)\n\t\tlet c2 = cells(atCol: 2)\n\t\tlet tl = cellsTopLeft()\n\t\tlet bl = cellsBottomLeft()\n\t\t\n\t\tif let cell = player.emptyCell(in: r0) {\n\t\t\treturn cell\n\t\t} else if let cell = player.emptyCell(in: r1) {\n\t\t\treturn cell + 3\n\t\t} else if let cell = player.emptyCell(in: r2) {\n\t\t\treturn cell + 6\n\t\t} else if let cell = player.emptyCell(in: c0) {\n\t\t\treturn cell * 3\n\t\t} else if let cell = player.emptyCell(in: c1) {\n\t\t\treturn cell * 3 + 1\n\t\t} else if let cell = player.emptyCell(in: c2) {\n\t\t\treturn cell * 3 + 2\n\t\t} else if let cell = player.emptyCell(in: tl) {\n\t\t\treturn cell == 0 ? 0 : (cell == 1 ? 4 : 8)\n\t\t} else if let cell = player.emptyCell(in: bl) {\n\t\t\treturn cell == 0 ? 6 : (cell == 1 ? 4 : 2)\n\t\t}\n\t\treturn nil\n\t}\n\t\n\tfunc findMove() -> Int {\n\t\tlet empties = cells.enumerated().filter { $0.1 == nil }\n\t\tlet r = Int(arc4random()) % empties.count\n\t\treturn empties[r].0\n\t}\n}\n\nextension Board : CustomStringConvertible {\n\tvar description: String {\n\t\tvar result = \"\\n---------------\\n\"\n\t\tfor (idx, cell) in cells.enumerated() {\n\t\t\tif let cell = cell {\n\t\t\t\tresult += \"| \\(cell) |\"\n\t\t\t} else {\n\t\t\t\tresult += \"| \\(idx) |\"\n\t\t\t}\n\t\t\t\n\t\t\tif (idx + 1) % 3 == 0 {\n\t\t\t\tresult += \"\\n---------------\\n\"\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n}\n\nwhile true {\n\tvar board = Board()\n\tprint(\"Who do you want to play as ('o' or 'x'): \", separator: \"\", terminator: \"\")\n\tlet answer = readLine()?.characters.first ?? \"x\"\n\t\n\tvar player: Token = answer == \"x\" ? .cross : .circle\n\tvar pc: Token = player == .cross ? .circle : .cross\n\t\n\tprint(board)\n\t\n\twhile true {\n\t\tprint(\"Choose cell to play on: \", separator: \"\", terminator: \"\")\n\t\tvar pos = Int(readLine() ?? \"0\") ?? 0\n\t\twhile !board.atCapacity() && board.cells[pos] != nil {\n\t\t\tprint(\"Invalid move. Choose cell to play on: \", separator: \"\", terminator: \"\")\n\t\t\tpos = Int(readLine() ?? \"0\") ?? 0\n\t\t}\n\t\t\n\t\tif board.atCapacity() {\n\t\t\tprint(\"Draw\")\n\t\t\tbreak\n\t\t}\n\t\t\n\t\tboard.play(token: player, at: pos)\n\t\tprint(board)\n\t\t\n\t\tif let winner = board.winner() {\n\t\t\tprint(\"winner is \\(winner)\")\n\t\t\tbreak\n\t\t} else if board.atCapacity() {\n\t\t\tprint(\"Draw\")\n\t\t\tbreak\n\t\t}\n\t\t\n\t\tif let win = board.findBestLocation(for: pc) {\n\t\t\tboard.play(token: pc, at: win)\n\t\t} else if let def = board.findBestLocation(for: player) {\n\t\t\tboard.play(token: pc, at: def)\n\t\t} else {\n\t\t\tboard.play(token: pc, at: board.findMove())\n\t\t}\n\t\t\n\t\tprint(board)\n\t\t\n\t\tif let winner = board.winner() {\n\t\t\tprint(\"winner is \\(winner)\")\n\t\t\tbreak\n\t\t}\n\t}\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaTicTacToe\n{\n  class Program\n  {\n\n    \n    static string[][] Players = new string[][] { \n      new string[] { \"COMPUTER\", \"X\" }, \n      new string[] { \"HUMAN\", \"O\" }     \n    };\n\n    const int Unplayed = -1;\n    const int Computer = 0;\n    const int Human = 1;\n\n    \n    static int[] GameBoard = new int[9];\n\n    static int[] corners = new int[] { 0, 2, 6, 8 };\n\n    static int[][] wins = new int[][] { \n      new int[] { 0, 1, 2 }, new int[] { 3, 4, 5 }, new int[] { 6, 7, 8 }, \n      new int[] { 0, 3, 6 }, new int[] { 1, 4, 7 }, new int[] { 2, 5, 8 }, \n      new int[] { 0, 4, 8 }, new int[] { 2, 4, 6 } };\n\n\n    \n    static void Main(string[] args)\n    {\n      while (true)\n      {\n        Console.Clear();\n        Console.WriteLine(\"Welcome to Rosetta Code Tic-Tac-Toe for C#.\");\n        initializeGameBoard();\n        displayGameBoard();\n        int currentPlayer = rnd.Next(0, 2);  \n        Console.WriteLine(\"The first move goes to {0} who is playing {1}s.\\n\", playerName(currentPlayer), playerToken(currentPlayer));\n        while (true)\n        {\n          int thisMove = getMoveFor(currentPlayer);\n          if (thisMove == Unplayed)\n          {\n            Console.WriteLine(\"{0}, you've quit the game ... am I that good?\", playerName(currentPlayer));\n            break;\n          }\n          playMove(thisMove, currentPlayer);\n          displayGameBoard();\n          if (isGameWon())\n          {\n            Console.WriteLine(\"{0} has won the game!\", playerName(currentPlayer));\n            break;\n          }\n          else if (isGameTied())\n          {\n            Console.WriteLine(\"Cat game ... we have a tie.\");\n            break;\n          }\n          currentPlayer = getNextPlayer(currentPlayer);\n        }\n        if (!playAgain())\n          return;\n      }\n    }\n\n    \n    static int getMoveFor(int player)\n    {\n      if (player == Human)\n        return getManualMove(player);\n      else\n      {\n        \n        \n        int selectedMove = getSemiRandomMove(player);\n        \n        Console.WriteLine(\"{0} selects position {1}.\", playerName(player), selectedMove + 1);\n        return selectedMove;\n      }\n    }\n\n    static int getManualMove(int player)\n    {\n      while (true)\n      {\n        Console.Write(\"{0}, enter you move (number): \", playerName(player));\n        ConsoleKeyInfo keyInfo = Console.ReadKey();\n        Console.WriteLine();  \n        if (keyInfo.Key == ConsoleKey.Escape)\n          return Unplayed;\n        if (keyInfo.Key >= ConsoleKey.D1 && keyInfo.Key <= ConsoleKey.D9)\n        {\n          int move = keyInfo.KeyChar - '1';  \n          if (GameBoard[move] == Unplayed)\n            return move;\n          else\n            Console.WriteLine(\"Spot {0} is already taken, please select again.\", move + 1);\n        }\n        else\n          Console.WriteLine(\"Illegal move, please select again.\\n\");\n      }\n    }\n\n    static int getRandomMove(int player)\n    {\n      int movesLeft = GameBoard.Count(position => position == Unplayed);\n      int x = rnd.Next(0, movesLeft);\n      for (int i = 0; i < GameBoard.Length; i++)  \n      {\n        if (GameBoard[i] == Unplayed && x < 0)    \n          return i;\n        x--;\n      }\n      return Unplayed;\n    }\n\n    \n    static int getSemiRandomMove(int player)\n    {\n      int posToPlay;\n      if (checkForWinningMove(player, out posToPlay))\n        return posToPlay;\n      if (checkForBlockingMove(player, out posToPlay))\n        return posToPlay;\n      return getRandomMove(player);\n    }\n\n    \n    static int getBestMove(int player)\n    {\n      return -1;\n    }\n\n    static bool checkForWinningMove(int player, out int posToPlay)\n    {\n      posToPlay = Unplayed;\n      foreach (var line in wins)\n        if (twoOfThreeMatchPlayer(player, line, out posToPlay))\n          return true;\n      return false;\n    }\n\n    static bool checkForBlockingMove(int player, out int posToPlay)\n    {\n      posToPlay = Unplayed;\n      foreach (var line in wins)\n        if (twoOfThreeMatchPlayer(getNextPlayer(player), line, out posToPlay))\n          return true;\n      return false;\n    }\n\n    static bool twoOfThreeMatchPlayer(int player, int[] line, out int posToPlay)\n    {\n      int cnt = 0;\n      posToPlay = int.MinValue;\n      foreach (int pos in line)\n      {\n        if (GameBoard[pos] == player)\n          cnt++;\n        else if (GameBoard[pos] == Unplayed)\n          posToPlay = pos;\n      }\n      return cnt == 2 && posToPlay >= 0;\n    }\n\n    static void playMove(int boardPosition, int player)\n    {\n      GameBoard[boardPosition] = player;\n    }\n\n    static bool isGameWon()\n    {\n      return wins.Any(line => takenBySamePlayer(line[0], line[1], line[2]));\n    }\n\n    static bool takenBySamePlayer(int a, int b, int c)\n    {\n      return GameBoard[a] != Unplayed && GameBoard[a] == GameBoard[b] && GameBoard[a] == GameBoard[c];\n    }\n\n    static bool isGameTied()\n    {\n      return !GameBoard.Any(spot => spot == Unplayed);\n    }\n\n    \n    static Random rnd = new Random();\n\n    static void initializeGameBoard()\n    {\n      for (int i = 0; i < GameBoard.Length; i++)\n        GameBoard[i] = Unplayed;\n    }\n\n    static string playerName(int player)\n    {\n      return Players[player][0];\n    }\n\n    static string playerToken(int player)\n    {\n      return Players[player][1];\n    }\n\n    static int getNextPlayer(int player)\n    {\n      return (player + 1) % 2;\n    }\n\n    static void displayGameBoard()\n    {\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(0), pieceAt(1), pieceAt(2));\n      Console.WriteLine(\"---|---|---\");\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(3), pieceAt(4), pieceAt(5));\n      Console.WriteLine(\"---|---|---\");\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(6), pieceAt(7), pieceAt(8));\n      Console.WriteLine();\n    }\n\n    static string pieceAt(int boardPosition)\n    {\n      if (GameBoard[boardPosition] == Unplayed)\n        return (boardPosition + 1).ToString();  \n      return playerToken(GameBoard[boardPosition]);\n    }\n\n    private static bool playAgain()\n    {\n      Console.WriteLine(\"\\nDo you want to play again?\");\n      return Console.ReadKey(false).Key == ConsoleKey.Y;\n    }\n  }\n\n}\n"}
{"id": 53244, "name": "Tic-tac-toe", "source": "Translate Swift to Python: import Darwin\n\nenum Token : CustomStringConvertible {\n\tcase cross, circle\n\t\n\tfunc matches(tokens: [Token?]) -> Bool {\n\t\tfor token in tokens {\n\t\t\tguard let t = token, t == self else { \n\t\t\t\treturn false \n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\t\n\tfunc emptyCell(in tokens: [Token?]) -> Int? {\n\t\tif tokens[0] == nil \n\t\t&& tokens[1] == self \n\t\t&& tokens[2] == self {\n\t\t\treturn 0\n\t\t} else\n\t\tif tokens[0] == self \n\t\t&& tokens[1] == nil \n\t\t&& tokens[2] == self {\n\t\t\treturn 1\n\t\t} else\n\t\tif tokens[0] == self \n\t\t&& tokens[1] == self \n\t\t&& tokens[2] == nil {\n\t\t\treturn 2\n\t\t}\n\t\treturn nil\n\t}\n\t\n\tvar description: String {\n\t\tswitch self {\n\t\t\tcase .cross: return \"x\" \n\t\t\tcase .circle: return \"o\"\n\t\t}\n\t}\n}\n\nstruct Board {\n\tvar cells: [Token?] = [nil, nil, nil, nil, nil, nil, nil, nil, nil]\n\t\n\tfunc cells(atCol col: Int) -> [Token?] {\n\t\treturn [cells[col], cells[col + 3], cells[col + 6]]\n\t}\n\t\n\tfunc cells(atRow row: Int) -> [Token?] {\n\t\treturn [cells[row * 3], cells[row * 3 + 1], cells[row * 3 + 2]]\n\t}\n\t\n\tfunc cellsTopLeft() -> [Token?] {\n\t\treturn [cells[0], cells[4], cells[8]]\n\t}\n\t\n\tfunc cellsBottomLeft() -> [Token?] {\n\t\treturn [cells[6], cells[4], cells[2]]\n\t}\n\t\n\tfunc winner() -> Token? {\n\t\tlet r0 = cells(atRow: 0)\n\t\tlet r1 = cells(atRow: 1)\n\t\tlet r2 = cells(atRow: 2)\n\t\tlet c0 = cells(atCol: 0)\n\t\tlet c1 = cells(atCol: 1)\n\t\tlet c2 = cells(atCol: 2)\n\t\tlet tl = cellsTopLeft()\n\t\tlet bl = cellsBottomLeft()\n\t\t\n\t\tif Token.cross.matches(tokens: r0)\n\t\t|| Token.cross.matches(tokens: r1)\n\t\t|| Token.cross.matches(tokens: r2)\n\t\t|| Token.cross.matches(tokens: c0)\n\t\t|| Token.cross.matches(tokens: c1)\n\t\t|| Token.cross.matches(tokens: c2)\n\t\t|| Token.cross.matches(tokens: tl)\n\t\t|| Token.cross.matches(tokens: bl) {\n\t\t\treturn .cross\n\t\t} else \n\t\tif Token.circle.matches(tokens: r0)\n\t\t|| Token.circle.matches(tokens: r1)\n\t\t|| Token.circle.matches(tokens: r2)\n\t\t|| Token.circle.matches(tokens: c0)\n\t\t|| Token.circle.matches(tokens: c1)\n\t\t|| Token.circle.matches(tokens: c2)\n\t\t|| Token.circle.matches(tokens: tl)\n\t\t|| Token.circle.matches(tokens: bl) {\n\t\t\treturn .circle\n\t\t}\n\t\treturn nil\n\t}\n\t\n\tfunc atCapacity() -> Bool {\n\t\treturn cells.filter { $0 == nil }.count == 0\n\t}\n\t\n\tmutating func play(token: Token, at location: Int) {\n\t\tcells[location] = token\n\t}\n\t\n\tfunc findBestLocation(for player: Token) -> Int? {\n\t\tlet r0 = cells(atRow: 0)\n\t\tlet r1 = cells(atRow: 1)\n\t\tlet r2 = cells(atRow: 2)\n\t\tlet c0 = cells(atCol: 0)\n\t\tlet c1 = cells(atCol: 1)\n\t\tlet c2 = cells(atCol: 2)\n\t\tlet tl = cellsTopLeft()\n\t\tlet bl = cellsBottomLeft()\n\t\t\n\t\tif let cell = player.emptyCell(in: r0) {\n\t\t\treturn cell\n\t\t} else if let cell = player.emptyCell(in: r1) {\n\t\t\treturn cell + 3\n\t\t} else if let cell = player.emptyCell(in: r2) {\n\t\t\treturn cell + 6\n\t\t} else if let cell = player.emptyCell(in: c0) {\n\t\t\treturn cell * 3\n\t\t} else if let cell = player.emptyCell(in: c1) {\n\t\t\treturn cell * 3 + 1\n\t\t} else if let cell = player.emptyCell(in: c2) {\n\t\t\treturn cell * 3 + 2\n\t\t} else if let cell = player.emptyCell(in: tl) {\n\t\t\treturn cell == 0 ? 0 : (cell == 1 ? 4 : 8)\n\t\t} else if let cell = player.emptyCell(in: bl) {\n\t\t\treturn cell == 0 ? 6 : (cell == 1 ? 4 : 2)\n\t\t}\n\t\treturn nil\n\t}\n\t\n\tfunc findMove() -> Int {\n\t\tlet empties = cells.enumerated().filter { $0.1 == nil }\n\t\tlet r = Int(arc4random()) % empties.count\n\t\treturn empties[r].0\n\t}\n}\n\nextension Board : CustomStringConvertible {\n\tvar description: String {\n\t\tvar result = \"\\n---------------\\n\"\n\t\tfor (idx, cell) in cells.enumerated() {\n\t\t\tif let cell = cell {\n\t\t\t\tresult += \"| \\(cell) |\"\n\t\t\t} else {\n\t\t\t\tresult += \"| \\(idx) |\"\n\t\t\t}\n\t\t\t\n\t\t\tif (idx + 1) % 3 == 0 {\n\t\t\t\tresult += \"\\n---------------\\n\"\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n}\n\nwhile true {\n\tvar board = Board()\n\tprint(\"Who do you want to play as ('o' or 'x'): \", separator: \"\", terminator: \"\")\n\tlet answer = readLine()?.characters.first ?? \"x\"\n\t\n\tvar player: Token = answer == \"x\" ? .cross : .circle\n\tvar pc: Token = player == .cross ? .circle : .cross\n\t\n\tprint(board)\n\t\n\twhile true {\n\t\tprint(\"Choose cell to play on: \", separator: \"\", terminator: \"\")\n\t\tvar pos = Int(readLine() ?? \"0\") ?? 0\n\t\twhile !board.atCapacity() && board.cells[pos] != nil {\n\t\t\tprint(\"Invalid move. Choose cell to play on: \", separator: \"\", terminator: \"\")\n\t\t\tpos = Int(readLine() ?? \"0\") ?? 0\n\t\t}\n\t\t\n\t\tif board.atCapacity() {\n\t\t\tprint(\"Draw\")\n\t\t\tbreak\n\t\t}\n\t\t\n\t\tboard.play(token: player, at: pos)\n\t\tprint(board)\n\t\t\n\t\tif let winner = board.winner() {\n\t\t\tprint(\"winner is \\(winner)\")\n\t\t\tbreak\n\t\t} else if board.atCapacity() {\n\t\t\tprint(\"Draw\")\n\t\t\tbreak\n\t\t}\n\t\t\n\t\tif let win = board.findBestLocation(for: pc) {\n\t\t\tboard.play(token: pc, at: win)\n\t\t} else if let def = board.findBestLocation(for: player) {\n\t\t\tboard.play(token: pc, at: def)\n\t\t} else {\n\t\t\tboard.play(token: pc, at: board.findMove())\n\t\t}\n\t\t\n\t\tprint(board)\n\t\t\n\t\tif let winner = board.winner() {\n\t\t\tprint(\"winner is \\(winner)\")\n\t\t\tbreak\n\t\t}\n\t}\n}\n", "target": "\n\nimport random\n\nboard = list('123456789')\nwins = ((0,1,2), (3,4,5), (6,7,8),\n        (0,3,6), (1,4,7), (2,5,8),\n        (0,4,8), (2,4,6))\n\ndef printboard():\n    print('\\n'.join(' '.join(board[x:x+3]) for x in(0,3,6)))\n\ndef score():\n    for w in wins:\n        b = board[w[0]]\n        if b in 'XO' and all (board[i] == b for i in w):\n            return b, [i+1 for i in w]\n    return None, None\n\ndef finished():\n    return all (b in 'XO' for b in board)\n\ndef space():\n    return [ b for b in board if b not in 'XO']\n\ndef my_turn(xo):\n    options = space()\n    choice = random.choice(options)\n    board[int(choice)-1] = xo\n    return choice\n\ndef your_turn(xo):\n    options = space()\n    while True:\n        choice = input(\" Put your %s in any of these positions: %s \"\n                       % (xo, ''.join(options))).strip()\n        if choice in options:\n            break\n        print( \"Whoops I don't understand the input\" )\n    board[int(choice)-1] = xo\n    return choice\n\ndef me(xo='X'):\n    printboard()\n    print('I go at', my_turn(xo))\n    return score()\n    assert not s[0], \"\\n%s wins across %s\" % s\n\ndef you(xo='O'):\n    printboard()\n    \n    print('You went at', your_turn(xo))\n    return score()\n    assert not s[0], \"\\n%s wins across %s\" % s\n\n\nprint(__doc__)\nwhile not finished():\n    s = me('X')\n    if s[0]:\n        printboard()\n        print(\"\\n%s wins across %s\" % s)\n        break\n    if not finished():\n        s = you('O')\n        if s[0]:\n            printboard()\n            print(\"\\n%s wins across %s\" % s)\n            break\nelse:\n    print('\\nA draw')\n"}
{"id": 53500, "name": "Pick random element", "source": "Translate Swift to C#: import Darwin\n\nlet myList = [1, 2, 4, 5, 62, 234, 1, -1]\nprint(myList[Int(arc4random_uniform(UInt32(myList.count)))])\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass RandomElementPicker {\n  static void Main() {\n    var list = new List<int>(new[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n    var rng = new Random();\n    var randomElement = list[rng.Next(list.Count)];\n    Console.WriteLine(\"I picked element {0}\", randomElement);\n  }\n}\n"}
{"id": 53502, "name": "Pick random element", "source": "Translate Swift to Java: import Darwin\n\nlet myList = [1, 2, 4, 5, 62, 234, 1, -1]\nprint(myList[Int(arc4random_uniform(UInt32(myList.count)))])\n", "target": "import java.util.Random;\n...\nint[] array = {1,2,3};\nreturn array[new Random().nextInt(array.length)]; \n"}
{"id": 53503, "name": "Pick random element", "source": "Translate Swift to Python: import Darwin\n\nlet myList = [1, 2, 4, 5, 62, 234, 1, -1]\nprint(myList[Int(arc4random_uniform(UInt32(myList.count)))])\n", "target": ">>> import random\n>>> random.choice(['foo', 'bar', 'baz'])\n'baz'\n"}
{"id": 53756, "name": "Jensen's Device", "source": "Translate Swift to C#: var i = 42 \n\nfunc sum(inout i: Int, lo: Int, hi: Int, @autoclosure term: () -> Double) -> Double {\n  var result = 0.0\n  for i = lo; i <= hi; i++ {\n    result += term()\n  }\n  return result\n}\n\nprintln(sum(&i, 1, 100, 1 / Double(i)))\n", "target": "using System;\n\nclass JensensDevice\n{    \n    public static double Sum(ref int i, int lo, int hi, Func<double> term)\n    {\n        double temp = 0.0;\n        for (i = lo; i <= hi; i++)\n        {\n            temp += term();\n        }\n        return temp;\n    }\n\n    static void Main()\n    {\n        int i = 0;\n        Console.WriteLine(Sum(ref i, 1, 100, () => 1.0 / i));\n    }\n}\n"}
{"id": 53758, "name": "Jensen's Device", "source": "Translate Swift to Java: var i = 42 \n\nfunc sum(inout i: Int, lo: Int, hi: Int, @autoclosure term: () -> Double) -> Double {\n  var result = 0.0\n  for i = lo; i <= hi; i++ {\n    result += term()\n  }\n  return result\n}\n\nprintln(sum(&i, 1, 100, 1 / Double(i)))\n", "target": "import java.util.function.*;\nimport java.util.stream.*;\n\npublic class Jensen {\n    static double sum(int lo, int hi, IntToDoubleFunction f) {\n        return IntStream.rangeClosed(lo, hi).mapToDouble(f).sum();\n    }\n        \n    public static void main(String args[]) {\n        System.out.println(sum(1, 100, (i -> 1.0/i)));\n    }\n}\n"}
{"id": 53759, "name": "Jensen's Device", "source": "Translate Swift to Python: var i = 42 \n\nfunc sum(inout i: Int, lo: Int, hi: Int, @autoclosure term: () -> Double) -> Double {\n  var result = 0.0\n  for i = lo; i <= hi; i++ {\n    result += term()\n  }\n  return result\n}\n\nprintln(sum(&i, 1, 100, 1 / Double(i)))\n", "target": "class Ref(object):\n    def __init__(self, value=None):\n        self.value = value\n\ndef harmonic_sum(i, lo, hi, term):\n    \n    temp = 0\n    i.value = lo\n    while i.value <= hi:  \n        temp += term() \n        i.value += 1   \n    return temp\n\ni = Ref()\n\n\n\nprint harmonic_sum(i, 1, 100, lambda: 1.0/i.value)\n"}
{"id": 54031, "name": "Greatest element of a list", "source": "Translate Swift to C#: if let x = [4,3,5,9,2,3].maxElement() {\n  print(x) \n}\n", "target": "int[] values = new int[] {1,2,3,4,5,6,7,8,9,10};\n\nint max = values.Max();\n"}
{"id": 54033, "name": "Greatest element of a list", "source": "Translate Swift to Java: if let x = [4,3,5,9,2,3].maxElement() {\n  print(x) \n}\n", "target": "public static float max(float[] values) throws NoSuchElementException {\n    if (values.length == 0)\n        throw new NoSuchElementException();\n    float themax = values[0];\n    for (int idx = 1; idx < values.length; ++idx) {\n        if (values[idx] > themax)\n            themax = values[idx];\n    }\n    return themax;\n}\n"}
{"id": 54137, "name": "Safe addition", "source": "Translate Swift to C#: let a = 1.2\nlet b = 0.03\n\nprint(\"\\(a) + \\(b) is in the range \\((a + b).nextDown)...\\((a + b).nextUp)\")\n", "target": "using System;\n\nnamespace SafeAddition {\n    class Program {\n        static float NextUp(float d) {\n            if (d == 0.0) return float.Epsilon;\n            if (float.IsNaN(d) || float.IsNegativeInfinity(d) || float.IsPositiveInfinity(d)) return d;\n\n            byte[] bytes = BitConverter.GetBytes(d);\n            int dl = BitConverter.ToInt32(bytes, 0);\n            dl++;\n            bytes = BitConverter.GetBytes(dl);\n\n            return BitConverter.ToSingle(bytes, 0);\n        }\n\n        static float NextDown(float d) {\n            if (d == 0.0) return -float.Epsilon;\n            if (float.IsNaN(d) || float.IsNegativeInfinity(d) || float.IsPositiveInfinity(d)) return d;\n\n            byte[] bytes = BitConverter.GetBytes(d);\n            int dl = BitConverter.ToInt32(bytes, 0);\n            dl--;\n            bytes = BitConverter.GetBytes(dl);\n\n            return BitConverter.ToSingle(bytes, 0);\n        }\n\n        static Tuple<float, float> SafeAdd(float a, float b) {\n            return new Tuple<float, float>(NextDown(a + b), NextUp(a + b));\n        }\n\n        static void Main(string[] args) {\n            float a = 1.20f;\n            float b = 0.03f;\n\n            Console.WriteLine(\"({0} + {1}) is in the range {2}\", a, b, SafeAdd(a, b));\n        }\n    }\n}\n"}
{"id": 54139, "name": "Safe addition", "source": "Translate Swift to Java: let a = 1.2\nlet b = 0.03\n\nprint(\"\\(a) + \\(b) is in the range \\((a + b).nextDown)...\\((a + b).nextUp)\")\n", "target": "public class SafeAddition {\n    private static double stepDown(double d) {\n        return Math.nextAfter(d, Double.NEGATIVE_INFINITY);\n    }\n\n    private static double stepUp(double d) {\n        return Math.nextUp(d);\n    }\n\n    private static double[] safeAdd(double a, double b) {\n        return new double[]{stepDown(a + b), stepUp(a + b)};\n    }\n\n    public static void main(String[] args) {\n        double a = 1.2;\n        double b = 0.03;\n        double[] result = safeAdd(a, b);\n        System.out.printf(\"(%.2f +\u00a0%.2f) is in the range\u00a0%.16f..%.16f\", a, b, result[0], result[1]);\n    }\n}\n"}
{"id": 54140, "name": "Safe addition", "source": "Translate Swift to Python: let a = 1.2\nlet b = 0.03\n\nprint(\"\\(a) + \\(b) is in the range \\((a + b).nextDown)...\\((a + b).nextUp)\")\n", "target": ">>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])\n0.9999999999999999\n>>> from math import fsum\n>>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])\n1.0\n"}
{"id": 54274, "name": "Discordian date", "source": "Translate Swift to C#: import Foundation\n\nlet monthDays = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]\nlet seasons = [\"Chaos\", \"Discord\", \"Confusion\", \"Bureacracy\", \"The Aftermath\"]\nlet dayNames = [\"Sweetmorn\", \"Boomtime\", \"Pungenday\", \"Prickle-Prickle\", \"Setting Orange\"]\nlet holyDays1 = [\"Mungday\", \"Mojoday\", \"Syaday\", \"Zaraday\", \"Maladay\"]\nlet holyDays2 = [\"Chaoflux\", \"Discoflux\", \"Confuflux\", \"Bureflux\", \"Afflux\"]\n\nfunc discordianDate(date: Date) -> String {\n    let calendar = Calendar.current\n    let year = calendar.component(.year, from: date)\n    let month = calendar.component(.month, from: date)\n    let day = calendar.component(.day, from: date)\n    let discYear = year + 1166\n    if month == 2 && day == 29 {\n        return \"St. Tib's Day in the YOLD \\(discYear)\"\n    }\n    let dayOfYear = monthDays[month - 1] + day - 1\n    let season = dayOfYear/73\n    let weekDay = dayOfYear % 5\n    let dayOfSeason = 1 + dayOfYear % 73\n    let ddate = \"\\(dayNames[weekDay]), day \\(dayOfSeason) of \\(seasons[season]) in the YOLD \\(discYear)\"\n    switch (dayOfSeason) {\n    case 5:\n        return ddate + \". Celebrate \\(holyDays1[season])!\"\n    case 50:\n        return ddate + \". Celebrate \\(holyDays2[season])!\"\n    default:\n        return ddate\n    }\n}\n\nfunc showDiscordianDate(year: Int, month: Int, day: Int) {\n    let calendar = Calendar.current\n    let date = calendar.date(from: DateComponents(year: year, month: month, day: day))!\n    let ddate = discordianDate(date: date)\n    let format = DateFormatter()\n    format.dateFormat = \"yyyy-MM-dd\"\n    print(\"\\(format.string(from: date)): \\(ddate)\")\n}\n\nshowDiscordianDate(year: 2022, month: 1, day: 20)\nshowDiscordianDate(year: 2020, month: 9, day: 21)\nshowDiscordianDate(year: 2020, month: 2, day: 29)\nshowDiscordianDate(year: 2019, month: 7, day: 15)\nshowDiscordianDate(year: 2025, month: 3, day: 19)\nshowDiscordianDate(year: 2017, month: 12, day: 8)\n", "target": "using System;\n\npublic static class DiscordianDate\n{\n    static readonly string[] seasons = { \"Chaos\", \"Discord\", \"Confusion\", \"Bureaucracy\", \"The Aftermath\" };\n    static readonly string[] weekdays = { \"Sweetmorn\", \"Boomtime\", \"Pungenday\", \"Prickle-Prickle\", \"Setting Orange\" };\n    static readonly string[] apostles = { \"Mungday\", \"Mojoday\", \"Syaday\", \"Zaraday\", \"Maladay\" };\n    static readonly string[] holidays = { \"Chaoflux\", \"Discoflux\", \"Confuflux\", \"Bureflux\", \"Afflux\" };\n    \n    public static string Discordian(this DateTime date) {\n        string yold = $\" in the YOLD {date.Year + 1166}.\";\n        int dayOfYear = date.DayOfYear;\n\n        if (DateTime.IsLeapYear(date.Year)) {\n            if (dayOfYear == 60) return \"St. Tib's day\" + yold;\n            else if (dayOfYear > 60) dayOfYear--;\n        }\n        dayOfYear--;\n\n        int seasonDay = dayOfYear % 73 + 1;\n        int seasonNr = dayOfYear / 73;\n        int weekdayNr = dayOfYear % 5;\n        string holyday = \"\";\n\n        if (seasonDay == 5)       holyday = $\" Celebrate {apostles[seasonNr]}!\";\n        else if (seasonDay == 50) holyday = $\" Celebrate {holidays[seasonNr]}!\";\n        return $\"{weekdays[weekdayNr]}, day {seasonDay} of {seasons[seasonNr]}{yold}{holyday}\";\n    }\n\n    public static void Main() {\n        foreach (var (day, month, year) in new [] {\n            (1, 1, 2010),\n            (5, 1, 2010),\n            (19, 2, 2011),\n            (28, 2, 2012),\n            (29, 2, 2012),\n            (1, 3, 2012),\n            (19, 3, 2013),\n            (3, 5, 2014),\n            (31, 5, 2015),\n            (22, 6, 2016),\n            (15, 7, 2016),\n            (12, 8, 2017),\n            (19, 9, 2018),\n            (26, 9, 2018),\n            (24, 10, 2019),\n            (8, 12, 2020),\n            (31, 12, 2020)\n        })\n        {\n            Console.WriteLine($\"{day:00}-{month:00}-{year:00} = {new DateTime(year, month, day).Discordian()}\");\n        }\n    }\n\n}\n"}
{"id": 54276, "name": "Discordian date", "source": "Translate Swift to Java: import Foundation\n\nlet monthDays = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]\nlet seasons = [\"Chaos\", \"Discord\", \"Confusion\", \"Bureacracy\", \"The Aftermath\"]\nlet dayNames = [\"Sweetmorn\", \"Boomtime\", \"Pungenday\", \"Prickle-Prickle\", \"Setting Orange\"]\nlet holyDays1 = [\"Mungday\", \"Mojoday\", \"Syaday\", \"Zaraday\", \"Maladay\"]\nlet holyDays2 = [\"Chaoflux\", \"Discoflux\", \"Confuflux\", \"Bureflux\", \"Afflux\"]\n\nfunc discordianDate(date: Date) -> String {\n    let calendar = Calendar.current\n    let year = calendar.component(.year, from: date)\n    let month = calendar.component(.month, from: date)\n    let day = calendar.component(.day, from: date)\n    let discYear = year + 1166\n    if month == 2 && day == 29 {\n        return \"St. Tib's Day in the YOLD \\(discYear)\"\n    }\n    let dayOfYear = monthDays[month - 1] + day - 1\n    let season = dayOfYear/73\n    let weekDay = dayOfYear % 5\n    let dayOfSeason = 1 + dayOfYear % 73\n    let ddate = \"\\(dayNames[weekDay]), day \\(dayOfSeason) of \\(seasons[season]) in the YOLD \\(discYear)\"\n    switch (dayOfSeason) {\n    case 5:\n        return ddate + \". Celebrate \\(holyDays1[season])!\"\n    case 50:\n        return ddate + \". Celebrate \\(holyDays2[season])!\"\n    default:\n        return ddate\n    }\n}\n\nfunc showDiscordianDate(year: Int, month: Int, day: Int) {\n    let calendar = Calendar.current\n    let date = calendar.date(from: DateComponents(year: year, month: month, day: day))!\n    let ddate = discordianDate(date: date)\n    let format = DateFormatter()\n    format.dateFormat = \"yyyy-MM-dd\"\n    print(\"\\(format.string(from: date)): \\(ddate)\")\n}\n\nshowDiscordianDate(year: 2022, month: 1, day: 20)\nshowDiscordianDate(year: 2020, month: 9, day: 21)\nshowDiscordianDate(year: 2020, month: 2, day: 29)\nshowDiscordianDate(year: 2019, month: 7, day: 15)\nshowDiscordianDate(year: 2025, month: 3, day: 19)\nshowDiscordianDate(year: 2017, month: 12, day: 8)\n", "target": "import java.util.Calendar;\nimport java.util.GregorianCalendar;\n\npublic class DiscordianDate {\n    final static String[] seasons = {\"Chaos\", \"Discord\", \"Confusion\",\n        \"Bureaucracy\", \"The Aftermath\"};\n\n    final static String[] weekday = {\"Sweetmorn\", \"Boomtime\", \"Pungenday\",\n        \"Prickle-Prickle\", \"Setting Orange\"};\n\n    final static String[] apostle = {\"Mungday\", \"Mojoday\", \"Syaday\",\n        \"Zaraday\", \"Maladay\"};\n\n    final static String[] holiday = {\"Chaoflux\", \"Discoflux\", \"Confuflux\",\n        \"Bureflux\", \"Afflux\"};\n\n    public static String discordianDate(final GregorianCalendar date) {\n        int y = date.get(Calendar.YEAR);\n        int yold = y + 1166;\n        int dayOfYear = date.get(Calendar.DAY_OF_YEAR);\n\n        if (date.isLeapYear(y)) {\n            if (dayOfYear == 60)\n                return \"St. Tib's Day, in the YOLD \" + yold;\n            else if (dayOfYear > 60)\n                dayOfYear--;\n        }\n\n        dayOfYear--;\n\n        int seasonDay = dayOfYear % 73 + 1;\n        if (seasonDay == 5)\n            return apostle[dayOfYear / 73] + \", in the YOLD \" + yold;\n        if (seasonDay == 50)\n            return holiday[dayOfYear / 73] + \", in the YOLD \" + yold;\n\n        String season = seasons[dayOfYear / 73];\n        String dayOfWeek = weekday[dayOfYear % 5];\n\n        return String.format(\"%s, day %s of %s in the YOLD %s\",\n                dayOfWeek, seasonDay, season, yold);\n    }\n\n    public static void main(String[] args) {\n\n        System.out.println(discordianDate(new GregorianCalendar()));\n\n        test(2010, 6, 22, \"Pungenday, day 57 of Confusion in the YOLD 3176\");\n        test(2012, 1, 28, \"Prickle-Prickle, day 59 of Chaos in the YOLD 3178\");\n        test(2012, 1, 29, \"St. Tib's Day, in the YOLD 3178\");\n        test(2012, 2, 1, \"Setting Orange, day 60 of Chaos in the YOLD 3178\");\n        test(2010, 0, 5, \"Mungday, in the YOLD 3176\");\n        test(2011, 4, 3, \"Discoflux, in the YOLD 3177\");\n        test(2015, 9, 19, \"Boomtime, day 73 of Bureaucracy in the YOLD 3181\");\n    }\n\n    private static void test(int y, int m, int d, final String result) {\n        assert (discordianDate(new GregorianCalendar(y, m, d)).equals(result));\n    }\n}\n"}
{"id": 54277, "name": "Discordian date", "source": "Translate Swift to Python: import Foundation\n\nlet monthDays = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]\nlet seasons = [\"Chaos\", \"Discord\", \"Confusion\", \"Bureacracy\", \"The Aftermath\"]\nlet dayNames = [\"Sweetmorn\", \"Boomtime\", \"Pungenday\", \"Prickle-Prickle\", \"Setting Orange\"]\nlet holyDays1 = [\"Mungday\", \"Mojoday\", \"Syaday\", \"Zaraday\", \"Maladay\"]\nlet holyDays2 = [\"Chaoflux\", \"Discoflux\", \"Confuflux\", \"Bureflux\", \"Afflux\"]\n\nfunc discordianDate(date: Date) -> String {\n    let calendar = Calendar.current\n    let year = calendar.component(.year, from: date)\n    let month = calendar.component(.month, from: date)\n    let day = calendar.component(.day, from: date)\n    let discYear = year + 1166\n    if month == 2 && day == 29 {\n        return \"St. Tib's Day in the YOLD \\(discYear)\"\n    }\n    let dayOfYear = monthDays[month - 1] + day - 1\n    let season = dayOfYear/73\n    let weekDay = dayOfYear % 5\n    let dayOfSeason = 1 + dayOfYear % 73\n    let ddate = \"\\(dayNames[weekDay]), day \\(dayOfSeason) of \\(seasons[season]) in the YOLD \\(discYear)\"\n    switch (dayOfSeason) {\n    case 5:\n        return ddate + \". Celebrate \\(holyDays1[season])!\"\n    case 50:\n        return ddate + \". Celebrate \\(holyDays2[season])!\"\n    default:\n        return ddate\n    }\n}\n\nfunc showDiscordianDate(year: Int, month: Int, day: Int) {\n    let calendar = Calendar.current\n    let date = calendar.date(from: DateComponents(year: year, month: month, day: day))!\n    let ddate = discordianDate(date: date)\n    let format = DateFormatter()\n    format.dateFormat = \"yyyy-MM-dd\"\n    print(\"\\(format.string(from: date)): \\(ddate)\")\n}\n\nshowDiscordianDate(year: 2022, month: 1, day: 20)\nshowDiscordianDate(year: 2020, month: 9, day: 21)\nshowDiscordianDate(year: 2020, month: 2, day: 29)\nshowDiscordianDate(year: 2019, month: 7, day: 15)\nshowDiscordianDate(year: 2025, month: 3, day: 19)\nshowDiscordianDate(year: 2017, month: 12, day: 8)\n", "target": "import datetime, calendar\n\nDISCORDIAN_SEASONS = [\"Chaos\", \"Discord\", \"Confusion\", \"Bureaucracy\", \"The Aftermath\"]\n\ndef ddate(year, month, day):\n    today = datetime.date(year, month, day)\n    is_leap_year = calendar.isleap(year)\n    if is_leap_year and month == 2 and day == 29:\n        return \"St. Tib's Day, YOLD \" + (year + 1166)\n    \n    day_of_year = today.timetuple().tm_yday - 1\n    \n    if is_leap_year and day_of_year >= 60:\n        day_of_year -= 1 \n    \n    season, dday = divmod(day_of_year, 73)\n    return \"%s %d, YOLD %d\" % (DISCORDIAN_SEASONS[season], dday + 1, year + 1166)\n"}
{"id": 54699, "name": "Binary digits", "source": "Translate Swift to C#: for num in [5, 50, 9000] {\n    println(String(num, radix: 2))\n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        foreach (var number in new[] { 5, 50, 9000 })\n        {\n            Console.WriteLine(Convert.ToString(number, 2));\n        }\n    }\n}\n"}
{"id": 54701, "name": "Binary digits", "source": "Translate Swift to Java: for num in [5, 50, 9000] {\n    println(String(num, radix: 2))\n}\n", "target": "module BinaryDigits\n    {\n    @Inject Console console;\n    void run()\n        {\n        Int[] tests = [0, 1, 5, 50, 9000];\n\n        Int longestInt = tests.map(n -> n.estimateStringLength()).reduce(0, (max, len) -> max.maxOf(len));\n        Int longestBin = tests.map(n -> (64-n.leadingZeroCount).maxOf(1)).reduce(0, (max, len) -> max.maxOf(len));\n\n        function String(Int) num = n ->\n            {\n            Int indent = longestInt - n.estimateStringLength();\n            return $\"{' ' * indent}{n}\";\n            };\n\n        function String(Int) bin = n ->\n            {\n            Int index  = n.leadingZeroCount.minOf(63);\n            Int indent = index - (64 - longestBin);\n            val bits   = n.toBitArray()[index ..< 64];\n            return $\"{' ' * indent}{bits.toString().substring(2)}\";\n            };\n\n        for (Int test : tests)\n            {\n            console.print($\"The decimal value {num(test)} should produce an output of {bin(test)}\");\n            }\n        }\n    }\n"}
{"id": 54702, "name": "Binary digits", "source": "Translate Swift to Python: for num in [5, 50, 9000] {\n    println(String(num, radix: 2))\n}\n", "target": ">>> for i in range(16): print('{0:b}'.format(i))\n\n0\n1\n10\n11\n100\n101\n110\n111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n"}
{"id": 54885, "name": "Dijkstra's algorithm", "source": "Translate Swift to C#: typealias WeightedEdge = (Int, Int, Int)\n\nstruct Grid<T> {\n  var nodes: [Node<T>]\n\n  mutating func addNode(data: T) -> Int {\n    nodes.append(Node(data: data, edges: []))\n\n    return nodes.count - 1\n  }\n\n  mutating func createEdges(weights: [WeightedEdge]) {\n    for (start, end, weight) in weights {\n      nodes[start].edges.append((end, weight))\n      nodes[end].edges.append((start, weight))\n    }\n  }\n\n  func findPath(start: Int, end: Int) -> ([Int], Int)? {\n    var dist = Array(repeating: (Int.max, nil as Int?), count: nodes.count)\n    var heap = Heap<State>(sort: { $0.cost < $1.cost })\n\n    dist[start] = (0, nil)\n    heap.insert(State(node: start, cost: 0))\n\n    while let state = heap.remove(at: 0) {\n      if state.node == end {\n        var path = [end]\n        var currentDist = dist[end]\n\n        while let prev = currentDist.1 {\n          path.append(prev)\n          currentDist = dist[prev]\n        }\n\n        return (path.reversed(), state.cost)\n      }\n\n      guard state.cost <= dist[state.node].0 else {\n        continue\n      }\n\n      for edge in nodes[state.node].edges {\n        let next = State(node: edge.0, cost: state.cost + edge.1)\n\n        if next.cost < dist[next.node].0 {\n          dist[next.node] = (next.cost, state.node)\n          heap.insert(next)\n        }\n      }\n    }\n\n    return nil\n  }\n}\n\nstruct Node<T> {\n  var data: T\n  var edges: [(Int, Int)]\n}\n\nstruct State {\n  var node: Int\n  var cost: Int\n}\n\nvar grid = Grid<String>(nodes: [])\n\nlet (a, b, c, d, e, f) = (\n  grid.addNode(data: \"a\"),\n  grid.addNode(data: \"b\"),\n  grid.addNode(data: \"c\"),\n  grid.addNode(data: \"d\"),\n  grid.addNode(data: \"e\"),\n  grid.addNode(data: \"f\")\n)\n\ngrid.createEdges(weights: [\n  (a, b, 7), (a, c, 9), (a, f, 14),\n  (b, c, 10), (b, d, 15), (c, d, 11),\n  (c, f, 2), (d, e, 6), (e, f, 9)\n])\n\nguard let (path, cost) = grid.findPath(start: a, end: e) else {\n  fatalError(\"Could not find path\")\n}\n\nprint(\"Cost: \\(cost)\")\nprint(path.map({ grid.nodes[$0].data }).joined(separator: \" -> \"))\n", "target": "using static System.Linq.Enumerable;\nusing static System.String;\nusing static System.Console;\nusing System.Collections.Generic;\nusing System;\nusing EdgeList = System.Collections.Generic.List<(int node, double weight)>;\n\npublic static class Dijkstra\n{\n    public static void Main() {\n        Graph graph = new Graph(6);\n        Func<char, int> id = c => c - 'a';\n        Func<int , char> name = i => (char)(i + 'a');\n        foreach (var (start, end, cost) in new [] {\n            ('a', 'b', 7),\n            ('a', 'c', 9),\n            ('a', 'f', 14),\n            ('b', 'c', 10),\n            ('b', 'd', 15),\n            ('c', 'd', 11),\n            ('c', 'f', 2),\n            ('d', 'e', 6),\n            ('e', 'f', 9),\n        }) {\n            graph.AddEdge(id(start), id(end), cost);\n        }\n\n        var path = graph.FindPath(id('a'));\n        for (int d = id('b'); d <= id('f'); d++) {\n            WriteLine(Join(\" -> \", Path(id('a'), d).Select(p => $\"{name(p.node)}({p.distance})\").Reverse()));\n        }\n        \n        IEnumerable<(double distance, int node)> Path(int start, int destination) {\n            yield return (path[destination].distance, destination);\n            for (int i = destination; i != start; i = path[i].prev) {\n                yield return (path[path[i].prev].distance, path[i].prev);\n            }\n        }\n    }\n\n}\n\nsealed class Graph\n{\n    private readonly List<EdgeList> adjacency;\n\n    public Graph(int vertexCount) => adjacency = Range(0, vertexCount).Select(v => new EdgeList()).ToList();\n\n    public int Count => adjacency.Count;\n    public bool HasEdge(int s, int e) => adjacency[s].Any(p => p.node == e);\n    public bool RemoveEdge(int s, int e) => adjacency[s].RemoveAll(p => p.node == e) > 0;\n\n    public bool AddEdge(int s, int e, double weight) {\n        if (HasEdge(s, e)) return false;\n        adjacency[s].Add((e, weight));\n        return true;\n    }\n\n    public (double distance, int prev)[] FindPath(int start) {\n        var info = Range(0, adjacency.Count).Select(i => (distance: double.PositiveInfinity, prev: i)).ToArray();\n        info[start].distance = 0;\n        var visited = new System.Collections.BitArray(adjacency.Count);\n\n        var heap = new Heap<(int node, double distance)>((a, b) => a.distance.CompareTo(b.distance));\n        heap.Push((start, 0));\n        while (heap.Count > 0) {\n            var current = heap.Pop();\n            if (visited[current.node]) continue;\n            var edges = adjacency[current.node];\n            for (int n = 0; n < edges.Count; n++) {\n                int v = edges[n].node;\n                if (visited[v]) continue;\n                double alt = info[current.node].distance + edges[n].weight;\n                if (alt < info[v].distance) {\n                    info[v] = (alt, current.node);\n                    heap.Push((v, alt));\n                }\n            }\n            visited[current.node] = true;\n        }\n        return info;\n    }\n\n}\n\nsealed class Heap<T>\n{\n    private readonly IComparer<T> comparer;\n    private readonly List<T> list = new List<T> { default };\n\n    public Heap() : this(default(IComparer<T>)) { }\n\n    public Heap(IComparer<T> comparer) {\n        this.comparer = comparer ?? Comparer<T>.Default;\n    }\n\n    public Heap(Comparison<T> comparison) : this(Comparer<T>.Create(comparison)) { }\n\n    public int Count => list.Count - 1;\n\n    public void Push(T element) {\n        list.Add(element);\n        SiftUp(list.Count - 1);\n    }\n\n    public T Pop() {\n        T result = list[1];\n        list[1] = list[list.Count - 1];\n        list.RemoveAt(list.Count - 1);\n        SiftDown(1);\n        return result;\n    }\n\n    private static int Parent(int i) => i / 2;\n    private static int Left(int i) => i * 2;\n    private static int Right(int i) => i * 2 + 1;\n\n    private void SiftUp(int i) {\n        while (i > 1) {\n            int parent = Parent(i);\n            if (comparer.Compare(list[i], list[parent]) > 0) return;\n            (list[parent], list[i]) = (list[i], list[parent]);\n            i = parent;\n        }\n    }\n\n    private void SiftDown(int i) {\n        for (int left = Left(i); left < list.Count; left = Left(i)) {\n            int smallest = comparer.Compare(list[left], list[i]) <= 0 ? left : i;\n            int right = Right(i);\n            if (right < list.Count && comparer.Compare(list[right], list[smallest]) <= 0) smallest = right;\n            if (smallest == i) return;\n            (list[i], list[smallest]) = (list[smallest], list[i]);\n            i = smallest;\n        }\n    }\n\n}\n"}
{"id": 54887, "name": "Dijkstra's algorithm", "source": "Translate Swift to Java: typealias WeightedEdge = (Int, Int, Int)\n\nstruct Grid<T> {\n  var nodes: [Node<T>]\n\n  mutating func addNode(data: T) -> Int {\n    nodes.append(Node(data: data, edges: []))\n\n    return nodes.count - 1\n  }\n\n  mutating func createEdges(weights: [WeightedEdge]) {\n    for (start, end, weight) in weights {\n      nodes[start].edges.append((end, weight))\n      nodes[end].edges.append((start, weight))\n    }\n  }\n\n  func findPath(start: Int, end: Int) -> ([Int], Int)? {\n    var dist = Array(repeating: (Int.max, nil as Int?), count: nodes.count)\n    var heap = Heap<State>(sort: { $0.cost < $1.cost })\n\n    dist[start] = (0, nil)\n    heap.insert(State(node: start, cost: 0))\n\n    while let state = heap.remove(at: 0) {\n      if state.node == end {\n        var path = [end]\n        var currentDist = dist[end]\n\n        while let prev = currentDist.1 {\n          path.append(prev)\n          currentDist = dist[prev]\n        }\n\n        return (path.reversed(), state.cost)\n      }\n\n      guard state.cost <= dist[state.node].0 else {\n        continue\n      }\n\n      for edge in nodes[state.node].edges {\n        let next = State(node: edge.0, cost: state.cost + edge.1)\n\n        if next.cost < dist[next.node].0 {\n          dist[next.node] = (next.cost, state.node)\n          heap.insert(next)\n        }\n      }\n    }\n\n    return nil\n  }\n}\n\nstruct Node<T> {\n  var data: T\n  var edges: [(Int, Int)]\n}\n\nstruct State {\n  var node: Int\n  var cost: Int\n}\n\nvar grid = Grid<String>(nodes: [])\n\nlet (a, b, c, d, e, f) = (\n  grid.addNode(data: \"a\"),\n  grid.addNode(data: \"b\"),\n  grid.addNode(data: \"c\"),\n  grid.addNode(data: \"d\"),\n  grid.addNode(data: \"e\"),\n  grid.addNode(data: \"f\")\n)\n\ngrid.createEdges(weights: [\n  (a, b, 7), (a, c, 9), (a, f, 14),\n  (b, c, 10), (b, d, 15), (c, d, 11),\n  (c, f, 2), (d, e, 6), (e, f, 9)\n])\n\nguard let (path, cost) = grid.findPath(start: a, end: e) else {\n  fatalError(\"Could not find path\")\n}\n\nprint(\"Cost: \\(cost)\")\nprint(path.map({ grid.nodes[$0].data }).joined(separator: \" -> \"))\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class Dijkstra {\n   private static final Graph.Edge[] GRAPH = {\n      new Graph.Edge(\"a\", \"b\", 7),\n      new Graph.Edge(\"a\", \"c\", 9),\n      new Graph.Edge(\"a\", \"f\", 14),\n      new Graph.Edge(\"b\", \"c\", 10),\n      new Graph.Edge(\"b\", \"d\", 15),\n      new Graph.Edge(\"c\", \"d\", 11),\n      new Graph.Edge(\"c\", \"f\", 2),\n      new Graph.Edge(\"d\", \"e\", 6),\n      new Graph.Edge(\"e\", \"f\", 9),\n   };\n   private static final String START = \"a\";\n   private static final String END = \"e\";\n   \n   public static void main(String[] args) {\n      Graph g = new Graph(GRAPH);\n      g.dijkstra(START);\n      g.printPath(END);\n      \n   }\n}\n\nclass Graph {\n   private final Map<String, Vertex> graph; \n   \n   \n   public static class Edge {\n      public final String v1, v2;\n      public final int dist;\n      public Edge(String v1, String v2, int dist) {\n         this.v1 = v1;\n         this.v2 = v2;\n         this.dist = dist;\n      }\n   }\n   \n   \n  public static class Vertex implements Comparable<Vertex>{\n\tpublic final String name;\n\tpublic int dist = Integer.MAX_VALUE; \n\tpublic Vertex previous = null;\n\tpublic final Map<Vertex, Integer> neighbours = new HashMap<>();\n\n\tpublic Vertex(String name)\n\t{\n\t\tthis.name = name;\n\t}\n\n\tprivate void printPath()\n\t{\n\t\tif (this == this.previous)\n\t\t{\n\t\t\tSystem.out.printf(\"%s\", this.name);\n\t\t}\n\t\telse if (this.previous == null)\n\t\t{\n\t\t\tSystem.out.printf(\"%s(unreached)\", this.name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.previous.printPath();\n\t\t\tSystem.out.printf(\" -> %s(%d)\", this.name, this.dist);\n\t\t}\n\t}\n\n\tpublic int compareTo(Vertex other)\n\t{\n\t\tif (dist == other.dist)\n\t\t\treturn name.compareTo(other.name);\n\n\t\treturn Integer.compare(dist, other.dist);\n\t}\n\n\t@Override public String toString()\n\t{\n\t\treturn \"(\" + name + \", \" + dist + \")\";\n\t}\n}\n   \n   \n   public Graph(Edge[] edges) {\n      graph = new HashMap<>(edges.length);\n      \n      \n      for (Edge e : edges) {\n         if (!graph.containsKey(e.v1)) graph.put(e.v1, new Vertex(e.v1));\n         if (!graph.containsKey(e.v2)) graph.put(e.v2, new Vertex(e.v2));\n      }\n      \n      \n      for (Edge e : edges) {\n         graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);\n         \n      }\n   }\n   \n    \n   public void dijkstra(String startName) {\n      if (!graph.containsKey(startName)) {\n         System.err.printf(\"Graph doesn't contain start vertex \\\"%s\\\"\\n\", startName);\n         return;\n      }\n      final Vertex source = graph.get(startName);\n      NavigableSet<Vertex> q = new TreeSet<>();\n      \n      \n      for (Vertex v : graph.values()) {\n         v.previous = v == source ? source : null;\n         v.dist = v == source ? 0 : Integer.MAX_VALUE;\n         q.add(v);\n      }\n      \n      dijkstra(q);\n   }\n   \n   \n   private void dijkstra(final NavigableSet<Vertex> q) {      \n      Vertex u, v;\n      while (!q.isEmpty()) {\n         \n         u = q.pollFirst(); \n         if (u.dist == Integer.MAX_VALUE) break; \n         \n         \n         for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {\n            v = a.getKey(); \n            \n            final int alternateDist = u.dist + a.getValue();\n            if (alternateDist < v.dist) { \n               q.remove(v);\n               v.dist = alternateDist;\n               v.previous = u;\n               q.add(v);\n            } \n         }\n      }\n   }\n   \n   \n   public void printPath(String endName) {\n      if (!graph.containsKey(endName)) {\n         System.err.printf(\"Graph doesn't contain end vertex \\\"%s\\\"\\n\", endName);\n         return;\n      }\n      \n      graph.get(endName).printPath();\n      System.out.println();\n   }\n   \n   public void printAllPaths() {\n      for (Vertex v : graph.values()) {\n         v.printPath();\n         System.out.println();\n      }\n   }\n}\n"}
{"id": 54888, "name": "Dijkstra's algorithm", "source": "Translate Swift to Python: typealias WeightedEdge = (Int, Int, Int)\n\nstruct Grid<T> {\n  var nodes: [Node<T>]\n\n  mutating func addNode(data: T) -> Int {\n    nodes.append(Node(data: data, edges: []))\n\n    return nodes.count - 1\n  }\n\n  mutating func createEdges(weights: [WeightedEdge]) {\n    for (start, end, weight) in weights {\n      nodes[start].edges.append((end, weight))\n      nodes[end].edges.append((start, weight))\n    }\n  }\n\n  func findPath(start: Int, end: Int) -> ([Int], Int)? {\n    var dist = Array(repeating: (Int.max, nil as Int?), count: nodes.count)\n    var heap = Heap<State>(sort: { $0.cost < $1.cost })\n\n    dist[start] = (0, nil)\n    heap.insert(State(node: start, cost: 0))\n\n    while let state = heap.remove(at: 0) {\n      if state.node == end {\n        var path = [end]\n        var currentDist = dist[end]\n\n        while let prev = currentDist.1 {\n          path.append(prev)\n          currentDist = dist[prev]\n        }\n\n        return (path.reversed(), state.cost)\n      }\n\n      guard state.cost <= dist[state.node].0 else {\n        continue\n      }\n\n      for edge in nodes[state.node].edges {\n        let next = State(node: edge.0, cost: state.cost + edge.1)\n\n        if next.cost < dist[next.node].0 {\n          dist[next.node] = (next.cost, state.node)\n          heap.insert(next)\n        }\n      }\n    }\n\n    return nil\n  }\n}\n\nstruct Node<T> {\n  var data: T\n  var edges: [(Int, Int)]\n}\n\nstruct State {\n  var node: Int\n  var cost: Int\n}\n\nvar grid = Grid<String>(nodes: [])\n\nlet (a, b, c, d, e, f) = (\n  grid.addNode(data: \"a\"),\n  grid.addNode(data: \"b\"),\n  grid.addNode(data: \"c\"),\n  grid.addNode(data: \"d\"),\n  grid.addNode(data: \"e\"),\n  grid.addNode(data: \"f\")\n)\n\ngrid.createEdges(weights: [\n  (a, b, 7), (a, c, 9), (a, f, 14),\n  (b, c, 10), (b, d, 15), (c, d, 11),\n  (c, f, 2), (d, e, 6), (e, f, 9)\n])\n\nguard let (path, cost) = grid.findPath(start: a, end: e) else {\n  fatalError(\"Could not find path\")\n}\n\nprint(\"Cost: \\(cost)\")\nprint(path.map({ grid.nodes[$0].data }).joined(separator: \" -> \"))\n", "target": "from collections import namedtuple, deque\nfrom pprint import pprint as pp\n \n \ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n \nclass Graph():\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        \n        self.vertices = {e.start for e in self.edges} | {e.end for e in self.edges}\n \n    def dijkstra(self, source, dest):\n        assert source in self.vertices\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        for start, end, cost in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n\n        \n \n        while q:\n            \n            u = min(q, key=lambda vertex: dist[vertex])\n            q.remove(u)\n            if dist[u] == inf or u == dest:\n                break\n            for v, cost in neighbours[u]:\n                alt = dist[u] + cost\n                if alt < dist[v]:                                  \n                    dist[v] = alt\n                    previous[v] = u\n        \n        s, u = deque(), dest\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        s.appendleft(u)\n        return s\n \n \ngraph = Graph([(\"a\", \"b\", 7),  (\"a\", \"c\", 9),  (\"a\", \"f\", 14), (\"b\", \"c\", 10),\n               (\"b\", \"d\", 15), (\"c\", \"d\", 11), (\"c\", \"f\", 2),  (\"d\", \"e\", 6),\n               (\"e\", \"f\", 9)])\npp(graph.dijkstra(\"a\", \"e\"))\n"}
{"id": 55759, "name": "Find the intersection of two lines", "source": "Translate Swift to C#: struct Point {\n  var x: Double\n  var y: Double\n}\n\nstruct Line {\n  var p1: Point\n  var p2: Point\n\n  var slope: Double {\n    guard p1.x - p2.x != 0.0 else { return .nan }\n\n    return (p1.y-p2.y) / (p1.x-p2.x)\n  }\n\n  func intersection(of other: Line) -> Point? {\n    let ourSlope = slope\n    let theirSlope = other.slope\n\n    guard ourSlope != theirSlope else { return nil }\n\n    if ourSlope.isNaN && !theirSlope.isNaN {\n      return Point(x: p1.x, y: (p1.x - other.p1.x) * theirSlope + other.p1.y)\n    } else if theirSlope.isNaN && !ourSlope.isNaN {\n      return Point(x: other.p1.x, y: (other.p1.x - p1.x) * ourSlope + p1.y)\n    } else {\n      let x = (ourSlope*p1.x - theirSlope*other.p1.x + other.p1.y - p1.y) / (ourSlope - theirSlope)\n      return Point(x: x, y: theirSlope*(x - other.p1.x) + other.p1.y)\n    }\n  }\n}\n\nlet l1 = Line(p1: Point(x: 4.0, y: 0.0), p2: Point(x: 6.0, y: 10.0))\nlet l2 = Line(p1: Point(x: 0.0, y: 3.0), p2: Point(x: 10.0, y: 7.0))\n\nprint(\"Intersection at\u00a0: \\(l1.intersection(of: l2)!)\")\n", "target": "using System;\nusing System.Drawing;\npublic class Program\n{\n    static PointF FindIntersection(PointF s1, PointF e1, PointF s2, PointF e2) {\n        float a1 = e1.Y - s1.Y;\n        float b1 = s1.X - e1.X;\n        float c1 = a1 * s1.X + b1 * s1.Y;\n\n        float a2 = e2.Y - s2.Y;\n        float b2 = s2.X - e2.X;\n        float c2 = a2 * s2.X + b2 * s2.Y;\n\n        float delta = a1 * b2 - a2 * b1;\n        \n        return delta == 0 ? new PointF(float.NaN, float.NaN)\n            : new PointF((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    static void Main() {\n        Func<float, float, PointF> p = (x, y) => new PointF(x, y);\n        Console.WriteLine(FindIntersection(p(4f, 0f), p(6f, 10f), p(0f, 3f), p(10f, 7f)));\n        Console.WriteLine(FindIntersection(p(0f, 0f), p(1f, 1f), p(1f, 2f), p(4f, 5f)));\n    }\n}\n"}
{"id": 55760, "name": "Find the intersection of two lines", "source": "Translate Swift to C#: struct Point {\n  var x: Double\n  var y: Double\n}\n\nstruct Line {\n  var p1: Point\n  var p2: Point\n\n  var slope: Double {\n    guard p1.x - p2.x != 0.0 else { return .nan }\n\n    return (p1.y-p2.y) / (p1.x-p2.x)\n  }\n\n  func intersection(of other: Line) -> Point? {\n    let ourSlope = slope\n    let theirSlope = other.slope\n\n    guard ourSlope != theirSlope else { return nil }\n\n    if ourSlope.isNaN && !theirSlope.isNaN {\n      return Point(x: p1.x, y: (p1.x - other.p1.x) * theirSlope + other.p1.y)\n    } else if theirSlope.isNaN && !ourSlope.isNaN {\n      return Point(x: other.p1.x, y: (other.p1.x - p1.x) * ourSlope + p1.y)\n    } else {\n      let x = (ourSlope*p1.x - theirSlope*other.p1.x + other.p1.y - p1.y) / (ourSlope - theirSlope)\n      return Point(x: x, y: theirSlope*(x - other.p1.x) + other.p1.y)\n    }\n  }\n}\n\nlet l1 = Line(p1: Point(x: 4.0, y: 0.0), p2: Point(x: 6.0, y: 10.0))\nlet l2 = Line(p1: Point(x: 0.0, y: 3.0), p2: Point(x: 10.0, y: 7.0))\n\nprint(\"Intersection at\u00a0: \\(l1.intersection(of: l2)!)\")\n", "target": "using System;\nusing System.Drawing;\npublic class Program\n{\n    static PointF FindIntersection(PointF s1, PointF e1, PointF s2, PointF e2) {\n        float a1 = e1.Y - s1.Y;\n        float b1 = s1.X - e1.X;\n        float c1 = a1 * s1.X + b1 * s1.Y;\n\n        float a2 = e2.Y - s2.Y;\n        float b2 = s2.X - e2.X;\n        float c2 = a2 * s2.X + b2 * s2.Y;\n\n        float delta = a1 * b2 - a2 * b1;\n        \n        return delta == 0 ? new PointF(float.NaN, float.NaN)\n            : new PointF((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    static void Main() {\n        Func<float, float, PointF> p = (x, y) => new PointF(x, y);\n        Console.WriteLine(FindIntersection(p(4f, 0f), p(6f, 10f), p(0f, 3f), p(10f, 7f)));\n        Console.WriteLine(FindIntersection(p(0f, 0f), p(1f, 1f), p(1f, 2f), p(4f, 5f)));\n    }\n}\n"}
{"id": 55763, "name": "Find the intersection of two lines", "source": "Translate Swift to Java: struct Point {\n  var x: Double\n  var y: Double\n}\n\nstruct Line {\n  var p1: Point\n  var p2: Point\n\n  var slope: Double {\n    guard p1.x - p2.x != 0.0 else { return .nan }\n\n    return (p1.y-p2.y) / (p1.x-p2.x)\n  }\n\n  func intersection(of other: Line) -> Point? {\n    let ourSlope = slope\n    let theirSlope = other.slope\n\n    guard ourSlope != theirSlope else { return nil }\n\n    if ourSlope.isNaN && !theirSlope.isNaN {\n      return Point(x: p1.x, y: (p1.x - other.p1.x) * theirSlope + other.p1.y)\n    } else if theirSlope.isNaN && !ourSlope.isNaN {\n      return Point(x: other.p1.x, y: (other.p1.x - p1.x) * ourSlope + p1.y)\n    } else {\n      let x = (ourSlope*p1.x - theirSlope*other.p1.x + other.p1.y - p1.y) / (ourSlope - theirSlope)\n      return Point(x: x, y: theirSlope*(x - other.p1.x) + other.p1.y)\n    }\n  }\n}\n\nlet l1 = Line(p1: Point(x: 4.0, y: 0.0), p2: Point(x: 6.0, y: 10.0))\nlet l2 = Line(p1: Point(x: 0.0, y: 3.0), p2: Point(x: 10.0, y: 7.0))\n\nprint(\"Intersection at\u00a0: \\(l1.intersection(of: l2)!)\")\n", "target": "public class Intersection {\n    private static class Point {\n        double x, y;\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"{%f, %f}\", x, y);\n        }\n    }\n\n    private static class Line {\n        Point s, e;\n\n        Line(Point s, Point e) {\n            this.s = s;\n            this.e = e;\n        }\n    }\n\n    private static Point findIntersection(Line l1, Line l2) {\n        double a1 = l1.e.y - l1.s.y;\n        double b1 = l1.s.x - l1.e.x;\n        double c1 = a1 * l1.s.x + b1 * l1.s.y;\n\n        double a2 = l2.e.y - l2.s.y;\n        double b2 = l2.s.x - l2.e.x;\n        double c2 = a2 * l2.s.x + b2 * l2.s.y;\n\n        double delta = a1 * b2 - a2 * b1;\n        return new Point((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    public static void main(String[] args) {\n        Line l1 = new Line(new Point(4, 0), new Point(6, 10));\n        Line l2 = new Line(new Point(0, 3), new Point(10, 7));\n        System.out.println(findIntersection(l1, l2));\n\n        l1 = new Line(new Point(0, 0), new Point(1, 1));\n        l2 = new Line(new Point(1, 2), new Point(4, 5));\n        System.out.println(findIntersection(l1, l2));\n    }\n}\n"}
{"id": 55764, "name": "Find the intersection of two lines", "source": "Translate Swift to Java: struct Point {\n  var x: Double\n  var y: Double\n}\n\nstruct Line {\n  var p1: Point\n  var p2: Point\n\n  var slope: Double {\n    guard p1.x - p2.x != 0.0 else { return .nan }\n\n    return (p1.y-p2.y) / (p1.x-p2.x)\n  }\n\n  func intersection(of other: Line) -> Point? {\n    let ourSlope = slope\n    let theirSlope = other.slope\n\n    guard ourSlope != theirSlope else { return nil }\n\n    if ourSlope.isNaN && !theirSlope.isNaN {\n      return Point(x: p1.x, y: (p1.x - other.p1.x) * theirSlope + other.p1.y)\n    } else if theirSlope.isNaN && !ourSlope.isNaN {\n      return Point(x: other.p1.x, y: (other.p1.x - p1.x) * ourSlope + p1.y)\n    } else {\n      let x = (ourSlope*p1.x - theirSlope*other.p1.x + other.p1.y - p1.y) / (ourSlope - theirSlope)\n      return Point(x: x, y: theirSlope*(x - other.p1.x) + other.p1.y)\n    }\n  }\n}\n\nlet l1 = Line(p1: Point(x: 4.0, y: 0.0), p2: Point(x: 6.0, y: 10.0))\nlet l2 = Line(p1: Point(x: 0.0, y: 3.0), p2: Point(x: 10.0, y: 7.0))\n\nprint(\"Intersection at\u00a0: \\(l1.intersection(of: l2)!)\")\n", "target": "public class Intersection {\n    private static class Point {\n        double x, y;\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"{%f, %f}\", x, y);\n        }\n    }\n\n    private static class Line {\n        Point s, e;\n\n        Line(Point s, Point e) {\n            this.s = s;\n            this.e = e;\n        }\n    }\n\n    private static Point findIntersection(Line l1, Line l2) {\n        double a1 = l1.e.y - l1.s.y;\n        double b1 = l1.s.x - l1.e.x;\n        double c1 = a1 * l1.s.x + b1 * l1.s.y;\n\n        double a2 = l2.e.y - l2.s.y;\n        double b2 = l2.s.x - l2.e.x;\n        double c2 = a2 * l2.s.x + b2 * l2.s.y;\n\n        double delta = a1 * b2 - a2 * b1;\n        return new Point((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    public static void main(String[] args) {\n        Line l1 = new Line(new Point(4, 0), new Point(6, 10));\n        Line l2 = new Line(new Point(0, 3), new Point(10, 7));\n        System.out.println(findIntersection(l1, l2));\n\n        l1 = new Line(new Point(0, 0), new Point(1, 1));\n        l2 = new Line(new Point(1, 2), new Point(4, 5));\n        System.out.println(findIntersection(l1, l2));\n    }\n}\n"}
{"id": 55765, "name": "Find the intersection of two lines", "source": "Translate Swift to Python: struct Point {\n  var x: Double\n  var y: Double\n}\n\nstruct Line {\n  var p1: Point\n  var p2: Point\n\n  var slope: Double {\n    guard p1.x - p2.x != 0.0 else { return .nan }\n\n    return (p1.y-p2.y) / (p1.x-p2.x)\n  }\n\n  func intersection(of other: Line) -> Point? {\n    let ourSlope = slope\n    let theirSlope = other.slope\n\n    guard ourSlope != theirSlope else { return nil }\n\n    if ourSlope.isNaN && !theirSlope.isNaN {\n      return Point(x: p1.x, y: (p1.x - other.p1.x) * theirSlope + other.p1.y)\n    } else if theirSlope.isNaN && !ourSlope.isNaN {\n      return Point(x: other.p1.x, y: (other.p1.x - p1.x) * ourSlope + p1.y)\n    } else {\n      let x = (ourSlope*p1.x - theirSlope*other.p1.x + other.p1.y - p1.y) / (ourSlope - theirSlope)\n      return Point(x: x, y: theirSlope*(x - other.p1.x) + other.p1.y)\n    }\n  }\n}\n\nlet l1 = Line(p1: Point(x: 4.0, y: 0.0), p2: Point(x: 6.0, y: 10.0))\nlet l2 = Line(p1: Point(x: 0.0, y: 3.0), p2: Point(x: 10.0, y: 7.0))\n\nprint(\"Intersection at\u00a0: \\(l1.intersection(of: l2)!)\")\n", "target": "from __future__ import division\n\ndef setup():\n    \n    (a, b), (c, d) = (4, 0), (6, 10)  \n    (e, f), (g, h) = (0, 3), (10, 7)  \n    pt = line_instersect(a, b, c, d, e, f, g, h)\n    scale(9)\n    line(a, b, c, d)\n    line(e, f, g, h)\n    if pt:\n        x, y = pt\n        stroke(255)\n        point(x, y)\n    println(pt)  \n\ndef line_instersect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2):\n    \n    d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1)\n    if d:\n        uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d\n        uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d\n    else:\n        return\n    if not(0 <= uA <= 1 and 0 <= uB <= 1):\n        return\n    x = Ax1 + uA * (Ax2 - Ax1)\n    y = Ay1 + uA * (Ay2 - Ay1)\n    return x, y\n"}
{"id": 55766, "name": "Find the intersection of two lines", "source": "Translate Swift to Python: struct Point {\n  var x: Double\n  var y: Double\n}\n\nstruct Line {\n  var p1: Point\n  var p2: Point\n\n  var slope: Double {\n    guard p1.x - p2.x != 0.0 else { return .nan }\n\n    return (p1.y-p2.y) / (p1.x-p2.x)\n  }\n\n  func intersection(of other: Line) -> Point? {\n    let ourSlope = slope\n    let theirSlope = other.slope\n\n    guard ourSlope != theirSlope else { return nil }\n\n    if ourSlope.isNaN && !theirSlope.isNaN {\n      return Point(x: p1.x, y: (p1.x - other.p1.x) * theirSlope + other.p1.y)\n    } else if theirSlope.isNaN && !ourSlope.isNaN {\n      return Point(x: other.p1.x, y: (other.p1.x - p1.x) * ourSlope + p1.y)\n    } else {\n      let x = (ourSlope*p1.x - theirSlope*other.p1.x + other.p1.y - p1.y) / (ourSlope - theirSlope)\n      return Point(x: x, y: theirSlope*(x - other.p1.x) + other.p1.y)\n    }\n  }\n}\n\nlet l1 = Line(p1: Point(x: 4.0, y: 0.0), p2: Point(x: 6.0, y: 10.0))\nlet l2 = Line(p1: Point(x: 0.0, y: 3.0), p2: Point(x: 10.0, y: 7.0))\n\nprint(\"Intersection at\u00a0: \\(l1.intersection(of: l2)!)\")\n", "target": "from __future__ import division\n\ndef setup():\n    \n    (a, b), (c, d) = (4, 0), (6, 10)  \n    (e, f), (g, h) = (0, 3), (10, 7)  \n    pt = line_instersect(a, b, c, d, e, f, g, h)\n    scale(9)\n    line(a, b, c, d)\n    line(e, f, g, h)\n    if pt:\n        x, y = pt\n        stroke(255)\n        point(x, y)\n    println(pt)  \n\ndef line_instersect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2):\n    \n    d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1)\n    if d:\n        uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d\n        uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d\n    else:\n        return\n    if not(0 <= uA <= 1 and 0 <= uB <= 1):\n        return\n    x = Ax1 + uA * (Ax2 - Ax1)\n    y = Ay1 + uA * (Ay2 - Ay1)\n    return x, y\n"}
{"id": 56175, "name": "Align columns", "source": "Translate Swift to C#: import Foundation\n\nextension String {\n  func dropLastIf(_ char: Character) -> String {\n    if last == char {\n      return String(dropLast())\n    } else {\n      return self\n    }\n  }\n}\n\nenum Align {\n  case left, center, right\n}\n\nfunc getLines(input: String) -> [String] {\n  input\n    .components(separatedBy: \"\\n\")\n    .map({ $0.replacingOccurrences(of: \" \", with: \"\").dropLastIf(\"$\") })\n}\n\nfunc getColWidths(from: String) -> [Int] {\n  var widths = [Int]()\n  let lines = getLines(input: from)\n\n  for line in lines {\n    let lens = line.components(separatedBy: \"$\").map({ $0.count })\n\n    for (i, len) in lens.enumerated() {\n      if i < widths.count {\n        widths[i] = max(widths[i], len)\n      } else {\n        widths.append(len)\n      }\n    }\n  }\n\n  return widths\n}\n\nfunc alignCols(input: String, align: Align = .left) -> String {\n  let widths = getColWidths(from: input)\n  let lines = getLines(input: input)\n  var res = \"\"\n\n  for line in lines {\n    for (str, width) in zip(line.components(separatedBy: \"$\"), widths) {\n      let blanks = width - str.count\n      let pre: Int, post: Int\n\n      switch align {\n      case .left:\n        (pre, post) = (0, blanks)\n      case .center:\n        (pre, post) = (blanks / 2, (blanks + 1) / 2)\n      case .right:\n        (pre, post) = (blanks, 0)\n      }\n\n      res += String(repeating: \" \", count: pre)\n      res += str\n      res += String(repeating: \" \", count: post)\n      res += \" \"\n    }\n\n    res += \"\\n\"\n  }\n\n  return res\n}\n\nlet input = \"\"\"\n            Given$a$text$file$of$many$lines,$where$fields$within$a$line$\n            are$delineated$by$a$single$'dollar'$character,$write$a$program\n            that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\n            column$are$separated$by$at$least$one$space.\n            Further,$allow$for$each$word$in$a$column$to$be$either$left$\n            justified,$right$justified,$or$center$justified$within$its$column.\n            \"\"\"\n\nprint(alignCols(input: input))\nprint()\nprint(alignCols(input: input, align: .center))\nprint()\nprint(alignCols(input: input, align: .right))\n", "target": "using System;\nclass ColumnAlignerProgram\n{\n    delegate string Justification(string s, int width);\n\n    static string[] AlignColumns(string[] lines, Justification justification)\n    {\n        const char Separator = '$';\n        \n        string[][] table = new string[lines.Length][];\n        int columns = 0;\n        for (int i = 0; i < lines.Length; i++)\n        {\n            string[] row = lines[i].TrimEnd(Separator).Split(Separator);\n            if (columns < row.Length) columns = row.Length;\n            table[i] = row;\n        }\n        \n        string[][] formattedTable = new string[table.Length][];\n        for (int i = 0; i < formattedTable.Length; i++)\n        {\n            formattedTable[i] = new string[columns];\n        }\n        for (int j = 0; j < columns; j++)\n        {\n            \n            int columnWidth = 0;\n            for (int i = 0; i < table.Length; i++)\n            {\n                if (j < table[i].Length && columnWidth < table[i][j].Length)\n                    columnWidth = table[i][j].Length;\n            }\n            \n            for (int i = 0; i < formattedTable.Length; i++)\n            {\n                if (j < table[i].Length)\n                    formattedTable[i][j] = justification(table[i][j], columnWidth);\n                else \n                    formattedTable[i][j] = new String(' ', columnWidth);\n            }\n        }\n        \n        string[] result = new string[formattedTable.Length];\n        for (int i = 0; i < result.Length; i++)\n        {\n            result[i] = String.Join(\" \", formattedTable[i]);\n        }\n        return result;\n    }\n\n    static string JustifyLeft(string s, int width) { return s.PadRight(width); }\n    static string JustifyRight(string s, int width) { return s.PadLeft(width); }\n    static string JustifyCenter(string s, int width) \n    { \n        return s.PadLeft((width + s.Length) / 2).PadRight(width); \n    }\n\n    static void Main()\n    {\n        string[] input = {    \n            \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n            \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n            \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n            \"column$are$separated$by$at$least$one$space.\",\n            \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n            \"justified,$right$justified,$or$center$justified$within$its$column.\",\n        };\n\n        foreach (string line in AlignColumns(input, JustifyCenter))\n        {\n            Console.WriteLine(line);\n        }\n    }\n}\n"}
{"id": 56176, "name": "Align columns", "source": "Translate Swift to Java: import Foundation\n\nextension String {\n  func dropLastIf(_ char: Character) -> String {\n    if last == char {\n      return String(dropLast())\n    } else {\n      return self\n    }\n  }\n}\n\nenum Align {\n  case left, center, right\n}\n\nfunc getLines(input: String) -> [String] {\n  input\n    .components(separatedBy: \"\\n\")\n    .map({ $0.replacingOccurrences(of: \" \", with: \"\").dropLastIf(\"$\") })\n}\n\nfunc getColWidths(from: String) -> [Int] {\n  var widths = [Int]()\n  let lines = getLines(input: from)\n\n  for line in lines {\n    let lens = line.components(separatedBy: \"$\").map({ $0.count })\n\n    for (i, len) in lens.enumerated() {\n      if i < widths.count {\n        widths[i] = max(widths[i], len)\n      } else {\n        widths.append(len)\n      }\n    }\n  }\n\n  return widths\n}\n\nfunc alignCols(input: String, align: Align = .left) -> String {\n  let widths = getColWidths(from: input)\n  let lines = getLines(input: input)\n  var res = \"\"\n\n  for line in lines {\n    for (str, width) in zip(line.components(separatedBy: \"$\"), widths) {\n      let blanks = width - str.count\n      let pre: Int, post: Int\n\n      switch align {\n      case .left:\n        (pre, post) = (0, blanks)\n      case .center:\n        (pre, post) = (blanks / 2, (blanks + 1) / 2)\n      case .right:\n        (pre, post) = (blanks, 0)\n      }\n\n      res += String(repeating: \" \", count: pre)\n      res += str\n      res += String(repeating: \" \", count: post)\n      res += \" \"\n    }\n\n    res += \"\\n\"\n  }\n\n  return res\n}\n\nlet input = \"\"\"\n            Given$a$text$file$of$many$lines,$where$fields$within$a$line$\n            are$delineated$by$a$single$'dollar'$character,$write$a$program\n            that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\n            column$are$separated$by$at$least$one$space.\n            Further,$allow$for$each$word$in$a$column$to$be$either$left$\n            justified,$right$justified,$or$center$justified$within$its$column.\n            \"\"\"\n\nprint(alignCols(input: input))\nprint()\nprint(alignCols(input: input, align: .center))\nprint()\nprint(alignCols(input: input, align: .right))\n", "target": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\n\n\npublic class ColumnAligner {\n    private List<String[]> words = new ArrayList<>();\n    private int columns = 0;\n    private List<Integer> columnWidths = new ArrayList<>();\n\n    \n    public ColumnAligner(String s) {\n        String[] lines = s.split(\"\\\\n\");\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    \n    public ColumnAligner(List<String> lines) {\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    private void processInputLine(String line) {\n        String[] lineWords = line.split(\"\\\\$\");\n        words.add(lineWords);\n        columns = Math.max(columns, lineWords.length);\n        for (int i = 0; i < lineWords.length; i++) {\n            String word = lineWords[i];\n            if (i >= columnWidths.size()) {\n                columnWidths.add(word.length());\n            } else {\n                columnWidths.set(i, Math.max(columnWidths.get(i), word.length()));\n            }\n        }\n    }\n\n    interface AlignFunction {\n        String align(String s, int length);\n    }\n\n    \n    public String alignLeft() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.rightPad(s, length);\n            }\n        });\n    }\n\n    \n    public String alignRight() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.leftPad(s, length);\n            }\n        });\n    }\n\n    \n    public String alignCenter() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.center(s, length);\n            }\n        });\n    }\n\n    private String align(AlignFunction a) {\n        StringBuilder result = new StringBuilder();\n        for (String[] lineWords : words) {\n            for (int i = 0; i < lineWords.length; i++) {\n                String word = lineWords[i];\n                if (i == 0) {\n                    result.append(\"|\");\n                }\n                result.append(a.align(word, columnWidths.get(i)) + \"|\");\n            }\n            result.append(\"\\n\");\n        }\n        return result.toString();\n    }\n\n    public static void main(String args[]) throws IOException {\n        if (args.length < 1) {\n            System.out.println(\"Usage: ColumnAligner file [left|right|center]\");\n            return;\n        }\n        String filePath = args[0];\n        String alignment = \"left\";\n        if (args.length >= 2) {\n            alignment = args[1];\n        }\n        ColumnAligner ca = new ColumnAligner(Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8));\n        switch (alignment) {\n        case \"left\":\n            System.out.print(ca.alignLeft());\n            break;\n        case \"right\":\n            System.out.print(ca.alignRight());\n            break;\n        case \"center\":\n            System.out.print(ca.alignCenter());\n            break;\n        default:\n            System.err.println(String.format(\"Error! Unknown alignment: '%s'\", alignment));\n            break;\n        }\n    }\n}\n"}
{"id": 56177, "name": "Align columns", "source": "Translate Swift to Python: import Foundation\n\nextension String {\n  func dropLastIf(_ char: Character) -> String {\n    if last == char {\n      return String(dropLast())\n    } else {\n      return self\n    }\n  }\n}\n\nenum Align {\n  case left, center, right\n}\n\nfunc getLines(input: String) -> [String] {\n  input\n    .components(separatedBy: \"\\n\")\n    .map({ $0.replacingOccurrences(of: \" \", with: \"\").dropLastIf(\"$\") })\n}\n\nfunc getColWidths(from: String) -> [Int] {\n  var widths = [Int]()\n  let lines = getLines(input: from)\n\n  for line in lines {\n    let lens = line.components(separatedBy: \"$\").map({ $0.count })\n\n    for (i, len) in lens.enumerated() {\n      if i < widths.count {\n        widths[i] = max(widths[i], len)\n      } else {\n        widths.append(len)\n      }\n    }\n  }\n\n  return widths\n}\n\nfunc alignCols(input: String, align: Align = .left) -> String {\n  let widths = getColWidths(from: input)\n  let lines = getLines(input: input)\n  var res = \"\"\n\n  for line in lines {\n    for (str, width) in zip(line.components(separatedBy: \"$\"), widths) {\n      let blanks = width - str.count\n      let pre: Int, post: Int\n\n      switch align {\n      case .left:\n        (pre, post) = (0, blanks)\n      case .center:\n        (pre, post) = (blanks / 2, (blanks + 1) / 2)\n      case .right:\n        (pre, post) = (blanks, 0)\n      }\n\n      res += String(repeating: \" \", count: pre)\n      res += str\n      res += String(repeating: \" \", count: post)\n      res += \" \"\n    }\n\n    res += \"\\n\"\n  }\n\n  return res\n}\n\nlet input = \"\"\"\n            Given$a$text$file$of$many$lines,$where$fields$within$a$line$\n            are$delineated$by$a$single$'dollar'$character,$write$a$program\n            that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\n            column$are$separated$by$at$least$one$space.\n            Further,$allow$for$each$word$in$a$column$to$be$either$left$\n            justified,$right$justified,$or$center$justified$within$its$column.\n            \"\"\"\n\nprint(alignCols(input: input))\nprint()\nprint(alignCols(input: input, align: .center))\nprint()\nprint(alignCols(input: input, align: .right))\n", "target": "from itertools import zip_longest\n\ntxt = \n \nparts = [line.rstrip(\"$\").split(\"$\") for line in txt.splitlines()]\nwidths = [max(len(word) for word in col) \n          for col in zip_longest(*parts, fillvalue='')]\n \nfor justify in \"<_Left ^_Center >_Right\".split():\n    j, jtext = justify.split('_')\n    print(f\"{jtext} column-aligned output:\\n\")\n    for line in parts:\n        print(' '.join(f\"{wrd:{j}{wdth}}\" for wdth, wrd in zip(widths, line)))\n    print(\"- \" * 52)\n"}
{"id": 56518, "name": "Longest common prefix", "source": "Translate Swift to C#: func commonPrefix(string1: String, string2: String) -> String {\n    return String(zip(string1, string2).prefix(while: {$0 == $1}).map{$0.0})\n}\n\nfunc longestCommonPrefix(_ strings: [String]) -> String {\n    switch (strings.count) {\n    case 0:\n        return \"\"\n    case 1:\n        return strings[0]\n    default:\n        return commonPrefix(string1: strings.min()!, string2: strings.max()!)\n    }\n}\n\nfunc printLongestCommonPrefix(_ strings: [String]) {\n    print(\"lcp(\\(strings)) = \\\"\\(longestCommonPrefix(strings))\\\"\")\n}\n\nprintLongestCommonPrefix([\"interspecies\", \"interstellar\", \"interstate\"])\nprintLongestCommonPrefix([\"throne\", \"throne\"])\nprintLongestCommonPrefix([\"throne\", \"dungeon\"])\nprintLongestCommonPrefix([\"throne\", \"\", \"throne\"])\nprintLongestCommonPrefix([\"cheese\"])\nprintLongestCommonPrefix([\"\"])\nprintLongestCommonPrefix([])\nprintLongestCommonPrefix([\"prefix\", \"suffix\"])\nprintLongestCommonPrefix([\"foo\", \"foobar\"])\n", "target": "using System;\n\nnamespace LCP {\n    class Program {\n        public static string LongestCommonPrefix(params string[] sa) {\n            if (null == sa) return \"\"; \n            string ret = \"\";\n            int idx = 0;\n\n            while (true) {\n                char thisLetter = '\\0';\n                foreach (var word in sa) {\n                    if (idx == word.Length) {\n                        \n                        return ret;\n                    }\n                    if (thisLetter == '\\0') {\n                        \n                        thisLetter = word[idx];\n                    }\n                    if (thisLetter != word[idx]) {\n                        return ret;\n                    }\n                }\n\n                \n                ret += thisLetter;\n                idx++;\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(LongestCommonPrefix(\"interspecies\", \"interstellar\", \"interstate\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"throne\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"dungeon\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"\", \"throne\"));\n            Console.WriteLine(LongestCommonPrefix(\"cheese\"));\n            Console.WriteLine(LongestCommonPrefix(\"\"));\n            Console.WriteLine(LongestCommonPrefix(null));\n            Console.WriteLine(LongestCommonPrefix(\"prefix\", \"suffix\"));\n            Console.WriteLine(LongestCommonPrefix(\"foo\", \"foobar\"));\n        }\n    }\n}\n"}
{"id": 56519, "name": "Longest common prefix", "source": "Translate Swift to C#: func commonPrefix(string1: String, string2: String) -> String {\n    return String(zip(string1, string2).prefix(while: {$0 == $1}).map{$0.0})\n}\n\nfunc longestCommonPrefix(_ strings: [String]) -> String {\n    switch (strings.count) {\n    case 0:\n        return \"\"\n    case 1:\n        return strings[0]\n    default:\n        return commonPrefix(string1: strings.min()!, string2: strings.max()!)\n    }\n}\n\nfunc printLongestCommonPrefix(_ strings: [String]) {\n    print(\"lcp(\\(strings)) = \\\"\\(longestCommonPrefix(strings))\\\"\")\n}\n\nprintLongestCommonPrefix([\"interspecies\", \"interstellar\", \"interstate\"])\nprintLongestCommonPrefix([\"throne\", \"throne\"])\nprintLongestCommonPrefix([\"throne\", \"dungeon\"])\nprintLongestCommonPrefix([\"throne\", \"\", \"throne\"])\nprintLongestCommonPrefix([\"cheese\"])\nprintLongestCommonPrefix([\"\"])\nprintLongestCommonPrefix([])\nprintLongestCommonPrefix([\"prefix\", \"suffix\"])\nprintLongestCommonPrefix([\"foo\", \"foobar\"])\n", "target": "using System;\n\nnamespace LCP {\n    class Program {\n        public static string LongestCommonPrefix(params string[] sa) {\n            if (null == sa) return \"\"; \n            string ret = \"\";\n            int idx = 0;\n\n            while (true) {\n                char thisLetter = '\\0';\n                foreach (var word in sa) {\n                    if (idx == word.Length) {\n                        \n                        return ret;\n                    }\n                    if (thisLetter == '\\0') {\n                        \n                        thisLetter = word[idx];\n                    }\n                    if (thisLetter != word[idx]) {\n                        return ret;\n                    }\n                }\n\n                \n                ret += thisLetter;\n                idx++;\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(LongestCommonPrefix(\"interspecies\", \"interstellar\", \"interstate\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"throne\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"dungeon\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"\", \"throne\"));\n            Console.WriteLine(LongestCommonPrefix(\"cheese\"));\n            Console.WriteLine(LongestCommonPrefix(\"\"));\n            Console.WriteLine(LongestCommonPrefix(null));\n            Console.WriteLine(LongestCommonPrefix(\"prefix\", \"suffix\"));\n            Console.WriteLine(LongestCommonPrefix(\"foo\", \"foobar\"));\n        }\n    }\n}\n"}
{"id": 56522, "name": "Longest common prefix", "source": "Translate Swift to Java: func commonPrefix(string1: String, string2: String) -> String {\n    return String(zip(string1, string2).prefix(while: {$0 == $1}).map{$0.0})\n}\n\nfunc longestCommonPrefix(_ strings: [String]) -> String {\n    switch (strings.count) {\n    case 0:\n        return \"\"\n    case 1:\n        return strings[0]\n    default:\n        return commonPrefix(string1: strings.min()!, string2: strings.max()!)\n    }\n}\n\nfunc printLongestCommonPrefix(_ strings: [String]) {\n    print(\"lcp(\\(strings)) = \\\"\\(longestCommonPrefix(strings))\\\"\")\n}\n\nprintLongestCommonPrefix([\"interspecies\", \"interstellar\", \"interstate\"])\nprintLongestCommonPrefix([\"throne\", \"throne\"])\nprintLongestCommonPrefix([\"throne\", \"dungeon\"])\nprintLongestCommonPrefix([\"throne\", \"\", \"throne\"])\nprintLongestCommonPrefix([\"cheese\"])\nprintLongestCommonPrefix([\"\"])\nprintLongestCommonPrefix([])\nprintLongestCommonPrefix([\"prefix\", \"suffix\"])\nprintLongestCommonPrefix([\"foo\", \"foobar\"])\n", "target": "public class LCP {\n    public static String lcp(String... list){\n        if(list == null) return \"\";\n        String ret = \"\";\n        int idx = 0;\n\n        while(true){\n            char thisLetter = 0;\n            for(String word : list){\n                if(idx == word.length()){ \n                    return ret;\n                }\n                if(thisLetter == 0){ \n                    thisLetter = word.charAt(idx);\n                }\n                if(thisLetter != word.charAt(idx)){ \n                    return ret;\n                }\n            }\n            ret += thisLetter;\n            idx++;\n        }\n    }\n    \n    public static void main(String[] args){\n        System.out.println(lcp(\"interspecies\",\"interstellar\",\"interstate\"));\n        System.out.println(lcp(\"throne\",\"throne\"));\n        System.out.println(lcp(\"throne\",\"dungeon\"));\n        System.out.println(lcp(\"throne\",\"\",\"throne\"));\n        System.out.println(lcp(\"cheese\"));\n        System.out.println(lcp(\"\"));\n        System.out.println(lcp(null));\n        System.out.println(lcp(\"prefix\",\"suffix\"));\n        System.out.println(lcp(\"foo\",\"foobar\"));\n    }\n}\n"}
{"id": 56523, "name": "Longest common prefix", "source": "Translate Swift to Java: func commonPrefix(string1: String, string2: String) -> String {\n    return String(zip(string1, string2).prefix(while: {$0 == $1}).map{$0.0})\n}\n\nfunc longestCommonPrefix(_ strings: [String]) -> String {\n    switch (strings.count) {\n    case 0:\n        return \"\"\n    case 1:\n        return strings[0]\n    default:\n        return commonPrefix(string1: strings.min()!, string2: strings.max()!)\n    }\n}\n\nfunc printLongestCommonPrefix(_ strings: [String]) {\n    print(\"lcp(\\(strings)) = \\\"\\(longestCommonPrefix(strings))\\\"\")\n}\n\nprintLongestCommonPrefix([\"interspecies\", \"interstellar\", \"interstate\"])\nprintLongestCommonPrefix([\"throne\", \"throne\"])\nprintLongestCommonPrefix([\"throne\", \"dungeon\"])\nprintLongestCommonPrefix([\"throne\", \"\", \"throne\"])\nprintLongestCommonPrefix([\"cheese\"])\nprintLongestCommonPrefix([\"\"])\nprintLongestCommonPrefix([])\nprintLongestCommonPrefix([\"prefix\", \"suffix\"])\nprintLongestCommonPrefix([\"foo\", \"foobar\"])\n", "target": "public class LCP {\n    public static String lcp(String... list){\n        if(list == null) return \"\";\n        String ret = \"\";\n        int idx = 0;\n\n        while(true){\n            char thisLetter = 0;\n            for(String word : list){\n                if(idx == word.length()){ \n                    return ret;\n                }\n                if(thisLetter == 0){ \n                    thisLetter = word.charAt(idx);\n                }\n                if(thisLetter != word.charAt(idx)){ \n                    return ret;\n                }\n            }\n            ret += thisLetter;\n            idx++;\n        }\n    }\n    \n    public static void main(String[] args){\n        System.out.println(lcp(\"interspecies\",\"interstellar\",\"interstate\"));\n        System.out.println(lcp(\"throne\",\"throne\"));\n        System.out.println(lcp(\"throne\",\"dungeon\"));\n        System.out.println(lcp(\"throne\",\"\",\"throne\"));\n        System.out.println(lcp(\"cheese\"));\n        System.out.println(lcp(\"\"));\n        System.out.println(lcp(null));\n        System.out.println(lcp(\"prefix\",\"suffix\"));\n        System.out.println(lcp(\"foo\",\"foobar\"));\n    }\n}\n"}
{"id": 56524, "name": "Longest common prefix", "source": "Translate Swift to Python: func commonPrefix(string1: String, string2: String) -> String {\n    return String(zip(string1, string2).prefix(while: {$0 == $1}).map{$0.0})\n}\n\nfunc longestCommonPrefix(_ strings: [String]) -> String {\n    switch (strings.count) {\n    case 0:\n        return \"\"\n    case 1:\n        return strings[0]\n    default:\n        return commonPrefix(string1: strings.min()!, string2: strings.max()!)\n    }\n}\n\nfunc printLongestCommonPrefix(_ strings: [String]) {\n    print(\"lcp(\\(strings)) = \\\"\\(longestCommonPrefix(strings))\\\"\")\n}\n\nprintLongestCommonPrefix([\"interspecies\", \"interstellar\", \"interstate\"])\nprintLongestCommonPrefix([\"throne\", \"throne\"])\nprintLongestCommonPrefix([\"throne\", \"dungeon\"])\nprintLongestCommonPrefix([\"throne\", \"\", \"throne\"])\nprintLongestCommonPrefix([\"cheese\"])\nprintLongestCommonPrefix([\"\"])\nprintLongestCommonPrefix([])\nprintLongestCommonPrefix([\"prefix\", \"suffix\"])\nprintLongestCommonPrefix([\"foo\", \"foobar\"])\n", "target": "import os.path\n\ndef lcp(*s):\n    return os.path.commonprefix(s)\n\nassert lcp(\"interspecies\",\"interstellar\",\"interstate\") == \"inters\"\nassert lcp(\"throne\",\"throne\") == \"throne\"\nassert lcp(\"throne\",\"dungeon\") == \"\"\nassert lcp(\"cheese\") == \"cheese\"\nassert lcp(\"\") == \"\"\nassert lcp(\"prefix\",\"suffix\") == \"\"\nassert lcp(\"foo\",\"foobar\") == \"foo\"\n"}
{"id": 56525, "name": "Longest common prefix", "source": "Translate Swift to Python: func commonPrefix(string1: String, string2: String) -> String {\n    return String(zip(string1, string2).prefix(while: {$0 == $1}).map{$0.0})\n}\n\nfunc longestCommonPrefix(_ strings: [String]) -> String {\n    switch (strings.count) {\n    case 0:\n        return \"\"\n    case 1:\n        return strings[0]\n    default:\n        return commonPrefix(string1: strings.min()!, string2: strings.max()!)\n    }\n}\n\nfunc printLongestCommonPrefix(_ strings: [String]) {\n    print(\"lcp(\\(strings)) = \\\"\\(longestCommonPrefix(strings))\\\"\")\n}\n\nprintLongestCommonPrefix([\"interspecies\", \"interstellar\", \"interstate\"])\nprintLongestCommonPrefix([\"throne\", \"throne\"])\nprintLongestCommonPrefix([\"throne\", \"dungeon\"])\nprintLongestCommonPrefix([\"throne\", \"\", \"throne\"])\nprintLongestCommonPrefix([\"cheese\"])\nprintLongestCommonPrefix([\"\"])\nprintLongestCommonPrefix([])\nprintLongestCommonPrefix([\"prefix\", \"suffix\"])\nprintLongestCommonPrefix([\"foo\", \"foobar\"])\n", "target": "import os.path\n\ndef lcp(*s):\n    return os.path.commonprefix(s)\n\nassert lcp(\"interspecies\",\"interstellar\",\"interstate\") == \"inters\"\nassert lcp(\"throne\",\"throne\") == \"throne\"\nassert lcp(\"throne\",\"dungeon\") == \"\"\nassert lcp(\"cheese\") == \"cheese\"\nassert lcp(\"\") == \"\"\nassert lcp(\"prefix\",\"suffix\") == \"\"\nassert lcp(\"foo\",\"foobar\") == \"foo\"\n"}
{"id": 56774, "name": "String matching", "source": "Translate Swift to C#: var str = \"Hello, playground\"\nstr.hasPrefix(\"Hell\")           \nstr.hasPrefix(\"hell\")           \n\nstr.containsString(\"llo\")       \nstr.containsString(\"xxoo\")      \n\nstr.hasSuffix(\"playground\")     \nstr.hasSuffix(\"world\")          \n", "target": "class Program\n{\n\tpublic static void Main (string[] args)\n\t{\n\t\tvar value = \"abcd\".StartsWith(\"ab\");\n\t\tvalue = \"abcd\".EndsWith(\"zn\"); \n\t\tvalue = \"abab\".Contains(\"bb\"); \n\t\tvalue = \"abab\".Contains(\"ab\"); \n\t\tint loc = \"abab\".IndexOf(\"bb\"); \n\t\tloc = \"abab\".IndexOf(\"ab\"); \n\t\tloc = \"abab\".IndexOf(\"ab\",loc+1); \n\t}\n}\n"}
{"id": 56776, "name": "String matching", "source": "Translate Swift to Java: var str = \"Hello, playground\"\nstr.hasPrefix(\"Hell\")           \nstr.hasPrefix(\"hell\")           \n\nstr.containsString(\"llo\")       \nstr.containsString(\"xxoo\")      \n\nstr.hasSuffix(\"playground\")     \nstr.hasSuffix(\"world\")          \n", "target": "\"abcd\".startsWith(\"ab\") \n\"abcd\".endsWith(\"zn\") \n\"abab\".contains(\"bb\") \n\"abab\".contains(\"ab\") \nint loc = \"abab\".indexOf(\"bb\") \nloc = \"abab\".indexOf(\"ab\") \nloc = \"abab\".indexOf(\"ab\",loc+1) \n"}
{"id": 56777, "name": "String matching", "source": "Translate Swift to Python: var str = \"Hello, playground\"\nstr.hasPrefix(\"Hell\")           \nstr.hasPrefix(\"hell\")           \n\nstr.containsString(\"llo\")       \nstr.containsString(\"xxoo\")      \n\nstr.hasSuffix(\"playground\")     \nstr.hasSuffix(\"world\")          \n", "target": "\"abcd\".startswith(\"ab\") \n\"abcd\".endswith(\"zn\") \n\"bb\" in \"abab\" \n\"ab\" in \"abab\" \nloc = \"abab\".find(\"bb\") \nloc = \"abab\".find(\"ab\") \nloc = \"abab\".find(\"ab\",loc+1) \n"}
{"id": 57057, "name": "Real constants and functions", "source": "Translate Swift to C#: import Darwin\n\nM_E \nM_PI \nsqrt(x) \nlog(x) \nexp(x) \nabs(x) \nfloor(x) \nceil(x) \npow(x,y) \n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {        \n        Console.WriteLine(Math.E); \n        Console.WriteLine(Math.PI); \n        Console.WriteLine(Math.Sqrt(10)); \n        Console.WriteLine(Math.Log(10)); \n        Console.WriteLine(Math.Log10(10)); \n        Console.WriteLine(Math.Exp(10)); \n        Console.WriteLine(Math.Abs(10)); \n        Console.WriteLine(Math.Floor(10.0)); \n        Console.WriteLine(Math.Ceiling(10.0)); \n        Console.WriteLine(Math.Pow(2, 5)); \n    }\n}\n"}
{"id": 57059, "name": "Real constants and functions", "source": "Translate Swift to Java: import Darwin\n\nM_E \nM_PI \nsqrt(x) \nlog(x) \nexp(x) \nabs(x) \nfloor(x) \nceil(x) \npow(x,y) \n", "target": "Math.E; \nMath.PI; \nMath.sqrt(x); \nMath.log(x); \nMath.exp(x); \nMath.abs(x); \nMath.floor(x); \nMath.ceil(x); \nMath.pow(x,y); \n"}
{"id": 57060, "name": "Real constants and functions", "source": "Translate Swift to Python: import Darwin\n\nM_E \nM_PI \nsqrt(x) \nlog(x) \nexp(x) \nabs(x) \nfloor(x) \nceil(x) \npow(x,y) \n", "target": "import math\n\nmath.e          \nmath.pi         \nmath.sqrt(x)    \nmath.log(x)     \nmath.log10(x)   \nmath.exp(x)     \nabs(x)          \nmath.floor(x)   \nmath.ceil(x)    \nx ** y          \npow(x, y[, n])  \n\n\n\n"}
{"id": 57235, "name": "Singly-linked list_Element definition", "source": "Translate Swift to C#: class Node<T>{\n    var data:T?=nil\n    var next:Node?=nil\n    init(input:T){\n        data=input\n        next=nil\n    }\n}\n", "target": "class LinkedListNode\n{\n    public int Value { get; set; }\n    public LinkedListNode Next { get; set; }\n\n    \n    public Link(int value, LinkedListNode next = null)\n    {\n        Item = value;\n        Next = next;\n    }\n}\n"}
{"id": 57237, "name": "Singly-linked list_Element definition", "source": "Translate Swift to Java: class Node<T>{\n    var data:T?=nil\n    var next:Node?=nil\n    init(input:T){\n        data=input\n        next=nil\n    }\n}\n", "target": "class Link\n{\n    Link next;\n    int data;\n}\n"}
{"id": 57238, "name": "Singly-linked list_Element definition", "source": "Translate Swift to Python: class Node<T>{\n    var data:T?=nil\n    var next:Node?=nil\n    init(input:T){\n        data=input\n        next=nil\n    }\n}\n", "target": "class LinkedList(object):\n     \n\tclass Node(object):\n\t\tdef __init__(self, item):\n\t\t\tself.value  = item\n\t\t\tself.next = None\n\tdef __init__(self, item=None):\n\t\tif item is not None:\n\t\t\tself.head = Node(item); self.tail = self.head\n\t\telse:\n\t\t\tself.head = None; self.tail = None\n\tdef append(self, item):\n\t\tif not self.head:\n\t\t\tself.head = Node(item)\n\t\t\tself.tail = self.head\n\t\telif self.tail:\n\t\t\tself.tail.next = Node(item)\n\t\t\tself.tail = self.tail.next\n\t\telse:\n\t\t\tself.tail = Node(item)\n\tdef __iter__(self):\n\t\tcursor = self.head\n\t\twhile cursor:\n\t\t\tyield cursor.value\n\t\t\tcursor = cursor.next\n"}
{"id": 57357, "name": "Pell's equation", "source": "Translate Swift to C#: func solvePell<T: BinaryInteger>(n: T, _ a: inout T, _ b: inout T) {\n  func swap(_ a: inout T, _ b: inout T, mul by: T) {\n    (a, b) = (b, b * by + a)\n  }\n\n  let x = T(Double(n).squareRoot())\n  var y = x\n  var z = T(1)\n  var r = x << 1\n  var e1 = T(1)\n  var e2 = T(0)\n  var f1 = T(0)\n  var f2 = T(1)\n\n  while true {\n    y = r * z - y\n    z = (n - y * y) / z\n    r = (x + y) / z\n\n    swap(&e1, &e2, mul: r)\n    swap(&f1, &f2, mul: r)\n\n    (a, b) = (f2, e2)\n\n    swap(&b, &a, mul: x)\n\n    if a * a - n * b * b == 1 {\n      return\n    }\n  }\n}\n\nvar x = BigInt(0)\nvar y = BigInt(0)\n\nfor n in [61, 109, 181, 277] {\n  solvePell(n: BigInt(n), &x, &y)\n\n  print(\"x\\u{00b2} - \\(n)y\\u{00b2} = 1 for x = \\(x) and y = \\(y)\")\n}\n", "target": "using System;\nusing System.Numerics;\n\nstatic class Program\n{\n    static void Fun(ref BigInteger a, ref BigInteger b, int c)\n    {\n        BigInteger t = a; a = b; b = b * c + t;\n    }\n\n    static void SolvePell(int n, ref BigInteger a, ref BigInteger b)\n    {\n        int x = (int)Math.Sqrt(n), y = x, z = 1, r = x << 1;\n        BigInteger e1 = 1, e2 = 0, f1 = 0, f2 = 1;\n        while (true)\n        {\n            y = r * z - y; z = (n - y * y) / z; r = (x + y) / z;\n            Fun(ref e1, ref e2, r); Fun(ref f1, ref f2, r); a = f2; b = e2; Fun(ref b, ref a, x);\n            if (a * a - n * b * b == 1) return;\n        }\n    }\n\n    static void Main()\n    {\n        BigInteger x, y; foreach (int n in new[] { 61, 109, 181, 277 })\n        {\n            SolvePell(n, ref x, ref y);\n            Console.WriteLine(\"x^2 - {0,3} * y^2 = 1 for x = {1,27:n0} and y = {2,25:n0}\", n, x, y);\n        }\n    }\n}\n"}
{"id": 57359, "name": "Pell's equation", "source": "Translate Swift to Java: func solvePell<T: BinaryInteger>(n: T, _ a: inout T, _ b: inout T) {\n  func swap(_ a: inout T, _ b: inout T, mul by: T) {\n    (a, b) = (b, b * by + a)\n  }\n\n  let x = T(Double(n).squareRoot())\n  var y = x\n  var z = T(1)\n  var r = x << 1\n  var e1 = T(1)\n  var e2 = T(0)\n  var f1 = T(0)\n  var f2 = T(1)\n\n  while true {\n    y = r * z - y\n    z = (n - y * y) / z\n    r = (x + y) / z\n\n    swap(&e1, &e2, mul: r)\n    swap(&f1, &f2, mul: r)\n\n    (a, b) = (f2, e2)\n\n    swap(&b, &a, mul: x)\n\n    if a * a - n * b * b == 1 {\n      return\n    }\n  }\n}\n\nvar x = BigInt(0)\nvar y = BigInt(0)\n\nfor n in [61, 109, 181, 277] {\n  solvePell(n: BigInt(n), &x, &y)\n\n  print(\"x\\u{00b2} - \\(n)y\\u{00b2} = 1 for x = \\(x) and y = \\(y)\")\n}\n", "target": "import java.math.BigInteger;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PellsEquation {\n\n    public static void main(String[] args) {\n        NumberFormat format = NumberFormat.getInstance();\n        for ( int n : new int[] {61, 109, 181, 277, 8941} ) {\n            BigInteger[] pell = pellsEquation(n);\n            System.out.printf(\"x^2 - %3d * y^2 = 1 for:%n    x = %s%n    y = %s%n%n\", n,  format.format(pell[0]),  format.format(pell[1]));\n        }\n    }\n\n    private static final BigInteger[] pellsEquation(int n) {\n        int a0 = (int) Math.sqrt(n);\n        if ( a0*a0 == n ) {\n            throw new IllegalArgumentException(\"ERROR 102:  Invalid n = \" + n);\n        }\n        List<Integer> continuedFrac = continuedFraction(n);\n        int count = 0;\n        BigInteger ajm2 = BigInteger.ONE;\n        BigInteger ajm1 = new BigInteger(a0 + \"\");\n        BigInteger bjm2 = BigInteger.ZERO;\n        BigInteger bjm1 = BigInteger.ONE;\n        boolean stop = (continuedFrac.size() % 2 == 1);\n        if ( continuedFrac.size() == 2 ) {\n            stop = true;\n        }\n        while ( true ) {\n            count++;\n            BigInteger bn = new BigInteger(continuedFrac.get(count) + \"\");\n            BigInteger aj = bn.multiply(ajm1).add(ajm2);\n            BigInteger bj = bn.multiply(bjm1).add(bjm2);\n            if ( stop && (count == continuedFrac.size()-2 || continuedFrac.size() == 2) ) {\n                return new BigInteger[] {aj, bj};\n            }\n            else if (continuedFrac.size() % 2 == 0 && count == continuedFrac.size()-2 ) {\n                stop = true;\n            }\n            if ( count == continuedFrac.size()-1 ) {\n                count = 0;\n            }\n            ajm2 = ajm1;\n            ajm1 = aj;\n            bjm2 = bjm1;\n            bjm1 = bj;\n        }\n    }\n\n    private static final List<Integer> continuedFraction(int n) {\n        List<Integer> answer = new ArrayList<Integer>();\n        int a0 = (int) Math.sqrt(n);\n        answer.add(a0);\n        int a = -a0;\n        int aStart = a;\n        int b = 1;\n        int bStart = b;\n\n        while ( true ) {\n            \n            int[] values = iterateFrac(n, a, b);\n            answer.add(values[0]);\n            a = values[1];\n            b = values[2];\n            if (a == aStart && b == bStart) break;\n        }\n        return answer;\n    }\n    \n    \n    \n    \n    private static final int[] iterateFrac(int n, int a, int b) {\n        int x = (int) Math.floor((b * Math.sqrt(n) - b * a)/(n - a * a));\n        int[] answer = new int[3];\n        answer[0] = x;\n        answer[1] = -(b * a + x *(n - a * a)) / b;\n        answer[2] = (n - a * a) / b;\n        return answer;\n    }\n\n\n}\n"}
{"id": 57360, "name": "Pell's equation", "source": "Translate Swift to Python: func solvePell<T: BinaryInteger>(n: T, _ a: inout T, _ b: inout T) {\n  func swap(_ a: inout T, _ b: inout T, mul by: T) {\n    (a, b) = (b, b * by + a)\n  }\n\n  let x = T(Double(n).squareRoot())\n  var y = x\n  var z = T(1)\n  var r = x << 1\n  var e1 = T(1)\n  var e2 = T(0)\n  var f1 = T(0)\n  var f2 = T(1)\n\n  while true {\n    y = r * z - y\n    z = (n - y * y) / z\n    r = (x + y) / z\n\n    swap(&e1, &e2, mul: r)\n    swap(&f1, &f2, mul: r)\n\n    (a, b) = (f2, e2)\n\n    swap(&b, &a, mul: x)\n\n    if a * a - n * b * b == 1 {\n      return\n    }\n  }\n}\n\nvar x = BigInt(0)\nvar y = BigInt(0)\n\nfor n in [61, 109, 181, 277] {\n  solvePell(n: BigInt(n), &x, &y)\n\n  print(\"x\\u{00b2} - \\(n)y\\u{00b2} = 1 for x = \\(x) and y = \\(y)\")\n}\n", "target": "import math\n\ndef solvePell(n):\n    x = int(math.sqrt(n))\n    y, z, r = x, 1, x << 1\n    e1, e2 = 1, 0\n    f1, f2 = 0, 1\n    while True:\n        y = r * z - y\n        z = (n - y * y) // z\n        r = (x + y) // z\n\n        e1, e2 = e2, e1 + e2 * r\n        f1, f2 = f2, f1 + f2 * r\n\n        a, b = f2 * x + e2, f2\n        if a * a - n * b * b == 1:\n            return a, b\n\nfor n in [61, 109, 181, 277]:\n    x, y = solvePell(n)\n    print(\"x^2 - %3d * y^2 = 1 for x = %27d and y = %25d\" % (n, x, y))\n"}
{"id": 57536, "name": "System time", "source": "Translate Swift to Java: import Foundation\n\nvar \u231a\ufe0f = NSDate()\nprintln(\u231a\ufe0f)\n", "target": "public class SystemTime{\n    public static void main(String[] args){\n        System.out.format(\"%tc%n\", System.currentTimeMillis());\n    }\n}\n"}
{"id": 57920, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Swift to C#: import Foundation\n\nfunc isPalin2(n: Int) -> Bool {\n  var x = 0\n  var n = n\n\n  guard n & 1 != 0 else {\n    return n == 0\n  }\n\n  while x < n {\n    x = x << 1 | n & 1\n    n >>= 1\n  }\n\n  return n == x || n == x >> 1\n}\n\nfunc reverse3(n: Int) -> Int {\n  var x = 0\n  var n = n\n\n  while n > 0 {\n    x = x * 3 + (n % 3)\n    n /= 3\n  }\n\n  return x\n}\n\nfunc printN(_ n: Int, base: Int) {\n  var n = n\n\n  print(\" \", terminator: \"\")\n\n  repeat {\n    print(\"\\(n % base)\", terminator: \"\")\n\n    n /= base\n  } while n > 0\n\n  print(\"(\\(base))\", terminator: \"\")\n}\n\nfunc show(n: Int) {\n  print(n, terminator: \"\")\n  printN(n, base: 2)\n  printN(n, base: 3)\n  print()\n}\n\nprivate var count = 0\nprivate var lo = 0\nprivate var (hi, pow2, pow3) = (1, 1, 1)\n\nshow(n: 0)\n\nwhile true {\n  var n: Int\n\n  for i in lo..<hi {\n    n = (i * 3 + 1) * pow3 + reverse3(n: i)\n\n    guard isPalin2(n: n) else {\n      continue\n    }\n\n    show(n: n)\n    count += 1\n\n    guard count < 7 else {\n      exit(0)\n    }\n  }\n\n  if hi == pow3 {\n    pow3 *= 3\n  } else {\n    pow2 *= 4\n  }\n\n  while true {\n    while pow2 <= pow3 {\n      pow2 *= 4\n    }\n\n    let lo2 = (pow2 / pow3 - 1) / 3\n    let hi2 = (pow2 * 2 / pow3 - 1) / 3 + 1\n    let lo3 = pow3 / 3\n    let hi3 = pow3\n\n    if lo2 >= hi3 {\n      pow3 *= 3\n    } else if lo3 >= hi2 {\n      pow2 *= 4\n    } else {\n      lo = max(lo2, lo3)\n      hi = min(hi2, hi3)\n      break\n    }\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class FindPalindromicNumbers\n{\n    static void Main(string[] args)\n    {\n        var query =\n            PalindromicTernaries()\n            .Where(IsPalindromicBinary)\n            .Take(6);\n        foreach (var x in query) {\n            Console.WriteLine(\"Decimal: \" + x);\n            Console.WriteLine(\"Ternary: \" + ToTernary(x));\n            Console.WriteLine(\"Binary: \" + Convert.ToString(x, 2));\n            Console.WriteLine();\n        }\n    }\n\n    public static IEnumerable<long> PalindromicTernaries() {\n        yield return 0;\n        yield return 1;\n        yield return 13;\n        yield return 23;\n\n        var f = new List<long> {0};\n        long fMiddle = 9;\n        while (true) {\n            for (long edge = 1; edge < 3; edge++) {\n                int i;\n                do {\n                    \n                    long result = fMiddle;\n                    long fLeft = fMiddle * 3;\n                    long fRight = fMiddle / 3;\n                    for (int j = f.Count - 1; j >= 0; j--) {\n                        result += (fLeft + fRight) * f[j];\n                        fLeft *= 3;\n                        fRight /= 3;\n                    }\n                    result += (fLeft + fRight) * edge;\n                    yield return result;\n\n                    \n                    for (i = f.Count - 1; i >= 0; i--) {\n                        if (f[i] == 2) {\n                            f[i] = 0;\n                        } else {\n                            f[i]++;\n                            break;\n                        }\n                    }\n                } while (i >= 0);\n            }\n            f.Add(0);\n            fMiddle *= 3;\n        }\n    }\n\n    public static bool IsPalindromicBinary(long number) {\n        long n = number;\n        long reverse = 0;\n        while (n != 0) {\n            reverse <<= 1;\n            if ((n & 1) == 1) reverse++;\n            n >>= 1;\n        }\n        return reverse == number;\n    }\n\n    public static string ToTernary(long n)\n    {\n        if (n == 0) return \"0\";\n        string result = \"\";\n        while (n > 0) {        {\n            result = (n % 3) + result;\n            n /= 3;\n        }\n        return result;\n    }\n\n}\n"}
{"id": 57921, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Swift to C#: import Foundation\n\nfunc isPalin2(n: Int) -> Bool {\n  var x = 0\n  var n = n\n\n  guard n & 1 != 0 else {\n    return n == 0\n  }\n\n  while x < n {\n    x = x << 1 | n & 1\n    n >>= 1\n  }\n\n  return n == x || n == x >> 1\n}\n\nfunc reverse3(n: Int) -> Int {\n  var x = 0\n  var n = n\n\n  while n > 0 {\n    x = x * 3 + (n % 3)\n    n /= 3\n  }\n\n  return x\n}\n\nfunc printN(_ n: Int, base: Int) {\n  var n = n\n\n  print(\" \", terminator: \"\")\n\n  repeat {\n    print(\"\\(n % base)\", terminator: \"\")\n\n    n /= base\n  } while n > 0\n\n  print(\"(\\(base))\", terminator: \"\")\n}\n\nfunc show(n: Int) {\n  print(n, terminator: \"\")\n  printN(n, base: 2)\n  printN(n, base: 3)\n  print()\n}\n\nprivate var count = 0\nprivate var lo = 0\nprivate var (hi, pow2, pow3) = (1, 1, 1)\n\nshow(n: 0)\n\nwhile true {\n  var n: Int\n\n  for i in lo..<hi {\n    n = (i * 3 + 1) * pow3 + reverse3(n: i)\n\n    guard isPalin2(n: n) else {\n      continue\n    }\n\n    show(n: n)\n    count += 1\n\n    guard count < 7 else {\n      exit(0)\n    }\n  }\n\n  if hi == pow3 {\n    pow3 *= 3\n  } else {\n    pow2 *= 4\n  }\n\n  while true {\n    while pow2 <= pow3 {\n      pow2 *= 4\n    }\n\n    let lo2 = (pow2 / pow3 - 1) / 3\n    let hi2 = (pow2 * 2 / pow3 - 1) / 3 + 1\n    let lo3 = pow3 / 3\n    let hi3 = pow3\n\n    if lo2 >= hi3 {\n      pow3 *= 3\n    } else if lo3 >= hi2 {\n      pow2 *= 4\n    } else {\n      lo = max(lo2, lo3)\n      hi = min(hi2, hi3)\n      break\n    }\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class FindPalindromicNumbers\n{\n    static void Main(string[] args)\n    {\n        var query =\n            PalindromicTernaries()\n            .Where(IsPalindromicBinary)\n            .Take(6);\n        foreach (var x in query) {\n            Console.WriteLine(\"Decimal: \" + x);\n            Console.WriteLine(\"Ternary: \" + ToTernary(x));\n            Console.WriteLine(\"Binary: \" + Convert.ToString(x, 2));\n            Console.WriteLine();\n        }\n    }\n\n    public static IEnumerable<long> PalindromicTernaries() {\n        yield return 0;\n        yield return 1;\n        yield return 13;\n        yield return 23;\n\n        var f = new List<long> {0};\n        long fMiddle = 9;\n        while (true) {\n            for (long edge = 1; edge < 3; edge++) {\n                int i;\n                do {\n                    \n                    long result = fMiddle;\n                    long fLeft = fMiddle * 3;\n                    long fRight = fMiddle / 3;\n                    for (int j = f.Count - 1; j >= 0; j--) {\n                        result += (fLeft + fRight) * f[j];\n                        fLeft *= 3;\n                        fRight /= 3;\n                    }\n                    result += (fLeft + fRight) * edge;\n                    yield return result;\n\n                    \n                    for (i = f.Count - 1; i >= 0; i--) {\n                        if (f[i] == 2) {\n                            f[i] = 0;\n                        } else {\n                            f[i]++;\n                            break;\n                        }\n                    }\n                } while (i >= 0);\n            }\n            f.Add(0);\n            fMiddle *= 3;\n        }\n    }\n\n    public static bool IsPalindromicBinary(long number) {\n        long n = number;\n        long reverse = 0;\n        while (n != 0) {\n            reverse <<= 1;\n            if ((n & 1) == 1) reverse++;\n            n >>= 1;\n        }\n        return reverse == number;\n    }\n\n    public static string ToTernary(long n)\n    {\n        if (n == 0) return \"0\";\n        string result = \"\";\n        while (n > 0) {        {\n            result = (n % 3) + result;\n            n /= 3;\n        }\n        return result;\n    }\n\n}\n"}
{"id": 57922, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Swift to Java: import Foundation\n\nfunc isPalin2(n: Int) -> Bool {\n  var x = 0\n  var n = n\n\n  guard n & 1 != 0 else {\n    return n == 0\n  }\n\n  while x < n {\n    x = x << 1 | n & 1\n    n >>= 1\n  }\n\n  return n == x || n == x >> 1\n}\n\nfunc reverse3(n: Int) -> Int {\n  var x = 0\n  var n = n\n\n  while n > 0 {\n    x = x * 3 + (n % 3)\n    n /= 3\n  }\n\n  return x\n}\n\nfunc printN(_ n: Int, base: Int) {\n  var n = n\n\n  print(\" \", terminator: \"\")\n\n  repeat {\n    print(\"\\(n % base)\", terminator: \"\")\n\n    n /= base\n  } while n > 0\n\n  print(\"(\\(base))\", terminator: \"\")\n}\n\nfunc show(n: Int) {\n  print(n, terminator: \"\")\n  printN(n, base: 2)\n  printN(n, base: 3)\n  print()\n}\n\nprivate var count = 0\nprivate var lo = 0\nprivate var (hi, pow2, pow3) = (1, 1, 1)\n\nshow(n: 0)\n\nwhile true {\n  var n: Int\n\n  for i in lo..<hi {\n    n = (i * 3 + 1) * pow3 + reverse3(n: i)\n\n    guard isPalin2(n: n) else {\n      continue\n    }\n\n    show(n: n)\n    count += 1\n\n    guard count < 7 else {\n      exit(0)\n    }\n  }\n\n  if hi == pow3 {\n    pow3 *= 3\n  } else {\n    pow2 *= 4\n  }\n\n  while true {\n    while pow2 <= pow3 {\n      pow2 *= 4\n    }\n\n    let lo2 = (pow2 / pow3 - 1) / 3\n    let hi2 = (pow2 * 2 / pow3 - 1) / 3 + 1\n    let lo3 = pow3 / 3\n    let hi3 = pow3\n\n    if lo2 >= hi3 {\n      pow3 *= 3\n    } else if lo3 >= hi2 {\n      pow2 *= 4\n    } else {\n      lo = max(lo2, lo3)\n      hi = min(hi2, hi3)\n      break\n    }\n  }\n}\n", "target": "public class Pali23 {\n\tpublic static boolean isPali(String x){\n\t\treturn x.equals(new StringBuilder(x).reverse().toString());\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tfor(long i = 0, count = 0; count < 6;i++){\n\t\t\tif((i & 1) == 0 && (i != 0)) continue; \n\t\t\t\n\t\t\t\n\t\t\tif(isPali(Long.toBinaryString(i)) && isPali(Long.toString(i, 3))){\n\t\t\t\tSystem.out.println(i + \", \" + Long.toBinaryString(i) + \", \" + Long.toString(i, 3));\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 57923, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Swift to Java: import Foundation\n\nfunc isPalin2(n: Int) -> Bool {\n  var x = 0\n  var n = n\n\n  guard n & 1 != 0 else {\n    return n == 0\n  }\n\n  while x < n {\n    x = x << 1 | n & 1\n    n >>= 1\n  }\n\n  return n == x || n == x >> 1\n}\n\nfunc reverse3(n: Int) -> Int {\n  var x = 0\n  var n = n\n\n  while n > 0 {\n    x = x * 3 + (n % 3)\n    n /= 3\n  }\n\n  return x\n}\n\nfunc printN(_ n: Int, base: Int) {\n  var n = n\n\n  print(\" \", terminator: \"\")\n\n  repeat {\n    print(\"\\(n % base)\", terminator: \"\")\n\n    n /= base\n  } while n > 0\n\n  print(\"(\\(base))\", terminator: \"\")\n}\n\nfunc show(n: Int) {\n  print(n, terminator: \"\")\n  printN(n, base: 2)\n  printN(n, base: 3)\n  print()\n}\n\nprivate var count = 0\nprivate var lo = 0\nprivate var (hi, pow2, pow3) = (1, 1, 1)\n\nshow(n: 0)\n\nwhile true {\n  var n: Int\n\n  for i in lo..<hi {\n    n = (i * 3 + 1) * pow3 + reverse3(n: i)\n\n    guard isPalin2(n: n) else {\n      continue\n    }\n\n    show(n: n)\n    count += 1\n\n    guard count < 7 else {\n      exit(0)\n    }\n  }\n\n  if hi == pow3 {\n    pow3 *= 3\n  } else {\n    pow2 *= 4\n  }\n\n  while true {\n    while pow2 <= pow3 {\n      pow2 *= 4\n    }\n\n    let lo2 = (pow2 / pow3 - 1) / 3\n    let hi2 = (pow2 * 2 / pow3 - 1) / 3 + 1\n    let lo3 = pow3 / 3\n    let hi3 = pow3\n\n    if lo2 >= hi3 {\n      pow3 *= 3\n    } else if lo3 >= hi2 {\n      pow2 *= 4\n    } else {\n      lo = max(lo2, lo3)\n      hi = min(hi2, hi3)\n      break\n    }\n  }\n}\n", "target": "public class Pali23 {\n\tpublic static boolean isPali(String x){\n\t\treturn x.equals(new StringBuilder(x).reverse().toString());\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tfor(long i = 0, count = 0; count < 6;i++){\n\t\t\tif((i & 1) == 0 && (i != 0)) continue; \n\t\t\t\n\t\t\t\n\t\t\tif(isPali(Long.toBinaryString(i)) && isPali(Long.toString(i, 3))){\n\t\t\t\tSystem.out.println(i + \", \" + Long.toBinaryString(i) + \", \" + Long.toString(i, 3));\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 57924, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Swift to Python: import Foundation\n\nfunc isPalin2(n: Int) -> Bool {\n  var x = 0\n  var n = n\n\n  guard n & 1 != 0 else {\n    return n == 0\n  }\n\n  while x < n {\n    x = x << 1 | n & 1\n    n >>= 1\n  }\n\n  return n == x || n == x >> 1\n}\n\nfunc reverse3(n: Int) -> Int {\n  var x = 0\n  var n = n\n\n  while n > 0 {\n    x = x * 3 + (n % 3)\n    n /= 3\n  }\n\n  return x\n}\n\nfunc printN(_ n: Int, base: Int) {\n  var n = n\n\n  print(\" \", terminator: \"\")\n\n  repeat {\n    print(\"\\(n % base)\", terminator: \"\")\n\n    n /= base\n  } while n > 0\n\n  print(\"(\\(base))\", terminator: \"\")\n}\n\nfunc show(n: Int) {\n  print(n, terminator: \"\")\n  printN(n, base: 2)\n  printN(n, base: 3)\n  print()\n}\n\nprivate var count = 0\nprivate var lo = 0\nprivate var (hi, pow2, pow3) = (1, 1, 1)\n\nshow(n: 0)\n\nwhile true {\n  var n: Int\n\n  for i in lo..<hi {\n    n = (i * 3 + 1) * pow3 + reverse3(n: i)\n\n    guard isPalin2(n: n) else {\n      continue\n    }\n\n    show(n: n)\n    count += 1\n\n    guard count < 7 else {\n      exit(0)\n    }\n  }\n\n  if hi == pow3 {\n    pow3 *= 3\n  } else {\n    pow2 *= 4\n  }\n\n  while true {\n    while pow2 <= pow3 {\n      pow2 *= 4\n    }\n\n    let lo2 = (pow2 / pow3 - 1) / 3\n    let hi2 = (pow2 * 2 / pow3 - 1) / 3 + 1\n    let lo3 = pow3 / 3\n    let hi3 = pow3\n\n    if lo2 >= hi3 {\n      pow3 *= 3\n    } else if lo3 >= hi2 {\n      pow2 *= 4\n    } else {\n      lo = max(lo2, lo3)\n      hi = min(hi2, hi3)\n      break\n    }\n  }\n}\n", "target": "from itertools import islice\n\ndigits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\ndef baseN(num,b):\n  if num == 0: return \"0\"\n  result = \"\"\n  while num != 0:\n    num, d = divmod(num, b)\n    result += digits[d]\n  return result[::-1] \n\ndef pal2(num):\n    if num == 0 or num == 1: return True\n    based = bin(num)[2:]\n    return based == based[::-1]\n\ndef pal_23():\n    yield 0\n    yield 1\n    n = 1\n    while True:\n        n += 1\n        b = baseN(n, 3)\n        revb = b[::-1]\n        \n        for trial in ('{0}{1}'.format(b, revb), '{0}0{1}'.format(b, revb),\n                      '{0}1{1}'.format(b, revb), '{0}2{1}'.format(b, revb)):\n            t = int(trial, 3)\n            if pal2(t):\n                yield t\n\nfor pal23 in islice(pal_23(), 6):\n    print(pal23, baseN(pal23, 3), baseN(pal23, 2))\n"}
{"id": 57925, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Swift to Python: import Foundation\n\nfunc isPalin2(n: Int) -> Bool {\n  var x = 0\n  var n = n\n\n  guard n & 1 != 0 else {\n    return n == 0\n  }\n\n  while x < n {\n    x = x << 1 | n & 1\n    n >>= 1\n  }\n\n  return n == x || n == x >> 1\n}\n\nfunc reverse3(n: Int) -> Int {\n  var x = 0\n  var n = n\n\n  while n > 0 {\n    x = x * 3 + (n % 3)\n    n /= 3\n  }\n\n  return x\n}\n\nfunc printN(_ n: Int, base: Int) {\n  var n = n\n\n  print(\" \", terminator: \"\")\n\n  repeat {\n    print(\"\\(n % base)\", terminator: \"\")\n\n    n /= base\n  } while n > 0\n\n  print(\"(\\(base))\", terminator: \"\")\n}\n\nfunc show(n: Int) {\n  print(n, terminator: \"\")\n  printN(n, base: 2)\n  printN(n, base: 3)\n  print()\n}\n\nprivate var count = 0\nprivate var lo = 0\nprivate var (hi, pow2, pow3) = (1, 1, 1)\n\nshow(n: 0)\n\nwhile true {\n  var n: Int\n\n  for i in lo..<hi {\n    n = (i * 3 + 1) * pow3 + reverse3(n: i)\n\n    guard isPalin2(n: n) else {\n      continue\n    }\n\n    show(n: n)\n    count += 1\n\n    guard count < 7 else {\n      exit(0)\n    }\n  }\n\n  if hi == pow3 {\n    pow3 *= 3\n  } else {\n    pow2 *= 4\n  }\n\n  while true {\n    while pow2 <= pow3 {\n      pow2 *= 4\n    }\n\n    let lo2 = (pow2 / pow3 - 1) / 3\n    let hi2 = (pow2 * 2 / pow3 - 1) / 3 + 1\n    let lo3 = pow3 / 3\n    let hi3 = pow3\n\n    if lo2 >= hi3 {\n      pow3 *= 3\n    } else if lo3 >= hi2 {\n      pow2 *= 4\n    } else {\n      lo = max(lo2, lo3)\n      hi = min(hi2, hi3)\n      break\n    }\n  }\n}\n", "target": "from itertools import islice\n\ndigits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\ndef baseN(num,b):\n  if num == 0: return \"0\"\n  result = \"\"\n  while num != 0:\n    num, d = divmod(num, b)\n    result += digits[d]\n  return result[::-1] \n\ndef pal2(num):\n    if num == 0 or num == 1: return True\n    based = bin(num)[2:]\n    return based == based[::-1]\n\ndef pal_23():\n    yield 0\n    yield 1\n    n = 1\n    while True:\n        n += 1\n        b = baseN(n, 3)\n        revb = b[::-1]\n        \n        for trial in ('{0}{1}'.format(b, revb), '{0}0{1}'.format(b, revb),\n                      '{0}1{1}'.format(b, revb), '{0}2{1}'.format(b, revb)):\n            t = int(trial, 3)\n            if pal2(t):\n                yield t\n\nfor pal23 in islice(pal_23(), 6):\n    print(pal23, baseN(pal23, 3), baseN(pal23, 2))\n"}
{"id": 59305, "name": "URL decoding", "source": "Translate Swift to C#: import Foundation\n\nlet encoded = \"http%3A%2F%2Ffoo%20bar%2F\"\nif let normal = encoded.stringByReplacingPercentEscapesUsingEncoding(NSUTF8StringEncoding) {\n  println(normal)\n}\n", "target": "using System;\n\nnamespace URLEncode\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            Console.WriteLine(Decode(\"http%3A%2F%2Ffoo%20bar%2F\"));\n        }\n\n        private static string Decode(string uri)\n        {\n            return Uri.UnescapeDataString(uri);\n        }\n    }\n}\n"}
{"id": 59306, "name": "URL decoding", "source": "Translate Swift to C#: import Foundation\n\nlet encoded = \"http%3A%2F%2Ffoo%20bar%2F\"\nif let normal = encoded.stringByReplacingPercentEscapesUsingEncoding(NSUTF8StringEncoding) {\n  println(normal)\n}\n", "target": "using System;\n\nnamespace URLEncode\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            Console.WriteLine(Decode(\"http%3A%2F%2Ffoo%20bar%2F\"));\n        }\n\n        private static string Decode(string uri)\n        {\n            return Uri.UnescapeDataString(uri);\n        }\n    }\n}\n"}
{"id": 59309, "name": "URL decoding", "source": "Translate Swift to Java: import Foundation\n\nlet encoded = \"http%3A%2F%2Ffoo%20bar%2F\"\nif let normal = encoded.stringByReplacingPercentEscapesUsingEncoding(NSUTF8StringEncoding) {\n  println(normal)\n}\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\n\npublic class Main\n{\n    public static void main(String[] args) throws UnsupportedEncodingException\n    {\n        String encoded = \"http%3A%2F%2Ffoo%20bar%2F\";\n        String normal = URLDecoder.decode(encoded, \"utf-8\");\n        System.out.println(normal);\n    }\n}\n"}
{"id": 59310, "name": "URL decoding", "source": "Translate Swift to Java: import Foundation\n\nlet encoded = \"http%3A%2F%2Ffoo%20bar%2F\"\nif let normal = encoded.stringByReplacingPercentEscapesUsingEncoding(NSUTF8StringEncoding) {\n  println(normal)\n}\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\n\npublic class Main\n{\n    public static void main(String[] args) throws UnsupportedEncodingException\n    {\n        String encoded = \"http%3A%2F%2Ffoo%20bar%2F\";\n        String normal = URLDecoder.decode(encoded, \"utf-8\");\n        System.out.println(normal);\n    }\n}\n"}
{"id": 59311, "name": "URL decoding", "source": "Translate Swift to Python: import Foundation\n\nlet encoded = \"http%3A%2F%2Ffoo%20bar%2F\"\nif let normal = encoded.stringByReplacingPercentEscapesUsingEncoding(NSUTF8StringEncoding) {\n  println(normal)\n}\n", "target": "\nimport urllib\nprint urllib.unquote(\"http%3A%2F%2Ffoo%20bar%2F\")\n\nfrom urllib.parse import unquote\nprint(unquote('http%3A%2F%2Ffoo%20bar%2F'))\n"}
{"id": 59312, "name": "URL decoding", "source": "Translate Swift to Python: import Foundation\n\nlet encoded = \"http%3A%2F%2Ffoo%20bar%2F\"\nif let normal = encoded.stringByReplacingPercentEscapesUsingEncoding(NSUTF8StringEncoding) {\n  println(normal)\n}\n", "target": "\nimport urllib\nprint urllib.unquote(\"http%3A%2F%2Ffoo%20bar%2F\")\n\nfrom urllib.parse import unquote\nprint(unquote('http%3A%2F%2Ffoo%20bar%2F'))\n"}
{"id": 59548, "name": "Closest-pair problem", "source": "Translate Swift to C#: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n\n  func distance(to p: Point) -> Double {\n    let x = pow(p.x - self.x, 2)\n    let y = pow(p.y - self.y, 2)\n    \n    return (x + y).squareRoot()\n  }\n}\n\nextension Collection where Element == Point {\n  func closestPair() -> (Point, Point)? {\n    let (xP, xY) = (sorted(by: { $0.x < $1.x }), sorted(by: { $0.y < $1.y }))\n    \n    return Self.closestPair(xP, xY)?.1\n  }\n  \n  static func closestPair(_ xP: [Element], _ yP: [Element]) -> (Double, (Point, Point))? {\n    guard xP.count > 3 else { return xP.closestPairBruteForce() }\n    \n    let half = xP.count / 2\n    let xl = Array(xP[..<half])\n    let xr = Array(xP[half...])\n    let xm = xl.last!.x\n    let (yl, yr) = yP.reduce(into: ([Element](), [Element]()), {cur, el in\n      if el.x > xm {\n        cur.1.append(el)\n      } else {\n        cur.0.append(el)\n      }\n    })\n    \n    guard let (distanceL, pairL) = closestPair(xl, yl) else { return nil }\n    guard let (distanceR, pairR) = closestPair(xr, yr) else { return nil }\n    \n    let (dMin, pairMin) = distanceL > distanceR ? (distanceR, pairR) : (distanceL, pairL)\n    \n    let ys = yP.filter({ abs(xm - $0.x) < dMin })\n    \n    var (closest, pairClosest) = (dMin, pairMin)\n    \n    for i in 0..<ys.count {\n      let p1 = ys[i]\n      \n      for k in i+1..<ys.count {\n        let p2 = ys[k]\n        \n        guard abs(p2.y - p1.y) < dMin else { break }\n        \n        let distance = abs(p1.distance(to: p2))\n        \n        if distance < closest {\n          (closest, pairClosest) = (distance, (p1, p2))\n        }\n      }\n    }\n    \n    return (closest, pairClosest)\n  }\n  \n  func closestPairBruteForce() -> (Double, (Point, Point))? {\n    guard count >= 2 else { return nil }\n    \n    var closestPoints = (self.first!, self[index(after: startIndex)])\n    var minDistance = abs(closestPoints.0.distance(to: closestPoints.1))\n    \n    guard count != 2 else { return (minDistance, closestPoints) }\n    \n    for i in 0..<count {\n      for j in i+1..<count {\n        let (iIndex, jIndex) = (index(startIndex, offsetBy: i), index(startIndex, offsetBy: j))\n        let (p1, p2) = (self[iIndex], self[jIndex])\n        \n        let distance = abs(p1.distance(to: p2))\n        \n        if distance < minDistance {\n          minDistance = distance\n          closestPoints = (p1, p2)\n        }\n      }\n    }\n    \n    return (minDistance, closestPoints)\n  }\n}\n\nvar points = [Point]()\n\nfor _ in 0..<10_000 {\n  points.append(Point(\n    x: .random(in: -10.0...10.0),\n    y: .random(in: -10.0...10.0)\n  ))\n}\n\nprint(points.closestPair()!)\n", "target": "class Segment\n{\n    public Segment(PointF p1, PointF p2)\n    {\n        P1 = p1;\n        P2 = p2;\n    }\n\n    public readonly PointF P1;\n    public readonly PointF P2;\n\n    public float Length()\n    {\n        return (float)Math.Sqrt(LengthSquared());\n    }\n\n    public float LengthSquared()\n    {\n        return (P1.X - P2.X) * (P1.X - P2.X)\n            + (P1.Y - P2.Y) * (P1.Y - P2.Y);\n    }\n}\n"}
{"id": 59550, "name": "Closest-pair problem", "source": "Translate Swift to Java: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n\n  func distance(to p: Point) -> Double {\n    let x = pow(p.x - self.x, 2)\n    let y = pow(p.y - self.y, 2)\n    \n    return (x + y).squareRoot()\n  }\n}\n\nextension Collection where Element == Point {\n  func closestPair() -> (Point, Point)? {\n    let (xP, xY) = (sorted(by: { $0.x < $1.x }), sorted(by: { $0.y < $1.y }))\n    \n    return Self.closestPair(xP, xY)?.1\n  }\n  \n  static func closestPair(_ xP: [Element], _ yP: [Element]) -> (Double, (Point, Point))? {\n    guard xP.count > 3 else { return xP.closestPairBruteForce() }\n    \n    let half = xP.count / 2\n    let xl = Array(xP[..<half])\n    let xr = Array(xP[half...])\n    let xm = xl.last!.x\n    let (yl, yr) = yP.reduce(into: ([Element](), [Element]()), {cur, el in\n      if el.x > xm {\n        cur.1.append(el)\n      } else {\n        cur.0.append(el)\n      }\n    })\n    \n    guard let (distanceL, pairL) = closestPair(xl, yl) else { return nil }\n    guard let (distanceR, pairR) = closestPair(xr, yr) else { return nil }\n    \n    let (dMin, pairMin) = distanceL > distanceR ? (distanceR, pairR) : (distanceL, pairL)\n    \n    let ys = yP.filter({ abs(xm - $0.x) < dMin })\n    \n    var (closest, pairClosest) = (dMin, pairMin)\n    \n    for i in 0..<ys.count {\n      let p1 = ys[i]\n      \n      for k in i+1..<ys.count {\n        let p2 = ys[k]\n        \n        guard abs(p2.y - p1.y) < dMin else { break }\n        \n        let distance = abs(p1.distance(to: p2))\n        \n        if distance < closest {\n          (closest, pairClosest) = (distance, (p1, p2))\n        }\n      }\n    }\n    \n    return (closest, pairClosest)\n  }\n  \n  func closestPairBruteForce() -> (Double, (Point, Point))? {\n    guard count >= 2 else { return nil }\n    \n    var closestPoints = (self.first!, self[index(after: startIndex)])\n    var minDistance = abs(closestPoints.0.distance(to: closestPoints.1))\n    \n    guard count != 2 else { return (minDistance, closestPoints) }\n    \n    for i in 0..<count {\n      for j in i+1..<count {\n        let (iIndex, jIndex) = (index(startIndex, offsetBy: i), index(startIndex, offsetBy: j))\n        let (p1, p2) = (self[iIndex], self[jIndex])\n        \n        let distance = abs(p1.distance(to: p2))\n        \n        if distance < minDistance {\n          minDistance = distance\n          closestPoints = (p1, p2)\n        }\n      }\n    }\n    \n    return (minDistance, closestPoints)\n  }\n}\n\nvar points = [Point]()\n\nfor _ in 0..<10_000 {\n  points.append(Point(\n    x: .random(in: -10.0...10.0),\n    y: .random(in: -10.0...10.0)\n  ))\n}\n\nprint(points.closestPair()!)\n", "target": "import java.util.*;\n\npublic class ClosestPair\n{\n  public static class Point\n  {\n    public final double x;\n    public final double y;\n    \n    public Point(double x, double y)\n    {\n      this.x = x;\n      this.y = y;\n    }\n    \n    public String toString()\n    {  return \"(\" + x + \", \" + y + \")\";  }\n  }\n  \n  public static class Pair\n  {\n    public Point point1 = null;\n    public Point point2 = null;\n    public double distance = 0.0;\n    \n    public Pair()\n    {  }\n    \n    public Pair(Point point1, Point point2)\n    {\n      this.point1 = point1;\n      this.point2 = point2;\n      calcDistance();\n    }\n    \n    public void update(Point point1, Point point2, double distance)\n    {\n      this.point1 = point1;\n      this.point2 = point2;\n      this.distance = distance;\n    }\n    \n    public void calcDistance()\n    {  this.distance = distance(point1, point2);  }\n    \n    public String toString()\n    {  return point1 + \"-\" + point2 + \"\u00a0: \" + distance;  }\n  }\n  \n  public static double distance(Point p1, Point p2)\n  {\n    double xdist = p2.x - p1.x;\n    double ydist = p2.y - p1.y;\n    return Math.hypot(xdist, ydist);\n  }\n  \n  public static Pair bruteForce(List<? extends Point> points)\n  {\n    int numPoints = points.size();\n    if (numPoints < 2)\n      return null;\n    Pair pair = new Pair(points.get(0), points.get(1));\n    if (numPoints > 2)\n    {\n      for (int i = 0; i < numPoints - 1; i++)\n      {\n        Point point1 = points.get(i);\n        for (int j = i + 1; j < numPoints; j++)\n        {\n          Point point2 = points.get(j);\n          double distance = distance(point1, point2);\n          if (distance < pair.distance)\n            pair.update(point1, point2, distance);\n        }\n      }\n    }\n    return pair;\n  }\n  \n  public static void sortByX(List<? extends Point> points)\n  {\n    Collections.sort(points, new Comparator<Point>() {\n        public int compare(Point point1, Point point2)\n        {\n          if (point1.x < point2.x)\n            return -1;\n          if (point1.x > point2.x)\n            return 1;\n          return 0;\n        }\n      }\n    );\n  }\n  \n  public static void sortByY(List<? extends Point> points)\n  {\n    Collections.sort(points, new Comparator<Point>() {\n        public int compare(Point point1, Point point2)\n        {\n          if (point1.y < point2.y)\n            return -1;\n          if (point1.y > point2.y)\n            return 1;\n          return 0;\n        }\n      }\n    );\n  }\n  \n  public static Pair divideAndConquer(List<? extends Point> points)\n  {\n    List<Point> pointsSortedByX = new ArrayList<Point>(points);\n    sortByX(pointsSortedByX);\n    List<Point> pointsSortedByY = new ArrayList<Point>(points);\n    sortByY(pointsSortedByY);\n    return divideAndConquer(pointsSortedByX, pointsSortedByY);\n  }\n  \n  private static Pair divideAndConquer(List<? extends Point> pointsSortedByX, List<? extends Point> pointsSortedByY)\n  {\n    int numPoints = pointsSortedByX.size();\n    if (numPoints <= 3)\n      return bruteForce(pointsSortedByX);\n    \n    int dividingIndex = numPoints >>> 1;\n    List<? extends Point> leftOfCenter = pointsSortedByX.subList(0, dividingIndex);\n    List<? extends Point> rightOfCenter = pointsSortedByX.subList(dividingIndex, numPoints);\n    \n    List<Point> tempList = new ArrayList<Point>(leftOfCenter);\n    sortByY(tempList);\n    Pair closestPair = divideAndConquer(leftOfCenter, tempList);\n    \n    tempList.clear();\n    tempList.addAll(rightOfCenter);\n    sortByY(tempList);\n    Pair closestPairRight = divideAndConquer(rightOfCenter, tempList);\n    \n    if (closestPairRight.distance < closestPair.distance)\n      closestPair = closestPairRight;\n    \n    tempList.clear();\n    double shortestDistance =closestPair.distance;\n    double centerX = rightOfCenter.get(0).x;\n    for (Point point : pointsSortedByY)\n      if (Math.abs(centerX - point.x) < shortestDistance)\n        tempList.add(point);\n    \n    for (int i = 0; i < tempList.size() - 1; i++)\n    {\n      Point point1 = tempList.get(i);\n      for (int j = i + 1; j < tempList.size(); j++)\n      {\n        Point point2 = tempList.get(j);\n        if ((point2.y - point1.y) >= shortestDistance)\n          break;\n        double distance = distance(point1, point2);\n        if (distance < closestPair.distance)\n        {\n          closestPair.update(point1, point2, distance);\n          shortestDistance = distance;\n        }\n      }\n    }\n    return closestPair;\n  }\n  \n  public static void main(String[] args)\n  {\n    int numPoints = (args.length == 0) ? 1000 : Integer.parseInt(args[0]);\n    List<Point> points = new ArrayList<Point>();\n    Random r = new Random();\n    for (int i = 0; i < numPoints; i++)\n      points.add(new Point(r.nextDouble(), r.nextDouble()));\n    System.out.println(\"Generated \" + numPoints + \" random points\");\n    long startTime = System.currentTimeMillis();\n    Pair bruteForceClosestPair = bruteForce(points);\n    long elapsedTime = System.currentTimeMillis() - startTime;\n    System.out.println(\"Brute force (\" + elapsedTime + \" ms): \" + bruteForceClosestPair);\n    startTime = System.currentTimeMillis();\n    Pair dqClosestPair = divideAndConquer(points);\n    elapsedTime = System.currentTimeMillis() - startTime;\n    System.out.println(\"Divide and conquer (\" + elapsedTime + \" ms): \" + dqClosestPair);\n    if (bruteForceClosestPair.distance != dqClosestPair.distance)\n      System.out.println(\"MISMATCH\");\n  }\n}\n"}
{"id": 59551, "name": "Closest-pair problem", "source": "Translate Swift to Python: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n\n  func distance(to p: Point) -> Double {\n    let x = pow(p.x - self.x, 2)\n    let y = pow(p.y - self.y, 2)\n    \n    return (x + y).squareRoot()\n  }\n}\n\nextension Collection where Element == Point {\n  func closestPair() -> (Point, Point)? {\n    let (xP, xY) = (sorted(by: { $0.x < $1.x }), sorted(by: { $0.y < $1.y }))\n    \n    return Self.closestPair(xP, xY)?.1\n  }\n  \n  static func closestPair(_ xP: [Element], _ yP: [Element]) -> (Double, (Point, Point))? {\n    guard xP.count > 3 else { return xP.closestPairBruteForce() }\n    \n    let half = xP.count / 2\n    let xl = Array(xP[..<half])\n    let xr = Array(xP[half...])\n    let xm = xl.last!.x\n    let (yl, yr) = yP.reduce(into: ([Element](), [Element]()), {cur, el in\n      if el.x > xm {\n        cur.1.append(el)\n      } else {\n        cur.0.append(el)\n      }\n    })\n    \n    guard let (distanceL, pairL) = closestPair(xl, yl) else { return nil }\n    guard let (distanceR, pairR) = closestPair(xr, yr) else { return nil }\n    \n    let (dMin, pairMin) = distanceL > distanceR ? (distanceR, pairR) : (distanceL, pairL)\n    \n    let ys = yP.filter({ abs(xm - $0.x) < dMin })\n    \n    var (closest, pairClosest) = (dMin, pairMin)\n    \n    for i in 0..<ys.count {\n      let p1 = ys[i]\n      \n      for k in i+1..<ys.count {\n        let p2 = ys[k]\n        \n        guard abs(p2.y - p1.y) < dMin else { break }\n        \n        let distance = abs(p1.distance(to: p2))\n        \n        if distance < closest {\n          (closest, pairClosest) = (distance, (p1, p2))\n        }\n      }\n    }\n    \n    return (closest, pairClosest)\n  }\n  \n  func closestPairBruteForce() -> (Double, (Point, Point))? {\n    guard count >= 2 else { return nil }\n    \n    var closestPoints = (self.first!, self[index(after: startIndex)])\n    var minDistance = abs(closestPoints.0.distance(to: closestPoints.1))\n    \n    guard count != 2 else { return (minDistance, closestPoints) }\n    \n    for i in 0..<count {\n      for j in i+1..<count {\n        let (iIndex, jIndex) = (index(startIndex, offsetBy: i), index(startIndex, offsetBy: j))\n        let (p1, p2) = (self[iIndex], self[jIndex])\n        \n        let distance = abs(p1.distance(to: p2))\n        \n        if distance < minDistance {\n          minDistance = distance\n          closestPoints = (p1, p2)\n        }\n      }\n    }\n    \n    return (minDistance, closestPoints)\n  }\n}\n\nvar points = [Point]()\n\nfor _ in 0..<10_000 {\n  points.append(Point(\n    x: .random(in: -10.0...10.0),\n    y: .random(in: -10.0...10.0)\n  ))\n}\n\nprint(points.closestPair()!)\n", "target": "\n\nfrom random import randint, randrange\nfrom operator import itemgetter, attrgetter\n\ninfinity = float('inf')\n\n\n\ndef bruteForceClosestPair(point):\n    numPoints = len(point)\n    if numPoints < 2:\n        return infinity, (None, None)\n    return min( ((abs(point[i] - point[j]), (point[i], point[j]))\n                 for i in range(numPoints-1)\n                 for j in range(i+1,numPoints)),\n                key=itemgetter(0))\n\ndef closestPair(point):\n    xP = sorted(point, key= attrgetter('real'))\n    yP = sorted(point, key= attrgetter('imag'))\n    return _closestPair(xP, yP)\n\ndef _closestPair(xP, yP):\n    numPoints = len(xP)\n    if numPoints <= 3:\n        return bruteForceClosestPair(xP)\n    Pl = xP[:numPoints/2]\n    Pr = xP[numPoints/2:]\n    Yl, Yr = [], []\n    xDivider = Pl[-1].real\n    for p in yP:\n        if p.real <= xDivider:\n            Yl.append(p)\n        else:\n            Yr.append(p)\n    dl, pairl = _closestPair(Pl, Yl)\n    dr, pairr = _closestPair(Pr, Yr)\n    dm, pairm = (dl, pairl) if dl < dr else (dr, pairr)\n    \n    closeY = [p for p in yP  if abs(p.real - xDivider) < dm]\n    numCloseY = len(closeY)\n    if numCloseY > 1:\n        \n        closestY = min( ((abs(closeY[i] - closeY[j]), (closeY[i], closeY[j]))\n                         for i in range(numCloseY-1)\n                         for j in range(i+1,min(i+8, numCloseY))),\n                        key=itemgetter(0))\n        return (dm, pairm) if dm <= closestY[0] else closestY\n    else:\n        return dm, pairm\n    \ndef times():\n    \n    import timeit\n\n    functions = [bruteForceClosestPair, closestPair]\n    for f in functions:\n        print 'Time for', f.__name__, timeit.Timer(\n            '%s(pointList)' % f.__name__,\n            'from closestpair import %s, pointList' % f.__name__).timeit(number=1)\n    \n\n\npointList = [randint(0,1000)+1j*randint(0,1000) for i in range(2000)]\n\nif __name__ == '__main__':\n    pointList = [(5+9j), (9+3j), (2+0j), (8+4j), (7+4j), (9+10j), (1+9j), (8+2j), 10j, (9+6j)]\n    print pointList\n    print '  bruteForceClosestPair:', bruteForceClosestPair(pointList)\n    print '            closestPair:', closestPair(pointList)\n    for i in range(10):\n        pointList = [randrange(11)+1j*randrange(11) for i in range(10)]\n        print '\\n', pointList\n        print ' bruteForceClosestPair:', bruteForceClosestPair(pointList)\n        print '           closestPair:', closestPair(pointList)\n    print '\\n'\n    times()\n    times()\n    times()\n"}
{"id": 59974, "name": "99 bottles of beer", "source": "Translate Swift to C#: for i in (1...99).reversed() {\n\tprint(\"\\(i) bottles of beer on the wall, \\(i) bottles of beer.\")\n\tlet next = i == 1 ? \"no\" : (i-1).description\n\tprint(\"Take one down and pass it around, \\(next) bottles of beer on the wall.\")\n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 99; i > -1; i--)\n        {\n            if (i == 0)\n            {\n                Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\");\n                Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n                break;\n            }\n            if (i == 1)\n            {\n                Console.WriteLine(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n                Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"{0} bottles of beer on the wall, {0} bottles of beer.\", i);\n                Console.WriteLine(\"Take one down and pass it around, {0} bottles of beer on the wall.\", i - 1);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 59975, "name": "99 bottles of beer", "source": "Translate Swift to C#: for i in (1...99).reversed() {\n\tprint(\"\\(i) bottles of beer on the wall, \\(i) bottles of beer.\")\n\tlet next = i == 1 ? \"no\" : (i-1).description\n\tprint(\"Take one down and pass it around, \\(next) bottles of beer on the wall.\")\n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 99; i > -1; i--)\n        {\n            if (i == 0)\n            {\n                Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\");\n                Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n                break;\n            }\n            if (i == 1)\n            {\n                Console.WriteLine(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n                Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"{0} bottles of beer on the wall, {0} bottles of beer.\", i);\n                Console.WriteLine(\"Take one down and pass it around, {0} bottles of beer on the wall.\", i - 1);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 59978, "name": "99 bottles of beer", "source": "Translate Swift to Java: for i in (1...99).reversed() {\n\tprint(\"\\(i) bottles of beer on the wall, \\(i) bottles of beer.\")\n\tlet next = i == 1 ? \"no\" : (i-1).description\n\tprint(\"Take one down and pass it around, \\(next) bottles of beer on the wall.\")\n}\n", "target": "module Bottles\n    {\n    @Inject Console console;\n    void run()\n        {\n        function String(Int) num     = i -> i==0 ? \"No\" : i.toString();\n        function String(Int) bottles = i -> i==1 ? \"bottle\" : \"bottles\";\n\n        for (Int remain : 99..1)\n            {\n            console.print($|{num(remain)} {bottles(remain)} of beer on the wall\n                           |{num(remain)} {bottles(remain)} of beer\n                           |Take one down, pass it around\n                           |{num(remain-1)} {bottles(remain-1)} of beer on the wall\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 59979, "name": "99 bottles of beer", "source": "Translate Swift to Java: for i in (1...99).reversed() {\n\tprint(\"\\(i) bottles of beer on the wall, \\(i) bottles of beer.\")\n\tlet next = i == 1 ? \"no\" : (i-1).description\n\tprint(\"Take one down and pass it around, \\(next) bottles of beer on the wall.\")\n}\n", "target": "module Bottles\n    {\n    @Inject Console console;\n    void run()\n        {\n        function String(Int) num     = i -> i==0 ? \"No\" : i.toString();\n        function String(Int) bottles = i -> i==1 ? \"bottle\" : \"bottles\";\n\n        for (Int remain : 99..1)\n            {\n            console.print($|{num(remain)} {bottles(remain)} of beer on the wall\n                           |{num(remain)} {bottles(remain)} of beer\n                           |Take one down, pass it around\n                           |{num(remain-1)} {bottles(remain-1)} of beer on the wall\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 59980, "name": "99 bottles of beer", "source": "Translate Swift to Python: for i in (1...99).reversed() {\n\tprint(\"\\(i) bottles of beer on the wall, \\(i) bottles of beer.\")\n\tlet next = i == 1 ? \"no\" : (i-1).description\n\tprint(\"Take one down and pass it around, \\(next) bottles of beer on the wall.\")\n}\n", "target": "fun bottles(n): match __args__:\n    (0) => \"No more bottles\"\n    (1) => \"1 bottle\"\n    (_) => \"$n bottles\"\n\nfor n in 99..-1..1:\n    print @format\n"}
{"id": 59981, "name": "99 bottles of beer", "source": "Translate Swift to Python: for i in (1...99).reversed() {\n\tprint(\"\\(i) bottles of beer on the wall, \\(i) bottles of beer.\")\n\tlet next = i == 1 ? \"no\" : (i-1).description\n\tprint(\"Take one down and pass it around, \\(next) bottles of beer on the wall.\")\n}\n", "target": "fun bottles(n): match __args__:\n    (0) => \"No more bottles\"\n    (1) => \"1 bottle\"\n    (_) => \"$n bottles\"\n\nfor n in 99..-1..1:\n    print @format\n"}
{"id": 60250, "name": "Concurrent computing", "source": "Translate Swift to C#: import Foundation\n\nlet myList = [\"Enjoy\", \"Rosetta\", \"Code\"]\n\nfor word in myList {\n    dispatch_async(dispatch_get_global_queue(0, 0)) {\n        NSLog(word)\n    }\n}\n\ndispatch_main()\n", "target": "static Random tRand = new Random();\n\nstatic void Main(string[] args)\n{\n\tThread t = new Thread(new ParameterizedThreadStart(WriteText));\n\tt.Start(\"Enjoy\");\n\n\tt = new Thread(new ParameterizedThreadStart(WriteText));\n\tt.Start(\"Rosetta\");\n\n\tt = new Thread(new ParameterizedThreadStart(WriteText));\n\tt.Start(\"Code\");\n\n\tConsole.ReadLine();\n}\n\nprivate static void WriteText(object p)\n{\n\tThread.Sleep(tRand.Next(1000, 4000));\n\tConsole.WriteLine(p);\n}\n"}
{"id": 60252, "name": "Concurrent computing", "source": "Translate Swift to Java: import Foundation\n\nlet myList = [\"Enjoy\", \"Rosetta\", \"Code\"]\n\nfor word in myList {\n    dispatch_async(dispatch_get_global_queue(0, 0)) {\n        NSLog(word)\n    }\n}\n\ndispatch_main()\n", "target": "import java.util.concurrent.CyclicBarrier;\n\npublic class Threads\n{\n  public static class DelayedMessagePrinter implements Runnable\n  {\n    private CyclicBarrier barrier;\n    private String msg;\n    \n    public DelayedMessagePrinter(CyclicBarrier barrier, String msg)\n    {\n      this.barrier = barrier;\n      this.msg = msg;\n    }\n    \n    public void run()\n    {\n      try\n      {  barrier.await();  }\n      catch (Exception e)\n      {  }\n      System.out.println(msg);\n    }\n  }\n  \n  public static void main(String[] args)\n  {\n    CyclicBarrier barrier = new CyclicBarrier(3);\n    new Thread(new DelayedMessagePrinter(barrier, \"Enjoy\")).start();\n    new Thread(new DelayedMessagePrinter(barrier, \"Rosetta\")).start();\n    new Thread(new DelayedMessagePrinter(barrier, \"Code\")).start();\n  }\n}\n"}
{"id": 60253, "name": "Concurrent computing", "source": "Translate Swift to Python: import Foundation\n\nlet myList = [\"Enjoy\", \"Rosetta\", \"Code\"]\n\nfor word in myList {\n    dispatch_async(dispatch_get_global_queue(0, 0)) {\n        NSLog(word)\n    }\n}\n\ndispatch_main()\n", "target": "let words = [\"Enjoy\", \"Rosetta\", \"Code\"]\n\nfor word in words:\n    (word) |> async (w) =>\n        sleep(random())\n        print(w)\n"}
{"id": 60480, "name": "Strip a set of characters from a string", "source": "Translate Swift to C#: extension String {\n  func stripCharactersInSet(chars: [Character]) -> String {\n    return String(seq: filter(self) {find(chars, $0) == nil})\n  }\n}\n\nlet aString = \"She was a soul stripper. She took my heart!\"\nlet chars: [Character] = [\"a\", \"e\", \"i\"]\n\nprintln(aString.stripCharactersInSet(chars))\n", "target": "using System;\n\npublic static string RemoveCharactersFromString(string testString, string removeChars)\n{\n    char[] charAry = removeChars.ToCharArray();\n    string returnString = testString;\n    foreach (char c in charAry)\n    {\n        while (returnString.IndexOf(c) > -1)\n        {\n            returnString = returnString.Remove(returnString.IndexOf(c), 1);\n        }\n    }\n    return returnString;\n}\n"}
{"id": 60482, "name": "Strip a set of characters from a string", "source": "Translate Swift to Java: extension String {\n  func stripCharactersInSet(chars: [Character]) -> String {\n    return String(seq: filter(self) {find(chars, $0) == nil})\n  }\n}\n\nlet aString = \"She was a soul stripper. She took my heart!\"\nlet chars: [Character] = [\"a\", \"e\", \"i\"]\n\nprintln(aString.stripCharactersInSet(chars))\n", "target": "class StripChars {\n    public static String stripChars(String inString, String toStrip) {\n        return inString.replaceAll(\"[\" + toStrip + \"]\", \"\");\n    }\n\n    public static void main(String[] args) {\n        String sentence = \"She was a soul stripper. She took my heart!\";\n        String chars = \"aei\";\n        System.out.println(\"sentence: \" + sentence);\n        System.out.println(\"to strip: \" + chars);\n        System.out.println(\"stripped: \" + stripChars(sentence, chars));\n    }\n}\n"}
{"id": 60483, "name": "Strip a set of characters from a string", "source": "Translate Swift to Python: extension String {\n  func stripCharactersInSet(chars: [Character]) -> String {\n    return String(seq: filter(self) {find(chars, $0) == nil})\n  }\n}\n\nlet aString = \"She was a soul stripper. She took my heart!\"\nlet chars: [Character] = [\"a\", \"e\", \"i\"]\n\nprintln(aString.stripCharactersInSet(chars))\n", "target": ">>> def stripchars(s, chars):\n...     return s.translate(None, chars)\n... \n>>> stripchars(\"She was a soul stripper. She took my heart!\", \"aei\")\n'Sh ws  soul strppr. Sh took my hrt!'\n"}
{"id": 60855, "name": "Isqrt (integer square root) of X", "source": "Translate Swift to C#: import BigInt\n\nfunc integerSquareRoot<T: BinaryInteger>(_ num: T) -> T {\n    var x: T = num\n    var q: T = 1\n    while q <= x {\n        q <<= 2\n    }\n    var r: T = 0\n    while q > 1 {\n        q >>= 2\n        let t: T = x - r - q\n        r >>= 1\n        if t >= 0 {\n            x = t\n            r += q\n        }\n    }\n    return r\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize<T: BinaryInteger>(_ num: T) -> String {\n    let string = String(num)\n    var result = String()\n    result.reserveCapacity(4 * string.count / 3)\n    var i = 0\n    for ch in string {\n        if i > 0 && i % 3 == string.count % 3 {\n            result += \",\"\n        }\n        result.append(ch)\n        i += 1\n    }\n    return result\n}\n\nprint(\"Integer square root for numbers 0 to 65:\")\nfor n in 0...65 {\n    print(integerSquareRoot(n), terminator: \" \")\n}\n\nlet powerWidth = 83\nlet isqrtWidth = 42\nprint(\"\\n\\nInteger square roots of odd powers of 7 from 1 to 73:\")\nprint(\" n |\\(pad(string: \"7 ^ n\", width: powerWidth)) |\\(pad(string: \"isqrt(7 ^ n)\", width: isqrtWidth))\")\nprint(String(repeating: \"-\", count: powerWidth + isqrtWidth + 6))\nvar p: BigInt = 7\nfor n in stride(from: 1, through: 73, by: 2) {\n    let power = pad(string: commatize(p), width: powerWidth)\n    let isqrt = pad(string: commatize(integerSquareRoot(p)), width: isqrtWidth)\n    print(\"\\(pad(string: String(n), width: 2)) |\\(power) |\\(isqrt)\")\n    p *= 49\n}\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\u00a0\nclass Program {\n\u00a0\n    static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n        q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\u00a0\n    static void Main() { const int max = 73, smax = 65;\n        int power_width = ((BI.Pow(7, max).ToString().Length / 3) << 2) + 3,\n            isqrt_width = (power_width + 1) >> 1;\n        WriteLine(\"Integer square root for numbers 0 to {0}:\", smax);\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", \n            (n / 10).ToString().Replace(\"0\", \" \")); WriteLine();\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", n % 10); WriteLine();\n        WriteLine(new String('-', (smax << 1) + 1));\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", isqrt(n));\n        WriteLine(\"\\n\\nInteger square roots of odd powers of 7 from 1 to {0}:\", max);\n        string s = string.Format(\"[0,2] |[1,{0}:n0] |[2,{1}:n0]\",\n            power_width, isqrt_width).Replace(\"[\", \"{\").Replace(\"]\", \"}\");\n        WriteLine(s, \"n\", \"7 ^ n\", \"isqrt(7 ^ n)\");\n        WriteLine(new String('-', power_width + isqrt_width + 6));\n        BI p = 7; for (int n = 1; n <= max; n += 2, p *= 49)\n            WriteLine (s, n, p, isqrt(p)); }\n}\n"}
{"id": 60856, "name": "Isqrt (integer square root) of X", "source": "Translate Swift to C#: import BigInt\n\nfunc integerSquareRoot<T: BinaryInteger>(_ num: T) -> T {\n    var x: T = num\n    var q: T = 1\n    while q <= x {\n        q <<= 2\n    }\n    var r: T = 0\n    while q > 1 {\n        q >>= 2\n        let t: T = x - r - q\n        r >>= 1\n        if t >= 0 {\n            x = t\n            r += q\n        }\n    }\n    return r\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize<T: BinaryInteger>(_ num: T) -> String {\n    let string = String(num)\n    var result = String()\n    result.reserveCapacity(4 * string.count / 3)\n    var i = 0\n    for ch in string {\n        if i > 0 && i % 3 == string.count % 3 {\n            result += \",\"\n        }\n        result.append(ch)\n        i += 1\n    }\n    return result\n}\n\nprint(\"Integer square root for numbers 0 to 65:\")\nfor n in 0...65 {\n    print(integerSquareRoot(n), terminator: \" \")\n}\n\nlet powerWidth = 83\nlet isqrtWidth = 42\nprint(\"\\n\\nInteger square roots of odd powers of 7 from 1 to 73:\")\nprint(\" n |\\(pad(string: \"7 ^ n\", width: powerWidth)) |\\(pad(string: \"isqrt(7 ^ n)\", width: isqrtWidth))\")\nprint(String(repeating: \"-\", count: powerWidth + isqrtWidth + 6))\nvar p: BigInt = 7\nfor n in stride(from: 1, through: 73, by: 2) {\n    let power = pad(string: commatize(p), width: powerWidth)\n    let isqrt = pad(string: commatize(integerSquareRoot(p)), width: isqrtWidth)\n    print(\"\\(pad(string: String(n), width: 2)) |\\(power) |\\(isqrt)\")\n    p *= 49\n}\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\u00a0\nclass Program {\n\u00a0\n    static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n        q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\u00a0\n    static void Main() { const int max = 73, smax = 65;\n        int power_width = ((BI.Pow(7, max).ToString().Length / 3) << 2) + 3,\n            isqrt_width = (power_width + 1) >> 1;\n        WriteLine(\"Integer square root for numbers 0 to {0}:\", smax);\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", \n            (n / 10).ToString().Replace(\"0\", \" \")); WriteLine();\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", n % 10); WriteLine();\n        WriteLine(new String('-', (smax << 1) + 1));\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", isqrt(n));\n        WriteLine(\"\\n\\nInteger square roots of odd powers of 7 from 1 to {0}:\", max);\n        string s = string.Format(\"[0,2] |[1,{0}:n0] |[2,{1}:n0]\",\n            power_width, isqrt_width).Replace(\"[\", \"{\").Replace(\"]\", \"}\");\n        WriteLine(s, \"n\", \"7 ^ n\", \"isqrt(7 ^ n)\");\n        WriteLine(new String('-', power_width + isqrt_width + 6));\n        BI p = 7; for (int n = 1; n <= max; n += 2, p *= 49)\n            WriteLine (s, n, p, isqrt(p)); }\n}\n"}
{"id": 60859, "name": "Isqrt (integer square root) of X", "source": "Translate Swift to Java: import BigInt\n\nfunc integerSquareRoot<T: BinaryInteger>(_ num: T) -> T {\n    var x: T = num\n    var q: T = 1\n    while q <= x {\n        q <<= 2\n    }\n    var r: T = 0\n    while q > 1 {\n        q >>= 2\n        let t: T = x - r - q\n        r >>= 1\n        if t >= 0 {\n            x = t\n            r += q\n        }\n    }\n    return r\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize<T: BinaryInteger>(_ num: T) -> String {\n    let string = String(num)\n    var result = String()\n    result.reserveCapacity(4 * string.count / 3)\n    var i = 0\n    for ch in string {\n        if i > 0 && i % 3 == string.count % 3 {\n            result += \",\"\n        }\n        result.append(ch)\n        i += 1\n    }\n    return result\n}\n\nprint(\"Integer square root for numbers 0 to 65:\")\nfor n in 0...65 {\n    print(integerSquareRoot(n), terminator: \" \")\n}\n\nlet powerWidth = 83\nlet isqrtWidth = 42\nprint(\"\\n\\nInteger square roots of odd powers of 7 from 1 to 73:\")\nprint(\" n |\\(pad(string: \"7 ^ n\", width: powerWidth)) |\\(pad(string: \"isqrt(7 ^ n)\", width: isqrtWidth))\")\nprint(String(repeating: \"-\", count: powerWidth + isqrtWidth + 6))\nvar p: BigInt = 7\nfor n in stride(from: 1, through: 73, by: 2) {\n    let power = pad(string: commatize(p), width: powerWidth)\n    let isqrt = pad(string: commatize(integerSquareRoot(p)), width: isqrtWidth)\n    print(\"\\(pad(string: String(n), width: 2)) |\\(power) |\\(isqrt)\")\n    p *= 49\n}\n", "target": "import java.math.BigInteger;\n\npublic class Isqrt {\n    private static BigInteger isqrt(BigInteger x) {\n        if (x.compareTo(BigInteger.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Argument cannot be negative\");\n        }\n        var q = BigInteger.ONE;\n        while (q.compareTo(x) <= 0) {\n            q = q.shiftLeft(2);\n        }\n        var z = x;\n        var r = BigInteger.ZERO;\n        while (q.compareTo(BigInteger.ONE) > 0) {\n            q = q.shiftRight(2);\n            var t = z;\n            t = t.subtract(r);\n            t = t.subtract(q);\n            r = r.shiftRight(1);\n            if (t.compareTo(BigInteger.ZERO) >= 0) {\n                z = t;\n                r = r.add(q);\n            }\n        }\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The integer square root of integers from 0 to 65 are:\");\n        for (int i = 0; i <= 65; i++) {\n            System.out.printf(\"%s \", isqrt(BigInteger.valueOf(i)));\n        }\n        System.out.println();\n\n        System.out.println(\"The integer square roots of powers of 7 from 7^1 up to 7^73 are:\");\n        System.out.println(\"power                                    7 ^ power                                                 integer square root\");\n        System.out.println(\"----- --------------------------------------------------------------------------------- -----------------------------------------\");\n        var pow7 = BigInteger.valueOf(7);\n        var bi49 = BigInteger.valueOf(49);\n        for (int i = 1; i < 74; i += 2) {\n            System.out.printf(\"%2d\u00a0%,84d\u00a0%,41d\\n\", i, pow7, isqrt(pow7));\n            pow7 = pow7.multiply(bi49);\n        }\n    }\n}\n"}
{"id": 60860, "name": "Isqrt (integer square root) of X", "source": "Translate Swift to Java: import BigInt\n\nfunc integerSquareRoot<T: BinaryInteger>(_ num: T) -> T {\n    var x: T = num\n    var q: T = 1\n    while q <= x {\n        q <<= 2\n    }\n    var r: T = 0\n    while q > 1 {\n        q >>= 2\n        let t: T = x - r - q\n        r >>= 1\n        if t >= 0 {\n            x = t\n            r += q\n        }\n    }\n    return r\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize<T: BinaryInteger>(_ num: T) -> String {\n    let string = String(num)\n    var result = String()\n    result.reserveCapacity(4 * string.count / 3)\n    var i = 0\n    for ch in string {\n        if i > 0 && i % 3 == string.count % 3 {\n            result += \",\"\n        }\n        result.append(ch)\n        i += 1\n    }\n    return result\n}\n\nprint(\"Integer square root for numbers 0 to 65:\")\nfor n in 0...65 {\n    print(integerSquareRoot(n), terminator: \" \")\n}\n\nlet powerWidth = 83\nlet isqrtWidth = 42\nprint(\"\\n\\nInteger square roots of odd powers of 7 from 1 to 73:\")\nprint(\" n |\\(pad(string: \"7 ^ n\", width: powerWidth)) |\\(pad(string: \"isqrt(7 ^ n)\", width: isqrtWidth))\")\nprint(String(repeating: \"-\", count: powerWidth + isqrtWidth + 6))\nvar p: BigInt = 7\nfor n in stride(from: 1, through: 73, by: 2) {\n    let power = pad(string: commatize(p), width: powerWidth)\n    let isqrt = pad(string: commatize(integerSquareRoot(p)), width: isqrtWidth)\n    print(\"\\(pad(string: String(n), width: 2)) |\\(power) |\\(isqrt)\")\n    p *= 49\n}\n", "target": "import java.math.BigInteger;\n\npublic class Isqrt {\n    private static BigInteger isqrt(BigInteger x) {\n        if (x.compareTo(BigInteger.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Argument cannot be negative\");\n        }\n        var q = BigInteger.ONE;\n        while (q.compareTo(x) <= 0) {\n            q = q.shiftLeft(2);\n        }\n        var z = x;\n        var r = BigInteger.ZERO;\n        while (q.compareTo(BigInteger.ONE) > 0) {\n            q = q.shiftRight(2);\n            var t = z;\n            t = t.subtract(r);\n            t = t.subtract(q);\n            r = r.shiftRight(1);\n            if (t.compareTo(BigInteger.ZERO) >= 0) {\n                z = t;\n                r = r.add(q);\n            }\n        }\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The integer square root of integers from 0 to 65 are:\");\n        for (int i = 0; i <= 65; i++) {\n            System.out.printf(\"%s \", isqrt(BigInteger.valueOf(i)));\n        }\n        System.out.println();\n\n        System.out.println(\"The integer square roots of powers of 7 from 7^1 up to 7^73 are:\");\n        System.out.println(\"power                                    7 ^ power                                                 integer square root\");\n        System.out.println(\"----- --------------------------------------------------------------------------------- -----------------------------------------\");\n        var pow7 = BigInteger.valueOf(7);\n        var bi49 = BigInteger.valueOf(49);\n        for (int i = 1; i < 74; i += 2) {\n            System.out.printf(\"%2d\u00a0%,84d\u00a0%,41d\\n\", i, pow7, isqrt(pow7));\n            pow7 = pow7.multiply(bi49);\n        }\n    }\n}\n"}
{"id": 60861, "name": "Isqrt (integer square root) of X", "source": "Translate Swift to Python: import BigInt\n\nfunc integerSquareRoot<T: BinaryInteger>(_ num: T) -> T {\n    var x: T = num\n    var q: T = 1\n    while q <= x {\n        q <<= 2\n    }\n    var r: T = 0\n    while q > 1 {\n        q >>= 2\n        let t: T = x - r - q\n        r >>= 1\n        if t >= 0 {\n            x = t\n            r += q\n        }\n    }\n    return r\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize<T: BinaryInteger>(_ num: T) -> String {\n    let string = String(num)\n    var result = String()\n    result.reserveCapacity(4 * string.count / 3)\n    var i = 0\n    for ch in string {\n        if i > 0 && i % 3 == string.count % 3 {\n            result += \",\"\n        }\n        result.append(ch)\n        i += 1\n    }\n    return result\n}\n\nprint(\"Integer square root for numbers 0 to 65:\")\nfor n in 0...65 {\n    print(integerSquareRoot(n), terminator: \" \")\n}\n\nlet powerWidth = 83\nlet isqrtWidth = 42\nprint(\"\\n\\nInteger square roots of odd powers of 7 from 1 to 73:\")\nprint(\" n |\\(pad(string: \"7 ^ n\", width: powerWidth)) |\\(pad(string: \"isqrt(7 ^ n)\", width: isqrtWidth))\")\nprint(String(repeating: \"-\", count: powerWidth + isqrtWidth + 6))\nvar p: BigInt = 7\nfor n in stride(from: 1, through: 73, by: 2) {\n    let power = pad(string: commatize(p), width: powerWidth)\n    let isqrt = pad(string: commatize(integerSquareRoot(p)), width: isqrtWidth)\n    print(\"\\(pad(string: String(n), width: 2)) |\\(power) |\\(isqrt)\")\n    p *= 49\n}\n", "target": "def isqrt ( x ):\n    q = 1\n    while q <= x : \n        q *= 4\n    z,r = x,0\n    while q > 1 :\n        q  /= 4\n        t,r = z-r-q,r/2\n        if t >= 0 :\n            z,r = t,r+q\n    return r \n\nprint ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))\nprint '\\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))\n"}
{"id": 60862, "name": "Isqrt (integer square root) of X", "source": "Translate Swift to Python: import BigInt\n\nfunc integerSquareRoot<T: BinaryInteger>(_ num: T) -> T {\n    var x: T = num\n    var q: T = 1\n    while q <= x {\n        q <<= 2\n    }\n    var r: T = 0\n    while q > 1 {\n        q >>= 2\n        let t: T = x - r - q\n        r >>= 1\n        if t >= 0 {\n            x = t\n            r += q\n        }\n    }\n    return r\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize<T: BinaryInteger>(_ num: T) -> String {\n    let string = String(num)\n    var result = String()\n    result.reserveCapacity(4 * string.count / 3)\n    var i = 0\n    for ch in string {\n        if i > 0 && i % 3 == string.count % 3 {\n            result += \",\"\n        }\n        result.append(ch)\n        i += 1\n    }\n    return result\n}\n\nprint(\"Integer square root for numbers 0 to 65:\")\nfor n in 0...65 {\n    print(integerSquareRoot(n), terminator: \" \")\n}\n\nlet powerWidth = 83\nlet isqrtWidth = 42\nprint(\"\\n\\nInteger square roots of odd powers of 7 from 1 to 73:\")\nprint(\" n |\\(pad(string: \"7 ^ n\", width: powerWidth)) |\\(pad(string: \"isqrt(7 ^ n)\", width: isqrtWidth))\")\nprint(String(repeating: \"-\", count: powerWidth + isqrtWidth + 6))\nvar p: BigInt = 7\nfor n in stride(from: 1, through: 73, by: 2) {\n    let power = pad(string: commatize(p), width: powerWidth)\n    let isqrt = pad(string: commatize(integerSquareRoot(p)), width: isqrtWidth)\n    print(\"\\(pad(string: String(n), width: 2)) |\\(power) |\\(isqrt)\")\n    p *= 49\n}\n", "target": "def isqrt ( x ):\n    q = 1\n    while q <= x : \n        q *= 4\n    z,r = x,0\n    while q > 1 :\n        q  /= 4\n        t,r = z-r-q,r/2\n        if t >= 0 :\n            z,r = t,r+q\n    return r \n\nprint ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))\nprint '\\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))\n"}
{"id": 61175, "name": "Jewels and stones", "source": "Translate Swift to C#: func countJewels(_ stones: String, _ jewels: String) -> Int {\n  return stones.map({ jewels.contains($0) ? 1 : 0 }).reduce(0, +)\n}\n\nprint(countJewels(\"aAAbbbb\", \"aA\"))\nprint(countJewels(\"ZZ\", \"z\"))\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(Count(\"aAAbbbb\", \"Aa\"));\n        Console.WriteLine(Count(\"ZZ\", \"z\"));\n    }\n\n    private static int Count(string stones, string jewels) {\n        var bag = jewels.ToHashSet();\n        return stones.Count(bag.Contains);\n    }\n}\n"}
{"id": 61176, "name": "Jewels and stones", "source": "Translate Swift to C#: func countJewels(_ stones: String, _ jewels: String) -> Int {\n  return stones.map({ jewels.contains($0) ? 1 : 0 }).reduce(0, +)\n}\n\nprint(countJewels(\"aAAbbbb\", \"aA\"))\nprint(countJewels(\"ZZ\", \"z\"))\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(Count(\"aAAbbbb\", \"Aa\"));\n        Console.WriteLine(Count(\"ZZ\", \"z\"));\n    }\n\n    private static int Count(string stones, string jewels) {\n        var bag = jewels.ToHashSet();\n        return stones.Count(bag.Contains);\n    }\n}\n"}
{"id": 61179, "name": "Jewels and stones", "source": "Translate Swift to Java: func countJewels(_ stones: String, _ jewels: String) -> Int {\n  return stones.map({ jewels.contains($0) ? 1 : 0 }).reduce(0, +)\n}\n\nprint(countJewels(\"aAAbbbb\", \"aA\"))\nprint(countJewels(\"ZZ\", \"z\"))\n", "target": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class App {\n    private static int countJewels(String stones, String jewels) {\n        Set<Character> bag = new HashSet<>();\n        for (char c : jewels.toCharArray()) {\n            bag.add(c);\n        }\n\n        int count = 0;\n        for (char c : stones.toCharArray()) {\n            if (bag.contains(c)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(countJewels(\"aAAbbbb\", \"aA\"));\n        System.out.println(countJewels(\"ZZ\", \"z\"));\n    }\n}\n"}
{"id": 61180, "name": "Jewels and stones", "source": "Translate Swift to Java: func countJewels(_ stones: String, _ jewels: String) -> Int {\n  return stones.map({ jewels.contains($0) ? 1 : 0 }).reduce(0, +)\n}\n\nprint(countJewels(\"aAAbbbb\", \"aA\"))\nprint(countJewels(\"ZZ\", \"z\"))\n", "target": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class App {\n    private static int countJewels(String stones, String jewels) {\n        Set<Character> bag = new HashSet<>();\n        for (char c : jewels.toCharArray()) {\n            bag.add(c);\n        }\n\n        int count = 0;\n        for (char c : stones.toCharArray()) {\n            if (bag.contains(c)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(countJewels(\"aAAbbbb\", \"aA\"));\n        System.out.println(countJewels(\"ZZ\", \"z\"));\n    }\n}\n"}
{"id": 61181, "name": "Jewels and stones", "source": "Translate Swift to Python: func countJewels(_ stones: String, _ jewels: String) -> Int {\n  return stones.map({ jewels.contains($0) ? 1 : 0 }).reduce(0, +)\n}\n\nprint(countJewels(\"aAAbbbb\", \"aA\"))\nprint(countJewels(\"ZZ\", \"z\"))\n", "target": "def countJewels(s, j):\n    return sum(x in j for x in s)\n\nprint countJewels(\"aAAbbbb\", \"aA\")\nprint countJewels(\"ZZ\", \"z\")\n"}
{"id": 61182, "name": "Jewels and stones", "source": "Translate Swift to Python: func countJewels(_ stones: String, _ jewels: String) -> Int {\n  return stones.map({ jewels.contains($0) ? 1 : 0 }).reduce(0, +)\n}\n\nprint(countJewels(\"aAAbbbb\", \"aA\"))\nprint(countJewels(\"ZZ\", \"z\"))\n", "target": "def countJewels(s, j):\n    return sum(x in j for x in s)\n\nprint countJewels(\"aAAbbbb\", \"aA\")\nprint countJewels(\"ZZ\", \"z\")\n"}
{"id": 61440, "name": "Factorial", "source": "Translate Swift to C#: func factorial(_ n: Int) -> Int {\n\treturn n < 2 ? 1 : (2...n).reduce(1, *)\n}\n", "target": "using System;\n\nclass Program\n{\n    static int Factorial(int number)\n    {\n        if(number < 0) \n            throw new ArgumentOutOfRangeException(nameof(number), number, \"Must be zero or a positive number.\");\n\n        var accumulator = 1;\n        for (var factor = 1; factor <= number; factor++)\n        {\n            accumulator *= factor;\n        }\n        return accumulator;\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Factorial(10));\n    }\n}\n"}
{"id": 61442, "name": "Factorial", "source": "Translate Swift to Java: func factorial(_ n: Int) -> Int {\n\treturn n < 2 ? 1 : (2...n).reduce(1, *)\n}\n", "target": "module ShowFactorials\n    {\n    static <Value extends IntNumber> Value factorial(Value n)\n        {\n        assert:arg n >= Value.zero();\n        return n <= Value.one() ? n : n * factorial(n-Value.one());\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        \n        UInt128 bigNum = 34;\n        console.print($\"factorial({bigNum})={factorial(bigNum)}\");\n\n        \n        for (Int i : 10..-1)\n            {\n            console.print($\"factorial({i})={factorial(i)}\");\n            }\n        }\n    }\n"}
{"id": 61443, "name": "Factorial", "source": "Translate Swift to Python: func factorial(_ n: Int) -> Int {\n\treturn n < 2 ? 1 : (2...n).reduce(1, *)\n}\n", "target": "import math\nmath.factorial(n)\n"}
{"id": 61648, "name": "Polynomial regression", "source": "Translate Swift to C#: let x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nlet y = [1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321]\n\nfunc average(_ input: [Int]) -> Int {\n    return input.reduce(0, +) / input.count\n}\n\nfunc polyRegression(x: [Int], y: [Int]) {\n    let xm = average(x)\n    let ym = average(y)\n    let x2m = average(x.map { $0 * $0 })\n    let x3m = average(x.map { $0 * $0 * $0 })\n    let x4m = average(x.map { $0 * $0 * $0 * $0 })\n    let xym = average(zip(x,y).map { $0 * $1 })\n    let x2ym = average(zip(x,y).map { $0 * $0 * $1 })\n\n    let sxx = x2m - xm * xm\n    let sxy = xym - xm * ym\n    let sxx2 = x3m - xm * x2m\n    let sx2x2 = x4m - x2m * x2m\n    let sx2y = x2ym - x2m * ym\n \n    let b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)\n    let c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)\n    let a = ym - b * xm - c * x2m\n\n    func abc(xx: Int) -> Int {\n        return (a + b * xx) + (c * xx * xx)\n    }\n    \n    print(\"y = \\(a) + \\(b)x + \\(c)x^2\\n\")\n    print(\" Input  Approximation\")\n    print(\" x   y     y1\")\n    \n    for i in 0 ..< x.count {\n        let result = Double(abc(xx: i))\n        print(String(format: \"%2d %3d  %5.1f\", x[i], y[i], result))\n    }\n}\n\npolyRegression(x: x, y: y)\n", "target": "        public static double[] Polyfit(double[] x, double[] y, int degree)\n        {\n            \n            var v = new DenseMatrix(x.Length, degree + 1);\n            for (int i = 0; i < v.RowCount; i++)\n                for (int j = 0; j <= degree; j++) v[i, j] = Math.Pow(x[i], j);\n            var yv = new DenseVector(y).ToColumnMatrix();\n            QR<double> qr = v.QR();\n            \n            \n            var r = qr.R.SubMatrix(0, degree + 1, 0, degree + 1);\n            var q = v.Multiply(r.Inverse());\n            var p = r.Inverse().Multiply(q.TransposeThisAndMultiply(yv));\n            return p.Column(0).ToArray();\n        }\n"}
{"id": 61650, "name": "Polynomial regression", "source": "Translate Swift to Java: let x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nlet y = [1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321]\n\nfunc average(_ input: [Int]) -> Int {\n    return input.reduce(0, +) / input.count\n}\n\nfunc polyRegression(x: [Int], y: [Int]) {\n    let xm = average(x)\n    let ym = average(y)\n    let x2m = average(x.map { $0 * $0 })\n    let x3m = average(x.map { $0 * $0 * $0 })\n    let x4m = average(x.map { $0 * $0 * $0 * $0 })\n    let xym = average(zip(x,y).map { $0 * $1 })\n    let x2ym = average(zip(x,y).map { $0 * $0 * $1 })\n\n    let sxx = x2m - xm * xm\n    let sxy = xym - xm * ym\n    let sxx2 = x3m - xm * x2m\n    let sx2x2 = x4m - x2m * x2m\n    let sx2y = x2ym - x2m * ym\n \n    let b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)\n    let c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)\n    let a = ym - b * xm - c * x2m\n\n    func abc(xx: Int) -> Int {\n        return (a + b * xx) + (c * xx * xx)\n    }\n    \n    print(\"y = \\(a) + \\(b)x + \\(c)x^2\\n\")\n    print(\" Input  Approximation\")\n    print(\" x   y     y1\")\n    \n    for i in 0 ..< x.count {\n        let result = Double(abc(xx: i))\n        print(String(format: \"%2d %3d  %5.1f\", x[i], y[i], result))\n    }\n}\n\npolyRegression(x: x, y: y)\n", "target": "import java.util.Arrays;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.stream.IntStream;\n\npublic class PolynomialRegression {\n    private static void polyRegression(int[] x, int[] y) {\n        int n = x.length;\n        double xm = Arrays.stream(x).average().orElse(Double.NaN);\n        double ym = Arrays.stream(y).average().orElse(Double.NaN);\n        double x2m = Arrays.stream(x).map(a -> a * a).average().orElse(Double.NaN);\n        double x3m = Arrays.stream(x).map(a -> a * a * a).average().orElse(Double.NaN);\n        double x4m = Arrays.stream(x).map(a -> a * a * a * a).average().orElse(Double.NaN);\n        double xym = 0.0;\n        for (int i = 0; i < x.length && i < y.length; ++i) {\n            xym += x[i] * y[i];\n        }\n        xym /= Math.min(x.length, y.length);\n        double x2ym = 0.0;\n        for (int i = 0; i < x.length && i < y.length; ++i) {\n            x2ym += x[i] * x[i] * y[i];\n        }\n        x2ym /= Math.min(x.length, y.length);\n\n        double sxx = x2m - xm * xm;\n        double sxy = xym - xm * ym;\n        double sxx2 = x3m - xm * x2m;\n        double sx2x2 = x4m - x2m * x2m;\n        double sx2y = x2ym - x2m * ym;\n\n        double b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);\n        double c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);\n        double a = ym - b * xm - c * x2m;\n\n        IntToDoubleFunction abc = (int xx) -> a + b * xx + c * xx * xx;\n\n        System.out.println(\"y = \" + a + \" + \" + b + \"x + \" + c + \"x^2\");\n        System.out.println(\" Input  Approximation\");\n        System.out.println(\" x   y     y1\");\n        for (int i = 0; i < n; ++i) {\n            System.out.printf(\"%2d %3d  %5.1f\\n\", x[i], y[i], abc.applyAsDouble(x[i]));\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] x = IntStream.range(0, 11).toArray();\n        int[] y = new int[]{1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321};\n        polyRegression(x, y);\n    }\n}\n"}
{"id": 61651, "name": "Polynomial regression", "source": "Translate Swift to Python: let x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nlet y = [1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321]\n\nfunc average(_ input: [Int]) -> Int {\n    return input.reduce(0, +) / input.count\n}\n\nfunc polyRegression(x: [Int], y: [Int]) {\n    let xm = average(x)\n    let ym = average(y)\n    let x2m = average(x.map { $0 * $0 })\n    let x3m = average(x.map { $0 * $0 * $0 })\n    let x4m = average(x.map { $0 * $0 * $0 * $0 })\n    let xym = average(zip(x,y).map { $0 * $1 })\n    let x2ym = average(zip(x,y).map { $0 * $0 * $1 })\n\n    let sxx = x2m - xm * xm\n    let sxy = xym - xm * ym\n    let sxx2 = x3m - xm * x2m\n    let sx2x2 = x4m - x2m * x2m\n    let sx2y = x2ym - x2m * ym\n \n    let b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)\n    let c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)\n    let a = ym - b * xm - c * x2m\n\n    func abc(xx: Int) -> Int {\n        return (a + b * xx) + (c * xx * xx)\n    }\n    \n    print(\"y = \\(a) + \\(b)x + \\(c)x^2\\n\")\n    print(\" Input  Approximation\")\n    print(\" x   y     y1\")\n    \n    for i in 0 ..< x.count {\n        let result = Double(abc(xx: i))\n        print(String(format: \"%2d %3d  %5.1f\", x[i], y[i], result))\n    }\n}\n\npolyRegression(x: x, y: y)\n", "target": ">>> x = [0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10]\n>>> y = [1,   6,  17,  34,  57,  86, 121, 162, 209, 262, 321]\n>>> coeffs = numpy.polyfit(x,y,deg=2)\n>>> coeffs\narray([ 3.,  2.,  1.])\n"}
{"id": 61884, "name": "Menu", "source": "Translate Swift to C#: func getMenuInput(selections: [String]) -> String {\n  guard !selections.isEmpty else {\n    return \"\"\n  }\n\n  func printMenu() {\n    for (i, str) in selections.enumerated() {\n      print(\"\\(i + 1)) \\(str)\")\n    }\n\n    print(\"Selection: \", terminator: \"\")\n  }\n\n  while true {\n    printMenu()\n\n    guard let input = readLine(strippingNewline: true), !input.isEmpty else {\n      return \"\"\n    }\n\n    guard let n = Int(input), n > 0, n <= selections.count else {\n      continue\n    }\n\n    return selections[n - 1]\n  }\n}\n\nlet selected = getMenuInput(selections: [\n  \"fee fie\",\n  \"huff and puff\",\n  \"mirror mirror\",\n  \"tick tock\"\n])\n\nprint(\"You chose: \\(selected)\")\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Menu\n{\n        static void Main(string[] args)\n        {\n            List<string> menu_items = new List<string>() { \"fee fie\", \"huff and puff\", \"mirror mirror\", \"tick tock\" };\n            \n            Console.WriteLine(PrintMenu(menu_items));\n            Console.ReadLine();\n        }\n        private static string PrintMenu(List<string> items)\n        {\n            if (items.Count == 0)\n                return \"\";\n\n            string input = \"\";\n            int i = -1;\n            do\n            {\n                for (int j = 0; j < items.Count; j++)\n                    Console.WriteLine(\"{0}) {1}\", j, items[j]);\n\n                Console.WriteLine(\"What number?\");\n                input = Console.ReadLine();\n\n            } while (!int.TryParse(input, out i) || i >= items.Count || i < 0);\n            return items[i];\n        }\n}\n"}
{"id": 61886, "name": "Menu", "source": "Translate Swift to Java: func getMenuInput(selections: [String]) -> String {\n  guard !selections.isEmpty else {\n    return \"\"\n  }\n\n  func printMenu() {\n    for (i, str) in selections.enumerated() {\n      print(\"\\(i + 1)) \\(str)\")\n    }\n\n    print(\"Selection: \", terminator: \"\")\n  }\n\n  while true {\n    printMenu()\n\n    guard let input = readLine(strippingNewline: true), !input.isEmpty else {\n      return \"\"\n    }\n\n    guard let n = Int(input), n > 0, n <= selections.count else {\n      continue\n    }\n\n    return selections[n - 1]\n  }\n}\n\nlet selected = getMenuInput(selections: [\n  \"fee fie\",\n  \"huff and puff\",\n  \"mirror mirror\",\n  \"tick tock\"\n])\n\nprint(\"You chose: \\(selected)\")\n", "target": "public static String select(List<String> list, String prompt){\n    if(list.size() == 0) return \"\";\n    Scanner sc = new Scanner(System.in);\n    String ret = null;\n    do{\n        for(int i=0;i<list.size();i++){\n            System.out.println(i + \": \"+list.get(i));\n        }\n        System.out.print(prompt);\n        int index = sc.nextInt();\n        if(index >= 0 && index < list.size()){\n            ret = list.get(index);\n        }\n    }while(ret == null);\n    return ret;\n}\n"}
{"id": 61887, "name": "Menu", "source": "Translate Swift to Python: func getMenuInput(selections: [String]) -> String {\n  guard !selections.isEmpty else {\n    return \"\"\n  }\n\n  func printMenu() {\n    for (i, str) in selections.enumerated() {\n      print(\"\\(i + 1)) \\(str)\")\n    }\n\n    print(\"Selection: \", terminator: \"\")\n  }\n\n  while true {\n    printMenu()\n\n    guard let input = readLine(strippingNewline: true), !input.isEmpty else {\n      return \"\"\n    }\n\n    guard let n = Int(input), n > 0, n <= selections.count else {\n      continue\n    }\n\n    return selections[n - 1]\n  }\n}\n\nlet selected = getMenuInput(selections: [\n  \"fee fie\",\n  \"huff and puff\",\n  \"mirror mirror\",\n  \"tick tock\"\n])\n\nprint(\"You chose: \\(selected)\")\n", "target": "def _menu(items):\n    for indexitem in enumerate(items):\n        print (\"  %2i) %s\" % indexitem)\n\ndef _ok(reply, itemcount):\n    try:\n        n = int(reply)\n        return 0 <= n < itemcount\n    except:\n        return False\n    \ndef selector(items, prompt):\n    'Prompt to select an item from the items'\n    if not items: return ''\n    reply = -1\n    itemcount = len(items)\n    while not _ok(reply, itemcount):\n        _menu(items)\n        \n        reply = raw_input(prompt).strip()\n    return items[int(reply)]\n\nif __name__ == '__main__':\n    items = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']\n    item = selector(items, 'Which is from the three pigs: ')\n    print (\"You chose: \" + item)\n"}
{"id": 62284, "name": "Greatest subsequential sum", "source": "Translate Swift to C#: func maxSubseq(sequence: [Int]) -> (Int, Int, Int) {\n    var maxSum = 0, thisSum = 0, i = 0\n    var start = 0, end = -1\n    for (j, seq) in sequence.enumerated() {\n        thisSum += seq\n        if thisSum < 0 {\n            i = j + 1\n            thisSum = 0\n        } else if (thisSum > maxSum) {\n            maxSum = thisSum\n            start = i\n            end = j\n        }\n    }\n    return start <= end && start >= 0 && end >= 0\n        ? (start, end + 1, maxSum) : (0, 0, 0)\n}\n\nlet a = [-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]\nlet (start, end, maxSum) = maxSubseq(sequence: a)\nprint(\"Max sum = \\(maxSum)\")\nprint(a[start..<end])\n", "target": "using System;\n\nnamespace Tests_With_Framework_4\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] integers = { -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 }; int length = integers.Length;\n            int maxsum, beginmax, endmax, sum; maxsum = beginmax = sum = 0; endmax = -1;\n\n            for (int i = 0; i < length; i++)\n            {\n                sum = 0;\n                for (int k = i; k < length; k++)\n                {\n                    sum += integers[k];\n                    if (sum > maxsum)\n                    {\n                        maxsum = sum;\n                        beginmax = i;\n                        endmax = k;\n                    }\n                }\n            }\n\n            for (int i = beginmax; i <= endmax; i++)\n                Console.WriteLine(integers[i]);\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 62285, "name": "Greatest subsequential sum", "source": "Translate Swift to C#: func maxSubseq(sequence: [Int]) -> (Int, Int, Int) {\n    var maxSum = 0, thisSum = 0, i = 0\n    var start = 0, end = -1\n    for (j, seq) in sequence.enumerated() {\n        thisSum += seq\n        if thisSum < 0 {\n            i = j + 1\n            thisSum = 0\n        } else if (thisSum > maxSum) {\n            maxSum = thisSum\n            start = i\n            end = j\n        }\n    }\n    return start <= end && start >= 0 && end >= 0\n        ? (start, end + 1, maxSum) : (0, 0, 0)\n}\n\nlet a = [-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]\nlet (start, end, maxSum) = maxSubseq(sequence: a)\nprint(\"Max sum = \\(maxSum)\")\nprint(a[start..<end])\n", "target": "using System;\n\nnamespace Tests_With_Framework_4\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] integers = { -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 }; int length = integers.Length;\n            int maxsum, beginmax, endmax, sum; maxsum = beginmax = sum = 0; endmax = -1;\n\n            for (int i = 0; i < length; i++)\n            {\n                sum = 0;\n                for (int k = i; k < length; k++)\n                {\n                    sum += integers[k];\n                    if (sum > maxsum)\n                    {\n                        maxsum = sum;\n                        beginmax = i;\n                        endmax = k;\n                    }\n                }\n            }\n\n            for (int i = beginmax; i <= endmax; i++)\n                Console.WriteLine(integers[i]);\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 62288, "name": "Greatest subsequential sum", "source": "Translate Swift to Java: func maxSubseq(sequence: [Int]) -> (Int, Int, Int) {\n    var maxSum = 0, thisSum = 0, i = 0\n    var start = 0, end = -1\n    for (j, seq) in sequence.enumerated() {\n        thisSum += seq\n        if thisSum < 0 {\n            i = j + 1\n            thisSum = 0\n        } else if (thisSum > maxSum) {\n            maxSum = thisSum\n            start = i\n            end = j\n        }\n    }\n    return start <= end && start >= 0 && end >= 0\n        ? (start, end + 1, maxSum) : (0, 0, 0)\n}\n\nlet a = [-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]\nlet (start, end, maxSum) = maxSubseq(sequence: a)\nprint(\"Max sum = \\(maxSum)\")\nprint(a[start..<end])\n", "target": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Sub{\n    private static int[] indices;\n\n    public static void main(String[] args){\n        ArrayList<Long> array= new ArrayList<Long>(); \n        Scanner in = new Scanner(System.in);\n        while(in.hasNextLong()) array.add(in.nextLong());\n        long highSum= Long.MIN_VALUE;\n        ArrayList<Long> highSet= new ArrayList<Long>();\n        \n        for(int subSize= 0;subSize<= array.size();subSize++){\n            indices= new int[subSize];\n            for(int i= 0;i< subSize;i++) indices[i]= i;\n            do{\n                long sum= 0;\n                ArrayList<Long> temp= new ArrayList<Long>();\n                \n                for(long index:indices) {sum+= array.get(index); temp.add(array.get(index));}\n                if(sum > highSum){\n                    highSet= temp;    \n                    highSum= sum;\n                }\n            }while(nextIndices(array));\n        }\n        System.out.println(\"Sum: \" + highSum + \"\\nSet: \" + \n        \t\thighSet);\n    }\n    \n\n    private static boolean nextIndices(ArrayList<Long> a) {\n        for(int i= indices.length-1;i >= 0;--i){\n            indices[i]++;\n            for(int j=i+1;j < indices.length;++j){\n                indices[j]= indices[j - 1] + 1;\n            }\n            if(indices[indices.length - 1] < a.size()){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"id": 62289, "name": "Greatest subsequential sum", "source": "Translate Swift to Java: func maxSubseq(sequence: [Int]) -> (Int, Int, Int) {\n    var maxSum = 0, thisSum = 0, i = 0\n    var start = 0, end = -1\n    for (j, seq) in sequence.enumerated() {\n        thisSum += seq\n        if thisSum < 0 {\n            i = j + 1\n            thisSum = 0\n        } else if (thisSum > maxSum) {\n            maxSum = thisSum\n            start = i\n            end = j\n        }\n    }\n    return start <= end && start >= 0 && end >= 0\n        ? (start, end + 1, maxSum) : (0, 0, 0)\n}\n\nlet a = [-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]\nlet (start, end, maxSum) = maxSubseq(sequence: a)\nprint(\"Max sum = \\(maxSum)\")\nprint(a[start..<end])\n", "target": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Sub{\n    private static int[] indices;\n\n    public static void main(String[] args){\n        ArrayList<Long> array= new ArrayList<Long>(); \n        Scanner in = new Scanner(System.in);\n        while(in.hasNextLong()) array.add(in.nextLong());\n        long highSum= Long.MIN_VALUE;\n        ArrayList<Long> highSet= new ArrayList<Long>();\n        \n        for(int subSize= 0;subSize<= array.size();subSize++){\n            indices= new int[subSize];\n            for(int i= 0;i< subSize;i++) indices[i]= i;\n            do{\n                long sum= 0;\n                ArrayList<Long> temp= new ArrayList<Long>();\n                \n                for(long index:indices) {sum+= array.get(index); temp.add(array.get(index));}\n                if(sum > highSum){\n                    highSet= temp;    \n                    highSum= sum;\n                }\n            }while(nextIndices(array));\n        }\n        System.out.println(\"Sum: \" + highSum + \"\\nSet: \" + \n        \t\thighSet);\n    }\n    \n\n    private static boolean nextIndices(ArrayList<Long> a) {\n        for(int i= indices.length-1;i >= 0;--i){\n            indices[i]++;\n            for(int j=i+1;j < indices.length;++j){\n                indices[j]= indices[j - 1] + 1;\n            }\n            if(indices[indices.length - 1] < a.size()){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"id": 62290, "name": "Greatest subsequential sum", "source": "Translate Swift to Python: func maxSubseq(sequence: [Int]) -> (Int, Int, Int) {\n    var maxSum = 0, thisSum = 0, i = 0\n    var start = 0, end = -1\n    for (j, seq) in sequence.enumerated() {\n        thisSum += seq\n        if thisSum < 0 {\n            i = j + 1\n            thisSum = 0\n        } else if (thisSum > maxSum) {\n            maxSum = thisSum\n            start = i\n            end = j\n        }\n    }\n    return start <= end && start >= 0 && end >= 0\n        ? (start, end + 1, maxSum) : (0, 0, 0)\n}\n\nlet a = [-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]\nlet (start, end, maxSum) = maxSubseq(sequence: a)\nprint(\"Max sum = \\(maxSum)\")\nprint(a[start..<end])\n", "target": "def maxsubseq(seq):\n  return max((seq[begin:end] for begin in xrange(len(seq)+1)\n                             for end in xrange(begin, len(seq)+1)),\n             key=sum)\n"}
{"id": 62291, "name": "Greatest subsequential sum", "source": "Translate Swift to Python: func maxSubseq(sequence: [Int]) -> (Int, Int, Int) {\n    var maxSum = 0, thisSum = 0, i = 0\n    var start = 0, end = -1\n    for (j, seq) in sequence.enumerated() {\n        thisSum += seq\n        if thisSum < 0 {\n            i = j + 1\n            thisSum = 0\n        } else if (thisSum > maxSum) {\n            maxSum = thisSum\n            start = i\n            end = j\n        }\n    }\n    return start <= end && start >= 0 && end >= 0\n        ? (start, end + 1, maxSum) : (0, 0, 0)\n}\n\nlet a = [-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]\nlet (start, end, maxSum) = maxSubseq(sequence: a)\nprint(\"Max sum = \\(maxSum)\")\nprint(a[start..<end])\n", "target": "def maxsubseq(seq):\n  return max((seq[begin:end] for begin in xrange(len(seq)+1)\n                             for end in xrange(begin, len(seq)+1)),\n             key=sum)\n"}
{"id": 62825, "name": "Integer sequence", "source": "Translate Swift to C#: var i = 0\nwhile true {\n    println(i++)\n}\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        BigInteger i = 1;\n        while (true)\n        {\n            Console.WriteLine(i++);\n        }\n    }\n}\n"}
{"id": 62826, "name": "Integer sequence", "source": "Translate Swift to C#: var i = 0\nwhile true {\n    println(i++)\n}\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        BigInteger i = 1;\n        while (true)\n        {\n            Console.WriteLine(i++);\n        }\n    }\n}\n"}
{"id": 62829, "name": "Integer sequence", "source": "Translate Swift to Java: var i = 0\nwhile true {\n    println(i++)\n}\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(long i = 1; ;i++) System.out.println(i);\n    }\n}\n"}
{"id": 62830, "name": "Integer sequence", "source": "Translate Swift to Java: var i = 0\nwhile true {\n    println(i++)\n}\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(long i = 1; ;i++) System.out.println(i);\n    }\n}\n"}
{"id": 63088, "name": "Fibonacci sequence", "source": "Translate Swift to C#: import Cocoa\n\nfunc fibonacci(n: Int) -> Int {\n    let square_root_of_5 = sqrt(5.0)\n    let p = (1 + square_root_of_5) / 2\n    let q = 1 / p\n    return Int((pow(p,CDouble(n)) + pow(q,CDouble(n))) / square_root_of_5 + 0.5)\n}\n\nfor i in 1...30 {\n    println(fibonacci(i))\n}\n", "target": "public static ulong Fib(uint n) {\n    return (n < 2)? n : Fib(n - 1) + Fib(n - 2);\n}\n"}
{"id": 63090, "name": "Fibonacci sequence", "source": "Translate Swift to Java: import Cocoa\n\nfunc fibonacci(n: Int) -> Int {\n    let square_root_of_5 = sqrt(5.0)\n    let p = (1 + square_root_of_5) / 2\n    let q = 1 / p\n    return Int((pow(p,CDouble(n)) + pow(q,CDouble(n))) / square_root_of_5 + 0.5)\n}\n\nfor i in 1...30 {\n    println(fibonacci(i))\n}\n", "target": "public static long itFibN(int n)\n{\n if (n < 2)\n  return n;\n long ans = 0;\n long n1 = 0;\n long n2 = 1;\n for(n--; n > 0; n--)\n {\n  ans = n1 + n2;\n  n1 = n2;\n  n2 = ans;\n }\n return ans;\n}\n"}
{"id": 63091, "name": "Fibonacci sequence", "source": "Translate Swift to Python: import Cocoa\n\nfunc fibonacci(n: Int) -> Int {\n    let square_root_of_5 = sqrt(5.0)\n    let p = (1 + square_root_of_5) / 2\n    let q = 1 / p\n    return Int((pow(p,CDouble(n)) + pow(q,CDouble(n))) / square_root_of_5 + 0.5)\n}\n\nfor i in 1...30 {\n    println(fibonacci(i))\n}\n", "target": "from math import *\n\ndef analytic_fibonacci(n):\n  sqrt_5 = sqrt(5);\n  p = (1 + sqrt_5) / 2;\n  q = 1/p;\n  return int( (p**n + q**n) / sqrt_5 + 0.5 )\n\nfor i in range(1,31):\n  print analytic_fibonacci(i),\n"}
{"id": 63369, "name": "Averages_Arithmetic mean", "source": "Translate Swift to C#: func meanDoubles(s: [Double]) -> Double {\n  return s.reduce(0, +) / Double(s.count)\n}\nfunc meanInts(s: [Int]) -> Double {\n  return meanDoubles(s.map{Double($0)})\n}\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(new[] { 1, 2, 3 }.Average());\n    }\n}\n"}
{"id": 63371, "name": "Averages_Arithmetic mean", "source": "Translate Swift to Java: func meanDoubles(s: [Double]) -> Double {\n  return s.reduce(0, +) / Double(s.count)\n}\nfunc meanInts(s: [Int]) -> Double {\n  return meanDoubles(s.map{Double($0)})\n}\n", "target": "public static double avg(double... arr) {\n    double sum = 0.0;\n    for (double x : arr) {\n        sum += x;\n    }\n    return sum / arr.length;\n}\n"}
{"id": 63372, "name": "Averages_Arithmetic mean", "source": "Translate Swift to Python: func meanDoubles(s: [Double]) -> Double {\n  return s.reduce(0, +) / Double(s.count)\n}\nfunc meanInts(s: [Int]) -> Double {\n  return meanDoubles(s.map{Double($0)})\n}\n", "target": "from math import fsum\ndef average(x):\n    return fsum(x)/float(len(x)) if x else 0\nprint (average([0,0,3,1,4,1,5,9,0,0]))\nprint (average([1e20,-1e-20,3,1,4,1,5,9,-1e20,1e-20]))\n"}
{"id": 63811, "name": "Sort an array of composite structures", "source": "Translate Swift to C#: extension Sequence {\n  func sorted<Value>(\n    on: KeyPath<Element, Value>,\n    using: (Value, Value) -> Bool\n  ) -> [Element] where Value: Comparable {\n    return withoutActuallyEscaping(using, do: {using -> [Element] in\n      return self.sorted(by: { using($0[keyPath: on], $1[keyPath: on]) })\n    })\n  }\n}\n\nstruct Person {\n  var name: String\n  var role: String\n}\n\nlet a = Person(name: \"alice\", role: \"manager\")\nlet b = Person(name: \"bob\", role: \"worker\")\nlet c = Person(name: \"charlie\", role: \"driver\")\n\nprint([c, b, a].sorted(on: \\.name, using: <))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{        \n    struct Entry\n    {\n        public Entry(string name, double value) { Name = name; Value = value; }\n        public string Name;\n        public double Value;\n    }\n\n    static void Main(string[] args)\n    {\n        var Elements = new List<Entry>\n        {\n            new Entry(\"Krypton\", 83.798), new Entry(\"Beryllium\", 9.012182), new Entry(\"Silicon\", 28.0855),\n            new Entry(\"Cobalt\", 58.933195), new Entry(\"Selenium\", 78.96), new Entry(\"Germanium\", 72.64)\n        };\n\n        var sortedElements = Elements.OrderBy(e => e.Name);\n\n        foreach (Entry e in sortedElements)\n            Console.WriteLine(\"{0,-11}{1}\", e.Name, e.Value);\n    }\n}\n"}
{"id": 63813, "name": "Sort an array of composite structures", "source": "Translate Swift to Java: extension Sequence {\n  func sorted<Value>(\n    on: KeyPath<Element, Value>,\n    using: (Value, Value) -> Bool\n  ) -> [Element] where Value: Comparable {\n    return withoutActuallyEscaping(using, do: {using -> [Element] in\n      return self.sorted(by: { using($0[keyPath: on], $1[keyPath: on]) })\n    })\n  }\n}\n\nstruct Person {\n  var name: String\n  var role: String\n}\n\nlet a = Person(name: \"alice\", role: \"manager\")\nlet b = Person(name: \"bob\", role: \"worker\")\nlet c = Person(name: \"charlie\", role: \"driver\")\n\nprint([c, b, a].sorted(on: \\.name, using: <))\n", "target": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class SortComp {\n    public static class Pair {\n        public String name;\n        public String value;\n        public Pair(String n, String v) {\n            name = n;\n            value = v;\n        }\n    }\n\n    public static void main(String[] args) {\n        Pair[] pairs = {new Pair(\"06-07\", \"Ducks\"), new Pair(\"00-01\", \"Avalanche\"),\n            new Pair(\"02-03\", \"Devils\"), new Pair(\"01-02\", \"Red Wings\"),\n            new Pair(\"03-04\", \"Lightning\"), new Pair(\"04-05\", \"lockout\"),\n            new Pair(\"05-06\", \"Hurricanes\"), new Pair(\"99-00\", \"Devils\"),\n            new Pair(\"07-08\", \"Red Wings\"), new Pair(\"08-09\", \"Penguins\")};\n\n        sortByName(pairs);\n        for (Pair p : pairs) {\n            System.out.println(p.name + \" \" + p.value);\n        }\n    }\n\n    public static void sortByName(Pair[] pairs) {\n        Arrays.sort(pairs, new Comparator<Pair>() {\n            public int compare(Pair p1, Pair p2) {\n                return p1.name.compareTo(p2.name);\n            }\n        });\n    }\n}\n"}
{"id": 63814, "name": "Sort an array of composite structures", "source": "Translate Swift to Python: extension Sequence {\n  func sorted<Value>(\n    on: KeyPath<Element, Value>,\n    using: (Value, Value) -> Bool\n  ) -> [Element] where Value: Comparable {\n    return withoutActuallyEscaping(using, do: {using -> [Element] in\n      return self.sorted(by: { using($0[keyPath: on], $1[keyPath: on]) })\n    })\n  }\n}\n\nstruct Person {\n  var name: String\n  var role: String\n}\n\nlet a = Person(name: \"alice\", role: \"manager\")\nlet b = Person(name: \"bob\", role: \"worker\")\nlet c = Person(name: \"charlie\", role: \"driver\")\n\nprint([c, b, a].sorted(on: \\.name, using: <))\n", "target": "people = [('joe', 120), ('foo', 31), ('bar', 51)]\nsorted(people)\n"}
{"id": 64651, "name": "Calculating the value of e", "source": "Translate Swift to C#: import Foundation\n\n\nfunc calculateE(epsilon: Double = 1.0e-15) -> Double {\n  var fact: UInt64 = 1\n  var e = 2.0, e0 = 0.0\n  var n = 2\n\n  repeat {\n    e0 = e\n    fact *= UInt64(n)\n    n += 1\n    e += 1.0 / Double(fact)\n  } while fabs(e - e0) >= epsilon\n\n  return e\n}\n\nprint(String(format: \"e =\u00a0%.15f\\n\", arguments: [calculateE()]))\n", "target": "using System;\n\nnamespace CalculateE {\n    class Program {\n        public const double EPSILON = 1.0e-15;\n\n        static void Main(string[] args) {\n            ulong fact = 1;\n            double e = 2.0;\n            double e0;\n            uint n = 2;\n            do {\n                e0 = e;\n                fact *= n++;\n                e += 1.0 / fact;\n            } while (Math.Abs(e - e0) >= EPSILON);\n            Console.WriteLine(\"e = {0:F15}\", e);\n        }\n    }\n}\n"}
{"id": 64652, "name": "Calculating the value of e", "source": "Translate Swift to C#: import Foundation\n\n\nfunc calculateE(epsilon: Double = 1.0e-15) -> Double {\n  var fact: UInt64 = 1\n  var e = 2.0, e0 = 0.0\n  var n = 2\n\n  repeat {\n    e0 = e\n    fact *= UInt64(n)\n    n += 1\n    e += 1.0 / Double(fact)\n  } while fabs(e - e0) >= epsilon\n\n  return e\n}\n\nprint(String(format: \"e =\u00a0%.15f\\n\", arguments: [calculateE()]))\n", "target": "using System;\n\nnamespace CalculateE {\n    class Program {\n        public const double EPSILON = 1.0e-15;\n\n        static void Main(string[] args) {\n            ulong fact = 1;\n            double e = 2.0;\n            double e0;\n            uint n = 2;\n            do {\n                e0 = e;\n                fact *= n++;\n                e += 1.0 / fact;\n            } while (Math.Abs(e - e0) >= EPSILON);\n            Console.WriteLine(\"e = {0:F15}\", e);\n        }\n    }\n}\n"}
{"id": 64655, "name": "Calculating the value of e", "source": "Translate Swift to Java: import Foundation\n\n\nfunc calculateE(epsilon: Double = 1.0e-15) -> Double {\n  var fact: UInt64 = 1\n  var e = 2.0, e0 = 0.0\n  var n = 2\n\n  repeat {\n    e0 = e\n    fact *= UInt64(n)\n    n += 1\n    e += 1.0 / Double(fact)\n  } while fabs(e - e0) >= epsilon\n\n  return e\n}\n\nprint(String(format: \"e =\u00a0%.15f\\n\", arguments: [calculateE()]))\n", "target": "public class CalculateE {\n    public static final double EPSILON = 1.0e-15;\n\n    public static void main(String[] args) {\n        long fact = 1;\n        double e = 2.0;\n        int n = 2;\n        double e0;\n        do {\n            e0 = e;\n            fact *= n++;\n            e += 1.0 / fact;\n        } while (Math.abs(e - e0) >= EPSILON);\n        System.out.printf(\"e =\u00a0%.15f\\n\", e);\n    }\n}\n"}
{"id": 64656, "name": "Calculating the value of e", "source": "Translate Swift to Java: import Foundation\n\n\nfunc calculateE(epsilon: Double = 1.0e-15) -> Double {\n  var fact: UInt64 = 1\n  var e = 2.0, e0 = 0.0\n  var n = 2\n\n  repeat {\n    e0 = e\n    fact *= UInt64(n)\n    n += 1\n    e += 1.0 / Double(fact)\n  } while fabs(e - e0) >= epsilon\n\n  return e\n}\n\nprint(String(format: \"e =\u00a0%.15f\\n\", arguments: [calculateE()]))\n", "target": "public class CalculateE {\n    public static final double EPSILON = 1.0e-15;\n\n    public static void main(String[] args) {\n        long fact = 1;\n        double e = 2.0;\n        int n = 2;\n        double e0;\n        do {\n            e0 = e;\n            fact *= n++;\n            e += 1.0 / fact;\n        } while (Math.abs(e - e0) >= EPSILON);\n        System.out.printf(\"e =\u00a0%.15f\\n\", e);\n    }\n}\n"}
{"id": 64657, "name": "Calculating the value of e", "source": "Translate Swift to Python: import Foundation\n\n\nfunc calculateE(epsilon: Double = 1.0e-15) -> Double {\n  var fact: UInt64 = 1\n  var e = 2.0, e0 = 0.0\n  var n = 2\n\n  repeat {\n    e0 = e\n    fact *= UInt64(n)\n    n += 1\n    e += 1.0 / Double(fact)\n  } while fabs(e - e0) >= epsilon\n\n  return e\n}\n\nprint(String(format: \"e =\u00a0%.15f\\n\", arguments: [calculateE()]))\n", "target": "import math\n\ne0 = 0\ne = 2\nn = 0\nfact = 1\nwhile(e-e0 > 1e-15):\n\te0 = e\n\tn += 1\n\tfact *= 2*n*(2*n+1)\n\te += (2.*n+2)/fact\n\nprint \"Computed e = \"+str(e)\nprint \"Real e = \"+str(math.e)\nprint \"Error = \"+str(math.e-e)\nprint \"Number of iterations = \"+str(n)\n"}
{"id": 64658, "name": "Calculating the value of e", "source": "Translate Swift to Python: import Foundation\n\n\nfunc calculateE(epsilon: Double = 1.0e-15) -> Double {\n  var fact: UInt64 = 1\n  var e = 2.0, e0 = 0.0\n  var n = 2\n\n  repeat {\n    e0 = e\n    fact *= UInt64(n)\n    n += 1\n    e += 1.0 / Double(fact)\n  } while fabs(e - e0) >= epsilon\n\n  return e\n}\n\nprint(String(format: \"e =\u00a0%.15f\\n\", arguments: [calculateE()]))\n", "target": "import math\n\ne0 = 0\ne = 2\nn = 0\nfact = 1\nwhile(e-e0 > 1e-15):\n\te0 = e\n\tn += 1\n\tfact *= 2*n*(2*n+1)\n\te += (2.*n+2)/fact\n\nprint \"Computed e = \"+str(e)\nprint \"Real e = \"+str(math.e)\nprint \"Error = \"+str(math.e-e)\nprint \"Number of iterations = \"+str(n)\n"}
{"id": 64859, "name": "Exceptions_Catch an exception thrown in a nested call", "source": "Translate Swift to C#: enum MyException : ErrorType {\n  case U0\n  case U1\n}\n\nfunc foo() throws {\n  for i in 0 ... 1 {\n    do {\n      try bar(i)\n    } catch MyException.U0 {\n      print(\"Function foo caught exception U0\")\n    }\n  }\n}\n\nfunc bar(i: Int) throws {\n  try baz(i) \n}\n\nfunc baz(i: Int) throws {\n  if i == 0 {\n    throw MyException.U0\n  } else {\n    throw MyException.U1\n  }\n}\n\ntry foo()\n", "target": "using System; \nclass Exceptions\n{\n  class U0 : Exception { }\n  class U1 : Exception { }\n  static int i;\n  static void foo()\n  {\n    for (i = 0; i < 2; i++)\n      try\n      {\n        bar();\n      }\n      catch (U0) {\n        Console.WriteLine(\"U0 Caught\");\n      }\n  }\n  static void bar()\n  {\n    baz();\n  }\n  static void baz(){\n    if (i == 0)\n      throw new U0();\n    throw new U1();\n  }\n\n  public static void Main()\n  {\n    foo();\n  }\n}\n"}
{"id": 64861, "name": "Exceptions_Catch an exception thrown in a nested call", "source": "Translate Swift to Java: enum MyException : ErrorType {\n  case U0\n  case U1\n}\n\nfunc foo() throws {\n  for i in 0 ... 1 {\n    do {\n      try bar(i)\n    } catch MyException.U0 {\n      print(\"Function foo caught exception U0\")\n    }\n  }\n}\n\nfunc bar(i: Int) throws {\n  try baz(i) \n}\n\nfunc baz(i: Int) throws {\n  if i == 0 {\n    throw MyException.U0\n  } else {\n    throw MyException.U1\n  }\n}\n\ntry foo()\n", "target": "class U0 extends Exception { }\nclass U1 extends Exception { }\n\npublic class ExceptionsTest {\n    public static void foo() throws U1 {\n        for (int i = 0; i <= 1; i++) {\n            try {\n                bar(i);\n            } catch (U0 e) {\n                System.out.println(\"Function foo caught exception U0\");\n            }\n        }\n    }\n\n    public static void bar(int i) throws U0, U1 {\n        baz(i); \n    }\n\n    public static void baz(int i) throws U0, U1 {\n        if (i == 0)\n            throw new U0();\n        else\n            throw new U1();\n    }\n\n    public static void main(String[] args) throws U1 {\n        foo();\n    }\n}\n"}
{"id": 64862, "name": "Exceptions_Catch an exception thrown in a nested call", "source": "Translate Swift to Python: enum MyException : ErrorType {\n  case U0\n  case U1\n}\n\nfunc foo() throws {\n  for i in 0 ... 1 {\n    do {\n      try bar(i)\n    } catch MyException.U0 {\n      print(\"Function foo caught exception U0\")\n    }\n  }\n}\n\nfunc bar(i: Int) throws {\n  try baz(i) \n}\n\nfunc baz(i: Int) throws {\n  if i == 0 {\n    throw MyException.U0\n  } else {\n    throw MyException.U1\n  }\n}\n\ntry foo()\n", "target": "class U0(Exception): pass\nclass U1(Exception): pass\n\ndef foo():\n    for i in range(2):\n        try:\n            bar(i)\n        except U0:\n            print(\"Function foo caught exception U0\")\n\ndef bar(i):\n    baz(i) \n\ndef baz(i):\n    raise U1 if i else U0\n\nfoo()\n"}
{"id": 65076, "name": "Symmetric difference", "source": "Translate Swift to C#: let setA : Set<String> = [\"John\", \"Bob\", \"Mary\", \"Serena\"]\nlet setB : Set<String> = [\"Jim\", \"Mary\", \"John\", \"Bob\"]\nprintln(setA.exclusiveOr(setB)) \nprintln(setA.subtract(setB)) \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaCode.SymmetricDifference\n{\n    public static class IEnumerableExtension\n    {\n        public static IEnumerable<T> SymmetricDifference<T>(this IEnumerable<T> @this, IEnumerable<T> that)\n        {\n            return @this.Except(that).Concat(that.Except(@this));\n        }\n    }\n\n    class Program\n    {\n        static void Main()\n        {\n            var a = new[] { \"John\", \"Bob\", \"Mary\", \"Serena\" };\n            var b = new[] { \"Jim\", \"Mary\", \"John\", \"Bob\" };\n\n            foreach (var element in a.SymmetricDifference(b))\n            {\n                Console.WriteLine(element);\n            }\n        }\n    }\n}\n"}
{"id": 65078, "name": "Symmetric difference", "source": "Translate Swift to Java: let setA : Set<String> = [\"John\", \"Bob\", \"Mary\", \"Serena\"]\nlet setB : Set<String> = [\"Jim\", \"Mary\", \"John\", \"Bob\"]\nprintln(setA.exclusiveOr(setB)) \nprintln(setA.subtract(setB)) \n", "target": "Set<String> setA = new Set<String>{'John', 'Bob', 'Mary', 'Serena'};\nSet<String> setB = new Set<String>{'Jim', 'Mary', 'John', 'Bob'};\n\n\nSet<String> notInSetA = setB.clone();\nnotInSetA.removeAll(setA);\n\nSet<String> notInSetB = setA.clone();\nnotInSetB.removeAll(setB);\n\nSet<String> symmetricDifference = new Set<String>();\nsymmetricDifference.addAll(notInSetA);\nsymmetricDifference.addAll(notInSetB);\n\n\nSet<String> union = setA.clone();\nunion.addAll(setB);\n\nSet<String> intersection = setA.clone();\nintersection.retainAll(setB);\n\nSet<String> symmetricDifference2 = union.clone();\nsymmetricDifference2.removeAll(intersection);\n\nSystem.debug('Not in set A: ' + notInSetA);\nSystem.debug('Not in set B: ' + notInSetB);\nSystem.debug('Symmetric Difference: ' + symmetricDifference);\nSystem.debug('Symmetric Difference 2: ' + symmetricDifference2);\n"}
{"id": 65079, "name": "Symmetric difference", "source": "Translate Swift to Python: let setA : Set<String> = [\"John\", \"Bob\", \"Mary\", \"Serena\"]\nlet setB : Set<String> = [\"Jim\", \"Mary\", \"John\", \"Bob\"]\nprintln(setA.exclusiveOr(setB)) \nprintln(setA.subtract(setB)) \n", "target": ">>> setA = {\"John\", \"Bob\", \"Mary\", \"Serena\"}\n>>> setB = {\"Jim\", \"Mary\", \"John\", \"Bob\"}\n>>> setA ^ setB \n{'Jim', 'Serena'}\n>>> setA - setB \n{'Serena'}\n>>> setB - setA \n{'Jim'}\n>>> setA | setB \n{'John', 'Bob', 'Jim', 'Serena', 'Mary'}\n>>> setA & setB \n{'Bob', 'John', 'Mary'}\n"}
{"id": 65287, "name": "Inheritance_Single", "source": "Translate Swift to C#: class Animal {\n  \n}\n\nclass Dog : Animal {\n  \n}\n\nclass Lab : Dog {\n  \n}\n\nclass Collie : Dog {\n  \n}\n\nclass Cat : Animal {\n  \n}\n", "target": "class Animal\n{ \n   \n  \n}\n\nclass Dog : Animal\n{ \n   \n  \n}\n\nclass Lab : Dog\n{ \n   \n  \n}\n\nclass Collie : Dog\n{ \n  \n  \n}\n\nclass Cat : Animal\n{ \n  \n  \n}\n"}
{"id": 65289, "name": "Inheritance_Single", "source": "Translate Swift to Java: class Animal {\n  \n}\n\nclass Dog : Animal {\n  \n}\n\nclass Lab : Dog {\n  \n}\n\nclass Collie : Dog {\n  \n}\n\nclass Cat : Animal {\n  \n}\n", "target": "public class Animal{\n   \n}\n"}
{"id": 65290, "name": "Inheritance_Single", "source": "Translate Swift to Python: class Animal {\n  \n}\n\nclass Dog : Animal {\n  \n}\n\nclass Lab : Dog {\n  \n}\n\nclass Collie : Dog {\n  \n}\n\nclass Cat : Animal {\n  \n}\n", "target": "class Animal:\n  pass \n\nclass Dog(Animal):\n  pass \n\nclass Cat(Animal):\n  pass \n\nclass Lab(Dog):\n  pass \n\nclass Collie(Dog):\n  pass \n"}
{"id": 65551, "name": "Averages_Mode", "source": "Translate Swift to C#:  \n\nextension Collection where Element: Hashable {\n\n    \n    func mode() -> Element? {\n        var frequencies = [Element: Int]()\n\n        \n        for element in self {\n            frequencies[element] = (frequencies[element] ?? 0) + 1\n        }\n\n        \n        if let ( mode, _ ) = frequencies.max(by: { $0.value < $1.value }) {\n            return mode\n        } else {\n            return nil\n        }\n    }\n\n}\n\n[\"q\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"z\", \"c\", \"c\", \"c\"].mode() \n[1, 1, 2, 3, 3, 3, 3, 4, 4, 4].mode() \n\nlet emptyArray: [Int] = []\nemptyArray.mode() \n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Test\n{\n    class Program\n    {\n     \n        static void Main(string[] args)\n        {\n            \n            List<int> myList = new List<int>() { 1, 1, 2, 4, 4 }; \n\n            var query =     from numbers in myList \n                            group numbers by numbers \n                            into groupedNumbers\n                            select new { Number = groupedNumbers.Key, Count = groupedNumbers.Count() }; \n            \n            int max = query.Max(g => g.Count);\n            IEnumerable<int> modes = query.Where(x => x.Count == max).Select(x => x.Number);\n            foreach (var item in modes)\n            {\n                Console.WriteLine(item);\n            }\n            \n            Console.ReadLine();\n        }\n\n             \n       \n    }\n     \n    \n}\n"}
{"id": 65553, "name": "Averages_Mode", "source": "Translate Swift to Java:  \n\nextension Collection where Element: Hashable {\n\n    \n    func mode() -> Element? {\n        var frequencies = [Element: Int]()\n\n        \n        for element in self {\n            frequencies[element] = (frequencies[element] ?? 0) + 1\n        }\n\n        \n        if let ( mode, _ ) = frequencies.max(by: { $0.value < $1.value }) {\n            return mode\n        } else {\n            return nil\n        }\n    }\n\n}\n\n[\"q\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"z\", \"c\", \"c\", \"c\"].mode() \n[1, 1, 2, 3, 3, 3, 3, 4, 4, 4].mode() \n\nlet emptyArray: [Int] = []\nemptyArray.mode() \n", "target": "import java.util.*;\n\npublic class Mode {\n    public static <T> List<T> mode(List<? extends T> coll) {\n        Map<T, Integer> seen = new HashMap<T, Integer>();\n        int max = 0;\n        List<T> maxElems = new ArrayList<T>();\n        for (T value : coll) {\n            if (seen.containsKey(value))\n                seen.put(value, seen.get(value) + 1);\n            else\n                seen.put(value, 1);\n            if (seen.get(value) > max) {\n                max = seen.get(value);\n                maxElems.clear();\n                maxElems.add(value);\n            } else if (seen.get(value) == max) {\n                maxElems.add(value);\n            }\n        }\n        return maxElems;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(mode(Arrays.asList(1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17))); \n        System.out.println(mode(Arrays.asList(1, 1, 2, 4, 4))); \n    }\n}\n"}
{"id": 65554, "name": "Averages_Mode", "source": "Translate Swift to Python:  \n\nextension Collection where Element: Hashable {\n\n    \n    func mode() -> Element? {\n        var frequencies = [Element: Int]()\n\n        \n        for element in self {\n            frequencies[element] = (frequencies[element] ?? 0) + 1\n        }\n\n        \n        if let ( mode, _ ) = frequencies.max(by: { $0.value < $1.value }) {\n            return mode\n        } else {\n            return nil\n        }\n    }\n\n}\n\n[\"q\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"z\", \"c\", \"c\", \"c\"].mode() \n[1, 1, 2, 3, 3, 3, 3, 4, 4, 4].mode() \n\nlet emptyArray: [Int] = []\nemptyArray.mode() \n", "target": ">>> from collections import defaultdict\n>>> def modes(values):\n\tcount = defaultdict(int)\n\tfor v in values:\n\t\tcount[v] +=1\n\tbest = max(count.values())\n\treturn [k for k,v in count.items() if v == best]\n\n>>> modes([1,3,6,6,6,6,7,7,12,12,17])\n[6]\n>>> modes((1,1,2,4,4))\n[1, 4]\n"}
{"id": 65780, "name": "Monte Carlo methods", "source": "Translate Swift to C#: import Foundation\n\nfunc mcpi(sampleSize size:Int) -> Double {\n    var x = 0 as Double\n    var y = 0 as Double\n    var m = 0 as Double\n    \n    for i in 0..<size {\n        x = Double(arc4random()) / Double(UINT32_MAX)\n        y = Double(arc4random()) / Double(UINT32_MAX)\n        \n        if ((x * x) + (y * y) < 1) {\n            m += 1\n        }\n    }\n    \n    return (4.0 * m) / Double(size)\n}\n\nprintln(mcpi(sampleSize: 100))\nprintln(mcpi(sampleSize: 1000))\nprintln(mcpi(sampleSize: 10000))\nprintln(mcpi(sampleSize: 100000))\nprintln(mcpi(sampleSize: 1000000))\nprintln(mcpi(sampleSize: 10000000))\nprintln(mcpi(sampleSize: 100000000))\n", "target": "using System;\n\nclass Program {\n    static double MonteCarloPi(int n) {\n        int inside = 0;\n        Random r = new Random();\n\n        for (int i = 0; i < n; i++) {\n            if (Math.Pow(r.NextDouble(), 2)+ Math.Pow(r.NextDouble(), 2) <= 1) {\n                inside++;\n            }\n        }\n\n        return 4.0 * inside / n;\n    }\n\n    static void Main(string[] args) {\n        int value = 1000;\n        for (int n = 0; n < 5; n++) {\n            value *= 10;\n            Console.WriteLine(\"{0}:{1}\", value.ToString(\"#,###\").PadLeft(11, ' '), MonteCarloPi(value));\n        }\n    }\n}\n"}
{"id": 65782, "name": "Monte Carlo methods", "source": "Translate Swift to Java: import Foundation\n\nfunc mcpi(sampleSize size:Int) -> Double {\n    var x = 0 as Double\n    var y = 0 as Double\n    var m = 0 as Double\n    \n    for i in 0..<size {\n        x = Double(arc4random()) / Double(UINT32_MAX)\n        y = Double(arc4random()) / Double(UINT32_MAX)\n        \n        if ((x * x) + (y * y) < 1) {\n            m += 1\n        }\n    }\n    \n    return (4.0 * m) / Double(size)\n}\n\nprintln(mcpi(sampleSize: 100))\nprintln(mcpi(sampleSize: 1000))\nprintln(mcpi(sampleSize: 10000))\nprintln(mcpi(sampleSize: 100000))\nprintln(mcpi(sampleSize: 1000000))\nprintln(mcpi(sampleSize: 10000000))\nprintln(mcpi(sampleSize: 100000000))\n", "target": "public class MC {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getPi(10000));\n\t\tSystem.out.println(getPi(100000));\n\t\tSystem.out.println(getPi(1000000));\n\t\tSystem.out.println(getPi(10000000));\n\t\tSystem.out.println(getPi(100000000));\n\t\t\n\t}\n\tpublic static double getPi(int numThrows){\n\t\tint inCircle= 0;\n\t\tfor(int i= 0;i < numThrows;i++){\n\t\t\t\n\t\t\t\n\t\t\tdouble randX= (Math.random() * 2) - 1;\n\t\t\tdouble randY= (Math.random() * 2) - 1;\n\t\t\t\n\t\t\tdouble dist= Math.sqrt(randX * randX + randY * randY);\n\t\t\t\n\t\t\tif(dist < 1){\n\t\t\t\tinCircle++;\n\t\t\t}\n\t\t}\n\t\treturn 4.0 * inCircle / numThrows;\n\t}\n}\n"}
{"id": 65783, "name": "Monte Carlo methods", "source": "Translate Swift to Python: import Foundation\n\nfunc mcpi(sampleSize size:Int) -> Double {\n    var x = 0 as Double\n    var y = 0 as Double\n    var m = 0 as Double\n    \n    for i in 0..<size {\n        x = Double(arc4random()) / Double(UINT32_MAX)\n        y = Double(arc4random()) / Double(UINT32_MAX)\n        \n        if ((x * x) + (y * y) < 1) {\n            m += 1\n        }\n    }\n    \n    return (4.0 * m) / Double(size)\n}\n\nprintln(mcpi(sampleSize: 100))\nprintln(mcpi(sampleSize: 1000))\nprintln(mcpi(sampleSize: 10000))\nprintln(mcpi(sampleSize: 100000))\nprintln(mcpi(sampleSize: 1000000))\nprintln(mcpi(sampleSize: 10000000))\nprintln(mcpi(sampleSize: 100000000))\n", "target": ">>> import random, math\n>>> throws = 1000\n>>> 4.0 * sum(math.hypot(*[random.random()*2-1\n\t                 for q in [0,1]]) < 1\n              for p in xrange(throws)) / float(throws)\n3.1520000000000001\n>>> throws = 1000000\n>>> 4.0 * sum(math.hypot(*[random.random()*2-1\n\t                 for q in [0,1]]) < 1\n              for p in xrange(throws)) / float(throws)\n3.1396359999999999\n>>> throws = 100000000\n>>> 4.0 * sum(math.hypot(*[random.random()*2-1\n\t                 for q in [0,1]]) < 1\n              for p in xrange(throws)) / float(throws)\n3.1415666400000002\n"}
{"id": 66138, "name": "N'th", "source": "Translate Swift to C#: func addSuffix(n:Int) -> String {\n    if n % 100 / 10 == 1 {\n        return \"th\"\n    }\n    \n    switch n % 10 {\n    case 1:\n        return \"st\"\n    case 2:\n        return \"nd\"\n    case 3:\n        return \"rd\"\n    default:\n        return \"th\"\n    }\n}\n\nfor i in 0...25 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\nfor i in 250...265 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\nfor i in 1000...1025 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    private static string Ordinalize(int i)\n    {\n        i = Math.Abs(i);\n\n        if (new[] {11, 12, 13}.Contains(i%100))\n            return i + \"th\";\n\n        switch (i%10)\n        {\n            case 1:\n                return i + \"st\";\n            case 2:\n                return i + \"nd\";\n            case 3:\n                return i + \"rd\";\n            default:\n                return i + \"th\";\n        }\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(0, 26).Select(Ordinalize)));\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(250, 16).Select(Ordinalize)));\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(1000, 26).Select(Ordinalize)));\n    }\n}\n"}
{"id": 66140, "name": "N'th", "source": "Translate Swift to Java: func addSuffix(n:Int) -> String {\n    if n % 100 / 10 == 1 {\n        return \"th\"\n    }\n    \n    switch n % 10 {\n    case 1:\n        return \"st\"\n    case 2:\n        return \"nd\"\n    case 3:\n        return \"rd\"\n    default:\n        return \"th\"\n    }\n}\n\nfor i in 0...25 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\nfor i in 250...265 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\nfor i in 1000...1025 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\n", "target": "public class Nth {\n\tpublic static String ordinalAbbrev(int n){\n\t\tString ans = \"th\"; \n\t\tif(n % 100 / 10 == 1) return ans; \n\t\tswitch(n % 10){\n\t\t\tcase 1: ans = \"st\"; break;\n\t\t\tcase 2: ans = \"nd\"; break;\n\t\t\tcase 3: ans = \"rd\"; break;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 25;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 250; i <= 265;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 1000; i <= 1025;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t}\n}\n"}
{"id": 66141, "name": "N'th", "source": "Translate Swift to Python: func addSuffix(n:Int) -> String {\n    if n % 100 / 10 == 1 {\n        return \"th\"\n    }\n    \n    switch n % 10 {\n    case 1:\n        return \"st\"\n    case 2:\n        return \"nd\"\n    case 3:\n        return \"rd\"\n    default:\n        return \"th\"\n    }\n}\n\nfor i in 0...25 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\nfor i in 250...265 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\nfor i in 1000...1025 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\n", "target": "_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    return \"%i'%s\" % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th')\n\nif __name__ == '__main__':\n    for j in range(0,1001, 250):\n        print(' '.join(nth(i) for i in list(range(j, j+25))))\n"}
{"id": 66623, "name": "Levenshtein distance", "source": "Translate Swift to C#: func levDis(w1: String, w2: String) -> Int {\n  \n  let (t, s) = (w1.characters, w2.characters)\n  \n  let empty = Repeat(count: s.count, repeatedValue: 0)\n  var mat = [[Int](0...s.count)] + (1...t.count).map{[$0] + empty}\n  \n  for (i, tLett) in t.enumerate() {\n    for (j, sLett) in s.enumerate() {\n      mat[i + 1][j + 1] = tLett == sLett ?\n        mat[i][j] : min(mat[i][j], mat[i][j + 1], mat[i + 1][j]).successor()\n    }\n  }\n  return mat.last!.last!\n}\n", "target": "using System;\n\nnamespace LevenshteinDistance\n{\n    class Program\n    {\n        static int LevenshteinDistance(string s, string t)\n        {\n            int n = s.Length;\n            int m = t.Length;\n            int[,] d = new int[n + 1, m + 1];\n\t\t\n\t    if (n == 0)\n\t    {\n\t\treturn m;\n\t    }\n\t\n\t    if (m == 0)\n\t    {\n\t\treturn n;\n\t    }\n\n            for (int i = 0; i <= n; i++)\n                d[i, 0] = i;\n            for (int j = 0; j <= m; j++)\n                d[0, j] = j;\n\t\t\t\n            for (int j = 1; j <= m; j++)\n                for (int i = 1; i <= n; i++)\n                    if (s[i - 1] == t[j - 1])\n                        d[i, j] = d[i - 1, j - 1];  \n                    else\n                        d[i, j] = Math.Min(Math.Min(\n                            d[i - 1, j] + 1,    \n                            d[i, j - 1] + 1),   \n                            d[i - 1, j - 1] + 1 \n                            );\n            return d[n, m];\n        }\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 2)\n                Console.WriteLine(\"{0} -> {1} = {2}\",\n                    args[0], args[1], LevenshteinDistance(args[0], args[1]));\n            else\n                Console.WriteLine(\"Usage:-\\n\\nLevenshteinDistance <string1> <string2>\");\n        }\n    }\n}\n"}
{"id": 66624, "name": "Levenshtein distance", "source": "Translate Swift to C#: func levDis(w1: String, w2: String) -> Int {\n  \n  let (t, s) = (w1.characters, w2.characters)\n  \n  let empty = Repeat(count: s.count, repeatedValue: 0)\n  var mat = [[Int](0...s.count)] + (1...t.count).map{[$0] + empty}\n  \n  for (i, tLett) in t.enumerate() {\n    for (j, sLett) in s.enumerate() {\n      mat[i + 1][j + 1] = tLett == sLett ?\n        mat[i][j] : min(mat[i][j], mat[i][j + 1], mat[i + 1][j]).successor()\n    }\n  }\n  return mat.last!.last!\n}\n", "target": "using System;\n\nnamespace LevenshteinDistance\n{\n    class Program\n    {\n        static int LevenshteinDistance(string s, string t)\n        {\n            int n = s.Length;\n            int m = t.Length;\n            int[,] d = new int[n + 1, m + 1];\n\t\t\n\t    if (n == 0)\n\t    {\n\t\treturn m;\n\t    }\n\t\n\t    if (m == 0)\n\t    {\n\t\treturn n;\n\t    }\n\n            for (int i = 0; i <= n; i++)\n                d[i, 0] = i;\n            for (int j = 0; j <= m; j++)\n                d[0, j] = j;\n\t\t\t\n            for (int j = 1; j <= m; j++)\n                for (int i = 1; i <= n; i++)\n                    if (s[i - 1] == t[j - 1])\n                        d[i, j] = d[i - 1, j - 1];  \n                    else\n                        d[i, j] = Math.Min(Math.Min(\n                            d[i - 1, j] + 1,    \n                            d[i, j - 1] + 1),   \n                            d[i - 1, j - 1] + 1 \n                            );\n            return d[n, m];\n        }\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 2)\n                Console.WriteLine(\"{0} -> {1} = {2}\",\n                    args[0], args[1], LevenshteinDistance(args[0], args[1]));\n            else\n                Console.WriteLine(\"Usage:-\\n\\nLevenshteinDistance <string1> <string2>\");\n        }\n    }\n}\n"}
{"id": 66627, "name": "Levenshtein distance", "source": "Translate Swift to Java: func levDis(w1: String, w2: String) -> Int {\n  \n  let (t, s) = (w1.characters, w2.characters)\n  \n  let empty = Repeat(count: s.count, repeatedValue: 0)\n  var mat = [[Int](0...s.count)] + (1...t.count).map{[$0] + empty}\n  \n  for (i, tLett) in t.enumerate() {\n    for (j, sLett) in s.enumerate() {\n      mat[i + 1][j + 1] = tLett == sLett ?\n        mat[i][j] : min(mat[i][j], mat[i][j + 1], mat[i + 1][j]).successor()\n    }\n  }\n  return mat.last!.last!\n}\n", "target": "public class Levenshtein {\n\n    public static int distance(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int [] costs = new int [b.length() + 1];\n        for (int j = 0; j < costs.length; j++)\n            costs[j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            \n            costs[0] = i;\n            int nw = i - 1;\n            for (int j = 1; j <= b.length(); j++) {\n                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);\n                nw = costs[j];\n                costs[j] = cj;\n            }\n        }\n        return costs[b.length()];\n    }\n\n    public static void main(String [] args) {\n        String [] data = { \"kitten\", \"sitting\", \"saturday\", \"sunday\", \"rosettacode\", \"raisethysword\" };\n        for (int i = 0; i < data.length; i += 2)\n            System.out.println(\"distance(\" + data[i] + \", \" + data[i+1] + \") = \" + distance(data[i], data[i+1]));\n    }\n}\n"}
{"id": 66628, "name": "Levenshtein distance", "source": "Translate Swift to Java: func levDis(w1: String, w2: String) -> Int {\n  \n  let (t, s) = (w1.characters, w2.characters)\n  \n  let empty = Repeat(count: s.count, repeatedValue: 0)\n  var mat = [[Int](0...s.count)] + (1...t.count).map{[$0] + empty}\n  \n  for (i, tLett) in t.enumerate() {\n    for (j, sLett) in s.enumerate() {\n      mat[i + 1][j + 1] = tLett == sLett ?\n        mat[i][j] : min(mat[i][j], mat[i][j + 1], mat[i + 1][j]).successor()\n    }\n  }\n  return mat.last!.last!\n}\n", "target": "public class Levenshtein {\n\n    public static int distance(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int [] costs = new int [b.length() + 1];\n        for (int j = 0; j < costs.length; j++)\n            costs[j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            \n            costs[0] = i;\n            int nw = i - 1;\n            for (int j = 1; j <= b.length(); j++) {\n                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);\n                nw = costs[j];\n                costs[j] = cj;\n            }\n        }\n        return costs[b.length()];\n    }\n\n    public static void main(String [] args) {\n        String [] data = { \"kitten\", \"sitting\", \"saturday\", \"sunday\", \"rosettacode\", \"raisethysword\" };\n        for (int i = 0; i < data.length; i += 2)\n            System.out.println(\"distance(\" + data[i] + \", \" + data[i+1] + \") = \" + distance(data[i], data[i+1]));\n    }\n}\n"}
{"id": 66629, "name": "Levenshtein distance", "source": "Translate Swift to Python: func levDis(w1: String, w2: String) -> Int {\n  \n  let (t, s) = (w1.characters, w2.characters)\n  \n  let empty = Repeat(count: s.count, repeatedValue: 0)\n  var mat = [[Int](0...s.count)] + (1...t.count).map{[$0] + empty}\n  \n  for (i, tLett) in t.enumerate() {\n    for (j, sLett) in s.enumerate() {\n      mat[i + 1][j + 1] = tLett == sLett ?\n        mat[i][j] : min(mat[i][j], mat[i][j + 1], mat[i + 1][j]).successor()\n    }\n  }\n  return mat.last!.last!\n}\n", "target": "def setup():\n    println(distance(\"kitten\", \"sitting\"))\n\ndef distance(a, b):\n    costs = []\n    for j in range(len(b) + 1):\n        costs.append(j)\n    for i in range(1, len(a) + 1):\n        costs[0] = i\n        nw = i - 1\n        for j in range(1, len(b) + 1):\n            cj = min(1 + min(costs[j], costs[j - 1]),\n                     nw if a[i - 1] == b[j - 1] else nw + 1)\n            nw = costs[j]\n            costs[j] = cj\n\n    return costs[len(b)]\n"}
{"id": 66630, "name": "Levenshtein distance", "source": "Translate Swift to Python: func levDis(w1: String, w2: String) -> Int {\n  \n  let (t, s) = (w1.characters, w2.characters)\n  \n  let empty = Repeat(count: s.count, repeatedValue: 0)\n  var mat = [[Int](0...s.count)] + (1...t.count).map{[$0] + empty}\n  \n  for (i, tLett) in t.enumerate() {\n    for (j, sLett) in s.enumerate() {\n      mat[i + 1][j + 1] = tLett == sLett ?\n        mat[i][j] : min(mat[i][j], mat[i][j + 1], mat[i + 1][j]).successor()\n    }\n  }\n  return mat.last!.last!\n}\n", "target": "def setup():\n    println(distance(\"kitten\", \"sitting\"))\n\ndef distance(a, b):\n    costs = []\n    for j in range(len(b) + 1):\n        costs.append(j)\n    for i in range(1, len(a) + 1):\n        costs[0] = i\n        nw = i - 1\n        for j in range(1, len(b) + 1):\n            cj = min(1 + min(costs[j], costs[j - 1]),\n                     nw if a[i - 1] == b[j - 1] else nw + 1)\n            nw = costs[j]\n            costs[j] = cj\n\n    return costs[len(b)]\n"}
{"id": 67806, "name": "Array length", "source": "Translate Swift to C#: let fruits = [\"apple\", \"orange\"] \nlet fruitsCount = fruits.count \n\nprint(fruitsCount) \n", "target": "using System;\n\nnamespace ArrayLength\n{\n  class Program\n  {\n    public static void Main()\n    {\n      var array = new String[](\"apple\", \"orange\");\n      Console.WriteLine(array.Count);\n      delete(array);\n    }\n  }\n}\n"}
{"id": 67807, "name": "Array length", "source": "Translate Swift to C#: let fruits = [\"apple\", \"orange\"] \nlet fruitsCount = fruits.count \n\nprint(fruitsCount) \n", "target": "using System;\n\nnamespace ArrayLength\n{\n  class Program\n  {\n    public static void Main()\n    {\n      var array = new String[](\"apple\", \"orange\");\n      Console.WriteLine(array.Count);\n      delete(array);\n    }\n  }\n}\n"}
{"id": 67810, "name": "Array length", "source": "Translate Swift to Java: let fruits = [\"apple\", \"orange\"] \nlet fruitsCount = fruits.count \n\nprint(fruitsCount) \n", "target": "String[] array  = [\"apple\", \"orange\"];\nInt      length = array.size;\n"}
{"id": 67811, "name": "Array length", "source": "Translate Swift to Java: let fruits = [\"apple\", \"orange\"] \nlet fruitsCount = fruits.count \n\nprint(fruitsCount) \n", "target": "String[] array  = [\"apple\", \"orange\"];\nInt      length = array.size;\n"}
{"id": 67812, "name": "Array length", "source": "Translate Swift to Python: let fruits = [\"apple\", \"orange\"] \nlet fruitsCount = fruits.count \n\nprint(fruitsCount) \n", "target": "arr = ['apple', 'orange']  \n\ndef setup():\n    println(len(arr))\n"}
{"id": 67813, "name": "Array length", "source": "Translate Swift to Python: let fruits = [\"apple\", \"orange\"] \nlet fruitsCount = fruits.count \n\nprint(fruitsCount) \n", "target": "arr = ['apple', 'orange']  \n\ndef setup():\n    println(len(arr))\n"}
{"id": 68108, "name": "Bulls and cows", "source": "Translate Swift to C#: func generateRandomNumArray(numDigits: Int = 4) -> [Character]\n{\n\tguard (1 ... 9).contains(numDigits) else { fatalError(\"number out of range\") }\n\n\treturn Array(\"123456789\".shuffled()[0 ..< numDigits])\n}\n\nfunc parseGuess(_ guess: String, numDigits: Int = 4) -> String?\n{\n\tguard guess.count == numDigits else { return nil }\n    \n\tlet guessArray = guess.filter{ $0.isASCII && $0.isWholeNumber }\n\n  \tguard Set(guessArray).count == numDigits else { return nil }\n\n  \treturn guessArray\n}\n\nfunc pluralIfNeeded(_ count: Int, _ units: String) -> String\n{\n\treturn \"\\(count) \" + units + (count == 1 ? \"\" : \"s\")\n}\n\nvar guessAgain = \"y\"\nwhile guessAgain == \"y\"\n{\n  \tlet num = generateRandomNumArray()\n  \tvar bulls = 0\n  \tvar cows = 0\n\n  \tprint(\"Please enter a 4 digit number with digits between 1-9, no repetitions: \")\n\n  \tif let guessStr = readLine(strippingNewline: true), let guess = parseGuess(guessStr)\n\t{\n\t\tfor (guess, actual) in zip(guess, num)\n\t\t{\n\t\t\tif guess == actual\n\t\t\t{\n\t  \t\t\tbulls += 1\n\t\t\t}\n\t\t\telse if num.contains(guess)\n\t\t\t{\n\t  \t\t\tcows += 1\n\t\t\t}\n  \t\t}\n\n\t\tprint(\"Actual number: \" + num)\n\t\tprint(\"Your score: \\(pluralIfNeeded(bulls, \"bull\")) and \\(pluralIfNeeded(cows, \"cow\"))\\n\")\n\t\tprint(\"Would you like to play again? (y): \")\n\n\t\tguessAgain = readLine(strippingNewline: true)?.lowercased() ?? \"n\"\n\t}\n\telse\n\t{\n\t\tprint(\"Invalid input\")\n  \t}\n}\n", "target": "using System;\n\nnamespace BullsnCows\n{\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            int[] nums = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n            KnuthShuffle<int>(ref nums);\n            int[] chosenNum = new int[4];\n            Array.Copy(nums, chosenNum, 4);\n\n            Console.WriteLine(\"Your Guess\u00a0?\");\n            while (!game(Console.ReadLine(), chosenNum))\n            {\n                Console.WriteLine(\"Your next Guess\u00a0?\");\n            }\n            \n            Console.ReadKey();\n        }\n\n        public static void KnuthShuffle<T>(ref T[] array)\n        {\n            System.Random random = new System.Random();\n            for (int i = 0; i < array.Length; i++)\n            {\n                int j = random.Next(array.Length);\n                T temp = array[i]; array[i] = array[j]; array[j] = temp;\n            }\n        }\n\n        public static bool game(string guess, int[] num)\n        {\n            char[] guessed = guess.ToCharArray();\n            int bullsCount = 0, cowsCount = 0;\n\n            if (guessed.Length != 4)\n            {\n                Console.WriteLine(\"Not a valid guess.\");\n                return false;\n            }\n\n            for (int i = 0; i < 4; i++)\n            {\n                int curguess = (int) char.GetNumericValue(guessed[i]);\n                if (curguess < 1 || curguess > 9)\n                {\n                    Console.WriteLine(\"Digit must be ge greater 0 and lower 10.\");\n                    return false;\n                }\n                if (curguess == num[i])\n                {\n                    bullsCount++;\n                }\n                else\n                {\n                    for (int j = 0; j < 4; j++)\n                    {\n                        if (curguess == num[j])\n                            cowsCount++;\n                    }\n                }\n            }\n\n            if (bullsCount == 4)\n            {\n                Console.WriteLine(\"Congratulations! You have won!\");\n                return true;\n            }\n            else\n            {\n                Console.WriteLine(\"Your Score is {0} bulls and {1} cows\", bullsCount, cowsCount);\n                return false;\n            }\n        }\n    }\n}\n"}
{"id": 68110, "name": "Bulls and cows", "source": "Translate Swift to Java: func generateRandomNumArray(numDigits: Int = 4) -> [Character]\n{\n\tguard (1 ... 9).contains(numDigits) else { fatalError(\"number out of range\") }\n\n\treturn Array(\"123456789\".shuffled()[0 ..< numDigits])\n}\n\nfunc parseGuess(_ guess: String, numDigits: Int = 4) -> String?\n{\n\tguard guess.count == numDigits else { return nil }\n    \n\tlet guessArray = guess.filter{ $0.isASCII && $0.isWholeNumber }\n\n  \tguard Set(guessArray).count == numDigits else { return nil }\n\n  \treturn guessArray\n}\n\nfunc pluralIfNeeded(_ count: Int, _ units: String) -> String\n{\n\treturn \"\\(count) \" + units + (count == 1 ? \"\" : \"s\")\n}\n\nvar guessAgain = \"y\"\nwhile guessAgain == \"y\"\n{\n  \tlet num = generateRandomNumArray()\n  \tvar bulls = 0\n  \tvar cows = 0\n\n  \tprint(\"Please enter a 4 digit number with digits between 1-9, no repetitions: \")\n\n  \tif let guessStr = readLine(strippingNewline: true), let guess = parseGuess(guessStr)\n\t{\n\t\tfor (guess, actual) in zip(guess, num)\n\t\t{\n\t\t\tif guess == actual\n\t\t\t{\n\t  \t\t\tbulls += 1\n\t\t\t}\n\t\t\telse if num.contains(guess)\n\t\t\t{\n\t  \t\t\tcows += 1\n\t\t\t}\n  \t\t}\n\n\t\tprint(\"Actual number: \" + num)\n\t\tprint(\"Your score: \\(pluralIfNeeded(bulls, \"bull\")) and \\(pluralIfNeeded(cows, \"cow\"))\\n\")\n\t\tprint(\"Would you like to play again? (y): \")\n\n\t\tguessAgain = readLine(strippingNewline: true)?.lowercased() ?? \"n\"\n\t}\n\telse\n\t{\n\t\tprint(\"Invalid input\")\n  \t}\n}\n", "target": "import java.util.InputMismatchException;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class BullsAndCows{\n\tpublic static void main(String[] args){\n\t\tRandom gen= new Random();\n\t\tint target;\n\t\twhile(hasDupes(target= (gen.nextInt(9000) + 1000)));\n\t\tString targetStr = target +\"\";\n\t\tboolean guessed = false;\n\t\tScanner input = new Scanner(System.in);\n\t\tint guesses = 0;\n\t\tdo{\n\t\t\tint bulls = 0;\n\t\t\tint cows = 0;\n\t\t\tSystem.out.print(\"Guess a 4-digit number with no duplicate digits: \");\n\t\t\tint guess;\n\t\t\ttry{\n\t\t\t\tguess = input.nextInt();\n\t\t\t\tif(hasDupes(guess) || guess < 1000) continue;\n\t\t\t}catch(InputMismatchException e){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tguesses++;\n\t\t\tString guessStr = guess + \"\";\n\t\t\tfor(int i= 0;i < 4;i++){\n\t\t\t\tif(guessStr.charAt(i) == targetStr.charAt(i)){\n\t\t\t\t\tbulls++;\n\t\t\t\t}else if(targetStr.contains(guessStr.charAt(i)+\"\")){\n\t\t\t\t\tcows++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bulls == 4){\n\t\t\t\tguessed = true;\n\t\t\t}else{\n\t\t\t\tSystem.out.println(cows+\" Cows and \"+bulls+\" Bulls.\");\n\t\t\t}\n\t\t}while(!guessed);\n\t\tSystem.out.println(\"You won after \"+guesses+\" guesses!\");\n\t}\n\n\tpublic static boolean hasDupes(int num){\n\t\tboolean[] digs = new boolean[10];\n\t\twhile(num > 0){\n\t\t\tif(digs[num%10]) return true;\n\t\t\tdigs[num%10] = true;\n\t\t\tnum/= 10;\n\t\t}\n\t\treturn false;\n\t}\n}\n"}
{"id": 68111, "name": "Bulls and cows", "source": "Translate Swift to Python: func generateRandomNumArray(numDigits: Int = 4) -> [Character]\n{\n\tguard (1 ... 9).contains(numDigits) else { fatalError(\"number out of range\") }\n\n\treturn Array(\"123456789\".shuffled()[0 ..< numDigits])\n}\n\nfunc parseGuess(_ guess: String, numDigits: Int = 4) -> String?\n{\n\tguard guess.count == numDigits else { return nil }\n    \n\tlet guessArray = guess.filter{ $0.isASCII && $0.isWholeNumber }\n\n  \tguard Set(guessArray).count == numDigits else { return nil }\n\n  \treturn guessArray\n}\n\nfunc pluralIfNeeded(_ count: Int, _ units: String) -> String\n{\n\treturn \"\\(count) \" + units + (count == 1 ? \"\" : \"s\")\n}\n\nvar guessAgain = \"y\"\nwhile guessAgain == \"y\"\n{\n  \tlet num = generateRandomNumArray()\n  \tvar bulls = 0\n  \tvar cows = 0\n\n  \tprint(\"Please enter a 4 digit number with digits between 1-9, no repetitions: \")\n\n  \tif let guessStr = readLine(strippingNewline: true), let guess = parseGuess(guessStr)\n\t{\n\t\tfor (guess, actual) in zip(guess, num)\n\t\t{\n\t\t\tif guess == actual\n\t\t\t{\n\t  \t\t\tbulls += 1\n\t\t\t}\n\t\t\telse if num.contains(guess)\n\t\t\t{\n\t  \t\t\tcows += 1\n\t\t\t}\n  \t\t}\n\n\t\tprint(\"Actual number: \" + num)\n\t\tprint(\"Your score: \\(pluralIfNeeded(bulls, \"bull\")) and \\(pluralIfNeeded(cows, \"cow\"))\\n\")\n\t\tprint(\"Would you like to play again? (y): \")\n\n\t\tguessAgain = readLine(strippingNewline: true)?.lowercased() ?? \"n\"\n\t}\n\telse\n\t{\n\t\tprint(\"Invalid input\")\n  \t}\n}\n", "target": "\n\nimport random\n\ndigits = '123456789'\nsize = 4\nchosen = ''.join(random.sample(digits,size))\n\nprint  % (size, size)\nguesses = 0\nwhile True:\n    guesses += 1\n    while True:\n        \n        guess = raw_input('\\nNext guess [%i]: ' % guesses).strip()\n        if len(guess) == size and \\\n           all(char in digits for char in guess) \\\n           and len(set(guess)) == size:\n            break\n        print \"Problem, try again. You need to enter %i unique digits from 1 to 9\" % size\n    if guess == chosen:\n        print '\\nCongratulations you guessed correctly in',guesses,'attempts'\n        break\n    bulls = cows = 0\n    for i in range(size):\n        if guess[i] == chosen[i]:\n            bulls += 1\n        elif guess[i] in chosen:\n            cows += 1\n    print '  %i Bulls\\n  %i Cows' % (bulls, cows)\n"}
{"id": 68287, "name": "Chowla numbers", "source": "Translate Swift to C#: import Foundation\n\n@inlinable\npublic func chowla<T: BinaryInteger>(n: T) -> T {\n  stride(from: 2, to: T(Double(n).squareRoot()+1), by: 1)\n    .lazy\n    .filter({ n % $0 == 0 })\n    .reduce(0, {(s: T, m: T) in\n      m*m == n ? s + m : s + m + (n / m)\n    })\n}\n\nextension Dictionary where Key == ClosedRange<Int> {\n  subscript(n: Int) -> Value {\n    get {\n      guard let key = keys.first(where: { $0.contains(n) }) else {\n        fatalError(\"dict does not contain range for \\(n)\")\n      }\n\n      return self[key]!\n    }\n\n    set {\n      guard let key = keys.first(where: { $0.contains(n) }) else {\n        fatalError(\"dict does not contain range for \\(n)\")\n      }\n\n      self[key] = newValue\n    }\n  }\n}\n\nlet lock = DispatchSemaphore(value: 1)\n\nvar perfect = [Int]()\nvar primeCounts = [\n  1...100: 0,\n  101...1_000: 0,\n  1_001...10_000: 0,\n  10_001...100_000: 0,\n  100_001...1_000_000: 0,\n  1_000_001...10_000_000: 0\n]\n\nfor i in 1...37 {\n  print(\"chowla(\\(i)) = \\(chowla(n: i))\")\n}\n\nDispatchQueue.concurrentPerform(iterations: 35_000_000) {i in\n  let chowled = chowla(n: i)\n\n  if chowled == 0 && i > 1 && i < 10_000_000 {\n    lock.wait()\n    primeCounts[i] += 1\n    lock.signal()\n  }\n\n  if chowled == i - 1 && i > 1 {\n    lock.wait()\n    perfect.append(i)\n    lock.signal()\n  }\n}\n\nlet numPrimes = primeCounts\n  .sorted(by: { $0.key.lowerBound < $1.key.lowerBound })\n  .reduce(into: [(Int, Int)](), {counts, oneCount in\n    guard !counts.isEmpty else {\n      counts.append((oneCount.key.upperBound, oneCount.value))\n\n      return\n    }\n\n    counts.append((oneCount.key.upperBound, counts.last!.1 + oneCount.value))\n  })\n\nfor (upper, count) in numPrimes {\n  print(\"Number of primes < \\(upper) = \\(count)\")\n}\n\nfor p in perfect {\n  print(\"\\(p) is a perfect number\")\n}\n", "target": "using System;\n\nnamespace chowla_cs\n{\n    class Program\n    {\n        static int chowla(int n)\n        {\n            int sum = 0;\n            for (int i = 2, j; i * i <= n; i++)\n                if (n % i == 0) sum += i + (i == (j = n / i) ? 0 : j);\n            return sum;\n        }\n\n        static bool[] sieve(int limit)\n        {\n            \n            \n            bool[] c = new bool[limit];\n            for (int i = 3; i * 3 < limit; i += 2)\n                if (!c[i] && (chowla(i) == 0))\n                    for (int j = 3 * i; j < limit; j += 2 * i)\n                        c[j] = true;\n            return c;\n        }\n\n        static void Main(string[] args)\n        {\n            for (int i = 1; i <= 37; i++)\n                Console.WriteLine(\"chowla({0}) = {1}\", i, chowla(i));\n            int count = 1, limit = (int)(1e7), power = 100;\n            bool[] c = sieve(limit);\n            for (int i = 3; i < limit; i += 2)\n            {\n                if (!c[i]) count++;\n                if (i == power - 1)\n                {\n                    Console.WriteLine(\"Count of primes up to {0,10:n0} = {1:n0}\", power, count);\n                    power *= 10;\n                }\n            }\n\n            count = 0; limit = 35000000;\n            int k = 2, kk = 3, p;\n            for (int i = 2; ; i++)\n            {\n                if ((p = k * kk) > limit) break;\n                if (chowla(p) == p - 1)\n                {\n                    Console.WriteLine(\"{0,10:n0} is a number that is perfect\", p);\n                    count++;\n                }\n                k = kk + 1; kk += k;\n            }\n            Console.WriteLine(\"There are {0} perfect numbers <= 35,000,000\", count);\n            if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 68289, "name": "Chowla numbers", "source": "Translate Swift to Java: import Foundation\n\n@inlinable\npublic func chowla<T: BinaryInteger>(n: T) -> T {\n  stride(from: 2, to: T(Double(n).squareRoot()+1), by: 1)\n    .lazy\n    .filter({ n % $0 == 0 })\n    .reduce(0, {(s: T, m: T) in\n      m*m == n ? s + m : s + m + (n / m)\n    })\n}\n\nextension Dictionary where Key == ClosedRange<Int> {\n  subscript(n: Int) -> Value {\n    get {\n      guard let key = keys.first(where: { $0.contains(n) }) else {\n        fatalError(\"dict does not contain range for \\(n)\")\n      }\n\n      return self[key]!\n    }\n\n    set {\n      guard let key = keys.first(where: { $0.contains(n) }) else {\n        fatalError(\"dict does not contain range for \\(n)\")\n      }\n\n      self[key] = newValue\n    }\n  }\n}\n\nlet lock = DispatchSemaphore(value: 1)\n\nvar perfect = [Int]()\nvar primeCounts = [\n  1...100: 0,\n  101...1_000: 0,\n  1_001...10_000: 0,\n  10_001...100_000: 0,\n  100_001...1_000_000: 0,\n  1_000_001...10_000_000: 0\n]\n\nfor i in 1...37 {\n  print(\"chowla(\\(i)) = \\(chowla(n: i))\")\n}\n\nDispatchQueue.concurrentPerform(iterations: 35_000_000) {i in\n  let chowled = chowla(n: i)\n\n  if chowled == 0 && i > 1 && i < 10_000_000 {\n    lock.wait()\n    primeCounts[i] += 1\n    lock.signal()\n  }\n\n  if chowled == i - 1 && i > 1 {\n    lock.wait()\n    perfect.append(i)\n    lock.signal()\n  }\n}\n\nlet numPrimes = primeCounts\n  .sorted(by: { $0.key.lowerBound < $1.key.lowerBound })\n  .reduce(into: [(Int, Int)](), {counts, oneCount in\n    guard !counts.isEmpty else {\n      counts.append((oneCount.key.upperBound, oneCount.value))\n\n      return\n    }\n\n    counts.append((oneCount.key.upperBound, counts.last!.1 + oneCount.value))\n  })\n\nfor (upper, count) in numPrimes {\n  print(\"Number of primes < \\(upper) = \\(count)\")\n}\n\nfor p in perfect {\n  print(\"\\(p) is a perfect number\")\n}\n", "target": "public class Chowla {\n\n    public static void main(String[] args) {\n        int[] chowlaNumbers = findChowlaNumbers(37);\n        for (int i = 0; i < chowlaNumbers.length; i++) {\n            System.out.printf(\"chowla(%d) = %d%n\", (i+1), chowlaNumbers[i]);\n        }\n        System.out.println();\n\n        int[][] primes = countPrimes(100, 10_000_000);\n        for (int i = 0; i < primes.length; i++) {\n            System.out.printf(Locale.US, \"There is\u00a0%,d primes up to\u00a0%,d%n\", primes[i][1], primes[i][0]);\n        }\n        System.out.println();\n\n        int[] perfectNumbers = findPerfectNumbers(35_000_000);\n        for (int i = 0; i < perfectNumbers.length; i++) {\n            System.out.printf(\"%d is a perfect number%n\", perfectNumbers[i]);\n        }\n        System.out.printf(Locale.US, \"There are %d perfect numbers <\u00a0%,d%n\", perfectNumbers.length, 35_000_000);\n    }\n\n    public static int chowla(int n) {\n        if (n < 0) throw new IllegalArgumentException(\"n is not positive\");\n        int sum = 0;\n        for (int i = 2, j; i * i <= n; i++)\n            if (n % i == 0) sum += i + (i == (j = n / i) ? 0 : j);\n        return sum;\n    }\n\n    protected static int[][] countPrimes(int power, int limit) {\n        int count = 0;\n        int[][] num = new int[countMultiplicity(limit, power)][2];\n        for (int n = 2, i=0;  n <= limit; n++) {\n            if (chowla(n) == 0) count++;\n            if (n % power == 0) {\n                num[i][0] = power;\n                num[i][1] = count;\n                i++;\n                power *= 10;\n            }\n        }\n        return num;\n    }\n\n    protected static int countMultiplicity(int limit, int start) {\n        int count = 0;\n        int cur = limit;\n        while(cur >= start) {\n            count++;\n            cur = cur/10;\n        }\n        return count;\n    }\n\n    protected static int[] findChowlaNumbers(int limit) {\n        int[] num = new int[limit];\n        for (int i = 0; i < limit; i++) {\n            num[i] = chowla(i+1);\n        }\n        return num;\n    }\n\n    protected static int[] findPerfectNumbers(int limit) {\n        int count = 0;\n        int[] num = new int[count];\n\n        int k = 2, kk = 3, p;\n        while ((p = k * kk) < limit) {\n            if (chowla(p) == p - 1) {\n                num = increaseArr(num);\n                num[count++] = p;\n            }\n            k = kk + 1;\n            kk += k;\n        }\n        return num;\n    }\n\n    private static int[] increaseArr(int[] arr) {\n        int[] tmp = new int[arr.length + 1];\n        System.arraycopy(arr, 0, tmp, 0, arr.length);\n        return tmp;\n    }\n}\n"}
{"id": 68290, "name": "Chowla numbers", "source": "Translate Swift to Python: import Foundation\n\n@inlinable\npublic func chowla<T: BinaryInteger>(n: T) -> T {\n  stride(from: 2, to: T(Double(n).squareRoot()+1), by: 1)\n    .lazy\n    .filter({ n % $0 == 0 })\n    .reduce(0, {(s: T, m: T) in\n      m*m == n ? s + m : s + m + (n / m)\n    })\n}\n\nextension Dictionary where Key == ClosedRange<Int> {\n  subscript(n: Int) -> Value {\n    get {\n      guard let key = keys.first(where: { $0.contains(n) }) else {\n        fatalError(\"dict does not contain range for \\(n)\")\n      }\n\n      return self[key]!\n    }\n\n    set {\n      guard let key = keys.first(where: { $0.contains(n) }) else {\n        fatalError(\"dict does not contain range for \\(n)\")\n      }\n\n      self[key] = newValue\n    }\n  }\n}\n\nlet lock = DispatchSemaphore(value: 1)\n\nvar perfect = [Int]()\nvar primeCounts = [\n  1...100: 0,\n  101...1_000: 0,\n  1_001...10_000: 0,\n  10_001...100_000: 0,\n  100_001...1_000_000: 0,\n  1_000_001...10_000_000: 0\n]\n\nfor i in 1...37 {\n  print(\"chowla(\\(i)) = \\(chowla(n: i))\")\n}\n\nDispatchQueue.concurrentPerform(iterations: 35_000_000) {i in\n  let chowled = chowla(n: i)\n\n  if chowled == 0 && i > 1 && i < 10_000_000 {\n    lock.wait()\n    primeCounts[i] += 1\n    lock.signal()\n  }\n\n  if chowled == i - 1 && i > 1 {\n    lock.wait()\n    perfect.append(i)\n    lock.signal()\n  }\n}\n\nlet numPrimes = primeCounts\n  .sorted(by: { $0.key.lowerBound < $1.key.lowerBound })\n  .reduce(into: [(Int, Int)](), {counts, oneCount in\n    guard !counts.isEmpty else {\n      counts.append((oneCount.key.upperBound, oneCount.value))\n\n      return\n    }\n\n    counts.append((oneCount.key.upperBound, counts.last!.1 + oneCount.value))\n  })\n\nfor (upper, count) in numPrimes {\n  print(\"Number of primes < \\(upper) = \\(count)\")\n}\n\nfor p in perfect {\n  print(\"\\(p) is a perfect number\")\n}\n", "target": "\nfrom sympy import divisors\n\ndef chowla(n):\n    return 0 if n < 2 else sum(divisors(n, generator=True)) - 1 -n\n\ndef is_prime(n):\n    return chowla(n) == 0\n\ndef primes_to(n):\n    return sum(chowla(i) == 0 for i in range(2, n))\n\ndef perfect_between(n, m):\n    c = 0\n    print(f\"\\nPerfect numbers between [{n:_}, {m:_})\")\n    for i in range(n, m):\n        if i > 1 and chowla(i) == i - 1:\n            print(f\"  {i:_}\")\n            c += 1\n    print(f\"Found {c} Perfect numbers between [{n:_}, {m:_})\")\n    \n\nif __name__ == '__main__':\n    for i in range(1, 38):\n        print(f\"chowla({i:2}) == {chowla(i)}\")\n    for i in range(2, 6):\n        print(f\"primes_to({10**i:_}) == {primes_to(10**i):_}\")\n    perfect_between(1, 1_000_000)\n    print()\n    for i in range(6, 8):\n        print(f\"primes_to({10**i:_}) == {primes_to(10**i):_}\")\n    perfect_between(1_000_000, 35_000_000)\n"}
{"id": 68686, "name": "Accumulator factory", "source": "Translate Swift to C#: func makeAccumulator(var sum: Double) -> Double -> Double {\n  return {\n    sum += $0\n    return sum\n  }\n}\n\nlet x = makeAccumulator(1)\nx(5)\nlet _ = makeAccumulator(3)\nprintln(x(2.3))\n", "target": "using System;\n\nclass Program\n{\n    static Func<dynamic, dynamic> Foo(dynamic n)\n    {\n        return i => n += i;\n    }\n\n    static void Main(string[] args)\n    {\n        var x = Foo(1);\n        x(5);\n        Foo(3);\n        Console.WriteLine(x(2.3));\n    }\n}\n"}
{"id": 68687, "name": "Accumulator factory", "source": "Translate Swift to C#: func makeAccumulator(var sum: Double) -> Double -> Double {\n  return {\n    sum += $0\n    return sum\n  }\n}\n\nlet x = makeAccumulator(1)\nx(5)\nlet _ = makeAccumulator(3)\nprintln(x(2.3))\n", "target": "using System;\n\nclass Program\n{\n    static Func<dynamic, dynamic> Foo(dynamic n)\n    {\n        return i => n += i;\n    }\n\n    static void Main(string[] args)\n    {\n        var x = Foo(1);\n        x(5);\n        Foo(3);\n        Console.WriteLine(x(2.3));\n    }\n}\n"}
{"id": 68690, "name": "Accumulator factory", "source": "Translate Swift to Java: func makeAccumulator(var sum: Double) -> Double -> Double {\n  return {\n    sum += $0\n    return sum\n  }\n}\n\nlet x = makeAccumulator(1)\nx(5)\nlet _ = makeAccumulator(3)\nprintln(x(2.3))\n", "target": "public class Accumulator\n    \n{\n    private Number sum;\n\n    public Accumulator(Number sum0) {\n\tsum = sum0;\n    }\n\n    public Number apply(Number n) {\n\t\n\t\n\treturn (longable(sum) && longable(n)) ?\n\t    (sum = sum.longValue() + n.longValue()) :\n\t    (sum = sum.doubleValue() + n.doubleValue());\n    }\n\n    private static boolean longable(Number n) {\n\treturn n instanceof Byte || n instanceof Short ||\n\t    n instanceof Integer || n instanceof Long;\n    }\n\n    public static void main(String[] args) {\n\tAccumulator x = new Accumulator(1);\n\tx.apply(5);\n\tnew Accumulator(3);\n\tSystem.out.println(x.apply(2.3));\n    }\n}\n"}
{"id": 68691, "name": "Accumulator factory", "source": "Translate Swift to Java: func makeAccumulator(var sum: Double) -> Double -> Double {\n  return {\n    sum += $0\n    return sum\n  }\n}\n\nlet x = makeAccumulator(1)\nx(5)\nlet _ = makeAccumulator(3)\nprintln(x(2.3))\n", "target": "public class Accumulator\n    \n{\n    private Number sum;\n\n    public Accumulator(Number sum0) {\n\tsum = sum0;\n    }\n\n    public Number apply(Number n) {\n\t\n\t\n\treturn (longable(sum) && longable(n)) ?\n\t    (sum = sum.longValue() + n.longValue()) :\n\t    (sum = sum.doubleValue() + n.doubleValue());\n    }\n\n    private static boolean longable(Number n) {\n\treturn n instanceof Byte || n instanceof Short ||\n\t    n instanceof Integer || n instanceof Long;\n    }\n\n    public static void main(String[] args) {\n\tAccumulator x = new Accumulator(1);\n\tx.apply(5);\n\tnew Accumulator(3);\n\tSystem.out.println(x.apply(2.3));\n    }\n}\n"}
{"id": 68692, "name": "Accumulator factory", "source": "Translate Swift to Python: func makeAccumulator(var sum: Double) -> Double -> Double {\n  return {\n    sum += $0\n    return sum\n  }\n}\n\nlet x = makeAccumulator(1)\nx(5)\nlet _ = makeAccumulator(3)\nprintln(x(2.3))\n", "target": "fun accumulator(var sum): :: Real -> _\n    n => sum += n\n\nlet f = accumulator!(5)\nprint f(5)   \nprint f(10)  \nprint f(2.4) \n"}
{"id": 68693, "name": "Accumulator factory", "source": "Translate Swift to Python: func makeAccumulator(var sum: Double) -> Double -> Double {\n  return {\n    sum += $0\n    return sum\n  }\n}\n\nlet x = makeAccumulator(1)\nx(5)\nlet _ = makeAccumulator(3)\nprintln(x(2.3))\n", "target": "fun accumulator(var sum): :: Real -> _\n    n => sum += n\n\nlet f = accumulator!(5)\nprint f(5)   \nprint f(10)  \nprint f(2.4) \n"}
{"id": 69384, "name": "Averages_Root mean square", "source": "Translate Swift to C#: extension Collection where Element: FloatingPoint {\n  @inlinable\n  public func rms() -> Element {\n    return (lazy.map({ $0 * $0 }).reduce(0, +) / Element(count)).squareRoot()\n  }\n}\n\nprint(\"RMS of 1...10: \\((1...10).map(Double.init).rms())\")\n", "target": "using System;\n\nnamespace rms\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] x = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            Console.WriteLine(rootMeanSquare(x));\n        }\n\n        private static double rootMeanSquare(int[] x)\n        {            \n            double sum = 0;\n            for (int i = 0; i < x.Length; i++)\n            {\n                sum += (x[i]*x[i]);\n            }\n            return Math.Sqrt(sum / x.Length);\n        }\n    }\n}\n"}
{"id": 69385, "name": "Averages_Root mean square", "source": "Translate Swift to C#: extension Collection where Element: FloatingPoint {\n  @inlinable\n  public func rms() -> Element {\n    return (lazy.map({ $0 * $0 }).reduce(0, +) / Element(count)).squareRoot()\n  }\n}\n\nprint(\"RMS of 1...10: \\((1...10).map(Double.init).rms())\")\n", "target": "using System;\n\nnamespace rms\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] x = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            Console.WriteLine(rootMeanSquare(x));\n        }\n\n        private static double rootMeanSquare(int[] x)\n        {            \n            double sum = 0;\n            for (int i = 0; i < x.Length; i++)\n            {\n                sum += (x[i]*x[i]);\n            }\n            return Math.Sqrt(sum / x.Length);\n        }\n    }\n}\n"}
{"id": 69388, "name": "Averages_Root mean square", "source": "Translate Swift to Java: extension Collection where Element: FloatingPoint {\n  @inlinable\n  public func rms() -> Element {\n    return (lazy.map({ $0 * $0 }).reduce(0, +) / Element(count)).squareRoot()\n  }\n}\n\nprint(\"RMS of 1...10: \\((1...10).map(Double.init).rms())\")\n", "target": "public class RootMeanSquare {\n\n    public static double rootMeanSquare(double... nums) {\n        double sum = 0.0;\n        for (double num : nums)\n            sum += num * num;\n        return Math.sqrt(sum / nums.length);\n    }\n\n    public static void main(String[] args) {\n        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        System.out.println(\"The RMS of the numbers from 1 to 10 is \" + rootMeanSquare(nums));\n    }\n}\n"}
{"id": 69389, "name": "Averages_Root mean square", "source": "Translate Swift to Java: extension Collection where Element: FloatingPoint {\n  @inlinable\n  public func rms() -> Element {\n    return (lazy.map({ $0 * $0 }).reduce(0, +) / Element(count)).squareRoot()\n  }\n}\n\nprint(\"RMS of 1...10: \\((1...10).map(Double.init).rms())\")\n", "target": "public class RootMeanSquare {\n\n    public static double rootMeanSquare(double... nums) {\n        double sum = 0.0;\n        for (double num : nums)\n            sum += num * num;\n        return Math.sqrt(sum / nums.length);\n    }\n\n    public static void main(String[] args) {\n        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        System.out.println(\"The RMS of the numbers from 1 to 10 is \" + rootMeanSquare(nums));\n    }\n}\n"}
{"id": 69390, "name": "Averages_Root mean square", "source": "Translate Swift to Python: extension Collection where Element: FloatingPoint {\n  @inlinable\n  public func rms() -> Element {\n    return (lazy.map({ $0 * $0 }).reduce(0, +) / Element(count)).squareRoot()\n  }\n}\n\nprint(\"RMS of 1...10: \\((1...10).map(Double.init).rms())\")\n", "target": "sqrt(mean(x\u00b2))\n"}
{"id": 69391, "name": "Averages_Root mean square", "source": "Translate Swift to Python: extension Collection where Element: FloatingPoint {\n  @inlinable\n  public func rms() -> Element {\n    return (lazy.map({ $0 * $0 }).reduce(0, +) / Element(count)).squareRoot()\n  }\n}\n\nprint(\"RMS of 1...10: \\((1...10).map(Double.init).rms())\")\n", "target": "sqrt(mean(x\u00b2))\n"}
{"id": 69774, "name": "Pi", "source": "Translate Swift to C#: \n\n\n\n\n\n\n\nimport Foundation\n\nvar r = [Int]()\nvar i = 0\nvar k = 2800\nvar b = 0\nvar c = 0\nvar d = 0\n\nfor _ in 0...2800 {\n    r.append(2000);\n}\nwhile k > 0 {\n    d = 0;\n    i = k;\n    while (true) {\n        d = d + r[i] * 10000\n        b = 2 * i - 1\n        r[i] = d % b\n        d = d / b\n        i = i - 1\n        if i == 0 {\n            break;\n        }\n        d = d * i;\n    }\n    print(c +  d / 10000, \"\")\n    c = d % 10000\n    k = k - 14\n}\n", "target": "using System;\nusing System.Numerics;\n\nnamespace PiCalc {\n    internal class Program {\n        private readonly BigInteger FOUR = new BigInteger(4);\n        private readonly BigInteger SEVEN = new BigInteger(7);\n        private readonly BigInteger TEN = new BigInteger(10);\n        private readonly BigInteger THREE = new BigInteger(3);\n        private readonly BigInteger TWO = new BigInteger(2);\n\n        private BigInteger k = BigInteger.One;\n        private BigInteger l = new BigInteger(3);\n        private BigInteger n = new BigInteger(3);\n        private BigInteger q = BigInteger.One;\n        private BigInteger r = BigInteger.Zero;\n        private BigInteger t = BigInteger.One;\n\n        public void CalcPiDigits() {\n            BigInteger nn, nr;\n            bool first = true;\n            while (true) {\n                if ((FOUR*q + r - t).CompareTo(n*t) == -1) {\n                    Console.Write(n);\n                    if (first) {\n                        Console.Write(\".\");\n                        first = false;\n                    }\n                    nr = TEN*(r - (n*t));\n                    n = TEN*(THREE*q + r)/t - (TEN*n);\n                    q *= TEN;\n                    r = nr;\n                } else {\n                    nr = (TWO*q + r)*l;\n                    nn = (q*(SEVEN*k) + TWO + r*l)/(t*l);\n                    q *= k;\n                    t *= l;\n                    l += TWO;\n                    k += BigInteger.One;\n                    n = nn;\n                    r = nr;\n                }\n            }\n        }\n\n        private static void Main(string[] args) {\n            new Program().CalcPiDigits();\n        }\n    }\n}\n"}
{"id": 69776, "name": "Pi", "source": "Translate Swift to Java: \n\n\n\n\n\n\n\nimport Foundation\n\nvar r = [Int]()\nvar i = 0\nvar k = 2800\nvar b = 0\nvar c = 0\nvar d = 0\n\nfor _ in 0...2800 {\n    r.append(2000);\n}\nwhile k > 0 {\n    d = 0;\n    i = k;\n    while (true) {\n        d = d + r[i] * 10000\n        b = 2 * i - 1\n        r[i] = d % b\n        d = d / b\n        i = i - 1\n        if i == 0 {\n            break;\n        }\n        d = d * i;\n    }\n    print(c +  d / 10000, \"\")\n    c = d % 10000\n    k = k - 14\n}\n", "target": "import java.math.BigInteger ;\n\npublic class Pi {\n  final BigInteger TWO = BigInteger.valueOf(2) ;\n  final BigInteger THREE = BigInteger.valueOf(3) ;\n  final BigInteger FOUR = BigInteger.valueOf(4) ;\n  final BigInteger SEVEN = BigInteger.valueOf(7) ;\n\n  BigInteger q = BigInteger.ONE ;\n  BigInteger r = BigInteger.ZERO ;\n  BigInteger t = BigInteger.ONE ;\n  BigInteger k = BigInteger.ONE ;\n  BigInteger n = BigInteger.valueOf(3) ;\n  BigInteger l = BigInteger.valueOf(3) ;\n\n  public void calcPiDigits(){\n    BigInteger nn, nr ;\n    boolean first = true ;\n    while(true){\n        if(FOUR.multiply(q).add(r).subtract(t).compareTo(n.multiply(t)) == -1){\n          System.out.print(n) ;\n          if(first){System.out.print(\".\") ; first = false ;}\n          nr = BigInteger.TEN.multiply(r.subtract(n.multiply(t))) ;\n          n = BigInteger.TEN.multiply(THREE.multiply(q).add(r)).divide(t).subtract(BigInteger.TEN.multiply(n)) ;\n          q = q.multiply(BigInteger.TEN) ;\n          r = nr ;\n          System.out.flush() ;\n        }else{\n          nr = TWO.multiply(q).add(r).multiply(l) ;\n          nn = q.multiply((SEVEN.multiply(k))).add(TWO).add(r.multiply(l)).divide(t.multiply(l)) ;\n          q = q.multiply(k) ;\n          t = t.multiply(l) ;\n          l = l.add(TWO) ;\n          k = k.add(BigInteger.ONE) ;\n          n = nn ;\n          r = nr ;\n        }\n    }\n  }\n\n  public static void main(String[] args) {\n    Pi p = new Pi() ;\n    p.calcPiDigits() ;\n  }\n}\n"}
{"id": 69777, "name": "Pi", "source": "Translate Swift to Python: \n\n\n\n\n\n\n\nimport Foundation\n\nvar r = [Int]()\nvar i = 0\nvar k = 2800\nvar b = 0\nvar c = 0\nvar d = 0\n\nfor _ in 0...2800 {\n    r.append(2000);\n}\nwhile k > 0 {\n    d = 0;\n    i = k;\n    while (true) {\n        d = d + r[i] * 10000\n        b = 2 * i - 1\n        r[i] = d % b\n        d = d / b\n        i = i - 1\n        if i == 0 {\n            break;\n        }\n        d = d * i;\n    }\n    print(c +  d / 10000, \"\")\n    c = d % 10000\n    k = k - 14\n}\n", "target": "def calcPi():\n    q, r, t, k, n, l = 1, 0, 1, 1, 3, 3\n    while True:\n        if 4*q+r-t < n*t:\n            yield n\n            nr = 10*(r-n*t)\n            n  = ((10*(3*q+r))//t)-10*n\n            q  *= 10\n            r  = nr\n        else:\n            nr = (2*q+r)*l\n            nn = (q*(7*k)+2+(r*l))//(t*l)\n            q  *= k\n            t  *= l\n            l  += 2\n            k += 1\n            n  = nn\n            r  = nr\n\nimport sys\npi_digits = calcPi()\ni = 0\nfor d in pi_digits:\n    sys.stdout.write(str(d))\n    i += 1\n    if i == 40: print(\"\"); i = 0\n"}
{"id": 70339, "name": "Loops_Foreach", "source": "Translate Swift to C#: for i in [1,2,3] {\n   print(i)\n}\n", "target": "string[] things = {\"Apple\", \"Banana\", \"Coconut\"};\n\nforeach (string thing in things)\n{\n    Console.WriteLine(thing);\n}\n"}
{"id": 70341, "name": "Loops_Foreach", "source": "Translate Swift to Java: for i in [1,2,3] {\n   print(i)\n}\n", "target": "module LoopForEach\n    {\n    @Inject Console console;\n    void run()\n        {\n        val vals = [10, 20, 30, 40];\n        console.print(\"Array of values:\");\n        Loop: for (val val : vals)\n            {\n            console.print($\"  value #{Loop.count + 1}: {val}\");\n            }\n\n        Map<String, Int> pairs = [\"x\"=42, \"y\"=69];\n        console.print(\"\\nKeys and values:\");\n        for ((String key, Int val) : pairs)\n            {\n            console.print($\"  {key}={val}\");\n            }\n        console.print(\"\\nJust the keys:\");\n        Loop: for (String key : pairs)\n            {\n            console.print($\"  key #{Loop.count + 1}: {key}\");\n            }\n\n        console.print(\"\\nValues from a range:\");\n        for (Int n : 1..5)\n            {\n            console.print($\"  {n}\");\n            }\n        }\n    }\n"}
{"id": 71363, "name": "Order two numerical lists", "source": "Translate Swift to C#: let a = [1,2,1,3,2]\nlet b = [1,2,0,4,4,0,0,0]\nprintln(lexicographicalCompare(a, b)) \n", "target": "namespace RosettaCode.OrderTwoNumericalLists\n{\n    using System;\n    using System.Collections.Generic;\n\n    internal static class Program\n    {\n        private static bool IsLessThan(this IEnumerable<int> enumerable,\n            IEnumerable<int> otherEnumerable)\n        {\n            using (\n                IEnumerator<int> enumerator = enumerable.GetEnumerator(),\n                    otherEnumerator = otherEnumerable.GetEnumerator())\n            {\n                while (true)\n                {\n                    if (!otherEnumerator.MoveNext())\n                    {\n                        return false;\n                    }\n\n                    if (!enumerator.MoveNext())\n                    {\n                        return true;\n                    }\n\n                    if (enumerator.Current == otherEnumerator.Current)\n                    {\n                        continue;\n                    }\n\n                    return enumerator.Current < otherEnumerator.Current;\n                }\n            }\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                new[] {1, 2, 1, 3, 2}.IsLessThan(new[] {1, 2, 0, 4, 4, 0, 0, 0}));\n        }\n    }\n}\n"}
{"id": 71364, "name": "Order two numerical lists", "source": "Translate Swift to C#: let a = [1,2,1,3,2]\nlet b = [1,2,0,4,4,0,0,0]\nprintln(lexicographicalCompare(a, b)) \n", "target": "namespace RosettaCode.OrderTwoNumericalLists\n{\n    using System;\n    using System.Collections.Generic;\n\n    internal static class Program\n    {\n        private static bool IsLessThan(this IEnumerable<int> enumerable,\n            IEnumerable<int> otherEnumerable)\n        {\n            using (\n                IEnumerator<int> enumerator = enumerable.GetEnumerator(),\n                    otherEnumerator = otherEnumerable.GetEnumerator())\n            {\n                while (true)\n                {\n                    if (!otherEnumerator.MoveNext())\n                    {\n                        return false;\n                    }\n\n                    if (!enumerator.MoveNext())\n                    {\n                        return true;\n                    }\n\n                    if (enumerator.Current == otherEnumerator.Current)\n                    {\n                        continue;\n                    }\n\n                    return enumerator.Current < otherEnumerator.Current;\n                }\n            }\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                new[] {1, 2, 1, 3, 2}.IsLessThan(new[] {1, 2, 0, 4, 4, 0, 0, 0}));\n        }\n    }\n}\n"}
{"id": 71367, "name": "Order two numerical lists", "source": "Translate Swift to Java: let a = [1,2,1,3,2]\nlet b = [1,2,0,4,4,0,0,0]\nprintln(lexicographicalCompare(a, b)) \n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class ListOrder{\n\tpublic static boolean ordered(double[] first, double[] second){\n\t\tif(first.length == 0) return true;\n\t\tif(second.length == 0) return false;\n\t\tif(first[0] == second[0])\n\t\t\treturn ordered(Arrays.copyOfRange(first, 1, first.length),\n\t\t\t\t\tArrays.copyOfRange(second, 1, second.length));\n\t\treturn first[0] < second[0];\n\t}\n\t\n\tpublic static <T extends Comparable<? super T>> boolean ordered(List<T> first, List<T> second){\n\t\tint i = 0;\n\t\tfor(; i < first.size() && i < second.size();i++){\n\t\t\tint cmp = first.get(i).compareTo(second.get(i));\n\t\t\tif(cmp == 0) continue;\n\t\t\tif(cmp < 0) return true;\n\t\t\treturn false;\n\t\t}\n\t\treturn i == first.size();\n\t}\n\t\n\tpublic static boolean ordered2(double[] first, double[] second){\n\t\tint i = 0;\n\t\tfor(; i < first.length && i < second.length;i++){\n\t\t\tif(first[i] == second[i]) continue;\n\t\t\tif(first[i] < second[i]) return true;\n\t\t\treturn false;\n\t\t}\n\t\treturn i == first.length;\n\t}\n}\n"}
{"id": 71368, "name": "Order two numerical lists", "source": "Translate Swift to Java: let a = [1,2,1,3,2]\nlet b = [1,2,0,4,4,0,0,0]\nprintln(lexicographicalCompare(a, b)) \n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class ListOrder{\n\tpublic static boolean ordered(double[] first, double[] second){\n\t\tif(first.length == 0) return true;\n\t\tif(second.length == 0) return false;\n\t\tif(first[0] == second[0])\n\t\t\treturn ordered(Arrays.copyOfRange(first, 1, first.length),\n\t\t\t\t\tArrays.copyOfRange(second, 1, second.length));\n\t\treturn first[0] < second[0];\n\t}\n\t\n\tpublic static <T extends Comparable<? super T>> boolean ordered(List<T> first, List<T> second){\n\t\tint i = 0;\n\t\tfor(; i < first.size() && i < second.size();i++){\n\t\t\tint cmp = first.get(i).compareTo(second.get(i));\n\t\t\tif(cmp == 0) continue;\n\t\t\tif(cmp < 0) return true;\n\t\t\treturn false;\n\t\t}\n\t\treturn i == first.size();\n\t}\n\t\n\tpublic static boolean ordered2(double[] first, double[] second){\n\t\tint i = 0;\n\t\tfor(; i < first.length && i < second.length;i++){\n\t\t\tif(first[i] == second[i]) continue;\n\t\t\tif(first[i] < second[i]) return true;\n\t\t\treturn false;\n\t\t}\n\t\treturn i == first.length;\n\t}\n}\n"}
{"id": 71369, "name": "Order two numerical lists", "source": "Translate Swift to Python: let a = [1,2,1,3,2]\nlet b = [1,2,0,4,4,0,0,0]\nprintln(lexicographicalCompare(a, b)) \n", "target": ">>> [1,2,1,3,2] < [1,2,0,4,4,0,0,0]\nFalse\n"}
{"id": 71370, "name": "Order two numerical lists", "source": "Translate Swift to Python: let a = [1,2,1,3,2]\nlet b = [1,2,0,4,4,0,0,0]\nprintln(lexicographicalCompare(a, b)) \n", "target": ">>> [1,2,1,3,2] < [1,2,0,4,4,0,0,0]\nFalse\n"}
{"id": 71950, "name": "Combinations with repetitions", "source": "Translate Swift to C#: func combosWithRep<T>(var objects: [T], n: Int) -> [[T]] {\n  if n == 0 { return [[]] } else {\n    var combos = [[T]]()\n    while let element = objects.last {\n      combos.appendContentsOf(combosWithRep(objects, n: n - 1).map{ $0 + [element] })\n      objects.removeLast()\n    }\n    return combos\n  }\n}\nprint(combosWithRep([\"iced\", \"jam\", \"plain\"], n: 2).map {$0.joinWithSeparator(\" and \")}.joinWithSeparator(\"\\n\"))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class MultiCombinations\n{\n    private static void Main()\n    {\n        var set = new List<string> { \"iced\", \"jam\", \"plain\" };\n        var combinations = GenerateCombinations(set, 2);\n\n        foreach (var combination in combinations)\n        {\n            string combinationStr = string.Join(\" \", combination);\n            Console.WriteLine(combinationStr);\n        }\n\n        var donuts = Enumerable.Range(1, 10).ToList();\n\n        int donutsCombinationsNumber = GenerateCombinations(donuts, 3).Count;\n\n        Console.WriteLine(\"{0} ways to order 3 donuts given 10 types\", donutsCombinationsNumber);\n    }\n    \n    private static List<List<T>> GenerateCombinations<T>(List<T> combinationList, int k)\n    {\n        var combinations = new List<List<T>>();\n\n        if (k == 0)\n        {\n            var emptyCombination = new List<T>();\n            combinations.Add(emptyCombination);\n\n            return combinations;\n        }\n\n        if (combinationList.Count == 0)\n        {\n            return combinations;\n        }\n\n        T head = combinationList[0];\n        var copiedCombinationList = new List<T>(combinationList);\n        \n        List<List<T>> subcombinations = GenerateCombinations(copiedCombinationList, k - 1);\n\n        foreach (var subcombination in subcombinations)\n        {\n            subcombination.Insert(0, head);\n            combinations.Add(subcombination);\n        }\n\n        combinationList.RemoveAt(0);\n        combinations.AddRange(GenerateCombinations(combinationList, k));\n\n        return combinations;\n    }\n}\n"}
{"id": 71952, "name": "Combinations with repetitions", "source": "Translate Swift to Java: func combosWithRep<T>(var objects: [T], n: Int) -> [[T]] {\n  if n == 0 { return [[]] } else {\n    var combos = [[T]]()\n    while let element = objects.last {\n      combos.appendContentsOf(combosWithRep(objects, n: n - 1).map{ $0 + [element] })\n      objects.removeLast()\n    }\n    return combos\n  }\n}\nprint(combosWithRep([\"iced\", \"jam\", \"plain\"], n: 2).map {$0.joinWithSeparator(\" and \")}.joinWithSeparator(\"\\n\"))\n", "target": "import com.objectwave.utility.*;\n\npublic class MultiCombinationsTester {\n\n    public MultiCombinationsTester() throws CombinatoricException {\n        Object[] objects = {\"iced\", \"jam\", \"plain\"};\n        \n        \n        \n        MultiCombinations mc = new MultiCombinations(objects, 2);\n        while (mc.hasMoreElements()) {\n            for (int i = 0; i < mc.nextElement().length; i++) {\n                System.out.print(mc.nextElement()[i].toString() + \" \");\n            }\n            System.out.println();\n        }\n\n        \n        System.out.println(\"----------\");\n        System.out.println(\"The ways to choose 3 items from 10 with replacement = \" + MultiCombinations.c(10, 3));\n    } \n\n    public static void main(String[] args) throws CombinatoricException {\n        new MultiCombinationsTester();\n    }\n} \n"}
{"id": 71953, "name": "Combinations with repetitions", "source": "Translate Swift to Python: func combosWithRep<T>(var objects: [T], n: Int) -> [[T]] {\n  if n == 0 { return [[]] } else {\n    var combos = [[T]]()\n    while let element = objects.last {\n      combos.appendContentsOf(combosWithRep(objects, n: n - 1).map{ $0 + [element] })\n      objects.removeLast()\n    }\n    return combos\n  }\n}\nprint(combosWithRep([\"iced\", \"jam\", \"plain\"], n: 2).map {$0.joinWithSeparator(\" and \")}.joinWithSeparator(\"\\n\"))\n", "target": ">>> from itertools import combinations_with_replacement\n>>> n, k = 'iced jam plain'.split(), 2\n>>> list(combinations_with_replacement(n,k))\n[('iced', 'iced'), ('iced', 'jam'), ('iced', 'plain'), ('jam', 'jam'), ('jam', 'plain'), ('plain', 'plain')]\n>>> \n>>> len(list(combinations_with_replacement(range(10), 3)))\n220\n>>>\n"}
{"id": 72307, "name": "Multiple distinct objects", "source": "Translate Swift to C#: class Foo { }\n\nvar foos = [Foo]()\nfor i in 0..<n {\n    foos.append(Foo())\n}\n\n\nvar foos_WRONG = [Foo](count: n, repeatedValue: Foo())  \n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nList<Foo> foos = Enumerable.Range(1, n).Select(x => new Foo()).ToList();\n"}
{"id": 72308, "name": "Multiple distinct objects", "source": "Translate Swift to C#: class Foo { }\n\nvar foos = [Foo]()\nfor i in 0..<n {\n    foos.append(Foo())\n}\n\n\nvar foos_WRONG = [Foo](count: n, repeatedValue: Foo())  \n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nList<Foo> foos = Enumerable.Range(1, n).Select(x => new Foo()).ToList();\n"}
{"id": 72311, "name": "Multiple distinct objects", "source": "Translate Swift to Java: class Foo { }\n\nvar foos = [Foo]()\nfor i in 0..<n {\n    foos.append(Foo())\n}\n\n\nvar foos_WRONG = [Foo](count: n, repeatedValue: Foo())  \n", "target": "Foo[] foos = new Foo[n]; \nfor (int i = 0; i < foos.length; i++)\n    foos[i] = new Foo();\n\n\nFoo[] foos_WRONG = new Foo[n];\nArrays.fill(foos, new Foo());  \n"}
{"id": 72312, "name": "Multiple distinct objects", "source": "Translate Swift to Java: class Foo { }\n\nvar foos = [Foo]()\nfor i in 0..<n {\n    foos.append(Foo())\n}\n\n\nvar foos_WRONG = [Foo](count: n, repeatedValue: Foo())  \n", "target": "Foo[] foos = new Foo[n]; \nfor (int i = 0; i < foos.length; i++)\n    foos[i] = new Foo();\n\n\nFoo[] foos_WRONG = new Foo[n];\nArrays.fill(foos, new Foo());  \n"}
{"id": 72313, "name": "Multiple distinct objects", "source": "Translate Swift to Python: class Foo { }\n\nvar foos = [Foo]()\nfor i in 0..<n {\n    foos.append(Foo())\n}\n\n\nvar foos_WRONG = [Foo](count: n, repeatedValue: Foo())  \n", "target": "[Foo()] * n \n"}
{"id": 72314, "name": "Multiple distinct objects", "source": "Translate Swift to Python: class Foo { }\n\nvar foos = [Foo]()\nfor i in 0..<n {\n    foos.append(Foo())\n}\n\n\nvar foos_WRONG = [Foo](count: n, repeatedValue: Foo())  \n", "target": "[Foo()] * n \n"}
{"id": 72858, "name": "Bell numbers", "source": "Translate Swift to C#: public struct BellTriangle<T: BinaryInteger> {\n  @usableFromInline\n  var arr: [T]\n\n  @inlinable\n  public internal(set) subscript(row row: Int, col col: Int) -> T {\n    get { arr[row * (row - 1) / 2 + col] }\n    set { arr[row * (row - 1) / 2 + col] = newValue }\n  }\n\n  @inlinable\n  public init(n: Int) {\n    arr = Array(repeating: 0, count: n * (n + 1) / 2)\n\n    self[row: 1, col: 0] = 1\n\n    for i in 2...n {\n      self[row: i, col: 0] = self[row: i - 1, col: i - 2]\n\n      for j in 1..<i {\n        self[row: i, col: j] = self[row: i, col: j - 1] + self[row: i - 1, col: j - 1]\n      }\n    }\n  }\n}\n\nlet tri = BellTriangle<Int>(n: 15)\n\nprint(\"First 15 Bell numbers:\")\n\nfor i in 1...15 {\n  print(\"\\(i): \\(tri[row: i, col: 0])\")\n}\n\nfor i in 1...10 {\n  print(tri[row: i, col: 0], terminator: \"\")\n\n  for j in 1..<i {\n    print(\", \\(tri[row: i, col: j])\", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "using System;\nusing System.Numerics;\n\nnamespace BellNumbers {\n    public static class Utility {\n        public static void Init<T>(this T[] array, T value) {\n            if (null == array) return;\n            for (int i = 0; i < array.Length; ++i) {\n                array[i] = value;\n            }\n        }\n    }\n\n    class Program {\n        static BigInteger[][] BellTriangle(int n) {\n            BigInteger[][] tri = new BigInteger[n][];\n            for (int i = 0; i < n; ++i) {\n                tri[i] = new BigInteger[i];\n                tri[i].Init(BigInteger.Zero);\n            }\n            tri[1][0] = 1;\n            for (int i = 2; i < n; ++i) {\n                tri[i][0] = tri[i - 1][i - 2];\n                for (int j = 1; j < i; ++j) {\n                    tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1];\n                }\n            }\n            return tri;\n        }\n\n        static void Main(string[] args) {\n            var bt = BellTriangle(51);\n            Console.WriteLine(\"First fifteen and fiftieth Bell numbers:\");\n            for (int i = 1; i < 16; ++i) {\n                Console.WriteLine(\"{0,2}: {1}\", i, bt[i][0]);\n            }\n            Console.WriteLine(\"50: {0}\", bt[50][0]);\n            Console.WriteLine();\n            Console.WriteLine(\"The first ten rows of Bell's triangle:\");\n            for (int i = 1; i < 11; ++i) {\n                \n                var it = bt[i].GetEnumerator();\n                Console.Write(\"[\");\n                if (it.MoveNext()) {\n                    Console.Write(it.Current);\n                }\n                while (it.MoveNext()) {\n                    Console.Write(\", \");\n                    Console.Write(it.Current);\n                }\n                Console.WriteLine(\"]\");\n            }\n        }\n    }\n}\n"}
{"id": 72859, "name": "Bell numbers", "source": "Translate Swift to C#: public struct BellTriangle<T: BinaryInteger> {\n  @usableFromInline\n  var arr: [T]\n\n  @inlinable\n  public internal(set) subscript(row row: Int, col col: Int) -> T {\n    get { arr[row * (row - 1) / 2 + col] }\n    set { arr[row * (row - 1) / 2 + col] = newValue }\n  }\n\n  @inlinable\n  public init(n: Int) {\n    arr = Array(repeating: 0, count: n * (n + 1) / 2)\n\n    self[row: 1, col: 0] = 1\n\n    for i in 2...n {\n      self[row: i, col: 0] = self[row: i - 1, col: i - 2]\n\n      for j in 1..<i {\n        self[row: i, col: j] = self[row: i, col: j - 1] + self[row: i - 1, col: j - 1]\n      }\n    }\n  }\n}\n\nlet tri = BellTriangle<Int>(n: 15)\n\nprint(\"First 15 Bell numbers:\")\n\nfor i in 1...15 {\n  print(\"\\(i): \\(tri[row: i, col: 0])\")\n}\n\nfor i in 1...10 {\n  print(tri[row: i, col: 0], terminator: \"\")\n\n  for j in 1..<i {\n    print(\", \\(tri[row: i, col: j])\", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "using System;\nusing System.Numerics;\n\nnamespace BellNumbers {\n    public static class Utility {\n        public static void Init<T>(this T[] array, T value) {\n            if (null == array) return;\n            for (int i = 0; i < array.Length; ++i) {\n                array[i] = value;\n            }\n        }\n    }\n\n    class Program {\n        static BigInteger[][] BellTriangle(int n) {\n            BigInteger[][] tri = new BigInteger[n][];\n            for (int i = 0; i < n; ++i) {\n                tri[i] = new BigInteger[i];\n                tri[i].Init(BigInteger.Zero);\n            }\n            tri[1][0] = 1;\n            for (int i = 2; i < n; ++i) {\n                tri[i][0] = tri[i - 1][i - 2];\n                for (int j = 1; j < i; ++j) {\n                    tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1];\n                }\n            }\n            return tri;\n        }\n\n        static void Main(string[] args) {\n            var bt = BellTriangle(51);\n            Console.WriteLine(\"First fifteen and fiftieth Bell numbers:\");\n            for (int i = 1; i < 16; ++i) {\n                Console.WriteLine(\"{0,2}: {1}\", i, bt[i][0]);\n            }\n            Console.WriteLine(\"50: {0}\", bt[50][0]);\n            Console.WriteLine();\n            Console.WriteLine(\"The first ten rows of Bell's triangle:\");\n            for (int i = 1; i < 11; ++i) {\n                \n                var it = bt[i].GetEnumerator();\n                Console.Write(\"[\");\n                if (it.MoveNext()) {\n                    Console.Write(it.Current);\n                }\n                while (it.MoveNext()) {\n                    Console.Write(\", \");\n                    Console.Write(it.Current);\n                }\n                Console.WriteLine(\"]\");\n            }\n        }\n    }\n}\n"}
{"id": 72862, "name": "Bell numbers", "source": "Translate Swift to Java: public struct BellTriangle<T: BinaryInteger> {\n  @usableFromInline\n  var arr: [T]\n\n  @inlinable\n  public internal(set) subscript(row row: Int, col col: Int) -> T {\n    get { arr[row * (row - 1) / 2 + col] }\n    set { arr[row * (row - 1) / 2 + col] = newValue }\n  }\n\n  @inlinable\n  public init(n: Int) {\n    arr = Array(repeating: 0, count: n * (n + 1) / 2)\n\n    self[row: 1, col: 0] = 1\n\n    for i in 2...n {\n      self[row: i, col: 0] = self[row: i - 1, col: i - 2]\n\n      for j in 1..<i {\n        self[row: i, col: j] = self[row: i, col: j - 1] + self[row: i - 1, col: j - 1]\n      }\n    }\n  }\n}\n\nlet tri = BellTriangle<Int>(n: 15)\n\nprint(\"First 15 Bell numbers:\")\n\nfor i in 1...15 {\n  print(\"\\(i): \\(tri[row: i, col: 0])\")\n}\n\nfor i in 1...10 {\n  print(tri[row: i, col: 0], terminator: \"\")\n\n  for j in 1..<i {\n    print(\", \\(tri[row: i, col: j])\", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Bell {\n    private static class BellTriangle {\n        private List<Integer> arr;\n\n        BellTriangle(int n) {\n            int length = n * (n + 1) / 2;\n            arr = new ArrayList<>(length);\n            for (int i = 0; i < length; ++i) {\n                arr.add(0);\n            }\n\n            set(1, 0, 1);\n            for (int i = 2; i <= n; ++i) {\n                set(i, 0, get(i - 1, i - 2));\n                for (int j = 1; j < i; ++j) {\n                    int value = get(i, j - 1) + get(i - 1, j - 1);\n                    set(i, j, value);\n                }\n            }\n        }\n\n        private int index(int row, int col) {\n            if (row > 0 && col >= 0 && col < row) {\n                return row * (row - 1) / 2 + col;\n            } else {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int get(int row, int col) {\n            int i = index(row, col);\n            return arr.get(i);\n        }\n\n        public void set(int row, int col, int value) {\n            int i = index(row, col);\n            arr.set(i, value);\n        }\n    }\n\n    public static void main(String[] args) {\n        final int rows = 15;\n        BellTriangle bt = new BellTriangle(rows);\n\n        System.out.println(\"First fifteen Bell numbers:\");\n        for (int i = 0; i < rows; ++i) {\n            System.out.printf(\"%2d: %d\\n\", i + 1, bt.get(i + 1, 0));\n        }\n\n        for (int i = 1; i <= 10; ++i) {\n            System.out.print(bt.get(i, 0));\n            for (int j = 1; j < i; ++j) {\n                System.out.printf(\", %d\", bt.get(i, j));\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 72863, "name": "Bell numbers", "source": "Translate Swift to Java: public struct BellTriangle<T: BinaryInteger> {\n  @usableFromInline\n  var arr: [T]\n\n  @inlinable\n  public internal(set) subscript(row row: Int, col col: Int) -> T {\n    get { arr[row * (row - 1) / 2 + col] }\n    set { arr[row * (row - 1) / 2 + col] = newValue }\n  }\n\n  @inlinable\n  public init(n: Int) {\n    arr = Array(repeating: 0, count: n * (n + 1) / 2)\n\n    self[row: 1, col: 0] = 1\n\n    for i in 2...n {\n      self[row: i, col: 0] = self[row: i - 1, col: i - 2]\n\n      for j in 1..<i {\n        self[row: i, col: j] = self[row: i, col: j - 1] + self[row: i - 1, col: j - 1]\n      }\n    }\n  }\n}\n\nlet tri = BellTriangle<Int>(n: 15)\n\nprint(\"First 15 Bell numbers:\")\n\nfor i in 1...15 {\n  print(\"\\(i): \\(tri[row: i, col: 0])\")\n}\n\nfor i in 1...10 {\n  print(tri[row: i, col: 0], terminator: \"\")\n\n  for j in 1..<i {\n    print(\", \\(tri[row: i, col: j])\", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Bell {\n    private static class BellTriangle {\n        private List<Integer> arr;\n\n        BellTriangle(int n) {\n            int length = n * (n + 1) / 2;\n            arr = new ArrayList<>(length);\n            for (int i = 0; i < length; ++i) {\n                arr.add(0);\n            }\n\n            set(1, 0, 1);\n            for (int i = 2; i <= n; ++i) {\n                set(i, 0, get(i - 1, i - 2));\n                for (int j = 1; j < i; ++j) {\n                    int value = get(i, j - 1) + get(i - 1, j - 1);\n                    set(i, j, value);\n                }\n            }\n        }\n\n        private int index(int row, int col) {\n            if (row > 0 && col >= 0 && col < row) {\n                return row * (row - 1) / 2 + col;\n            } else {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int get(int row, int col) {\n            int i = index(row, col);\n            return arr.get(i);\n        }\n\n        public void set(int row, int col, int value) {\n            int i = index(row, col);\n            arr.set(i, value);\n        }\n    }\n\n    public static void main(String[] args) {\n        final int rows = 15;\n        BellTriangle bt = new BellTriangle(rows);\n\n        System.out.println(\"First fifteen Bell numbers:\");\n        for (int i = 0; i < rows; ++i) {\n            System.out.printf(\"%2d: %d\\n\", i + 1, bt.get(i + 1, 0));\n        }\n\n        for (int i = 1; i <= 10; ++i) {\n            System.out.print(bt.get(i, 0));\n            for (int j = 1; j < i; ++j) {\n                System.out.printf(\", %d\", bt.get(i, j));\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 72864, "name": "Bell numbers", "source": "Translate Swift to Python: public struct BellTriangle<T: BinaryInteger> {\n  @usableFromInline\n  var arr: [T]\n\n  @inlinable\n  public internal(set) subscript(row row: Int, col col: Int) -> T {\n    get { arr[row * (row - 1) / 2 + col] }\n    set { arr[row * (row - 1) / 2 + col] = newValue }\n  }\n\n  @inlinable\n  public init(n: Int) {\n    arr = Array(repeating: 0, count: n * (n + 1) / 2)\n\n    self[row: 1, col: 0] = 1\n\n    for i in 2...n {\n      self[row: i, col: 0] = self[row: i - 1, col: i - 2]\n\n      for j in 1..<i {\n        self[row: i, col: j] = self[row: i, col: j - 1] + self[row: i - 1, col: j - 1]\n      }\n    }\n  }\n}\n\nlet tri = BellTriangle<Int>(n: 15)\n\nprint(\"First 15 Bell numbers:\")\n\nfor i in 1...15 {\n  print(\"\\(i): \\(tri[row: i, col: 0])\")\n}\n\nfor i in 1...10 {\n  print(tri[row: i, col: 0], terminator: \"\")\n\n  for j in 1..<i {\n    print(\", \\(tri[row: i, col: j])\", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "def bellTriangle(n):\n    tri = [None] * n\n    for i in xrange(n):\n        tri[i] = [0] * i\n    tri[1][0] = 1\n    for i in xrange(2, n):\n        tri[i][0] = tri[i - 1][i - 2]\n        for j in xrange(1, i):\n            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]\n    return tri\n\ndef main():\n    bt = bellTriangle(51)\n    print \"First fifteen and fiftieth Bell numbers:\"\n    for i in xrange(1, 16):\n        print \"%2d: %d\" % (i, bt[i][0])\n    print \"50:\", bt[50][0]\n    print\n    print \"The first ten rows of Bell's triangle:\"\n    for i in xrange(1, 11):\n        print bt[i]\n\nmain()\n"}
{"id": 72865, "name": "Bell numbers", "source": "Translate Swift to Python: public struct BellTriangle<T: BinaryInteger> {\n  @usableFromInline\n  var arr: [T]\n\n  @inlinable\n  public internal(set) subscript(row row: Int, col col: Int) -> T {\n    get { arr[row * (row - 1) / 2 + col] }\n    set { arr[row * (row - 1) / 2 + col] = newValue }\n  }\n\n  @inlinable\n  public init(n: Int) {\n    arr = Array(repeating: 0, count: n * (n + 1) / 2)\n\n    self[row: 1, col: 0] = 1\n\n    for i in 2...n {\n      self[row: i, col: 0] = self[row: i - 1, col: i - 2]\n\n      for j in 1..<i {\n        self[row: i, col: j] = self[row: i, col: j - 1] + self[row: i - 1, col: j - 1]\n      }\n    }\n  }\n}\n\nlet tri = BellTriangle<Int>(n: 15)\n\nprint(\"First 15 Bell numbers:\")\n\nfor i in 1...15 {\n  print(\"\\(i): \\(tri[row: i, col: 0])\")\n}\n\nfor i in 1...10 {\n  print(tri[row: i, col: 0], terminator: \"\")\n\n  for j in 1..<i {\n    print(\", \\(tri[row: i, col: j])\", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "def bellTriangle(n):\n    tri = [None] * n\n    for i in xrange(n):\n        tri[i] = [0] * i\n    tri[1][0] = 1\n    for i in xrange(2, n):\n        tri[i][0] = tri[i - 1][i - 2]\n        for j in xrange(1, i):\n            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]\n    return tri\n\ndef main():\n    bt = bellTriangle(51)\n    print \"First fifteen and fiftieth Bell numbers:\"\n    for i in xrange(1, 16):\n        print \"%2d: %d\" % (i, bt[i][0])\n    print \"50:\", bt[50][0]\n    print\n    print \"The first ten rows of Bell's triangle:\"\n    for i in xrange(1, 11):\n        print bt[i]\n\nmain()\n"}
{"id": 73250, "name": "Modular exponentiation", "source": "Translate Swift to C#: import BigInt\n\nfunc modPow<T: BinaryInteger>(n: T, e: T, m: T) -> T {\n  guard e != 0 else {\n    return 1\n  }\n\n  var res = T(1)\n  var base = n % m\n  var exp = e\n\n  while true {\n    if exp & 1 == 1 {\n      res *= base\n      res %= m\n    }\n\n    if exp == 1 {\n      return res\n    }\n\n    exp /= 2\n    base *= base\n    base %= m\n  }\n}\n\nlet a = BigInt(\"2988348162058574136915891421498819466320163312926952423791023078876139\")\nlet b = BigInt(\"2351399303373464486466122544523690094744975233415544072992656881240319\")\n\nprint(modPow(n: a, e: b, m: BigInt(10).power(40)))\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main() {\n        var a = BigInteger.Parse(\"2988348162058574136915891421498819466320163312926952423791023078876139\");\n        var b = BigInteger.Parse(\"2351399303373464486466122544523690094744975233415544072992656881240319\");\n        var m = BigInteger.Pow(10, 40);\n        Console.WriteLine(BigInteger.ModPow(a, b, m));\n    }\n}\n"}
{"id": 73251, "name": "Modular exponentiation", "source": "Translate Swift to C#: import BigInt\n\nfunc modPow<T: BinaryInteger>(n: T, e: T, m: T) -> T {\n  guard e != 0 else {\n    return 1\n  }\n\n  var res = T(1)\n  var base = n % m\n  var exp = e\n\n  while true {\n    if exp & 1 == 1 {\n      res *= base\n      res %= m\n    }\n\n    if exp == 1 {\n      return res\n    }\n\n    exp /= 2\n    base *= base\n    base %= m\n  }\n}\n\nlet a = BigInt(\"2988348162058574136915891421498819466320163312926952423791023078876139\")\nlet b = BigInt(\"2351399303373464486466122544523690094744975233415544072992656881240319\")\n\nprint(modPow(n: a, e: b, m: BigInt(10).power(40)))\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main() {\n        var a = BigInteger.Parse(\"2988348162058574136915891421498819466320163312926952423791023078876139\");\n        var b = BigInteger.Parse(\"2351399303373464486466122544523690094744975233415544072992656881240319\");\n        var m = BigInteger.Pow(10, 40);\n        Console.WriteLine(BigInteger.ModPow(a, b, m));\n    }\n}\n"}
{"id": 73254, "name": "Modular exponentiation", "source": "Translate Swift to Java: import BigInt\n\nfunc modPow<T: BinaryInteger>(n: T, e: T, m: T) -> T {\n  guard e != 0 else {\n    return 1\n  }\n\n  var res = T(1)\n  var base = n % m\n  var exp = e\n\n  while true {\n    if exp & 1 == 1 {\n      res *= base\n      res %= m\n    }\n\n    if exp == 1 {\n      return res\n    }\n\n    exp /= 2\n    base *= base\n    base %= m\n  }\n}\n\nlet a = BigInt(\"2988348162058574136915891421498819466320163312926952423791023078876139\")\nlet b = BigInt(\"2351399303373464486466122544523690094744975233415544072992656881240319\")\n\nprint(modPow(n: a, e: b, m: BigInt(10).power(40)))\n", "target": "import java.math.BigInteger;\n\npublic class PowMod {\n    public static void main(String[] args){\n        BigInteger a = new BigInteger(\n      \"2988348162058574136915891421498819466320163312926952423791023078876139\");\n        BigInteger b = new BigInteger(\n      \"2351399303373464486466122544523690094744975233415544072992656881240319\");\n        BigInteger m = new BigInteger(\"10000000000000000000000000000000000000000\");\n        \n        System.out.println(a.modPow(b, m));\n    }\n}\n"}
{"id": 73255, "name": "Modular exponentiation", "source": "Translate Swift to Java: import BigInt\n\nfunc modPow<T: BinaryInteger>(n: T, e: T, m: T) -> T {\n  guard e != 0 else {\n    return 1\n  }\n\n  var res = T(1)\n  var base = n % m\n  var exp = e\n\n  while true {\n    if exp & 1 == 1 {\n      res *= base\n      res %= m\n    }\n\n    if exp == 1 {\n      return res\n    }\n\n    exp /= 2\n    base *= base\n    base %= m\n  }\n}\n\nlet a = BigInt(\"2988348162058574136915891421498819466320163312926952423791023078876139\")\nlet b = BigInt(\"2351399303373464486466122544523690094744975233415544072992656881240319\")\n\nprint(modPow(n: a, e: b, m: BigInt(10).power(40)))\n", "target": "import java.math.BigInteger;\n\npublic class PowMod {\n    public static void main(String[] args){\n        BigInteger a = new BigInteger(\n      \"2988348162058574136915891421498819466320163312926952423791023078876139\");\n        BigInteger b = new BigInteger(\n      \"2351399303373464486466122544523690094744975233415544072992656881240319\");\n        BigInteger m = new BigInteger(\"10000000000000000000000000000000000000000\");\n        \n        System.out.println(a.modPow(b, m));\n    }\n}\n"}
{"id": 73256, "name": "Modular exponentiation", "source": "Translate Swift to Python: import BigInt\n\nfunc modPow<T: BinaryInteger>(n: T, e: T, m: T) -> T {\n  guard e != 0 else {\n    return 1\n  }\n\n  var res = T(1)\n  var base = n % m\n  var exp = e\n\n  while true {\n    if exp & 1 == 1 {\n      res *= base\n      res %= m\n    }\n\n    if exp == 1 {\n      return res\n    }\n\n    exp /= 2\n    base *= base\n    base %= m\n  }\n}\n\nlet a = BigInt(\"2988348162058574136915891421498819466320163312926952423791023078876139\")\nlet b = BigInt(\"2351399303373464486466122544523690094744975233415544072992656881240319\")\n\nprint(modPow(n: a, e: b, m: BigInt(10).power(40)))\n", "target": "a = 2988348162058574136915891421498819466320163312926952423791023078876139\nb = 2351399303373464486466122544523690094744975233415544072992656881240319\nm = 10 ** 40\nprint(pow(a, b, m))\n"}
{"id": 73257, "name": "Modular exponentiation", "source": "Translate Swift to Python: import BigInt\n\nfunc modPow<T: BinaryInteger>(n: T, e: T, m: T) -> T {\n  guard e != 0 else {\n    return 1\n  }\n\n  var res = T(1)\n  var base = n % m\n  var exp = e\n\n  while true {\n    if exp & 1 == 1 {\n      res *= base\n      res %= m\n    }\n\n    if exp == 1 {\n      return res\n    }\n\n    exp /= 2\n    base *= base\n    base %= m\n  }\n}\n\nlet a = BigInt(\"2988348162058574136915891421498819466320163312926952423791023078876139\")\nlet b = BigInt(\"2351399303373464486466122544523690094744975233415544072992656881240319\")\n\nprint(modPow(n: a, e: b, m: BigInt(10).power(40)))\n", "target": "a = 2988348162058574136915891421498819466320163312926952423791023078876139\nb = 2351399303373464486466122544523690094744975233415544072992656881240319\nm = 10 ** 40\nprint(pow(a, b, m))\n"}
{"id": 73530, "name": "Josephus problem", "source": "Translate Swift to C#: class Josephus {\n    \n    class func lineUp(#numberOfPeople:Int) -> [Int] {\n        var people = [Int]()\n        for (var i = 0; i < numberOfPeople; i++) {\n            people.append(i)\n        }\n        return people\n    }\n    \n    class func execute(#numberOfPeople:Int, spacing:Int) -> Int {\n        var killIndex = 0\n        var people = self.lineUp(numberOfPeople: numberOfPeople)\n        \n        println(\"Prisoners executed in order:\")\n        while (people.count > 1) {\n            killIndex = (killIndex + spacing - 1) % people.count\n            executeAndRemove(&people, killIndex: killIndex)\n        }\n        println()\n        return people[0]\n    }\n    \n    class func executeAndRemove(inout people:[Int], killIndex:Int) {\n        print(\"\\(people[killIndex]) \")\n        people.removeAtIndex(killIndex)\n    }\n\n    class func execucteAllButM(#numberOfPeople:Int, spacing:Int, save:Int) -> [Int] {\n        var killIndex = 0\n        var people = self.lineUp(numberOfPeople: numberOfPeople)\n        \n        println(\"Prisoners executed in order:\")\n        while (people.count > save) {\n            killIndex = (killIndex + spacing - 1) % people.count\n            executeAndRemove(&people, killIndex: killIndex)\n        }\n        println()\n        return people\n    }\n}\n\nprintln(\"Josephus is number: \\(Josephus.execute(numberOfPeople: 41, spacing: 3))\")\nprintln()\nprintln(\"Survivors: \\(Josephus.execucteAllButM(numberOfPeople: 41, spacing: 3, save: 3))\")\n", "target": "namespace Josephus\n{\n    using System;\n    using System.Collections;\n    using System.Collections.Generic;\n\n    public class Program\n    {\n        public static int[] JosephusProblem(int n, int m)\n        {\n            var circle = new List<int>();\n            var order = new int[n];\n\n            for (var i = 0; i < n; ++i)\n            {\n                circle.Add(i);\n            }\n\n            var l = 0;\n            var j = 0;\n            var k = 0;\n\n            while (circle.Count != 0)\n            {\n                j++;\n                if (j == m)\n                {\n                    order[k] = circle[l];\n                    circle.RemoveAt(l);\n\n                    k++;\n                    l--;\n                    j = 0;\n                }\n\n                if (k == n - 1)\n                {\n                    order[k] = circle[0];\n                    circle.RemoveAt(0);\n                }\n\n                if (l == circle.Count - 1)\n                {\n                    l = 0;\n                }\n                else\n                {\n                    l++;\n                }\n            }\n\n            return order;\n        }\n\n        static void Main(string[] args)\n        {\n            try\n            {\n                var n = 7;\n                var m = 2;\n\n                var result = JosephusProblem(n, m);\n\n               for (var i = 0; i < result.Length; i++)\n               {\n                   Console.WriteLine(result[i]);\n               }\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n            }\n            finally\n            {\n                Console.ReadLine();\n            }\n        }\n\n    }\n}\n"}
{"id": 73532, "name": "Josephus problem", "source": "Translate Swift to Java: class Josephus {\n    \n    class func lineUp(#numberOfPeople:Int) -> [Int] {\n        var people = [Int]()\n        for (var i = 0; i < numberOfPeople; i++) {\n            people.append(i)\n        }\n        return people\n    }\n    \n    class func execute(#numberOfPeople:Int, spacing:Int) -> Int {\n        var killIndex = 0\n        var people = self.lineUp(numberOfPeople: numberOfPeople)\n        \n        println(\"Prisoners executed in order:\")\n        while (people.count > 1) {\n            killIndex = (killIndex + spacing - 1) % people.count\n            executeAndRemove(&people, killIndex: killIndex)\n        }\n        println()\n        return people[0]\n    }\n    \n    class func executeAndRemove(inout people:[Int], killIndex:Int) {\n        print(\"\\(people[killIndex]) \")\n        people.removeAtIndex(killIndex)\n    }\n\n    class func execucteAllButM(#numberOfPeople:Int, spacing:Int, save:Int) -> [Int] {\n        var killIndex = 0\n        var people = self.lineUp(numberOfPeople: numberOfPeople)\n        \n        println(\"Prisoners executed in order:\")\n        while (people.count > save) {\n            killIndex = (killIndex + spacing - 1) % people.count\n            executeAndRemove(&people, killIndex: killIndex)\n        }\n        println()\n        return people\n    }\n}\n\nprintln(\"Josephus is number: \\(Josephus.execute(numberOfPeople: 41, spacing: 3))\")\nprintln()\nprintln(\"Survivors: \\(Josephus.execucteAllButM(numberOfPeople: 41, spacing: 3, save: 3))\")\n", "target": "import java.util.ArrayList;\n\npublic class Josephus {\n    public static int execute(int n, int k){\n        int killIdx = 0;\n        ArrayList<Integer> prisoners = new ArrayList<Integer>(n);\n        for(int i = 0;i < n;i++){\n            prisoners.add(i);\n        }\n        System.out.println(\"Prisoners executed in order:\");\n        while(prisoners.size() > 1){\n            killIdx = (killIdx + k - 1) % prisoners.size();\n            System.out.print(prisoners.get(killIdx) + \" \");\n            prisoners.remove(killIdx);\n        }\n        System.out.println();\n        return prisoners.get(0);\n    }\n    \n    public static ArrayList<Integer> executeAllButM(int n, int k, int m){\n        int killIdx = 0;\n        ArrayList<Integer> prisoners = new ArrayList<Integer>(n);\n        for(int i = 0;i < n;i++){\n            prisoners.add(i);\n        }\n        System.out.println(\"Prisoners executed in order:\");\n        while(prisoners.size() > m){\n            killIdx = (killIdx + k - 1) % prisoners.size();\n            System.out.print(prisoners.get(killIdx) + \" \");\n            prisoners.remove(killIdx);\n        }\n        System.out.println();\n        return prisoners;\n    }\n    \n    public static void main(String[] args){\n        System.out.println(\"Survivor: \" + execute(41, 3));\n        System.out.println(\"Survivors: \" + executeAllButM(41, 3, 3));\n    }\n}\n"}
{"id": 73533, "name": "Josephus problem", "source": "Translate Swift to Python: class Josephus {\n    \n    class func lineUp(#numberOfPeople:Int) -> [Int] {\n        var people = [Int]()\n        for (var i = 0; i < numberOfPeople; i++) {\n            people.append(i)\n        }\n        return people\n    }\n    \n    class func execute(#numberOfPeople:Int, spacing:Int) -> Int {\n        var killIndex = 0\n        var people = self.lineUp(numberOfPeople: numberOfPeople)\n        \n        println(\"Prisoners executed in order:\")\n        while (people.count > 1) {\n            killIndex = (killIndex + spacing - 1) % people.count\n            executeAndRemove(&people, killIndex: killIndex)\n        }\n        println()\n        return people[0]\n    }\n    \n    class func executeAndRemove(inout people:[Int], killIndex:Int) {\n        print(\"\\(people[killIndex]) \")\n        people.removeAtIndex(killIndex)\n    }\n\n    class func execucteAllButM(#numberOfPeople:Int, spacing:Int, save:Int) -> [Int] {\n        var killIndex = 0\n        var people = self.lineUp(numberOfPeople: numberOfPeople)\n        \n        println(\"Prisoners executed in order:\")\n        while (people.count > save) {\n            killIndex = (killIndex + spacing - 1) % people.count\n            executeAndRemove(&people, killIndex: killIndex)\n        }\n        println()\n        return people\n    }\n}\n\nprintln(\"Josephus is number: \\(Josephus.execute(numberOfPeople: 41, spacing: 3))\")\nprintln()\nprintln(\"Survivors: \\(Josephus.execucteAllButM(numberOfPeople: 41, spacing: 3, save: 3))\")\n", "target": ">>> def j(n, k):\n\tp, i, seq = list(range(n)), 0, []\n\twhile p:\n\t\ti = (i+k-1) % len(p)\n\t\tseq.append(p.pop(i))\n\treturn 'Prisoner killing order: %s.\\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])\n\n>>> print(j(5, 2))\nPrisoner killing order: 1, 3, 0, 4.\nSurvivor: 2\n>>> print(j(41, 3))\nPrisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.\nSurvivor: 30\n>>>\n"}
{"id": 73760, "name": "Pathological floating point problems", "source": "Translate Swift to C#: extension Numeric where Self: Strideable {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nprotocol PathologicalFloat: SignedNumeric, Strideable, ExpressibleByFloatLiteral {\n  static var e: Self { get }\n\n  static func /(_ lhs: Self, _ rhs: Self) -> Self\n}\n\nextension Double: PathologicalFloat {\n  static var e: Double { Double(\"2.71828182845904523536028747135266249\")! }\n}\n\nextension Float: PathologicalFloat {\n  static var e: Float { Float(\"2.7182818284590\")! }\n}\n\nextension Decimal: PathologicalFloat {\n  static var e: Decimal { Decimal(string: \"2.71828182845904523536028747135266249\")! }\n}\n\nextension BDouble: PathologicalFloat {\n  static var e: BDouble { BDouble(\"2.71828182845904523536028747135266249\")! }\n\n  public func advanced(by n: BDouble) -> BDouble { self + n }\n  public func distance(to other: BDouble) -> BDouble { abs(self - other) }\n}\n\nfunc badSequence<T: PathologicalFloat>(n: Int) -> T {\n  guard n != 1 else { return 2 }\n  guard n != 2 else { return -4 }\n\n  var a: T = 2, b: T = -4\n\n  for _ in stride(from: 2, to: n, by: 1) {\n    (a, b) = (b, 111 - 1130  / b + 3000 / (a * b))\n  }\n\n  return b\n}\n\nfunc chaoticBank<T: PathologicalFloat>(years: T) -> T {\n  var balance = T.e - 1\n\n  for year: T in stride(from: 1, through: 25, by: 1) {\n    balance = (balance * year) - 1\n  }\n\n  return balance\n}\n\nfunc rumpFunction<T: PathologicalFloat>(_ a: T, _ b: T) -> T {\n  let aSquared = a.power(2)\n  let bSix = b.power(6)\n\n  let f1 = 333.75 * bSix\n  let f2 = aSquared * (11 * aSquared * b.power(2) - bSix - 121 * b.power(4) - 2)\n  let f3 = 5.5 * b.power(8) + a / (2 * b)\n\n  return f1 + f2 + f3\n}\n\nfunc fmt<T: CVarArg>(_ n: T) -> String { String(format: \"%16.16f\", n) }\n\nprint(\"Bad sequence\")\nfor i in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100] {\n  let vFloat: Float = badSequence(n: i)\n  let vDouble: Double = badSequence(n: i)\n  let vDecimal: Decimal = badSequence(n: i)\n  let vBigDouble: BDouble = badSequence(n: i)\n\n  print(\"v(\\(i)) as Float \\(fmt(vFloat)); as Double = \\(fmt(vDouble)); as Decimal = \\(vDecimal); as BDouble = \\(vBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n}\n\n\nlet bankFloat: Float = chaoticBank(years: 25)\nlet bankDouble: Double = chaoticBank(years: 25)\nlet bankDecimal: Decimal = chaoticBank(years: 25)\nlet bankBigDouble: BDouble = chaoticBank(years: 25)\n\nprint(\"\\nChaotic bank\")\nprint(\"After 25 years your bank will be \\(bankFloat) if stored as a Float\")\nprint(\"After 25 years your bank will be \\(bankDouble) if stored as a Double\")\nprint(\"After 25 years your bank will be \\(bankDecimal) if stored as a Decimal\")\nprint(\"After 25 years your bank will be \\(bankBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false)) if stored as a BigDouble\")\n\nlet rumpFloat: Float = rumpFunction(77617.0, 33096.0)\nlet rumpDouble: Double = rumpFunction(77617.0, 33096.0)\nlet rumpDecimal: Decimal = rumpFunction(77617.0, 33096.0)\nlet rumpBigDouble: BDouble = rumpFunction(77617.0, 33096.0)\n\nprint(\"\\nRump's function\")\nprint(\"rump(77617.0, 33096.0) as Float \\(rumpFloat); as Double = \\(rumpDouble); as Decimal = \\(rumpDecimal); as BDouble = \\(rumpBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n", "target": "#define USE_BIGRATIONAL\n#define BANDED_ROWS\n#define INCREASED_LIMITS\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.Linq;\nusing System.Numerics;\nusing Numerics;\n\nusing static Common;\nusing static Task1;\nusing static Task2;\nusing static Task3;\n\n#if !USE_BIGRATIONAL\n\nstruct BigRational\n{\n    public override string ToString() => \"NOT USING BIGRATIONAL\";\n    public static explicit operator decimal(BigRational value) => -1;\n}\n#endif\n\nstatic class Common\n{\n    public const string FMT_STR = \"{0,4}   {1,-15:G9}   {2,-24:G17}   {3,-32}   {4,-32}\";\n    public static string Headings { get; } =\n        string.Format(\n            CultureInfo.InvariantCulture,\n            FMT_STR,\n            new[] { \"N\", \"Single\", \"Double\", \"Decimal\", \"BigRational (rounded as Decimal)\" });\n\n    [Conditional(\"BANDED_ROWS\")]\n    static void SetConsoleFormat(int n)\n    {\n        if (n % 2 == 0)\n        {\n            Console.BackgroundColor = ConsoleColor.Black;\n            Console.ForegroundColor = ConsoleColor.White;\n        }\n        else\n        {\n            Console.BackgroundColor = ConsoleColor.White;\n            Console.ForegroundColor = ConsoleColor.Black;\n        }\n    }\n\n    public static string FormatOutput(int n, (float sn, double db, decimal dm, BigRational br) x)\n    {\n        SetConsoleFormat(n);\n        return string.Format(CultureInfo.CurrentCulture, FMT_STR, n, x.sn, x.db, x.dm, (decimal)x.br);\n    }\n\n    static void Main()\n    {\n        WrongConvergence();\n\n        Console.WriteLine();\n        ChaoticBankSociety();\n\n        Console.WriteLine();\n        SiegfriedRump();\n\n        SetConsoleFormat(0);\n    }\n}\n"}
{"id": 73761, "name": "Pathological floating point problems", "source": "Translate Swift to Java: extension Numeric where Self: Strideable {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nprotocol PathologicalFloat: SignedNumeric, Strideable, ExpressibleByFloatLiteral {\n  static var e: Self { get }\n\n  static func /(_ lhs: Self, _ rhs: Self) -> Self\n}\n\nextension Double: PathologicalFloat {\n  static var e: Double { Double(\"2.71828182845904523536028747135266249\")! }\n}\n\nextension Float: PathologicalFloat {\n  static var e: Float { Float(\"2.7182818284590\")! }\n}\n\nextension Decimal: PathologicalFloat {\n  static var e: Decimal { Decimal(string: \"2.71828182845904523536028747135266249\")! }\n}\n\nextension BDouble: PathologicalFloat {\n  static var e: BDouble { BDouble(\"2.71828182845904523536028747135266249\")! }\n\n  public func advanced(by n: BDouble) -> BDouble { self + n }\n  public func distance(to other: BDouble) -> BDouble { abs(self - other) }\n}\n\nfunc badSequence<T: PathologicalFloat>(n: Int) -> T {\n  guard n != 1 else { return 2 }\n  guard n != 2 else { return -4 }\n\n  var a: T = 2, b: T = -4\n\n  for _ in stride(from: 2, to: n, by: 1) {\n    (a, b) = (b, 111 - 1130  / b + 3000 / (a * b))\n  }\n\n  return b\n}\n\nfunc chaoticBank<T: PathologicalFloat>(years: T) -> T {\n  var balance = T.e - 1\n\n  for year: T in stride(from: 1, through: 25, by: 1) {\n    balance = (balance * year) - 1\n  }\n\n  return balance\n}\n\nfunc rumpFunction<T: PathologicalFloat>(_ a: T, _ b: T) -> T {\n  let aSquared = a.power(2)\n  let bSix = b.power(6)\n\n  let f1 = 333.75 * bSix\n  let f2 = aSquared * (11 * aSquared * b.power(2) - bSix - 121 * b.power(4) - 2)\n  let f3 = 5.5 * b.power(8) + a / (2 * b)\n\n  return f1 + f2 + f3\n}\n\nfunc fmt<T: CVarArg>(_ n: T) -> String { String(format: \"%16.16f\", n) }\n\nprint(\"Bad sequence\")\nfor i in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100] {\n  let vFloat: Float = badSequence(n: i)\n  let vDouble: Double = badSequence(n: i)\n  let vDecimal: Decimal = badSequence(n: i)\n  let vBigDouble: BDouble = badSequence(n: i)\n\n  print(\"v(\\(i)) as Float \\(fmt(vFloat)); as Double = \\(fmt(vDouble)); as Decimal = \\(vDecimal); as BDouble = \\(vBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n}\n\n\nlet bankFloat: Float = chaoticBank(years: 25)\nlet bankDouble: Double = chaoticBank(years: 25)\nlet bankDecimal: Decimal = chaoticBank(years: 25)\nlet bankBigDouble: BDouble = chaoticBank(years: 25)\n\nprint(\"\\nChaotic bank\")\nprint(\"After 25 years your bank will be \\(bankFloat) if stored as a Float\")\nprint(\"After 25 years your bank will be \\(bankDouble) if stored as a Double\")\nprint(\"After 25 years your bank will be \\(bankDecimal) if stored as a Decimal\")\nprint(\"After 25 years your bank will be \\(bankBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false)) if stored as a BigDouble\")\n\nlet rumpFloat: Float = rumpFunction(77617.0, 33096.0)\nlet rumpDouble: Double = rumpFunction(77617.0, 33096.0)\nlet rumpDecimal: Decimal = rumpFunction(77617.0, 33096.0)\nlet rumpBigDouble: BDouble = rumpFunction(77617.0, 33096.0)\n\nprint(\"\\nRump's function\")\nprint(\"rump(77617.0, 33096.0) as Float \\(rumpFloat); as Double = \\(rumpDouble); as Decimal = \\(rumpDecimal); as BDouble = \\(rumpBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n", "target": "import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class FPProblems {\n    public static void wrongConvergence() {\n        int[] INDEXES = new int[] { 3, 4, 5, 6, 7, 8, 20, 30, 50, 100 };\n        \n        \n        double[] fpValues = new double[100];\n        fpValues[0] = 2.0;\n        fpValues[1] = -4.0;\n        for (int i = 2; i < fpValues.length; i++) {\n            fpValues[i] = 111.0 - 1130.0 / fpValues[i - 1] + 3000.0 / (fpValues[i - 1] * fpValues[i - 2]);\n        }\n        \n        \n        BigRational[] brValues = new BigRational[100];\n        brValues[0] = BigRational.valueOf(2);\n        brValues[1] = BigRational.valueOf(-4);\n        for (int i = 2; i < brValues.length; i++) {\n            \n            BigRational clause2 = BigRational.valueOf(1130).divide(brValues[i - 1]);\n            BigRational clause3 = BigRational.valueOf(3000).divide(brValues[i - 1].multiply(brValues[i - 2]));\n            brValues[i] = BigRational.valueOf(111).subtract(clause2).add(clause3);\n        }\n        \n        System.out.println(\"Wrong Convergence Sequence\");\n        for (int n : INDEXES) {\n            BigDecimal value = brValues[n - 1].toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  For index \" + n + \", FP value is \" + fpValues[n - 1] + \", and rounded BigRational value is \" + value.toPlainString());\n        }\n        \n        return;\n    }\n    \n    public static void chaoticBankSociety() {\n        System.out.println(\"Chaotic Bank Society\");\n        double balance = Math.E - 1.0;\n        \n        \n        BigRational e = BigRational.ONE;\n        BigRational d = BigRational.ONE;\n        for (int i = 1; i < 1000; i++) {\n            d = d.multiply(BigRational.valueOf(i));\n            e = e.add(d.reciprocal());\n        }\n        System.out.println(\"DEBUG: e=\" + e.toBigDecimal(100, RoundingMode.HALF_UP).toPlainString());\n        \n        \n        \n        \n        BigRational brBalance = e.subtract(BigRational.ONE);\n        for (int year = 1; year <= 25; year++) {\n            balance = (balance * year) - 1.0;\n            brBalance = brBalance.multiply(BigRational.valueOf(year)).subtract(BigRational.ONE);\n            BigDecimal bdValue = brBalance.toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  Year=\" + year + \", FP balance=\" + balance + \", BigRational balance=\" + bdValue.toPlainString());\n        }\n    }\n    \n    public static void siegfriedRump() {\n        System.out.println(\"Siegfried Rump formula\");\n        double fpValue;\n        {\n            double a = 77617.0;\n            double b = 33096.0;\n            fpValue = 333.75 * Math.pow(b, 6) + a * a * (11.0 * a * a * b * b - Math.pow(b, 6) - 121.0 * Math.pow(b, 4) - 2.0) + 5.5 * Math.pow(b, 8) + a / (2.0 * b);\n        }\n        \n        BigRational brValue;\n        {\n            BigRational a = BigRational.valueOf(77617);\n            BigRational b = BigRational.valueOf(33096);\n            BigRational clause1 = BigRational.valueOf(333.75).multiply(b.pow(6));\n            BigRational clause2a = BigRational.valueOf(11).multiply(a).multiply(a).multiply(b).multiply(b);\n            BigRational clause2b = b.pow(6).add(BigRational.valueOf(121).multiply(b.pow(4))).add(BigRational.valueOf(2));\n            BigRational clause2 = a.multiply(a).multiply(clause2a.subtract(clause2b));\n            BigRational clause3 = BigRational.valueOf(5.5).multiply(b.pow(8));\n            BigRational clause4 = a.divide(b.multiply(BigRational.valueOf(2)));\n            brValue = clause1.add(clause2).add(clause3).add(clause4);\n        }\n        \n        System.out.println(\"  FP value is \" + fpValue);\n        System.out.println(\"  BigRational rounded value is \" + brValue.toBigDecimal(64, RoundingMode.HALF_UP).toPlainString());\n        System.out.println(\"  BigRational full value is \" + brValue.toString());\n    }\n    \n    public static void main(String... args) {\n        wrongConvergence();\n        \n        System.out.println();\n        chaoticBankSociety();\n\n        System.out.println();\n        siegfriedRump();\n    }\n}\n"}
{"id": 73762, "name": "Pathological floating point problems", "source": "Translate Swift to Java: extension Numeric where Self: Strideable {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nprotocol PathologicalFloat: SignedNumeric, Strideable, ExpressibleByFloatLiteral {\n  static var e: Self { get }\n\n  static func /(_ lhs: Self, _ rhs: Self) -> Self\n}\n\nextension Double: PathologicalFloat {\n  static var e: Double { Double(\"2.71828182845904523536028747135266249\")! }\n}\n\nextension Float: PathologicalFloat {\n  static var e: Float { Float(\"2.7182818284590\")! }\n}\n\nextension Decimal: PathologicalFloat {\n  static var e: Decimal { Decimal(string: \"2.71828182845904523536028747135266249\")! }\n}\n\nextension BDouble: PathologicalFloat {\n  static var e: BDouble { BDouble(\"2.71828182845904523536028747135266249\")! }\n\n  public func advanced(by n: BDouble) -> BDouble { self + n }\n  public func distance(to other: BDouble) -> BDouble { abs(self - other) }\n}\n\nfunc badSequence<T: PathologicalFloat>(n: Int) -> T {\n  guard n != 1 else { return 2 }\n  guard n != 2 else { return -4 }\n\n  var a: T = 2, b: T = -4\n\n  for _ in stride(from: 2, to: n, by: 1) {\n    (a, b) = (b, 111 - 1130  / b + 3000 / (a * b))\n  }\n\n  return b\n}\n\nfunc chaoticBank<T: PathologicalFloat>(years: T) -> T {\n  var balance = T.e - 1\n\n  for year: T in stride(from: 1, through: 25, by: 1) {\n    balance = (balance * year) - 1\n  }\n\n  return balance\n}\n\nfunc rumpFunction<T: PathologicalFloat>(_ a: T, _ b: T) -> T {\n  let aSquared = a.power(2)\n  let bSix = b.power(6)\n\n  let f1 = 333.75 * bSix\n  let f2 = aSquared * (11 * aSquared * b.power(2) - bSix - 121 * b.power(4) - 2)\n  let f3 = 5.5 * b.power(8) + a / (2 * b)\n\n  return f1 + f2 + f3\n}\n\nfunc fmt<T: CVarArg>(_ n: T) -> String { String(format: \"%16.16f\", n) }\n\nprint(\"Bad sequence\")\nfor i in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100] {\n  let vFloat: Float = badSequence(n: i)\n  let vDouble: Double = badSequence(n: i)\n  let vDecimal: Decimal = badSequence(n: i)\n  let vBigDouble: BDouble = badSequence(n: i)\n\n  print(\"v(\\(i)) as Float \\(fmt(vFloat)); as Double = \\(fmt(vDouble)); as Decimal = \\(vDecimal); as BDouble = \\(vBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n}\n\n\nlet bankFloat: Float = chaoticBank(years: 25)\nlet bankDouble: Double = chaoticBank(years: 25)\nlet bankDecimal: Decimal = chaoticBank(years: 25)\nlet bankBigDouble: BDouble = chaoticBank(years: 25)\n\nprint(\"\\nChaotic bank\")\nprint(\"After 25 years your bank will be \\(bankFloat) if stored as a Float\")\nprint(\"After 25 years your bank will be \\(bankDouble) if stored as a Double\")\nprint(\"After 25 years your bank will be \\(bankDecimal) if stored as a Decimal\")\nprint(\"After 25 years your bank will be \\(bankBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false)) if stored as a BigDouble\")\n\nlet rumpFloat: Float = rumpFunction(77617.0, 33096.0)\nlet rumpDouble: Double = rumpFunction(77617.0, 33096.0)\nlet rumpDecimal: Decimal = rumpFunction(77617.0, 33096.0)\nlet rumpBigDouble: BDouble = rumpFunction(77617.0, 33096.0)\n\nprint(\"\\nRump's function\")\nprint(\"rump(77617.0, 33096.0) as Float \\(rumpFloat); as Double = \\(rumpDouble); as Decimal = \\(rumpDecimal); as BDouble = \\(rumpBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n", "target": "import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class FPProblems {\n    public static void wrongConvergence() {\n        int[] INDEXES = new int[] { 3, 4, 5, 6, 7, 8, 20, 30, 50, 100 };\n        \n        \n        double[] fpValues = new double[100];\n        fpValues[0] = 2.0;\n        fpValues[1] = -4.0;\n        for (int i = 2; i < fpValues.length; i++) {\n            fpValues[i] = 111.0 - 1130.0 / fpValues[i - 1] + 3000.0 / (fpValues[i - 1] * fpValues[i - 2]);\n        }\n        \n        \n        BigRational[] brValues = new BigRational[100];\n        brValues[0] = BigRational.valueOf(2);\n        brValues[1] = BigRational.valueOf(-4);\n        for (int i = 2; i < brValues.length; i++) {\n            \n            BigRational clause2 = BigRational.valueOf(1130).divide(brValues[i - 1]);\n            BigRational clause3 = BigRational.valueOf(3000).divide(brValues[i - 1].multiply(brValues[i - 2]));\n            brValues[i] = BigRational.valueOf(111).subtract(clause2).add(clause3);\n        }\n        \n        System.out.println(\"Wrong Convergence Sequence\");\n        for (int n : INDEXES) {\n            BigDecimal value = brValues[n - 1].toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  For index \" + n + \", FP value is \" + fpValues[n - 1] + \", and rounded BigRational value is \" + value.toPlainString());\n        }\n        \n        return;\n    }\n    \n    public static void chaoticBankSociety() {\n        System.out.println(\"Chaotic Bank Society\");\n        double balance = Math.E - 1.0;\n        \n        \n        BigRational e = BigRational.ONE;\n        BigRational d = BigRational.ONE;\n        for (int i = 1; i < 1000; i++) {\n            d = d.multiply(BigRational.valueOf(i));\n            e = e.add(d.reciprocal());\n        }\n        System.out.println(\"DEBUG: e=\" + e.toBigDecimal(100, RoundingMode.HALF_UP).toPlainString());\n        \n        \n        \n        \n        BigRational brBalance = e.subtract(BigRational.ONE);\n        for (int year = 1; year <= 25; year++) {\n            balance = (balance * year) - 1.0;\n            brBalance = brBalance.multiply(BigRational.valueOf(year)).subtract(BigRational.ONE);\n            BigDecimal bdValue = brBalance.toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  Year=\" + year + \", FP balance=\" + balance + \", BigRational balance=\" + bdValue.toPlainString());\n        }\n    }\n    \n    public static void siegfriedRump() {\n        System.out.println(\"Siegfried Rump formula\");\n        double fpValue;\n        {\n            double a = 77617.0;\n            double b = 33096.0;\n            fpValue = 333.75 * Math.pow(b, 6) + a * a * (11.0 * a * a * b * b - Math.pow(b, 6) - 121.0 * Math.pow(b, 4) - 2.0) + 5.5 * Math.pow(b, 8) + a / (2.0 * b);\n        }\n        \n        BigRational brValue;\n        {\n            BigRational a = BigRational.valueOf(77617);\n            BigRational b = BigRational.valueOf(33096);\n            BigRational clause1 = BigRational.valueOf(333.75).multiply(b.pow(6));\n            BigRational clause2a = BigRational.valueOf(11).multiply(a).multiply(a).multiply(b).multiply(b);\n            BigRational clause2b = b.pow(6).add(BigRational.valueOf(121).multiply(b.pow(4))).add(BigRational.valueOf(2));\n            BigRational clause2 = a.multiply(a).multiply(clause2a.subtract(clause2b));\n            BigRational clause3 = BigRational.valueOf(5.5).multiply(b.pow(8));\n            BigRational clause4 = a.divide(b.multiply(BigRational.valueOf(2)));\n            brValue = clause1.add(clause2).add(clause3).add(clause4);\n        }\n        \n        System.out.println(\"  FP value is \" + fpValue);\n        System.out.println(\"  BigRational rounded value is \" + brValue.toBigDecimal(64, RoundingMode.HALF_UP).toPlainString());\n        System.out.println(\"  BigRational full value is \" + brValue.toString());\n    }\n    \n    public static void main(String... args) {\n        wrongConvergence();\n        \n        System.out.println();\n        chaoticBankSociety();\n\n        System.out.println();\n        siegfriedRump();\n    }\n}\n"}
{"id": 73763, "name": "Pathological floating point problems", "source": "Translate Swift to Python: extension Numeric where Self: Strideable {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nprotocol PathologicalFloat: SignedNumeric, Strideable, ExpressibleByFloatLiteral {\n  static var e: Self { get }\n\n  static func /(_ lhs: Self, _ rhs: Self) -> Self\n}\n\nextension Double: PathologicalFloat {\n  static var e: Double { Double(\"2.71828182845904523536028747135266249\")! }\n}\n\nextension Float: PathologicalFloat {\n  static var e: Float { Float(\"2.7182818284590\")! }\n}\n\nextension Decimal: PathologicalFloat {\n  static var e: Decimal { Decimal(string: \"2.71828182845904523536028747135266249\")! }\n}\n\nextension BDouble: PathologicalFloat {\n  static var e: BDouble { BDouble(\"2.71828182845904523536028747135266249\")! }\n\n  public func advanced(by n: BDouble) -> BDouble { self + n }\n  public func distance(to other: BDouble) -> BDouble { abs(self - other) }\n}\n\nfunc badSequence<T: PathologicalFloat>(n: Int) -> T {\n  guard n != 1 else { return 2 }\n  guard n != 2 else { return -4 }\n\n  var a: T = 2, b: T = -4\n\n  for _ in stride(from: 2, to: n, by: 1) {\n    (a, b) = (b, 111 - 1130  / b + 3000 / (a * b))\n  }\n\n  return b\n}\n\nfunc chaoticBank<T: PathologicalFloat>(years: T) -> T {\n  var balance = T.e - 1\n\n  for year: T in stride(from: 1, through: 25, by: 1) {\n    balance = (balance * year) - 1\n  }\n\n  return balance\n}\n\nfunc rumpFunction<T: PathologicalFloat>(_ a: T, _ b: T) -> T {\n  let aSquared = a.power(2)\n  let bSix = b.power(6)\n\n  let f1 = 333.75 * bSix\n  let f2 = aSquared * (11 * aSquared * b.power(2) - bSix - 121 * b.power(4) - 2)\n  let f3 = 5.5 * b.power(8) + a / (2 * b)\n\n  return f1 + f2 + f3\n}\n\nfunc fmt<T: CVarArg>(_ n: T) -> String { String(format: \"%16.16f\", n) }\n\nprint(\"Bad sequence\")\nfor i in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100] {\n  let vFloat: Float = badSequence(n: i)\n  let vDouble: Double = badSequence(n: i)\n  let vDecimal: Decimal = badSequence(n: i)\n  let vBigDouble: BDouble = badSequence(n: i)\n\n  print(\"v(\\(i)) as Float \\(fmt(vFloat)); as Double = \\(fmt(vDouble)); as Decimal = \\(vDecimal); as BDouble = \\(vBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n}\n\n\nlet bankFloat: Float = chaoticBank(years: 25)\nlet bankDouble: Double = chaoticBank(years: 25)\nlet bankDecimal: Decimal = chaoticBank(years: 25)\nlet bankBigDouble: BDouble = chaoticBank(years: 25)\n\nprint(\"\\nChaotic bank\")\nprint(\"After 25 years your bank will be \\(bankFloat) if stored as a Float\")\nprint(\"After 25 years your bank will be \\(bankDouble) if stored as a Double\")\nprint(\"After 25 years your bank will be \\(bankDecimal) if stored as a Decimal\")\nprint(\"After 25 years your bank will be \\(bankBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false)) if stored as a BigDouble\")\n\nlet rumpFloat: Float = rumpFunction(77617.0, 33096.0)\nlet rumpDouble: Double = rumpFunction(77617.0, 33096.0)\nlet rumpDecimal: Decimal = rumpFunction(77617.0, 33096.0)\nlet rumpBigDouble: BDouble = rumpFunction(77617.0, 33096.0)\n\nprint(\"\\nRump's function\")\nprint(\"rump(77617.0, 33096.0) as Float \\(rumpFloat); as Double = \\(rumpDouble); as Decimal = \\(rumpDecimal); as BDouble = \\(rumpBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n", "target": "from fractions import Fraction\n\ndef muller_seq(n:int) -> float:\n    seq = [Fraction(0), Fraction(2), Fraction(-4)]\n    for i in range(3, n+1):\n        next_value = (111 - 1130/seq[i-1]\n            + 3000/(seq[i-1]*seq[i-2]))\n        seq.append(next_value)\n    return float(seq[n])\n\nfor n in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100]:\n    print(\"{:4d} -> {}\".format(n, muller_seq(n)))\n"}
{"id": 73764, "name": "Pathological floating point problems", "source": "Translate Swift to Python: extension Numeric where Self: Strideable {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nprotocol PathologicalFloat: SignedNumeric, Strideable, ExpressibleByFloatLiteral {\n  static var e: Self { get }\n\n  static func /(_ lhs: Self, _ rhs: Self) -> Self\n}\n\nextension Double: PathologicalFloat {\n  static var e: Double { Double(\"2.71828182845904523536028747135266249\")! }\n}\n\nextension Float: PathologicalFloat {\n  static var e: Float { Float(\"2.7182818284590\")! }\n}\n\nextension Decimal: PathologicalFloat {\n  static var e: Decimal { Decimal(string: \"2.71828182845904523536028747135266249\")! }\n}\n\nextension BDouble: PathologicalFloat {\n  static var e: BDouble { BDouble(\"2.71828182845904523536028747135266249\")! }\n\n  public func advanced(by n: BDouble) -> BDouble { self + n }\n  public func distance(to other: BDouble) -> BDouble { abs(self - other) }\n}\n\nfunc badSequence<T: PathologicalFloat>(n: Int) -> T {\n  guard n != 1 else { return 2 }\n  guard n != 2 else { return -4 }\n\n  var a: T = 2, b: T = -4\n\n  for _ in stride(from: 2, to: n, by: 1) {\n    (a, b) = (b, 111 - 1130  / b + 3000 / (a * b))\n  }\n\n  return b\n}\n\nfunc chaoticBank<T: PathologicalFloat>(years: T) -> T {\n  var balance = T.e - 1\n\n  for year: T in stride(from: 1, through: 25, by: 1) {\n    balance = (balance * year) - 1\n  }\n\n  return balance\n}\n\nfunc rumpFunction<T: PathologicalFloat>(_ a: T, _ b: T) -> T {\n  let aSquared = a.power(2)\n  let bSix = b.power(6)\n\n  let f1 = 333.75 * bSix\n  let f2 = aSquared * (11 * aSquared * b.power(2) - bSix - 121 * b.power(4) - 2)\n  let f3 = 5.5 * b.power(8) + a / (2 * b)\n\n  return f1 + f2 + f3\n}\n\nfunc fmt<T: CVarArg>(_ n: T) -> String { String(format: \"%16.16f\", n) }\n\nprint(\"Bad sequence\")\nfor i in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100] {\n  let vFloat: Float = badSequence(n: i)\n  let vDouble: Double = badSequence(n: i)\n  let vDecimal: Decimal = badSequence(n: i)\n  let vBigDouble: BDouble = badSequence(n: i)\n\n  print(\"v(\\(i)) as Float \\(fmt(vFloat)); as Double = \\(fmt(vDouble)); as Decimal = \\(vDecimal); as BDouble = \\(vBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n}\n\n\nlet bankFloat: Float = chaoticBank(years: 25)\nlet bankDouble: Double = chaoticBank(years: 25)\nlet bankDecimal: Decimal = chaoticBank(years: 25)\nlet bankBigDouble: BDouble = chaoticBank(years: 25)\n\nprint(\"\\nChaotic bank\")\nprint(\"After 25 years your bank will be \\(bankFloat) if stored as a Float\")\nprint(\"After 25 years your bank will be \\(bankDouble) if stored as a Double\")\nprint(\"After 25 years your bank will be \\(bankDecimal) if stored as a Decimal\")\nprint(\"After 25 years your bank will be \\(bankBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false)) if stored as a BigDouble\")\n\nlet rumpFloat: Float = rumpFunction(77617.0, 33096.0)\nlet rumpDouble: Double = rumpFunction(77617.0, 33096.0)\nlet rumpDecimal: Decimal = rumpFunction(77617.0, 33096.0)\nlet rumpBigDouble: BDouble = rumpFunction(77617.0, 33096.0)\n\nprint(\"\\nRump's function\")\nprint(\"rump(77617.0, 33096.0) as Float \\(rumpFloat); as Double = \\(rumpDouble); as Decimal = \\(rumpDecimal); as BDouble = \\(rumpBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n", "target": "from fractions import Fraction\n\ndef muller_seq(n:int) -> float:\n    seq = [Fraction(0), Fraction(2), Fraction(-4)]\n    for i in range(3, n+1):\n        next_value = (111 - 1130/seq[i-1]\n            + 3000/(seq[i-1]*seq[i-2]))\n        seq.append(next_value)\n    return float(seq[n])\n\nfor n in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100]:\n    print(\"{:4d} -> {}\".format(n, muller_seq(n)))\n"}
{"id": 74465, "name": "Array concatenation", "source": "Translate Swift to C#: let array1 = [1,2,3]\nlet array2 = [4,5,6]\nlet array3 = array1 + array2\n", "target": "using System;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] a = { 1, 2, 3 };\n            int[] b = { 4, 5, 6 };\n\n            int[] c = new int[a.Length + b.Length];\n            a.CopyTo(c, 0);\n            b.CopyTo(c, a.Length);\n\n            foreach(int n in c)\n            {\n                Console.WriteLine(n.ToString());\n            }\n        }\n    }\n}\n"}
{"id": 74467, "name": "Array concatenation", "source": "Translate Swift to Java: let array1 = [1,2,3]\nlet array2 = [4,5,6]\nlet array3 = array1 + array2\n", "target": "String[] fruits = [\"apples\", \"oranges\"];\nString[] grains = [\"wheat\", \"corn\"];\nString[] all    = fruits + grains;\n"}
{"id": 74468, "name": "Array concatenation", "source": "Translate Swift to Python: let array1 = [1,2,3]\nlet array2 = [4,5,6]\nlet array3 = array1 + array2\n", "target": "arr1 = [1, 2, 3]\narr2 = [4, 5, 6]\narr3 = [7, 8, 9]\narr4 = arr1 + arr2\nassert arr4 == [1, 2, 3, 4, 5, 6]\narr4.extend(arr3)\nassert arr4 == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"}
{"id": 74731, "name": "Abundant, deficient and perfect number classifications", "source": "Translate Swift to C#: var deficients = 0 \nvar perfects = 0 \nvar abundants = 0 \n\n\ndeficients++\n\n\nfor i in 2...20000 {\n\n    var sumPd = 1 \n    \n    var maxPdToTest = i/2 \n\n    for var j = 2; j < maxPdToTest; j++ {\n        \n        if (i%j) == 0 {\n            \n            sumPd += j\n            \n            \n            maxPdToTest = i / j\n            \n            \n            if maxPdToTest != j {\n                sumPd += maxPdToTest\n            }\n        }\n    }\n    \n    \n    if sumPd < i {\n        deficients++\n    } else if sumPd > i {\n        abundants++\n    } else {\n        perfects++\n    }\n}\n\nprintln(\"There are \\(deficients) deficient, \\(perfects) perfect and \\(abundants) abundant integers from 1 to 20000.\")\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        int abundant, deficient, perfect;\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        ClassifyNumbers.UsingSieve(20000, out abundant, out deficient, out perfect); sw.Stop();\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms\");\n        sw.Restart();\n        ClassifyNumbers.UsingOptiDivision(20000, out abundant, out deficient, out perfect);\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms\");\n        sw.Restart();\n        ClassifyNumbers.UsingDivision(20000, out abundant, out deficient, out perfect);\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms\");\n    }\n}\n\npublic static class ClassifyNumbers\n{\n    \n    public static void UsingSieve(int bound, out int abundant, out int deficient, out int perfect) {\n        abundant = perfect = 0;\n        \n        int[] sum = new int[bound + 1];\n        for (int divisor = 1; divisor <= bound >> 1; divisor++)\n            for (int i = divisor << 1; i <= bound; i += divisor)\n                sum[i] += divisor;\n        for (int i = 1; i <= bound; i++) {\n            if (sum[i] > i) abundant++;\n            else if (sum[i] == i) perfect++;\n        }\n        deficient = bound - abundant - perfect;\n    }\n\n    \n    public static void UsingOptiDivision(int bound, out int abundant, out int deficient, out int perfect) {\n        abundant = perfect = 0; int sum = 0;\n        for (int i = 2, d, r = 1; i <= bound; i++) {\n            if ((d = r * r - i) < 0) r++;\n            for (int x = 2; x < r; x++) if (i % x == 0) sum += x + i / x;\n            if (d == 0) sum += r;\n            switch (sum.CompareTo(i)) { case 0: perfect++; break; case 1: abundant++; break; }\n            sum = 1;\n        }\n        deficient = bound - abundant - perfect;\n    }\n\n    \n    public static void UsingDivision(int bound, out int abundant, out int deficient, out int perfect) {\n        abundant = perfect = 0;\n        for (int i = 2; i <= bound; i++) {\n            int sum = Enumerable.Range(1, (i + 1) / 2)\n                .Where(div => i % div == 0).Sum();\n            switch (sum.CompareTo(i)) {\n                case 0: perfect++; break;\n                case 1: abundant++; break;\n            }\n        }\n        deficient = bound - abundant - perfect;\n    }\n}\n"}
{"id": 74733, "name": "Abundant, deficient and perfect number classifications", "source": "Translate Swift to Java: var deficients = 0 \nvar perfects = 0 \nvar abundants = 0 \n\n\ndeficients++\n\n\nfor i in 2...20000 {\n\n    var sumPd = 1 \n    \n    var maxPdToTest = i/2 \n\n    for var j = 2; j < maxPdToTest; j++ {\n        \n        if (i%j) == 0 {\n            \n            sumPd += j\n            \n            \n            maxPdToTest = i / j\n            \n            \n            if maxPdToTest != j {\n                sumPd += maxPdToTest\n            }\n        }\n    }\n    \n    \n    if sumPd < i {\n        deficients++\n    } else if sumPd > i {\n        abundants++\n    } else {\n        perfects++\n    }\n}\n\nprintln(\"There are \\(deficients) deficient, \\(perfects) perfect and \\(abundants) abundant integers from 1 to 20000.\")\n", "target": "import java.util.stream.LongStream;\n\npublic class NumberClassifications {\n \n    public static void main(String[] args) {\n        int deficient = 0;\n        int perfect = 0;\n        int abundant = 0;\n \n        for (long i = 1; i <= 20_000; i++) {\n            long sum = properDivsSum(i);\n            if (sum < i)\n                deficient++;\n            else if (sum == i)\n                perfect++;\n            else\n                abundant++;\n        }\n        System.out.println(\"Deficient: \" + deficient);\n        System.out.println(\"Perfect: \" + perfect);\n        System.out.println(\"Abundant: \" + abundant);\n    }\n \n    public static long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n != i && n % i == 0).sum();\n    }\n}\n"}
{"id": 74734, "name": "Abundant, deficient and perfect number classifications", "source": "Translate Swift to Python: var deficients = 0 \nvar perfects = 0 \nvar abundants = 0 \n\n\ndeficients++\n\n\nfor i in 2...20000 {\n\n    var sumPd = 1 \n    \n    var maxPdToTest = i/2 \n\n    for var j = 2; j < maxPdToTest; j++ {\n        \n        if (i%j) == 0 {\n            \n            sumPd += j\n            \n            \n            maxPdToTest = i / j\n            \n            \n            if maxPdToTest != j {\n                sumPd += maxPdToTest\n            }\n        }\n    }\n    \n    \n    if sumPd < i {\n        deficients++\n    } else if sumPd > i {\n        abundants++\n    } else {\n        perfects++\n    }\n}\n\nprintln(\"There are \\(deficients) deficient, \\(perfects) perfect and \\(abundants) abundant integers from 1 to 20000.\")\n", "target": ">>> from proper_divisors import proper_divs\n>>> from collections import Counter\n>>> \n>>> rangemax = 20000\n>>> \n>>> def pdsum(n):\n...     return sum(proper_divs(n))\n... \n>>> def classify(n, p):\n...     return 'perfect' if n == p else 'abundant' if p > n else 'deficient'\n... \n>>> classes = Counter(classify(n, pdsum(n)) for n in range(1, 1 + rangemax))\n>>> classes.most_common()\n[('deficient', 15043), ('abundant', 4953), ('perfect', 4)]\n>>>\n"}
{"id": 74896, "name": "Leonardo numbers", "source": "Translate Swift to C#: struct Leonardo: Sequence, IteratorProtocol {\n    private let add : Int\n    private var n0: Int\n    private var n1: Int\n    \n    init(n0: Int = 1, n1: Int = 1, add: Int = 1) {\n        self.n0 = n0\n        self.n1 = n1\n        self.add = add\n    }\n    \n    mutating func next() -> Int? {\n        let n = n0\n        n0 = n1\n        n1 += n + add\n        return n\n    }\n}\n\nprint(\"First 25 Leonardo numbers:\")\nprint(Leonardo().prefix(25).map{String($0)}.joined(separator: \" \"))\n\nprint(\"First 25 Fibonacci numbers:\")\nprint(Leonardo(n0: 0, add: 0).prefix(25).map{String($0)}.joined(separator: \" \"))\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(string.Join(\" \", Leonardo().Take(25)));\n        Console.WriteLine(string.Join(\" \", Leonardo(L0: 0, L1: 1, add: 0).Take(25)));\n    }\n\n    public static IEnumerable<int> Leonardo(int L0 = 1, int L1 = 1, int add = 1) {\n        while (true) {\n            yield return L0;\n            (L0, L1) = (L1, L0 + L1 + add);\n        }\n    }\n}\n"}
{"id": 74898, "name": "Leonardo numbers", "source": "Translate Swift to Java: struct Leonardo: Sequence, IteratorProtocol {\n    private let add : Int\n    private var n0: Int\n    private var n1: Int\n    \n    init(n0: Int = 1, n1: Int = 1, add: Int = 1) {\n        self.n0 = n0\n        self.n1 = n1\n        self.add = add\n    }\n    \n    mutating func next() -> Int? {\n        let n = n0\n        n0 = n1\n        n1 += n + add\n        return n\n    }\n}\n\nprint(\"First 25 Leonardo numbers:\")\nprint(Leonardo().prefix(25).map{String($0)}.joined(separator: \" \"))\n\nprint(\"First 25 Fibonacci numbers:\")\nprint(Leonardo(n0: 0, add: 0).prefix(25).map{String($0)}.joined(separator: \" \"))\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\n@SuppressWarnings(\"SameParameterValue\")\npublic class LeonardoNumbers {\n    private static List<Integer> leonardo(int n) {\n        return leonardo(n, 1, 1, 1);\n    }\n\n    private static List<Integer> leonardo(int n, int l0, int l1, int add) {\n        Integer[] leo = new Integer[n];\n        leo[0] = l0;\n        leo[1] = l1;\n        for (int i = 2; i < n; i++) {\n            leo[i] = leo[i - 1] + leo[i - 2] + add;\n        }\n        return Arrays.asList(leo);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The first 25 Leonardo numbers with L[0] = 1, L[1] = 1 and add number = 1 are:\");\n        System.out.println(leonardo(25));\n        System.out.println(\"\\nThe first 25 Leonardo numbers with L[0] = 0, L[1] = 1 and add number = 0 are:\");\n        System.out.println(leonardo(25, 0, 1, 0));\n    }\n}\n"}
{"id": 74899, "name": "Leonardo numbers", "source": "Translate Swift to Python: struct Leonardo: Sequence, IteratorProtocol {\n    private let add : Int\n    private var n0: Int\n    private var n1: Int\n    \n    init(n0: Int = 1, n1: Int = 1, add: Int = 1) {\n        self.n0 = n0\n        self.n1 = n1\n        self.add = add\n    }\n    \n    mutating func next() -> Int? {\n        let n = n0\n        n0 = n1\n        n1 += n + add\n        return n\n    }\n}\n\nprint(\"First 25 Leonardo numbers:\")\nprint(Leonardo().prefix(25).map{String($0)}.joined(separator: \" \"))\n\nprint(\"First 25 Fibonacci numbers:\")\nprint(Leonardo(n0: 0, add: 0).prefix(25).map{String($0)}.joined(separator: \" \"))\n", "target": "def Leonardo(L_Zero, L_One, Add, Amount):\n    terms = [L_Zero,L_One]\n    while len(terms) < Amount:\n        new = terms[-1] + terms[-2]\n        new += Add\n        terms.append(new)\n    return terms\n\nout = \"\"\nprint \"First 25 Leonardo numbers:\"\nfor term in Leonardo(1,1,1,25):\n    out += str(term) + \" \"\nprint out\n\nout = \"\"\nprint \"Leonardo numbers with fibonacci parameters:\"\nfor term in Leonardo(0,1,0,25):\n    out += str(term) + \" \"\nprint out\n"}
{"id": 75104, "name": "Variadic function", "source": "Translate Swift to C#: func printAll<T>(things: T...) {\n  \n  for i in things {\n    print(i)\n  }\n}\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        PrintAll(\"test\", \"rosetta code\", 123, 5.6);\n    }\n\n    static void PrintAll(params object[] varargs) {\n        foreach (var i in varargs) {\n            Console.WriteLine(i);\n        }\n    }\n}\n"}
{"id": 75106, "name": "Variadic function", "source": "Translate Swift to Java: func printAll<T>(things: T...) {\n  \n  for i in things {\n    print(i)\n  }\n}\n", "target": "module VariadicFunction\n    {\n    void show(String[] strings)\n        {\n        @Inject Console console;\n        strings.forEach(s -> console.print(s));\n        }\n\n    void run()\n        {\n        show([\"hello\", \"world\"]);\n\n        String s1 = \"not\";\n        String s2 = \"a\";\n        String s3 = \"constant\";\n        String s4 = \"literal\";\n        show([s1, s2, s3, s4]);\n        }\n    }\n"}
{"id": 75107, "name": "Variadic function", "source": "Translate Swift to Python: func printAll<T>(things: T...) {\n  \n  for i in things {\n    print(i)\n  }\n}\n", "target": "def print_all(*things):\n    for x in things:\n        print x\n"}
{"id": 75781, "name": "Exponentiation operator", "source": "Translate Swift to C#: func raise<T: Numeric>(_ base: T, to exponent: Int) -> T {\n    precondition(exponent >= 0, \"Exponent has to be nonnegative\")\n    return Array(repeating: base, count: exponent).reduce(1, *)\n}\n\ninfix operator **: MultiplicationPrecedence\n\nfunc **<T: Numeric>(lhs: T, rhs: Int) -> T {\n    return raise(lhs, to: rhs)\n}\n\nlet someFloat: Float = 2\nlet someInt: Int = 10\n\nassert(raise(someFloat, to: someInt) == 1024)\nassert(someFloat ** someInt == 1024)\nassert(raise(someInt, to: someInt) == 10000000000)\nassert(someInt ** someInt == 10000000000)\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(\"5^5 = \" + Expon(5, 5));\n\tConsole.WriteLine(\"5.5^5 = \" + Expon(5.5, 5));\n\tConsole.ReadLine();\n}\n\nstatic double Expon(int Val, int Pow) \n{\n\treturn Math.Pow(Val, Pow);\n}\nstatic double Expon(double Val, int Pow)\n{\n\treturn Math.Pow(Val, Pow);\n}\n"}
{"id": 75783, "name": "Exponentiation operator", "source": "Translate Swift to Java: func raise<T: Numeric>(_ base: T, to exponent: Int) -> T {\n    precondition(exponent >= 0, \"Exponent has to be nonnegative\")\n    return Array(repeating: base, count: exponent).reduce(1, *)\n}\n\ninfix operator **: MultiplicationPrecedence\n\nfunc **<T: Numeric>(lhs: T, rhs: Int) -> T {\n    return raise(lhs, to: rhs)\n}\n\nlet someFloat: Float = 2\nlet someInt: Int = 10\n\nassert(raise(someFloat, to: someInt) == 1024)\nassert(someFloat ** someInt == 1024)\nassert(raise(someInt, to: someInt) == 10000000000)\nassert(someInt ** someInt == 10000000000)\n", "target": "public class Exp{\n   public static void main(String[] args){\n      System.out.println(pow(2,30));\n      System.out.println(pow(2.0,30)); \n      System.out.println(pow(2.0,-2));\n   }\n\n   public static double pow(double base, int exp){\n      if(exp < 0) return 1 / pow(base, -exp);\n      double ans = 1.0;\n      for(;exp > 0;--exp) ans *= base;\n      return ans;\n   }\n}\n"}
{"id": 75784, "name": "Exponentiation operator", "source": "Translate Swift to Python: func raise<T: Numeric>(_ base: T, to exponent: Int) -> T {\n    precondition(exponent >= 0, \"Exponent has to be nonnegative\")\n    return Array(repeating: base, count: exponent).reduce(1, *)\n}\n\ninfix operator **: MultiplicationPrecedence\n\nfunc **<T: Numeric>(lhs: T, rhs: Int) -> T {\n    return raise(lhs, to: rhs)\n}\n\nlet someFloat: Float = 2\nlet someInt: Int = 10\n\nassert(raise(someFloat, to: someInt) == 1024)\nassert(someFloat ** someInt == 1024)\nassert(raise(someInt, to: someInt) == 10000000000)\nassert(someInt ** someInt == 10000000000)\n", "target": "MULTIPLY = lambda x, y: x*y\n\nclass num(float):\n    \n    \n    def __pow__(self, b):\n        return reduce(MULTIPLY, [self]*b, 1)\n\n\nprint num(2).__pow__(3)\nprint num(2) ** 3\n\n\nprint num(2.3).__pow__(8)\nprint num(2.3) ** 8\n"}
{"id": 76031, "name": "Sorting algorithms_Bubble sort", "source": "Translate Swift to C#: func bubbleSort<T:Comparable>(list:inout[T]) {\n    var done = false\n    while !done {\n        done = true\n        for i in 1..<list.count {\n            if list[i - 1] > list[i] {\n                (list[i], list[i - 1]) = (list[i - 1], list[i])\n                done = false\n            }\n        }\n    }\n}\n\nvar list1 = [3, 1, 7, 5, 2, 5, 3, 8, 4]\nprint(list1)\nbubbleSort(list: &list1)\nprint(list1)\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.BubbleSort\n{\n    public static class BubbleSortMethods\n    {\n        \n        \n        \n        public static void BubbleSort<T>(this List<T> list) where T : IComparable\n        {\n            bool madeChanges;\n            int itemCount = list.Count;\n            do\n            {\n                madeChanges = false;\n                itemCount--;\n                for (int i = 0; i < itemCount; i++)\n                {\n                    if (list[i].CompareTo(list[i + 1]) > 0)\n                    {\n                        T temp = list[i + 1];\n                        list[i + 1] = list[i];\n                        list[i] = temp;\n                        madeChanges = true;\n                    }\n                }\n            } while (madeChanges);\n        }\n    }\n\n    \n    \n    class Program\n    {\n        static void Main()\n        {\n            List<int> testList = new List<int> { 3, 7, 3, 2, 1, -4, 10, 12, 4 };\n            testList.BubbleSort();\n            foreach (var t in testList) Console.Write(t + \" \");\n        }\n    }\n}\n"}
{"id": 76033, "name": "Sorting algorithms_Bubble sort", "source": "Translate Swift to Java: func bubbleSort<T:Comparable>(list:inout[T]) {\n    var done = false\n    while !done {\n        done = true\n        for i in 1..<list.count {\n            if list[i - 1] > list[i] {\n                (list[i], list[i - 1]) = (list[i - 1], list[i])\n                done = false\n            }\n        }\n    }\n}\n\nvar list1 = [3, 1, 7, 5, 2, 5, 3, 8, 4]\nprint(list1)\nbubbleSort(list: &list1)\nprint(list1)\n", "target": "public static <E extends Comparable<? super E>> void bubbleSort(E[] comparable) {\n    boolean changed = false;\n    do {\n        changed = false;\n        for (int a = 0; a < comparable.length - 1; a++) {\n            if (comparable[a].compareTo(comparable[a + 1]) > 0) {\n                E tmp = comparable[a];\n                comparable[a] = comparable[a + 1];\n                comparable[a + 1] = tmp;\n                changed = true;\n            }\n        }\n    } while (changed);\n}\n"}
{"id": 76034, "name": "Sorting algorithms_Bubble sort", "source": "Translate Swift to Python: func bubbleSort<T:Comparable>(list:inout[T]) {\n    var done = false\n    while !done {\n        done = true\n        for i in 1..<list.count {\n            if list[i - 1] > list[i] {\n                (list[i], list[i - 1]) = (list[i - 1], list[i])\n                done = false\n            }\n        }\n    }\n}\n\nvar list1 = [3, 1, 7, 5, 2, 5, 3, 8, 4]\nprint(list1)\nbubbleSort(list: &list1)\nprint(list1)\n", "target": "def bubble_sort(seq):\n    \n    changed = True\n    while changed:\n        changed = False\n        for i in range(len(seq) - 1):\n            if seq[i] > seq[i+1]:\n                seq[i], seq[i+1] = seq[i+1], seq[i]\n                changed = True\n    return seq\n\nif __name__ == \"__main__\":\n   \n\n   from random import shuffle\n\n   testset = [_ for _ in range(100)]\n   testcase = testset.copy() \n   shuffle(testcase)\n   assert testcase != testset  \n   bubble_sort(testcase)\n   assert testcase == testset  \n"}
{"id": 76889, "name": "Approximate equality", "source": "Translate Swift to C#: import Foundation\n\nextension FloatingPoint {\n  @inlinable\n  public func isAlmostEqual(\n    to other: Self,\n    tolerance: Self = Self.ulpOfOne.squareRoot()\n  ) -> Bool {\n    \n    \n    assert(tolerance >= .ulpOfOne && tolerance < 1, \"tolerance should be in [.ulpOfOne, 1).\")\n\n    \n    \n    \n    guard self.isFinite && other.isFinite else {\n      return rescaledAlmostEqual(to: other, tolerance: tolerance)\n    }\n\n    \n    \n    \n    let scale = max(abs(self), abs(other), .leastNormalMagnitude)\n    return abs(self - other) < scale*tolerance\n  }\n\n  @usableFromInline\n  internal func rescaledAlmostEqual(to other: Self, tolerance: Self) -> Bool {\n    \n    \n    if self.isNaN || other.isNaN { return false }\n    if self.isInfinite {\n      if other.isInfinite { return self == other }\n\n      \n      \n      \n      let scaledSelf = Self(sign: self.sign,\n        exponent: Self.greatestFiniteMagnitude.exponent,\n        significand: 1)\n      let scaledOther = Self(sign: .plus,\n        exponent: -1,\n        significand: other)\n\n      \n      return scaledSelf.isAlmostEqual(to: scaledOther, tolerance: tolerance)\n    }\n\n    \n    \n    return other.rescaledAlmostEqual(to: self, tolerance: tolerance)\n  }\n}\n\nlet testCases = [\n  (100000000000000.01, 100000000000000.011),\n  (100.01, 100.011),\n  (10000000000000.001 / 10000.0, 1000000000.0000001000),\n  (0.001, 0.0010000001),\n  (0.000000000000000000000101, 0.0),\n  (sqrt(2) * sqrt(2), 2.0),\n  (-sqrt(2) * sqrt(2), -2.0),\n  (3.14159265358979323846, 3.14159265358979324)\n]\n\nfor testCase in testCases {\n  print(\"\\(testCase.0), \\(testCase.1) => \\(testCase.0.isAlmostEqual(to: testCase.1))\")\n}\n", "target": "using System;\n\npublic static class Program\n{\n    public static void Main() {\n        Test(100000000000000.01, 100000000000000.011);\n        Test(100.01, 100.011);\n        Test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        Test(0.001, 0.0010000001);\n        Test(0.000000000000000000000101, 0.0);\n        Test(Math.Sqrt(2) * Math.Sqrt(2), 2.0);\n        Test(-Math.Sqrt(2) * Math.Sqrt(2), -2.0);\n        Test(3.14159265358979323846, 3.14159265358979324);\n\n        void Test(double a, double b) {\n            const double epsilon = 1e-18;\n            WriteLine($\"{a}, {b} => {a.ApproxEquals(b, epsilon)}\");\n        }\n    }\n\n    public static bool ApproxEquals(this double value, double other, double epsilon) => Math.Abs(value - other) < epsilon;\n}\n"}
{"id": 76890, "name": "Approximate equality", "source": "Translate Swift to C#: import Foundation\n\nextension FloatingPoint {\n  @inlinable\n  public func isAlmostEqual(\n    to other: Self,\n    tolerance: Self = Self.ulpOfOne.squareRoot()\n  ) -> Bool {\n    \n    \n    assert(tolerance >= .ulpOfOne && tolerance < 1, \"tolerance should be in [.ulpOfOne, 1).\")\n\n    \n    \n    \n    guard self.isFinite && other.isFinite else {\n      return rescaledAlmostEqual(to: other, tolerance: tolerance)\n    }\n\n    \n    \n    \n    let scale = max(abs(self), abs(other), .leastNormalMagnitude)\n    return abs(self - other) < scale*tolerance\n  }\n\n  @usableFromInline\n  internal func rescaledAlmostEqual(to other: Self, tolerance: Self) -> Bool {\n    \n    \n    if self.isNaN || other.isNaN { return false }\n    if self.isInfinite {\n      if other.isInfinite { return self == other }\n\n      \n      \n      \n      let scaledSelf = Self(sign: self.sign,\n        exponent: Self.greatestFiniteMagnitude.exponent,\n        significand: 1)\n      let scaledOther = Self(sign: .plus,\n        exponent: -1,\n        significand: other)\n\n      \n      return scaledSelf.isAlmostEqual(to: scaledOther, tolerance: tolerance)\n    }\n\n    \n    \n    return other.rescaledAlmostEqual(to: self, tolerance: tolerance)\n  }\n}\n\nlet testCases = [\n  (100000000000000.01, 100000000000000.011),\n  (100.01, 100.011),\n  (10000000000000.001 / 10000.0, 1000000000.0000001000),\n  (0.001, 0.0010000001),\n  (0.000000000000000000000101, 0.0),\n  (sqrt(2) * sqrt(2), 2.0),\n  (-sqrt(2) * sqrt(2), -2.0),\n  (3.14159265358979323846, 3.14159265358979324)\n]\n\nfor testCase in testCases {\n  print(\"\\(testCase.0), \\(testCase.1) => \\(testCase.0.isAlmostEqual(to: testCase.1))\")\n}\n", "target": "using System;\n\npublic static class Program\n{\n    public static void Main() {\n        Test(100000000000000.01, 100000000000000.011);\n        Test(100.01, 100.011);\n        Test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        Test(0.001, 0.0010000001);\n        Test(0.000000000000000000000101, 0.0);\n        Test(Math.Sqrt(2) * Math.Sqrt(2), 2.0);\n        Test(-Math.Sqrt(2) * Math.Sqrt(2), -2.0);\n        Test(3.14159265358979323846, 3.14159265358979324);\n\n        void Test(double a, double b) {\n            const double epsilon = 1e-18;\n            WriteLine($\"{a}, {b} => {a.ApproxEquals(b, epsilon)}\");\n        }\n    }\n\n    public static bool ApproxEquals(this double value, double other, double epsilon) => Math.Abs(value - other) < epsilon;\n}\n"}
{"id": 76893, "name": "Approximate equality", "source": "Translate Swift to Java: import Foundation\n\nextension FloatingPoint {\n  @inlinable\n  public func isAlmostEqual(\n    to other: Self,\n    tolerance: Self = Self.ulpOfOne.squareRoot()\n  ) -> Bool {\n    \n    \n    assert(tolerance >= .ulpOfOne && tolerance < 1, \"tolerance should be in [.ulpOfOne, 1).\")\n\n    \n    \n    \n    guard self.isFinite && other.isFinite else {\n      return rescaledAlmostEqual(to: other, tolerance: tolerance)\n    }\n\n    \n    \n    \n    let scale = max(abs(self), abs(other), .leastNormalMagnitude)\n    return abs(self - other) < scale*tolerance\n  }\n\n  @usableFromInline\n  internal func rescaledAlmostEqual(to other: Self, tolerance: Self) -> Bool {\n    \n    \n    if self.isNaN || other.isNaN { return false }\n    if self.isInfinite {\n      if other.isInfinite { return self == other }\n\n      \n      \n      \n      let scaledSelf = Self(sign: self.sign,\n        exponent: Self.greatestFiniteMagnitude.exponent,\n        significand: 1)\n      let scaledOther = Self(sign: .plus,\n        exponent: -1,\n        significand: other)\n\n      \n      return scaledSelf.isAlmostEqual(to: scaledOther, tolerance: tolerance)\n    }\n\n    \n    \n    return other.rescaledAlmostEqual(to: self, tolerance: tolerance)\n  }\n}\n\nlet testCases = [\n  (100000000000000.01, 100000000000000.011),\n  (100.01, 100.011),\n  (10000000000000.001 / 10000.0, 1000000000.0000001000),\n  (0.001, 0.0010000001),\n  (0.000000000000000000000101, 0.0),\n  (sqrt(2) * sqrt(2), 2.0),\n  (-sqrt(2) * sqrt(2), -2.0),\n  (3.14159265358979323846, 3.14159265358979324)\n]\n\nfor testCase in testCases {\n  print(\"\\(testCase.0), \\(testCase.1) => \\(testCase.0.isAlmostEqual(to: testCase.1))\")\n}\n", "target": "public class Approximate {\n    private static boolean approxEquals(double value, double other, double epsilon) {\n        return Math.abs(value - other) < epsilon;\n    }\n\n    private static void test(double a, double b) {\n        double epsilon = 1e-18;\n        System.out.printf(\"%f, %f => %s\\n\", a, b, approxEquals(a, b, epsilon));\n    }\n\n    public static void main(String[] args) {\n        test(100000000000000.01, 100000000000000.011);\n        test(100.01, 100.011);\n        test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        test(0.001, 0.0010000001);\n        test(0.000000000000000000000101, 0.0);\n        test(Math.sqrt(2.0) * Math.sqrt(2.0), 2.0);\n        test(-Math.sqrt(2.0) * Math.sqrt(2.0), -2.0);\n        test(3.14159265358979323846, 3.14159265358979324);\n    }\n}\n"}
{"id": 76894, "name": "Approximate equality", "source": "Translate Swift to Java: import Foundation\n\nextension FloatingPoint {\n  @inlinable\n  public func isAlmostEqual(\n    to other: Self,\n    tolerance: Self = Self.ulpOfOne.squareRoot()\n  ) -> Bool {\n    \n    \n    assert(tolerance >= .ulpOfOne && tolerance < 1, \"tolerance should be in [.ulpOfOne, 1).\")\n\n    \n    \n    \n    guard self.isFinite && other.isFinite else {\n      return rescaledAlmostEqual(to: other, tolerance: tolerance)\n    }\n\n    \n    \n    \n    let scale = max(abs(self), abs(other), .leastNormalMagnitude)\n    return abs(self - other) < scale*tolerance\n  }\n\n  @usableFromInline\n  internal func rescaledAlmostEqual(to other: Self, tolerance: Self) -> Bool {\n    \n    \n    if self.isNaN || other.isNaN { return false }\n    if self.isInfinite {\n      if other.isInfinite { return self == other }\n\n      \n      \n      \n      let scaledSelf = Self(sign: self.sign,\n        exponent: Self.greatestFiniteMagnitude.exponent,\n        significand: 1)\n      let scaledOther = Self(sign: .plus,\n        exponent: -1,\n        significand: other)\n\n      \n      return scaledSelf.isAlmostEqual(to: scaledOther, tolerance: tolerance)\n    }\n\n    \n    \n    return other.rescaledAlmostEqual(to: self, tolerance: tolerance)\n  }\n}\n\nlet testCases = [\n  (100000000000000.01, 100000000000000.011),\n  (100.01, 100.011),\n  (10000000000000.001 / 10000.0, 1000000000.0000001000),\n  (0.001, 0.0010000001),\n  (0.000000000000000000000101, 0.0),\n  (sqrt(2) * sqrt(2), 2.0),\n  (-sqrt(2) * sqrt(2), -2.0),\n  (3.14159265358979323846, 3.14159265358979324)\n]\n\nfor testCase in testCases {\n  print(\"\\(testCase.0), \\(testCase.1) => \\(testCase.0.isAlmostEqual(to: testCase.1))\")\n}\n", "target": "public class Approximate {\n    private static boolean approxEquals(double value, double other, double epsilon) {\n        return Math.abs(value - other) < epsilon;\n    }\n\n    private static void test(double a, double b) {\n        double epsilon = 1e-18;\n        System.out.printf(\"%f, %f => %s\\n\", a, b, approxEquals(a, b, epsilon));\n    }\n\n    public static void main(String[] args) {\n        test(100000000000000.01, 100000000000000.011);\n        test(100.01, 100.011);\n        test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        test(0.001, 0.0010000001);\n        test(0.000000000000000000000101, 0.0);\n        test(Math.sqrt(2.0) * Math.sqrt(2.0), 2.0);\n        test(-Math.sqrt(2.0) * Math.sqrt(2.0), -2.0);\n        test(3.14159265358979323846, 3.14159265358979324);\n    }\n}\n"}
{"id": 76895, "name": "Approximate equality", "source": "Translate Swift to Python: import Foundation\n\nextension FloatingPoint {\n  @inlinable\n  public func isAlmostEqual(\n    to other: Self,\n    tolerance: Self = Self.ulpOfOne.squareRoot()\n  ) -> Bool {\n    \n    \n    assert(tolerance >= .ulpOfOne && tolerance < 1, \"tolerance should be in [.ulpOfOne, 1).\")\n\n    \n    \n    \n    guard self.isFinite && other.isFinite else {\n      return rescaledAlmostEqual(to: other, tolerance: tolerance)\n    }\n\n    \n    \n    \n    let scale = max(abs(self), abs(other), .leastNormalMagnitude)\n    return abs(self - other) < scale*tolerance\n  }\n\n  @usableFromInline\n  internal func rescaledAlmostEqual(to other: Self, tolerance: Self) -> Bool {\n    \n    \n    if self.isNaN || other.isNaN { return false }\n    if self.isInfinite {\n      if other.isInfinite { return self == other }\n\n      \n      \n      \n      let scaledSelf = Self(sign: self.sign,\n        exponent: Self.greatestFiniteMagnitude.exponent,\n        significand: 1)\n      let scaledOther = Self(sign: .plus,\n        exponent: -1,\n        significand: other)\n\n      \n      return scaledSelf.isAlmostEqual(to: scaledOther, tolerance: tolerance)\n    }\n\n    \n    \n    return other.rescaledAlmostEqual(to: self, tolerance: tolerance)\n  }\n}\n\nlet testCases = [\n  (100000000000000.01, 100000000000000.011),\n  (100.01, 100.011),\n  (10000000000000.001 / 10000.0, 1000000000.0000001000),\n  (0.001, 0.0010000001),\n  (0.000000000000000000000101, 0.0),\n  (sqrt(2) * sqrt(2), 2.0),\n  (-sqrt(2) * sqrt(2), -2.0),\n  (3.14159265358979323846, 3.14159265358979324)\n]\n\nfor testCase in testCases {\n  print(\"\\(testCase.0), \\(testCase.1) => \\(testCase.0.isAlmostEqual(to: testCase.1))\")\n}\n", "target": "from numpy import sqrt\nfrom math import isclose\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [sqrt(2) * sqrt(2),            2.0],\n              [-sqrt(2) * sqrt(2),          -2.0],\n              [3.14159265358979323846,       3.14159265358979324]]\n\nfor (x, y) in testvalues:\n    maybenot = \"is\" if isclose(x, y) else \"is NOT\"\n    print(x, maybenot, \"approximately equal to \", y)\n"}
{"id": 76896, "name": "Approximate equality", "source": "Translate Swift to Python: import Foundation\n\nextension FloatingPoint {\n  @inlinable\n  public func isAlmostEqual(\n    to other: Self,\n    tolerance: Self = Self.ulpOfOne.squareRoot()\n  ) -> Bool {\n    \n    \n    assert(tolerance >= .ulpOfOne && tolerance < 1, \"tolerance should be in [.ulpOfOne, 1).\")\n\n    \n    \n    \n    guard self.isFinite && other.isFinite else {\n      return rescaledAlmostEqual(to: other, tolerance: tolerance)\n    }\n\n    \n    \n    \n    let scale = max(abs(self), abs(other), .leastNormalMagnitude)\n    return abs(self - other) < scale*tolerance\n  }\n\n  @usableFromInline\n  internal func rescaledAlmostEqual(to other: Self, tolerance: Self) -> Bool {\n    \n    \n    if self.isNaN || other.isNaN { return false }\n    if self.isInfinite {\n      if other.isInfinite { return self == other }\n\n      \n      \n      \n      let scaledSelf = Self(sign: self.sign,\n        exponent: Self.greatestFiniteMagnitude.exponent,\n        significand: 1)\n      let scaledOther = Self(sign: .plus,\n        exponent: -1,\n        significand: other)\n\n      \n      return scaledSelf.isAlmostEqual(to: scaledOther, tolerance: tolerance)\n    }\n\n    \n    \n    return other.rescaledAlmostEqual(to: self, tolerance: tolerance)\n  }\n}\n\nlet testCases = [\n  (100000000000000.01, 100000000000000.011),\n  (100.01, 100.011),\n  (10000000000000.001 / 10000.0, 1000000000.0000001000),\n  (0.001, 0.0010000001),\n  (0.000000000000000000000101, 0.0),\n  (sqrt(2) * sqrt(2), 2.0),\n  (-sqrt(2) * sqrt(2), -2.0),\n  (3.14159265358979323846, 3.14159265358979324)\n]\n\nfor testCase in testCases {\n  print(\"\\(testCase.0), \\(testCase.1) => \\(testCase.0.isAlmostEqual(to: testCase.1))\")\n}\n", "target": "from numpy import sqrt\nfrom math import isclose\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [sqrt(2) * sqrt(2),            2.0],\n              [-sqrt(2) * sqrt(2),          -2.0],\n              [3.14159265358979323846,       3.14159265358979324]]\n\nfor (x, y) in testvalues:\n    maybenot = \"is\" if isclose(x, y) else \"is NOT\"\n    print(x, maybenot, \"approximately equal to \", y)\n"}
{"id": 77151, "name": "Greatest common divisor", "source": "Translate Swift to C#: \n\nfunc gcd(var a: Int, var b: Int) -> Int {\n    \n    a = abs(a); b = abs(b)\n    \n    if (b > a) { swap(&a, &b) }\n\n    while (b > 0) { (a, b) = (b, a % b) }\n    \n    return a\n}\n\n\n\nfunc gcdr (var a: Int, var b: Int) -> Int {\n    \n    a = abs(a); b = abs(b)\n\n    if (b > a) { swap(&a, &b) }\n    \n    return gcd_rec(a,b)\n}\n\n\nprivate func gcd_rec(a: Int, b: Int) -> Int {\n    \n    return b == 0 ? a : gcd_rec(b, a % b)\n}\n\n\nfor (a,b) in [(1,1), (100, -10), (10, -100), (-36, -17), (27, 18), (30, -42)] {\n    \n    println(\"Iterative: GCD of \\(a) and \\(b) is \\(gcd(a, b))\")\n    println(\"Recursive: GCD of \\(a) and \\(b) is \\(gcdr(a, b))\")\n}\n", "target": "static void Main()\n{\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 1, gcd(1, 1));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 10, gcd(1, 10));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 10, 100, gcd(10, 100));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 5, 50, gcd(5, 50));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 8, 24, gcd(8, 24));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 17, gcd(36, 17));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 18, gcd(36, 18));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 19, gcd(36, 19));\n\tfor (int x = 1; x < 36; x++)\n\t{\n\t\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, x, gcd(36, x));\n\t}\n\tConsole.Read();\n}\n \n\n\n\nstatic int gcd(int a, int b)\n{\n    while (b != 0) b = a % (a = b);\n    return a;\n}\n"}
{"id": 77153, "name": "Greatest common divisor", "source": "Translate Swift to Java: \n\nfunc gcd(var a: Int, var b: Int) -> Int {\n    \n    a = abs(a); b = abs(b)\n    \n    if (b > a) { swap(&a, &b) }\n\n    while (b > 0) { (a, b) = (b, a % b) }\n    \n    return a\n}\n\n\n\nfunc gcdr (var a: Int, var b: Int) -> Int {\n    \n    a = abs(a); b = abs(b)\n\n    if (b > a) { swap(&a, &b) }\n    \n    return gcd_rec(a,b)\n}\n\n\nprivate func gcd_rec(a: Int, b: Int) -> Int {\n    \n    return b == 0 ? a : gcd_rec(b, a % b)\n}\n\n\nfor (a,b) in [(1,1), (100, -10), (10, -100), (-36, -17), (27, 18), (30, -42)] {\n    \n    println(\"Iterative: GCD of \\(a) and \\(b) is \\(gcd(a, b))\")\n    println(\"Recursive: GCD of \\(a) and \\(b) is \\(gcdr(a, b))\")\n}\n", "target": "public static long gcd(long a, long b){\n   long factor= Math.min(a, b);\n   for(long loop= factor;loop > 1;loop--){\n      if(a % loop == 0 && b % loop == 0){\n         return loop;\n      }\n   }\n   return 1;\n}\n"}
{"id": 77154, "name": "Greatest common divisor", "source": "Translate Swift to Python: \n\nfunc gcd(var a: Int, var b: Int) -> Int {\n    \n    a = abs(a); b = abs(b)\n    \n    if (b > a) { swap(&a, &b) }\n\n    while (b > 0) { (a, b) = (b, a % b) }\n    \n    return a\n}\n\n\n\nfunc gcdr (var a: Int, var b: Int) -> Int {\n    \n    a = abs(a); b = abs(b)\n\n    if (b > a) { swap(&a, &b) }\n    \n    return gcd_rec(a,b)\n}\n\n\nprivate func gcd_rec(a: Int, b: Int) -> Int {\n    \n    return b == 0 ? a : gcd_rec(b, a % b)\n}\n\n\nfor (a,b) in [(1,1), (100, -10), (10, -100), (-36, -17), (27, 18), (30, -42)] {\n    \n    println(\"Iterative: GCD of \\(a) and \\(b) is \\(gcd(a, b))\")\n    println(\"Recursive: GCD of \\(a) and \\(b) is \\(gcdr(a, b))\")\n}\n", "target": "from fractions import gcd\n"}
{"id": 77431, "name": "Luhn test of credit card numbers", "source": "Translate Swift to C#: func luhn(_ number: String) -> Bool {\n    return number.reversed().enumerated().map({\n        let digit = Int(String($0.element))!\n        let even = $0.offset % 2 == 0\n        return even ? digit : digit == 9 ? 9 : digit * 2 % 9\n    }).reduce(0, +) % 10 == 0\n}\n\nluhn(\"49927398716\") \nluhn(\"49927398717\") \n", "target": "    public static class Luhn\n    {\n        public static bool LuhnCheck(this string cardNumber)\n        {\n            return LuhnCheck(cardNumber.Select(c => c - '0').ToArray());\n        }\n\n        private static bool LuhnCheck(this int[] digits)\n        {\n            return GetCheckValue(digits) == 0;\n        }\n\n        private static int GetCheckValue(int[] digits)\n        {\n            return digits.Select((d, i) => i % 2 == digits.Length % 2 ? ((2 * d) % 10) + d / 5 : d).Sum() % 10;\n        }\n    }\n\n    public static class TestProgram\n    {\n        public static void Main()\n        {\n            long[] testNumbers = {49927398716, 49927398717, 1234567812345678, 1234567812345670};\n            foreach (var testNumber in testNumbers)\n                Console.WriteLine(\"{0} is {1}valid\", testNumber, testNumber.ToString().LuhnCheck() ? \"\" : \"not \");\n        }\n    }\n"}
{"id": 77433, "name": "Luhn test of credit card numbers", "source": "Translate Swift to Java: func luhn(_ number: String) -> Bool {\n    return number.reversed().enumerated().map({\n        let digit = Int(String($0.element))!\n        let even = $0.offset % 2 == 0\n        return even ? digit : digit == 9 ? 9 : digit * 2 % 9\n    }).reduce(0, +) % 10 == 0\n}\n\nluhn(\"49927398716\") \nluhn(\"49927398717\") \n", "target": "public class Luhn {\n    public static void main(String[] args) {\n        System.out.println(luhnTest(\"49927398716\"));\n        System.out.println(luhnTest(\"49927398717\"));\n        System.out.println(luhnTest(\"1234567812345678\"));\n        System.out.println(luhnTest(\"1234567812345670\"));\n    }\n    \n    public static boolean luhnTest(String number){\n        int s1 = 0, s2 = 0;\n        String reverse = new StringBuffer(number).reverse().toString();\n        for(int i = 0 ;i < reverse.length();i++){\n            int digit = Character.digit(reverse.charAt(i), 10);\n            if(i % 2 == 0){\n                s1 += digit;\n            }else{\n                s2 += 2 * digit;\n                if(digit >= 5){\n                    s2 -= 9;\n                }\n            }\n        }\n        return (s1 + s2) % 10 == 0;\n    }\n}\n"}
{"id": 77434, "name": "Luhn test of credit card numbers", "source": "Translate Swift to Python: func luhn(_ number: String) -> Bool {\n    return number.reversed().enumerated().map({\n        let digit = Int(String($0.element))!\n        let even = $0.offset % 2 == 0\n        return even ? digit : digit == 9 ? 9 : digit * 2 % 9\n    }).reduce(0, +) % 10 == 0\n}\n\nluhn(\"49927398716\") \nluhn(\"49927398717\") \n", "target": ">>> def luhn(n):\n\tr = [int(ch) for ch in str(n)][::-1]\n\treturn (sum(r[0::2]) + sum(sum(divmod(d*2,10)) for d in r[1::2])) % 10 == 0\n\n>>> for n in (49927398716, 49927398717, 1234567812345678, 1234567812345670):\n\tprint(n, luhn(n))\n"}
{"id": 77712, "name": "Sorting algorithms_Quicksort", "source": "Translate Swift to C#: func quicksort<T where T : Comparable>(inout elements: [T], range: Range<Int>) {\n  if (range.endIndex - range.startIndex > 1) {\n    let pivotIndex = partition(&elements, range)\n    quicksort(&elements, range.startIndex ..< pivotIndex)\n    quicksort(&elements, pivotIndex+1 ..< range.endIndex)\n  }\n}\n\nfunc quicksort<T where T : Comparable>(inout elements: [T]) {\n  quicksort(&elements, indices(elements))\n}\n", "target": "\n\n\n\n\n#define Tripartite\n\nnamespace RosettaCode {\n  using System;\n  using System.Diagnostics;\n\n  public class QuickSort<T> where T : IComparable {\n    #region Constants\n    public const UInt32 INSERTION_LIMIT_DEFAULT = 12;\n    private const Int32 SAMPLES_MAX = 19;\n    #endregion\n\n    #region Properties\n    public UInt32 InsertionLimit { get; }\n    private T[] Samples { get; }\n    private Int32 Left { get; set; }\n    private Int32 Right { get; set; }\n    private Int32 LeftMedian { get; set; }\n    private Int32 RightMedian { get; set; }\n    #endregion\n\n    #region Constructors\n    public QuickSort(UInt32 insertionLimit = INSERTION_LIMIT_DEFAULT) {\n      this.InsertionLimit = insertionLimit;\n      this.Samples = new T[SAMPLES_MAX];\n    }\n    #endregion\n\n    #region Sort Methods\n    public void Sort(T[] entries) {\n      Sort(entries, 0, entries.Length - 1);\n    }\n\n    public void Sort(T[] entries, Int32 first, Int32 last) {\n      var length = last + 1 - first;\n      while (length > 1) {\n        if (length < InsertionLimit) {\n          InsertionSort<T>.Sort(entries, first, last);\n          return;\n        }\n\n        Left = first;\n        Right = last;\n        var median = pivot(entries);\n        partition(median, entries);\n        \n\n        var leftLength = Right + 1 - first;\n        var rightLength = last + 1 - Left;\n\n        \n        \n        \n        \n        if (leftLength < rightLength) {\n          Sort(entries, first, Right);\n          first = Left;\n          length = rightLength;\n        }\n        else {\n          Sort(entries, Left, last);\n          last = Right;\n          length = leftLength;\n        }\n      }\n    }\n\n    \n    private static Int32 sampleSize(Int32 length, Int32 max = SAMPLES_MAX) {\n      var logLen = (Int32)Math.Log10(length);\n      var samples = Math.Min(2 * logLen + 1, max);\n      return Math.Min(samples, length);\n    }\n\n    \n    \n    private T pivot(T[] entries) {\n      var length = Right + 1 - Left;\n      var samples = sampleSize(length);\n      \n      for (var sample = 0; sample < samples; sample++) {\n        \n        var index = (Int64)length * sample / samples + Left;\n        Samples[sample] = entries[index];\n      }\n\n      InsertionSort<T>.Sort(Samples, 0, samples - 1);\n      return Samples[samples / 2];\n    }\n\n    private void partition(T median, T[] entries) {\n      var first = Left;\n      var last = Right;\n#if Tripartite\n      LeftMedian = first;\n      RightMedian = last;\n#endif\n      while (true) {\n        \n        \n        \n        while (median.CompareTo(entries[Left]) > 0) Left++;\n        while (median.CompareTo(entries[Right]) < 0) Right--;\n\n        \n        if (Right <= Left) break;\n\n        Swap(entries, Left, Right);\n        swapOut(median, entries);\n        Left++;\n        Right--;\n        \n      }\n\n      if (Left == Right) {\n        Left++;\n        Right--;\n      }\n      \n      swapIn(entries, first, last);\n\n      \n      \n    }\n    #endregion\n\n    #region Swap Methods\n    [Conditional(\"Tripartite\")]\n    private void swapOut(T median, T[] entries) {\n      if (median.CompareTo(entries[Left]) == 0) Swap(entries, LeftMedian++, Left);\n      if (median.CompareTo(entries[Right]) == 0) Swap(entries, Right, RightMedian--);\n    }\n\n    [Conditional(\"Tripartite\")]\n    private void swapIn(T[] entries, Int32 first, Int32 last) {\n      \n      while (first < LeftMedian) Swap(entries, first++, Right--);\n      while (RightMedian < last) Swap(entries, Left++, last--);\n    }\n\n    \n    public void Swap(T[] entries, Int32 left, Int32 right) {\n      Swap(ref entries[left], ref entries[right]);\n    }\n\n    \n    public static void Swap(ref T e1, ref T e2) {\n      var e = e1;\n      e1 = e2;\n      e2 = e;\n    }\n    #endregion\n  }\n\n  #region Insertion Sort\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var next = first + 1; next <= last; next++)\n        insert(entries, first, next);\n    }\n\n    \n    private static void insert(T[] entries, Int32 first, Int32 next) {\n      var entry = entries[next];\n      while (next > first && entries[next - 1].CompareTo(entry) > 0)\n        entries[next] = entries[--next];\n      entries[next] = entry;\n    }\n  }\n  #endregion\n}\n"}
{"id": 77714, "name": "Sorting algorithms_Quicksort", "source": "Translate Swift to Java: func quicksort<T where T : Comparable>(inout elements: [T], range: Range<Int>) {\n  if (range.endIndex - range.startIndex > 1) {\n    let pivotIndex = partition(&elements, range)\n    quicksort(&elements, range.startIndex ..< pivotIndex)\n    quicksort(&elements, pivotIndex+1 ..< range.endIndex)\n  }\n}\n\nfunc quicksort<T where T : Comparable>(inout elements: [T]) {\n  quicksort(&elements, indices(elements))\n}\n", "target": "public static <E extends Comparable<? super E>> List<E> quickSort(List<E> arr) {\n    if (arr.isEmpty())\n        return arr;\n    else {\n        E pivot = arr.get(0);\n\n        List<E> less = new LinkedList<E>();\n        List<E> pivotList = new LinkedList<E>();\n        List<E> more = new LinkedList<E>();\n\n        \n        for (E i: arr) {\n            if (i.compareTo(pivot) < 0)\n                less.add(i);\n            else if (i.compareTo(pivot) > 0)\n                more.add(i);\n            else\n                pivotList.add(i);\n        }\n\n        \n        less = quickSort(less);\n        more = quickSort(more);\n\n        \n        less.addAll(pivotList);\n        less.addAll(more);\n        return less;\n    }\n}\n"}
{"id": 77715, "name": "Sorting algorithms_Quicksort", "source": "Translate Swift to Python: func quicksort<T where T : Comparable>(inout elements: [T], range: Range<Int>) {\n  if (range.endIndex - range.startIndex > 1) {\n    let pivotIndex = partition(&elements, range)\n    quicksort(&elements, range.startIndex ..< pivotIndex)\n    quicksort(&elements, pivotIndex+1 ..< range.endIndex)\n  }\n}\n\nfunc quicksort<T where T : Comparable>(inout elements: [T]) {\n  quicksort(&elements, indices(elements))\n}\n", "target": "def quickSort(arr):\n    less = []\n    pivotList = []\n    more = []\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        for i in arr:\n            if i < pivot:\n                less.append(i)\n            elif i > pivot:\n                more.append(i)\n            else:\n                pivotList.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + pivotList + more\n\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\na = quickSort(a)\n"}
{"id": 77930, "name": "Date manipulation", "source": "Translate Swift to C#: import Foundation\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"MMMM dd yyyy hh:mma zzz\"\n\nguard let date = formatter.date(from: \"March 7 2009 7:30pm EST\") else {\n  fatalError()\n}\n\nprint(formatter.string(from: date))\nprint(formatter.string(from: date + 60 * 60 * 12))\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        CultureInfo ci=CultureInfo.CreateSpecificCulture(\"en-US\");\n        string dateString = \"March 7 2009 7:30pm EST\";\n        string format = \"MMMM d yyyy h:mmtt z\";\n        DateTime myDateTime = DateTime.ParseExact(dateString.Replace(\"EST\",\"+6\"),format,ci) ;\n        DateTime newDateTime = myDateTime.AddHours(12).AddDays(1) ;\n        Console.WriteLine(newDateTime.ToString(format).Replace(\"-5\",\"EST\")); \n\n        Console.ReadLine();\n    }\n}\n"}
{"id": 77932, "name": "Date manipulation", "source": "Translate Swift to Java: import Foundation\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"MMMM dd yyyy hh:mma zzz\"\n\nguard let date = formatter.date(from: \"March 7 2009 7:30pm EST\") else {\n  fatalError()\n}\n\nprint(formatter.string(from: date))\nprint(formatter.string(from: date + 60 * 60 * 12))\n", "target": "import java.time.*;\nimport java.time.format.*;\n\nclass Main {  \n  public static void main(String args[]) { \n    String dateStr = \"March 7 2009 7:30pm EST\";\n\n    DateTimeFormatter df = new DateTimeFormatterBuilder()\n\t\t\t\t.parseCaseInsensitive()\n\t\t\t\t.appendPattern(\"MMMM d yyyy h:mma zzz\")\n\t\t\t\t.toFormatter();\n\t\t\n    ZonedDateTime after12Hours = ZonedDateTime.parse(dateStr, df).plusHours(12);\n  \n    System.out.println(\"Date: \" + dateStr);\n    System.out.println(\"+12h: \" + after12Hours.format(df));\n\n    ZonedDateTime after12HoursInCentralEuropeTime = after12Hours.withZoneSameInstant(ZoneId.of(\"CET\"));\n    System.out.println(\"+12h (in Central Europe): \" + after12HoursInCentralEuropeTime.format(df));\n  }\n}\n"}
{"id": 77933, "name": "Date manipulation", "source": "Translate Swift to Python: import Foundation\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"MMMM dd yyyy hh:mma zzz\"\n\nguard let date = formatter.date(from: \"March 7 2009 7:30pm EST\") else {\n  fatalError()\n}\n\nprint(formatter.string(from: date))\nprint(formatter.string(from: date + 60 * 60 * 12))\n", "target": "import datetime\n\ndef mt():\n\tdatime1=\"March 7 2009 7:30pm EST\"\n\tformatting = \"%B %d %Y %I:%M%p \"\n\tdatime2 = datime1[:-3]  \n\ttdelta = datetime.timedelta(hours=12)\t\t\n\ts3 = datetime.datetime.strptime(datime2, formatting)\n\tdatime2 = s3+tdelta\n\tprint datime2.strftime(\"%B %d %Y %I:%M%p %Z\") + datime1[-3:]\n\nmt()\n"}
{"id": 78216, "name": "Rot-13", "source": "Translate Swift to C#: func rot13char(c: UnicodeScalar) -> UnicodeScalar {\n  switch c {\n  case \"A\"...\"M\", \"a\"...\"m\":\n    return UnicodeScalar(UInt32(c) + 13)\n  case \"N\"...\"Z\", \"n\"...\"z\":\n    return UnicodeScalar(UInt32(c) - 13)\n  default:\n    return c\n  }\n}\n\nfunc rot13(str: String) -> String {\n  return String(map(str.unicodeScalars){ c in Character(rot13char(c)) })\n}\n\nprintln(rot13(\"The quick brown fox jumps over the lazy dog\"))\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nclass Program\n{\n    static char Rot13(char c)\n    {\n        if ('a' <= c && c <= 'm' || 'A' <= c && c <= 'M')\n        {\n            return (char)(c + 13);\n        }\n        if ('n' <= c && c <= 'z' || 'N' <= c && c <= 'Z')\n        {\n            return (char)(c - 13);\n        }\n        return c;\n    }\n\n    static string Rot13(string s)\n    {\n        return new string(s.Select(Rot13).ToArray());\n    }\n\n\n    static void Main(string[] args)\n    {\n        foreach (var file in args.Where(file => File.Exists(file)))\n        {\n            Console.WriteLine(Rot13(File.ReadAllText(file)));\n        }\n        if (!args.Any())\n        {\n            Console.WriteLine(Rot13(Console.In.ReadToEnd()));\n        }\n    }\n}\n"}
{"id": 78218, "name": "Rot-13", "source": "Translate Swift to Java: func rot13char(c: UnicodeScalar) -> UnicodeScalar {\n  switch c {\n  case \"A\"...\"M\", \"a\"...\"m\":\n    return UnicodeScalar(UInt32(c) + 13)\n  case \"N\"...\"Z\", \"n\"...\"z\":\n    return UnicodeScalar(UInt32(c) - 13)\n  default:\n    return c\n  }\n}\n\nfunc rot13(str: String) -> String {\n  return String(map(str.unicodeScalars){ c in Character(rot13char(c)) })\n}\n\nprintln(rot13(\"The quick brown fox jumps over the lazy dog\"))\n", "target": "import java.io.*;\n\npublic class Rot13 {\n\n    public static void main(String[] args) throws IOException {\n        if (args.length >= 1) {\n            for (String file : args) {\n                try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {\n                    rot13(in, System.out);\n                }\n            }\n        } else {\n            rot13(System.in, System.out);\n        }\n    }\n\n    private static void rot13(InputStream in, OutputStream out) throws IOException {\n        int ch;\n        while ((ch = in.read()) != -1) {\n            out.write(rot13((char) ch));\n        }\n    }\n\n    private static char rot13(char ch) {\n        if (ch >= 'A' && ch <= 'Z') {\n            return (char) (((ch - 'A') + 13) % 26 + 'A');\n        }\n        if (ch >= 'a' && ch <= 'z') {\n            return (char) (((ch - 'a') + 13) % 26 + 'a');\n        }\n        return ch;\n    }\n}\n"}
{"id": 78219, "name": "Rot-13", "source": "Translate Swift to Python: func rot13char(c: UnicodeScalar) -> UnicodeScalar {\n  switch c {\n  case \"A\"...\"M\", \"a\"...\"m\":\n    return UnicodeScalar(UInt32(c) + 13)\n  case \"N\"...\"Z\", \"n\"...\"z\":\n    return UnicodeScalar(UInt32(c) - 13)\n  default:\n    return c\n  }\n}\n\nfunc rot13(str: String) -> String {\n  return String(map(str.unicodeScalars){ c in Character(rot13char(c)) })\n}\n\nprintln(rot13(\"The quick brown fox jumps over the lazy dog\"))\n", "target": ">>> u'foo'.encode('rot13')\n'sbb'\n>>> 'sbb'.decode('rot13')\nu'foo'\n"}
{"id": 78355, "name": "Parametric polymorphism", "source": "Translate Swift to C#: class Tree<T> {\n  var value: T?\n  var left: Tree<T>?\n  var right: Tree<T>?\n  \n  func replaceAll(value: T?) {\n    self.value = value\n    left?.replaceAll(value)\n    right?.replaceAll(value)\n  }\n}\n", "target": "using System;\n\nclass BinaryTree<T>\n{\n    public T value;\n    public BinaryTree<T> left;\n    public BinaryTree<T> right;\n\n    public BinaryTree(T value)\n    {\n        this.value = value;\n    }\n\n    public BinaryTree<U> Map<U>(Func<T, U> f)\n    {\n        BinaryTree<U> tree = new BinaryTree<U>(f(this.value));\n        if (this.left != null)\n        {\n            tree.left = this.left.Map(f);\n        }\n        if (this.right != null)\n        {\n            tree.right = this.right.Map(f);\n        }\n        return tree;\n    }\n}\n"}
{"id": 78357, "name": "Parametric polymorphism", "source": "Translate Swift to Java: class Tree<T> {\n  var value: T?\n  var left: Tree<T>?\n  var right: Tree<T>?\n  \n  func replaceAll(value: T?) {\n    self.value = value\n    left?.replaceAll(value)\n    right?.replaceAll(value)\n  }\n}\n", "target": "public class Tree<T>{\n\tprivate T value;\n\tprivate Tree<T> left;\n\tprivate Tree<T> right;\n\n\tpublic void replaceAll(T value){\n\t\tthis.value = value;\n\t\tif (left != null)\n\t\t\tleft.replaceAll(value);\n\t\tif (right != null)\n\t\t\tright.replaceAll(value);\n\t}\n}\n"}
{"id": 79533, "name": "Sum multiples of 3 and 5", "source": "Translate Swift to C#: var n:Int=1000\n\nfunc sum(x:Int)->Int{\n\t\n\tvar s:Int=0\n\tfor i in 0...x{\n\t\tif i%3==0 || i%5==0\n\t\t{\n\t\t\ts=s+i\n\t\t}\n\t\t\n\t}\n\treturn s\n}\n\nvar sumofmult:Int=sum(x:n)\nprint(sumofmult)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            List<BigInteger> candidates = new List<BigInteger>(new BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });\n            candidates.Add(BigInteger.Parse(\"100000000000000000000\"));\n\n            foreach (BigInteger candidate in candidates)\n            {\n                BigInteger c = candidate - 1;\n                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);\n                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);\n                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);\n\n                Console.WriteLine(\"The sum of numbers divisible by 3 or 5 between 1 and {0} is {1}\", c, answer3 + answer5 - answer15);\n            }\n\n            Console.ReadKey(true);\n        }\n\n        private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)\n        {\n            BigInteger largest = candidate;\n            while (largest % n > 0)\n                largest--;\n            BigInteger totalCount = (largest / n);\n            BigInteger pairCount = totalCount / 2;\n            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);\n            BigInteger pairSum = largest + n;\n            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);\n        }\n\n    }\n}\n"}
{"id": 79534, "name": "Sum multiples of 3 and 5", "source": "Translate Swift to C#: var n:Int=1000\n\nfunc sum(x:Int)->Int{\n\t\n\tvar s:Int=0\n\tfor i in 0...x{\n\t\tif i%3==0 || i%5==0\n\t\t{\n\t\t\ts=s+i\n\t\t}\n\t\t\n\t}\n\treturn s\n}\n\nvar sumofmult:Int=sum(x:n)\nprint(sumofmult)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            List<BigInteger> candidates = new List<BigInteger>(new BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });\n            candidates.Add(BigInteger.Parse(\"100000000000000000000\"));\n\n            foreach (BigInteger candidate in candidates)\n            {\n                BigInteger c = candidate - 1;\n                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);\n                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);\n                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);\n\n                Console.WriteLine(\"The sum of numbers divisible by 3 or 5 between 1 and {0} is {1}\", c, answer3 + answer5 - answer15);\n            }\n\n            Console.ReadKey(true);\n        }\n\n        private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)\n        {\n            BigInteger largest = candidate;\n            while (largest % n > 0)\n                largest--;\n            BigInteger totalCount = (largest / n);\n            BigInteger pairCount = totalCount / 2;\n            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);\n            BigInteger pairSum = largest + n;\n            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);\n        }\n\n    }\n}\n"}
{"id": 79537, "name": "Sum multiples of 3 and 5", "source": "Translate Swift to Java: var n:Int=1000\n\nfunc sum(x:Int)->Int{\n\t\n\tvar s:Int=0\n\tfor i in 0...x{\n\t\tif i%3==0 || i%5==0\n\t\t{\n\t\t\ts=s+i\n\t\t}\n\t\t\n\t}\n\treturn s\n}\n\nvar sumofmult:Int=sum(x:n)\nprint(sumofmult)\n", "target": "class SumMultiples {\n\tpublic static long getSum(long n) {\n\t\tlong sum = 0;\n\t\tfor (int i = 3; i < n; i++) {\n\t\t\tif (i % 3 == 0 || i % 5 == 0) sum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getSum(1000));\n\t}\n}\n"}
{"id": 79538, "name": "Sum multiples of 3 and 5", "source": "Translate Swift to Java: var n:Int=1000\n\nfunc sum(x:Int)->Int{\n\t\n\tvar s:Int=0\n\tfor i in 0...x{\n\t\tif i%3==0 || i%5==0\n\t\t{\n\t\t\ts=s+i\n\t\t}\n\t\t\n\t}\n\treturn s\n}\n\nvar sumofmult:Int=sum(x:n)\nprint(sumofmult)\n", "target": "class SumMultiples {\n\tpublic static long getSum(long n) {\n\t\tlong sum = 0;\n\t\tfor (int i = 3; i < n; i++) {\n\t\t\tif (i % 3 == 0 || i % 5 == 0) sum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getSum(1000));\n\t}\n}\n"}
{"id": 79539, "name": "Sum multiples of 3 and 5", "source": "Translate Swift to Python: var n:Int=1000\n\nfunc sum(x:Int)->Int{\n\t\n\tvar s:Int=0\n\tfor i in 0...x{\n\t\tif i%3==0 || i%5==0\n\t\t{\n\t\t\ts=s+i\n\t\t}\n\t\t\n\t}\n\treturn s\n}\n\nvar sumofmult:Int=sum(x:n)\nprint(sumofmult)\n", "target": "def sum35a(n):\n    'Direct count'\n    \n    return sum(x for x in range(n) if x%3==0 or x%5==0)\n\ndef sum35b(n): \n    \"Count all the 3's; all the 5's; minus double-counted 3*5's\"\n    \n    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))\n    \ndef sum35c(n):\n    'Sum the arithmetic progressions: sum3 + sum5 - sum15'\n    consts = (3, 5, 15)\n    \n    divs = [(n-1) // c for c in consts]\n    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]\n    return sums[0] + sums[1] - sums[2]\n\n\nfor n in range(1001):\n    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)\n    assert sa == sb == sc  \n\nprint('For n = %7i -> %i\\n' % (n, sc))\n\n\nfor p in range(7):\n    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))\n\n\np = 20\nprint('\\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))\n"}
{"id": 79540, "name": "Sum multiples of 3 and 5", "source": "Translate Swift to Python: var n:Int=1000\n\nfunc sum(x:Int)->Int{\n\t\n\tvar s:Int=0\n\tfor i in 0...x{\n\t\tif i%3==0 || i%5==0\n\t\t{\n\t\t\ts=s+i\n\t\t}\n\t\t\n\t}\n\treturn s\n}\n\nvar sumofmult:Int=sum(x:n)\nprint(sumofmult)\n", "target": "def sum35a(n):\n    'Direct count'\n    \n    return sum(x for x in range(n) if x%3==0 or x%5==0)\n\ndef sum35b(n): \n    \"Count all the 3's; all the 5's; minus double-counted 3*5's\"\n    \n    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))\n    \ndef sum35c(n):\n    'Sum the arithmetic progressions: sum3 + sum5 - sum15'\n    consts = (3, 5, 15)\n    \n    divs = [(n-1) // c for c in consts]\n    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]\n    return sums[0] + sums[1] - sums[2]\n\n\nfor n in range(1001):\n    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)\n    assert sa == sb == sc  \n\nprint('For n = %7i -> %i\\n' % (n, sc))\n\n\nfor p in range(7):\n    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))\n\n\np = 20\nprint('\\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))\n"}
{"id": 79865, "name": "Pascal's triangle", "source": "Translate Swift to C#: func pascal(n:Int)->[Int]{\n    if n==1{\n        let a=[1]\n        print(a)\n        return a\n    }\n    else{\n        var a=pascal(n:n-1)\n        var temp=a\n        for i in 0..<a.count{\n            if i+1==a.count{\n                temp.append(1)\n                break\n            }\n            temp[i+1] = a[i]+a[i+1]\n        }\n        a=temp\n        print(a)\n        return a\n    }\n}\nlet waste = pascal(n:10)\n", "target": "using System;\n\nnamespace RosettaCode {\n\n    class PascalsTriangle {\n\n        public static void CreateTriangle(int n) {\n            if (n > 0) {\n                for (int i = 0; i < n; i++) {\n                    int c = 1;\n                    Console.Write(\" \".PadLeft(2 * (n - 1 - i)));\n                    for (int k = 0; k <= i; k++) {\n                        Console.Write(\"{0}\", c.ToString().PadLeft(3));\n                        c = c * (i - k) / (k + 1);\n                    }\n                    Console.WriteLine();\n                }\n            }\n        }\n\n        public static void Main() {\n            CreateTriangle(8);\n        }\n    }\n}\n"}
{"id": 79867, "name": "Pascal's triangle", "source": "Translate Swift to Java: func pascal(n:Int)->[Int]{\n    if n==1{\n        let a=[1]\n        print(a)\n        return a\n    }\n    else{\n        var a=pascal(n:n-1)\n        var temp=a\n        for i in 0..<a.count{\n            if i+1==a.count{\n                temp.append(1)\n                break\n            }\n            temp[i+1] = a[i]+a[i+1]\n        }\n        a=temp\n        print(a)\n        return a\n    }\n}\nlet waste = pascal(n:10)\n", "target": "import java.util.ArrayList;\n...\npublic static void genPyrN(int rows){\n\tif(rows < 0) return;\n\t\n\tArrayList<Integer> last = new ArrayList<Integer>();\n\tlast.add(1);\n\tSystem.out.println(last);\n\tfor(int i= 1;i <= rows;++i){\n\t\t\n\t\tArrayList<Integer> thisRow= new ArrayList<Integer>();\n\t\tthisRow.add(last.get(0)); \n\t\tfor(int j= 1;j < i;++j){\n\t\t\t\n\t\t\tthisRow.add(last.get(j - 1) + last.get(j));\n\t\t}\n\t\tthisRow.add(last.get(0)); \n\t\tlast= thisRow;\n\t\tSystem.out.println(thisRow);\n\t}\n}\n"}
{"id": 79868, "name": "Pascal's triangle", "source": "Translate Swift to Python: func pascal(n:Int)->[Int]{\n    if n==1{\n        let a=[1]\n        print(a)\n        return a\n    }\n    else{\n        var a=pascal(n:n-1)\n        var temp=a\n        for i in 0..<a.count{\n            if i+1==a.count{\n                temp.append(1)\n                break\n            }\n            temp[i+1] = a[i]+a[i+1]\n        }\n        a=temp\n        print(a)\n        return a\n    }\n}\nlet waste = pascal(n:10)\n", "target": "def pascal(n):\n   \n   row = [1]\n   k = [0]\n   for x in range(max(n,0)):\n      print row\n      row=[l+r for l,r in zip(row+k,k+row)]\n   return n>=1\n"}
{"id": 80149, "name": "Logical operations", "source": "Translate Swift to C#: func logic(a: Bool, b: Bool) {\n  println(\"a AND b: \\(a && b)\");\n  println(\"a OR b: \\(a || b)\");\n  println(\"NOT a: \\(!a)\");\n}\n", "target": "using System;\n\nnamespace LogicalOperations\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool a = true, b = false;\n            Console.WriteLine(\"a and b is {0}\", a && b);\n            Console.WriteLine(\"a or b is {0}\", a || b);\n            Console.WriteLine(\"Not a is {0}\", !a);\n            Console.WriteLine(\"a exclusive-or b is {0}\", a ^ b);\n        }\n    }\n}\n"}
{"id": 80151, "name": "Logical operations", "source": "Translate Swift to Java: func logic(a: Bool, b: Bool) {\n  println(\"a AND b: \\(a && b)\");\n  println(\"a OR b: \\(a || b)\");\n  println(\"NOT a: \\(!a)\");\n}\n", "target": "boolean a = true;\nboolean b = false;\nSystem.Debug('a AND b: ' + (a && b));\nSystem.Debug('a OR b: ' + (a || b));\nSystem.Debug('NOT a: ' + (!a));\nSystem.Debug('a XOR b: ' + (a ^ b));\n"}
{"id": 80152, "name": "Logical operations", "source": "Translate Swift to Python: func logic(a: Bool, b: Bool) {\n  println(\"a AND b: \\(a && b)\");\n  println(\"a OR b: \\(a || b)\");\n  println(\"NOT a: \\(!a)\");\n}\n", "target": "def logic(a, b):\n    print('a and b:', a and b)\n    print('a or b:', a or b)\n    print('not a:', not a)\n"}
{"id": 80526, "name": "Perfect shuffle", "source": "Translate Swift to C#: func perfectShuffle<T>(_ arr: [T]) -> [T]? {\n  guard arr.count & 1 == 0 else {\n    return nil\n  }\n\n  let half = arr.count / 2\n  var res = [T]()\n\n  for i in 0..<half {\n    res.append(arr[i])\n    res.append(arr[i + half])\n  }\n\n  return res\n}\n\nlet decks = [\n  Array(1...8),\n  Array(1...24),\n  Array(1...52),\n  Array(1...100),\n  Array(1...1020),\n  Array(1...1024),\n  Array(1...10000)\n]\n\nfor deck in decks {\n  var shuffled = deck\n  var shuffles = 0\n\n  repeat {\n    shuffled = perfectShuffle(shuffled)!\n    shuffles += 1\n  } while shuffled != deck\n\n  print(\"Deck of \\(shuffled.count) took \\(shuffles) shuffles to get back to original order\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class PerfectShuffle\n{\n    static void Main()\n    {\n        foreach (int input in new [] {8, 24, 52, 100, 1020, 1024, 10000}) {\n            int[] numbers = Enumerable.Range(1, input).ToArray();\n            Console.WriteLine($\"{input} cards: {ShuffleThrough(numbers).Count()}\");\n        }\n\n        IEnumerable<T[]> ShuffleThrough<T>(T[] original) {\n            T[] copy = (T[])original.Clone();\n            do {\n                yield return copy = Shuffle(copy);\n            } while (!Enumerable.SequenceEqual(original, copy));\n        }\n    }\n\n    public static T[] Shuffle<T>(T[] array) {\n        if (array.Length % 2 != 0) throw new ArgumentException(\"Length must be even.\");\n        int half = array.Length / 2;\n        T[] result = new T[array.Length];\n        for (int t = 0, l = 0, r = half; l < half; t+=2, l++, r++) {\n            result[t] = array[l];\n            result[t+1] = array[r];\n        }\n        return result;\n    }\n    \n}\n"}
{"id": 80527, "name": "Perfect shuffle", "source": "Translate Swift to C#: func perfectShuffle<T>(_ arr: [T]) -> [T]? {\n  guard arr.count & 1 == 0 else {\n    return nil\n  }\n\n  let half = arr.count / 2\n  var res = [T]()\n\n  for i in 0..<half {\n    res.append(arr[i])\n    res.append(arr[i + half])\n  }\n\n  return res\n}\n\nlet decks = [\n  Array(1...8),\n  Array(1...24),\n  Array(1...52),\n  Array(1...100),\n  Array(1...1020),\n  Array(1...1024),\n  Array(1...10000)\n]\n\nfor deck in decks {\n  var shuffled = deck\n  var shuffles = 0\n\n  repeat {\n    shuffled = perfectShuffle(shuffled)!\n    shuffles += 1\n  } while shuffled != deck\n\n  print(\"Deck of \\(shuffled.count) took \\(shuffles) shuffles to get back to original order\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class PerfectShuffle\n{\n    static void Main()\n    {\n        foreach (int input in new [] {8, 24, 52, 100, 1020, 1024, 10000}) {\n            int[] numbers = Enumerable.Range(1, input).ToArray();\n            Console.WriteLine($\"{input} cards: {ShuffleThrough(numbers).Count()}\");\n        }\n\n        IEnumerable<T[]> ShuffleThrough<T>(T[] original) {\n            T[] copy = (T[])original.Clone();\n            do {\n                yield return copy = Shuffle(copy);\n            } while (!Enumerable.SequenceEqual(original, copy));\n        }\n    }\n\n    public static T[] Shuffle<T>(T[] array) {\n        if (array.Length % 2 != 0) throw new ArgumentException(\"Length must be even.\");\n        int half = array.Length / 2;\n        T[] result = new T[array.Length];\n        for (int t = 0, l = 0, r = half; l < half; t+=2, l++, r++) {\n            result[t] = array[l];\n            result[t+1] = array[r];\n        }\n        return result;\n    }\n    \n}\n"}
{"id": 80530, "name": "Perfect shuffle", "source": "Translate Swift to Java: func perfectShuffle<T>(_ arr: [T]) -> [T]? {\n  guard arr.count & 1 == 0 else {\n    return nil\n  }\n\n  let half = arr.count / 2\n  var res = [T]()\n\n  for i in 0..<half {\n    res.append(arr[i])\n    res.append(arr[i + half])\n  }\n\n  return res\n}\n\nlet decks = [\n  Array(1...8),\n  Array(1...24),\n  Array(1...52),\n  Array(1...100),\n  Array(1...1020),\n  Array(1...1024),\n  Array(1...10000)\n]\n\nfor deck in decks {\n  var shuffled = deck\n  var shuffles = 0\n\n  repeat {\n    shuffled = perfectShuffle(shuffled)!\n    shuffles += 1\n  } while shuffled != deck\n\n  print(\"Deck of \\(shuffled.count) took \\(shuffles) shuffles to get back to original order\")\n}\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class PerfectShuffle {\n\n    public static void main(String[] args) {\n        int[] sizes = {8, 24, 52, 100, 1020, 1024, 10_000};\n        for (int size : sizes)\n            System.out.printf(\"%5d\u00a0: %5d%n\", size, perfectShuffle(size));\n    }\n\n    static int perfectShuffle(int size) {\n        if (size % 2 != 0)\n            throw new IllegalArgumentException(\"size must be even\");\n\n        int half = size / 2;\n        int[] a = IntStream.range(0, size).toArray();\n        int[] original = a.clone();\n        int[] aa = new int[size];\n\n        for (int count = 1; true; count++) {\n            System.arraycopy(a, 0, aa, 0, size);\n\n            for (int i = 0; i < half; i++) {\n                a[2 * i] = aa[i];\n                a[2 * i + 1] = aa[i + half];\n            }\n\n            if (Arrays.equals(a, original))\n                return count;\n        }\n    }\n}\n"}
{"id": 80531, "name": "Perfect shuffle", "source": "Translate Swift to Java: func perfectShuffle<T>(_ arr: [T]) -> [T]? {\n  guard arr.count & 1 == 0 else {\n    return nil\n  }\n\n  let half = arr.count / 2\n  var res = [T]()\n\n  for i in 0..<half {\n    res.append(arr[i])\n    res.append(arr[i + half])\n  }\n\n  return res\n}\n\nlet decks = [\n  Array(1...8),\n  Array(1...24),\n  Array(1...52),\n  Array(1...100),\n  Array(1...1020),\n  Array(1...1024),\n  Array(1...10000)\n]\n\nfor deck in decks {\n  var shuffled = deck\n  var shuffles = 0\n\n  repeat {\n    shuffled = perfectShuffle(shuffled)!\n    shuffles += 1\n  } while shuffled != deck\n\n  print(\"Deck of \\(shuffled.count) took \\(shuffles) shuffles to get back to original order\")\n}\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class PerfectShuffle {\n\n    public static void main(String[] args) {\n        int[] sizes = {8, 24, 52, 100, 1020, 1024, 10_000};\n        for (int size : sizes)\n            System.out.printf(\"%5d\u00a0: %5d%n\", size, perfectShuffle(size));\n    }\n\n    static int perfectShuffle(int size) {\n        if (size % 2 != 0)\n            throw new IllegalArgumentException(\"size must be even\");\n\n        int half = size / 2;\n        int[] a = IntStream.range(0, size).toArray();\n        int[] original = a.clone();\n        int[] aa = new int[size];\n\n        for (int count = 1; true; count++) {\n            System.arraycopy(a, 0, aa, 0, size);\n\n            for (int i = 0; i < half; i++) {\n                a[2 * i] = aa[i];\n                a[2 * i + 1] = aa[i + half];\n            }\n\n            if (Arrays.equals(a, original))\n                return count;\n        }\n    }\n}\n"}
{"id": 80532, "name": "Perfect shuffle", "source": "Translate Swift to Python: func perfectShuffle<T>(_ arr: [T]) -> [T]? {\n  guard arr.count & 1 == 0 else {\n    return nil\n  }\n\n  let half = arr.count / 2\n  var res = [T]()\n\n  for i in 0..<half {\n    res.append(arr[i])\n    res.append(arr[i + half])\n  }\n\n  return res\n}\n\nlet decks = [\n  Array(1...8),\n  Array(1...24),\n  Array(1...52),\n  Array(1...100),\n  Array(1...1020),\n  Array(1...1024),\n  Array(1...10000)\n]\n\nfor deck in decks {\n  var shuffled = deck\n  var shuffles = 0\n\n  repeat {\n    shuffled = perfectShuffle(shuffled)!\n    shuffles += 1\n  } while shuffled != deck\n\n  print(\"Deck of \\(shuffled.count) took \\(shuffles) shuffles to get back to original order\")\n}\n", "target": "import doctest\nimport random\n\n\ndef flatten(lst):\n    \n    return [i for sublst in lst for i in sublst]\n\ndef magic_shuffle(deck):\n    \n    half = len(deck) // 2 \n    return flatten(zip(deck[:half], deck[half:]))\n\ndef after_how_many_is_equal(shuffle_type,start,end):\n    \n\n    start = shuffle_type(start)\n    counter = 1\n    while start != end:\n        start = shuffle_type(start)\n        counter += 1\n    return counter\n\ndef main():\n    doctest.testmod()\n\n    print(\"Length of the deck of cards | Perfect shuffles needed to obtain the same deck back\")\n    for length in (8, 24, 52, 100, 1020, 1024, 10000):\n        deck = list(range(length))\n        shuffles_needed = after_how_many_is_equal(magic_shuffle,deck,deck)\n        print(\"{} | {}\".format(length,shuffles_needed))\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 80533, "name": "Perfect shuffle", "source": "Translate Swift to Python: func perfectShuffle<T>(_ arr: [T]) -> [T]? {\n  guard arr.count & 1 == 0 else {\n    return nil\n  }\n\n  let half = arr.count / 2\n  var res = [T]()\n\n  for i in 0..<half {\n    res.append(arr[i])\n    res.append(arr[i + half])\n  }\n\n  return res\n}\n\nlet decks = [\n  Array(1...8),\n  Array(1...24),\n  Array(1...52),\n  Array(1...100),\n  Array(1...1020),\n  Array(1...1024),\n  Array(1...10000)\n]\n\nfor deck in decks {\n  var shuffled = deck\n  var shuffles = 0\n\n  repeat {\n    shuffled = perfectShuffle(shuffled)!\n    shuffles += 1\n  } while shuffled != deck\n\n  print(\"Deck of \\(shuffled.count) took \\(shuffles) shuffles to get back to original order\")\n}\n", "target": "import doctest\nimport random\n\n\ndef flatten(lst):\n    \n    return [i for sublst in lst for i in sublst]\n\ndef magic_shuffle(deck):\n    \n    half = len(deck) // 2 \n    return flatten(zip(deck[:half], deck[half:]))\n\ndef after_how_many_is_equal(shuffle_type,start,end):\n    \n\n    start = shuffle_type(start)\n    counter = 1\n    while start != end:\n        start = shuffle_type(start)\n        counter += 1\n    return counter\n\ndef main():\n    doctest.testmod()\n\n    print(\"Length of the deck of cards | Perfect shuffles needed to obtain the same deck back\")\n    for length in (8, 24, 52, 100, 1020, 1024, 10000):\n        deck = list(range(length))\n        shuffles_needed = after_how_many_is_equal(magic_shuffle,deck,deck)\n        print(\"{} | {}\".format(length,shuffles_needed))\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 80984, "name": "Conway's Game of Life", "source": "Translate Swift to C#: struct Cell: Hashable {\n  var x: Int\n  var y: Int\n}\n\nstruct Colony {\n  private var height: Int\n  private var width: Int\n  private var cells: Set<Cell>\n\n  init(cells: Set<Cell>, height: Int, width: Int) {\n    self.cells = cells\n    self.height = height\n    self.width = width\n  }\n\n  private func neighborCounts() -> [Cell: Int] {\n    var counts = [Cell: Int]()\n\n    for cell in cells.flatMap(Colony.neighbors(for:)) {\n      counts[cell, default: 0] += 1\n    }\n\n    return counts\n  }\n\n  private static func neighbors(for cell: Cell) -> [Cell] {\n    return [\n      Cell(x: cell.x - 1, y: cell.y - 1),\n      Cell(x: cell.x,     y: cell.y - 1),\n      Cell(x: cell.x + 1, y: cell.y - 1),\n      Cell(x: cell.x - 1, y: cell.y),\n      Cell(x: cell.x + 1, y: cell.y),\n      Cell(x: cell.x - 1, y: cell.y + 1),\n      Cell(x: cell.x,     y: cell.y + 1),\n      Cell(x: cell.x + 1, y: cell.y + 1),\n    ]\n  }\n\n  func printColony() {\n    for y in 0..<height {\n      for x in 0..<width {\n        let char = cells.contains(Cell(x: x, y: y)) ? \"0\" : \".\"\n\n        print(\"\\(char) \", terminator: \"\")\n      }\n\n      print()\n    }\n  }\n\n  mutating func run(iterations: Int) {\n    print(\"(0)\")\n    printColony()\n    print()\n\n    for i in 1...iterations {\n      print(\"(\\(i))\")\n      runGeneration()\n      printColony()\n      print()\n    }\n  }\n\n  private mutating func runGeneration() {\n    cells = Set(neighborCounts().compactMap({keyValue in\n      switch (keyValue.value, cells.contains(keyValue.key)) {\n      case (2, true), (3, _):\n        return keyValue.key\n      case _:\n        return nil\n      }\n    }))\n  }\n}\n\nlet blinker = [Cell(x: 1, y: 0), Cell(x: 1, y: 1), Cell(x: 1, y: 2)] as Set\n\nvar col = Colony(cells: blinker, height: 3, width: 3)\n\nprint(\"Blinker: \")\ncol.run(iterations: 3)\n\nlet glider = [\n  Cell(x: 1, y: 0),\n  Cell(x: 2, y: 1),\n  Cell(x: 0, y: 2),\n  Cell(x: 1, y: 2),\n  Cell(x: 2, y: 2)\n] as Set\n\ncol = Colony(cells: glider, height: 8, width: 8)\n\nprint(\"Glider: \")\ncol.run(iterations: 20)\n", "target": "using System;\nusing System.Text;\nusing System.Threading;\n \nnamespace ConwaysGameOfLife\n{\n    \n    class Program\n    {\n        \n        private const int DELAY = 50;\n \n        \n        private const ConsoleColor DEAD_COLOR = ConsoleColor.White;\n        private const ConsoleColor LIVE_COLOR = ConsoleColor.Black;\n \n        \n        private const ConsoleColor EXTRA_COLOR = ConsoleColor.Gray;\n \n        private const char EMPTY_BLOCK_CHAR = ' ';\n        private const char FULL_BLOCK_CHAR = '\\u2588';\n \n        \n        private static bool[,] board;\n \n        \n        private static int width = 32;\n        private static int height = 32;\n \n        \n        private static bool loopEdges = true;\n \n \n        static void Main(string[] args)\n        {\n            \n            initializeDemoBoard();\n \n            initializeConsole();\n \n            \n            while (!Console.KeyAvailable || Console.ReadKey(true).Key != ConsoleKey.Escape) {\n                Program.drawBoard();\n                Program.updateBoard();\n \n                \n                Thread.Sleep(DELAY);\n            }\n        }\n \n        \n        private static void initializeConsole()\n        {\n            Console.BackgroundColor = EXTRA_COLOR;\n            Console.Clear();\n \n            Console.CursorVisible = false;\n \n            \n            \n            int width = Math.Max(Program.width, 8) * 2 + 1;\n            int height = Math.Max(Program.height, 8) + 1;\n            Console.SetWindowSize(width, height);\n            Console.SetBufferSize(width, height);\n \n            Console.BackgroundColor = DEAD_COLOR;\n            Console.ForegroundColor = LIVE_COLOR;\n        }\n \n        \n        private static void initializeRandomBoard()\n        {\n            var random = new Random();\n \n            Program.board = new bool[Program.width, Program.height];\n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    \n                    Program.board[x, y] = random.Next(2) == 0;\n                }\n            }\n        }\n \n        \n        private static void initializeDemoBoard()\n        {\n            Program.width = 3;\n            Program.height = 3;\n \n            Program.loopEdges = false;\n \n            Program.board = new bool[3, 3];\n            Program.board[1, 0] = true;\n            Program.board[1, 1] = true;\n            Program.board[1, 2] = true;\n        }\n \n        \n        private static void drawBoard()\n        {\n            \n            var builder = new StringBuilder();\n \n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    char c = Program.board[x, y] ? FULL_BLOCK_CHAR : EMPTY_BLOCK_CHAR;\n \n                    \n                    builder.Append(c);\n                    builder.Append(c);\n                }\n                builder.Append('\\n');\n            }\n \n            \n            Console.SetCursorPosition(0, 0);\n            Console.Write (builder.ToString());\n        }\n \n        \n        private static void updateBoard()\n        {\n            \n            bool[,] newBoard = new bool[Program.width, Program.height];\n \n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    var n = countLiveNeighbors(x, y);\n                    var c = Program.board[x, y];\n \n                    \n                    \n                    newBoard[x, y] = c && (n == 2 || n == 3) || !c && n == 3;\n                }\n            }\n \n            \n            Program.board = newBoard;\n        }\n \n        \n        private static int countLiveNeighbors(int x, int y)\n        {\n            \n            int value = 0;\n \n            \n            for (var j = -1; j <= 1; j++) {\n                \n                if (!Program.loopEdges && y + j < 0 || y + j >= Program.height) {\n                    continue;\n                }\n \n                \n                int k = (y + j + Program.height) % Program.height;\n \n                for (var i = -1; i <= 1; i++) {\n                    \n                    if (!Program.loopEdges && x + i < 0 || x + i >= Program.width) {\n                        continue;\n                    }\n \n                    \n                    int h = (x + i + Program.width) % Program.width;\n \n                    \n                    value += Program.board[h, k] ? 1 : 0;\n                }\n            }\n \n            \n            return value - (Program.board[x, y] ? 1 : 0);\n        }\n    }\n}\n"}
{"id": 80986, "name": "Conway's Game of Life", "source": "Translate Swift to Java: struct Cell: Hashable {\n  var x: Int\n  var y: Int\n}\n\nstruct Colony {\n  private var height: Int\n  private var width: Int\n  private var cells: Set<Cell>\n\n  init(cells: Set<Cell>, height: Int, width: Int) {\n    self.cells = cells\n    self.height = height\n    self.width = width\n  }\n\n  private func neighborCounts() -> [Cell: Int] {\n    var counts = [Cell: Int]()\n\n    for cell in cells.flatMap(Colony.neighbors(for:)) {\n      counts[cell, default: 0] += 1\n    }\n\n    return counts\n  }\n\n  private static func neighbors(for cell: Cell) -> [Cell] {\n    return [\n      Cell(x: cell.x - 1, y: cell.y - 1),\n      Cell(x: cell.x,     y: cell.y - 1),\n      Cell(x: cell.x + 1, y: cell.y - 1),\n      Cell(x: cell.x - 1, y: cell.y),\n      Cell(x: cell.x + 1, y: cell.y),\n      Cell(x: cell.x - 1, y: cell.y + 1),\n      Cell(x: cell.x,     y: cell.y + 1),\n      Cell(x: cell.x + 1, y: cell.y + 1),\n    ]\n  }\n\n  func printColony() {\n    for y in 0..<height {\n      for x in 0..<width {\n        let char = cells.contains(Cell(x: x, y: y)) ? \"0\" : \".\"\n\n        print(\"\\(char) \", terminator: \"\")\n      }\n\n      print()\n    }\n  }\n\n  mutating func run(iterations: Int) {\n    print(\"(0)\")\n    printColony()\n    print()\n\n    for i in 1...iterations {\n      print(\"(\\(i))\")\n      runGeneration()\n      printColony()\n      print()\n    }\n  }\n\n  private mutating func runGeneration() {\n    cells = Set(neighborCounts().compactMap({keyValue in\n      switch (keyValue.value, cells.contains(keyValue.key)) {\n      case (2, true), (3, _):\n        return keyValue.key\n      case _:\n        return nil\n      }\n    }))\n  }\n}\n\nlet blinker = [Cell(x: 1, y: 0), Cell(x: 1, y: 1), Cell(x: 1, y: 2)] as Set\n\nvar col = Colony(cells: blinker, height: 3, width: 3)\n\nprint(\"Blinker: \")\ncol.run(iterations: 3)\n\nlet glider = [\n  Cell(x: 1, y: 0),\n  Cell(x: 2, y: 1),\n  Cell(x: 0, y: 2),\n  Cell(x: 1, y: 2),\n  Cell(x: 2, y: 2)\n] as Set\n\ncol = Colony(cells: glider, height: 8, width: 8)\n\nprint(\"Glider: \")\ncol.run(iterations: 20)\n", "target": "public class GameOfLife{\n\tpublic static void main(String[] args){\n\t\tString[] dish= {\n\t\t\t\t\"_#_\",\n\t\t\t\t\"_#_\",\n\t\t\t\t\"_#_\",};\n\t\tint gens= 3;\n\t\tfor(int i= 0;i < gens;i++){\n\t\t\tSystem.out.println(\"Generation \" + i + \":\");\n\t\t\tprint(dish);\n\t\t\tdish= life(dish);\n\t\t}\n\t}\n\n\tpublic static String[] life(String[] dish){\n\t\tString[] newGen= new String[dish.length];\n\t\tfor(int row= 0;row < dish.length;row++){\n\t\t\tnewGen[row]= \"\";\n\t\t\tfor(int i= 0;i < dish[row].length();i++){\n\t\t\t\tString above= \"\";\n\t\t\t\tString same= \"\";\n\t\t\t\tString below= \"\";\n\t\t\t\tif(i == 0){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i,\n\t\t\t\t\t\t\t\t\ti + 2);\n\t\t\t\t\tsame= dish[row].substring(i + 1, i + 2);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i, i + 2);\n\t\t\t\t}else if(i == dish[row].length() - 1){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i - 1,\n\t\t\t\t\t\t\t\t\ti + 1);\n\t\t\t\t\tsame= dish[row].substring(i - 1, i);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i - 1, i + 1);\n\t\t\t\t}else{\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i - 1,\n\t\t\t\t\t\t\t\t\ti + 2);\n\t\t\t\t\tsame= dish[row].substring(i - 1, i)\n\t\t\t\t\t\t\t\t\t+ dish[row].substring(i + 1, i + 2);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i - 1, i + 2);\n\t\t\t\t}\n\t\t\t\tint neighbors= getNeighbors(above, same, below);\n\t\t\t\tif(neighbors < 2 || neighbors > 3){\n\t\t\t\t\tnewGen[row]+= \"_\";\n\t\t\t\t}else if(neighbors == 3){\n\t\t\t\t\tnewGen[row]+= \"#\";\n\t\t\t\t}else{\n\t\t\t\t\tnewGen[row]+= dish[row].charAt(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn newGen;\n\t}\n\n\tpublic static int getNeighbors(String above, String same, String below){\n\t\tint ans= 0;\n\t\tif(above != null){\n\t\t\tfor(char x: above.toCharArray()){\n\t\t\t\tif(x == '#') ans++;\n\t\t\t}\n\t\t}\n\t\tfor(char x: same.toCharArray()){\n\t\t\tif(x == '#') ans++;\n\t\t}\n\t\tif(below != null){\n\t\t\tfor(char x: below.toCharArray()){\n\t\t\t\tif(x == '#') ans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static void print(String[] dish){\n\t\tfor(String s: dish){\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}\n"}
{"id": 80987, "name": "Conway's Game of Life", "source": "Translate Swift to Python: struct Cell: Hashable {\n  var x: Int\n  var y: Int\n}\n\nstruct Colony {\n  private var height: Int\n  private var width: Int\n  private var cells: Set<Cell>\n\n  init(cells: Set<Cell>, height: Int, width: Int) {\n    self.cells = cells\n    self.height = height\n    self.width = width\n  }\n\n  private func neighborCounts() -> [Cell: Int] {\n    var counts = [Cell: Int]()\n\n    for cell in cells.flatMap(Colony.neighbors(for:)) {\n      counts[cell, default: 0] += 1\n    }\n\n    return counts\n  }\n\n  private static func neighbors(for cell: Cell) -> [Cell] {\n    return [\n      Cell(x: cell.x - 1, y: cell.y - 1),\n      Cell(x: cell.x,     y: cell.y - 1),\n      Cell(x: cell.x + 1, y: cell.y - 1),\n      Cell(x: cell.x - 1, y: cell.y),\n      Cell(x: cell.x + 1, y: cell.y),\n      Cell(x: cell.x - 1, y: cell.y + 1),\n      Cell(x: cell.x,     y: cell.y + 1),\n      Cell(x: cell.x + 1, y: cell.y + 1),\n    ]\n  }\n\n  func printColony() {\n    for y in 0..<height {\n      for x in 0..<width {\n        let char = cells.contains(Cell(x: x, y: y)) ? \"0\" : \".\"\n\n        print(\"\\(char) \", terminator: \"\")\n      }\n\n      print()\n    }\n  }\n\n  mutating func run(iterations: Int) {\n    print(\"(0)\")\n    printColony()\n    print()\n\n    for i in 1...iterations {\n      print(\"(\\(i))\")\n      runGeneration()\n      printColony()\n      print()\n    }\n  }\n\n  private mutating func runGeneration() {\n    cells = Set(neighborCounts().compactMap({keyValue in\n      switch (keyValue.value, cells.contains(keyValue.key)) {\n      case (2, true), (3, _):\n        return keyValue.key\n      case _:\n        return nil\n      }\n    }))\n  }\n}\n\nlet blinker = [Cell(x: 1, y: 0), Cell(x: 1, y: 1), Cell(x: 1, y: 2)] as Set\n\nvar col = Colony(cells: blinker, height: 3, width: 3)\n\nprint(\"Blinker: \")\ncol.run(iterations: 3)\n\nlet glider = [\n  Cell(x: 1, y: 0),\n  Cell(x: 2, y: 1),\n  Cell(x: 0, y: 2),\n  Cell(x: 1, y: 2),\n  Cell(x: 2, y: 2)\n] as Set\n\ncol = Colony(cells: glider, height: 8, width: 8)\n\nprint(\"Glider: \")\ncol.run(iterations: 20)\n", "target": "cell_size = 10\nsample = 10 \nplay = False   \nlast_cell = 0\n\ndef setup():\n    global grid, next_grid, rows, cols\n    size(800, 500)\n\n    rows = height / cell_size\n    cols = width / cell_size\n    grid = empty_grid()\n    next_grid = empty_grid()\n    randomize_grid()\n\n    println(\"Press 'space' to start/stop\")\n    println(\"'e' to clear all cells\")\n    println(\"'b' demonstrate 'blinker'\")\n    println(\"'g' demonstrate glider\")\n    println(\"'r' to randomize grid\")\n    println(\"'+' and '-' to change speed\")\n\ndef draw():\n    background(0)\n    for i in range(cols):\n        x = i * cell_size\n        for j in range(rows):\n            y = j * cell_size\n            current_state = grid[i][j]\n            fill(255)\n            noStroke()\n            if current_state:\n                rect(x, y, cell_size, cell_size)\n            if play:\n                ngbs_alive = calc_ngbs_alive(i, j)\n                result = rule(current_state, ngbs_alive)\n                next_grid[i][j] = result\n                \n    if play and frameCount % sample == 0 and not mousePressed:\n        step()\n\ndef rule(current, ngbs):\n    \n    if ngbs < 2 or ngbs > 3:\n        return 0  \n    elif ngbs == 3:\n        return 1  \n    else:\n        return current  \n\ndef calc_ngbs_alive(i, j):\n    NEIGHBOURS = ((-1, 00), (01, 00),  \n                  (-1, -1), (00, -1),\n                  (01, -1), (-1, 01),\n                  (00, 01), (01, 01))\n    alive = 0\n    for iv, jv in NEIGHBOURS:\n        alive += grid[(i + iv) % cols][(j + jv) % rows]\n    return alive\n\ndef empty_grid():\n    grid = []\n    for _ in range(cols):\n        grid.append([0] * rows)\n    return grid\n\ndef randomize_grid():\n    from random import choice\n    for i in range(cols):\n        for j in range(rows):\n            grid[i][j] = choice((0, 1))\n\ndef step():\n    global grid, next_grid\n    grid = next_grid\n    next_grid = empty_grid()\n\ndef keyReleased():\n    global grid, play, sample\n    if key == \"e\":\n        grid = empty_grid()\n    if key == \"r\":\n        randomize_grid()\n    if key == \"g\":\n         grid[10][10:13] = [0, 1, 0]       \n         grid[11][10:13] = [0, 0, 1]       \n         grid[12][10:13] = [1, 1, 1]       \n    if key == \"b\":\n         grid[10][10:13] = [0, 1, 0]       \n         grid[11][10:13] = [0, 1, 0]       \n         grid[12][10:13] = [0, 1, 0]               \n    if key == \" \":\n        play = not play \n    if  str(key) in '+=':\n        sample = max(sample - 1, 1);\n    if key == '-':\n        sample += 1\n\ndef mousePressed():\n    paint()\n    \ndef mouseDragged():\n    paint()\n\ndef paint():\n    global last_cell\n    i, j = mouseX // cell_size, mouseY // cell_size\n    p = j * cols + i\n    if p != last_cell:\n        last_cell = p\n        grid[i][j] = (1, 0)[grid[i][j]]\n"}
{"id": 82121, "name": "Gaussian elimination", "source": "Translate Swift to C#: func gaussEliminate(_ sys: [[Double]]) -> [Double]? {\n  var system = sys\n\n  let size = system.count\n\n  for i in 0..<size-1 where system[i][i] != 0 {\n    for j in i..<size-1 {\n      let factor = system[j + 1][i] / system[i][i]\n\n      for k in i..<size+1 {\n        system[j + 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  for i in (1..<size).reversed() where system[i][i] != 0 {\n    for j in (1..<i+1).reversed() {\n      let factor = system[j - 1][i] / system[i][i]\n\n      for k in (0..<size+1).reversed() {\n        system[j - 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  var solutions = [Double]()\n\n  for i in 0..<size {\n    guard system[i][i] != 0 else {\n      return nil\n    }\n\n    system[i][size] /= system[i][i]\n    system[i][i] = 1\n    solutions.append(system[i][size])\n  }\n\n  return solutions\n}\n\nlet sys = [\n  [1.00, 0.00, 0.00, 0.00, 0.00, 0.00, -0.01],\n  [1.00, 0.63, 0.39, 0.25, 0.16, 0.10, 0.61],\n  [1.00, 1.26, 1.58, 1.98, 2.49, 3.13, 0.91],\n  [1.00, 1.88, 3.55, 6.70, 12.62, 23.80, 0.99],\n  [1.00, 2.51, 6.32, 15.88, 39.90, 100.28, 0.60],\n  [1.00, 3.14, 9.87, 31.01, 97.41, 306.02, 0.02]\n]\n\nguard let sols = gaussEliminate(sys) else {\n  fatalError(\"No solutions\")\n}\n\nfor (i, f) in sols.enumerated() {\n  print(\"X\\(i + 1) = \\(f)\")\n}\n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal void ElimPartial(Vector B)\n        {\n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                SwapRows(diag, max_row);\n                B.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                    this[diag, col] *= invd;\n                B[diag] *= invd;\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < cols; col++)\n                            this[row, col] -= d * this[diag, col];\n                        B[row] -= d * B[diag];\n                    }\n                }\n            }\n        }\n        \n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 82124, "name": "Gaussian elimination", "source": "Translate Swift to Java: func gaussEliminate(_ sys: [[Double]]) -> [Double]? {\n  var system = sys\n\n  let size = system.count\n\n  for i in 0..<size-1 where system[i][i] != 0 {\n    for j in i..<size-1 {\n      let factor = system[j + 1][i] / system[i][i]\n\n      for k in i..<size+1 {\n        system[j + 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  for i in (1..<size).reversed() where system[i][i] != 0 {\n    for j in (1..<i+1).reversed() {\n      let factor = system[j - 1][i] / system[i][i]\n\n      for k in (0..<size+1).reversed() {\n        system[j - 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  var solutions = [Double]()\n\n  for i in 0..<size {\n    guard system[i][i] != 0 else {\n      return nil\n    }\n\n    system[i][size] /= system[i][i]\n    system[i][i] = 1\n    solutions.append(system[i][size])\n  }\n\n  return solutions\n}\n\nlet sys = [\n  [1.00, 0.00, 0.00, 0.00, 0.00, 0.00, -0.01],\n  [1.00, 0.63, 0.39, 0.25, 0.16, 0.10, 0.61],\n  [1.00, 1.26, 1.58, 1.98, 2.49, 3.13, 0.91],\n  [1.00, 1.88, 3.55, 6.70, 12.62, 23.80, 0.99],\n  [1.00, 2.51, 6.32, 15.88, 39.90, 100.28, 0.60],\n  [1.00, 3.14, 9.87, 31.01, 97.41, 306.02, 0.02]\n]\n\nguard let sols = gaussEliminate(sys) else {\n  fatalError(\"No solutions\")\n}\n\nfor (i, f) in sols.enumerated() {\n  print(\"X\\(i + 1) = \\(f)\")\n}\n", "target": "import java.util.Locale;\n\npublic class GaussianElimination {\n    public static double solve(double[][] a, double[][] b) {\n        if (a == null || b == null || a.length == 0 || b.length == 0) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n        \n        int n = b.length, p = b[0].length;\n        if (a.length != n || a[0].length != n) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n\n        double det = 1.0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int k = i;\n            for (int j = i + 1; j < n; j++) {\n                if (Math.abs(a[j][i]) > Math.abs(a[k][i])) {\n                    k = j;\n                }\n            }\n            \n            if (k != i) {\n                det = -det;\n                \n                for (int j = i; j < n; j++) {\n                    double s = a[i][j];\n                    a[i][j] = a[k][j];\n                    a[k][j] = s;\n                }\n\n                for (int j = 0; j < p; j++) {\n                    double s = b[i][j];\n                    b[i][j] = b[k][j];\n                    b[k][j] = s;\n                }\n            }\n            \n            for (int j = i + 1; j < n; j++) {\n                double s = a[j][i] / a[i][i];\n                for (k = i + 1; k < n; k++) {\n                    a[j][k] -= s * a[i][k];\n                }\n                \n                for (k = 0; k < p; k++) {\n                    b[j][k] -= s * b[i][k];\n                }\n            }\n        }\n        \n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 1; j < n; j++) {\n                double s = a[i][j];\n                for (int k = 0; k < p; k++) {\n                    b[i][k] -= s * b[j][k];\n                }\n            }\n            double s = a[i][i];\n            det *= s;\n            for (int k = 0; k < p; k++) {\n                b[i][k] /= s;\n            }\n        }\n        \n        return det;\n    }\n    \n    public static void main(String[] args) {\n        double[][] a = new double[][] {{4.0, 1.0, 0.0, 0.0, 0.0},\n                                       {1.0, 4.0, 1.0, 0.0, 0.0},\n                                       {0.0, 1.0, 4.0, 1.0, 0.0},\n                                       {0.0, 0.0, 1.0, 4.0, 1.0},\n                                       {0.0, 0.0, 0.0, 1.0, 4.0}};\n\n        double[][] b = new double[][] {{1.0 / 2.0},\n                                       {2.0 / 3.0},\n                                       {3.0 / 4.0},\n                                       {4.0 / 5.0},\n                                       {5.0 / 6.0}};\n                                       \n        double[] x = {39.0 / 400.0,\n                      11.0 / 100.0,\n                      31.0 / 240.0,\n                      37.0 / 300.0,\n                      71.0 / 400.0};\n                                       \n        System.out.println(\"det: \" + solve(a, b));\n        \n\n        for (int i = 0; i < 5; i++) {\n            System.out.printf(Locale.US, \"%12.8f %12.4e\\n\", b[i][0], b[i][0] - x[i]);\n        }\n    }\n}\n"}
{"id": 82125, "name": "Gaussian elimination", "source": "Translate Swift to Java: func gaussEliminate(_ sys: [[Double]]) -> [Double]? {\n  var system = sys\n\n  let size = system.count\n\n  for i in 0..<size-1 where system[i][i] != 0 {\n    for j in i..<size-1 {\n      let factor = system[j + 1][i] / system[i][i]\n\n      for k in i..<size+1 {\n        system[j + 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  for i in (1..<size).reversed() where system[i][i] != 0 {\n    for j in (1..<i+1).reversed() {\n      let factor = system[j - 1][i] / system[i][i]\n\n      for k in (0..<size+1).reversed() {\n        system[j - 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  var solutions = [Double]()\n\n  for i in 0..<size {\n    guard system[i][i] != 0 else {\n      return nil\n    }\n\n    system[i][size] /= system[i][i]\n    system[i][i] = 1\n    solutions.append(system[i][size])\n  }\n\n  return solutions\n}\n\nlet sys = [\n  [1.00, 0.00, 0.00, 0.00, 0.00, 0.00, -0.01],\n  [1.00, 0.63, 0.39, 0.25, 0.16, 0.10, 0.61],\n  [1.00, 1.26, 1.58, 1.98, 2.49, 3.13, 0.91],\n  [1.00, 1.88, 3.55, 6.70, 12.62, 23.80, 0.99],\n  [1.00, 2.51, 6.32, 15.88, 39.90, 100.28, 0.60],\n  [1.00, 3.14, 9.87, 31.01, 97.41, 306.02, 0.02]\n]\n\nguard let sols = gaussEliminate(sys) else {\n  fatalError(\"No solutions\")\n}\n\nfor (i, f) in sols.enumerated() {\n  print(\"X\\(i + 1) = \\(f)\")\n}\n", "target": "import java.util.Locale;\n\npublic class GaussianElimination {\n    public static double solve(double[][] a, double[][] b) {\n        if (a == null || b == null || a.length == 0 || b.length == 0) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n        \n        int n = b.length, p = b[0].length;\n        if (a.length != n || a[0].length != n) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n\n        double det = 1.0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int k = i;\n            for (int j = i + 1; j < n; j++) {\n                if (Math.abs(a[j][i]) > Math.abs(a[k][i])) {\n                    k = j;\n                }\n            }\n            \n            if (k != i) {\n                det = -det;\n                \n                for (int j = i; j < n; j++) {\n                    double s = a[i][j];\n                    a[i][j] = a[k][j];\n                    a[k][j] = s;\n                }\n\n                for (int j = 0; j < p; j++) {\n                    double s = b[i][j];\n                    b[i][j] = b[k][j];\n                    b[k][j] = s;\n                }\n            }\n            \n            for (int j = i + 1; j < n; j++) {\n                double s = a[j][i] / a[i][i];\n                for (k = i + 1; k < n; k++) {\n                    a[j][k] -= s * a[i][k];\n                }\n                \n                for (k = 0; k < p; k++) {\n                    b[j][k] -= s * b[i][k];\n                }\n            }\n        }\n        \n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 1; j < n; j++) {\n                double s = a[i][j];\n                for (int k = 0; k < p; k++) {\n                    b[i][k] -= s * b[j][k];\n                }\n            }\n            double s = a[i][i];\n            det *= s;\n            for (int k = 0; k < p; k++) {\n                b[i][k] /= s;\n            }\n        }\n        \n        return det;\n    }\n    \n    public static void main(String[] args) {\n        double[][] a = new double[][] {{4.0, 1.0, 0.0, 0.0, 0.0},\n                                       {1.0, 4.0, 1.0, 0.0, 0.0},\n                                       {0.0, 1.0, 4.0, 1.0, 0.0},\n                                       {0.0, 0.0, 1.0, 4.0, 1.0},\n                                       {0.0, 0.0, 0.0, 1.0, 4.0}};\n\n        double[][] b = new double[][] {{1.0 / 2.0},\n                                       {2.0 / 3.0},\n                                       {3.0 / 4.0},\n                                       {4.0 / 5.0},\n                                       {5.0 / 6.0}};\n                                       \n        double[] x = {39.0 / 400.0,\n                      11.0 / 100.0,\n                      31.0 / 240.0,\n                      37.0 / 300.0,\n                      71.0 / 400.0};\n                                       \n        System.out.println(\"det: \" + solve(a, b));\n        \n\n        for (int i = 0; i < 5; i++) {\n            System.out.printf(Locale.US, \"%12.8f %12.4e\\n\", b[i][0], b[i][0] - x[i]);\n        }\n    }\n}\n"}
{"id": 82126, "name": "Gaussian elimination", "source": "Translate Swift to Python: func gaussEliminate(_ sys: [[Double]]) -> [Double]? {\n  var system = sys\n\n  let size = system.count\n\n  for i in 0..<size-1 where system[i][i] != 0 {\n    for j in i..<size-1 {\n      let factor = system[j + 1][i] / system[i][i]\n\n      for k in i..<size+1 {\n        system[j + 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  for i in (1..<size).reversed() where system[i][i] != 0 {\n    for j in (1..<i+1).reversed() {\n      let factor = system[j - 1][i] / system[i][i]\n\n      for k in (0..<size+1).reversed() {\n        system[j - 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  var solutions = [Double]()\n\n  for i in 0..<size {\n    guard system[i][i] != 0 else {\n      return nil\n    }\n\n    system[i][size] /= system[i][i]\n    system[i][i] = 1\n    solutions.append(system[i][size])\n  }\n\n  return solutions\n}\n\nlet sys = [\n  [1.00, 0.00, 0.00, 0.00, 0.00, 0.00, -0.01],\n  [1.00, 0.63, 0.39, 0.25, 0.16, 0.10, 0.61],\n  [1.00, 1.26, 1.58, 1.98, 2.49, 3.13, 0.91],\n  [1.00, 1.88, 3.55, 6.70, 12.62, 23.80, 0.99],\n  [1.00, 2.51, 6.32, 15.88, 39.90, 100.28, 0.60],\n  [1.00, 3.14, 9.87, 31.01, 97.41, 306.02, 0.02]\n]\n\nguard let sols = gaussEliminate(sys) else {\n  fatalError(\"No solutions\")\n}\n\nfor (i, f) in sols.enumerated() {\n  print(\"X\\(i + 1) = \\(f)\")\n}\n", "target": "\n\n\nimport copy\nfrom fractions import Fraction\n\ndef gauss(a, b):\n    a = copy.deepcopy(a)\n    b = copy.deepcopy(b)\n    n = len(a)\n    p = len(b[0])\n    det = 1\n    for i in range(n - 1):\n        k = i\n        for j in range(i + 1, n):\n            if abs(a[j][i]) > abs(a[k][i]):\n                k = j\n        if k != i:\n            a[i], a[k] = a[k], a[i]\n            b[i], b[k] = b[k], b[i]\n            det = -det\n            \n        for j in range(i + 1, n):\n            t = a[j][i]/a[i][i]\n            for k in range(i + 1, n):\n                a[j][k] -= t*a[i][k]\n            for k in range(p):\n                b[j][k] -= t*b[i][k]\n                \n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            t = a[i][j]\n            for k in range(p):\n                b[i][k] -= t*b[j][k]\n        t = 1/a[i][i]\n        det *= a[i][i]\n        for j in range(p):\n            b[i][j] *= t\n    return det, b\n\ndef zeromat(p, q):\n    return [[0]*q for i in range(p)]\n\ndef matmul(a, b):\n    n, p = len(a), len(a[0])\n    p1, q = len(b), len(b[0])\n    if p != p1:\n        raise ValueError(\"Incompatible dimensions\")\n    c = zeromat(n, q)\n    for i in range(n):\n        for j in range(q):\n                c[i][j] = sum(a[i][k]*b[k][j] for k in range(p))\n    return c\n\n\ndef mapmat(f, a):\n    return [list(map(f, v)) for v in a]\n\ndef ratmat(a):\n    return mapmat(Fraction, a)\n\n\n\na = [[2, 9, 4], [7, 5, 3], [6, 1, 8]]\nb = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\ndet, c = gauss(a, b)\n\ndet\n-360.0\n\nc\n[[-0.10277777777777776, 0.18888888888888888, -0.019444444444444438],\n[0.10555555555555554, 0.02222222222222223, -0.061111111111111116],\n[0.0638888888888889, -0.14444444444444446, 0.14722222222222223]]\n\n\nmatmul(a, c)\n[[1.0, 0.0, 0.0], [5.551115123125783e-17, 1.0, 0.0],\n[1.1102230246251565e-16, -2.220446049250313e-16, 1.0]]\n\n\n\ndet, c = gauss(ratmat(a), ratmat(b))\n\ndet\nFraction(-360, 1)\n\nc\n[[Fraction(-37, 360), Fraction(17, 90), Fraction(-7, 360)],\n[Fraction(19, 180), Fraction(1, 45), Fraction(-11, 180)],\n[Fraction(23, 360), Fraction(-13, 90), Fraction(53, 360)]]\n\nmatmul(a, c)\n[[Fraction(1, 1), Fraction(0, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(1, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(0, 1), Fraction(1, 1)]]\n"}
{"id": 82127, "name": "Gaussian elimination", "source": "Translate Swift to Python: func gaussEliminate(_ sys: [[Double]]) -> [Double]? {\n  var system = sys\n\n  let size = system.count\n\n  for i in 0..<size-1 where system[i][i] != 0 {\n    for j in i..<size-1 {\n      let factor = system[j + 1][i] / system[i][i]\n\n      for k in i..<size+1 {\n        system[j + 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  for i in (1..<size).reversed() where system[i][i] != 0 {\n    for j in (1..<i+1).reversed() {\n      let factor = system[j - 1][i] / system[i][i]\n\n      for k in (0..<size+1).reversed() {\n        system[j - 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  var solutions = [Double]()\n\n  for i in 0..<size {\n    guard system[i][i] != 0 else {\n      return nil\n    }\n\n    system[i][size] /= system[i][i]\n    system[i][i] = 1\n    solutions.append(system[i][size])\n  }\n\n  return solutions\n}\n\nlet sys = [\n  [1.00, 0.00, 0.00, 0.00, 0.00, 0.00, -0.01],\n  [1.00, 0.63, 0.39, 0.25, 0.16, 0.10, 0.61],\n  [1.00, 1.26, 1.58, 1.98, 2.49, 3.13, 0.91],\n  [1.00, 1.88, 3.55, 6.70, 12.62, 23.80, 0.99],\n  [1.00, 2.51, 6.32, 15.88, 39.90, 100.28, 0.60],\n  [1.00, 3.14, 9.87, 31.01, 97.41, 306.02, 0.02]\n]\n\nguard let sols = gaussEliminate(sys) else {\n  fatalError(\"No solutions\")\n}\n\nfor (i, f) in sols.enumerated() {\n  print(\"X\\(i + 1) = \\(f)\")\n}\n", "target": "\n\n\nimport copy\nfrom fractions import Fraction\n\ndef gauss(a, b):\n    a = copy.deepcopy(a)\n    b = copy.deepcopy(b)\n    n = len(a)\n    p = len(b[0])\n    det = 1\n    for i in range(n - 1):\n        k = i\n        for j in range(i + 1, n):\n            if abs(a[j][i]) > abs(a[k][i]):\n                k = j\n        if k != i:\n            a[i], a[k] = a[k], a[i]\n            b[i], b[k] = b[k], b[i]\n            det = -det\n            \n        for j in range(i + 1, n):\n            t = a[j][i]/a[i][i]\n            for k in range(i + 1, n):\n                a[j][k] -= t*a[i][k]\n            for k in range(p):\n                b[j][k] -= t*b[i][k]\n                \n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            t = a[i][j]\n            for k in range(p):\n                b[i][k] -= t*b[j][k]\n        t = 1/a[i][i]\n        det *= a[i][i]\n        for j in range(p):\n            b[i][j] *= t\n    return det, b\n\ndef zeromat(p, q):\n    return [[0]*q for i in range(p)]\n\ndef matmul(a, b):\n    n, p = len(a), len(a[0])\n    p1, q = len(b), len(b[0])\n    if p != p1:\n        raise ValueError(\"Incompatible dimensions\")\n    c = zeromat(n, q)\n    for i in range(n):\n        for j in range(q):\n                c[i][j] = sum(a[i][k]*b[k][j] for k in range(p))\n    return c\n\n\ndef mapmat(f, a):\n    return [list(map(f, v)) for v in a]\n\ndef ratmat(a):\n    return mapmat(Fraction, a)\n\n\n\na = [[2, 9, 4], [7, 5, 3], [6, 1, 8]]\nb = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\ndet, c = gauss(a, b)\n\ndet\n-360.0\n\nc\n[[-0.10277777777777776, 0.18888888888888888, -0.019444444444444438],\n[0.10555555555555554, 0.02222222222222223, -0.061111111111111116],\n[0.0638888888888889, -0.14444444444444446, 0.14722222222222223]]\n\n\nmatmul(a, c)\n[[1.0, 0.0, 0.0], [5.551115123125783e-17, 1.0, 0.0],\n[1.1102230246251565e-16, -2.220446049250313e-16, 1.0]]\n\n\n\ndet, c = gauss(ratmat(a), ratmat(b))\n\ndet\nFraction(-360, 1)\n\nc\n[[Fraction(-37, 360), Fraction(17, 90), Fraction(-7, 360)],\n[Fraction(19, 180), Fraction(1, 45), Fraction(-11, 180)],\n[Fraction(23, 360), Fraction(-13, 90), Fraction(53, 360)]]\n\nmatmul(a, c)\n[[Fraction(1, 1), Fraction(0, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(1, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(0, 1), Fraction(1, 1)]]\n"}
{"id": 83055, "name": "Wieferich primes", "source": "Translate Swift to C#: func primeSieve(limit: Int) -> [Bool] {\n    guard limit > 0 else {\n        return []\n    }\n    var sieve = Array(repeating: true, count: limit)\n    sieve[0] = false\n    if limit > 1 {\n        sieve[1] = false\n    }\n    if limit > 4 {\n        for i in stride(from: 4, to: limit, by: 2) {\n            sieve[i] = false\n        }\n    }\n    var p = 3\n    while true {\n        var q = p * p\n        if q >= limit {\n            break\n        }\n        if sieve[p] {\n            let inc = 2 * p\n            while q < limit {\n                sieve[q] = false\n                q += inc\n            }\n        }\n        p += 2\n    }\n    return sieve\n}\n\nfunc modpow(base: Int, exponent: Int, mod: Int) -> Int {\n    if mod == 1 {\n        return 0\n    }\n    var result = 1\n    var exp = exponent\n    var b = base\n    b %= mod\n    while exp > 0 {\n        if (exp & 1) == 1 {\n            result = (result * b) % mod\n        }\n        b = (b * b) % mod\n        exp >>= 1\n    }\n    return result\n}\n\nfunc wieferichPrimes(limit: Int) -> [Int] {\n    let sieve = primeSieve(limit: limit)\n    var result: [Int] = []\n    for p in 2..<limit {\n        if sieve[p] && modpow(base: 2, exponent: p - 1, mod: p * p) == 1 {\n            result.append(p)\n        }\n    }\n    return result\n}\n\nlet limit = 5000\nprint(\"Wieferich primes less than \\(limit):\")\nfor p in wieferichPrimes(limit: limit) {\n    print(p)\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace WieferichPrimes {\n    class Program {\n        static long ModPow(long @base, long exp, long mod) {\n            if (mod == 1) {\n                return 0;\n            }\n\n            long result = 1;\n            @base %= mod;\n            for (; exp > 0; exp >>= 1) {\n                if ((exp & 1) == 1) {\n                    result = (result * @base) % mod;\n                }\n                @base = (@base * @base) % mod;\n            }\n            return result;\n        }\n\n        static bool[] PrimeSieve(int limit) {\n            bool[] sieve = Enumerable.Repeat(true, limit).ToArray();\n\n            if (limit > 0) {\n                sieve[0] = false;\n            }\n            if (limit > 1) {\n                sieve[1] = false;\n            }\n\n            for (int i = 4; i < limit; i += 2) {\n                sieve[i] = false;\n            }\n\n            for (int p = 3; ; p += 2) {\n                int q = p * p;\n                if (q >= limit) {\n                    break;\n                }\n                if (sieve[p]) {\n                    int inc = 2 * p;\n                    for (; q < limit; q += inc) {\n                        sieve[q] = false;\n                    }\n                }\n            }\n\n            return sieve;\n        }\n\n        static List<int> WiefreichPrimes(int limit) {\n            bool[] sieve = PrimeSieve(limit);\n            List<int> result = new List<int>();\n            for (int p = 2; p < limit; p++) {\n                if (sieve[p] && ModPow(2, p - 1, p * p) == 1) {\n                    result.Add(p);\n                }\n            }\n            return result;\n        }\n\n        static void Main() {\n            const int limit = 5000;\n            Console.WriteLine(\"Wieferich primes less that {0}:\", limit);\n            foreach (int p in WiefreichPrimes(limit)) {\n                Console.WriteLine(p);\n            }\n        }\n    }\n}\n"}
{"id": 83057, "name": "Wieferich primes", "source": "Translate Swift to Java: func primeSieve(limit: Int) -> [Bool] {\n    guard limit > 0 else {\n        return []\n    }\n    var sieve = Array(repeating: true, count: limit)\n    sieve[0] = false\n    if limit > 1 {\n        sieve[1] = false\n    }\n    if limit > 4 {\n        for i in stride(from: 4, to: limit, by: 2) {\n            sieve[i] = false\n        }\n    }\n    var p = 3\n    while true {\n        var q = p * p\n        if q >= limit {\n            break\n        }\n        if sieve[p] {\n            let inc = 2 * p\n            while q < limit {\n                sieve[q] = false\n                q += inc\n            }\n        }\n        p += 2\n    }\n    return sieve\n}\n\nfunc modpow(base: Int, exponent: Int, mod: Int) -> Int {\n    if mod == 1 {\n        return 0\n    }\n    var result = 1\n    var exp = exponent\n    var b = base\n    b %= mod\n    while exp > 0 {\n        if (exp & 1) == 1 {\n            result = (result * b) % mod\n        }\n        b = (b * b) % mod\n        exp >>= 1\n    }\n    return result\n}\n\nfunc wieferichPrimes(limit: Int) -> [Int] {\n    let sieve = primeSieve(limit: limit)\n    var result: [Int] = []\n    for p in 2..<limit {\n        if sieve[p] && modpow(base: 2, exponent: p - 1, mod: p * p) == 1 {\n            result.append(p)\n        }\n    }\n    return result\n}\n\nlet limit = 5000\nprint(\"Wieferich primes less than \\(limit):\")\nfor p in wieferichPrimes(limit: limit) {\n    print(p)\n}\n", "target": "import java.util.*;\n\npublic class WieferichPrimes {\n    public static void main(String[] args) {\n        final int limit = 5000;\n        System.out.printf(\"Wieferich primes less than %d:\\n\", limit);\n        for (Integer p : wieferichPrimes(limit))\n            System.out.println(p);\n    }    \n\n    private static boolean[] primeSieve(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        if (limit > 0)\n            sieve[0] = false;\n        if (limit > 1)\n            sieve[1] = false;\n        for (int i = 4; i < limit; i += 2)\n            sieve[i] = false;\n        for (int p = 3; ; p += 2) {\n            int q = p * p;\n            if (q >= limit)\n                break;\n            if (sieve[p]) {\n                int inc = 2 * p;\n                for (; q < limit; q += inc)\n                    sieve[q] = false;\n            }\n        }\n        return sieve;\n    }\n\n    private static long modpow(long base, long exp, long mod) {\n        if (mod == 1)\n            return 0;\n        long result = 1;\n        base %= mod;\n        for (; exp > 0; exp >>= 1) {\n            if ((exp & 1) == 1)\n                result = (result * base) % mod;\n            base = (base * base) % mod;\n        }\n        return result;\n    }\n\n    private static List<Integer> wieferichPrimes(int limit) {\n        boolean[] sieve = primeSieve(limit);\n        List<Integer> result = new ArrayList<>();\n        for (int p = 2; p < limit; ++p) {\n            if (sieve[p] && modpow(2, p - 1, p * p) == 1)\n                result.add(p);\n        }\n        return result;\n    }\n}\n"}
{"id": 83058, "name": "Wieferich primes", "source": "Translate Swift to Python: func primeSieve(limit: Int) -> [Bool] {\n    guard limit > 0 else {\n        return []\n    }\n    var sieve = Array(repeating: true, count: limit)\n    sieve[0] = false\n    if limit > 1 {\n        sieve[1] = false\n    }\n    if limit > 4 {\n        for i in stride(from: 4, to: limit, by: 2) {\n            sieve[i] = false\n        }\n    }\n    var p = 3\n    while true {\n        var q = p * p\n        if q >= limit {\n            break\n        }\n        if sieve[p] {\n            let inc = 2 * p\n            while q < limit {\n                sieve[q] = false\n                q += inc\n            }\n        }\n        p += 2\n    }\n    return sieve\n}\n\nfunc modpow(base: Int, exponent: Int, mod: Int) -> Int {\n    if mod == 1 {\n        return 0\n    }\n    var result = 1\n    var exp = exponent\n    var b = base\n    b %= mod\n    while exp > 0 {\n        if (exp & 1) == 1 {\n            result = (result * b) % mod\n        }\n        b = (b * b) % mod\n        exp >>= 1\n    }\n    return result\n}\n\nfunc wieferichPrimes(limit: Int) -> [Int] {\n    let sieve = primeSieve(limit: limit)\n    var result: [Int] = []\n    for p in 2..<limit {\n        if sieve[p] && modpow(base: 2, exponent: p - 1, mod: p * p) == 1 {\n            result.append(p)\n        }\n    }\n    return result\n}\n\nlet limit = 5000\nprint(\"Wieferich primes less than \\(limit):\")\nfor p in wieferichPrimes(limit: limit) {\n    print(p)\n}\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef isWeiferich(p):\n    if not isPrime(p):\n        return False\n    q = 1\n    p2 = p ** 2\n    while p > 1:\n        q = (2 * q) % p2\n        p -= 1\n    if q == 1:\n        return True\n    else:\n        return False\n\n\nif __name__ == '__main__':\n    print(\"Wieferich primes less than 5000: \")\n    for i in range(2, 5001):\n        if isWeiferich(i):\n            print(i)\n"}
{"id": 83234, "name": "AKS test for primes", "source": "Translate Swift to C#: func polynomialCoeffs(n: Int) -> [Int] {\n    var result = [Int](count : n+1, repeatedValue : 0)\n    \n    result[0]=1\n    for i in 1 ..< n/2+1 { \n        result[i] = result[i-1] * (n-i+1)/i;\n    }\n    for i in n/2+1 ..< n+1 { \n        result[i] = result[n-i];\n    }\n    \n    for i in stride(from: 1, through: n, by: 2) {\n        result[i] = -result[i]\n    }\n    \n    return result\n}\n\nfunc isPrime(n: Int) -> Bool {\n    \n    var coeffs = polynomialCoeffs(n)\n    \n    coeffs[0]--\n    coeffs[n]++\n    \n    for i in 1 ... n {\n        if coeffs[i]%n != 0 {\n            return false\n        }\n    }\n    \n    return true\n}\n\nfor i in 0...10 {\n    \n    let coeffs = polynomialCoeffs(i)\n    \n    print(\"(x-1)^\\(i) = \")\n    if i == 0 {\n        print(\"1\")\n    } else {\n        if i == 1 {\n            print(\"x\")\n        } else {\n            print(\"x^\\(i)\")\n            if i == 2 {\n                print(\"\\(coeffs[i-1])x\")\n            } else {\n                for j in 1...(i - 2) {\n                    if j%2 == 0 {\n                        print(\"+\\(coeffs[j])x^\\(i-j)\")\n                    } else {\n                        print(\"\\(coeffs[j])x^\\(i-j)\")\n                    }\n                }\n                if (i-1)%2 == 0 {\n                    print(\"+\\(coeffs[i-1])x\")\n                } else {\n                    print(\"\\(coeffs[i-1])x\")\n                }\n            }\n        }\n        if i%2 == 0 {\n            print(\"+\\(coeffs[i])\")\n        } else {\n            print(\"\\(coeffs[i])\")\n        }\n    }\n    println()\n}\n\nprintln()\nprint(\"Primes under 50\u00a0: \")\n\nfor i in 1...50 {\n    if isPrime(i) {\n        print(\"\\(i) \")\n    }\n}\n", "target": "using System;\n    public class AksTest\n    {\n        static long[] c = new long[100];\n\n        static void Main(string[] args)\n        {\n        for (int n = 0; n < 10; n++) {\n\t\tcoef(n);\n\t\tConsole.Write(\"(x-1)^\" + n + \" = \");\n\t\tshow(n);\n\t\tConsole.WriteLine(\"\");\n\t}\t \n\t   Console.Write(\"Primes:\");\n\t  for (int n = 1; n <= 63; n++)\n\t     if (is_prime(n))\n\t       Console.Write(n + \" \");\n\t \n\t    Console.WriteLine('\\n');\n            Console.ReadLine();\n        }\n\n        static void coef(int n)\n        {\n            int i, j;\n\n            if (n < 0 || n > 63) System.Environment.Exit(0);\n\n            for (c[i = 0] = 1L; i < n; c[0] = -c[0], i++)\n                for (c[1 + (j = i)] = 1L; j > 0; j--)\n                    c[j] = c[j - 1] - c[j];\n        }\n\n        static bool is_prime(int n)\n        {\n            int i;\n\n            coef(n);\n            c[0] += 1;\n            c[i = n] -= 1;\n\n            while (i-- != 0 && (c[i] % n) == 0) ;\n\n            return i < 0;\n        }\n\n        static void show(int n)\n\t    {\n\t\t    do {\n                Console.Write(\"+\" + c[n] + \"x^\" + n);\n\t\t    }while (n-- != 0);\n\t    }\n    }\n"}
{"id": 83236, "name": "AKS test for primes", "source": "Translate Swift to Java: func polynomialCoeffs(n: Int) -> [Int] {\n    var result = [Int](count : n+1, repeatedValue : 0)\n    \n    result[0]=1\n    for i in 1 ..< n/2+1 { \n        result[i] = result[i-1] * (n-i+1)/i;\n    }\n    for i in n/2+1 ..< n+1 { \n        result[i] = result[n-i];\n    }\n    \n    for i in stride(from: 1, through: n, by: 2) {\n        result[i] = -result[i]\n    }\n    \n    return result\n}\n\nfunc isPrime(n: Int) -> Bool {\n    \n    var coeffs = polynomialCoeffs(n)\n    \n    coeffs[0]--\n    coeffs[n]++\n    \n    for i in 1 ... n {\n        if coeffs[i]%n != 0 {\n            return false\n        }\n    }\n    \n    return true\n}\n\nfor i in 0...10 {\n    \n    let coeffs = polynomialCoeffs(i)\n    \n    print(\"(x-1)^\\(i) = \")\n    if i == 0 {\n        print(\"1\")\n    } else {\n        if i == 1 {\n            print(\"x\")\n        } else {\n            print(\"x^\\(i)\")\n            if i == 2 {\n                print(\"\\(coeffs[i-1])x\")\n            } else {\n                for j in 1...(i - 2) {\n                    if j%2 == 0 {\n                        print(\"+\\(coeffs[j])x^\\(i-j)\")\n                    } else {\n                        print(\"\\(coeffs[j])x^\\(i-j)\")\n                    }\n                }\n                if (i-1)%2 == 0 {\n                    print(\"+\\(coeffs[i-1])x\")\n                } else {\n                    print(\"\\(coeffs[i-1])x\")\n                }\n            }\n        }\n        if i%2 == 0 {\n            print(\"+\\(coeffs[i])\")\n        } else {\n            print(\"\\(coeffs[i])\")\n        }\n    }\n    println()\n}\n\nprintln()\nprint(\"Primes under 50\u00a0: \")\n\nfor i in 1...50 {\n    if isPrime(i) {\n        print(\"\\(i) \")\n    }\n}\n", "target": "public class AksTest {\n    private static final long[] c = new long[64];\n\n    public static void main(String[] args) {\n        for (int n = 0; n < 10; n++) {\n            coeff(n);\n            show(n);\n        }\n\n        System.out.print(\"Primes:\");\n        for (int n = 1; n < c.length; n++)\n            if (isPrime(n))\n                System.out.printf(\" %d\", n);\n\n        System.out.println();\n    }\n\n    static void coeff(int n) {\n        c[0] = 1;\n        for (int i = 0; i < n; c[0] = -c[0], i++) {\n            c[1 + i] = 1;\n            for (int j = i; j > 0; j--)\n                c[j] = c[j - 1] - c[j];\n        }\n    }\n\n    static boolean isPrime(int n) {\n        coeff(n);\n        c[0]++;\n        c[n]--;\n\n        int i = n;\n        while (i-- != 0 && c[i] % n == 0)\n            continue;\n        return i < 0;\n    }\n\n    static void show(int n) {\n        System.out.print(\"(x-1)^\" + n + \" =\");\n        for (int i = n; i >= 0; i--) {\n            System.out.print(\" + \" + c[i] + \"x^\" + i);\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 83237, "name": "AKS test for primes", "source": "Translate Swift to Python: func polynomialCoeffs(n: Int) -> [Int] {\n    var result = [Int](count : n+1, repeatedValue : 0)\n    \n    result[0]=1\n    for i in 1 ..< n/2+1 { \n        result[i] = result[i-1] * (n-i+1)/i;\n    }\n    for i in n/2+1 ..< n+1 { \n        result[i] = result[n-i];\n    }\n    \n    for i in stride(from: 1, through: n, by: 2) {\n        result[i] = -result[i]\n    }\n    \n    return result\n}\n\nfunc isPrime(n: Int) -> Bool {\n    \n    var coeffs = polynomialCoeffs(n)\n    \n    coeffs[0]--\n    coeffs[n]++\n    \n    for i in 1 ... n {\n        if coeffs[i]%n != 0 {\n            return false\n        }\n    }\n    \n    return true\n}\n\nfor i in 0...10 {\n    \n    let coeffs = polynomialCoeffs(i)\n    \n    print(\"(x-1)^\\(i) = \")\n    if i == 0 {\n        print(\"1\")\n    } else {\n        if i == 1 {\n            print(\"x\")\n        } else {\n            print(\"x^\\(i)\")\n            if i == 2 {\n                print(\"\\(coeffs[i-1])x\")\n            } else {\n                for j in 1...(i - 2) {\n                    if j%2 == 0 {\n                        print(\"+\\(coeffs[j])x^\\(i-j)\")\n                    } else {\n                        print(\"\\(coeffs[j])x^\\(i-j)\")\n                    }\n                }\n                if (i-1)%2 == 0 {\n                    print(\"+\\(coeffs[i-1])x\")\n                } else {\n                    print(\"\\(coeffs[i-1])x\")\n                }\n            }\n        }\n        if i%2 == 0 {\n            print(\"+\\(coeffs[i])\")\n        } else {\n            print(\"\\(coeffs[i])\")\n        }\n    }\n    println()\n}\n\nprintln()\nprint(\"Primes under 50\u00a0: \")\n\nfor i in 1...50 {\n    if isPrime(i) {\n        print(\"\\(i) \")\n    }\n}\n", "target": "def expand_x_1(n): \n\n    c =1\n    for i in range(n//2+1):\n        c = c*(n-i)//(i+1)\n        yield c\n        \ndef aks(p):\n    if p==2:\n        return True\n\n    for i in expand_x_1(p):\n        if i % p:\n\n            return False\n    return True\n"}
{"id": 83906, "name": "Loops_N plus one half", "source": "Translate Swift to C#: for var i = 1; ; i++ {\n    print(i)\n    if i == 10 {\n        println()\n        break\n    }\n    print(\", \")\n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 1; ; i++)\n        {\n            Console.Write(i);\n            if (i == 10) break;\n            Console.Write(\", \");\n        }\n        Console.WriteLine();\n    }\n}\n"}
{"id": 83908, "name": "Loops_N plus one half", "source": "Translate Swift to Java: for var i = 1; ; i++ {\n    print(i)\n    if i == 10 {\n        println()\n        break\n    }\n    print(\", \")\n}\n", "target": "var out = System.out\nfor(i in 1..10) {\n  if(i > 1) out.print(\", \")\n  out.print(i)\n}\n"}
{"id": 83909, "name": "Loops_N plus one half", "source": "Translate Swift to Python: for var i = 1; ; i++ {\n    print(i)\n    if i == 10 {\n        println()\n        break\n    }\n    print(\", \")\n}\n", "target": "print ( ', '.join(str(i+1) for i in range(10)) )\n"}
{"id": 84316, "name": "Euler's sum of powers conjecture", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nfunc sumOfPowers(maxN: Int = 250) -> (Int, Int, Int, Int, Int) {\n  let pow5 = (0..<maxN).map({ $0.power(5) })\n  let pow5ToN = {n in pow5.firstIndex(of: n)}\n\n  for x0 in 1..<maxN {\n    for x1 in 1..<x0 {\n      for x2 in 1..<x1 {\n        for x3 in 1..<x2 {\n          let powSum = pow5[x0] + pow5[x1] + pow5[x2] + pow5[x3]\n\n          if let idx = pow5ToN(powSum) {\n            return (x0, x1, x2, x3, idx)\n          }\n        }\n      }\n    }\n  }\n\n  fatalError(\"Did not find solution\")\n}\n\nlet (x0, x1, x2, x3, y) = sumOfPowers()\n\nprint(\"\\(x0)^5 + \\(x1)^5 + \\(x2)^5 \\(x3)^5 = \\(y)^5\")\n", "target": "using System;\n\nnamespace EulerSumOfPowers {\n    class Program {\n        const int MAX_NUMBER = 250;\n\n        static void Main(string[] args) {\n            bool found = false;\n            long[] fifth = new long[MAX_NUMBER];\n\n            for (int i = 1; i <= MAX_NUMBER; i++) {\n                long i2 = i * i;\n                fifth[i - 1] = i2 * i2 * i;\n            }\n\n            for (int a = 0; a < MAX_NUMBER && !found; a++) {\n                for (int b = a; b < MAX_NUMBER && !found; b++) {\n                    for (int c = b; c < MAX_NUMBER && !found; c++) {\n                        for (int d = c; d < MAX_NUMBER && !found; d++) {\n                            long sum = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                            int e = Array.BinarySearch(fifth, sum);\n                            found = e >= 0;\n                            if (found) {\n                                Console.WriteLine(\"{0}^5 + {1}^5 + {2}^5 + {3}^5 = {4}^5\", a + 1, b + 1, c + 1, d + 1, e + 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 84317, "name": "Euler's sum of powers conjecture", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nfunc sumOfPowers(maxN: Int = 250) -> (Int, Int, Int, Int, Int) {\n  let pow5 = (0..<maxN).map({ $0.power(5) })\n  let pow5ToN = {n in pow5.firstIndex(of: n)}\n\n  for x0 in 1..<maxN {\n    for x1 in 1..<x0 {\n      for x2 in 1..<x1 {\n        for x3 in 1..<x2 {\n          let powSum = pow5[x0] + pow5[x1] + pow5[x2] + pow5[x3]\n\n          if let idx = pow5ToN(powSum) {\n            return (x0, x1, x2, x3, idx)\n          }\n        }\n      }\n    }\n  }\n\n  fatalError(\"Did not find solution\")\n}\n\nlet (x0, x1, x2, x3, y) = sumOfPowers()\n\nprint(\"\\(x0)^5 + \\(x1)^5 + \\(x2)^5 \\(x3)^5 = \\(y)^5\")\n", "target": "using System;\n\nnamespace EulerSumOfPowers {\n    class Program {\n        const int MAX_NUMBER = 250;\n\n        static void Main(string[] args) {\n            bool found = false;\n            long[] fifth = new long[MAX_NUMBER];\n\n            for (int i = 1; i <= MAX_NUMBER; i++) {\n                long i2 = i * i;\n                fifth[i - 1] = i2 * i2 * i;\n            }\n\n            for (int a = 0; a < MAX_NUMBER && !found; a++) {\n                for (int b = a; b < MAX_NUMBER && !found; b++) {\n                    for (int c = b; c < MAX_NUMBER && !found; c++) {\n                        for (int d = c; d < MAX_NUMBER && !found; d++) {\n                            long sum = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                            int e = Array.BinarySearch(fifth, sum);\n                            found = e >= 0;\n                            if (found) {\n                                Console.WriteLine(\"{0}^5 + {1}^5 + {2}^5 + {3}^5 = {4}^5\", a + 1, b + 1, c + 1, d + 1, e + 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 84320, "name": "Euler's sum of powers conjecture", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nfunc sumOfPowers(maxN: Int = 250) -> (Int, Int, Int, Int, Int) {\n  let pow5 = (0..<maxN).map({ $0.power(5) })\n  let pow5ToN = {n in pow5.firstIndex(of: n)}\n\n  for x0 in 1..<maxN {\n    for x1 in 1..<x0 {\n      for x2 in 1..<x1 {\n        for x3 in 1..<x2 {\n          let powSum = pow5[x0] + pow5[x1] + pow5[x2] + pow5[x3]\n\n          if let idx = pow5ToN(powSum) {\n            return (x0, x1, x2, x3, idx)\n          }\n        }\n      }\n    }\n  }\n\n  fatalError(\"Did not find solution\")\n}\n\nlet (x0, x1, x2, x3, y) = sumOfPowers()\n\nprint(\"\\(x0)^5 + \\(x1)^5 + \\(x2)^5 \\(x3)^5 = \\(y)^5\")\n", "target": "public class eulerSopConjecture\n{\n\n    static final int    MAX_NUMBER = 250;\n\n    public static void main( String[] args )\n    {\n        boolean found = false;\n        long[]  fifth = new long[ MAX_NUMBER ];\n\n        for( int i = 1; i <= MAX_NUMBER; i ++ )\n        {\n            long i2 =  i * i;\n            fifth[ i - 1 ] = i2 * i2 * i;\n        } \n\n        for( int a = 0; a < MAX_NUMBER && ! found ; a ++ )\n        {\n            for( int b = a; b < MAX_NUMBER && ! found ; b ++ )\n            {\n                for( int c = b; c < MAX_NUMBER && ! found ; c ++ )\n                {\n                    for( int d = c; d < MAX_NUMBER && ! found ; d ++ )\n                    {\n                        long sum  = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                        int  e = java.util.Arrays.binarySearch( fifth, sum );\n                        found  = ( e >= 0 );\n                        if( found )\n                        {\n                            \n                            System.out.print( (a+1) + \"^5 + \"\n                                            + (b+1) + \"^5 + \"\n                                            + (c+1) + \"^5 + \"\n                                            + (d+1) + \"^5 = \"\n                                            + (e+1) + \"^5\"\n                                            );\n                        } \n                    } \n                } \n            } \n        } \n    } \n\n} \n"}
{"id": 84321, "name": "Euler's sum of powers conjecture", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nfunc sumOfPowers(maxN: Int = 250) -> (Int, Int, Int, Int, Int) {\n  let pow5 = (0..<maxN).map({ $0.power(5) })\n  let pow5ToN = {n in pow5.firstIndex(of: n)}\n\n  for x0 in 1..<maxN {\n    for x1 in 1..<x0 {\n      for x2 in 1..<x1 {\n        for x3 in 1..<x2 {\n          let powSum = pow5[x0] + pow5[x1] + pow5[x2] + pow5[x3]\n\n          if let idx = pow5ToN(powSum) {\n            return (x0, x1, x2, x3, idx)\n          }\n        }\n      }\n    }\n  }\n\n  fatalError(\"Did not find solution\")\n}\n\nlet (x0, x1, x2, x3, y) = sumOfPowers()\n\nprint(\"\\(x0)^5 + \\(x1)^5 + \\(x2)^5 \\(x3)^5 = \\(y)^5\")\n", "target": "public class eulerSopConjecture\n{\n\n    static final int    MAX_NUMBER = 250;\n\n    public static void main( String[] args )\n    {\n        boolean found = false;\n        long[]  fifth = new long[ MAX_NUMBER ];\n\n        for( int i = 1; i <= MAX_NUMBER; i ++ )\n        {\n            long i2 =  i * i;\n            fifth[ i - 1 ] = i2 * i2 * i;\n        } \n\n        for( int a = 0; a < MAX_NUMBER && ! found ; a ++ )\n        {\n            for( int b = a; b < MAX_NUMBER && ! found ; b ++ )\n            {\n                for( int c = b; c < MAX_NUMBER && ! found ; c ++ )\n                {\n                    for( int d = c; d < MAX_NUMBER && ! found ; d ++ )\n                    {\n                        long sum  = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                        int  e = java.util.Arrays.binarySearch( fifth, sum );\n                        found  = ( e >= 0 );\n                        if( found )\n                        {\n                            \n                            System.out.print( (a+1) + \"^5 + \"\n                                            + (b+1) + \"^5 + \"\n                                            + (c+1) + \"^5 + \"\n                                            + (d+1) + \"^5 = \"\n                                            + (e+1) + \"^5\"\n                                            );\n                        } \n                    } \n                } \n            } \n        } \n    } \n\n} \n"}
{"id": 84322, "name": "Euler's sum of powers conjecture", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nfunc sumOfPowers(maxN: Int = 250) -> (Int, Int, Int, Int, Int) {\n  let pow5 = (0..<maxN).map({ $0.power(5) })\n  let pow5ToN = {n in pow5.firstIndex(of: n)}\n\n  for x0 in 1..<maxN {\n    for x1 in 1..<x0 {\n      for x2 in 1..<x1 {\n        for x3 in 1..<x2 {\n          let powSum = pow5[x0] + pow5[x1] + pow5[x2] + pow5[x3]\n\n          if let idx = pow5ToN(powSum) {\n            return (x0, x1, x2, x3, idx)\n          }\n        }\n      }\n    }\n  }\n\n  fatalError(\"Did not find solution\")\n}\n\nlet (x0, x1, x2, x3, y) = sumOfPowers()\n\nprint(\"\\(x0)^5 + \\(x1)^5 + \\(x2)^5 \\(x3)^5 = \\(y)^5\")\n", "target": "def eulers_sum_of_powers():\n    max_n = 250\n    pow_5 = [n**5 for n in range(max_n)]\n    pow5_to_n = {n**5: n for n in range(max_n)}\n    for x0 in range(1, max_n):\n        for x1 in range(1, x0):\n            for x2 in range(1, x1):\n                for x3 in range(1, x2):\n                    pow_5_sum = sum(pow_5[i] for i in (x0, x1, x2, x3))\n                    if pow_5_sum in pow5_to_n:\n                        y = pow5_to_n[pow_5_sum]\n                        return (x0, x1, x2, x3, y)\n\nprint(\"%i**5 + %i**5 + %i**5 + %i**5 == %i**5\" % eulers_sum_of_powers())\n"}
{"id": 84323, "name": "Euler's sum of powers conjecture", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nfunc sumOfPowers(maxN: Int = 250) -> (Int, Int, Int, Int, Int) {\n  let pow5 = (0..<maxN).map({ $0.power(5) })\n  let pow5ToN = {n in pow5.firstIndex(of: n)}\n\n  for x0 in 1..<maxN {\n    for x1 in 1..<x0 {\n      for x2 in 1..<x1 {\n        for x3 in 1..<x2 {\n          let powSum = pow5[x0] + pow5[x1] + pow5[x2] + pow5[x3]\n\n          if let idx = pow5ToN(powSum) {\n            return (x0, x1, x2, x3, idx)\n          }\n        }\n      }\n    }\n  }\n\n  fatalError(\"Did not find solution\")\n}\n\nlet (x0, x1, x2, x3, y) = sumOfPowers()\n\nprint(\"\\(x0)^5 + \\(x1)^5 + \\(x2)^5 \\(x3)^5 = \\(y)^5\")\n", "target": "def eulers_sum_of_powers():\n    max_n = 250\n    pow_5 = [n**5 for n in range(max_n)]\n    pow5_to_n = {n**5: n for n in range(max_n)}\n    for x0 in range(1, max_n):\n        for x1 in range(1, x0):\n            for x2 in range(1, x1):\n                for x3 in range(1, x2):\n                    pow_5_sum = sum(pow_5[i] for i in (x0, x1, x2, x3))\n                    if pow_5_sum in pow5_to_n:\n                        y = pow5_to_n[pow_5_sum]\n                        return (x0, x1, x2, x3, y)\n\nprint(\"%i**5 + %i**5 + %i**5 + %i**5 == %i**5\" % eulers_sum_of_powers())\n"}
{"id": 85033, "name": "Primality by trial division", "source": "Translate Swift to C#: import Foundation\n\nextension Int {\n  func isPrime() -> Bool {\n    \n    switch self {\n    case let x where x < 2:\n      return false\n    case 2:\n      return true\n    default:\n      return\n        self % 2 != 0 &&\n        !stride(from: 3, through: Int(sqrt(Double(self))), by: 2).contains {self % $0 == 0}\n    }\n  }\n}\n", "target": "static bool isPrime(int n)\n        {\n            if (n <= 1) return false;\n            for (int i = 2; i * i <= n; i++)            \n                if (n % i == 0) return false;            \n            return true;\n        }\n"}
{"id": 85035, "name": "Primality by trial division", "source": "Translate Swift to Java: import Foundation\n\nextension Int {\n  func isPrime() -> Bool {\n    \n    switch self {\n    case let x where x < 2:\n      return false\n    case 2:\n      return true\n    default:\n      return\n        self % 2 != 0 &&\n        !stride(from: 3, through: Int(sqrt(Double(self))), by: 2).contains {self % $0 == 0}\n    }\n  }\n}\n", "target": "public static boolean prime(long a){\n   if(a == 2){\n      return true;\n   }else if(a <= 1 || a % 2 == 0){\n      return false;\n   }\n   long max = (long)Math.sqrt(a);\n   for(long n= 3; n <= max; n+= 2){\n      if(a % n == 0){ return false; }\n   }\n   return true;\n}\n"}
{"id": 85036, "name": "Primality by trial division", "source": "Translate Swift to Python: import Foundation\n\nextension Int {\n  func isPrime() -> Bool {\n    \n    switch self {\n    case let x where x < 2:\n      return false\n    case 2:\n      return true\n    default:\n      return\n        self % 2 != 0 &&\n        !stride(from: 3, through: Int(sqrt(Double(self))), by: 2).contains {self % $0 == 0}\n    }\n  }\n}\n", "target": "def prime(a):\n    return not (a < 2 or any(a % x == 0 for x in xrange(2, int(a**0.5) + 1)))\n"}
{"id": 85699, "name": "Time a function", "source": "Translate Swift to C#: import Foundation\n\npublic struct TimeResult {\n  public var seconds: Double\n  public var nanoSeconds: Double\n\n  public var duration: Double { seconds + (nanoSeconds / 1e9) }\n\n  @usableFromInline\n  init(seconds: Double, nanoSeconds: Double) {\n    self.seconds = seconds\n    self.nanoSeconds = nanoSeconds\n  }\n}\n\nextension TimeResult: CustomStringConvertible {\n  public var description: String {\n    return \"TimeResult(seconds: \\(seconds); nanoSeconds: \\(nanoSeconds); duration: \\(duration)s)\"\n  }\n}\n\npublic struct ClockTimer {\n  @inlinable @inline(__always)\n  public static func time<T>(_ f: () throws -> T) rethrows -> (T, TimeResult) {\n    var tsi = timespec()\n    var tsf = timespec()\n\n    clock_gettime(CLOCK_MONOTONIC_RAW, &tsi)\n    let res = try f()\n    clock_gettime(CLOCK_MONOTONIC_RAW, &tsf)\n\n    let secondsElapsed = difftime(tsf.tv_sec, tsi.tv_sec)\n    let nanoSecondsElapsed = Double(tsf.tv_nsec - tsi.tv_nsec)\n\n    return (res, TimeResult(seconds: secondsElapsed, nanoSeconds: nanoSecondsElapsed))\n  }\n}\n\nfunc ackermann(m: Int, n: Int) -> Int {\n  switch (m, n) {\n  case (0, _):\n    return n + 1\n  case (_, 0):\n    return ackermann(m: m - 1, n: 1)\n  case (_, _):\n    return ackermann(m: m - 1, n: ackermann(m: m, n: n - 1))\n  }\n}\n\nlet (n, t) = ClockTimer.time { ackermann(m: 3, n: 11) }\n\nprint(\"Took \\(t.duration)s to calculate ackermann(m: 3, n: 11) = \\(n)\")\n\nlet (n2, t2) = ClockTimer.time { ackermann(m: 4, n: 1) }\n\nprint(\"Took \\(t2.duration)s to calculate ackermann(m: 4, n: 1) = \\(n2)\")\n", "target": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Diagnostics;\n\nclass Program {\n    static void Main(string[] args) {\n        Stopwatch sw = new Stopwatch();\n\n        sw.Start();\n        DoSomething();\n        sw.Stop();\n\n        Console.WriteLine(\"DoSomething() took {0}ms.\", sw.Elapsed.TotalMilliseconds);\n    }\n\n    static void DoSomething() {\n        Thread.Sleep(1000);\n\n        Enumerable.Range(1, 10000).Where(x => x % 2 == 0).Sum();  \n    }\n}\n"}
{"id": 85701, "name": "Time a function", "source": "Translate Swift to Java: import Foundation\n\npublic struct TimeResult {\n  public var seconds: Double\n  public var nanoSeconds: Double\n\n  public var duration: Double { seconds + (nanoSeconds / 1e9) }\n\n  @usableFromInline\n  init(seconds: Double, nanoSeconds: Double) {\n    self.seconds = seconds\n    self.nanoSeconds = nanoSeconds\n  }\n}\n\nextension TimeResult: CustomStringConvertible {\n  public var description: String {\n    return \"TimeResult(seconds: \\(seconds); nanoSeconds: \\(nanoSeconds); duration: \\(duration)s)\"\n  }\n}\n\npublic struct ClockTimer {\n  @inlinable @inline(__always)\n  public static func time<T>(_ f: () throws -> T) rethrows -> (T, TimeResult) {\n    var tsi = timespec()\n    var tsf = timespec()\n\n    clock_gettime(CLOCK_MONOTONIC_RAW, &tsi)\n    let res = try f()\n    clock_gettime(CLOCK_MONOTONIC_RAW, &tsf)\n\n    let secondsElapsed = difftime(tsf.tv_sec, tsi.tv_sec)\n    let nanoSecondsElapsed = Double(tsf.tv_nsec - tsi.tv_nsec)\n\n    return (res, TimeResult(seconds: secondsElapsed, nanoSeconds: nanoSecondsElapsed))\n  }\n}\n\nfunc ackermann(m: Int, n: Int) -> Int {\n  switch (m, n) {\n  case (0, _):\n    return n + 1\n  case (_, 0):\n    return ackermann(m: m - 1, n: 1)\n  case (_, _):\n    return ackermann(m: m - 1, n: ackermann(m: m, n: n - 1))\n  }\n}\n\nlet (n, t) = ClockTimer.time { ackermann(m: 3, n: 11) }\n\nprint(\"Took \\(t.duration)s to calculate ackermann(m: 3, n: 11) = \\(n)\")\n\nlet (n2, t2) = ClockTimer.time { ackermann(m: 4, n: 1) }\n\nprint(\"Took \\(t2.duration)s to calculate ackermann(m: 4, n: 1) = \\(n2)\")\n", "target": "import java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\n\npublic class TimeIt {\n\tpublic static void main(String[] args) {\n\t\tfinal ThreadMXBean threadMX = ManagementFactory.getThreadMXBean();\n\t\tassert threadMX.isCurrentThreadCpuTimeSupported();\n\t\tthreadMX.setThreadCpuTimeEnabled(true);\n\t\t\n\t\tlong start, end;\n\t\tstart = threadMX.getCurrentThreadCpuTime();\n\t\tcountTo(100000000);\n\t\tend = threadMX.getCurrentThreadCpuTime();\n\t\tSystem.out.println(\"Counting to 100000000 takes \"+(end-start)/1000000+\"ms\");\n\t\tstart = threadMX.getCurrentThreadCpuTime();\n\t\tcountTo(1000000000L);\n\t\tend = threadMX.getCurrentThreadCpuTime();\n\t\tSystem.out.println(\"Counting to 1000000000 takes \"+(end-start)/1000000+\"ms\");\n \n\t}\n \n\tpublic static void countTo(long x){\n\t\tSystem.out.println(\"Counting...\");\n\t\tfor(long i=0;i<x;i++);\n\t\tSystem.out.println(\"Done!\");\n\t}\n}\n"}
{"id": 85702, "name": "Time a function", "source": "Translate Swift to Python: import Foundation\n\npublic struct TimeResult {\n  public var seconds: Double\n  public var nanoSeconds: Double\n\n  public var duration: Double { seconds + (nanoSeconds / 1e9) }\n\n  @usableFromInline\n  init(seconds: Double, nanoSeconds: Double) {\n    self.seconds = seconds\n    self.nanoSeconds = nanoSeconds\n  }\n}\n\nextension TimeResult: CustomStringConvertible {\n  public var description: String {\n    return \"TimeResult(seconds: \\(seconds); nanoSeconds: \\(nanoSeconds); duration: \\(duration)s)\"\n  }\n}\n\npublic struct ClockTimer {\n  @inlinable @inline(__always)\n  public static func time<T>(_ f: () throws -> T) rethrows -> (T, TimeResult) {\n    var tsi = timespec()\n    var tsf = timespec()\n\n    clock_gettime(CLOCK_MONOTONIC_RAW, &tsi)\n    let res = try f()\n    clock_gettime(CLOCK_MONOTONIC_RAW, &tsf)\n\n    let secondsElapsed = difftime(tsf.tv_sec, tsi.tv_sec)\n    let nanoSecondsElapsed = Double(tsf.tv_nsec - tsi.tv_nsec)\n\n    return (res, TimeResult(seconds: secondsElapsed, nanoSeconds: nanoSecondsElapsed))\n  }\n}\n\nfunc ackermann(m: Int, n: Int) -> Int {\n  switch (m, n) {\n  case (0, _):\n    return n + 1\n  case (_, 0):\n    return ackermann(m: m - 1, n: 1)\n  case (_, _):\n    return ackermann(m: m - 1, n: ackermann(m: m, n: n - 1))\n  }\n}\n\nlet (n, t) = ClockTimer.time { ackermann(m: 3, n: 11) }\n\nprint(\"Took \\(t.duration)s to calculate ackermann(m: 3, n: 11) = \\(n)\")\n\nlet (n2, t2) = ClockTimer.time { ackermann(m: 4, n: 1) }\n\nprint(\"Took \\(t2.duration)s to calculate ackermann(m: 4, n: 1) = \\(n2)\")\n", "target": "import sys, timeit\ndef usec(function, arguments):\n    modname, funcname = __name__, function.__name__\n    timer = timeit.Timer(stmt='%(funcname)s(*args)' % vars(),\n                         setup='from %(modname)s import %(funcname)s; args=%(arguments)r' % vars())\n    try:\n        t, N = 0, 1\n        while t < 0.2:            \n            t = min(timer.repeat(repeat=3, number=N))            \n            N *= 10\n        microseconds = round(10000000 * t / N, 1) \n        return microseconds \n    except:\n        timer.print_exc(file=sys.stderr)\n        raise\n\nfrom math import pow\ndef nothing(): pass\ndef identity(x): return x\n"}
{"id": 85951, "name": "Binary search", "source": "Translate Swift to C#: func binarySearch<T: Comparable>(xs: [T], x: T) -> Int? {\n  var recurse: ((Int, Int) -> Int?)!\n  recurse = {(low, high) in switch (low + high) / 2 {\n    case _ where high < low: return nil\n    case let mid where xs[mid] > x: return recurse(low, mid - 1)\n    case let mid where xs[mid] < x: return recurse(mid + 1, high)\n    case let mid: return mid\n  }}\n  return recurse(0, xs.count - 1)\n}\n", "target": "namespace Search {\n  using System;\n\n  public static partial class Extensions {\n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForGLB<T>(this T[] entries, T value)\n      where T : IComparable {\n      return entries.RecursiveBinarySearchForGLB(value, 0, entries.Length - 1);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForGLB<T>(this T[] entries, T value, int left, int right)\n      where T : IComparable {\n      if (left <= right) {\n        var middle = left + (right - left) / 2;\n        return entries[middle].CompareTo(value) < 0 ?\n          entries.RecursiveBinarySearchForGLB(value, middle + 1, right) :\n          entries.RecursiveBinarySearchForGLB(value, left, middle - 1);\n      }\n\n      \n      \n      return right;\n    }\n\n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForLUB<T>(this T[] entries, T value)\n      where T : IComparable {\n      return entries.RecursiveBinarySearchForLUB(value, 0, entries.Length - 1);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForLUB<T>(this T[] entries, T value, int left, int right)\n      where T : IComparable {\n      if (left <= right) {\n        var middle = left + (right - left) / 2;\n        return entries[middle].CompareTo(value) <= 0 ?\n          entries.RecursiveBinarySearchForLUB(value, middle + 1, right) :\n          entries.RecursiveBinarySearchForLUB(value, left, middle - 1);\n      }\n\n      \n      \n      return left;\n    }\n  }\n}\n"}
{"id": 85953, "name": "Binary search", "source": "Translate Swift to Java: func binarySearch<T: Comparable>(xs: [T], x: T) -> Int? {\n  var recurse: ((Int, Int) -> Int?)!\n  recurse = {(low, high) in switch (low + high) / 2 {\n    case _ where high < low: return nil\n    case let mid where xs[mid] > x: return recurse(low, mid - 1)\n    case let mid where xs[mid] < x: return recurse(mid + 1, high)\n    case let mid: return mid\n  }}\n  return recurse(0, xs.count - 1)\n}\n", "target": "public class BinarySearchIterative {\n\n    public static int binarySearch(int[] nums, int check) {\n        int hi = nums.length - 1;\n        int lo = 0;\n        while (hi >= lo) {\n            int guess = (lo + hi) >>> 1;  \n            if (nums[guess] > check) {\n                hi = guess - 1;\n            } else if (nums[guess] < check) {\n                lo = guess + 1;\n            } else {\n                return guess;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] haystack = {1, 5, 6, 7, 8, 11};\n        int needle = 5;\n        int index = binarySearch(haystack, needle);\n        if (index == -1) {\n            System.out.println(needle + \" is not in the array\");\n        } else {\n            System.out.println(needle + \" is at index \" + index);\n        }\n    }\n}\n"}
{"id": 85954, "name": "Binary search", "source": "Translate Swift to Python: func binarySearch<T: Comparable>(xs: [T], x: T) -> Int? {\n  var recurse: ((Int, Int) -> Int?)!\n  recurse = {(low, high) in switch (low + high) / 2 {\n    case _ where high < low: return nil\n    case let mid where xs[mid] > x: return recurse(low, mid - 1)\n    case let mid where xs[mid] < x: return recurse(mid + 1, high)\n    case let mid: return mid\n  }}\n  return recurse(0, xs.count - 1)\n}\n", "target": "def binary_search(l, value):\n    low = 0\n    high = len(l)-1\n    while low <= high: \n        mid = (low+high)//2\n        if l[mid] > value: high = mid-1\n        elif l[mid] < value: low = mid+1\n        else: return mid\n    return -1\n"}
{"id": 86115, "name": "Documentation", "source": "Translate Swift to C#: \nfunc add(a: Int, b: Int) -> Int {\n    return a + b\n}\n", "target": "\n\n\npublic static class XMLSystem\n{\n    static XMLSystem()\n    {\n        \n    }\n\n    \n    \n    \n    \n    \n    public static XmlDocument GetXML(string name) \n    {\n        return null;\n    }\n}\n"}
{"id": 86116, "name": "Documentation", "source": "Translate Swift to Java: \nfunc add(a: Int, b: Int) -> Int {\n    return a + b\n}\n", "target": "\npublic class Doc{\n   \n   private String field;\n\n   \n   public int method(long num) throws BadException{\n      \n   }\n}\n"}
{"id": 86117, "name": "Documentation", "source": "Translate Swift to Python: \nfunc add(a: Int, b: Int) -> Int {\n    return a + b\n}\n", "target": "class Doc(object):\n   \n   def method(self, num):\n      \n      pass\n"}
{"id": 86579, "name": "Vigen\u00e8re cipher", "source": "Translate Swift to C#: public func convertToUnicodeScalars(\n  str: String,\n  minChar: UInt32,\n  maxChar: UInt32\n) -> [UInt32] {\n  var scalars = [UInt32]()\n\n  for scalar in str.unicodeScalars {\n    let val = scalar.value\n\n    guard val >= minChar && val <= maxChar else {\n      continue\n    }\n\n    scalars.append(val)\n  }\n\n  return scalars\n}\n\npublic struct Vigenere {\n  private let keyScalars: [UInt32]\n  private let smallestScalar: UInt32\n  private let largestScalar: UInt32\n  private let sizeAlphabet: UInt32\n\n  public init?(key: String, smallestCharacter: Character = \"A\", largestCharacter:  Character = \"Z\") {\n    let smallScalars = smallestCharacter.unicodeScalars\n    let largeScalars = largestCharacter.unicodeScalars\n\n    guard smallScalars.count == 1, largeScalars.count == 1 else {\n      return nil\n    }\n\n    self.smallestScalar = smallScalars.first!.value\n    self.largestScalar = largeScalars.first!.value\n    self.sizeAlphabet = (largestScalar - smallestScalar) + 1\n\n    let scalars = convertToUnicodeScalars(str: key, minChar: smallestScalar, maxChar: largestScalar)\n\n    guard !scalars.isEmpty else {\n      return nil\n    }\n\n    self.keyScalars = scalars\n\n  }\n\n  public func decrypt(_ str: String) -> String? {\n    let txtBytes = convertToUnicodeScalars(str: str, minChar: smallestScalar, maxChar: largestScalar)\n\n    guard !txtBytes.isEmpty else {\n      return nil\n    }\n\n    var res = \"\"\n\n    for (i, c) in txtBytes.enumerated() where c >= smallestScalar && c <= largestScalar {\n      guard let char =\n        UnicodeScalar((c &+ sizeAlphabet &- keyScalars[i % keyScalars.count]) % sizeAlphabet &+ smallestScalar)\n      else {\n        return nil\n      }\n\n      res += String(char)\n    }\n\n    return res\n  }\n\n  public func encrypt(_ str: String) -> String? {\n    let txtBytes = convertToUnicodeScalars(str: str, minChar: smallestScalar, maxChar: largestScalar)\n\n    guard !txtBytes.isEmpty else {\n      return nil\n    }\n\n    var res = \"\"\n\n    for (i, c) in txtBytes.enumerated() where c >= smallestScalar && c <= largestScalar {\n      guard let char =\n        UnicodeScalar((c &+ keyScalars[i % keyScalars.count] &- 2 &* smallestScalar) % sizeAlphabet &+ smallestScalar)\n      else {\n        return nil\n      }\n\n      res += String(char)\n    }\n\n    return res\n  }\n}\n\nlet text = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\nlet key = \"VIGENERECIPHER\";\nlet cipher = Vigenere(key: key)!\n\nprint(\"Key: \\(key)\")\nprint(\"Plain Text: \\(text)\")\n\nlet encoded = cipher.encrypt(text.uppercased())!\n\nprint(\"Cipher Text: \\(encoded)\")\n\nlet decoded = cipher.decrypt(encoded)!\n\nprint(\"Decoded: \\(decoded)\")\n\nprint(\"\\nLarger set:\")\n\nlet key2 = \"Vigen\u00e8re cipher\"\nlet text2 = \"This is a \u00fcnicode string \ud83d\ude03\"\n\nlet cipher2 = Vigenere(key: key2, smallestCharacter: \" \", largestCharacter: \"\ud83d\udef9\")!\n\nprint(\"Key: \\(key2)\")\nprint(\"Plain Text: \\(text2)\")\n\nlet encoded2 = cipher2.encrypt(text2)!\n\nprint(\"Cipher Text: \\(encoded2)\")\n\nlet decoded2 = cipher2.decrypt(encoded2)!\n\nprint(\"Decoded: \\(decoded2)\")\n", "target": "using System;\n\nnamespace VigenereCipher\n{\n    class VCipher\n    {\n        public string encrypt(string txt, string pw, int d)\n        {\n            int pwi = 0, tmp;\n            string ns = \"\";\n            txt = txt.ToUpper();\n            pw = pw.ToUpper();\n            foreach (char t in txt)\n            {\n                if (t < 65) continue;\n                tmp = t - 65 + d * (pw[pwi] - 65);\n                if (tmp < 0) tmp += 26;\n                ns += Convert.ToChar(65 + ( tmp % 26) );\n                if (++pwi == pw.Length) pwi = 0;\n            }\n\n            return ns;\n        }\n    };\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            VCipher v = new VCipher();\n\n            string s0 = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\",\n                   pw = \"VIGENERECIPHER\";\n\n            Console.WriteLine(s0 + \"\\n\" + pw + \"\\n\");\n            string s1 = v.encrypt(s0, pw, 1);\n            Console.WriteLine(\"Encrypted: \" + s1);\n            s1 = v.encrypt(s1, \"VIGENERECIPHER\", -1);\n            Console.WriteLine(\"Decrypted: \" + s1);\n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 86581, "name": "Vigen\u00e8re cipher", "source": "Translate Swift to Java: public func convertToUnicodeScalars(\n  str: String,\n  minChar: UInt32,\n  maxChar: UInt32\n) -> [UInt32] {\n  var scalars = [UInt32]()\n\n  for scalar in str.unicodeScalars {\n    let val = scalar.value\n\n    guard val >= minChar && val <= maxChar else {\n      continue\n    }\n\n    scalars.append(val)\n  }\n\n  return scalars\n}\n\npublic struct Vigenere {\n  private let keyScalars: [UInt32]\n  private let smallestScalar: UInt32\n  private let largestScalar: UInt32\n  private let sizeAlphabet: UInt32\n\n  public init?(key: String, smallestCharacter: Character = \"A\", largestCharacter:  Character = \"Z\") {\n    let smallScalars = smallestCharacter.unicodeScalars\n    let largeScalars = largestCharacter.unicodeScalars\n\n    guard smallScalars.count == 1, largeScalars.count == 1 else {\n      return nil\n    }\n\n    self.smallestScalar = smallScalars.first!.value\n    self.largestScalar = largeScalars.first!.value\n    self.sizeAlphabet = (largestScalar - smallestScalar) + 1\n\n    let scalars = convertToUnicodeScalars(str: key, minChar: smallestScalar, maxChar: largestScalar)\n\n    guard !scalars.isEmpty else {\n      return nil\n    }\n\n    self.keyScalars = scalars\n\n  }\n\n  public func decrypt(_ str: String) -> String? {\n    let txtBytes = convertToUnicodeScalars(str: str, minChar: smallestScalar, maxChar: largestScalar)\n\n    guard !txtBytes.isEmpty else {\n      return nil\n    }\n\n    var res = \"\"\n\n    for (i, c) in txtBytes.enumerated() where c >= smallestScalar && c <= largestScalar {\n      guard let char =\n        UnicodeScalar((c &+ sizeAlphabet &- keyScalars[i % keyScalars.count]) % sizeAlphabet &+ smallestScalar)\n      else {\n        return nil\n      }\n\n      res += String(char)\n    }\n\n    return res\n  }\n\n  public func encrypt(_ str: String) -> String? {\n    let txtBytes = convertToUnicodeScalars(str: str, minChar: smallestScalar, maxChar: largestScalar)\n\n    guard !txtBytes.isEmpty else {\n      return nil\n    }\n\n    var res = \"\"\n\n    for (i, c) in txtBytes.enumerated() where c >= smallestScalar && c <= largestScalar {\n      guard let char =\n        UnicodeScalar((c &+ keyScalars[i % keyScalars.count] &- 2 &* smallestScalar) % sizeAlphabet &+ smallestScalar)\n      else {\n        return nil\n      }\n\n      res += String(char)\n    }\n\n    return res\n  }\n}\n\nlet text = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\nlet key = \"VIGENERECIPHER\";\nlet cipher = Vigenere(key: key)!\n\nprint(\"Key: \\(key)\")\nprint(\"Plain Text: \\(text)\")\n\nlet encoded = cipher.encrypt(text.uppercased())!\n\nprint(\"Cipher Text: \\(encoded)\")\n\nlet decoded = cipher.decrypt(encoded)!\n\nprint(\"Decoded: \\(decoded)\")\n\nprint(\"\\nLarger set:\")\n\nlet key2 = \"Vigen\u00e8re cipher\"\nlet text2 = \"This is a \u00fcnicode string \ud83d\ude03\"\n\nlet cipher2 = Vigenere(key: key2, smallestCharacter: \" \", largestCharacter: \"\ud83d\udef9\")!\n\nprint(\"Key: \\(key2)\")\nprint(\"Plain Text: \\(text2)\")\n\nlet encoded2 = cipher2.encrypt(text2)!\n\nprint(\"Cipher Text: \\(encoded2)\")\n\nlet decoded2 = cipher2.decrypt(encoded2)!\n\nprint(\"Decoded: \\(decoded2)\")\n", "target": "public class VigenereCipher {\n    public static void main(String[] args) {\n        String key = \"VIGENERECIPHER\";\n        String ori = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\n        String enc = encrypt(ori, key);\n        System.out.println(enc);\n        System.out.println(decrypt(enc, key));\n    }\n\n    static String encrypt(String text, final String key) {\n        String res = \"\";\n        text = text.toUpperCase();\n        for (int i = 0, j = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c < 'A' || c > 'Z') continue;\n            res += (char)((c + key.charAt(j) - 2 * 'A') % 26 + 'A');\n            j = ++j % key.length();\n        }\n        return res;\n    }\n\n    static String decrypt(String text, final String key) {\n        String res = \"\";\n        text = text.toUpperCase();\n        for (int i = 0, j = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c < 'A' || c > 'Z') continue;\n            res += (char)((c - key.charAt(j) + 26) % 26 + 'A');\n            j = ++j % key.length();\n        }\n        return res;\n    }\n}\n"}
{"id": 86582, "name": "Vigen\u00e8re cipher", "source": "Translate Swift to Python: public func convertToUnicodeScalars(\n  str: String,\n  minChar: UInt32,\n  maxChar: UInt32\n) -> [UInt32] {\n  var scalars = [UInt32]()\n\n  for scalar in str.unicodeScalars {\n    let val = scalar.value\n\n    guard val >= minChar && val <= maxChar else {\n      continue\n    }\n\n    scalars.append(val)\n  }\n\n  return scalars\n}\n\npublic struct Vigenere {\n  private let keyScalars: [UInt32]\n  private let smallestScalar: UInt32\n  private let largestScalar: UInt32\n  private let sizeAlphabet: UInt32\n\n  public init?(key: String, smallestCharacter: Character = \"A\", largestCharacter:  Character = \"Z\") {\n    let smallScalars = smallestCharacter.unicodeScalars\n    let largeScalars = largestCharacter.unicodeScalars\n\n    guard smallScalars.count == 1, largeScalars.count == 1 else {\n      return nil\n    }\n\n    self.smallestScalar = smallScalars.first!.value\n    self.largestScalar = largeScalars.first!.value\n    self.sizeAlphabet = (largestScalar - smallestScalar) + 1\n\n    let scalars = convertToUnicodeScalars(str: key, minChar: smallestScalar, maxChar: largestScalar)\n\n    guard !scalars.isEmpty else {\n      return nil\n    }\n\n    self.keyScalars = scalars\n\n  }\n\n  public func decrypt(_ str: String) -> String? {\n    let txtBytes = convertToUnicodeScalars(str: str, minChar: smallestScalar, maxChar: largestScalar)\n\n    guard !txtBytes.isEmpty else {\n      return nil\n    }\n\n    var res = \"\"\n\n    for (i, c) in txtBytes.enumerated() where c >= smallestScalar && c <= largestScalar {\n      guard let char =\n        UnicodeScalar((c &+ sizeAlphabet &- keyScalars[i % keyScalars.count]) % sizeAlphabet &+ smallestScalar)\n      else {\n        return nil\n      }\n\n      res += String(char)\n    }\n\n    return res\n  }\n\n  public func encrypt(_ str: String) -> String? {\n    let txtBytes = convertToUnicodeScalars(str: str, minChar: smallestScalar, maxChar: largestScalar)\n\n    guard !txtBytes.isEmpty else {\n      return nil\n    }\n\n    var res = \"\"\n\n    for (i, c) in txtBytes.enumerated() where c >= smallestScalar && c <= largestScalar {\n      guard let char =\n        UnicodeScalar((c &+ keyScalars[i % keyScalars.count] &- 2 &* smallestScalar) % sizeAlphabet &+ smallestScalar)\n      else {\n        return nil\n      }\n\n      res += String(char)\n    }\n\n    return res\n  }\n}\n\nlet text = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\nlet key = \"VIGENERECIPHER\";\nlet cipher = Vigenere(key: key)!\n\nprint(\"Key: \\(key)\")\nprint(\"Plain Text: \\(text)\")\n\nlet encoded = cipher.encrypt(text.uppercased())!\n\nprint(\"Cipher Text: \\(encoded)\")\n\nlet decoded = cipher.decrypt(encoded)!\n\nprint(\"Decoded: \\(decoded)\")\n\nprint(\"\\nLarger set:\")\n\nlet key2 = \"Vigen\u00e8re cipher\"\nlet text2 = \"This is a \u00fcnicode string \ud83d\ude03\"\n\nlet cipher2 = Vigenere(key: key2, smallestCharacter: \" \", largestCharacter: \"\ud83d\udef9\")!\n\nprint(\"Key: \\(key2)\")\nprint(\"Plain Text: \\(text2)\")\n\nlet encoded2 = cipher2.encrypt(text2)!\n\nprint(\"Cipher Text: \\(encoded2)\")\n\nlet decoded2 = cipher2.decrypt(encoded2)!\n\nprint(\"Decoded: \\(decoded2)\")\n", "target": "\n\nfrom itertools import starmap, cycle\n\n\ndef encrypt(message, key):\n    \n\n    \n    \n    message = filter(str.isalpha, message.upper())\n\n    def enc(c, k):\n        \n\n        return chr(((ord(k) + ord(c) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(enc, zip(message, cycle(key))))\n\n\ndef decrypt(message, key):\n    \n\n    def dec(c, k):\n        \n\n        return chr(((ord(c) - ord(k) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(dec, zip(message, cycle(key))))\n\n\ndef main():\n    \n\n    text = 'Beware the Jabberwock, my son! The jaws that bite, ' + (\n           'the claws that catch!'\n    )\n    key = 'VIGENERECIPHER'\n\n    encr = encrypt(text, key)\n    decr = decrypt(encr, key)\n\n    print(text)\n    print(encr)\n    print(decr)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 87194, "name": "Higher-order functions", "source": "Translate Swift to C#: func func1(f: String->String) -> String { return f(\"a string\") }\nfunc func2(s: String) -> String { return \"func2 called with \" + s }\nprintln(func1(func2)) \n", "target": "using System;\n\n\ndelegate int Func2(int a, int b);\n\nclass Program\n{\n    static int Add(int a, int b)\n    {\n        return a + b;\n    }\n    \n    static int Mul(int a, int b)\n    {\n        return a * b;\n    }\n    \n    static int Div(int a, int b)\n    {\n        return a / b;\n    }\n    \n    static int Call(Func2 f, int a, int b)\n    {\n        \n        return f(a, b);\n    }\n\n    static void Main()\n    {\n        int a = 6;\n        int b = 2;\n\n        \n        Func2 add = new Func2(Add);\n        Func2 mul = new Func2(Mul);\n        Func2 div = new Func2(Div);\n        \n        Console.WriteLine(\"f=Add, f({0}, {1}) = {2}\", a, b, Call(add, a, b));\n        Console.WriteLine(\"f=Mul, f({0}, {1}) = {2}\", a, b, Call(mul, a, b));\n        Console.WriteLine(\"f=Div, f({0}, {1}) = {2}\", a, b, Call(div, a, b));\n    }\n}\n"}
{"id": 87196, "name": "Higher-order functions", "source": "Translate Swift to Java: func func1(f: String->String) -> String { return f(\"a string\") }\nfunc func2(s: String) -> String { return \"func2 called with \" + s }\nprintln(func1(func2)) \n", "target": "public class NewClass {\n   \n   public NewClass() {\n       first(new AnEventOrCallback() {\n           public void call() {\n               second();\n           }\n       });\n   }\n   \n   public void first(AnEventOrCallback obj) {\n       obj.call();\n   }\n   \n   public void second() {\n       System.out.println(\"Second\");\n   }\n   \n   public static void main(String[] args) {\n       new NewClass();\n   }\n}\n\ninterface AnEventOrCallback {\n   public void call();\n}\n"}
{"id": 87197, "name": "Higher-order functions", "source": "Translate Swift to Python: func func1(f: String->String) -> String { return f(\"a string\") }\nfunc func2(s: String) -> String { return \"func2 called with \" + s }\nprintln(func1(func2)) \n", "target": "def first(function):\n    return function()\n\ndef second():\n    return \"second\"\n\nresult = first(second)\n"}
{"id": 87419, "name": "CUSIP", "source": "Translate Swift to C#: struct CUSIP {\n  var value: String\n\n  private static let alphabet = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\n  init?(value: String) {\n    if value.count == 9 && String(value.last!) == CUSIP.checkDigit(cusipString: String(value.dropLast())) {\n      self.value = value\n    } else if value.count == 8, let checkDigit = CUSIP.checkDigit(cusipString: value) {\n      self.value = value + checkDigit\n    } else {\n      return nil\n    }\n  }\n\n  static func checkDigit(cusipString: String) -> String? {\n    guard cusipString.count == 8, cusipString.allSatisfy({ $0.isASCII }) else {\n      return nil\n    }\n\n    let sum = cusipString.uppercased().enumerated().reduce(0, {sum, pair in\n      let (i, char) = pair\n      var v: Int\n\n      switch char {\n      case \"*\":\n        v = 36\n      case \"@\":\n        v = 37\n      case \"#\":\n        v = 38\n      case _ where char.isNumber:\n        v = char.wholeNumberValue!\n      case _:\n        v = Int(char.asciiValue! - 65) + 10\n      }\n\n      if i & 1 == 1 {\n        v *= 2\n      }\n\n      return sum + (v / 10) + (v % 10)\n    })\n\n    return String((10 - (sum % 10)) % 10)\n  }\n}\n\nlet testCases = [\n  \"037833100\",\n  \"17275R102\",\n  \"38259P508\",\n  \"594918104\",\n  \"68389X106\",\n  \"68389X105\"\n]\n\nfor potentialCUSIP in testCases {\n  print(\"\\(potentialCUSIP) -> \", terminator: \"\")\n\n  switch CUSIP(value: potentialCUSIP) {\n  case nil:\n    print(\"Invalid\")\n  case _:\n    print(\"Valid\")\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace CUSIP {\n    class Program {\n        static bool IsCusip(string s) {\n            if (s.Length != 9) return false;\n            int sum = 0;\n            for (int i = 0; i <= 7; i++) {\n                char c = s[i];\n\n                int v;\n                if (c >= '0' && c <= '9') {\n                    v = c - 48;\n                }\n                else if (c >= 'A' && c <= 'Z') {\n                    v = c - 55;  \n                }\n                else if (c == '*') {\n                    v = 36;\n                }\n                else if (c == '#') {\n                    v = 38;\n                }\n                else {\n                    return false;\n                }\n                if (i % 2 == 1) v *= 2;  \n                sum += v / 10 + v % 10;\n            }\n            return s[8] - 48 == (10 - (sum % 10)) % 10;\n        }\n\n        static void Main(string[] args) {\n            List<string> candidates = new List<string>() {\n                \"037833100\",\n                \"17275R102\",\n                \"38259P508\",\n                \"594918104\",\n                \"68389X106\",\n                \"68389X105\"\n            };\n            foreach (var candidate in candidates) {\n                Console.WriteLine(\"{0} -> {1}\", candidate, IsCusip(candidate) ? \"correct\" : \"incorrect\");\n            }\n        }\n    }\n}\n"}
{"id": 87421, "name": "CUSIP", "source": "Translate Swift to Java: struct CUSIP {\n  var value: String\n\n  private static let alphabet = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\n  init?(value: String) {\n    if value.count == 9 && String(value.last!) == CUSIP.checkDigit(cusipString: String(value.dropLast())) {\n      self.value = value\n    } else if value.count == 8, let checkDigit = CUSIP.checkDigit(cusipString: value) {\n      self.value = value + checkDigit\n    } else {\n      return nil\n    }\n  }\n\n  static func checkDigit(cusipString: String) -> String? {\n    guard cusipString.count == 8, cusipString.allSatisfy({ $0.isASCII }) else {\n      return nil\n    }\n\n    let sum = cusipString.uppercased().enumerated().reduce(0, {sum, pair in\n      let (i, char) = pair\n      var v: Int\n\n      switch char {\n      case \"*\":\n        v = 36\n      case \"@\":\n        v = 37\n      case \"#\":\n        v = 38\n      case _ where char.isNumber:\n        v = char.wholeNumberValue!\n      case _:\n        v = Int(char.asciiValue! - 65) + 10\n      }\n\n      if i & 1 == 1 {\n        v *= 2\n      }\n\n      return sum + (v / 10) + (v % 10)\n    })\n\n    return String((10 - (sum % 10)) % 10)\n  }\n}\n\nlet testCases = [\n  \"037833100\",\n  \"17275R102\",\n  \"38259P508\",\n  \"594918104\",\n  \"68389X106\",\n  \"68389X105\"\n]\n\nfor potentialCUSIP in testCases {\n  print(\"\\(potentialCUSIP) -> \", terminator: \"\")\n\n  switch CUSIP(value: potentialCUSIP) {\n  case nil:\n    print(\"Invalid\")\n  case _:\n    print(\"Valid\")\n  }\n}\n", "target": "import java.util.List;\n\npublic class Cusip {\n    private static Boolean isCusip(String s) {\n        if (s.length() != 9) return false;\n        int sum = 0;\n        for (int i = 0; i <= 7; i++) {\n            char c = s.charAt(i);\n\n            int v;\n            if (c >= '0' && c <= '9') {\n                v = c - 48;\n            } else if (c >= 'A' && c <= 'Z') {\n                v = c - 55;  \n            } else if (c == '*') {\n                v = 36;\n            } else if (c == '@') {\n                v = 37;\n            } else if (c == '#') {\n                v = 38;\n            } else {\n                return false;\n            }\n            if (i % 2 == 1) v *= 2;  \n            sum += v / 10 + v % 10;\n        }\n        return s.charAt(8) - 48 == (10 - (sum % 10)) % 10;\n    }\n\n    public static void main(String[] args) {\n        List<String> candidates = List.of(\n                \"037833100\", \"17275R102\", \"38259P508\", \"594918104\", \"68389X106\", \"68389X105\", \"EXTRACRD8\",\n                \"EXTRACRD9\", \"BADCUSIP!\", \"683&9X106\", \"68389x105\", \"683$9X106\", \"68389}105\", \"87264ABE4\"\n        );\n        for (String candidate : candidates) {\n            System.out.printf(\"%s -> %s%n\", candidate, isCusip(candidate) ? \"correct\" : \"incorrect\");\n        }\n    }\n}\n"}
{"id": 87422, "name": "CUSIP", "source": "Translate Swift to Python: struct CUSIP {\n  var value: String\n\n  private static let alphabet = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\n  init?(value: String) {\n    if value.count == 9 && String(value.last!) == CUSIP.checkDigit(cusipString: String(value.dropLast())) {\n      self.value = value\n    } else if value.count == 8, let checkDigit = CUSIP.checkDigit(cusipString: value) {\n      self.value = value + checkDigit\n    } else {\n      return nil\n    }\n  }\n\n  static func checkDigit(cusipString: String) -> String? {\n    guard cusipString.count == 8, cusipString.allSatisfy({ $0.isASCII }) else {\n      return nil\n    }\n\n    let sum = cusipString.uppercased().enumerated().reduce(0, {sum, pair in\n      let (i, char) = pair\n      var v: Int\n\n      switch char {\n      case \"*\":\n        v = 36\n      case \"@\":\n        v = 37\n      case \"#\":\n        v = 38\n      case _ where char.isNumber:\n        v = char.wholeNumberValue!\n      case _:\n        v = Int(char.asciiValue! - 65) + 10\n      }\n\n      if i & 1 == 1 {\n        v *= 2\n      }\n\n      return sum + (v / 10) + (v % 10)\n    })\n\n    return String((10 - (sum % 10)) % 10)\n  }\n}\n\nlet testCases = [\n  \"037833100\",\n  \"17275R102\",\n  \"38259P508\",\n  \"594918104\",\n  \"68389X106\",\n  \"68389X105\"\n]\n\nfor potentialCUSIP in testCases {\n  print(\"\\(potentialCUSIP) -> \", terminator: \"\")\n\n  switch CUSIP(value: potentialCUSIP) {\n  case nil:\n    print(\"Invalid\")\n  case _:\n    print(\"Valid\")\n  }\n}\n", "target": "\n\nimport math\n\ndef cusip_check(cusip):\n    if len(cusip) != 9:\n        raise ValueError('CUSIP must be 9 characters')\n\n    cusip = cusip.upper()\n    total = 0\n    for i in range(8):\n        c = cusip[i]\n        if c.isdigit():\n            v = int(c)\n        elif c.isalpha():\n            p = ord(c) - ord('A') + 1\n            v = p + 9\n        elif c == '*':\n            v = 36\n        elif c == '@':\n            v = 37\n        elif c == '\n            v = 38\n\n        if i % 2 != 0:\n            v *= 2\n\n        total += int(v / 10) + v % 10\n    check = (10 - (total % 10)) % 10\n    return str(check) == cusip[-1]\n\nif __name__ == '__main__':\n    codes = [\n            '037833100',\n            '17275R102',\n            '38259P508',\n            '594918104',\n            '68389X106',\n            '68389X105'\n            ]\n    for code in codes:\n        print(f'{code} -> {cusip_check(code)}')\n"}
{"id": 87753, "name": "String length", "source": "Translate Swift to Java: let numberOfCharacters = \"m\u00f8\u00f8se\".characters.count  \n", "target": "String s = \"Hello, world!\"; \nint byteCountUTF16 = s.getBytes(\"UTF-16\").length; \nint byteCountUTF16LE = s.getBytes(\"UTF-16LE\").length; \nint byteCountUTF8  = s.getBytes(\"UTF-8\").length; \n"}
{"id": 88324, "name": "HTTPS", "source": "Translate Swift to C#: import Foundation\n\n\nlet request = NSURLRequest(URL: NSURL(string: \"https:\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in \n    \n    \n    if (data != nil) {\n        let string = NSString(data: data!, encoding: NSUTF8StringEncoding)\n        println(string)\n    }\n}\n\nCFRunLoopRun() \n", "target": "using System;\nusing System.Net;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var client = new WebClient();\n        var data = client.DownloadString(\"https:\n\n        Console.WriteLine(data);\n    }\n}\n"}
{"id": 88325, "name": "HTTPS", "source": "Translate Swift to Java: import Foundation\n\n\nlet request = NSURLRequest(URL: NSURL(string: \"https:\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in \n    \n    \n    if (data != nil) {\n        let string = NSString(data: data!, encoding: NSUTF8StringEncoding)\n        println(string)\n    }\n}\n\nCFRunLoopRun() \n", "target": "URL url = new URL(\"https:\nHttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\nScanner scanner = new Scanner(connection.getInputStream());\n\nwhile (scanner.hasNext()) {\n    System.out.println(scanner.next());\n}\n"}
{"id": 88326, "name": "HTTPS", "source": "Translate Swift to Python: import Foundation\n\n\nlet request = NSURLRequest(URL: NSURL(string: \"https:\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in \n    \n    \n    if (data != nil) {\n        let string = NSString(data: data!, encoding: NSUTF8StringEncoding)\n        println(string)\n    }\n}\n\nCFRunLoopRun() \n", "target": "import urllib.request\nprint(urllib.request.urlopen(\"https://sourceforge.net/\").read())\n"}
{"id": 88602, "name": "Sorting algorithms_Insertion sort", "source": "Translate Swift to C#: func insertionSort<T:Comparable>(inout list:[T]) {\n    for i in 1..<list.count {\n        var j = i\n        \n        while j > 0 && list[j - 1] > list[j] {\n           swap(&list[j], &list[j - 1])\n            j--\n        }\n    }\n}\n", "target": "namespace Sort {\n  using System;\n\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries) {\n      Sort(entries, 0, entries.Length - 1);\n    }\n\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var i = first + 1; i <= last; i++) {\n        var entry = entries[i];\n        var j = i;\n\n        while (j > first && entries[j - 1].CompareTo(entry) > 0)\n          entries[j] = entries[--j];\n\n        entries[j] = entry;\n      }\n    }\n  }\n}\n"}
{"id": 88604, "name": "Sorting algorithms_Insertion sort", "source": "Translate Swift to Python: func insertionSort<T:Comparable>(inout list:[T]) {\n    for i in 1..<list.count {\n        var j = i\n        \n        while j > 0 && list[j - 1] > list[j] {\n           swap(&list[j], &list[j - 1])\n            j--\n        }\n    }\n}\n", "target": "def insertion_sort(L):\n    for i in xrange(1, len(L)):\n        j = i-1 \n        key = L[i]\n        while j >= 0 and L[j] > key:\n           L[j+1] = L[j]\n           j -= 1\n        L[j+1] = key\n"}
{"id": 89051, "name": "Angle difference between two bearings", "source": "Translate Swift to C#: func angleDifference(a1: Double, a2: Double) -> Double {\n  let diff = (a2 - a1).truncatingRemainder(dividingBy: 360)\n\n  if diff < -180.0 {\n    return 360.0 + diff\n  } else if diff > 180.0 {\n    return -360.0 + diff\n  } else {\n    return diff\n  }\n}\n\nlet testCases = [\n  (20.0, 45.0),\n  (-45, 45),\n  (-85, 90),\n  (-95, 90),\n  (-45, 125),\n  (-45, 145),\n  (29.4803, -88.6381),\n  (-78.3251, -159.036),\n  (-70099.74233810938, 29840.67437876723),\n  (-165313.6666297357, 33693.9894517456),\n  (1174.8380510598456, -154146.66490124757),\n  (60175.77306795546, 42213.07192354373)\n]\n\nprint(testCases.map(angleDifference))\n", "target": "using System;\n\nnamespace Angle_difference_between_two_bearings\n{\n\tclass Program\n\t{\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\"Hello World!\");\n\t\t\tConsole.WriteLine();\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing( 20M,45));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,45M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-85M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-95M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,125M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,145M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 29.4803M,-88.6381M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-78.3251M, -159.036M));\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing(-70099.74233810938M,   29840.67437876723M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-165313.6666297357M,   33693.9894517456M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 1174.8380510598456M, -154146.66490124757M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 60175.77306795546M,   42213.07192354373M));\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t}\n\t\t\n\t\tstatic decimal Delta_Bearing(decimal b1, decimal b2)\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tdecimal d = 0;\n\t\t\t\n\t\t\t\n\t\t\tif(b1<0)\n\t\t\t\tb1 += 360;\n\t\t\tif(b2<0)\n\t\t\t\tb2 += 360;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\td = (b2 - b1)%360;\n\t\t\t\n\t\t\tif(d>180)\n\t\t\t\td -= 360;\n\t\t\telse if(d<-180)\n\t\t\t\td += 360;\n\t\t\t\n\t\t\treturn d;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}\n"}
{"id": 89052, "name": "Angle difference between two bearings", "source": "Translate Swift to C#: func angleDifference(a1: Double, a2: Double) -> Double {\n  let diff = (a2 - a1).truncatingRemainder(dividingBy: 360)\n\n  if diff < -180.0 {\n    return 360.0 + diff\n  } else if diff > 180.0 {\n    return -360.0 + diff\n  } else {\n    return diff\n  }\n}\n\nlet testCases = [\n  (20.0, 45.0),\n  (-45, 45),\n  (-85, 90),\n  (-95, 90),\n  (-45, 125),\n  (-45, 145),\n  (29.4803, -88.6381),\n  (-78.3251, -159.036),\n  (-70099.74233810938, 29840.67437876723),\n  (-165313.6666297357, 33693.9894517456),\n  (1174.8380510598456, -154146.66490124757),\n  (60175.77306795546, 42213.07192354373)\n]\n\nprint(testCases.map(angleDifference))\n", "target": "using System;\n\nnamespace Angle_difference_between_two_bearings\n{\n\tclass Program\n\t{\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\"Hello World!\");\n\t\t\tConsole.WriteLine();\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing( 20M,45));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,45M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-85M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-95M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,125M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,145M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 29.4803M,-88.6381M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-78.3251M, -159.036M));\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing(-70099.74233810938M,   29840.67437876723M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-165313.6666297357M,   33693.9894517456M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 1174.8380510598456M, -154146.66490124757M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 60175.77306795546M,   42213.07192354373M));\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t}\n\t\t\n\t\tstatic decimal Delta_Bearing(decimal b1, decimal b2)\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tdecimal d = 0;\n\t\t\t\n\t\t\t\n\t\t\tif(b1<0)\n\t\t\t\tb1 += 360;\n\t\t\tif(b2<0)\n\t\t\t\tb2 += 360;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\td = (b2 - b1)%360;\n\t\t\t\n\t\t\tif(d>180)\n\t\t\t\td -= 360;\n\t\t\telse if(d<-180)\n\t\t\t\td += 360;\n\t\t\t\n\t\t\treturn d;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}\n"}
{"id": 89055, "name": "Angle difference between two bearings", "source": "Translate Swift to Java: func angleDifference(a1: Double, a2: Double) -> Double {\n  let diff = (a2 - a1).truncatingRemainder(dividingBy: 360)\n\n  if diff < -180.0 {\n    return 360.0 + diff\n  } else if diff > 180.0 {\n    return -360.0 + diff\n  } else {\n    return diff\n  }\n}\n\nlet testCases = [\n  (20.0, 45.0),\n  (-45, 45),\n  (-85, 90),\n  (-95, 90),\n  (-45, 125),\n  (-45, 145),\n  (29.4803, -88.6381),\n  (-78.3251, -159.036),\n  (-70099.74233810938, 29840.67437876723),\n  (-165313.6666297357, 33693.9894517456),\n  (1174.8380510598456, -154146.66490124757),\n  (60175.77306795546, 42213.07192354373)\n]\n\nprint(testCases.map(angleDifference))\n", "target": "public class AngleDifference {\n\n    public static double getDifference(double b1, double b2) {\n        double r = (b2 - b1) % 360.0;\n        if (r < -180.0)\n            r += 360.0;\n        if (r >= 180.0)\n            r -= 360.0;\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Input in -180 to +180 range\");\n        System.out.println(getDifference(20.0, 45.0));\n        System.out.println(getDifference(-45.0, 45.0));\n        System.out.println(getDifference(-85.0, 90.0));\n        System.out.println(getDifference(-95.0, 90.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(29.4803, -88.6381));\n        System.out.println(getDifference(-78.3251, -159.036));\n\n        System.out.println(\"Input in wider range\");\n        System.out.println(getDifference(-70099.74233810938, 29840.67437876723));\n        System.out.println(getDifference(-165313.6666297357, 33693.9894517456));\n        System.out.println(getDifference(1174.8380510598456, -154146.66490124757));\n        System.out.println(getDifference(60175.77306795546, 42213.07192354373));\n    }\n}\n"}
{"id": 89056, "name": "Angle difference between two bearings", "source": "Translate Swift to Java: func angleDifference(a1: Double, a2: Double) -> Double {\n  let diff = (a2 - a1).truncatingRemainder(dividingBy: 360)\n\n  if diff < -180.0 {\n    return 360.0 + diff\n  } else if diff > 180.0 {\n    return -360.0 + diff\n  } else {\n    return diff\n  }\n}\n\nlet testCases = [\n  (20.0, 45.0),\n  (-45, 45),\n  (-85, 90),\n  (-95, 90),\n  (-45, 125),\n  (-45, 145),\n  (29.4803, -88.6381),\n  (-78.3251, -159.036),\n  (-70099.74233810938, 29840.67437876723),\n  (-165313.6666297357, 33693.9894517456),\n  (1174.8380510598456, -154146.66490124757),\n  (60175.77306795546, 42213.07192354373)\n]\n\nprint(testCases.map(angleDifference))\n", "target": "public class AngleDifference {\n\n    public static double getDifference(double b1, double b2) {\n        double r = (b2 - b1) % 360.0;\n        if (r < -180.0)\n            r += 360.0;\n        if (r >= 180.0)\n            r -= 360.0;\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Input in -180 to +180 range\");\n        System.out.println(getDifference(20.0, 45.0));\n        System.out.println(getDifference(-45.0, 45.0));\n        System.out.println(getDifference(-85.0, 90.0));\n        System.out.println(getDifference(-95.0, 90.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(29.4803, -88.6381));\n        System.out.println(getDifference(-78.3251, -159.036));\n\n        System.out.println(\"Input in wider range\");\n        System.out.println(getDifference(-70099.74233810938, 29840.67437876723));\n        System.out.println(getDifference(-165313.6666297357, 33693.9894517456));\n        System.out.println(getDifference(1174.8380510598456, -154146.66490124757));\n        System.out.println(getDifference(60175.77306795546, 42213.07192354373));\n    }\n}\n"}
{"id": 89057, "name": "Angle difference between two bearings", "source": "Translate Swift to Python: func angleDifference(a1: Double, a2: Double) -> Double {\n  let diff = (a2 - a1).truncatingRemainder(dividingBy: 360)\n\n  if diff < -180.0 {\n    return 360.0 + diff\n  } else if diff > 180.0 {\n    return -360.0 + diff\n  } else {\n    return diff\n  }\n}\n\nlet testCases = [\n  (20.0, 45.0),\n  (-45, 45),\n  (-85, 90),\n  (-95, 90),\n  (-45, 125),\n  (-45, 145),\n  (29.4803, -88.6381),\n  (-78.3251, -159.036),\n  (-70099.74233810938, 29840.67437876723),\n  (-165313.6666297357, 33693.9894517456),\n  (1174.8380510598456, -154146.66490124757),\n  (60175.77306795546, 42213.07192354373)\n]\n\nprint(testCases.map(angleDifference))\n", "target": "from __future__ import print_function\n \ndef getDifference(b1, b2):\n\tr = (b2 - b1) % 360.0\n\t\n\t\n\tif r >= 180.0:\n\t\tr -= 360.0\n\treturn r\n \nif __name__ == \"__main__\":\n\tprint (\"Input in -180 to +180 range\")\n\tprint (getDifference(20.0, 45.0))\n\tprint (getDifference(-45.0, 45.0))\n\tprint (getDifference(-85.0, 90.0))\n\tprint (getDifference(-95.0, 90.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(29.4803, -88.6381))\n\tprint (getDifference(-78.3251, -159.036))\n \n\tprint (\"Input in wider range\")\n\tprint (getDifference(-70099.74233810938, 29840.67437876723))\n\tprint (getDifference(-165313.6666297357, 33693.9894517456))\n\tprint (getDifference(1174.8380510598456, -154146.66490124757))\n\tprint (getDifference(60175.77306795546, 42213.07192354373))\n"}
{"id": 89058, "name": "Angle difference between two bearings", "source": "Translate Swift to Python: func angleDifference(a1: Double, a2: Double) -> Double {\n  let diff = (a2 - a1).truncatingRemainder(dividingBy: 360)\n\n  if diff < -180.0 {\n    return 360.0 + diff\n  } else if diff > 180.0 {\n    return -360.0 + diff\n  } else {\n    return diff\n  }\n}\n\nlet testCases = [\n  (20.0, 45.0),\n  (-45, 45),\n  (-85, 90),\n  (-95, 90),\n  (-45, 125),\n  (-45, 145),\n  (29.4803, -88.6381),\n  (-78.3251, -159.036),\n  (-70099.74233810938, 29840.67437876723),\n  (-165313.6666297357, 33693.9894517456),\n  (1174.8380510598456, -154146.66490124757),\n  (60175.77306795546, 42213.07192354373)\n]\n\nprint(testCases.map(angleDifference))\n", "target": "from __future__ import print_function\n \ndef getDifference(b1, b2):\n\tr = (b2 - b1) % 360.0\n\t\n\t\n\tif r >= 180.0:\n\t\tr -= 360.0\n\treturn r\n \nif __name__ == \"__main__\":\n\tprint (\"Input in -180 to +180 range\")\n\tprint (getDifference(20.0, 45.0))\n\tprint (getDifference(-45.0, 45.0))\n\tprint (getDifference(-85.0, 90.0))\n\tprint (getDifference(-95.0, 90.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(29.4803, -88.6381))\n\tprint (getDifference(-78.3251, -159.036))\n \n\tprint (\"Input in wider range\")\n\tprint (getDifference(-70099.74233810938, 29840.67437876723))\n\tprint (getDifference(-165313.6666297357, 33693.9894517456))\n\tprint (getDifference(1174.8380510598456, -154146.66490124757))\n\tprint (getDifference(60175.77306795546, 42213.07192354373))\n"}
{"id": 89573, "name": "Named parameters", "source": "Translate Swift to C#: func greet(person: String, hometown: String) -> String {\n    return \"Hello \\(person)!  Glad you could visit from \\(hometown).\"\n}\nprint(greet(person: \"Bill\", hometown: \"Cupertino\"))\n", "target": "using System;\n\nnamespace NamedParams\n{\n    class Program\n    {\n        static void AddWidget(string parent, float x = 0, float y = 0, string text = \"Default\")\n        {\n            Console.WriteLine(\"parent = {0}, x = {1}, y = {2}, text = {3}\", parent, x, y, text);\n        }\n\n        static void Main(string[] args)\n        {\n            AddWidget(\"root\", 320, 240, \"First\");\n            AddWidget(\"root\", text: \"Origin\");\n            AddWidget(\"root\", 500);\n            AddWidget(\"root\", text: \"Footer\", y: 400);\n        }\n    }\n}\n"}
{"id": 89575, "name": "Named parameters", "source": "Translate Swift to Java: func greet(person: String, hometown: String) -> String {\n    return \"Hello \\(person)!  Glad you could visit from \\(hometown).\"\n}\nprint(greet(person: \"Bill\", hometown: \"Cupertino\"))\n", "target": "module NamedParams\n    {\n    const Point(Int x, Int y)\n        {\n        Point with(Int? x=Null, Int? y=Null)\n            {\n            return new Point(x ?: this.x, y ?: this.y);\n            }\n        }\n\n    @Inject Console console;\n\n    void run()\n        {\n        Point origin = new Point(0, 0);\n        console.print($\"origin={origin}\");\n        Point moveRight = origin.with(x=5);\n        console.print($\"moveRight(x=5)={moveRight}\");\n        Point moveUp    = moveRight.with(y=3);\n        console.print($\"moveUp(y=3)={moveUp}\");\n        }\n    }\n"}
{"id": 89576, "name": "Named parameters", "source": "Translate Swift to Python: func greet(person: String, hometown: String) -> String {\n    return \"Hello \\(person)!  Glad you could visit from \\(hometown).\"\n}\nprint(greet(person: \"Bill\", hometown: \"Cupertino\"))\n", "target": "def subtract(x, y):\n    return x - y\n\nsubtract(5, 3)         \nsubtract(y = 3, x = 5) \n"}
{"id": 89830, "name": "Catalan numbers", "source": "Translate Swift to C#: func catalan(_ n: Int) -> Int {\n  switch n {\n  case 0:\n    return 1\n  case _:\n    return catalan(n - 1) * 2 * (2 * n - 1) / (n + 1)\n  }\n}\n\nfor i in 1..<16 {\n  print(\"catalan(\\(i)) => \\(catalan(i))\")\n}\n", "target": "namespace CatalanNumbers\n{\n    \n    \n    \n    public class CatalanNumberGenerator\n    {\n        private static double Factorial(double n)\n        {\n            if (n == 0)\n                return 1;\n\n            return n * Factorial(n - 1);\n        }\n\n        public double FirstOption(double n)\n        {\n            const double topMultiplier = 2;\n            return Factorial(topMultiplier * n) / (Factorial(n + 1) * Factorial(n));\n        }\n\n        public double SecondOption(double n)\n        {\n            if (n == 0)\n            {\n                return 1;\n            }\n            double sum = 0;\n            double i = 0;\n            for (; i <= (n - 1); i++)\n            {\n                sum += SecondOption(i) * SecondOption((n - 1) - i);\n            }\n            return sum;\n        }\n\n        public double ThirdOption(double n)\n        {\n            if (n == 0)\n            {\n                return 1;\n            }\n            return ((2 * (2 * n - 1)) / (n + 1)) * ThirdOption(n - 1);\n        }\n    }\n}\n\n\n\nusing System;\nusing System.Configuration;\n\n\n\n\n\n\n\n\n\n\nnamespace CatalanNumbers\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            CatalanNumberGenerator generator = new CatalanNumberGenerator();\n            int i = 0;\n            DateTime initial;\n            DateTime final;\n            TimeSpan ts;\n\n            try\n            {\n                initial = DateTime.Now;\n                for (; i <= Convert.ToInt32(ConfigurationManager.AppSettings[\"MaxCatalanNumber\"]); i++)\n                {\n                    Console.WriteLine(\"CatalanNumber({0}):{1}\", i, generator.FirstOption(i));\n                }\n                final = DateTime.Now;\n                ts = final - initial;\n                Console.WriteLine(\"It took {0}.{1} to execute\\n\", ts.Seconds, ts.Milliseconds);\n\n                i = 0;\n                initial = DateTime.Now;\n                for (; i <= Convert.ToInt32(ConfigurationManager.AppSettings[\"MaxCatalanNumber\"]); i++)\n                {\n                    Console.WriteLine(\"CatalanNumber({0}):{1}\", i, generator.SecondOption(i));\n                }\n                final = DateTime.Now;\n                ts = final - initial;\n                Console.WriteLine(\"It took {0}.{1} to execute\\n\", ts.Seconds, ts.Milliseconds);   \n\n                i = 0;\n                initial = DateTime.Now;\n                for (; i <= Convert.ToInt32(ConfigurationManager.AppSettings[\"MaxCatalanNumber\"]); i++)\n                {\n                    Console.WriteLine(\"CatalanNumber({0}):{1}\", i, generator.ThirdOption(i));\n                }\n                final = DateTime.Now;\n                ts = final - initial;\n                Console.WriteLine(\"It took {0}.{1} to execute\", ts.Seconds, ts.Milliseconds, ts.TotalMilliseconds);\n                Console.ReadLine();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"Stopped at index {0}:\", i);\n                Console.WriteLine(ex.Message);\n                Console.ReadLine();\n            }\n        }\n    }\n}\n"}
{"id": 89832, "name": "Catalan numbers", "source": "Translate Swift to Java: func catalan(_ n: Int) -> Int {\n  switch n {\n  case 0:\n    return 1\n  case _:\n    return catalan(n - 1) * 2 * (2 * n - 1) / (n + 1)\n  }\n}\n\nfor i in 1..<16 {\n  print(\"catalan(\\(i)) => \\(catalan(i))\")\n}\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class CatlanNumbers {\n\n    public static void main(String[] args) {\n        Catlan f1 = new Catlan1();\n        Catlan f2 = new Catlan2();\n        Catlan f3 = new Catlan3();\n        System.out.printf(\"           Formula 1     Formula 2     Formula 3%n\");\n        for ( int n = 0 ; n <= 15 ; n++ ) {\n             System.out.printf(\"C(%2d) =\u00a0%,12d \u00a0%,12d \u00a0%,12d%n\", n, f1.catlin(n), f2.catlin(n), f3.catlin(n));\n        }\n    }\n    \n    private static interface Catlan {\n        public BigInteger catlin(long n);\n    }\n    \n    private static class Catlan1 implements Catlan {\n\n        \n        @Override\n        public BigInteger catlin(long n) {\n            List<Long> numerator = new ArrayList<>();\n            for ( long k = n+2 ; k <= 2*n ; k++ ) {\n                numerator.add(k);\n            }\n            \n            List<Long> denominator = new ArrayList<>();\n            for ( long k = 2 ; k <= n ; k++ ) {\n                denominator.add(k);\n            }\n            \n            for ( int i = numerator.size()-1 ; i >= 0  ; i-- ) {\n                for ( int j = denominator.size()-1 ; j >= 0  ; j-- ) {\n                    if ( denominator.get(j) == 1 ) {\n                        continue;\n                    }\n                    if ( numerator.get(i) % denominator.get(j) == 0 ) {\n                        long val = numerator.get(i) / denominator.get(j);\n                        numerator.set(i, val);\n                        denominator.remove(denominator.get(j));\n                        if ( val == 1 ) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            BigInteger catlin = BigInteger.ONE;\n            for ( int i = 0 ; i < numerator.size() ; i++ ) {\n                catlin = catlin.multiply(BigInteger.valueOf(numerator.get(i)));\n            }\n            for ( int i = 0 ; i < denominator.size() ; i++ ) {\n                catlin = catlin.divide(BigInteger.valueOf(denominator.get(i)));\n            }\n            return catlin;\n        }        \n    }\n    \n    private static class Catlan2 implements Catlan {\n\n        private static Map<Long,BigInteger> CACHE = new HashMap<>();\n        static {\n            CACHE.put(0L, BigInteger.ONE);\n        }\n        \n        \n        @Override\n        public BigInteger catlin(long n) {\n            if ( CACHE.containsKey(n) ) {\n                return CACHE.get(n);\n            }\n            BigInteger catlin = BigInteger.ZERO;\n            n--;\n            for ( int i = 0 ; i <= n ; i++ ) {\n                \n                catlin = catlin.add(catlin(i).multiply(catlin(n-i)));\n            }\n            CACHE.put(n+1, catlin);\n            return catlin;\n        }\n    }\n    \n    private static class Catlan3 implements Catlan {\n\n        private static Map<Long,BigInteger> CACHE = new HashMap<>();\n        static {\n            CACHE.put(0L, BigInteger.ONE);\n        }\n        \n        \n        @Override\n        public BigInteger catlin(long n) {\n            if ( CACHE.containsKey(n) ) {\n                return CACHE.get(n);\n            }\n            BigInteger catlin = BigInteger.valueOf(2).multiply(BigInteger.valueOf(2*n-1)).multiply(catlin(n-1)).divide(BigInteger.valueOf(n+1));\n            CACHE.put(n, catlin);\n            return catlin;\n        }\n    }\n\n}\n"}
{"id": 89833, "name": "Catalan numbers", "source": "Translate Swift to Python: func catalan(_ n: Int) -> Int {\n  switch n {\n  case 0:\n    return 1\n  case _:\n    return catalan(n - 1) * 2 * (2 * n - 1) / (n + 1)\n  }\n}\n\nfor i in 1..<16 {\n  print(\"catalan(\\(i)) => \\(catalan(i))\")\n}\n", "target": "from math import factorial\nimport functools\n\n\ndef memoize(func):\n    cache = {}\n\n    def memoized(key):\n        \n        if key not in cache:\n            cache[key] = func(key)\n        return cache[key]\n    return functools.update_wrapper(memoized, func)\n\n\n@memoize\ndef fact(n):\n    return factorial(n)\n\n\ndef cat_direct(n):\n    return fact(2 * n) // fact(n + 1) // fact(n)\n\n\n@memoize\ndef catR1(n):\n    return 1 if n == 0 else (\n        sum(catR1(i) * catR1(n - 1 - i) for i in range(n))\n    )\n\n\n@memoize\ndef catR2(n):\n    return 1 if n == 0 else (\n        ((4 * n - 2) * catR2(n - 1)) // (n + 1)\n    )\n\n\nif __name__ == '__main__':\n    def pr(results):\n        fmt = '%-10s %-10s %-10s'\n        print((fmt % tuple(c.__name__ for c in defs)).upper())\n        print(fmt % (('=' * 10,) * 3))\n        for r in zip(*results):\n            print(fmt % r)\n\n    defs = (cat_direct, catR1, catR2)\n    results = [tuple(c(i) for i in range(15)) for c in defs]\n    pr(results)\n"}
{"id": 90097, "name": "Reverse a string", "source": "Translate Swift to C#: func reverseString(s: String) -> String {\n  return String(s.characters.reverse())\n}\nprint(reverseString(\"asdf\"))\nprint(reverseString(\"as\u20dddf\u0305\"))\n", "target": "using System;\n\nnamespace System\n{\n\textension String\n\t{\n\t\tpublic void Reverse()\n\t\t{\n\t\t\tint i = 0;\n\t\t\tint j = mLength - 1;\n\t\t\twhile (i < j)\n\t\t\t{\n\t\t\t\tSwap!(Ptr[i++], Ptr[j--]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nnamespace StringReverse\n{\n\tclass Program\n\t{\n\t\tstatic void Main()\n\t\t{\n\t\t\tString s = scope .(\"abcdef\");\n\t\t\ts.Reverse();\n\t\t\tConsole.WriteLine(s);\n\t\t}\n\t}\n}\n"}
{"id": 90099, "name": "Reverse a string", "source": "Translate Swift to Java: func reverseString(s: String) -> String {\n  return String(s.characters.reverse())\n}\nprint(reverseString(\"asdf\"))\nprint(reverseString(\"as\u20dddf\u0305\"))\n", "target": "String str = 'Hello World!';\nstr = str.reverse();\nsystem.debug(str);\n"}
{"id": 90100, "name": "Reverse a string", "source": "Translate Swift to Python: func reverseString(s: String) -> String {\n  return String(s.characters.reverse())\n}\nprint(reverseString(\"asdf\"))\nprint(reverseString(\"as\u20dddf\u0305\"))\n", "target": "input()[::-1]\n"}
{"id": 90428, "name": "Barnsley fern", "source": "Translate Swift to C#: import UIKit\nimport CoreImage\nimport PlaygroundSupport\n\nlet imageWH = 300\nlet context = CGContext(data: nil,\n                        width: imageWH,\n                        height: imageWH,\n                        bitsPerComponent: 8,\n                        bytesPerRow: 0,\n                        space: CGColorSpace(name: CGColorSpace.sRGB)!,\n                        bitmapInfo: CGImageAlphaInfo.premultipliedFirst.rawValue)!\nvar x0 = 0.0\nvar x1 = 0.0\nvar y0 = 0.0\nvar y1 = 0.0\n\ncontext.setFillColor(#colorLiteral(red: 0, green: 0, blue: 0, alpha: 1))\ncontext.fill(CGRect(x: 0, y: 0, width: imageWH, height: imageWH))\ncontext.setFillColor(#colorLiteral(red: 0.539716677, green: 1, blue: 0.265400682, alpha: 1))\n\nfor _ in 0..<100_000 {\n    switch Int(arc4random()) % 100 {\n    case 0:\n        x1 = 0\n        y1 = 0.16 * y0\n    case 1...7:\n        x1 = -0.15 * x0 + 0.28 * y0\n        y1 = 0.26 * x0 + 0.24 * y0 + 0.44\n    case 8...15:\n        x1 = 0.2 * x0 - 0.26 * y0\n        y1 = 0.23 * x0 + 0.22 * y0 + 1.6\n    default:\n        x1 = 0.85 * x0 + 0.04 * y0\n        y1 = -0.04 * x0 + 0.85 * y0 + 1.6\n    }\n    \n    context.fill(CGRect(x: 30 * x1 + Double(imageWH) / 2.0, y: 30 * y1,\n                        width: 1, height: 1))\n    \n    (x0, y0) = (x1, y1)\n}\n\nlet uiImage = UIImage(cgImage: context.makeImage()!)\n", "target": "using System;\nusing System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaBarnsleyFern\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 600;\n            const int h = 600;\n            var bm = new Bitmap(w, h);\n            var r = new Random();\n            double x = 0;\n            double y = 0;\n            for (int count = 0; count < 100000; count++)\n            {\n                bm.SetPixel((int)(300 + 58 * x), (int)(58 * y), Color.ForestGreen);\n                int roll = r.Next(100);\n                double xp = x;\n                if (roll < 1)\n                {\n                    x = 0;\n                    y = 0.16 * y;\n                } else if (roll < 86)\n                {\n                    x = 0.85 * x + 0.04 * y;\n                    y = -0.04 * xp + 0.85 * y + 1.6;\n                } else if (roll < 93)\n                {\n                    x = 0.2 * x - 0.26 * y;\n                    y = 0.23 * xp + 0.22 * y + 1.6;\n                } else\n                {\n                    x = -0.15 * x + 0.28 * y;\n                    y = 0.26 * xp + 0.24 * y + 0.44;\n                }\n            }\n            const string filename = \"Fern.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 90429, "name": "Barnsley fern", "source": "Translate Swift to C#: import UIKit\nimport CoreImage\nimport PlaygroundSupport\n\nlet imageWH = 300\nlet context = CGContext(data: nil,\n                        width: imageWH,\n                        height: imageWH,\n                        bitsPerComponent: 8,\n                        bytesPerRow: 0,\n                        space: CGColorSpace(name: CGColorSpace.sRGB)!,\n                        bitmapInfo: CGImageAlphaInfo.premultipliedFirst.rawValue)!\nvar x0 = 0.0\nvar x1 = 0.0\nvar y0 = 0.0\nvar y1 = 0.0\n\ncontext.setFillColor(#colorLiteral(red: 0, green: 0, blue: 0, alpha: 1))\ncontext.fill(CGRect(x: 0, y: 0, width: imageWH, height: imageWH))\ncontext.setFillColor(#colorLiteral(red: 0.539716677, green: 1, blue: 0.265400682, alpha: 1))\n\nfor _ in 0..<100_000 {\n    switch Int(arc4random()) % 100 {\n    case 0:\n        x1 = 0\n        y1 = 0.16 * y0\n    case 1...7:\n        x1 = -0.15 * x0 + 0.28 * y0\n        y1 = 0.26 * x0 + 0.24 * y0 + 0.44\n    case 8...15:\n        x1 = 0.2 * x0 - 0.26 * y0\n        y1 = 0.23 * x0 + 0.22 * y0 + 1.6\n    default:\n        x1 = 0.85 * x0 + 0.04 * y0\n        y1 = -0.04 * x0 + 0.85 * y0 + 1.6\n    }\n    \n    context.fill(CGRect(x: 30 * x1 + Double(imageWH) / 2.0, y: 30 * y1,\n                        width: 1, height: 1))\n    \n    (x0, y0) = (x1, y1)\n}\n\nlet uiImage = UIImage(cgImage: context.makeImage()!)\n", "target": "using System;\nusing System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaBarnsleyFern\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 600;\n            const int h = 600;\n            var bm = new Bitmap(w, h);\n            var r = new Random();\n            double x = 0;\n            double y = 0;\n            for (int count = 0; count < 100000; count++)\n            {\n                bm.SetPixel((int)(300 + 58 * x), (int)(58 * y), Color.ForestGreen);\n                int roll = r.Next(100);\n                double xp = x;\n                if (roll < 1)\n                {\n                    x = 0;\n                    y = 0.16 * y;\n                } else if (roll < 86)\n                {\n                    x = 0.85 * x + 0.04 * y;\n                    y = -0.04 * xp + 0.85 * y + 1.6;\n                } else if (roll < 93)\n                {\n                    x = 0.2 * x - 0.26 * y;\n                    y = 0.23 * xp + 0.22 * y + 1.6;\n                } else\n                {\n                    x = -0.15 * x + 0.28 * y;\n                    y = 0.26 * xp + 0.24 * y + 0.44;\n                }\n            }\n            const string filename = \"Fern.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 90432, "name": "Barnsley fern", "source": "Translate Swift to Java: import UIKit\nimport CoreImage\nimport PlaygroundSupport\n\nlet imageWH = 300\nlet context = CGContext(data: nil,\n                        width: imageWH,\n                        height: imageWH,\n                        bitsPerComponent: 8,\n                        bytesPerRow: 0,\n                        space: CGColorSpace(name: CGColorSpace.sRGB)!,\n                        bitmapInfo: CGImageAlphaInfo.premultipliedFirst.rawValue)!\nvar x0 = 0.0\nvar x1 = 0.0\nvar y0 = 0.0\nvar y1 = 0.0\n\ncontext.setFillColor(#colorLiteral(red: 0, green: 0, blue: 0, alpha: 1))\ncontext.fill(CGRect(x: 0, y: 0, width: imageWH, height: imageWH))\ncontext.setFillColor(#colorLiteral(red: 0.539716677, green: 1, blue: 0.265400682, alpha: 1))\n\nfor _ in 0..<100_000 {\n    switch Int(arc4random()) % 100 {\n    case 0:\n        x1 = 0\n        y1 = 0.16 * y0\n    case 1...7:\n        x1 = -0.15 * x0 + 0.28 * y0\n        y1 = 0.26 * x0 + 0.24 * y0 + 0.44\n    case 8...15:\n        x1 = 0.2 * x0 - 0.26 * y0\n        y1 = 0.23 * x0 + 0.22 * y0 + 1.6\n    default:\n        x1 = 0.85 * x0 + 0.04 * y0\n        y1 = -0.04 * x0 + 0.85 * y0 + 1.6\n    }\n    \n    context.fill(CGRect(x: 30 * x1 + Double(imageWH) / 2.0, y: 30 * y1,\n                        width: 1, height: 1))\n    \n    (x0, y0) = (x1, y1)\n}\n\nlet uiImage = UIImage(cgImage: context.makeImage()!)\n", "target": "import java.awt.*;\nimport java.awt.image.BufferedImage;\nimport javax.swing.*;\n\npublic class BarnsleyFern extends JPanel {\n\n    BufferedImage img;\n\n    public BarnsleyFern() {\n        final int dim = 640;\n        setPreferredSize(new Dimension(dim, dim));\n        setBackground(Color.white);\n        img = new BufferedImage(dim, dim, BufferedImage.TYPE_INT_ARGB);\n        createFern(dim, dim);\n    }\n\n    void createFern(int w, int h) {\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < 200_000; i++) {\n            double tmpx, tmpy;\n            double r = Math.random();\n\n            if (r <= 0.01) {\n                tmpx = 0;\n                tmpy = 0.16 * y;\n            } else if (r <= 0.08) {\n                tmpx = 0.2 * x - 0.26 * y;\n                tmpy = 0.23 * x + 0.22 * y + 1.6;\n            } else if (r <= 0.15) {\n                tmpx = -0.15 * x + 0.28 * y;\n                tmpy = 0.26 * x + 0.24 * y + 0.44;\n            } else {\n                tmpx = 0.85 * x + 0.04 * y;\n                tmpy = -0.04 * x + 0.85 * y + 1.6;\n            }\n            x = tmpx;\n            y = tmpy;\n\n            img.setRGB((int) Math.round(w / 2 + x * w / 11),\n                    (int) Math.round(h - y * h / 11), 0xFF32CD32);\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        g.drawImage(img, 0, 0, null);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Barnsley Fern\");\n            f.setResizable(false);\n            f.add(new BarnsleyFern(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 90433, "name": "Barnsley fern", "source": "Translate Swift to Java: import UIKit\nimport CoreImage\nimport PlaygroundSupport\n\nlet imageWH = 300\nlet context = CGContext(data: nil,\n                        width: imageWH,\n                        height: imageWH,\n                        bitsPerComponent: 8,\n                        bytesPerRow: 0,\n                        space: CGColorSpace(name: CGColorSpace.sRGB)!,\n                        bitmapInfo: CGImageAlphaInfo.premultipliedFirst.rawValue)!\nvar x0 = 0.0\nvar x1 = 0.0\nvar y0 = 0.0\nvar y1 = 0.0\n\ncontext.setFillColor(#colorLiteral(red: 0, green: 0, blue: 0, alpha: 1))\ncontext.fill(CGRect(x: 0, y: 0, width: imageWH, height: imageWH))\ncontext.setFillColor(#colorLiteral(red: 0.539716677, green: 1, blue: 0.265400682, alpha: 1))\n\nfor _ in 0..<100_000 {\n    switch Int(arc4random()) % 100 {\n    case 0:\n        x1 = 0\n        y1 = 0.16 * y0\n    case 1...7:\n        x1 = -0.15 * x0 + 0.28 * y0\n        y1 = 0.26 * x0 + 0.24 * y0 + 0.44\n    case 8...15:\n        x1 = 0.2 * x0 - 0.26 * y0\n        y1 = 0.23 * x0 + 0.22 * y0 + 1.6\n    default:\n        x1 = 0.85 * x0 + 0.04 * y0\n        y1 = -0.04 * x0 + 0.85 * y0 + 1.6\n    }\n    \n    context.fill(CGRect(x: 30 * x1 + Double(imageWH) / 2.0, y: 30 * y1,\n                        width: 1, height: 1))\n    \n    (x0, y0) = (x1, y1)\n}\n\nlet uiImage = UIImage(cgImage: context.makeImage()!)\n", "target": "import java.awt.*;\nimport java.awt.image.BufferedImage;\nimport javax.swing.*;\n\npublic class BarnsleyFern extends JPanel {\n\n    BufferedImage img;\n\n    public BarnsleyFern() {\n        final int dim = 640;\n        setPreferredSize(new Dimension(dim, dim));\n        setBackground(Color.white);\n        img = new BufferedImage(dim, dim, BufferedImage.TYPE_INT_ARGB);\n        createFern(dim, dim);\n    }\n\n    void createFern(int w, int h) {\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < 200_000; i++) {\n            double tmpx, tmpy;\n            double r = Math.random();\n\n            if (r <= 0.01) {\n                tmpx = 0;\n                tmpy = 0.16 * y;\n            } else if (r <= 0.08) {\n                tmpx = 0.2 * x - 0.26 * y;\n                tmpy = 0.23 * x + 0.22 * y + 1.6;\n            } else if (r <= 0.15) {\n                tmpx = -0.15 * x + 0.28 * y;\n                tmpy = 0.26 * x + 0.24 * y + 0.44;\n            } else {\n                tmpx = 0.85 * x + 0.04 * y;\n                tmpy = -0.04 * x + 0.85 * y + 1.6;\n            }\n            x = tmpx;\n            y = tmpy;\n\n            img.setRGB((int) Math.round(w / 2 + x * w / 11),\n                    (int) Math.round(h - y * h / 11), 0xFF32CD32);\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        g.drawImage(img, 0, 0, null);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Barnsley Fern\");\n            f.setResizable(false);\n            f.add(new BarnsleyFern(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 90434, "name": "Barnsley fern", "source": "Translate Swift to Python: import UIKit\nimport CoreImage\nimport PlaygroundSupport\n\nlet imageWH = 300\nlet context = CGContext(data: nil,\n                        width: imageWH,\n                        height: imageWH,\n                        bitsPerComponent: 8,\n                        bytesPerRow: 0,\n                        space: CGColorSpace(name: CGColorSpace.sRGB)!,\n                        bitmapInfo: CGImageAlphaInfo.premultipliedFirst.rawValue)!\nvar x0 = 0.0\nvar x1 = 0.0\nvar y0 = 0.0\nvar y1 = 0.0\n\ncontext.setFillColor(#colorLiteral(red: 0, green: 0, blue: 0, alpha: 1))\ncontext.fill(CGRect(x: 0, y: 0, width: imageWH, height: imageWH))\ncontext.setFillColor(#colorLiteral(red: 0.539716677, green: 1, blue: 0.265400682, alpha: 1))\n\nfor _ in 0..<100_000 {\n    switch Int(arc4random()) % 100 {\n    case 0:\n        x1 = 0\n        y1 = 0.16 * y0\n    case 1...7:\n        x1 = -0.15 * x0 + 0.28 * y0\n        y1 = 0.26 * x0 + 0.24 * y0 + 0.44\n    case 8...15:\n        x1 = 0.2 * x0 - 0.26 * y0\n        y1 = 0.23 * x0 + 0.22 * y0 + 1.6\n    default:\n        x1 = 0.85 * x0 + 0.04 * y0\n        y1 = -0.04 * x0 + 0.85 * y0 + 1.6\n    }\n    \n    context.fill(CGRect(x: 30 * x1 + Double(imageWH) / 2.0, y: 30 * y1,\n                        width: 1, height: 1))\n    \n    (x0, y0) = (x1, y1)\n}\n\nlet uiImage = UIImage(cgImage: context.makeImage()!)\n", "target": "size(640, 640)\nbackground(0)\n\nx = 0\ny = 0\n\nfor _ in range(100000):\n    xt = 0\n    yt = 0\n    r = random(100)\n\n    if r <= 1:\n        xt = 0\n        yt = 0.16 * y\n    elif r <= 8:\n        xt = 0.20 * x - 0.26 * y\n        yt = 0.23 * x + 0.22 * y + 1.60\n    elif r <= 15:\n        xt = -0.15 * x + 0.28 * y\n        yt = +0.26 * x + 0.24 * y + 0.44\n    else:\n        xt = +0.85 * x + 0.04 * y\n        yt = -0.04 * x + 0.85 * y + 1.60\nsize(640, 640)\nbackground(0)\n\nx = 0\ny = 0\n\nfor _ in range(100000):\n    xt = 0\n    yt = 0\n    r = random(100)\n    \n    if r <= 1:\n        xt = 0\n        yt = 0.16*y\n    elif r <= 8:\n        xt = 0.20*x - 0.26*y\n        yt = 0.23*x + 0.22*y + 1.60\n    elif r <= 15:\n        xt = -0.15*x + 0.28*y\n        yt =    0.26*x + 0.24*y + 0.44\n    else:\n        xt =    0.85*x + 0.04*y\n        yt = -0.04*x + 0.85*y + 1.60\n    \n    x = xt\n    y = yt\n\n    m = round(width/2 + 60*x)\n    n = height-round(60*y)\n\n    set(m, n, \"\n    x = xt\n    y = yt\n\n    m = round(width / 2 + 60 * x)\n    n = height - round(60 * y)\n\n    set(m, n, \"\n"}
{"id": 90435, "name": "Barnsley fern", "source": "Translate Swift to Python: import UIKit\nimport CoreImage\nimport PlaygroundSupport\n\nlet imageWH = 300\nlet context = CGContext(data: nil,\n                        width: imageWH,\n                        height: imageWH,\n                        bitsPerComponent: 8,\n                        bytesPerRow: 0,\n                        space: CGColorSpace(name: CGColorSpace.sRGB)!,\n                        bitmapInfo: CGImageAlphaInfo.premultipliedFirst.rawValue)!\nvar x0 = 0.0\nvar x1 = 0.0\nvar y0 = 0.0\nvar y1 = 0.0\n\ncontext.setFillColor(#colorLiteral(red: 0, green: 0, blue: 0, alpha: 1))\ncontext.fill(CGRect(x: 0, y: 0, width: imageWH, height: imageWH))\ncontext.setFillColor(#colorLiteral(red: 0.539716677, green: 1, blue: 0.265400682, alpha: 1))\n\nfor _ in 0..<100_000 {\n    switch Int(arc4random()) % 100 {\n    case 0:\n        x1 = 0\n        y1 = 0.16 * y0\n    case 1...7:\n        x1 = -0.15 * x0 + 0.28 * y0\n        y1 = 0.26 * x0 + 0.24 * y0 + 0.44\n    case 8...15:\n        x1 = 0.2 * x0 - 0.26 * y0\n        y1 = 0.23 * x0 + 0.22 * y0 + 1.6\n    default:\n        x1 = 0.85 * x0 + 0.04 * y0\n        y1 = -0.04 * x0 + 0.85 * y0 + 1.6\n    }\n    \n    context.fill(CGRect(x: 30 * x1 + Double(imageWH) / 2.0, y: 30 * y1,\n                        width: 1, height: 1))\n    \n    (x0, y0) = (x1, y1)\n}\n\nlet uiImage = UIImage(cgImage: context.makeImage()!)\n", "target": "size(640, 640)\nbackground(0)\n\nx = 0\ny = 0\n\nfor _ in range(100000):\n    xt = 0\n    yt = 0\n    r = random(100)\n\n    if r <= 1:\n        xt = 0\n        yt = 0.16 * y\n    elif r <= 8:\n        xt = 0.20 * x - 0.26 * y\n        yt = 0.23 * x + 0.22 * y + 1.60\n    elif r <= 15:\n        xt = -0.15 * x + 0.28 * y\n        yt = +0.26 * x + 0.24 * y + 0.44\n    else:\n        xt = +0.85 * x + 0.04 * y\n        yt = -0.04 * x + 0.85 * y + 1.60\nsize(640, 640)\nbackground(0)\n\nx = 0\ny = 0\n\nfor _ in range(100000):\n    xt = 0\n    yt = 0\n    r = random(100)\n    \n    if r <= 1:\n        xt = 0\n        yt = 0.16*y\n    elif r <= 8:\n        xt = 0.20*x - 0.26*y\n        yt = 0.23*x + 0.22*y + 1.60\n    elif r <= 15:\n        xt = -0.15*x + 0.28*y\n        yt =    0.26*x + 0.24*y + 0.44\n    else:\n        xt =    0.85*x + 0.04*y\n        yt = -0.04*x + 0.85*y + 1.60\n    \n    x = xt\n    y = yt\n\n    m = round(width/2 + 60*x)\n    n = height-round(60*y)\n\n    set(m, n, \"\n    x = xt\n    y = yt\n\n    m = round(width / 2 + 60 * x)\n    n = height - round(60 * y)\n\n    set(m, n, \"\n"}
{"id": 90876, "name": "Command-line arguments", "source": "Translate Swift to C#: let args = Process.arguments\nprintln(\"This program is named \\(args[0]).\")\nprintln(\"There are \\(args.count-1) arguments.\")\nfor i in 1..<args.count {\n  println(\"the argument #\\(i) is \\(args[i])\")\n}\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            for (int i = 0; i < args.Length; i++)\n                Console.WriteLine(String.Format(\"Argument {0} is '{1}'\", i, args[i]));\n        }\n    }\n}\n"}
{"id": 90877, "name": "Command-line arguments", "source": "Translate Swift to C#: let args = Process.arguments\nprintln(\"This program is named \\(args[0]).\")\nprintln(\"There are \\(args.count-1) arguments.\")\nfor i in 1..<args.count {\n  println(\"the argument #\\(i) is \\(args[i])\")\n}\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            for (int i = 0; i < args.Length; i++)\n                Console.WriteLine(String.Format(\"Argument {0} is '{1}'\", i, args[i]));\n        }\n    }\n}\n"}
{"id": 90880, "name": "Command-line arguments", "source": "Translate Swift to Java: let args = Process.arguments\nprintln(\"This program is named \\(args[0]).\")\nprintln(\"There are \\(args.count-1) arguments.\")\nfor i in 1..<args.count {\n  println(\"the argument #\\(i) is \\(args[i])\")\n}\n", "target": "public class Arguments {\n  public static void main(String[] args) {\n     System.out.println(\"There are \" + args.length + \" arguments given.\");\n     for(int i = 0; i < args.length; i++) \n        System.out.println(\"The argument #\" + (i+1) + \" is \" + args[i] + \" and is at index \" + i);\n  }\n}\n"}
{"id": 90881, "name": "Command-line arguments", "source": "Translate Swift to Java: let args = Process.arguments\nprintln(\"This program is named \\(args[0]).\")\nprintln(\"There are \\(args.count-1) arguments.\")\nfor i in 1..<args.count {\n  println(\"the argument #\\(i) is \\(args[i])\")\n}\n", "target": "public class Arguments {\n  public static void main(String[] args) {\n     System.out.println(\"There are \" + args.length + \" arguments given.\");\n     for(int i = 0; i < args.length; i++) \n        System.out.println(\"The argument #\" + (i+1) + \" is \" + args[i] + \" and is at index \" + i);\n  }\n}\n"}
{"id": 90882, "name": "Command-line arguments", "source": "Translate Swift to Python: let args = Process.arguments\nprintln(\"This program is named \\(args[0]).\")\nprintln(\"There are \\(args.count-1) arguments.\")\nfor i in 1..<args.count {\n  println(\"the argument #\\(i) is \\(args[i])\")\n}\n", "target": "import sys\nprogram_name = sys.argv[0]\narguments = sys.argv[1:]\ncount = len(arguments)\n"}
{"id": 90883, "name": "Command-line arguments", "source": "Translate Swift to Python: let args = Process.arguments\nprintln(\"This program is named \\(args[0]).\")\nprintln(\"There are \\(args.count-1) arguments.\")\nfor i in 1..<args.count {\n  println(\"the argument #\\(i) is \\(args[i])\")\n}\n", "target": "import sys\nprogram_name = sys.argv[0]\narguments = sys.argv[1:]\ncount = len(arguments)\n"}
{"id": 91385, "name": "Tokenize a string", "source": "Translate Swift to C#: let text = \"Hello,How,Are,You,Today\"\nlet tokens = text.components(separatedBy: \",\") \nprint(tokens)\nlet result = tokens.joined(separator: \".\")\nprint(result)\n", "target": "string str = \"Hello,How,Are,You,Today\"; \n\n\nstring[] strings = str.Split(',');\nConsole.WriteLine(String.Join(\".\", strings));\n"}
{"id": 91387, "name": "Tokenize a string", "source": "Translate Swift to Java: let text = \"Hello,How,Are,You,Today\"\nlet tokens = text.components(separatedBy: \",\") \nprint(tokens)\nlet result = tokens.joined(separator: \".\")\nprint(result)\n", "target": "String toTokenize = \"Hello,How,Are,You,Today\";\nSystem.out.println(String.join(\".\", toTokenize.split(\",\")));\n"}
{"id": 91388, "name": "Tokenize a string", "source": "Translate Swift to Python: let text = \"Hello,How,Are,You,Today\"\nlet tokens = text.components(separatedBy: \",\") \nprint(tokens)\nlet result = tokens.joined(separator: \".\")\nprint(result)\n", "target": "let text = 'Hello,How,Are,You,Today'\nlet tokens = text.split(||,||)\nprint tokens.join(with: '.')\n"}
{"id": 91813, "name": "Stack", "source": "Translate Swift to C#: struct Stack<T> {\n    var items = [T]()\n    var empty:Bool {\n        return items.count == 0\n    }\n    \n    func peek() -> T {\n        return items[items.count - 1]\n    }\n    \n    mutating func pop() -> T {\n        return items.removeLast()\n    }\n    \n    mutating func push(obj:T) {\n        items.append(obj)\n    }\n}\n\nvar stack = Stack<Int>()\nstack.push(1)\nstack.push(2)\nprintln(stack.pop())\nprintln(stack.peek())\nstack.pop()\nprintln(stack.empty)\n", "target": "\nSystem.Collections.Stack stack = new System.Collections.Stack();\nstack.Push( obj );\nbool isEmpty = stack.Count == 0;\nobject top = stack.Peek(); \ntop = stack.Pop();\n\n\nSystem.Collections.Generic.Stack<Foo> stack = new System.Collections.Generic.Stack<Foo>();\nstack.Push(new Foo());\nbool isEmpty = stack.Count == 0;\nFoo top = stack.Peek(); \ntop = stack.Pop();\n"}
{"id": 91815, "name": "Stack", "source": "Translate Swift to Java: struct Stack<T> {\n    var items = [T]()\n    var empty:Bool {\n        return items.count == 0\n    }\n    \n    func peek() -> T {\n        return items[items.count - 1]\n    }\n    \n    mutating func pop() -> T {\n        return items.removeLast()\n    }\n    \n    mutating func push(obj:T) {\n        items.append(obj)\n    }\n}\n\nvar stack = Stack<Int>()\nstack.push(1)\nstack.push(2)\nprintln(stack.pop())\nprintln(stack.peek())\nstack.pop()\nprintln(stack.empty)\n", "target": "import java.util.Stack;\n\npublic class StackTest {\n    public static void main( final String[] args ) {\n        final Stack<String> stack = new Stack<String>();\n\n        System.out.println( \"New stack empty? \" + stack.empty() );\n\n        stack.push( \"There can be only one\" );\n        System.out.println( \"Pushed stack empty? \" + stack.empty() );\n        System.out.println( \"Popped single entry: \" + stack.pop() );\n\n        stack.push( \"First\" );\n        stack.push( \"Second\" );\n        System.out.println( \"Popped entry should be second: \" + stack.pop() );\n\n        \n        stack.pop();\n        stack.pop();\n    }\n}\n"}
{"id": 91816, "name": "Stack", "source": "Translate Swift to Python: struct Stack<T> {\n    var items = [T]()\n    var empty:Bool {\n        return items.count == 0\n    }\n    \n    func peek() -> T {\n        return items[items.count - 1]\n    }\n    \n    mutating func pop() -> T {\n        return items.removeLast()\n    }\n    \n    mutating func push(obj:T) {\n        items.append(obj)\n    }\n}\n\nvar stack = Stack<Int>()\nstack.push(1)\nstack.push(2)\nprintln(stack.pop())\nprintln(stack.peek())\nstack.pop()\nprintln(stack.empty)\n", "target": "from collections import deque\nstack = deque()\nstack.append(value) \nvalue = stack.pop()\nnot stack \n"}
{"id": 92056, "name": "CRC-32", "source": "Translate Swift to C#: import Foundation\n\nlet strData = \"The quick brown fox jumps over the lazy dog\".dataUsingEncoding(NSUTF8StringEncoding,\n    allowLossyConversion: false)\nlet crc = crc32(uLong(0), UnsafePointer<Bytef>(strData!.bytes), uInt(strData!.length))\n\nprintln(NSString(format:\"%2X\", crc))\n", "target": "    \n    \n    \n    public class Crc32\n    {\n        #region Constants\n        \n        \n        \n        private const UInt32 s_generator = 0xEDB88320;\n        #endregion\n\n        #region Constructors\n        \n        \n        \n        public Crc32()\n        {\n            \n            m_checksumTable = Enumerable.Range(0, 256).Select(i =>\n            {\n                var tableEntry = (uint)i;\n                for (var j = 0; j < 8; ++j)\n                {\n                    tableEntry = ((tableEntry & 1) != 0)\n                        ? (s_generator ^ (tableEntry >> 1)) \n                        : (tableEntry >> 1);\n                }\n                return tableEntry;\n            }).ToArray();\n        }\n        #endregion\n\n        #region Methods\n        \n        \n        \n        \n        \n        public UInt32 Get<T>(IEnumerable<T> byteStream)\n        {\n            try\n            {\n                \n                return ~byteStream.Aggregate(0xFFFFFFFF, (checksumRegister, currentByte) => \n                          (m_checksumTable[(checksumRegister & 0xFF) ^ Convert.ToByte(currentByte)] ^ (checksumRegister >> 8)));\n            }\n            catch (FormatException e)\n            {\n                throw new CrcException(\"Could not read the stream out as bytes.\", e);\n            }\n            catch (InvalidCastException e)\n            {\n                throw new CrcException(\"Could not read the stream out as bytes.\", e);\n            }\n            catch (OverflowException e)\n            {\n                throw new CrcException(\"Could not read the stream out as bytes.\", e);\n            }\n        }\n        #endregion\n\n        #region Fields\n        \n        \n        \n        private readonly UInt32[] m_checksumTable;\n\n        #endregion\n    }\n"}
{"id": 92058, "name": "CRC-32", "source": "Translate Swift to Java: import Foundation\n\nlet strData = \"The quick brown fox jumps over the lazy dog\".dataUsingEncoding(NSUTF8StringEncoding,\n    allowLossyConversion: false)\nlet crc = crc32(uLong(0), UnsafePointer<Bytef>(strData!.bytes), uInt(strData!.length))\n\nprintln(NSString(format:\"%2X\", crc))\n", "target": "import java.util.zip.* ;\n\npublic class CRCMaker {\n   public static void main( String[ ] args ) {\n      String toBeEncoded = new String( \"The quick brown fox jumps over the lazy dog\" ) ;\n      CRC32 myCRC = new CRC32( ) ;\n      myCRC.update( toBeEncoded.getBytes( ) ) ;\n      System.out.println( \"The CRC-32 value is\u00a0: \" + Long.toHexString( myCRC.getValue( ) ) + \"\u00a0!\" ) ;\n   }\n}\n"}
{"id": 92059, "name": "CRC-32", "source": "Translate Swift to Python: import Foundation\n\nlet strData = \"The quick brown fox jumps over the lazy dog\".dataUsingEncoding(NSUTF8StringEncoding,\n    allowLossyConversion: false)\nlet crc = crc32(uLong(0), UnsafePointer<Bytef>(strData!.bytes), uInt(strData!.length))\n\nprintln(NSString(format:\"%2X\", crc))\n", "target": ">>> s = 'The quick brown fox jumps over the lazy dog'\n>>> import zlib\n>>> hex(zlib.crc32(s))\n'0x414fa339'\n\n>>> import binascii\n>>> hex(binascii.crc32(s))\n'0x414fa339'\n"}
{"id": 92217, "name": "Determine if only one instance is running", "source": "Translate Swift to C#: import Foundation\n\nlet globalCenter = NSDistributedNotificationCenter.defaultCenter()\nlet time = NSDate().timeIntervalSince1970\n\nglobalCenter.addObserverForName(\"OnlyOne\", object: nil, queue: NSOperationQueue.mainQueue()) {not in\n    if let senderTime = not.userInfo?[\"time\"] as? NSTimeInterval where senderTime != time {\n        println(\"More than one running\")\n        exit(0)\n    } else {\n        println(\"Only one\")\n    }\n}\n\nfunc send() {\n    globalCenter.postNotificationName(\"OnlyOne\", object: nil, userInfo: [\"time\": time])\n    \n    let waitTime = dispatch_time(DISPATCH_TIME_NOW, Int64(3 * NSEC_PER_SEC))\n    \n    dispatch_after(waitTime, dispatch_get_main_queue()) {\n        send()\n    }\n}\n\nsend()\nCFRunLoopRun()\n", "target": "using System;\nusing System.Net;\nusing System.Net.Sockets;\n\nclass Program {        \n    static void Main(string[] args) {        \n        try {\n            TcpListener server = new TcpListener(IPAddress.Any, 12345);\n            server.Start();\n        } \n       \n        catch (SocketException e) {\n            if (e.SocketErrorCode == SocketError.AddressAlreadyInUse) {\n                Console.Error.WriteLine(\"Already running.\");\n            }\n        }\n    }\n}\n"}
{"id": 92219, "name": "Determine if only one instance is running", "source": "Translate Swift to Java: import Foundation\n\nlet globalCenter = NSDistributedNotificationCenter.defaultCenter()\nlet time = NSDate().timeIntervalSince1970\n\nglobalCenter.addObserverForName(\"OnlyOne\", object: nil, queue: NSOperationQueue.mainQueue()) {not in\n    if let senderTime = not.userInfo?[\"time\"] as? NSTimeInterval where senderTime != time {\n        println(\"More than one running\")\n        exit(0)\n    } else {\n        println(\"Only one\")\n    }\n}\n\nfunc send() {\n    globalCenter.postNotificationName(\"OnlyOne\", object: nil, userInfo: [\"time\": time])\n    \n    let waitTime = dispatch_time(DISPATCH_TIME_NOW, Int64(3 * NSEC_PER_SEC))\n    \n    dispatch_after(waitTime, dispatch_get_main_queue()) {\n        send()\n    }\n}\n\nsend()\nCFRunLoopRun()\n", "target": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.UnknownHostException;\n \npublic class SingletonApp\n{\n    private static final int PORT = 65000;  \n    private static ServerSocket s;\n\n    \n    static {\n        try {\n            s = new ServerSocket(PORT, 10, InetAddress.getLocalHost());\n        } catch (UnknownHostException e) {\n            \n        } catch (IOException e) {\n            \n            System.out.print(\"Application is already running,\");\n            System.out.println(\" so terminating this instance.\");\n            System.exit(0);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.print(\"OK, only this instance is running\");\n        System.out.println(\" but will terminate in 10 seconds.\");\n        try {\n            Thread.sleep(10000);\n            if (s != null && !s.isClosed()) s.close();\n        } catch (Exception e) {\n            System.err.println(e);\n        }\n    }\n}\n"}
{"id": 92220, "name": "Determine if only one instance is running", "source": "Translate Swift to Python: import Foundation\n\nlet globalCenter = NSDistributedNotificationCenter.defaultCenter()\nlet time = NSDate().timeIntervalSince1970\n\nglobalCenter.addObserverForName(\"OnlyOne\", object: nil, queue: NSOperationQueue.mainQueue()) {not in\n    if let senderTime = not.userInfo?[\"time\"] as? NSTimeInterval where senderTime != time {\n        println(\"More than one running\")\n        exit(0)\n    } else {\n        println(\"Only one\")\n    }\n}\n\nfunc send() {\n    globalCenter.postNotificationName(\"OnlyOne\", object: nil, userInfo: [\"time\": time])\n    \n    let waitTime = dispatch_time(DISPATCH_TIME_NOW, Int64(3 * NSEC_PER_SEC))\n    \n    dispatch_after(waitTime, dispatch_get_main_queue()) {\n        send()\n    }\n}\n\nsend()\nCFRunLoopRun()\n", "target": "import __main__, os\n\ndef isOnlyInstance():\n    \n    \n    return os.system(\"(( $(ps -ef | grep python | grep '[\" +\n                     __main__.__file__[0] + \"]\" + __main__.__file__[1:] +\n                     \"' | wc -l) > 1 ))\") != 0\n"}
{"id": 92600, "name": "Van der Corput sequence", "source": "Translate Swift to C#: func vanDerCorput(n: Int, base: Int, num: inout Int, denom: inout Int) {\n  var n = n, p = 0, q = 1\n\n  while n != 0 {\n    p = p * base + (n % base)\n    q *= base\n    n /= base\n  }\n\n  num = p\n  denom = q\n\n  while p != 0 {\n    n = p\n    p = q % p\n    q = n\n  }\n\n  num /= q\n  denom /= q\n}\n\nvar num = 0\nvar denom = 0\n\nfor base in 2...5 {\n  print(\"base \\(base): 0 \", terminator: \"\")\n\n  for n in 1..<10 {\n    vanDerCorput(n: n, base: base, num: &num, denom: &denom)\n\n    print(\"\\(num)/\\(denom) \", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace VanDerCorput\n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    public class VanDerCorputSequence: IEnumerable<Tuple<long,long>>\n    {\n        \n        \n        \n        public int Base { get; private set; }\n\n        \n        \n        \n        public long Count { get; private set; }\n\n        \n        \n        \n        \n        \n        public VanDerCorputSequence(int iBase, long count = long.MaxValue) {\n            if (iBase < 2)\n                throw new ArgumentOutOfRangeException(\"iBase\", \"must be two or greater, not the given value of \" + iBase);\n            Base = iBase;\n            Count = count;\n        }\n\n        \n        \n        \n        \n        \n        \n        public Tuple<long,long> Compute(long n)\n        {\n            long p = 0, q = 1;\n            long numerator, denominator;\n            while (n != 0)\n            {\n                p = p * Base + (n % Base);\n                q *= Base;\n                n /= Base;\n            }\n            numerator = p;\n            denominator = q;\n            while (p != 0) \n            { \n                n = p; \n                p = q % p; \n                q = n; \n            }\n            numerator /= q;\n            denominator /= q;\n            return new Tuple<long,long>(numerator, denominator);\n        }\n\n        \n        \n        \n        \n        \n        \n        public static Tuple<long, long> Compute(int iBase, long n)\n        {\n            var seq = new VanDerCorputSequence(iBase);\n            return seq.Compute(n);\n        }\n\n        \n        \n        \n        \n        \n        public IEnumerator<Tuple<long, long>> GetEnumerator()\n        {\n            long iSequenceIndex = 0L;\n            while (iSequenceIndex < Count)\n            {\n                yield return Compute(iSequenceIndex);\n                iSequenceIndex++;\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()\n        {\n            return GetEnumerator();\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            TestBasesTwoThroughFive();\n\n            Console.WriteLine(\"Type return to continue...\");\n            Console.ReadLine();\n        }\n\n        static void TestBasesTwoThroughFive()\n        {\n            foreach (var seq in Enumerable.Range(2, 5).Select(x => new VanDerCorputSequence(x, 10))) \n            {\n                Console.Write(\"base \" + seq.Base + \":\");\n                foreach(var vc in seq) \n                    Console.Write(\" \" + vc.Item1 + \"/\" + vc.Item2);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 92601, "name": "Van der Corput sequence", "source": "Translate Swift to C#: func vanDerCorput(n: Int, base: Int, num: inout Int, denom: inout Int) {\n  var n = n, p = 0, q = 1\n\n  while n != 0 {\n    p = p * base + (n % base)\n    q *= base\n    n /= base\n  }\n\n  num = p\n  denom = q\n\n  while p != 0 {\n    n = p\n    p = q % p\n    q = n\n  }\n\n  num /= q\n  denom /= q\n}\n\nvar num = 0\nvar denom = 0\n\nfor base in 2...5 {\n  print(\"base \\(base): 0 \", terminator: \"\")\n\n  for n in 1..<10 {\n    vanDerCorput(n: n, base: base, num: &num, denom: &denom)\n\n    print(\"\\(num)/\\(denom) \", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace VanDerCorput\n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    public class VanDerCorputSequence: IEnumerable<Tuple<long,long>>\n    {\n        \n        \n        \n        public int Base { get; private set; }\n\n        \n        \n        \n        public long Count { get; private set; }\n\n        \n        \n        \n        \n        \n        public VanDerCorputSequence(int iBase, long count = long.MaxValue) {\n            if (iBase < 2)\n                throw new ArgumentOutOfRangeException(\"iBase\", \"must be two or greater, not the given value of \" + iBase);\n            Base = iBase;\n            Count = count;\n        }\n\n        \n        \n        \n        \n        \n        \n        public Tuple<long,long> Compute(long n)\n        {\n            long p = 0, q = 1;\n            long numerator, denominator;\n            while (n != 0)\n            {\n                p = p * Base + (n % Base);\n                q *= Base;\n                n /= Base;\n            }\n            numerator = p;\n            denominator = q;\n            while (p != 0) \n            { \n                n = p; \n                p = q % p; \n                q = n; \n            }\n            numerator /= q;\n            denominator /= q;\n            return new Tuple<long,long>(numerator, denominator);\n        }\n\n        \n        \n        \n        \n        \n        \n        public static Tuple<long, long> Compute(int iBase, long n)\n        {\n            var seq = new VanDerCorputSequence(iBase);\n            return seq.Compute(n);\n        }\n\n        \n        \n        \n        \n        \n        public IEnumerator<Tuple<long, long>> GetEnumerator()\n        {\n            long iSequenceIndex = 0L;\n            while (iSequenceIndex < Count)\n            {\n                yield return Compute(iSequenceIndex);\n                iSequenceIndex++;\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()\n        {\n            return GetEnumerator();\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            TestBasesTwoThroughFive();\n\n            Console.WriteLine(\"Type return to continue...\");\n            Console.ReadLine();\n        }\n\n        static void TestBasesTwoThroughFive()\n        {\n            foreach (var seq in Enumerable.Range(2, 5).Select(x => new VanDerCorputSequence(x, 10))) \n            {\n                Console.Write(\"base \" + seq.Base + \":\");\n                foreach(var vc in seq) \n                    Console.Write(\" \" + vc.Item1 + \"/\" + vc.Item2);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 92604, "name": "Van der Corput sequence", "source": "Translate Swift to Java: func vanDerCorput(n: Int, base: Int, num: inout Int, denom: inout Int) {\n  var n = n, p = 0, q = 1\n\n  while n != 0 {\n    p = p * base + (n % base)\n    q *= base\n    n /= base\n  }\n\n  num = p\n  denom = q\n\n  while p != 0 {\n    n = p\n    p = q % p\n    q = n\n  }\n\n  num /= q\n  denom /= q\n}\n\nvar num = 0\nvar denom = 0\n\nfor base in 2...5 {\n  print(\"base \\(base): 0 \", terminator: \"\")\n\n  for n in 1..<10 {\n    vanDerCorput(n: n, base: base, num: &num, denom: &denom)\n\n    print(\"\\(num)/\\(denom) \", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "public class VanDerCorput{\n\tpublic static double vdc(int n){\n\t\tdouble vdc = 0;\n\t\tint denom = 1;\n\t\twhile(n != 0){\n\t\t\tvdc += n % 2.0 / (denom *= 2);\n\t\t\tn /= 2;\n\t\t}\n\t\treturn vdc;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(vdc(i));\n\t\t}\n\t}\n}\n"}
{"id": 92605, "name": "Van der Corput sequence", "source": "Translate Swift to Java: func vanDerCorput(n: Int, base: Int, num: inout Int, denom: inout Int) {\n  var n = n, p = 0, q = 1\n\n  while n != 0 {\n    p = p * base + (n % base)\n    q *= base\n    n /= base\n  }\n\n  num = p\n  denom = q\n\n  while p != 0 {\n    n = p\n    p = q % p\n    q = n\n  }\n\n  num /= q\n  denom /= q\n}\n\nvar num = 0\nvar denom = 0\n\nfor base in 2...5 {\n  print(\"base \\(base): 0 \", terminator: \"\")\n\n  for n in 1..<10 {\n    vanDerCorput(n: n, base: base, num: &num, denom: &denom)\n\n    print(\"\\(num)/\\(denom) \", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "public class VanDerCorput{\n\tpublic static double vdc(int n){\n\t\tdouble vdc = 0;\n\t\tint denom = 1;\n\t\twhile(n != 0){\n\t\t\tvdc += n % 2.0 / (denom *= 2);\n\t\t\tn /= 2;\n\t\t}\n\t\treturn vdc;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(vdc(i));\n\t\t}\n\t}\n}\n"}
{"id": 92606, "name": "Van der Corput sequence", "source": "Translate Swift to Python: func vanDerCorput(n: Int, base: Int, num: inout Int, denom: inout Int) {\n  var n = n, p = 0, q = 1\n\n  while n != 0 {\n    p = p * base + (n % base)\n    q *= base\n    n /= base\n  }\n\n  num = p\n  denom = q\n\n  while p != 0 {\n    n = p\n    p = q % p\n    q = n\n  }\n\n  num /= q\n  denom /= q\n}\n\nvar num = 0\nvar denom = 0\n\nfor base in 2...5 {\n  print(\"base \\(base): 0 \", terminator: \"\")\n\n  for n in 1..<10 {\n    vanDerCorput(n: n, base: base, num: &num, denom: &denom)\n\n    print(\"\\(num)/\\(denom) \", terminator: \"\")\n  }\n\n  print()\n}\n", "target": ">>> def base10change(n, base):\n\tdigits = []\n\twhile n:\n\t\tn,remainder = divmod(n, base)\n\t\tdigits.insert(0, remainder)\n\treturn digits\n\n>>> base10change(11, 2)\n[1, 0, 1, 1]\n"}
{"id": 92607, "name": "Van der Corput sequence", "source": "Translate Swift to Python: func vanDerCorput(n: Int, base: Int, num: inout Int, denom: inout Int) {\n  var n = n, p = 0, q = 1\n\n  while n != 0 {\n    p = p * base + (n % base)\n    q *= base\n    n /= base\n  }\n\n  num = p\n  denom = q\n\n  while p != 0 {\n    n = p\n    p = q % p\n    q = n\n  }\n\n  num /= q\n  denom /= q\n}\n\nvar num = 0\nvar denom = 0\n\nfor base in 2...5 {\n  print(\"base \\(base): 0 \", terminator: \"\")\n\n  for n in 1..<10 {\n    vanDerCorput(n: n, base: base, num: &num, denom: &denom)\n\n    print(\"\\(num)/\\(denom) \", terminator: \"\")\n  }\n\n  print()\n}\n", "target": ">>> def base10change(n, base):\n\tdigits = []\n\twhile n:\n\t\tn,remainder = divmod(n, base)\n\t\tdigits.insert(0, remainder)\n\treturn digits\n\n>>> base10change(11, 2)\n[1, 0, 1, 1]\n"}
{"id": 92871, "name": "Loops_Nested", "source": "Translate Swift to C#: let array = [[2, 12, 10, 4], [18, 11, 20, 2]]\n\nloop: for row in array {\n    for element in row {\n        println(\" \\(element)\")\n        if element == 20 { break loop }\n    }\n}\nprint(\"done\")\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        int[,] a = new int[10, 10];\n        Random r = new Random();\n\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                a[i, j] = r.Next(0, 21) + 1;\n            }\n        }\n        \n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                Console.Write(\" {0}\", a[i, j]);\n                if (a[i, j] == 20) {\n                    goto Done;\n                }\n            }\n            Console.WriteLine();\n        }\n    Done:\n        Console.WriteLine();\n    }\n}\n"}
{"id": 92873, "name": "Loops_Nested", "source": "Translate Swift to Java: let array = [[2, 12, 10, 4], [18, 11, 20, 2]]\n\nloop: for row in array {\n    for element in row {\n        println(\" \\(element)\")\n        if element == 20 { break loop }\n    }\n}\nprint(\"done\")\n", "target": "import java.util.Random;\n\npublic class NestedLoopTest {\n    public static final Random gen = new Random();\n    public static void main(String[] args) {\n        int[][] a = new int[10][10];\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[i].length; j++)\n                a[i][j] = gen.nextInt(20) + 1;\n\n        Outer:for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < a[i].length; j++) {\n                System.out.print(\" \" + a[i][j]);\n                if (a[i][j] == 20)\n                    break Outer; \n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 92874, "name": "Loops_Nested", "source": "Translate Swift to Python: let array = [[2, 12, 10, 4], [18, 11, 20, 2]]\n\nloop: for row in array {\n    for element in row {\n        println(\" \\(element)\")\n        if element == 20 { break loop }\n    }\n}\nprint(\"done\")\n", "target": "from random import randint\n\ndef do_scan(mat):\n    for row in mat:\n        for item in row:\n            print item,\n            if item == 20:\n                print\n                return\n        print\n    print\n\nmat = [[randint(1, 20) for x in xrange(10)] for y in xrange(10)]\ndo_scan(mat)\n"}
{"id": 93350, "name": "Sorting algorithms_Heapsort", "source": "Translate Swift to C#: func heapsort<T:Comparable>(inout list:[T]) {\n    var count = list.count\n    \n    func shiftDown(inout list:[T], start:Int, end:Int) {\n        var root = start\n        \n        while root * 2 + 1 <= end {\n            var child = root * 2 + 1\n            var swap = root\n            \n            if list[swap] < list[child] {\n                swap = child\n            }\n            \n            if child + 1 <= end && list[swap] < list[child + 1] {\n                swap = child + 1\n            }\n            \n            if swap == root {\n                return\n            } else {\n                (list[root], list[swap]) = (list[swap], list[root])\n                root = swap\n            }\n        }\n    }\n    \n    func heapify(inout list:[T], count:Int) {\n        var start = (count - 2) / 2\n        \n        while start >= 0 {\n            shiftDown(&list, start, count - 1)\n            \n            start--\n        }\n    }\n    \n    heapify(&list, count)\n    \n    var end = count - 1\n    \n    while end > 0 {\n        (list[end], list[0]) = (list[0], list[end])\n        \n        end--\n        \n        shiftDown(&list, 0, end)\n    }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\npublic class HeapSortClass\n{\n    public static void HeapSort<T>(T[] array)\n    {\n        HeapSort<T>(array, 0, array.Length, Comparer<T>.Default);\n    }\n\n    public static void HeapSort<T>(T[] array, int offset, int length, IComparer<T> comparer)\n    {\n        HeapSort<T>(array, offset, length, comparer.Compare);\n    }\n\n    public static void HeapSort<T>(T[] array, int offset, int length, Comparison<T> comparison)\n    {\n        \n        for (int i = 0; i < length; i++)\n        {\n            int index = i;\n            T item = array[offset + i]; \n\n            \n            while (index > 0 &&\n                comparison(array[offset + (index - 1) / 2], item) < 0)\n            {\n                int top = (index - 1) / 2;\n                array[offset + index] = array[offset + top];\n                index = top;\n            }\n            array[offset + index] = item;\n        }\n\n        for (int i = length - 1; i > 0; i--)\n        {\n            \n            T last = array[offset + i];\n            array[offset + i] = array[offset];\n\n            int index = 0;\n            \n            while (index * 2 + 1 < i)\n            {\n                int left = index * 2 + 1, right = left + 1;\n\n                if (right < i && comparison(array[offset + left], array[offset + right]) < 0)\n                {\n                    if (comparison(last, array[offset + right]) > 0) break;\n\n                    array[offset + index] = array[offset + right];\n                    index = right;\n                }\n                else\n                {\n                    if (comparison(last, array[offset + left]) > 0) break;\n\n                    array[offset + index] = array[offset + left];\n                    index = left;\n                }\n            }\n            array[offset + index] = last;\n        }\n    }\n\n    static void Main()\n    {\n        \n        byte[] r = {5, 4, 1, 2};\n        HeapSort(r);\n\n        string[] s = { \"-\", \"D\", \"a\", \"33\" };\n        HeapSort(s, 0, s.Length, StringComparer.CurrentCultureIgnoreCase);\n    }\n}\n"}
{"id": 93352, "name": "Sorting algorithms_Heapsort", "source": "Translate Swift to Java: func heapsort<T:Comparable>(inout list:[T]) {\n    var count = list.count\n    \n    func shiftDown(inout list:[T], start:Int, end:Int) {\n        var root = start\n        \n        while root * 2 + 1 <= end {\n            var child = root * 2 + 1\n            var swap = root\n            \n            if list[swap] < list[child] {\n                swap = child\n            }\n            \n            if child + 1 <= end && list[swap] < list[child + 1] {\n                swap = child + 1\n            }\n            \n            if swap == root {\n                return\n            } else {\n                (list[root], list[swap]) = (list[swap], list[root])\n                root = swap\n            }\n        }\n    }\n    \n    func heapify(inout list:[T], count:Int) {\n        var start = (count - 2) / 2\n        \n        while start >= 0 {\n            shiftDown(&list, start, count - 1)\n            \n            start--\n        }\n    }\n    \n    heapify(&list, count)\n    \n    var end = count - 1\n    \n    while end > 0 {\n        (list[end], list[0]) = (list[0], list[end])\n        \n        end--\n        \n        shiftDown(&list, 0, end)\n    }\n}\n", "target": "public static void heapSort(int[] a){\n\tint count = a.length;\n\n\t\n\theapify(a, count);\n\n\tint end = count - 1;\n\twhile(end > 0){\n\t\t\n\t\t\n\t\tint tmp = a[end];\n\t\ta[end] = a[0];\n\t\ta[0] = tmp;\n\t\t\n\t\tsiftDown(a, 0, end - 1);\n\t\t\n\t\t\n\t\tend--;\n\t}\n}\n\npublic static void heapify(int[] a, int count){\n\t\n\tint start = (count - 2) / 2; \n\n\twhile(start >= 0){\n\t\t\n\t\t\n\t\t\n\t\tsiftDown(a, start, count - 1);\n\t\tstart--;\n\t}\n\t\n}\n\npublic static void siftDown(int[] a, int start, int end){\n\t\n\tint root = start;\n\n\twhile((root * 2 + 1) <= end){      \n\t\tint child = root * 2 + 1;           \n\t\t\n\t\tif(child + 1 <= end && a[child] < a[child + 1])\n\t\t\tchild = child + 1;           \n\t\tif(a[root] < a[child]){     \n\t\t\tint tmp = a[root];\n\t\t\ta[root] = a[child];\n\t\t\ta[child] = tmp;\n\t\t\troot = child;                \n\t\t}else\n\t\t\treturn;\n\t}\n}\n"}
{"id": 93353, "name": "Sorting algorithms_Heapsort", "source": "Translate Swift to Python: func heapsort<T:Comparable>(inout list:[T]) {\n    var count = list.count\n    \n    func shiftDown(inout list:[T], start:Int, end:Int) {\n        var root = start\n        \n        while root * 2 + 1 <= end {\n            var child = root * 2 + 1\n            var swap = root\n            \n            if list[swap] < list[child] {\n                swap = child\n            }\n            \n            if child + 1 <= end && list[swap] < list[child + 1] {\n                swap = child + 1\n            }\n            \n            if swap == root {\n                return\n            } else {\n                (list[root], list[swap]) = (list[swap], list[root])\n                root = swap\n            }\n        }\n    }\n    \n    func heapify(inout list:[T], count:Int) {\n        var start = (count - 2) / 2\n        \n        while start >= 0 {\n            shiftDown(&list, start, count - 1)\n            \n            start--\n        }\n    }\n    \n    heapify(&list, count)\n    \n    var end = count - 1\n    \n    while end > 0 {\n        (list[end], list[0]) = (list[0], list[end])\n        \n        end--\n        \n        shiftDown(&list, 0, end)\n    }\n}\n", "target": "def heapsort(lst):\n  \n\n  \n  for start in range((len(lst)-2)/2, -1, -1):\n    siftdown(lst, start, len(lst)-1)\n\n  for end in range(len(lst)-1, 0, -1):\n    lst[end], lst[0] = lst[0], lst[end]\n    siftdown(lst, 0, end - 1)\n  return lst\n\ndef siftdown(lst, start, end):\n  root = start\n  while True:\n    child = root * 2 + 1\n    if child > end: break\n    if child + 1 <= end and lst[child] < lst[child + 1]:\n      child += 1\n    if lst[root] < lst[child]:\n      lst[root], lst[child] = lst[child], lst[root]\n      root = child\n    else:\n      break\n"}
{"id": 93659, "name": "Nim game", "source": "Translate Swift to C#: var tokens = 12\n\nwhile tokens != 0 {\n  print(\"Tokens remaining: \\(tokens)\\nPlease enter a number between 1 and 3: \", terminator: \"\")\n\n  guard let input = readLine(), let n = Int(input), n >= 1 && n <= 3 else {\n    fatalError(\"Invalid input\")\n  }\n\n  tokens -= n\n\n  if tokens == 0 {\n    print(\"You win!\")\n\n    break\n  }\n\n  print(\"I'll remove \\(4 - n) tokens.\")\n\n  tokens -= 4 - n\n\n  if tokens == 0 {\n    print(\"I win!\")\n  }\n\n  print()\n}\n", "target": "using System;\n\nnamespace nimGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"There are twelve tokens.\\n\" +\n                    \"You can take 1, 2, or 3 on your turn.\\n\" +\n                    \"Whoever takes the last token wins.\\n\");\n\n            int tokens = 12;\n\n            while (tokens > 0)\n            {\n                Console.WriteLine(\"There are \" + tokens + \" remaining.\");\n                Console.WriteLine(\"How many do you take?\");\n                int playertake = Convert.ToInt32(Console.ReadLine());\n\n                if (playertake < 1 | playertake > 3)\n                {\n                    Console.WriteLine(\"1, 2, or 3 only.\");\n                }\n                else\n                {\n                    tokens -= playertake;\n                    Console.WriteLine(\"I take \" + (4 - playertake) + \".\");\n                    tokens -= (4 - playertake);\n                }\n            }\n            Console.WriteLine(\"I win again.\");\n            Console.ReadLine();\n        }\n\n    }\n}\n"}
{"id": 93660, "name": "Nim game", "source": "Translate Swift to C#: var tokens = 12\n\nwhile tokens != 0 {\n  print(\"Tokens remaining: \\(tokens)\\nPlease enter a number between 1 and 3: \", terminator: \"\")\n\n  guard let input = readLine(), let n = Int(input), n >= 1 && n <= 3 else {\n    fatalError(\"Invalid input\")\n  }\n\n  tokens -= n\n\n  if tokens == 0 {\n    print(\"You win!\")\n\n    break\n  }\n\n  print(\"I'll remove \\(4 - n) tokens.\")\n\n  tokens -= 4 - n\n\n  if tokens == 0 {\n    print(\"I win!\")\n  }\n\n  print()\n}\n", "target": "using System;\n\nnamespace nimGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"There are twelve tokens.\\n\" +\n                    \"You can take 1, 2, or 3 on your turn.\\n\" +\n                    \"Whoever takes the last token wins.\\n\");\n\n            int tokens = 12;\n\n            while (tokens > 0)\n            {\n                Console.WriteLine(\"There are \" + tokens + \" remaining.\");\n                Console.WriteLine(\"How many do you take?\");\n                int playertake = Convert.ToInt32(Console.ReadLine());\n\n                if (playertake < 1 | playertake > 3)\n                {\n                    Console.WriteLine(\"1, 2, or 3 only.\");\n                }\n                else\n                {\n                    tokens -= playertake;\n                    Console.WriteLine(\"I take \" + (4 - playertake) + \".\");\n                    tokens -= (4 - playertake);\n                }\n            }\n            Console.WriteLine(\"I win again.\");\n            Console.ReadLine();\n        }\n\n    }\n}\n"}
{"id": 93663, "name": "Nim game", "source": "Translate Swift to Java: var tokens = 12\n\nwhile tokens != 0 {\n  print(\"Tokens remaining: \\(tokens)\\nPlease enter a number between 1 and 3: \", terminator: \"\")\n\n  guard let input = readLine(), let n = Int(input), n >= 1 && n <= 3 else {\n    fatalError(\"Invalid input\")\n  }\n\n  tokens -= n\n\n  if tokens == 0 {\n    print(\"You win!\")\n\n    break\n  }\n\n  print(\"I'll remove \\(4 - n) tokens.\")\n\n  tokens -= 4 - n\n\n  if tokens == 0 {\n    print(\"I win!\")\n  }\n\n  print()\n}\n", "target": "import java.util.Scanner;\n\npublic class NimGame {\n\n    public static void main(String[] args) {\n        runGame(12);\n    }\n    \n    private static void runGame(int tokens) {\n        System.out.printf(\"Nim game.%n%n\");\n\n        Scanner in = new Scanner(System.in);;\n        \n        do {            \n            boolean humanInputOk = false;\n            int humanTokens = 0;\n            while ( ! humanInputOk ) {\n                System.out.printf(\"Human takes how many tokens?  \");\n                String input = in.next();\n                try {\n                    humanTokens = Integer.parseInt(input);\n                    if ( humanTokens >= 1 && humanTokens <= 3 ) {\n                        humanInputOk = true;\n                    }\n                    else {\n                        System.out.printf(\"Try a number between 1 and 3.%n\");\n                    }\n                }\n                catch (NumberFormatException e) {\n                    System.out.printf(\"Invalid input.  Try a number between 1 and 3.%n\");\n                }\n            }\n            \n            tokens -= humanTokens;\n            \n            System.out.printf(\"You take %d token%s.%n%d token%s remaining.%n%n\", humanTokens, humanTokens > 1 ? \"s\" : \"\", tokens, tokens != 1 ? \"s\" : \"\");\n            if ( tokens == 0 ) {\n                System.out.printf(\"You win!!.%n%n\");\n                break;\n            }\n            int computerTokens = 4 - humanTokens;\n            tokens -= computerTokens;\n            \n            System.out.printf(\"Computer takes %d token%s.%n%d token%s remaining.%n%n\", computerTokens, computerTokens != 1 ? \"s\" : \"\", tokens, tokens != 1 ? \"s\" : \"\");\n            if ( tokens == 0 ) {\n                System.out.printf(\"Computer wins!!.%n%n\");\n            }\n\n        } while (tokens > 0);\n\n        in.close();\n    }\n\n}\n"}
{"id": 93664, "name": "Nim game", "source": "Translate Swift to Java: var tokens = 12\n\nwhile tokens != 0 {\n  print(\"Tokens remaining: \\(tokens)\\nPlease enter a number between 1 and 3: \", terminator: \"\")\n\n  guard let input = readLine(), let n = Int(input), n >= 1 && n <= 3 else {\n    fatalError(\"Invalid input\")\n  }\n\n  tokens -= n\n\n  if tokens == 0 {\n    print(\"You win!\")\n\n    break\n  }\n\n  print(\"I'll remove \\(4 - n) tokens.\")\n\n  tokens -= 4 - n\n\n  if tokens == 0 {\n    print(\"I win!\")\n  }\n\n  print()\n}\n", "target": "import java.util.Scanner;\n\npublic class NimGame {\n\n    public static void main(String[] args) {\n        runGame(12);\n    }\n    \n    private static void runGame(int tokens) {\n        System.out.printf(\"Nim game.%n%n\");\n\n        Scanner in = new Scanner(System.in);;\n        \n        do {            \n            boolean humanInputOk = false;\n            int humanTokens = 0;\n            while ( ! humanInputOk ) {\n                System.out.printf(\"Human takes how many tokens?  \");\n                String input = in.next();\n                try {\n                    humanTokens = Integer.parseInt(input);\n                    if ( humanTokens >= 1 && humanTokens <= 3 ) {\n                        humanInputOk = true;\n                    }\n                    else {\n                        System.out.printf(\"Try a number between 1 and 3.%n\");\n                    }\n                }\n                catch (NumberFormatException e) {\n                    System.out.printf(\"Invalid input.  Try a number between 1 and 3.%n\");\n                }\n            }\n            \n            tokens -= humanTokens;\n            \n            System.out.printf(\"You take %d token%s.%n%d token%s remaining.%n%n\", humanTokens, humanTokens > 1 ? \"s\" : \"\", tokens, tokens != 1 ? \"s\" : \"\");\n            if ( tokens == 0 ) {\n                System.out.printf(\"You win!!.%n%n\");\n                break;\n            }\n            int computerTokens = 4 - humanTokens;\n            tokens -= computerTokens;\n            \n            System.out.printf(\"Computer takes %d token%s.%n%d token%s remaining.%n%n\", computerTokens, computerTokens != 1 ? \"s\" : \"\", tokens, tokens != 1 ? \"s\" : \"\");\n            if ( tokens == 0 ) {\n                System.out.printf(\"Computer wins!!.%n%n\");\n            }\n\n        } while (tokens > 0);\n\n        in.close();\n    }\n\n}\n"}
{"id": 93665, "name": "Nim game", "source": "Translate Swift to Python: var tokens = 12\n\nwhile tokens != 0 {\n  print(\"Tokens remaining: \\(tokens)\\nPlease enter a number between 1 and 3: \", terminator: \"\")\n\n  guard let input = readLine(), let n = Int(input), n >= 1 && n <= 3 else {\n    fatalError(\"Invalid input\")\n  }\n\n  tokens -= n\n\n  if tokens == 0 {\n    print(\"You win!\")\n\n    break\n  }\n\n  print(\"I'll remove \\(4 - n) tokens.\")\n\n  tokens -= 4 - n\n\n  if tokens == 0 {\n    print(\"I win!\")\n  }\n\n  print()\n}\n", "target": "print(\"Py Nim\\n\")\n\ndef getTokens(curTokens):\n\tglobal tokens\n\t\n\tprint(\"How many tokens would you like to take? \", end='')\n\ttake = int(input())\n\t\n\tif (take < 1 or take > 3):\n\t\tprint(\"Number must be between 1 and 3.\\n\")\n\t\tgetTokens(curTokens)\n\t\treturn\n\t\n\ttokens = curTokens - take\n\tprint(f'You take {take} tokens.')\n\tprint(f'{tokens} tokens remaining.\\n')\n\ndef compTurn(curTokens):\n\tglobal tokens\n\t\n\ttake = curTokens % 4\n\ttokens = curTokens - take\n\tprint (f'Computer takes {take} tokens.')\n\tprint (f'{tokens} tokens remaining.\\n')\n\t\n\ntokens = 12\nwhile (tokens > 0):\n\tgetTokens(tokens)\n\tcompTurn(tokens)\n\nprint(\"Computer wins!\")\n"}
{"id": 93666, "name": "Nim game", "source": "Translate Swift to Python: var tokens = 12\n\nwhile tokens != 0 {\n  print(\"Tokens remaining: \\(tokens)\\nPlease enter a number between 1 and 3: \", terminator: \"\")\n\n  guard let input = readLine(), let n = Int(input), n >= 1 && n <= 3 else {\n    fatalError(\"Invalid input\")\n  }\n\n  tokens -= n\n\n  if tokens == 0 {\n    print(\"You win!\")\n\n    break\n  }\n\n  print(\"I'll remove \\(4 - n) tokens.\")\n\n  tokens -= 4 - n\n\n  if tokens == 0 {\n    print(\"I win!\")\n  }\n\n  print()\n}\n", "target": "print(\"Py Nim\\n\")\n\ndef getTokens(curTokens):\n\tglobal tokens\n\t\n\tprint(\"How many tokens would you like to take? \", end='')\n\ttake = int(input())\n\t\n\tif (take < 1 or take > 3):\n\t\tprint(\"Number must be between 1 and 3.\\n\")\n\t\tgetTokens(curTokens)\n\t\treturn\n\t\n\ttokens = curTokens - take\n\tprint(f'You take {take} tokens.')\n\tprint(f'{tokens} tokens remaining.\\n')\n\ndef compTurn(curTokens):\n\tglobal tokens\n\t\n\ttake = curTokens % 4\n\ttokens = curTokens - take\n\tprint (f'Computer takes {take} tokens.')\n\tprint (f'{tokens} tokens remaining.\\n')\n\t\n\ntokens = 12\nwhile (tokens > 0):\n\tgetTokens(tokens)\n\tcompTurn(tokens)\n\nprint(\"Computer wins!\")\n"}
{"id": 94096, "name": "Sum and product of an array", "source": "Translate Swift to C#: let a = [1, 2, 3, 4, 5]\nprintln(a.reduce(0, +)) \nprintln(a.reduce(1, *)) \n\nprintln(reduce(a, 0, +)) \nprintln(reduce(a, 1, *)) \n", "target": "int sum = 0, prod = 1;\nint[] arg = { 1, 2, 3, 4, 5 };\nforeach (int value in arg) {\n  sum += value;\n  prod *= value;\n}\n"}
{"id": 94098, "name": "Sum and product of an array", "source": "Translate Swift to Java: let a = [1, 2, 3, 4, 5]\nprintln(a.reduce(0, +)) \nprintln(a.reduce(1, *)) \n\nprintln(reduce(a, 0, +)) \nprintln(reduce(a, 1, *)) \n", "target": "public class SumProd\n{\n public static void main(final String[] args)\n {\n  int sum = 0;\n  int prod = 1;\n  int[] arg = {1,2,3,4,5};\n  for (int i : arg)\n  {\n   sum += i;\n   prod *= i;\n  }\n }\n}\n"}
{"id": 94099, "name": "Sum and product of an array", "source": "Translate Swift to Python: let a = [1, 2, 3, 4, 5]\nprintln(a.reduce(0, +)) \nprintln(a.reduce(1, *)) \n\nprintln(reduce(a, 0, +)) \nprintln(reduce(a, 1, *)) \n", "target": "numbers = [1, 2, 3]\ntotal = sum(numbers)\n\nproduct = 1\nfor i in numbers:\n    product *= i\n"}
{"id": 94628, "name": "100 doors", "source": "Translate Swift to C#: \nenum DoorState : String {\n    case Opened = \"Opened\"\n    case Closed = \"Closed\"\n}\n\n\nvar doorsStateList = [DoorState](count: 100, repeatedValue: DoorState.Closed)\n\n\nfor i in 1...100 {\n    \n    map(stride(from: i - 1, to: 100, by: i)) {\n        doorsStateList[$0] = doorsStateList[$0] == .Opened ? .Closed : .Opened\n    }\n}\n\n\nfor (index, item) in enumerate(doorsStateList) {\n    println(\"Door \\(index+1) is \\(item.rawValue)\")\n}\n", "target": "namespace ConsoleApplication1\n{\n    using System;\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool[] doors = new bool[100];\n\n            \n            for (int d = 0; d < 100; d++) doors[d] = false;\n\n            \n            for (int p = 0; p < 100; p++)\n            {\n                \n                for (int d = 0; d < 100; d++)\n                {\n                    if ((d + 1) % (p + 1) == 0)\n                    {\n                        doors[d] = !doors[d];\n                    }\n                }\n            }\n\n            \n            Console.WriteLine(\"Passes Completed!!!  Here are the results: \\r\\n\");\n            for (int d = 0; d < 100; d++)\n            {\n                if (doors[d])\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Open\", d + 1));\n                }\n                else\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Closed\", d + 1));\n                }\n            }\n            Console.ReadKey(true);\n        }\n    }\n}\n"}
{"id": 94629, "name": "100 doors", "source": "Translate Swift to C#: \nenum DoorState : String {\n    case Opened = \"Opened\"\n    case Closed = \"Closed\"\n}\n\n\nvar doorsStateList = [DoorState](count: 100, repeatedValue: DoorState.Closed)\n\n\nfor i in 1...100 {\n    \n    map(stride(from: i - 1, to: 100, by: i)) {\n        doorsStateList[$0] = doorsStateList[$0] == .Opened ? .Closed : .Opened\n    }\n}\n\n\nfor (index, item) in enumerate(doorsStateList) {\n    println(\"Door \\(index+1) is \\(item.rawValue)\")\n}\n", "target": "namespace ConsoleApplication1\n{\n    using System;\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool[] doors = new bool[100];\n\n            \n            for (int d = 0; d < 100; d++) doors[d] = false;\n\n            \n            for (int p = 0; p < 100; p++)\n            {\n                \n                for (int d = 0; d < 100; d++)\n                {\n                    if ((d + 1) % (p + 1) == 0)\n                    {\n                        doors[d] = !doors[d];\n                    }\n                }\n            }\n\n            \n            Console.WriteLine(\"Passes Completed!!!  Here are the results: \\r\\n\");\n            for (int d = 0; d < 100; d++)\n            {\n                if (doors[d])\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Open\", d + 1));\n                }\n                else\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Closed\", d + 1));\n                }\n            }\n            Console.ReadKey(true);\n        }\n    }\n}\n"}
{"id": 94632, "name": "100 doors", "source": "Translate Swift to Java: \nenum DoorState : String {\n    case Opened = \"Opened\"\n    case Closed = \"Closed\"\n}\n\n\nvar doorsStateList = [DoorState](count: 100, repeatedValue: DoorState.Closed)\n\n\nfor i in 1...100 {\n    \n    map(stride(from: i - 1, to: 100, by: i)) {\n        doorsStateList[$0] = doorsStateList[$0] == .Opened ? .Closed : .Opened\n    }\n}\n\n\nfor (index, item) in enumerate(doorsStateList) {\n    println(\"Door \\(index+1) is \\(item.rawValue)\")\n}\n", "target": "module OneHundredDoors\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Boolean[] doors = new Boolean[100];\n        for (Int pass : 0 ..< 100)\n            {\n            for (Int door = pass; door < 100; door += 1+pass)\n                {\n                doors[door] = !doors[door];\n                }\n            }\n\n        console.print($\"open doors: {doors.mapIndexed((d, i) -> d\u00a0? i+1\u00a0: 0).filter(i -> i > 0)}\");\n        }\n    }\n"}
{"id": 94633, "name": "100 doors", "source": "Translate Swift to Java: \nenum DoorState : String {\n    case Opened = \"Opened\"\n    case Closed = \"Closed\"\n}\n\n\nvar doorsStateList = [DoorState](count: 100, repeatedValue: DoorState.Closed)\n\n\nfor i in 1...100 {\n    \n    map(stride(from: i - 1, to: 100, by: i)) {\n        doorsStateList[$0] = doorsStateList[$0] == .Opened ? .Closed : .Opened\n    }\n}\n\n\nfor (index, item) in enumerate(doorsStateList) {\n    println(\"Door \\(index+1) is \\(item.rawValue)\")\n}\n", "target": "module OneHundredDoors\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Boolean[] doors = new Boolean[100];\n        for (Int pass : 0 ..< 100)\n            {\n            for (Int door = pass; door < 100; door += 1+pass)\n                {\n                doors[door] = !doors[door];\n                }\n            }\n\n        console.print($\"open doors: {doors.mapIndexed((d, i) -> d\u00a0? i+1\u00a0: 0).filter(i -> i > 0)}\");\n        }\n    }\n"}
{"id": 94634, "name": "100 doors", "source": "Translate Swift to Python: \nenum DoorState : String {\n    case Opened = \"Opened\"\n    case Closed = \"Closed\"\n}\n\n\nvar doorsStateList = [DoorState](count: 100, repeatedValue: DoorState.Closed)\n\n\nfor i in 1...100 {\n    \n    map(stride(from: i - 1, to: 100, by: i)) {\n        doorsStateList[$0] = doorsStateList[$0] == .Opened ? .Closed : .Opened\n    }\n}\n\n\nfor (index, item) in enumerate(doorsStateList) {\n    println(\"Door \\(index+1) is \\(item.rawValue)\")\n}\n", "target": "var doors = falses(100)\n\nfor a in 1..100: for b in a..a..100:\n    doors[b] = not doors[b]\n\nfor a in 1..100:\n    print \"Door $a is ${(doors[a])\u00a0? 'open.': 'closed.'}\"\n"}
{"id": 94635, "name": "100 doors", "source": "Translate Swift to Python: \nenum DoorState : String {\n    case Opened = \"Opened\"\n    case Closed = \"Closed\"\n}\n\n\nvar doorsStateList = [DoorState](count: 100, repeatedValue: DoorState.Closed)\n\n\nfor i in 1...100 {\n    \n    map(stride(from: i - 1, to: 100, by: i)) {\n        doorsStateList[$0] = doorsStateList[$0] == .Opened ? .Closed : .Opened\n    }\n}\n\n\nfor (index, item) in enumerate(doorsStateList) {\n    println(\"Door \\(index+1) is \\(item.rawValue)\")\n}\n", "target": "var doors = falses(100)\n\nfor a in 1..100: for b in a..a..100:\n    doors[b] = not doors[b]\n\nfor a in 1..100:\n    print \"Door $a is ${(doors[a])\u00a0? 'open.': 'closed.'}\"\n"}
{"id": 95102, "name": "Anti-primes", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func countDivisors() -> Int {\n    var workingN = self\n    var count = 1\n\n    while workingN & 1 == 0 {\n      workingN >>= 1\n\n      count += 1\n    }\n\n    var d = Self(3)\n\n    while d * d <= workingN {\n      var (quo, rem) = workingN.quotientAndRemainder(dividingBy: d)\n\n      if rem == 0 {\n        var dc = 0\n\n        while rem == 0 {\n          dc += count\n          workingN = quo\n\n          (quo, rem) = workingN.quotientAndRemainder(dividingBy: d)\n        }\n\n        count += dc\n      }\n\n      d += 2\n    }\n\n    return workingN != 1 ? count * 2 : count\n  }\n}\n\nvar antiPrimes = [Int]()\nvar maxDivs = 0\n\nfor n in 1... {\n  guard antiPrimes.count < 20 else {\n    break\n  }\n\n  let divs = n.countDivisors()\n\n  if maxDivs < divs {\n    maxDivs = divs\n    antiPrimes.append(n)\n  }\n}\n\nprint(\"First 20 anti-primes are \\(Array(antiPrimes))\")\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\t\t\t\t\t\npublic static class Program\n{\n    public static void Main() =>\n        Console.WriteLine(string.Join(\" \", FindAntiPrimes().Take(20)));\n\t\n    static IEnumerable<int> FindAntiPrimes() {\n        int max = 0;\n        for (int i = 1; ; i++) {\n            int divisors = CountDivisors(i);\n            if (divisors > max) {\n                max = divisors;\n                yield return i;\n            }\n        }\n\t\n        int CountDivisors(int n) => Enumerable.Range(1, n / 2).Count(i => n % i == 0) + 1;\n    }\n}\n"}
{"id": 95103, "name": "Anti-primes", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func countDivisors() -> Int {\n    var workingN = self\n    var count = 1\n\n    while workingN & 1 == 0 {\n      workingN >>= 1\n\n      count += 1\n    }\n\n    var d = Self(3)\n\n    while d * d <= workingN {\n      var (quo, rem) = workingN.quotientAndRemainder(dividingBy: d)\n\n      if rem == 0 {\n        var dc = 0\n\n        while rem == 0 {\n          dc += count\n          workingN = quo\n\n          (quo, rem) = workingN.quotientAndRemainder(dividingBy: d)\n        }\n\n        count += dc\n      }\n\n      d += 2\n    }\n\n    return workingN != 1 ? count * 2 : count\n  }\n}\n\nvar antiPrimes = [Int]()\nvar maxDivs = 0\n\nfor n in 1... {\n  guard antiPrimes.count < 20 else {\n    break\n  }\n\n  let divs = n.countDivisors()\n\n  if maxDivs < divs {\n    maxDivs = divs\n    antiPrimes.append(n)\n  }\n}\n\nprint(\"First 20 anti-primes are \\(Array(antiPrimes))\")\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\t\t\t\t\t\npublic static class Program\n{\n    public static void Main() =>\n        Console.WriteLine(string.Join(\" \", FindAntiPrimes().Take(20)));\n\t\n    static IEnumerable<int> FindAntiPrimes() {\n        int max = 0;\n        for (int i = 1; ; i++) {\n            int divisors = CountDivisors(i);\n            if (divisors > max) {\n                max = divisors;\n                yield return i;\n            }\n        }\n\t\n        int CountDivisors(int n) => Enumerable.Range(1, n / 2).Count(i => n % i == 0) + 1;\n    }\n}\n"}
{"id": 95106, "name": "Anti-primes", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func countDivisors() -> Int {\n    var workingN = self\n    var count = 1\n\n    while workingN & 1 == 0 {\n      workingN >>= 1\n\n      count += 1\n    }\n\n    var d = Self(3)\n\n    while d * d <= workingN {\n      var (quo, rem) = workingN.quotientAndRemainder(dividingBy: d)\n\n      if rem == 0 {\n        var dc = 0\n\n        while rem == 0 {\n          dc += count\n          workingN = quo\n\n          (quo, rem) = workingN.quotientAndRemainder(dividingBy: d)\n        }\n\n        count += dc\n      }\n\n      d += 2\n    }\n\n    return workingN != 1 ? count * 2 : count\n  }\n}\n\nvar antiPrimes = [Int]()\nvar maxDivs = 0\n\nfor n in 1... {\n  guard antiPrimes.count < 20 else {\n    break\n  }\n\n  let divs = n.countDivisors()\n\n  if maxDivs < divs {\n    maxDivs = divs\n    antiPrimes.append(n)\n  }\n}\n\nprint(\"First 20 anti-primes are \\(Array(antiPrimes))\")\n", "target": "public class Antiprime {\n\n    static int countDivisors(int n) {\n        if (n < 2) return 1;\n        int count = 2; \n        for (int i = 2; i <= n/2; ++i) {\n            if (n%i == 0) ++count;\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        int maxDiv = 0, count = 0;\n        System.out.println(\"The first 20 anti-primes are:\");\n        for (int n = 1; count < 20; ++n) {\n            int d = countDivisors(n);\n            if (d > maxDiv) {\n                System.out.printf(\"%d \", n);\n                maxDiv = d;\n                count++;\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 95107, "name": "Anti-primes", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func countDivisors() -> Int {\n    var workingN = self\n    var count = 1\n\n    while workingN & 1 == 0 {\n      workingN >>= 1\n\n      count += 1\n    }\n\n    var d = Self(3)\n\n    while d * d <= workingN {\n      var (quo, rem) = workingN.quotientAndRemainder(dividingBy: d)\n\n      if rem == 0 {\n        var dc = 0\n\n        while rem == 0 {\n          dc += count\n          workingN = quo\n\n          (quo, rem) = workingN.quotientAndRemainder(dividingBy: d)\n        }\n\n        count += dc\n      }\n\n      d += 2\n    }\n\n    return workingN != 1 ? count * 2 : count\n  }\n}\n\nvar antiPrimes = [Int]()\nvar maxDivs = 0\n\nfor n in 1... {\n  guard antiPrimes.count < 20 else {\n    break\n  }\n\n  let divs = n.countDivisors()\n\n  if maxDivs < divs {\n    maxDivs = divs\n    antiPrimes.append(n)\n  }\n}\n\nprint(\"First 20 anti-primes are \\(Array(antiPrimes))\")\n", "target": "public class Antiprime {\n\n    static int countDivisors(int n) {\n        if (n < 2) return 1;\n        int count = 2; \n        for (int i = 2; i <= n/2; ++i) {\n            if (n%i == 0) ++count;\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        int maxDiv = 0, count = 0;\n        System.out.println(\"The first 20 anti-primes are:\");\n        for (int n = 1; count < 20; ++n) {\n            int d = countDivisors(n);\n            if (d > maxDiv) {\n                System.out.printf(\"%d \", n);\n                maxDiv = d;\n                count++;\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 95108, "name": "Anti-primes", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func countDivisors() -> Int {\n    var workingN = self\n    var count = 1\n\n    while workingN & 1 == 0 {\n      workingN >>= 1\n\n      count += 1\n    }\n\n    var d = Self(3)\n\n    while d * d <= workingN {\n      var (quo, rem) = workingN.quotientAndRemainder(dividingBy: d)\n\n      if rem == 0 {\n        var dc = 0\n\n        while rem == 0 {\n          dc += count\n          workingN = quo\n\n          (quo, rem) = workingN.quotientAndRemainder(dividingBy: d)\n        }\n\n        count += dc\n      }\n\n      d += 2\n    }\n\n    return workingN != 1 ? count * 2 : count\n  }\n}\n\nvar antiPrimes = [Int]()\nvar maxDivs = 0\n\nfor n in 1... {\n  guard antiPrimes.count < 20 else {\n    break\n  }\n\n  let divs = n.countDivisors()\n\n  if maxDivs < divs {\n    maxDivs = divs\n    antiPrimes.append(n)\n  }\n}\n\nprint(\"First 20 anti-primes are \\(Array(antiPrimes))\")\n", "target": "from itertools import chain, count, cycle, islice, accumulate\n \ndef factors(n):\n    def prime_powers(n):\n        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):\n            if c*c > n: break\n            if n%c: continue\n            d,p = (), c\n            while not n%c:\n                n,p,d = n//c, p*c, d+(p,)\n            yield d\n        if n > 1: yield n,\n \n    r = [1]\n    for e in prime_powers(n):\n        r += [a*b for a in r for b in e]\n    return r\n    \ndef antiprimes():\n    mx = 0\n    yield 1\n    for c in count(2,2):\n        if c >= 58: break\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln\n    for c in count(60,30):\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln  \n\nif __name__ == '__main__':\n    print(*islice(antiprimes(), 40)))\n"}
{"id": 95109, "name": "Anti-primes", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func countDivisors() -> Int {\n    var workingN = self\n    var count = 1\n\n    while workingN & 1 == 0 {\n      workingN >>= 1\n\n      count += 1\n    }\n\n    var d = Self(3)\n\n    while d * d <= workingN {\n      var (quo, rem) = workingN.quotientAndRemainder(dividingBy: d)\n\n      if rem == 0 {\n        var dc = 0\n\n        while rem == 0 {\n          dc += count\n          workingN = quo\n\n          (quo, rem) = workingN.quotientAndRemainder(dividingBy: d)\n        }\n\n        count += dc\n      }\n\n      d += 2\n    }\n\n    return workingN != 1 ? count * 2 : count\n  }\n}\n\nvar antiPrimes = [Int]()\nvar maxDivs = 0\n\nfor n in 1... {\n  guard antiPrimes.count < 20 else {\n    break\n  }\n\n  let divs = n.countDivisors()\n\n  if maxDivs < divs {\n    maxDivs = divs\n    antiPrimes.append(n)\n  }\n}\n\nprint(\"First 20 anti-primes are \\(Array(antiPrimes))\")\n", "target": "from itertools import chain, count, cycle, islice, accumulate\n \ndef factors(n):\n    def prime_powers(n):\n        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):\n            if c*c > n: break\n            if n%c: continue\n            d,p = (), c\n            while not n%c:\n                n,p,d = n//c, p*c, d+(p,)\n            yield d\n        if n > 1: yield n,\n \n    r = [1]\n    for e in prime_powers(n):\n        r += [a*b for a in r for b in e]\n    return r\n    \ndef antiprimes():\n    mx = 0\n    yield 1\n    for c in count(2,2):\n        if c >= 58: break\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln\n    for c in count(60,30):\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln  \n\nif __name__ == '__main__':\n    print(*islice(antiprimes(), 40)))\n"}
{"id": 95723, "name": "Knuth shuffle", "source": "Translate Swift to C#: extension BidirectionalCollection where Self: MutableCollection\n{\n\tmutating func shuffleInPlace()\n\t{\n\t\tvar index = self.index(before: self.endIndex)\n\t\twhile index != self.startIndex\n\t\t{\n\t\t\t\n\t\t\tlet randomInt = Int.random(in: 0 ... self.distance(from: startIndex, to: index))\n\t\t\tlet randomIndex = self.index(startIndex, offsetBy: randomInt)\n\t\t\tself.swapAt(index, randomIndex)\n\t\t\tindex = self.index(before: index)\n\t\t}\n\t}\n}\n\nvar a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\na.shuffleInPlace()\nprint(a)\n", "target": "public static void KnuthShuffle<T>(T[] array)\n{\n    System.Random random = new System.Random();\n    for (int i = 0; i < array.Length; i++)\n    {\n        int j = random.Next(i, array.Length); \n        T temp = array[i]; array[i] = array[j]; array[j] = temp;\n    }\n}\n"}
{"id": 95725, "name": "Knuth shuffle", "source": "Translate Swift to Java: extension BidirectionalCollection where Self: MutableCollection\n{\n\tmutating func shuffleInPlace()\n\t{\n\t\tvar index = self.index(before: self.endIndex)\n\t\twhile index != self.startIndex\n\t\t{\n\t\t\t\n\t\t\tlet randomInt = Int.random(in: 0 ... self.distance(from: startIndex, to: index))\n\t\t\tlet randomIndex = self.index(startIndex, offsetBy: randomInt)\n\t\t\tself.swapAt(index, randomIndex)\n\t\t\tindex = self.index(before: index)\n\t\t}\n\t}\n}\n\nvar a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\na.shuffleInPlace()\nprint(a)\n", "target": "import java.util.Random;\n\npublic static final Random gen = new Random();\n\n\npublic static void shuffle (int[] array) {\n    int n = array.length;\n    while (n > 1) {\n        int k = gen.nextInt(n--); \n        int temp = array[n];\n        array[n] = array[k];\n        array[k] = temp;\n    }\n}\n\npublic static void shuffle (Object[] array) {\n    int n = array.length;\n    while (n > 1) {\n        int k = gen.nextInt(n--); \n        Object temp = array[n];\n        array[n] = array[k];\n        array[k] = temp;\n    }\n}\n"}
{"id": 95726, "name": "Knuth shuffle", "source": "Translate Swift to Python: extension BidirectionalCollection where Self: MutableCollection\n{\n\tmutating func shuffleInPlace()\n\t{\n\t\tvar index = self.index(before: self.endIndex)\n\t\twhile index != self.startIndex\n\t\t{\n\t\t\t\n\t\t\tlet randomInt = Int.random(in: 0 ... self.distance(from: startIndex, to: index))\n\t\t\tlet randomIndex = self.index(startIndex, offsetBy: randomInt)\n\t\t\tself.swapAt(index, randomIndex)\n\t\t\tindex = self.index(before: index)\n\t\t}\n\t}\n}\n\nvar a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\na.shuffleInPlace()\nprint(a)\n", "target": "from random import randrange\n\ndef knuth_shuffle(x):\n    for i in range(len(x)-1, 0, -1):\n        j = randrange(i + 1)\n        x[i], x[j] = x[j], x[i]\n\nx = list(range(10))\nknuth_shuffle(x)\nprint(\"shuffled:\", x)\n"}
{"id": 95916, "name": "Synchronous concurrency", "source": "Translate Swift to C#: \n\n\n\nimport Foundation\n\nclass Reader: NSObject {\n    let inputPath = \"~/Desktop/input.txt\".stringByExpandingTildeInPath\n    var gotNumberOfLines = false\n    \n    override init() {\n        super.init()\n        NSNotificationCenter.defaultCenter().addObserver(self, selector: \"linesPrinted:\",\n            name: \"LinesPrinted\", object: nil)\n    }\n    \n    deinit {\n        NSNotificationCenter.defaultCenter().removeObserver(self)\n    }\n    \n    \n    func linesPrinted(not:NSNotification) {\n        println(not.object!)\n        self.gotNumberOfLines = true\n        exit(0)\n    }\n\n    func readFile() {\n        var err:NSError?\n        let fileString = NSString(contentsOfFile: self.inputPath,\n            encoding: NSUTF8StringEncoding, error: &err)\n        \n        if let lines = fileString?.componentsSeparatedByString(\"\\n\") {\n            for line in lines {\n                NSNotificationCenter.defaultCenter().postNotificationName(\"Line\", object: line)\n            }\n            NSNotificationCenter.defaultCenter().postNotificationName(\"LineNumberRequest\", object: nil)\n            \n            while !self.gotNumberOfLines {\n                sleep(1 as UInt32)\n            }\n        }\n    }\n}\n", "target": "using System;\nusing System.Threading.Tasks;\nusing System.Collections.Concurrent;\nusing System.IO;\n\nnamespace SynchronousConcurrency\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            BlockingCollection<string> toWriterTask = new BlockingCollection<string>();\n            BlockingCollection<int> fromWriterTask = new BlockingCollection<int>();\n            Task writer = Task.Factory.StartNew(() => ConsoleWriter(toWriterTask, fromWriterTask));\n            Task reader = Task.Factory.StartNew(() => FileReader(fromWriterTask, toWriterTask));\n            Task.WaitAll(writer, reader);\n        }\n        static void ConsoleWriter(BlockingCollection<string> input, BlockingCollection<int> output)\n        {\n            int nLines = 0;\n            string line;\n            while ((line = input.Take()) != null)\n            {\n                Console.WriteLine(line);\n                ++nLines;\n            }\n            output.Add(nLines);\n        }\n        static void FileReader(BlockingCollection<int> input, BlockingCollection<string> output)\n        {\n            StreamReader file = new StreamReader(\"input.txt\"); \n            string line;\n            while ((line = file.ReadLine()) != null)\n            {\n                output.Add(line);\n\n            }\n            output.Add(null); \n            Console.WriteLine(\"line count: \" + input.Take());\n        }\n    }\n}\n"}
{"id": 95918, "name": "Synchronous concurrency", "source": "Translate Swift to Java: \n\n\n\nimport Foundation\n\nclass Reader: NSObject {\n    let inputPath = \"~/Desktop/input.txt\".stringByExpandingTildeInPath\n    var gotNumberOfLines = false\n    \n    override init() {\n        super.init()\n        NSNotificationCenter.defaultCenter().addObserver(self, selector: \"linesPrinted:\",\n            name: \"LinesPrinted\", object: nil)\n    }\n    \n    deinit {\n        NSNotificationCenter.defaultCenter().removeObserver(self)\n    }\n    \n    \n    func linesPrinted(not:NSNotification) {\n        println(not.object!)\n        self.gotNumberOfLines = true\n        exit(0)\n    }\n\n    func readFile() {\n        var err:NSError?\n        let fileString = NSString(contentsOfFile: self.inputPath,\n            encoding: NSUTF8StringEncoding, error: &err)\n        \n        if let lines = fileString?.componentsSeparatedByString(\"\\n\") {\n            for line in lines {\n                NSNotificationCenter.defaultCenter().postNotificationName(\"Line\", object: line)\n            }\n            NSNotificationCenter.defaultCenter().postNotificationName(\"LineNumberRequest\", object: nil)\n            \n            while !self.gotNumberOfLines {\n                sleep(1 as UInt32)\n            }\n        }\n    }\n}\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nclass SynchronousConcurrency\n{\n  public static void main(String[] args) throws Exception\n  {\n    final AtomicLong lineCount = new AtomicLong(0);\n    final BlockingQueue<String> queue = new LinkedBlockingQueue<String>();\n    final String EOF = new String();\n    \n    final Thread writerThread = new Thread(new Runnable() {\n        public void run()\n        {\n          long linesWrote = 0;\n          while (true)\n          {\n            try\n            {\n              String line = queue.take();\n              \n              if (line == EOF)\n                break;\n              System.out.println(line);\n              linesWrote++;\n            }\n            catch (InterruptedException ie)\n            {  }\n          }\n          lineCount.set(linesWrote);\n        }\n      }\n    );\n    writerThread.start();\n    \n    \n    BufferedReader br = new BufferedReader(new FileReader(\"input.txt\"));\n    String line;\n    while ((line = br.readLine()) != null)\n      queue.put(line);\n    br.close();\n    queue.put(EOF);\n    writerThread.join();\n    \n    System.out.println(\"Line count: \" + lineCount.get());\n    return;\n  }\n}\n"}
{"id": 95919, "name": "Synchronous concurrency", "source": "Translate Swift to Python: \n\n\n\nimport Foundation\n\nclass Reader: NSObject {\n    let inputPath = \"~/Desktop/input.txt\".stringByExpandingTildeInPath\n    var gotNumberOfLines = false\n    \n    override init() {\n        super.init()\n        NSNotificationCenter.defaultCenter().addObserver(self, selector: \"linesPrinted:\",\n            name: \"LinesPrinted\", object: nil)\n    }\n    \n    deinit {\n        NSNotificationCenter.defaultCenter().removeObserver(self)\n    }\n    \n    \n    func linesPrinted(not:NSNotification) {\n        println(not.object!)\n        self.gotNumberOfLines = true\n        exit(0)\n    }\n\n    func readFile() {\n        var err:NSError?\n        let fileString = NSString(contentsOfFile: self.inputPath,\n            encoding: NSUTF8StringEncoding, error: &err)\n        \n        if let lines = fileString?.componentsSeparatedByString(\"\\n\") {\n            for line in lines {\n                NSNotificationCenter.defaultCenter().postNotificationName(\"Line\", object: line)\n            }\n            NSNotificationCenter.defaultCenter().postNotificationName(\"LineNumberRequest\", object: nil)\n            \n            while !self.gotNumberOfLines {\n                sleep(1 as UInt32)\n            }\n        }\n    }\n}\n", "target": "import sys\nfrom Queue import Queue\nfrom threading import Thread\n\nlines = Queue(1)\ncount = Queue(1)\n\ndef read(file):\n    try:\n        for line in file:\n            lines.put(line)\n    finally:\n        lines.put(None)\n    print count.get()\n\ndef write(file):\n    n = 0\n    while 1:\n        line = lines.get()\n        if line is None:\n            break\n        file.write(line)\n        n += 1\n    count.put(n)\n\nreader = Thread(target=read, args=(open('input.txt'),))\nwriter = Thread(target=write, args=(sys.stdout,))\nreader.start()\nwriter.start()\nreader.join()\nwriter.join()\n"}
{"id": 96497, "name": "Map range", "source": "Translate Swift to C#: import Foundation\n\nfunc mapRanges(_ r1: ClosedRange<Double>, _ r2: ClosedRange<Double>, to: Double) -> Double {\n  let num = (to - r1.lowerBound) * (r2.upperBound - r2.lowerBound)\n  let denom = r1.upperBound - r1.lowerBound\n  \n  return r2.lowerBound + num / denom\n}\n\nfor i in 0...10 {\n  print(String(format: \"%2d maps to %5.2f\", i, mapRanges(0...10, -1...0, to: Double(i))))\n}\n", "target": "using System;\nusing System.Linq;\n\npublic class MapRange\n{\n    public static void Main() {\n        foreach (int i in Enumerable.Range(0, 11))\n            Console.WriteLine($\"{i} maps to {Map(0, 10, -1, 0, i)}\");\n    }\n    \n    static double Map(double a1, double a2, double b1, double b2, double s) => b1 + (s - a1) * (b2 - b1) / (a2 - a1);\n}\n"}
{"id": 96498, "name": "Map range", "source": "Translate Swift to C#: import Foundation\n\nfunc mapRanges(_ r1: ClosedRange<Double>, _ r2: ClosedRange<Double>, to: Double) -> Double {\n  let num = (to - r1.lowerBound) * (r2.upperBound - r2.lowerBound)\n  let denom = r1.upperBound - r1.lowerBound\n  \n  return r2.lowerBound + num / denom\n}\n\nfor i in 0...10 {\n  print(String(format: \"%2d maps to %5.2f\", i, mapRanges(0...10, -1...0, to: Double(i))))\n}\n", "target": "using System;\nusing System.Linq;\n\npublic class MapRange\n{\n    public static void Main() {\n        foreach (int i in Enumerable.Range(0, 11))\n            Console.WriteLine($\"{i} maps to {Map(0, 10, -1, 0, i)}\");\n    }\n    \n    static double Map(double a1, double a2, double b1, double b2, double s) => b1 + (s - a1) * (b2 - b1) / (a2 - a1);\n}\n"}
{"id": 96501, "name": "Map range", "source": "Translate Swift to Java: import Foundation\n\nfunc mapRanges(_ r1: ClosedRange<Double>, _ r2: ClosedRange<Double>, to: Double) -> Double {\n  let num = (to - r1.lowerBound) * (r2.upperBound - r2.lowerBound)\n  let denom = r1.upperBound - r1.lowerBound\n  \n  return r2.lowerBound + num / denom\n}\n\nfor i in 0...10 {\n  print(String(format: \"%2d maps to %5.2f\", i, mapRanges(0...10, -1...0, to: Double(i))))\n}\n", "target": "public class Range {\n\tpublic static void main(String[] args){\n\t\tfor(float s = 0;s <= 10; s++){\n\t\t\tSystem.out.println(s + \" in [0, 10] maps to \"+ \n\t\t\t\t\tmapRange(0, 10, -1, 0, s)+\" in [-1, 0].\");\n\t\t}\n\t}\n\t\n\tpublic static double mapRange(double a1, double a2, double b1, double b2, double s){\n\t\treturn b1 + ((s - a1)*(b2 - b1))/(a2 - a1);\n\t}\n}\n"}
{"id": 96502, "name": "Map range", "source": "Translate Swift to Java: import Foundation\n\nfunc mapRanges(_ r1: ClosedRange<Double>, _ r2: ClosedRange<Double>, to: Double) -> Double {\n  let num = (to - r1.lowerBound) * (r2.upperBound - r2.lowerBound)\n  let denom = r1.upperBound - r1.lowerBound\n  \n  return r2.lowerBound + num / denom\n}\n\nfor i in 0...10 {\n  print(String(format: \"%2d maps to %5.2f\", i, mapRanges(0...10, -1...0, to: Double(i))))\n}\n", "target": "public class Range {\n\tpublic static void main(String[] args){\n\t\tfor(float s = 0;s <= 10; s++){\n\t\t\tSystem.out.println(s + \" in [0, 10] maps to \"+ \n\t\t\t\t\tmapRange(0, 10, -1, 0, s)+\" in [-1, 0].\");\n\t\t}\n\t}\n\t\n\tpublic static double mapRange(double a1, double a2, double b1, double b2, double s){\n\t\treturn b1 + ((s - a1)*(b2 - b1))/(a2 - a1);\n\t}\n}\n"}
{"id": 96503, "name": "Map range", "source": "Translate Swift to Python: import Foundation\n\nfunc mapRanges(_ r1: ClosedRange<Double>, _ r2: ClosedRange<Double>, to: Double) -> Double {\n  let num = (to - r1.lowerBound) * (r2.upperBound - r2.lowerBound)\n  let denom = r1.upperBound - r1.lowerBound\n  \n  return r2.lowerBound + num / denom\n}\n\nfor i in 0...10 {\n  print(String(format: \"%2d maps to %5.2f\", i, mapRanges(0...10, -1...0, to: Double(i))))\n}\n", "target": ">>> def maprange( a, b, s):\n\t(a1, a2), (b1, b2) = a, b\n\treturn  b1 + ((s - a1) * (b2 - b1) / (a2 - a1))\n\n>>> for s in range(11):\n\tprint(\"%2g maps to %g\" % (s, maprange( (0, 10), (-1, 0), s)))\n\n\t\n 0 maps to -1\n 1 maps to -0.9\n 2 maps to -0.8\n 3 maps to -0.7\n 4 maps to -0.6\n 5 maps to -0.5\n 6 maps to -0.4\n 7 maps to -0.3\n 8 maps to -0.2\n 9 maps to -0.1\n10 maps to 0\n"}
{"id": 96504, "name": "Map range", "source": "Translate Swift to Python: import Foundation\n\nfunc mapRanges(_ r1: ClosedRange<Double>, _ r2: ClosedRange<Double>, to: Double) -> Double {\n  let num = (to - r1.lowerBound) * (r2.upperBound - r2.lowerBound)\n  let denom = r1.upperBound - r1.lowerBound\n  \n  return r2.lowerBound + num / denom\n}\n\nfor i in 0...10 {\n  print(String(format: \"%2d maps to %5.2f\", i, mapRanges(0...10, -1...0, to: Double(i))))\n}\n", "target": ">>> def maprange( a, b, s):\n\t(a1, a2), (b1, b2) = a, b\n\treturn  b1 + ((s - a1) * (b2 - b1) / (a2 - a1))\n\n>>> for s in range(11):\n\tprint(\"%2g maps to %g\" % (s, maprange( (0, 10), (-1, 0), s)))\n\n\t\n 0 maps to -1\n 1 maps to -0.9\n 2 maps to -0.8\n 3 maps to -0.7\n 4 maps to -0.6\n 5 maps to -0.5\n 6 maps to -0.4\n 7 maps to -0.3\n 8 maps to -0.2\n 9 maps to -0.1\n10 maps to 0\n"}
{"id": 96738, "name": "Function composition", "source": "Translate Swift to C#: func compose<A,B,C>(f: (B) -> C, g: (A) -> B) -> (A) -> C {\n  return { f(g($0)) }\n}\n\nlet sin_asin = compose(sin, asin)\nprintln(sin_asin(0.5))\n", "target": "using System;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Func<int, int> outfunc = Composer<int, int, int>.Compose(functA, functB);\n        Console.WriteLine(outfunc(5)); \n    }\n    static int functA(int i) { return i * 10; }\n    static int functB(int i) { return i + 5; }\n    class Composer<A, B, C>\n    {\n        public static Func<C, A> Compose(Func<B, A> a, Func<C, B> b)\n        {\n            return delegate(C i) { return a(b(i)); };\n        }\n    }\n}\n"}
{"id": 96740, "name": "Function composition", "source": "Translate Swift to Java: func compose<A,B,C>(f: (B) -> C, g: (A) -> B) -> (A) -> C {\n  return { f(g($0)) }\n}\n\nlet sin_asin = compose(sin, asin)\nprintln(sin_asin(0.5))\n", "target": "public class Compose {\n\n    \n    \n    public interface Fun<A,B> {\n        B call(A x);\n    }\n\n    public static <A,B,C> Fun<A,C> compose(final Fun<B,C> f, final Fun<A,B> g) {\n        return new Fun<A,C>() {\n            public C call(A x) {\n                return f.call(g.call(x));\n            }\n        };\n    }\n\n    public static void main(String[] args) {\n        Fun<Double,Double> sin = new Fun<Double,Double>() {\n            public Double call(Double x) {\n                return Math.sin(x);\n            }\n        };\n        Fun<Double,Double> asin = new Fun<Double,Double>() {\n            public Double call(Double x) {\n                return Math.asin(x);\n            }\n        };\n\n        Fun<Double,Double> sin_asin = compose(sin, asin);\n\n        System.out.println(sin_asin.call(0.5)); \n    }\n}\n"}
{"id": 96741, "name": "Function composition", "source": "Translate Swift to Python: func compose<A,B,C>(f: (B) -> C, g: (A) -> B) -> (A) -> C {\n  return { f(g($0)) }\n}\n\nlet sin_asin = compose(sin, asin)\nprintln(sin_asin(0.5))\n", "target": "compose = lambda f, g: lambda x: f( g(x) )\n"}
{"id": 97012, "name": "HTTP", "source": "Translate Swift to C#: import Foundation\n\nlet request = NSURLRequest(URL: NSURL(string: \"http:\n\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in\n    \n    \n    if (data != nil) {\n        let string = NSString(data: data!, encoding: NSUTF8StringEncoding)\n        println(string)\n    }\n}\n\nCFRunLoopRun() \n", "target": "using System;\nusing System.Text;\nusing System.Net;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        WebClient wc = new WebClient();\n        string content = wc.DownloadString(\"http:\n        Console.WriteLine(content);\n    }\n}\n"}
{"id": 97014, "name": "HTTP", "source": "Translate Swift to Java: import Foundation\n\nlet request = NSURLRequest(URL: NSURL(string: \"http:\n\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in\n    \n    \n    if (data != nil) {\n        let string = NSString(data: data!, encoding: NSUTF8StringEncoding)\n        println(string)\n    }\n}\n\nCFRunLoopRun() \n", "target": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.Charset;\n\npublic class Main {\n    public static void main(String[] args) {\n        var request = HttpRequest.newBuilder(URI.create(\"https:\n                .GET()\n                .build();\n\n        HttpClient.newHttpClient()\n                .sendAsync(request, HttpResponse.BodyHandlers.ofString(Charset.defaultCharset()))\n                .thenApply(HttpResponse::body)\n                .thenAccept(System.out::println)\n                .join();\n    }\n}\n"}
{"id": 97015, "name": "HTTP", "source": "Translate Swift to Python: import Foundation\n\nlet request = NSURLRequest(URL: NSURL(string: \"http:\n\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in\n    \n    \n    if (data != nil) {\n        let string = NSString(data: data!, encoding: NSUTF8StringEncoding)\n        println(string)\n    }\n}\n\nCFRunLoopRun() \n", "target": "import urllib.request\nprint(urllib.request.urlopen(\"http://rosettacode.org\").read())\n"}
{"id": 97303, "name": "Smith numbers", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public var isSmith: Bool {\n    guard self > 3 else {\n      return false\n    }\n\n    let primeFactors = primeDecomposition()\n\n    guard primeFactors.count != 1 else {\n      return false\n    }\n\n    return primeFactors.map({ $0.sumDigits() }).reduce(0, +) == sumDigits()\n  }\n\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n\n  @inlinable\n  public func sumDigits() -> Self {\n    return String(self).lazy.map({ Self(Int(String($0))!) }).reduce(0, +)\n  }\n}\n\nlet smiths = (0..<10_000).filter({ $0.isSmith })\n\nprint(\"Num Smith numbers below 10,000: \\(smiths.count)\")\nprint(\"First 10 smith numbers: \\(Array(smiths.prefix(10)))\")\nprint(\"Last 10 smith numbers below 10,000: \\(Array(smiths.suffix(10)))\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SmithNumbers {\n    class Program {\n        static int SumDigits(int n) {\n            int sum = 0;\n            while (n > 0) {\n                n = Math.DivRem(n, 10, out int rem);\n                sum += rem;\n            }\n            return sum;\n        }\n\n        static List<int> PrimeFactors(int n) {\n            List<int> result = new List<int>();\n\n            for (int i = 2; n % i == 0; n /= i) {\n                result.Add(i);\n            }\n\n            for (int i = 3; i * i < n; i += 2) {\n                while (n % i == 0) {\n                    result.Add(i);\n                    n /= i;\n                }\n            }\n\n            if (n != 1) {\n                result.Add(n);\n            }\n\n            return result;\n        }\n\n        static void Main(string[] args) {\n            const int SIZE = 8;\n            int count = 0;\n            for (int n = 1; n < 10_000; n++) {\n                var factors = PrimeFactors(n);\n                if (factors.Count > 1) {\n                    int sum = SumDigits(n);\n                    foreach (var f in factors) {\n                        sum -= SumDigits(f);\n                    }\n                    if (sum == 0) {\n                        Console.Write(\"{0,5}\", n);\n                        if (count == SIZE - 1) {\n                            Console.WriteLine();\n                        }\n                        count = (count + 1) % SIZE;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 97304, "name": "Smith numbers", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public var isSmith: Bool {\n    guard self > 3 else {\n      return false\n    }\n\n    let primeFactors = primeDecomposition()\n\n    guard primeFactors.count != 1 else {\n      return false\n    }\n\n    return primeFactors.map({ $0.sumDigits() }).reduce(0, +) == sumDigits()\n  }\n\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n\n  @inlinable\n  public func sumDigits() -> Self {\n    return String(self).lazy.map({ Self(Int(String($0))!) }).reduce(0, +)\n  }\n}\n\nlet smiths = (0..<10_000).filter({ $0.isSmith })\n\nprint(\"Num Smith numbers below 10,000: \\(smiths.count)\")\nprint(\"First 10 smith numbers: \\(Array(smiths.prefix(10)))\")\nprint(\"Last 10 smith numbers below 10,000: \\(Array(smiths.suffix(10)))\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SmithNumbers {\n    class Program {\n        static int SumDigits(int n) {\n            int sum = 0;\n            while (n > 0) {\n                n = Math.DivRem(n, 10, out int rem);\n                sum += rem;\n            }\n            return sum;\n        }\n\n        static List<int> PrimeFactors(int n) {\n            List<int> result = new List<int>();\n\n            for (int i = 2; n % i == 0; n /= i) {\n                result.Add(i);\n            }\n\n            for (int i = 3; i * i < n; i += 2) {\n                while (n % i == 0) {\n                    result.Add(i);\n                    n /= i;\n                }\n            }\n\n            if (n != 1) {\n                result.Add(n);\n            }\n\n            return result;\n        }\n\n        static void Main(string[] args) {\n            const int SIZE = 8;\n            int count = 0;\n            for (int n = 1; n < 10_000; n++) {\n                var factors = PrimeFactors(n);\n                if (factors.Count > 1) {\n                    int sum = SumDigits(n);\n                    foreach (var f in factors) {\n                        sum -= SumDigits(f);\n                    }\n                    if (sum == 0) {\n                        Console.Write(\"{0,5}\", n);\n                        if (count == SIZE - 1) {\n                            Console.WriteLine();\n                        }\n                        count = (count + 1) % SIZE;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 97307, "name": "Smith numbers", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public var isSmith: Bool {\n    guard self > 3 else {\n      return false\n    }\n\n    let primeFactors = primeDecomposition()\n\n    guard primeFactors.count != 1 else {\n      return false\n    }\n\n    return primeFactors.map({ $0.sumDigits() }).reduce(0, +) == sumDigits()\n  }\n\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n\n  @inlinable\n  public func sumDigits() -> Self {\n    return String(self).lazy.map({ Self(Int(String($0))!) }).reduce(0, +)\n  }\n}\n\nlet smiths = (0..<10_000).filter({ $0.isSmith })\n\nprint(\"Num Smith numbers below 10,000: \\(smiths.count)\")\nprint(\"First 10 smith numbers: \\(Array(smiths.prefix(10)))\")\nprint(\"Last 10 smith numbers below 10,000: \\(Array(smiths.suffix(10)))\")\n", "target": "import java.util.*;\n\npublic class SmithNumbers {\n\n    public static void main(String[] args) {\n        for (int n = 1; n < 10_000; n++) {\n            List<Integer> factors = primeFactors(n);\n            if (factors.size() > 1) {\n                int sum = sumDigits(n);\n                for (int f : factors)\n                    sum -= sumDigits(f);\n                if (sum == 0)\n                    System.out.println(n);\n            }\n        }\n    }\n\n    static List<Integer> primeFactors(int n) {\n        List<Integer> result = new ArrayList<>();\n\n        for (int i = 2; n % i == 0; n /= i)\n            result.add(i);\n\n        for (int i = 3; i * i <= n; i += 2) {\n            while (n % i == 0) {\n                result.add(i);\n                n /= i;\n            }\n        }\n\n        if (n != 1)\n            result.add(n);\n\n        return result;\n    }\n\n    static int sumDigits(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += (n % 10);\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"id": 97308, "name": "Smith numbers", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public var isSmith: Bool {\n    guard self > 3 else {\n      return false\n    }\n\n    let primeFactors = primeDecomposition()\n\n    guard primeFactors.count != 1 else {\n      return false\n    }\n\n    return primeFactors.map({ $0.sumDigits() }).reduce(0, +) == sumDigits()\n  }\n\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n\n  @inlinable\n  public func sumDigits() -> Self {\n    return String(self).lazy.map({ Self(Int(String($0))!) }).reduce(0, +)\n  }\n}\n\nlet smiths = (0..<10_000).filter({ $0.isSmith })\n\nprint(\"Num Smith numbers below 10,000: \\(smiths.count)\")\nprint(\"First 10 smith numbers: \\(Array(smiths.prefix(10)))\")\nprint(\"Last 10 smith numbers below 10,000: \\(Array(smiths.suffix(10)))\")\n", "target": "import java.util.*;\n\npublic class SmithNumbers {\n\n    public static void main(String[] args) {\n        for (int n = 1; n < 10_000; n++) {\n            List<Integer> factors = primeFactors(n);\n            if (factors.size() > 1) {\n                int sum = sumDigits(n);\n                for (int f : factors)\n                    sum -= sumDigits(f);\n                if (sum == 0)\n                    System.out.println(n);\n            }\n        }\n    }\n\n    static List<Integer> primeFactors(int n) {\n        List<Integer> result = new ArrayList<>();\n\n        for (int i = 2; n % i == 0; n /= i)\n            result.add(i);\n\n        for (int i = 3; i * i <= n; i += 2) {\n            while (n % i == 0) {\n                result.add(i);\n                n /= i;\n            }\n        }\n\n        if (n != 1)\n            result.add(n);\n\n        return result;\n    }\n\n    static int sumDigits(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += (n % 10);\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"id": 97309, "name": "Smith numbers", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public var isSmith: Bool {\n    guard self > 3 else {\n      return false\n    }\n\n    let primeFactors = primeDecomposition()\n\n    guard primeFactors.count != 1 else {\n      return false\n    }\n\n    return primeFactors.map({ $0.sumDigits() }).reduce(0, +) == sumDigits()\n  }\n\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n\n  @inlinable\n  public func sumDigits() -> Self {\n    return String(self).lazy.map({ Self(Int(String($0))!) }).reduce(0, +)\n  }\n}\n\nlet smiths = (0..<10_000).filter({ $0.isSmith })\n\nprint(\"Num Smith numbers below 10,000: \\(smiths.count)\")\nprint(\"First 10 smith numbers: \\(Array(smiths.prefix(10)))\")\nprint(\"Last 10 smith numbers below 10,000: \\(Array(smiths.suffix(10)))\")\n", "target": "from sys import stdout\n\n\ndef factors(n):\n    rt = []\n    f = 2\n    if n == 1:\n        rt.append(1);\n    else:\n        while 1:\n            if 0 == ( n % f ):\n                rt.append(f);\n                n //= f\n                if n == 1:\n                    return rt\n            else:\n                f += 1\n    return rt\n\n\ndef sum_digits(n):\n    sum = 0\n    while n > 0:\n        m = n % 10\n        sum += m\n        n -= m\n        n //= 10\n\n    return sum\n\n\ndef add_all_digits(lst):\n    sum = 0\n    for i in range (len(lst)):\n        sum += sum_digits(lst[i])\n\n    return sum\n\n\ndef list_smith_numbers(cnt):\n    for i in range(4, cnt):\n        fac = factors(i)\n        if len(fac) > 1:\n            if sum_digits(i) == add_all_digits(fac):\n                stdout.write(\"{0} \".format(i) )\n\n\nlist_smith_numbers(10_000)\n"}
{"id": 97310, "name": "Smith numbers", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public var isSmith: Bool {\n    guard self > 3 else {\n      return false\n    }\n\n    let primeFactors = primeDecomposition()\n\n    guard primeFactors.count != 1 else {\n      return false\n    }\n\n    return primeFactors.map({ $0.sumDigits() }).reduce(0, +) == sumDigits()\n  }\n\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n\n  @inlinable\n  public func sumDigits() -> Self {\n    return String(self).lazy.map({ Self(Int(String($0))!) }).reduce(0, +)\n  }\n}\n\nlet smiths = (0..<10_000).filter({ $0.isSmith })\n\nprint(\"Num Smith numbers below 10,000: \\(smiths.count)\")\nprint(\"First 10 smith numbers: \\(Array(smiths.prefix(10)))\")\nprint(\"Last 10 smith numbers below 10,000: \\(Array(smiths.suffix(10)))\")\n", "target": "from sys import stdout\n\n\ndef factors(n):\n    rt = []\n    f = 2\n    if n == 1:\n        rt.append(1);\n    else:\n        while 1:\n            if 0 == ( n % f ):\n                rt.append(f);\n                n //= f\n                if n == 1:\n                    return rt\n            else:\n                f += 1\n    return rt\n\n\ndef sum_digits(n):\n    sum = 0\n    while n > 0:\n        m = n % 10\n        sum += m\n        n -= m\n        n //= 10\n\n    return sum\n\n\ndef add_all_digits(lst):\n    sum = 0\n    for i in range (len(lst)):\n        sum += sum_digits(lst[i])\n\n    return sum\n\n\ndef list_smith_numbers(cnt):\n    for i in range(4, cnt):\n        fac = factors(i)\n        if len(fac) > 1:\n            if sum_digits(i) == add_all_digits(fac):\n                stdout.write(\"{0} \".format(i) )\n\n\nlist_smith_numbers(10_000)\n"}
{"id": 98168, "name": "Dutch national flag problem", "source": "Translate Swift to C#: \nfunc partition3<T: Comparable>(_ a: inout [T], mid: T) {\n    var i = 0\n    var j = 0\n    var k = a.count - 1\n    while j <= k {\n        if a[j] < mid {\n            a.swapAt(i, j);\n            i += 1;\n            j += 1;\n        } else if a[j] > mid {\n            a.swapAt(j, k);\n            k -= 1;\n        } else {\n            j += 1;\n        }\n    }\n}\n\nfunc isSorted<T: Comparable>(_ a: [T]) -> Bool {\n    var i = 0\n    let n = a.count\n    while i + 1 < n {\n        if a[i] > a[i + 1] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\nenum Ball : CustomStringConvertible, Comparable {\n  case red\n  case white\n  case blue\n  \n  var description : String {\n    switch self {\n    case .red: return \"red\"\n    case .white: return \"white\"\n    case .blue: return \"blue\"\n    }\n  }\n}\n\nvar balls: [Ball] = [ Ball.red, Ball.white, Ball.blue,\n                      Ball.red, Ball.white, Ball.blue,\n                      Ball.red, Ball.white, Ball.blue]\nballs.shuffle()\nprint(\"\\(balls)\")\nprint(\"Sorted: \\(isSorted(balls))\")\n\npartition3(&balls, mid: Ball.white)\nprint(\"\\(balls)\")\nprint(\"Sorted: \\(isSorted(balls))\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void QuickSort(IComparable[] elements, int left, int right)\n        {\n            int i = left, j = right;\n            IComparable pivot = elements[left + (right - left) / 2];\n\n            while (i <= j)\n            {\n                while (elements[i].CompareTo(pivot) < 0) i++;\n                while (elements[j].CompareTo(pivot) > 0) j--;\n\n                if (i <= j)\n                {\n                    \n                    IComparable tmp = elements[i];\n                    elements[i] = elements[j];\n                    elements[j] = tmp;\n                    i++;\n                    j--;\n                }\n            }\n\n            \n            if (left < j) QuickSort(elements, left, j);\n            if (i < right) QuickSort(elements, i, right);\n        }\n        const int NUMBALLS = 5;\n        static void Main(string[] args)\n        {\n            Func<string[], bool> IsSorted = (ballList) =>\n                {\n                    int state = 0;\n                    for (int i = 0; i < NUMBALLS; i++)\n                    {\n                        if (int.Parse(ballList[i]) < state)\n                            return false;\n                        if (int.Parse(ballList[i]) > state)\n                            state = int.Parse(ballList[i]);\n                    }\n                    return true;\n                };\n            Func<string[], string> PrintOut = (ballList2) =>\n                {\n                    StringBuilder str = new StringBuilder();\n                    for (int i = 0; i < NUMBALLS; i++)\n                        str.Append(int.Parse(ballList2[i]) == 0 ? \"r\" : int.Parse(ballList2[i]) == 1 ? \"w\" : \"b\");\n                    return str.ToString();\n                };\n            bool continueLoop = true;\n            string[] balls = new string[NUMBALLS]; \n            Random numberGenerator = new Random();\n            do \n            {\n                \n                for (int i = 0; i < NUMBALLS; i++)\n                    balls[i] = numberGenerator.Next(3).ToString();\n\n                continueLoop = IsSorted(balls);\n                if (continueLoop)\n                    Console.WriteLine(\"Accidentally still sorted: {0}\", PrintOut(balls));\n            } while (continueLoop);\n            Console.WriteLine(\"Non-sorted: {0}\", PrintOut(balls));\n            QuickSort(balls, 0, NUMBALLS - 1); \n            Console.WriteLine(\"{0}: {1}\", IsSorted(balls) ? \"Sorted\" : \"Sort failed\", PrintOut(balls));\n        }\n    }\n}\n"}
{"id": 98169, "name": "Dutch national flag problem", "source": "Translate Swift to C#: \nfunc partition3<T: Comparable>(_ a: inout [T], mid: T) {\n    var i = 0\n    var j = 0\n    var k = a.count - 1\n    while j <= k {\n        if a[j] < mid {\n            a.swapAt(i, j);\n            i += 1;\n            j += 1;\n        } else if a[j] > mid {\n            a.swapAt(j, k);\n            k -= 1;\n        } else {\n            j += 1;\n        }\n    }\n}\n\nfunc isSorted<T: Comparable>(_ a: [T]) -> Bool {\n    var i = 0\n    let n = a.count\n    while i + 1 < n {\n        if a[i] > a[i + 1] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\nenum Ball : CustomStringConvertible, Comparable {\n  case red\n  case white\n  case blue\n  \n  var description : String {\n    switch self {\n    case .red: return \"red\"\n    case .white: return \"white\"\n    case .blue: return \"blue\"\n    }\n  }\n}\n\nvar balls: [Ball] = [ Ball.red, Ball.white, Ball.blue,\n                      Ball.red, Ball.white, Ball.blue,\n                      Ball.red, Ball.white, Ball.blue]\nballs.shuffle()\nprint(\"\\(balls)\")\nprint(\"Sorted: \\(isSorted(balls))\")\n\npartition3(&balls, mid: Ball.white)\nprint(\"\\(balls)\")\nprint(\"Sorted: \\(isSorted(balls))\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void QuickSort(IComparable[] elements, int left, int right)\n        {\n            int i = left, j = right;\n            IComparable pivot = elements[left + (right - left) / 2];\n\n            while (i <= j)\n            {\n                while (elements[i].CompareTo(pivot) < 0) i++;\n                while (elements[j].CompareTo(pivot) > 0) j--;\n\n                if (i <= j)\n                {\n                    \n                    IComparable tmp = elements[i];\n                    elements[i] = elements[j];\n                    elements[j] = tmp;\n                    i++;\n                    j--;\n                }\n            }\n\n            \n            if (left < j) QuickSort(elements, left, j);\n            if (i < right) QuickSort(elements, i, right);\n        }\n        const int NUMBALLS = 5;\n        static void Main(string[] args)\n        {\n            Func<string[], bool> IsSorted = (ballList) =>\n                {\n                    int state = 0;\n                    for (int i = 0; i < NUMBALLS; i++)\n                    {\n                        if (int.Parse(ballList[i]) < state)\n                            return false;\n                        if (int.Parse(ballList[i]) > state)\n                            state = int.Parse(ballList[i]);\n                    }\n                    return true;\n                };\n            Func<string[], string> PrintOut = (ballList2) =>\n                {\n                    StringBuilder str = new StringBuilder();\n                    for (int i = 0; i < NUMBALLS; i++)\n                        str.Append(int.Parse(ballList2[i]) == 0 ? \"r\" : int.Parse(ballList2[i]) == 1 ? \"w\" : \"b\");\n                    return str.ToString();\n                };\n            bool continueLoop = true;\n            string[] balls = new string[NUMBALLS]; \n            Random numberGenerator = new Random();\n            do \n            {\n                \n                for (int i = 0; i < NUMBALLS; i++)\n                    balls[i] = numberGenerator.Next(3).ToString();\n\n                continueLoop = IsSorted(balls);\n                if (continueLoop)\n                    Console.WriteLine(\"Accidentally still sorted: {0}\", PrintOut(balls));\n            } while (continueLoop);\n            Console.WriteLine(\"Non-sorted: {0}\", PrintOut(balls));\n            QuickSort(balls, 0, NUMBALLS - 1); \n            Console.WriteLine(\"{0}: {1}\", IsSorted(balls) ? \"Sorted\" : \"Sort failed\", PrintOut(balls));\n        }\n    }\n}\n"}
{"id": 98172, "name": "Dutch national flag problem", "source": "Translate Swift to Java: \nfunc partition3<T: Comparable>(_ a: inout [T], mid: T) {\n    var i = 0\n    var j = 0\n    var k = a.count - 1\n    while j <= k {\n        if a[j] < mid {\n            a.swapAt(i, j);\n            i += 1;\n            j += 1;\n        } else if a[j] > mid {\n            a.swapAt(j, k);\n            k -= 1;\n        } else {\n            j += 1;\n        }\n    }\n}\n\nfunc isSorted<T: Comparable>(_ a: [T]) -> Bool {\n    var i = 0\n    let n = a.count\n    while i + 1 < n {\n        if a[i] > a[i + 1] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\nenum Ball : CustomStringConvertible, Comparable {\n  case red\n  case white\n  case blue\n  \n  var description : String {\n    switch self {\n    case .red: return \"red\"\n    case .white: return \"white\"\n    case .blue: return \"blue\"\n    }\n  }\n}\n\nvar balls: [Ball] = [ Ball.red, Ball.white, Ball.blue,\n                      Ball.red, Ball.white, Ball.blue,\n                      Ball.red, Ball.white, Ball.blue]\nballs.shuffle()\nprint(\"\\(balls)\")\nprint(\"Sorted: \\(isSorted(balls))\")\n\npartition3(&balls, mid: Ball.white)\nprint(\"\\(balls)\")\nprint(\"Sorted: \\(isSorted(balls))\")\n", "target": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class DutchNationalFlag {\n    enum DutchColors {\n        RED, WHITE, BLUE\n    }\n\n    public static void main(String[] args){\n        DutchColors[] balls = new DutchColors[12];\n        DutchColors[] values = DutchColors.values();\n        Random rand = new Random();\n\n        for (int i = 0; i < balls.length; i++)\n            balls[i]=values[rand.nextInt(values.length)];\n        System.out.println(\"Before: \" + Arrays.toString(balls));\n\n        Arrays.sort(balls);\n        System.out.println(\"After:  \" + Arrays.toString(balls));\n\n        boolean sorted = true;\n        for (int i = 1; i < balls.length; i++ ){\n            if (balls[i-1].compareTo(balls[i]) > 0){\n                sorted=false;\n                break;\n            }\n        }\n        System.out.println(\"Correctly sorted: \" + sorted);\n    }\n}\n"}
{"id": 98173, "name": "Dutch national flag problem", "source": "Translate Swift to Java: \nfunc partition3<T: Comparable>(_ a: inout [T], mid: T) {\n    var i = 0\n    var j = 0\n    var k = a.count - 1\n    while j <= k {\n        if a[j] < mid {\n            a.swapAt(i, j);\n            i += 1;\n            j += 1;\n        } else if a[j] > mid {\n            a.swapAt(j, k);\n            k -= 1;\n        } else {\n            j += 1;\n        }\n    }\n}\n\nfunc isSorted<T: Comparable>(_ a: [T]) -> Bool {\n    var i = 0\n    let n = a.count\n    while i + 1 < n {\n        if a[i] > a[i + 1] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\nenum Ball : CustomStringConvertible, Comparable {\n  case red\n  case white\n  case blue\n  \n  var description : String {\n    switch self {\n    case .red: return \"red\"\n    case .white: return \"white\"\n    case .blue: return \"blue\"\n    }\n  }\n}\n\nvar balls: [Ball] = [ Ball.red, Ball.white, Ball.blue,\n                      Ball.red, Ball.white, Ball.blue,\n                      Ball.red, Ball.white, Ball.blue]\nballs.shuffle()\nprint(\"\\(balls)\")\nprint(\"Sorted: \\(isSorted(balls))\")\n\npartition3(&balls, mid: Ball.white)\nprint(\"\\(balls)\")\nprint(\"Sorted: \\(isSorted(balls))\")\n", "target": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class DutchNationalFlag {\n    enum DutchColors {\n        RED, WHITE, BLUE\n    }\n\n    public static void main(String[] args){\n        DutchColors[] balls = new DutchColors[12];\n        DutchColors[] values = DutchColors.values();\n        Random rand = new Random();\n\n        for (int i = 0; i < balls.length; i++)\n            balls[i]=values[rand.nextInt(values.length)];\n        System.out.println(\"Before: \" + Arrays.toString(balls));\n\n        Arrays.sort(balls);\n        System.out.println(\"After:  \" + Arrays.toString(balls));\n\n        boolean sorted = true;\n        for (int i = 1; i < balls.length; i++ ){\n            if (balls[i-1].compareTo(balls[i]) > 0){\n                sorted=false;\n                break;\n            }\n        }\n        System.out.println(\"Correctly sorted: \" + sorted);\n    }\n}\n"}
{"id": 98174, "name": "Dutch national flag problem", "source": "Translate Swift to Python: \nfunc partition3<T: Comparable>(_ a: inout [T], mid: T) {\n    var i = 0\n    var j = 0\n    var k = a.count - 1\n    while j <= k {\n        if a[j] < mid {\n            a.swapAt(i, j);\n            i += 1;\n            j += 1;\n        } else if a[j] > mid {\n            a.swapAt(j, k);\n            k -= 1;\n        } else {\n            j += 1;\n        }\n    }\n}\n\nfunc isSorted<T: Comparable>(_ a: [T]) -> Bool {\n    var i = 0\n    let n = a.count\n    while i + 1 < n {\n        if a[i] > a[i + 1] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\nenum Ball : CustomStringConvertible, Comparable {\n  case red\n  case white\n  case blue\n  \n  var description : String {\n    switch self {\n    case .red: return \"red\"\n    case .white: return \"white\"\n    case .blue: return \"blue\"\n    }\n  }\n}\n\nvar balls: [Ball] = [ Ball.red, Ball.white, Ball.blue,\n                      Ball.red, Ball.white, Ball.blue,\n                      Ball.red, Ball.white, Ball.blue]\nballs.shuffle()\nprint(\"\\(balls)\")\nprint(\"Sorted: \\(isSorted(balls))\")\n\npartition3(&balls, mid: Ball.white)\nprint(\"\\(balls)\")\nprint(\"Sorted: \\(isSorted(balls))\")\n", "target": "import random\n\ncolours_in_order = 'Red White Blue'.split()\n\ndef dutch_flag_sort(items, order=colours_in_order):\n    'return sort of items using the given order'\n    reverse_index = dict((x,i) for i,x in enumerate(order))\n    return sorted(items, key=lambda x: reverse_index[x])\n\ndef dutch_flag_check(items, order=colours_in_order):\n    'Return True if each item of items is in the given order'\n    reverse_index = dict((x,i) for i,x in enumerate(order))\n    order_of_items = [reverse_index[item] for item in items]\n    return all(x <= y for x, y in zip(order_of_items, order_of_items[1:]))\n\ndef random_balls(mx=5):\n    'Select from 1 to mx balls of each colour, randomly'\n    balls = sum([[colour] * random.randint(1, mx)\n                 for colour in colours_in_order], [])\n    random.shuffle(balls)\n    return balls\n\ndef main():\n    \n    while True:\n        balls = random_balls()\n        if not dutch_flag_check(balls):\n            break\n    print(\"Original Ball order:\", balls)\n    sorted_balls = dutch_flag_sort(balls)\n    print(\"Sorted Ball Order:\", sorted_balls)\n    assert dutch_flag_check(sorted_balls), 'Whoops. Not sorted!'\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 98175, "name": "Dutch national flag problem", "source": "Translate Swift to Python: \nfunc partition3<T: Comparable>(_ a: inout [T], mid: T) {\n    var i = 0\n    var j = 0\n    var k = a.count - 1\n    while j <= k {\n        if a[j] < mid {\n            a.swapAt(i, j);\n            i += 1;\n            j += 1;\n        } else if a[j] > mid {\n            a.swapAt(j, k);\n            k -= 1;\n        } else {\n            j += 1;\n        }\n    }\n}\n\nfunc isSorted<T: Comparable>(_ a: [T]) -> Bool {\n    var i = 0\n    let n = a.count\n    while i + 1 < n {\n        if a[i] > a[i + 1] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\nenum Ball : CustomStringConvertible, Comparable {\n  case red\n  case white\n  case blue\n  \n  var description : String {\n    switch self {\n    case .red: return \"red\"\n    case .white: return \"white\"\n    case .blue: return \"blue\"\n    }\n  }\n}\n\nvar balls: [Ball] = [ Ball.red, Ball.white, Ball.blue,\n                      Ball.red, Ball.white, Ball.blue,\n                      Ball.red, Ball.white, Ball.blue]\nballs.shuffle()\nprint(\"\\(balls)\")\nprint(\"Sorted: \\(isSorted(balls))\")\n\npartition3(&balls, mid: Ball.white)\nprint(\"\\(balls)\")\nprint(\"Sorted: \\(isSorted(balls))\")\n", "target": "import random\n\ncolours_in_order = 'Red White Blue'.split()\n\ndef dutch_flag_sort(items, order=colours_in_order):\n    'return sort of items using the given order'\n    reverse_index = dict((x,i) for i,x in enumerate(order))\n    return sorted(items, key=lambda x: reverse_index[x])\n\ndef dutch_flag_check(items, order=colours_in_order):\n    'Return True if each item of items is in the given order'\n    reverse_index = dict((x,i) for i,x in enumerate(order))\n    order_of_items = [reverse_index[item] for item in items]\n    return all(x <= y for x, y in zip(order_of_items, order_of_items[1:]))\n\ndef random_balls(mx=5):\n    'Select from 1 to mx balls of each colour, randomly'\n    balls = sum([[colour] * random.randint(1, mx)\n                 for colour in colours_in_order], [])\n    random.shuffle(balls)\n    return balls\n\ndef main():\n    \n    while True:\n        balls = random_balls()\n        if not dutch_flag_check(balls):\n            break\n    print(\"Original Ball order:\", balls)\n    sorted_balls = dutch_flag_sort(balls)\n    print(\"Sorted Ball Order:\", sorted_balls)\n    assert dutch_flag_check(sorted_balls), 'Whoops. Not sorted!'\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 98972, "name": "Catamorphism", "source": "Translate Swift to C#: let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nprint(nums.reduce(0, +))\nprint(nums.reduce(1, *))\nprint(nums.reduce(\"\", { $0 + String($1) }))\n", "target": "var nums = Enumerable.Range(1, 10);\n\nint summation = nums.Aggregate((a, b) => a + b);\n\nint product = nums.Aggregate((a, b) => a * b);\n\nstring concatenation = nums.Aggregate(String.Empty, (a, b) => a.ToString() + b.ToString());\n\nConsole.WriteLine(\"{0} {1} {2}\", summation, product, concatenation);\n"}
{"id": 98973, "name": "Catamorphism", "source": "Translate Swift to C#: let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nprint(nums.reduce(0, +))\nprint(nums.reduce(1, *))\nprint(nums.reduce(\"\", { $0 + String($1) }))\n", "target": "var nums = Enumerable.Range(1, 10);\n\nint summation = nums.Aggregate((a, b) => a + b);\n\nint product = nums.Aggregate((a, b) => a * b);\n\nstring concatenation = nums.Aggregate(String.Empty, (a, b) => a.ToString() + b.ToString());\n\nConsole.WriteLine(\"{0} {1} {2}\", summation, product, concatenation);\n"}
{"id": 98976, "name": "Catamorphism", "source": "Translate Swift to Java: let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nprint(nums.reduce(0, +))\nprint(nums.reduce(1, *))\nprint(nums.reduce(\"\", { $0 + String($1) }))\n", "target": "import java.util.stream.Stream;\n\npublic class ReduceTask {\n\n    public static void main(String[] args) {\n        System.out.println(Stream.of(1, 2, 3, 4, 5).mapToInt(i -> i).sum());\n        System.out.println(Stream.of(1, 2, 3, 4, 5).reduce(1, (a, b) -> a * b));\n    }\n}\n"}
{"id": 98977, "name": "Catamorphism", "source": "Translate Swift to Java: let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nprint(nums.reduce(0, +))\nprint(nums.reduce(1, *))\nprint(nums.reduce(\"\", { $0 + String($1) }))\n", "target": "import java.util.stream.Stream;\n\npublic class ReduceTask {\n\n    public static void main(String[] args) {\n        System.out.println(Stream.of(1, 2, 3, 4, 5).mapToInt(i -> i).sum());\n        System.out.println(Stream.of(1, 2, 3, 4, 5).reduce(1, (a, b) -> a * b));\n    }\n}\n"}
{"id": 98978, "name": "Catamorphism", "source": "Translate Swift to Python: let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nprint(nums.reduce(0, +))\nprint(nums.reduce(1, *))\nprint(nums.reduce(\"\", { $0 + String($1) }))\n", "target": ">>> \n>>> from operator import add\n>>> listoflists = [['the', 'cat'], ['sat', 'on'], ['the', 'mat']]\n>>> help(reduce)\nHelp on built-in function reduce in module __builtin__:\n\nreduce(...)\n    reduce(function, sequence[, initial]) -> value\n    \n    Apply a function of two arguments cumulatively to the items of a sequence,\n    from left to right, so as to reduce the sequence to a single value.\n    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\n    of the sequence in the calculation, and serves as a default when the\n    sequence is empty.\n\n>>> reduce(add, listoflists, [])\n['the', 'cat', 'sat', 'on', 'the', 'mat']\n>>>\n"}
{"id": 98979, "name": "Catamorphism", "source": "Translate Swift to Python: let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nprint(nums.reduce(0, +))\nprint(nums.reduce(1, *))\nprint(nums.reduce(\"\", { $0 + String($1) }))\n", "target": ">>> \n>>> from operator import add\n>>> listoflists = [['the', 'cat'], ['sat', 'on'], ['the', 'mat']]\n>>> help(reduce)\nHelp on built-in function reduce in module __builtin__:\n\nreduce(...)\n    reduce(function, sequence[, initial]) -> value\n    \n    Apply a function of two arguments cumulatively to the items of a sequence,\n    from left to right, so as to reduce the sequence to a single value.\n    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\n    of the sequence in the calculation, and serves as a default when the\n    sequence is empty.\n\n>>> reduce(add, listoflists, [])\n['the', 'cat', 'sat', 'on', 'the', 'mat']\n>>>\n"}
{"id": 99243, "name": "Sleep", "source": "Translate Swift to C#: import Foundation\n\nprintln(\"Enter number of seconds to sleep\")\nlet input = NSFileHandle.fileHandleWithStandardInput()\nvar amount = NSString(data:input.availableData, encoding: NSUTF8StringEncoding)?.intValue\nvar interval = NSTimeInterval(amount!)\nprintln(\"Sleeping...\")\nNSThread.sleepForTimeInterval(interval)\n\nprintln(\"Awake!\")\n", "target": "using System;\nusing System.Threading;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int sleep = Convert.ToInt32(Console.ReadLine());\n        Console.WriteLine(\"Sleeping...\");\n        Thread.Sleep(sleep); \n        Console.WriteLine(\"Awake!\");\n    }\n}\n"}
{"id": 99245, "name": "Sleep", "source": "Translate Swift to Java: import Foundation\n\nprintln(\"Enter number of seconds to sleep\")\nlet input = NSFileHandle.fileHandleWithStandardInput()\nvar amount = NSString(data:input.availableData, encoding: NSUTF8StringEncoding)?.intValue\nvar interval = NSTimeInterval(amount!)\nprintln(\"Sleeping...\")\nNSThread.sleepForTimeInterval(interval)\n\nprintln(\"Awake!\")\n", "target": "import java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Sleep {\n    public static void main(final String[] args) throws InterruptedException {\n        try {\n            int ms = new Scanner(System.in).nextInt(); \n            System.out.println(\"Sleeping...\");\n            Thread.sleep(ms);\n            System.out.println(\"Awake!\");\n        } catch (InputMismatchException inputMismatchException) {\n            System.err.println(\"Exception: \" + inputMismatchException);\n        }\n    }\n}\n"}
{"id": 99246, "name": "Sleep", "source": "Translate Swift to Python: import Foundation\n\nprintln(\"Enter number of seconds to sleep\")\nlet input = NSFileHandle.fileHandleWithStandardInput()\nvar amount = NSString(data:input.availableData, encoding: NSUTF8StringEncoding)?.intValue\nvar interval = NSTimeInterval(amount!)\nprintln(\"Sleeping...\")\nNSThread.sleepForTimeInterval(interval)\n\nprintln(\"Awake!\")\n", "target": "import time\n\nseconds = float(raw_input())\nprint \"Sleeping...\"\ntime.sleep(seconds) \nprint \"Awake!\"\n"}
{"id": 99418, "name": "Polymorphism", "source": "Translate Swift to C#: class RCPoint : Printable {\n  var x: Int\n  var y: Int\n  init(x: Int = 0, y: Int = 0) {\n    self.x = x\n    self.y = y\n  }\n  convenience init(p: RCPoint) {\n    self.init(x:p.x, y:p.y)\n  }\n  var description: String {\n  return \"<RCPoint x: \\(self.x) y: \\(self.y)>\"\n  }\n}\n\nclass RCCircle : RCPoint {\n  var r: Int\n  init(p: RCPoint, r: Int = 0) {\n    self.r = r\n    super.init(x:p.x, y:p.y)\n  }\n  init(x: Int = 0, y: Int = 0, r: Int = 0) {\n    self.r = r\n    super.init(x:x, y:y)\n  }\n  convenience init(c: RCCircle) {\n    self.init(x:c.x, y:c.y, r:c.r)\n  }\n  override var description: String {\n    return \"<RCCircle x: \\(x) y: \\(y) r: \\(r)>\"\n  }\n}\n\nprintln(RCPoint())\nprintln(RCPoint(x:3))\nprintln(RCPoint(x:3, y:4))\nprintln(RCCircle())\nprintln(RCCircle(x:3))\nprintln(RCCircle(x:3, y:4))\nprintln(RCCircle(x:3, y:4, r:7))\nlet p = RCPoint(x:1, y:2)\nprintln(RCCircle(p:p))\nprintln(RCCircle(p:p, r:7))\nprintln(p.x) \np.x = 8\nprintln(p.x) \n", "target": "using System;\nclass Point\n{\n  protected int x, y;\n  public Point() : this(0) {}\n  public Point(int x) : this(x,0) {}\n  public Point(int x, int y) { this.x = x; this.y = y; }\n  public int X { get { return x; } set { x = value; } }\n  public int Y { get { return y; } set { y = value; } }\n  public virtual void print() { System.Console.WriteLine(\"Point\"); }\n}\n\npublic class Circle : Point\n{\n  private int r;\n  public Circle(Point p) : this(p,0) { }\n  public Circle(Point p, int r) : base(p) { this.r = r; }\n  public Circle() : this(0) { }\n  public Circle(int x) : this(x,0) { }\n  public Circle(int x, int y) : this(x,y,0) { }\n  public Circle(int x, int y, int r) : base(x,y) { this.r = r; }\n  public int R { get { return r; } set { r = value; } }\n  public override void print() { System.Console.WriteLine(\"Circle\"); }\n \n  public static void main(String args[])\n  {\n    Point p = new Point();\n    Point c = new Circle();\n    p.print();\n    c.print();\n  }\n}\n"}
{"id": 99420, "name": "Polymorphism", "source": "Translate Swift to Java: class RCPoint : Printable {\n  var x: Int\n  var y: Int\n  init(x: Int = 0, y: Int = 0) {\n    self.x = x\n    self.y = y\n  }\n  convenience init(p: RCPoint) {\n    self.init(x:p.x, y:p.y)\n  }\n  var description: String {\n  return \"<RCPoint x: \\(self.x) y: \\(self.y)>\"\n  }\n}\n\nclass RCCircle : RCPoint {\n  var r: Int\n  init(p: RCPoint, r: Int = 0) {\n    self.r = r\n    super.init(x:p.x, y:p.y)\n  }\n  init(x: Int = 0, y: Int = 0, r: Int = 0) {\n    self.r = r\n    super.init(x:x, y:y)\n  }\n  convenience init(c: RCCircle) {\n    self.init(x:c.x, y:c.y, r:c.r)\n  }\n  override var description: String {\n    return \"<RCCircle x: \\(x) y: \\(y) r: \\(r)>\"\n  }\n}\n\nprintln(RCPoint())\nprintln(RCPoint(x:3))\nprintln(RCPoint(x:3, y:4))\nprintln(RCCircle())\nprintln(RCCircle(x:3))\nprintln(RCCircle(x:3, y:4))\nprintln(RCCircle(x:3, y:4, r:7))\nlet p = RCPoint(x:1, y:2)\nprintln(RCCircle(p:p))\nprintln(RCCircle(p:p, r:7))\nprintln(p.x) \np.x = 8\nprintln(p.x) \n", "target": "class Point {\n   protected int x, y;\n   public Point() { this(0); }\n   public Point(int x) { this(x, 0); }\n   public Point(int x, int y) { this.x = x; this.y = y; }\n   public Point(Point p) { this(p.x, p.y); }\n   public int getX() { return this.x; }\n   public int getY() { return this.y; }\n   public void setX(int x) { this.x = x; }\n   public void setY(int y) { this.y = y; }\n   public void print() { System.out.println(\"Point x: \" + this.x + \" y: \" + this.y); }\n}\n\nclass Circle extends Point {\n   private int r;\n   public Circle(Point p) { this(p, 0); }\n   public Circle(Point p, int r) { super(p); this.r = r; }\n   public Circle() { this(0); }\n   public Circle(int x) { this(x, 0); }\n   public Circle(int x, int y) { this(x, y, 0); }\n   public Circle(int x, int y, int r) { super(x, y); this.r = r; }\n   public Circle(Circle c) { this(c.x, c.y, c.r); }\n   public int getR() { return this.r; }\n   public void setR(int r) { this.r = r; }\n   public void print() { System.out.println(\"Circle x: \" + this.x + \" y: \" + this.y + \" r: \" + this.r); }\n}\n\npublic class test {\n  public static void main(String args[]) {\n    Point p = new Point();\n    Point c = new Circle();\n    p.print();\n    c.print();     \n  }\n}\n"}
{"id": 99421, "name": "Polymorphism", "source": "Translate Swift to Python: class RCPoint : Printable {\n  var x: Int\n  var y: Int\n  init(x: Int = 0, y: Int = 0) {\n    self.x = x\n    self.y = y\n  }\n  convenience init(p: RCPoint) {\n    self.init(x:p.x, y:p.y)\n  }\n  var description: String {\n  return \"<RCPoint x: \\(self.x) y: \\(self.y)>\"\n  }\n}\n\nclass RCCircle : RCPoint {\n  var r: Int\n  init(p: RCPoint, r: Int = 0) {\n    self.r = r\n    super.init(x:p.x, y:p.y)\n  }\n  init(x: Int = 0, y: Int = 0, r: Int = 0) {\n    self.r = r\n    super.init(x:x, y:y)\n  }\n  convenience init(c: RCCircle) {\n    self.init(x:c.x, y:c.y, r:c.r)\n  }\n  override var description: String {\n    return \"<RCCircle x: \\(x) y: \\(y) r: \\(r)>\"\n  }\n}\n\nprintln(RCPoint())\nprintln(RCPoint(x:3))\nprintln(RCPoint(x:3, y:4))\nprintln(RCCircle())\nprintln(RCCircle(x:3))\nprintln(RCCircle(x:3, y:4))\nprintln(RCCircle(x:3, y:4, r:7))\nlet p = RCPoint(x:1, y:2)\nprintln(RCCircle(p:p))\nprintln(RCCircle(p:p, r:7))\nprintln(p.x) \np.x = 8\nprintln(p.x) \n", "target": "class Point(object):\n    def __init__(self, x=0.0, y=0.0):\n        self.x = x\n        self.y = y\n    def __repr__(self):\n        return '<Point 0x%x x: %f y: %f>' % (id(self), self.x, self.y)\n\nclass Circle(object):\n    def __init__(self, center=None, radius=1.0):\n        self.center = center or Point()\n        self.radius = radius\n    def __repr__(self):\n        return '<Circle 0x%x x: %f y: %f radius: %f>' % (\n            id(self), self.center.x, self.center.y, self.radius)\n"}
{"id": 99615, "name": "Semiprime", "source": "Translate Swift to C#: import Foundation\n\nfunc primes(n: Int) -> AnyGenerator<Int> {\n  \n  var (seive, i) = ([Int](0..<n), 1)\n  let lim = Int(sqrt(Double(n)))\n  \n  return anyGenerator {\n    while ++i < n {\n      if seive[i] != 0 {\n        if i <= lim {\n          for notPrime in stride(from: i*i, to: n, by: i) {\n            seive[notPrime] = 0\n          }\n        }\n        return i\n      }\n    }\n    return nil\n  }\n}\n\nfunc isSemiPrime(n: Int) -> Bool {\n  let g = primes(n)\n  while let first = g.next() {\n    if n % first == 0 {\n      if first * first == n {\n        return true\n      } else {\n        while let second = g.next() {\n          if first * second == n { return true }\n        }\n      }\n    }\n  }\n  return false\n}\n", "target": "static void Main(string[] args)\n{\n    \n    for (int i = 0; i < 50; i++)\n    {\n        Console.WriteLine(\"{0}\\t{1} \", i,isSemiPrime(i));\n    }\n    Console.ReadLine();\n}\n\n\nprivate static bool isSemiPrime(int c)\n{\n    int a = 2, b = 0;\n    while (b < 3 && c != 1)\n    {\n        if ((c % a) == 0)\n        {\n            c /= a;\n            b++;\n        }\n        else\n        {\n            a++;\n        };\n    }\n    return b == 2;\n}\n"}
{"id": 99617, "name": "Semiprime", "source": "Translate Swift to Java: import Foundation\n\nfunc primes(n: Int) -> AnyGenerator<Int> {\n  \n  var (seive, i) = ([Int](0..<n), 1)\n  let lim = Int(sqrt(Double(n)))\n  \n  return anyGenerator {\n    while ++i < n {\n      if seive[i] != 0 {\n        if i <= lim {\n          for notPrime in stride(from: i*i, to: n, by: i) {\n            seive[notPrime] = 0\n          }\n        }\n        return i\n      }\n    }\n    return nil\n  }\n}\n\nfunc isSemiPrime(n: Int) -> Bool {\n  let g = primes(n)\n  while let first = g.next() {\n    if n % first == 0 {\n      if first * first == n {\n        return true\n      } else {\n        while let second = g.next() {\n          if first * second == n { return true }\n        }\n      }\n    }\n  }\n  return false\n}\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SemiPrime{\n\tprivate static final BigInteger TWO = BigInteger.valueOf(2);\n\t \n\tpublic static List<BigInteger> primeDecomp(BigInteger a){\n\t    \n\t    if(a.compareTo(TWO) < 0){\n\t        return null; \n\t    }\n\t \n\t    \n\t    List<BigInteger> result = new ArrayList<BigInteger>();\n\t    while(a.and(BigInteger.ONE).equals(BigInteger.ZERO)){\n\t        a = a.shiftRight(1);\n\t        result.add(TWO);\n\t    }\n\t \n\t    \n\t    if(!a.equals(BigInteger.ONE)){\n\t        BigInteger b = BigInteger.valueOf(3);\n\t        while(b.compareTo(a) < 0){\n\t            if(b.isProbablePrime(10)){\n\t                BigInteger[] dr = a.divideAndRemainder(b);\n\t                if(dr[1].equals(BigInteger.ZERO)){\n\t                    result.add(b);\n\t                    a = dr[0];\n\t                }\n\t            }\n\t            b = b.add(TWO);\n\t        }\n\t        result.add(b); \n\t    }\n\t    return result;\n\t}\n\t\n\tpublic static boolean isSemi(BigInteger x){\n\t\tList<BigInteger> decomp = primeDecomp(x);\n\t\treturn decomp != null && decomp.size() == 2;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 2; i <= 100; i++){\n\t\t\tif(isSemi(BigInteger.valueOf(i))){\n\t\t\t\tSystem.out.print(i + \" \");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 1675; i <= 1680; i++){\n\t\t\tif(isSemi(BigInteger.valueOf(i))){\n\t\t\t\tSystem.out.print(i + \" \");\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 99618, "name": "Semiprime", "source": "Translate Swift to Python: import Foundation\n\nfunc primes(n: Int) -> AnyGenerator<Int> {\n  \n  var (seive, i) = ([Int](0..<n), 1)\n  let lim = Int(sqrt(Double(n)))\n  \n  return anyGenerator {\n    while ++i < n {\n      if seive[i] != 0 {\n        if i <= lim {\n          for notPrime in stride(from: i*i, to: n, by: i) {\n            seive[notPrime] = 0\n          }\n        }\n        return i\n      }\n    }\n    return nil\n  }\n}\n\nfunc isSemiPrime(n: Int) -> Bool {\n  let g = primes(n)\n  while let first = g.next() {\n    if n % first == 0 {\n      if first * first == n {\n        return true\n      } else {\n        while let second = g.next() {\n          if first * second == n { return true }\n        }\n      }\n    }\n  }\n  return false\n}\n", "target": "from prime_decomposition import decompose\n\ndef semiprime(n):\n    d = decompose(n)\n    try:\n        return next(d) * next(d) == n\n    except StopIteration:\n        return False\n"}
{"id": 99898, "name": "Generate lower case ASCII alphabet", "source": "Translate Swift to C#: var letters = [Character]()\n\nfor i in 97...122 {\n    let char = Character(UnicodeScalar(i))\n    letters.append(char)\n}\n", "target": "using System;\nusing System.Linq;\n\ninternal class Program\n{\n    private static void Main()\n    {\n        Console.WriteLine(String.Concat(Enumerable.Range('a', 26).Select(c => (char)c)));\n    }\n}\n"}
{"id": 99900, "name": "Generate lower case ASCII alphabet", "source": "Translate Swift to Java: var letters = [Character]()\n\nfor i in 97...122 {\n    let char = Character(UnicodeScalar(i))\n    letters.append(char)\n}\n", "target": "public class LowerAscii {\n\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(26);\n        for (char ch = 'a'; ch <= 'z'; ch++)\n            sb.append(ch);\n        System.out.printf(\"lower ascii: %s, length: %s\", sb, sb.length());\n    }\n}\n"}
{"id": 99901, "name": "Generate lower case ASCII alphabet", "source": "Translate Swift to Python: var letters = [Character]()\n\nfor i in 97...122 {\n    let char = Character(UnicodeScalar(i))\n    letters.append(char)\n}\n", "target": "\nfrom string import ascii_lowercase\n\n\nlower = [chr(i) for i in range(ord('a'), ord('z') + 1)]\n"}
{"id": 100886, "name": "Roman numerals_Decode", "source": "Translate Swift to C#: extension Int {\n    init(romanNumerals: String) {\n        let values = [\n            ( \"M\", 1000),\n            (\"CM\",  900),\n            ( \"D\",  500),\n            (\"CD\",  400),\n            ( \"C\",  100),\n            (\"XC\",   90),\n            ( \"L\",   50),\n            (\"XL\",   40),\n            ( \"X\",   10),\n            (\"IX\",    9),\n            ( \"V\",    5),\n            (\"IV\",    4),\n            ( \"I\",    1),\n        ]\n        \n        self = 0\n        var raw = romanNumerals\n        for (digit, value) in values {\n            while raw.hasPrefix(digit) {\n                self += value\n                raw.removeFirst(digit.count)\n            }\n        }\n    }\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Roman\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            \n            Console.WriteLine(\"{0}: {1}\", \"MCMXC\", Decode(\"MCMXC\"));\n            Console.WriteLine(\"{0}: {1}\", \"MMVIII\", Decode(\"MMVIII\"));\n            Console.WriteLine(\"{0}: {1}\", \"MDCLXVI\", Decode(\"MDCLXVI\"));\n        }\n\n        \n        private static readonly Dictionary<char, int> RomanDictionary = new Dictionary<char, int>\n                                                                            {\n                                                                                {'I', 1},\n                                                                                {'V', 5},\n                                                                                {'X', 10},\n                                                                                {'L', 50},\n                                                                                {'C', 100},\n                                                                                {'D', 500},\n                                                                                {'M', 1000}\n                                                                            };\n\n        private static int Decode(string roman)\n        {\n            \n            roman = roman.ToUpper();\n\n            \n            int total = 0, minus = 0;\n\n            for (int i = 0; i < roman.Length; i++) \n            {\n                \n                int thisNumeral = RomanDictionary[roman[i]] - minus;\n\n                \n                if (i >= roman.Length - 1 ||\n                    thisNumeral + minus >= RomanDictionary[roman[i + 1]])\n                {\n                    total += thisNumeral;\n                    minus = 0;\n                }\n                else\n                {\n                    minus = thisNumeral;\n                }\n            }\n\n            return total; \n        }\n    }\n}\n"}
{"id": 100887, "name": "Roman numerals_Decode", "source": "Translate Swift to C#: extension Int {\n    init(romanNumerals: String) {\n        let values = [\n            ( \"M\", 1000),\n            (\"CM\",  900),\n            ( \"D\",  500),\n            (\"CD\",  400),\n            ( \"C\",  100),\n            (\"XC\",   90),\n            ( \"L\",   50),\n            (\"XL\",   40),\n            ( \"X\",   10),\n            (\"IX\",    9),\n            ( \"V\",    5),\n            (\"IV\",    4),\n            ( \"I\",    1),\n        ]\n        \n        self = 0\n        var raw = romanNumerals\n        for (digit, value) in values {\n            while raw.hasPrefix(digit) {\n                self += value\n                raw.removeFirst(digit.count)\n            }\n        }\n    }\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Roman\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            \n            Console.WriteLine(\"{0}: {1}\", \"MCMXC\", Decode(\"MCMXC\"));\n            Console.WriteLine(\"{0}: {1}\", \"MMVIII\", Decode(\"MMVIII\"));\n            Console.WriteLine(\"{0}: {1}\", \"MDCLXVI\", Decode(\"MDCLXVI\"));\n        }\n\n        \n        private static readonly Dictionary<char, int> RomanDictionary = new Dictionary<char, int>\n                                                                            {\n                                                                                {'I', 1},\n                                                                                {'V', 5},\n                                                                                {'X', 10},\n                                                                                {'L', 50},\n                                                                                {'C', 100},\n                                                                                {'D', 500},\n                                                                                {'M', 1000}\n                                                                            };\n\n        private static int Decode(string roman)\n        {\n            \n            roman = roman.ToUpper();\n\n            \n            int total = 0, minus = 0;\n\n            for (int i = 0; i < roman.Length; i++) \n            {\n                \n                int thisNumeral = RomanDictionary[roman[i]] - minus;\n\n                \n                if (i >= roman.Length - 1 ||\n                    thisNumeral + minus >= RomanDictionary[roman[i + 1]])\n                {\n                    total += thisNumeral;\n                    minus = 0;\n                }\n                else\n                {\n                    minus = thisNumeral;\n                }\n            }\n\n            return total; \n        }\n    }\n}\n"}
{"id": 100890, "name": "Roman numerals_Decode", "source": "Translate Swift to Java: extension Int {\n    init(romanNumerals: String) {\n        let values = [\n            ( \"M\", 1000),\n            (\"CM\",  900),\n            ( \"D\",  500),\n            (\"CD\",  400),\n            ( \"C\",  100),\n            (\"XC\",   90),\n            ( \"L\",   50),\n            (\"XL\",   40),\n            ( \"X\",   10),\n            (\"IX\",    9),\n            ( \"V\",    5),\n            (\"IV\",    4),\n            ( \"I\",    1),\n        ]\n        \n        self = 0\n        var raw = romanNumerals\n        for (digit, value) in values {\n            while raw.hasPrefix(digit) {\n                self += value\n                raw.removeFirst(digit.count)\n            }\n        }\n    }\n}\n", "target": "\ngrammar ParseRN ;\n\noptions {\n\tlanguage = Java;\n}\n@members {\nint rnValue;\nint ONE;\n}\n\nparseRN:\t({rnValue = 0;} rn NEWLINE {System.out.println($rn.text + \" = \" + rnValue);})*\n\t;\n\t\nrn\t:\t(Thousand {rnValue += 1000;})* hundreds? tens? units?;\n\nhundreds:\t{ONE = 0;} (h9 | h5) {if (ONE > 3) System.out.println (\"Too many hundreds\");};\nh9\t:\tHundred {ONE += 1;} (FiveHund {rnValue += 400;}| Thousand {rnValue += 900;}|{rnValue += 100;} (Hundred {rnValue += 100; ONE += 1;})*);\nh5\t:\tFiveHund {rnValue += 500;} (Hundred {rnValue += 100; ONE += 1;})*;\n\ntens\t:\t{ONE = 0;} (t9 | t5) {if (ONE > 3) System.out.println (\"Too many tens\");};\nt9\t:\tTen {ONE += 1;} (Fifty {rnValue += 40;}| Hundred {rnValue += 90;}|{rnValue += 10;} (Ten {rnValue += 10; ONE += 1;})*);\nt5\t:\tFifty {rnValue += 50;} (Ten {rnValue += 10; ONE += 1;})*;\n\t\nunits\t:\t{ONE = 0;} (u9 | u5) {if (ONE > 3) System.out.println (\"Too many ones\");};\nu9\t:\tOne {ONE += 1;} (Five {rnValue += 4;}| Ten {rnValue += 9;}|{rnValue += 1;} (One {rnValue += 1; ONE += 1;})*);\nu5\t:\tFive {rnValue += 5;} (One {rnValue += 1; ONE += 1;})*;\n\t\nOne\t:\t'I';\nFive\t:\t'V';\nTen\t:\t'X';\nFifty\t:\t'L';\nHundred:\t'C';\nFiveHund:\t'D';\nThousand:\t'M' ;\nNEWLINE:\t'\\r'? '\\n' ;\n"}
{"id": 100891, "name": "Roman numerals_Decode", "source": "Translate Swift to Java: extension Int {\n    init(romanNumerals: String) {\n        let values = [\n            ( \"M\", 1000),\n            (\"CM\",  900),\n            ( \"D\",  500),\n            (\"CD\",  400),\n            ( \"C\",  100),\n            (\"XC\",   90),\n            ( \"L\",   50),\n            (\"XL\",   40),\n            ( \"X\",   10),\n            (\"IX\",    9),\n            ( \"V\",    5),\n            (\"IV\",    4),\n            ( \"I\",    1),\n        ]\n        \n        self = 0\n        var raw = romanNumerals\n        for (digit, value) in values {\n            while raw.hasPrefix(digit) {\n                self += value\n                raw.removeFirst(digit.count)\n            }\n        }\n    }\n}\n", "target": "\ngrammar ParseRN ;\n\noptions {\n\tlanguage = Java;\n}\n@members {\nint rnValue;\nint ONE;\n}\n\nparseRN:\t({rnValue = 0;} rn NEWLINE {System.out.println($rn.text + \" = \" + rnValue);})*\n\t;\n\t\nrn\t:\t(Thousand {rnValue += 1000;})* hundreds? tens? units?;\n\nhundreds:\t{ONE = 0;} (h9 | h5) {if (ONE > 3) System.out.println (\"Too many hundreds\");};\nh9\t:\tHundred {ONE += 1;} (FiveHund {rnValue += 400;}| Thousand {rnValue += 900;}|{rnValue += 100;} (Hundred {rnValue += 100; ONE += 1;})*);\nh5\t:\tFiveHund {rnValue += 500;} (Hundred {rnValue += 100; ONE += 1;})*;\n\ntens\t:\t{ONE = 0;} (t9 | t5) {if (ONE > 3) System.out.println (\"Too many tens\");};\nt9\t:\tTen {ONE += 1;} (Fifty {rnValue += 40;}| Hundred {rnValue += 90;}|{rnValue += 10;} (Ten {rnValue += 10; ONE += 1;})*);\nt5\t:\tFifty {rnValue += 50;} (Ten {rnValue += 10; ONE += 1;})*;\n\t\nunits\t:\t{ONE = 0;} (u9 | u5) {if (ONE > 3) System.out.println (\"Too many ones\");};\nu9\t:\tOne {ONE += 1;} (Five {rnValue += 4;}| Ten {rnValue += 9;}|{rnValue += 1;} (One {rnValue += 1; ONE += 1;})*);\nu5\t:\tFive {rnValue += 5;} (One {rnValue += 1; ONE += 1;})*;\n\t\nOne\t:\t'I';\nFive\t:\t'V';\nTen\t:\t'X';\nFifty\t:\t'L';\nHundred:\t'C';\nFiveHund:\t'D';\nThousand:\t'M' ;\nNEWLINE:\t'\\r'? '\\n' ;\n"}
{"id": 100892, "name": "Roman numerals_Decode", "source": "Translate Swift to Python: extension Int {\n    init(romanNumerals: String) {\n        let values = [\n            ( \"M\", 1000),\n            (\"CM\",  900),\n            ( \"D\",  500),\n            (\"CD\",  400),\n            ( \"C\",  100),\n            (\"XC\",   90),\n            ( \"L\",   50),\n            (\"XL\",   40),\n            ( \"X\",   10),\n            (\"IX\",    9),\n            ( \"V\",    5),\n            (\"IV\",    4),\n            ( \"I\",    1),\n        ]\n        \n        self = 0\n        var raw = romanNumerals\n        for (digit, value) in values {\n            while raw.hasPrefix(digit) {\n                self += value\n                raw.removeFirst(digit.count)\n            }\n        }\n    }\n}\n", "target": "_rdecode = dict(zip('MDCLXVI', (1000, 500, 100, 50, 10, 5, 1)))\n\ndef decode( roman ):\n    result = 0\n    for r, r1 in zip(roman, roman[1:]):\n        rd, rd1 = _rdecode[r], _rdecode[r1]\n        result += -rd if rd < rd1 else rd\n    return result + _rdecode[roman[-1]]\n\nif __name__ == '__main__':\n    for r in 'MCMXC MMVIII MDCLXVI'.split():\n        print( r, decode(r) )\n"}
{"id": 100893, "name": "Roman numerals_Decode", "source": "Translate Swift to Python: extension Int {\n    init(romanNumerals: String) {\n        let values = [\n            ( \"M\", 1000),\n            (\"CM\",  900),\n            ( \"D\",  500),\n            (\"CD\",  400),\n            ( \"C\",  100),\n            (\"XC\",   90),\n            ( \"L\",   50),\n            (\"XL\",   40),\n            ( \"X\",   10),\n            (\"IX\",    9),\n            ( \"V\",    5),\n            (\"IV\",    4),\n            ( \"I\",    1),\n        ]\n        \n        self = 0\n        var raw = romanNumerals\n        for (digit, value) in values {\n            while raw.hasPrefix(digit) {\n                self += value\n                raw.removeFirst(digit.count)\n            }\n        }\n    }\n}\n", "target": "_rdecode = dict(zip('MDCLXVI', (1000, 500, 100, 50, 10, 5, 1)))\n\ndef decode( roman ):\n    result = 0\n    for r, r1 in zip(roman, roman[1:]):\n        rd, rd1 = _rdecode[r], _rdecode[r1]\n        result += -rd if rd < rd1 else rd\n    return result + _rdecode[roman[-1]]\n\nif __name__ == '__main__':\n    for r in 'MCMXC MMVIII MDCLXVI'.split():\n        print( r, decode(r) )\n"}
{"id": 101185, "name": "Euler method", "source": "Translate Swift to C#: import Foundation\n\nlet numberFormat = \" %7.3f\"\nlet k = 0.07\nlet initialTemp = 100.0\nlet finalTemp = 20.0\nlet startTime = 0\nlet endTime = 100\n\nfunc ivpEuler(function: (Double, Double) -> Double, initialValue: Double, step: Int) {\n    print(String(format: \" Step %2d: \", step), terminator: \"\")\n    var y = initialValue\n    for t in stride(from: startTime, through: endTime, by: step) {\n        if t % 10 == 0 {\n            print(String(format: numberFormat, y), terminator: \"\")\n        }\n        y += Double(step) * function(Double(t), y)\n    }\n    print()\n}\n\nfunc analytic() {\n    print(\"    Time: \", terminator: \"\")\n    for t in stride(from: startTime, through: endTime, by: 10) {\n        print(String(format: \" %7d\", t), terminator: \"\")\n    }\n    print(\"\\nAnalytic: \", terminator: \"\")\n    for t in stride(from: startTime, through: endTime, by: 10) {\n        let temp = finalTemp + (initialTemp - finalTemp) * exp(-k * Double(t))\n        print(String(format: numberFormat, temp), terminator: \"\")\n    }\n    print()\n}\n\nfunc cooling(t: Double, temp: Double) -> Double {\n    return -k * (temp - finalTemp)\n}\n\nanalytic()\nivpEuler(function: cooling, initialValue: initialTemp, step: 2)\nivpEuler(function: cooling, initialValue: initialTemp, step: 5)\nivpEuler(function: cooling, initialValue: initialTemp, step: 10)\n", "target": "using System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tconst float T0 = 100f;\n\t\tconst float TR = 20f;\n\t\tconst float k = 0.07f;\n\t\treadonly static float[] delta_t = {2.0f,5.0f,10.0f};\n\t\tconst int n = 100;\n\t\t\n\t\tpublic delegate float func(float t);\n\t\tstatic float NewtonCooling(float t)\n\t\t{\n\t\t\treturn -k * (t-TR);\t\t\t\n\t\t}\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfunc f = new func(NewtonCooling); \n\t\t\tfor(int i=0; i<delta_t.Length; i++)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"delta_t = \" + delta_t[i]);\n\t\t\t\tEuler(f,T0,n,delta_t[i]);\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tpublic static void Euler(func f, float y, int n, float h)\n\t\t{\n\t\t\tfor(float x=0; x<=n; x+=h)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"\\t\" + x + \"\\t\" + y);\n\t\t\t\ty += h * f(y);\t\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 101187, "name": "Euler method", "source": "Translate Swift to Java: import Foundation\n\nlet numberFormat = \" %7.3f\"\nlet k = 0.07\nlet initialTemp = 100.0\nlet finalTemp = 20.0\nlet startTime = 0\nlet endTime = 100\n\nfunc ivpEuler(function: (Double, Double) -> Double, initialValue: Double, step: Int) {\n    print(String(format: \" Step %2d: \", step), terminator: \"\")\n    var y = initialValue\n    for t in stride(from: startTime, through: endTime, by: step) {\n        if t % 10 == 0 {\n            print(String(format: numberFormat, y), terminator: \"\")\n        }\n        y += Double(step) * function(Double(t), y)\n    }\n    print()\n}\n\nfunc analytic() {\n    print(\"    Time: \", terminator: \"\")\n    for t in stride(from: startTime, through: endTime, by: 10) {\n        print(String(format: \" %7d\", t), terminator: \"\")\n    }\n    print(\"\\nAnalytic: \", terminator: \"\")\n    for t in stride(from: startTime, through: endTime, by: 10) {\n        let temp = finalTemp + (initialTemp - finalTemp) * exp(-k * Double(t))\n        print(String(format: numberFormat, temp), terminator: \"\")\n    }\n    print()\n}\n\nfunc cooling(t: Double, temp: Double) -> Double {\n    return -k * (temp - finalTemp)\n}\n\nanalytic()\nivpEuler(function: cooling, initialValue: initialTemp, step: 2)\nivpEuler(function: cooling, initialValue: initialTemp, step: 5)\nivpEuler(function: cooling, initialValue: initialTemp, step: 10)\n", "target": "public class Euler {\n  private static void euler (Callable f, double y0, int a, int b, int h) {\n    int t = a;\n    double y = y0;\n    while (t < b) {\n      System.out.println (\"\" + t + \" \" + y);\n      t += h;\n      y += h * f.compute (t, y);\n    }\n    System.out.println (\"DONE\");\n  }\n\n  public static void main (String[] args) {\n    Callable cooling = new Cooling ();\n    int[] steps = {2, 5, 10};\n    for (int stepSize : steps) {\n      System.out.println (\"Step size: \" + stepSize);\n      euler (cooling, 100.0, 0, 100, stepSize);\n    }\n  }\n}\n\n\ninterface Callable {\n  public double compute (int time, double t);\n}\n\n\nclass Cooling implements Callable {\n  public double compute (int time, double t) {\n    return -0.07 * (t - 20);\n  }\n}\n"}
{"id": 101188, "name": "Euler method", "source": "Translate Swift to Python: import Foundation\n\nlet numberFormat = \" %7.3f\"\nlet k = 0.07\nlet initialTemp = 100.0\nlet finalTemp = 20.0\nlet startTime = 0\nlet endTime = 100\n\nfunc ivpEuler(function: (Double, Double) -> Double, initialValue: Double, step: Int) {\n    print(String(format: \" Step %2d: \", step), terminator: \"\")\n    var y = initialValue\n    for t in stride(from: startTime, through: endTime, by: step) {\n        if t % 10 == 0 {\n            print(String(format: numberFormat, y), terminator: \"\")\n        }\n        y += Double(step) * function(Double(t), y)\n    }\n    print()\n}\n\nfunc analytic() {\n    print(\"    Time: \", terminator: \"\")\n    for t in stride(from: startTime, through: endTime, by: 10) {\n        print(String(format: \" %7d\", t), terminator: \"\")\n    }\n    print(\"\\nAnalytic: \", terminator: \"\")\n    for t in stride(from: startTime, through: endTime, by: 10) {\n        let temp = finalTemp + (initialTemp - finalTemp) * exp(-k * Double(t))\n        print(String(format: numberFormat, temp), terminator: \"\")\n    }\n    print()\n}\n\nfunc cooling(t: Double, temp: Double) -> Double {\n    return -k * (temp - finalTemp)\n}\n\nanalytic()\nivpEuler(function: cooling, initialValue: initialTemp, step: 2)\nivpEuler(function: cooling, initialValue: initialTemp, step: 5)\nivpEuler(function: cooling, initialValue: initialTemp, step: 10)\n", "target": "def euler(f,y0,a,b,h):\n\tt,y = a,y0\n\twhile t <= b:\n\t\tprint \"%6.3f %6.3f\" % (t,y)\n\t\tt += h\n\t\ty += h * f(t,y)\n\ndef newtoncooling(time, temp):\n\treturn -0.07 * (temp - 20)\n\neuler(newtoncooling,100,0,100,10)\n"}
{"id": 101652, "name": "Horner's rule for polynomial evaluation", "source": "Translate Swift to C#: func horner(coefs: [Double], x: Double) -> Double {\n  return reduce(lazy(coefs).reverse(), 0) { $0 * x + $1 }\n}\n\nprintln(horner([-19, 7, -4, 6], 3))\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static double Horner(double[] coefficients, double variable)\n    {\n        return coefficients.Reverse().Aggregate(\n                (accumulator, coefficient) => accumulator * variable + coefficient);\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Horner(new[] { -19.0, 7.0, -4.0, 6.0 }, 3.0));\n    }\n}\n"}
{"id": 101653, "name": "Horner's rule for polynomial evaluation", "source": "Translate Swift to C#: func horner(coefs: [Double], x: Double) -> Double {\n  return reduce(lazy(coefs).reverse(), 0) { $0 * x + $1 }\n}\n\nprintln(horner([-19, 7, -4, 6], 3))\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static double Horner(double[] coefficients, double variable)\n    {\n        return coefficients.Reverse().Aggregate(\n                (accumulator, coefficient) => accumulator * variable + coefficient);\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Horner(new[] { -19.0, 7.0, -4.0, 6.0 }, 3.0));\n    }\n}\n"}
{"id": 101656, "name": "Horner's rule for polynomial evaluation", "source": "Translate Swift to Java: func horner(coefs: [Double], x: Double) -> Double {\n  return reduce(lazy(coefs).reverse(), 0) { $0 * x + $1 }\n}\n\nprintln(horner([-19, 7, -4, 6], 3))\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Horner {\n    public static void main(String[] args){\n        List<Double> coeffs = new ArrayList<Double>();\n        coeffs.add(-19.0);\n        coeffs.add(7.0);\n        coeffs.add(-4.0);\n        coeffs.add(6.0);\n        System.out.println(polyEval(coeffs, 3));\n    }\n\n    public static double polyEval(List<Double> coefficients, double x) {\n        Collections.reverse(coefficients);\n        Double accumulator = coefficients.get(0);\n        for (int i = 1; i < coefficients.size(); i++) {\n            accumulator = (accumulator * x) + (Double) coefficients.get(i);\n        }\n        return accumulator;\n    }\n}\n"}
{"id": 101657, "name": "Horner's rule for polynomial evaluation", "source": "Translate Swift to Java: func horner(coefs: [Double], x: Double) -> Double {\n  return reduce(lazy(coefs).reverse(), 0) { $0 * x + $1 }\n}\n\nprintln(horner([-19, 7, -4, 6], 3))\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Horner {\n    public static void main(String[] args){\n        List<Double> coeffs = new ArrayList<Double>();\n        coeffs.add(-19.0);\n        coeffs.add(7.0);\n        coeffs.add(-4.0);\n        coeffs.add(6.0);\n        System.out.println(polyEval(coeffs, 3));\n    }\n\n    public static double polyEval(List<Double> coefficients, double x) {\n        Collections.reverse(coefficients);\n        Double accumulator = coefficients.get(0);\n        for (int i = 1; i < coefficients.size(); i++) {\n            accumulator = (accumulator * x) + (Double) coefficients.get(i);\n        }\n        return accumulator;\n    }\n}\n"}
{"id": 101658, "name": "Horner's rule for polynomial evaluation", "source": "Translate Swift to Python: func horner(coefs: [Double], x: Double) -> Double {\n  return reduce(lazy(coefs).reverse(), 0) { $0 * x + $1 }\n}\n\nprintln(horner([-19, 7, -4, 6], 3))\n", "target": ">>> def horner(coeffs, x):\n\tacc = 0\n\tfor c in reversed(coeffs):\n\t\tacc = acc * x + c\n\treturn acc\n\n>>> horner( (-19, 7, -4, 6), 3)\n128\n"}
{"id": 101659, "name": "Horner's rule for polynomial evaluation", "source": "Translate Swift to Python: func horner(coefs: [Double], x: Double) -> Double {\n  return reduce(lazy(coefs).reverse(), 0) { $0 * x + $1 }\n}\n\nprintln(horner([-19, 7, -4, 6], 3))\n", "target": ">>> def horner(coeffs, x):\n\tacc = 0\n\tfor c in reversed(coeffs):\n\t\tacc = acc * x + c\n\treturn acc\n\n>>> horner( (-19, 7, -4, 6), 3)\n128\n"}
{"id": 101973, "name": "Matrix multiplication", "source": "Translate Swift to C#: @inlinable\npublic func matrixMult<T: Numeric>(_ m1: [[T]], _ m2: [[T]]) -> [[T]] {\n  let n = m1[0].count\n  let m = m1.count\n  let p = m2[0].count\n\n  guard m != 0 else {\n    return []\n  }\n\n  precondition(n == m2.count)\n\n  var ret = Array(repeating: Array(repeating: T.zero, count: p), count: m)\n\n  for i in 0..<m {\n    for j in 0..<p {\n      for k in 0..<n {\n        ret[i][j] += m1[i][k] * m2[k][j]\n      }\n    }\n  }\n\n  return ret\n}\n\n@inlinable\npublic func printMatrix<T>(_ matrix: [[T]]) {\n  guard !matrix.isEmpty else {\n    print()\n\n    return\n  }\n\n  let rows = matrix.count\n  let cols = matrix[0].count\n\n  for i in 0..<rows {\n    for j in 0..<cols {\n      print(matrix[i][j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\nlet m1 = [\n  [6.5, 2, 3],\n  [4.5, 1, 5]\n]\n\nlet m2 = [\n  [10.0, 16, 23, 50],\n  [12, -8, 16, -4],\n  [70, 60, -1, -2]\n]\n\nlet m3 = matrixMult(m1, m2)\n\nprintMatrix(m3)\n", "target": "public class Matrix\n{\n\tint n;\n\tint m;\n\tdouble[,] a;\n\n\tpublic Matrix(int n, int m)\n\t{\n\t\tif (n <= 0 || m <= 0)\n\t\t\tthrow new ArgumentException(\"Matrix dimensions must be positive\");\n\t\tthis.n = n;\n\t\tthis.m = m;\n\t\ta = new double[n, m];\n\t}\n\n\t\n\tpublic double this[int i, int j]\n\t{\n\t\tget { return a[i - 1, j - 1]; }\n\t\tset { a[i - 1, j - 1] = value; }\n\t}\n\n\tpublic int N { get { return n; } }\n\tpublic int M { get { return m; } }\n\n\tpublic static Matrix operator*(Matrix _a, Matrix b)\n\t{\n\t\tint n = _a.N;\n\t\tint m = b.M;\n\t\tint l = _a.M;\n\t\tif (l != b.N)\n\t\t\tthrow new ArgumentException(\"Illegal matrix dimensions for multiplication. _a.M must be equal b.N\");\n\t\tMatrix result = new Matrix(_a.N, b.M);\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tdouble sum = 0.0;\n\t\t\t\tfor (int k = 0; k < l; k++)\n\t\t\t\t\tsum += _a.a[i, k]*b.a[k, j];\n\t\t\t\tresult.a[i, j] = sum;\n\t\t\t}\n\t\treturn result;\n\t}\n}\n"}
{"id": 101975, "name": "Matrix multiplication", "source": "Translate Swift to Java: @inlinable\npublic func matrixMult<T: Numeric>(_ m1: [[T]], _ m2: [[T]]) -> [[T]] {\n  let n = m1[0].count\n  let m = m1.count\n  let p = m2[0].count\n\n  guard m != 0 else {\n    return []\n  }\n\n  precondition(n == m2.count)\n\n  var ret = Array(repeating: Array(repeating: T.zero, count: p), count: m)\n\n  for i in 0..<m {\n    for j in 0..<p {\n      for k in 0..<n {\n        ret[i][j] += m1[i][k] * m2[k][j]\n      }\n    }\n  }\n\n  return ret\n}\n\n@inlinable\npublic func printMatrix<T>(_ matrix: [[T]]) {\n  guard !matrix.isEmpty else {\n    print()\n\n    return\n  }\n\n  let rows = matrix.count\n  let cols = matrix[0].count\n\n  for i in 0..<rows {\n    for j in 0..<cols {\n      print(matrix[i][j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\nlet m1 = [\n  [6.5, 2, 3],\n  [4.5, 1, 5]\n]\n\nlet m2 = [\n  [10.0, 16, 23, 50],\n  [12, -8, 16, -4],\n  [70, 60, -1, -2]\n]\n\nlet m3 = matrixMult(m1, m2)\n\nprintMatrix(m3)\n", "target": "public static double[][] mult(double a[][], double b[][]){\n   if(a.length == 0) return new double[0][0];\n   if(a[0].length != b.length) return null; \n\n   int n = a[0].length;\n   int m = a.length;\n   int p = b[0].length;\n\n   double ans[][] = new double[m][p];\n\n   for(int i = 0;i < m;i++){\n      for(int j = 0;j < p;j++){\n         for(int k = 0;k < n;k++){\n            ans[i][j] += a[i][k] * b[k][j];\n         }\n      }\n   }\n   return ans;\n}\n"}
{"id": 101976, "name": "Matrix multiplication", "source": "Translate Swift to Python: @inlinable\npublic func matrixMult<T: Numeric>(_ m1: [[T]], _ m2: [[T]]) -> [[T]] {\n  let n = m1[0].count\n  let m = m1.count\n  let p = m2[0].count\n\n  guard m != 0 else {\n    return []\n  }\n\n  precondition(n == m2.count)\n\n  var ret = Array(repeating: Array(repeating: T.zero, count: p), count: m)\n\n  for i in 0..<m {\n    for j in 0..<p {\n      for k in 0..<n {\n        ret[i][j] += m1[i][k] * m2[k][j]\n      }\n    }\n  }\n\n  return ret\n}\n\n@inlinable\npublic func printMatrix<T>(_ matrix: [[T]]) {\n  guard !matrix.isEmpty else {\n    print()\n\n    return\n  }\n\n  let rows = matrix.count\n  let cols = matrix[0].count\n\n  for i in 0..<rows {\n    for j in 0..<cols {\n      print(matrix[i][j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\nlet m1 = [\n  [6.5, 2, 3],\n  [4.5, 1, 5]\n]\n\nlet m2 = [\n  [10.0, 16, 23, 50],\n  [12, -8, 16, -4],\n  [70, 60, -1, -2]\n]\n\nlet m3 = matrixMult(m1, m2)\n\nprintMatrix(m3)\n", "target": "a=((1,  1,  1,   1), \n     (2,  4,  8,  16),\n     (3,  9, 27,  81),\n     (4, 16, 64, 256))\n\nb=((  4  , -3  ,  4/3.,  -1/4. ), \n     (-13/3., 19/4., -7/3.,  11/24.),\n     (  3/2., -2.  ,  7/6.,  -1/4. ),\n     ( -1/6.,  1/4., -1/6.,   1/24.))\n\n\n\ndef MatrixMul( mtx_a, mtx_b):\n    tpos_b = zip( *mtx_b)\n    rtn = [[ sum( ea*eb for ea,eb in zip(a,b)) for b in tpos_b] for a in mtx_a]\n    return rtn\n\n\nv = MatrixMul( a, b )\n\nprint 'v = ('\nfor r in v:\n    print '[', \n    for val in r:\n        print '%8.2f '%val, \n    print ']'\nprint ')'\n\n\nu = MatrixMul(b,a)\n\nprint 'u = '\nfor r in u:\n    print '[', \n    for val in r:\n        print '%8.2f '%val, \n    print ']'\nprint ')'\n"}
{"id": 102887, "name": "Mandelbrot set", "source": "Translate Swift to C#: import Foundation\nimport Numerics\nimport QDBMP\n\npublic typealias Color = (red: UInt8, green: UInt8, blue: UInt8)\n\npublic class BitmapDrawer {\n  public let imageHeight: Int\n  public let imageWidth: Int\n\n  var grid: [[Color?]]\n\n  private let bmp: OpaquePointer\n\n  public init(height: Int, width: Int) {\n    self.imageHeight = height\n    self.imageWidth = width\n    self.grid = [[Color?]](repeating: [Color?](repeating: nil, count: height), count: width)\n    self.bmp = BMP_Create(UInt(width), UInt(height), 24)\n\n    checkError()\n  }\n\n  deinit {\n    BMP_Free(bmp)\n  }\n\n  private func checkError() {\n    let err = BMP_GetError()\n\n    guard err == BMP_STATUS(0) else {\n      fatalError(\"\\(err)\")\n    }\n  }\n\n  public func save(to path: String = \"~/Desktop/out.bmp\") {\n    for x in 0..<imageWidth {\n      for y in 0..<imageHeight {\n        guard let color = grid[x][y] else { continue }\n\n        BMP_SetPixelRGB(bmp, UInt(x), UInt(y), color.red, color.green, color.blue)\n        checkError()\n      }\n    }\n\n    (path as NSString).expandingTildeInPath.withCString {s in\n      BMP_WriteFile(bmp, s)\n    }\n  }\n\n  public func setPixel(x: Int, y: Int, to color: Color?) {\n    grid[x][y] = color\n  }\n}\n\nlet imageSize = 10_000\nlet canvas = BitmapDrawer(height: imageSize, width: imageSize)\nlet maxIterations = 256\nlet cxMin = -2.0\nlet cxMax = 1.0\nlet cyMin = -1.5\nlet cyMax = 1.5\nlet scaleX = (cxMax - cxMin) / Double(imageSize)\nlet scaleY = (cyMax - cyMin) / Double(imageSize)\n\nfor x in 0..<imageSize {\n  for y in 0..<imageSize {\n    let cx = cxMin + Double(x) * scaleX\n    let cy = cyMin + Double(y) * scaleY\n\n    let c = Complex(cx, cy)\n    var z = Complex(0.0, 0.0)\n    var i = 0\n\n    for t in 0..<maxIterations {\n      if z.magnitude > 2 {\n        break\n      }\n\n      z = z * z + c\n      i = t\n    }\n\n    canvas.setPixel(x: x, y: y, to: Color(red: UInt8(i), green: UInt8(i), blue: UInt8(i)))\n  }\n}\n\ncanvas.save()\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Imaging;\nusing System.Threading;\nusing System.Windows.Forms;\n\n\n\n\npublic class MandelbrotSetForm : Form\n{\n    const double MaxValueExtent = 2.0;\n    Thread thread;\n\n    static double CalcMandelbrotSetColor(ComplexNumber c)\n    {\n        \n        const int MaxIterations = 1000;\n        const double MaxNorm = MaxValueExtent * MaxValueExtent;\n\n        int iteration = 0;\n        ComplexNumber z = new ComplexNumber();\n        do\n        {\n            z = z * z + c;\n            iteration++;\n        } while (z.Norm() < MaxNorm && iteration < MaxIterations);\n        if (iteration < MaxIterations)\n            return (double)iteration / MaxIterations;\n        else\n            return 0; \n    }\n\n    static void GenerateBitmap(Bitmap bitmap)\n    {\n        double scale = 2 * MaxValueExtent / Math.Min(bitmap.Width, bitmap.Height);\n        for (int i = 0; i < bitmap.Height; i++)\n        {\n            double y = (bitmap.Height / 2 - i) * scale;\n            for (int j = 0; j < bitmap.Width; j++)\n            {\n                double x = (j - bitmap.Width / 2) * scale;\n                double color = CalcMandelbrotSetColor(new ComplexNumber(x, y));\n                bitmap.SetPixel(j, i, GetColor(color));\n            }\n        }\n    }\n\n    static Color GetColor(double value)\n    {\n        const double MaxColor = 256;\n        const double ContrastValue = 0.2;\n        return Color.FromArgb(0, 0,\n            (int)(MaxColor * Math.Pow(value, ContrastValue)));\n    }\n    \n    public MandelbrotSetForm()\n    {\n        \n        this.Text = \"Mandelbrot Set Drawing\";\n        this.BackColor = System.Drawing.Color.Black;\n        this.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Stretch;\n        this.MaximizeBox = false;\n        this.StartPosition = FormStartPosition.CenterScreen;\n        this.FormBorderStyle = FormBorderStyle.FixedDialog;\n        this.ClientSize = new Size(640, 640);\n        this.Load += new System.EventHandler(this.MainForm_Load);\n    }\n\n    void MainForm_Load(object sender, EventArgs e)\n    {\n        thread = new Thread(thread_Proc);\n        thread.IsBackground = true;\n        thread.Start(this.ClientSize);\n    }\n\n    void thread_Proc(object args)\n    {\n        \n        Size size = (Size)args;\n        int width = 16;\n        while (width * 2 < size.Width)\n        {\n            int height = width * size.Height / size.Width;\n            Bitmap bitmap = new Bitmap(width, height, PixelFormat.Format24bppRgb);\n            GenerateBitmap(bitmap);\n            this.BeginInvoke(new SetNewBitmapDelegate(SetNewBitmap), bitmap);\n            width *= 2;\n            Thread.Sleep(200);\n        }\n        \n        Bitmap finalBitmap = new Bitmap(size.Width, size.Height, PixelFormat.Format24bppRgb);\n        GenerateBitmap(finalBitmap);\n        this.BeginInvoke(new SetNewBitmapDelegate(SetNewBitmap), finalBitmap);\n    }\n\n    void SetNewBitmap(Bitmap image)\n    {\n        if (this.BackgroundImage != null)\n            this.BackgroundImage.Dispose();\n        this.BackgroundImage = image;\n    }\n\n    delegate void SetNewBitmapDelegate(Bitmap image);\n\n    static void Main()\n    {\n        Application.Run(new MandelbrotSetForm());\n    }\n}\n\nstruct ComplexNumber\n{\n    public double Re;\n    public double Im;\n\n    public ComplexNumber(double re, double im)\n    {\n        this.Re = re;\n        this.Im = im;\n    }\n\n    public static ComplexNumber operator +(ComplexNumber x, ComplexNumber y)\n    {\n        return new ComplexNumber(x.Re + y.Re, x.Im + y.Im);\n    }\n\n    public static ComplexNumber operator *(ComplexNumber x, ComplexNumber y)\n    {\n        return new ComplexNumber(x.Re * y.Re - x.Im * y.Im,\n            x.Re * y.Im + x.Im * y.Re);\n    }\n\n    public double Norm()\n    {\n        return Re * Re + Im * Im;\n    }\n}\n"}
{"id": 102889, "name": "Mandelbrot set", "source": "Translate Swift to Java: import Foundation\nimport Numerics\nimport QDBMP\n\npublic typealias Color = (red: UInt8, green: UInt8, blue: UInt8)\n\npublic class BitmapDrawer {\n  public let imageHeight: Int\n  public let imageWidth: Int\n\n  var grid: [[Color?]]\n\n  private let bmp: OpaquePointer\n\n  public init(height: Int, width: Int) {\n    self.imageHeight = height\n    self.imageWidth = width\n    self.grid = [[Color?]](repeating: [Color?](repeating: nil, count: height), count: width)\n    self.bmp = BMP_Create(UInt(width), UInt(height), 24)\n\n    checkError()\n  }\n\n  deinit {\n    BMP_Free(bmp)\n  }\n\n  private func checkError() {\n    let err = BMP_GetError()\n\n    guard err == BMP_STATUS(0) else {\n      fatalError(\"\\(err)\")\n    }\n  }\n\n  public func save(to path: String = \"~/Desktop/out.bmp\") {\n    for x in 0..<imageWidth {\n      for y in 0..<imageHeight {\n        guard let color = grid[x][y] else { continue }\n\n        BMP_SetPixelRGB(bmp, UInt(x), UInt(y), color.red, color.green, color.blue)\n        checkError()\n      }\n    }\n\n    (path as NSString).expandingTildeInPath.withCString {s in\n      BMP_WriteFile(bmp, s)\n    }\n  }\n\n  public func setPixel(x: Int, y: Int, to color: Color?) {\n    grid[x][y] = color\n  }\n}\n\nlet imageSize = 10_000\nlet canvas = BitmapDrawer(height: imageSize, width: imageSize)\nlet maxIterations = 256\nlet cxMin = -2.0\nlet cxMax = 1.0\nlet cyMin = -1.5\nlet cyMax = 1.5\nlet scaleX = (cxMax - cxMin) / Double(imageSize)\nlet scaleY = (cyMax - cyMin) / Double(imageSize)\n\nfor x in 0..<imageSize {\n  for y in 0..<imageSize {\n    let cx = cxMin + Double(x) * scaleX\n    let cy = cyMin + Double(y) * scaleY\n\n    let c = Complex(cx, cy)\n    var z = Complex(0.0, 0.0)\n    var i = 0\n\n    for t in 0..<maxIterations {\n      if z.magnitude > 2 {\n        break\n      }\n\n      z = z * z + c\n      i = t\n    }\n\n    canvas.setPixel(x: x, y: y, to: Color(red: UInt8(i), green: UInt8(i), blue: UInt8(i)))\n  }\n}\n\ncanvas.save()\n", "target": "import java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport javax.swing.JFrame;\n\npublic class Mandelbrot extends JFrame {\n\n    private final int MAX_ITER = 570;\n    private final double ZOOM = 150;\n    private BufferedImage I;\n    private double zx, zy, cX, cY, tmp;\n\n    public Mandelbrot() {\n        super(\"Mandelbrot Set\");\n        setBounds(100, 100, 800, 600);\n        setResizable(false);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        I = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);\n        for (int y = 0; y < getHeight(); y++) {\n            for (int x = 0; x < getWidth(); x++) {\n                zx = zy = 0;\n                cX = (x - 400) / ZOOM;\n                cY = (y - 300) / ZOOM;\n                int iter = MAX_ITER;\n                while (zx * zx + zy * zy < 4 && iter > 0) {\n                    tmp = zx * zx - zy * zy + cX;\n                    zy = 2.0 * zx * zy + cY;\n                    zx = tmp;\n                    iter--;\n                }\n                I.setRGB(x, y, iter | (iter << 8));\n            }\n        }\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.drawImage(I, 0, 0, this);\n    }\n\n    public static void main(String[] args) {\n        new Mandelbrot().setVisible(true);\n    }\n}\n"}
{"id": 102890, "name": "Mandelbrot set", "source": "Translate Swift to Python: import Foundation\nimport Numerics\nimport QDBMP\n\npublic typealias Color = (red: UInt8, green: UInt8, blue: UInt8)\n\npublic class BitmapDrawer {\n  public let imageHeight: Int\n  public let imageWidth: Int\n\n  var grid: [[Color?]]\n\n  private let bmp: OpaquePointer\n\n  public init(height: Int, width: Int) {\n    self.imageHeight = height\n    self.imageWidth = width\n    self.grid = [[Color?]](repeating: [Color?](repeating: nil, count: height), count: width)\n    self.bmp = BMP_Create(UInt(width), UInt(height), 24)\n\n    checkError()\n  }\n\n  deinit {\n    BMP_Free(bmp)\n  }\n\n  private func checkError() {\n    let err = BMP_GetError()\n\n    guard err == BMP_STATUS(0) else {\n      fatalError(\"\\(err)\")\n    }\n  }\n\n  public func save(to path: String = \"~/Desktop/out.bmp\") {\n    for x in 0..<imageWidth {\n      for y in 0..<imageHeight {\n        guard let color = grid[x][y] else { continue }\n\n        BMP_SetPixelRGB(bmp, UInt(x), UInt(y), color.red, color.green, color.blue)\n        checkError()\n      }\n    }\n\n    (path as NSString).expandingTildeInPath.withCString {s in\n      BMP_WriteFile(bmp, s)\n    }\n  }\n\n  public func setPixel(x: Int, y: Int, to color: Color?) {\n    grid[x][y] = color\n  }\n}\n\nlet imageSize = 10_000\nlet canvas = BitmapDrawer(height: imageSize, width: imageSize)\nlet maxIterations = 256\nlet cxMin = -2.0\nlet cxMax = 1.0\nlet cyMin = -1.5\nlet cyMax = 1.5\nlet scaleX = (cxMax - cxMin) / Double(imageSize)\nlet scaleY = (cyMax - cyMin) / Double(imageSize)\n\nfor x in 0..<imageSize {\n  for y in 0..<imageSize {\n    let cx = cxMin + Double(x) * scaleX\n    let cy = cyMin + Double(y) * scaleY\n\n    let c = Complex(cx, cy)\n    var z = Complex(0.0, 0.0)\n    var i = 0\n\n    for t in 0..<maxIterations {\n      if z.magnitude > 2 {\n        break\n      }\n\n      z = z * z + c\n      i = t\n    }\n\n    canvas.setPixel(x: x, y: y, to: Color(red: UInt8(i), green: UInt8(i), blue: UInt8(i)))\n  }\n}\n\ncanvas.save()\n", "target": "i = di = dj = 0\nfn1, fn2, fn3 = random(20), random(20), random(20)\nf = 10\n    \ndef setup():\n    global zmx1, zmx2, zmy1, zmy2\n    size(500, 500)\n    zmx1 = int(width / 4)\n    zmx2 = 2\n    zmy1 = int(height / 4)\n    zmy2 = 2\n\n\ndef draw():\n    global i\n\n    if i <= width:\n        i += 1\n    x = float(i + di) / zmx1 - zmx2\n    for j in range(height + 1):\n        y = zmy2 - float(j + dj) / zmy1\n        zr = zi = zr2 = zi2 = 0\n        cr, ci = x, y\n        n = 1\n        while n < 200 and (zr2 + zi2) < 4:\n            zi2 = zi * zi\n            zr2 = zr * zr\n            zi = 2 * zi * zr + ci\n            zr = zr2 - zi2 + cr\n            n += 1\n\n        re = (n * fn1) % 255\n        gr = (n * fn2) % 255\n        bl = (n * fn3) % 255\n        stroke(re, gr, bl)\n        point(i, j)\n\n\ndef mousePressed():\n    global zmx1, zmx2, zmy1, zmy2, di, dj\n    global i, j\n    background(200)\n    xt, yt = mouseX, mouseY\n    di = di + xt - width / 2.\n    dj = dj + yt - height / 2.\n    zmx1 = zmx1 * f\n    zmx2 = zmx2 * (1. / f)\n    zmy1 = zmy1 * f\n    zmy2 = zmy2 * (1. / f)\n    di, dj = di * f, dj * f\n    i = j = 0\n"}
{"id": 103164, "name": "Anagrams", "source": "Translate Swift to C#: import Foundation\n\nlet wordsURL = NSURL(string: \"http:\n\nlet wordsstring = try NSString(contentsOfURL:wordsURL , encoding: NSUTF8StringEncoding)\nlet allwords = wordsstring.componentsSeparatedByString(\"\\n\")\n\nlet words = allwords\n\nextension String {\n    var charactersAscending : String {\n        return String(Array(characters).sort())\n    }\n}\n\nvar charsToWords = [String:Set<String>]()\n\nvar biggest = 0\nvar biggestlists = [Set<String>]()\n\nfor thisword in words {\n    let chars = thisword.charactersAscending\n    \n    var knownwords = charsToWords[chars] ?? Set<String>()\n    knownwords.insert(thisword)\n    charsToWords[chars] = knownwords\n\n    if knownwords.count > biggest {\n        biggest = knownwords.count\n\n        biggestlists = [knownwords]\n    }\n    else if knownwords.count == biggest {\n        biggestlists.append(knownwords)\n    }\n}\n\nprint(\"Found \\(biggestlists.count) sets of anagrams with \\(biggest) members each\")\nfor (i, thislist) in biggestlists.enumerate() {\n    print(\"set \\(i): \\(thislist.sort())\")\n}\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Text.RegularExpressions;\n\nnamespace Anagram\n{\n    class Program\n    {\n        const string DICO_URL = \"http:\n\n        static void Main( string[] args )\n        {\n            WebRequest request = WebRequest.Create(DICO_URL);\n            string[] words;\n            using (StreamReader sr = new StreamReader(request.GetResponse().GetResponseStream(), true)) {\n                words = Regex.Split(sr.ReadToEnd(), @\"\\r?\\n\");\n            }\n            var groups = from string w in words\n                         group w by string.Concat(w.OrderBy(x => x)) into c\n                         group c by c.Count() into d\n                         orderby d.Key descending\n                         select d;\n            foreach (var c in groups.First()) {\n                Console.WriteLine(string.Join(\" \", c));\n            }\n        }\n    }\n}\n"}
{"id": 103166, "name": "Anagrams", "source": "Translate Swift to Java: import Foundation\n\nlet wordsURL = NSURL(string: \"http:\n\nlet wordsstring = try NSString(contentsOfURL:wordsURL , encoding: NSUTF8StringEncoding)\nlet allwords = wordsstring.componentsSeparatedByString(\"\\n\")\n\nlet words = allwords\n\nextension String {\n    var charactersAscending : String {\n        return String(Array(characters).sort())\n    }\n}\n\nvar charsToWords = [String:Set<String>]()\n\nvar biggest = 0\nvar biggestlists = [Set<String>]()\n\nfor thisword in words {\n    let chars = thisword.charactersAscending\n    \n    var knownwords = charsToWords[chars] ?? Set<String>()\n    knownwords.insert(thisword)\n    charsToWords[chars] = knownwords\n\n    if knownwords.count > biggest {\n        biggest = knownwords.count\n\n        biggestlists = [knownwords]\n    }\n    else if knownwords.count == biggest {\n        biggestlists.append(knownwords)\n    }\n}\n\nprint(\"Found \\(biggestlists.count) sets of anagrams with \\(biggest) members each\")\nfor (i, thislist) in biggestlists.enumerate() {\n    print(\"set \\(i): \\(thislist.sort())\")\n}\n", "target": "import java.net.*;\nimport java.io.*;\nimport java.util.*;\n \npublic class WordsOfEqChars {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http:\n        InputStreamReader isr = new InputStreamReader(url.openStream());\n        BufferedReader reader = new BufferedReader(isr);\n\n        Map<String, Collection<String>> anagrams = new HashMap<String, Collection<String>>();\n        String word;\n        int count = 0;\n        while ((word = reader.readLine()) != null) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            String key = new String(chars);\n            if (!anagrams.containsKey(key))\n                anagrams.put(key, new ArrayList<String>());\n            anagrams.get(key).add(word);\n            count = Math.max(count, anagrams.get(key).size());\n        }\n\n        reader.close();\n\n        for (Collection<String> ana : anagrams.values())\n            if (ana.size() >= count)\n                System.out.println(ana);\n    }   \n}\n"}
{"id": 103167, "name": "Anagrams", "source": "Translate Swift to Python: import Foundation\n\nlet wordsURL = NSURL(string: \"http:\n\nlet wordsstring = try NSString(contentsOfURL:wordsURL , encoding: NSUTF8StringEncoding)\nlet allwords = wordsstring.componentsSeparatedByString(\"\\n\")\n\nlet words = allwords\n\nextension String {\n    var charactersAscending : String {\n        return String(Array(characters).sort())\n    }\n}\n\nvar charsToWords = [String:Set<String>]()\n\nvar biggest = 0\nvar biggestlists = [Set<String>]()\n\nfor thisword in words {\n    let chars = thisword.charactersAscending\n    \n    var knownwords = charsToWords[chars] ?? Set<String>()\n    knownwords.insert(thisword)\n    charsToWords[chars] = knownwords\n\n    if knownwords.count > biggest {\n        biggest = knownwords.count\n\n        biggestlists = [knownwords]\n    }\n    else if knownwords.count == biggest {\n        biggestlists.append(knownwords)\n    }\n}\n\nprint(\"Found \\(biggestlists.count) sets of anagrams with \\(biggest) members each\")\nfor (i, thislist) in biggestlists.enumerate() {\n    print(\"set \\(i): \\(thislist.sort())\")\n}\n", "target": ">>> import urllib.request\n>>> from collections import defaultdict\n>>> words = urllib.request.urlopen('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt').read().split()\n>>> anagram = defaultdict(list) \n>>> for word in words:\n\tanagram[tuple(sorted(word))].append( word )\n\n\t\n>>> count = max(len(ana) for ana in anagram.values())\n>>> for ana in anagram.values():\n\tif len(ana) >= count:\n\t\tprint ([x.decode() for x in ana])\n"}
{"id": 103717, "name": "Letter frequency", "source": "Translate Swift to C#: import Foundation\n\nlet dictPath: String\n\nswitch CommandLine.arguments.count {\ncase 2:\n  dictPath = CommandLine.arguments[1]\ncase _:\n  dictPath = \"/usr/share/dict/words\"\n}\n\nlet wordsData = FileManager.default.contents(atPath: dictPath)!\nlet allWords = String(data: wordsData, encoding: .utf8)!\nlet words = allWords.components(separatedBy: \"\\n\")\nlet counts = words.flatMap({ $0.map({ ($0, 1) }) }).reduce(into: [:], { $0[$1.0, default: 0] += $1.1 })\n\nfor (char, count) in counts {\n  print(\"\\(char): \\(count)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nclass Program\n{\n    static SortedDictionary<TItem, int> GetFrequencies<TItem>(IEnumerable<TItem> items)\n    {\n        var dictionary = new SortedDictionary<TItem, int>();\n        foreach (var item in items)\n        {\n            if (dictionary.ContainsKey(item))\n            {\n                dictionary[item]++;\n            }\n            else\n            {\n                dictionary[item] = 1;\n            }\n        }\n        return dictionary;\n    }\n\n    static void Main(string[] arguments)\n    {\n        var file = arguments.FirstOrDefault();\n        if (File.Exists(file))\n        {\n            var text = File.ReadAllText(file);\n            foreach (var entry in GetFrequencies(text))\n            {\n                Console.WriteLine(\"{0}: {1}\", entry.Key, entry.Value);\n            }\n        }\n    }\n}\n"}
{"id": 103719, "name": "Letter frequency", "source": "Translate Swift to Java: import Foundation\n\nlet dictPath: String\n\nswitch CommandLine.arguments.count {\ncase 2:\n  dictPath = CommandLine.arguments[1]\ncase _:\n  dictPath = \"/usr/share/dict/words\"\n}\n\nlet wordsData = FileManager.default.contents(atPath: dictPath)!\nlet allWords = String(data: wordsData, encoding: .utf8)!\nlet words = allWords.components(separatedBy: \"\\n\")\nlet counts = words.flatMap({ $0.map({ ($0, 1) }) }).reduce(into: [:], { $0[$1.0, default: 0] += $1.1 })\n\nfor (char, count) in counts {\n  print(\"\\(char): \\(count)\")\n}\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\n\npublic class LetterFreq {\n\tpublic static int[] countLetters(String filename) throws IOException{\n\t\tint[] freqs = new int[26];\n\t\tBufferedReader in = new BufferedReader(new FileReader(filename));\n\t\tString line;\n\t\twhile((line = in.readLine()) != null){\n\t\t\tline = line.toUpperCase();\n\t\t\tfor(char ch:line.toCharArray()){\n\t\t\t\tif(Character.isLetter(ch)){\n\t\t\t\t\tfreqs[ch - 'A']++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tin.close();\n\t\treturn freqs;\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tSystem.out.println(Arrays.toString(countLetters(\"filename.txt\")));\n\t}\n}\n"}
{"id": 103720, "name": "Letter frequency", "source": "Translate Swift to Python: import Foundation\n\nlet dictPath: String\n\nswitch CommandLine.arguments.count {\ncase 2:\n  dictPath = CommandLine.arguments[1]\ncase _:\n  dictPath = \"/usr/share/dict/words\"\n}\n\nlet wordsData = FileManager.default.contents(atPath: dictPath)!\nlet allWords = String(data: wordsData, encoding: .utf8)!\nlet words = allWords.components(separatedBy: \"\\n\")\nlet counts = words.flatMap({ $0.map({ ($0, 1) }) }).reduce(into: [:], { $0[$1.0, default: 0] += $1.1 })\n\nfor (char, count) in counts {\n  print(\"\\(char): \\(count)\")\n}\n", "target": "import collections, sys\n\ndef filecharcount(openfile):\n    return sorted(collections.Counter(c for l in openfile for c in l).items())\n\nf = open(sys.argv[1])\nprint(filecharcount(f))\n"}
{"id": 103899, "name": "Sort a list of object identifiers", "source": "Translate Swift to C#: import Foundation\n\npublic struct OID {\n  public var val: String\n\n  public init(_ val: String) {\n    self.val = val\n  }\n}\n\nextension OID: CustomStringConvertible {\n  public var description: String {\n    return val\n  }\n}\n\nextension OID: Comparable {\n  public static func < (lhs: OID, rhs: OID) -> Bool {\n    let split1 = lhs.val.components(separatedBy: \".\").compactMap(Int.init)\n    let split2 = rhs.val.components(separatedBy: \".\").compactMap(Int.init)\n    let minSize = min(split1.count, split2.count)\n\n    for i in 0..<minSize {\n      if split1[i] < split2[i] {\n        return true\n      } else if split1[i] > split2[i] {\n        return false\n      }\n    }\n\n    return split1.count < split2.count\n  }\n\n  public static func == (lhs: OID, rhs: OID) -> Bool {\n    return lhs.val == rhs.val\n  }\n}\n\nlet ids = [\n  \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\", \n  \"1.3.6.1.4.1.11.2.17.5.2.0.79\", \n  \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\", \n  \"1.3.6.1.4.1.11150.3.4.0.1\", \n  \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\", \n  \"1.3.6.1.4.1.11150.3.4.0\"\n].map(OID.init)\n\nfor id in ids.sorted() {\n  print(id)\n}\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main() {\n        var oids = new [] {\n            \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\",\n            \"1.3.6.1.4.1.11.2.17.5.2.0.79\",\n            \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\",\n            \"1.3.6.1.4.1.11150.3.4.0.1\",\n            \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\",\n            \"1.3.6.1.4.1.11150.3.4.0\"\n        };\n\n        var comparer = Comparer<string>.Create((a, b) => {\n            int c = a.Split('.').Select(int.Parse)\n\t        .Zip(b.Split('.').Select(int.Parse),\n                    (i, j) => i.CompareTo(j)).FirstOrDefault(x => x != 0);\n            return c != 0 ? c : a.Length.CompareTo(b.Length);\n        });\n\n        Array.Sort(oids, comparer);\n\n        Console.WriteLine(string.Join(Environment.NewLine, oids));\n    }\n}\n"}
{"id": 103901, "name": "Sort a list of object identifiers", "source": "Translate Swift to Java: import Foundation\n\npublic struct OID {\n  public var val: String\n\n  public init(_ val: String) {\n    self.val = val\n  }\n}\n\nextension OID: CustomStringConvertible {\n  public var description: String {\n    return val\n  }\n}\n\nextension OID: Comparable {\n  public static func < (lhs: OID, rhs: OID) -> Bool {\n    let split1 = lhs.val.components(separatedBy: \".\").compactMap(Int.init)\n    let split2 = rhs.val.components(separatedBy: \".\").compactMap(Int.init)\n    let minSize = min(split1.count, split2.count)\n\n    for i in 0..<minSize {\n      if split1[i] < split2[i] {\n        return true\n      } else if split1[i] > split2[i] {\n        return false\n      }\n    }\n\n    return split1.count < split2.count\n  }\n\n  public static func == (lhs: OID, rhs: OID) -> Bool {\n    return lhs.val == rhs.val\n  }\n}\n\nlet ids = [\n  \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\", \n  \"1.3.6.1.4.1.11.2.17.5.2.0.79\", \n  \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\", \n  \"1.3.6.1.4.1.11150.3.4.0.1\", \n  \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\", \n  \"1.3.6.1.4.1.11150.3.4.0\"\n].map(OID.init)\n\nfor id in ids.sorted() {\n  print(id)\n}\n", "target": "package com.rosettacode;\n\nimport java.util.Comparator;\nimport java.util.stream.Stream;\n\npublic class OIDListSorting {\n\n    public static void main(String[] args) {\n\n        final String dot = \"\\\\.\";\n\n        final Comparator<String> oids_comparator = (o1, o2) -> {\n            final String[] o1Numbers = o1.split(dot), o2Numbers = o2.split(dot);\n            for (int i = 0; ; i++) {\n                if (i == o1Numbers.length && i == o2Numbers.length)\n                    return 0;\n                if (i == o1Numbers.length)\n                    return -1;\n                if (i == o2Numbers.length)\n                    return 1;\n                final int nextO1Number = Integer.valueOf(o1Numbers[i]), nextO2Number = Integer.valueOf(o2Numbers[i]);\n                final int result = Integer.compare(nextO1Number, nextO2Number);\n                if (result != 0)\n                    return result;\n            }\n        };\n\n        Stream.of(\"1.3.6.1.4.1.11.2.17.19.3.4.0.10\", \"1.3.6.1.4.1.11.2.17.5.2.0.79\", \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\",\n                  \"1.3.6.1.4.1.11150.3.4.0.1\", \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\", \"1.3.6.1.4.1.11150.3.4.0\")\n                .sorted(oids_comparator)\n                .forEach(System.out::println);\n    }\n}\n"}
{"id": 103902, "name": "Sort a list of object identifiers", "source": "Translate Swift to Python: import Foundation\n\npublic struct OID {\n  public var val: String\n\n  public init(_ val: String) {\n    self.val = val\n  }\n}\n\nextension OID: CustomStringConvertible {\n  public var description: String {\n    return val\n  }\n}\n\nextension OID: Comparable {\n  public static func < (lhs: OID, rhs: OID) -> Bool {\n    let split1 = lhs.val.components(separatedBy: \".\").compactMap(Int.init)\n    let split2 = rhs.val.components(separatedBy: \".\").compactMap(Int.init)\n    let minSize = min(split1.count, split2.count)\n\n    for i in 0..<minSize {\n      if split1[i] < split2[i] {\n        return true\n      } else if split1[i] > split2[i] {\n        return false\n      }\n    }\n\n    return split1.count < split2.count\n  }\n\n  public static func == (lhs: OID, rhs: OID) -> Bool {\n    return lhs.val == rhs.val\n  }\n}\n\nlet ids = [\n  \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\", \n  \"1.3.6.1.4.1.11.2.17.5.2.0.79\", \n  \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\", \n  \"1.3.6.1.4.1.11150.3.4.0.1\", \n  \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\", \n  \"1.3.6.1.4.1.11150.3.4.0\"\n].map(OID.init)\n\nfor id in ids.sorted() {\n  print(id)\n}\n", "target": "data = [\n    '1.3.6.1.4.1.11.2.17.19.3.4.0.10',\n    '1.3.6.1.4.1.11.2.17.5.2.0.79',\n    '1.3.6.1.4.1.11.2.17.19.3.4.0.4',\n    '1.3.6.1.4.1.11150.3.4.0.1',\n    '1.3.6.1.4.1.11.2.17.19.3.4.0.1',\n    '1.3.6.1.4.1.11150.3.4.0'\n]\n\nfor s in sorted(data, key=lambda x: list(map(int, x.split('.')))):\n    print(s)\n"}
{"id": 104116, "name": "Hello world_Graphical", "source": "Translate Swift to C#: import Cocoa\n\nlet alert = NSAlert()\nalert.messageText = \"Goodbye, World!\"\nalert.runModal()\n", "target": "using System;\nusing System.Windows.Forms;\n\nclass Program {\n    static void Main(string[] args) {\n        Application.EnableVisualStyles(); \n        MessageBox.Show(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 104118, "name": "Hello world_Graphical", "source": "Translate Swift to Java: import Cocoa\n\nlet alert = NSAlert()\nalert.messageText = \"Goodbye, World!\"\nalert.runModal()\n", "target": "import javax.swing.*;\nimport java.awt.*;\n\npublic class OutputSwing {\n\n    public static void main(String[] args) {\n\n        SwingUtilities.invokeLater(new Runnable(){\n            public void run() {\n                JOptionPane.showMessageDialog (null, \"Goodbye, World!\"); \n                JFrame frame = new JFrame(\"Goodbye, World!\");            \n                JTextArea text = new JTextArea(\"Goodbye, World!\");       \n                JButton button = new JButton(\"Goodbye, World!\");         \n\n                frame.setLayout(new FlowLayout());\n                frame.add(button);\n                frame.add(text);\n                frame.pack();\n                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n                frame.setVisible(true);\n            }\n        });\n    }\n}\n"}
{"id": 104119, "name": "Hello world_Graphical", "source": "Translate Swift to Python: import Cocoa\n\nlet alert = NSAlert()\nalert.messageText = \"Goodbye, World!\"\nalert.runModal()\n", "target": "import bpy\n\n\nbpy.data.objects['Cube'].select_set(True)\n\n\nbpy.ops.object.delete(True)\n  \n\nbpy.data.curves.new(type=\"FONT\", name=\"Font Curve\").body = \"Hello World\"\nfont_obj = bpy.data.objects.new(name=\"Font Object\", object_data=bpy.data.curves[\"Font Curve\"])\nbpy.context.scene.collection.objects.link(font_obj)\n        \n\nbpy.context.scene.camera.location = (2.5,0.3,10)\n\n\nbpy.context.scene.camera.rotation_euler = (0,0,0)\n\n\narea = next(area for area in bpy.context.screen.areas if area.type == 'VIEW_3D')\narea.spaces[0].region_3d.view_perspective = 'CAMERA'\n"}
{"id": 104401, "name": "Search a list", "source": "Translate Swift to C#: let haystack = [\"Zig\",\"Zag\",\"Wally\",\"Ronald\",\"Bush\",\"Krusty\",\"Charlie\",\"Bush\",\"Bozo\"]\nfor needle in [\"Washington\",\"Bush\"] {\n  if let index = haystack.indexOf(needle) {\n    print(\"\\(index) \\(needle)\")\n  } else {\n    print(\"\\(needle) is not in haystack\")\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Program {\n    static void Main(string[] args) {\n        List<string> haystack = new List<string>() { \"Zig\", \"Zag\", \"Wally\", \"Ronald\", \"Bush\", \"Krusty\", \"Charlie\", \"Bush\", \"Bozo\" };\n\n        foreach (string needle in new string[] { \"Washington\", \"Bush\" }) {\n            int index = haystack.IndexOf(needle);\n            \n            if (index < 0) Console.WriteLine(\"{0} is not in haystack\",needle);                \n            else Console.WriteLine(\"{0} {1}\",index,needle);\n        }\n    }\n}\n"}
{"id": 104403, "name": "Search a list", "source": "Translate Swift to Java: let haystack = [\"Zig\",\"Zag\",\"Wally\",\"Ronald\",\"Bush\",\"Krusty\",\"Charlie\",\"Bush\",\"Bozo\"]\nfor needle in [\"Washington\",\"Bush\"] {\n  if let index = haystack.indexOf(needle) {\n    print(\"\\(index) \\(needle)\")\n  } else {\n    print(\"\\(needle) is not in haystack\")\n  }\n}\n", "target": "import java.util.List;\nimport java.util.Arrays;\n\nList<String> haystack = Arrays.asList(\"Zig\",\"Zag\",\"Wally\",\"Ronald\",\"Bush\",\"Krusty\",\"Charlie\",\"Bush\",\"Bozo\");\n\nfor (String needle : new String[]{\"Washington\",\"Bush\"}) {\n    int index = haystack.indexOf(needle);\n    if (index < 0)\n        System.out.println(needle + \" is not in haystack\");\n    else\n        System.out.println(index + \" \" + needle);\n}\n"}
{"id": 104404, "name": "Search a list", "source": "Translate Swift to Python: let haystack = [\"Zig\",\"Zag\",\"Wally\",\"Ronald\",\"Bush\",\"Krusty\",\"Charlie\",\"Bush\",\"Bozo\"]\nfor needle in [\"Washington\",\"Bush\"] {\n  if let index = haystack.indexOf(needle) {\n    print(\"\\(index) \\(needle)\")\n  } else {\n    print(\"\\(needle) is not in haystack\")\n  }\n}\n", "target": "haystack=[\"Zig\",\"Zag\",\"Wally\",\"Ronald\",\"Bush\",\"Krusty\",\"Charlie\",\"Bush\",\"Bozo\"]\n\nfor needle in (\"Washington\",\"Bush\"):\n  try:\n    print haystack.index(needle), needle\n  except ValueError, value_error:\n    print needle,\"is not in haystack\"\n"}
{"id": 104847, "name": "Break OO privacy", "source": "Translate Swift to C#: struct Example {\n    var notSoSecret = \"Hello!\"\n    private var secret = 42\n}\n\nlet e = Example()\nlet mirror = Mirror(reflecting: e)\n\nif let secret = mirror.children.filter({ $0.label == \"secret\" }).first?.value {\n    print(\"Value of the secret is \\(secret)\")\n}\n", "target": "using System;\nusing System.Reflection;\n\npublic class MyClass\n{\n    private int answer = 42;\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var myInstance = new MyClass();\n        var fieldInfo = typeof(MyClass).GetField(\"answer\", BindingFlags.NonPublic | BindingFlags.Instance);\n        var answer = fieldInfo.GetValue(myInstance);\n        Console.WriteLine(answer);\n    }\n}\n"}
{"id": 104848, "name": "Break OO privacy", "source": "Translate Swift to C#: struct Example {\n    var notSoSecret = \"Hello!\"\n    private var secret = 42\n}\n\nlet e = Example()\nlet mirror = Mirror(reflecting: e)\n\nif let secret = mirror.children.filter({ $0.label == \"secret\" }).first?.value {\n    print(\"Value of the secret is \\(secret)\")\n}\n", "target": "using System;\nusing System.Reflection;\n\npublic class MyClass\n{\n    private int answer = 42;\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var myInstance = new MyClass();\n        var fieldInfo = typeof(MyClass).GetField(\"answer\", BindingFlags.NonPublic | BindingFlags.Instance);\n        var answer = fieldInfo.GetValue(myInstance);\n        Console.WriteLine(answer);\n    }\n}\n"}
{"id": 104851, "name": "Break OO privacy", "source": "Translate Swift to Java: struct Example {\n    var notSoSecret = \"Hello!\"\n    private var secret = 42\n}\n\nlet e = Example()\nlet mirror = Mirror(reflecting: e)\n\nif let secret = mirror.children.filter({ $0.label == \"secret\" }).first?.value {\n    print(\"Value of the secret is \\(secret)\")\n}\n", "target": "module BreakOO\n    {\n    \n    class Exposed\n        {\n        public    String pub = \"public\";\n        protected String pro = \"protected\";\n        private   String pri = \"private\";\n\n        @Override\n        String toString()\n            {\n            return $\"pub={pub.quoted()}, pro={pro.quoted()}, pri={pri.quoted()}\";\n            }\n        }\n\n    void run()\n        {\n        @Inject Console console;\n\n        Exposed expo = new Exposed();\n        console.print($\"before: {expo}\");\n\n        \n        expo.pub = $\"this was {expo.pub}\";\n     \n     \n\n        \n        assert (protected Exposed) expoPro := &expo.revealAs((protected Exposed));\n        expoPro.pro = $\"this was {expoPro.pro}\";\n     \n\n        \n        assert (private Exposed) expoPri := &expo.revealAs((private Exposed));\n        expoPri.pri = $\"this was {expoPri.pri}\";\n\n        \n        \n        assert (struct Exposed) expoStr := &expo.revealAs((struct Exposed));\n        expoStr.pub = $\"{expoStr.pub}!!!\";\n        expoStr.pro = $\"{expoStr.pro}!!!\";\n        expoStr.pri = $\"{expoStr.pri}!!!\";\n\n        console.print($\"after: {expo}\");\n        }\n    }\n"}
{"id": 104852, "name": "Break OO privacy", "source": "Translate Swift to Java: struct Example {\n    var notSoSecret = \"Hello!\"\n    private var secret = 42\n}\n\nlet e = Example()\nlet mirror = Mirror(reflecting: e)\n\nif let secret = mirror.children.filter({ $0.label == \"secret\" }).first?.value {\n    print(\"Value of the secret is \\(secret)\")\n}\n", "target": "module BreakOO\n    {\n    \n    class Exposed\n        {\n        public    String pub = \"public\";\n        protected String pro = \"protected\";\n        private   String pri = \"private\";\n\n        @Override\n        String toString()\n            {\n            return $\"pub={pub.quoted()}, pro={pro.quoted()}, pri={pri.quoted()}\";\n            }\n        }\n\n    void run()\n        {\n        @Inject Console console;\n\n        Exposed expo = new Exposed();\n        console.print($\"before: {expo}\");\n\n        \n        expo.pub = $\"this was {expo.pub}\";\n     \n     \n\n        \n        assert (protected Exposed) expoPro := &expo.revealAs((protected Exposed));\n        expoPro.pro = $\"this was {expoPro.pro}\";\n     \n\n        \n        assert (private Exposed) expoPri := &expo.revealAs((private Exposed));\n        expoPri.pri = $\"this was {expoPri.pri}\";\n\n        \n        \n        assert (struct Exposed) expoStr := &expo.revealAs((struct Exposed));\n        expoStr.pub = $\"{expoStr.pub}!!!\";\n        expoStr.pro = $\"{expoStr.pro}!!!\";\n        expoStr.pri = $\"{expoStr.pri}!!!\";\n\n        console.print($\"after: {expo}\");\n        }\n    }\n"}
{"id": 104853, "name": "Break OO privacy", "source": "Translate Swift to Python: struct Example {\n    var notSoSecret = \"Hello!\"\n    private var secret = 42\n}\n\nlet e = Example()\nlet mirror = Mirror(reflecting: e)\n\nif let secret = mirror.children.filter({ $0.label == \"secret\" }).first?.value {\n    print(\"Value of the secret is \\(secret)\")\n}\n", "target": ">>> class MyClassName:\n\t__private = 123\n\tnon_private = __private * 2\n\n\t\n>>> mine = MyClassName()\n>>> mine.non_private\n246\n>>> mine.__private\nTraceback (most recent call last):\n  File \"<pyshell\n    mine.__private\nAttributeError: 'MyClassName' object has no attribute '__private'\n>>> mine._MyClassName__private\n123\n>>>\n"}
{"id": 104854, "name": "Break OO privacy", "source": "Translate Swift to Python: struct Example {\n    var notSoSecret = \"Hello!\"\n    private var secret = 42\n}\n\nlet e = Example()\nlet mirror = Mirror(reflecting: e)\n\nif let secret = mirror.children.filter({ $0.label == \"secret\" }).first?.value {\n    print(\"Value of the secret is \\(secret)\")\n}\n", "target": ">>> class MyClassName:\n\t__private = 123\n\tnon_private = __private * 2\n\n\t\n>>> mine = MyClassName()\n>>> mine.non_private\n246\n>>> mine.__private\nTraceback (most recent call last):\n  File \"<pyshell\n    mine.__private\nAttributeError: 'MyClassName' object has no attribute '__private'\n>>> mine._MyClassName__private\n123\n>>>\n"}
{"id": 105089, "name": "Amicable pairs", "source": "Translate Swift to C#: import func Darwin.sqrt\n\nfunc sqrt(x:Int) -> Int { return Int(sqrt(Double(x))) }\n\nfunc properDivs(n: Int) -> [Int] {\n    \n    if n == 1 { return [] }\n    \n    var result = [Int]()\n    \n    for div in filter (1...sqrt(n), { n % $0 == 0 }) {\n        \n        result.append(div)\n\n        if n/div != div && n/div != n { result.append(n/div) }\n    }\n    \n    return sorted(result)\n    \n}\n\n\nfunc sumDivs(n:Int) -> Int {\n    \n    struct Cache { static var sum = [Int:Int]() }\n    \n    if let sum = Cache.sum[n] { return sum }\n    \n    let sum = properDivs(n).reduce(0) { $0 + $1 }\n    \n    Cache.sum[n] = sum\n    \n    return sum\n}\n\nfunc amicable(n:Int, m:Int) -> Bool {\n    \n    if n == m { return false }\n    \n    if sumDivs(n) != m || sumDivs(m) != n { return false }\n    \n    return true\n}\n\nvar pairs = [(Int, Int)]()\n\nfor n in 1 ..< 20_000 {\n    for m in n+1 ... 20_000 {\n        if amicable(n, m) {\n            pairs.append(n, m)\n            println(\"\\(n, m)\")\n        }\n    }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaCode.AmicablePairs\n{\n    internal static class Program {\n        private const int Limit = 20000;        \n\n        private static void Main()\n        {\n            foreach (var pair in GetPairs(Limit))\n            {\n                Console.WriteLine(\"{0} {1}\", pair.Item1, pair.Item2);\n            }\n        }\n\n        private static IEnumerable<Tuple<int, int>> GetPairs(int max)\n        {\n            List<int> divsums =\n                Enumerable.Range(0, max + 1).Select(i => ProperDivisors(i).Sum()).ToList();\n            for(int i=1; i<divsums.Count; i++) {\n                int sum = divsums[i];\n                if(i < sum && sum <= divsums.Count && divsums[sum] == i) {\n                    yield return new Tuple<int, int>(i, sum);\n                }\n            }\n        }\n\n        private static IEnumerable<int> ProperDivisors(int number)\n        {\n            return\n                Enumerable.Range(1, number / 2)\n                    .Where(divisor => number % divisor == 0);\n        }\n    }\n}\n"}
{"id": 105091, "name": "Amicable pairs", "source": "Translate Swift to Java: import func Darwin.sqrt\n\nfunc sqrt(x:Int) -> Int { return Int(sqrt(Double(x))) }\n\nfunc properDivs(n: Int) -> [Int] {\n    \n    if n == 1 { return [] }\n    \n    var result = [Int]()\n    \n    for div in filter (1...sqrt(n), { n % $0 == 0 }) {\n        \n        result.append(div)\n\n        if n/div != div && n/div != n { result.append(n/div) }\n    }\n    \n    return sorted(result)\n    \n}\n\n\nfunc sumDivs(n:Int) -> Int {\n    \n    struct Cache { static var sum = [Int:Int]() }\n    \n    if let sum = Cache.sum[n] { return sum }\n    \n    let sum = properDivs(n).reduce(0) { $0 + $1 }\n    \n    Cache.sum[n] = sum\n    \n    return sum\n}\n\nfunc amicable(n:Int, m:Int) -> Bool {\n    \n    if n == m { return false }\n    \n    if sumDivs(n) != m || sumDivs(m) != n { return false }\n    \n    return true\n}\n\nvar pairs = [(Int, Int)]()\n\nfor n in 1 ..< 20_000 {\n    for m in n+1 ... 20_000 {\n        if amicable(n, m) {\n            pairs.append(n, m)\n            println(\"\\(n, m)\")\n        }\n    }\n}\n", "target": "import java.util.Map;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.LongStream;\n\npublic class AmicablePairs {\n\n    public static void main(String[] args) {\n        int limit = 20_000;\n\n        Map<Long, Long> map = LongStream.rangeClosed(1, limit)\n                .parallel()\n                .boxed()\n                .collect(Collectors.toMap(Function.identity(), AmicablePairs::properDivsSum));\n\n        LongStream.rangeClosed(1, limit)\n                .forEach(n -> {\n                    long m = map.get(n);\n                    if (m > n && m <= limit && map.get(m) == n)\n                        System.out.printf(\"%s %s %n\", n, m);\n                });\n    }\n\n    public static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0).sum();\n    }\n}\n"}
{"id": 105092, "name": "Amicable pairs", "source": "Translate Swift to Python: import func Darwin.sqrt\n\nfunc sqrt(x:Int) -> Int { return Int(sqrt(Double(x))) }\n\nfunc properDivs(n: Int) -> [Int] {\n    \n    if n == 1 { return [] }\n    \n    var result = [Int]()\n    \n    for div in filter (1...sqrt(n), { n % $0 == 0 }) {\n        \n        result.append(div)\n\n        if n/div != div && n/div != n { result.append(n/div) }\n    }\n    \n    return sorted(result)\n    \n}\n\n\nfunc sumDivs(n:Int) -> Int {\n    \n    struct Cache { static var sum = [Int:Int]() }\n    \n    if let sum = Cache.sum[n] { return sum }\n    \n    let sum = properDivs(n).reduce(0) { $0 + $1 }\n    \n    Cache.sum[n] = sum\n    \n    return sum\n}\n\nfunc amicable(n:Int, m:Int) -> Bool {\n    \n    if n == m { return false }\n    \n    if sumDivs(n) != m || sumDivs(m) != n { return false }\n    \n    return true\n}\n\nvar pairs = [(Int, Int)]()\n\nfor n in 1 ..< 20_000 {\n    for m in n+1 ... 20_000 {\n        if amicable(n, m) {\n            pairs.append(n, m)\n            println(\"\\(n, m)\")\n        }\n    }\n}\n", "target": "from proper_divisors import proper_divs\n\ndef amicable(rangemax=20000):\n    n2divsum = {n: sum(proper_divs(n)) for n in range(1, rangemax + 1)}\n    for num, divsum in n2divsum.items():\n        if num < divsum and divsum <= rangemax and n2divsum[divsum] == num:\n            yield num, divsum\n\nif __name__ == '__main__':\n    for num, divsum in amicable():\n        print('Amicable pair: %i and %i With proper divisors:\\n    %r\\n    %r'\n              % (num, divsum, sorted(proper_divs(num)), sorted(proper_divs(divsum))))\n"}
{"id": 105599, "name": "Variables", "source": "Translate Swift to C#: import Foundation\n\n\n\n\n\nvar str = \"Hello, playground\" \nlet letStr:String = \"This is a constant\"\n\n\n\nvar str1:String! \n\n\nstr1 = \"foo bar\" \n\n\n\nvar optionalString = Optional<String>(\"foo bar\") \n\nprintln(optionalString) \n\n\nvar optionalString1:String? = \"foo bar\"\n\n\nprintln(optionalString1!)\n\noptionalString1 = nil \n\n\n\nif let value = optionalString1?.lowercaseString {\n    \n} else {\n    println(\"optionalString1 is nil\")\n}\n\n\ntypealias MyNewType = String \nvar myNewTypeString = MyNewType(\"foo bar\")\n\n\n\n\nlet myAnyObjectString:AnyObject = \"foo bar\"\n\n\nif let myString = myAnyObjectString as? String {\n    println(myString) \n} else {\n    println(\"myString is not a string\")\n}\n\n\n\n\nvar myFunc:(() -> Void)\nfunc showScopes() {\n    \n    let myFunctionVariable = \"foo bar function\"\n    \n    \n    func nestFunc() {\n        println(myFunctionVariable)\n    }\n    nestFunc()\n}\n\nmyFunc = showScopes \nmyFunc() \n", "target": "int j;\n"}
{"id": 105601, "name": "Variables", "source": "Translate Swift to Java: import Foundation\n\n\n\n\n\nvar str = \"Hello, playground\" \nlet letStr:String = \"This is a constant\"\n\n\n\nvar str1:String! \n\n\nstr1 = \"foo bar\" \n\n\n\nvar optionalString = Optional<String>(\"foo bar\") \n\nprintln(optionalString) \n\n\nvar optionalString1:String? = \"foo bar\"\n\n\nprintln(optionalString1!)\n\noptionalString1 = nil \n\n\n\nif let value = optionalString1?.lowercaseString {\n    \n} else {\n    println(\"optionalString1 is nil\")\n}\n\n\ntypealias MyNewType = String \nvar myNewTypeString = MyNewType(\"foo bar\")\n\n\n\n\nlet myAnyObjectString:AnyObject = \"foo bar\"\n\n\nif let myString = myAnyObjectString as? String {\n    println(myString) \n} else {\n    println(\"myString is not a string\")\n}\n\n\n\n\nvar myFunc:(() -> Void)\nfunc showScopes() {\n    \n    let myFunctionVariable = \"foo bar function\"\n    \n    \n    func nestFunc() {\n        println(myFunctionVariable)\n    }\n    nestFunc()\n}\n\nmyFunc = showScopes \nmyFunc() \n", "target": "int a;\ndouble b;\nAClassNameHere c;\n"}
{"id": 105602, "name": "Variables", "source": "Translate Swift to Python: import Foundation\n\n\n\n\n\nvar str = \"Hello, playground\" \nlet letStr:String = \"This is a constant\"\n\n\n\nvar str1:String! \n\n\nstr1 = \"foo bar\" \n\n\n\nvar optionalString = Optional<String>(\"foo bar\") \n\nprintln(optionalString) \n\n\nvar optionalString1:String? = \"foo bar\"\n\n\nprintln(optionalString1!)\n\noptionalString1 = nil \n\n\n\nif let value = optionalString1?.lowercaseString {\n    \n} else {\n    println(\"optionalString1 is nil\")\n}\n\n\ntypealias MyNewType = String \nvar myNewTypeString = MyNewType(\"foo bar\")\n\n\n\n\nlet myAnyObjectString:AnyObject = \"foo bar\"\n\n\nif let myString = myAnyObjectString as? String {\n    println(myString) \n} else {\n    println(\"myString is not a string\")\n}\n\n\n\n\nvar myFunc:(() -> Void)\nfunc showScopes() {\n    \n    let myFunctionVariable = \"foo bar function\"\n    \n    \n    func nestFunc() {\n        println(myFunctionVariable)\n    }\n    nestFunc()\n}\n\nmyFunc = showScopes \nmyFunc() \n", "target": "\nexample1 = 3\nexample2 = 3.0\nexample3 = True\nexample4 = \"hello\"\n\n\nexample1 = \"goodbye\"\n"}
{"id": 105812, "name": "Sort three variables", "source": "Translate Swift to C#: func varSort<T: Comparable>(_ x: inout T, _ y: inout T, _ z: inout T) {\n  let res = [x, y, z].sorted()\n\n  x = res[0]\n  y = res[1]\n  z = res[2]\n}\n\nvar x = \"lions, tigers, and\"\nvar y = \"bears, oh my!\"\nvar z = \"(from the \\\"Wizard of OZ\\\")\"\n\nprint(\"Before:\")\nprint(\"x = \\(x)\")\nprint(\"y = \\(y)\")\nprint(\"z = \\(z)\")\nprint()\n\nvarSort(&x, &y, &z)\n\nprint(\"After:\")\nprint(\"x = \\(x)\")\nprint(\"y = \\(y)\")\nprint(\"z = \\(z)\")\n", "target": "using System;\npublic class Program\n{\n    public static void Main()\n    {\n        (int x, int y, int z) = (77444, -12, 0);\n\n        \n        if (x > y) (x, y) = (y, x);\n        if (x > z) (x, z) = (z, x);\n        if (y > z) (y, z) = (z, y);\n        Console.WriteLine((x, y, z));\n\n        var (a, b, c) = (\n            \"lions, tigers, and\",\n            \"bears, oh my!\",\n            \"(from the 'Wizard of OZ')\");\n        \n        \n        Sort(ref a, ref b, ref c);\n        Console.WriteLine((a, b, c));\n    }\n    \n    public static void Sort<T>(ref T a, ref T b, ref T c)\n        where T : IComparable<T>\n    {\n        if (a.CompareTo(b) > 0) (a, b) = (b, a);\n        if (a.CompareTo(c) > 0) (a, c) = (c, a);\n        if (b.CompareTo(c) > 0) (b, c) = (c, b);\n    }\n}\n"}
{"id": 105814, "name": "Sort three variables", "source": "Translate Swift to Java: func varSort<T: Comparable>(_ x: inout T, _ y: inout T, _ z: inout T) {\n  let res = [x, y, z].sorted()\n\n  x = res[0]\n  y = res[1]\n  z = res[2]\n}\n\nvar x = \"lions, tigers, and\"\nvar y = \"bears, oh my!\"\nvar z = \"(from the \\\"Wizard of OZ\\\")\"\n\nprint(\"Before:\")\nprint(\"x = \\(x)\")\nprint(\"y = \\(y)\")\nprint(\"z = \\(z)\")\nprint()\n\nvarSort(&x, &y, &z)\n\nprint(\"After:\")\nprint(\"x = \\(x)\")\nprint(\"y = \\(y)\")\nprint(\"z = \\(z)\")\n", "target": "import java.util.Comparator;\nimport java.util.stream.Stream;\n\nclass Box {\n    public int weightKg;\n\n    Box(final int weightKg) {\n        this.weightKg = weightKg;\n    }\n}\n\npublic class Sort3Vars {\n    public static void main(String... args) {\n        int iA = 21;\n        int iB = 11;\n        int iC = 82;\n        int[] sortedInt = Stream.of(iA, iB, iC).sorted().mapToInt(Integer::intValue).toArray();\n        iA = sortedInt[0];\n        iB = sortedInt[1];\n        iC = sortedInt[2];\n        System.out.printf(\"Sorted values: %d %d %d%n\", iA, iB, iC);\n\n        String sA = \"s21\";\n        String sB = \"s11\";\n        String sC = \"s82\";\n        Object[] sortedStr = Stream.of(sA, sB, sC).sorted().toArray();\n        sA = (String) sortedStr[0];\n        sB = (String) sortedStr[1];\n        sC = (String) sortedStr[2];\n        System.out.printf(\"Sorted values: %s %s %s%n\", sA, sB, sC);\n\n        Box bA = new Box(200);\n        Box bB = new Box(12);\n        Box bC = new Box(143);\n        \n        Object[] sortedBox = Stream.of(bA, bB, bC).sorted(Comparator.comparingInt(a -> a.weightKg)).toArray();\n        bA = (Box) sortedBox[0];\n        bB = (Box) sortedBox[1];\n        bC = (Box) sortedBox[2];\n        System.out.printf(\"Sorted Boxes: %dKg %dKg %dKg%n\", bA.weightKg, bB.weightKg, bC.weightKg);\n    }\n}\n"}
{"id": 105815, "name": "Sort three variables", "source": "Translate Swift to Python: func varSort<T: Comparable>(_ x: inout T, _ y: inout T, _ z: inout T) {\n  let res = [x, y, z].sorted()\n\n  x = res[0]\n  y = res[1]\n  z = res[2]\n}\n\nvar x = \"lions, tigers, and\"\nvar y = \"bears, oh my!\"\nvar z = \"(from the \\\"Wizard of OZ\\\")\"\n\nprint(\"Before:\")\nprint(\"x = \\(x)\")\nprint(\"y = \\(y)\")\nprint(\"z = \\(z)\")\nprint()\n\nvarSort(&x, &y, &z)\n\nprint(\"After:\")\nprint(\"x = \\(x)\")\nprint(\"y = \\(y)\")\nprint(\"z = \\(z)\")\n", "target": "\na= raw_input(\"Enter values one by one ..\\n1.\").strip()\nb=raw_input(\"2.\").strip()\nc=raw_input(\"3.\").strip()\nif a>b :\n   a,b = b,a \nif a>c:\n   a,c = c,a \nif b>c:\n   b,c = c,b \nprint(str(a)+\" \"+str(b)+\" \"+str(c))\n"}
{"id": 106323, "name": "Miller\u2013Rabin primality test", "source": "Translate Swift to C#: import BigInt\n\nprivate let numTrails = 5\n\nfunc isPrime(_ n: BigInt) -> Bool {\n  guard n >= 2 else { fatalError() }\n  guard n != 2 else { return true }\n  guard n % 2 != 0 else { return false }\n\n  var s = 0\n  var d = n - 1\n\n  while true {\n    let (quo, rem) = (d / 2, d % 2)\n\n    guard rem != 1 else { break }\n\n    s += 1\n    d = quo\n  }\n\n  func tryComposite(_ a: BigInt) -> Bool {\n    guard a.power(d, modulus: n) != 1 else { return false }\n\n    for i in 0..<s where a.power((2 as BigInt).power(i) * d, modulus: n) == n - 1 {\n      return false\n    }\n\n    return true\n  }\n\n  for _ in 0..<numTrails where tryComposite(BigInt(BigUInt.randomInteger(lessThan: BigUInt(n)))) {\n    return false\n  }\n\n  return true\n}\n", "target": "public static class RabinMiller\n{\n    public static bool IsPrime(int n, int k)\n    {\n        if ((n < 2) || (n % 2 == 0)) return (n == 2);\n\n        int s = n - 1;\n        while (s % 2 == 0)  s >>= 1;\n\n        Random r = new Random();\n        for (int i = 0; i < k; i++)\n        {\n            int a = r.Next(n - 1) + 1;\n            int temp = s;\n            long mod = 1;\n            for (int j = 0; j < temp; ++j)  mod = (mod * a) % n;\n            while (temp != n - 1 && mod != 1 && mod != n - 1)\n            {\n                mod = (mod * mod) % n;\n                temp *= 2;\n            }\n\n            if (mod != n - 1 && temp % 2 == 0) return false;\n        }\n        return true;\n    }\n}\n"}
{"id": 106324, "name": "Miller\u2013Rabin primality test", "source": "Translate Swift to Java: import BigInt\n\nprivate let numTrails = 5\n\nfunc isPrime(_ n: BigInt) -> Bool {\n  guard n >= 2 else { fatalError() }\n  guard n != 2 else { return true }\n  guard n % 2 != 0 else { return false }\n\n  var s = 0\n  var d = n - 1\n\n  while true {\n    let (quo, rem) = (d / 2, d % 2)\n\n    guard rem != 1 else { break }\n\n    s += 1\n    d = quo\n  }\n\n  func tryComposite(_ a: BigInt) -> Bool {\n    guard a.power(d, modulus: n) != 1 else { return false }\n\n    for i in 0..<s where a.power((2 as BigInt).power(i) * d, modulus: n) == n - 1 {\n      return false\n    }\n\n    return true\n  }\n\n  for _ in 0..<numTrails where tryComposite(BigInt(BigUInt.randomInteger(lessThan: BigUInt(n)))) {\n    return false\n  }\n\n  return true\n}\n", "target": "import java.math.BigInteger;\n\npublic class MillerRabinPrimalityTest {\n  public static void main(String[] args) {\n    BigInteger n = new BigInteger(args[0]);\n    int certainty = Integer.parseInt(args[1]);\n    System.out.println(n.toString() + \" is \" + (n.isProbablePrime(certainty) ? \"probably prime\" : \"composite\"));\n  }\n}\n"}
{"id": 106325, "name": "Miller\u2013Rabin primality test", "source": "Translate Swift to Python: import BigInt\n\nprivate let numTrails = 5\n\nfunc isPrime(_ n: BigInt) -> Bool {\n  guard n >= 2 else { fatalError() }\n  guard n != 2 else { return true }\n  guard n % 2 != 0 else { return false }\n\n  var s = 0\n  var d = n - 1\n\n  while true {\n    let (quo, rem) = (d / 2, d % 2)\n\n    guard rem != 1 else { break }\n\n    s += 1\n    d = quo\n  }\n\n  func tryComposite(_ a: BigInt) -> Bool {\n    guard a.power(d, modulus: n) != 1 else { return false }\n\n    for i in 0..<s where a.power((2 as BigInt).power(i) * d, modulus: n) == n - 1 {\n      return false\n    }\n\n    return true\n  }\n\n  for _ in 0..<numTrails where tryComposite(BigInt(BigUInt.randomInteger(lessThan: BigUInt(n)))) {\n    return false\n  }\n\n  return true\n}\n", "target": "import random\n\ndef is_Prime(n):\n    \n    if n!=int(n):\n        return False\n    n=int(n)\n    \n    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:\n        return False\n        \n    if n==2 or n==3 or n==5 or n==7:\n        return True\n    s = 0\n    d = n-1\n    while d%2==0:\n        d>>=1\n        s+=1\n    assert(2**s * d == n-1)\n  \n    def trial_composite(a):\n        if pow(a, d, n) == 1:\n            return False\n        for i in range(s):\n            if pow(a, 2**i * d, n) == n-1:\n                return False\n        return True  \n \n    for i in range(8):\n        a = random.randrange(2, n)\n        if trial_composite(a):\n            return False\n \n    return True\n"}
{"id": 106844, "name": "Last Friday of each month", "source": "Translate Swift to C#: import Foundation\n\nfunc lastFridays(of year: Int) -> [Date] {\n\t\n\tlet calendar = Calendar.current\n\tvar dates = [Date]()\n\t\n\tfor month in 2...13 {\n\t\t\n\t\tlet lastDayOfMonth = DateComponents(calendar: calendar,\n\t\t                                    year: year,\n\t\t                                    month: month,\n\t\t                                    day: 0,\n\t\t                                    hour: 12)\n\t\t\n\t\tlet date = calendar.date(from: lastDayOfMonth)!\n\t\t\n\t\tlet isFriday = calendar.component(.weekday, from: date) == 6\n\t\t\n\t\tif isFriday {\n\t\t\t\n\t\t\tdates.append(calendar.date(from: lastDayOfMonth)!)\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tlet lastWeekofMonth = calendar.ordinality(of: .weekOfMonth,\n\t\t\t                                          in: .month,\n\t\t\t                                          for: date)!\n\t\t\t\n\t\t\tlet lastWithFriday = lastWeekofMonth - (calendar.component(.weekday, from: date) > 6 ? 0 : 1)\n\t\t\t\n\t\t\tlet lastFridayOfMonth = DateComponents(calendar: calendar,\n\t\t\t                                       year: year,\n\t\t\t                                       month: month - 1,\n\t\t\t                                       hour: 12,\n\t\t\t                                       weekday: 6,\n\t\t\t                                       weekOfMonth: lastWithFriday)\n\t\t\t\n\t\t\tdates.append(calendar.date(from: lastFridayOfMonth)!)\n\t\t}\n\t}\n\treturn dates\n}\n\nvar dateFormatter = DateFormatter()\ndateFormatter.dateStyle = .short\n\nprint(lastFridays(of: 2013).map(dateFormatter.string).joined(separator: \"\\n\"))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\n\nnamespace RosettaCode.LastFridaysOfYear\n{\n    internal static class Program\n    {\n        private static IEnumerable<DateTime> LastFridaysOfYear(int year)\n        {\n            for (var month = 1; month <= 12; month++)\n            {\n                var date = new DateTime(year, month, 1).AddMonths(1).AddDays(-1);\n                while (date.DayOfWeek != DayOfWeek.Friday)\n                {\n                    date = date.AddDays(-1);\n                }\n                yield return date;\n            }\n        }\n\n        private static void Main(string[] arguments)\n        {\n            int year;\n            var argument = arguments.FirstOrDefault();\n            if (string.IsNullOrEmpty(argument) || !int.TryParse(argument, out year))\n            {\n                year = DateTime.Today.Year;\n            }\n\n            foreach (var date in LastFridaysOfYear(year))\n            {\n                Console.WriteLine(date.ToString(\"d\", CultureInfo.InvariantCulture));\n            }\n        }\n    }\n}\n"}
{"id": 106845, "name": "Last Friday of each month", "source": "Translate Swift to C#: import Foundation\n\nfunc lastFridays(of year: Int) -> [Date] {\n\t\n\tlet calendar = Calendar.current\n\tvar dates = [Date]()\n\t\n\tfor month in 2...13 {\n\t\t\n\t\tlet lastDayOfMonth = DateComponents(calendar: calendar,\n\t\t                                    year: year,\n\t\t                                    month: month,\n\t\t                                    day: 0,\n\t\t                                    hour: 12)\n\t\t\n\t\tlet date = calendar.date(from: lastDayOfMonth)!\n\t\t\n\t\tlet isFriday = calendar.component(.weekday, from: date) == 6\n\t\t\n\t\tif isFriday {\n\t\t\t\n\t\t\tdates.append(calendar.date(from: lastDayOfMonth)!)\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tlet lastWeekofMonth = calendar.ordinality(of: .weekOfMonth,\n\t\t\t                                          in: .month,\n\t\t\t                                          for: date)!\n\t\t\t\n\t\t\tlet lastWithFriday = lastWeekofMonth - (calendar.component(.weekday, from: date) > 6 ? 0 : 1)\n\t\t\t\n\t\t\tlet lastFridayOfMonth = DateComponents(calendar: calendar,\n\t\t\t                                       year: year,\n\t\t\t                                       month: month - 1,\n\t\t\t                                       hour: 12,\n\t\t\t                                       weekday: 6,\n\t\t\t                                       weekOfMonth: lastWithFriday)\n\t\t\t\n\t\t\tdates.append(calendar.date(from: lastFridayOfMonth)!)\n\t\t}\n\t}\n\treturn dates\n}\n\nvar dateFormatter = DateFormatter()\ndateFormatter.dateStyle = .short\n\nprint(lastFridays(of: 2013).map(dateFormatter.string).joined(separator: \"\\n\"))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\n\nnamespace RosettaCode.LastFridaysOfYear\n{\n    internal static class Program\n    {\n        private static IEnumerable<DateTime> LastFridaysOfYear(int year)\n        {\n            for (var month = 1; month <= 12; month++)\n            {\n                var date = new DateTime(year, month, 1).AddMonths(1).AddDays(-1);\n                while (date.DayOfWeek != DayOfWeek.Friday)\n                {\n                    date = date.AddDays(-1);\n                }\n                yield return date;\n            }\n        }\n\n        private static void Main(string[] arguments)\n        {\n            int year;\n            var argument = arguments.FirstOrDefault();\n            if (string.IsNullOrEmpty(argument) || !int.TryParse(argument, out year))\n            {\n                year = DateTime.Today.Year;\n            }\n\n            foreach (var date in LastFridaysOfYear(year))\n            {\n                Console.WriteLine(date.ToString(\"d\", CultureInfo.InvariantCulture));\n            }\n        }\n    }\n}\n"}
{"id": 106848, "name": "Last Friday of each month", "source": "Translate Swift to Java: import Foundation\n\nfunc lastFridays(of year: Int) -> [Date] {\n\t\n\tlet calendar = Calendar.current\n\tvar dates = [Date]()\n\t\n\tfor month in 2...13 {\n\t\t\n\t\tlet lastDayOfMonth = DateComponents(calendar: calendar,\n\t\t                                    year: year,\n\t\t                                    month: month,\n\t\t                                    day: 0,\n\t\t                                    hour: 12)\n\t\t\n\t\tlet date = calendar.date(from: lastDayOfMonth)!\n\t\t\n\t\tlet isFriday = calendar.component(.weekday, from: date) == 6\n\t\t\n\t\tif isFriday {\n\t\t\t\n\t\t\tdates.append(calendar.date(from: lastDayOfMonth)!)\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tlet lastWeekofMonth = calendar.ordinality(of: .weekOfMonth,\n\t\t\t                                          in: .month,\n\t\t\t                                          for: date)!\n\t\t\t\n\t\t\tlet lastWithFriday = lastWeekofMonth - (calendar.component(.weekday, from: date) > 6 ? 0 : 1)\n\t\t\t\n\t\t\tlet lastFridayOfMonth = DateComponents(calendar: calendar,\n\t\t\t                                       year: year,\n\t\t\t                                       month: month - 1,\n\t\t\t                                       hour: 12,\n\t\t\t                                       weekday: 6,\n\t\t\t                                       weekOfMonth: lastWithFriday)\n\t\t\t\n\t\t\tdates.append(calendar.date(from: lastFridayOfMonth)!)\n\t\t}\n\t}\n\treturn dates\n}\n\nvar dateFormatter = DateFormatter()\ndateFormatter.dateStyle = .short\n\nprint(lastFridays(of: 2013).map(dateFormatter.string).joined(separator: \"\\n\"))\n", "target": "import java.text.*;\nimport java.util.*;\n\npublic class LastFridays {\n\n    public static void main(String[] args) throws Exception {\n        int year = Integer.parseInt(args[0]);\n        GregorianCalendar c = new GregorianCalendar(year, 0, 1);\n\n        for (String mon : new DateFormatSymbols(Locale.US).getShortMonths()) {\n            if (!mon.isEmpty()) {\n                int totalDaysOfMonth = c.getActualMaximum(Calendar.DAY_OF_MONTH);\n                c.set(Calendar.DAY_OF_MONTH, totalDaysOfMonth);\n\n                int daysToRollBack = (c.get(Calendar.DAY_OF_WEEK) + 1) % 7;\n\n                int day = totalDaysOfMonth - daysToRollBack;\n                c.set(Calendar.DAY_OF_MONTH, day);\n\n                System.out.printf(\"%d %s %d\\n\", year, mon, day);\n\n                c.set(year, c.get(Calendar.MONTH) + 1, 1);\n            }\n        }\n    }\n}\n"}
{"id": 106849, "name": "Last Friday of each month", "source": "Translate Swift to Java: import Foundation\n\nfunc lastFridays(of year: Int) -> [Date] {\n\t\n\tlet calendar = Calendar.current\n\tvar dates = [Date]()\n\t\n\tfor month in 2...13 {\n\t\t\n\t\tlet lastDayOfMonth = DateComponents(calendar: calendar,\n\t\t                                    year: year,\n\t\t                                    month: month,\n\t\t                                    day: 0,\n\t\t                                    hour: 12)\n\t\t\n\t\tlet date = calendar.date(from: lastDayOfMonth)!\n\t\t\n\t\tlet isFriday = calendar.component(.weekday, from: date) == 6\n\t\t\n\t\tif isFriday {\n\t\t\t\n\t\t\tdates.append(calendar.date(from: lastDayOfMonth)!)\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tlet lastWeekofMonth = calendar.ordinality(of: .weekOfMonth,\n\t\t\t                                          in: .month,\n\t\t\t                                          for: date)!\n\t\t\t\n\t\t\tlet lastWithFriday = lastWeekofMonth - (calendar.component(.weekday, from: date) > 6 ? 0 : 1)\n\t\t\t\n\t\t\tlet lastFridayOfMonth = DateComponents(calendar: calendar,\n\t\t\t                                       year: year,\n\t\t\t                                       month: month - 1,\n\t\t\t                                       hour: 12,\n\t\t\t                                       weekday: 6,\n\t\t\t                                       weekOfMonth: lastWithFriday)\n\t\t\t\n\t\t\tdates.append(calendar.date(from: lastFridayOfMonth)!)\n\t\t}\n\t}\n\treturn dates\n}\n\nvar dateFormatter = DateFormatter()\ndateFormatter.dateStyle = .short\n\nprint(lastFridays(of: 2013).map(dateFormatter.string).joined(separator: \"\\n\"))\n", "target": "import java.text.*;\nimport java.util.*;\n\npublic class LastFridays {\n\n    public static void main(String[] args) throws Exception {\n        int year = Integer.parseInt(args[0]);\n        GregorianCalendar c = new GregorianCalendar(year, 0, 1);\n\n        for (String mon : new DateFormatSymbols(Locale.US).getShortMonths()) {\n            if (!mon.isEmpty()) {\n                int totalDaysOfMonth = c.getActualMaximum(Calendar.DAY_OF_MONTH);\n                c.set(Calendar.DAY_OF_MONTH, totalDaysOfMonth);\n\n                int daysToRollBack = (c.get(Calendar.DAY_OF_WEEK) + 1) % 7;\n\n                int day = totalDaysOfMonth - daysToRollBack;\n                c.set(Calendar.DAY_OF_MONTH, day);\n\n                System.out.printf(\"%d %s %d\\n\", year, mon, day);\n\n                c.set(year, c.get(Calendar.MONTH) + 1, 1);\n            }\n        }\n    }\n}\n"}
{"id": 106850, "name": "Last Friday of each month", "source": "Translate Swift to Python: import Foundation\n\nfunc lastFridays(of year: Int) -> [Date] {\n\t\n\tlet calendar = Calendar.current\n\tvar dates = [Date]()\n\t\n\tfor month in 2...13 {\n\t\t\n\t\tlet lastDayOfMonth = DateComponents(calendar: calendar,\n\t\t                                    year: year,\n\t\t                                    month: month,\n\t\t                                    day: 0,\n\t\t                                    hour: 12)\n\t\t\n\t\tlet date = calendar.date(from: lastDayOfMonth)!\n\t\t\n\t\tlet isFriday = calendar.component(.weekday, from: date) == 6\n\t\t\n\t\tif isFriday {\n\t\t\t\n\t\t\tdates.append(calendar.date(from: lastDayOfMonth)!)\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tlet lastWeekofMonth = calendar.ordinality(of: .weekOfMonth,\n\t\t\t                                          in: .month,\n\t\t\t                                          for: date)!\n\t\t\t\n\t\t\tlet lastWithFriday = lastWeekofMonth - (calendar.component(.weekday, from: date) > 6 ? 0 : 1)\n\t\t\t\n\t\t\tlet lastFridayOfMonth = DateComponents(calendar: calendar,\n\t\t\t                                       year: year,\n\t\t\t                                       month: month - 1,\n\t\t\t                                       hour: 12,\n\t\t\t                                       weekday: 6,\n\t\t\t                                       weekOfMonth: lastWithFriday)\n\t\t\t\n\t\t\tdates.append(calendar.date(from: lastFridayOfMonth)!)\n\t\t}\n\t}\n\treturn dates\n}\n\nvar dateFormatter = DateFormatter()\ndateFormatter.dateStyle = .short\n\nprint(lastFridays(of: 2013).map(dateFormatter.string).joined(separator: \"\\n\"))\n", "target": "import calendar\n\ndef last_fridays(year):\n    for month in range(1, 13):\n        last_friday = max(week[calendar.FRIDAY]\n            for week in calendar.monthcalendar(year, month))\n        print('{:4d}-{:02d}-{:02d}'.format(year, month, last_friday))\n"}
{"id": 106851, "name": "Last Friday of each month", "source": "Translate Swift to Python: import Foundation\n\nfunc lastFridays(of year: Int) -> [Date] {\n\t\n\tlet calendar = Calendar.current\n\tvar dates = [Date]()\n\t\n\tfor month in 2...13 {\n\t\t\n\t\tlet lastDayOfMonth = DateComponents(calendar: calendar,\n\t\t                                    year: year,\n\t\t                                    month: month,\n\t\t                                    day: 0,\n\t\t                                    hour: 12)\n\t\t\n\t\tlet date = calendar.date(from: lastDayOfMonth)!\n\t\t\n\t\tlet isFriday = calendar.component(.weekday, from: date) == 6\n\t\t\n\t\tif isFriday {\n\t\t\t\n\t\t\tdates.append(calendar.date(from: lastDayOfMonth)!)\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tlet lastWeekofMonth = calendar.ordinality(of: .weekOfMonth,\n\t\t\t                                          in: .month,\n\t\t\t                                          for: date)!\n\t\t\t\n\t\t\tlet lastWithFriday = lastWeekofMonth - (calendar.component(.weekday, from: date) > 6 ? 0 : 1)\n\t\t\t\n\t\t\tlet lastFridayOfMonth = DateComponents(calendar: calendar,\n\t\t\t                                       year: year,\n\t\t\t                                       month: month - 1,\n\t\t\t                                       hour: 12,\n\t\t\t                                       weekday: 6,\n\t\t\t                                       weekOfMonth: lastWithFriday)\n\t\t\t\n\t\t\tdates.append(calendar.date(from: lastFridayOfMonth)!)\n\t\t}\n\t}\n\treturn dates\n}\n\nvar dateFormatter = DateFormatter()\ndateFormatter.dateStyle = .short\n\nprint(lastFridays(of: 2013).map(dateFormatter.string).joined(separator: \"\\n\"))\n", "target": "import calendar\n\ndef last_fridays(year):\n    for month in range(1, 13):\n        last_friday = max(week[calendar.FRIDAY]\n            for week in calendar.monthcalendar(year, month))\n        print('{:4d}-{:02d}-{:02d}'.format(year, month, last_friday))\n"}
{"id": 107166, "name": "Date format", "source": "Translate Swift to C#: import Foundation\nextension String {\n    func toStandardDateWithDateFormat(format: String) -> String {\n        let dateFormatter = NSDateFormatter()\n        dateFormatter.dateFormat = format\n        dateFormatter.dateStyle = .LongStyle\n        return dateFormatter.stringFromDate(dateFormatter.dateFromString(self)!)\n    }\n}\n\nlet date = \"2015-08-28\".toStandardDateWithDateFormat(\"yyyy-MM-dd\")\n", "target": "using System;\n\nnamespace RosettaCode.DateFormat\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            DateTime today = DateTime.Now.Date;\n            Console.WriteLine(today.ToString(\"yyyy-MM-dd\"));\n            Console.WriteLine(today.ToString(\"dddd, MMMMM d, yyyy\"));\n        }\n    }\n}\n"}
{"id": 107168, "name": "Date format", "source": "Translate Swift to Java: import Foundation\nextension String {\n    func toStandardDateWithDateFormat(format: String) -> String {\n        let dateFormatter = NSDateFormatter()\n        dateFormatter.dateFormat = format\n        dateFormatter.dateStyle = .LongStyle\n        return dateFormatter.stringFromDate(dateFormatter.dateFromString(self)!)\n    }\n}\n\nlet date = \"2015-08-28\".toStandardDateWithDateFormat(\"yyyy-MM-dd\")\n", "target": "Datetime dtNow = datetime.now();\nString strDt1 = dtNow.format('yyyy-MM-dd');\nString strDt2 = dtNow.format('EEEE, MMMM dd, yyyy');\nsystem.debug(strDt1); \nsystem.debug(strDt2); \n"}
{"id": 107169, "name": "Date format", "source": "Translate Swift to Python: import Foundation\nextension String {\n    func toStandardDateWithDateFormat(format: String) -> String {\n        let dateFormatter = NSDateFormatter()\n        dateFormatter.dateFormat = format\n        dateFormatter.dateStyle = .LongStyle\n        return dateFormatter.stringFromDate(dateFormatter.dateFromString(self)!)\n    }\n}\n\nlet date = \"2015-08-28\".toStandardDateWithDateFormat(\"yyyy-MM-dd\")\n", "target": "import datetime\ntoday = datetime.date.today()\n\ntoday.isoformat()\n\ntoday.strftime(\"%A, %B %d, %Y\")\n\n\n\"The date is {0:%A, %B %d, %Y}\".format(d)\n\n\"The date is {date:%A, %B %d, %Y}\".format(date=d)\n\nf\"The date is {d:%A, %B %d, %Y}\"\n"}
{"id": 107731, "name": "Exponentiation order", "source": "Translate Swift to C#: precedencegroup ExponentiationPrecedence {\n  associativity: left\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationPrecedence\n\n@inlinable\npublic func ** <T: BinaryInteger>(lhs: T, rhs: T) -> T {\n  guard lhs != 0 else {\n    return 1\n  }\n\n  var x = lhs\n  var n = rhs\n  var y = T(1)\n\n  while n > 1 {\n    switch n & 1 {\n    case 0:\n      n /= 2\n    case 1:\n      y *= x\n      n = (n - 1) / 2\n    case _:\n      fatalError()\n    }\n\n    x *= x\n  }\n\n  return x * y\n}\n\nprint(5 ** 3 ** 2)\nprint((5 ** 3) ** 2)\nprint(5 ** (3 ** 2))\n", "target": "using System;\n\nnamespace exponents\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            Console.WriteLine(Math.Pow(Math.Pow(5, 3), 2));\n            Console.WriteLine(Math.Pow(5, Math.Pow(3, 2)));\n            Console.Read();\n        }\n\n    }\n}\n"}
{"id": 107732, "name": "Exponentiation order", "source": "Translate Swift to C#: precedencegroup ExponentiationPrecedence {\n  associativity: left\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationPrecedence\n\n@inlinable\npublic func ** <T: BinaryInteger>(lhs: T, rhs: T) -> T {\n  guard lhs != 0 else {\n    return 1\n  }\n\n  var x = lhs\n  var n = rhs\n  var y = T(1)\n\n  while n > 1 {\n    switch n & 1 {\n    case 0:\n      n /= 2\n    case 1:\n      y *= x\n      n = (n - 1) / 2\n    case _:\n      fatalError()\n    }\n\n    x *= x\n  }\n\n  return x * y\n}\n\nprint(5 ** 3 ** 2)\nprint((5 ** 3) ** 2)\nprint(5 ** (3 ** 2))\n", "target": "using System;\n\nnamespace exponents\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            Console.WriteLine(Math.Pow(Math.Pow(5, 3), 2));\n            Console.WriteLine(Math.Pow(5, Math.Pow(3, 2)));\n            Console.Read();\n        }\n\n    }\n}\n"}
{"id": 107735, "name": "Exponentiation order", "source": "Translate Swift to Python: precedencegroup ExponentiationPrecedence {\n  associativity: left\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationPrecedence\n\n@inlinable\npublic func ** <T: BinaryInteger>(lhs: T, rhs: T) -> T {\n  guard lhs != 0 else {\n    return 1\n  }\n\n  var x = lhs\n  var n = rhs\n  var y = T(1)\n\n  while n > 1 {\n    switch n & 1 {\n    case 0:\n      n /= 2\n    case 1:\n      y *= x\n      n = (n - 1) / 2\n    case _:\n      fatalError()\n    }\n\n    x *= x\n  }\n\n  return x * y\n}\n\nprint(5 ** 3 ** 2)\nprint((5 ** 3) ** 2)\nprint(5 ** (3 ** 2))\n", "target": ">>> 5**3**2\n1953125\n>>> (5**3)**2\n15625\n>>> 5**(3**2)\n1953125\n>>> \n>>> try: from functools import reduce \nexcept: pass\n\n>>> reduce(pow, (5, 3, 2))\n15625\n>>>\n"}
{"id": 107736, "name": "Exponentiation order", "source": "Translate Swift to Python: precedencegroup ExponentiationPrecedence {\n  associativity: left\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationPrecedence\n\n@inlinable\npublic func ** <T: BinaryInteger>(lhs: T, rhs: T) -> T {\n  guard lhs != 0 else {\n    return 1\n  }\n\n  var x = lhs\n  var n = rhs\n  var y = T(1)\n\n  while n > 1 {\n    switch n & 1 {\n    case 0:\n      n /= 2\n    case 1:\n      y *= x\n      n = (n - 1) / 2\n    case _:\n      fatalError()\n    }\n\n    x *= x\n  }\n\n  return x * y\n}\n\nprint(5 ** 3 ** 2)\nprint((5 ** 3) ** 2)\nprint(5 ** (3 ** 2))\n", "target": ">>> 5**3**2\n1953125\n>>> (5**3)**2\n15625\n>>> 5**(3**2)\n1953125\n>>> \n>>> try: from functools import reduce \nexcept: pass\n\n>>> reduce(pow, (5, 3, 2))\n15625\n>>>\n"}
{"id": 107997, "name": "Loops_For with a specified step", "source": "Translate Swift to C#: for i in stride(from: 1, to: 10, by: 2) {\n  print(i)\n}\n", "target": "using System;\n \nclass Program {\n    static void Main(string[] args) {    \n        for (int i = 2; i <= 8; i+= 2) {        \n            Console.Write(\"{0}, \", i);\n        }\n\n        Console.WriteLine(\"who do we appreciate?\");\n    }\n}\n"}
{"id": 107999, "name": "Loops_For with a specified step", "source": "Translate Swift to Java: for i in stride(from: 1, to: 10, by: 2) {\n  print(i)\n}\n", "target": "for(int i = 2; i <= 8;i += 2){\n   System.out.print(i + \", \");\n}\nSystem.out.println(\"who do we appreciate?\");\n"}
{"id": 108000, "name": "Loops_For with a specified step", "source": "Translate Swift to Python: for i in stride(from: 1, to: 10, by: 2) {\n  print(i)\n}\n", "target": "for i in xrange(2, 9, 2):\n    print \"%d,\" % i,\nprint \"who do we appreciate?\"\n"}
{"id": 108599, "name": "Generator_Exponential", "source": "Translate Swift to C#: func powGen(m: Int) -> GeneratorOf<Int> {\n  let power = Double(m)\n  var cur: Double = 0\n  return GeneratorOf { Int(pow(cur++, power)) }\n}\n\nvar squares = powGen(2)\nvar cubes = powGen(3)\n\nvar nCube = cubes.next()\n\nvar filteredSqs = GeneratorOf<Int> {\n  for var nSq = squares.next() ;; nCube = cubes.next() {\n    if nCube > nSq {\n      return nSq\n    } else if nCube == nSq {\n      nSq = squares.next()\n    }\n  }\n}\n\nextension GeneratorOf {\n  func drop(n: Int) -> GeneratorOf<T> {\n    var g = self\n    for _ in 0..<n {g.next()}\n    return GeneratorOf{g.next()}\n  }\n  func take(n: Int) -> GeneratorOf<T> {\n    var (i, g) = (0, self)\n    return GeneratorOf{++i > n ? nil : g.next()}\n  }\n}\n\nfor num in filteredSqs.drop(20).take(10) {\n  print(num)\n}\n\n\n\n\n\n\n\n\n\n\n\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static void Main() {\n        Func<int, IEnumerable<int>> ms = m => Infinite().Select(i => (int)Math.Pow(i, m));\n        var squares = ms(2);\n        var cubes = ms(3);\n        var filtered = squares.Where(square => cubes.First(cube => cube >= square) != square);\n        var final = filtered.Skip(20).Take(10);\n        foreach (var i in final) Console.WriteLine(i);\n    }\n\n    static IEnumerable<int> Infinite() {\n        var i = 0;\n        while (true) yield return i++;\n    }\n}\n"}
{"id": 108600, "name": "Generator_Exponential", "source": "Translate Swift to C#: func powGen(m: Int) -> GeneratorOf<Int> {\n  let power = Double(m)\n  var cur: Double = 0\n  return GeneratorOf { Int(pow(cur++, power)) }\n}\n\nvar squares = powGen(2)\nvar cubes = powGen(3)\n\nvar nCube = cubes.next()\n\nvar filteredSqs = GeneratorOf<Int> {\n  for var nSq = squares.next() ;; nCube = cubes.next() {\n    if nCube > nSq {\n      return nSq\n    } else if nCube == nSq {\n      nSq = squares.next()\n    }\n  }\n}\n\nextension GeneratorOf {\n  func drop(n: Int) -> GeneratorOf<T> {\n    var g = self\n    for _ in 0..<n {g.next()}\n    return GeneratorOf{g.next()}\n  }\n  func take(n: Int) -> GeneratorOf<T> {\n    var (i, g) = (0, self)\n    return GeneratorOf{++i > n ? nil : g.next()}\n  }\n}\n\nfor num in filteredSqs.drop(20).take(10) {\n  print(num)\n}\n\n\n\n\n\n\n\n\n\n\n\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static void Main() {\n        Func<int, IEnumerable<int>> ms = m => Infinite().Select(i => (int)Math.Pow(i, m));\n        var squares = ms(2);\n        var cubes = ms(3);\n        var filtered = squares.Where(square => cubes.First(cube => cube >= square) != square);\n        var final = filtered.Skip(20).Take(10);\n        foreach (var i in final) Console.WriteLine(i);\n    }\n\n    static IEnumerable<int> Infinite() {\n        var i = 0;\n        while (true) yield return i++;\n    }\n}\n"}
{"id": 108603, "name": "Generator_Exponential", "source": "Translate Swift to Java: func powGen(m: Int) -> GeneratorOf<Int> {\n  let power = Double(m)\n  var cur: Double = 0\n  return GeneratorOf { Int(pow(cur++, power)) }\n}\n\nvar squares = powGen(2)\nvar cubes = powGen(3)\n\nvar nCube = cubes.next()\n\nvar filteredSqs = GeneratorOf<Int> {\n  for var nSq = squares.next() ;; nCube = cubes.next() {\n    if nCube > nSq {\n      return nSq\n    } else if nCube == nSq {\n      nSq = squares.next()\n    }\n  }\n}\n\nextension GeneratorOf {\n  func drop(n: Int) -> GeneratorOf<T> {\n    var g = self\n    for _ in 0..<n {g.next()}\n    return GeneratorOf{g.next()}\n  }\n  func take(n: Int) -> GeneratorOf<T> {\n    var (i, g) = (0, self)\n    return GeneratorOf{++i > n ? nil : g.next()}\n  }\n}\n\nfor num in filteredSqs.drop(20).take(10) {\n  print(num)\n}\n\n\n\n\n\n\n\n\n\n\n\n", "target": "import java.util.function.LongSupplier;\nimport static java.util.stream.LongStream.generate;\n\npublic class GeneratorExponential implements LongSupplier {\n    private LongSupplier source, filter;\n    private long s, f;\n\n    public GeneratorExponential(LongSupplier source, LongSupplier filter) {\n        this.source = source;\n        this.filter = filter;\n        f = filter.getAsLong();\n    }\n\n    @Override\n    public long getAsLong() {\n        s = source.getAsLong();\n\n        while (s == f) {\n            s = source.getAsLong();\n            f = filter.getAsLong();\n        }\n\n        while (s > f) {\n            f = filter.getAsLong();\n        }\n\n        return s;\n    }\n\n    public static void main(String[] args) {\n        generate(new GeneratorExponential(new SquaresGen(), new CubesGen()))\n                .skip(20).limit(10)\n                .forEach(n -> System.out.printf(\"%d \", n));\n    }\n}\n\nclass SquaresGen implements LongSupplier {\n    private long n;\n\n    @Override\n    public long getAsLong() {\n        return n * n++;\n    }\n}\n\nclass CubesGen implements LongSupplier {\n    private long n;\n\n    @Override\n    public long getAsLong() {\n        return n * n * n++;\n    }\n}\n"}
{"id": 108604, "name": "Generator_Exponential", "source": "Translate Swift to Java: func powGen(m: Int) -> GeneratorOf<Int> {\n  let power = Double(m)\n  var cur: Double = 0\n  return GeneratorOf { Int(pow(cur++, power)) }\n}\n\nvar squares = powGen(2)\nvar cubes = powGen(3)\n\nvar nCube = cubes.next()\n\nvar filteredSqs = GeneratorOf<Int> {\n  for var nSq = squares.next() ;; nCube = cubes.next() {\n    if nCube > nSq {\n      return nSq\n    } else if nCube == nSq {\n      nSq = squares.next()\n    }\n  }\n}\n\nextension GeneratorOf {\n  func drop(n: Int) -> GeneratorOf<T> {\n    var g = self\n    for _ in 0..<n {g.next()}\n    return GeneratorOf{g.next()}\n  }\n  func take(n: Int) -> GeneratorOf<T> {\n    var (i, g) = (0, self)\n    return GeneratorOf{++i > n ? nil : g.next()}\n  }\n}\n\nfor num in filteredSqs.drop(20).take(10) {\n  print(num)\n}\n\n\n\n\n\n\n\n\n\n\n\n", "target": "import java.util.function.LongSupplier;\nimport static java.util.stream.LongStream.generate;\n\npublic class GeneratorExponential implements LongSupplier {\n    private LongSupplier source, filter;\n    private long s, f;\n\n    public GeneratorExponential(LongSupplier source, LongSupplier filter) {\n        this.source = source;\n        this.filter = filter;\n        f = filter.getAsLong();\n    }\n\n    @Override\n    public long getAsLong() {\n        s = source.getAsLong();\n\n        while (s == f) {\n            s = source.getAsLong();\n            f = filter.getAsLong();\n        }\n\n        while (s > f) {\n            f = filter.getAsLong();\n        }\n\n        return s;\n    }\n\n    public static void main(String[] args) {\n        generate(new GeneratorExponential(new SquaresGen(), new CubesGen()))\n                .skip(20).limit(10)\n                .forEach(n -> System.out.printf(\"%d \", n));\n    }\n}\n\nclass SquaresGen implements LongSupplier {\n    private long n;\n\n    @Override\n    public long getAsLong() {\n        return n * n++;\n    }\n}\n\nclass CubesGen implements LongSupplier {\n    private long n;\n\n    @Override\n    public long getAsLong() {\n        return n * n * n++;\n    }\n}\n"}
{"id": 108605, "name": "Generator_Exponential", "source": "Translate Swift to Python: func powGen(m: Int) -> GeneratorOf<Int> {\n  let power = Double(m)\n  var cur: Double = 0\n  return GeneratorOf { Int(pow(cur++, power)) }\n}\n\nvar squares = powGen(2)\nvar cubes = powGen(3)\n\nvar nCube = cubes.next()\n\nvar filteredSqs = GeneratorOf<Int> {\n  for var nSq = squares.next() ;; nCube = cubes.next() {\n    if nCube > nSq {\n      return nSq\n    } else if nCube == nSq {\n      nSq = squares.next()\n    }\n  }\n}\n\nextension GeneratorOf {\n  func drop(n: Int) -> GeneratorOf<T> {\n    var g = self\n    for _ in 0..<n {g.next()}\n    return GeneratorOf{g.next()}\n  }\n  func take(n: Int) -> GeneratorOf<T> {\n    var (i, g) = (0, self)\n    return GeneratorOf{++i > n ? nil : g.next()}\n  }\n}\n\nfor num in filteredSqs.drop(20).take(10) {\n  print(num)\n}\n\n\n\n\n\n\n\n\n\n\n\n", "target": "from itertools import islice, count\n\ndef powers(m):\n    for n in count():\n        yield n ** m\n    \ndef filtered(s1, s2):\n    v, f = next(s1), next(s2)\n    while True:\n        if v > f:\n            f = next(s2)\n            continue\n        elif v < f:\n            yield v\n        v = next(s1)\n\nsquares, cubes = powers(2), powers(3)\nf = filtered(squares, cubes)\nprint(list(islice(f, 20, 30)))\n"}
{"id": 108606, "name": "Generator_Exponential", "source": "Translate Swift to Python: func powGen(m: Int) -> GeneratorOf<Int> {\n  let power = Double(m)\n  var cur: Double = 0\n  return GeneratorOf { Int(pow(cur++, power)) }\n}\n\nvar squares = powGen(2)\nvar cubes = powGen(3)\n\nvar nCube = cubes.next()\n\nvar filteredSqs = GeneratorOf<Int> {\n  for var nSq = squares.next() ;; nCube = cubes.next() {\n    if nCube > nSq {\n      return nSq\n    } else if nCube == nSq {\n      nSq = squares.next()\n    }\n  }\n}\n\nextension GeneratorOf {\n  func drop(n: Int) -> GeneratorOf<T> {\n    var g = self\n    for _ in 0..<n {g.next()}\n    return GeneratorOf{g.next()}\n  }\n  func take(n: Int) -> GeneratorOf<T> {\n    var (i, g) = (0, self)\n    return GeneratorOf{++i > n ? nil : g.next()}\n  }\n}\n\nfor num in filteredSqs.drop(20).take(10) {\n  print(num)\n}\n\n\n\n\n\n\n\n\n\n\n\n", "target": "from itertools import islice, count\n\ndef powers(m):\n    for n in count():\n        yield n ** m\n    \ndef filtered(s1, s2):\n    v, f = next(s1), next(s2)\n    while True:\n        if v > f:\n            f = next(s2)\n            continue\n        elif v < f:\n            yield v\n        v = next(s1)\n\nsquares, cubes = powers(2), powers(3)\nf = filtered(squares, cubes)\nprint(list(islice(f, 20, 30)))\n"}
{"id": 108907, "name": "Loops_Break", "source": "Translate Swift to C#: while true\n{\n  let a = Int(arc4random()) % (20)\n  print(\"a: \\(a)\",terminator: \"   \")\n  if (a == 10)\n  {\n    break\n  }\n  let b = Int(arc4random()) % (20)\n  print(\"b: \\(b)\")\n}\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        Random random = new Random();\n        while (true)\n        {\n            int a = random.Next(20);\n            Console.WriteLine(a);\n            if (a == 10)\n                break;\n            int b = random.Next(20)\n            Console.WriteLine(b);\n        }\n           \n        Console.ReadLine();\n    }       \n}\n"}
{"id": 108909, "name": "Loops_Break", "source": "Translate Swift to Java: while true\n{\n  let a = Int(arc4random()) % (20)\n  print(\"a: \\(a)\",terminator: \"   \")\n  if (a == 10)\n  {\n    break\n  }\n  let b = Int(arc4random()) % (20)\n  print(\"b: \\(b)\")\n}\n", "target": "import java.util.Random;\n\nRandom rand = new Random();\nwhile(true){\n    int a = rand.nextInt(20);\n    System.out.println(a);\n    if(a == 10) break;\n    int b = rand.nextInt(20);\n    System.out.println(b);\n}\n"}
{"id": 108910, "name": "Loops_Break", "source": "Translate Swift to Python: while true\n{\n  let a = Int(arc4random()) % (20)\n  print(\"a: \\(a)\",terminator: \"   \")\n  if (a == 10)\n  {\n    break\n  }\n  let b = Int(arc4random()) % (20)\n  print(\"b: \\(b)\")\n}\n", "target": "from random import randrange\n\nwhile True:\n    a = randrange(20)\n    print(a)\n    if a == 10:\n        break\n    b = randrange(20)\n    print(b)\n"}
{"id": 109154, "name": "Non-decimal radices_Convert", "source": "Translate Swift to C#: println(String(26, radix: 16)) \n", "target": "public static class BaseConverter {\n\n    \n    \n    \n    \n    \n    \n    public static long stringToLong(string s, int b) {\n\n        if ( b < 2 || b > 36 )\n            throw new ArgumentException(\"Base must be between 2 and 36\", \"b\");\n\n        checked {\n\n            int slen = s.Length;\n            long result = 0;\n            bool isNegative = false;\n\n            for ( int i = 0; i < slen; i++ ) {\n\n                char c = s[i];\n                int num;\n\n                if ( c == '-' ) {\n                    \n                    if ( i != 0 )\n                        throw new ArgumentException(\"A negative sign is allowed only as the first character of the string.\", \"s\");\n\n                    isNegative = true;\n                    continue;\n                }\n\n                if ( c > 0x2F && c < 0x3A )\n                    \n                    num = c - 0x30;\n                else if ( c > 0x40 && c < 0x5B )\n                    \n                    \n                    num = c - 0x37;  \n                else if ( c > 0x60 && c < 0x7B )\n                    \n                    \n                    num = c - 0x57;  \n                else\n                    throw new ArgumentException(\"The string contains an invalid character '\" + c + \"'\", \"s\");\n\n                \n\n                if ( num >= b )\n                    throw new ArgumentException(\"The string contains a character '\" + c + \"' which is not allowed in base \" + b, \"s\");\n\n                \n\n                result *= b;\n                result += num;\n\n            }\n\n            if ( isNegative )\n                result = -result;\n\n            return result;\n\n        }\n\n    }\n\n    \n    \n    \n    \n    \n    \n    public static string longToString(long n, int b) {\n        \n        \n        \n        \n        if ( b < 2 || b > 36 )\n            throw new ArgumentException(\"Base must be between 2 and 36\", \"b\");\n\n        \n\n        if ( b == 10 )\n            return n.ToString();\n\n        checked {\n            long longBase = b;\n            \n            StringBuilder sb = new StringBuilder();\n            \n            if ( n < 0 ) {\n                \n                n = -n;\n                sb.Append('-');\n            }\n            \n            long div = 1;\n            while ( n / div >= b )\n                \n                \n                div *= b;\n            \n            while ( true ) {\n                byte digit = (byte) (n / div);\n            \n                if ( digit < 10 )\n                    \n                    sb.Append((char) (digit + 0x30));\n                else\n                    \n                    sb.Append((char) (digit + 0x57));  \n            \n                if ( div == 1 )\n                    \n                    break;\n            \n                n %= div;\n                div /= b;\n            }\n            \n            return sb.ToString();\n        }\n\n    }\n\n}\n"}
{"id": 109156, "name": "Non-decimal radices_Convert", "source": "Translate Swift to Java: println(String(26, radix: 16)) \n", "target": "public static long backToTen(String num, int oldBase){\n   return Long.parseLong(num, oldBase); \n}\n\npublic static String tenToBase(long num, int newBase){\n   return Long.toString(num, newBase);\n}\n"}
{"id": 109586, "name": "Factors of an integer", "source": "Translate Swift to C#: func factors(n: Int) -> [Int] {\n    \n    return filter(1...n) { n % $0 == 0 }\n}\n", "target": "static void Main (string[] args) {\n    do {\n        Console.WriteLine (\"Number:\");\n        Int64 p = 0;\n        do {\n            try {\n                p = Convert.ToInt64 (Console.ReadLine ());\n                break;\n            } catch (Exception) { }\n\n        } while (true);\n\n        Console.WriteLine (\"For 1 through \" + ((int) Math.Sqrt (p)).ToString () + \"\");\n        for (int x = 1; x <= (int) Math.Sqrt (p); x++) {\n            if (p % x == 0)\n                Console.WriteLine (\"Found: \" + x.ToString () + \". \" + p.ToString () + \" / \" + x.ToString () + \" = \" + (p / x).ToString ());\n        }\n\n        Console.WriteLine (\"Done.\");\n    } while (true);\n}\n"}
{"id": 109588, "name": "Factors of an integer", "source": "Translate Swift to Java: func factors(n: Int) -> [Int] {\n    \n    return filter(1...n) { n % $0 == 0 }\n}\n", "target": "public static TreeSet<Long> factors(long n)\n{\n TreeSet<Long> factors = new TreeSet<Long>();\n factors.add(n);\n factors.add(1L);\n for(long test = n - 1; test >= Math.sqrt(n); test--)\n  if(n % test == 0)\n  {\n   factors.add(test);\n   factors.add(n / test);\n  }\n return factors;\n}\n"}
{"id": 109589, "name": "Factors of an integer", "source": "Translate Swift to Python: func factors(n: Int) -> [Int] {\n    \n    return filter(1...n) { n % $0 == 0 }\n}\n", "target": ">>> def factors(n):\n      return [i for i in range(1, n + 1) if not n%i]\n"}
{"id": 109853, "name": "Regular expressions", "source": "Translate Swift to C#: import Foundation\n\nlet str = \"I am a string\"\nif let range = str.rangeOfString(\"string$\", options: .RegularExpressionSearch) {\n  println(\"Ends with 'string'\")\n}\n", "target": "using System;\nusing System.Text.RegularExpressions;\n\nclass Program {\n    static void Main(string[] args) {\n        string str = \"I am a string\";\n\n        if (new Regex(\"string$\").IsMatch(str)) {\n            Console.WriteLine(\"Ends with string.\");\n        }\n\n        str = new Regex(\" a \").Replace(str, \" another \");\n        Console.WriteLine(str);\n    }\n}\n"}
{"id": 109855, "name": "Regular expressions", "source": "Translate Swift to Java: import Foundation\n\nlet str = \"I am a string\"\nif let range = str.rangeOfString(\"string$\", options: .RegularExpressionSearch) {\n  println(\"Ends with 'string'\")\n}\n", "target": "String str = \"I am a string\";\nif (str.matches(\".*string\")) { \n  System.out.println(\"ends with 'string'\");\n}\n"}
{"id": 109856, "name": "Regular expressions", "source": "Translate Swift to Python: import Foundation\n\nlet str = \"I am a string\"\nif let range = str.rangeOfString(\"string$\", options: .RegularExpressionSearch) {\n  println(\"Ends with 'string'\")\n}\n", "target": "import re\n\nstring = \"This is a string\"\n\nif re.search('string$', string):\n    print(\"Ends with string.\")\n\nstring = re.sub(\" a \", \" another \", string)\nprint(string)\n"}
{"id": 110752, "name": "Gapful numbers", "source": "Translate Swift to C#: func isGapful(n: Int) -> Bool {\n  guard n > 100 else {\n    return true\n  }\n\n  let asString = String(n)\n  let div = Int(\"\\(asString.first!)\\(asString.last!)\")!\n\n  return n % div == 0\n}\n\nlet first30 = (100...).lazy.filter(isGapful).prefix(30)\nlet mil = (1_000_000...).lazy.filter(isGapful).prefix(15)\nlet bil = (1_000_000_000...).lazy.filter(isGapful).prefix(15)\n\nprint(\"First 30 gapful numbers: \\(Array(first30))\")\nprint(\"First 15 >= 1,000,000: \\(Array(mil))\")\nprint(\"First 15 >= 1,000,000,000: \\(Array(bil))\")\n", "target": "using System;\n\nnamespace GapfulNumbers\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"The first 30 gapful numbers are: \");\n            \n            FindGap(100, 30);\n\n            Console.WriteLine(\"The first 15 gapful numbers > 1,000,000 are: \");\n            FindGap(1000000, 15);\n\n            Console.WriteLine(\"The first 10 gapful numbers > 1,000,000,000 are: \");\n            FindGap(1000000000, 10);\n\n            Console.Read();\n        }\n\n        public static int firstNum(int n)\n        {\n            \n            while (n >= 10)\n            {\n                n /= 10;\n            }\n            return (n);\n        }\n\n        public static int lastNum(int n)\n        {\n            \n            return (n % 10);\n        }\n\n        static void FindGap(int n, int gaps)\n        {\n            int count = 0;\n            while (count < gaps)\n            {\n\n                \n                string concat = firstNum(n).ToString() + lastNum(n).ToString();\n                \n                int i = Convert.ToInt32(concat);\n\n                \n                if (n % i == 0)\n                {\n                    Console.Write(n + \" \");\n                    count++;\n                    n++;\n                }\n                else\n                {\n                    n++;\n                    continue;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 110753, "name": "Gapful numbers", "source": "Translate Swift to C#: func isGapful(n: Int) -> Bool {\n  guard n > 100 else {\n    return true\n  }\n\n  let asString = String(n)\n  let div = Int(\"\\(asString.first!)\\(asString.last!)\")!\n\n  return n % div == 0\n}\n\nlet first30 = (100...).lazy.filter(isGapful).prefix(30)\nlet mil = (1_000_000...).lazy.filter(isGapful).prefix(15)\nlet bil = (1_000_000_000...).lazy.filter(isGapful).prefix(15)\n\nprint(\"First 30 gapful numbers: \\(Array(first30))\")\nprint(\"First 15 >= 1,000,000: \\(Array(mil))\")\nprint(\"First 15 >= 1,000,000,000: \\(Array(bil))\")\n", "target": "using System;\n\nnamespace GapfulNumbers\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"The first 30 gapful numbers are: \");\n            \n            FindGap(100, 30);\n\n            Console.WriteLine(\"The first 15 gapful numbers > 1,000,000 are: \");\n            FindGap(1000000, 15);\n\n            Console.WriteLine(\"The first 10 gapful numbers > 1,000,000,000 are: \");\n            FindGap(1000000000, 10);\n\n            Console.Read();\n        }\n\n        public static int firstNum(int n)\n        {\n            \n            while (n >= 10)\n            {\n                n /= 10;\n            }\n            return (n);\n        }\n\n        public static int lastNum(int n)\n        {\n            \n            return (n % 10);\n        }\n\n        static void FindGap(int n, int gaps)\n        {\n            int count = 0;\n            while (count < gaps)\n            {\n\n                \n                string concat = firstNum(n).ToString() + lastNum(n).ToString();\n                \n                int i = Convert.ToInt32(concat);\n\n                \n                if (n % i == 0)\n                {\n                    Console.Write(n + \" \");\n                    count++;\n                    n++;\n                }\n                else\n                {\n                    n++;\n                    continue;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 110756, "name": "Gapful numbers", "source": "Translate Swift to Java: func isGapful(n: Int) -> Bool {\n  guard n > 100 else {\n    return true\n  }\n\n  let asString = String(n)\n  let div = Int(\"\\(asString.first!)\\(asString.last!)\")!\n\n  return n % div == 0\n}\n\nlet first30 = (100...).lazy.filter(isGapful).prefix(30)\nlet mil = (1_000_000...).lazy.filter(isGapful).prefix(15)\nlet bil = (1_000_000_000...).lazy.filter(isGapful).prefix(15)\n\nprint(\"First 30 gapful numbers: \\(Array(first30))\")\nprint(\"First 15 >= 1,000,000: \\(Array(mil))\")\nprint(\"First 15 >= 1,000,000,000: \\(Array(bil))\")\n", "target": "import java.util.List;\n\npublic class GapfulNumbers {\n    private static String commatize(long n) {\n        StringBuilder sb = new StringBuilder(Long.toString(n));\n        int le = sb.length();\n        for (int i = le - 3; i >= 1; i -= 3) {\n            sb.insert(i, ',');\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        List<Long> starts = List.of((long) 1e2, (long) 1e6, (long) 1e7, (long) 1e9, (long) 7123);\n        List<Integer> counts = List.of(30, 15, 15, 10, 25);\n        for (int i = 0; i < starts.size(); ++i) {\n            int count = 0;\n            Long j = starts.get(i);\n            long pow = 100;\n            while (j >= pow * 10) {\n                pow *= 10;\n            }\n            System.out.printf(\"First %d gapful numbers starting at %s:\\n\", counts.get(i), commatize(starts.get(i)));\n            while (count < counts.get(i)) {\n                long fl = (j / pow) * 10 + (j % 10);\n                if (j % fl == 0) {\n                    System.out.printf(\"%d \", j);\n                    count++;\n                }\n                j++;\n                if (j >= 10 * pow) {\n                    pow *= 10;\n                }\n            }\n            System.out.println('\\n');\n        }\n    }\n}\n"}
{"id": 110757, "name": "Gapful numbers", "source": "Translate Swift to Java: func isGapful(n: Int) -> Bool {\n  guard n > 100 else {\n    return true\n  }\n\n  let asString = String(n)\n  let div = Int(\"\\(asString.first!)\\(asString.last!)\")!\n\n  return n % div == 0\n}\n\nlet first30 = (100...).lazy.filter(isGapful).prefix(30)\nlet mil = (1_000_000...).lazy.filter(isGapful).prefix(15)\nlet bil = (1_000_000_000...).lazy.filter(isGapful).prefix(15)\n\nprint(\"First 30 gapful numbers: \\(Array(first30))\")\nprint(\"First 15 >= 1,000,000: \\(Array(mil))\")\nprint(\"First 15 >= 1,000,000,000: \\(Array(bil))\")\n", "target": "import java.util.List;\n\npublic class GapfulNumbers {\n    private static String commatize(long n) {\n        StringBuilder sb = new StringBuilder(Long.toString(n));\n        int le = sb.length();\n        for (int i = le - 3; i >= 1; i -= 3) {\n            sb.insert(i, ',');\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        List<Long> starts = List.of((long) 1e2, (long) 1e6, (long) 1e7, (long) 1e9, (long) 7123);\n        List<Integer> counts = List.of(30, 15, 15, 10, 25);\n        for (int i = 0; i < starts.size(); ++i) {\n            int count = 0;\n            Long j = starts.get(i);\n            long pow = 100;\n            while (j >= pow * 10) {\n                pow *= 10;\n            }\n            System.out.printf(\"First %d gapful numbers starting at %s:\\n\", counts.get(i), commatize(starts.get(i)));\n            while (count < counts.get(i)) {\n                long fl = (j / pow) * 10 + (j % 10);\n                if (j % fl == 0) {\n                    System.out.printf(\"%d \", j);\n                    count++;\n                }\n                j++;\n                if (j >= 10 * pow) {\n                    pow *= 10;\n                }\n            }\n            System.out.println('\\n');\n        }\n    }\n}\n"}
{"id": 110758, "name": "Gapful numbers", "source": "Translate Swift to Python: func isGapful(n: Int) -> Bool {\n  guard n > 100 else {\n    return true\n  }\n\n  let asString = String(n)\n  let div = Int(\"\\(asString.first!)\\(asString.last!)\")!\n\n  return n % div == 0\n}\n\nlet first30 = (100...).lazy.filter(isGapful).prefix(30)\nlet mil = (1_000_000...).lazy.filter(isGapful).prefix(15)\nlet bil = (1_000_000_000...).lazy.filter(isGapful).prefix(15)\n\nprint(\"First 30 gapful numbers: \\(Array(first30))\")\nprint(\"First 15 >= 1,000,000: \\(Array(mil))\")\nprint(\"First 15 >= 1,000,000,000: \\(Array(bil))\")\n", "target": "from itertools import islice, count\nfor start, n in [(100, 30), (1_000_000, 15), (1_000_000_000, 10)]:\n    print(f\"\\nFirst {n} gapful numbers from {start:_}\")\n    print(list(islice(( x for x in count(start) \n                        if (x % (int(str(x)[0]) * 10 + (x % 10)) == 0) )\n                      , n)))\n"}
{"id": 110759, "name": "Gapful numbers", "source": "Translate Swift to Python: func isGapful(n: Int) -> Bool {\n  guard n > 100 else {\n    return true\n  }\n\n  let asString = String(n)\n  let div = Int(\"\\(asString.first!)\\(asString.last!)\")!\n\n  return n % div == 0\n}\n\nlet first30 = (100...).lazy.filter(isGapful).prefix(30)\nlet mil = (1_000_000...).lazy.filter(isGapful).prefix(15)\nlet bil = (1_000_000_000...).lazy.filter(isGapful).prefix(15)\n\nprint(\"First 30 gapful numbers: \\(Array(first30))\")\nprint(\"First 15 >= 1,000,000: \\(Array(mil))\")\nprint(\"First 15 >= 1,000,000,000: \\(Array(bil))\")\n", "target": "from itertools import islice, count\nfor start, n in [(100, 30), (1_000_000, 15), (1_000_000_000, 10)]:\n    print(f\"\\nFirst {n} gapful numbers from {start:_}\")\n    print(list(islice(( x for x in count(start) \n                        if (x % (int(str(x)[0]) * 10 + (x % 10)) == 0) )\n                      , n)))\n"}
{"id": 111163, "name": "Take notes on the command line", "source": "Translate Swift to C#: import Foundation\n\nlet args = Process.arguments\nlet manager = NSFileManager()\nlet currentPath = manager.currentDirectoryPath\nvar err:NSError?\n\n\nif !manager.fileExistsAtPath(currentPath + \"/notes.txt\") {\n    println(\"notes.txt doesn't exist\")\n    manager.createFileAtPath(currentPath + \"/notes.txt\", contents: nil, attributes: nil)\n}\n\n\nlet handler = NSFileHandle(forUpdatingAtPath: currentPath + \"/notes.txt\")\n\n\nif args.count == 1 {\n    let str = NSString(contentsOfFile: currentPath + \"/notes.txt\", encoding: NSUTF8StringEncoding, error: &err)\n    println(str!)\n    exit(0)\n}\n\nlet time = NSDate()\nlet format = NSDateFormatter()\nlet timeData = (format.stringFromDate(time) + \"\\n\").dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nformat.dateFormat = \"yyyy.MM.dd 'at' HH:mm:ss zzz\"\n\n\nhandler?.seekToEndOfFile()\nhandler?.writeData(timeData!)\n\nvar str = \"\\t\"\nfor i in 1..<args.count {\n    str += args[i] + \" \"\n}\n\nstr += \"\\n\"\n\nlet strData = str.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nhandler?.writeData(strData!)\n", "target": "using System;\nusing System.IO;\nusing System.Text;\n\nnamespace RosettaCode\n{\n  internal class Program\n  {\n    private const string FileName = \"NOTES.TXT\";\n\n    private static void Main(string[] args)\n    {\n      if (args.Length==0)\n      {\n        string txt = File.ReadAllText(FileName);\n        Console.WriteLine(txt);\n      }\n      else\n      {\n        var sb = new StringBuilder();\n        sb.Append(DateTime.Now).Append(\"\\n\\t\");\n        foreach (string s in args)\n          sb.Append(s).Append(\" \");\n        sb.Append(\"\\n\");\n\n        if (File.Exists(FileName))\n          File.AppendAllText(FileName, sb.ToString());\n        else\n          File.WriteAllText(FileName, sb.ToString());\n      }\n    }\n  }\n}\n"}
{"id": 111165, "name": "Take notes on the command line", "source": "Translate Swift to Java: import Foundation\n\nlet args = Process.arguments\nlet manager = NSFileManager()\nlet currentPath = manager.currentDirectoryPath\nvar err:NSError?\n\n\nif !manager.fileExistsAtPath(currentPath + \"/notes.txt\") {\n    println(\"notes.txt doesn't exist\")\n    manager.createFileAtPath(currentPath + \"/notes.txt\", contents: nil, attributes: nil)\n}\n\n\nlet handler = NSFileHandle(forUpdatingAtPath: currentPath + \"/notes.txt\")\n\n\nif args.count == 1 {\n    let str = NSString(contentsOfFile: currentPath + \"/notes.txt\", encoding: NSUTF8StringEncoding, error: &err)\n    println(str!)\n    exit(0)\n}\n\nlet time = NSDate()\nlet format = NSDateFormatter()\nlet timeData = (format.stringFromDate(time) + \"\\n\").dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nformat.dateFormat = \"yyyy.MM.dd 'at' HH:mm:ss zzz\"\n\n\nhandler?.seekToEndOfFile()\nhandler?.writeData(timeData!)\n\nvar str = \"\\t\"\nfor i in 1..<args.count {\n    str += args[i] + \" \"\n}\n\nstr += \"\\n\"\n\nlet strData = str.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nhandler?.writeData(strData!)\n", "target": "import java.io.*;\nimport java.nio.channels.*;\nimport java.util.Date;\n\npublic class TakeNotes {\n    public static void main(String[] args) throws IOException {\n        if (args.length > 0) {\n            PrintStream ps = new PrintStream(new FileOutputStream(\"notes.txt\", true));\n            ps.println(new Date());\n            ps.print(\"\\t\" + args[0]);\n            for (int i = 1; i < args.length; i++)\n                ps.print(\" \" + args[i]);\n            ps.println();\n            ps.close();\n        } else {\n            FileChannel fc = new FileInputStream(\"notes.txt\").getChannel();\n            fc.transferTo(0, fc.size(), Channels.newChannel(System.out));\n            fc.close();\n        }\n    }\n}\n"}
{"id": 111166, "name": "Take notes on the command line", "source": "Translate Swift to Python: import Foundation\n\nlet args = Process.arguments\nlet manager = NSFileManager()\nlet currentPath = manager.currentDirectoryPath\nvar err:NSError?\n\n\nif !manager.fileExistsAtPath(currentPath + \"/notes.txt\") {\n    println(\"notes.txt doesn't exist\")\n    manager.createFileAtPath(currentPath + \"/notes.txt\", contents: nil, attributes: nil)\n}\n\n\nlet handler = NSFileHandle(forUpdatingAtPath: currentPath + \"/notes.txt\")\n\n\nif args.count == 1 {\n    let str = NSString(contentsOfFile: currentPath + \"/notes.txt\", encoding: NSUTF8StringEncoding, error: &err)\n    println(str!)\n    exit(0)\n}\n\nlet time = NSDate()\nlet format = NSDateFormatter()\nlet timeData = (format.stringFromDate(time) + \"\\n\").dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nformat.dateFormat = \"yyyy.MM.dd 'at' HH:mm:ss zzz\"\n\n\nhandler?.seekToEndOfFile()\nhandler?.writeData(timeData!)\n\nvar str = \"\\t\"\nfor i in 1..<args.count {\n    str += args[i] + \" \"\n}\n\nstr += \"\\n\"\n\nlet strData = str.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nhandler?.writeData(strData!)\n", "target": "import sys, datetime, shutil\n\nif len(sys.argv) == 1:\n    try:\n        with open(\"notes.txt\", \"r\") as f:\n            shutil.copyfileobj(f, sys.stdout)\n    except IOError:\n        pass\nelse:\n    with open(\"notes.txt\", \"a\") as f:\n        f.write(datetime.datetime.now().isoformat() + \"\\n\")\n        f.write(\"\\t%s\\n\" % ' '.join(sys.argv[1:]))\n"}
{"id": 111747, "name": "Sort using a custom comparator", "source": "Translate Swift to C#: import Foundation\n\nvar list = [\"this\",\n  \"is\",\n  \"a\",\n  \"set\",\n  \"of\",\n  \"strings\",\n  \"to\",\n  \"sort\",\n  \"This\",\n  \"Is\",\n  \"A\",\n  \"Set\",\n  \"Of\",\n  \"Strings\",\n  \"To\",\n  \"Sort\"]\n\nlist.sortInPlace {lhs, rhs in\n  let lhsCount = lhs.characters.count\n  let rhsCount = rhs.characters.count\n  let result = rhsCount - lhsCount\n  \n  if result == 0 {\n    return lhs.lowercaseString > rhs.lowercaseString\n  }\n  \n  return lhsCount > rhsCount\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode {\n    class SortCustomComparator {\n        \n        public void CustomSort() {\n            String[] items = { \"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\" };\n            List<String> list = new List<string>(items);\n\n            DisplayList(\"Unsorted\", list);\n            \n            list.Sort(CustomCompare);\n            DisplayList(\"Descending Length\", list);\n\n            list.Sort();\n            DisplayList(\"Ascending order\", list);\n        }\n\n        \n        public int CustomCompare(String x, String y) {\n            int result = -x.Length.CompareTo(y.Length);\n            if (result == 0) {\n                result = x.ToLower().CompareTo(y.ToLower());\n            }\n\n            return result;\n        }\n\n        \n        public void DisplayList(String header, List<String> theList) {\n            Console.WriteLine(header);\n            Console.WriteLine(\"\".PadLeft(header.Length, '*'));\n            foreach (String str in theList) {\n                Console.WriteLine(str);\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 111749, "name": "Sort using a custom comparator", "source": "Translate Swift to Java: import Foundation\n\nvar list = [\"this\",\n  \"is\",\n  \"a\",\n  \"set\",\n  \"of\",\n  \"strings\",\n  \"to\",\n  \"sort\",\n  \"This\",\n  \"Is\",\n  \"A\",\n  \"Set\",\n  \"Of\",\n  \"Strings\",\n  \"To\",\n  \"Sort\"]\n\nlist.sortInPlace {lhs, rhs in\n  let lhsCount = lhs.characters.count\n  let rhsCount = rhs.characters.count\n  let result = rhsCount - lhsCount\n  \n  if result == 0 {\n    return lhs.lowercaseString > rhs.lowercaseString\n  }\n  \n  return lhsCount > rhsCount\n}\n", "target": "import java.util.Comparator;\nimport java.util.Arrays;\n\npublic class Test {\n  public static void main(String[] args) {\n    String[] strings = {\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"};\n\n    Arrays.sort(strings, new Comparator<String>() {\n      public int compare(String s1, String s2) {\n        int c = s2.length() - s1.length();\n        if (c == 0)\n          c = s1.compareToIgnoreCase(s2);\n        return c;\n      }\n    });\n\n    for (String s: strings)\n      System.out.print(s + \" \");\n  }\n}\n"}
{"id": 111750, "name": "Sort using a custom comparator", "source": "Translate Swift to Python: import Foundation\n\nvar list = [\"this\",\n  \"is\",\n  \"a\",\n  \"set\",\n  \"of\",\n  \"strings\",\n  \"to\",\n  \"sort\",\n  \"This\",\n  \"Is\",\n  \"A\",\n  \"Set\",\n  \"Of\",\n  \"Strings\",\n  \"To\",\n  \"Sort\"]\n\nlist.sortInPlace {lhs, rhs in\n  let lhsCount = lhs.characters.count\n  let rhsCount = rhs.characters.count\n  let result = rhsCount - lhsCount\n  \n  if result == 0 {\n    return lhs.lowercaseString > rhs.lowercaseString\n  }\n  \n  return lhsCount > rhsCount\n}\n", "target": "strings = \"here are Some sample strings to be sorted\".split()\n\ndef mykey(x):\n    return -len(x), x.upper()\n\nprint sorted(strings, key=mykey)\n"}
{"id": 112034, "name": "Feigenbaum constant calculation", "source": "Translate Swift to C#: import Foundation\n\nfunc feigenbaum(iterations: Int = 13) {\n  var a = 0.0\n  var a1 = 1.0\n  var a2 = 0.0\n  var d = 0.0\n  var d1 = 3.2\n\n  print(\" i       d\")\n\n  for i in 2...iterations {\n    a = a1 + (a1 - a2) / d1\n\n    for _ in 1...10 {\n      var x = 0.0\n      var y = 0.0\n\n      for _ in 1...1<<i {\n        y = 1.0 - 2.0 * y * x\n        x = a - x * x\n      }\n\n      a -= x / y\n    }\n\n    d = (a1 - a2) / (a - a1)\n    d1 = d\n    (a1, a2) = (a, a1)\n\n    print(String(format: \"%2d   \u00a0%.8f\", i, d))\n  }\n}\n\nfeigenbaum()\n", "target": "using System;\n\nnamespace FeigenbaumConstant {\n    class Program {\n        static void Main(string[] args) {\n            var maxIt = 13;\n            var maxItJ = 10;\n            var a1 = 1.0;\n            var a2 = 0.0;\n            var d1 = 3.2;\n            Console.WriteLine(\" i       d\");\n            for (int i = 2; i <= maxIt; i++) {\n                var a = a1 + (a1 - a2) / d1;\n                for (int j = 1; j <= maxItJ; j++) {\n                    var x = 0.0;\n                    var y = 0.0;\n                    for (int k = 1; k <= 1<<i; k++) {\n                        y = 1.0 - 2.0 * y * x;\n                        x = a - x * x;\n                    }\n                    a -= x / y;\n                }\n                var d = (a1 - a2) / (a - a1);\n                Console.WriteLine(\"{0,2:d}    {1:f8}\", i, d);\n                d1 = d;\n                a2 = a1;\n                a1 = a;\n            }\n        }\n    }\n}\n"}
{"id": 112035, "name": "Feigenbaum constant calculation", "source": "Translate Swift to C#: import Foundation\n\nfunc feigenbaum(iterations: Int = 13) {\n  var a = 0.0\n  var a1 = 1.0\n  var a2 = 0.0\n  var d = 0.0\n  var d1 = 3.2\n\n  print(\" i       d\")\n\n  for i in 2...iterations {\n    a = a1 + (a1 - a2) / d1\n\n    for _ in 1...10 {\n      var x = 0.0\n      var y = 0.0\n\n      for _ in 1...1<<i {\n        y = 1.0 - 2.0 * y * x\n        x = a - x * x\n      }\n\n      a -= x / y\n    }\n\n    d = (a1 - a2) / (a - a1)\n    d1 = d\n    (a1, a2) = (a, a1)\n\n    print(String(format: \"%2d   \u00a0%.8f\", i, d))\n  }\n}\n\nfeigenbaum()\n", "target": "using System;\n\nnamespace FeigenbaumConstant {\n    class Program {\n        static void Main(string[] args) {\n            var maxIt = 13;\n            var maxItJ = 10;\n            var a1 = 1.0;\n            var a2 = 0.0;\n            var d1 = 3.2;\n            Console.WriteLine(\" i       d\");\n            for (int i = 2; i <= maxIt; i++) {\n                var a = a1 + (a1 - a2) / d1;\n                for (int j = 1; j <= maxItJ; j++) {\n                    var x = 0.0;\n                    var y = 0.0;\n                    for (int k = 1; k <= 1<<i; k++) {\n                        y = 1.0 - 2.0 * y * x;\n                        x = a - x * x;\n                    }\n                    a -= x / y;\n                }\n                var d = (a1 - a2) / (a - a1);\n                Console.WriteLine(\"{0,2:d}    {1:f8}\", i, d);\n                d1 = d;\n                a2 = a1;\n                a1 = a;\n            }\n        }\n    }\n}\n"}
{"id": 112038, "name": "Feigenbaum constant calculation", "source": "Translate Swift to Java: import Foundation\n\nfunc feigenbaum(iterations: Int = 13) {\n  var a = 0.0\n  var a1 = 1.0\n  var a2 = 0.0\n  var d = 0.0\n  var d1 = 3.2\n\n  print(\" i       d\")\n\n  for i in 2...iterations {\n    a = a1 + (a1 - a2) / d1\n\n    for _ in 1...10 {\n      var x = 0.0\n      var y = 0.0\n\n      for _ in 1...1<<i {\n        y = 1.0 - 2.0 * y * x\n        x = a - x * x\n      }\n\n      a -= x / y\n    }\n\n    d = (a1 - a2) / (a - a1)\n    d1 = d\n    (a1, a2) = (a, a1)\n\n    print(String(format: \"%2d   \u00a0%.8f\", i, d))\n  }\n}\n\nfeigenbaum()\n", "target": "public class Feigenbaum {\n    public static void main(String[] args) {\n        int max_it = 13;\n        int max_it_j = 10;\n        double a1 = 1.0;\n        double a2 = 0.0;\n        double d1 = 3.2;\n        double a;\n\n        System.out.println(\" i       d\");\n        for (int i = 2; i <= max_it; i++) {\n            a = a1 + (a1 - a2) / d1;\n            for (int j = 0; j < max_it_j; j++) {\n                double x = 0.0;\n                double y = 0.0;\n                for (int k = 0; k < 1 << i; k++) {\n                    y = 1.0 - 2.0 * y * x;\n                    x = a - x * x;\n                }\n                a -= x / y;\n            }\n            double d = (a1 - a2) / (a - a1);\n            System.out.printf(\"%2d   \u00a0%.8f\\n\", i, d);\n            d1 = d;\n            a2 = a1;\n            a1 = a;\n        }\n    }\n}\n"}
{"id": 112039, "name": "Feigenbaum constant calculation", "source": "Translate Swift to Java: import Foundation\n\nfunc feigenbaum(iterations: Int = 13) {\n  var a = 0.0\n  var a1 = 1.0\n  var a2 = 0.0\n  var d = 0.0\n  var d1 = 3.2\n\n  print(\" i       d\")\n\n  for i in 2...iterations {\n    a = a1 + (a1 - a2) / d1\n\n    for _ in 1...10 {\n      var x = 0.0\n      var y = 0.0\n\n      for _ in 1...1<<i {\n        y = 1.0 - 2.0 * y * x\n        x = a - x * x\n      }\n\n      a -= x / y\n    }\n\n    d = (a1 - a2) / (a - a1)\n    d1 = d\n    (a1, a2) = (a, a1)\n\n    print(String(format: \"%2d   \u00a0%.8f\", i, d))\n  }\n}\n\nfeigenbaum()\n", "target": "public class Feigenbaum {\n    public static void main(String[] args) {\n        int max_it = 13;\n        int max_it_j = 10;\n        double a1 = 1.0;\n        double a2 = 0.0;\n        double d1 = 3.2;\n        double a;\n\n        System.out.println(\" i       d\");\n        for (int i = 2; i <= max_it; i++) {\n            a = a1 + (a1 - a2) / d1;\n            for (int j = 0; j < max_it_j; j++) {\n                double x = 0.0;\n                double y = 0.0;\n                for (int k = 0; k < 1 << i; k++) {\n                    y = 1.0 - 2.0 * y * x;\n                    x = a - x * x;\n                }\n                a -= x / y;\n            }\n            double d = (a1 - a2) / (a - a1);\n            System.out.printf(\"%2d   \u00a0%.8f\\n\", i, d);\n            d1 = d;\n            a2 = a1;\n            a1 = a;\n        }\n    }\n}\n"}
{"id": 112040, "name": "Feigenbaum constant calculation", "source": "Translate Swift to Python: import Foundation\n\nfunc feigenbaum(iterations: Int = 13) {\n  var a = 0.0\n  var a1 = 1.0\n  var a2 = 0.0\n  var d = 0.0\n  var d1 = 3.2\n\n  print(\" i       d\")\n\n  for i in 2...iterations {\n    a = a1 + (a1 - a2) / d1\n\n    for _ in 1...10 {\n      var x = 0.0\n      var y = 0.0\n\n      for _ in 1...1<<i {\n        y = 1.0 - 2.0 * y * x\n        x = a - x * x\n      }\n\n      a -= x / y\n    }\n\n    d = (a1 - a2) / (a - a1)\n    d1 = d\n    (a1, a2) = (a, a1)\n\n    print(String(format: \"%2d   \u00a0%.8f\", i, d))\n  }\n}\n\nfeigenbaum()\n", "target": "max_it = 13\nmax_it_j = 10\na1 = 1.0\na2 = 0.0\nd1 = 3.2\na = 0.0\n\nprint \" i       d\"\nfor i in range(2, max_it + 1):\n    a = a1 + (a1 - a2) / d1\n    for j in range(1, max_it_j + 1):\n        x = 0.0\n        y = 0.0\n        for k in range(1, (1 << i) + 1):\n            y = 1.0 - 2.0 * y * x\n            x = a - x * x\n        a = a - x / y\n    d = (a1 - a2) / (a - a1)\n    print(\"{0:2d}    {1:.8f}\".format(i, d))\n    d1 = d\n    a2 = a1\n    a1 = a\n"}
{"id": 112041, "name": "Feigenbaum constant calculation", "source": "Translate Swift to Python: import Foundation\n\nfunc feigenbaum(iterations: Int = 13) {\n  var a = 0.0\n  var a1 = 1.0\n  var a2 = 0.0\n  var d = 0.0\n  var d1 = 3.2\n\n  print(\" i       d\")\n\n  for i in 2...iterations {\n    a = a1 + (a1 - a2) / d1\n\n    for _ in 1...10 {\n      var x = 0.0\n      var y = 0.0\n\n      for _ in 1...1<<i {\n        y = 1.0 - 2.0 * y * x\n        x = a - x * x\n      }\n\n      a -= x / y\n    }\n\n    d = (a1 - a2) / (a - a1)\n    d1 = d\n    (a1, a2) = (a, a1)\n\n    print(String(format: \"%2d   \u00a0%.8f\", i, d))\n  }\n}\n\nfeigenbaum()\n", "target": "max_it = 13\nmax_it_j = 10\na1 = 1.0\na2 = 0.0\nd1 = 3.2\na = 0.0\n\nprint \" i       d\"\nfor i in range(2, max_it + 1):\n    a = a1 + (a1 - a2) / d1\n    for j in range(1, max_it_j + 1):\n        x = 0.0\n        y = 0.0\n        for k in range(1, (1 << i) + 1):\n            y = 1.0 - 2.0 * y * x\n            x = a - x * x\n        a = a - x / y\n    d = (a1 - a2) / (a - a1)\n    print(\"{0:2d}    {1:.8f}\".format(i, d))\n    d1 = d\n    a2 = a1\n    a1 = a\n"}
{"id": 112450, "name": "Stair-climbing puzzle", "source": "Translate Swift to C#: func step_up() {\n  while !step() {\n    step_up()\n  }\n}\n", "target": "void step_up() {\n    while (!step()) step_up();\n}\n"}
{"id": 112451, "name": "Stair-climbing puzzle", "source": "Translate Swift to C#: func step_up() {\n  while !step() {\n    step_up()\n  }\n}\n", "target": "void step_up() {\n    while (!step()) step_up();\n}\n"}
{"id": 112454, "name": "Stair-climbing puzzle", "source": "Translate Swift to Java: func step_up() {\n  while !step() {\n    step_up()\n  }\n}\n", "target": "public void stepUp() {\n  while (!step()) stepUp();\n}\n"}
{"id": 112455, "name": "Stair-climbing puzzle", "source": "Translate Swift to Java: func step_up() {\n  while !step() {\n    step_up()\n  }\n}\n", "target": "public void stepUp() {\n  while (!step()) stepUp();\n}\n"}
{"id": 112456, "name": "Stair-climbing puzzle", "source": "Translate Swift to Python: func step_up() {\n  while !step() {\n    step_up()\n  }\n}\n", "target": "def step_up1():\n  \n  deficit = 1\n  while deficit > 0:\n    if step():\n      deficit -= 1\n    else:\n      deficit += 1\n"}
{"id": 112457, "name": "Stair-climbing puzzle", "source": "Translate Swift to Python: func step_up() {\n  while !step() {\n    step_up()\n  }\n}\n", "target": "def step_up1():\n  \n  deficit = 1\n  while deficit > 0:\n    if step():\n      deficit -= 1\n    else:\n      deficit += 1\n"}
{"id": 112619, "name": "Hostname", "source": "Translate Swift to Java: print(ProcessInfo.processInfo.hostName)\n", "target": "import java.net.*;\nclass DiscoverHostName {\n public static void main(final String[] args) {\n  try {\n   System.out.println(InetAddress.getLocalHost().getHostName());\n  } catch (UnknownHostException e) { \n  }\n }\n}\n"}
{"id": 112863, "name": "Guess the number", "source": "Translate Swift to C#: import Cocoa\n\nvar found = false\nlet randomNum = Int(arc4random_uniform(10) + 1)\n\nprintln(\"Guess a number between 1 and 10\\n\")\nwhile (!found) {\n    var fh = NSFileHandle.fileHandleWithStandardInput()\n    \n    println(\"Enter a number: \")\n    let data = fh.availableData\n    var str = NSString(data: data, encoding: NSUTF8StringEncoding)\n    if (str?.integerValue == randomNum) {\n        found = true\n        println(\"Well guessed!\")\n    }\n}\n", "target": "using System;\n\nclass GuessTheNumberGame\n{\n    static void Main()\n    {\n        int randomNumber = new Random().Next(1, 11);\n        \n        Console.WriteLine(\"I'm thinking of a number between 1 and 10. Can you guess it?\");\n        while(true)\n        {\n            Console.Write(\"Guess: \");\n            if (int.Parse(Console.ReadLine()) == randomNumber)\n                break;\n            Console.WriteLine(\"That's not it. Guess again.\");\n        }\n        Console.WriteLine(\"Congrats!! You guessed right!\");\n    }\n};\n"}
{"id": 112865, "name": "Guess the number", "source": "Translate Swift to Java: import Cocoa\n\nvar found = false\nlet randomNum = Int(arc4random_uniform(10) + 1)\n\nprintln(\"Guess a number between 1 and 10\\n\")\nwhile (!found) {\n    var fh = NSFileHandle.fileHandleWithStandardInput()\n    \n    println(\"Enter a number: \")\n    let data = fh.availableData\n    var str = NSString(data: data, encoding: NSUTF8StringEncoding)\n    if (str?.integerValue == randomNum) {\n        found = true\n        println(\"Well guessed!\")\n    }\n}\n", "target": "public class Guessing {\n    public static void main(String[] args) throws NumberFormatException{\n        int n = (int)(Math.random() * 10 + 1);\n        System.out.print(\"Guess the number between 1 and 10: \");\n        while(Integer.parseInt(System.console().readLine()) != n){\n            System.out.print(\"Wrong! Guess again: \");\n        }\n        System.out.println(\"Well guessed!\");\n    }\n}\n"}
{"id": 112866, "name": "Guess the number", "source": "Translate Swift to Python: import Cocoa\n\nvar found = false\nlet randomNum = Int(arc4random_uniform(10) + 1)\n\nprintln(\"Guess a number between 1 and 10\\n\")\nwhile (!found) {\n    var fh = NSFileHandle.fileHandleWithStandardInput()\n    \n    println(\"Enter a number: \")\n    let data = fh.availableData\n    var str = NSString(data: data, encoding: NSUTF8StringEncoding)\n    if (str?.integerValue == randomNum) {\n        found = true\n        println(\"Well guessed!\")\n    }\n}\n", "target": "import random\nt,g=random.randint(1,10),0\ng=int(input(\"Guess a number that's between 1 and 10: \"))\nwhile t!=g:g=int(input(\"Guess again! \"))\nprint(\"That's right!\")\n"}
{"id": 113193, "name": "Set", "source": "Translate Swift to C#: var s1 : Set<Int> = [1, 2, 3, 4]\nlet s2 : Set<Int> = [3, 4, 5, 6]\nprintln(s1.union(s2)) \nprintln(s1.intersect(s2)) \nprintln(s1.subtract(s2)) \nprintln(s1.isSubsetOf(s1)) \nprintln(Set<Int>([3, 1]).isSubsetOf(s1)) \nprintln(s1.isStrictSubsetOf(s1)) \nprintln(Set<Int>([3, 1]).isStrictSubsetOf(s1)) \nprintln(Set<Int>([3, 2, 4, 1]) == s1) \nprintln(s1 == s2) \nprintln(s1.contains(2)) \nprintln(Set<Int>([1, 2, 3, 4]).isSupersetOf(s1)) \nprintln(Set<Int>([1, 2, 3, 4]).isStrictSupersetOf(s1)) \nprintln(Set<Int>([1, 2, 3, 4, 5]).isStrictSupersetOf(s1)) \nprintln(s1.exclusiveOr(s2)) \nprintln(s1.count) \ns1.insert(99) \nprintln(s1) \ns1.remove(99) \nprintln(s1) \ns1.unionInPlace(s2) \nprintln(s1) \ns1.subtractInPlace(s2) \nprintln(s1) \ns1.exclusiveOrInPlace(s2) \nprintln(s1) \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass Program\n{\n    static void PrintCollection(IEnumerable<int> x)\n    {\n        Console.WriteLine(string.Join(\" \", x));\n    }\n    static void Main(string[] args)\n    {\n        Console.OutputEncoding = Encoding.UTF8;\n        Console.WriteLine(\"Set creation\");\n        var A = new HashSet<int> { 4, 12, 14, 17, 18, 19, 20 };\n        var B = new HashSet<int> { 2, 5, 8, 11, 12, 13, 17, 18, 20 };\n\n        PrintCollection(A);\n        PrintCollection(B);\n\n        Console.WriteLine(\"Test m \u2208 S -- \\\"m is an element in set S\\\"\");\n        Console.WriteLine(\"14 is an element in set A: {0}\", A.Contains(14));\n        Console.WriteLine(\"15 is an element in set A: {0}\", A.Contains(15));\n\n        Console.WriteLine(\"A \u222a B -- union; a set of all elements either in set A or in set B.\");\n        var aUb = A.Union(B);\n        PrintCollection(aUb);\n\n        Console.WriteLine(\"A \u2216 B -- difference; a set of all elements in set A, except those in set B.\");\n        var aDb = A.Except(B);\n        PrintCollection(aDb);\n\n        Console.WriteLine(\"A \u2286 B -- subset; true if every element in set A is also in set B.\");\n        Console.WriteLine(A.IsSubsetOf(B));\n        var C = new HashSet<int> { 14, 17, 18 };\n        Console.WriteLine(C.IsSubsetOf(A));\n\n        Console.WriteLine(\"A = B -- equality; true if every element of set A is in set B and vice versa.\");\n        Console.WriteLine(A.SetEquals(B));\n        var D = new HashSet<int> { 4, 12, 14, 17, 18, 19, 20 };\n        Console.WriteLine(A.SetEquals(D));\n\n        Console.WriteLine(\"If A \u2286 B, but A \u2260 B, then A is called a true or proper subset of B, written A \u2282 B or A \u228a B\");\n        Console.WriteLine(A.IsProperSubsetOf(B));\n        Console.WriteLine(C.IsProperSubsetOf(A));\n\n        Console.WriteLine(\"Modify a mutable set.  (Add 10 to A; remove 12 from B).\");\n        A.Add(10);\n        B.Remove(12);\n        PrintCollection(A);\n        PrintCollection(B);\n\n        Console.ReadKey();\n    }\n}\n"}
{"id": 113195, "name": "Set", "source": "Translate Swift to Java: var s1 : Set<Int> = [1, 2, 3, 4]\nlet s2 : Set<Int> = [3, 4, 5, 6]\nprintln(s1.union(s2)) \nprintln(s1.intersect(s2)) \nprintln(s1.subtract(s2)) \nprintln(s1.isSubsetOf(s1)) \nprintln(Set<Int>([3, 1]).isSubsetOf(s1)) \nprintln(s1.isStrictSubsetOf(s1)) \nprintln(Set<Int>([3, 1]).isStrictSubsetOf(s1)) \nprintln(Set<Int>([3, 2, 4, 1]) == s1) \nprintln(s1 == s2) \nprintln(s1.contains(2)) \nprintln(Set<Int>([1, 2, 3, 4]).isSupersetOf(s1)) \nprintln(Set<Int>([1, 2, 3, 4]).isStrictSupersetOf(s1)) \nprintln(Set<Int>([1, 2, 3, 4, 5]).isStrictSupersetOf(s1)) \nprintln(s1.exclusiveOr(s2)) \nprintln(s1.count) \ns1.insert(99) \nprintln(s1) \ns1.remove(99) \nprintln(s1) \ns1.unionInPlace(s2) \nprintln(s1) \ns1.subtractInPlace(s2) \nprintln(s1) \ns1.exclusiveOrInPlace(s2) \nprintln(s1) \n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class Sets {\n    public static void main(String[] args){\n        Set<Integer> a = new TreeSet<>();\n        \n        \n        \n        \n        \n        Set<Integer> b = new TreeSet<>();\n        Set<Integer> c = new TreeSet<>();\n        Set<Integer> d = new TreeSet<>();\n        \n        a.addAll(Arrays.asList(1, 2, 3, 4, 5));\n        b.addAll(Arrays.asList(2, 3, 4, 5, 6, 8));\n        c.addAll(Arrays.asList(2, 3, 4));\n        d.addAll(Arrays.asList(2, 3, 4));\n        System.out.println(\"a: \" + a);\n        System.out.println(\"b: \" + b);\n        System.out.println(\"c: \" + c);\n        System.out.println(\"d: \" + d);\n        \n        System.out.println(\"2 in a: \" + a.contains(2));\n        System.out.println(\"6 in a: \" + a.contains(6));\n        \n        Set<Integer> ab = new TreeSet<>();\n        ab.addAll(a);\n        ab.addAll(b);\n        System.out.println(\"a union b: \" + ab);\n        \n        Set<Integer> a_b = new TreeSet<>();\n        a_b.addAll(a);\n        a_b.removeAll(b);\n        System.out.println(\"a - b: \" + a_b);\n        \n        System.out.println(\"c subset of a: \" + a.containsAll(c));\n        \n        \n        System.out.println(\"c = d: \" + c.equals(d));\n        System.out.println(\"d = c: \" + d.equals(c));\n        \n        Set<Integer> aib = new TreeSet<>();\n        aib.addAll(a);\n        aib.retainAll(b);\n        System.out.println(\"a intersect b: \" + aib);\n        \n        System.out.println(\"add 7 to a: \" + a.add(7));\n        System.out.println(\"add 2 to a again: \" + a.add(2));\n        \n        \n        Set<Integer> empty = Collections.EMPTY_SET; \n        \n        empty.isEmpty(); \n        empty.size();\n        Collections.disjoint(a, b); \n        Collections.unmodifiableSet(a); \n    }\n}\n"}
{"id": 113196, "name": "Set", "source": "Translate Swift to Python: var s1 : Set<Int> = [1, 2, 3, 4]\nlet s2 : Set<Int> = [3, 4, 5, 6]\nprintln(s1.union(s2)) \nprintln(s1.intersect(s2)) \nprintln(s1.subtract(s2)) \nprintln(s1.isSubsetOf(s1)) \nprintln(Set<Int>([3, 1]).isSubsetOf(s1)) \nprintln(s1.isStrictSubsetOf(s1)) \nprintln(Set<Int>([3, 1]).isStrictSubsetOf(s1)) \nprintln(Set<Int>([3, 2, 4, 1]) == s1) \nprintln(s1 == s2) \nprintln(s1.contains(2)) \nprintln(Set<Int>([1, 2, 3, 4]).isSupersetOf(s1)) \nprintln(Set<Int>([1, 2, 3, 4]).isStrictSupersetOf(s1)) \nprintln(Set<Int>([1, 2, 3, 4, 5]).isStrictSupersetOf(s1)) \nprintln(s1.exclusiveOr(s2)) \nprintln(s1.count) \ns1.insert(99) \nprintln(s1) \ns1.remove(99) \nprintln(s1) \ns1.unionInPlace(s2) \nprintln(s1) \ns1.subtractInPlace(s2) \nprintln(s1) \ns1.exclusiveOrInPlace(s2) \nprintln(s1) \n", "target": ">>> s1, s2 = {1, 2, 3, 4}, {3, 4, 5, 6}\n>>> s1 | s2 \n{1, 2, 3, 4, 5, 6}\n>>> s1 & s2 \n{3, 4}\n>>> s1 - s2 \n{1, 2}\n>>> s1 < s1 \nFalse\n>>> {3, 1} < s1 \nTrue\n>>> s1 <= s1 \nTrue\n>>> {3, 1} <= s1 \nTrue\n>>> {3, 2, 4, 1} == s1 \nTrue\n>>> s1 == s2 \nFalse\n>>> 2 in s1 \nTrue\n>>> 10 not in s1 \nTrue\n>>> {1, 2, 3, 4, 5} > s1 \nTrue\n>>> {1, 2, 3, 4} > s1 \nFalse\n>>> {1, 2, 3, 4} >= s1 \nTrue\n>>> s1 ^ s2 \n{1, 2, 5, 6}\n>>> len(s1) \n4\n>>> s1.add(99) \n>>> s1\n{99, 1, 2, 3, 4}\n>>> s1.discard(99) \n>>> s1\n{1, 2, 3, 4}\n>>> s1 |= s2 \n>>> s1\n{1, 2, 3, 4, 5, 6}\n>>> s1 -= s2 \n>>> s1\n{1, 2}\n>>> s1 ^= s2 \n>>> s1\n{1, 2, 3, 4, 5, 6}\n>>>\n"}
{"id": 113527, "name": "Parsing_RPN calculator algorithm", "source": "Translate Swift to C#: let opa = [\n    \"^\": (prec: 4, rAssoc: true),\n    \"*\": (prec: 3, rAssoc: false),\n    \"/\": (prec: 3, rAssoc: false),\n    \"+\": (prec: 2, rAssoc: false),\n    \"-\": (prec: 2, rAssoc: false),\n]\n\nfunc rpn(tokens: [String]) -> [String] {\n    var rpn : [String] = []\n    var stack : [String] = [] \n\n    for tok in tokens {\n        switch tok {\n        case \"(\":\n            stack += [tok] \n        case \")\":\n            while !stack.isEmpty {\n                let op = stack.removeLast() \n                if op == \"(\" {\n                    break \n                } else {\n                    rpn += [op] \n                }\n            }\n        default:\n            if let o1 = opa[tok] { \n                for op in stack.reverse() {\n                    if let o2 = opa[op] {\n                        if !(o1.prec > o2.prec || (o1.prec == o2.prec && o1.rAssoc)) {\n                            \n                            rpn += [stack.removeLast()] \n                            continue\n                        }\n                    }\n                    break\n                }\n\n                stack += [tok] \n            } else { \n                rpn += [tok] \n            }\n        }\n    }\n\n    return rpn + stack.reverse()\n}\n\nfunc parseInfix(e: String) -> String {\n    let tokens = e.characters.split{ $0 == \" \" }.map(String.init)\n    return rpn(tokens).joinWithSeparator(\" \")\n}\n\nvar input : String\n\ninput = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\"\n\"infix: \\(input)\"\n\"postfix: \\(parseInfix(input))\"\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Globalization;\nusing System.Threading;\n\nnamespace RPNEvaluator\n{\n    class RPNEvaluator\n    {\n        static void Main(string[] args)\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n\n            string rpn = \"3 4 2 * 1 5 - 2 3 ^ ^ / +\";\n            Console.WriteLine(\"{0}\\n\", rpn);\n\n            decimal result = CalculateRPN(rpn);\n            Console.WriteLine(\"\\nResult is {0}\", result);\n        }\n\n        static decimal CalculateRPN(string rpn)\n        {\n            string[] rpnTokens = rpn.Split(' ');\n            Stack<decimal> stack = new Stack<decimal>();\n            decimal number = decimal.Zero;\n\n            foreach (string token in rpnTokens)\n            {\n                if (decimal.TryParse(token, out number))\n                {\n                    stack.Push(number);\n                }\n                else\n                {\n                    switch (token)\n                    {\n                        case \"^\":\n                        case \"pow\":\n                            {\n                                number = stack.Pop();\n                                stack.Push((decimal)Math.Pow((double)stack.Pop(), (double)number));\n                                break;\n                            }\n                        case \"ln\":\n                            {\n                                stack.Push((decimal)Math.Log((double)stack.Pop(), Math.E));\n                                break;\n                            }\n                        case \"sqrt\":\n                            {\n                                stack.Push((decimal)Math.Sqrt((double)stack.Pop()));\n                                break;\n                            }\n                        case \"*\":\n                            {\n                                stack.Push(stack.Pop() * stack.Pop());\n                                break;\n                            }\n                        case \"/\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() / number);\n                                break;\n                            }\n                        case \"+\":\n                            {\n                                stack.Push(stack.Pop() + stack.Pop());\n                                break;\n                            }\n                        case \"-\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() - number);\n                                break;\n                            }\n                        default:\n                            Console.WriteLine(\"Error in CalculateRPN(string) Method!\");\n                            break;\n                    }\n                }\n                PrintState(stack);\n            }\n\n            return stack.Pop();\n        }\n\n        static void PrintState(Stack<decimal> stack)\n        {\n            decimal[] arr = stack.ToArray();\n\n            for (int i = arr.Length - 1; i >= 0; i--)\n            {\n                Console.Write(\"{0,-8:F3}\", arr[i]);\n            }\n            \n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 113528, "name": "Parsing_RPN calculator algorithm", "source": "Translate Swift to C#: let opa = [\n    \"^\": (prec: 4, rAssoc: true),\n    \"*\": (prec: 3, rAssoc: false),\n    \"/\": (prec: 3, rAssoc: false),\n    \"+\": (prec: 2, rAssoc: false),\n    \"-\": (prec: 2, rAssoc: false),\n]\n\nfunc rpn(tokens: [String]) -> [String] {\n    var rpn : [String] = []\n    var stack : [String] = [] \n\n    for tok in tokens {\n        switch tok {\n        case \"(\":\n            stack += [tok] \n        case \")\":\n            while !stack.isEmpty {\n                let op = stack.removeLast() \n                if op == \"(\" {\n                    break \n                } else {\n                    rpn += [op] \n                }\n            }\n        default:\n            if let o1 = opa[tok] { \n                for op in stack.reverse() {\n                    if let o2 = opa[op] {\n                        if !(o1.prec > o2.prec || (o1.prec == o2.prec && o1.rAssoc)) {\n                            \n                            rpn += [stack.removeLast()] \n                            continue\n                        }\n                    }\n                    break\n                }\n\n                stack += [tok] \n            } else { \n                rpn += [tok] \n            }\n        }\n    }\n\n    return rpn + stack.reverse()\n}\n\nfunc parseInfix(e: String) -> String {\n    let tokens = e.characters.split{ $0 == \" \" }.map(String.init)\n    return rpn(tokens).joinWithSeparator(\" \")\n}\n\nvar input : String\n\ninput = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\"\n\"infix: \\(input)\"\n\"postfix: \\(parseInfix(input))\"\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Globalization;\nusing System.Threading;\n\nnamespace RPNEvaluator\n{\n    class RPNEvaluator\n    {\n        static void Main(string[] args)\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n\n            string rpn = \"3 4 2 * 1 5 - 2 3 ^ ^ / +\";\n            Console.WriteLine(\"{0}\\n\", rpn);\n\n            decimal result = CalculateRPN(rpn);\n            Console.WriteLine(\"\\nResult is {0}\", result);\n        }\n\n        static decimal CalculateRPN(string rpn)\n        {\n            string[] rpnTokens = rpn.Split(' ');\n            Stack<decimal> stack = new Stack<decimal>();\n            decimal number = decimal.Zero;\n\n            foreach (string token in rpnTokens)\n            {\n                if (decimal.TryParse(token, out number))\n                {\n                    stack.Push(number);\n                }\n                else\n                {\n                    switch (token)\n                    {\n                        case \"^\":\n                        case \"pow\":\n                            {\n                                number = stack.Pop();\n                                stack.Push((decimal)Math.Pow((double)stack.Pop(), (double)number));\n                                break;\n                            }\n                        case \"ln\":\n                            {\n                                stack.Push((decimal)Math.Log((double)stack.Pop(), Math.E));\n                                break;\n                            }\n                        case \"sqrt\":\n                            {\n                                stack.Push((decimal)Math.Sqrt((double)stack.Pop()));\n                                break;\n                            }\n                        case \"*\":\n                            {\n                                stack.Push(stack.Pop() * stack.Pop());\n                                break;\n                            }\n                        case \"/\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() / number);\n                                break;\n                            }\n                        case \"+\":\n                            {\n                                stack.Push(stack.Pop() + stack.Pop());\n                                break;\n                            }\n                        case \"-\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() - number);\n                                break;\n                            }\n                        default:\n                            Console.WriteLine(\"Error in CalculateRPN(string) Method!\");\n                            break;\n                    }\n                }\n                PrintState(stack);\n            }\n\n            return stack.Pop();\n        }\n\n        static void PrintState(Stack<decimal> stack)\n        {\n            decimal[] arr = stack.ToArray();\n\n            for (int i = arr.Length - 1; i >= 0; i--)\n            {\n                Console.Write(\"{0,-8:F3}\", arr[i]);\n            }\n            \n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 113531, "name": "Parsing_RPN calculator algorithm", "source": "Translate Swift to Java: let opa = [\n    \"^\": (prec: 4, rAssoc: true),\n    \"*\": (prec: 3, rAssoc: false),\n    \"/\": (prec: 3, rAssoc: false),\n    \"+\": (prec: 2, rAssoc: false),\n    \"-\": (prec: 2, rAssoc: false),\n]\n\nfunc rpn(tokens: [String]) -> [String] {\n    var rpn : [String] = []\n    var stack : [String] = [] \n\n    for tok in tokens {\n        switch tok {\n        case \"(\":\n            stack += [tok] \n        case \")\":\n            while !stack.isEmpty {\n                let op = stack.removeLast() \n                if op == \"(\" {\n                    break \n                } else {\n                    rpn += [op] \n                }\n            }\n        default:\n            if let o1 = opa[tok] { \n                for op in stack.reverse() {\n                    if let o2 = opa[op] {\n                        if !(o1.prec > o2.prec || (o1.prec == o2.prec && o1.rAssoc)) {\n                            \n                            rpn += [stack.removeLast()] \n                            continue\n                        }\n                    }\n                    break\n                }\n\n                stack += [tok] \n            } else { \n                rpn += [tok] \n            }\n        }\n    }\n\n    return rpn + stack.reverse()\n}\n\nfunc parseInfix(e: String) -> String {\n    let tokens = e.characters.split{ $0 == \" \" }.map(String.init)\n    return rpn(tokens).joinWithSeparator(\" \")\n}\n\nvar input : String\n\ninput = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\"\n\"infix: \\(input)\"\n\"postfix: \\(parseInfix(input))\"\n", "target": "grammar rpnC ;\n\n\n\n\n\n@members {\nStack<Double> s = new Stack<Double>();\n}\nrpn\t:\t(WS* (num|op) (WS | WS* NEWLINE {System.out.println(s.pop());}))*;\nnum\t:\t'-'? Digit+ ('.' Digit+)? {s.push(Double.parseDouble($num.text));};\nDigit\t:\t'0'..'9';\nop\t:\t'-' {double x = s.pop(); s.push(s.pop() - x);}\n\t|\t'/' {double x = s.pop(); s.push(s.pop() / x);}\n\t|\t'*' {s.push(s.pop() * s.pop());}\n\t|\t'^' {double x = s.pop(); s.push(Math.pow(s.pop(), x));}\n\t|\t'+' {s.push(s.pop() + s.pop());};\nWS\t:\t(' ' | '\\t'){skip()};\nNEWLINE\t:\t'\\r'? '\\n';\n"}
{"id": 113532, "name": "Parsing_RPN calculator algorithm", "source": "Translate Swift to Java: let opa = [\n    \"^\": (prec: 4, rAssoc: true),\n    \"*\": (prec: 3, rAssoc: false),\n    \"/\": (prec: 3, rAssoc: false),\n    \"+\": (prec: 2, rAssoc: false),\n    \"-\": (prec: 2, rAssoc: false),\n]\n\nfunc rpn(tokens: [String]) -> [String] {\n    var rpn : [String] = []\n    var stack : [String] = [] \n\n    for tok in tokens {\n        switch tok {\n        case \"(\":\n            stack += [tok] \n        case \")\":\n            while !stack.isEmpty {\n                let op = stack.removeLast() \n                if op == \"(\" {\n                    break \n                } else {\n                    rpn += [op] \n                }\n            }\n        default:\n            if let o1 = opa[tok] { \n                for op in stack.reverse() {\n                    if let o2 = opa[op] {\n                        if !(o1.prec > o2.prec || (o1.prec == o2.prec && o1.rAssoc)) {\n                            \n                            rpn += [stack.removeLast()] \n                            continue\n                        }\n                    }\n                    break\n                }\n\n                stack += [tok] \n            } else { \n                rpn += [tok] \n            }\n        }\n    }\n\n    return rpn + stack.reverse()\n}\n\nfunc parseInfix(e: String) -> String {\n    let tokens = e.characters.split{ $0 == \" \" }.map(String.init)\n    return rpn(tokens).joinWithSeparator(\" \")\n}\n\nvar input : String\n\ninput = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\"\n\"infix: \\(input)\"\n\"postfix: \\(parseInfix(input))\"\n", "target": "grammar rpnC ;\n\n\n\n\n\n@members {\nStack<Double> s = new Stack<Double>();\n}\nrpn\t:\t(WS* (num|op) (WS | WS* NEWLINE {System.out.println(s.pop());}))*;\nnum\t:\t'-'? Digit+ ('.' Digit+)? {s.push(Double.parseDouble($num.text));};\nDigit\t:\t'0'..'9';\nop\t:\t'-' {double x = s.pop(); s.push(s.pop() - x);}\n\t|\t'/' {double x = s.pop(); s.push(s.pop() / x);}\n\t|\t'*' {s.push(s.pop() * s.pop());}\n\t|\t'^' {double x = s.pop(); s.push(Math.pow(s.pop(), x));}\n\t|\t'+' {s.push(s.pop() + s.pop());};\nWS\t:\t(' ' | '\\t'){skip()};\nNEWLINE\t:\t'\\r'? '\\n';\n"}
{"id": 113533, "name": "Parsing_RPN calculator algorithm", "source": "Translate Swift to Python: let opa = [\n    \"^\": (prec: 4, rAssoc: true),\n    \"*\": (prec: 3, rAssoc: false),\n    \"/\": (prec: 3, rAssoc: false),\n    \"+\": (prec: 2, rAssoc: false),\n    \"-\": (prec: 2, rAssoc: false),\n]\n\nfunc rpn(tokens: [String]) -> [String] {\n    var rpn : [String] = []\n    var stack : [String] = [] \n\n    for tok in tokens {\n        switch tok {\n        case \"(\":\n            stack += [tok] \n        case \")\":\n            while !stack.isEmpty {\n                let op = stack.removeLast() \n                if op == \"(\" {\n                    break \n                } else {\n                    rpn += [op] \n                }\n            }\n        default:\n            if let o1 = opa[tok] { \n                for op in stack.reverse() {\n                    if let o2 = opa[op] {\n                        if !(o1.prec > o2.prec || (o1.prec == o2.prec && o1.rAssoc)) {\n                            \n                            rpn += [stack.removeLast()] \n                            continue\n                        }\n                    }\n                    break\n                }\n\n                stack += [tok] \n            } else { \n                rpn += [tok] \n            }\n        }\n    }\n\n    return rpn + stack.reverse()\n}\n\nfunc parseInfix(e: String) -> String {\n    let tokens = e.characters.split{ $0 == \" \" }.map(String.init)\n    return rpn(tokens).joinWithSeparator(\" \")\n}\n\nvar input : String\n\ninput = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\"\n\"infix: \\(input)\"\n\"postfix: \\(parseInfix(input))\"\n", "target": "def op_pow(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a ** b )\ndef op_mul(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a * b )\ndef op_div(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a / b )\ndef op_add(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a + b )\ndef op_sub(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a - b )\ndef op_num(stack, num):\n    stack.append( num )\n    \nops = {\n '^': op_pow,\n '*': op_mul,\n '/': op_div,\n '+': op_add,\n '-': op_sub,\n }\n\ndef get_input(inp = None):\n    'Inputs an expression and returns list of tokens'\n    \n    if inp is None:\n        inp = input('expression: ')\n    tokens = inp.strip().split()\n    return tokens\n\ndef rpn_calc(tokens):\n    stack = []\n    table = ['TOKEN,ACTION,STACK'.split(',')]\n    for token in tokens:\n        if token in ops:\n            action = 'Apply op to top of stack'\n            ops[token](stack)\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n        else:\n            action = 'Push num onto top of stack'\n            op_num(stack, eval(token))\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n    return table\n\nif __name__ == '__main__':\n    rpn = '3 4 2 * 1 5 - 2 3 ^ ^ / +'\n    print( 'For RPN expression: %r\\n' % rpn )\n    rp = rpn_calc(get_input(rpn))\n    maxcolwidths = [max(len(y) for y in x) for x in zip(*rp)]\n    row = rp[0]\n    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n    for row in rp[1:]:\n        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n\n    print('\\n The final output value is: %r' % rp[-1][2])\n"}
{"id": 113534, "name": "Parsing_RPN calculator algorithm", "source": "Translate Swift to Python: let opa = [\n    \"^\": (prec: 4, rAssoc: true),\n    \"*\": (prec: 3, rAssoc: false),\n    \"/\": (prec: 3, rAssoc: false),\n    \"+\": (prec: 2, rAssoc: false),\n    \"-\": (prec: 2, rAssoc: false),\n]\n\nfunc rpn(tokens: [String]) -> [String] {\n    var rpn : [String] = []\n    var stack : [String] = [] \n\n    for tok in tokens {\n        switch tok {\n        case \"(\":\n            stack += [tok] \n        case \")\":\n            while !stack.isEmpty {\n                let op = stack.removeLast() \n                if op == \"(\" {\n                    break \n                } else {\n                    rpn += [op] \n                }\n            }\n        default:\n            if let o1 = opa[tok] { \n                for op in stack.reverse() {\n                    if let o2 = opa[op] {\n                        if !(o1.prec > o2.prec || (o1.prec == o2.prec && o1.rAssoc)) {\n                            \n                            rpn += [stack.removeLast()] \n                            continue\n                        }\n                    }\n                    break\n                }\n\n                stack += [tok] \n            } else { \n                rpn += [tok] \n            }\n        }\n    }\n\n    return rpn + stack.reverse()\n}\n\nfunc parseInfix(e: String) -> String {\n    let tokens = e.characters.split{ $0 == \" \" }.map(String.init)\n    return rpn(tokens).joinWithSeparator(\" \")\n}\n\nvar input : String\n\ninput = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\"\n\"infix: \\(input)\"\n\"postfix: \\(parseInfix(input))\"\n", "target": "def op_pow(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a ** b )\ndef op_mul(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a * b )\ndef op_div(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a / b )\ndef op_add(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a + b )\ndef op_sub(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a - b )\ndef op_num(stack, num):\n    stack.append( num )\n    \nops = {\n '^': op_pow,\n '*': op_mul,\n '/': op_div,\n '+': op_add,\n '-': op_sub,\n }\n\ndef get_input(inp = None):\n    'Inputs an expression and returns list of tokens'\n    \n    if inp is None:\n        inp = input('expression: ')\n    tokens = inp.strip().split()\n    return tokens\n\ndef rpn_calc(tokens):\n    stack = []\n    table = ['TOKEN,ACTION,STACK'.split(',')]\n    for token in tokens:\n        if token in ops:\n            action = 'Apply op to top of stack'\n            ops[token](stack)\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n        else:\n            action = 'Push num onto top of stack'\n            op_num(stack, eval(token))\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n    return table\n\nif __name__ == '__main__':\n    rpn = '3 4 2 * 1 5 - 2 3 ^ ^ / +'\n    print( 'For RPN expression: %r\\n' % rpn )\n    rp = rpn_calc(get_input(rpn))\n    maxcolwidths = [max(len(y) for y in x) for x in zip(*rp)]\n    row = rp[0]\n    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n    for row in rp[1:]:\n        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n\n    print('\\n The final output value is: %r' % rp[-1][2])\n"}
{"id": 113842, "name": "Run-length encoding", "source": "Translate Swift to C#: import Foundation\n\n\nfunc encode(input: String) -> [(Int, Character)] {\n    return input.characters.reduce([(Int, Character)]()) {\n        if $0.last?.1 == $1 { var r = $0; r[r.count - 1].0++; return r }\n        return $0 + [(1, $1)]\n    }\n}\n\n\nfunc decode(encoded: [(Int, Character)]) -> String {\n    return encoded.reduce(\"\") { $0 + String(count: $1.0, repeatedValue: $1.1) }\n}\n", "target": "using System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nusing static System.Linq.Enumerable;\n\nnamespace RunLengthEncoding\n{\n    static class Program\n    {\n          public static string Encode(string input) => input.Length ==0 ? \"\" : input.Skip(1)\n            .Aggregate((t:input[0].ToString(),o:Empty<string>()),\n               (a,c)=>a.t[0]==c ? (a.t+c,a.o) : (c.ToString(),a.o.Append(a.t)),\n               a=>a.o.Append(a.t).Select(p => (key: p.Length, chr: p[0])))\n            .Select(p=> $\"{p.key}{p.chr}\")\n            .StringConcat();\n\n        public static string Decode(string input) => input\n            .Aggregate((t: \"\", o: Empty<string>()), (a, c) => !char.IsDigit(c) ? (\"\", a.o.Append(a.t+c)) : (a.t + c,a.o)).o \n            .Select(p => new string(p.Last(), int.Parse(string.Concat(p.Where(char.IsDigit)))))\n            .StringConcat();\n\n        private static string StringConcat(this IEnumerable<string> seq) => string.Concat(seq);\n        \n        public static void Main(string[] args)\n        {\n            const string  raw = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n            const string encoded = \"12W1B12W3B24W1B14W\";\n\n            WriteLine($\"raw = {raw}\");\n            WriteLine($\"encoded = {encoded}\");\n            WriteLine($\"Encode(raw) = encoded = {Encode(raw)}\");\n            WriteLine($\"Decode(encode) = {Decode(encoded)}\");\n            WriteLine($\"Decode(Encode(raw)) = {Decode(Encode(raw)) == raw}\");\n            ReadLine();\n        }\n    }\n}\n"}
{"id": 113844, "name": "Run-length encoding", "source": "Translate Swift to Java: import Foundation\n\n\nfunc encode(input: String) -> [(Int, Character)] {\n    return input.characters.reduce([(Int, Character)]()) {\n        if $0.last?.1 == $1 { var r = $0; r[r.count - 1].0++; return r }\n        return $0 + [(1, $1)]\n    }\n}\n\n\nfunc decode(encoded: [(Int, Character)]) -> String {\n    return encoded.reduce(\"\") { $0 + String(count: $1.0, repeatedValue: $1.1) }\n}\n", "target": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\npublic class RunLengthEncoding {\n\n    public static String encode(String source) {\n        StringBuffer dest = new StringBuffer();\n        for (int i = 0; i < source.length(); i++) {\n            int runLength = 1;\n            while (i+1 < source.length() && source.charAt(i) == source.charAt(i+1)) {\n                runLength++;\n                i++;\n            }\n            dest.append(runLength);\n            dest.append(source.charAt(i));\n        }\n        return dest.toString();\n    }\n\n    public static String decode(String source) {\n        StringBuffer dest = new StringBuffer();\n        Pattern pattern = Pattern.compile(\"[0-9]+|[a-zA-Z]\");\n        Matcher matcher = pattern.matcher(source);\n        while (matcher.find()) {\n            int number = Integer.parseInt(matcher.group());\n            matcher.find();\n            while (number-- != 0) {\n                dest.append(matcher.group());\n            }\n        }\n        return dest.toString();\n    }\n\n    public static void main(String[] args) {\n        String example = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n        System.out.println(encode(example));\n        System.out.println(decode(\"1W1B1W1B1W1B1W1B1W1B1W1B1W1B\"));\n    }\n}\n"}
{"id": 113845, "name": "Run-length encoding", "source": "Translate Swift to Python: import Foundation\n\n\nfunc encode(input: String) -> [(Int, Character)] {\n    return input.characters.reduce([(Int, Character)]()) {\n        if $0.last?.1 == $1 { var r = $0; r[r.count - 1].0++; return r }\n        return $0 + [(1, $1)]\n    }\n}\n\n\nfunc decode(encoded: [(Int, Character)]) -> String {\n    return encoded.reduce(\"\") { $0 + String(count: $1.0, repeatedValue: $1.1) }\n}\n", "target": "def encode(input_string):\n    count = 1\n    prev = None\n    lst = []\n    for character in input_string:\n        if character != prev:\n            if prev:\n                entry = (prev, count)\n                lst.append(entry)\n            count = 1\n            prev = character\n        else:\n            count += 1\n    else:\n        try:\n            entry = (character, count)\n            lst.append(entry)\n            return (lst, 0)\n        except Exception as e:\n            print(\"Exception encountered {e}\".format(e=e)) \n            return (e, 1)\n \ndef decode(lst):\n    q = []\n    for character, count in lst:\n        q.append(character * count)\n    return ''.join(q)\n \n\nvalue = encode(\"aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa\")\nif value[1] == 0:\n    print(\"Encoded value is {}\".format(value[0]))\n    decode(value[0])\n"}
{"id": 114115, "name": "Anonymous recursion", "source": "Translate Swift to C#: let fib: Int -> Int = {\n  func f(n: Int) -> Int {\n    assert(n >= 0, \"fib: no negative numbers\")\n    return n < 2 ? 1 : f(n-1) + f(n-2)\n  }\n  return f\n}()\n\nprint(fib(8))\n", "target": "static int Fib(int n)\n{\n    if (n < 0) throw new ArgumentException(\"Must be non negativ\", \"n\");\n \n    Func<int, int> fib = null; \n    fib = p => p > 1 ? fib(p - 2) + fib(p - 1) : p;\n    return fib(n);\n}\n"}
{"id": 114117, "name": "Anonymous recursion", "source": "Translate Swift to Java: let fib: Int -> Int = {\n  func f(n: Int) -> Int {\n    assert(n >= 0, \"fib: no negative numbers\")\n    return n < 2 ? 1 : f(n-1) + f(n-2)\n  }\n  return f\n}()\n\nprint(fib(8))\n", "target": "public static long fib(int n) {\n    if (n < 0)\n        throw new IllegalArgumentException(\"n can not be a negative number\");\n\n    return new Object() {\n        private long fibInner(int n) {\n            return (n < 2) ? n : (fibInner(n - 1) + fibInner(n - 2));\n        }\n    }.fibInner(n);\n}\n"}
{"id": 114118, "name": "Anonymous recursion", "source": "Translate Swift to Python: let fib: Int -> Int = {\n  func f(n: Int) -> Int {\n    assert(n >= 0, \"fib: no negative numbers\")\n    return n < 2 ? 1 : f(n-1) + f(n-2)\n  }\n  return f\n}()\n\nprint(fib(8))\n", "target": ">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))\n>>> fib = lambda f: lambda n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2)))\n>>> [ Y(fib)(i) for i in range(-2, 10) ]\n[None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n"}
{"id": 114627, "name": "A+B", "source": "Translate Swift to C#: import Foundation\n\nlet input = NSFileHandle.fileHandleWithStandardInput()\n\nlet data = input.availableData\nlet str = NSString(data: data, encoding: NSUTF8StringEncoding)!\n\nlet nums = str.componentsSeparatedByString(\" \")\nlet a = (nums[0] as String).toInt()!\nlet b = (nums[1] as String).toInt()!\n\nprint(\" \\(a + b)\")\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(Console.ReadLine().Split().Select(int.Parse).Sum());\n    }\n}\n"}
{"id": 114628, "name": "A+B", "source": "Translate Swift to C#: import Foundation\n\nlet input = NSFileHandle.fileHandleWithStandardInput()\n\nlet data = input.availableData\nlet str = NSString(data: data, encoding: NSUTF8StringEncoding)!\n\nlet nums = str.componentsSeparatedByString(\" \")\nlet a = (nums[0] as String).toInt()!\nlet b = (nums[1] as String).toInt()!\n\nprint(\" \\(a + b)\")\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(Console.ReadLine().Split().Select(int.Parse).Sum());\n    }\n}\n"}
{"id": 114631, "name": "A+B", "source": "Translate Swift to Java: import Foundation\n\nlet input = NSFileHandle.fileHandleWithStandardInput()\n\nlet data = input.availableData\nlet str = NSString(data: data, encoding: NSUTF8StringEncoding)!\n\nlet nums = str.componentsSeparatedByString(\" \")\nlet a = (nums[0] as String).toInt()!\nlet b = (nums[1] as String).toInt()!\n\nprint(\" \\(a + b)\")\n", "target": "import java.util.Scanner;\n\npublic class Sum2 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in); \n        System.out.println(in.nextInt() + in.nextInt()); \n    }\n}\n"}
{"id": 114632, "name": "A+B", "source": "Translate Swift to Java: import Foundation\n\nlet input = NSFileHandle.fileHandleWithStandardInput()\n\nlet data = input.availableData\nlet str = NSString(data: data, encoding: NSUTF8StringEncoding)!\n\nlet nums = str.componentsSeparatedByString(\" \")\nlet a = (nums[0] as String).toInt()!\nlet b = (nums[1] as String).toInt()!\n\nprint(\" \\(a + b)\")\n", "target": "import java.util.Scanner;\n\npublic class Sum2 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in); \n        System.out.println(in.nextInt() + in.nextInt()); \n    }\n}\n"}
{"id": 114633, "name": "A+B", "source": "Translate Swift to Python: import Foundation\n\nlet input = NSFileHandle.fileHandleWithStandardInput()\n\nlet data = input.availableData\nlet str = NSString(data: data, encoding: NSUTF8StringEncoding)!\n\nlet nums = str.componentsSeparatedByString(\" \")\nlet a = (nums[0] as String).toInt()!\nlet b = (nums[1] as String).toInt()!\n\nprint(\" \\(a + b)\")\n", "target": "try: raw_input\nexcept: raw_input = input\n\nprint(sum(map(int, raw_input().split())))\n"}
{"id": 114634, "name": "A+B", "source": "Translate Swift to Python: import Foundation\n\nlet input = NSFileHandle.fileHandleWithStandardInput()\n\nlet data = input.availableData\nlet str = NSString(data: data, encoding: NSUTF8StringEncoding)!\n\nlet nums = str.componentsSeparatedByString(\" \")\nlet a = (nums[0] as String).toInt()!\nlet b = (nums[1] as String).toInt()!\n\nprint(\" \\(a + b)\")\n", "target": "try: raw_input\nexcept: raw_input = input\n\nprint(sum(map(int, raw_input().split())))\n"}
{"id": 114972, "name": "Leap year", "source": "Translate Swift to C#: func isLeapYear(year: Int) -> Bool {\n    return year.isMultiple(of: 100) ? year.isMultiple(of: 400) : year.isMultiple(of: 4)\n}\n\n[1900, 1994, 1996, 1997, 2000].forEach { year in\n    print(\"\\(year): \\(isLeapYear(year: year) ? \"YES\" : \"NO\")\")\n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        foreach (var year in new[] { 1900, 1994, 1996, DateTime.Now.Year })\n        {\n            Console.WriteLine(\"{0} is {1}a leap year.\",\n                              year,\n                              DateTime.IsLeapYear(year) ? string.Empty : \"not \");\n        }\n    }\n}\n"}
{"id": 114974, "name": "Leap year", "source": "Translate Swift to Java: func isLeapYear(year: Int) -> Bool {\n    return year.isMultiple(of: 100) ? year.isMultiple(of: 400) : year.isMultiple(of: 4)\n}\n\n[1900, 1994, 1996, 1997, 2000].forEach { year in\n    print(\"\\(year): \\(isLeapYear(year: year) ? \"YES\" : \"NO\")\")\n}\n", "target": "import java.util.GregorianCalendar;\nimport java.text.MessageFormat;\n\npublic class Leapyear{\n        public static void main(String[] argv){\n                int[] yrs = {1800,1900,1994,1998,1999,2000,2001,2004,2100};\n                GregorianCalendar cal = new GregorianCalendar();\n                for(int year : yrs){\n                        System.err.println(MessageFormat.format(\"The year {0,number,#} is leaper: {1} / {2}.\",\n                                                                 year, cal.isLeapYear(year), isLeapYear(year)));\n                }\n\n        }\n        public static boolean isLeapYear(int year){\n                return (year % 100 == 0) ? (year % 400 == 0) : (year % 4 == 0);\n        }\n}\n"}
{"id": 114975, "name": "Leap year", "source": "Translate Swift to Python: func isLeapYear(year: Int) -> Bool {\n    return year.isMultiple(of: 100) ? year.isMultiple(of: 400) : year.isMultiple(of: 4)\n}\n\n[1900, 1994, 1996, 1997, 2000].forEach { year in\n    print(\"\\(year): \\(isLeapYear(year: year) ? \"YES\" : \"NO\")\")\n}\n", "target": "import calendar\ncalendar.isleap(year)\n"}
{"id": 115493, "name": "Doubly-linked list_Element insertion", "source": "Translate Swift to C#: typealias NodePtr<T> = UnsafeMutablePointer<Node<T>>\n\nclass Node<T> {\n  var value: T\n  fileprivate var prev: NodePtr<T>?\n  fileprivate var next: NodePtr<T>?\n\n  init(value: T, prev: NodePtr<T>? = nil, next: NodePtr<T>? = nil) {\n    self.value = value\n    self.prev = prev\n    self.next = next\n  }\n}\n\n@discardableResult\nfunc insert<T>(_ val: T, after: Node<T>? = nil, list: NodePtr<T>? = nil) -> NodePtr<T> {\n  let node = NodePtr<T>.allocate(capacity: 1)\n\n  node.initialize(to: Node(value: val))\n\n  var n = list\n\n  while n != nil {\n    if n?.pointee !== after {\n      n = n?.pointee.next\n\n      continue\n    }\n\n    node.pointee.prev = n\n    node.pointee.next = n?.pointee.next\n    n?.pointee.next?.pointee.prev = node\n    n?.pointee.next = node\n\n    break\n  }\n\n  return node\n}\n\n\nlet list = insert(1)\n\n\ninsert(2, after: list.pointee, list: list)\n\n\ninsert(3, after: list.pointee, list: list)\n", "target": "static void InsertAfter(Link prev, int i)\n{\n    if (prev.next != null)\n    {\n        prev.next.prev = new Link() { item = i, prev = prev, next = prev.next };\n        prev.next = prev.next.prev;\n    }\n    else\n        prev.next = new Link() { item = i, prev = prev };\n}\n"}
{"id": 115495, "name": "Doubly-linked list_Element insertion", "source": "Translate Swift to Java: typealias NodePtr<T> = UnsafeMutablePointer<Node<T>>\n\nclass Node<T> {\n  var value: T\n  fileprivate var prev: NodePtr<T>?\n  fileprivate var next: NodePtr<T>?\n\n  init(value: T, prev: NodePtr<T>? = nil, next: NodePtr<T>? = nil) {\n    self.value = value\n    self.prev = prev\n    self.next = next\n  }\n}\n\n@discardableResult\nfunc insert<T>(_ val: T, after: Node<T>? = nil, list: NodePtr<T>? = nil) -> NodePtr<T> {\n  let node = NodePtr<T>.allocate(capacity: 1)\n\n  node.initialize(to: Node(value: val))\n\n  var n = list\n\n  while n != nil {\n    if n?.pointee !== after {\n      n = n?.pointee.next\n\n      continue\n    }\n\n    node.pointee.prev = n\n    node.pointee.next = n?.pointee.next\n    n?.pointee.next?.pointee.prev = node\n    n?.pointee.next = node\n\n    break\n  }\n\n  return node\n}\n\n\nlet list = insert(1)\n\n\ninsert(2, after: list.pointee, list: list)\n\n\ninsert(3, after: list.pointee, list: list)\n", "target": "import java.util.LinkedList;\n\n@SuppressWarnings(\"serial\")\npublic class DoublyLinkedListInsertion<T> extends LinkedList<T> {\n   \n    public static void main(String[] args) {\n        DoublyLinkedListInsertion<String> list = new DoublyLinkedListInsertion<String>();\n        list.addFirst(\"Add First 1\");\n        list.addFirst(\"Add First 2\");\n        list.addFirst(\"Add First 3\");\n        list.addFirst(\"Add First 4\");\n        list.addFirst(\"Add First 5\");\n        traverseList(list);\n        \n        list.addAfter(\"Add First 3\", \"Add New\");\n        traverseList(list);\n    }\n    \n    \n    public void addAfter(T after, T element) {\n        int index = indexOf(after);\n        if ( index >= 0 ) {\n            add(index + 1, element);\n        }\n        else {\n            addLast(element);\n        }\n    }\n    \n    private static void traverseList(LinkedList<String> list) {\n        System.out.println(\"Traverse List:\");\n        for ( int i = 0 ; i < list.size() ; i++ ) {\n            System.out.printf(\"Element number %d - Element value = '%s'%n\", i, list.get(i));\n        }\n        System.out.println();\n    }\n    \n}\n"}
{"id": 115496, "name": "Doubly-linked list_Element insertion", "source": "Translate Swift to Python: typealias NodePtr<T> = UnsafeMutablePointer<Node<T>>\n\nclass Node<T> {\n  var value: T\n  fileprivate var prev: NodePtr<T>?\n  fileprivate var next: NodePtr<T>?\n\n  init(value: T, prev: NodePtr<T>? = nil, next: NodePtr<T>? = nil) {\n    self.value = value\n    self.prev = prev\n    self.next = next\n  }\n}\n\n@discardableResult\nfunc insert<T>(_ val: T, after: Node<T>? = nil, list: NodePtr<T>? = nil) -> NodePtr<T> {\n  let node = NodePtr<T>.allocate(capacity: 1)\n\n  node.initialize(to: Node(value: val))\n\n  var n = list\n\n  while n != nil {\n    if n?.pointee !== after {\n      n = n?.pointee.next\n\n      continue\n    }\n\n    node.pointee.prev = n\n    node.pointee.next = n?.pointee.next\n    n?.pointee.next?.pointee.prev = node\n    n?.pointee.next = node\n\n    break\n  }\n\n  return node\n}\n\n\nlet list = insert(1)\n\n\ninsert(2, after: list.pointee, list: list)\n\n\ninsert(3, after: list.pointee, list: list)\n", "target": "def insert(anchor, new):\n    new.next = anchor.next\n    new.prev = anchor\n    anchor.next.prev = new\n    anchor.next = new\n"}
{"id": 115945, "name": "N-queens problem", "source": "Translate Swift to C#: \tlet maxn = 31\n\n\tfunc nq(n: Int) -> Int {\n\t    var cols = Array(repeating: 0, count: maxn)\n\t    var diagl = Array(repeating: 0, count: maxn)\n\t    var diagr = Array(repeating: 0, count: maxn)\n\t    var posibs = Array(repeating: 0, count: maxn)\n\t    var num = 0\n\t    for q0 in 0...n-3 {\n\t\tfor q1 in q0+2...n-1 {\n\t\t    let bit0: Int = 1<<q0\n\t\t    let bit1: Int = 1<<q1\n\t\t    var d: Int = 0\n\t\t    cols[0] = bit0 | bit1 | (-1<<n)\n\t\t    diagl[0] = (bit0<<1|bit1)<<1\n\t\t    diagr[0] = (bit0>>1|bit1)>>1\n\n\t\t    var posib: Int = ~(cols[0] | diagl[0] | diagr[0])\n\n\t\t    while (d >= 0) {\n\t\t\twhile(posib != 0) {\n\t\t\t    let bit: Int = posib & -posib\n\t\t\t    let ncols: Int = cols[d] | bit\n\t\t\t    let ndiagl: Int = (diagl[d] | bit) << 1;\n\t\t\t    let ndiagr: Int = (diagr[d] | bit) >> 1;\n\t\t\t    let nposib: Int = ~(ncols | ndiagl | ndiagr);\n\t\t\t    posib^=bit\n\t\t\t    num += (ncols == -1 ? 1 : 0)\n\t\t\t    if (nposib != 0){\n\t\t\t\tif(posib != 0) {\n\t\t\t\t    posibs[d] = posib\n\t\t\t\t    d += 1\n\t\t\t\t}\n\t\t\t\tcols[d] = ncols\n\t\t\t\tdiagl[d] = ndiagl\n\t\t\t\tdiagr[d] = ndiagr\n\t\t\t\tposib = nposib\n\t\t\t    }\n\t\t\t}\n\t\t\td -= 1\n\t\t\tposib = d<0 ? n : posibs[d]\n\n\t\t    }\n\t\t}\n\n\t    }\n\t    return num*2\n\t}\n\tif(CommandLine.arguments.count == 2) {\n\n\t    let board_size: Int = Int(CommandLine.arguments[1])!\n\t    print (\"Number of solutions for board size \\(board_size) is: \\(nq(n:board_size))\")\n\n\t} else {\n\t    print(\"Usage: 8q <n>\")\n\t}\n", "target": "using System.Collections.Generic;\nusing static System.Linq.Enumerable;\nusing static System.Console;\nusing static System.Math;\n\nnamespace N_Queens\n{\n    static class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = 8;\n            var cols = Range(0, n);\n            var combs = cols.Combinations(2).Select(pairs=> pairs.ToArray());\n            var solved = from v in cols.Permutations().Select(p => p.ToArray())\n                         where combs.All(c => Abs(v[c[0]] - v[c[1]]) != Abs(c[0] - c[1]))\n                         select v;\n            \n            WriteLine($\"{n}-queens has {solved.Count()} solutions\");\n            WriteLine(\"Position is row, value is column:-\");\n            var first = string.Join(\" \", solved.First());\n            WriteLine($\"First Solution: {first}\");\n            Read();\n        }\n\n        \n        public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values)\n        {\n            if (values.Count() == 1)\n                return values.ToSingleton();\n\n            return values.SelectMany(v => Permutations(values.Except(v.ToSingleton())), (v, p) => p.Prepend(v));\n        }\n\n        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq) =>\n            seq.Aggregate(Empty<T>().ToSingleton(), (a, b) => a.Concat(a.Select(x => x.Append(b))));\n\n        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq, int numItems) =>\n            seq.Combinations().Where(s => s.Count() == numItems);\n\n        public static IEnumerable<T> ToSingleton<T>(this T item) { yield return item; }\n    }\n}\n"}
{"id": 115946, "name": "N-queens problem", "source": "Translate Swift to C#: \tlet maxn = 31\n\n\tfunc nq(n: Int) -> Int {\n\t    var cols = Array(repeating: 0, count: maxn)\n\t    var diagl = Array(repeating: 0, count: maxn)\n\t    var diagr = Array(repeating: 0, count: maxn)\n\t    var posibs = Array(repeating: 0, count: maxn)\n\t    var num = 0\n\t    for q0 in 0...n-3 {\n\t\tfor q1 in q0+2...n-1 {\n\t\t    let bit0: Int = 1<<q0\n\t\t    let bit1: Int = 1<<q1\n\t\t    var d: Int = 0\n\t\t    cols[0] = bit0 | bit1 | (-1<<n)\n\t\t    diagl[0] = (bit0<<1|bit1)<<1\n\t\t    diagr[0] = (bit0>>1|bit1)>>1\n\n\t\t    var posib: Int = ~(cols[0] | diagl[0] | diagr[0])\n\n\t\t    while (d >= 0) {\n\t\t\twhile(posib != 0) {\n\t\t\t    let bit: Int = posib & -posib\n\t\t\t    let ncols: Int = cols[d] | bit\n\t\t\t    let ndiagl: Int = (diagl[d] | bit) << 1;\n\t\t\t    let ndiagr: Int = (diagr[d] | bit) >> 1;\n\t\t\t    let nposib: Int = ~(ncols | ndiagl | ndiagr);\n\t\t\t    posib^=bit\n\t\t\t    num += (ncols == -1 ? 1 : 0)\n\t\t\t    if (nposib != 0){\n\t\t\t\tif(posib != 0) {\n\t\t\t\t    posibs[d] = posib\n\t\t\t\t    d += 1\n\t\t\t\t}\n\t\t\t\tcols[d] = ncols\n\t\t\t\tdiagl[d] = ndiagl\n\t\t\t\tdiagr[d] = ndiagr\n\t\t\t\tposib = nposib\n\t\t\t    }\n\t\t\t}\n\t\t\td -= 1\n\t\t\tposib = d<0 ? n : posibs[d]\n\n\t\t    }\n\t\t}\n\n\t    }\n\t    return num*2\n\t}\n\tif(CommandLine.arguments.count == 2) {\n\n\t    let board_size: Int = Int(CommandLine.arguments[1])!\n\t    print (\"Number of solutions for board size \\(board_size) is: \\(nq(n:board_size))\")\n\n\t} else {\n\t    print(\"Usage: 8q <n>\")\n\t}\n", "target": "using System.Collections.Generic;\nusing static System.Linq.Enumerable;\nusing static System.Console;\nusing static System.Math;\n\nnamespace N_Queens\n{\n    static class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = 8;\n            var cols = Range(0, n);\n            var combs = cols.Combinations(2).Select(pairs=> pairs.ToArray());\n            var solved = from v in cols.Permutations().Select(p => p.ToArray())\n                         where combs.All(c => Abs(v[c[0]] - v[c[1]]) != Abs(c[0] - c[1]))\n                         select v;\n            \n            WriteLine($\"{n}-queens has {solved.Count()} solutions\");\n            WriteLine(\"Position is row, value is column:-\");\n            var first = string.Join(\" \", solved.First());\n            WriteLine($\"First Solution: {first}\");\n            Read();\n        }\n\n        \n        public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values)\n        {\n            if (values.Count() == 1)\n                return values.ToSingleton();\n\n            return values.SelectMany(v => Permutations(values.Except(v.ToSingleton())), (v, p) => p.Prepend(v));\n        }\n\n        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq) =>\n            seq.Aggregate(Empty<T>().ToSingleton(), (a, b) => a.Concat(a.Select(x => x.Append(b))));\n\n        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq, int numItems) =>\n            seq.Combinations().Where(s => s.Count() == numItems);\n\n        public static IEnumerable<T> ToSingleton<T>(this T item) { yield return item; }\n    }\n}\n"}
{"id": 115949, "name": "N-queens problem", "source": "Translate Swift to Java: \tlet maxn = 31\n\n\tfunc nq(n: Int) -> Int {\n\t    var cols = Array(repeating: 0, count: maxn)\n\t    var diagl = Array(repeating: 0, count: maxn)\n\t    var diagr = Array(repeating: 0, count: maxn)\n\t    var posibs = Array(repeating: 0, count: maxn)\n\t    var num = 0\n\t    for q0 in 0...n-3 {\n\t\tfor q1 in q0+2...n-1 {\n\t\t    let bit0: Int = 1<<q0\n\t\t    let bit1: Int = 1<<q1\n\t\t    var d: Int = 0\n\t\t    cols[0] = bit0 | bit1 | (-1<<n)\n\t\t    diagl[0] = (bit0<<1|bit1)<<1\n\t\t    diagr[0] = (bit0>>1|bit1)>>1\n\n\t\t    var posib: Int = ~(cols[0] | diagl[0] | diagr[0])\n\n\t\t    while (d >= 0) {\n\t\t\twhile(posib != 0) {\n\t\t\t    let bit: Int = posib & -posib\n\t\t\t    let ncols: Int = cols[d] | bit\n\t\t\t    let ndiagl: Int = (diagl[d] | bit) << 1;\n\t\t\t    let ndiagr: Int = (diagr[d] | bit) >> 1;\n\t\t\t    let nposib: Int = ~(ncols | ndiagl | ndiagr);\n\t\t\t    posib^=bit\n\t\t\t    num += (ncols == -1 ? 1 : 0)\n\t\t\t    if (nposib != 0){\n\t\t\t\tif(posib != 0) {\n\t\t\t\t    posibs[d] = posib\n\t\t\t\t    d += 1\n\t\t\t\t}\n\t\t\t\tcols[d] = ncols\n\t\t\t\tdiagl[d] = ndiagl\n\t\t\t\tdiagr[d] = ndiagr\n\t\t\t\tposib = nposib\n\t\t\t    }\n\t\t\t}\n\t\t\td -= 1\n\t\t\tposib = d<0 ? n : posibs[d]\n\n\t\t    }\n\t\t}\n\n\t    }\n\t    return num*2\n\t}\n\tif(CommandLine.arguments.count == 2) {\n\n\t    let board_size: Int = Int(CommandLine.arguments[1])!\n\t    print (\"Number of solutions for board size \\(board_size) is: \\(nq(n:board_size))\")\n\n\t} else {\n\t    print(\"Usage: 8q <n>\")\n\t}\n", "target": "public class NQueens {\n\n  private static int[] b = new int[8];\n  private static int s = 0;\n\n  static boolean unsafe(int y) {\n    int x = b[y];\n    for (int i = 1; i <= y; i++) {\n      int t = b[y - i];\n      if (t == x ||\n          t == x - i ||\n          t == x + i) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public static void putboard() {\n    System.out.println(\"\\n\\nSolution \" + (++s));\n    for (int y = 0; y < 8; y++) {\n      for (int x = 0; x < 8; x++) {\n        System.out.print((b[y] == x) ? \"|Q\" : \"|_\");\n      }\n      System.out.println(\"|\");\n    }\n  }\n\n  public static void main(String[] args) {\n    int y = 0;\n    b[0] = -1;\n    while (y >= 0) {\n      do {\n        b[y]++;\n      } while ((b[y] < 8) && unsafe(y));\n      if (b[y] < 8) {\n        if (y < 7) {\n          b[++y] = -1;\n        } else {\n          putboard();\n        }\n      } else {\n        y--;\n      }\n    }\n  }\n}\n"}
{"id": 115950, "name": "N-queens problem", "source": "Translate Swift to Java: \tlet maxn = 31\n\n\tfunc nq(n: Int) -> Int {\n\t    var cols = Array(repeating: 0, count: maxn)\n\t    var diagl = Array(repeating: 0, count: maxn)\n\t    var diagr = Array(repeating: 0, count: maxn)\n\t    var posibs = Array(repeating: 0, count: maxn)\n\t    var num = 0\n\t    for q0 in 0...n-3 {\n\t\tfor q1 in q0+2...n-1 {\n\t\t    let bit0: Int = 1<<q0\n\t\t    let bit1: Int = 1<<q1\n\t\t    var d: Int = 0\n\t\t    cols[0] = bit0 | bit1 | (-1<<n)\n\t\t    diagl[0] = (bit0<<1|bit1)<<1\n\t\t    diagr[0] = (bit0>>1|bit1)>>1\n\n\t\t    var posib: Int = ~(cols[0] | diagl[0] | diagr[0])\n\n\t\t    while (d >= 0) {\n\t\t\twhile(posib != 0) {\n\t\t\t    let bit: Int = posib & -posib\n\t\t\t    let ncols: Int = cols[d] | bit\n\t\t\t    let ndiagl: Int = (diagl[d] | bit) << 1;\n\t\t\t    let ndiagr: Int = (diagr[d] | bit) >> 1;\n\t\t\t    let nposib: Int = ~(ncols | ndiagl | ndiagr);\n\t\t\t    posib^=bit\n\t\t\t    num += (ncols == -1 ? 1 : 0)\n\t\t\t    if (nposib != 0){\n\t\t\t\tif(posib != 0) {\n\t\t\t\t    posibs[d] = posib\n\t\t\t\t    d += 1\n\t\t\t\t}\n\t\t\t\tcols[d] = ncols\n\t\t\t\tdiagl[d] = ndiagl\n\t\t\t\tdiagr[d] = ndiagr\n\t\t\t\tposib = nposib\n\t\t\t    }\n\t\t\t}\n\t\t\td -= 1\n\t\t\tposib = d<0 ? n : posibs[d]\n\n\t\t    }\n\t\t}\n\n\t    }\n\t    return num*2\n\t}\n\tif(CommandLine.arguments.count == 2) {\n\n\t    let board_size: Int = Int(CommandLine.arguments[1])!\n\t    print (\"Number of solutions for board size \\(board_size) is: \\(nq(n:board_size))\")\n\n\t} else {\n\t    print(\"Usage: 8q <n>\")\n\t}\n", "target": "public class NQueens {\n\n  private static int[] b = new int[8];\n  private static int s = 0;\n\n  static boolean unsafe(int y) {\n    int x = b[y];\n    for (int i = 1; i <= y; i++) {\n      int t = b[y - i];\n      if (t == x ||\n          t == x - i ||\n          t == x + i) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public static void putboard() {\n    System.out.println(\"\\n\\nSolution \" + (++s));\n    for (int y = 0; y < 8; y++) {\n      for (int x = 0; x < 8; x++) {\n        System.out.print((b[y] == x) ? \"|Q\" : \"|_\");\n      }\n      System.out.println(\"|\");\n    }\n  }\n\n  public static void main(String[] args) {\n    int y = 0;\n    b[0] = -1;\n    while (y >= 0) {\n      do {\n        b[y]++;\n      } while ((b[y] < 8) && unsafe(y));\n      if (b[y] < 8) {\n        if (y < 7) {\n          b[++y] = -1;\n        } else {\n          putboard();\n        }\n      } else {\n        y--;\n      }\n    }\n  }\n}\n"}
{"id": 115951, "name": "N-queens problem", "source": "Translate Swift to Python: \tlet maxn = 31\n\n\tfunc nq(n: Int) -> Int {\n\t    var cols = Array(repeating: 0, count: maxn)\n\t    var diagl = Array(repeating: 0, count: maxn)\n\t    var diagr = Array(repeating: 0, count: maxn)\n\t    var posibs = Array(repeating: 0, count: maxn)\n\t    var num = 0\n\t    for q0 in 0...n-3 {\n\t\tfor q1 in q0+2...n-1 {\n\t\t    let bit0: Int = 1<<q0\n\t\t    let bit1: Int = 1<<q1\n\t\t    var d: Int = 0\n\t\t    cols[0] = bit0 | bit1 | (-1<<n)\n\t\t    diagl[0] = (bit0<<1|bit1)<<1\n\t\t    diagr[0] = (bit0>>1|bit1)>>1\n\n\t\t    var posib: Int = ~(cols[0] | diagl[0] | diagr[0])\n\n\t\t    while (d >= 0) {\n\t\t\twhile(posib != 0) {\n\t\t\t    let bit: Int = posib & -posib\n\t\t\t    let ncols: Int = cols[d] | bit\n\t\t\t    let ndiagl: Int = (diagl[d] | bit) << 1;\n\t\t\t    let ndiagr: Int = (diagr[d] | bit) >> 1;\n\t\t\t    let nposib: Int = ~(ncols | ndiagl | ndiagr);\n\t\t\t    posib^=bit\n\t\t\t    num += (ncols == -1 ? 1 : 0)\n\t\t\t    if (nposib != 0){\n\t\t\t\tif(posib != 0) {\n\t\t\t\t    posibs[d] = posib\n\t\t\t\t    d += 1\n\t\t\t\t}\n\t\t\t\tcols[d] = ncols\n\t\t\t\tdiagl[d] = ndiagl\n\t\t\t\tdiagr[d] = ndiagr\n\t\t\t\tposib = nposib\n\t\t\t    }\n\t\t\t}\n\t\t\td -= 1\n\t\t\tposib = d<0 ? n : posibs[d]\n\n\t\t    }\n\t\t}\n\n\t    }\n\t    return num*2\n\t}\n\tif(CommandLine.arguments.count == 2) {\n\n\t    let board_size: Int = Int(CommandLine.arguments[1])!\n\t    print (\"Number of solutions for board size \\(board_size) is: \\(nq(n:board_size))\")\n\n\t} else {\n\t    print(\"Usage: 8q <n>\")\n\t}\n", "target": "from itertools import permutations, product\n\nn = 8\ncols = range(n)\ni = 0  \n\nsolutions = [vec for vec in permutations(cols)\n             if n == len(set(vec[i] + i for i in cols))\n                  == len(set(vec[i] - i for i in cols))]\n\ndef setup():\n    size(400, 400)\n    textAlign(CENTER, CENTER)\n    textFont(createFont(\"DejaVu Sans\", 44))\n\ndef draw():\n    background(0)\n    w = width / n\n    for x, y in product(range(n), range(n)):\n        fill(255 * ((x + y) % 2))\n        square(x * w, y * w, w)\n        if solutions[i][y] == x:\n            fill(255 - 255 * ((x + y) % 2))\n            text(u'\u2655', w / 2 + x * w, w / 3 + y * w)\n\ndef keyPressed():  \n    global i\n    i = (i + 1) % len(solutions)\n"}
{"id": 115952, "name": "N-queens problem", "source": "Translate Swift to Python: \tlet maxn = 31\n\n\tfunc nq(n: Int) -> Int {\n\t    var cols = Array(repeating: 0, count: maxn)\n\t    var diagl = Array(repeating: 0, count: maxn)\n\t    var diagr = Array(repeating: 0, count: maxn)\n\t    var posibs = Array(repeating: 0, count: maxn)\n\t    var num = 0\n\t    for q0 in 0...n-3 {\n\t\tfor q1 in q0+2...n-1 {\n\t\t    let bit0: Int = 1<<q0\n\t\t    let bit1: Int = 1<<q1\n\t\t    var d: Int = 0\n\t\t    cols[0] = bit0 | bit1 | (-1<<n)\n\t\t    diagl[0] = (bit0<<1|bit1)<<1\n\t\t    diagr[0] = (bit0>>1|bit1)>>1\n\n\t\t    var posib: Int = ~(cols[0] | diagl[0] | diagr[0])\n\n\t\t    while (d >= 0) {\n\t\t\twhile(posib != 0) {\n\t\t\t    let bit: Int = posib & -posib\n\t\t\t    let ncols: Int = cols[d] | bit\n\t\t\t    let ndiagl: Int = (diagl[d] | bit) << 1;\n\t\t\t    let ndiagr: Int = (diagr[d] | bit) >> 1;\n\t\t\t    let nposib: Int = ~(ncols | ndiagl | ndiagr);\n\t\t\t    posib^=bit\n\t\t\t    num += (ncols == -1 ? 1 : 0)\n\t\t\t    if (nposib != 0){\n\t\t\t\tif(posib != 0) {\n\t\t\t\t    posibs[d] = posib\n\t\t\t\t    d += 1\n\t\t\t\t}\n\t\t\t\tcols[d] = ncols\n\t\t\t\tdiagl[d] = ndiagl\n\t\t\t\tdiagr[d] = ndiagr\n\t\t\t\tposib = nposib\n\t\t\t    }\n\t\t\t}\n\t\t\td -= 1\n\t\t\tposib = d<0 ? n : posibs[d]\n\n\t\t    }\n\t\t}\n\n\t    }\n\t    return num*2\n\t}\n\tif(CommandLine.arguments.count == 2) {\n\n\t    let board_size: Int = Int(CommandLine.arguments[1])!\n\t    print (\"Number of solutions for board size \\(board_size) is: \\(nq(n:board_size))\")\n\n\t} else {\n\t    print(\"Usage: 8q <n>\")\n\t}\n", "target": "from itertools import permutations, product\n\nn = 8\ncols = range(n)\ni = 0  \n\nsolutions = [vec for vec in permutations(cols)\n             if n == len(set(vec[i] + i for i in cols))\n                  == len(set(vec[i] - i for i in cols))]\n\ndef setup():\n    size(400, 400)\n    textAlign(CENTER, CENTER)\n    textFont(createFont(\"DejaVu Sans\", 44))\n\ndef draw():\n    background(0)\n    w = width / n\n    for x, y in product(range(n), range(n)):\n        fill(255 * ((x + y) % 2))\n        square(x * w, y * w, w)\n        if solutions[i][y] == x:\n            fill(255 - 255 * ((x + y) % 2))\n            text(u'\u2655', w / 2 + x * w, w / 3 + y * w)\n\ndef keyPressed():  \n    global i\n    i = (i + 1) % len(solutions)\n"}
{"id": 116313, "name": "Four bit adder", "source": "Translate Swift to C#: typealias FourBit = (Int, Int, Int, Int)\n\nfunc halfAdder(_ a: Int, _ b: Int) -> (Int, Int) {\n  return (a ^ b, a & b)\n}\n\nfunc fullAdder(_ a: Int, _ b: Int, carry: Int) -> (Int, Int) {\n  let (s0, c0) = halfAdder(a, b)\n  let (s1, c1) = halfAdder(s0, carry)\n\n  return (s1, c0 | c1)\n}\n\nfunc fourBitAdder(_ a: FourBit, _ b: FourBit) -> (FourBit, carry: Int) {\n  let (sum1, carry1) = halfAdder(a.3, b.3)\n  let (sum2, carry2) = fullAdder(a.2, b.2, carry: carry1)\n  let (sum3, carry3) = fullAdder(a.1, b.1, carry: carry2)\n  let (sum4, carryOut) = fullAdder(a.0, b.0, carry: carry3)\n\n  return ((sum4, sum3, sum2, sum1), carryOut)\n}\n\nlet a = (0, 1, 1, 0)\nlet b = (0, 1, 1, 0)\n\nprint(\"\\(a) + \\(b) = \\(fourBitAdder(a, b))\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCodeTasks.FourBitAdder\n{\n\tpublic struct BitAdderOutput\n\t{\n\t\tpublic bool S { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn \"S\" + ( S ? \"1\" : \"0\" ) + \"C\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct Nibble\n\t{\n\t\tpublic bool _1 { get; set; }\n\t\tpublic bool _2 { get; set; }\n\t\tpublic bool _3 { get; set; }\n\t\tpublic bool _4 { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn ( _4 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _3 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _2 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _1 ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct FourBitAdderOutput\n\t{\n\t\tpublic Nibble N { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn N.ToString ( ) + \"c\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\n\tpublic static class LogicGates\n\t{\n\t\t\n\t\tpublic static bool Not ( bool A ) { return !A; }\n\t\tpublic static bool And ( bool A, bool B ) { return A && B; }\n\t\tpublic static bool Or ( bool A, bool B ) { return A || B; }\n\n\t\t\n\t\tpublic static bool Xor ( bool A, bool B ) {\treturn Or ( And ( A, Not ( B ) ), ( And ( Not ( A ), B ) ) ); }\n\t}\n\n\tpublic static class ConstructiveBlocks\n\t{\n\t\tpublic static BitAdderOutput HalfAdder ( bool A, bool B )\n\t\t{\n\t\t\treturn new BitAdderOutput ( ) { S = LogicGates.Xor ( A, B ), C = LogicGates.And ( A, B ) };\n\t\t}\n\n\t\tpublic static BitAdderOutput FullAdder ( bool A, bool B, bool CI )\n\t\t{\n\t\t\tBitAdderOutput HA1 = HalfAdder ( CI, A );\n\t\t\tBitAdderOutput HA2 = HalfAdder ( HA1.S, B );\n\n\t\t\treturn new BitAdderOutput ( ) { S = HA2.S, C = LogicGates.Or ( HA1.C, HA2.C ) };\n\t\t}\n\n\t\tpublic static FourBitAdderOutput FourBitAdder ( Nibble A, Nibble B, bool CI )\n\t\t{\n\n\t\t\tBitAdderOutput FA1 = FullAdder ( A._1, B._1, CI );\n\t\t\tBitAdderOutput FA2 = FullAdder ( A._2, B._2, FA1.C );\n\t\t\tBitAdderOutput FA3 = FullAdder ( A._3, B._3, FA2.C );\n\t\t\tBitAdderOutput FA4 = FullAdder ( A._4, B._4, FA3.C );\n\n\t\t\treturn new FourBitAdderOutput ( ) { N = new Nibble ( ) { _1 = FA1.S, _2 = FA2.S, _3 = FA3.S, _4 = FA4.S }, C = FA4.C };\n\t\t}\n\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Four Bit Adder\" );\n\n\t\t\tfor ( int i = 0; i < 256; i++ )\n\t\t\t{\n\t\t\t\tNibble A = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tNibble B = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tif ( (i & 1) == 1)\n\t\t\t\t{\n\t\t\t\t\tA._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 2 ) == 2 )\n\t\t\t\t{\n\t\t\t\t\tA._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 4 ) == 4 )\n\t\t\t\t{\n\t\t\t\t\tA._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 8 ) == 8 )\n\t\t\t\t{\n\t\t\t\t\tA._4 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 16 ) == 16 )\n\t\t\t\t{\n\t\t\t\t\tB._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 32 ) == 32)\n\t\t\t\t{\n\t\t\t\t\tB._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 64 ) == 64 )\n\t\t\t\t{\n\t\t\t\t\tB._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 128 ) == 128 )\n\t\t\t\t{\n\t\t\t\t\tB._4 = true;\n\t\t\t\t}\n\n\t\t\t\tConsole.WriteLine ( \"{0} + {1} = {2}\", A.ToString ( ), B.ToString ( ), FourBitAdder( A, B, false ).ToString ( ) );\n\n\t\t\t}\n\n\t\t\tConsole.WriteLine ( );\n\t\t}\n\n\t}\n}\n"}
{"id": 116314, "name": "Four bit adder", "source": "Translate Swift to C#: typealias FourBit = (Int, Int, Int, Int)\n\nfunc halfAdder(_ a: Int, _ b: Int) -> (Int, Int) {\n  return (a ^ b, a & b)\n}\n\nfunc fullAdder(_ a: Int, _ b: Int, carry: Int) -> (Int, Int) {\n  let (s0, c0) = halfAdder(a, b)\n  let (s1, c1) = halfAdder(s0, carry)\n\n  return (s1, c0 | c1)\n}\n\nfunc fourBitAdder(_ a: FourBit, _ b: FourBit) -> (FourBit, carry: Int) {\n  let (sum1, carry1) = halfAdder(a.3, b.3)\n  let (sum2, carry2) = fullAdder(a.2, b.2, carry: carry1)\n  let (sum3, carry3) = fullAdder(a.1, b.1, carry: carry2)\n  let (sum4, carryOut) = fullAdder(a.0, b.0, carry: carry3)\n\n  return ((sum4, sum3, sum2, sum1), carryOut)\n}\n\nlet a = (0, 1, 1, 0)\nlet b = (0, 1, 1, 0)\n\nprint(\"\\(a) + \\(b) = \\(fourBitAdder(a, b))\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCodeTasks.FourBitAdder\n{\n\tpublic struct BitAdderOutput\n\t{\n\t\tpublic bool S { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn \"S\" + ( S ? \"1\" : \"0\" ) + \"C\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct Nibble\n\t{\n\t\tpublic bool _1 { get; set; }\n\t\tpublic bool _2 { get; set; }\n\t\tpublic bool _3 { get; set; }\n\t\tpublic bool _4 { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn ( _4 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _3 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _2 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _1 ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct FourBitAdderOutput\n\t{\n\t\tpublic Nibble N { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn N.ToString ( ) + \"c\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\n\tpublic static class LogicGates\n\t{\n\t\t\n\t\tpublic static bool Not ( bool A ) { return !A; }\n\t\tpublic static bool And ( bool A, bool B ) { return A && B; }\n\t\tpublic static bool Or ( bool A, bool B ) { return A || B; }\n\n\t\t\n\t\tpublic static bool Xor ( bool A, bool B ) {\treturn Or ( And ( A, Not ( B ) ), ( And ( Not ( A ), B ) ) ); }\n\t}\n\n\tpublic static class ConstructiveBlocks\n\t{\n\t\tpublic static BitAdderOutput HalfAdder ( bool A, bool B )\n\t\t{\n\t\t\treturn new BitAdderOutput ( ) { S = LogicGates.Xor ( A, B ), C = LogicGates.And ( A, B ) };\n\t\t}\n\n\t\tpublic static BitAdderOutput FullAdder ( bool A, bool B, bool CI )\n\t\t{\n\t\t\tBitAdderOutput HA1 = HalfAdder ( CI, A );\n\t\t\tBitAdderOutput HA2 = HalfAdder ( HA1.S, B );\n\n\t\t\treturn new BitAdderOutput ( ) { S = HA2.S, C = LogicGates.Or ( HA1.C, HA2.C ) };\n\t\t}\n\n\t\tpublic static FourBitAdderOutput FourBitAdder ( Nibble A, Nibble B, bool CI )\n\t\t{\n\n\t\t\tBitAdderOutput FA1 = FullAdder ( A._1, B._1, CI );\n\t\t\tBitAdderOutput FA2 = FullAdder ( A._2, B._2, FA1.C );\n\t\t\tBitAdderOutput FA3 = FullAdder ( A._3, B._3, FA2.C );\n\t\t\tBitAdderOutput FA4 = FullAdder ( A._4, B._4, FA3.C );\n\n\t\t\treturn new FourBitAdderOutput ( ) { N = new Nibble ( ) { _1 = FA1.S, _2 = FA2.S, _3 = FA3.S, _4 = FA4.S }, C = FA4.C };\n\t\t}\n\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Four Bit Adder\" );\n\n\t\t\tfor ( int i = 0; i < 256; i++ )\n\t\t\t{\n\t\t\t\tNibble A = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tNibble B = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tif ( (i & 1) == 1)\n\t\t\t\t{\n\t\t\t\t\tA._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 2 ) == 2 )\n\t\t\t\t{\n\t\t\t\t\tA._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 4 ) == 4 )\n\t\t\t\t{\n\t\t\t\t\tA._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 8 ) == 8 )\n\t\t\t\t{\n\t\t\t\t\tA._4 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 16 ) == 16 )\n\t\t\t\t{\n\t\t\t\t\tB._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 32 ) == 32)\n\t\t\t\t{\n\t\t\t\t\tB._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 64 ) == 64 )\n\t\t\t\t{\n\t\t\t\t\tB._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 128 ) == 128 )\n\t\t\t\t{\n\t\t\t\t\tB._4 = true;\n\t\t\t\t}\n\n\t\t\t\tConsole.WriteLine ( \"{0} + {1} = {2}\", A.ToString ( ), B.ToString ( ), FourBitAdder( A, B, false ).ToString ( ) );\n\n\t\t\t}\n\n\t\t\tConsole.WriteLine ( );\n\t\t}\n\n\t}\n}\n"}
{"id": 116315, "name": "Four bit adder", "source": "Translate Swift to Java: typealias FourBit = (Int, Int, Int, Int)\n\nfunc halfAdder(_ a: Int, _ b: Int) -> (Int, Int) {\n  return (a ^ b, a & b)\n}\n\nfunc fullAdder(_ a: Int, _ b: Int, carry: Int) -> (Int, Int) {\n  let (s0, c0) = halfAdder(a, b)\n  let (s1, c1) = halfAdder(s0, carry)\n\n  return (s1, c0 | c1)\n}\n\nfunc fourBitAdder(_ a: FourBit, _ b: FourBit) -> (FourBit, carry: Int) {\n  let (sum1, carry1) = halfAdder(a.3, b.3)\n  let (sum2, carry2) = fullAdder(a.2, b.2, carry: carry1)\n  let (sum3, carry3) = fullAdder(a.1, b.1, carry: carry2)\n  let (sum4, carryOut) = fullAdder(a.0, b.0, carry: carry3)\n\n  return ((sum4, sum3, sum2, sum1), carryOut)\n}\n\nlet a = (0, 1, 1, 0)\nlet b = (0, 1, 1, 0)\n\nprint(\"\\(a) + \\(b) = \\(fourBitAdder(a, b))\")\n", "target": "public class GateLogic\n{\n  \n  public interface OneInputGate\n  {  boolean eval(boolean input);  }\n  \n  public interface TwoInputGate\n  {  boolean eval(boolean input1, boolean input2);  }\n  \n  public interface MultiGate\n  {  boolean[] eval(boolean... inputs);  }\n  \n  \n  public static OneInputGate NOT = new OneInputGate() {\n    public boolean eval(boolean input)\n    {  return !input;  }\n  };\n  \n  \n  public static TwoInputGate AND = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 && input2;  }\n  };\n  \n  \n  public static TwoInputGate OR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 || input2;  }\n  };\n  \n  \n  public static TwoInputGate XOR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {\n      return OR.eval(\n               AND.eval(input1, NOT.eval(input2)),\n               AND.eval(NOT.eval(input1), input2)\n             );\n    }\n  };\n  \n  \n  public static MultiGate HALF_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 2)\n        throw new IllegalArgumentException();\n      return new boolean[] {\n        XOR.eval(inputs[0], inputs[1]),  \n        AND.eval(inputs[0], inputs[1])   \n      };\n    }\n  };\n  \n  \n  public static MultiGate FULL_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 3)\n        throw new IllegalArgumentException();\n      \n      \n      boolean[] haOutputs1 = HALF_ADDER.eval(inputs[0], inputs[1]);\n      boolean[] haOutputs2 = HALF_ADDER.eval(haOutputs1[0], inputs[2]);\n      return new boolean[] {\n        haOutputs2[0],                         \n        OR.eval(haOutputs1[1], haOutputs2[1])  \n      };\n    }\n  };\n  \n  public static MultiGate buildAdder(final int numBits)\n  {\n    return new MultiGate() {\n      public boolean[] eval(boolean... inputs)\n      {\n        \n        if (inputs.length != (numBits << 1))\n          throw new IllegalArgumentException();\n        boolean[] outputs = new boolean[numBits + 1];\n        boolean[] faInputs = new boolean[3];\n        boolean[] faOutputs = null;\n        for (int i = 0; i < numBits; i++)\n        {\n          faInputs[0] = (faOutputs == null) ? false : faOutputs[1];  \n          faInputs[1] = inputs[i];                                   \n          faInputs[2] = inputs[numBits + i];                         \n          faOutputs = FULL_ADDER.eval(faInputs);\n          outputs[i] = faOutputs[0];                                 \n        }\n        if (faOutputs != null)\n          outputs[numBits] = faOutputs[1];                           \n        return outputs;\n      }\n    };\n  }\n  \n  public static void main(String[] args)\n  {\n    int numBits = Integer.parseInt(args[0]);\n    int firstNum = Integer.parseInt(args[1]);\n    int secondNum = Integer.parseInt(args[2]);\n    int maxNum = 1 << numBits;\n    if ((firstNum < 0) || (firstNum >= maxNum))\n    {\n      System.out.println(\"First number is out of range\");\n      return;\n    }\n    if ((secondNum < 0) || (secondNum >= maxNum))\n    {\n      System.out.println(\"Second number is out of range\");\n      return;\n    }\n    \n    MultiGate multiBitAdder = buildAdder(numBits);\n    \n    boolean[] inputs = new boolean[numBits << 1];\n    String firstNumDisplay = \"\";\n    String secondNumDisplay = \"\";\n    for (int i = 0; i < numBits; i++)\n    {\n      boolean firstBit = ((firstNum >>> i) & 1) == 1;\n      boolean secondBit = ((secondNum >>> i) & 1) == 1;\n      inputs[i] = firstBit;\n      inputs[numBits + i] = secondBit;\n      firstNumDisplay = (firstBit ? \"1\" : \"0\") + firstNumDisplay;\n      secondNumDisplay = (secondBit ? \"1\" : \"0\") + secondNumDisplay;\n    }\n    \n    boolean[] outputs = multiBitAdder.eval(inputs);\n    int outputNum = 0;\n    String outputNumDisplay = \"\";\n    String outputCarryDisplay = null;\n    for (int i = numBits; i >= 0; i--)\n    {\n      outputNum = (outputNum << 1) | (outputs[i] ? 1 : 0);\n      if (i == numBits)\n        outputCarryDisplay = outputs[i] ? \"1\" : \"0\";\n      else\n        outputNumDisplay += (outputs[i] ? \"1\" : \"0\");\n    }\n    System.out.println(\"numBits=\" + numBits);\n    System.out.println(\"A=\" + firstNumDisplay + \" (\" + firstNum + \"), B=\" + secondNumDisplay + \" (\" + secondNum + \"), S=\" + outputCarryDisplay + \" \" + outputNumDisplay + \" (\" + outputNum + \")\");\n    return;\n  }\n  \n}\n"}
{"id": 116316, "name": "Four bit adder", "source": "Translate Swift to Java: typealias FourBit = (Int, Int, Int, Int)\n\nfunc halfAdder(_ a: Int, _ b: Int) -> (Int, Int) {\n  return (a ^ b, a & b)\n}\n\nfunc fullAdder(_ a: Int, _ b: Int, carry: Int) -> (Int, Int) {\n  let (s0, c0) = halfAdder(a, b)\n  let (s1, c1) = halfAdder(s0, carry)\n\n  return (s1, c0 | c1)\n}\n\nfunc fourBitAdder(_ a: FourBit, _ b: FourBit) -> (FourBit, carry: Int) {\n  let (sum1, carry1) = halfAdder(a.3, b.3)\n  let (sum2, carry2) = fullAdder(a.2, b.2, carry: carry1)\n  let (sum3, carry3) = fullAdder(a.1, b.1, carry: carry2)\n  let (sum4, carryOut) = fullAdder(a.0, b.0, carry: carry3)\n\n  return ((sum4, sum3, sum2, sum1), carryOut)\n}\n\nlet a = (0, 1, 1, 0)\nlet b = (0, 1, 1, 0)\n\nprint(\"\\(a) + \\(b) = \\(fourBitAdder(a, b))\")\n", "target": "public class GateLogic\n{\n  \n  public interface OneInputGate\n  {  boolean eval(boolean input);  }\n  \n  public interface TwoInputGate\n  {  boolean eval(boolean input1, boolean input2);  }\n  \n  public interface MultiGate\n  {  boolean[] eval(boolean... inputs);  }\n  \n  \n  public static OneInputGate NOT = new OneInputGate() {\n    public boolean eval(boolean input)\n    {  return !input;  }\n  };\n  \n  \n  public static TwoInputGate AND = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 && input2;  }\n  };\n  \n  \n  public static TwoInputGate OR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 || input2;  }\n  };\n  \n  \n  public static TwoInputGate XOR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {\n      return OR.eval(\n               AND.eval(input1, NOT.eval(input2)),\n               AND.eval(NOT.eval(input1), input2)\n             );\n    }\n  };\n  \n  \n  public static MultiGate HALF_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 2)\n        throw new IllegalArgumentException();\n      return new boolean[] {\n        XOR.eval(inputs[0], inputs[1]),  \n        AND.eval(inputs[0], inputs[1])   \n      };\n    }\n  };\n  \n  \n  public static MultiGate FULL_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 3)\n        throw new IllegalArgumentException();\n      \n      \n      boolean[] haOutputs1 = HALF_ADDER.eval(inputs[0], inputs[1]);\n      boolean[] haOutputs2 = HALF_ADDER.eval(haOutputs1[0], inputs[2]);\n      return new boolean[] {\n        haOutputs2[0],                         \n        OR.eval(haOutputs1[1], haOutputs2[1])  \n      };\n    }\n  };\n  \n  public static MultiGate buildAdder(final int numBits)\n  {\n    return new MultiGate() {\n      public boolean[] eval(boolean... inputs)\n      {\n        \n        if (inputs.length != (numBits << 1))\n          throw new IllegalArgumentException();\n        boolean[] outputs = new boolean[numBits + 1];\n        boolean[] faInputs = new boolean[3];\n        boolean[] faOutputs = null;\n        for (int i = 0; i < numBits; i++)\n        {\n          faInputs[0] = (faOutputs == null) ? false : faOutputs[1];  \n          faInputs[1] = inputs[i];                                   \n          faInputs[2] = inputs[numBits + i];                         \n          faOutputs = FULL_ADDER.eval(faInputs);\n          outputs[i] = faOutputs[0];                                 \n        }\n        if (faOutputs != null)\n          outputs[numBits] = faOutputs[1];                           \n        return outputs;\n      }\n    };\n  }\n  \n  public static void main(String[] args)\n  {\n    int numBits = Integer.parseInt(args[0]);\n    int firstNum = Integer.parseInt(args[1]);\n    int secondNum = Integer.parseInt(args[2]);\n    int maxNum = 1 << numBits;\n    if ((firstNum < 0) || (firstNum >= maxNum))\n    {\n      System.out.println(\"First number is out of range\");\n      return;\n    }\n    if ((secondNum < 0) || (secondNum >= maxNum))\n    {\n      System.out.println(\"Second number is out of range\");\n      return;\n    }\n    \n    MultiGate multiBitAdder = buildAdder(numBits);\n    \n    boolean[] inputs = new boolean[numBits << 1];\n    String firstNumDisplay = \"\";\n    String secondNumDisplay = \"\";\n    for (int i = 0; i < numBits; i++)\n    {\n      boolean firstBit = ((firstNum >>> i) & 1) == 1;\n      boolean secondBit = ((secondNum >>> i) & 1) == 1;\n      inputs[i] = firstBit;\n      inputs[numBits + i] = secondBit;\n      firstNumDisplay = (firstBit ? \"1\" : \"0\") + firstNumDisplay;\n      secondNumDisplay = (secondBit ? \"1\" : \"0\") + secondNumDisplay;\n    }\n    \n    boolean[] outputs = multiBitAdder.eval(inputs);\n    int outputNum = 0;\n    String outputNumDisplay = \"\";\n    String outputCarryDisplay = null;\n    for (int i = numBits; i >= 0; i--)\n    {\n      outputNum = (outputNum << 1) | (outputs[i] ? 1 : 0);\n      if (i == numBits)\n        outputCarryDisplay = outputs[i] ? \"1\" : \"0\";\n      else\n        outputNumDisplay += (outputs[i] ? \"1\" : \"0\");\n    }\n    System.out.println(\"numBits=\" + numBits);\n    System.out.println(\"A=\" + firstNumDisplay + \" (\" + firstNum + \"), B=\" + secondNumDisplay + \" (\" + secondNum + \"), S=\" + outputCarryDisplay + \" \" + outputNumDisplay + \" (\" + outputNum + \")\");\n    return;\n  }\n  \n}\n"}
{"id": 116317, "name": "Four bit adder", "source": "Translate Swift to Python: typealias FourBit = (Int, Int, Int, Int)\n\nfunc halfAdder(_ a: Int, _ b: Int) -> (Int, Int) {\n  return (a ^ b, a & b)\n}\n\nfunc fullAdder(_ a: Int, _ b: Int, carry: Int) -> (Int, Int) {\n  let (s0, c0) = halfAdder(a, b)\n  let (s1, c1) = halfAdder(s0, carry)\n\n  return (s1, c0 | c1)\n}\n\nfunc fourBitAdder(_ a: FourBit, _ b: FourBit) -> (FourBit, carry: Int) {\n  let (sum1, carry1) = halfAdder(a.3, b.3)\n  let (sum2, carry2) = fullAdder(a.2, b.2, carry: carry1)\n  let (sum3, carry3) = fullAdder(a.1, b.1, carry: carry2)\n  let (sum4, carryOut) = fullAdder(a.0, b.0, carry: carry3)\n\n  return ((sum4, sum3, sum2, sum1), carryOut)\n}\n\nlet a = (0, 1, 1, 0)\nlet b = (0, 1, 1, 0)\n\nprint(\"\\(a) + \\(b) = \\(fourBitAdder(a, b))\")\n", "target": "\n\nfrom myhdl import *\n\n\n\n@block\ndef NOTgate( a,  q ):   \n   \n   @always_comb   \n   def NOTgateLogic():\n      q.next = not a\n\n   return NOTgateLogic   \n\n\n@block\ndef ANDgate( a, b,  q ):\n   \n   @always_comb \n   def ANDgateLogic():\n      q.next = a and b\n\n   return ANDgateLogic\n\n\n@block\ndef ORgate( a, b,  q ):\n      \n   @always_comb  \n   def ORgateLogic():\n      q.next = a or b\n\n   return ORgateLogic\n\n\n\n\n@block\ndef XORgate( a, b,  q ):\n      \n   \n   nota, notb, annotb, bnnota = [Signal(bool(0)) for i in range(4)]\n   \n   inv0 = NOTgate( a,  nota )\n   inv1 = NOTgate( b,  notb )\n   and2a = ANDgate( a, notb,  annotb )\n   and2b = ANDgate( b, nota,  bnnota )\n   or2a = ORgate( annotb, bnnota,  q )\n\n   return inv0, inv1, and2a, and2b, or2a\n\n\n@block\ndef HalfAdder( in_a, in_b,  summ, carry ):\n    \n   and2a =  ANDgate(in_a, in_b,  carry)\n   xor2a =  XORgate(in_a, in_b,  summ)\n\n   return and2a, xor2a\n\n\n@block\ndef FullAdder( fa_c0, fa_a, fa_b,  fa_s, fa_c1 ):\n   \n\n   ha1_s, ha1_c1, ha2_c1 = [Signal(bool(0)) for i in range(3)]\n\n   HalfAdder01 = HalfAdder( fa_c0, fa_a,  ha1_s, ha1_c1 )\n   HalfAdder02 = HalfAdder( ha1_s, fa_b,  fa_s,  ha2_c1 )\n   or2a = ORgate(ha1_c1, ha2_c1,  fa_c1)\n\n   return HalfAdder01, HalfAdder02, or2a\n\n\n@block\ndef Adder4b( ina, inb,  cOut, sum4):\n    \n\n   cl = [Signal(bool()) for i in range(0,4)]  \n   sl = [Signal(bool()) for i in range(4)]  \n\n   HalfAdder0 = HalfAdder(        ina(0), inb(0),  sl[0], cl[1] )\n   FullAdder1 = FullAdder( cl[1], ina(1), inb(1),  sl[1], cl[2] ) \n   FullAdder2 = FullAdder( cl[2], ina(2), inb(2),  sl[2], cl[3] ) \n   FullAdder3 = FullAdder( cl[3], ina(3), inb(3),  sl[3], cOut ) \n\n   sc = ConcatSignal(*reversed(sl))  \n\n   @always_comb\n   def list2intbv():\n      sum4.next = sc  \n\n   return HalfAdder0, FullAdder1, FullAdder2, FullAdder3, list2intbv\n\n\n\nt_co, t_s, t_a, t_b, dbug =  [Signal(bool(0)) for i in range(5)]\nina4, inb4, sum4 =  [Signal(intbv(0)[4:])  for i in range(3)]\n\nfrom random import randrange \n\n@block\ndef Test_Adder4b():\n   \n   dut = Adder4b( ina4, inb4,  t_co, sum4 )\n\n   @instance\n   def check():\n      print( \"\\n      b   a   |  c1    s   \\n     -------------------\" )\n      for i in range(15):\n         ina4.next, inb4.next = randrange(2**4), randrange(2**4)\n         yield delay(5)\n         print( \"     %2d  %2d   |  %2d   %2d     \" \\\n                % (ina4,inb4, t_co,sum4) )\n         assert t_co * 16 + sum4 == ina4 + inb4  \n      print()\n\n   return dut, check\n\n\n\n\ndef main():\n   simInst = Test_Adder4b()\n   simInst.name = \"mySimInst\"\n   simInst.config_sim(trace=True)  \n   simInst.run_sim(duration=None)\n\n   inst = Adder4b( ina4, inb4,  t_co, sum4 )  \n   inst.convert(hdl='VHDL')  \n   inst.convert(hdl='Verilog')  \n\n    \nif __name__ == '__main__':\n   main()\n"}
{"id": 116318, "name": "Four bit adder", "source": "Translate Swift to Python: typealias FourBit = (Int, Int, Int, Int)\n\nfunc halfAdder(_ a: Int, _ b: Int) -> (Int, Int) {\n  return (a ^ b, a & b)\n}\n\nfunc fullAdder(_ a: Int, _ b: Int, carry: Int) -> (Int, Int) {\n  let (s0, c0) = halfAdder(a, b)\n  let (s1, c1) = halfAdder(s0, carry)\n\n  return (s1, c0 | c1)\n}\n\nfunc fourBitAdder(_ a: FourBit, _ b: FourBit) -> (FourBit, carry: Int) {\n  let (sum1, carry1) = halfAdder(a.3, b.3)\n  let (sum2, carry2) = fullAdder(a.2, b.2, carry: carry1)\n  let (sum3, carry3) = fullAdder(a.1, b.1, carry: carry2)\n  let (sum4, carryOut) = fullAdder(a.0, b.0, carry: carry3)\n\n  return ((sum4, sum3, sum2, sum1), carryOut)\n}\n\nlet a = (0, 1, 1, 0)\nlet b = (0, 1, 1, 0)\n\nprint(\"\\(a) + \\(b) = \\(fourBitAdder(a, b))\")\n", "target": "\n\nfrom myhdl import *\n\n\n\n@block\ndef NOTgate( a,  q ):   \n   \n   @always_comb   \n   def NOTgateLogic():\n      q.next = not a\n\n   return NOTgateLogic   \n\n\n@block\ndef ANDgate( a, b,  q ):\n   \n   @always_comb \n   def ANDgateLogic():\n      q.next = a and b\n\n   return ANDgateLogic\n\n\n@block\ndef ORgate( a, b,  q ):\n      \n   @always_comb  \n   def ORgateLogic():\n      q.next = a or b\n\n   return ORgateLogic\n\n\n\n\n@block\ndef XORgate( a, b,  q ):\n      \n   \n   nota, notb, annotb, bnnota = [Signal(bool(0)) for i in range(4)]\n   \n   inv0 = NOTgate( a,  nota )\n   inv1 = NOTgate( b,  notb )\n   and2a = ANDgate( a, notb,  annotb )\n   and2b = ANDgate( b, nota,  bnnota )\n   or2a = ORgate( annotb, bnnota,  q )\n\n   return inv0, inv1, and2a, and2b, or2a\n\n\n@block\ndef HalfAdder( in_a, in_b,  summ, carry ):\n    \n   and2a =  ANDgate(in_a, in_b,  carry)\n   xor2a =  XORgate(in_a, in_b,  summ)\n\n   return and2a, xor2a\n\n\n@block\ndef FullAdder( fa_c0, fa_a, fa_b,  fa_s, fa_c1 ):\n   \n\n   ha1_s, ha1_c1, ha2_c1 = [Signal(bool(0)) for i in range(3)]\n\n   HalfAdder01 = HalfAdder( fa_c0, fa_a,  ha1_s, ha1_c1 )\n   HalfAdder02 = HalfAdder( ha1_s, fa_b,  fa_s,  ha2_c1 )\n   or2a = ORgate(ha1_c1, ha2_c1,  fa_c1)\n\n   return HalfAdder01, HalfAdder02, or2a\n\n\n@block\ndef Adder4b( ina, inb,  cOut, sum4):\n    \n\n   cl = [Signal(bool()) for i in range(0,4)]  \n   sl = [Signal(bool()) for i in range(4)]  \n\n   HalfAdder0 = HalfAdder(        ina(0), inb(0),  sl[0], cl[1] )\n   FullAdder1 = FullAdder( cl[1], ina(1), inb(1),  sl[1], cl[2] ) \n   FullAdder2 = FullAdder( cl[2], ina(2), inb(2),  sl[2], cl[3] ) \n   FullAdder3 = FullAdder( cl[3], ina(3), inb(3),  sl[3], cOut ) \n\n   sc = ConcatSignal(*reversed(sl))  \n\n   @always_comb\n   def list2intbv():\n      sum4.next = sc  \n\n   return HalfAdder0, FullAdder1, FullAdder2, FullAdder3, list2intbv\n\n\n\nt_co, t_s, t_a, t_b, dbug =  [Signal(bool(0)) for i in range(5)]\nina4, inb4, sum4 =  [Signal(intbv(0)[4:])  for i in range(3)]\n\nfrom random import randrange \n\n@block\ndef Test_Adder4b():\n   \n   dut = Adder4b( ina4, inb4,  t_co, sum4 )\n\n   @instance\n   def check():\n      print( \"\\n      b   a   |  c1    s   \\n     -------------------\" )\n      for i in range(15):\n         ina4.next, inb4.next = randrange(2**4), randrange(2**4)\n         yield delay(5)\n         print( \"     %2d  %2d   |  %2d   %2d     \" \\\n                % (ina4,inb4, t_co,sum4) )\n         assert t_co * 16 + sum4 == ina4 + inb4  \n      print()\n\n   return dut, check\n\n\n\n\ndef main():\n   simInst = Test_Adder4b()\n   simInst.name = \"mySimInst\"\n   simInst.config_sim(trace=True)  \n   simInst.run_sim(duration=None)\n\n   inst = Adder4b( ina4, inb4,  t_co, sum4 )  \n   inst.convert(hdl='VHDL')  \n   inst.convert(hdl='Verilog')  \n\n    \nif __name__ == '__main__':\n   main()\n"}
{"id": 116673, "name": "Longest common subsequence", "source": "Translate Swift to C#: rlcs(_ s1: String, _ s2: String) -> String {\n   if s1.count == 0 || s2.count == 0 {\n       return \"\"\n   } else if s1[s1.index(s1.endIndex, offsetBy: -1)] == s2[s2.index(s2.endIndex, offsetBy: -1)] {\n       return rlcs(String(s1[s1.startIndex..<s1.index(s1.endIndex, offsetBy: -1)]),\n                   String(s2[s2.startIndex..<s2.index(s2.endIndex, offsetBy: -1)])) + String(s1[s1.index(s1.endIndex, offsetBy: -1)])\n   } else {\n       let str1 = rlcs(s1, String(s2[s2.startIndex..<s2.index(s2.endIndex, offsetBy: -1)]))\n       let str2 = rlcs(String(s1[s1.startIndex..<s1.index(s1.endIndex, offsetBy: -1)]), s2)\n\n       return str1.count > str2.count ? str1 : str2\n   }\n}\n", "target": "using System;\n\nnamespace LCS\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string word1 = \"thisisatest\";\n            string word2 = \"testing123testing\";\n            \n            Console.WriteLine(lcsBack(word1, word2));\n            Console.ReadKey();\n        }\n\n        public static string lcsBack(string a, string b)\n        {\n            string aSub = a.Substring(0, (a.Length - 1 < 0) ? 0 : a.Length - 1);\n            string bSub = b.Substring(0, (b.Length - 1 < 0) ? 0 : b.Length - 1);\n            \n            if (a.Length == 0 || b.Length == 0)            \n                return \"\";\n            else if (a[a.Length - 1] == b[b.Length - 1])\n                return lcsBack(aSub, bSub) + a[a.Length - 1];\n            else\n            {\n                string x = lcsBack(a, bSub);\n                string y = lcsBack(aSub, b);\n                return (x.Length > y.Length) ? x : y;\n            }\n        }\n    }\n}\n"}
{"id": 116674, "name": "Longest common subsequence", "source": "Translate Swift to C#: rlcs(_ s1: String, _ s2: String) -> String {\n   if s1.count == 0 || s2.count == 0 {\n       return \"\"\n   } else if s1[s1.index(s1.endIndex, offsetBy: -1)] == s2[s2.index(s2.endIndex, offsetBy: -1)] {\n       return rlcs(String(s1[s1.startIndex..<s1.index(s1.endIndex, offsetBy: -1)]),\n                   String(s2[s2.startIndex..<s2.index(s2.endIndex, offsetBy: -1)])) + String(s1[s1.index(s1.endIndex, offsetBy: -1)])\n   } else {\n       let str1 = rlcs(s1, String(s2[s2.startIndex..<s2.index(s2.endIndex, offsetBy: -1)]))\n       let str2 = rlcs(String(s1[s1.startIndex..<s1.index(s1.endIndex, offsetBy: -1)]), s2)\n\n       return str1.count > str2.count ? str1 : str2\n   }\n}\n", "target": "using System;\n\nnamespace LCS\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string word1 = \"thisisatest\";\n            string word2 = \"testing123testing\";\n            \n            Console.WriteLine(lcsBack(word1, word2));\n            Console.ReadKey();\n        }\n\n        public static string lcsBack(string a, string b)\n        {\n            string aSub = a.Substring(0, (a.Length - 1 < 0) ? 0 : a.Length - 1);\n            string bSub = b.Substring(0, (b.Length - 1 < 0) ? 0 : b.Length - 1);\n            \n            if (a.Length == 0 || b.Length == 0)            \n                return \"\";\n            else if (a[a.Length - 1] == b[b.Length - 1])\n                return lcsBack(aSub, bSub) + a[a.Length - 1];\n            else\n            {\n                string x = lcsBack(a, bSub);\n                string y = lcsBack(aSub, b);\n                return (x.Length > y.Length) ? x : y;\n            }\n        }\n    }\n}\n"}
{"id": 116677, "name": "Longest common subsequence", "source": "Translate Swift to Java: rlcs(_ s1: String, _ s2: String) -> String {\n   if s1.count == 0 || s2.count == 0 {\n       return \"\"\n   } else if s1[s1.index(s1.endIndex, offsetBy: -1)] == s2[s2.index(s2.endIndex, offsetBy: -1)] {\n       return rlcs(String(s1[s1.startIndex..<s1.index(s1.endIndex, offsetBy: -1)]),\n                   String(s2[s2.startIndex..<s2.index(s2.endIndex, offsetBy: -1)])) + String(s1[s1.index(s1.endIndex, offsetBy: -1)])\n   } else {\n       let str1 = rlcs(s1, String(s2[s2.startIndex..<s2.index(s2.endIndex, offsetBy: -1)]))\n       let str2 = rlcs(String(s1[s1.startIndex..<s1.index(s1.endIndex, offsetBy: -1)]), s2)\n\n       return str1.count > str2.count ? str1 : str2\n   }\n}\n", "target": "public static String lcs(String a, String b){\n    int aLen = a.length();\n    int bLen = b.length();\n    if(aLen == 0 || bLen == 0){\n        return \"\";\n    }else if(a.charAt(aLen-1) == b.charAt(bLen-1)){\n        return lcs(a.substring(0,aLen-1),b.substring(0,bLen-1))\n            + a.charAt(aLen-1);\n    }else{\n        String x = lcs(a, b.substring(0,bLen-1));\n        String y = lcs(a.substring(0,aLen-1), b);\n        return (x.length() > y.length()) ? x : y;\n    }\n}\n"}
{"id": 116678, "name": "Longest common subsequence", "source": "Translate Swift to Java: rlcs(_ s1: String, _ s2: String) -> String {\n   if s1.count == 0 || s2.count == 0 {\n       return \"\"\n   } else if s1[s1.index(s1.endIndex, offsetBy: -1)] == s2[s2.index(s2.endIndex, offsetBy: -1)] {\n       return rlcs(String(s1[s1.startIndex..<s1.index(s1.endIndex, offsetBy: -1)]),\n                   String(s2[s2.startIndex..<s2.index(s2.endIndex, offsetBy: -1)])) + String(s1[s1.index(s1.endIndex, offsetBy: -1)])\n   } else {\n       let str1 = rlcs(s1, String(s2[s2.startIndex..<s2.index(s2.endIndex, offsetBy: -1)]))\n       let str2 = rlcs(String(s1[s1.startIndex..<s1.index(s1.endIndex, offsetBy: -1)]), s2)\n\n       return str1.count > str2.count ? str1 : str2\n   }\n}\n", "target": "public static String lcs(String a, String b){\n    int aLen = a.length();\n    int bLen = b.length();\n    if(aLen == 0 || bLen == 0){\n        return \"\";\n    }else if(a.charAt(aLen-1) == b.charAt(bLen-1)){\n        return lcs(a.substring(0,aLen-1),b.substring(0,bLen-1))\n            + a.charAt(aLen-1);\n    }else{\n        String x = lcs(a, b.substring(0,bLen-1));\n        String y = lcs(a.substring(0,aLen-1), b);\n        return (x.length() > y.length()) ? x : y;\n    }\n}\n"}
{"id": 116679, "name": "Longest common subsequence", "source": "Translate Swift to Python: rlcs(_ s1: String, _ s2: String) -> String {\n   if s1.count == 0 || s2.count == 0 {\n       return \"\"\n   } else if s1[s1.index(s1.endIndex, offsetBy: -1)] == s2[s2.index(s2.endIndex, offsetBy: -1)] {\n       return rlcs(String(s1[s1.startIndex..<s1.index(s1.endIndex, offsetBy: -1)]),\n                   String(s2[s2.startIndex..<s2.index(s2.endIndex, offsetBy: -1)])) + String(s1[s1.index(s1.endIndex, offsetBy: -1)])\n   } else {\n       let str1 = rlcs(s1, String(s2[s2.startIndex..<s2.index(s2.endIndex, offsetBy: -1)]))\n       let str2 = rlcs(String(s1[s1.startIndex..<s1.index(s1.endIndex, offsetBy: -1)]), s2)\n\n       return str1.count > str2.count ? str1 : str2\n   }\n}\n", "target": "def lcs(xstr, ystr):\n    \n    if not xstr or not ystr:\n        return \"\"\n    x, xs, y, ys = xstr[0], xstr[1:], ystr[0], ystr[1:]\n    if x == y:\n        return str(lcs(xs, ys)) + x\n    else:\n        return max(lcs(xstr, ys), lcs(xs, ystr), key=len)\n"}
{"id": 116680, "name": "Longest common subsequence", "source": "Translate Swift to Python: rlcs(_ s1: String, _ s2: String) -> String {\n   if s1.count == 0 || s2.count == 0 {\n       return \"\"\n   } else if s1[s1.index(s1.endIndex, offsetBy: -1)] == s2[s2.index(s2.endIndex, offsetBy: -1)] {\n       return rlcs(String(s1[s1.startIndex..<s1.index(s1.endIndex, offsetBy: -1)]),\n                   String(s2[s2.startIndex..<s2.index(s2.endIndex, offsetBy: -1)])) + String(s1[s1.index(s1.endIndex, offsetBy: -1)])\n   } else {\n       let str1 = rlcs(s1, String(s2[s2.startIndex..<s2.index(s2.endIndex, offsetBy: -1)]))\n       let str2 = rlcs(String(s1[s1.startIndex..<s1.index(s1.endIndex, offsetBy: -1)]), s2)\n\n       return str1.count > str2.count ? str1 : str2\n   }\n}\n", "target": "def lcs(xstr, ystr):\n    \n    if not xstr or not ystr:\n        return \"\"\n    x, xs, y, ys = xstr[0], xstr[1:], ystr[0], ystr[1:]\n    if x == y:\n        return str(lcs(xs, ys)) + x\n    else:\n        return max(lcs(xstr, ys), lcs(xs, ystr), key=len)\n"}
{"id": 117142, "name": "ABC problem", "source": "Translate Swift to C#: import Foundation\n\nfunc Blockable(str: String) -> Bool {\n\n    var blocks = [\n        \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n        \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\" ]\n\n    var strUp = str.uppercaseString\n    var final = \"\"\n\n    for char: Character in strUp {\n        var CharString: String = \"\"; CharString.append(char)\n        for j in 0..<blocks.count {\n            if blocks[j].hasPrefix(CharString) ||\n               blocks[j].hasSuffix(CharString) {\n                final.append(char)\n                blocks[j] = \"\"\n                break\n            }\n        }\n    }\n\n    return final == strUp\n}\n\nfunc CanOrNot(can: Bool) -> String {\n    return can ? \"can\" : \"cannot\"\n}\n\nfor str in [ \"A\", \"BARK\", \"BooK\", \"TrEaT\", \"comMON\", \"sQuAd\", \"Confuse\" ] {\n    println(\"'\\(str)' \\(CanOrNot(Blockable(str))) be spelled with blocks.\")\n}\n", "target": "using System;\nusing System.IO;\n\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\n\nvoid Main()\n{\n   string blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\";\n   List<string> words = new List<string>() {\n      \"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"\n   };\n\n   foreach(var word in words)\n   {\n      Console.WriteLine(\"{0}: {1}\", word, CheckWord(blocks, word));\n   }\n}\n\nbool CheckWord(string blocks, string word)\n{\n   for(int i = 0; i < word.Length; ++i)\n   {\n      int length = blocks.Length;\n      Regex rgx = new Regex(\"([a-z]\"+word[i]+\"|\"+word[i]+\"[a-z])\", RegexOptions.IgnoreCase);\n      blocks = rgx.Replace(blocks, \"\", 1);\n      if(blocks.Length == length) return false;\n   }\n   return true;\n}\n"}
{"id": 117143, "name": "ABC problem", "source": "Translate Swift to C#: import Foundation\n\nfunc Blockable(str: String) -> Bool {\n\n    var blocks = [\n        \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n        \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\" ]\n\n    var strUp = str.uppercaseString\n    var final = \"\"\n\n    for char: Character in strUp {\n        var CharString: String = \"\"; CharString.append(char)\n        for j in 0..<blocks.count {\n            if blocks[j].hasPrefix(CharString) ||\n               blocks[j].hasSuffix(CharString) {\n                final.append(char)\n                blocks[j] = \"\"\n                break\n            }\n        }\n    }\n\n    return final == strUp\n}\n\nfunc CanOrNot(can: Bool) -> String {\n    return can ? \"can\" : \"cannot\"\n}\n\nfor str in [ \"A\", \"BARK\", \"BooK\", \"TrEaT\", \"comMON\", \"sQuAd\", \"Confuse\" ] {\n    println(\"'\\(str)' \\(CanOrNot(Blockable(str))) be spelled with blocks.\")\n}\n", "target": "using System;\nusing System.IO;\n\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\n\nvoid Main()\n{\n   string blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\";\n   List<string> words = new List<string>() {\n      \"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"\n   };\n\n   foreach(var word in words)\n   {\n      Console.WriteLine(\"{0}: {1}\", word, CheckWord(blocks, word));\n   }\n}\n\nbool CheckWord(string blocks, string word)\n{\n   for(int i = 0; i < word.Length; ++i)\n   {\n      int length = blocks.Length;\n      Regex rgx = new Regex(\"([a-z]\"+word[i]+\"|\"+word[i]+\"[a-z])\", RegexOptions.IgnoreCase);\n      blocks = rgx.Replace(blocks, \"\", 1);\n      if(blocks.Length == length) return false;\n   }\n   return true;\n}\n"}
{"id": 117146, "name": "ABC problem", "source": "Translate Swift to Java: import Foundation\n\nfunc Blockable(str: String) -> Bool {\n\n    var blocks = [\n        \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n        \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\" ]\n\n    var strUp = str.uppercaseString\n    var final = \"\"\n\n    for char: Character in strUp {\n        var CharString: String = \"\"; CharString.append(char)\n        for j in 0..<blocks.count {\n            if blocks[j].hasPrefix(CharString) ||\n               blocks[j].hasSuffix(CharString) {\n                final.append(char)\n                blocks[j] = \"\"\n                break\n            }\n        }\n    }\n\n    return final == strUp\n}\n\nfunc CanOrNot(can: Bool) -> String {\n    return can ? \"can\" : \"cannot\"\n}\n\nfor str in [ \"A\", \"BARK\", \"BooK\", \"TrEaT\", \"comMON\", \"sQuAd\", \"Confuse\" ] {\n    println(\"'\\(str)' \\(CanOrNot(Blockable(str))) be spelled with blocks.\")\n}\n", "target": "static Boolean canMakeWord(List<String> src_blocks, String word) {\n    if (String.isEmpty(word)) {\n        return true;\n    }\n\n    List<String> blocks = new List<String>();\n    for (String block : src_blocks) {\n        blocks.add(block.toUpperCase());\n    }\n    \n    for (Integer i = 0; i < word.length(); i++) {\n        Integer blockIndex = -1;\n        String c = word.mid(i, 1).toUpperCase();\n        \n        for (Integer j = 0; j < blocks.size(); j++) {\n            if (blocks.get(j).contains(c)) {\n                blockIndex = j;\n                break;\n            }\n        }\n        \n        if (blockIndex == -1) {\n            return false;\n        } else {\n            blocks.remove(blockIndex);\n        }\n    }\n        \n    return true;\n}\n\nList<String> blocks = new List<String>{\n    'BO', 'XK', 'DQ', 'CP', 'NA',\n    'GT', 'RE', 'TG', 'QD', 'FS', \n    'JW', 'HU', 'VI', 'AN', 'OB', \n    'ER', 'FS', 'LY', 'PC', 'ZM'\n};\nSystem.debug('\"\": ' + canMakeWord(blocks, ''));\nSystem.debug('\"A\": ' + canMakeWord(blocks, 'A'));\nSystem.debug('\"BARK\": ' + canMakeWord(blocks, 'BARK'));\nSystem.debug('\"book\": ' + canMakeWord(blocks, 'book'));\nSystem.debug('\"treat\": ' + canMakeWord(blocks, 'treat'));\nSystem.debug('\"COMMON\": ' + canMakeWord(blocks, 'COMMON'));\nSystem.debug('\"SQuAd\": ' + canMakeWord(blocks, 'SQuAd'));\nSystem.debug('\"CONFUSE\": ' + canMakeWord(blocks, 'CONFUSE'));\n"}
{"id": 117147, "name": "ABC problem", "source": "Translate Swift to Java: import Foundation\n\nfunc Blockable(str: String) -> Bool {\n\n    var blocks = [\n        \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n        \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\" ]\n\n    var strUp = str.uppercaseString\n    var final = \"\"\n\n    for char: Character in strUp {\n        var CharString: String = \"\"; CharString.append(char)\n        for j in 0..<blocks.count {\n            if blocks[j].hasPrefix(CharString) ||\n               blocks[j].hasSuffix(CharString) {\n                final.append(char)\n                blocks[j] = \"\"\n                break\n            }\n        }\n    }\n\n    return final == strUp\n}\n\nfunc CanOrNot(can: Bool) -> String {\n    return can ? \"can\" : \"cannot\"\n}\n\nfor str in [ \"A\", \"BARK\", \"BooK\", \"TrEaT\", \"comMON\", \"sQuAd\", \"Confuse\" ] {\n    println(\"'\\(str)' \\(CanOrNot(Blockable(str))) be spelled with blocks.\")\n}\n", "target": "static Boolean canMakeWord(List<String> src_blocks, String word) {\n    if (String.isEmpty(word)) {\n        return true;\n    }\n\n    List<String> blocks = new List<String>();\n    for (String block : src_blocks) {\n        blocks.add(block.toUpperCase());\n    }\n    \n    for (Integer i = 0; i < word.length(); i++) {\n        Integer blockIndex = -1;\n        String c = word.mid(i, 1).toUpperCase();\n        \n        for (Integer j = 0; j < blocks.size(); j++) {\n            if (blocks.get(j).contains(c)) {\n                blockIndex = j;\n                break;\n            }\n        }\n        \n        if (blockIndex == -1) {\n            return false;\n        } else {\n            blocks.remove(blockIndex);\n        }\n    }\n        \n    return true;\n}\n\nList<String> blocks = new List<String>{\n    'BO', 'XK', 'DQ', 'CP', 'NA',\n    'GT', 'RE', 'TG', 'QD', 'FS', \n    'JW', 'HU', 'VI', 'AN', 'OB', \n    'ER', 'FS', 'LY', 'PC', 'ZM'\n};\nSystem.debug('\"\": ' + canMakeWord(blocks, ''));\nSystem.debug('\"A\": ' + canMakeWord(blocks, 'A'));\nSystem.debug('\"BARK\": ' + canMakeWord(blocks, 'BARK'));\nSystem.debug('\"book\": ' + canMakeWord(blocks, 'book'));\nSystem.debug('\"treat\": ' + canMakeWord(blocks, 'treat'));\nSystem.debug('\"COMMON\": ' + canMakeWord(blocks, 'COMMON'));\nSystem.debug('\"SQuAd\": ' + canMakeWord(blocks, 'SQuAd'));\nSystem.debug('\"CONFUSE\": ' + canMakeWord(blocks, 'CONFUSE'));\n"}
{"id": 117148, "name": "ABC problem", "source": "Translate Swift to Python: import Foundation\n\nfunc Blockable(str: String) -> Bool {\n\n    var blocks = [\n        \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n        \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\" ]\n\n    var strUp = str.uppercaseString\n    var final = \"\"\n\n    for char: Character in strUp {\n        var CharString: String = \"\"; CharString.append(char)\n        for j in 0..<blocks.count {\n            if blocks[j].hasPrefix(CharString) ||\n               blocks[j].hasSuffix(CharString) {\n                final.append(char)\n                blocks[j] = \"\"\n                break\n            }\n        }\n    }\n\n    return final == strUp\n}\n\nfunc CanOrNot(can: Bool) -> String {\n    return can ? \"can\" : \"cannot\"\n}\n\nfor str in [ \"A\", \"BARK\", \"BooK\", \"TrEaT\", \"comMON\", \"sQuAd\", \"Confuse\" ] {\n    println(\"'\\(str)' \\(CanOrNot(Blockable(str))) be spelled with blocks.\")\n}\n", "target": "    >>> can_make_word(\"A\")\n    True\n    >>> can_make_word(\"BARK\")\n    True\n    >>> can_make_word(\"BOOK\")\n    False\n    >>> can_make_word(\"TREAT\")\n    True\n    >>> can_make_word(\"COMMON\")\n    False\n    >>> can_make_word(\"SQUAD\")\n    True\n    >>> can_make_word(\"CONFUSE\")\n    True\n"}
{"id": 117149, "name": "ABC problem", "source": "Translate Swift to Python: import Foundation\n\nfunc Blockable(str: String) -> Bool {\n\n    var blocks = [\n        \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n        \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\" ]\n\n    var strUp = str.uppercaseString\n    var final = \"\"\n\n    for char: Character in strUp {\n        var CharString: String = \"\"; CharString.append(char)\n        for j in 0..<blocks.count {\n            if blocks[j].hasPrefix(CharString) ||\n               blocks[j].hasSuffix(CharString) {\n                final.append(char)\n                blocks[j] = \"\"\n                break\n            }\n        }\n    }\n\n    return final == strUp\n}\n\nfunc CanOrNot(can: Bool) -> String {\n    return can ? \"can\" : \"cannot\"\n}\n\nfor str in [ \"A\", \"BARK\", \"BooK\", \"TrEaT\", \"comMON\", \"sQuAd\", \"Confuse\" ] {\n    println(\"'\\(str)' \\(CanOrNot(Blockable(str))) be spelled with blocks.\")\n}\n", "target": "    >>> can_make_word(\"A\")\n    True\n    >>> can_make_word(\"BARK\")\n    True\n    >>> can_make_word(\"BOOK\")\n    False\n    >>> can_make_word(\"TREAT\")\n    True\n    >>> can_make_word(\"COMMON\")\n    False\n    >>> can_make_word(\"SQUAD\")\n    True\n    >>> can_make_word(\"CONFUSE\")\n    True\n"}
{"id": 117878, "name": "Sum digits of an integer", "source": "Translate Swift to C#: extension String: Error {\n    func sumDigits(withBase base: Int) throws -> Int {\n        func characterToInt(_ base: Int) -> (Character) -> Int? {\n            return { char in\n                return Int(String(char), radix: base)\n            }\n        }\n        \n        return try self.map(characterToInt(base))\n            .flatMap {\n                guard $0 != nil else { throw \"Invalid input\" }\n                return $0\n            }\n            .reduce(0, +)\n    }\n}\n\nprint(try! \"1\".sumDigits(withBase: 10))\nprint(try! \"1234\".sumDigits(withBase: 10))\nprint(try! \"fe\".sumDigits(withBase: 16))\nprint(try! \"f0e\".sumDigits(withBase: 16))\n", "target": "namespace RosettaCode.SumDigitsOfAnInteger\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    internal static class Program\n    {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        private static IEnumerable<int> Digits(this int number, int @base = 10)\n        {\n            while (number != 0)\n            {\n                int digit;\n                number = Math.DivRem(number, @base, out digit);\n                yield return digit;\n            }\n        }\n\n        \n        \n        \n        \n        \n        \n        private static int SumOfDigits(this int number, int @base = 10)\n        {\n            return number.Digits(@base).Sum();\n        }\n\n        \n        \n        \n        private static void Main()\n        {\n            foreach (var example in\n                new[]\n                {\n                    new {Number = 1, Base = 10},\n                    new {Number = 12345, Base = 10},\n                    new {Number = 123045, Base = 10},\n                    new {Number = 0xfe, Base = 0x10},\n                    new {Number = 0xf0e, Base = 0x10}\n                })\n            {\n                Console.WriteLine(example.Number.SumOfDigits(example.Base));\n            }\n        }\n    }\n}\n"}
{"id": 117879, "name": "Sum digits of an integer", "source": "Translate Swift to C#: extension String: Error {\n    func sumDigits(withBase base: Int) throws -> Int {\n        func characterToInt(_ base: Int) -> (Character) -> Int? {\n            return { char in\n                return Int(String(char), radix: base)\n            }\n        }\n        \n        return try self.map(characterToInt(base))\n            .flatMap {\n                guard $0 != nil else { throw \"Invalid input\" }\n                return $0\n            }\n            .reduce(0, +)\n    }\n}\n\nprint(try! \"1\".sumDigits(withBase: 10))\nprint(try! \"1234\".sumDigits(withBase: 10))\nprint(try! \"fe\".sumDigits(withBase: 16))\nprint(try! \"f0e\".sumDigits(withBase: 16))\n", "target": "namespace RosettaCode.SumDigitsOfAnInteger\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    internal static class Program\n    {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        private static IEnumerable<int> Digits(this int number, int @base = 10)\n        {\n            while (number != 0)\n            {\n                int digit;\n                number = Math.DivRem(number, @base, out digit);\n                yield return digit;\n            }\n        }\n\n        \n        \n        \n        \n        \n        \n        private static int SumOfDigits(this int number, int @base = 10)\n        {\n            return number.Digits(@base).Sum();\n        }\n\n        \n        \n        \n        private static void Main()\n        {\n            foreach (var example in\n                new[]\n                {\n                    new {Number = 1, Base = 10},\n                    new {Number = 12345, Base = 10},\n                    new {Number = 123045, Base = 10},\n                    new {Number = 0xfe, Base = 0x10},\n                    new {Number = 0xf0e, Base = 0x10}\n                })\n            {\n                Console.WriteLine(example.Number.SumOfDigits(example.Base));\n            }\n        }\n    }\n}\n"}
{"id": 117882, "name": "Sum digits of an integer", "source": "Translate Swift to Java: extension String: Error {\n    func sumDigits(withBase base: Int) throws -> Int {\n        func characterToInt(_ base: Int) -> (Character) -> Int? {\n            return { char in\n                return Int(String(char), radix: base)\n            }\n        }\n        \n        return try self.map(characterToInt(base))\n            .flatMap {\n                guard $0 != nil else { throw \"Invalid input\" }\n                return $0\n            }\n            .reduce(0, +)\n    }\n}\n\nprint(try! \"1\".sumDigits(withBase: 10))\nprint(try! \"1234\".sumDigits(withBase: 10))\nprint(try! \"fe\".sumDigits(withBase: 16))\nprint(try! \"f0e\".sumDigits(withBase: 16))\n", "target": "import java.math.BigInteger;\npublic class SumDigits {\n    public static int sumDigits(long num) {\n\treturn sumDigits(num, 10);\n    }\n    public static int sumDigits(long num, int base) {\n\tString s = Long.toString(num, base);\n\tint result = 0;\n\tfor (int i = 0; i < s.length(); i++)\n\t    result += Character.digit(s.charAt(i), base);\n\treturn result;\n    }\n    public static int sumDigits(BigInteger num) {\n\treturn sumDigits(num, 10);\n    }\n    public static int sumDigits(BigInteger num, int base) {\n\tString s = num.toString(base);\n\tint result = 0;\n\tfor (int i = 0; i < s.length(); i++)\n\t    result += Character.digit(s.charAt(i), base);\n\treturn result;\n    }\n\n    public static void main(String[] args) {\n\tSystem.out.println(sumDigits(1));\n\tSystem.out.println(sumDigits(12345));\n\tSystem.out.println(sumDigits(123045));\n\tSystem.out.println(sumDigits(0xfe, 16));\n\tSystem.out.println(sumDigits(0xf0e, 16));\n\tSystem.out.println(sumDigits(new BigInteger(\"12345678901234567890\")));\n    }\n}\n"}
{"id": 117883, "name": "Sum digits of an integer", "source": "Translate Swift to Java: extension String: Error {\n    func sumDigits(withBase base: Int) throws -> Int {\n        func characterToInt(_ base: Int) -> (Character) -> Int? {\n            return { char in\n                return Int(String(char), radix: base)\n            }\n        }\n        \n        return try self.map(characterToInt(base))\n            .flatMap {\n                guard $0 != nil else { throw \"Invalid input\" }\n                return $0\n            }\n            .reduce(0, +)\n    }\n}\n\nprint(try! \"1\".sumDigits(withBase: 10))\nprint(try! \"1234\".sumDigits(withBase: 10))\nprint(try! \"fe\".sumDigits(withBase: 16))\nprint(try! \"f0e\".sumDigits(withBase: 16))\n", "target": "import java.math.BigInteger;\npublic class SumDigits {\n    public static int sumDigits(long num) {\n\treturn sumDigits(num, 10);\n    }\n    public static int sumDigits(long num, int base) {\n\tString s = Long.toString(num, base);\n\tint result = 0;\n\tfor (int i = 0; i < s.length(); i++)\n\t    result += Character.digit(s.charAt(i), base);\n\treturn result;\n    }\n    public static int sumDigits(BigInteger num) {\n\treturn sumDigits(num, 10);\n    }\n    public static int sumDigits(BigInteger num, int base) {\n\tString s = num.toString(base);\n\tint result = 0;\n\tfor (int i = 0; i < s.length(); i++)\n\t    result += Character.digit(s.charAt(i), base);\n\treturn result;\n    }\n\n    public static void main(String[] args) {\n\tSystem.out.println(sumDigits(1));\n\tSystem.out.println(sumDigits(12345));\n\tSystem.out.println(sumDigits(123045));\n\tSystem.out.println(sumDigits(0xfe, 16));\n\tSystem.out.println(sumDigits(0xf0e, 16));\n\tSystem.out.println(sumDigits(new BigInteger(\"12345678901234567890\")));\n    }\n}\n"}
{"id": 117884, "name": "Sum digits of an integer", "source": "Translate Swift to Python: extension String: Error {\n    func sumDigits(withBase base: Int) throws -> Int {\n        func characterToInt(_ base: Int) -> (Character) -> Int? {\n            return { char in\n                return Int(String(char), radix: base)\n            }\n        }\n        \n        return try self.map(characterToInt(base))\n            .flatMap {\n                guard $0 != nil else { throw \"Invalid input\" }\n                return $0\n            }\n            .reduce(0, +)\n    }\n}\n\nprint(try! \"1\".sumDigits(withBase: 10))\nprint(try! \"1234\".sumDigits(withBase: 10))\nprint(try! \"fe\".sumDigits(withBase: 16))\nprint(try! \"f0e\".sumDigits(withBase: 16))\n", "target": "\n\n\n\n\n\u0ba8\u0bbf\u0bb0\u0bb2\u0bcd\u0baa\u0bbe\u0b95\u0bae\u0bcd \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( \u0b8e\u0ba3\u0bcd )\n  \u0ba4\u0bca\u0b95\u0bc8 = 0\n  @( \u0b8e\u0ba3\u0bcd > 0 ) \u0bb5\u0bb0\u0bc8\n     d = \u0b8e\u0ba3\u0bcd%10;\n     \u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \"digit = \",d\n     \u0b8e\u0ba3\u0bcd = (\u0b8e\u0ba3\u0bcd-d)/10;\n     \u0ba4\u0bca\u0b95\u0bc8  = \u0ba4\u0bca\u0b95\u0bc8  + d\n  \u0bae\u0bc1\u0b9f\u0bbf\n  \u0baa\u0bbf\u0ba9\u0bcd\u0b95\u0bca\u0b9f\u0bc1 \u0ba4\u0bca\u0b95\u0bc8 \n\u0bae\u0bc1\u0b9f\u0bbf\n\n\n\u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( 1289)\n\u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( 123456789)\n"}
{"id": 117885, "name": "Sum digits of an integer", "source": "Translate Swift to Python: extension String: Error {\n    func sumDigits(withBase base: Int) throws -> Int {\n        func characterToInt(_ base: Int) -> (Character) -> Int? {\n            return { char in\n                return Int(String(char), radix: base)\n            }\n        }\n        \n        return try self.map(characterToInt(base))\n            .flatMap {\n                guard $0 != nil else { throw \"Invalid input\" }\n                return $0\n            }\n            .reduce(0, +)\n    }\n}\n\nprint(try! \"1\".sumDigits(withBase: 10))\nprint(try! \"1234\".sumDigits(withBase: 10))\nprint(try! \"fe\".sumDigits(withBase: 16))\nprint(try! \"f0e\".sumDigits(withBase: 16))\n", "target": "\n\n\n\n\n\u0ba8\u0bbf\u0bb0\u0bb2\u0bcd\u0baa\u0bbe\u0b95\u0bae\u0bcd \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( \u0b8e\u0ba3\u0bcd )\n  \u0ba4\u0bca\u0b95\u0bc8 = 0\n  @( \u0b8e\u0ba3\u0bcd > 0 ) \u0bb5\u0bb0\u0bc8\n     d = \u0b8e\u0ba3\u0bcd%10;\n     \u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \"digit = \",d\n     \u0b8e\u0ba3\u0bcd = (\u0b8e\u0ba3\u0bcd-d)/10;\n     \u0ba4\u0bca\u0b95\u0bc8  = \u0ba4\u0bca\u0b95\u0bc8  + d\n  \u0bae\u0bc1\u0b9f\u0bbf\n  \u0baa\u0bbf\u0ba9\u0bcd\u0b95\u0bca\u0b9f\u0bc1 \u0ba4\u0bca\u0b95\u0bc8 \n\u0bae\u0bc1\u0b9f\u0bbf\n\n\n\u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( 1289)\n\u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( 123456789)\n"}
{"id": 118214, "name": "Apply a callback to an array", "source": "Translate Swift to C#: func square(n: Int) -> Int {\n    return n * n\n}\n\nlet numbers = [1, 3, 5, 7]\n\nlet squares1a = numbers.map(square)         \n\nlet squares1b = numbers.map {x in x*x}      \n\nlet squares1b = numbers.map { $0 * $0 }      \n\nlet isquares1 = numbers.lazy.map(square)   \n", "target": "int[] intArray = { 1, 2, 3, 4, 5 };\n\nint[] squares1 = intArray.Select(x => x * x).ToArray();\n\n\nint[] squares2 = (from x in intArray\n                  select x * x).ToArray();\n\n\nforeach (var i in intArray)\n    Console.WriteLine(i * i);\n"}
{"id": 118216, "name": "Apply a callback to an array", "source": "Translate Swift to Java: func square(n: Int) -> Int {\n    return n * n\n}\n\nlet numbers = [1, 3, 5, 7]\n\nlet squares1a = numbers.map(square)         \n\nlet squares1b = numbers.map {x in x*x}      \n\nlet squares1b = numbers.map { $0 * $0 }      \n\nlet isquares1 = numbers.lazy.map(square)   \n", "target": "public class ArrayCallback7 {\n\n    interface IntConsumer {\n        void run(int x);\n    }\n\n    interface IntToInt {\n        int run(int x);\n    }\n\n    static void forEach(int[] arr, IntConsumer consumer) {\n        for (int i : arr) {\n            consumer.run(i);\n        }\n    }\n\n    static void update(int[] arr, IntToInt mapper) {\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = mapper.run(arr[i]);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n        forEach(numbers, new IntConsumer() {\n            public void run(int x) {\n                System.out.println(x);\n            }\n        });\n\n        update(numbers, new IntToInt() {\n            @Override\n            public int run(int x) {\n                return x * x;\n            }\n        });\n\n        forEach(numbers, new IntConsumer() {\n            public void run(int x) {\n                System.out.println(x);\n            }\n        });\n    }\n}\n"}
{"id": 118217, "name": "Apply a callback to an array", "source": "Translate Swift to Python: func square(n: Int) -> Int {\n    return n * n\n}\n\nlet numbers = [1, 3, 5, 7]\n\nlet squares1a = numbers.map(square)         \n\nlet squares1b = numbers.map {x in x*x}      \n\nlet squares1b = numbers.map { $0 * $0 }      \n\nlet isquares1 = numbers.lazy.map(square)   \n", "target": "def square(n):\n    return n * n\n  \nnumbers = [1, 3, 5, 7]\n\nsquares1 = [square(n) for n in numbers]     \n\nsquares2a = map(square, numbers)            \n\nsquares2b = map(lambda x: x*x, numbers)     \n\nsquares3 = [n * n for n in numbers]         \n                                            \n\nisquares1 = (n * n for n in numbers)        \n\nimport itertools\nisquares2 = itertools.imap(square, numbers) \n"}
{"id": 118496, "name": "Sum of squares", "source": "Translate Swift to C#: func sumSq(s: [Int]) -> Int {\n  return s.map{$0 * $0}.reduce(0, +)\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static int SumOfSquares(IEnumerable<int> list)\n    {\n        return list.Sum(x => x * x);\n    }\n    static void Main(string[] args)\n    {\n        Console.WriteLine(SumOfSquares(new int[] { 4, 8, 15, 16, 23, 42 })); \n        Console.WriteLine(SumOfSquares(new int[] { 1, 2, 3, 4, 5 })); \n        Console.WriteLine(SumOfSquares(new int[] { })); \n    }\n}\n"}
{"id": 118498, "name": "Sum of squares", "source": "Translate Swift to Java: func sumSq(s: [Int]) -> Int {\n  return s.map{$0 * $0}.reduce(0, +)\n}\n", "target": "public class SumSquares\n{\n public static void main(final String[] args)\n {\n  double sum = 0;\n  int[] nums = {1,2,3,4,5};\n  for (int i : nums)\n   sum += i * i;\n  System.out.println(\"The sum of the squares is: \" + sum);\n }\n}\n"}
{"id": 118499, "name": "Sum of squares", "source": "Translate Swift to Python: func sumSq(s: [Int]) -> Int {\n  return s.map{$0 * $0}.reduce(0, +)\n}\n", "target": "sum([1, 2, 3, 4]\u00b2)\n"}
{"id": 118956, "name": "Convert seconds to compound duration", "source": "Translate Swift to C#: func duration (_ secs:Int) -> String {\n    if secs <= 0 { return \"\" }\n    let units = [(604800,\"wk\"), (86400,\"d\"), (3600,\"hr\"),  (60,\"min\")]\n    var secs = secs\n    var result = \"\"\n    for (period, unit) in units {\n        if secs >= period {\n            result +=  \"\\(secs/period) \\(unit), \"\n            secs = secs % period\n        }\n    }\n    if secs == 0 {\n        result.removeLast(2) \n    } else {\n        result += \"\\(secs) sec\"\n    }\n    return result\n}\n \nprint(duration(7259))\nprint(duration(86400))\nprint(duration(6000000))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ConvertSecondsToCompoundDuration\n{\n  class Program\n  {\n    static void Main( string[] args )\n    {\n      foreach ( string arg in args )\n      {\n        int duration ;\n        bool isValid = int.TryParse( arg , out duration ) ;\n\n        if ( !isValid     ) { Console.Error.WriteLine( \"ERROR: Not an integer: {0}\"           , arg ) ; }\n        if ( duration < 0 ) { Console.Error.WriteLine( \"ERROR: duration must be non-negative\" , arg ) ; }\n        \n        Console.WriteLine();\n        Console.WriteLine( \"{0:#,##0} seconds ==> {1}\" , duration , FormatAsDuration(duration) ) ;\n        \n      }\n    }\n    \n    private static string FormatAsDuration( int duration )\n    {\n      if ( duration < 0 ) throw new ArgumentOutOfRangeException(\"duration\") ;\n      return string.Join( \", \" , GetDurationParts(duration)  ) ;\n    }\n    \n    private static IEnumerable<string> GetDurationParts( int duration )\n    {\n      var parts = new[]\n      {\n        new { Name=\"wk\" , Length = 7*24*60*60*1 , } ,\n        new { Name=\"d\"  , Length =   24*60*60*1 , } ,\n        new { Name=\"h\"  , Length =      60*60*1 , } ,\n        new { Name=\"m\"  , Length =         60*1 , } ,\n        new { Name=\"s\"  , Length =            1 , } ,\n      } ;\n      \n      foreach ( var part in parts )\n      {\n        int n = Math.DivRem( duration , part.Length , out duration ) ;\n        if ( n > 0 ) yield return string.Format( \"{0} {1}\" , n , part.Name ) ;\n      }\n      \n    }\n    \n  }\n  \n}\n"}
{"id": 118957, "name": "Convert seconds to compound duration", "source": "Translate Swift to C#: func duration (_ secs:Int) -> String {\n    if secs <= 0 { return \"\" }\n    let units = [(604800,\"wk\"), (86400,\"d\"), (3600,\"hr\"),  (60,\"min\")]\n    var secs = secs\n    var result = \"\"\n    for (period, unit) in units {\n        if secs >= period {\n            result +=  \"\\(secs/period) \\(unit), \"\n            secs = secs % period\n        }\n    }\n    if secs == 0 {\n        result.removeLast(2) \n    } else {\n        result += \"\\(secs) sec\"\n    }\n    return result\n}\n \nprint(duration(7259))\nprint(duration(86400))\nprint(duration(6000000))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ConvertSecondsToCompoundDuration\n{\n  class Program\n  {\n    static void Main( string[] args )\n    {\n      foreach ( string arg in args )\n      {\n        int duration ;\n        bool isValid = int.TryParse( arg , out duration ) ;\n\n        if ( !isValid     ) { Console.Error.WriteLine( \"ERROR: Not an integer: {0}\"           , arg ) ; }\n        if ( duration < 0 ) { Console.Error.WriteLine( \"ERROR: duration must be non-negative\" , arg ) ; }\n        \n        Console.WriteLine();\n        Console.WriteLine( \"{0:#,##0} seconds ==> {1}\" , duration , FormatAsDuration(duration) ) ;\n        \n      }\n    }\n    \n    private static string FormatAsDuration( int duration )\n    {\n      if ( duration < 0 ) throw new ArgumentOutOfRangeException(\"duration\") ;\n      return string.Join( \", \" , GetDurationParts(duration)  ) ;\n    }\n    \n    private static IEnumerable<string> GetDurationParts( int duration )\n    {\n      var parts = new[]\n      {\n        new { Name=\"wk\" , Length = 7*24*60*60*1 , } ,\n        new { Name=\"d\"  , Length =   24*60*60*1 , } ,\n        new { Name=\"h\"  , Length =      60*60*1 , } ,\n        new { Name=\"m\"  , Length =         60*1 , } ,\n        new { Name=\"s\"  , Length =            1 , } ,\n      } ;\n      \n      foreach ( var part in parts )\n      {\n        int n = Math.DivRem( duration , part.Length , out duration ) ;\n        if ( n > 0 ) yield return string.Format( \"{0} {1}\" , n , part.Name ) ;\n      }\n      \n    }\n    \n  }\n  \n}\n"}
{"id": 118960, "name": "Convert seconds to compound duration", "source": "Translate Swift to Java: func duration (_ secs:Int) -> String {\n    if secs <= 0 { return \"\" }\n    let units = [(604800,\"wk\"), (86400,\"d\"), (3600,\"hr\"),  (60,\"min\")]\n    var secs = secs\n    var result = \"\"\n    for (period, unit) in units {\n        if secs >= period {\n            result +=  \"\\(secs/period) \\(unit), \"\n            secs = secs % period\n        }\n    }\n    if secs == 0 {\n        result.removeLast(2) \n    } else {\n        result += \"\\(secs) sec\"\n    }\n    return result\n}\n \nprint(duration(7259))\nprint(duration(86400))\nprint(duration(6000000))\n", "target": "public class CompoundDuration {\n\n    public static void main(String[] args) {\n        compound(7259);\n        compound(86400);\n        compound(6000_000);\n    }\n\n    private static void compound(long seconds) {\n        StringBuilder sb = new StringBuilder();\n\n        seconds = addUnit(sb, seconds, 604800, \" wk, \");\n        seconds = addUnit(sb, seconds, 86400, \" d, \");\n        seconds = addUnit(sb, seconds, 3600, \" hr, \");\n        seconds = addUnit(sb, seconds, 60, \" min, \");\n        addUnit(sb, seconds, 1, \" sec, \");\n\n        sb.setLength(sb.length() > 2 ? sb.length() - 2 : 0);\n\n        System.out.println(sb);\n    }\n\n    private static long addUnit(StringBuilder sb, long sec, long unit, String s) {\n        long n;\n        if ((n = sec / unit) > 0) {\n            sb.append(n).append(s);\n            sec %= (n * unit);\n        }\n        return sec;\n    }\n}\n"}
{"id": 118961, "name": "Convert seconds to compound duration", "source": "Translate Swift to Java: func duration (_ secs:Int) -> String {\n    if secs <= 0 { return \"\" }\n    let units = [(604800,\"wk\"), (86400,\"d\"), (3600,\"hr\"),  (60,\"min\")]\n    var secs = secs\n    var result = \"\"\n    for (period, unit) in units {\n        if secs >= period {\n            result +=  \"\\(secs/period) \\(unit), \"\n            secs = secs % period\n        }\n    }\n    if secs == 0 {\n        result.removeLast(2) \n    } else {\n        result += \"\\(secs) sec\"\n    }\n    return result\n}\n \nprint(duration(7259))\nprint(duration(86400))\nprint(duration(6000000))\n", "target": "public class CompoundDuration {\n\n    public static void main(String[] args) {\n        compound(7259);\n        compound(86400);\n        compound(6000_000);\n    }\n\n    private static void compound(long seconds) {\n        StringBuilder sb = new StringBuilder();\n\n        seconds = addUnit(sb, seconds, 604800, \" wk, \");\n        seconds = addUnit(sb, seconds, 86400, \" d, \");\n        seconds = addUnit(sb, seconds, 3600, \" hr, \");\n        seconds = addUnit(sb, seconds, 60, \" min, \");\n        addUnit(sb, seconds, 1, \" sec, \");\n\n        sb.setLength(sb.length() > 2 ? sb.length() - 2 : 0);\n\n        System.out.println(sb);\n    }\n\n    private static long addUnit(StringBuilder sb, long sec, long unit, String s) {\n        long n;\n        if ((n = sec / unit) > 0) {\n            sb.append(n).append(s);\n            sec %= (n * unit);\n        }\n        return sec;\n    }\n}\n"}
{"id": 118962, "name": "Convert seconds to compound duration", "source": "Translate Swift to Python: func duration (_ secs:Int) -> String {\n    if secs <= 0 { return \"\" }\n    let units = [(604800,\"wk\"), (86400,\"d\"), (3600,\"hr\"),  (60,\"min\")]\n    var secs = secs\n    var result = \"\"\n    for (period, unit) in units {\n        if secs >= period {\n            result +=  \"\\(secs/period) \\(unit), \"\n            secs = secs % period\n        }\n    }\n    if secs == 0 {\n        result.removeLast(2) \n    } else {\n        result += \"\\(secs) sec\"\n    }\n    return result\n}\n \nprint(duration(7259))\nprint(duration(86400))\nprint(duration(6000000))\n", "target": ">>> def duration(seconds):\n\tt= []\n\tfor dm in (60, 60, 24, 7):\n\t\tseconds, m = divmod(seconds, dm)\n\t\tt.append(m)\n\tt.append(seconds)\n\treturn ', '.join('%d %s' % (num, unit)\n\t\t\t for num, unit in zip(t[::-1], 'wk d hr min sec'.split())\n\t\t\t if num)\n\n>>> for seconds in [7259, 86400, 6000000]:\n\tprint(\"%7d sec = %s\" % (seconds, duration(seconds)))\n\n\t\n   7259 sec = 2 hr, 59 sec\n  86400 sec = 1 d\n6000000 sec = 9 wk, 6 d, 10 hr, 40 min\n>>>\n"}
{"id": 118963, "name": "Convert seconds to compound duration", "source": "Translate Swift to Python: func duration (_ secs:Int) -> String {\n    if secs <= 0 { return \"\" }\n    let units = [(604800,\"wk\"), (86400,\"d\"), (3600,\"hr\"),  (60,\"min\")]\n    var secs = secs\n    var result = \"\"\n    for (period, unit) in units {\n        if secs >= period {\n            result +=  \"\\(secs/period) \\(unit), \"\n            secs = secs % period\n        }\n    }\n    if secs == 0 {\n        result.removeLast(2) \n    } else {\n        result += \"\\(secs) sec\"\n    }\n    return result\n}\n \nprint(duration(7259))\nprint(duration(86400))\nprint(duration(6000000))\n", "target": ">>> def duration(seconds):\n\tt= []\n\tfor dm in (60, 60, 24, 7):\n\t\tseconds, m = divmod(seconds, dm)\n\t\tt.append(m)\n\tt.append(seconds)\n\treturn ', '.join('%d %s' % (num, unit)\n\t\t\t for num, unit in zip(t[::-1], 'wk d hr min sec'.split())\n\t\t\t if num)\n\n>>> for seconds in [7259, 86400, 6000000]:\n\tprint(\"%7d sec = %s\" % (seconds, duration(seconds)))\n\n\t\n   7259 sec = 2 hr, 59 sec\n  86400 sec = 1 d\n6000000 sec = 9 wk, 6 d, 10 hr, 40 min\n>>>\n"}
{"id": 119437, "name": "Loops_Do-while", "source": "Translate Swift to C#: var val = 0\nrepeat {\n  val += 1\n  print(val)\n} while val % 6 != 0\n", "target": "int a = 0;\n\ndo\n{\n    a += 1;\n    Console.WriteLine(a);\n} while (a % 6 != 0);\n"}
{"id": 119439, "name": "Loops_Do-while", "source": "Translate Swift to Java: var val = 0\nrepeat {\n  val += 1\n  print(val)\n} while val % 6 != 0\n", "target": "int val = 0;\ndo{\n   val++;\n   System.out.println(val);\n}while(val % 6 != 0);\n"}
{"id": 119440, "name": "Loops_Do-while", "source": "Translate Swift to Python: var val = 0\nrepeat {\n  val += 1\n  print(val)\n} while val % 6 != 0\n", "target": "val = 0\nwhile True:\n   val +=1\n   print val\n   if val % 6 == 0: break\n"}
{"id": 119790, "name": "Cheryl's birthday", "source": "Translate Swift to C#: struct MonthDay: CustomStringConvertible {\n  static let months = [\n    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n  ]\n\n  var month: Int\n  var day: Int\n\n  var description: String { \"\\(MonthDay.months[month - 1]) \\(day)\" }\n\n  private func isUniqueIn(months: [MonthDay], by prop: KeyPath<MonthDay, Int>) -> Bool {\n    return months.lazy.filter({ $0[keyPath: prop] == self[keyPath: prop] }).count == 1\n  }\n\n  func monthIsUniqueIn(months: [MonthDay]) -> Bool {\n    return isUniqueIn(months: months, by: \\.month)\n  }\n\n  func dayIsUniqueIn(months: [MonthDay]) -> Bool {\n    return isUniqueIn(months: months, by: \\.day)\n  }\n\n  func monthWithUniqueDayIn(months: [MonthDay]) -> Bool {\n    return months.firstIndex(where: { $0.month == month && $0.dayIsUniqueIn(months: months) }) != nil\n  }\n}\n\nlet choices = [\n  MonthDay(month: 5, day: 15),\n  MonthDay(month: 5, day: 16),\n  MonthDay(month: 5, day: 19),\n  MonthDay(month: 6, day: 17),\n  MonthDay(month: 6, day: 18),\n  MonthDay(month: 7, day: 14),\n  MonthDay(month: 7, day: 16),\n  MonthDay(month: 8, day: 14),\n  MonthDay(month: 8, day: 15),\n  MonthDay(month: 8, day: 17)\n]\n\n\nlet albertKnows = choices.filter({ !$0.monthIsUniqueIn(months: choices) })\n\n\nlet bernardKnows = albertKnows.filter({ !$0.monthWithUniqueDayIn(months: albertKnows) })\n\n\nlet bernardKnowsMore = bernardKnows.filter({ $0.dayIsUniqueIn(months: bernardKnows) })\n\n\nguard let birthday = bernardKnowsMore.filter({ $0.monthIsUniqueIn(months: bernardKnowsMore) }).first else {\n  fatalError()\n}\n\nprint(\"Cheryl's birthday is \\(birthday)\")\n", "target": "public static class CherylsBirthday\n{\n    public static void Main() {\n        var dates = new HashSet<(string month, int day)> {\n            (\"May\", 15),\n            (\"May\", 16),\n            (\"May\", 19),\n            (\"June\", 17),\n            (\"June\", 18),\n            (\"July\", 14),\n            (\"July\", 16),\n            (\"August\", 14),\n            (\"August\", 15),\n            (\"August\", 17)\n        };\n\n        Console.WriteLine(dates.Count + \" remaining.\");\n        \n        var monthsWithUniqueDays = dates.GroupBy(d => d.day).Where(g => g.Count() == 1).Select(g => g.First().month).ToHashSet();\n        dates.RemoveWhere(d => monthsWithUniqueDays.Contains(d.month));\n        Console.WriteLine(dates.Count + \" remaining.\");\n        \n        dates.IntersectWith(dates.GroupBy(d => d.day).Where(g => g.Count() == 1).Select(g => g.First()));\n        Console.WriteLine(dates.Count + \" remaining.\");\n        \n        dates.IntersectWith(dates.GroupBy(d => d.month).Where(g => g.Count() == 1).Select(g => g.First()));\n        Console.WriteLine(dates.Single());\n    }\n    \n}\n"}
{"id": 119791, "name": "Cheryl's birthday", "source": "Translate Swift to C#: struct MonthDay: CustomStringConvertible {\n  static let months = [\n    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n  ]\n\n  var month: Int\n  var day: Int\n\n  var description: String { \"\\(MonthDay.months[month - 1]) \\(day)\" }\n\n  private func isUniqueIn(months: [MonthDay], by prop: KeyPath<MonthDay, Int>) -> Bool {\n    return months.lazy.filter({ $0[keyPath: prop] == self[keyPath: prop] }).count == 1\n  }\n\n  func monthIsUniqueIn(months: [MonthDay]) -> Bool {\n    return isUniqueIn(months: months, by: \\.month)\n  }\n\n  func dayIsUniqueIn(months: [MonthDay]) -> Bool {\n    return isUniqueIn(months: months, by: \\.day)\n  }\n\n  func monthWithUniqueDayIn(months: [MonthDay]) -> Bool {\n    return months.firstIndex(where: { $0.month == month && $0.dayIsUniqueIn(months: months) }) != nil\n  }\n}\n\nlet choices = [\n  MonthDay(month: 5, day: 15),\n  MonthDay(month: 5, day: 16),\n  MonthDay(month: 5, day: 19),\n  MonthDay(month: 6, day: 17),\n  MonthDay(month: 6, day: 18),\n  MonthDay(month: 7, day: 14),\n  MonthDay(month: 7, day: 16),\n  MonthDay(month: 8, day: 14),\n  MonthDay(month: 8, day: 15),\n  MonthDay(month: 8, day: 17)\n]\n\n\nlet albertKnows = choices.filter({ !$0.monthIsUniqueIn(months: choices) })\n\n\nlet bernardKnows = albertKnows.filter({ !$0.monthWithUniqueDayIn(months: albertKnows) })\n\n\nlet bernardKnowsMore = bernardKnows.filter({ $0.dayIsUniqueIn(months: bernardKnows) })\n\n\nguard let birthday = bernardKnowsMore.filter({ $0.monthIsUniqueIn(months: bernardKnowsMore) }).first else {\n  fatalError()\n}\n\nprint(\"Cheryl's birthday is \\(birthday)\")\n", "target": "public static class CherylsBirthday\n{\n    public static void Main() {\n        var dates = new HashSet<(string month, int day)> {\n            (\"May\", 15),\n            (\"May\", 16),\n            (\"May\", 19),\n            (\"June\", 17),\n            (\"June\", 18),\n            (\"July\", 14),\n            (\"July\", 16),\n            (\"August\", 14),\n            (\"August\", 15),\n            (\"August\", 17)\n        };\n\n        Console.WriteLine(dates.Count + \" remaining.\");\n        \n        var monthsWithUniqueDays = dates.GroupBy(d => d.day).Where(g => g.Count() == 1).Select(g => g.First().month).ToHashSet();\n        dates.RemoveWhere(d => monthsWithUniqueDays.Contains(d.month));\n        Console.WriteLine(dates.Count + \" remaining.\");\n        \n        dates.IntersectWith(dates.GroupBy(d => d.day).Where(g => g.Count() == 1).Select(g => g.First()));\n        Console.WriteLine(dates.Count + \" remaining.\");\n        \n        dates.IntersectWith(dates.GroupBy(d => d.month).Where(g => g.Count() == 1).Select(g => g.First()));\n        Console.WriteLine(dates.Single());\n    }\n    \n}\n"}
{"id": 119794, "name": "Cheryl's birthday", "source": "Translate Swift to Java: struct MonthDay: CustomStringConvertible {\n  static let months = [\n    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n  ]\n\n  var month: Int\n  var day: Int\n\n  var description: String { \"\\(MonthDay.months[month - 1]) \\(day)\" }\n\n  private func isUniqueIn(months: [MonthDay], by prop: KeyPath<MonthDay, Int>) -> Bool {\n    return months.lazy.filter({ $0[keyPath: prop] == self[keyPath: prop] }).count == 1\n  }\n\n  func monthIsUniqueIn(months: [MonthDay]) -> Bool {\n    return isUniqueIn(months: months, by: \\.month)\n  }\n\n  func dayIsUniqueIn(months: [MonthDay]) -> Bool {\n    return isUniqueIn(months: months, by: \\.day)\n  }\n\n  func monthWithUniqueDayIn(months: [MonthDay]) -> Bool {\n    return months.firstIndex(where: { $0.month == month && $0.dayIsUniqueIn(months: months) }) != nil\n  }\n}\n\nlet choices = [\n  MonthDay(month: 5, day: 15),\n  MonthDay(month: 5, day: 16),\n  MonthDay(month: 5, day: 19),\n  MonthDay(month: 6, day: 17),\n  MonthDay(month: 6, day: 18),\n  MonthDay(month: 7, day: 14),\n  MonthDay(month: 7, day: 16),\n  MonthDay(month: 8, day: 14),\n  MonthDay(month: 8, day: 15),\n  MonthDay(month: 8, day: 17)\n]\n\n\nlet albertKnows = choices.filter({ !$0.monthIsUniqueIn(months: choices) })\n\n\nlet bernardKnows = albertKnows.filter({ !$0.monthWithUniqueDayIn(months: albertKnows) })\n\n\nlet bernardKnowsMore = bernardKnows.filter({ $0.dayIsUniqueIn(months: bernardKnows) })\n\n\nguard let birthday = bernardKnowsMore.filter({ $0.monthIsUniqueIn(months: bernardKnowsMore) }).first else {\n  fatalError()\n}\n\nprint(\"Cheryl's birthday is \\(birthday)\")\n", "target": "import java.time.Month;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    private static class Birthday {\n        private Month month;\n        private int day;\n\n        public Birthday(Month month, int day) {\n            this.month = month;\n            this.day = day;\n        }\n\n        public Month getMonth() {\n            return month;\n        }\n\n        public int getDay() {\n            return day;\n        }\n\n        @Override\n        public String toString() {\n            return month + \" \" + day;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Birthday> choices = List.of(\n            new Birthday(Month.MAY, 15),\n            new Birthday(Month.MAY, 16),\n            new Birthday(Month.MAY, 19),\n            new Birthday(Month.JUNE, 17),\n            new Birthday(Month.JUNE, 18),\n            new Birthday(Month.JULY, 14),\n            new Birthday(Month.JULY, 16),\n            new Birthday(Month.AUGUST, 14),\n            new Birthday(Month.AUGUST, 15),\n            new Birthday(Month.AUGUST, 17)\n        );\n        System.out.printf(\"There are %d candidates remaining.\\n\", choices.size());\n\n        \n        Set<Month> uniqueMonths = choices.stream()\n            .collect(Collectors.groupingBy(Birthday::getDay))\n            .values()\n            .stream()\n            .filter(g -> g.size() == 1)\n            .flatMap(Collection::stream)\n            .map(Birthday::getMonth)\n            .collect(Collectors.toSet());\n        List<Birthday> f1List = choices.stream()\n            .filter(birthday -> !uniqueMonths.contains(birthday.month))\n            .collect(Collectors.toList());\n        System.out.printf(\"There are %d candidates remaining.\\n\", f1List.size());\n\n        \n        List<Birthday> f2List = f1List.stream()\n            .collect(Collectors.groupingBy(Birthday::getDay))\n            .values()\n            .stream()\n            .filter(g -> g.size() == 1)\n            .flatMap(Collection::stream)\n            .collect(Collectors.toList());\n        System.out.printf(\"There are %d candidates remaining.\\n\", f2List.size());\n\n        \n        List<Birthday> f3List = f2List.stream()\n            .collect(Collectors.groupingBy(Birthday::getMonth))\n            .values()\n            .stream()\n            .filter(g -> g.size() == 1)\n            .flatMap(Collection::stream)\n            .collect(Collectors.toList());\n        System.out.printf(\"There are %d candidates remaining.\\n\", f3List.size());\n\n        if (f3List.size() == 1) {\n            System.out.printf(\"Cheryl's birthday is %s\\n\", f3List.get(0));\n        } else {\n            System.out.println(\"No unique choice found\");\n        }\n    }\n}\n"}
{"id": 119795, "name": "Cheryl's birthday", "source": "Translate Swift to Java: struct MonthDay: CustomStringConvertible {\n  static let months = [\n    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n  ]\n\n  var month: Int\n  var day: Int\n\n  var description: String { \"\\(MonthDay.months[month - 1]) \\(day)\" }\n\n  private func isUniqueIn(months: [MonthDay], by prop: KeyPath<MonthDay, Int>) -> Bool {\n    return months.lazy.filter({ $0[keyPath: prop] == self[keyPath: prop] }).count == 1\n  }\n\n  func monthIsUniqueIn(months: [MonthDay]) -> Bool {\n    return isUniqueIn(months: months, by: \\.month)\n  }\n\n  func dayIsUniqueIn(months: [MonthDay]) -> Bool {\n    return isUniqueIn(months: months, by: \\.day)\n  }\n\n  func monthWithUniqueDayIn(months: [MonthDay]) -> Bool {\n    return months.firstIndex(where: { $0.month == month && $0.dayIsUniqueIn(months: months) }) != nil\n  }\n}\n\nlet choices = [\n  MonthDay(month: 5, day: 15),\n  MonthDay(month: 5, day: 16),\n  MonthDay(month: 5, day: 19),\n  MonthDay(month: 6, day: 17),\n  MonthDay(month: 6, day: 18),\n  MonthDay(month: 7, day: 14),\n  MonthDay(month: 7, day: 16),\n  MonthDay(month: 8, day: 14),\n  MonthDay(month: 8, day: 15),\n  MonthDay(month: 8, day: 17)\n]\n\n\nlet albertKnows = choices.filter({ !$0.monthIsUniqueIn(months: choices) })\n\n\nlet bernardKnows = albertKnows.filter({ !$0.monthWithUniqueDayIn(months: albertKnows) })\n\n\nlet bernardKnowsMore = bernardKnows.filter({ $0.dayIsUniqueIn(months: bernardKnows) })\n\n\nguard let birthday = bernardKnowsMore.filter({ $0.monthIsUniqueIn(months: bernardKnowsMore) }).first else {\n  fatalError()\n}\n\nprint(\"Cheryl's birthday is \\(birthday)\")\n", "target": "import java.time.Month;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    private static class Birthday {\n        private Month month;\n        private int day;\n\n        public Birthday(Month month, int day) {\n            this.month = month;\n            this.day = day;\n        }\n\n        public Month getMonth() {\n            return month;\n        }\n\n        public int getDay() {\n            return day;\n        }\n\n        @Override\n        public String toString() {\n            return month + \" \" + day;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Birthday> choices = List.of(\n            new Birthday(Month.MAY, 15),\n            new Birthday(Month.MAY, 16),\n            new Birthday(Month.MAY, 19),\n            new Birthday(Month.JUNE, 17),\n            new Birthday(Month.JUNE, 18),\n            new Birthday(Month.JULY, 14),\n            new Birthday(Month.JULY, 16),\n            new Birthday(Month.AUGUST, 14),\n            new Birthday(Month.AUGUST, 15),\n            new Birthday(Month.AUGUST, 17)\n        );\n        System.out.printf(\"There are %d candidates remaining.\\n\", choices.size());\n\n        \n        Set<Month> uniqueMonths = choices.stream()\n            .collect(Collectors.groupingBy(Birthday::getDay))\n            .values()\n            .stream()\n            .filter(g -> g.size() == 1)\n            .flatMap(Collection::stream)\n            .map(Birthday::getMonth)\n            .collect(Collectors.toSet());\n        List<Birthday> f1List = choices.stream()\n            .filter(birthday -> !uniqueMonths.contains(birthday.month))\n            .collect(Collectors.toList());\n        System.out.printf(\"There are %d candidates remaining.\\n\", f1List.size());\n\n        \n        List<Birthday> f2List = f1List.stream()\n            .collect(Collectors.groupingBy(Birthday::getDay))\n            .values()\n            .stream()\n            .filter(g -> g.size() == 1)\n            .flatMap(Collection::stream)\n            .collect(Collectors.toList());\n        System.out.printf(\"There are %d candidates remaining.\\n\", f2List.size());\n\n        \n        List<Birthday> f3List = f2List.stream()\n            .collect(Collectors.groupingBy(Birthday::getMonth))\n            .values()\n            .stream()\n            .filter(g -> g.size() == 1)\n            .flatMap(Collection::stream)\n            .collect(Collectors.toList());\n        System.out.printf(\"There are %d candidates remaining.\\n\", f3List.size());\n\n        if (f3List.size() == 1) {\n            System.out.printf(\"Cheryl's birthday is %s\\n\", f3List.get(0));\n        } else {\n            System.out.println(\"No unique choice found\");\n        }\n    }\n}\n"}
{"id": 119796, "name": "Cheryl's birthday", "source": "Translate Swift to Python: struct MonthDay: CustomStringConvertible {\n  static let months = [\n    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n  ]\n\n  var month: Int\n  var day: Int\n\n  var description: String { \"\\(MonthDay.months[month - 1]) \\(day)\" }\n\n  private func isUniqueIn(months: [MonthDay], by prop: KeyPath<MonthDay, Int>) -> Bool {\n    return months.lazy.filter({ $0[keyPath: prop] == self[keyPath: prop] }).count == 1\n  }\n\n  func monthIsUniqueIn(months: [MonthDay]) -> Bool {\n    return isUniqueIn(months: months, by: \\.month)\n  }\n\n  func dayIsUniqueIn(months: [MonthDay]) -> Bool {\n    return isUniqueIn(months: months, by: \\.day)\n  }\n\n  func monthWithUniqueDayIn(months: [MonthDay]) -> Bool {\n    return months.firstIndex(where: { $0.month == month && $0.dayIsUniqueIn(months: months) }) != nil\n  }\n}\n\nlet choices = [\n  MonthDay(month: 5, day: 15),\n  MonthDay(month: 5, day: 16),\n  MonthDay(month: 5, day: 19),\n  MonthDay(month: 6, day: 17),\n  MonthDay(month: 6, day: 18),\n  MonthDay(month: 7, day: 14),\n  MonthDay(month: 7, day: 16),\n  MonthDay(month: 8, day: 14),\n  MonthDay(month: 8, day: 15),\n  MonthDay(month: 8, day: 17)\n]\n\n\nlet albertKnows = choices.filter({ !$0.monthIsUniqueIn(months: choices) })\n\n\nlet bernardKnows = albertKnows.filter({ !$0.monthWithUniqueDayIn(months: albertKnows) })\n\n\nlet bernardKnowsMore = bernardKnows.filter({ $0.dayIsUniqueIn(months: bernardKnows) })\n\n\nguard let birthday = bernardKnowsMore.filter({ $0.monthIsUniqueIn(months: bernardKnowsMore) }).first else {\n  fatalError()\n}\n\nprint(\"Cheryl's birthday is \\(birthday)\")\n", "target": "\n\nfrom itertools import groupby\nfrom re import split\n\n\n\ndef main():\n    \n\n    month, day = 0, 1\n    print(\n        \n        \n        uniquePairing(month)(\n            \n            \n            uniquePairing(day)(\n                \n                \n                monthsWithUniqueDays(False)([\n                    \n                    tuple(x.split()) for x in\n                    split(\n                        ', ',\n                        'May 15, May 16, May 19, ' +\n                        'June 17, June 18, ' +\n                        'July 14, July 16, ' +\n                        'Aug 14, Aug 15, Aug 17'\n                    )\n                ])\n            )\n        )\n    )\n\n\n\n\n\ndef monthsWithUniqueDays(blnInclude):\n    \n    def go(xs):\n        month, day = 0, 1\n        months = [fst(x) for x in uniquePairing(day)(xs)]\n        return [\n            md for md in xs\n            if blnInclude or not (md[month] in months)\n        ]\n    return go\n\n\n\ndef uniquePairing(i):\n    \n    def go(xs):\n        def inner(md):\n            dct = md[i]\n            uniques = [\n                k for k in dct.keys()\n                if 1 == len(dct[k])\n            ]\n            return [tpl for tpl in xs if tpl[i] in uniques]\n        return inner\n    return ap(bindPairs)(go)\n\n\n\n\n\ndef bindPairs(xs):\n    \n    return lambda f: f(\n        (\n            dictFromPairs(xs),\n            dictFromPairs(\n                [(b, a) for (a, b) in xs]\n            )\n        )\n    )\n\n\n\ndef dictFromPairs(xs):\n    \n    return {\n        k: [snd(x) for x in m] for k, m in groupby(\n            sorted(xs, key=fst), key=fst\n        )\n    }\n\n\n\n\n\ndef ap(f):\n    \n    def go(g):\n        def fxgx(x):\n            return f(x)(\n                g(x)\n            )\n        return fxgx\n    return go\n\n\n\ndef fst(tpl):\n    \n    return tpl[0]\n\n\n\ndef snd(tpl):\n    \n    return tpl[1]\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 119797, "name": "Cheryl's birthday", "source": "Translate Swift to Python: struct MonthDay: CustomStringConvertible {\n  static let months = [\n    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n  ]\n\n  var month: Int\n  var day: Int\n\n  var description: String { \"\\(MonthDay.months[month - 1]) \\(day)\" }\n\n  private func isUniqueIn(months: [MonthDay], by prop: KeyPath<MonthDay, Int>) -> Bool {\n    return months.lazy.filter({ $0[keyPath: prop] == self[keyPath: prop] }).count == 1\n  }\n\n  func monthIsUniqueIn(months: [MonthDay]) -> Bool {\n    return isUniqueIn(months: months, by: \\.month)\n  }\n\n  func dayIsUniqueIn(months: [MonthDay]) -> Bool {\n    return isUniqueIn(months: months, by: \\.day)\n  }\n\n  func monthWithUniqueDayIn(months: [MonthDay]) -> Bool {\n    return months.firstIndex(where: { $0.month == month && $0.dayIsUniqueIn(months: months) }) != nil\n  }\n}\n\nlet choices = [\n  MonthDay(month: 5, day: 15),\n  MonthDay(month: 5, day: 16),\n  MonthDay(month: 5, day: 19),\n  MonthDay(month: 6, day: 17),\n  MonthDay(month: 6, day: 18),\n  MonthDay(month: 7, day: 14),\n  MonthDay(month: 7, day: 16),\n  MonthDay(month: 8, day: 14),\n  MonthDay(month: 8, day: 15),\n  MonthDay(month: 8, day: 17)\n]\n\n\nlet albertKnows = choices.filter({ !$0.monthIsUniqueIn(months: choices) })\n\n\nlet bernardKnows = albertKnows.filter({ !$0.monthWithUniqueDayIn(months: albertKnows) })\n\n\nlet bernardKnowsMore = bernardKnows.filter({ $0.dayIsUniqueIn(months: bernardKnows) })\n\n\nguard let birthday = bernardKnowsMore.filter({ $0.monthIsUniqueIn(months: bernardKnowsMore) }).first else {\n  fatalError()\n}\n\nprint(\"Cheryl's birthday is \\(birthday)\")\n", "target": "\n\nfrom itertools import groupby\nfrom re import split\n\n\n\ndef main():\n    \n\n    month, day = 0, 1\n    print(\n        \n        \n        uniquePairing(month)(\n            \n            \n            uniquePairing(day)(\n                \n                \n                monthsWithUniqueDays(False)([\n                    \n                    tuple(x.split()) for x in\n                    split(\n                        ', ',\n                        'May 15, May 16, May 19, ' +\n                        'June 17, June 18, ' +\n                        'July 14, July 16, ' +\n                        'Aug 14, Aug 15, Aug 17'\n                    )\n                ])\n            )\n        )\n    )\n\n\n\n\n\ndef monthsWithUniqueDays(blnInclude):\n    \n    def go(xs):\n        month, day = 0, 1\n        months = [fst(x) for x in uniquePairing(day)(xs)]\n        return [\n            md for md in xs\n            if blnInclude or not (md[month] in months)\n        ]\n    return go\n\n\n\ndef uniquePairing(i):\n    \n    def go(xs):\n        def inner(md):\n            dct = md[i]\n            uniques = [\n                k for k in dct.keys()\n                if 1 == len(dct[k])\n            ]\n            return [tpl for tpl in xs if tpl[i] in uniques]\n        return inner\n    return ap(bindPairs)(go)\n\n\n\n\n\ndef bindPairs(xs):\n    \n    return lambda f: f(\n        (\n            dictFromPairs(xs),\n            dictFromPairs(\n                [(b, a) for (a, b) in xs]\n            )\n        )\n    )\n\n\n\ndef dictFromPairs(xs):\n    \n    return {\n        k: [snd(x) for x in m] for k, m in groupby(\n            sorted(xs, key=fst), key=fst\n        )\n    }\n\n\n\n\n\ndef ap(f):\n    \n    def go(g):\n        def fxgx(x):\n            return f(x)(\n                g(x)\n            )\n        return fxgx\n    return go\n\n\n\ndef fst(tpl):\n    \n    return tpl[0]\n\n\n\ndef snd(tpl):\n    \n    return tpl[1]\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 120913, "name": "100 prisoners", "source": "Translate Swift to C#: import Foundation\n\nstruct PrisonersGame {\n  let strategy: Strategy\n  let numPrisoners: Int\n  let drawers: [Int]\n\n  init(numPrisoners: Int, strategy: Strategy) {\n    self.numPrisoners = numPrisoners\n    self.strategy = strategy\n    self.drawers = (1...numPrisoners).shuffled()\n  }\n\n  @discardableResult\n  func play() -> Bool {\n    for num in 1...numPrisoners {\n      guard findNumber(num) else {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  private func findNumber(_ num: Int) -> Bool {\n    var tries = 0\n    var nextDrawer = num - 1\n\n    while tries < 50 {\n      tries += 1\n\n      switch strategy {\n      case .random where drawers.randomElement()! == num:\n        return true\n      case .optimum where drawers[nextDrawer] == num:\n        return true\n      case .optimum:\n        nextDrawer = drawers[nextDrawer] - 1\n      case _:\n        continue\n      }\n    }\n\n    return false\n  }\n\n  enum Strategy {\n    case random, optimum\n  }\n}\n\nlet numGames = 100_000\nlet lock = DispatchSemaphore(value: 1)\nvar done = 0\n\nprint(\"Running \\(numGames) games for each strategy\")\n\nDispatchQueue.concurrentPerform(iterations: 2) {i in\n  let strat = i == 0 ? PrisonersGame.Strategy.random : .optimum\n  var numPardoned = 0\n\n  for _ in 0..<numGames {\n    let game = PrisonersGame(numPrisoners: 100, strategy: strat)\n\n    if game.play() {\n      numPardoned += 1\n    }\n  }\n\n  print(\"Probability of pardon with \\(strat) strategy: \\(Double(numPardoned) / Double(numGames))\")\n\n  lock.wait()\n  done += 1\n  lock.signal()\n\n  if done == 2 {\n    exit(0)\n  }\n}\n\ndispatchMain()\n", "target": "using System;\nusing System.Linq;\n\nnamespace Prisoners {\n    class Program {\n        static bool PlayOptimal() {\n            var secrets = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n            for (int p = 0; p < 100; p++) {\n                bool success = false;\n\n                var choice = p;\n                for (int i = 0; i < 50; i++) {\n                    if (secrets[choice] == p) {\n                        success = true;\n                        break;\n                    }\n                    choice = secrets[choice];\n                }\n\n                if (!success) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        static bool PlayRandom() {\n            var secrets = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n            for (int p = 0; p < 100; p++) {\n                var choices = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n                bool success = false;\n                for (int i = 0; i < 50; i++) {\n                    if (choices[i] == p) {\n                        success = true;\n                        break;\n                    }\n                }\n\n                if (!success) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        static double Exec(uint n, Func<bool> play) {\n            uint success = 0;\n            for (uint i = 0; i < n; i++) {\n                if (play()) {\n                    success++;\n                }\n            }\n            return 100.0 * success / n;\n        }\n\n        static void Main() {\n            const uint N = 1_000_000;\n            Console.WriteLine(\"# of executions: {0}\", N);\n            Console.WriteLine(\"Optimal play success rate: {0:0.00000000000}%\", Exec(N, PlayOptimal));\n            Console.WriteLine(\" Random play success rate: {0:0.00000000000}%\", Exec(N, PlayRandom));\n        }\n    }\n}\n"}
{"id": 120914, "name": "100 prisoners", "source": "Translate Swift to C#: import Foundation\n\nstruct PrisonersGame {\n  let strategy: Strategy\n  let numPrisoners: Int\n  let drawers: [Int]\n\n  init(numPrisoners: Int, strategy: Strategy) {\n    self.numPrisoners = numPrisoners\n    self.strategy = strategy\n    self.drawers = (1...numPrisoners).shuffled()\n  }\n\n  @discardableResult\n  func play() -> Bool {\n    for num in 1...numPrisoners {\n      guard findNumber(num) else {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  private func findNumber(_ num: Int) -> Bool {\n    var tries = 0\n    var nextDrawer = num - 1\n\n    while tries < 50 {\n      tries += 1\n\n      switch strategy {\n      case .random where drawers.randomElement()! == num:\n        return true\n      case .optimum where drawers[nextDrawer] == num:\n        return true\n      case .optimum:\n        nextDrawer = drawers[nextDrawer] - 1\n      case _:\n        continue\n      }\n    }\n\n    return false\n  }\n\n  enum Strategy {\n    case random, optimum\n  }\n}\n\nlet numGames = 100_000\nlet lock = DispatchSemaphore(value: 1)\nvar done = 0\n\nprint(\"Running \\(numGames) games for each strategy\")\n\nDispatchQueue.concurrentPerform(iterations: 2) {i in\n  let strat = i == 0 ? PrisonersGame.Strategy.random : .optimum\n  var numPardoned = 0\n\n  for _ in 0..<numGames {\n    let game = PrisonersGame(numPrisoners: 100, strategy: strat)\n\n    if game.play() {\n      numPardoned += 1\n    }\n  }\n\n  print(\"Probability of pardon with \\(strat) strategy: \\(Double(numPardoned) / Double(numGames))\")\n\n  lock.wait()\n  done += 1\n  lock.signal()\n\n  if done == 2 {\n    exit(0)\n  }\n}\n\ndispatchMain()\n", "target": "using System;\nusing System.Linq;\n\nnamespace Prisoners {\n    class Program {\n        static bool PlayOptimal() {\n            var secrets = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n            for (int p = 0; p < 100; p++) {\n                bool success = false;\n\n                var choice = p;\n                for (int i = 0; i < 50; i++) {\n                    if (secrets[choice] == p) {\n                        success = true;\n                        break;\n                    }\n                    choice = secrets[choice];\n                }\n\n                if (!success) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        static bool PlayRandom() {\n            var secrets = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n            for (int p = 0; p < 100; p++) {\n                var choices = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n                bool success = false;\n                for (int i = 0; i < 50; i++) {\n                    if (choices[i] == p) {\n                        success = true;\n                        break;\n                    }\n                }\n\n                if (!success) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        static double Exec(uint n, Func<bool> play) {\n            uint success = 0;\n            for (uint i = 0; i < n; i++) {\n                if (play()) {\n                    success++;\n                }\n            }\n            return 100.0 * success / n;\n        }\n\n        static void Main() {\n            const uint N = 1_000_000;\n            Console.WriteLine(\"# of executions: {0}\", N);\n            Console.WriteLine(\"Optimal play success rate: {0:0.00000000000}%\", Exec(N, PlayOptimal));\n            Console.WriteLine(\" Random play success rate: {0:0.00000000000}%\", Exec(N, PlayRandom));\n        }\n    }\n}\n"}
{"id": 120917, "name": "100 prisoners", "source": "Translate Swift to Java: import Foundation\n\nstruct PrisonersGame {\n  let strategy: Strategy\n  let numPrisoners: Int\n  let drawers: [Int]\n\n  init(numPrisoners: Int, strategy: Strategy) {\n    self.numPrisoners = numPrisoners\n    self.strategy = strategy\n    self.drawers = (1...numPrisoners).shuffled()\n  }\n\n  @discardableResult\n  func play() -> Bool {\n    for num in 1...numPrisoners {\n      guard findNumber(num) else {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  private func findNumber(_ num: Int) -> Bool {\n    var tries = 0\n    var nextDrawer = num - 1\n\n    while tries < 50 {\n      tries += 1\n\n      switch strategy {\n      case .random where drawers.randomElement()! == num:\n        return true\n      case .optimum where drawers[nextDrawer] == num:\n        return true\n      case .optimum:\n        nextDrawer = drawers[nextDrawer] - 1\n      case _:\n        continue\n      }\n    }\n\n    return false\n  }\n\n  enum Strategy {\n    case random, optimum\n  }\n}\n\nlet numGames = 100_000\nlet lock = DispatchSemaphore(value: 1)\nvar done = 0\n\nprint(\"Running \\(numGames) games for each strategy\")\n\nDispatchQueue.concurrentPerform(iterations: 2) {i in\n  let strat = i == 0 ? PrisonersGame.Strategy.random : .optimum\n  var numPardoned = 0\n\n  for _ in 0..<numGames {\n    let game = PrisonersGame(numPrisoners: 100, strategy: strat)\n\n    if game.play() {\n      numPardoned += 1\n    }\n  }\n\n  print(\"Probability of pardon with \\(strat) strategy: \\(Double(numPardoned) / Double(numGames))\")\n\n  lock.wait()\n  done += 1\n  lock.signal()\n\n  if done == 2 {\n    exit(0)\n  }\n}\n\ndispatchMain()\n", "target": "import java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Main {\n    private static boolean playOptimal(int n) {\n        List<Integer> secretList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n        Collections.shuffle(secretList);\n\n        prisoner:\n        for (int i = 0; i < secretList.size(); ++i) {\n            int prev = i;\n            for (int j = 0; j < secretList.size() / 2; ++j) {\n                if (secretList.get(prev) == i) {\n                    continue prisoner;\n                }\n                prev = secretList.get(prev);\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private static boolean playRandom(int n) {\n        List<Integer> secretList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n        Collections.shuffle(secretList);\n\n        prisoner:\n        for (Integer i : secretList) {\n            List<Integer> trialList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n            Collections.shuffle(trialList);\n\n            for (int j = 0; j < trialList.size() / 2; ++j) {\n                if (Objects.equals(trialList.get(j), i)) {\n                    continue prisoner;\n                }\n            }\n\n            return false;\n        }\n        return true;\n    }\n\n    private static double exec(int n, int p, Function<Integer, Boolean> play) {\n        int succ = 0;\n        for (int i = 0; i < n; ++i) {\n            if (play.apply(p)) {\n                succ++;\n            }\n        }\n        return (succ * 100.0) / n;\n    }\n\n    public static void main(String[] args) {\n        final int n = 100_000;\n        final int p = 100;\n        System.out.printf(\"# of executions: %d\\n\", n);\n        System.out.printf(\"Optimal play success rate: %f%%\\n\", exec(n, p, Main::playOptimal));\n        System.out.printf(\"Random play success rate: %f%%\\n\", exec(n, p, Main::playRandom));\n    }\n}\n"}
{"id": 120918, "name": "100 prisoners", "source": "Translate Swift to Java: import Foundation\n\nstruct PrisonersGame {\n  let strategy: Strategy\n  let numPrisoners: Int\n  let drawers: [Int]\n\n  init(numPrisoners: Int, strategy: Strategy) {\n    self.numPrisoners = numPrisoners\n    self.strategy = strategy\n    self.drawers = (1...numPrisoners).shuffled()\n  }\n\n  @discardableResult\n  func play() -> Bool {\n    for num in 1...numPrisoners {\n      guard findNumber(num) else {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  private func findNumber(_ num: Int) -> Bool {\n    var tries = 0\n    var nextDrawer = num - 1\n\n    while tries < 50 {\n      tries += 1\n\n      switch strategy {\n      case .random where drawers.randomElement()! == num:\n        return true\n      case .optimum where drawers[nextDrawer] == num:\n        return true\n      case .optimum:\n        nextDrawer = drawers[nextDrawer] - 1\n      case _:\n        continue\n      }\n    }\n\n    return false\n  }\n\n  enum Strategy {\n    case random, optimum\n  }\n}\n\nlet numGames = 100_000\nlet lock = DispatchSemaphore(value: 1)\nvar done = 0\n\nprint(\"Running \\(numGames) games for each strategy\")\n\nDispatchQueue.concurrentPerform(iterations: 2) {i in\n  let strat = i == 0 ? PrisonersGame.Strategy.random : .optimum\n  var numPardoned = 0\n\n  for _ in 0..<numGames {\n    let game = PrisonersGame(numPrisoners: 100, strategy: strat)\n\n    if game.play() {\n      numPardoned += 1\n    }\n  }\n\n  print(\"Probability of pardon with \\(strat) strategy: \\(Double(numPardoned) / Double(numGames))\")\n\n  lock.wait()\n  done += 1\n  lock.signal()\n\n  if done == 2 {\n    exit(0)\n  }\n}\n\ndispatchMain()\n", "target": "import java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Main {\n    private static boolean playOptimal(int n) {\n        List<Integer> secretList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n        Collections.shuffle(secretList);\n\n        prisoner:\n        for (int i = 0; i < secretList.size(); ++i) {\n            int prev = i;\n            for (int j = 0; j < secretList.size() / 2; ++j) {\n                if (secretList.get(prev) == i) {\n                    continue prisoner;\n                }\n                prev = secretList.get(prev);\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private static boolean playRandom(int n) {\n        List<Integer> secretList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n        Collections.shuffle(secretList);\n\n        prisoner:\n        for (Integer i : secretList) {\n            List<Integer> trialList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n            Collections.shuffle(trialList);\n\n            for (int j = 0; j < trialList.size() / 2; ++j) {\n                if (Objects.equals(trialList.get(j), i)) {\n                    continue prisoner;\n                }\n            }\n\n            return false;\n        }\n        return true;\n    }\n\n    private static double exec(int n, int p, Function<Integer, Boolean> play) {\n        int succ = 0;\n        for (int i = 0; i < n; ++i) {\n            if (play.apply(p)) {\n                succ++;\n            }\n        }\n        return (succ * 100.0) / n;\n    }\n\n    public static void main(String[] args) {\n        final int n = 100_000;\n        final int p = 100;\n        System.out.printf(\"# of executions: %d\\n\", n);\n        System.out.printf(\"Optimal play success rate: %f%%\\n\", exec(n, p, Main::playOptimal));\n        System.out.printf(\"Random play success rate: %f%%\\n\", exec(n, p, Main::playRandom));\n    }\n}\n"}
{"id": 120919, "name": "100 prisoners", "source": "Translate Swift to Python: import Foundation\n\nstruct PrisonersGame {\n  let strategy: Strategy\n  let numPrisoners: Int\n  let drawers: [Int]\n\n  init(numPrisoners: Int, strategy: Strategy) {\n    self.numPrisoners = numPrisoners\n    self.strategy = strategy\n    self.drawers = (1...numPrisoners).shuffled()\n  }\n\n  @discardableResult\n  func play() -> Bool {\n    for num in 1...numPrisoners {\n      guard findNumber(num) else {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  private func findNumber(_ num: Int) -> Bool {\n    var tries = 0\n    var nextDrawer = num - 1\n\n    while tries < 50 {\n      tries += 1\n\n      switch strategy {\n      case .random where drawers.randomElement()! == num:\n        return true\n      case .optimum where drawers[nextDrawer] == num:\n        return true\n      case .optimum:\n        nextDrawer = drawers[nextDrawer] - 1\n      case _:\n        continue\n      }\n    }\n\n    return false\n  }\n\n  enum Strategy {\n    case random, optimum\n  }\n}\n\nlet numGames = 100_000\nlet lock = DispatchSemaphore(value: 1)\nvar done = 0\n\nprint(\"Running \\(numGames) games for each strategy\")\n\nDispatchQueue.concurrentPerform(iterations: 2) {i in\n  let strat = i == 0 ? PrisonersGame.Strategy.random : .optimum\n  var numPardoned = 0\n\n  for _ in 0..<numGames {\n    let game = PrisonersGame(numPrisoners: 100, strategy: strat)\n\n    if game.play() {\n      numPardoned += 1\n    }\n  }\n\n  print(\"Probability of pardon with \\(strat) strategy: \\(Double(numPardoned) / Double(numGames))\")\n\n  lock.wait()\n  done += 1\n  lock.signal()\n\n  if done == 2 {\n    exit(0)\n  }\n}\n\ndispatchMain()\n", "target": "import random\n\ndef play_random(n):\n    \n    pardoned = 0\n    in_drawer = list(range(100))\n    sampler = list(range(100))\n    for _round in range(n):\n        random.shuffle(in_drawer)\n        found = False\n        for prisoner in range(100):\n            found = False\n            for reveal in random.sample(sampler, 50):\n                card = in_drawer[reveal]\n                if card == prisoner:\n                    found = True\n                    break\n            if not found:\n                break\n        if found:\n            pardoned += 1\n    return pardoned / n * 100   \n\ndef play_optimal(n):\n    \n    pardoned = 0\n    in_drawer = list(range(100))\n    for _round in range(n):\n        random.shuffle(in_drawer)\n        for prisoner in range(100):\n            reveal = prisoner\n            found = False\n            for go in range(50):\n                card = in_drawer[reveal]\n                if card == prisoner:\n                    found = True\n                    break\n                reveal = card\n            if not found:\n                break\n        if found:\n            pardoned += 1\n    return pardoned / n * 100   \n\nif __name__ == '__main__':\n    n = 100_000\n    print(\" Simulation count:\", n)\n    print(f\" Random play wins: {play_random(n):4.1f}% of simulations\")\n    print(f\"Optimal play wins: {play_optimal(n):4.1f}% of simulations\")\n"}
{"id": 120920, "name": "100 prisoners", "source": "Translate Swift to Python: import Foundation\n\nstruct PrisonersGame {\n  let strategy: Strategy\n  let numPrisoners: Int\n  let drawers: [Int]\n\n  init(numPrisoners: Int, strategy: Strategy) {\n    self.numPrisoners = numPrisoners\n    self.strategy = strategy\n    self.drawers = (1...numPrisoners).shuffled()\n  }\n\n  @discardableResult\n  func play() -> Bool {\n    for num in 1...numPrisoners {\n      guard findNumber(num) else {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  private func findNumber(_ num: Int) -> Bool {\n    var tries = 0\n    var nextDrawer = num - 1\n\n    while tries < 50 {\n      tries += 1\n\n      switch strategy {\n      case .random where drawers.randomElement()! == num:\n        return true\n      case .optimum where drawers[nextDrawer] == num:\n        return true\n      case .optimum:\n        nextDrawer = drawers[nextDrawer] - 1\n      case _:\n        continue\n      }\n    }\n\n    return false\n  }\n\n  enum Strategy {\n    case random, optimum\n  }\n}\n\nlet numGames = 100_000\nlet lock = DispatchSemaphore(value: 1)\nvar done = 0\n\nprint(\"Running \\(numGames) games for each strategy\")\n\nDispatchQueue.concurrentPerform(iterations: 2) {i in\n  let strat = i == 0 ? PrisonersGame.Strategy.random : .optimum\n  var numPardoned = 0\n\n  for _ in 0..<numGames {\n    let game = PrisonersGame(numPrisoners: 100, strategy: strat)\n\n    if game.play() {\n      numPardoned += 1\n    }\n  }\n\n  print(\"Probability of pardon with \\(strat) strategy: \\(Double(numPardoned) / Double(numGames))\")\n\n  lock.wait()\n  done += 1\n  lock.signal()\n\n  if done == 2 {\n    exit(0)\n  }\n}\n\ndispatchMain()\n", "target": "import random\n\ndef play_random(n):\n    \n    pardoned = 0\n    in_drawer = list(range(100))\n    sampler = list(range(100))\n    for _round in range(n):\n        random.shuffle(in_drawer)\n        found = False\n        for prisoner in range(100):\n            found = False\n            for reveal in random.sample(sampler, 50):\n                card = in_drawer[reveal]\n                if card == prisoner:\n                    found = True\n                    break\n            if not found:\n                break\n        if found:\n            pardoned += 1\n    return pardoned / n * 100   \n\ndef play_optimal(n):\n    \n    pardoned = 0\n    in_drawer = list(range(100))\n    for _round in range(n):\n        random.shuffle(in_drawer)\n        for prisoner in range(100):\n            reveal = prisoner\n            found = False\n            for go in range(50):\n                card = in_drawer[reveal]\n                if card == prisoner:\n                    found = True\n                    break\n                reveal = card\n            if not found:\n                break\n        if found:\n            pardoned += 1\n    return pardoned / n * 100   \n\nif __name__ == '__main__':\n    n = 100_000\n    print(\" Simulation count:\", n)\n    print(f\" Random play wins: {play_random(n):4.1f}% of simulations\")\n    print(f\"Optimal play wins: {play_optimal(n):4.1f}% of simulations\")\n"}
{"id": 121834, "name": "Harshad or Niven series", "source": "Translate Swift to C#: struct Harshad: Sequence, IteratorProtocol {\n  private var i = 0\n\n  mutating func next() -> Int? {\n    while true {\n      i += 1\n\n      if i % Array(String(i)).map(String.init).compactMap(Int.init).reduce(0, +) == 0 {\n        return i\n      }\n    }\n  }\n}\n\nprint(\"First 20: \\(Array(Harshad().prefix(20)))\")\nprint(\"First over a 1000: \\(Harshad().first(where: { $0 > 1000 })!)\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Harshad\n{\n    class Program\n    {\n        public static bool IsHarshad(int n)\n        {\n            char[] inputChars = n.ToString().ToCharArray();\n            IList<byte> digits = new List<byte>();\n\n            foreach (char digit in inputChars)\n            {\n                digits.Add((byte)Char.GetNumericValue(digit));\n            }\n\n            if (n < 1)\n            {\n                return false;\n            }\n\n            int sum = 0;\n\n            foreach (byte digit in digits)\n            {\n                sum += digit;\n            }\n\n            return n % sum == 0;\n        }\n\n        static void Main(string[] args)\n        {\n            int i = 1;\n            int count = 0;\n\n            while (true)\n            {\n                if (IsHarshad(i))\n                {\n                    count++;\n\n                    if (count <= 20)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                    }\n                    else if (i > 1000)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                        break;\n                    }\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 121835, "name": "Harshad or Niven series", "source": "Translate Swift to C#: struct Harshad: Sequence, IteratorProtocol {\n  private var i = 0\n\n  mutating func next() -> Int? {\n    while true {\n      i += 1\n\n      if i % Array(String(i)).map(String.init).compactMap(Int.init).reduce(0, +) == 0 {\n        return i\n      }\n    }\n  }\n}\n\nprint(\"First 20: \\(Array(Harshad().prefix(20)))\")\nprint(\"First over a 1000: \\(Harshad().first(where: { $0 > 1000 })!)\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Harshad\n{\n    class Program\n    {\n        public static bool IsHarshad(int n)\n        {\n            char[] inputChars = n.ToString().ToCharArray();\n            IList<byte> digits = new List<byte>();\n\n            foreach (char digit in inputChars)\n            {\n                digits.Add((byte)Char.GetNumericValue(digit));\n            }\n\n            if (n < 1)\n            {\n                return false;\n            }\n\n            int sum = 0;\n\n            foreach (byte digit in digits)\n            {\n                sum += digit;\n            }\n\n            return n % sum == 0;\n        }\n\n        static void Main(string[] args)\n        {\n            int i = 1;\n            int count = 0;\n\n            while (true)\n            {\n                if (IsHarshad(i))\n                {\n                    count++;\n\n                    if (count <= 20)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                    }\n                    else if (i > 1000)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                        break;\n                    }\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 121838, "name": "Harshad or Niven series", "source": "Translate Swift to Java: struct Harshad: Sequence, IteratorProtocol {\n  private var i = 0\n\n  mutating func next() -> Int? {\n    while true {\n      i += 1\n\n      if i % Array(String(i)).map(String.init).compactMap(Int.init).reduce(0, +) == 0 {\n        return i\n      }\n    }\n  }\n}\n\nprint(\"First 20: \\(Array(Harshad().prefix(20)))\")\nprint(\"First over a 1000: \\(Harshad().first(where: { $0 > 1000 })!)\")\n", "target": "public class Harshad{\n    private static long sumDigits(long n){\n        long sum = 0;\n        for(char digit:Long.toString(n).toCharArray()){\n            sum += Character.digit(digit, 10);\n        }\n        return sum;\n    }\n    public static void main(String[] args){\n        for(int count = 0, i = 1; count < 20;i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                count++;\n            }\n        }\n        System.out.println();\n        for(int i = 1001; ; i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                break;\n            }\n        }\n    }\n}\n"}
{"id": 121839, "name": "Harshad or Niven series", "source": "Translate Swift to Java: struct Harshad: Sequence, IteratorProtocol {\n  private var i = 0\n\n  mutating func next() -> Int? {\n    while true {\n      i += 1\n\n      if i % Array(String(i)).map(String.init).compactMap(Int.init).reduce(0, +) == 0 {\n        return i\n      }\n    }\n  }\n}\n\nprint(\"First 20: \\(Array(Harshad().prefix(20)))\")\nprint(\"First over a 1000: \\(Harshad().first(where: { $0 > 1000 })!)\")\n", "target": "public class Harshad{\n    private static long sumDigits(long n){\n        long sum = 0;\n        for(char digit:Long.toString(n).toCharArray()){\n            sum += Character.digit(digit, 10);\n        }\n        return sum;\n    }\n    public static void main(String[] args){\n        for(int count = 0, i = 1; count < 20;i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                count++;\n            }\n        }\n        System.out.println();\n        for(int i = 1001; ; i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                break;\n            }\n        }\n    }\n}\n"}
{"id": 121840, "name": "Harshad or Niven series", "source": "Translate Swift to Python: struct Harshad: Sequence, IteratorProtocol {\n  private var i = 0\n\n  mutating func next() -> Int? {\n    while true {\n      i += 1\n\n      if i % Array(String(i)).map(String.init).compactMap(Int.init).reduce(0, +) == 0 {\n        return i\n      }\n    }\n  }\n}\n\nprint(\"First 20: \\(Array(Harshad().prefix(20)))\")\nprint(\"First over a 1000: \\(Harshad().first(where: { $0 > 1000 })!)\")\n", "target": ">>> import itertools\n>>> def harshad():\n\tfor n in itertools.count(1):\n\t\tif n % sum(int(ch) for ch in str(n)) == 0:\n\t\t\tyield n\n\n\t\t\n>>> list(itertools.islice(harshad(), 0, 20))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42]\n>>> for n in harshad():\n\tif n > 1000:\n\t\tprint(n)\n\t\tbreak\n\n\t\n1002\n>>>\n"}
{"id": 121841, "name": "Harshad or Niven series", "source": "Translate Swift to Python: struct Harshad: Sequence, IteratorProtocol {\n  private var i = 0\n\n  mutating func next() -> Int? {\n    while true {\n      i += 1\n\n      if i % Array(String(i)).map(String.init).compactMap(Int.init).reduce(0, +) == 0 {\n        return i\n      }\n    }\n  }\n}\n\nprint(\"First 20: \\(Array(Harshad().prefix(20)))\")\nprint(\"First over a 1000: \\(Harshad().first(where: { $0 > 1000 })!)\")\n", "target": ">>> import itertools\n>>> def harshad():\n\tfor n in itertools.count(1):\n\t\tif n % sum(int(ch) for ch in str(n)) == 0:\n\t\t\tyield n\n\n\t\t\n>>> list(itertools.islice(harshad(), 0, 20))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42]\n>>> for n in harshad():\n\tif n > 1000:\n\t\tprint(n)\n\t\tbreak\n\n\t\n1002\n>>>\n"}
{"id": 122030, "name": "Arithmetic_Rational", "source": "Translate Swift to C#: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public func gcd(with other: Self) -> Self {\n    var gcd = self\n    var b = other\n\n    while b != 0 {\n      (gcd, b) = (b, gcd % b)\n    }\n\n    return gcd\n  }\n\n  @inlinable\n  public func lcm(with other: Self) -> Self {\n    let g = gcd(with: other)\n\n    return self / g * other\n  }\n}\n\npublic struct Frac<NumType: BinaryInteger & SignedNumeric>: Equatable {\n  @usableFromInline\n  var _num: NumType\n\n  @usableFromInline\n  var _dom: NumType\n\n  @usableFromInline\n  init(_num: NumType, _dom: NumType) {\n    self._num = _num\n    self._dom = _dom\n  }\n\n  @inlinable\n  public init(numerator: NumType, denominator: NumType) {\n    let divisor = numerator.gcd(with: denominator)\n\n    self._num = numerator / divisor\n    self._dom = denominator / divisor\n  }\n\n  @inlinable\n  public static func + (lhs: Frac, rhs: Frac) -> Frac {\n    let multiplier = lhs._dom.lcm(with: rhs.denominator)\n\n    return Frac(\n      numerator: lhs._num * multiplier / lhs._dom + rhs._num * multiplier / rhs._dom,\n      denominator: multiplier\n    )\n  }\n\n  @inlinable\n  public static func += (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs + rhs\n  }\n\n  @inlinable\n  public static func - (lhs: Frac, rhs: Frac) -> Frac {\n    return lhs + -rhs\n  }\n\n  @inlinable\n  public static func -= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs + -rhs\n  }\n\n  @inlinable\n  public static func * (lhs: Frac, rhs: Frac) -> Frac {\n    return Frac(numerator: lhs._num * rhs._num, denominator: lhs._dom * rhs._dom)\n  }\n\n  @inlinable\n  public static func *= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs * rhs\n  }\n\n  @inlinable\n  public static func / (lhs: Frac, rhs: Frac) -> Frac {\n    return lhs * Frac(_num: rhs._dom, _dom: rhs._num)\n  }\n\n  @inlinable\n  public static func /= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs / rhs\n  }\n\n  @inlinable\n  prefix static func - (rhs: Frac) -> Frac {\n    return Frac(_num: -rhs._num, _dom: rhs._dom)\n  }\n}\n\nextension Frac {\n  @inlinable\n  public var numerator: NumType {\n    get { _num }\n    set {\n      let divisor = newValue.gcd(with: denominator)\n\n      _num = newValue / divisor\n      _dom = denominator / divisor\n    }\n  }\n\n  @inlinable\n  public var denominator: NumType {\n    get { _dom }\n    set {\n      let divisor = newValue.gcd(with: numerator)\n\n      _num = numerator / divisor\n      _dom = newValue / divisor\n    }\n  }\n}\n\nextension Frac: CustomStringConvertible {\n  public var description: String {\n    let neg = numerator < 0 || denominator < 0\n\n    return \"Frac(\\(neg ? \"-\" : \"\")\\(abs(numerator)) / \\(abs(denominator)))\"\n  }\n}\n\nextension Frac: Comparable {\n  @inlinable\n  public static func <(lhs: Frac, rhs: Frac) -> Bool {\n    return lhs._num * rhs._dom < lhs._dom * rhs._num\n  }\n}\n\nextension Frac: ExpressibleByIntegerLiteral {\n  public init(integerLiteral value: Int) {\n    self._num = NumType(value)\n    self._dom = 1\n  }\n}\n\n\nfor candidate in 2..<1<<19 {\n  var sum = Frac(numerator: 1, denominator: candidate)\n\n  let m = Int(ceil(Double(candidate).squareRoot()))\n\n  for factor in 2..<m where candidate % factor == 0 {\n    sum += Frac(numerator: 1, denominator: factor)\n    sum += Frac(numerator: 1, denominator: candidate / factor)\n  }\n\n  if sum == 1 {\n    print(\"\\(candidate) is perfect\")\n  }\n}\n", "target": "using System;\n\nstruct Fraction : IEquatable<Fraction>, IComparable<Fraction>\n{\n    public readonly long Num;\n    public readonly long Denom;\n\n    public Fraction(long num, long denom)\n    {\n        if (num == 0)\n        {\n            denom = 1;\n        }\n        else if (denom == 0)\n        {\n            throw new ArgumentException(\"Denominator may not be zero\", \"denom\");\n        }\n        else if (denom < 0)\n        {\n            num = -num;\n            denom = -denom;\n        }\n\n        long d = GCD(num, denom);\n        this.Num = num / d;\n        this.Denom = denom / d;\n    }\n\n    private static long GCD(long x, long y)\n    {\n        return y == 0 ? x : GCD(y, x % y);\n    }\n\n    private static long LCM(long x, long y)\n    {\n        return x / GCD(x, y) * y;\n    }\n\n    public Fraction Abs()\n    {\n        return new Fraction(Math.Abs(Num), Denom);\n    }\n\n    public Fraction Reciprocal()\n    {\n        return new Fraction(Denom, Num);\n    }\n\n    #region Conversion Operators\n\n    public static implicit operator Fraction(long i)\n    {\n        return new Fraction(i, 1);\n    }\n\n    public static explicit operator double(Fraction f)\n    {\n        return f.Num == 0 ? 0 : (double)f.Num / f.Denom;\n    }\n\n    #endregion\n\n    #region Arithmetic Operators\n\n    public static Fraction operator -(Fraction f)\n    {\n        return new Fraction(-f.Num, f.Denom);\n    }\n\n    public static Fraction operator +(Fraction a, Fraction b)\n    {\n        long m = LCM(a.Denom, b.Denom);\n        long na = a.Num * m / a.Denom;\n        long nb = b.Num * m / b.Denom;\n        return new Fraction(na + nb, m);\n    }\n\n    public static Fraction operator -(Fraction a, Fraction b)\n    {\n        return a + (-b);\n    }\n\n    public static Fraction operator *(Fraction a, Fraction b)\n    {\n        return new Fraction(a.Num * b.Num, a.Denom * b.Denom);\n    }\n\n    public static Fraction operator /(Fraction a, Fraction b)\n    {\n        return a * b.Reciprocal();\n    }\n\n    public static Fraction operator %(Fraction a, Fraction b)\n    {\n        long l = a.Num * b.Denom, r = a.Denom * b.Num;\n        long n = l / r;\n        return new Fraction(l - n * r, a.Denom * b.Denom);\n    }\n\n    #endregion\n\n    #region Comparison Operators\n\n    public static bool operator ==(Fraction a, Fraction b)\n    {\n        return a.Num == b.Num && a.Denom == b.Denom;\n    }\n\n    public static bool operator !=(Fraction a, Fraction b)\n    {\n        return a.Num != b.Num || a.Denom != b.Denom;\n    }\n\n    public static bool operator <(Fraction a, Fraction b)\n    {\n        return (a.Num * b.Denom) < (a.Denom * b.Num);\n    }\n\n    public static bool operator >(Fraction a, Fraction b)\n    {\n        return (a.Num * b.Denom) > (a.Denom * b.Num);\n    }\n\n    public static bool operator <=(Fraction a, Fraction b)\n    {\n        return !(a > b);\n    }\n\n    public static bool operator >=(Fraction a, Fraction b)\n    {\n        return !(a < b);\n    }\n\n    #endregion\n\n    #region Object Members\n\n    public override bool Equals(object obj)\n    {\n        if (obj is Fraction)\n            return ((Fraction)obj) == this;\n        else\n            return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return Num.GetHashCode() ^ Denom.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return Num.ToString() + \"/\" + Denom.ToString();\n    }\n\n    #endregion\n\n    #region IEquatable<Fraction> Members\n\n    public bool Equals(Fraction other)\n    {\n        return other == this;\n    }\n\n    #endregion\n\n    #region IComparable<Fraction> Members\n\n    public int CompareTo(Fraction other)\n    {\n        return (this.Num * other.Denom).CompareTo(this.Denom * other.Num);\n    }\n\n    #endregion\n}\n"}
{"id": 122032, "name": "Arithmetic_Rational", "source": "Translate Swift to Java: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public func gcd(with other: Self) -> Self {\n    var gcd = self\n    var b = other\n\n    while b != 0 {\n      (gcd, b) = (b, gcd % b)\n    }\n\n    return gcd\n  }\n\n  @inlinable\n  public func lcm(with other: Self) -> Self {\n    let g = gcd(with: other)\n\n    return self / g * other\n  }\n}\n\npublic struct Frac<NumType: BinaryInteger & SignedNumeric>: Equatable {\n  @usableFromInline\n  var _num: NumType\n\n  @usableFromInline\n  var _dom: NumType\n\n  @usableFromInline\n  init(_num: NumType, _dom: NumType) {\n    self._num = _num\n    self._dom = _dom\n  }\n\n  @inlinable\n  public init(numerator: NumType, denominator: NumType) {\n    let divisor = numerator.gcd(with: denominator)\n\n    self._num = numerator / divisor\n    self._dom = denominator / divisor\n  }\n\n  @inlinable\n  public static func + (lhs: Frac, rhs: Frac) -> Frac {\n    let multiplier = lhs._dom.lcm(with: rhs.denominator)\n\n    return Frac(\n      numerator: lhs._num * multiplier / lhs._dom + rhs._num * multiplier / rhs._dom,\n      denominator: multiplier\n    )\n  }\n\n  @inlinable\n  public static func += (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs + rhs\n  }\n\n  @inlinable\n  public static func - (lhs: Frac, rhs: Frac) -> Frac {\n    return lhs + -rhs\n  }\n\n  @inlinable\n  public static func -= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs + -rhs\n  }\n\n  @inlinable\n  public static func * (lhs: Frac, rhs: Frac) -> Frac {\n    return Frac(numerator: lhs._num * rhs._num, denominator: lhs._dom * rhs._dom)\n  }\n\n  @inlinable\n  public static func *= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs * rhs\n  }\n\n  @inlinable\n  public static func / (lhs: Frac, rhs: Frac) -> Frac {\n    return lhs * Frac(_num: rhs._dom, _dom: rhs._num)\n  }\n\n  @inlinable\n  public static func /= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs / rhs\n  }\n\n  @inlinable\n  prefix static func - (rhs: Frac) -> Frac {\n    return Frac(_num: -rhs._num, _dom: rhs._dom)\n  }\n}\n\nextension Frac {\n  @inlinable\n  public var numerator: NumType {\n    get { _num }\n    set {\n      let divisor = newValue.gcd(with: denominator)\n\n      _num = newValue / divisor\n      _dom = denominator / divisor\n    }\n  }\n\n  @inlinable\n  public var denominator: NumType {\n    get { _dom }\n    set {\n      let divisor = newValue.gcd(with: numerator)\n\n      _num = numerator / divisor\n      _dom = newValue / divisor\n    }\n  }\n}\n\nextension Frac: CustomStringConvertible {\n  public var description: String {\n    let neg = numerator < 0 || denominator < 0\n\n    return \"Frac(\\(neg ? \"-\" : \"\")\\(abs(numerator)) / \\(abs(denominator)))\"\n  }\n}\n\nextension Frac: Comparable {\n  @inlinable\n  public static func <(lhs: Frac, rhs: Frac) -> Bool {\n    return lhs._num * rhs._dom < lhs._dom * rhs._num\n  }\n}\n\nextension Frac: ExpressibleByIntegerLiteral {\n  public init(integerLiteral value: Int) {\n    self._num = NumType(value)\n    self._dom = 1\n  }\n}\n\n\nfor candidate in 2..<1<<19 {\n  var sum = Frac(numerator: 1, denominator: candidate)\n\n  let m = Int(ceil(Double(candidate).squareRoot()))\n\n  for factor in 2..<m where candidate % factor == 0 {\n    sum += Frac(numerator: 1, denominator: factor)\n    sum += Frac(numerator: 1, denominator: candidate / factor)\n  }\n\n  if sum == 1 {\n    print(\"\\(candidate) is perfect\")\n  }\n}\n", "target": "public class BigRationalFindPerfectNumbers {\n    public static void main(String[] args) {\n        int MAX_NUM = 1 << 19;\n        System.out.println(\"Searching for perfect numbers in the range [1, \" + (MAX_NUM - 1) + \"]\");\n\n        BigRational TWO = BigRational.valueOf(2);\n        for (int i = 1; i < MAX_NUM; i++) {\n            BigRational reciprocalSum = BigRational.ONE;\n            if (i > 1)\n                reciprocalSum = reciprocalSum.add(BigRational.valueOf(i).reciprocal());\n            int maxDivisor = (int) Math.sqrt(i);\n            if (maxDivisor >= i)\n                maxDivisor--;\n\n            for (int divisor = 2; divisor <= maxDivisor; divisor++) {\n                if (i % divisor == 0) {\n                    reciprocalSum = reciprocalSum.add(BigRational.valueOf(divisor).reciprocal());\n                    int dividend = i / divisor;\n                    if (divisor != dividend)\n                        reciprocalSum = reciprocalSum.add(BigRational.valueOf(dividend).reciprocal());\n                }\n            }\n            if (reciprocalSum.equals(TWO))\n                System.out.println(String.valueOf(i) + \" is a perfect number\");\n        }\n    }\n}\n"}
{"id": 122033, "name": "Arithmetic_Rational", "source": "Translate Swift to Python: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public func gcd(with other: Self) -> Self {\n    var gcd = self\n    var b = other\n\n    while b != 0 {\n      (gcd, b) = (b, gcd % b)\n    }\n\n    return gcd\n  }\n\n  @inlinable\n  public func lcm(with other: Self) -> Self {\n    let g = gcd(with: other)\n\n    return self / g * other\n  }\n}\n\npublic struct Frac<NumType: BinaryInteger & SignedNumeric>: Equatable {\n  @usableFromInline\n  var _num: NumType\n\n  @usableFromInline\n  var _dom: NumType\n\n  @usableFromInline\n  init(_num: NumType, _dom: NumType) {\n    self._num = _num\n    self._dom = _dom\n  }\n\n  @inlinable\n  public init(numerator: NumType, denominator: NumType) {\n    let divisor = numerator.gcd(with: denominator)\n\n    self._num = numerator / divisor\n    self._dom = denominator / divisor\n  }\n\n  @inlinable\n  public static func + (lhs: Frac, rhs: Frac) -> Frac {\n    let multiplier = lhs._dom.lcm(with: rhs.denominator)\n\n    return Frac(\n      numerator: lhs._num * multiplier / lhs._dom + rhs._num * multiplier / rhs._dom,\n      denominator: multiplier\n    )\n  }\n\n  @inlinable\n  public static func += (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs + rhs\n  }\n\n  @inlinable\n  public static func - (lhs: Frac, rhs: Frac) -> Frac {\n    return lhs + -rhs\n  }\n\n  @inlinable\n  public static func -= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs + -rhs\n  }\n\n  @inlinable\n  public static func * (lhs: Frac, rhs: Frac) -> Frac {\n    return Frac(numerator: lhs._num * rhs._num, denominator: lhs._dom * rhs._dom)\n  }\n\n  @inlinable\n  public static func *= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs * rhs\n  }\n\n  @inlinable\n  public static func / (lhs: Frac, rhs: Frac) -> Frac {\n    return lhs * Frac(_num: rhs._dom, _dom: rhs._num)\n  }\n\n  @inlinable\n  public static func /= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs / rhs\n  }\n\n  @inlinable\n  prefix static func - (rhs: Frac) -> Frac {\n    return Frac(_num: -rhs._num, _dom: rhs._dom)\n  }\n}\n\nextension Frac {\n  @inlinable\n  public var numerator: NumType {\n    get { _num }\n    set {\n      let divisor = newValue.gcd(with: denominator)\n\n      _num = newValue / divisor\n      _dom = denominator / divisor\n    }\n  }\n\n  @inlinable\n  public var denominator: NumType {\n    get { _dom }\n    set {\n      let divisor = newValue.gcd(with: numerator)\n\n      _num = numerator / divisor\n      _dom = newValue / divisor\n    }\n  }\n}\n\nextension Frac: CustomStringConvertible {\n  public var description: String {\n    let neg = numerator < 0 || denominator < 0\n\n    return \"Frac(\\(neg ? \"-\" : \"\")\\(abs(numerator)) / \\(abs(denominator)))\"\n  }\n}\n\nextension Frac: Comparable {\n  @inlinable\n  public static func <(lhs: Frac, rhs: Frac) -> Bool {\n    return lhs._num * rhs._dom < lhs._dom * rhs._num\n  }\n}\n\nextension Frac: ExpressibleByIntegerLiteral {\n  public init(integerLiteral value: Int) {\n    self._num = NumType(value)\n    self._dom = 1\n  }\n}\n\n\nfor candidate in 2..<1<<19 {\n  var sum = Frac(numerator: 1, denominator: candidate)\n\n  let m = Int(ceil(Double(candidate).squareRoot()))\n\n  for factor in 2..<m where candidate % factor == 0 {\n    sum += Frac(numerator: 1, denominator: factor)\n    sum += Frac(numerator: 1, denominator: candidate / factor)\n  }\n\n  if sum == 1 {\n    print(\"\\(candidate) is perfect\")\n  }\n}\n", "target": "from fractions import Fraction\n\nfor candidate in range(2, 2**19):\n  sum = Fraction(1, candidate)\n  for factor in range(2, int(candidate**0.5)+1):\n    if candidate % factor == 0:\n      sum += Fraction(1, factor) + Fraction(1, candidate // factor)\n  if sum.denominator == 1:\n    print(\"Sum of recipr. factors of %d = %d exactly %s\" %\n           (candidate, int(sum), \"perfect!\" if sum == 1 else \"\"))\n"}
{"id": 122459, "name": "Even or odd", "source": "Translate Swift to C#: func isEven(n:Int) -> Bool {\n\n    \n    if (n & 1 != 0) {\n        return false\n    }\n\n    \n    if (n % 2 != 0) {\n        return false\n    }\n    return true\n}\n", "target": "namespace RosettaCode\n{\n    using System;\n\n    public static class EvenOrOdd\n    {\n        public static bool IsEvenBitwise(this int number)\n        {\n            return (number & 1) == 0;\n        }\n\n        public static bool IsOddBitwise(this int number)\n        {\n            return (number & 1) != 0;\n        }\n\n        public static bool IsEvenRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder == 0;\n        }\n\n        public static bool IsOddRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder != 0;\n        }\n\n        public static bool IsEvenModulo(this int number)\n        {\n            return (number % 2) == 0;\n        }\n\n        public static bool IsOddModulo(this int number)\n        {\n            return (number % 2) != 0;\n        }\n    }\n    public class Program\n    {\n        public static void Main()\n        {\n            int num = 26;               \n            if (num.IsEvenBitwise())    \n            {\n                Console.Write(\"Even\");\n            }\n            else\n            {\n                Console.Write(\"Odd\");\n            }\n            \n            if (num.IsOddBitwise())    \n            {\n                Console.Write(\"Odd\");\n            }\n            else\n            {\n                Console.Write(\"Even\");\n            }\n            \n        }\n    }\n}\n"}
{"id": 122460, "name": "Even or odd", "source": "Translate Swift to C#: func isEven(n:Int) -> Bool {\n\n    \n    if (n & 1 != 0) {\n        return false\n    }\n\n    \n    if (n % 2 != 0) {\n        return false\n    }\n    return true\n}\n", "target": "namespace RosettaCode\n{\n    using System;\n\n    public static class EvenOrOdd\n    {\n        public static bool IsEvenBitwise(this int number)\n        {\n            return (number & 1) == 0;\n        }\n\n        public static bool IsOddBitwise(this int number)\n        {\n            return (number & 1) != 0;\n        }\n\n        public static bool IsEvenRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder == 0;\n        }\n\n        public static bool IsOddRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder != 0;\n        }\n\n        public static bool IsEvenModulo(this int number)\n        {\n            return (number % 2) == 0;\n        }\n\n        public static bool IsOddModulo(this int number)\n        {\n            return (number % 2) != 0;\n        }\n    }\n    public class Program\n    {\n        public static void Main()\n        {\n            int num = 26;               \n            if (num.IsEvenBitwise())    \n            {\n                Console.Write(\"Even\");\n            }\n            else\n            {\n                Console.Write(\"Odd\");\n            }\n            \n            if (num.IsOddBitwise())    \n            {\n                Console.Write(\"Odd\");\n            }\n            else\n            {\n                Console.Write(\"Even\");\n            }\n            \n        }\n    }\n}\n"}
{"id": 122463, "name": "Even or odd", "source": "Translate Swift to Java: func isEven(n:Int) -> Bool {\n\n    \n    if (n & 1 != 0) {\n        return false\n    }\n\n    \n    if (n % 2 != 0) {\n        return false\n    }\n    return true\n}\n", "target": "public static boolean isEven(int i){\n    return (i & 1) == 0;\n}\n"}
{"id": 122464, "name": "Even or odd", "source": "Translate Swift to Java: func isEven(n:Int) -> Bool {\n\n    \n    if (n & 1 != 0) {\n        return false\n    }\n\n    \n    if (n % 2 != 0) {\n        return false\n    }\n    return true\n}\n", "target": "public static boolean isEven(int i){\n    return (i & 1) == 0;\n}\n"}
{"id": 122465, "name": "Even or odd", "source": "Translate Swift to Python: func isEven(n:Int) -> Bool {\n\n    \n    if (n & 1 != 0) {\n        return false\n    }\n\n    \n    if (n % 2 != 0) {\n        return false\n    }\n    return true\n}\n", "target": ">>> def is_odd(i): return bool(i & 1)\n\n>>> def is_even(i): return not is_odd(i)\n\n>>> [(j, is_odd(j)) for j in range(10)]\n[(0, False), (1, True), (2, False), (3, True), (4, False), (5, True), (6, False), (7, True), (8, False), (9, True)]\n>>> [(j, is_even(j)) for j in range(10)]\n[(0, True), (1, False), (2, True), (3, False), (4, True), (5, False), (6, True), (7, False), (8, True), (9, False)]\n>>>\n"}
{"id": 122466, "name": "Even or odd", "source": "Translate Swift to Python: func isEven(n:Int) -> Bool {\n\n    \n    if (n & 1 != 0) {\n        return false\n    }\n\n    \n    if (n % 2 != 0) {\n        return false\n    }\n    return true\n}\n", "target": ">>> def is_odd(i): return bool(i & 1)\n\n>>> def is_even(i): return not is_odd(i)\n\n>>> [(j, is_odd(j)) for j in range(10)]\n[(0, False), (1, True), (2, False), (3, True), (4, False), (5, True), (6, False), (7, True), (8, False), (9, True)]\n>>> [(j, is_even(j)) for j in range(10)]\n[(0, True), (1, False), (2, True), (3, False), (4, True), (5, False), (6, True), (7, False), (8, True), (9, False)]\n>>>\n"}
{"id": 122742, "name": "Quickselect algorithm", "source": "Translate Swift to C#: func select<T where T : Comparable>(var elements: [T], n: Int) -> T {\n  var r = indices(elements)\n  while true {\n    let pivotIndex = partition(&elements, r)\n    if n == pivotIndex {\n      return elements[pivotIndex]\n    } else if n < pivotIndex {\n      r.endIndex = pivotIndex\n    } else {\n      r.startIndex = pivotIndex+1\n    }\n  }\n}\n\nfor i in 0 ..< 10 {\n  let a = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]\n  print(select(a, i))\n  if i < 9 { print(\", \") }\n}\nprintln()\n", "target": "\n\n\n\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace QuickSelect\n{\n    internal static class Program\n    {\n        #region Static Members\n\n        private static void Main()\n        {\n            var inputArray = new[] {9, 8, 7, 6, 5, 0, 1, 2, 3, 4};\n            \n            Console.WriteLine( \"Loop quick select 10 times.\" );\n            for( var i = 0 ; i < 10 ; i++ )\n            {\n                Console.Write( inputArray.NthSmallestElement( i ) );\n                if( i < 9 )\n                    Console.Write( \", \" );\n            }\n            Console.WriteLine();\n\n            \n            \n            Console.WriteLine( \"Just sort 10 elements.\" );\n            Console.WriteLine( string.Join( \", \", inputArray.TakeSmallest( 10 ).OrderBy( v => v ).Select( v => v.ToString() ).ToArray() ) );\n            \n            Console.WriteLine( \"Get 4 smallest and sort them.\" );\n            Console.WriteLine( string.Join( \", \", inputArray.TakeSmallest( 4 ).OrderBy( v => v ).Select( v => v.ToString() ).ToArray() ) );\n            Console.WriteLine( \"< Press any key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n\n    internal static class ArrayExtension\n    {\n        #region Static Members\n\n        \n        \n        \n        \n        \n        \n        \n        public static IEnumerable<T> TakeSmallest<T>( this T[] array, int count ) where T : IComparable<T>\n        {\n            if( count < 0 )\n                throw new ArgumentOutOfRangeException( \"count\", \"Count is smaller than 0.\" );\n            if( count == 0 )\n                return new T[0];\n            if( array.Length <= count )\n                return array;\n\n            return QuickSelectSmallest( array, count - 1 ).Take( count );\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        public static T NthSmallestElement<T>( this T[] array, int n ) where T : IComparable<T>\n        {\n            if( n < 0 || n > array.Length - 1 )\n                throw new ArgumentOutOfRangeException( \"n\", n, string.Format( \"n should be between 0 and {0} it was {1}.\", array.Length - 1, n ) );\n            if( array.Length == 0 )\n                throw new ArgumentException( \"Array is empty.\", \"array\" );\n            if( array.Length == 1 )\n                return array[ 0 ];\n\n            return QuickSelectSmallest( array, n )[ n ];\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        private static T[] QuickSelectSmallest<T>( T[] input, int n ) where T : IComparable<T>\n        {\n            \n            \n            var partiallySortedArray = (T[]) input.Clone();\n           \n            \n            var startIndex = 0;\n            var endIndex = input.Length - 1;\n            \n            \n            \n            var pivotIndex = n;\n\n            \n            var r = new Random();\n            while( endIndex > startIndex )\n            {\n                pivotIndex = QuickSelectPartition( partiallySortedArray, startIndex, endIndex, pivotIndex );\n                if( pivotIndex == n )\n                    \n                    break;\n                if( pivotIndex > n )\n                    \n                    endIndex = pivotIndex - 1;\n                else                    \n                    \n                    startIndex = pivotIndex + 1;\n\n                \n                \n                pivotIndex = r.Next( startIndex,  endIndex );\n            }\n            return partiallySortedArray;\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        private static int QuickSelectPartition<T>( this T[] array, int startIndex, int endIndex, int pivotIndex ) where T : IComparable<T>\n        {\n            var pivotValue = array[ pivotIndex ];\n            \n            array.Swap( pivotIndex, endIndex );\n            for( var i = startIndex ; i < endIndex ; i++ )\n            {\n                if( array[ i ].CompareTo( pivotValue ) > 0 )\n                    continue;\n\n                \n                array.Swap( i, startIndex );\n                \n                startIndex++;\n            }\n            \n            array.Swap( endIndex, startIndex );\n            return startIndex;\n        }\n\n        private static void Swap<T>( this T[] array, int index1, int index2 )\n        {\n            if( index1 == index2 )\n                return;\n\n            var temp = array[ index1 ];\n            array[ index1 ] = array[ index2 ];\n            array[ index2 ] = temp;\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 122744, "name": "Quickselect algorithm", "source": "Translate Swift to Java: func select<T where T : Comparable>(var elements: [T], n: Int) -> T {\n  var r = indices(elements)\n  while true {\n    let pivotIndex = partition(&elements, r)\n    if n == pivotIndex {\n      return elements[pivotIndex]\n    } else if n < pivotIndex {\n      r.endIndex = pivotIndex\n    } else {\n      r.startIndex = pivotIndex+1\n    }\n  }\n}\n\nfor i in 0 ..< 10 {\n  let a = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]\n  print(select(a, i))\n  if i < 9 { print(\", \") }\n}\nprintln()\n", "target": "import java.util.Random;\n\npublic class QuickSelect {\n\n\tprivate static <E extends Comparable<? super E>> int partition(E[] arr, int left, int right, int pivot) {\n\t\tE pivotVal = arr[pivot];\n\t\tswap(arr, pivot, right);\n\t\tint storeIndex = left;\n\t\tfor (int i = left; i < right; i++) {\n\t\t\tif (arr[i].compareTo(pivotVal) < 0) {\n\t\t\t\tswap(arr, i, storeIndex);\n\t\t\t\tstoreIndex++;\n\t\t\t}\n\t\t}\n\t\tswap(arr, right, storeIndex);\n\t\treturn storeIndex;\n\t}\n\t\n\tprivate static <E extends Comparable<? super E>> E select(E[] arr, int n) {\n\t\tint left = 0;\n\t\tint right = arr.length - 1;\n\t\tRandom rand = new Random();\n\t\twhile (right >= left) {\n\t\t\tint pivotIndex = partition(arr, left, right, rand.nextInt(right - left + 1) + left);\n\t\t\tif (pivotIndex == n) {\n\t\t\t\treturn arr[pivotIndex];\n\t\t\t} else if (pivotIndex < n) {\n\t\t\t\tleft = pivotIndex + 1;\n\t\t\t} else {\n\t\t\t\tright = pivotIndex - 1;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tprivate static void swap(Object[] arr, int i1, int i2) {\n\t\tif (i1 != i2) {\n\t\t\tObject temp = arr[i1];\n\t\t\tarr[i1] = arr[i2];\n\t\t\tarr[i2] = temp;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tInteger[] input = {9, 8, 7, 6, 5, 0, 1, 2, 3, 4};\n\t\t\tSystem.out.print(select(input, i));\n\t\t\tif (i < 9) System.out.print(\", \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}\n"}
{"id": 122745, "name": "Quickselect algorithm", "source": "Translate Swift to Python: func select<T where T : Comparable>(var elements: [T], n: Int) -> T {\n  var r = indices(elements)\n  while true {\n    let pivotIndex = partition(&elements, r)\n    if n == pivotIndex {\n      return elements[pivotIndex]\n    } else if n < pivotIndex {\n      r.endIndex = pivotIndex\n    } else {\n      r.startIndex = pivotIndex+1\n    }\n  }\n}\n\nfor i in 0 ..< 10 {\n  let a = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]\n  print(select(a, i))\n  if i < 9 { print(\", \") }\n}\nprintln()\n", "target": "import random\n\ndef partition(vector, left, right, pivotIndex):\n    pivotValue = vector[pivotIndex]\n    vector[pivotIndex], vector[right] = vector[right], vector[pivotIndex]  \n    storeIndex = left\n    for i in range(left, right):\n        if vector[i] < pivotValue:\n            vector[storeIndex], vector[i] = vector[i], vector[storeIndex]\n            storeIndex += 1\n    vector[right], vector[storeIndex] = vector[storeIndex], vector[right]  \n    return storeIndex\n\ndef _select(vector, left, right, k):\n    \"Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1] inclusive.\"\n    while True:\n        pivotIndex = random.randint(left, right)     \n        pivotNewIndex = partition(vector, left, right, pivotIndex)\n        pivotDist = pivotNewIndex - left\n        if pivotDist == k:\n            return vector[pivotNewIndex]\n        elif k < pivotDist:\n            right = pivotNewIndex - 1\n        else:\n            k -= pivotDist + 1\n            left = pivotNewIndex + 1\n\ndef select(vector, k, left=None, right=None):\n    \n    if left is None:\n        left = 0\n    lv1 = len(vector) - 1\n    if right is None:\n        right = lv1\n    assert vector and k >= 0, \"Either null vector or k < 0 \"\n    assert 0 <= left <= lv1, \"left is out of range\"\n    assert left <= right <= lv1, \"right is out of range\"\n    return _select(vector, left, right, k)\n\nif __name__ == '__main__':\n    v = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]\n    print([select(v, i) for i in range(10)])\n"}
{"id": 123368, "name": "Infinity", "source": "Translate Swift to C#: let inf = Double.infinity\ninf.isInfinite \n", "target": "using System;\n\nclass Program\n{\n    static double PositiveInfinity()\n    {\n        return double.PositiveInfinity;\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(PositiveInfinity());\n    }\n}\n"}
{"id": 123590, "name": "Sort an integer array", "source": "Translate Swift to C#: var nums = [2, 4, 3, 1, 2]\nnums.sortInPlace()\nprint(nums)\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n    static void Main() {\n        int[] unsorted = { 6, 2, 7, 8, 3, 1, 10, 5, 4, 9 };\n        Array.Sort(unsorted);\n    }\n}\n"}
{"id": 123592, "name": "Sort an integer array", "source": "Translate Swift to Java: var nums = [2, 4, 3, 1, 2]\nnums.sortInPlace()\nprint(nums)\n", "target": "import java.util.Arrays;\n\npublic class Example {\n    public static void main(String[] args)\n    {\n        int[] nums = {2,4,3,1,2};\n        Arrays.sort(nums);\n    }\n}\n"}
{"id": 123593, "name": "Sort an integer array", "source": "Translate Swift to Python: var nums = [2, 4, 3, 1, 2]\nnums.sortInPlace()\nprint(nums)\n", "target": "nums = [2,4,3,1,2]\nnums.sort()\n"}
{"id": 124469, "name": "Cartesian product of two or more lists", "source": "Translate Swift to C#: func + <T>(el: T, arr: [T]) -> [T] {\n  var ret = arr\n\n  ret.insert(el, at: 0)\n\n  return ret\n}\n\nfunc cartesianProduct<T>(_ arrays: [T]...) -> [[T]] {\n  guard let head = arrays.first else {\n    return []\n  }\n\n  let first = Array(head)\n\n  func pel(\n    _ el: T,\n    _ ll: [[T]],\n    _ a: [[T]] = []\n  ) -> [[T]] {\n    switch ll.count {\n    case 0:\n      return a.reversed()\n    case _:\n      let tail = Array(ll.dropFirst())\n      let head = ll.first!\n\n      return pel(el, tail, el + head + a)\n    }\n  }\n\n  return arrays.reversed()\n    .reduce([first], {res, el in el.flatMap({ pel($0, res) }) })\n    .map({ $0.dropLast(first.count) })\n}\n\n\nprint(cartesianProduct([1, 2], [3, 4]))\nprint(cartesianProduct([3, 4], [1, 2]))\nprint(cartesianProduct([1, 2], []))\nprint(cartesianProduct([1776, 1789], [7, 12], [4, 14, 23], [0, 1]))\nprint(cartesianProduct([1, 2, 3], [30], [500, 100]))\nprint(cartesianProduct([1, 2, 3], [], [500, 100])\n", "target": "using System;\npublic class Program\n{\n    public static void Main()\n    {\n        int[] empty = new int[0];\n        int[] list1 = { 1, 2 };\n        int[] list2 = { 3, 4 };\n        int[] list3 = { 1776, 1789 };\n        int[] list4 = { 7, 12 };\n        int[] list5 = { 4, 14, 23 };\n        int[] list6 = { 0, 1 };\n        int[] list7 = { 1, 2, 3 };\n        int[] list8 = { 30 };\n        int[] list9 = { 500, 100 };\n        \n        foreach (var sequenceList in new [] {\n            new [] { list1, list2 },\n            new [] { list2, list1 },\n            new [] { list1, empty },\n            new [] { empty, list1 },\n            new [] { list3, list4, list5, list6 },\n            new [] { list7, list8, list9 },\n            new [] { list7, empty, list9 }\n        }) {\n            var cart = sequenceList.CartesianProduct()\n                .Select(tuple => $\"({string.Join(\", \", tuple)})\");\n            Console.WriteLine($\"{{{string.Join(\", \", cart)}}}\");\n        }\n    }\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> sequences) {\n        IEnumerable<IEnumerable<T>> emptyProduct = new[] { Enumerable.Empty<T>() };\n        return sequences.Aggregate(\n            emptyProduct,\n            (accumulator, sequence) =>\n            from acc in accumulator\n            from item in sequence\n            select acc.Concat(new [] { item }));\n    }\n}\n"}
{"id": 124470, "name": "Cartesian product of two or more lists", "source": "Translate Swift to C#: func + <T>(el: T, arr: [T]) -> [T] {\n  var ret = arr\n\n  ret.insert(el, at: 0)\n\n  return ret\n}\n\nfunc cartesianProduct<T>(_ arrays: [T]...) -> [[T]] {\n  guard let head = arrays.first else {\n    return []\n  }\n\n  let first = Array(head)\n\n  func pel(\n    _ el: T,\n    _ ll: [[T]],\n    _ a: [[T]] = []\n  ) -> [[T]] {\n    switch ll.count {\n    case 0:\n      return a.reversed()\n    case _:\n      let tail = Array(ll.dropFirst())\n      let head = ll.first!\n\n      return pel(el, tail, el + head + a)\n    }\n  }\n\n  return arrays.reversed()\n    .reduce([first], {res, el in el.flatMap({ pel($0, res) }) })\n    .map({ $0.dropLast(first.count) })\n}\n\n\nprint(cartesianProduct([1, 2], [3, 4]))\nprint(cartesianProduct([3, 4], [1, 2]))\nprint(cartesianProduct([1, 2], []))\nprint(cartesianProduct([1776, 1789], [7, 12], [4, 14, 23], [0, 1]))\nprint(cartesianProduct([1, 2, 3], [30], [500, 100]))\nprint(cartesianProduct([1, 2, 3], [], [500, 100])\n", "target": "using System;\npublic class Program\n{\n    public static void Main()\n    {\n        int[] empty = new int[0];\n        int[] list1 = { 1, 2 };\n        int[] list2 = { 3, 4 };\n        int[] list3 = { 1776, 1789 };\n        int[] list4 = { 7, 12 };\n        int[] list5 = { 4, 14, 23 };\n        int[] list6 = { 0, 1 };\n        int[] list7 = { 1, 2, 3 };\n        int[] list8 = { 30 };\n        int[] list9 = { 500, 100 };\n        \n        foreach (var sequenceList in new [] {\n            new [] { list1, list2 },\n            new [] { list2, list1 },\n            new [] { list1, empty },\n            new [] { empty, list1 },\n            new [] { list3, list4, list5, list6 },\n            new [] { list7, list8, list9 },\n            new [] { list7, empty, list9 }\n        }) {\n            var cart = sequenceList.CartesianProduct()\n                .Select(tuple => $\"({string.Join(\", \", tuple)})\");\n            Console.WriteLine($\"{{{string.Join(\", \", cart)}}}\");\n        }\n    }\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> sequences) {\n        IEnumerable<IEnumerable<T>> emptyProduct = new[] { Enumerable.Empty<T>() };\n        return sequences.Aggregate(\n            emptyProduct,\n            (accumulator, sequence) =>\n            from acc in accumulator\n            from item in sequence\n            select acc.Concat(new [] { item }));\n    }\n}\n"}
{"id": 124473, "name": "Cartesian product of two or more lists", "source": "Translate Swift to Java: func + <T>(el: T, arr: [T]) -> [T] {\n  var ret = arr\n\n  ret.insert(el, at: 0)\n\n  return ret\n}\n\nfunc cartesianProduct<T>(_ arrays: [T]...) -> [[T]] {\n  guard let head = arrays.first else {\n    return []\n  }\n\n  let first = Array(head)\n\n  func pel(\n    _ el: T,\n    _ ll: [[T]],\n    _ a: [[T]] = []\n  ) -> [[T]] {\n    switch ll.count {\n    case 0:\n      return a.reversed()\n    case _:\n      let tail = Array(ll.dropFirst())\n      let head = ll.first!\n\n      return pel(el, tail, el + head + a)\n    }\n  }\n\n  return arrays.reversed()\n    .reduce([first], {res, el in el.flatMap({ pel($0, res) }) })\n    .map({ $0.dropLast(first.count) })\n}\n\n\nprint(cartesianProduct([1, 2], [3, 4]))\nprint(cartesianProduct([3, 4], [1, 2]))\nprint(cartesianProduct([1, 2], []))\nprint(cartesianProduct([1776, 1789], [7, 12], [4, 14, 23], [0, 1]))\nprint(cartesianProduct([1, 2, 3], [30], [500, 100]))\nprint(cartesianProduct([1, 2, 3], [], [500, 100])\n", "target": "import static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\nimport static java.util.Optional.of;\nimport static java.util.stream.Collectors.toList;\n\nimport java.util.List;\n\npublic class CartesianProduct {\n\n    public List<?> product(List<?>... a) {\n        if (a.length >= 2) {\n            List<?> product = a[0];\n            for (int i = 1; i < a.length; i++) {\n                product = product(product, a[i]);\n            }\n            return product;\n        }\n\n        return emptyList();\n    }\n\n    private <A, B> List<?> product(List<A> a, List<B> b) {\n        return of(a.stream()\n                .map(e1 -> of(b.stream().map(e2 -> asList(e1, e2)).collect(toList())).orElse(emptyList()))\n                .flatMap(List::stream)\n                .collect(toList())).orElse(emptyList());\n    }\n}\n"}
{"id": 124474, "name": "Cartesian product of two or more lists", "source": "Translate Swift to Java: func + <T>(el: T, arr: [T]) -> [T] {\n  var ret = arr\n\n  ret.insert(el, at: 0)\n\n  return ret\n}\n\nfunc cartesianProduct<T>(_ arrays: [T]...) -> [[T]] {\n  guard let head = arrays.first else {\n    return []\n  }\n\n  let first = Array(head)\n\n  func pel(\n    _ el: T,\n    _ ll: [[T]],\n    _ a: [[T]] = []\n  ) -> [[T]] {\n    switch ll.count {\n    case 0:\n      return a.reversed()\n    case _:\n      let tail = Array(ll.dropFirst())\n      let head = ll.first!\n\n      return pel(el, tail, el + head + a)\n    }\n  }\n\n  return arrays.reversed()\n    .reduce([first], {res, el in el.flatMap({ pel($0, res) }) })\n    .map({ $0.dropLast(first.count) })\n}\n\n\nprint(cartesianProduct([1, 2], [3, 4]))\nprint(cartesianProduct([3, 4], [1, 2]))\nprint(cartesianProduct([1, 2], []))\nprint(cartesianProduct([1776, 1789], [7, 12], [4, 14, 23], [0, 1]))\nprint(cartesianProduct([1, 2, 3], [30], [500, 100]))\nprint(cartesianProduct([1, 2, 3], [], [500, 100])\n", "target": "import static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\nimport static java.util.Optional.of;\nimport static java.util.stream.Collectors.toList;\n\nimport java.util.List;\n\npublic class CartesianProduct {\n\n    public List<?> product(List<?>... a) {\n        if (a.length >= 2) {\n            List<?> product = a[0];\n            for (int i = 1; i < a.length; i++) {\n                product = product(product, a[i]);\n            }\n            return product;\n        }\n\n        return emptyList();\n    }\n\n    private <A, B> List<?> product(List<A> a, List<B> b) {\n        return of(a.stream()\n                .map(e1 -> of(b.stream().map(e2 -> asList(e1, e2)).collect(toList())).orElse(emptyList()))\n                .flatMap(List::stream)\n                .collect(toList())).orElse(emptyList());\n    }\n}\n"}
{"id": 124475, "name": "Cartesian product of two or more lists", "source": "Translate Swift to Python: func + <T>(el: T, arr: [T]) -> [T] {\n  var ret = arr\n\n  ret.insert(el, at: 0)\n\n  return ret\n}\n\nfunc cartesianProduct<T>(_ arrays: [T]...) -> [[T]] {\n  guard let head = arrays.first else {\n    return []\n  }\n\n  let first = Array(head)\n\n  func pel(\n    _ el: T,\n    _ ll: [[T]],\n    _ a: [[T]] = []\n  ) -> [[T]] {\n    switch ll.count {\n    case 0:\n      return a.reversed()\n    case _:\n      let tail = Array(ll.dropFirst())\n      let head = ll.first!\n\n      return pel(el, tail, el + head + a)\n    }\n  }\n\n  return arrays.reversed()\n    .reduce([first], {res, el in el.flatMap({ pel($0, res) }) })\n    .map({ $0.dropLast(first.count) })\n}\n\n\nprint(cartesianProduct([1, 2], [3, 4]))\nprint(cartesianProduct([3, 4], [1, 2]))\nprint(cartesianProduct([1, 2], []))\nprint(cartesianProduct([1776, 1789], [7, 12], [4, 14, 23], [0, 1]))\nprint(cartesianProduct([1, 2, 3], [30], [500, 100]))\nprint(cartesianProduct([1, 2, 3], [], [500, 100])\n", "target": "import itertools\n\ndef cp(lsts):\n    return list(itertools.product(*lsts))\n\nif __name__ == '__main__':\n    from pprint import pprint as pp\n    \n    for lists in [[[1,2],[3,4]], [[3,4],[1,2]], [[], [1, 2]], [[1, 2], []],\n                  ((1776, 1789),  (7, 12), (4, 14, 23), (0, 1)),\n                  ((1, 2, 3), (30,), (500, 100)),\n                  ((1, 2, 3), (), (500, 100))]:\n        print(lists, '=>')\n        pp(cp(lists), indent=2)\n"}
{"id": 124476, "name": "Cartesian product of two or more lists", "source": "Translate Swift to Python: func + <T>(el: T, arr: [T]) -> [T] {\n  var ret = arr\n\n  ret.insert(el, at: 0)\n\n  return ret\n}\n\nfunc cartesianProduct<T>(_ arrays: [T]...) -> [[T]] {\n  guard let head = arrays.first else {\n    return []\n  }\n\n  let first = Array(head)\n\n  func pel(\n    _ el: T,\n    _ ll: [[T]],\n    _ a: [[T]] = []\n  ) -> [[T]] {\n    switch ll.count {\n    case 0:\n      return a.reversed()\n    case _:\n      let tail = Array(ll.dropFirst())\n      let head = ll.first!\n\n      return pel(el, tail, el + head + a)\n    }\n  }\n\n  return arrays.reversed()\n    .reduce([first], {res, el in el.flatMap({ pel($0, res) }) })\n    .map({ $0.dropLast(first.count) })\n}\n\n\nprint(cartesianProduct([1, 2], [3, 4]))\nprint(cartesianProduct([3, 4], [1, 2]))\nprint(cartesianProduct([1, 2], []))\nprint(cartesianProduct([1776, 1789], [7, 12], [4, 14, 23], [0, 1]))\nprint(cartesianProduct([1, 2, 3], [30], [500, 100]))\nprint(cartesianProduct([1, 2, 3], [], [500, 100])\n", "target": "import itertools\n\ndef cp(lsts):\n    return list(itertools.product(*lsts))\n\nif __name__ == '__main__':\n    from pprint import pprint as pp\n    \n    for lists in [[[1,2],[3,4]], [[3,4],[1,2]], [[], [1, 2]], [[1, 2], []],\n                  ((1776, 1789),  (7, 12), (4, 14, 23), (0, 1)),\n                  ((1, 2, 3), (30,), (500, 100)),\n                  ((1, 2, 3), (), (500, 100))]:\n        print(lists, '=>')\n        pp(cp(lists), indent=2)\n"}
{"id": 124840, "name": "Prime decomposition", "source": "Translate Swift to C#: func primeDecomposition<T: BinaryInteger>(of n: T) -> [T] {\n  guard n > 2 else { return [] }\n\n  func step(_ x: T) -> T {\n    return 1 + (x << 2) - ((x >> 1) << 1)\n  }\n\n  let maxQ = T(Double(n).squareRoot())\n  var d: T = 1\n  var q: T = n % 2 == 0 ? 2 : 3\n\n  while q <= maxQ && n % q != 0 {\n    q = step(d)\n    d += 1\n  }\n\n  return q <= maxQ ? [q] + primeDecomposition(of: n / q) : [n]\n}\n\nfor prime in Eratosthenes(upTo: 60) {\n  let m = Int(pow(2, Double(prime))) - 1\n  let decom = primeDecomposition(of: m)\n\n  print(\"2^\\(prime) - 1 = \\(m) => \\(decom)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PrimeDecomposition\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            GetPrimes(12);\n        }\n\n        static List<int> GetPrimes(decimal n)\n        {\n            List<int> storage = new List<int>();\n            while (n > 1)\n            {\n                int i = 1;\n                while (true)\n                {\n                    if (IsPrime(i))\n                    {                        \n                        if (((decimal)n / i) == Math.Round((decimal) n / i))\n                        {\n                            n /= i;\n                            storage.Add(i);                            \n                            break;\n                        }\n                    }\n                    i++;\n                }\n            }\n            return storage;\n        }\n\n        static bool IsPrime(int n)\n        {\n            if (n <= 1) return false;\n            for (int i = 2; i <= Math.Sqrt(n); i++)\n                if (n % i == 0) return false;\n            return true;\n        }\n    }\n}\n"}
{"id": 124842, "name": "Prime decomposition", "source": "Translate Swift to Java: func primeDecomposition<T: BinaryInteger>(of n: T) -> [T] {\n  guard n > 2 else { return [] }\n\n  func step(_ x: T) -> T {\n    return 1 + (x << 2) - ((x >> 1) << 1)\n  }\n\n  let maxQ = T(Double(n).squareRoot())\n  var d: T = 1\n  var q: T = n % 2 == 0 ? 2 : 3\n\n  while q <= maxQ && n % q != 0 {\n    q = step(d)\n    d += 1\n  }\n\n  return q <= maxQ ? [q] + primeDecomposition(of: n / q) : [n]\n}\n\nfor prime in Eratosthenes(upTo: 60) {\n  let m = Int(pow(2, Double(prime))) - 1\n  let decom = primeDecomposition(of: m)\n\n  print(\"2^\\(prime) - 1 = \\(m) => \\(decom)\")\n}\n", "target": "public boolean prime(BigInteger i);\n"}
{"id": 124843, "name": "Prime decomposition", "source": "Translate Swift to Python: func primeDecomposition<T: BinaryInteger>(of n: T) -> [T] {\n  guard n > 2 else { return [] }\n\n  func step(_ x: T) -> T {\n    return 1 + (x << 2) - ((x >> 1) << 1)\n  }\n\n  let maxQ = T(Double(n).squareRoot())\n  var d: T = 1\n  var q: T = n % 2 == 0 ? 2 : 3\n\n  while q <= maxQ && n % q != 0 {\n    q = step(d)\n    d += 1\n  }\n\n  return q <= maxQ ? [q] + primeDecomposition(of: n / q) : [n]\n}\n\nfor prime in Eratosthenes(upTo: 60) {\n  let m = Int(pow(2, Double(prime))) - 1\n  let decom = primeDecomposition(of: m)\n\n  print(\"2^\\(prime) - 1 = \\(m) => \\(decom)\")\n}\n", "target": "from __future__ import print_function\n\nimport sys\nfrom itertools import cycle\n\ndef is_prime(n):\n    return list(zip((True, False), decompose(n)))[-1][0]\n\nclass IsPrimeCached(dict):\n    def __missing__(self, n):\n        r = is_prime(n)\n        self[n] = r\n        return r\n\nis_prime_cached = IsPrimeCached()\n\ndef croft():\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    for p in (2, 3, 5):\n        yield p\n    roots = {}  \n    not_primeroot = tuple(x not in {1,7,11,13,17,19,23,29} for x in range(30))\n    q = 1\n    for x in cycle((6, 4, 2, 4, 2, 4, 6, 2)):\n        \n        q += x\n        \n        \n        if q in roots:\n            p = roots.pop(q)\n            x = q + p\n            while not_primeroot[x % 30] or x in roots:\n                x += p\n            roots[x] = p\n        else:\n            roots[q * q] = q + q\n            yield q\nprimes = croft\n\ndef decompose(n):\n    for p in primes():\n        if p*p > n: break\n        while n % p == 0:\n            yield p\n            n //=p\n    if n > 1:\n        yield n\n\n\nif __name__ == '__main__':\n    \n\n    import time\n\n    for m in primes():\n        p = 2 ** m - 1\n        print( \"2**{0:d}-1 = {1:d}, with factors:\".format(m, p) )\n        start = time.time()\n        for factor in decompose(p):\n            print(factor, end=' ')\n            sys.stdout.flush()\n\n        print( \"=> {0:.2f}s\".format( time.time()-start ) )\n        if m >= 59:\n            break\n"}
{"id": 125170, "name": "Happy numbers", "source": "Translate Swift to C#: func isHappyNumber(var n:Int) -> Bool {\n    var cycle = [Int]()\n    \n    while n != 1 && !cycle.contains(n) {\n        cycle.append(n)\n        var m = 0\n        while n > 0 {\n            let d = n % 10\n            m += d * d\n            n = (n  - d) / 10\n        }\n        n = m\n    }\n    return n == 1\n}\n\nvar found = 0\nvar count = 0\nwhile found != 8 {\n    if isHappyNumber(count) {\n        print(count)\n        found++\n    }\n    count++\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace HappyNums\n{\n    class Program\n    {\n        public static bool ishappy(int n)\n        {\n            List<int> cache = new List<int>();\n            int sum = 0;\n            while (n != 1)\n            {\n                if (cache.Contains(n))\n                {\n                    return false;\n                }\n                cache.Add(n);\n                while (n != 0)\n                {\n                    int digit = n % 10;\n                    sum += digit * digit;\n                    n /= 10;\n                }\n                n = sum;\n                sum = 0;\n            }\n           return true;            \n        }\n\n        static void Main(string[] args)\n        {\n            int num = 1;\n            List<int> happynums = new List<int>();\n\n            while (happynums.Count < 8)\n            {\n                if (ishappy(num))\n                {\n                    happynums.Add(num);\n                }\n                num++;\n            }\n            Console.WriteLine(\"First 8 happy numbers\u00a0: \" + string.Join(\",\", happynums));\n        }\n    }\n}\n"}
{"id": 125172, "name": "Happy numbers", "source": "Translate Swift to Java: func isHappyNumber(var n:Int) -> Bool {\n    var cycle = [Int]()\n    \n    while n != 1 && !cycle.contains(n) {\n        cycle.append(n)\n        var m = 0\n        while n > 0 {\n            let d = n % 10\n            m += d * d\n            n = (n  - d) / 10\n        }\n        n = m\n    }\n    return n == 1\n}\n\nvar found = 0\nvar count = 0\nwhile found != 8 {\n    if isHappyNumber(count) {\n        print(count)\n        found++\n    }\n    count++\n}\n", "target": "import java.util.HashSet;\npublic class Happy{\n   public static boolean happy(long number){\n       long m = 0;\n       int digit = 0;\n       HashSet<Long> cycle = new HashSet<Long>();\n       while(number != 1 && cycle.add(number)){\n           m = 0;\n           while(number > 0){\n               digit = (int)(number % 10);\n               m += digit*digit;\n               number /= 10;\n           }\n           number = m;\n       }\n       return number == 1;\n   }\n\n   public static void main(String[] args){\n       for(long num = 1,count = 0;count<8;num++){\n           if(happy(num)){\n               System.out.println(num);\n               count++;\n           }\n       }\n   }\n}\n"}
{"id": 125173, "name": "Happy numbers", "source": "Translate Swift to Python: func isHappyNumber(var n:Int) -> Bool {\n    var cycle = [Int]()\n    \n    while n != 1 && !cycle.contains(n) {\n        cycle.append(n)\n        var m = 0\n        while n > 0 {\n            let d = n % 10\n            m += d * d\n            n = (n  - d) / 10\n        }\n        n = m\n    }\n    return n == 1\n}\n\nvar found = 0\nvar count = 0\nwhile found != 8 {\n    if isHappyNumber(count) {\n        print(count)\n        found++\n    }\n    count++\n}\n", "target": ">>> def happy(n):\n    past = set()\t\t\t\n    while n != 1:\n        n = sum(int(i)**2 for i in str(n))\n        if n in past:\n            return False\n        past.add(n)\n    return True\n\n>>> [x for x in xrange(500) if happy(x)][:8]\n[1, 7, 10, 13, 19, 23, 28, 31]\n"}
{"id": 125647, "name": "Averages_Mean time of day", "source": "Translate Swift to C#: import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (y, x) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * y, cInv * x))\n}\n\nstruct DigitTime {\n  var hour: Int\n  var minute: Int\n  var second: Int\n\n  init?(fromString str: String) {\n    let split = str.components(separatedBy: \":\").compactMap(Int.init)\n\n    guard split.count == 3 else {\n      return nil\n    }\n\n    (hour, minute, second) = (split[0], split[1], split[2])\n  }\n\n  init(fromDegrees angle: Double) {\n    let totalSeconds = 24 * 60 * 60 * angle / 360\n\n    second = Int(totalSeconds.truncatingRemainder(dividingBy: 60))\n    minute = Int((totalSeconds.truncatingRemainder(dividingBy: 3600) - Double(second)) / 60)\n    hour = Int(totalSeconds / 3600)\n  }\n\n  func toDegrees() -> Double {\n    return 360 * Double(hour) / 24.0 + 360 * Double(minute) / (24 * 60.0) + 360 * Double(second) / (24 * 3600.0)\n  }\n}\n\nextension DigitTime: CustomStringConvertible {\n  var description: String { String(format: \"%02i:%02i:%02i\", hour, minute, second) }\n}\n\nlet times = [\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"].compactMap(DigitTime.init(fromString:))\n\nguard times.count == 4 else {\n  fatalError()\n}\n\nlet meanTime = DigitTime(fromDegrees: 360 + meanOfAngles(times.map({ $0.toDegrees() })))\n\nprint(\"Given times \\(times), the mean time is \\(meanTime)\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing static System.Math;\n\nnamespace RosettaCode;\n\nclass Program\n{\n    private const int SecondsPerDay = 60 * 60 * 24;\n\n    static void Main()\n    {\n        var digitimes = new List<TimeSpan>();\n\n        Console.WriteLine(\"Enter times, end with no input: \");\n        while (true) {\n            string input = Console.ReadLine();\n            if (string.IsNullOrWhiteSpace(input)) break;\n            if (TimeSpan.TryParse(input, out var digitime)) {\n                digitimes.Add(digitime);\n            } else {\n                Console.WriteLine(\"Seems this is wrong input: ignoring time\");\n            }\n        }\n        if(digitimes.Count() > 0)\n            Console.WriteLine($\"The mean time is\u00a0: {MeanTime(digitimes)}\");\n    }\n\n    public static TimeSpan MeanTime(IEnumerable<TimeSpan> ts) => FromDegrees(MeanAngle(ts.Select(ToDegrees)));\n    public static double ToDegrees(TimeSpan ts) => ts.TotalSeconds * 360d / SecondsPerDay;\n    public static TimeSpan FromDegrees(double degrees) => TimeSpan.FromSeconds((int)(degrees * SecondsPerDay / 360));\n\n    public static double MeanAngle(IEnumerable<double> angles)\n    {\n        var x = angles.Average(a => Cos(a * PI / 180));\n        var y = angles.Average(a => Sin(a * PI / 180));\n        return (Atan2(y, x) * 180 / PI + 360) % 360;\n    }\n}\n"}
{"id": 125649, "name": "Averages_Mean time of day", "source": "Translate Swift to Java: import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (y, x) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * y, cInv * x))\n}\n\nstruct DigitTime {\n  var hour: Int\n  var minute: Int\n  var second: Int\n\n  init?(fromString str: String) {\n    let split = str.components(separatedBy: \":\").compactMap(Int.init)\n\n    guard split.count == 3 else {\n      return nil\n    }\n\n    (hour, minute, second) = (split[0], split[1], split[2])\n  }\n\n  init(fromDegrees angle: Double) {\n    let totalSeconds = 24 * 60 * 60 * angle / 360\n\n    second = Int(totalSeconds.truncatingRemainder(dividingBy: 60))\n    minute = Int((totalSeconds.truncatingRemainder(dividingBy: 3600) - Double(second)) / 60)\n    hour = Int(totalSeconds / 3600)\n  }\n\n  func toDegrees() -> Double {\n    return 360 * Double(hour) / 24.0 + 360 * Double(minute) / (24 * 60.0) + 360 * Double(second) / (24 * 3600.0)\n  }\n}\n\nextension DigitTime: CustomStringConvertible {\n  var description: String { String(format: \"%02i:%02i:%02i\", hour, minute, second) }\n}\n\nlet times = [\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"].compactMap(DigitTime.init(fromString:))\n\nguard times.count == 4 else {\n  fatalError()\n}\n\nlet meanTime = DigitTime(fromDegrees: 360 + meanOfAngles(times.map({ $0.toDegrees() })))\n\nprint(\"Given times \\(times), the mean time is \\(meanTime)\")\n", "target": "public class MeanTimeOfDay {\n    \n    static double meanAngle(double[] angles) {\n        int len = angles.length;\n        double sinSum = 0.0;\n        for (int i = 0; i < len; i++) {\n            sinSum += Math.sin(angles[i] * Math.PI / 180.0);\n        }\n \n        double cosSum = 0.0;\n        for (int i = 0; i < len; i++) {\n            cosSum += Math.cos(angles[i] * Math.PI / 180.0);\n        }\n\n        return Math.atan2(sinSum / len, cosSum / len) * 180.0 / Math.PI;\n    }\n\n    \n    static int timeToSecs(String t) {\n        int hours = Integer.parseInt(t.substring(0, 2));\n        int mins  = Integer.parseInt(t.substring(3, 5));\n        int secs  = Integer.parseInt(t.substring(6, 8));\n        return 3600 * hours + 60 * mins + secs;\n    }\n\n    \n    static double timeToDegrees(String t) {\n        return timeToSecs(t) / 240.0;\n    }\n\n    static String degreesToTime(double d) {\n        if (d < 0.0) d += 360.0;\n        int secs  = (int)(d * 240.0);\n        int hours = secs / 3600;\n        int mins  = secs % 3600;\n        secs = mins % 60;\n        mins /= 60;\n        return String.format(\"%2d:%2d:%2d\", hours, mins, secs);\n    }\n\n    public static void main(String[] args) {\n        String[] tm = {\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"};\n        double[] angles = new double[4];\n        for (int i = 0; i < 4; i++) angles[i] = timeToDegrees(tm[i]);        \n        double mean = meanAngle(angles);\n        System.out.println(\"Average time is\u00a0: \" + degreesToTime(mean));\n    }\n}\n"}
{"id": 125650, "name": "Averages_Mean time of day", "source": "Translate Swift to Python: import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (y, x) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * y, cInv * x))\n}\n\nstruct DigitTime {\n  var hour: Int\n  var minute: Int\n  var second: Int\n\n  init?(fromString str: String) {\n    let split = str.components(separatedBy: \":\").compactMap(Int.init)\n\n    guard split.count == 3 else {\n      return nil\n    }\n\n    (hour, minute, second) = (split[0], split[1], split[2])\n  }\n\n  init(fromDegrees angle: Double) {\n    let totalSeconds = 24 * 60 * 60 * angle / 360\n\n    second = Int(totalSeconds.truncatingRemainder(dividingBy: 60))\n    minute = Int((totalSeconds.truncatingRemainder(dividingBy: 3600) - Double(second)) / 60)\n    hour = Int(totalSeconds / 3600)\n  }\n\n  func toDegrees() -> Double {\n    return 360 * Double(hour) / 24.0 + 360 * Double(minute) / (24 * 60.0) + 360 * Double(second) / (24 * 3600.0)\n  }\n}\n\nextension DigitTime: CustomStringConvertible {\n  var description: String { String(format: \"%02i:%02i:%02i\", hour, minute, second) }\n}\n\nlet times = [\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"].compactMap(DigitTime.init(fromString:))\n\nguard times.count == 4 else {\n  fatalError()\n}\n\nlet meanTime = DigitTime(fromDegrees: 360 + meanOfAngles(times.map({ $0.toDegrees() })))\n\nprint(\"Given times \\(times), the mean time is \\(meanTime)\")\n", "target": "from cmath import rect, phase\nfrom math import radians, degrees\n\n\ndef mean_angle(deg):\n    return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))\n\ndef mean_time(times):\n    t = (time.split(':') for time in times)\n    seconds = ((float(s) + int(m) * 60 + int(h) * 3600) \n               for h, m, s in t)\n    day = 24 * 60 * 60\n    to_angles = [s * 360. / day for s in seconds]\n    mean_as_angle = mean_angle(to_angles)\n    mean_seconds = mean_as_angle * day / 360.\n    if mean_seconds < 0:\n        mean_seconds += day\n    h, m = divmod(mean_seconds, 3600)\n    m, s = divmod(m, 60)\n    return '%02i:%02i:%02i' % (h, m, s)\n\n\nif __name__ == '__main__':\n    print( mean_time([\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"]) )\n"}
{"id": 126267, "name": "Knight's tour", "source": "Translate Swift to C#: public struct CPoint {\n  public var x: Int\n  public var y: Int\n\n  public init(x: Int, y: Int) {\n    (self.x, self.y) = (x, y)\n  }\n\n  public func move(by: (dx: Int, dy: Int)) -> CPoint {\n    return CPoint(x: self.x + by.dx, y: self.y + by.dy)\n  }\n}\n\nextension CPoint: Comparable {\n  public static func <(lhs: CPoint, rhs: CPoint) -> Bool {\n    if lhs.x == rhs.x {\n      return lhs.y < rhs.y\n    } else {\n      return lhs.x < rhs.x\n    }\n  }\n}\n\npublic class KnightsTour {\n  public var size: Int { board.count }\n\n  private var board: [[Int]]\n\n  public init(size: Int) {\n    board = Array(repeating: Array(repeating: 0, count: size), count: size)\n  }\n\n  public func countMoves(forPoint point: CPoint) -> Int {\n    return KnightsTour.knightMoves.lazy\n      .map(point.move)\n      .reduce(0, {count, movedTo in\n        return squareAvailable(movedTo) ? count + 1 : count\n    })\n  }\n\n  public func printBoard() {\n    for row in board {\n      for x in row {\n        print(\"\\(x) \", terminator: \"\")\n      }\n\n      print()\n    }\n\n    print()\n  }\n\n  private func reset() {\n    for i in 0..<size {\n      for j in 0..<size {\n        board[i][j] = 0\n      }\n    }\n  }\n\n  public func squareAvailable(_ p: CPoint) -> Bool {\n    return 0 <= p.x\n      && p.x < size\n      && 0 <= p.y\n      && p.y < size\n      && board[p.x][p.y] == 0\n  }\n\n  public func tour(startingAt point: CPoint = CPoint(x: 0, y: 0)) -> Bool {\n    var step = 2\n    var p = point\n\n    reset()\n\n    board[p.x][p.y] = 1\n\n    while step <= size * size {\n      let candidates = KnightsTour.knightMoves.lazy\n        .map(p.move)\n        .map({moved in (moved, self.countMoves(forPoint: moved), self.squareAvailable(moved)) })\n        .filter({ $0.2 })\n\n      guard let bestMove = candidates.sorted(by: bestChoice).first else {\n        return false\n      }\n\n      p = bestMove.0\n      board[p.x][p.y] = step\n\n      step += 1\n    }\n\n    return true\n  }\n}\n\nprivate func bestChoice(_ choice1: (CPoint, Int, Bool), _ choice2: (CPoint, Int, Bool)) -> Bool {\n  if choice1.1 == choice2.1 {\n    return choice1.0 < choice2.0\n  }\n\n  return choice1.1 < choice2.1\n}\n\nextension KnightsTour {\n  fileprivate static let knightMoves = [\n    (2, 1),\n    (1, 2),\n    (-1, 2),\n    (-2, 1),\n    (-2, -1),\n    (-1, -2),\n    (1, -2),\n    (2, -1),\n  ]\n}\n\nlet b = KnightsTour(size: 8)\n\nprint()\n\nlet completed = b.tour(startingAt: CPoint(x: 3, y: 1))\n\nif completed {\n  print(\"Completed tour\")\n} else {\n  print(\"Did not complete tour\")\n}\n\nb.printBoard()\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\n\t\tconst int N = 8;\n\t\t\n\t\treadonly static int[,] moves = { {+1,-2},{+2,-1},{+2,+1},{+1,+2},\n\t\t\t                         {-1,+2},{-2,+1},{-2,-1},{-1,-2} };\n\t\tstruct ListMoves\n\t\t{\n\t\t\tpublic int x, y;\t\t\t\n\t\t\tpublic ListMoves( int _x, int _y ) { x = _x; y = _y; }\n\t\t}\t\t\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tint[,] board = new int[N,N];\n\t\t\tboard.Initialize();\n\t\t\t\n\t\t\tint x = 0,\t\t\t\t\t\t\n\t\t\t    y = 0;\n\t\t\t\n\t\t\tList<ListMoves> list = new List<ListMoves>(N*N);\n\t\t\tlist.Add( new ListMoves(x,y) );\n\t\t\t\t\t\t\n\t\t\tdo\n\t\t\t{\t\t\t\t\t\t\t\t\n\t\t\t\tif ( Move_Possible( board, x, y ) )\n\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tint move = board[x,y];\t\t\t\t\t\n\t\t\t\t\tboard[x,y]++;\n\t\t\t\t\tx += moves[move,0];\n\t\t\t\t\ty += moves[move,1];\t\t\t\n\t\t\t\t\tlist.Add( new ListMoves(x,y) );\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\t\t\t\t\t\n\t\t\t\t\tif ( board[x,y] >= 8 )\n\t\t\t\t\t{\t\t\t\t\t\t\n\t\t\t\t\t\tboard[x,y] = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tlist.RemoveAt(list.Count-1);\t\t\t\t\t\t\n\t\t\t\t\t\tif ( list.Count == 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tConsole.WriteLine( \"No solution found.\" );\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\t\t\n\t\t\t\t\t\tx = list[list.Count-1].x;\n\t\t\t\t\t\ty = list[list.Count-1].y;\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tboard[x,y]++;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\twhile( list.Count < N*N );\n\t\t\t\n\t\t\tint last_x = list[0].x,\n\t\t\t    last_y = list[0].y;\n\t\t\tstring letters = \"ABCDEFGH\";\n\t\t\tfor( int i=1; i<list.Count; i++ )\n\t\t\t{\t\t\t\t\n\t\t\t\tConsole.WriteLine( string.Format(\"{0,2}:  \", i) + letters[last_x] + (last_y+1) + \" - \" + letters[list[i].x] + (list[i].y+1) );\n\t\t\t\t\n\t\t\t\tlast_x = list[i].x;\n\t\t\t\tlast_y = list[i].y;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic bool Move_Possible( int[,] board, int cur_x, int cur_y )\n\t\t{\t\t\t\n\t\t\tif ( board[cur_x,cur_y] >= 8 ) \n\t\t\t\treturn false;\n\t\t\t\n\t\t\tint new_x = cur_x + moves[board[cur_x,cur_y],0],\n\t\t\t    new_y = cur_y + moves[board[cur_x,cur_y],1];\n\t\t\t\n\t\t\tif ( new_x >= 0 && new_x < N && new_y >= 0 && new_y < N && board[new_x,new_y] == 0 )\n\t\t\t\treturn true;\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t}\n}\n"}
{"id": 126268, "name": "Knight's tour", "source": "Translate Swift to C#: public struct CPoint {\n  public var x: Int\n  public var y: Int\n\n  public init(x: Int, y: Int) {\n    (self.x, self.y) = (x, y)\n  }\n\n  public func move(by: (dx: Int, dy: Int)) -> CPoint {\n    return CPoint(x: self.x + by.dx, y: self.y + by.dy)\n  }\n}\n\nextension CPoint: Comparable {\n  public static func <(lhs: CPoint, rhs: CPoint) -> Bool {\n    if lhs.x == rhs.x {\n      return lhs.y < rhs.y\n    } else {\n      return lhs.x < rhs.x\n    }\n  }\n}\n\npublic class KnightsTour {\n  public var size: Int { board.count }\n\n  private var board: [[Int]]\n\n  public init(size: Int) {\n    board = Array(repeating: Array(repeating: 0, count: size), count: size)\n  }\n\n  public func countMoves(forPoint point: CPoint) -> Int {\n    return KnightsTour.knightMoves.lazy\n      .map(point.move)\n      .reduce(0, {count, movedTo in\n        return squareAvailable(movedTo) ? count + 1 : count\n    })\n  }\n\n  public func printBoard() {\n    for row in board {\n      for x in row {\n        print(\"\\(x) \", terminator: \"\")\n      }\n\n      print()\n    }\n\n    print()\n  }\n\n  private func reset() {\n    for i in 0..<size {\n      for j in 0..<size {\n        board[i][j] = 0\n      }\n    }\n  }\n\n  public func squareAvailable(_ p: CPoint) -> Bool {\n    return 0 <= p.x\n      && p.x < size\n      && 0 <= p.y\n      && p.y < size\n      && board[p.x][p.y] == 0\n  }\n\n  public func tour(startingAt point: CPoint = CPoint(x: 0, y: 0)) -> Bool {\n    var step = 2\n    var p = point\n\n    reset()\n\n    board[p.x][p.y] = 1\n\n    while step <= size * size {\n      let candidates = KnightsTour.knightMoves.lazy\n        .map(p.move)\n        .map({moved in (moved, self.countMoves(forPoint: moved), self.squareAvailable(moved)) })\n        .filter({ $0.2 })\n\n      guard let bestMove = candidates.sorted(by: bestChoice).first else {\n        return false\n      }\n\n      p = bestMove.0\n      board[p.x][p.y] = step\n\n      step += 1\n    }\n\n    return true\n  }\n}\n\nprivate func bestChoice(_ choice1: (CPoint, Int, Bool), _ choice2: (CPoint, Int, Bool)) -> Bool {\n  if choice1.1 == choice2.1 {\n    return choice1.0 < choice2.0\n  }\n\n  return choice1.1 < choice2.1\n}\n\nextension KnightsTour {\n  fileprivate static let knightMoves = [\n    (2, 1),\n    (1, 2),\n    (-1, 2),\n    (-2, 1),\n    (-2, -1),\n    (-1, -2),\n    (1, -2),\n    (2, -1),\n  ]\n}\n\nlet b = KnightsTour(size: 8)\n\nprint()\n\nlet completed = b.tour(startingAt: CPoint(x: 3, y: 1))\n\nif completed {\n  print(\"Completed tour\")\n} else {\n  print(\"Did not complete tour\")\n}\n\nb.printBoard()\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\n\t\tconst int N = 8;\n\t\t\n\t\treadonly static int[,] moves = { {+1,-2},{+2,-1},{+2,+1},{+1,+2},\n\t\t\t                         {-1,+2},{-2,+1},{-2,-1},{-1,-2} };\n\t\tstruct ListMoves\n\t\t{\n\t\t\tpublic int x, y;\t\t\t\n\t\t\tpublic ListMoves( int _x, int _y ) { x = _x; y = _y; }\n\t\t}\t\t\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tint[,] board = new int[N,N];\n\t\t\tboard.Initialize();\n\t\t\t\n\t\t\tint x = 0,\t\t\t\t\t\t\n\t\t\t    y = 0;\n\t\t\t\n\t\t\tList<ListMoves> list = new List<ListMoves>(N*N);\n\t\t\tlist.Add( new ListMoves(x,y) );\n\t\t\t\t\t\t\n\t\t\tdo\n\t\t\t{\t\t\t\t\t\t\t\t\n\t\t\t\tif ( Move_Possible( board, x, y ) )\n\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tint move = board[x,y];\t\t\t\t\t\n\t\t\t\t\tboard[x,y]++;\n\t\t\t\t\tx += moves[move,0];\n\t\t\t\t\ty += moves[move,1];\t\t\t\n\t\t\t\t\tlist.Add( new ListMoves(x,y) );\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\t\t\t\t\t\n\t\t\t\t\tif ( board[x,y] >= 8 )\n\t\t\t\t\t{\t\t\t\t\t\t\n\t\t\t\t\t\tboard[x,y] = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tlist.RemoveAt(list.Count-1);\t\t\t\t\t\t\n\t\t\t\t\t\tif ( list.Count == 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tConsole.WriteLine( \"No solution found.\" );\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\t\t\n\t\t\t\t\t\tx = list[list.Count-1].x;\n\t\t\t\t\t\ty = list[list.Count-1].y;\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tboard[x,y]++;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\twhile( list.Count < N*N );\n\t\t\t\n\t\t\tint last_x = list[0].x,\n\t\t\t    last_y = list[0].y;\n\t\t\tstring letters = \"ABCDEFGH\";\n\t\t\tfor( int i=1; i<list.Count; i++ )\n\t\t\t{\t\t\t\t\n\t\t\t\tConsole.WriteLine( string.Format(\"{0,2}:  \", i) + letters[last_x] + (last_y+1) + \" - \" + letters[list[i].x] + (list[i].y+1) );\n\t\t\t\t\n\t\t\t\tlast_x = list[i].x;\n\t\t\t\tlast_y = list[i].y;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic bool Move_Possible( int[,] board, int cur_x, int cur_y )\n\t\t{\t\t\t\n\t\t\tif ( board[cur_x,cur_y] >= 8 ) \n\t\t\t\treturn false;\n\t\t\t\n\t\t\tint new_x = cur_x + moves[board[cur_x,cur_y],0],\n\t\t\t    new_y = cur_y + moves[board[cur_x,cur_y],1];\n\t\t\t\n\t\t\tif ( new_x >= 0 && new_x < N && new_y >= 0 && new_y < N && board[new_x,new_y] == 0 )\n\t\t\t\treturn true;\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t}\n}\n"}
{"id": 126271, "name": "Knight's tour", "source": "Translate Swift to Java: public struct CPoint {\n  public var x: Int\n  public var y: Int\n\n  public init(x: Int, y: Int) {\n    (self.x, self.y) = (x, y)\n  }\n\n  public func move(by: (dx: Int, dy: Int)) -> CPoint {\n    return CPoint(x: self.x + by.dx, y: self.y + by.dy)\n  }\n}\n\nextension CPoint: Comparable {\n  public static func <(lhs: CPoint, rhs: CPoint) -> Bool {\n    if lhs.x == rhs.x {\n      return lhs.y < rhs.y\n    } else {\n      return lhs.x < rhs.x\n    }\n  }\n}\n\npublic class KnightsTour {\n  public var size: Int { board.count }\n\n  private var board: [[Int]]\n\n  public init(size: Int) {\n    board = Array(repeating: Array(repeating: 0, count: size), count: size)\n  }\n\n  public func countMoves(forPoint point: CPoint) -> Int {\n    return KnightsTour.knightMoves.lazy\n      .map(point.move)\n      .reduce(0, {count, movedTo in\n        return squareAvailable(movedTo) ? count + 1 : count\n    })\n  }\n\n  public func printBoard() {\n    for row in board {\n      for x in row {\n        print(\"\\(x) \", terminator: \"\")\n      }\n\n      print()\n    }\n\n    print()\n  }\n\n  private func reset() {\n    for i in 0..<size {\n      for j in 0..<size {\n        board[i][j] = 0\n      }\n    }\n  }\n\n  public func squareAvailable(_ p: CPoint) -> Bool {\n    return 0 <= p.x\n      && p.x < size\n      && 0 <= p.y\n      && p.y < size\n      && board[p.x][p.y] == 0\n  }\n\n  public func tour(startingAt point: CPoint = CPoint(x: 0, y: 0)) -> Bool {\n    var step = 2\n    var p = point\n\n    reset()\n\n    board[p.x][p.y] = 1\n\n    while step <= size * size {\n      let candidates = KnightsTour.knightMoves.lazy\n        .map(p.move)\n        .map({moved in (moved, self.countMoves(forPoint: moved), self.squareAvailable(moved)) })\n        .filter({ $0.2 })\n\n      guard let bestMove = candidates.sorted(by: bestChoice).first else {\n        return false\n      }\n\n      p = bestMove.0\n      board[p.x][p.y] = step\n\n      step += 1\n    }\n\n    return true\n  }\n}\n\nprivate func bestChoice(_ choice1: (CPoint, Int, Bool), _ choice2: (CPoint, Int, Bool)) -> Bool {\n  if choice1.1 == choice2.1 {\n    return choice1.0 < choice2.0\n  }\n\n  return choice1.1 < choice2.1\n}\n\nextension KnightsTour {\n  fileprivate static let knightMoves = [\n    (2, 1),\n    (1, 2),\n    (-1, 2),\n    (-2, 1),\n    (-2, -1),\n    (-1, -2),\n    (1, -2),\n    (2, -1),\n  ]\n}\n\nlet b = KnightsTour(size: 8)\n\nprint()\n\nlet completed = b.tour(startingAt: CPoint(x: 3, y: 1))\n\nif completed {\n  print(\"Completed tour\")\n} else {\n  print(\"Did not complete tour\")\n}\n\nb.printBoard()\n", "target": "import java.util.*;\n\npublic class KnightsTour {\n    private final static int base = 12;\n    private final static int[][] moves = {{1,-2},{2,-1},{2,1},{1,2},{-1,2},\n        {-2,1},{-2,-1},{-1,-2}};\n    private static int[][] grid;\n    private static int total;\n\n    public static void main(String[] args) {\n        grid = new int[base][base];\n        total = (base - 4) * (base - 4);\n\n        for (int r = 0; r < base; r++)\n            for (int c = 0; c < base; c++)\n                if (r < 2 || r > base - 3 || c < 2 || c > base - 3)\n                    grid[r][c] = -1;\n\n        int row = 2 + (int) (Math.random() * (base - 4));\n        int col = 2 + (int) (Math.random() * (base - 4));\n\n        grid[row][col] = 1;\n\n        if (solve(row, col, 2))\n            printResult();\n        else System.out.println(\"no result\");\n\n    }\n\n    private static boolean solve(int r, int c, int count) {\n        if (count > total)\n            return true;\n\n        List<int[]> nbrs = neighbors(r, c);\n\n        if (nbrs.isEmpty() && count != total)\n            return false;\n\n        Collections.sort(nbrs, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return a[2] - b[2];\n            }\n        });\n\n        for (int[] nb : nbrs) {\n            r = nb[0];\n            c = nb[1];\n            grid[r][c] = count;\n            if (!orphanDetected(count, r, c) && solve(r, c, count + 1))\n                return true;\n            grid[r][c] = 0;\n        }\n\n        return false;\n    }\n\n    private static List<int[]> neighbors(int r, int c) {\n        List<int[]> nbrs = new ArrayList<>();\n\n        for (int[] m : moves) {\n            int x = m[0];\n            int y = m[1];\n            if (grid[r + y][c + x] == 0) {\n                int num = countNeighbors(r + y, c + x);\n                nbrs.add(new int[]{r + y, c + x, num});\n            }\n        }\n        return nbrs;\n    }\n\n    private static int countNeighbors(int r, int c) {\n        int num = 0;\n        for (int[] m : moves)\n            if (grid[r + m[1]][c + m[0]] == 0)\n                num++;\n        return num;\n    }\n\n    private static boolean orphanDetected(int cnt, int r, int c) {\n        if (cnt < total - 1) {\n            List<int[]> nbrs = neighbors(r, c);\n            for (int[] nb : nbrs)\n                if (countNeighbors(nb[0], nb[1]) == 0)\n                    return true;\n        }\n        return false;\n    }\n\n    private static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1) continue;\n                System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 126272, "name": "Knight's tour", "source": "Translate Swift to Java: public struct CPoint {\n  public var x: Int\n  public var y: Int\n\n  public init(x: Int, y: Int) {\n    (self.x, self.y) = (x, y)\n  }\n\n  public func move(by: (dx: Int, dy: Int)) -> CPoint {\n    return CPoint(x: self.x + by.dx, y: self.y + by.dy)\n  }\n}\n\nextension CPoint: Comparable {\n  public static func <(lhs: CPoint, rhs: CPoint) -> Bool {\n    if lhs.x == rhs.x {\n      return lhs.y < rhs.y\n    } else {\n      return lhs.x < rhs.x\n    }\n  }\n}\n\npublic class KnightsTour {\n  public var size: Int { board.count }\n\n  private var board: [[Int]]\n\n  public init(size: Int) {\n    board = Array(repeating: Array(repeating: 0, count: size), count: size)\n  }\n\n  public func countMoves(forPoint point: CPoint) -> Int {\n    return KnightsTour.knightMoves.lazy\n      .map(point.move)\n      .reduce(0, {count, movedTo in\n        return squareAvailable(movedTo) ? count + 1 : count\n    })\n  }\n\n  public func printBoard() {\n    for row in board {\n      for x in row {\n        print(\"\\(x) \", terminator: \"\")\n      }\n\n      print()\n    }\n\n    print()\n  }\n\n  private func reset() {\n    for i in 0..<size {\n      for j in 0..<size {\n        board[i][j] = 0\n      }\n    }\n  }\n\n  public func squareAvailable(_ p: CPoint) -> Bool {\n    return 0 <= p.x\n      && p.x < size\n      && 0 <= p.y\n      && p.y < size\n      && board[p.x][p.y] == 0\n  }\n\n  public func tour(startingAt point: CPoint = CPoint(x: 0, y: 0)) -> Bool {\n    var step = 2\n    var p = point\n\n    reset()\n\n    board[p.x][p.y] = 1\n\n    while step <= size * size {\n      let candidates = KnightsTour.knightMoves.lazy\n        .map(p.move)\n        .map({moved in (moved, self.countMoves(forPoint: moved), self.squareAvailable(moved)) })\n        .filter({ $0.2 })\n\n      guard let bestMove = candidates.sorted(by: bestChoice).first else {\n        return false\n      }\n\n      p = bestMove.0\n      board[p.x][p.y] = step\n\n      step += 1\n    }\n\n    return true\n  }\n}\n\nprivate func bestChoice(_ choice1: (CPoint, Int, Bool), _ choice2: (CPoint, Int, Bool)) -> Bool {\n  if choice1.1 == choice2.1 {\n    return choice1.0 < choice2.0\n  }\n\n  return choice1.1 < choice2.1\n}\n\nextension KnightsTour {\n  fileprivate static let knightMoves = [\n    (2, 1),\n    (1, 2),\n    (-1, 2),\n    (-2, 1),\n    (-2, -1),\n    (-1, -2),\n    (1, -2),\n    (2, -1),\n  ]\n}\n\nlet b = KnightsTour(size: 8)\n\nprint()\n\nlet completed = b.tour(startingAt: CPoint(x: 3, y: 1))\n\nif completed {\n  print(\"Completed tour\")\n} else {\n  print(\"Did not complete tour\")\n}\n\nb.printBoard()\n", "target": "import java.util.*;\n\npublic class KnightsTour {\n    private final static int base = 12;\n    private final static int[][] moves = {{1,-2},{2,-1},{2,1},{1,2},{-1,2},\n        {-2,1},{-2,-1},{-1,-2}};\n    private static int[][] grid;\n    private static int total;\n\n    public static void main(String[] args) {\n        grid = new int[base][base];\n        total = (base - 4) * (base - 4);\n\n        for (int r = 0; r < base; r++)\n            for (int c = 0; c < base; c++)\n                if (r < 2 || r > base - 3 || c < 2 || c > base - 3)\n                    grid[r][c] = -1;\n\n        int row = 2 + (int) (Math.random() * (base - 4));\n        int col = 2 + (int) (Math.random() * (base - 4));\n\n        grid[row][col] = 1;\n\n        if (solve(row, col, 2))\n            printResult();\n        else System.out.println(\"no result\");\n\n    }\n\n    private static boolean solve(int r, int c, int count) {\n        if (count > total)\n            return true;\n\n        List<int[]> nbrs = neighbors(r, c);\n\n        if (nbrs.isEmpty() && count != total)\n            return false;\n\n        Collections.sort(nbrs, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return a[2] - b[2];\n            }\n        });\n\n        for (int[] nb : nbrs) {\n            r = nb[0];\n            c = nb[1];\n            grid[r][c] = count;\n            if (!orphanDetected(count, r, c) && solve(r, c, count + 1))\n                return true;\n            grid[r][c] = 0;\n        }\n\n        return false;\n    }\n\n    private static List<int[]> neighbors(int r, int c) {\n        List<int[]> nbrs = new ArrayList<>();\n\n        for (int[] m : moves) {\n            int x = m[0];\n            int y = m[1];\n            if (grid[r + y][c + x] == 0) {\n                int num = countNeighbors(r + y, c + x);\n                nbrs.add(new int[]{r + y, c + x, num});\n            }\n        }\n        return nbrs;\n    }\n\n    private static int countNeighbors(int r, int c) {\n        int num = 0;\n        for (int[] m : moves)\n            if (grid[r + m[1]][c + m[0]] == 0)\n                num++;\n        return num;\n    }\n\n    private static boolean orphanDetected(int cnt, int r, int c) {\n        if (cnt < total - 1) {\n            List<int[]> nbrs = neighbors(r, c);\n            for (int[] nb : nbrs)\n                if (countNeighbors(nb[0], nb[1]) == 0)\n                    return true;\n        }\n        return false;\n    }\n\n    private static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1) continue;\n                System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 126273, "name": "Knight's tour", "source": "Translate Swift to Python: public struct CPoint {\n  public var x: Int\n  public var y: Int\n\n  public init(x: Int, y: Int) {\n    (self.x, self.y) = (x, y)\n  }\n\n  public func move(by: (dx: Int, dy: Int)) -> CPoint {\n    return CPoint(x: self.x + by.dx, y: self.y + by.dy)\n  }\n}\n\nextension CPoint: Comparable {\n  public static func <(lhs: CPoint, rhs: CPoint) -> Bool {\n    if lhs.x == rhs.x {\n      return lhs.y < rhs.y\n    } else {\n      return lhs.x < rhs.x\n    }\n  }\n}\n\npublic class KnightsTour {\n  public var size: Int { board.count }\n\n  private var board: [[Int]]\n\n  public init(size: Int) {\n    board = Array(repeating: Array(repeating: 0, count: size), count: size)\n  }\n\n  public func countMoves(forPoint point: CPoint) -> Int {\n    return KnightsTour.knightMoves.lazy\n      .map(point.move)\n      .reduce(0, {count, movedTo in\n        return squareAvailable(movedTo) ? count + 1 : count\n    })\n  }\n\n  public func printBoard() {\n    for row in board {\n      for x in row {\n        print(\"\\(x) \", terminator: \"\")\n      }\n\n      print()\n    }\n\n    print()\n  }\n\n  private func reset() {\n    for i in 0..<size {\n      for j in 0..<size {\n        board[i][j] = 0\n      }\n    }\n  }\n\n  public func squareAvailable(_ p: CPoint) -> Bool {\n    return 0 <= p.x\n      && p.x < size\n      && 0 <= p.y\n      && p.y < size\n      && board[p.x][p.y] == 0\n  }\n\n  public func tour(startingAt point: CPoint = CPoint(x: 0, y: 0)) -> Bool {\n    var step = 2\n    var p = point\n\n    reset()\n\n    board[p.x][p.y] = 1\n\n    while step <= size * size {\n      let candidates = KnightsTour.knightMoves.lazy\n        .map(p.move)\n        .map({moved in (moved, self.countMoves(forPoint: moved), self.squareAvailable(moved)) })\n        .filter({ $0.2 })\n\n      guard let bestMove = candidates.sorted(by: bestChoice).first else {\n        return false\n      }\n\n      p = bestMove.0\n      board[p.x][p.y] = step\n\n      step += 1\n    }\n\n    return true\n  }\n}\n\nprivate func bestChoice(_ choice1: (CPoint, Int, Bool), _ choice2: (CPoint, Int, Bool)) -> Bool {\n  if choice1.1 == choice2.1 {\n    return choice1.0 < choice2.0\n  }\n\n  return choice1.1 < choice2.1\n}\n\nextension KnightsTour {\n  fileprivate static let knightMoves = [\n    (2, 1),\n    (1, 2),\n    (-1, 2),\n    (-2, 1),\n    (-2, -1),\n    (-1, -2),\n    (1, -2),\n    (2, -1),\n  ]\n}\n\nlet b = KnightsTour(size: 8)\n\nprint()\n\nlet completed = b.tour(startingAt: CPoint(x: 3, y: 1))\n\nif completed {\n  print(\"Completed tour\")\n} else {\n  print(\"Did not complete tour\")\n}\n\nb.printBoard()\n", "target": "import copy\n\nboardsize=6\n_kmoves = ((2,1), (1,2), (-1,2), (-2,1), (-2,-1), (-1,-2), (1,-2), (2,-1)) \n\n\ndef chess2index(chess, boardsize=boardsize):\n    'Convert Algebraic chess notation to internal index format'\n    chess = chess.strip().lower()\n    x = ord(chess[0]) - ord('a')\n    y = boardsize - int(chess[1:])\n    return (x, y)\n    \ndef boardstring(board, boardsize=boardsize):\n    r = range(boardsize)\n    lines = ''\n    for y in r:\n        lines += '\\n' + ','.join('%2i' % board[(x,y)] if board[(x,y)] else '  '\n                                 for x in r)\n    return lines\n    \ndef knightmoves(board, P, boardsize=boardsize):\n    Px, Py = P\n    kmoves = set((Px+x, Py+y) for x,y in _kmoves)\n    kmoves = set( (x,y)\n                  for x,y in kmoves\n                  if 0 <= x < boardsize\n                     and 0 <= y < boardsize\n                     and not board[(x,y)] )\n    return kmoves\n\ndef accessibility(board, P, boardsize=boardsize):\n    access = []\n    brd = copy.deepcopy(board)\n    for pos in knightmoves(board, P, boardsize=boardsize):\n        brd[pos] = -1\n        access.append( (len(knightmoves(brd, pos, boardsize=boardsize)), pos) )\n        brd[pos] = 0\n    return access\n    \ndef knights_tour(start, boardsize=boardsize, _debug=False):\n    board = {(x,y):0 for x in range(boardsize) for y in range(boardsize)}\n    move = 1\n    P = chess2index(start, boardsize)\n    board[P] = move\n    move += 1\n    if _debug:\n        print(boardstring(board, boardsize=boardsize))\n    while move <= len(board):\n        P = min(accessibility(board, P, boardsize))[1]\n        board[P] = move\n        move += 1\n        if _debug:\n            print(boardstring(board, boardsize=boardsize))\n            input('\\n%2i next: ' % move)\n    return board\n\nif __name__ == '__main__':\n    while 1:\n        boardsize = int(input('\\nboardsize: '))\n        if boardsize < 5:\n            continue\n        start = input('Start position: ')\n        board = knights_tour(start, boardsize)\n        print(boardstring(board, boardsize=boardsize))\n"}
{"id": 126274, "name": "Knight's tour", "source": "Translate Swift to Python: public struct CPoint {\n  public var x: Int\n  public var y: Int\n\n  public init(x: Int, y: Int) {\n    (self.x, self.y) = (x, y)\n  }\n\n  public func move(by: (dx: Int, dy: Int)) -> CPoint {\n    return CPoint(x: self.x + by.dx, y: self.y + by.dy)\n  }\n}\n\nextension CPoint: Comparable {\n  public static func <(lhs: CPoint, rhs: CPoint) -> Bool {\n    if lhs.x == rhs.x {\n      return lhs.y < rhs.y\n    } else {\n      return lhs.x < rhs.x\n    }\n  }\n}\n\npublic class KnightsTour {\n  public var size: Int { board.count }\n\n  private var board: [[Int]]\n\n  public init(size: Int) {\n    board = Array(repeating: Array(repeating: 0, count: size), count: size)\n  }\n\n  public func countMoves(forPoint point: CPoint) -> Int {\n    return KnightsTour.knightMoves.lazy\n      .map(point.move)\n      .reduce(0, {count, movedTo in\n        return squareAvailable(movedTo) ? count + 1 : count\n    })\n  }\n\n  public func printBoard() {\n    for row in board {\n      for x in row {\n        print(\"\\(x) \", terminator: \"\")\n      }\n\n      print()\n    }\n\n    print()\n  }\n\n  private func reset() {\n    for i in 0..<size {\n      for j in 0..<size {\n        board[i][j] = 0\n      }\n    }\n  }\n\n  public func squareAvailable(_ p: CPoint) -> Bool {\n    return 0 <= p.x\n      && p.x < size\n      && 0 <= p.y\n      && p.y < size\n      && board[p.x][p.y] == 0\n  }\n\n  public func tour(startingAt point: CPoint = CPoint(x: 0, y: 0)) -> Bool {\n    var step = 2\n    var p = point\n\n    reset()\n\n    board[p.x][p.y] = 1\n\n    while step <= size * size {\n      let candidates = KnightsTour.knightMoves.lazy\n        .map(p.move)\n        .map({moved in (moved, self.countMoves(forPoint: moved), self.squareAvailable(moved)) })\n        .filter({ $0.2 })\n\n      guard let bestMove = candidates.sorted(by: bestChoice).first else {\n        return false\n      }\n\n      p = bestMove.0\n      board[p.x][p.y] = step\n\n      step += 1\n    }\n\n    return true\n  }\n}\n\nprivate func bestChoice(_ choice1: (CPoint, Int, Bool), _ choice2: (CPoint, Int, Bool)) -> Bool {\n  if choice1.1 == choice2.1 {\n    return choice1.0 < choice2.0\n  }\n\n  return choice1.1 < choice2.1\n}\n\nextension KnightsTour {\n  fileprivate static let knightMoves = [\n    (2, 1),\n    (1, 2),\n    (-1, 2),\n    (-2, 1),\n    (-2, -1),\n    (-1, -2),\n    (1, -2),\n    (2, -1),\n  ]\n}\n\nlet b = KnightsTour(size: 8)\n\nprint()\n\nlet completed = b.tour(startingAt: CPoint(x: 3, y: 1))\n\nif completed {\n  print(\"Completed tour\")\n} else {\n  print(\"Did not complete tour\")\n}\n\nb.printBoard()\n", "target": "import copy\n\nboardsize=6\n_kmoves = ((2,1), (1,2), (-1,2), (-2,1), (-2,-1), (-1,-2), (1,-2), (2,-1)) \n\n\ndef chess2index(chess, boardsize=boardsize):\n    'Convert Algebraic chess notation to internal index format'\n    chess = chess.strip().lower()\n    x = ord(chess[0]) - ord('a')\n    y = boardsize - int(chess[1:])\n    return (x, y)\n    \ndef boardstring(board, boardsize=boardsize):\n    r = range(boardsize)\n    lines = ''\n    for y in r:\n        lines += '\\n' + ','.join('%2i' % board[(x,y)] if board[(x,y)] else '  '\n                                 for x in r)\n    return lines\n    \ndef knightmoves(board, P, boardsize=boardsize):\n    Px, Py = P\n    kmoves = set((Px+x, Py+y) for x,y in _kmoves)\n    kmoves = set( (x,y)\n                  for x,y in kmoves\n                  if 0 <= x < boardsize\n                     and 0 <= y < boardsize\n                     and not board[(x,y)] )\n    return kmoves\n\ndef accessibility(board, P, boardsize=boardsize):\n    access = []\n    brd = copy.deepcopy(board)\n    for pos in knightmoves(board, P, boardsize=boardsize):\n        brd[pos] = -1\n        access.append( (len(knightmoves(brd, pos, boardsize=boardsize)), pos) )\n        brd[pos] = 0\n    return access\n    \ndef knights_tour(start, boardsize=boardsize, _debug=False):\n    board = {(x,y):0 for x in range(boardsize) for y in range(boardsize)}\n    move = 1\n    P = chess2index(start, boardsize)\n    board[P] = move\n    move += 1\n    if _debug:\n        print(boardstring(board, boardsize=boardsize))\n    while move <= len(board):\n        P = min(accessibility(board, P, boardsize))[1]\n        board[P] = move\n        move += 1\n        if _debug:\n            print(boardstring(board, boardsize=boardsize))\n            input('\\n%2i next: ' % move)\n    return board\n\nif __name__ == '__main__':\n    while 1:\n        boardsize = int(input('\\nboardsize: '))\n        if boardsize < 5:\n            continue\n        start = input('Start position: ')\n        board = knights_tour(start, boardsize)\n        print(boardstring(board, boardsize=boardsize))\n"}
{"id": 126742, "name": "Sudan function", "source": "Translate Swift to C#: \n\nfunc F(n: Int,x: Int,y: Int) -> Int {\n  if (n == 0) {\n    return x + y;\n  }\n\n  else if (y == 0) {\n    return x;\n  }\n\n    return F(n: n - 1, x: F(n: n, x: x, y: y - 1), y: F(n: n, x: x, y: y - 1) + y);\n}\n\nprint(\"F1(3,3) = \" + String(F(n: 1,x: 3,y: 3)));\n", "target": "\n\nusing System;\n\nnamespace Sudan\n{\n  class Sudan\n  {\n  \tstatic int F(int n,int x,int y) {\n  \t\tif (n == 0) {\n    \t\treturn x + y;\n  \t\t}\n \n  \t\telse if (y == 0) {\n    \t\treturn x;\n  \t\t}\n \n  \t\treturn F(n - 1, F(n, x, y - 1), F(n, x, y - 1) + y);\n\t}\n    \n    static void Main(string[] args)\n    {\n      Console.WriteLine(\"F(1,3,3) = \" + F(1,3,3));    \n    }\n  }\n}\n"}
{"id": 126744, "name": "Sudan function", "source": "Translate Swift to Java: \n\nfunc F(n: Int,x: Int,y: Int) -> Int {\n  if (n == 0) {\n    return x + y;\n  }\n\n  else if (y == 0) {\n    return x;\n  }\n\n    return F(n: n - 1, x: F(n: n, x: x, y: y - 1), y: F(n: n, x: x, y: y - 1) + y);\n}\n\nprint(\"F1(3,3) = \" + String(F(n: 1,x: 3,y: 3)));\n", "target": "\n\npublic class Main {\n\n  private static int F(int n,int x,int y) {\n  \tif (n == 0) {\n    \treturn x + y;\n  \t}\n \n \t else if (y == 0) {\n    \treturn x;\n  \t}\n \n  \treturn F(n - 1, F(n, x, y - 1), F(n, x, y - 1) + y);\n }\n\n  public static void main(String[] args) {\n    System.out.println(\"F(1,3,3) = \" + F(1,3,3));\n  }\n}\n"}
{"id": 126745, "name": "Sudan function", "source": "Translate Swift to Python: \n\nfunc F(n: Int,x: Int,y: Int) -> Int {\n  if (n == 0) {\n    return x + y;\n  }\n\n  else if (y == 0) {\n    return x;\n  }\n\n    return F(n: n - 1, x: F(n: n, x: x, y: y - 1), y: F(n: n, x: x, y: y - 1) + y);\n}\n\nprint(\"F1(3,3) = \" + String(F(n: 1,x: 3,y: 3)));\n", "target": "\n\ndef F(n,x,y):\n  if n==0:\n    return x + y\n  elif y==0:\n    return x\n  else:\n    return F(n - 1, F(n, x, y - 1), F(n, x, y - 1) + y)\n    \n    \nprint(\"F(1,3,3) = \", F(1,3,3))\n"}
{"id": 126963, "name": "Classes", "source": "Translate Swift to C#: class MyClass{\n\n  \n  var variable : Int\n\n  \n  init() {\n    self.variable = 42\n  }\n\n  \n  func someMethod() {\n    self.variable = 1\n  }\n}\n", "target": "public class MyClass\n{\n    public MyClass()\n    {\n    }\n    public void SomeMethod()\n    {\n    }\n    private int _variable;\n    public int Variable\n    {\n        get { return _variable; }\n        set { _variable = value; }\n    }\n    public static void Main()\n    {\n        \n        MyClass instance = new MyClass();\n        \n        instance.SomeMethod();\n        \n        instance.Variable = 99;\n        \n        System.Console.WriteLine( \"Variable=\" + instance.Variable.ToString() );\n    }\n}\n"}
{"id": 126965, "name": "Classes", "source": "Translate Swift to Java: class MyClass{\n\n  \n  var variable : Int\n\n  \n  init() {\n    self.variable = 42\n  }\n\n  \n  func someMethod() {\n    self.variable = 1\n  }\n}\n", "target": "public class MyClass{\n\n  \n  private int variable;  \n\n  \n  public MyClass(){\n    \n  }\n\n  \n  public void someMethod(){\n   this.variable = 1;\n  }\n}\n"}
{"id": 126966, "name": "Classes", "source": "Translate Swift to Python: class MyClass{\n\n  \n  var variable : Int\n\n  \n  init() {\n    self.variable = 42\n  }\n\n  \n  func someMethod() {\n    self.variable = 1\n  }\n}\n", "target": "class MyClass:\n    name2 = 2 \n\n    def __init__(self):\n        \n        self.name1 = 0 \n  \n    def someMethod(self):\n        \n        self.name1 = 1\n        MyClass.name2 = 3\n  \n  \nmyclass = MyClass() \n\nclass MyOtherClass:\n    count = 0  \n    def __init__(self, name, gender=\"Male\", age=None):\n        \n        MyOtherClass.count += 1\n        self.name = name\n        self.gender = gender\n        if age is not None:\n            self.age = age\n    def __del__(self):\n        MyOtherClass.count -= 1\n\nperson1 = MyOtherClass(\"John\")\nprint person1.name, person1.gender  \nprint person1.age                   \nperson2 = MyOtherClass(\"Jane\", \"Female\", 23)\nprint person2.name, person2.gender, person2.age  \n"}
{"id": 128597, "name": "Roman numerals_Encode", "source": "Translate Swift to C#: func ator(var n: Int) -> String {\n\n    var result = \"\"\n    \n    for (value, letter) in\n       [( 1000,    \"M\"),\n        (  900,   \"CM\"),\n        (  500,    \"D\"),\n        (  400,   \"CD\"),\n        (  100,    \"C\"),\n        (   90,   \"XC\"),\n        (   50,    \"L\"),\n        (   40,   \"XL\"),\n        (   10,    \"X\"),\n        (    9,   \"IX\"),\n        (    5,    \"V\"),\n        (    4,   \"IV\"),\n        (    1,    \"I\")]\n    {\n        while n >= value {\n            result += letter\n            n   -= value\n        }\n    }\n    return result\n}\n", "target": "using System;\nclass Program\n{\n    static uint[] nums = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };\n    static string[] rum = { \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" };\n\n    static string ToRoman(uint number)\n    {\n        string value = \"\";\n        for (int i = 0; i < nums.Length && number != 0; i++)\n        {\n            while (number >= nums[i])\n            {\n                number -= nums[i];\n                value += rum[i];\n            }\n        }\n        return value;\n    }\n\n    static void Main()\n    {\n        for (uint number = 1; number <= 1 << 10; number *= 2)\n        {\n            Console.WriteLine(\"{0} = {1}\", number, ToRoman(number));\n        }\n    }\n}\n"}
{"id": 128598, "name": "Roman numerals_Encode", "source": "Translate Swift to C#: func ator(var n: Int) -> String {\n\n    var result = \"\"\n    \n    for (value, letter) in\n       [( 1000,    \"M\"),\n        (  900,   \"CM\"),\n        (  500,    \"D\"),\n        (  400,   \"CD\"),\n        (  100,    \"C\"),\n        (   90,   \"XC\"),\n        (   50,    \"L\"),\n        (   40,   \"XL\"),\n        (   10,    \"X\"),\n        (    9,   \"IX\"),\n        (    5,    \"V\"),\n        (    4,   \"IV\"),\n        (    1,    \"I\")]\n    {\n        while n >= value {\n            result += letter\n            n   -= value\n        }\n    }\n    return result\n}\n", "target": "using System;\nclass Program\n{\n    static uint[] nums = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };\n    static string[] rum = { \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" };\n\n    static string ToRoman(uint number)\n    {\n        string value = \"\";\n        for (int i = 0; i < nums.Length && number != 0; i++)\n        {\n            while (number >= nums[i])\n            {\n                number -= nums[i];\n                value += rum[i];\n            }\n        }\n        return value;\n    }\n\n    static void Main()\n    {\n        for (uint number = 1; number <= 1 << 10; number *= 2)\n        {\n            Console.WriteLine(\"{0} = {1}\", number, ToRoman(number));\n        }\n    }\n}\n"}
{"id": 128601, "name": "Roman numerals_Encode", "source": "Translate Swift to Java: func ator(var n: Int) -> String {\n\n    var result = \"\"\n    \n    for (value, letter) in\n       [( 1000,    \"M\"),\n        (  900,   \"CM\"),\n        (  500,    \"D\"),\n        (  400,   \"CD\"),\n        (  100,    \"C\"),\n        (   90,   \"XC\"),\n        (   50,    \"L\"),\n        (   40,   \"XL\"),\n        (   10,    \"X\"),\n        (    9,   \"IX\"),\n        (    5,    \"V\"),\n        (    4,   \"IV\"),\n        (    1,    \"I\")]\n    {\n        while n >= value {\n            result += letter\n            n   -= value\n        }\n    }\n    return result\n}\n", "target": "public class RN {\n\n    enum Numeral {\n        I(1), IV(4), V(5), IX(9), X(10), XL(40), L(50), XC(90), C(100), CD(400), D(500), CM(900), M(1000);\n        int weight;\n\n        Numeral(int weight) {\n            this.weight = weight;\n        }\n    };\n\n    public static String roman(long n) {\n        \n        if( n <= 0) {\n            throw new IllegalArgumentException();\n        }\n        \n        StringBuilder buf = new StringBuilder();\n\n        final Numeral[] values = Numeral.values();\n        for (int i = values.length - 1; i >= 0; i--) {\n            while (n >= values[i].weight) {\n                buf.append(values[i]);\n                n -= values[i].weight;\n            }\n        }\n        return buf.toString();\n    }\n\n    public static void test(long n) {\n        System.out.println(n + \" = \" + roman(n));\n    }\n\n    public static void main(String[] args) {\n        test(1999);\n        test(25);\n        test(944);\n        test(0);\n    }\n\n}\n"}
{"id": 128602, "name": "Roman numerals_Encode", "source": "Translate Swift to Java: func ator(var n: Int) -> String {\n\n    var result = \"\"\n    \n    for (value, letter) in\n       [( 1000,    \"M\"),\n        (  900,   \"CM\"),\n        (  500,    \"D\"),\n        (  400,   \"CD\"),\n        (  100,    \"C\"),\n        (   90,   \"XC\"),\n        (   50,    \"L\"),\n        (   40,   \"XL\"),\n        (   10,    \"X\"),\n        (    9,   \"IX\"),\n        (    5,    \"V\"),\n        (    4,   \"IV\"),\n        (    1,    \"I\")]\n    {\n        while n >= value {\n            result += letter\n            n   -= value\n        }\n    }\n    return result\n}\n", "target": "public class RN {\n\n    enum Numeral {\n        I(1), IV(4), V(5), IX(9), X(10), XL(40), L(50), XC(90), C(100), CD(400), D(500), CM(900), M(1000);\n        int weight;\n\n        Numeral(int weight) {\n            this.weight = weight;\n        }\n    };\n\n    public static String roman(long n) {\n        \n        if( n <= 0) {\n            throw new IllegalArgumentException();\n        }\n        \n        StringBuilder buf = new StringBuilder();\n\n        final Numeral[] values = Numeral.values();\n        for (int i = values.length - 1; i >= 0; i--) {\n            while (n >= values[i].weight) {\n                buf.append(values[i]);\n                n -= values[i].weight;\n            }\n        }\n        return buf.toString();\n    }\n\n    public static void test(long n) {\n        System.out.println(n + \" = \" + roman(n));\n    }\n\n    public static void main(String[] args) {\n        test(1999);\n        test(25);\n        test(944);\n        test(0);\n    }\n\n}\n"}
{"id": 128603, "name": "Roman numerals_Encode", "source": "Translate Swift to Python: func ator(var n: Int) -> String {\n\n    var result = \"\"\n    \n    for (value, letter) in\n       [( 1000,    \"M\"),\n        (  900,   \"CM\"),\n        (  500,    \"D\"),\n        (  400,   \"CD\"),\n        (  100,    \"C\"),\n        (   90,   \"XC\"),\n        (   50,    \"L\"),\n        (   40,   \"XL\"),\n        (   10,    \"X\"),\n        (    9,   \"IX\"),\n        (    5,    \"V\"),\n        (    4,   \"IV\"),\n        (    1,    \"I\")]\n    {\n        while n >= value {\n            result += letter\n            n   -= value\n        }\n    }\n    return result\n}\n", "target": "import roman\nprint(roman.toRoman(2022))\n"}
{"id": 128604, "name": "Roman numerals_Encode", "source": "Translate Swift to Python: func ator(var n: Int) -> String {\n\n    var result = \"\"\n    \n    for (value, letter) in\n       [( 1000,    \"M\"),\n        (  900,   \"CM\"),\n        (  500,    \"D\"),\n        (  400,   \"CD\"),\n        (  100,    \"C\"),\n        (   90,   \"XC\"),\n        (   50,    \"L\"),\n        (   40,   \"XL\"),\n        (   10,    \"X\"),\n        (    9,   \"IX\"),\n        (    5,    \"V\"),\n        (    4,   \"IV\"),\n        (    1,    \"I\")]\n    {\n        while n >= value {\n            result += letter\n            n   -= value\n        }\n    }\n    return result\n}\n", "target": "import roman\nprint(roman.toRoman(2022))\n"}
{"id": 128942, "name": "Loops_While", "source": "Translate Swift to C#: var i = 1024\nwhile i > 0 {\n  println(i)\n  i /= 2\n}\n", "target": "int i = 1024;\nwhile(i > 0){\n   System.Console.WriteLine(i);\n   i /= 2;\n}\n"}
{"id": 128944, "name": "Loops_While", "source": "Translate Swift to Java: var i = 1024\nwhile i > 0 {\n  println(i)\n  i /= 2\n}\n", "target": "int i = 1024;\nwhile(i > 0){\n   System.out.println(i);\n   i >>= 1; \n}\n"}
{"id": 128945, "name": "Loops_While", "source": "Translate Swift to Python: var i = 1024\nwhile i > 0 {\n  println(i)\n  i /= 2\n}\n", "target": "n = 1024\nwhile n > 0:\n    print n\n    n //= 2\n"}
{"id": 129425, "name": "Towers of Hanoi", "source": "Translate Swift to C#: func hanoi(n:Int, a:String, b:String, c:String) {\n    if (n > 0) {\n        hanoi(n - 1, a, c, b)\n        println(\"Move disk from \\(a) to \\(c)\")\n        hanoi(n - 1, b, a, c)\n    }\n}\n\nhanoi(4, \"A\", \"B\", \"C\")\n", "target": "public  void move(int n, int from, int to, int via) {\n   if (n == 1) {\n     System.Console.WriteLine(\"Move disk from pole \" + from + \" to pole \" + to);\n   } else {\n     move(n - 1, from, via, to);\n     move(1, from, to, via);\n     move(n - 1, via, to, from);\n   }\n }\n"}
{"id": 129427, "name": "Towers of Hanoi", "source": "Translate Swift to Java: func hanoi(n:Int, a:String, b:String, c:String) {\n    if (n > 0) {\n        hanoi(n - 1, a, c, b)\n        println(\"Move disk from \\(a) to \\(c)\")\n        hanoi(n - 1, b, a, c)\n    }\n}\n\nhanoi(4, \"A\", \"B\", \"C\")\n", "target": "public void move(int n, int from, int to, int via) {\n  if (n == 1) {\n    System.out.println(\"Move disk from pole \" + from + \" to pole \" + to);\n  } else {\n    move(n - 1, from, via, to);\n    move(1, from, to, via);\n    move(n - 1, via, to, from);\n  }\n}\n"}
{"id": 129428, "name": "Towers of Hanoi", "source": "Translate Swift to Python: func hanoi(n:Int, a:String, b:String, c:String) {\n    if (n > 0) {\n        hanoi(n - 1, a, c, b)\n        println(\"Move disk from \\(a) to \\(c)\")\n        hanoi(n - 1, b, a, c)\n    }\n}\n\nhanoi(4, \"A\", \"B\", \"C\")\n", "target": "\n\n\n\u0ba8\u0bbf\u0bb0\u0bb2\u0bcd\u0baa\u0bbe\u0b95\u0bae\u0bcd \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd, \u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1, \u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1)\n\n  @(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd == 1 ) \u0b86\u0ba9\u0bbe\u0bb2\u0bcd\n     \u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf  \u201c\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1 \u201d + str(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1) + \u201c\u0b90 \\t  (\u201d + str(\u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1) + \u201c  \u2014> \u201d +  str(\u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1)+ \u201c) \u0b85\u0b9a\u0bcd\u0b9a\u0bbf\u0bb1\u0bcd\u0b95\u0bc1 \u0ba8\u0b95\u0bb0\u0bcd\u0ba4\u0bcd\u0ba4\u0bc1\u0b95.\u201d\n  \u0b87\u0bb2\u0bcd\u0bb2\u0bc8\n\n  @( [\"\u0b87\", \"\u0b85\",  \"\u0b86\"]  \u0b87\u0bb2\u0bcd \u0b85\u0b9a\u0bcd\u0b9a\u0bc1 ) \u0b92\u0bb5\u0bcd\u0bb5\u0bca\u0ba9\u0bcd\u0bb1\u0bbe\u0b95\n          @( (\u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1 != \u0b85\u0b9a\u0bcd\u0b9a\u0bc1)  && (\u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1  != \u0b85\u0b9a\u0bcd\u0b9a\u0bc1) ) \u0b86\u0ba9\u0bbe\u0bb2\u0bcd\n              \u0ba8\u0b9f\u0bc1 = \u0b85\u0b9a\u0bcd\u0b9a\u0bc1\n          \u0bae\u0bc1\u0b9f\u0bbf\n  \u0bae\u0bc1\u0b9f\u0bbf\n\n    \n    \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1,   \u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0ba8\u0b9f\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1)\n\n    \n    \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(1, \u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1, \u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd)\n\n    \n    \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1, \u0ba8\u0b9f\u0bc1, \u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1)\n  \u0bae\u0bc1\u0b9f\u0bbf\n\u0bae\u0bc1\u0b9f\u0bbf\n\n\u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(4,\u201d\u0b85\u201d,\u201d\u0b86\u201d,0)\n"}
{"id": 129619, "name": "Active object", "source": "Translate Swift to C#: \nimport Foundation\n\nimport Darwin\n\nclass ActiveObject:NSObject {\n\n    let sampling = 0.1\n    var K: (t: NSTimeInterval) -> Double\n    var S: Double\n    var t0, t1: NSTimeInterval\n    var thread = NSThread()\n    \n    func integrateK() {\n        t0 = t1\n        t1 += sampling\n        S += (K(t:t1) + K(t: t0)) * (t1 - t0) / 2\n    }\n\n    func updateObject() {\n        while true {\n            integrateK()\n            usleep(100000)\n        }\n    }\n    \n    init(function: (NSTimeInterval) -> Double) {\n        S = 0\n        t0 = 0\n        t1 = 0\n        K = function\n        super.init()\n        thread = NSThread(target: self, selector: \"updateObject\", object: nil)\n        thread.start()\n    }\n    \n    func Input(function: (NSTimeInterval) -> Double) {\n        K = function\n\n    }\n    \n    func Output() -> Double {\n        return S\n    }\n    \n}\n\n\nfunc sine(t: NSTimeInterval) -> Double {\n    let f = 0.5\n    \n    return sin(2 * M_PI * f * t)\n}\n\nvar activeObject = ActiveObject(function: sine)\n\nvar date = NSDate()\n\nsleep(2)\n\nactiveObject.Input({(t: NSTimeInterval) -> Double in return 0.0})\n\nusleep(500000)\n\nprintln(activeObject.Output())\n", "target": "using System;\nusing System.Threading.Tasks;\n\nusing static System.Diagnostics.Stopwatch;\nusing static System.Math;\nusing static System.Threading.Thread;\n\nclass ActiveObject\n{\n    static double timeScale = 1.0 / Frequency;\n\n    Func<double, double> func;\n    Task updateTask;\n    double integral;\n    double value;\n    long timestamp0, timestamp;\n\n    public ActiveObject(Func<double, double> input)\n    {\n        timestamp0 = timestamp = GetTimestamp();\n        func = input;\n        value = func(0);\n        updateTask = Integrate();\n    }\n\n    public void ChangeInput(Func<double, double> input)\n    {\n        lock (updateTask)\n        {\n            func = input;\n        }\n    }\n\n    public double Value\n    {\n        get\n        {\n            lock (updateTask)\n            {\n                return integral;\n            }\n        }\n    }\n\n    async Task Integrate()\n    {\n        while (true)\n        {\n            await Task.Yield();\n            var newTime = GetTimestamp();\n            double newValue;\n\n            lock (updateTask)\n            {\n                newValue = func((newTime - timestamp0) * timeScale);\n                integral += (newValue + value) * (newTime - timestamp) * timeScale / 2;\n            }\n\n            timestamp = newTime;\n            value = newValue;\n        }\n    }\n}\n\nclass Program\n{\n    static Func<double, double> Sine(double frequency) =>\n        t => Sin(2 * PI * frequency * t);\n\n    static void Main(string[] args)\n    {\n        var ao = new ActiveObject(Sine(0.5));\n        Sleep(TimeSpan.FromSeconds(2));\n        ao.ChangeInput(t => 0);\n        Sleep(TimeSpan.FromSeconds(0.5));\n        Console.WriteLine(ao.Value);\n    }\n}\n"}
{"id": 129621, "name": "Active object", "source": "Translate Swift to Java: \nimport Foundation\n\nimport Darwin\n\nclass ActiveObject:NSObject {\n\n    let sampling = 0.1\n    var K: (t: NSTimeInterval) -> Double\n    var S: Double\n    var t0, t1: NSTimeInterval\n    var thread = NSThread()\n    \n    func integrateK() {\n        t0 = t1\n        t1 += sampling\n        S += (K(t:t1) + K(t: t0)) * (t1 - t0) / 2\n    }\n\n    func updateObject() {\n        while true {\n            integrateK()\n            usleep(100000)\n        }\n    }\n    \n    init(function: (NSTimeInterval) -> Double) {\n        S = 0\n        t0 = 0\n        t1 = 0\n        K = function\n        super.init()\n        thread = NSThread(target: self, selector: \"updateObject\", object: nil)\n        thread.start()\n    }\n    \n    func Input(function: (NSTimeInterval) -> Double) {\n        K = function\n\n    }\n    \n    func Output() -> Double {\n        return S\n    }\n    \n}\n\n\nfunc sine(t: NSTimeInterval) -> Double {\n    let f = 0.5\n    \n    return sin(2 * M_PI * f * t)\n}\n\nvar activeObject = ActiveObject(function: sine)\n\nvar date = NSDate()\n\nsleep(2)\n\nactiveObject.Input({(t: NSTimeInterval) -> Double in return 0.0})\n\nusleep(500000)\n\nprintln(activeObject.Output())\n", "target": "\npublic class Integrator {\n\n    public interface Function {\n        double apply(double timeSinceStartInSeconds);\n    }\n\n    private final long start;\n    private volatile boolean running;\n\n    private Function func;\n    private double t0;\n    private double v0;\n    private double sum;\n\n    public Integrator(Function func) {\n        this.start = System.nanoTime();\n        setFunc(func);\n        new Thread(this::integrate).start();\n    }\n\n    public void setFunc(Function func) {\n        this.func = func;\n        v0 = func.apply(0.0);\n        t0 = 0;\n    }\n\n    public double getOutput() {\n        return sum;\n    }\n\n    public void stop() {\n        running = false;\n    }\n\n    private void integrate() {\n        running = true;\n        while (running) {\n            try {\n                Thread.sleep(1);\n                update();\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n    }\n\n    private void update() {\n        double t1 = (System.nanoTime() - start) / 1.0e9;\n        double v1 = func.apply(t1);\n        double rect = (t1 - t0) * (v0 + v1) / 2;\n        this.sum += rect;\n        t0 = t1;\n        v0 = v1;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Integrator integrator = new Integrator(t -> Math.sin(Math.PI * t));\n        Thread.sleep(2000);\n\n        integrator.setFunc(t -> 0.0);\n        Thread.sleep(500);\n\n        integrator.stop();\n        System.out.println(integrator.getOutput());\n    }\n}\n"}
{"id": 129622, "name": "Active object", "source": "Translate Swift to Python: \nimport Foundation\n\nimport Darwin\n\nclass ActiveObject:NSObject {\n\n    let sampling = 0.1\n    var K: (t: NSTimeInterval) -> Double\n    var S: Double\n    var t0, t1: NSTimeInterval\n    var thread = NSThread()\n    \n    func integrateK() {\n        t0 = t1\n        t1 += sampling\n        S += (K(t:t1) + K(t: t0)) * (t1 - t0) / 2\n    }\n\n    func updateObject() {\n        while true {\n            integrateK()\n            usleep(100000)\n        }\n    }\n    \n    init(function: (NSTimeInterval) -> Double) {\n        S = 0\n        t0 = 0\n        t1 = 0\n        K = function\n        super.init()\n        thread = NSThread(target: self, selector: \"updateObject\", object: nil)\n        thread.start()\n    }\n    \n    func Input(function: (NSTimeInterval) -> Double) {\n        K = function\n\n    }\n    \n    func Output() -> Double {\n        return S\n    }\n    \n}\n\n\nfunc sine(t: NSTimeInterval) -> Double {\n    let f = 0.5\n    \n    return sin(2 * M_PI * f * t)\n}\n\nvar activeObject = ActiveObject(function: sine)\n\nvar date = NSDate()\n\nsleep(2)\n\nactiveObject.Input({(t: NSTimeInterval) -> Double in return 0.0})\n\nusleep(500000)\n\nprintln(activeObject.Output())\n", "target": "from time import time, sleep\nfrom threading import Thread\n\nclass Integrator(Thread):\n    'continuously integrate a function `K`, at each `interval` seconds'\n    def __init__(self, K=lambda t:0, interval=1e-4):\n        Thread.__init__(self)\n        self.interval  = interval\n        self.K   = K\n        self.S   = 0.0\n        self.__run = True\n        self.start()\n\n    def run(self):\n        \"entry point for the thread\"\n        interval = self.interval\n        start = time()\n        t0, k0 = 0, self.K(0)\n        while self.__run:\n            sleep(interval)\n            t1 = time() - start\n            k1 = self.K(t1)\n            self.S += (k1 + k0)*(t1 - t0)/2.0\n            t0, k0 = t1, k1\n\n    def join(self):\n        self.__run = False\n        Thread.join(self)\n\nif __name__ == \"__main__\":\n    from math import sin, pi\n \n    ai = Integrator(lambda t: sin(pi*t))\n    sleep(2)\n    print(ai.S)\n    ai.K = lambda t: 0\n    sleep(0.5)\n    print(ai.S)\n"}
{"id": 129964, "name": "Remove duplicate elements", "source": "Translate Swift to C#: println(Array(Set([3,2,1,2,3,4])))\n", "target": "int[] nums = { 1, 1, 2, 3, 4, 4 };\nList<int> unique = new List<int>();\nforeach (int n in nums)\n    if (!unique.Contains(n))\n        unique.Add(n);\n"}
{"id": 129966, "name": "Remove duplicate elements", "source": "Translate Swift to Java: println(Array(Set([3,2,1,2,3,4])))\n", "target": "module RetainUniqueValues\n    {\n    @Inject Console console;\n    void run()\n        {\n        Int[] array = [1, 2, 3, 2, 1, 2, 3, 4, 5, 3, 2, 1];\n        array = array.distinct().toArray();\n        console.print($\"result={array}\");\n        }\n    }\n"}
{"id": 129967, "name": "Remove duplicate elements", "source": "Translate Swift to Python: println(Array(Set([3,2,1,2,3,4])))\n", "target": "items = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\n"}
{"id": 130209, "name": "Emirp primes", "source": "Translate Swift to C#: import Foundation\n\nextension BinaryInteger {\n  var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n}\n\nfunc isEmirp<T: BinaryInteger>(n: T) -> Bool {\n  guard n.isPrime else {\n    return false\n  }\n\n  var aux = n\n  var revPrime = T(0)\n\n  while aux > 0 {\n    revPrime = revPrime * 10 + aux % 10\n    aux /= 10\n  }\n\n  guard n != revPrime else {\n    return false\n  }\n\n  return revPrime.isPrime\n}\n\nlet lots = (2...).lazy.filter(isEmirp).prefix(10000)\nlet rang = (7700...8000).filter(isEmirp)\n\nprint(\"First 20 emirps: \\(Array(lots.prefix(20)))\")\nprint(\"Emirps between 7700 and 8000: \\(rang)\")\nprint(\"10,000th emirp: \\(Array(lots).last!)\")\n", "target": "using static System.Console;\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main() {\n        const int limit = 1_000_000;\n        WriteLine(\"First 20:\");\n        WriteLine(FindEmirpPrimes(limit).Take(20).Delimit());\n        WriteLine();\n\t\t\n        WriteLine(\"Between 7700 and 8000:\");\n        WriteLine(FindEmirpPrimes(limit).SkipWhile(p => p < 7700).TakeWhile(p => p < 8000).Delimit());\n        WriteLine();\n\t\t\n        WriteLine(\"10000th:\");\n        WriteLine(FindEmirpPrimes(limit).ElementAt(9999));\n    }\n\t\n    private static IEnumerable<int> FindEmirpPrimes(int limit)\n    {\n        var primes = Primes(limit).ToHashSet();\n\t\t\n        foreach (int prime in primes) {\n            int reverse = prime.Reverse();\n            if (reverse != prime && primes.Contains(reverse)) yield return prime;\n\t}\n    }\n\t\n    private static IEnumerable<int> Primes(int bound) {\n        if (bound < 2) yield break;\n        yield return 2;\n\t\t\n        BitArray composite = new BitArray((bound - 1) / 2);\n        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;\n        for (int i = 0; i < limit; i++) {\n            if (composite[i]) continue;\n\t    int prime = 2 * i + 3;\n\t    yield return prime;\n\t\t\t\n\t    for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime)\n\t        composite[j] = true;\n        }\n\tfor (int i = limit; i < composite.Count; i++)\n\t    if (!composite[i]) yield return 2 * i + 3;\n    }\n}\n\npublic static class Extensions\n{\n    public static HashSet<T> ToHashSet<T>(this IEnumerable<T> source) => new HashSet<T>(source);\n\n    private const string defaultSeparator = \" \";\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = defaultSeparator) =>\n        string.Join(separator ?? defaultSeparator, source);\n\n    public static int Reverse(this int number)\n    {\n\tif (number < 0) return -Reverse(-number);\n\tif (number < 10) return number;\n\tint reverse = 0;\n\twhile (number > 0) {\n\t    reverse = reverse * 10 + number % 10;\n\t    number /= 10;\n\t}\n\treturn reverse;\n    }\n}\n"}
{"id": 130211, "name": "Emirp primes", "source": "Translate Swift to Java: import Foundation\n\nextension BinaryInteger {\n  var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n}\n\nfunc isEmirp<T: BinaryInteger>(n: T) -> Bool {\n  guard n.isPrime else {\n    return false\n  }\n\n  var aux = n\n  var revPrime = T(0)\n\n  while aux > 0 {\n    revPrime = revPrime * 10 + aux % 10\n    aux /= 10\n  }\n\n  guard n != revPrime else {\n    return false\n  }\n\n  return revPrime.isPrime\n}\n\nlet lots = (2...).lazy.filter(isEmirp).prefix(10000)\nlet rang = (7700...8000).filter(isEmirp)\n\nprint(\"First 20 emirps: \\(Array(lots.prefix(20)))\")\nprint(\"Emirps between 7700 and 8000: \\(rang)\")\nprint(\"10,000th emirp: \\(Array(lots).last!)\")\n", "target": "public class Emirp{\n\t\n\t\n\tpublic static boolean isPrime(long x){\n\t\tif(x < 2) return false;\n\t\tif(x == 2) return true;\n\t\tif((x & 1) == 0) return false;\n\t\t\n\t\tfor(long i = 3; i <= Math.sqrt(x);i+=2){\n\t\t\tif(x % i == 0) return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isEmirp(long x){\n\t\tString xString = Long.toString(x);\n\t\tif(xString.length() == 1) return false;\n\t\tif(xString.matches(\"[24568].*\") || xString.matches(\".*[24568]\")) return false; \n\t\tlong xR = Long.parseLong(new StringBuilder(xString).reverse().toString());\n\t\tif(xR == x) return false;\n\t\treturn isPrime(x) && isPrime(xR);\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tint count = 0;\n\t\tlong x = 1;\n\t\t\n\t\tSystem.out.println(\"First 20 emirps:\");\n\t\twhile(count < 20){\n\t\t\tif(isEmirp(x)){\n\t\t\t\tcount++;\n\t\t\t\tSystem.out.print(x + \" \");\n\t\t\t}\n\t\t\tx++;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"\\nEmirps between 7700 and 8000:\");\n\t\tfor(x = 7700; x <= 8000; x++){\n\t\t\tif(isEmirp(x)){\n\t\t\t\tSystem.out.print(x +\" \");\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"\\n10,000th emirp:\");\n\t\tfor(x = 1, count = 0;count < 10000; x++){\n\t\t\tif(isEmirp(x)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(--x);\n\t}\n}\n"}
{"id": 130212, "name": "Emirp primes", "source": "Translate Swift to Python: import Foundation\n\nextension BinaryInteger {\n  var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n}\n\nfunc isEmirp<T: BinaryInteger>(n: T) -> Bool {\n  guard n.isPrime else {\n    return false\n  }\n\n  var aux = n\n  var revPrime = T(0)\n\n  while aux > 0 {\n    revPrime = revPrime * 10 + aux % 10\n    aux /= 10\n  }\n\n  guard n != revPrime else {\n    return false\n  }\n\n  return revPrime.isPrime\n}\n\nlet lots = (2...).lazy.filter(isEmirp).prefix(10000)\nlet rang = (7700...8000).filter(isEmirp)\n\nprint(\"First 20 emirps: \\(Array(lots.prefix(20)))\")\nprint(\"Emirps between 7700 and 8000: \\(rang)\")\nprint(\"10,000th emirp: \\(Array(lots).last!)\")\n", "target": "from __future__ import print_function\nfrom prime_decomposition import primes, is_prime\nfrom heapq import *\nfrom itertools import islice\n\ndef emirp():\n    largest = set()\n    emirps = []\n    heapify(emirps)\n    for pr in primes():\n        while emirps and pr > emirps[0]:\n            yield heappop(emirps)\n        if pr in largest:\n            yield pr\n        else:\n            rp = int(str(pr)[::-1])\n            if rp > pr and is_prime(rp):\n                heappush(emirps, pr)\n                largest.add(rp)\n\nprint('First 20:\\n  ', list(islice(emirp(), 20)))\nprint('Between 7700 and 8000:\\n  [', end='')\nfor pr in emirp():\n    if pr >= 8000: break\n    if pr >= 7700: print(pr, end=', ')\nprint(']')\nprint('10000th:\\n  ', list(islice(emirp(), 10000-1, 10000)))\n"}
{"id": 131486, "name": "Constrained random points on a circle", "source": "Translate Swift to C#: let nPoints = 100\n\nfunc generatePoint() -> (Int, Int) {\n  while true {\n    let x = Int.random(in: -15...16)\n    let y = Int.random(in: -15...16)\n    let r2 = x * x + y * y\n\n    if r2 >= 100 && r2 <= 225 {\n      return (x, y)\n    }\n  }\n}\n\nfunc filteringMethod() {\n  var rows = [[String]](repeating: Array(repeating: \" \", count: 62), count: 31)\n\n  for _ in 0..<nPoints {\n    let (x, y) = generatePoint()\n\n    rows[y + 15][x + 15 * 2] = \"*\"\n  }\n\n  for row in rows {\n    print(row.joined())\n  }\n}\n\nfunc precalculatingMethod() {\n  var possiblePoints = [(Int, Int)]()\n\n  for y in -15...15 {\n    for x in -15...15 {\n      let r2 = x * x + y * y\n\n      if r2 >= 100 && r2 <= 225 {\n        possiblePoints.append((x, y))\n      }\n    }\n  }\n\n  possiblePoints.shuffle()\n\n  var rows = [[String]](repeating: Array(repeating: \" \", count: 62), count: 31)\n\n  for (x, y) in possiblePoints {\n    rows[y + 15][x + 15 * 2] = \"*\"\n  }\n\n  for row in rows {\n    print(row.joined())\n  }\n}\n\nprint(\"Filtering method:\")\nfilteringMethod()\n\nprint(\"Precalculating method:\")\nprecalculatingMethod()\n", "target": "using System;\nusing System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaConstrainedRandomCircle\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var points = new Point[404];\n            int i = 0;\n            for (int y = -15; y <= 15; y++)\n                for (int x = -15; x <= 15 && i < 404; x++)\n                {\n                    var c = Math.Sqrt(x * x + y * y);\n                    if (10 <= c && c <= 15)\n                    {\n                        points[i++] = new Point(x, y);\n                    }\n                }\n\n            var bm = new Bitmap(600, 600);\n            var g = Graphics.FromImage(bm);\n            var brush = new SolidBrush(Color.Magenta);\n\n            var r = new System.Random();\n            for (int count = 0; count < 100; count++)\n            {\n                var p = points[r.Next(404)];\n                g.FillEllipse(brush, new Rectangle(290 + 19 * p.X, 290 + 19 * p.Y, 10, 10));\n            }\n            const string filename = \"Constrained Random Circle.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 131488, "name": "Constrained random points on a circle", "source": "Translate Swift to Java: let nPoints = 100\n\nfunc generatePoint() -> (Int, Int) {\n  while true {\n    let x = Int.random(in: -15...16)\n    let y = Int.random(in: -15...16)\n    let r2 = x * x + y * y\n\n    if r2 >= 100 && r2 <= 225 {\n      return (x, y)\n    }\n  }\n}\n\nfunc filteringMethod() {\n  var rows = [[String]](repeating: Array(repeating: \" \", count: 62), count: 31)\n\n  for _ in 0..<nPoints {\n    let (x, y) = generatePoint()\n\n    rows[y + 15][x + 15 * 2] = \"*\"\n  }\n\n  for row in rows {\n    print(row.joined())\n  }\n}\n\nfunc precalculatingMethod() {\n  var possiblePoints = [(Int, Int)]()\n\n  for y in -15...15 {\n    for x in -15...15 {\n      let r2 = x * x + y * y\n\n      if r2 >= 100 && r2 <= 225 {\n        possiblePoints.append((x, y))\n      }\n    }\n  }\n\n  possiblePoints.shuffle()\n\n  var rows = [[String]](repeating: Array(repeating: \" \", count: 62), count: 31)\n\n  for (x, y) in possiblePoints {\n    rows[y + 15][x + 15 * 2] = \"*\"\n  }\n\n  for row in rows {\n    print(row.joined())\n  }\n}\n\nprint(\"Filtering method:\")\nfilteringMethod()\n\nprint(\"Precalculating method:\")\nprecalculatingMethod()\n", "target": "import java.util.Random;\n\npublic class FuzzyCircle {\n\tstatic final Random rnd = new Random();\n\tpublic static void main(String[] args){\n\t\tchar[][] field = new char[31][31];\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[i].length; j++){\n\t\t\t\tfield[i][j] = ' ';\n\t\t\t}\n\t\t}\n\t\tint pointsInDisc = 0;\n\t\twhile(pointsInDisc < 100){\n\t\t\tint x = rnd.nextInt(31) - 15;\n\t\t\tint y = rnd.nextInt(31) - 15;\n\t\t\tdouble dist = Math.hypot(x, y);\n\t\t\tif(dist >= 10 && dist <= 15 && field[x + 15][y + 15] == ' '){\n\t\t\t\tfield[x + 15][y + 15] = 'X';\n\t\t\t\tpointsInDisc++;\n\t\t\t}\n\t\t}\n\t\tfor(char[] row:field){\n\t\t\tfor(char space:row){\n\t\t\t\tSystem.out.print(space);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 131489, "name": "Constrained random points on a circle", "source": "Translate Swift to Python: let nPoints = 100\n\nfunc generatePoint() -> (Int, Int) {\n  while true {\n    let x = Int.random(in: -15...16)\n    let y = Int.random(in: -15...16)\n    let r2 = x * x + y * y\n\n    if r2 >= 100 && r2 <= 225 {\n      return (x, y)\n    }\n  }\n}\n\nfunc filteringMethod() {\n  var rows = [[String]](repeating: Array(repeating: \" \", count: 62), count: 31)\n\n  for _ in 0..<nPoints {\n    let (x, y) = generatePoint()\n\n    rows[y + 15][x + 15 * 2] = \"*\"\n  }\n\n  for row in rows {\n    print(row.joined())\n  }\n}\n\nfunc precalculatingMethod() {\n  var possiblePoints = [(Int, Int)]()\n\n  for y in -15...15 {\n    for x in -15...15 {\n      let r2 = x * x + y * y\n\n      if r2 >= 100 && r2 <= 225 {\n        possiblePoints.append((x, y))\n      }\n    }\n  }\n\n  possiblePoints.shuffle()\n\n  var rows = [[String]](repeating: Array(repeating: \" \", count: 62), count: 31)\n\n  for (x, y) in possiblePoints {\n    rows[y + 15][x + 15 * 2] = \"*\"\n  }\n\n  for row in rows {\n    print(row.joined())\n  }\n}\n\nprint(\"Filtering method:\")\nfilteringMethod()\n\nprint(\"Precalculating method:\")\nprecalculatingMethod()\n", "target": ">>> from collections import defaultdict\n>>> from random import choice\n>>> world = defaultdict(int)\n>>> possiblepoints = [(x,y) for x in range(-15,16)\n\t\t  for y in range(-15,16)\n\t\t  if 10 <= abs(x+y*1j) <= 15]\n>>> for i in range(100): world[choice(possiblepoints)] += 1\n\n>>> for x in range(-15,16):\n\tprint(''.join(str(min([9, world[(x,y)]])) if world[(x,y)] else ' '\n\t\t\t  for y in range(-15,16)))\n\n\t\n                               \n             1     1           \n          1 1                  \n      11 1     1  1     1      \n     111  1     1211           \n      1   2    1 1    11       \n      1  11         21         \n     1   1            11  1    \n   1  2                1 1     \n                               \n 1  2                          \n   1 1                      1  \n   1 1                         \n   2                      11   \n  1                         1  \n                         1     \n                               \n                               \n  1                          1 \n                         1     \n                         2     \n                            1  \n     1                  1 1    \n      1                2   1   \n   1   3            11  2      \n    11   1    1      1   2     \n            1   1    2         \n        1  1                   \n         1      1     1        \n          2 2   1              \n               1\n"}
{"id": 131643, "name": "Call an object method", "source": "Translate Swift to C#: \nMyClass.method(someParameter)\n\nlet foo = MyClass.self\nfoo.method(someParameter)\n\n\nmyInstance.method(someParameter)\n\n\nmyInstance.method(red:arg1, green:arg2, blue:arg3)\n", "target": "\nMyClass.Method(someParameter);\n \n\nmyInstance.Method(someParameter);\n"}
{"id": 131645, "name": "Call an object method", "source": "Translate Swift to Java: \nMyClass.method(someParameter)\n\nlet foo = MyClass.self\nfoo.method(someParameter)\n\n\nmyInstance.method(someParameter)\n\n\nmyInstance.method(red:arg1, green:arg2, blue:arg3)\n", "target": "\nMyClass.method(someParameter);\n\n\nmyInstance.method(someParameter);\n"}
{"id": 131646, "name": "Call an object method", "source": "Translate Swift to Python: \nMyClass.method(someParameter)\n\nlet foo = MyClass.self\nfoo.method(someParameter)\n\n\nmyInstance.method(someParameter)\n\n\nmyInstance.method(red:arg1, green:arg2, blue:arg3)\n", "target": "class MyClass(object):\n\t@classmethod\n\tdef myClassMethod(self, x):\n\t\tpass\n\t@staticmethod\n\tdef myStaticMethod(x):\n\t\tpass\n\tdef myMethod(self, x):\n\t\treturn 42 + x\n\nmyInstance = MyClass()\n\n\nmyInstance.myMethod(someParameter)\n\nMyClass.myMethod(myInstance, someParameter)\n\n\n\nMyClass.myClassMethod(someParameter)\nMyClass.myStaticMethod(someParameter)\n\nmyInstance.myClassMethod(someParameter)\nmyInstance.myStaticMethod(someParameter)\n"}
{"id": 132009, "name": "Factors of a Mersenne number", "source": "Translate Swift to C#: import Foundation\n\nextension BinaryInteger {\n  var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n\n  func modPow(exp: Self, mod: Self) -> Self {\n    guard exp != 0 else {\n      return 1\n    }\n\n    var res = Self(1)\n    var base = self % mod\n    var exp = exp\n\n    while true {\n      if exp & 1 == 1 {\n        res *= base\n        res %= mod\n      }\n\n      if exp == 1 {\n        return res\n      }\n\n      exp >>= 1\n      base *= base\n      base %= mod\n    }\n  }\n}\n\nfunc mFactor(exp: Int) -> Int? {\n  for k in 0..<16384 {\n    let q = 2*exp*k + 1\n\n    if !q.isPrime {\n      continue\n    } else if q % 8 != 1 && q % 8 != 7 {\n      continue\n    } else if 2.modPow(exp: exp, mod: q) == 1 {\n      return q\n    }\n  }\n\n  return nil\n}\n\nprint(mFactor(exp: 929)!)\n", "target": "using System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tint q = 929;\n\t\t\tif ( !isPrime(q) ) return;\n\t\t\tint r = q;\n\t\t\twhile( r > 0 ) \n\t\t\t\tr <<= 1;\n\t\t\tint d = 2 * q + 1;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tint i = 1;\n\t\t\t\tfor( int p=r; p!=0; p<<=1 )\n\t\t\t\t{\n\t\t\t\t\ti = (i*i) % d;\n\t\t\t\t\tif (p < 0) i *= 2;\n\t\t\t\t\tif (i > d) i -= d;\n\t\t\t\t}\n\t\t\t\tif (i != 1) d += 2 * q; else break;\t\t\t\t\n\t\t\t}\n\t\t\twhile(true);\n\t\t\t\n\t\t\tConsole.WriteLine(\"2^\"+q+\"-1 = 0 (mod \"+d+\")\"); \n\t\t}\n\t\t\n\t\tstatic bool isPrime(int n)\n\t\t{\n\t\t\tif ( n % 2 == 0 ) return n == 2;\n\t\t\tif ( n % 3 == 0 ) return n == 3;\n\t\t\tint d = 5;\n\t\t\twhile( d*d <= n )\n\t\t\t{\n\t\t\t\tif ( n % d == 0 ) return false;\n\t\t\t\td += 2;\n\t\t\t\tif ( n % d == 0 ) return false;\n\t\t\t\td += 4;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n}\n"}
{"id": 132011, "name": "Factors of a Mersenne number", "source": "Translate Swift to Java: import Foundation\n\nextension BinaryInteger {\n  var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n\n  func modPow(exp: Self, mod: Self) -> Self {\n    guard exp != 0 else {\n      return 1\n    }\n\n    var res = Self(1)\n    var base = self % mod\n    var exp = exp\n\n    while true {\n      if exp & 1 == 1 {\n        res *= base\n        res %= mod\n      }\n\n      if exp == 1 {\n        return res\n      }\n\n      exp >>= 1\n      base *= base\n      base %= mod\n    }\n  }\n}\n\nfunc mFactor(exp: Int) -> Int? {\n  for k in 0..<16384 {\n    let q = 2*exp*k + 1\n\n    if !q.isPrime {\n      continue\n    } else if q % 8 != 1 && q % 8 != 7 {\n      continue\n    } else if 2.modPow(exp: exp, mod: q) == 1 {\n      return q\n    }\n  }\n\n  return nil\n}\n\nprint(mFactor(exp: 929)!)\n", "target": "import java.math.BigInteger;\n\nclass MersenneFactorCheck\n{\n\n  private final static BigInteger TWO = BigInteger.valueOf(2);\n  \n  public static boolean isPrime(long n)\n  {\n    if (n == 2)\n      return true;\n    if ((n < 2) || ((n & 1) == 0))\n      return false;\n    long maxFactor = (long)Math.sqrt((double)n);\n    for (long possibleFactor = 3; possibleFactor <= maxFactor; possibleFactor += 2)\n      if ((n % possibleFactor) == 0)\n        return false;\n    return true;\n  }\n  \n  public static BigInteger findFactorMersenneNumber(int primeP)\n  {\n    if (primeP <= 0)\n      throw new IllegalArgumentException();\n    BigInteger bigP = BigInteger.valueOf(primeP);\n    BigInteger m = BigInteger.ONE.shiftLeft(primeP).subtract(BigInteger.ONE);\n    \n    BigInteger maxFactor = BigInteger.ONE.shiftLeft((primeP + 1) >>> 1);\n    BigInteger twoP = BigInteger.valueOf(primeP << 1);\n    BigInteger possibleFactor = BigInteger.ONE;\n    int possibleFactorBits12 = 0;\n    int twoPBits12 = primeP & 3;\n    \n    while ((possibleFactor = possibleFactor.add(twoP)).compareTo(maxFactor) <= 0)\n    {\n      possibleFactorBits12 = (possibleFactorBits12 + twoPBits12) & 3;\n      \n      if ((possibleFactorBits12 == 0) || (possibleFactorBits12 == 3))\n        if (TWO.modPow(bigP, possibleFactor).equals(BigInteger.ONE))\n          return possibleFactor;\n    }\n    return null;\n  }\n  \n  public static void checkMersenneNumber(int p)\n  {\n    if (!isPrime(p))\n    {\n      System.out.println(\"M\" + p + \" is not prime\");\n      return;\n    }\n    BigInteger factor = findFactorMersenneNumber(p);\n    if (factor == null)\n      System.out.println(\"M\" + p + \" is prime\");\n    else\n      System.out.println(\"M\" + p + \" is not prime, has factor \" + factor);\n    return;\n  }\n\n  public static void main(String[] args)\n  {\n    for (int p = 1; p <= 50; p++)\n      checkMersenneNumber(p);\n    checkMersenneNumber(929);\n    return;\n  }\n  \n}\n"}
{"id": 132012, "name": "Factors of a Mersenne number", "source": "Translate Swift to Python: import Foundation\n\nextension BinaryInteger {\n  var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n\n  func modPow(exp: Self, mod: Self) -> Self {\n    guard exp != 0 else {\n      return 1\n    }\n\n    var res = Self(1)\n    var base = self % mod\n    var exp = exp\n\n    while true {\n      if exp & 1 == 1 {\n        res *= base\n        res %= mod\n      }\n\n      if exp == 1 {\n        return res\n      }\n\n      exp >>= 1\n      base *= base\n      base %= mod\n    }\n  }\n}\n\nfunc mFactor(exp: Int) -> Int? {\n  for k in 0..<16384 {\n    let q = 2*exp*k + 1\n\n    if !q.isPrime {\n      continue\n    } else if q % 8 != 1 && q % 8 != 7 {\n      continue\n    } else if 2.modPow(exp: exp, mod: q) == 1 {\n      return q\n    }\n  }\n\n  return nil\n}\n\nprint(mFactor(exp: 929)!)\n", "target": "def is_prime(number):\n    return True \n\ndef m_factor(p):\n    max_k = 16384 / p \n    for k in xrange(max_k):\n        q = 2*p*k + 1\n        if not is_prime(q):\n            continue\n        elif q % 8 != 1 and q % 8 != 7:\n            continue\n        elif pow(2, p, q) == 1:\n            return q\n    return None\n\nif __name__ == '__main__':\n    exponent = int(raw_input(\"Enter exponent of Mersenne number: \"))\n    if not is_prime(exponent):\n        print \"Exponent is not prime: %d\" % exponent\n    else:\n        factor = m_factor(exponent)\n        if not factor:\n            print \"No factor found for M%d\" % exponent\n        else:\n            print \"M%d has a factor: %d\" % (exponent, factor)\n"}
{"id": 132462, "name": "Population count", "source": "Translate Swift to C#: func populationCount(n: Int) -> Int {\n  guard n >= 0 else { fatalError() }\n\n  return String(n, radix: 2).filter({ $0 == \"1\" }).count\n}\n\nlet pows = (0...)\n    .lazy\n    .map({ Int(pow(3, Double($0))) })\n    .map(populationCount)\n    .prefix(30)\n\nlet evils = (0...)\n    .lazy\n    .filter({ populationCount(n: $0) & 1 == 0 })\n    .prefix(30)\n\nlet odious = (0...)\n    .lazy\n    .filter({ populationCount(n: $0) & 1 == 1 })\n    .prefix(30)\n\nprint(\"Powers:\", Array(pows))\nprint(\"Evils:\", Array(evils))\nprint(\"Odious:\", Array(odious))\n", "target": "using System;\nusing System.Linq;\n\nnamespace PopulationCount\n{\n    class Program\n    {\n        private static int PopulationCount(long n)\n        {\n            string binaryn = Convert.ToString(n, 2);\n            return binaryn.ToCharArray().Where(t => t == '1').Count();\n        }\n\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Population Counts:\");\n            Console.Write(\"3^n\u00a0:   \");\n\n            int count = 0;\n\n            while (count < 30)\n            {\n                double n = Math.Pow(3f, (double)count);\n                int popCount = PopulationCount((long)n);\n                Console.Write(string.Format(\"{0} \", popCount));\n                count++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Evil:   \");\n\n            count = 0;\n            int i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 == 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Odious: \");\n\n            count = 0;\n            i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 != 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 132463, "name": "Population count", "source": "Translate Swift to C#: func populationCount(n: Int) -> Int {\n  guard n >= 0 else { fatalError() }\n\n  return String(n, radix: 2).filter({ $0 == \"1\" }).count\n}\n\nlet pows = (0...)\n    .lazy\n    .map({ Int(pow(3, Double($0))) })\n    .map(populationCount)\n    .prefix(30)\n\nlet evils = (0...)\n    .lazy\n    .filter({ populationCount(n: $0) & 1 == 0 })\n    .prefix(30)\n\nlet odious = (0...)\n    .lazy\n    .filter({ populationCount(n: $0) & 1 == 1 })\n    .prefix(30)\n\nprint(\"Powers:\", Array(pows))\nprint(\"Evils:\", Array(evils))\nprint(\"Odious:\", Array(odious))\n", "target": "using System;\nusing System.Linq;\n\nnamespace PopulationCount\n{\n    class Program\n    {\n        private static int PopulationCount(long n)\n        {\n            string binaryn = Convert.ToString(n, 2);\n            return binaryn.ToCharArray().Where(t => t == '1').Count();\n        }\n\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Population Counts:\");\n            Console.Write(\"3^n\u00a0:   \");\n\n            int count = 0;\n\n            while (count < 30)\n            {\n                double n = Math.Pow(3f, (double)count);\n                int popCount = PopulationCount((long)n);\n                Console.Write(string.Format(\"{0} \", popCount));\n                count++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Evil:   \");\n\n            count = 0;\n            int i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 == 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Odious: \");\n\n            count = 0;\n            i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 != 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 132466, "name": "Population count", "source": "Translate Swift to Java: func populationCount(n: Int) -> Int {\n  guard n >= 0 else { fatalError() }\n\n  return String(n, radix: 2).filter({ $0 == \"1\" }).count\n}\n\nlet pows = (0...)\n    .lazy\n    .map({ Int(pow(3, Double($0))) })\n    .map(populationCount)\n    .prefix(30)\n\nlet evils = (0...)\n    .lazy\n    .filter({ populationCount(n: $0) & 1 == 0 })\n    .prefix(30)\n\nlet odious = (0...)\n    .lazy\n    .filter({ populationCount(n: $0) & 1 == 1 })\n    .prefix(30)\n\nprint(\"Powers:\", Array(pows))\nprint(\"Evils:\", Array(evils))\nprint(\"Odious:\", Array(odious))\n", "target": "import java.math.BigInteger;\n\npublic class PopCount {\n    public static void main(String[] args) {\n\t{ \n\t    System.out.print(\"32-bit integer: \");\n\t    int n = 1;\n\t    for (int i = 0; i < 20; i++) {\n\t\tSystem.out.printf(\"%d \", Integer.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"64-bit integer: \");\n\t    long n = 1;\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", Long.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"big integer  \u00a0: \");\n\t    BigInteger n = BigInteger.ONE;\n\t    BigInteger three = BigInteger.valueOf(3);\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", n.bitCount());\n\t\tn = n.multiply(three);\n\t    }\n\t    System.out.println();\n\t}\n\n\tint[] od = new int[30];\n\tint ne = 0, no = 0;\n\tSystem.out.print(\"evil  \u00a0: \");\n\tfor (int n = 0; ne+no < 60; n++) {\n\t    if ((Integer.bitCount(n) & 1) == 0) {\n\t\tif (ne < 30) {\n\t\t    System.out.printf(\"%d \", n);\n\t\t    ne++;\n\t\t}\n\t    } else {\n\t\tif (no < 30) {\n\t\t    od[no++] = n;\n\t\t}\n\t    }\n\t}\n\tSystem.out.println();\n\tSystem.out.print(\"odious\u00a0: \");\n\tfor (int n : od) {\n\t    System.out.printf(\"%d \", n);\n\t}\n\tSystem.out.println();\n    }\n}\n"}
{"id": 132467, "name": "Population count", "source": "Translate Swift to Java: func populationCount(n: Int) -> Int {\n  guard n >= 0 else { fatalError() }\n\n  return String(n, radix: 2).filter({ $0 == \"1\" }).count\n}\n\nlet pows = (0...)\n    .lazy\n    .map({ Int(pow(3, Double($0))) })\n    .map(populationCount)\n    .prefix(30)\n\nlet evils = (0...)\n    .lazy\n    .filter({ populationCount(n: $0) & 1 == 0 })\n    .prefix(30)\n\nlet odious = (0...)\n    .lazy\n    .filter({ populationCount(n: $0) & 1 == 1 })\n    .prefix(30)\n\nprint(\"Powers:\", Array(pows))\nprint(\"Evils:\", Array(evils))\nprint(\"Odious:\", Array(odious))\n", "target": "import java.math.BigInteger;\n\npublic class PopCount {\n    public static void main(String[] args) {\n\t{ \n\t    System.out.print(\"32-bit integer: \");\n\t    int n = 1;\n\t    for (int i = 0; i < 20; i++) {\n\t\tSystem.out.printf(\"%d \", Integer.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"64-bit integer: \");\n\t    long n = 1;\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", Long.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"big integer  \u00a0: \");\n\t    BigInteger n = BigInteger.ONE;\n\t    BigInteger three = BigInteger.valueOf(3);\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", n.bitCount());\n\t\tn = n.multiply(three);\n\t    }\n\t    System.out.println();\n\t}\n\n\tint[] od = new int[30];\n\tint ne = 0, no = 0;\n\tSystem.out.print(\"evil  \u00a0: \");\n\tfor (int n = 0; ne+no < 60; n++) {\n\t    if ((Integer.bitCount(n) & 1) == 0) {\n\t\tif (ne < 30) {\n\t\t    System.out.printf(\"%d \", n);\n\t\t    ne++;\n\t\t}\n\t    } else {\n\t\tif (no < 30) {\n\t\t    od[no++] = n;\n\t\t}\n\t    }\n\t}\n\tSystem.out.println();\n\tSystem.out.print(\"odious\u00a0: \");\n\tfor (int n : od) {\n\t    System.out.printf(\"%d \", n);\n\t}\n\tSystem.out.println();\n    }\n}\n"}
{"id": 132468, "name": "Population count", "source": "Translate Swift to Python: func populationCount(n: Int) -> Int {\n  guard n >= 0 else { fatalError() }\n\n  return String(n, radix: 2).filter({ $0 == \"1\" }).count\n}\n\nlet pows = (0...)\n    .lazy\n    .map({ Int(pow(3, Double($0))) })\n    .map(populationCount)\n    .prefix(30)\n\nlet evils = (0...)\n    .lazy\n    .filter({ populationCount(n: $0) & 1 == 0 })\n    .prefix(30)\n\nlet odious = (0...)\n    .lazy\n    .filter({ populationCount(n: $0) & 1 == 1 })\n    .prefix(30)\n\nprint(\"Powers:\", Array(pows))\nprint(\"Evils:\", Array(evils))\nprint(\"Odious:\", Array(odious))\n", "target": ">>> def popcount(n): return bin(n).count(\"1\")\n... \n>>> [popcount(3**i) for i in range(30)]\n[1, 2, 2, 4, 3, 6, 6, 5, 6, 8, 9, 13, 10, 11, 14, 15, 11, 14, 14, 17, 17, 20, 19, 22, 16, 18, 24, 30, 25, 25]\n>>> evil, odious, i = [], [], 0\n>>> while len(evil) < 30 or len(odious) < 30:\n...     p = popcount(i)\n...     if p % 2: odious.append(i)\n...     else: evil.append(i)\n...     i += 1\n... \n>>> evil[:30]\n[0, 3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45, 46, 48, 51, 53, 54, 57, 58]\n>>> odious[:30]\n[1, 2, 4, 7, 8, 11, 13, 14, 16, 19, 21, 22, 25, 26, 28, 31, 32, 35, 37, 38, 41, 42, 44, 47, 49, 50, 52, 55, 56, 59]\n>>>\n"}
{"id": 132469, "name": "Population count", "source": "Translate Swift to Python: func populationCount(n: Int) -> Int {\n  guard n >= 0 else { fatalError() }\n\n  return String(n, radix: 2).filter({ $0 == \"1\" }).count\n}\n\nlet pows = (0...)\n    .lazy\n    .map({ Int(pow(3, Double($0))) })\n    .map(populationCount)\n    .prefix(30)\n\nlet evils = (0...)\n    .lazy\n    .filter({ populationCount(n: $0) & 1 == 0 })\n    .prefix(30)\n\nlet odious = (0...)\n    .lazy\n    .filter({ populationCount(n: $0) & 1 == 1 })\n    .prefix(30)\n\nprint(\"Powers:\", Array(pows))\nprint(\"Evils:\", Array(evils))\nprint(\"Odious:\", Array(odious))\n", "target": ">>> def popcount(n): return bin(n).count(\"1\")\n... \n>>> [popcount(3**i) for i in range(30)]\n[1, 2, 2, 4, 3, 6, 6, 5, 6, 8, 9, 13, 10, 11, 14, 15, 11, 14, 14, 17, 17, 20, 19, 22, 16, 18, 24, 30, 25, 25]\n>>> evil, odious, i = [], [], 0\n>>> while len(evil) < 30 or len(odious) < 30:\n...     p = popcount(i)\n...     if p % 2: odious.append(i)\n...     else: evil.append(i)\n...     i += 1\n... \n>>> evil[:30]\n[0, 3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45, 46, 48, 51, 53, 54, 57, 58]\n>>> odious[:30]\n[1, 2, 4, 7, 8, 11, 13, 14, 16, 19, 21, 22, 25, 26, 28, 31, 32, 35, 37, 38, 41, 42, 44, 47, 49, 50, 52, 55, 56, 59]\n>>>\n"}
{"id": 132921, "name": "Langton's ant", "source": "Translate Swift to C#: import Foundation\n\nlet WIDTH = 100\nlet HEIGHT = 100\n\nstruct Point {\n    var x:Int\n    var y:Int\n}\n\nenum Direction: Int {\n    case North = 0, East, West, South\n}\n\nclass Langton {\n    let leftTurn = [Direction.West, Direction.North, Direction.South, Direction.East]\n    let rightTurn = [Direction.East, Direction.South, Direction.North, Direction.West]\n    let xInc = [0, 1,-1, 0]\n    let yInc = [-1, 0, 0, 1]\n    var isBlack:[[Bool]]\n    var origin:Point\n    var antPosition = Point(x:0, y:0)\n    var outOfBounds = false\n    var antDirection = Direction.East\n    \n    init(width:Int, height:Int) {\n        self.origin = Point(x:width / 2, y:height / 2)\n        self.isBlack = Array(count: width, repeatedValue: Array(count: height, repeatedValue: false))\n    }\n    \n    func moveAnt() {\n        self.antPosition.x += xInc[self.antDirection.rawValue]\n        self.antPosition.y += yInc[self.antDirection.rawValue]\n    }\n    \n    func step() -> Point {\n        if self.outOfBounds {\n            println(\"Ant tried to move while out of bounds.\")\n            exit(0)\n        }\n        \n        var ptCur = Point(x:self.antPosition.x + self.origin.x, y:self.antPosition.y + self.origin.y)\n        let black = self.isBlack[ptCur.x][ptCur.y]\n        let direction = self.antDirection.rawValue\n        \n        self.antDirection = (black ? self.leftTurn : self.rightTurn)[direction]\n\n        self.isBlack[ptCur.x][ptCur.y] = !self.isBlack[ptCur.x][ptCur.y]\n        \n        self.moveAnt()\n        ptCur = Point(x:self.antPosition.x + self.origin.x, y:self.antPosition.y + self.origin.y)\n        self.outOfBounds =\n            ptCur.x < 0 ||\n            ptCur.x >= self.isBlack.count ||\n            ptCur.y < 0 ||\n            ptCur.y >= self.isBlack[0].count\n        \n        return self.antPosition\n    }\n}\n\n\nlet ant = Langton(width: WIDTH, height: HEIGHT)\nwhile !ant.outOfBounds {\n    ant.step()\n}\n\nfor row in 0 ..< WIDTH {\n    for col in 0 ..< HEIGHT {\n        print(ant.isBlack[col][row] ? \"#\" : \" \")\n    }\n    println()\n}\n", "target": "using System;\n\nnamespace LangtonAnt\n{\n    public struct Point\n    {\n        public int X;\n        public int Y;\n\n        public Point(int x, int y)\n        {\n            X = x;\n            Y = y;\n        }\n    }\n\n    enum Direction\n    {\n        North, East, West, South\n    }\n\n    public class Langton\n    {\n        public readonly bool [,] IsBlack;\n        private Point _origin;\n        private Point _antPosition = new Point(0, 0);\n        public bool OutOfBounds { get; set;}\n\n        \n        private Direction _antDirection = Direction.East;\n\n        private readonly Direction[] _leftTurn = new[] { Direction.West, Direction.North, Direction.South, Direction.East };\n        private readonly Direction[] _rightTurn = new[] { Direction.East, Direction.South, Direction.North, Direction.West };\n        private readonly int[] _xInc = new[] { 0, 1,-1, 0};\n        private readonly int[] _yInc = new[] {-1, 0, 0, 1};\n\n        public Langton(int width, int height, Point origin)\n        {\n            _origin = origin;\n            IsBlack = new bool[width, height];\n            OutOfBounds = false;\n        }\n\n        public Langton(int width, int height) : this(width, height, new Point(width / 2, height / 2)) {}\n\n        private void MoveAnt()\n        {\n            _antPosition.X += _xInc[(int)_antDirection];\n            _antPosition.Y += _yInc[(int)_antDirection];\n        }\n\n        public Point Step()\n        {\n            if (OutOfBounds)\n            {\n                throw new InvalidOperationException(\"Trying to step after ant is out of bounds\");\n            }\n            Point ptCur = new Point(_antPosition.X + _origin.X, _antPosition.Y + _origin.Y);\n            bool leftTurn = IsBlack[ptCur.X, ptCur.Y];\n            int iDirection = (int) _antDirection;\n            _antDirection = leftTurn ? _leftTurn[iDirection] : _rightTurn[iDirection];\n            IsBlack[ptCur.X, ptCur.Y] = !IsBlack[ptCur.X, ptCur.Y];\n            MoveAnt();\n            ptCur = new Point(_antPosition.X + _origin.X, _antPosition.Y + _origin.Y);\n            OutOfBounds = \n                ptCur.X < 0 ||\n                ptCur.X >= IsBlack.GetUpperBound(0) ||\n                ptCur.Y < 0 ||\n                ptCur.Y >= IsBlack.GetUpperBound(1);\n            return _antPosition;\n        }\n    }\n    class Program\n    {\n        static void Main()\n        {\n            Langton ant = new Langton(100, 100);\n\n            while (!ant.OutOfBounds) ant.Step();\n\n            for (int iRow = 0; iRow < 100; iRow++)\n            {\n                for (int iCol = 0; iCol < 100; iCol++)\n                {\n                    Console.Write(ant.IsBlack[iCol, iRow] ? \"#\" : \" \");\n                }\n                Console.WriteLine();\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 132923, "name": "Langton's ant", "source": "Translate Swift to Java: import Foundation\n\nlet WIDTH = 100\nlet HEIGHT = 100\n\nstruct Point {\n    var x:Int\n    var y:Int\n}\n\nenum Direction: Int {\n    case North = 0, East, West, South\n}\n\nclass Langton {\n    let leftTurn = [Direction.West, Direction.North, Direction.South, Direction.East]\n    let rightTurn = [Direction.East, Direction.South, Direction.North, Direction.West]\n    let xInc = [0, 1,-1, 0]\n    let yInc = [-1, 0, 0, 1]\n    var isBlack:[[Bool]]\n    var origin:Point\n    var antPosition = Point(x:0, y:0)\n    var outOfBounds = false\n    var antDirection = Direction.East\n    \n    init(width:Int, height:Int) {\n        self.origin = Point(x:width / 2, y:height / 2)\n        self.isBlack = Array(count: width, repeatedValue: Array(count: height, repeatedValue: false))\n    }\n    \n    func moveAnt() {\n        self.antPosition.x += xInc[self.antDirection.rawValue]\n        self.antPosition.y += yInc[self.antDirection.rawValue]\n    }\n    \n    func step() -> Point {\n        if self.outOfBounds {\n            println(\"Ant tried to move while out of bounds.\")\n            exit(0)\n        }\n        \n        var ptCur = Point(x:self.antPosition.x + self.origin.x, y:self.antPosition.y + self.origin.y)\n        let black = self.isBlack[ptCur.x][ptCur.y]\n        let direction = self.antDirection.rawValue\n        \n        self.antDirection = (black ? self.leftTurn : self.rightTurn)[direction]\n\n        self.isBlack[ptCur.x][ptCur.y] = !self.isBlack[ptCur.x][ptCur.y]\n        \n        self.moveAnt()\n        ptCur = Point(x:self.antPosition.x + self.origin.x, y:self.antPosition.y + self.origin.y)\n        self.outOfBounds =\n            ptCur.x < 0 ||\n            ptCur.x >= self.isBlack.count ||\n            ptCur.y < 0 ||\n            ptCur.y >= self.isBlack[0].count\n        \n        return self.antPosition\n    }\n}\n\n\nlet ant = Langton(width: WIDTH, height: HEIGHT)\nwhile !ant.outOfBounds {\n    ant.step()\n}\n\nfor row in 0 ..< WIDTH {\n    for col in 0 ..< HEIGHT {\n        print(ant.isBlack[col][row] ? \"#\" : \" \")\n    }\n    println()\n}\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\npublic class Langton extends JFrame{\n\tprivate JPanel planePanel;\n\tprivate static final int ZOOM = 4;\n\t\n\tpublic Langton(final boolean[][] plane){\n\t\tplanePanel = new JPanel(){\n\t\t\t@Override\n\t\t\tpublic void paint(Graphics g) {\n\t\t\t\tfor(int y = 0; y < plane.length;y++){\n\t\t\t\t\tfor(int x = 0; x < plane[0].length;x++){\n\t\t\t\t\t\tg.setColor(plane[y][x] ? Color.BLACK : Color.WHITE);\n\t\t\t\t\t\tg.fillRect(x * ZOOM, y * ZOOM, ZOOM, ZOOM);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tg.setColor(Color.GREEN);\n\t\t\t\tg.fillRect(plane[0].length / 2 * ZOOM,\n\t\t\t\t           plane.length / 2 * ZOOM, ZOOM/2, ZOOM/2);\n\t\t\t}\n\t\t};\n\t\tplanePanel.setSize(plane[0].length - 1, plane.length - 1);\n\t\tadd(planePanel);\n\t\tsetSize(ZOOM * plane[0].length, ZOOM * plane.length + 30);\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetVisible(true);\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tnew Langton(runAnt(100, 100));\n\t}\n\n\tprivate static boolean[][] runAnt(int height, int width){\n\t\tboolean[][] plane = new boolean[height][width];\n\t\tint antX = width/2, antY = height/2;\n\t\tint xChange = 0, yChange = -1; \n\t\twhile(antX < width && antY < height && antX >= 0 && antY >= 0){\n\t\t\tif(plane[antY][antX]){\n\t\t\t\t\n\t\t\t\tif(xChange == 0){ \n\t\t\t\t\txChange = yChange;\n\t\t\t\t\tyChange = 0;\n\t\t\t\t}else{ \n\t\t\t\t\tyChange = -xChange;\n\t\t\t\t\txChange = 0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\n\t\t\t\tif(xChange == 0){ \n\t\t\t\t\txChange = -yChange;\n\t\t\t\t\tyChange = 0;\n\t\t\t\t}else{ \n\t\t\t\t\tyChange = xChange;\n\t\t\t\t\txChange = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tplane[antY][antX] = !plane[antY][antX];\n\t\t\tantX += xChange;\n\t\t\tantY += yChange;\n\t\t}\n\t\treturn plane;\n\t}\n}\n"}
{"id": 132924, "name": "Langton's ant", "source": "Translate Swift to Python: import Foundation\n\nlet WIDTH = 100\nlet HEIGHT = 100\n\nstruct Point {\n    var x:Int\n    var y:Int\n}\n\nenum Direction: Int {\n    case North = 0, East, West, South\n}\n\nclass Langton {\n    let leftTurn = [Direction.West, Direction.North, Direction.South, Direction.East]\n    let rightTurn = [Direction.East, Direction.South, Direction.North, Direction.West]\n    let xInc = [0, 1,-1, 0]\n    let yInc = [-1, 0, 0, 1]\n    var isBlack:[[Bool]]\n    var origin:Point\n    var antPosition = Point(x:0, y:0)\n    var outOfBounds = false\n    var antDirection = Direction.East\n    \n    init(width:Int, height:Int) {\n        self.origin = Point(x:width / 2, y:height / 2)\n        self.isBlack = Array(count: width, repeatedValue: Array(count: height, repeatedValue: false))\n    }\n    \n    func moveAnt() {\n        self.antPosition.x += xInc[self.antDirection.rawValue]\n        self.antPosition.y += yInc[self.antDirection.rawValue]\n    }\n    \n    func step() -> Point {\n        if self.outOfBounds {\n            println(\"Ant tried to move while out of bounds.\")\n            exit(0)\n        }\n        \n        var ptCur = Point(x:self.antPosition.x + self.origin.x, y:self.antPosition.y + self.origin.y)\n        let black = self.isBlack[ptCur.x][ptCur.y]\n        let direction = self.antDirection.rawValue\n        \n        self.antDirection = (black ? self.leftTurn : self.rightTurn)[direction]\n\n        self.isBlack[ptCur.x][ptCur.y] = !self.isBlack[ptCur.x][ptCur.y]\n        \n        self.moveAnt()\n        ptCur = Point(x:self.antPosition.x + self.origin.x, y:self.antPosition.y + self.origin.y)\n        self.outOfBounds =\n            ptCur.x < 0 ||\n            ptCur.x >= self.isBlack.count ||\n            ptCur.y < 0 ||\n            ptCur.y >= self.isBlack[0].count\n        \n        return self.antPosition\n    }\n}\n\n\nlet ant = Langton(width: WIDTH, height: HEIGHT)\nwhile !ant.outOfBounds {\n    ant.step()\n}\n\nfor row in 0 ..< WIDTH {\n    for col in 0 ..< HEIGHT {\n        print(ant.isBlack[col][row] ? \"#\" : \" \")\n    }\n    println()\n}\n", "target": "\n\n\n\n\n\nSTEP = 100\ncount = 0\n\ndef setup():\n    global x, y, direction\n\n    \n    \n    size(100, 100, P2D)\n\n    background(255)\n    x = width / 2\n    y = height / 2\n    direction = 0\n\ndef draw():\n    global count\n    for i in range(STEP):\n        count += 1\n        pix = get(x, y) != -1 \n        setBool(x, y, pix)\n\n        turn(pix)\n        move()\n\n        if (x < 0 or y < 0 or x >= width or y >= height):\n            println(\"finished\")\n            noLoop()\n            break\n\n    if count % 1000 == 0:\n        println(\"iteration {}\".format(count))\n\ndef move():\n    global x, y\n    if direction == 0:\n        y -= 1\n    elif direction == 1:\n        x -= 1\n    elif direction == 2:\n        y += 1\n    elif direction == 3:\n        x += 1\n\ndef turn(rightleft):\n    global direction\n    direction += 1 if rightleft else -1\n    if direction == -1:\n        direction = 3\n    if direction == 4:\n        direction = 0\n\ndef setBool(x, y, white):\n    set(x, y, -1 if white else 0)\n"}
{"id": 133099, "name": "Bernoulli numbers", "source": "Translate Swift to C#: import BigInt\n\npublic func bernoulli<T: BinaryInteger & SignedNumeric>(n: Int) -> Frac<T> {\n  guard n != 0 else {\n    return 1\n  }\n\n  var arr = [Frac<T>]()\n\n  for m in 0...n {\n    arr.append(Frac(numerator: 1, denominator: T(m) + 1))\n\n    for j in stride(from: m, through: 1, by: -1) {\n      arr[j-1] = (arr[j-1] - arr[j]) * Frac(numerator: T(j), denominator: 1)\n    }\n  }\n\n  return arr[0]\n}\n\nfor n in 0...60 {\n  let b = bernoulli(n: n) as Frac<BigInt>\n\n  guard b != 0 else {\n    continue\n  }\n\n  print(\"B(\\(n)) = \\(b)\")\n}\n", "target": "using Mpir.NET;\nusing System;\n\nnamespace Bernoulli\n{\n    class Program\n    {\n        private static void bernoulli(mpq_t rop, uint n)\n        {\n            mpq_t[] a = new mpq_t[n + 1];\n\n            for (uint i = 0; i < n + 1; i++)\n            {\n                a[i] = new mpq_t();\n            }\n\n            for (uint m = 0; m <= n; ++m)\n            {\n                mpir.mpq_set_ui(a[m], 1, m + 1);\n\n                for (uint j = m; j > 0; --j)\n                {\n                    mpir.mpq_sub(a[j - 1], a[j], a[j - 1]);\n                    mpir.mpq_set_ui(rop, j, 1);\n                    mpir.mpq_mul(a[j - 1], a[j - 1], rop);\n                }\n\n                mpir.mpq_set(rop, a[0]);\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            mpq_t rop = new mpq_t();\n            mpz_t n = new mpz_t();\n            mpz_t d = new mpz_t();\n\n            for (uint  i = 0; i <= 60; ++i) \n            {\n                bernoulli(rop, i);\n\n                if (mpir.mpq_cmp_ui(rop, 0, 1) != 0) \n                {\n                    mpir.mpq_get_num(n, rop);\n                    mpir.mpq_get_den(d, rop);\n                    Console.WriteLine(string.Format(\"B({0, 2}) = {1, 44} / {2}\", i, n, d));\n                }\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 133101, "name": "Bernoulli numbers", "source": "Translate Swift to Java: import BigInt\n\npublic func bernoulli<T: BinaryInteger & SignedNumeric>(n: Int) -> Frac<T> {\n  guard n != 0 else {\n    return 1\n  }\n\n  var arr = [Frac<T>]()\n\n  for m in 0...n {\n    arr.append(Frac(numerator: 1, denominator: T(m) + 1))\n\n    for j in stride(from: m, through: 1, by: -1) {\n      arr[j-1] = (arr[j-1] - arr[j]) * Frac(numerator: T(j), denominator: 1)\n    }\n  }\n\n  return arr[0]\n}\n\nfor n in 0...60 {\n  let b = bernoulli(n: n) as Frac<BigInt>\n\n  guard b != 0 else {\n    continue\n  }\n\n  print(\"B(\\(n)) = \\(b)\")\n}\n", "target": "import org.apache.commons.math3.fraction.BigFraction;\n\npublic class BernoulliNumbers {\n\n    public static void main(String[] args) {\n        for (int n = 0; n <= 60; n++) {\n            BigFraction b = bernouilli(n);\n            if (!b.equals(BigFraction.ZERO))\n                System.out.printf(\"B(%-2d) =\u00a0%-1s%n\", n , b);\n        }\n    }\n\n    static BigFraction bernouilli(int n) {\n        BigFraction[] A = new BigFraction[n + 1];\n        for (int m = 0; m <= n; m++) {\n            A[m] = new BigFraction(1, (m + 1));\n            for (int j = m; j >= 1; j--)\n                A[j - 1] = (A[j - 1].subtract(A[j])).multiply(new BigFraction(j));\n        }\n        return A[0];\n    }\n}\n"}
{"id": 133102, "name": "Bernoulli numbers", "source": "Translate Swift to Python: import BigInt\n\npublic func bernoulli<T: BinaryInteger & SignedNumeric>(n: Int) -> Frac<T> {\n  guard n != 0 else {\n    return 1\n  }\n\n  var arr = [Frac<T>]()\n\n  for m in 0...n {\n    arr.append(Frac(numerator: 1, denominator: T(m) + 1))\n\n    for j in stride(from: m, through: 1, by: -1) {\n      arr[j-1] = (arr[j-1] - arr[j]) * Frac(numerator: T(j), denominator: 1)\n    }\n  }\n\n  return arr[0]\n}\n\nfor n in 0...60 {\n  let b = bernoulli(n: n) as Frac<BigInt>\n\n  guard b != 0 else {\n    continue\n  }\n\n  print(\"B(\\(n)) = \\(b)\")\n}\n", "target": "from fractions import Fraction as Fr\n\ndef bernoulli(n):\n    A = [0] * (n+1)\n    for m in range(n+1):\n        A[m] = Fr(1, m+1)\n        for j in range(m, 0, -1):\n          A[j-1] = j*(A[j-1] - A[j])\n    return A[0] \n\nbn = [(i, bernoulli(i)) for i in range(61)]\nbn = [(i, b) for i,b in bn if b]\nwidth = max(len(str(b.numerator)) for i,b in bn)\nfor i,b in bn:\n    print('B(%2i) = %*i/%i' % (i, width, b.numerator, b.denominator))\n"}
{"id": 133551, "name": "Pangram checker", "source": "Translate Swift to C#: import Foundation\n\nlet str = \"the quick brown fox jumps over the lazy dog\"\n\nfunc isPangram(str:String) -> Bool {\n    let stringArray = Array(str.lowercaseString)\n    for char in \"abcdefghijklmnopqrstuvwxyz\" {\n        if (find(stringArray, char) == nil) {\n            return false\n        }\n    }\n    return true\n}\n\nisPangram(str) \nisPangram(\"Test string\") \n", "target": "using System;\nusing System.Linq;\n\nstatic class Program\n{\n    static bool IsPangram(this string text, string alphabet = \"abcdefghijklmnopqrstuvwxyz\")\n    {\n        return alphabet.All(text.ToLower().Contains);\n    }\n\n    static void Main(string[] arguments)\n    {\n        Console.WriteLine(arguments.Any() && arguments.First().IsPangram());\n    }\n}\n"}
{"id": 133552, "name": "Pangram checker", "source": "Translate Swift to C#: import Foundation\n\nlet str = \"the quick brown fox jumps over the lazy dog\"\n\nfunc isPangram(str:String) -> Bool {\n    let stringArray = Array(str.lowercaseString)\n    for char in \"abcdefghijklmnopqrstuvwxyz\" {\n        if (find(stringArray, char) == nil) {\n            return false\n        }\n    }\n    return true\n}\n\nisPangram(str) \nisPangram(\"Test string\") \n", "target": "using System;\nusing System.Linq;\n\nstatic class Program\n{\n    static bool IsPangram(this string text, string alphabet = \"abcdefghijklmnopqrstuvwxyz\")\n    {\n        return alphabet.All(text.ToLower().Contains);\n    }\n\n    static void Main(string[] arguments)\n    {\n        Console.WriteLine(arguments.Any() && arguments.First().IsPangram());\n    }\n}\n"}
{"id": 133555, "name": "Pangram checker", "source": "Translate Swift to Java: import Foundation\n\nlet str = \"the quick brown fox jumps over the lazy dog\"\n\nfunc isPangram(str:String) -> Bool {\n    let stringArray = Array(str.lowercaseString)\n    for char in \"abcdefghijklmnopqrstuvwxyz\" {\n        if (find(stringArray, char) == nil) {\n            return false\n        }\n    }\n    return true\n}\n\nisPangram(str) \nisPangram(\"Test string\") \n", "target": "public class Pangram {\n    public static boolean isPangram(String test){\n        for (char a = 'A'; a <= 'Z'; a++)\n            if ((test.indexOf(a) < 0) && (test.indexOf((char)(a + 32)) < 0))\n                return false;\n        return true;\n    }\n\n    public static void main(String[] args){\n        System.out.println(isPangram(\"the quick brown fox jumps over the lazy dog\"));\n        System.out.println(isPangram(\"the quick brown fox jumped over the lazy dog\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKLMNOPQSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKL.NOPQRSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABC.D.E.FGHI*J/KL-M+NO*PQ R\\nSTUVWXYZ\"));\n        System.out.println(isPangram(\"\"));\n    }\n}\n"}
{"id": 133556, "name": "Pangram checker", "source": "Translate Swift to Java: import Foundation\n\nlet str = \"the quick brown fox jumps over the lazy dog\"\n\nfunc isPangram(str:String) -> Bool {\n    let stringArray = Array(str.lowercaseString)\n    for char in \"abcdefghijklmnopqrstuvwxyz\" {\n        if (find(stringArray, char) == nil) {\n            return false\n        }\n    }\n    return true\n}\n\nisPangram(str) \nisPangram(\"Test string\") \n", "target": "public class Pangram {\n    public static boolean isPangram(String test){\n        for (char a = 'A'; a <= 'Z'; a++)\n            if ((test.indexOf(a) < 0) && (test.indexOf((char)(a + 32)) < 0))\n                return false;\n        return true;\n    }\n\n    public static void main(String[] args){\n        System.out.println(isPangram(\"the quick brown fox jumps over the lazy dog\"));\n        System.out.println(isPangram(\"the quick brown fox jumped over the lazy dog\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKLMNOPQSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKL.NOPQRSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABC.D.E.FGHI*J/KL-M+NO*PQ R\\nSTUVWXYZ\"));\n        System.out.println(isPangram(\"\"));\n    }\n}\n"}
{"id": 133557, "name": "Pangram checker", "source": "Translate Swift to Python: import Foundation\n\nlet str = \"the quick brown fox jumps over the lazy dog\"\n\nfunc isPangram(str:String) -> Bool {\n    let stringArray = Array(str.lowercaseString)\n    for char in \"abcdefghijklmnopqrstuvwxyz\" {\n        if (find(stringArray, char) == nil) {\n            return false\n        }\n    }\n    return true\n}\n\nisPangram(str) \nisPangram(\"Test string\") \n", "target": "import string, sys\nif sys.version_info[0] < 3:\n    input = raw_input\n\ndef ispangram(sentence, alphabet=string.ascii_lowercase):\n    alphaset = set(alphabet)\n    return alphaset <= set(sentence.lower())\n\nprint ( ispangram(input('Sentence: ')) )\n"}
{"id": 133558, "name": "Pangram checker", "source": "Translate Swift to Python: import Foundation\n\nlet str = \"the quick brown fox jumps over the lazy dog\"\n\nfunc isPangram(str:String) -> Bool {\n    let stringArray = Array(str.lowercaseString)\n    for char in \"abcdefghijklmnopqrstuvwxyz\" {\n        if (find(stringArray, char) == nil) {\n            return false\n        }\n    }\n    return true\n}\n\nisPangram(str) \nisPangram(\"Test string\") \n", "target": "import string, sys\nif sys.version_info[0] < 3:\n    input = raw_input\n\ndef ispangram(sentence, alphabet=string.ascii_lowercase):\n    alphaset = set(alphabet)\n    return alphaset <= set(sentence.lower())\n\nprint ( ispangram(input('Sentence: ')) )\n"}
{"id": 133860, "name": "Find common directory path", "source": "Translate Swift to C#: import Foundation\n\n\nfunc getPrefix(_ text:[String]) -> String? {\n    var common:String = text[0]\n    for i in text {\n        common = i.commonPrefix(with: common)\n    }\n    return common\n}\n\nvar test = [\"/home/user1/tmp/coverage/test\", \n \"/home/user1/tmp/covert/operator\",\n \"/home/user1/tmp/coven/members\"]\n\nvar output:String = getPrefix(test)!\nprint(output)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCodeTasks\n{\n\n\tclass Program\n\t{\n\t\tstatic void Main ( string[ ] args )\n\t\t{\n\t\t\tFindCommonDirectoryPath.Test ( );\n\t\t}\n\n\t}\n\n\tclass FindCommonDirectoryPath\n\t{\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Find Common Directory Path\" );\n\t\t\tConsole.WriteLine ( );\n\t\t\tList<string> PathSet1 = new List<string> ( );\n\t\t\tPathSet1.Add ( \"/home/user1/tmp/coverage/test\" );\n\t\t\tPathSet1.Add ( \"/home/user1/tmp/covert/operator\" );\n\t\t\tPathSet1.Add ( \"/home/user1/tmp/coven/members\" );\n\t\t\tConsole.WriteLine(\"Path Set 1 (All Absolute Paths):\");\n\t\t\tforeach ( string path in PathSet1 )\n\t\t\t{\n\t\t\t\tConsole.WriteLine ( path );\n\t\t\t}\n\t\t\tConsole.WriteLine ( \"Path Set 1 Common Path: {0}\", FindCommonPath ( \"/\", PathSet1 ) );\n\t\t}\n\t\tpublic static string FindCommonPath ( string Separator, List<string> Paths )\n\t\t{\n\t\t\tstring CommonPath = String.Empty;\n\t\t\tList<string> SeparatedPath = Paths\n\t\t\t\t.First ( str => str.Length == Paths.Max ( st2 => st2.Length ) )\n\t\t\t\t.Split ( new string[ ] { Separator }, StringSplitOptions.RemoveEmptyEntries )\n\t\t\t\t.ToList ( );\n\n\t\t\tforeach ( string PathSegment in SeparatedPath.AsEnumerable ( ) )\n\t\t\t{\n\t\t\t\tif ( CommonPath.Length == 0 && Paths.All ( str => str.StartsWith ( PathSegment ) ) )\n\t\t\t\t{\n\t\t\t\t\tCommonPath = PathSegment;\n\t\t\t\t}\n\t\t\t\telse if ( Paths.All ( str => str.StartsWith ( CommonPath + Separator + PathSegment ) ) )\n\t\t\t\t{\n\t\t\t\t\tCommonPath += Separator + PathSegment;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn CommonPath;\n\t\t}\n\t}\n}\n"}
{"id": 133862, "name": "Find common directory path", "source": "Translate Swift to Java: import Foundation\n\n\nfunc getPrefix(_ text:[String]) -> String? {\n    var common:String = text[0]\n    for i in text {\n        common = i.commonPrefix(with: common)\n    }\n    return common\n}\n\nvar test = [\"/home/user1/tmp/coverage/test\", \n \"/home/user1/tmp/covert/operator\",\n \"/home/user1/tmp/coven/members\"]\n\nvar output:String = getPrefix(test)!\nprint(output)\n", "target": "public class CommonPath {\n\tpublic static String commonPath(String... paths){\n\t\tString commonPath = \"\";\n\t\tString[][] folders = new String[paths.length][];\n\t\tfor(int i = 0; i < paths.length; i++){\n\t\t\tfolders[i] = paths[i].split(\"/\"); \n\t\t}\n\t\tfor(int j = 0; j < folders[0].length; j++){\n\t\t\tString thisFolder = folders[0][j]; \n\t\t\tboolean allMatched = true; \n\t\t\tfor(int i = 1; i < folders.length && allMatched; i++){ \n\t\t\t\tif(folders[i].length < j){ \n\t\t\t\t\tallMatched = false; \n\t\t\t\t\tbreak; \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tallMatched &= folders[i][j].equals(thisFolder); \n\t\t\t}\n\t\t\tif(allMatched){ \n\t\t\t\tcommonPath += thisFolder + \"/\"; \n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn commonPath;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tString[] paths = { \"/home/user1/tmp/coverage/test\",\n\t\t\t\t \"/home/user1/tmp/covert/operator\",\n\t\t\t\t \"/home/user1/tmp/coven/members\"};\n\t\tSystem.out.println(commonPath(paths));\n\t\t\n\t\tString[] paths2 = { \"/hame/user1/tmp/coverage/test\",\n\t\t\t\t \"/home/user1/tmp/covert/operator\",\n\t\t\t\t \"/home/user1/tmp/coven/members\"};\n\t\tSystem.out.println(commonPath(paths2));\n\t}\n}\n"}
{"id": 133863, "name": "Find common directory path", "source": "Translate Swift to Python: import Foundation\n\n\nfunc getPrefix(_ text:[String]) -> String? {\n    var common:String = text[0]\n    for i in text {\n        common = i.commonPrefix(with: common)\n    }\n    return common\n}\n\nvar test = [\"/home/user1/tmp/coverage/test\", \n \"/home/user1/tmp/covert/operator\",\n \"/home/user1/tmp/coven/members\"]\n\nvar output:String = getPrefix(test)!\nprint(output)\n", "target": ">>> import os\n>>> os.path.commonpath(['/home/user1/tmp/coverage/test', \n                        '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])\n'/home/user1/tmp'\n"}
{"id": 134015, "name": "Delegates", "source": "Translate Swift to C#: import Foundation\n\nprotocol Thingable { \n  func thing() -> String\n}\n\nclass Delegator {\n  weak var delegate: AnyObject?\n  func operation() -> String {\n    if let f = self.delegate?.thing {\n      return f()\n    } else {\n      return \"default implementation\"\n    }\n  }\n}\n\nclass Delegate {\n  dynamic func thing() -> String { return \"delegate implementation\" }\n}\n\n\nlet a = Delegator()\nprintln(a.operation())    \n\n\na.delegate = \"A delegate may be any object\"\nprintln(a.operation())    \n\n\nlet d = Delegate()\na.delegate = d\nprintln(a.operation())    \n", "target": "using System;\n\ninterface IOperable\n{\n    string Operate();\n}\n\nclass Inoperable\n{\n}\n\nclass Operable : IOperable\n{\n    public string Operate()\n    {\n        return \"Delegate implementation.\";\n    }\n}\n\nclass Delegator : IOperable\n{\n    object Delegate;\n\n    public string Operate()\n    {\n        var operable = Delegate as IOperable;\n        return operable != null ? operable.Operate() : \"Default implementation.\";\n    }\n\n    static void Main()\n    {\n        var delegator = new Delegator();\n        foreach (var @delegate in new object[] { null, new Inoperable(), new Operable() })\n        {\n            delegator.Delegate = @delegate;\n            Console.WriteLine(delegator.Operate());\n        }\n    }\n}\n"}
{"id": 134017, "name": "Delegates", "source": "Translate Swift to Java: import Foundation\n\nprotocol Thingable { \n  func thing() -> String\n}\n\nclass Delegator {\n  weak var delegate: AnyObject?\n  func operation() -> String {\n    if let f = self.delegate?.thing {\n      return f()\n    } else {\n      return \"default implementation\"\n    }\n  }\n}\n\nclass Delegate {\n  dynamic func thing() -> String { return \"delegate implementation\" }\n}\n\n\nlet a = Delegator()\nprintln(a.operation())    \n\n\na.delegate = \"A delegate may be any object\"\nprintln(a.operation())    \n\n\nlet d = Delegate()\na.delegate = d\nprintln(a.operation())    \n", "target": "interface Thingable {\n    String thing();\n}\n\nclass Delegator {\n    public Thingable delegate;\n\n    public String operation() {\n        if (delegate == null)\n            return \"default implementation\";\n        else\n            return delegate.thing();\n    }\n}\n\nclass Delegate implements Thingable {\n    public String thing() {\n        return \"delegate implementation\";\n    }\n}\n\n\n\npublic class DelegateExample {\n    public static void main(String[] args) {\n        \n        Delegator a = new Delegator();\n        assert a.operation().equals(\"default implementation\");\n\n        \n        Delegate d = new Delegate();\n        a.delegate = d;\n        assert a.operation().equals(\"delegate implementation\");\n\n        \n        a.delegate = new Thingable() {\n                public String thing() {\n                    return \"anonymous delegate implementation\";\n                }\n            };\n        assert a.operation().equals(\"anonymous delegate implementation\");\n    }\n}\n"}
{"id": 134018, "name": "Delegates", "source": "Translate Swift to Python: import Foundation\n\nprotocol Thingable { \n  func thing() -> String\n}\n\nclass Delegator {\n  weak var delegate: AnyObject?\n  func operation() -> String {\n    if let f = self.delegate?.thing {\n      return f()\n    } else {\n      return \"default implementation\"\n    }\n  }\n}\n\nclass Delegate {\n  dynamic func thing() -> String { return \"delegate implementation\" }\n}\n\n\nlet a = Delegator()\nprintln(a.operation())    \n\n\na.delegate = \"A delegate may be any object\"\nprintln(a.operation())    \n\n\nlet d = Delegate()\na.delegate = d\nprintln(a.operation())    \n", "target": "class Delegator:\n   def __init__(self):\n      self.delegate = None\n   def operation(self):\n       if hasattr(self.delegate, 'thing') and callable(self.delegate.thing):\n          return self.delegate.thing()\n       return 'default implementation'\n\nclass Delegate:\n   def thing(self):\n      return 'delegate implementation'\n\nif __name__ == '__main__':\n\n   \n   a = Delegator()\n   assert a.operation() == 'default implementation'\n\n   \n   a.delegate = 'A delegate may be any object'\n   assert a.operation() == 'default implementation'\n\n   \n   a.delegate = Delegate()\n   assert a.operation() == 'delegate implementation'\n"}
{"id": 134527, "name": "Empty string", "source": "Translate Swift to C#: var s = \"\"\nif s.isEmpty { \n  println(\"s is empty\")\n} else {\n  println(\"s is not empty\")\n}\n", "target": "using System;\n\nnamespace EmptyString\n{\n  class Program\n  {\n    public static void Main()\n    {\n      String s = scope .();\n      if (s.IsEmpty)\n      {\n        Console.Writeln(\"string empty\");\n      }\n      if (!s.IsEmpty)\n      {\n        Console.Writeln(\"string not empty\");\n      }\n    }\n  }\n}\n"}
{"id": 134528, "name": "Empty string", "source": "Translate Swift to C#: var s = \"\"\nif s.isEmpty { \n  println(\"s is empty\")\n} else {\n  println(\"s is not empty\")\n}\n", "target": "using System;\n\nnamespace EmptyString\n{\n  class Program\n  {\n    public static void Main()\n    {\n      String s = scope .();\n      if (s.IsEmpty)\n      {\n        Console.Writeln(\"string empty\");\n      }\n      if (!s.IsEmpty)\n      {\n        Console.Writeln(\"string not empty\");\n      }\n    }\n  }\n}\n"}
{"id": 134531, "name": "Empty string", "source": "Translate Swift to Java: var s = \"\"\nif s.isEmpty { \n  println(\"s is empty\")\n} else {\n  println(\"s is not empty\")\n}\n", "target": "String s = \"\";\nif(s != null && s.isEmpty()){\n   System.out.println(\"s is empty\");\n}else{\n   System.out.println(\"s is not empty\");\n}\n"}
{"id": 134532, "name": "Empty string", "source": "Translate Swift to Java: var s = \"\"\nif s.isEmpty { \n  println(\"s is empty\")\n} else {\n  println(\"s is not empty\")\n}\n", "target": "String s = \"\";\nif(s != null && s.isEmpty()){\n   System.out.println(\"s is empty\");\n}else{\n   System.out.println(\"s is not empty\");\n}\n"}
{"id": 134533, "name": "Empty string", "source": "Translate Swift to Python: var s = \"\"\nif s.isEmpty { \n  println(\"s is empty\")\n} else {\n  println(\"s is not empty\")\n}\n", "target": "s = ''\n\ns = str()\n\nif not s or s == '':\n   print(\"String is empty\")\n\nif len(s) == 0:\n    print(\"String is empty\")\nelse:\n    print(\"String not empty\")\n\n\n\n\n\n\ndef emptystring(s):\n   if isinstance(s, (''.__class__ , u''.__class__) ):\n      if len(s) == 0: \n         return True\n      else \n         return False\n\n   elif s is None:\n        return True\n"}
{"id": 134534, "name": "Empty string", "source": "Translate Swift to Python: var s = \"\"\nif s.isEmpty { \n  println(\"s is empty\")\n} else {\n  println(\"s is not empty\")\n}\n", "target": "s = ''\n\ns = str()\n\nif not s or s == '':\n   print(\"String is empty\")\n\nif len(s) == 0:\n    print(\"String is empty\")\nelse:\n    print(\"String not empty\")\n\n\n\n\n\n\ndef emptystring(s):\n   if isinstance(s, (''.__class__ , u''.__class__) ):\n      if len(s) == 0: \n         return True\n      else \n         return False\n\n   elif s is None:\n        return True\n"}
{"id": 135019, "name": "Equilibrium index", "source": "Translate Swift to C#: extension Collection where Element: Numeric {\n  func equilibriumIndexes() -> [Index] {\n    guard !isEmpty else {\n      return []\n    }\n\n    let sumAll = reduce(0, +)\n    var ret = [Index]()\n    var sumLeft: Element = 0\n    var sumRight: Element\n\n    for i in indices {\n      sumRight = sumAll - sumLeft - self[i]\n\n      if sumLeft == sumRight {\n        ret.append(i)\n      }\n\n      sumLeft += self[i]\n    }\n\n    return ret\n  }\n}\n\nlet arr = [-7, 1, 5, 2, -4, 3, 0]\n\nprint(\"Equilibrium indexes of \\(arr): \\(arr.equilibriumIndexes())\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static IEnumerable<int> EquilibriumIndices(IEnumerable<int> sequence)\n    {\n        var left = 0;\n        var right = sequence.Sum();\n        var index = 0;\n        foreach (var element in sequence)\n        {\n            right -= element;\n            if (left == right)\n            {\n                yield return index;\n            }\n            left += element;\n            index++;\n        }\n    }\n\n    static void Main()\n    {\n        foreach (var index in EquilibriumIndices(new[] { -7, 1, 5, 2, -4, 3, 0 }))\n        {\n            Console.WriteLine(index);\n        }\n    }\n}\n"}
{"id": 135020, "name": "Equilibrium index", "source": "Translate Swift to C#: extension Collection where Element: Numeric {\n  func equilibriumIndexes() -> [Index] {\n    guard !isEmpty else {\n      return []\n    }\n\n    let sumAll = reduce(0, +)\n    var ret = [Index]()\n    var sumLeft: Element = 0\n    var sumRight: Element\n\n    for i in indices {\n      sumRight = sumAll - sumLeft - self[i]\n\n      if sumLeft == sumRight {\n        ret.append(i)\n      }\n\n      sumLeft += self[i]\n    }\n\n    return ret\n  }\n}\n\nlet arr = [-7, 1, 5, 2, -4, 3, 0]\n\nprint(\"Equilibrium indexes of \\(arr): \\(arr.equilibriumIndexes())\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static IEnumerable<int> EquilibriumIndices(IEnumerable<int> sequence)\n    {\n        var left = 0;\n        var right = sequence.Sum();\n        var index = 0;\n        foreach (var element in sequence)\n        {\n            right -= element;\n            if (left == right)\n            {\n                yield return index;\n            }\n            left += element;\n            index++;\n        }\n    }\n\n    static void Main()\n    {\n        foreach (var index in EquilibriumIndices(new[] { -7, 1, 5, 2, -4, 3, 0 }))\n        {\n            Console.WriteLine(index);\n        }\n    }\n}\n"}
{"id": 135023, "name": "Equilibrium index", "source": "Translate Swift to Java: extension Collection where Element: Numeric {\n  func equilibriumIndexes() -> [Index] {\n    guard !isEmpty else {\n      return []\n    }\n\n    let sumAll = reduce(0, +)\n    var ret = [Index]()\n    var sumLeft: Element = 0\n    var sumRight: Element\n\n    for i in indices {\n      sumRight = sumAll - sumLeft - self[i]\n\n      if sumLeft == sumRight {\n        ret.append(i)\n      }\n\n      sumLeft += self[i]\n    }\n\n    return ret\n  }\n}\n\nlet arr = [-7, 1, 5, 2, -4, 3, 0]\n\nprint(\"Equilibrium indexes of \\(arr): \\(arr.equilibriumIndexes())\")\n", "target": "public class Equlibrium {\n\tpublic static void main(String[] args) {\n\t\tint[] sequence = {-7, 1, 5, 2, -4, 3, 0};\n\t\tequlibrium_indices(sequence);\n\t}\n\n\tpublic static void equlibrium_indices(int[] sequence){\n\t\t\n\t\tint totalSum = 0;\n\t\tfor (int n : sequence) {\n\t\t\ttotalSum += n;\n\t\t}\n\t\t\n\t\tint runningSum = 0;\n\t\tfor (int i = 0; i < sequence.length; i++) {\n\t\t\tint n = sequence[i];\n\t\t\tif (totalSum - runningSum - n == runningSum) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t\trunningSum += n;\n\t\t}\n\t}\n}\n"}
{"id": 135024, "name": "Equilibrium index", "source": "Translate Swift to Java: extension Collection where Element: Numeric {\n  func equilibriumIndexes() -> [Index] {\n    guard !isEmpty else {\n      return []\n    }\n\n    let sumAll = reduce(0, +)\n    var ret = [Index]()\n    var sumLeft: Element = 0\n    var sumRight: Element\n\n    for i in indices {\n      sumRight = sumAll - sumLeft - self[i]\n\n      if sumLeft == sumRight {\n        ret.append(i)\n      }\n\n      sumLeft += self[i]\n    }\n\n    return ret\n  }\n}\n\nlet arr = [-7, 1, 5, 2, -4, 3, 0]\n\nprint(\"Equilibrium indexes of \\(arr): \\(arr.equilibriumIndexes())\")\n", "target": "public class Equlibrium {\n\tpublic static void main(String[] args) {\n\t\tint[] sequence = {-7, 1, 5, 2, -4, 3, 0};\n\t\tequlibrium_indices(sequence);\n\t}\n\n\tpublic static void equlibrium_indices(int[] sequence){\n\t\t\n\t\tint totalSum = 0;\n\t\tfor (int n : sequence) {\n\t\t\ttotalSum += n;\n\t\t}\n\t\t\n\t\tint runningSum = 0;\n\t\tfor (int i = 0; i < sequence.length; i++) {\n\t\t\tint n = sequence[i];\n\t\t\tif (totalSum - runningSum - n == runningSum) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t\trunningSum += n;\n\t\t}\n\t}\n}\n"}
{"id": 135025, "name": "Equilibrium index", "source": "Translate Swift to Python: extension Collection where Element: Numeric {\n  func equilibriumIndexes() -> [Index] {\n    guard !isEmpty else {\n      return []\n    }\n\n    let sumAll = reduce(0, +)\n    var ret = [Index]()\n    var sumLeft: Element = 0\n    var sumRight: Element\n\n    for i in indices {\n      sumRight = sumAll - sumLeft - self[i]\n\n      if sumLeft == sumRight {\n        ret.append(i)\n      }\n\n      sumLeft += self[i]\n    }\n\n    return ret\n  }\n}\n\nlet arr = [-7, 1, 5, 2, -4, 3, 0]\n\nprint(\"Equilibrium indexes of \\(arr): \\(arr.equilibriumIndexes())\")\n", "target": "def eqindex2Pass(data):\n    \"Two pass\"\n    suml, sumr, ddelayed = 0, sum(data), 0\n    for i, d in enumerate(data):\n        suml += ddelayed\n        sumr -= d\n        ddelayed = d\n        if suml == sumr:\n            yield i\n"}
{"id": 135026, "name": "Equilibrium index", "source": "Translate Swift to Python: extension Collection where Element: Numeric {\n  func equilibriumIndexes() -> [Index] {\n    guard !isEmpty else {\n      return []\n    }\n\n    let sumAll = reduce(0, +)\n    var ret = [Index]()\n    var sumLeft: Element = 0\n    var sumRight: Element\n\n    for i in indices {\n      sumRight = sumAll - sumLeft - self[i]\n\n      if sumLeft == sumRight {\n        ret.append(i)\n      }\n\n      sumLeft += self[i]\n    }\n\n    return ret\n  }\n}\n\nlet arr = [-7, 1, 5, 2, -4, 3, 0]\n\nprint(\"Equilibrium indexes of \\(arr): \\(arr.equilibriumIndexes())\")\n", "target": "def eqindex2Pass(data):\n    \"Two pass\"\n    suml, sumr, ddelayed = 0, sum(data), 0\n    for i, d in enumerate(data):\n        suml += ddelayed\n        sumr -= d\n        ddelayed = d\n        if suml == sumr:\n            yield i\n"}
{"id": 135336, "name": "Matrix transposition", "source": "Translate Swift to C#: @inlinable\npublic func matrixTranspose<T>(_ matrix: [[T]]) -> [[T]] {\n  guard !matrix.isEmpty else {\n    return []\n  }\n\n  var ret = Array(repeating: [T](), count: matrix[0].count)\n\n  for row in matrix {\n    for j in 0..<row.count {\n      ret[j].append(row[j])\n    }\n  }\n\n  return ret\n}\n\n@inlinable\npublic func printMatrix<T>(_ matrix: [[T]]) {\n  guard !matrix.isEmpty else {\n    print()\n\n    return\n  }\n\n  let rows = matrix.count\n  let cols = matrix[0].count\n\n  for i in 0..<rows {\n    for j in 0..<cols {\n      print(matrix[i][j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\nlet m1 = [\n  [1, 2, 3],\n  [4, 5, 6]\n]\n\nprint(\"Input:\")\nprintMatrix(m1)\n\n\nlet m2 = matrixTranspose(m1)\n\nprint(\"Output:\")\nprintMatrix(m2)\n", "target": "using System;\nusing System.Text;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\t\t\t\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tdouble[,] m = { {1,2,3},{4,5,6},{7,8,9} };\n\t\t\t\n\t\t\tdouble[,] t = Transpose( m );\t\n\t\t\t\n\t\t\tfor( int i=0; i<t.GetLength(0); i++ )\n\t\t\t{\n\t\t\t\tfor( int j=0; j<t.GetLength(1); j++ )\t\t\n\t\t\t\t\tConsole.Write( t[i,j] + \"  \" );\n\t\t\t\tConsole.WriteLine(\"\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static double[,] Transpose( double[,] m )\n\t\t{\n\t\t\tdouble[,] t = new double[m.GetLength(1),m.GetLength(0)];\n\t\t\tfor( int i=0; i<m.GetLength(0); i++ )\n\t\t\t\tfor( int j=0; j<m.GetLength(1); j++ )\n\t\t\t\t\tt[j,i] = m[i,j];\t\t\t\n\t\t\t\n\t\t\treturn t;\n\t\t}\n\t}\n}\n"}
{"id": 135338, "name": "Matrix transposition", "source": "Translate Swift to Java: @inlinable\npublic func matrixTranspose<T>(_ matrix: [[T]]) -> [[T]] {\n  guard !matrix.isEmpty else {\n    return []\n  }\n\n  var ret = Array(repeating: [T](), count: matrix[0].count)\n\n  for row in matrix {\n    for j in 0..<row.count {\n      ret[j].append(row[j])\n    }\n  }\n\n  return ret\n}\n\n@inlinable\npublic func printMatrix<T>(_ matrix: [[T]]) {\n  guard !matrix.isEmpty else {\n    print()\n\n    return\n  }\n\n  let rows = matrix.count\n  let cols = matrix[0].count\n\n  for i in 0..<rows {\n    for j in 0..<cols {\n      print(matrix[i][j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\nlet m1 = [\n  [1, 2, 3],\n  [4, 5, 6]\n]\n\nprint(\"Input:\")\nprintMatrix(m1)\n\n\nlet m2 = matrixTranspose(m1)\n\nprint(\"Output:\")\nprintMatrix(m2)\n", "target": "import java.util.Arrays;\npublic class Transpose{\n       public static void main(String[] args){\n               double[][] m = {{1, 1, 1, 1},\n                               {2, 4, 8, 16},\n                               {3, 9, 27, 81},\n                               {4, 16, 64, 256},\n                               {5, 25, 125, 625}};\n               double[][] ans = new double[m[0].length][m.length];\n               for(int rows = 0; rows < m.length; rows++){\n                       for(int cols = 0; cols < m[0].length; cols++){\n                               ans[cols][rows] = m[rows][cols];\n                       }\n               }\n               for(double[] i:ans){\n                       System.out.println(Arrays.toString(i));\n               }\n       }\n}\n"}
{"id": 135339, "name": "Matrix transposition", "source": "Translate Swift to Python: @inlinable\npublic func matrixTranspose<T>(_ matrix: [[T]]) -> [[T]] {\n  guard !matrix.isEmpty else {\n    return []\n  }\n\n  var ret = Array(repeating: [T](), count: matrix[0].count)\n\n  for row in matrix {\n    for j in 0..<row.count {\n      ret[j].append(row[j])\n    }\n  }\n\n  return ret\n}\n\n@inlinable\npublic func printMatrix<T>(_ matrix: [[T]]) {\n  guard !matrix.isEmpty else {\n    print()\n\n    return\n  }\n\n  let rows = matrix.count\n  let cols = matrix[0].count\n\n  for i in 0..<rows {\n    for j in 0..<cols {\n      print(matrix[i][j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\nlet m1 = [\n  [1, 2, 3],\n  [4, 5, 6]\n]\n\nprint(\"Input:\")\nprintMatrix(m1)\n\n\nlet m2 = matrixTranspose(m1)\n\nprint(\"Output:\")\nprintMatrix(m2)\n", "target": "m=((1,  1,  1,   1),\n   (2,  4,  8,  16),\n   (3,  9, 27,  81),\n   (4, 16, 64, 256),\n   (5, 25,125, 625))\nprint(zip(*m))\n\n\n"}
{"id": 135493, "name": "Atomic updates", "source": "Translate Swift to C#: import Foundation\n\nfinal class AtomicBuckets: CustomStringConvertible {\n  var count: Int {\n    return buckets.count\n  }\n\n  var description: String {\n    return withBucketsLocked { \"\\(buckets)\" }\n  }\n\n  var total: Int {\n    return withBucketsLocked { buckets.reduce(0, +) }\n  }\n\n  private let lock = DispatchSemaphore(value: 1)\n\n  private var buckets: [Int]\n\n  subscript(n: Int) -> Int {\n    return withBucketsLocked { buckets[n] }\n  }\n\n  init(with buckets: [Int]) {\n    self.buckets = buckets\n  }\n\n  func transfer(amount: Int, from: Int, to: Int) {\n    withBucketsLocked {\n      let transferAmount = buckets[from] >= amount ? amount : buckets[from]\n\n      buckets[from] -= transferAmount\n      buckets[to] += transferAmount\n    }\n  }\n\n  private func withBucketsLocked<T>(do: () -> T) -> T {\n    let ret: T\n\n    lock.wait()\n    ret = `do`()\n    lock.signal()\n\n    return ret\n  }\n}\n\nlet bucks = AtomicBuckets(with: [21, 39, 40, 20])\nlet order = DispatchSource.makeTimerSource()\nlet chaos = DispatchSource.makeTimerSource()\nlet printer = DispatchSource.makeTimerSource()\n\nprinter.setEventHandler {\n  print(\"\\(bucks) = \\(bucks.total)\")\n}\n\nprinter.schedule(deadline: .now(), repeating: .seconds(1))\nprinter.activate()\n\norder.setEventHandler {\n  let (b1, b2) = (Int.random(in: 0..<bucks.count), Int.random(in: 0..<bucks.count))\n  let (v1, v2) = (bucks[b1], bucks[b2])\n\n  guard v1 != v2 else {\n    return\n  }\n\n  if v1 > v2 {\n    bucks.transfer(amount: (v1 - v2) / 2, from: b1, to: b2)\n  } else {\n    bucks.transfer(amount: (v2 - v1) / 2, from: b2, to: b1)\n  }\n}\n\norder.schedule(deadline: .now(), repeating: .milliseconds(5))\norder.activate()\n\nchaos.setEventHandler {\n  let (b1, b2) = (Int.random(in: 0..<bucks.count), Int.random(in: 0..<bucks.count))\n\n  bucks.transfer(amount: Int.random(in: 0..<(bucks[b1] + 1)), from: b1, to: b2)\n}\n\nchaos.schedule(deadline: .now(), repeating: .milliseconds(5))\nchaos.activate()\n\ndispatchMain()\n", "target": "using System; \nusing System.Threading; \npublic class ThreadSafeBuckets\n{\n    \n    \n    Random rand = new Random();\n    int[] Buckets;\n    object[] locks; \n    public int BucketCount { get; private set; }\n    public ThreadSafeBuckets(int bucketcount)\n    {\n        \n        BucketCount = bucketcount;\n        Buckets = new int[bucketcount];\n        locks = new object[bucketcount];\n        int startingtotal = 0;\n        for (int i = 0; i < BucketCount; i++)\n        {\n            locks[i] = new object();\n            Buckets[i] = rand.Next(30);\n            startingtotal += Buckets[i];\n        }\n        \n        Console.WriteLine(\"Starting total: \" + startingtotal);\n    }\n    public int GetBucketValue(int i)\n    {\n        return Buckets[i];\n    }\n    public void Transfer(int i, int j, int amount)\n    {\n        \n        if (i > BucketCount || j > BucketCount || i < 0 || j < 0 ||\n            i == j || amount < 0)\n            return;\n\n        \n        lock (locks[Math.Min(i, j)])\n            lock (locks[Math.Max(i, j)])\n            {\n                \n                amount = Math.Min(amount, Buckets[i]);\n\n                \n                Buckets[i] -= amount;\n                Buckets[j] += amount;\n            }\n    }\n\n    public void PrintBuckets()\n    {\n        int counter = 0;\n        \n        for (int i = 0; i < BucketCount; i++)\n        {\n            Monitor.Enter(locks[i]);\n            Console.Write(Buckets[i] + \" \");\n            counter += Buckets[i];\n        }\n        \n        Console.Write(\"= \" + counter);\n        Console.WriteLine();\n\n        foreach (var l in locks)\n            Monitor.Exit(l);\n    }\n}\n\nclass Program\n{\n    static ThreadSafeBuckets TSBs;\n\n    public static void Main(){\n        \n        TSBs = new ThreadSafeBuckets(10);\n        TSBs.PrintBuckets();\n        \n        new Thread(new ThreadStart(EqualizerThread)).Start();\n        Thread.Sleep(1);\n        \n        new Thread(new ThreadStart(RandomizerThread)).Start();\n        \n        PrinterThread();\n    }\n    \n    static void EqualizerThread()\n    {\n        Random rand = new Random();\n        while (true)\n        {\n            \n            int b1 = rand.Next(TSBs.BucketCount);\n            int b2 = rand.Next(TSBs.BucketCount);\n            \n            int diff = TSBs.GetBucketValue(b1) - TSBs.GetBucketValue(b2);\n            \n            if (diff < 0)\n                TSBs.Transfer(b2, b1, -diff / 2);\n            else\n                TSBs.Transfer(b1, b2, diff/2);\n        }\n    }\n    \n    static void RandomizerThread()\n    {\n        Random rand = new Random();\n        while (true)\n        {\n            int b1 = rand.Next(TSBs.BucketCount);\n            int b2 = rand.Next(TSBs.BucketCount);\n            int diff = rand.Next(TSBs.GetBucketValue(b1));\n            TSBs.Transfer(b1, b2, diff);\n        }\n    }\n    \n    static void PrinterThread()\n    {\n        while (true)\n        {\n            Thread.Sleep(50); \n            TSBs.PrintBuckets();\n        }\n    }\n}\n"}
{"id": 135495, "name": "Atomic updates", "source": "Translate Swift to Java: import Foundation\n\nfinal class AtomicBuckets: CustomStringConvertible {\n  var count: Int {\n    return buckets.count\n  }\n\n  var description: String {\n    return withBucketsLocked { \"\\(buckets)\" }\n  }\n\n  var total: Int {\n    return withBucketsLocked { buckets.reduce(0, +) }\n  }\n\n  private let lock = DispatchSemaphore(value: 1)\n\n  private var buckets: [Int]\n\n  subscript(n: Int) -> Int {\n    return withBucketsLocked { buckets[n] }\n  }\n\n  init(with buckets: [Int]) {\n    self.buckets = buckets\n  }\n\n  func transfer(amount: Int, from: Int, to: Int) {\n    withBucketsLocked {\n      let transferAmount = buckets[from] >= amount ? amount : buckets[from]\n\n      buckets[from] -= transferAmount\n      buckets[to] += transferAmount\n    }\n  }\n\n  private func withBucketsLocked<T>(do: () -> T) -> T {\n    let ret: T\n\n    lock.wait()\n    ret = `do`()\n    lock.signal()\n\n    return ret\n  }\n}\n\nlet bucks = AtomicBuckets(with: [21, 39, 40, 20])\nlet order = DispatchSource.makeTimerSource()\nlet chaos = DispatchSource.makeTimerSource()\nlet printer = DispatchSource.makeTimerSource()\n\nprinter.setEventHandler {\n  print(\"\\(bucks) = \\(bucks.total)\")\n}\n\nprinter.schedule(deadline: .now(), repeating: .seconds(1))\nprinter.activate()\n\norder.setEventHandler {\n  let (b1, b2) = (Int.random(in: 0..<bucks.count), Int.random(in: 0..<bucks.count))\n  let (v1, v2) = (bucks[b1], bucks[b2])\n\n  guard v1 != v2 else {\n    return\n  }\n\n  if v1 > v2 {\n    bucks.transfer(amount: (v1 - v2) / 2, from: b1, to: b2)\n  } else {\n    bucks.transfer(amount: (v2 - v1) / 2, from: b2, to: b1)\n  }\n}\n\norder.schedule(deadline: .now(), repeating: .milliseconds(5))\norder.activate()\n\nchaos.setEventHandler {\n  let (b1, b2) = (Int.random(in: 0..<bucks.count), Int.random(in: 0..<bucks.count))\n\n  bucks.transfer(amount: Int.random(in: 0..<(bucks[b1] + 1)), from: b1, to: b2)\n}\n\nchaos.schedule(deadline: .now(), repeating: .milliseconds(5))\nchaos.activate()\n\ndispatchMain()\n", "target": "import java.util.Arrays;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class AtomicUpdates {\n\n    private static final int NUM_BUCKETS = 10;\n\n    public static class Buckets {\n        private final int[] data;\n\n        public Buckets(int[] data) {\n            this.data = data.clone();\n        }\n\n        public int getBucket(int index) {\n            synchronized (data) {\n                return data[index];\n            }\n        }\n\n        public int transfer(int srcIndex, int dstIndex, int amount) {\n            if (amount < 0)\n                throw new IllegalArgumentException(\"negative amount: \" + amount);\n            if (amount == 0)\n                return 0;\n\n            synchronized (data) {\n                if (data[srcIndex] - amount < 0)\n                    amount = data[srcIndex];\n                if (data[dstIndex] + amount < 0)\n                    amount = Integer.MAX_VALUE - data[dstIndex];\n                if (amount < 0)\n                    throw new IllegalStateException();\n                data[srcIndex] -= amount;\n                data[dstIndex] += amount;\n                return amount;\n            }\n        }\n\n        public int[] getBuckets() {\n            synchronized (data) {\n                return data.clone();\n            }\n        }\n    }\n\n    private static long getTotal(int[] values) {\n        long total = 0;\n        for (int value : values) {\n            total += value;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n\n        int[] values = new int[NUM_BUCKETS];\n        for (int i = 0; i < values.length; i++)\n            values[i] = rnd.nextInt() & Integer.MAX_VALUE;\n        System.out.println(\"Initial Array: \" + getTotal(values) + \" \" + Arrays.toString(values));\n\n        Buckets buckets = new Buckets(values);\n        new Thread(() -> equalize(buckets), \"equalizer\").start();\n        new Thread(() -> transferRandomAmount(buckets), \"transferrer\").start();\n        new Thread(() -> print(buckets), \"printer\").start();\n    }\n\n    private static void transferRandomAmount(Buckets buckets) {\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n        while (true) {\n            int srcIndex = rnd.nextInt(NUM_BUCKETS);\n            int dstIndex = rnd.nextInt(NUM_BUCKETS);\n            int amount = rnd.nextInt() & Integer.MAX_VALUE;\n            buckets.transfer(srcIndex, dstIndex, amount);\n        }\n    }\n\n    private static void equalize(Buckets buckets) {\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n        while (true) {\n            int srcIndex = rnd.nextInt(NUM_BUCKETS);\n            int dstIndex = rnd.nextInt(NUM_BUCKETS);\n            int amount = (buckets.getBucket(srcIndex) - buckets.getBucket(dstIndex)) / 2;\n            if (amount >= 0)\n                buckets.transfer(srcIndex, dstIndex, amount);\n        }\n    }\n\n    private static void print(Buckets buckets) {\n        while (true) {\n            long nextPrintTime = System.currentTimeMillis() + 3000;\n            long now;\n            while ((now = System.currentTimeMillis()) < nextPrintTime) {\n                try {\n                    Thread.sleep(nextPrintTime - now);\n                } catch (InterruptedException e) {\n                    return;\n                }\n            }\n\n            int[] bucketValues = buckets.getBuckets();\n            System.out.println(\"Current values: \" + getTotal(bucketValues) + \" \" + Arrays.toString(bucketValues));\n        }\n    }\n}\n"}
{"id": 135496, "name": "Atomic updates", "source": "Translate Swift to Python: import Foundation\n\nfinal class AtomicBuckets: CustomStringConvertible {\n  var count: Int {\n    return buckets.count\n  }\n\n  var description: String {\n    return withBucketsLocked { \"\\(buckets)\" }\n  }\n\n  var total: Int {\n    return withBucketsLocked { buckets.reduce(0, +) }\n  }\n\n  private let lock = DispatchSemaphore(value: 1)\n\n  private var buckets: [Int]\n\n  subscript(n: Int) -> Int {\n    return withBucketsLocked { buckets[n] }\n  }\n\n  init(with buckets: [Int]) {\n    self.buckets = buckets\n  }\n\n  func transfer(amount: Int, from: Int, to: Int) {\n    withBucketsLocked {\n      let transferAmount = buckets[from] >= amount ? amount : buckets[from]\n\n      buckets[from] -= transferAmount\n      buckets[to] += transferAmount\n    }\n  }\n\n  private func withBucketsLocked<T>(do: () -> T) -> T {\n    let ret: T\n\n    lock.wait()\n    ret = `do`()\n    lock.signal()\n\n    return ret\n  }\n}\n\nlet bucks = AtomicBuckets(with: [21, 39, 40, 20])\nlet order = DispatchSource.makeTimerSource()\nlet chaos = DispatchSource.makeTimerSource()\nlet printer = DispatchSource.makeTimerSource()\n\nprinter.setEventHandler {\n  print(\"\\(bucks) = \\(bucks.total)\")\n}\n\nprinter.schedule(deadline: .now(), repeating: .seconds(1))\nprinter.activate()\n\norder.setEventHandler {\n  let (b1, b2) = (Int.random(in: 0..<bucks.count), Int.random(in: 0..<bucks.count))\n  let (v1, v2) = (bucks[b1], bucks[b2])\n\n  guard v1 != v2 else {\n    return\n  }\n\n  if v1 > v2 {\n    bucks.transfer(amount: (v1 - v2) / 2, from: b1, to: b2)\n  } else {\n    bucks.transfer(amount: (v2 - v1) / 2, from: b2, to: b1)\n  }\n}\n\norder.schedule(deadline: .now(), repeating: .milliseconds(5))\norder.activate()\n\nchaos.setEventHandler {\n  let (b1, b2) = (Int.random(in: 0..<bucks.count), Int.random(in: 0..<bucks.count))\n\n  bucks.transfer(amount: Int.random(in: 0..<(bucks[b1] + 1)), from: b1, to: b2)\n}\n\nchaos.schedule(deadline: .now(), repeating: .milliseconds(5))\nchaos.activate()\n\ndispatchMain()\n", "target": "from __future__ import with_statement \nimport threading\nimport random\nimport time\n\nterminate = threading.Event()\n\nclass Buckets:\n    def __init__(self, nbuckets):\n        self.nbuckets = nbuckets\n        self.values = [random.randrange(10) for i in range(nbuckets)]\n        self.lock = threading.Lock()\n\n    def __getitem__(self, i):\n        return self.values[i]\n\n    def transfer(self, src, dst, amount):\n        with self.lock:\n            amount = min(amount, self.values[src])\n            self.values[src] -= amount\n            self.values[dst] += amount\n\n    def snapshot(self):\n        \n        with self.lock:\n            return self.values[:]\n\ndef randomize(buckets):\n    nbuckets = buckets.nbuckets\n    while not terminate.isSet():\n        src = random.randrange(nbuckets)\n        dst = random.randrange(nbuckets)\n        if dst!=src:\n            amount = random.randrange(20)\n            buckets.transfer(src, dst, amount)\n\ndef equalize(buckets):\n    nbuckets = buckets.nbuckets\n    while not terminate.isSet():\n        src = random.randrange(nbuckets)\n        dst = random.randrange(nbuckets)\n        if dst!=src:\n            amount = (buckets[src] - buckets[dst]) // 2\n            if amount>=0: buckets.transfer(src, dst, amount)\n            else: buckets.transfer(dst, src, -amount)\n\ndef print_state(buckets):\n    snapshot = buckets.snapshot()\n    for value in snapshot:\n        print '%2d' % value,\n    print '=', sum(snapshot)\n\n\nbuckets = Buckets(15)\n\n\nt1 = threading.Thread(target=randomize, args=[buckets])\nt1.start()\n\n\nt2 = threading.Thread(target=equalize, args=[buckets])\nt2.start()\n\n\ntry:\n    while True:\n        print_state(buckets)\n        time.sleep(1)\nexcept KeyboardInterrupt: \n    terminate.set()\n\n\nt1.join()\nt2.join()\n"}
{"id": 136035, "name": "Pernicious numbers", "source": "Translate Swift to C#: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n}\n\npublic func populationCount(n: Int) -> Int {\n  guard n >= 0 else { \n      return 0\n  }\n\n  return String(n, radix: 2).lazy.filter({ $0 == \"1\" }).count\n}\n\nlet first25 = (1...).lazy.filter({ populationCount(n: $0).isPrime }).prefix(25)\nlet rng = (888_888_877...888_888_888).lazy.filter({ populationCount(n: $0).isPrime })\n\nprint(\"First 25 Pernicious numbers: \\(Array(first25))\")\nprint(\"Pernicious numbers between 888_888_877...888_888_888: \\(Array(rng))\")\n", "target": "using System;\nusing System.Linq;\n\nnamespace PerniciousNumbers\n{\n    class Program\n    {\n        public static int PopulationCount(long n)\n        {\n            int cnt = 0;\n            do\n            {\n                if ((n & 1) != 0) \n                {\n                    cnt++;\n                }\n            } while ((n >>= 1) > 0);\n\n            return cnt;\n        }\n\n         public static bool isPrime(int x)\n        {\n            if (x <= 2 || (x & 1) == 0)\n            {\n                return x == 2;\n            }\n\n            var limit = Math.Sqrt(x);\n            for (int i = 3; i <= limit; i += 2)\n            {\n                if (x % i == 0)\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static IEnumerable<int> Pernicious(int start, int count, int take)\n        {\n            return Enumerable.Range(start, count).Where(n => isPrime(PopulationCount(n))).Take(take);\n        }\n\n        static void Main(string[] args)\n        {\n            foreach (var n in Pernicious(0, int.MaxValue, 25))\n            {\n                Console.Write(\"{0} \", n);\n            }\n\n            Console.WriteLine();\n\n            foreach (var n in Pernicious(888888877, 11, 11))\n            {\n                Console.Write(\"{0} \", n);\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 136037, "name": "Pernicious numbers", "source": "Translate Swift to Java: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n}\n\npublic func populationCount(n: Int) -> Int {\n  guard n >= 0 else { \n      return 0\n  }\n\n  return String(n, radix: 2).lazy.filter({ $0 == \"1\" }).count\n}\n\nlet first25 = (1...).lazy.filter({ populationCount(n: $0).isPrime }).prefix(25)\nlet rng = (888_888_877...888_888_888).lazy.filter({ populationCount(n: $0).isPrime })\n\nprint(\"First 25 Pernicious numbers: \\(Array(first25))\")\nprint(\"Pernicious numbers between 888_888_877...888_888_888: \\(Array(rng))\")\n", "target": "public class Pernicious{\n    \n    public static boolean isPrime(int x){\n        if(x < 2) return false;\n        for(int i = 2; i < x; i++){\n            if(x % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static int popCount(long x){\n        return Long.bitCount(x);\n    }\n\n    public static void main(String[] args){\n        for(long i = 1, n = 0; n < 25; i++){\n            if(isPrime(popCount(i))){\n                System.out.print(i + \" \");\n                n++;\n            }\n        }\n        \n        System.out.println();\n        \n        for(long i = 888888877; i <= 888888888; i++){\n            if(isPrime(popCount(i))) System.out.print(i + \" \");\n        }\n    }\n}\n"}
{"id": 136038, "name": "Pernicious numbers", "source": "Translate Swift to Python: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n}\n\npublic func populationCount(n: Int) -> Int {\n  guard n >= 0 else { \n      return 0\n  }\n\n  return String(n, radix: 2).lazy.filter({ $0 == \"1\" }).count\n}\n\nlet first25 = (1...).lazy.filter({ populationCount(n: $0).isPrime }).prefix(25)\nlet rng = (888_888_877...888_888_888).lazy.filter({ populationCount(n: $0).isPrime })\n\nprint(\"First 25 Pernicious numbers: \\(Array(first25))\")\nprint(\"Pernicious numbers between 888_888_877...888_888_888: \\(Array(rng))\")\n", "target": ">>> def popcount(n): return bin(n).count(\"1\")\n\n>>> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61}\n>>> p, i = [], 0\n>>> while len(p) < 25:\n        if popcount(i) in primes: p.append(i)\n        i += 1\n\n        \n>>> p\n[3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22, 24, 25, 26, 28, 31, 33, 34, 35, 36]\n>>> p, i = [], 888888877\n>>> while i <= 888888888:\n        if popcount(i) in primes: p.append(i)\n        i += 1\n\n        \n>>> p\n[888888877, 888888878, 888888880, 888888883, 888888885, 888888886]\n>>>\n"}
{"id": 136659, "name": "Literals_String", "source": "Translate Swift to C#: let you = \"You\"\nlet str1 = \"\\(you) can insert variables into strings.\"\nlet str2 = \"Swift also supports unicode in strings \u0131\u222b\u0192\u2202\u00df\u00b4\u2122\u00a1\u00e0\"\nlet str3 = \"Swift also supports control characters \\n\\tLike this\"\nlet str4 = \"'\" \nlet str5 = \"\\\"\" \nprintln(str3)\n", "target": "string path = @\"C:\\Windows\\System32\";\nstring multiline = @\"Line 1.\nLine 2.\nLine 3.\";\n"}
{"id": 136661, "name": "Literals_String", "source": "Translate Swift to Java: let you = \"You\"\nlet str1 = \"\\(you) can insert variables into strings.\"\nlet str2 = \"Swift also supports unicode in strings \u0131\u222b\u0192\u2202\u00df\u00b4\u2122\u00a1\u00e0\"\nlet str3 = \"Swift also supports control characters \\n\\tLike this\"\nlet str4 = \"'\" \nlet str5 = \"\\\"\" \nprintln(str3)\n", "target": "  char a = 'a';  \n  String b = \"abc\";  \n  char doubleQuote = '\"';  \n  char singleQuote = '\\'';  \n  String singleQuotes = \"''\";  \n  String doubleQuotes = \"\\\"\\\"\";  \n"}
{"id": 136662, "name": "Literals_String", "source": "Translate Swift to Python: let you = \"You\"\nlet str1 = \"\\(you) can insert variables into strings.\"\nlet str2 = \"Swift also supports unicode in strings \u0131\u222b\u0192\u2202\u00df\u00b4\u2122\u00a1\u00e0\"\nlet str3 = \"Swift also supports control characters \\n\\tLike this\"\nlet str4 = \"'\" \nlet str5 = \"\\\"\" \nprintln(str3)\n", "target": "'c' == \"c\" \n'text' == \"text\"\n' \" '\n\" ' \"\n'\\x20' == ' '\nu'unicode string'\nu'\\u05d0' \n"}
{"id": 137449, "name": "Add a variable to a class instance at runtime", "source": "Translate Swift to C#: import Foundation\n \nlet fooKey = UnsafeMutablePointer<UInt8>.alloc(1)\n \nclass MyClass { }\nlet e = MyClass()\n \n\nobjc_setAssociatedObject(e, fooKey, 1, .OBJC_ASSOCIATION_RETAIN)\n \n\nif let associatedObject = objc_getAssociatedObject(e, fooKey) {\n  print(\"associated object: \\(associatedObject)\")\n} else {\n  print(\"no associated object\")\n}\n", "target": "\n\n\n\n\n\n\n\nusing System;\nusing System.Dynamic;\n\nnamespace DynamicClassVariable\n{\n    internal static class Program\n    {\n        #region Static Members\n\n        private static void Main()\n        {\n            \n            \n            dynamic sampleObj = new ExpandoObject();\n            \n            sampleObj.bar = 1;\n            Console.WriteLine( \"sampleObj.bar = {0}\", sampleObj.bar );\n\n            \n            \n            \n            \n            Console.WriteLine( \"< Press any key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 137450, "name": "Add a variable to a class instance at runtime", "source": "Translate Swift to Python: import Foundation\n \nlet fooKey = UnsafeMutablePointer<UInt8>.alloc(1)\n \nclass MyClass { }\nlet e = MyClass()\n \n\nobjc_setAssociatedObject(e, fooKey, 1, .OBJC_ASSOCIATION_RETAIN)\n \n\nif let associatedObject = objc_getAssociatedObject(e, fooKey) {\n  print(\"associated object: \\(associatedObject)\")\n} else {\n  print(\"no associated object\")\n}\n", "target": "class empty(object):\n    pass\ne = empty()\n"}
{"id": 137853, "name": "JSON", "source": "Translate Swift to C#: import Foundation\n\nlet jsonString = \"{ \\\"foo\\\": 1, \\\"bar\\\": [10, \\\"apples\\\"] }\"\nif let jsonData = jsonString.data(using: .utf8) {\n\tif let jsonObject: Any = try? JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) {\n\t\tprint(\"Dictionary: \\(jsonObject)\")\n\t}\n}\n\nlet obj = [\n\t\"foo\": [1, \"Orange\"],\n\t\"bar\": 1\n] as [String : Any]\n\nif let objData = try? JSONSerialization.data(withJSONObject: obj, options: .prettyPrinted) {\n\tif let jsonString2 = String(data: objData, encoding: .utf8) {\n\t\tprint(\"JSON: \\(jsonString2)\")\n\t}\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Web.Script.Serialization;\n\nclass Program\n{\n    static void Main()\n    {\n        var people = new Dictionary<string, object> {{\"1\", \"John\"}, {\"2\", \"Susan\"}};\n        var serializer = new JavaScriptSerializer();\n        \n        var json = serializer.Serialize(people);\n        Console.WriteLine(json);\n\n        var deserialized = serializer.Deserialize<Dictionary<string, object>>(json);\n        Console.WriteLine(deserialized[\"2\"]);\n\n        var jsonObject = serializer.DeserializeObject(@\"{ \"\"foo\"\": 1, \"\"bar\"\": [10, \"\"apples\"\"] }\");\n        var data = jsonObject as Dictionary<string, object>;\n        var array = data[\"bar\"] as object[];\n        Console.WriteLine(array[1]);\n    }\n}\n"}
{"id": 137854, "name": "JSON", "source": "Translate Swift to C#: import Foundation\n\nlet jsonString = \"{ \\\"foo\\\": 1, \\\"bar\\\": [10, \\\"apples\\\"] }\"\nif let jsonData = jsonString.data(using: .utf8) {\n\tif let jsonObject: Any = try? JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) {\n\t\tprint(\"Dictionary: \\(jsonObject)\")\n\t}\n}\n\nlet obj = [\n\t\"foo\": [1, \"Orange\"],\n\t\"bar\": 1\n] as [String : Any]\n\nif let objData = try? JSONSerialization.data(withJSONObject: obj, options: .prettyPrinted) {\n\tif let jsonString2 = String(data: objData, encoding: .utf8) {\n\t\tprint(\"JSON: \\(jsonString2)\")\n\t}\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Web.Script.Serialization;\n\nclass Program\n{\n    static void Main()\n    {\n        var people = new Dictionary<string, object> {{\"1\", \"John\"}, {\"2\", \"Susan\"}};\n        var serializer = new JavaScriptSerializer();\n        \n        var json = serializer.Serialize(people);\n        Console.WriteLine(json);\n\n        var deserialized = serializer.Deserialize<Dictionary<string, object>>(json);\n        Console.WriteLine(deserialized[\"2\"]);\n\n        var jsonObject = serializer.DeserializeObject(@\"{ \"\"foo\"\": 1, \"\"bar\"\": [10, \"\"apples\"\"] }\");\n        var data = jsonObject as Dictionary<string, object>;\n        var array = data[\"bar\"] as object[];\n        Console.WriteLine(array[1]);\n    }\n}\n"}
{"id": 137857, "name": "JSON", "source": "Translate Swift to Java: import Foundation\n\nlet jsonString = \"{ \\\"foo\\\": 1, \\\"bar\\\": [10, \\\"apples\\\"] }\"\nif let jsonData = jsonString.data(using: .utf8) {\n\tif let jsonObject: Any = try? JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) {\n\t\tprint(\"Dictionary: \\(jsonObject)\")\n\t}\n}\n\nlet obj = [\n\t\"foo\": [1, \"Orange\"],\n\t\"bar\": 1\n] as [String : Any]\n\nif let objData = try? JSONSerialization.data(withJSONObject: obj, options: .prettyPrinted) {\n\tif let jsonString2 = String(data: objData, encoding: .utf8) {\n\t\tprint(\"JSON: \\(jsonString2)\")\n\t}\n}\n", "target": "\n\n\n\ngrammar JSON ;\n@members {\nString Indent = \"\";\n}\nNumber\t:\t(('0')|('-'? ('1'..'9') ('0'..'9')*)) ('.' ('0'..'9')+)? (('e'|'E') ('+'|'-')? ('0'..'9')+)?;\nWS\t:\t(' ' | '\\t' | '\\r' |'\\n') {skip();};\nTz\t:\t' ' .. '!' | '#' .. '[' | ']' .. '~';\nControl\t:\t'\\\\' ('\"'|'\\\\'|'/'|'b'|'f'|'n'|'r'|'t'|UCode);\nUCode\t:\t'u' ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F');\nKeyword\t:\t'true' | 'false' | 'null';\nString\t:\t'\"' (Control? Tz)* '\"';\nobject\t:       '{' {System.out.println(Indent + \"{Object}\"); Indent += \"    \";} (pair (',' pair*)*)? '}' {Indent = Indent.substring(4);};\npair\t:\te = String {System.out.println(Indent + \"{Property}\\t\" + $e.text);} ':' value;\nvalue\t:\tNumber             {System.out.println(Indent + \"{Number}  \\t\" + $Number.text);}\n\t|\tobject\n\t|\tString             {System.out.println(Indent + \"{String}  \\t\" + $String.text);}\n\t|\tKeyword            {System.out.println(Indent + \"{Keyword} \\t\" + $Keyword.text);}\n\t|\tarray;\narray\t:\t'[' {System.out.println(Indent + \"Array\"); Indent += \"    \";} (value (',' value)*)? ']' {Indent = Indent.substring(4);};\n"}
{"id": 137858, "name": "JSON", "source": "Translate Swift to Java: import Foundation\n\nlet jsonString = \"{ \\\"foo\\\": 1, \\\"bar\\\": [10, \\\"apples\\\"] }\"\nif let jsonData = jsonString.data(using: .utf8) {\n\tif let jsonObject: Any = try? JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) {\n\t\tprint(\"Dictionary: \\(jsonObject)\")\n\t}\n}\n\nlet obj = [\n\t\"foo\": [1, \"Orange\"],\n\t\"bar\": 1\n] as [String : Any]\n\nif let objData = try? JSONSerialization.data(withJSONObject: obj, options: .prettyPrinted) {\n\tif let jsonString2 = String(data: objData, encoding: .utf8) {\n\t\tprint(\"JSON: \\(jsonString2)\")\n\t}\n}\n", "target": "\n\n\n\ngrammar JSON ;\n@members {\nString Indent = \"\";\n}\nNumber\t:\t(('0')|('-'? ('1'..'9') ('0'..'9')*)) ('.' ('0'..'9')+)? (('e'|'E') ('+'|'-')? ('0'..'9')+)?;\nWS\t:\t(' ' | '\\t' | '\\r' |'\\n') {skip();};\nTz\t:\t' ' .. '!' | '#' .. '[' | ']' .. '~';\nControl\t:\t'\\\\' ('\"'|'\\\\'|'/'|'b'|'f'|'n'|'r'|'t'|UCode);\nUCode\t:\t'u' ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F');\nKeyword\t:\t'true' | 'false' | 'null';\nString\t:\t'\"' (Control? Tz)* '\"';\nobject\t:       '{' {System.out.println(Indent + \"{Object}\"); Indent += \"    \";} (pair (',' pair*)*)? '}' {Indent = Indent.substring(4);};\npair\t:\te = String {System.out.println(Indent + \"{Property}\\t\" + $e.text);} ':' value;\nvalue\t:\tNumber             {System.out.println(Indent + \"{Number}  \\t\" + $Number.text);}\n\t|\tobject\n\t|\tString             {System.out.println(Indent + \"{String}  \\t\" + $String.text);}\n\t|\tKeyword            {System.out.println(Indent + \"{Keyword} \\t\" + $Keyword.text);}\n\t|\tarray;\narray\t:\t'[' {System.out.println(Indent + \"Array\"); Indent += \"    \";} (value (',' value)*)? ']' {Indent = Indent.substring(4);};\n"}
{"id": 137859, "name": "JSON", "source": "Translate Swift to Python: import Foundation\n\nlet jsonString = \"{ \\\"foo\\\": 1, \\\"bar\\\": [10, \\\"apples\\\"] }\"\nif let jsonData = jsonString.data(using: .utf8) {\n\tif let jsonObject: Any = try? JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) {\n\t\tprint(\"Dictionary: \\(jsonObject)\")\n\t}\n}\n\nlet obj = [\n\t\"foo\": [1, \"Orange\"],\n\t\"bar\": 1\n] as [String : Any]\n\nif let objData = try? JSONSerialization.data(withJSONObject: obj, options: .prettyPrinted) {\n\tif let jsonString2 = String(data: objData, encoding: .utf8) {\n\t\tprint(\"JSON: \\(jsonString2)\")\n\t}\n}\n", "target": ">>> import json\n>>> data = json.loads('{ \"foo\": 1, \"bar\": [10, \"apples\"] }')\n>>> sample = { \"blue\": [1,2], \"ocean\": \"water\" }\n>>> json_string = json.dumps(sample)\n>>> json_string\n'{\"blue\": [1, 2], \"ocean\": \"water\"}'\n>>> sample\n{'blue': [1, 2], 'ocean': 'water'}\n>>> data\n{'foo': 1, 'bar': [10, 'apples']}\n"}
{"id": 137860, "name": "JSON", "source": "Translate Swift to Python: import Foundation\n\nlet jsonString = \"{ \\\"foo\\\": 1, \\\"bar\\\": [10, \\\"apples\\\"] }\"\nif let jsonData = jsonString.data(using: .utf8) {\n\tif let jsonObject: Any = try? JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) {\n\t\tprint(\"Dictionary: \\(jsonObject)\")\n\t}\n}\n\nlet obj = [\n\t\"foo\": [1, \"Orange\"],\n\t\"bar\": 1\n] as [String : Any]\n\nif let objData = try? JSONSerialization.data(withJSONObject: obj, options: .prettyPrinted) {\n\tif let jsonString2 = String(data: objData, encoding: .utf8) {\n\t\tprint(\"JSON: \\(jsonString2)\")\n\t}\n}\n", "target": ">>> import json\n>>> data = json.loads('{ \"foo\": 1, \"bar\": [10, \"apples\"] }')\n>>> sample = { \"blue\": [1,2], \"ocean\": \"water\" }\n>>> json_string = json.dumps(sample)\n>>> json_string\n'{\"blue\": [1, 2], \"ocean\": \"water\"}'\n>>> sample\n{'blue': [1, 2], 'ocean': 'water'}\n>>> data\n{'foo': 1, 'bar': [10, 'apples']}\n"}
{"id": 138639, "name": "Evolutionary algorithm", "source": "Translate Swift to C#: func evolve(\n  to target: String,\n  parent: inout String,\n  mutationRate: Int,\n  copies: Int\n) {\n  var parentFitness: Int {\n    return fitness(target: target, sentence: parent)\n  }\n\n  var generation = 0\n\n  while parent != target {\n    generation += 1\n\n    let bestOfGeneration =\n        (0..<copies)\n          .map({_ in mutate(sentence: parent, rate: mutationRate) })\n          .map({ (fitness(target: target, sentence: $0), $0) })\n          .sorted(by: { $0.0 < $1.0 })\n          .first!\n\n    if bestOfGeneration.0 < parentFitness {\n      print(\"Gen \\(generation) produced better fit. \\(bestOfGeneration.1) with fitness \\(bestOfGeneration.0)\")\n      parent = bestOfGeneration.1\n    }\n  }\n}\n\nfunc fitness(target: String, sentence: String) -> Int {\n  return zip(target, sentence).filter(!=).count\n}\n\nfunc mutate(sentence: String, rate: Int) -> String {\n  return String(\n    sentence.map({char in\n      if Int.random(in: 1...100) - rate <= 0 {\n        return \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".randomElement()!\n      } else {\n        return char\n      }\n    })\n  )\n}\n\nlet target = \"METHINKS IT IS LIKE A WEASEL\"\nlet copies = 100\nlet mutationRate = 20\n\nvar start = mutate(sentence: target, rate: 100)\n\nprint(\"target: \\(target)\")\nprint(\"Gen 0: \\(start) with fitness \\(fitness(target: target, sentence: start))\")\n\nevolve(to: target, parent: &start, mutationRate: mutationRate, copies: 100)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static Random Rng = new Random((int)DateTime.Now.Ticks);\n\n    static char NextCharacter(this Random self) {\n        const string AllowedChars = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        return AllowedChars[self.Next() % AllowedChars.Length];\n    }\n\n    static string NextString(this Random self, int length) {\n        return String.Join(\"\", Enumerable.Repeat(' ', length)\n            .Select(c => Rng.NextCharacter()));\n    }\n\n    static int Fitness(string target, string current) {\n        return target.Zip(current, (a, b) => a == b ? 1 : 0).Sum();\n    }\n\n    static string Mutate(string current, double rate) {\n        return String.Join(\"\", from c in current\n               select Rng.NextDouble() <= rate ? Rng.NextCharacter() : c);\n    }\n\n    static void Main(string[] args) {\n        const string target = \"METHINKS IT IS LIKE A WEASEL\";\n        const int C = 100;\n        const double P = 0.05;\n\n        \n        string parent = Rng.NextString(target.Length);\n\n        Console.WriteLine(\"START:       {0,20} fitness: {1}\", \n            parent, Fitness(target, parent));\n        int i = 0;\n\n        while (parent != target) {\n            \n            var candidates = Enumerable.Range(0, C + 1)\n                .Select(n => n > 0 ? Mutate(parent, P) : parent);\n\n            \n            parent = candidates.OrderByDescending(c => Fitness(target, c)).First();\n\n            ++i;\n            Console.WriteLine(\"     #{0,6} {1,20} fitness: {2}\", \n                i, parent, Fitness(target, parent));\n        }\n\n        Console.WriteLine(\"END: #{0,6} {1,20}\", i, parent);\n    }\n}\n"}
{"id": 138640, "name": "Evolutionary algorithm", "source": "Translate Swift to C#: func evolve(\n  to target: String,\n  parent: inout String,\n  mutationRate: Int,\n  copies: Int\n) {\n  var parentFitness: Int {\n    return fitness(target: target, sentence: parent)\n  }\n\n  var generation = 0\n\n  while parent != target {\n    generation += 1\n\n    let bestOfGeneration =\n        (0..<copies)\n          .map({_ in mutate(sentence: parent, rate: mutationRate) })\n          .map({ (fitness(target: target, sentence: $0), $0) })\n          .sorted(by: { $0.0 < $1.0 })\n          .first!\n\n    if bestOfGeneration.0 < parentFitness {\n      print(\"Gen \\(generation) produced better fit. \\(bestOfGeneration.1) with fitness \\(bestOfGeneration.0)\")\n      parent = bestOfGeneration.1\n    }\n  }\n}\n\nfunc fitness(target: String, sentence: String) -> Int {\n  return zip(target, sentence).filter(!=).count\n}\n\nfunc mutate(sentence: String, rate: Int) -> String {\n  return String(\n    sentence.map({char in\n      if Int.random(in: 1...100) - rate <= 0 {\n        return \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".randomElement()!\n      } else {\n        return char\n      }\n    })\n  )\n}\n\nlet target = \"METHINKS IT IS LIKE A WEASEL\"\nlet copies = 100\nlet mutationRate = 20\n\nvar start = mutate(sentence: target, rate: 100)\n\nprint(\"target: \\(target)\")\nprint(\"Gen 0: \\(start) with fitness \\(fitness(target: target, sentence: start))\")\n\nevolve(to: target, parent: &start, mutationRate: mutationRate, copies: 100)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static Random Rng = new Random((int)DateTime.Now.Ticks);\n\n    static char NextCharacter(this Random self) {\n        const string AllowedChars = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        return AllowedChars[self.Next() % AllowedChars.Length];\n    }\n\n    static string NextString(this Random self, int length) {\n        return String.Join(\"\", Enumerable.Repeat(' ', length)\n            .Select(c => Rng.NextCharacter()));\n    }\n\n    static int Fitness(string target, string current) {\n        return target.Zip(current, (a, b) => a == b ? 1 : 0).Sum();\n    }\n\n    static string Mutate(string current, double rate) {\n        return String.Join(\"\", from c in current\n               select Rng.NextDouble() <= rate ? Rng.NextCharacter() : c);\n    }\n\n    static void Main(string[] args) {\n        const string target = \"METHINKS IT IS LIKE A WEASEL\";\n        const int C = 100;\n        const double P = 0.05;\n\n        \n        string parent = Rng.NextString(target.Length);\n\n        Console.WriteLine(\"START:       {0,20} fitness: {1}\", \n            parent, Fitness(target, parent));\n        int i = 0;\n\n        while (parent != target) {\n            \n            var candidates = Enumerable.Range(0, C + 1)\n                .Select(n => n > 0 ? Mutate(parent, P) : parent);\n\n            \n            parent = candidates.OrderByDescending(c => Fitness(target, c)).First();\n\n            ++i;\n            Console.WriteLine(\"     #{0,6} {1,20} fitness: {2}\", \n                i, parent, Fitness(target, parent));\n        }\n\n        Console.WriteLine(\"END: #{0,6} {1,20}\", i, parent);\n    }\n}\n"}
{"id": 138643, "name": "Evolutionary algorithm", "source": "Translate Swift to Java: func evolve(\n  to target: String,\n  parent: inout String,\n  mutationRate: Int,\n  copies: Int\n) {\n  var parentFitness: Int {\n    return fitness(target: target, sentence: parent)\n  }\n\n  var generation = 0\n\n  while parent != target {\n    generation += 1\n\n    let bestOfGeneration =\n        (0..<copies)\n          .map({_ in mutate(sentence: parent, rate: mutationRate) })\n          .map({ (fitness(target: target, sentence: $0), $0) })\n          .sorted(by: { $0.0 < $1.0 })\n          .first!\n\n    if bestOfGeneration.0 < parentFitness {\n      print(\"Gen \\(generation) produced better fit. \\(bestOfGeneration.1) with fitness \\(bestOfGeneration.0)\")\n      parent = bestOfGeneration.1\n    }\n  }\n}\n\nfunc fitness(target: String, sentence: String) -> Int {\n  return zip(target, sentence).filter(!=).count\n}\n\nfunc mutate(sentence: String, rate: Int) -> String {\n  return String(\n    sentence.map({char in\n      if Int.random(in: 1...100) - rate <= 0 {\n        return \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".randomElement()!\n      } else {\n        return char\n      }\n    })\n  )\n}\n\nlet target = \"METHINKS IT IS LIKE A WEASEL\"\nlet copies = 100\nlet mutationRate = 20\n\nvar start = mutate(sentence: target, rate: 100)\n\nprint(\"target: \\(target)\")\nprint(\"Gen 0: \\(start) with fitness \\(fitness(target: target, sentence: start))\")\n\nevolve(to: target, parent: &start, mutationRate: mutationRate, copies: 100)\n", "target": "import java.util.Random;\n\npublic class EvoAlgo {\n  static final String target = \"METHINKS IT IS LIKE A WEASEL\";\n  static final char[] possibilities = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".toCharArray();\n  static int C = 100; \n  static double minMutateRate = 0.09;\n  static int perfectFitness = target.length();\n  private static String parent;\n  static Random rand = new Random();\n\n  private static int fitness(String trial){\n    int retVal = 0;\n    for(int i = 0;i < trial.length(); i++){\n      if (trial.charAt(i) == target.charAt(i)) retVal++;\n    }\n    return retVal;\n  }\n\n  private static double newMutateRate(){\n    return (((double)perfectFitness - fitness(parent)) / perfectFitness * (1 - minMutateRate));\n  }\n\n  private static String mutate(String parent, double rate){\n    String retVal = \"\";\n    for(int i = 0;i < parent.length(); i++){\n      retVal += (rand.nextDouble() <= rate) ?\n        possibilities[rand.nextInt(possibilities.length)]:\n        parent.charAt(i);\n    }\n    return retVal;\n  }\n  \n  public static void main(String[] args){\n    parent = mutate(target, 1);\n    int iter = 0;\n    while(!target.equals(parent)){\n      double rate = newMutateRate();\n      iter++;\n      if(iter % 100 == 0){\n        System.out.println(iter +\": \"+parent+ \", fitness: \"+fitness(parent)+\", rate: \"+rate);\n      }\n      String bestSpawn = null;\n      int bestFit = 0;\n      for(int i = 0; i < C; i++){\n        String spawn = mutate(parent, rate);\n        int fitness = fitness(spawn);\n        if(fitness > bestFit){\n          bestSpawn = spawn;\n          bestFit = fitness;\n        }\n      }\n      parent = bestFit > fitness(parent) ? bestSpawn : parent;\n    }\n    System.out.println(parent+\", \"+iter);\n  }\n\n}\n"}
{"id": 138644, "name": "Evolutionary algorithm", "source": "Translate Swift to Java: func evolve(\n  to target: String,\n  parent: inout String,\n  mutationRate: Int,\n  copies: Int\n) {\n  var parentFitness: Int {\n    return fitness(target: target, sentence: parent)\n  }\n\n  var generation = 0\n\n  while parent != target {\n    generation += 1\n\n    let bestOfGeneration =\n        (0..<copies)\n          .map({_ in mutate(sentence: parent, rate: mutationRate) })\n          .map({ (fitness(target: target, sentence: $0), $0) })\n          .sorted(by: { $0.0 < $1.0 })\n          .first!\n\n    if bestOfGeneration.0 < parentFitness {\n      print(\"Gen \\(generation) produced better fit. \\(bestOfGeneration.1) with fitness \\(bestOfGeneration.0)\")\n      parent = bestOfGeneration.1\n    }\n  }\n}\n\nfunc fitness(target: String, sentence: String) -> Int {\n  return zip(target, sentence).filter(!=).count\n}\n\nfunc mutate(sentence: String, rate: Int) -> String {\n  return String(\n    sentence.map({char in\n      if Int.random(in: 1...100) - rate <= 0 {\n        return \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".randomElement()!\n      } else {\n        return char\n      }\n    })\n  )\n}\n\nlet target = \"METHINKS IT IS LIKE A WEASEL\"\nlet copies = 100\nlet mutationRate = 20\n\nvar start = mutate(sentence: target, rate: 100)\n\nprint(\"target: \\(target)\")\nprint(\"Gen 0: \\(start) with fitness \\(fitness(target: target, sentence: start))\")\n\nevolve(to: target, parent: &start, mutationRate: mutationRate, copies: 100)\n", "target": "import java.util.Random;\n\npublic class EvoAlgo {\n  static final String target = \"METHINKS IT IS LIKE A WEASEL\";\n  static final char[] possibilities = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".toCharArray();\n  static int C = 100; \n  static double minMutateRate = 0.09;\n  static int perfectFitness = target.length();\n  private static String parent;\n  static Random rand = new Random();\n\n  private static int fitness(String trial){\n    int retVal = 0;\n    for(int i = 0;i < trial.length(); i++){\n      if (trial.charAt(i) == target.charAt(i)) retVal++;\n    }\n    return retVal;\n  }\n\n  private static double newMutateRate(){\n    return (((double)perfectFitness - fitness(parent)) / perfectFitness * (1 - minMutateRate));\n  }\n\n  private static String mutate(String parent, double rate){\n    String retVal = \"\";\n    for(int i = 0;i < parent.length(); i++){\n      retVal += (rand.nextDouble() <= rate) ?\n        possibilities[rand.nextInt(possibilities.length)]:\n        parent.charAt(i);\n    }\n    return retVal;\n  }\n  \n  public static void main(String[] args){\n    parent = mutate(target, 1);\n    int iter = 0;\n    while(!target.equals(parent)){\n      double rate = newMutateRate();\n      iter++;\n      if(iter % 100 == 0){\n        System.out.println(iter +\": \"+parent+ \", fitness: \"+fitness(parent)+\", rate: \"+rate);\n      }\n      String bestSpawn = null;\n      int bestFit = 0;\n      for(int i = 0; i < C; i++){\n        String spawn = mutate(parent, rate);\n        int fitness = fitness(spawn);\n        if(fitness > bestFit){\n          bestSpawn = spawn;\n          bestFit = fitness;\n        }\n      }\n      parent = bestFit > fitness(parent) ? bestSpawn : parent;\n    }\n    System.out.println(parent+\", \"+iter);\n  }\n\n}\n"}
{"id": 138645, "name": "Evolutionary algorithm", "source": "Translate Swift to Python: func evolve(\n  to target: String,\n  parent: inout String,\n  mutationRate: Int,\n  copies: Int\n) {\n  var parentFitness: Int {\n    return fitness(target: target, sentence: parent)\n  }\n\n  var generation = 0\n\n  while parent != target {\n    generation += 1\n\n    let bestOfGeneration =\n        (0..<copies)\n          .map({_ in mutate(sentence: parent, rate: mutationRate) })\n          .map({ (fitness(target: target, sentence: $0), $0) })\n          .sorted(by: { $0.0 < $1.0 })\n          .first!\n\n    if bestOfGeneration.0 < parentFitness {\n      print(\"Gen \\(generation) produced better fit. \\(bestOfGeneration.1) with fitness \\(bestOfGeneration.0)\")\n      parent = bestOfGeneration.1\n    }\n  }\n}\n\nfunc fitness(target: String, sentence: String) -> Int {\n  return zip(target, sentence).filter(!=).count\n}\n\nfunc mutate(sentence: String, rate: Int) -> String {\n  return String(\n    sentence.map({char in\n      if Int.random(in: 1...100) - rate <= 0 {\n        return \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".randomElement()!\n      } else {\n        return char\n      }\n    })\n  )\n}\n\nlet target = \"METHINKS IT IS LIKE A WEASEL\"\nlet copies = 100\nlet mutationRate = 20\n\nvar start = mutate(sentence: target, rate: 100)\n\nprint(\"target: \\(target)\")\nprint(\"Gen 0: \\(start) with fitness \\(fitness(target: target, sentence: start))\")\n\nevolve(to: target, parent: &start, mutationRate: mutationRate, copies: 100)\n", "target": "from string import letters\nfrom random import choice, random\n \ntarget  = list(\"METHINKS IT IS LIKE A WEASEL\")\ncharset = letters + ' '\nparent  = [choice(charset) for _ in range(len(target))]\nminmutaterate  = .09\nC = range(100)\n \nperfectfitness = float(len(target))\n    \ndef fitness(trial):\n    'Sum of matching chars by position'\n    return sum(t==h for t,h in zip(trial, target))\n \ndef mutaterate():\n    'Less mutation the closer the fit of the parent'\n    return 1-((perfectfitness - fitness(parent)) / perfectfitness * (1 - minmutaterate))\n \ndef mutate(parent, rate):\n    return [(ch if random() <= rate else choice(charset)) for ch in parent]\n \ndef que():\n    '(from the favourite saying of Manuel in Fawlty Towers)'\n    print (\"\n           (iterations, fitness(parent)*100./perfectfitness, ''.join(parent)))\n\ndef mate(a, b):\n    place = 0\n    if choice(xrange(10)) < 7:\n        place = choice(xrange(len(target)))\n    else:\n        return a, b\n    \n    return a, b, a[:place] + b[place:], b[:place] + a[place:]\n\niterations = 0\ncenter = len(C)/2\nwhile parent != target:\n    rate = mutaterate()\n    iterations += 1\n    if iterations % 100 == 0: que()\n    copies = [ mutate(parent, rate) for _ in C ]  + [parent]\n    parent1 = max(copies[:center], key=fitness)\n    parent2 = max(copies[center:], key=fitness)\n    parent = max(mate(parent1, parent2), key=fitness)\nque()\n"}
{"id": 138646, "name": "Evolutionary algorithm", "source": "Translate Swift to Python: func evolve(\n  to target: String,\n  parent: inout String,\n  mutationRate: Int,\n  copies: Int\n) {\n  var parentFitness: Int {\n    return fitness(target: target, sentence: parent)\n  }\n\n  var generation = 0\n\n  while parent != target {\n    generation += 1\n\n    let bestOfGeneration =\n        (0..<copies)\n          .map({_ in mutate(sentence: parent, rate: mutationRate) })\n          .map({ (fitness(target: target, sentence: $0), $0) })\n          .sorted(by: { $0.0 < $1.0 })\n          .first!\n\n    if bestOfGeneration.0 < parentFitness {\n      print(\"Gen \\(generation) produced better fit. \\(bestOfGeneration.1) with fitness \\(bestOfGeneration.0)\")\n      parent = bestOfGeneration.1\n    }\n  }\n}\n\nfunc fitness(target: String, sentence: String) -> Int {\n  return zip(target, sentence).filter(!=).count\n}\n\nfunc mutate(sentence: String, rate: Int) -> String {\n  return String(\n    sentence.map({char in\n      if Int.random(in: 1...100) - rate <= 0 {\n        return \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".randomElement()!\n      } else {\n        return char\n      }\n    })\n  )\n}\n\nlet target = \"METHINKS IT IS LIKE A WEASEL\"\nlet copies = 100\nlet mutationRate = 20\n\nvar start = mutate(sentence: target, rate: 100)\n\nprint(\"target: \\(target)\")\nprint(\"Gen 0: \\(start) with fitness \\(fitness(target: target, sentence: start))\")\n\nevolve(to: target, parent: &start, mutationRate: mutationRate, copies: 100)\n", "target": "from string import letters\nfrom random import choice, random\n \ntarget  = list(\"METHINKS IT IS LIKE A WEASEL\")\ncharset = letters + ' '\nparent  = [choice(charset) for _ in range(len(target))]\nminmutaterate  = .09\nC = range(100)\n \nperfectfitness = float(len(target))\n    \ndef fitness(trial):\n    'Sum of matching chars by position'\n    return sum(t==h for t,h in zip(trial, target))\n \ndef mutaterate():\n    'Less mutation the closer the fit of the parent'\n    return 1-((perfectfitness - fitness(parent)) / perfectfitness * (1 - minmutaterate))\n \ndef mutate(parent, rate):\n    return [(ch if random() <= rate else choice(charset)) for ch in parent]\n \ndef que():\n    '(from the favourite saying of Manuel in Fawlty Towers)'\n    print (\"\n           (iterations, fitness(parent)*100./perfectfitness, ''.join(parent)))\n\ndef mate(a, b):\n    place = 0\n    if choice(xrange(10)) < 7:\n        place = choice(xrange(len(target)))\n    else:\n        return a, b\n    \n    return a, b, a[:place] + b[place:], b[:place] + a[place:]\n\niterations = 0\ncenter = len(C)/2\nwhile parent != target:\n    rate = mutaterate()\n    iterations += 1\n    if iterations % 100 == 0: que()\n    copies = [ mutate(parent, rate) for _ in C ]  + [parent]\n    parent1 = max(copies[:center], key=fitness)\n    parent2 = max(copies[center:], key=fitness)\n    parent = max(mate(parent1, parent2), key=fitness)\nque()\n"}
{"id": 138892, "name": "Maze generation", "source": "Translate Swift to C#: import Foundation\n\nextension Array {\n    mutating func shuffle() {\n        guard count > 1 else { return }\n\n        for i in 0..<self.count - 1 {\n            let j = Int(arc4random_uniform(UInt32(count - i))) + i\n            guard i != j else { continue }\n            swap(&self[i], &self[j])\n        }\n    }\n}\n\nenum Direction:Int {\n    case north = 1\n    case south = 2\n    case east = 4\n    case west = 8\n\n    static var allDirections:[Direction] {\n        return [Direction.north, Direction.south, Direction.east, Direction.west]\n    }\n\n    var opposite:Direction {\n        switch self {\n        case .north:\n            return .south\n        case .south:\n            return .north\n        case .east:\n            return .west\n        case .west:\n            return .east\n        }\n    }\n\n    var diff:(Int, Int) {\n        switch self {\n        case .north:\n            return (0, -1)\n        case .south:\n            return (0, 1)\n        case .east:\n            return (1, 0)\n        case .west:\n            return (-1, 0)\n        }\n    }\n\n    var char:String {\n        switch self {\n        case .north:\n            return \"N\"\n        case .south:\n            return \"S\"\n        case .east:\n            return \"E\"\n        case .west:\n            return \"W\"\n        }\n    }\n\n}\n\nclass MazeGenerator {\n    let x:Int\n    let y:Int\n    var maze:[[Int]]\n\n    init(_ x:Int, _ y:Int) {\n        self.x  = x\n        self.y = y\n        let column = [Int](repeating: 0, count: y)\n        self.maze = [[Int]](repeating: column, count: x)\n        generateMaze(0, 0)\n    }\n\n    private func generateMaze(_ cx:Int, _ cy:Int) {\n        var directions = Direction.allDirections\n        directions.shuffle()\n        for direction in directions {\n            let (dx, dy) = direction.diff\n            let nx = cx + dx\n            let ny = cy + dy\n            if inBounds(nx, ny) && maze[nx][ny] == 0 {\n                maze[cx][cy] |= direction.rawValue\n                maze[nx][ny] |= direction.opposite.rawValue\n                generateMaze(nx, ny)\n            }\n        }\n    }\n\n    private func inBounds(_ testX:Int, _ testY:Int) -> Bool {\n        return inBounds(value:testX, upper:self.x) && inBounds(value:testY, upper:self.y)\n    }\n\n    private func inBounds(value:Int, upper:Int) -> Bool {\n        return (value >= 0) && (value < upper)\n    }\n\n    func display() {\n        let cellWidth = 3\n        for j in 0..<y {\n            \n            var topEdge = \"\"\n            for i in 0..<x {\n                topEdge += \"+\"\n                topEdge += String(repeating: (maze[i][j] & Direction.north.rawValue) == 0 ? \"-\" : \" \", count: cellWidth)\n            }\n            topEdge += \"+\"\n            print(topEdge)\n\n            \n            var leftEdge = \"\"\n            for i in 0..<x {\n                leftEdge += (maze[i][j] & Direction.west.rawValue) == 0 ? \"|\" : \" \"\n                leftEdge += String(repeating: \" \", count: cellWidth)\n            }\n            leftEdge += \"|\"\n            print(leftEdge)\n        }\n\n        \n        var bottomEdge = \"\"\n        for _ in 0..<x {\n            bottomEdge += \"+\"\n            bottomEdge += String(repeating: \"-\", count: cellWidth)\n        }\n        bottomEdge += \"+\"\n        print(bottomEdge)\n    }\n    \n    func displayInts() {\n        for j in 0..<y {\n            var line = \"\"\n            for i in 0..<x {\n                line += String(maze[i][j]) + \"\\t\"\n            }\n            print(line)\n        }\n    }\n\n    func displayDirections() {\n        for j in 0..<y {\n            var line = \"\"\n            for i in 0..<x {\n                line += getDirectionsAsString(maze[i][j]) + \"\\t\"\n            }\n            print(line)\n        }\n    }\n\n    private func getDirectionsAsString(_ value:Int) -> String {\n        var line = \"\"\n        for direction in Direction.allDirections {\n            if (value & direction.rawValue) != 0 {\n                line += direction.char\n            }\n        }\n        return line\n    }\n}\n\n\nlet x = 20\nlet y = 10\nlet maze = MazeGenerator(x, y)\nmaze.display()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Drawing;\n\nnamespace MazeGeneration\n{\n    public static class Extensions\n    {\n        public static IEnumerable<T> Shuffle<T>(this IEnumerable<T> source, Random rng)\n        {\n            var e = source.ToArray();\n            for (var i = e.Length - 1; i >= 0; i--)\n            {\n                var swapIndex = rng.Next(i + 1);\n                yield return e[swapIndex];\n                e[swapIndex] = e[i];\n            }\n        }\n\n        public static CellState OppositeWall(this CellState orig)\n        {\n            return (CellState)(((int) orig >> 2) | ((int) orig << 2)) & CellState.Initial;\n        }\n\n        public static bool HasFlag(this CellState cs,CellState flag)\n        {\n            return ((int)cs & (int)flag) != 0;\n        }\n    }\n\n    [Flags]\n    public enum CellState\n    {\n        Top = 1,\n        Right = 2,\n        Bottom = 4,\n        Left = 8,\n        Visited = 128,\n        Initial = Top | Right | Bottom | Left,\n    }\n\n    public struct RemoveWallAction\n    {\n        public Point Neighbour;\n        public CellState Wall;\n    }\n\n    public class Maze\n    {\n        private readonly CellState[,] _cells;\n        private readonly int _width;\n        private readonly int _height;\n        private readonly Random _rng;\n\n        public Maze(int width, int height)\n        {\n            _width = width;\n            _height = height;\n            _cells = new CellState[width, height];\n            for(var x=0; x<width; x++)\n                for(var y=0; y<height; y++)\n                    _cells[x, y] = CellState.Initial;\n            _rng = new Random();\n            VisitCell(_rng.Next(width), _rng.Next(height));\n        }\n\n        public CellState this[int x, int y]\n        {\n            get { return _cells[x,y]; }\n            set { _cells[x,y] = value; }\n        }\n\n        public IEnumerable<RemoveWallAction> GetNeighbours(Point p)\n        {\n            if (p.X > 0) yield return new RemoveWallAction {Neighbour = new Point(p.X - 1, p.Y), Wall = CellState.Left};\n            if (p.Y > 0) yield return new RemoveWallAction {Neighbour = new Point(p.X, p.Y - 1), Wall = CellState.Top};\n            if (p.X < _width-1) yield return new RemoveWallAction {Neighbour = new Point(p.X + 1, p.Y), Wall = CellState.Right};\n            if (p.Y < _height-1) yield return new RemoveWallAction {Neighbour = new Point(p.X, p.Y + 1), Wall = CellState.Bottom};\n        }\n\n        public void VisitCell(int x, int y)\n        {\n            this[x,y] |= CellState.Visited;\n            foreach (var p in GetNeighbours(new Point(x, y)).Shuffle(_rng).Where(z => !(this[z.Neighbour.X, z.Neighbour.Y].HasFlag(CellState.Visited))))\n            {\n                this[x, y] -= p.Wall;\n                this[p.Neighbour.X, p.Neighbour.Y] -= p.Wall.OppositeWall();\n                VisitCell(p.Neighbour.X, p.Neighbour.Y);\n            }\n        }\n\n        public void Display()\n        {\n            var firstLine = string.Empty;\n            for (var y = 0; y < _height; y++)\n            {\n                var sbTop = new StringBuilder();\n                var sbMid = new StringBuilder();\n                for (var x = 0; x < _width; x++)\n                {\n                    sbTop.Append(this[x, y].HasFlag(CellState.Top) ? \"+---\" : \"+   \");\n                    sbMid.Append(this[x, y].HasFlag(CellState.Left) ? \"|   \" : \"    \");\n                }\n                if (firstLine == string.Empty)\n                    firstLine = \"   \" + sbTop.ToString();\n                Debug.WriteLine(\"   \" + sbTop + \"+\");\n                Debug.WriteLine(\"   \" + sbMid + \"|\");\n            }\n            Debug.WriteLine(firstLine);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var maze = new Maze(20, 20);\n            maze.Display();\n        }\n    }\n}\n"}
{"id": 138894, "name": "Maze generation", "source": "Translate Swift to Java: import Foundation\n\nextension Array {\n    mutating func shuffle() {\n        guard count > 1 else { return }\n\n        for i in 0..<self.count - 1 {\n            let j = Int(arc4random_uniform(UInt32(count - i))) + i\n            guard i != j else { continue }\n            swap(&self[i], &self[j])\n        }\n    }\n}\n\nenum Direction:Int {\n    case north = 1\n    case south = 2\n    case east = 4\n    case west = 8\n\n    static var allDirections:[Direction] {\n        return [Direction.north, Direction.south, Direction.east, Direction.west]\n    }\n\n    var opposite:Direction {\n        switch self {\n        case .north:\n            return .south\n        case .south:\n            return .north\n        case .east:\n            return .west\n        case .west:\n            return .east\n        }\n    }\n\n    var diff:(Int, Int) {\n        switch self {\n        case .north:\n            return (0, -1)\n        case .south:\n            return (0, 1)\n        case .east:\n            return (1, 0)\n        case .west:\n            return (-1, 0)\n        }\n    }\n\n    var char:String {\n        switch self {\n        case .north:\n            return \"N\"\n        case .south:\n            return \"S\"\n        case .east:\n            return \"E\"\n        case .west:\n            return \"W\"\n        }\n    }\n\n}\n\nclass MazeGenerator {\n    let x:Int\n    let y:Int\n    var maze:[[Int]]\n\n    init(_ x:Int, _ y:Int) {\n        self.x  = x\n        self.y = y\n        let column = [Int](repeating: 0, count: y)\n        self.maze = [[Int]](repeating: column, count: x)\n        generateMaze(0, 0)\n    }\n\n    private func generateMaze(_ cx:Int, _ cy:Int) {\n        var directions = Direction.allDirections\n        directions.shuffle()\n        for direction in directions {\n            let (dx, dy) = direction.diff\n            let nx = cx + dx\n            let ny = cy + dy\n            if inBounds(nx, ny) && maze[nx][ny] == 0 {\n                maze[cx][cy] |= direction.rawValue\n                maze[nx][ny] |= direction.opposite.rawValue\n                generateMaze(nx, ny)\n            }\n        }\n    }\n\n    private func inBounds(_ testX:Int, _ testY:Int) -> Bool {\n        return inBounds(value:testX, upper:self.x) && inBounds(value:testY, upper:self.y)\n    }\n\n    private func inBounds(value:Int, upper:Int) -> Bool {\n        return (value >= 0) && (value < upper)\n    }\n\n    func display() {\n        let cellWidth = 3\n        for j in 0..<y {\n            \n            var topEdge = \"\"\n            for i in 0..<x {\n                topEdge += \"+\"\n                topEdge += String(repeating: (maze[i][j] & Direction.north.rawValue) == 0 ? \"-\" : \" \", count: cellWidth)\n            }\n            topEdge += \"+\"\n            print(topEdge)\n\n            \n            var leftEdge = \"\"\n            for i in 0..<x {\n                leftEdge += (maze[i][j] & Direction.west.rawValue) == 0 ? \"|\" : \" \"\n                leftEdge += String(repeating: \" \", count: cellWidth)\n            }\n            leftEdge += \"|\"\n            print(leftEdge)\n        }\n\n        \n        var bottomEdge = \"\"\n        for _ in 0..<x {\n            bottomEdge += \"+\"\n            bottomEdge += String(repeating: \"-\", count: cellWidth)\n        }\n        bottomEdge += \"+\"\n        print(bottomEdge)\n    }\n    \n    func displayInts() {\n        for j in 0..<y {\n            var line = \"\"\n            for i in 0..<x {\n                line += String(maze[i][j]) + \"\\t\"\n            }\n            print(line)\n        }\n    }\n\n    func displayDirections() {\n        for j in 0..<y {\n            var line = \"\"\n            for i in 0..<x {\n                line += getDirectionsAsString(maze[i][j]) + \"\\t\"\n            }\n            print(line)\n        }\n    }\n\n    private func getDirectionsAsString(_ value:Int) -> String {\n        var line = \"\"\n        for direction in Direction.allDirections {\n            if (value & direction.rawValue) != 0 {\n                line += direction.char\n            }\n        }\n        return line\n    }\n}\n\n\nlet x = 20\nlet y = 10\nlet maze = MazeGenerator(x, y)\nmaze.display()\n", "target": "package org.rosettacode;\n\nimport java.util.Collections;\nimport java.util.Arrays;\n\n\npublic class MazeGenerator {\n\tprivate final int x;\n\tprivate final int y;\n\tprivate final int[][] maze;\n\n\tpublic MazeGenerator(int x, int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tmaze = new int[this.x][this.y];\n\t\tgenerateMaze(0, 0);\n\t}\n\n\tpublic void display() {\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tSystem.out.print((maze[j][i] & 1) == 0 ? \"+---\" : \"+   \");\n\t\t\t}\n\t\t\tSystem.out.println(\"+\");\n\t\t\t\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tSystem.out.print((maze[j][i] & 8) == 0 ? \"|   \" : \"    \");\n\t\t\t}\n\t\t\tSystem.out.println(\"|\");\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < x; j++) {\n\t\t\tSystem.out.print(\"+---\");\n\t\t}\n\t\tSystem.out.println(\"+\");\n\t}\n\n\tprivate void generateMaze(int cx, int cy) {\n\t\tDIR[] dirs = DIR.values();\n\t\tCollections.shuffle(Arrays.asList(dirs));\n\t\tfor (DIR dir : dirs) {\n\t\t\tint nx = cx + dir.dx;\n\t\t\tint ny = cy + dir.dy;\n\t\t\tif (between(nx, x) && between(ny, y)\n\t\t\t\t\t&& (maze[nx][ny] == 0)) {\n\t\t\t\tmaze[cx][cy] |= dir.bit;\n\t\t\t\tmaze[nx][ny] |= dir.opposite.bit;\n\t\t\t\tgenerateMaze(nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static boolean between(int v, int upper) {\n\t\treturn (v >= 0) && (v < upper);\n\t}\n\n\tprivate enum DIR {\n\t\tN(1, 0, -1), S(2, 0, 1), E(4, 1, 0), W(8, -1, 0);\n\t\tprivate final int bit;\n\t\tprivate final int dx;\n\t\tprivate final int dy;\n\t\tprivate DIR opposite;\n\n\t\t\n\t\tstatic {\n\t\t\tN.opposite = S;\n\t\t\tS.opposite = N;\n\t\t\tE.opposite = W;\n\t\t\tW.opposite = E;\n\t\t}\n\n\t\tprivate DIR(int bit, int dx, int dy) {\n\t\t\tthis.bit = bit;\n\t\t\tthis.dx = dx;\n\t\t\tthis.dy = dy;\n\t\t}\n\t};\n\n\tpublic static void main(String[] args) {\n\t\tint x = args.length >= 1 ? (Integer.parseInt(args[0])) : 8;\n\t\tint y = args.length == 2 ? (Integer.parseInt(args[1])) : 8;\n\t\tMazeGenerator maze = new MazeGenerator(x, y);\n\t\tmaze.display();\n\t}\n\n}\n"}
{"id": 138895, "name": "Maze generation", "source": "Translate Swift to Python: import Foundation\n\nextension Array {\n    mutating func shuffle() {\n        guard count > 1 else { return }\n\n        for i in 0..<self.count - 1 {\n            let j = Int(arc4random_uniform(UInt32(count - i))) + i\n            guard i != j else { continue }\n            swap(&self[i], &self[j])\n        }\n    }\n}\n\nenum Direction:Int {\n    case north = 1\n    case south = 2\n    case east = 4\n    case west = 8\n\n    static var allDirections:[Direction] {\n        return [Direction.north, Direction.south, Direction.east, Direction.west]\n    }\n\n    var opposite:Direction {\n        switch self {\n        case .north:\n            return .south\n        case .south:\n            return .north\n        case .east:\n            return .west\n        case .west:\n            return .east\n        }\n    }\n\n    var diff:(Int, Int) {\n        switch self {\n        case .north:\n            return (0, -1)\n        case .south:\n            return (0, 1)\n        case .east:\n            return (1, 0)\n        case .west:\n            return (-1, 0)\n        }\n    }\n\n    var char:String {\n        switch self {\n        case .north:\n            return \"N\"\n        case .south:\n            return \"S\"\n        case .east:\n            return \"E\"\n        case .west:\n            return \"W\"\n        }\n    }\n\n}\n\nclass MazeGenerator {\n    let x:Int\n    let y:Int\n    var maze:[[Int]]\n\n    init(_ x:Int, _ y:Int) {\n        self.x  = x\n        self.y = y\n        let column = [Int](repeating: 0, count: y)\n        self.maze = [[Int]](repeating: column, count: x)\n        generateMaze(0, 0)\n    }\n\n    private func generateMaze(_ cx:Int, _ cy:Int) {\n        var directions = Direction.allDirections\n        directions.shuffle()\n        for direction in directions {\n            let (dx, dy) = direction.diff\n            let nx = cx + dx\n            let ny = cy + dy\n            if inBounds(nx, ny) && maze[nx][ny] == 0 {\n                maze[cx][cy] |= direction.rawValue\n                maze[nx][ny] |= direction.opposite.rawValue\n                generateMaze(nx, ny)\n            }\n        }\n    }\n\n    private func inBounds(_ testX:Int, _ testY:Int) -> Bool {\n        return inBounds(value:testX, upper:self.x) && inBounds(value:testY, upper:self.y)\n    }\n\n    private func inBounds(value:Int, upper:Int) -> Bool {\n        return (value >= 0) && (value < upper)\n    }\n\n    func display() {\n        let cellWidth = 3\n        for j in 0..<y {\n            \n            var topEdge = \"\"\n            for i in 0..<x {\n                topEdge += \"+\"\n                topEdge += String(repeating: (maze[i][j] & Direction.north.rawValue) == 0 ? \"-\" : \" \", count: cellWidth)\n            }\n            topEdge += \"+\"\n            print(topEdge)\n\n            \n            var leftEdge = \"\"\n            for i in 0..<x {\n                leftEdge += (maze[i][j] & Direction.west.rawValue) == 0 ? \"|\" : \" \"\n                leftEdge += String(repeating: \" \", count: cellWidth)\n            }\n            leftEdge += \"|\"\n            print(leftEdge)\n        }\n\n        \n        var bottomEdge = \"\"\n        for _ in 0..<x {\n            bottomEdge += \"+\"\n            bottomEdge += String(repeating: \"-\", count: cellWidth)\n        }\n        bottomEdge += \"+\"\n        print(bottomEdge)\n    }\n    \n    func displayInts() {\n        for j in 0..<y {\n            var line = \"\"\n            for i in 0..<x {\n                line += String(maze[i][j]) + \"\\t\"\n            }\n            print(line)\n        }\n    }\n\n    func displayDirections() {\n        for j in 0..<y {\n            var line = \"\"\n            for i in 0..<x {\n                line += getDirectionsAsString(maze[i][j]) + \"\\t\"\n            }\n            print(line)\n        }\n    }\n\n    private func getDirectionsAsString(_ value:Int) -> String {\n        var line = \"\"\n        for direction in Direction.allDirections {\n            if (value & direction.rawValue) != 0 {\n                line += direction.char\n            }\n        }\n        return line\n    }\n}\n\n\nlet x = 20\nlet y = 10\nlet maze = MazeGenerator(x, y)\nmaze.display()\n", "target": "g_size = 10\nbackground_color = color(80, 80, 220)\nrunner = color(255, 50, 50)\nvisited_color = color(220, 240, 240)\ndone_color = color(100, 160, 250)\n\ndef setup():\n    global cell, done, visit, run_cell, c_size\n    size(600, 600)\n    frameRate(20)\n    smooth(4)\n    strokeCap(ROUND)\n    c_size = max(width / g_size, height / g_size)\n    cell = [[None] * g_size for _ in range(g_size)]\n    \n    for i in range(g_size):\n        for j in range(g_size):\n            cell[i][j] = Cell(i, j)\n\n    for i in range(g_size):\n        for j in range(g_size):\n            cell[i][j].add_neighbor()\n\n    run_cell = cell[0][0]\n    visit, done = [], []\n    visit.append(run_cell)\n\n\ndef draw():\n    global run_cell\n    \n    background(background_color)\n    \n    for i in range(g_size):\n        for j in range(g_size):\n            cell[i][j].draw_cell()\n            cell[i][j].draw_wall()\n\n    if len(visit) < g_size * g_size:\n        if run_cell.check_sides():\n            chosen = run_cell.pick_neighbor()\n            done.append(run_cell)\n            run_cell.stacked = True\n            if chosen.i - run_cell.i == 1:\n                run_cell.wall[1] = False\n                chosen.wall[3] = False\n            elif chosen.i - run_cell.i == -1:\n                run_cell.wall[3] = False\n                chosen.wall[1] = False\n            elif chosen.j - run_cell.j == 1:\n                run_cell.wall[2] = False\n                chosen.wall[0] = False\n            else:\n                run_cell.wall[0] = False\n                chosen.wall[2] = False\n            run_cell.current = False\n            run_cell = chosen\n            run_cell.current = True\n            run_cell.visited = True\n        elif done:\n            run_cell.current = False\n            run_cell = done.pop()\n            run_cell.stacked = False\n            run_cell.current = True\n\n\nclass Cell:\n\n    def __init__(self, i, j):\n        self.i = i\n        self.j = j\n        self.wall = [True, True, True, True]\n        self.visited = False\n        self.stacked = False\n        self.current = False\n\n    def pick_neighbor(self):\n        from random import choice\n        unvisited = [nb for nb in self.neighbor\n                          if nb.visited == False]\n        return choice(unvisited)\n\n    def add_neighbor(self):\n        i, j = self.i, self.j\n        neighbor = []\n        if i > 0:\n            neighbor.append(cell[i - 1][j])\n        if i < g_size - 1:\n            neighbor.append(cell[i + 1][j])\n        if j > 0:\n            neighbor.append(cell[i][j - 1])\n        if j < g_size - 1:\n            neighbor.append(cell[i][j + 1])\n        self.neighbor = neighbor\n\n    def check_sides(self):\n        for nb in self.neighbor:\n            if not nb.visited:\n                return True\n        return False\n\n    def draw_cell(self):\n        s = c_size\n        noStroke()\n        noFill()\n        if self.current:\n            fill(runner)\n        elif self.stacked:\n            fill(done_color)\n        elif self.visited:\n            fill(visited_color)\n        rect(self.j * s, self.i * s, s, s)\n\n    def draw_wall(self):\n        i, j = self.i, self.j\n        wall = self.wall\n        stroke(0)\n        strokeWeight(5)\n        if wall[0]: line(j * c_size, i * c_size, j * c_size, (i + 1) * c_size)\n        if wall[1]: line(j * c_size, (i + 1) * c_size, (j + 1) * c_size, (i + 1) * c_size)\n        if wall[2]: line((j + 1) * c_size, (i + 1) * c_size, (j + 1) * c_size, i * c_size)\n        if wall[3]: line((j + 1) * c_size, i * c_size, j * c_size, i * c_size)\n"}
{"id": 139159, "name": "Ordered words", "source": "Translate Swift to C#: import Foundation\n\nguard\n    let url =  NSURL(string: \"http:\n    let input = try? NSString(contentsOfURL: url,encoding: NSUTF8StringEncoding) as String\n    else { exit(EXIT_FAILURE) }\n\nlet words = input.componentsSeparatedByCharactersInSet(NSCharacterSet.newlineCharacterSet())\nlet group: ([Int: [String]], String) -> [Int: [String]] = {\n    var d = $0; let g = d[$1.characters.count] ?? []\n    d[$1.characters.count] = g + [$1]\n    return d\n}\nlet ordered: ([String], String) -> [String] = {\n    guard String($1.characters.sort()) == $1 else { return $0 }\n    return $0 + [$1]\n}\n\nlet groups = words\n    .reduce([String](), combine: ordered)\n    .reduce([Int: [String]](), combine: group)\n\nguard\n    let maxLength = groups.keys.maxElement(),\n    let maxLengthGroup = groups[maxLength]\n    else { exit(EXIT_FAILURE) }\n\nmaxLengthGroup.forEach { print($0) }\n", "target": "using System;\nusing System.Linq;\nusing System.Net;\n\nstatic class Program\n{\n    static void Main(string[] args)\n    {\n        WebClient client = new WebClient();\n        string text = client.DownloadString(\"http:\n        string[] words = text.Split(new char[] { '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries);\n\n        var query = from w in words\n                    where IsOrderedWord(w)\n                    group w by w.Length into ows\n                    orderby ows.Key descending\n                    select ows;\n\n        Console.WriteLine(string.Join(\", \", query.First().ToArray()));\n    }\n\n    private static bool IsOrderedWord(string w)\n    {\n        for (int i = 1; i < w.Length; i++)\n            if (w[i] < w[i - 1])\n                return false;\n\n        return true;\n    }\n}\n"}
{"id": 139161, "name": "Ordered words", "source": "Translate Swift to Java: import Foundation\n\nguard\n    let url =  NSURL(string: \"http:\n    let input = try? NSString(contentsOfURL: url,encoding: NSUTF8StringEncoding) as String\n    else { exit(EXIT_FAILURE) }\n\nlet words = input.componentsSeparatedByCharactersInSet(NSCharacterSet.newlineCharacterSet())\nlet group: ([Int: [String]], String) -> [Int: [String]] = {\n    var d = $0; let g = d[$1.characters.count] ?? []\n    d[$1.characters.count] = g + [$1]\n    return d\n}\nlet ordered: ([String], String) -> [String] = {\n    guard String($1.characters.sort()) == $1 else { return $0 }\n    return $0 + [$1]\n}\n\nlet groups = words\n    .reduce([String](), combine: ordered)\n    .reduce([Int: [String]](), combine: group)\n\nguard\n    let maxLength = groups.keys.maxElement(),\n    let maxLengthGroup = groups[maxLength]\n    else { exit(EXIT_FAILURE) }\n\nmaxLengthGroup.forEach { print($0) }\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Ordered {\n\n\tprivate static boolean isOrderedWord(String word){\n\t\tchar[] sortedWord = word.toCharArray();\n\t\tArrays.sort(sortedWord);\n\t\treturn word.equals(new String(sortedWord));\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tList<String> orderedWords = new LinkedList<String>();\n\t\tBufferedReader in = new BufferedReader(new FileReader(args[0]));\n\t\twhile(in.ready()){\n\t\t\tString word = in.readLine();\n\t\t\tif(isOrderedWord(word)) orderedWords.add(word);\n\t\t}\n\t\tin.close();\n\t\t\n\t\tCollections.<String>sort(orderedWords, new Comparator<String>() {\n\t\t\t@Override\n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\treturn new Integer(o2.length()).compareTo(o1.length());\n\t\t\t}\n\t\t});\n\t\t\n\t\tint maxLen = orderedWords.get(0).length();\n\t\tfor(String word: orderedWords){\n\t\t\tif(word.length() == maxLen){\n\t\t\t\tSystem.out.println(word);\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 139162, "name": "Ordered words", "source": "Translate Swift to Python: import Foundation\n\nguard\n    let url =  NSURL(string: \"http:\n    let input = try? NSString(contentsOfURL: url,encoding: NSUTF8StringEncoding) as String\n    else { exit(EXIT_FAILURE) }\n\nlet words = input.componentsSeparatedByCharactersInSet(NSCharacterSet.newlineCharacterSet())\nlet group: ([Int: [String]], String) -> [Int: [String]] = {\n    var d = $0; let g = d[$1.characters.count] ?? []\n    d[$1.characters.count] = g + [$1]\n    return d\n}\nlet ordered: ([String], String) -> [String] = {\n    guard String($1.characters.sort()) == $1 else { return $0 }\n    return $0 + [$1]\n}\n\nlet groups = words\n    .reduce([String](), combine: ordered)\n    .reduce([Int: [String]](), combine: group)\n\nguard\n    let maxLength = groups.keys.maxElement(),\n    let maxLengthGroup = groups[maxLength]\n    else { exit(EXIT_FAILURE) }\n\nmaxLengthGroup.forEach { print($0) }\n", "target": "import urllib.request\n\nurl = 'http://www.puzzlers.org/pub/wordlists/unixdict.txt'\nwords = urllib.request.urlopen(url).read().decode(\"utf-8\").split()\nordered = [word for word in words if word==''.join(sorted(word))]\nmaxlen = len(max(ordered, key=len))\nmaxorderedwords = [word for word in ordered if len(word) == maxlen]\nprint(' '.join(maxorderedwords))\n"}
{"id": 139398, "name": "Arrays", "source": "Translate Swift to C#: \nvar anyArray = [Any]()\nanyArray.append(\"foo\") \nanyArray.append(1) \nanyArray.removeAtIndex(1) \nanyArray[0] = \"bar\" \n", "target": " int[] numbers = new int[10];\n"}
{"id": 139400, "name": "Arrays", "source": "Translate Swift to Java: \nvar anyArray = [Any]()\nanyArray.append(\"foo\") \nanyArray.append(1) \nanyArray.removeAtIndex(1) \nanyArray[0] = \"bar\" \n", "target": "Int[] literalArray = [1,2,3];\nInt[] fixedLengthArray = new Int[10];\nInt[] variableArray = new Int[];\n\nassert literalArray.size == 3; \nInt n = literalArray[2];       \nfixedLengthArray[4] = 12345;   \n\nfixedLengthArray += 6789;  \nvariableArray    += 6789;  \n"}
{"id": 139401, "name": "Arrays", "source": "Translate Swift to Python: \nvar anyArray = [Any]()\nanyArray.append(\"foo\") \nanyArray.append(1) \nanyArray.removeAtIndex(1) \nanyArray[0] = \"bar\" \n", "target": "array = []\n\narray.append(1)\narray.append(3)\n\narray[0] = 2\n\nprint(array[0])\n"}
{"id": 139855, "name": "Associative array_Merging", "source": "Translate Swift to C#: let base : [String: Any] = [\"name\": \"Rocket Skates\", \"price\": 12.75, \"color\": \"yellow\"]\nlet update : [String: Any] = [\"price\": 15.25, \"color\": \"red\", \"year\": 1974]\n\nlet result = base.merging(update) { (_, new) in new }\n\nprint(result)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        var baseData = new Dictionary<string, object> {\n            [\"name\"] = \"Rocket Skates\",\n            [\"price\"] = 12.75,\n            [\"color\"] = \"yellow\"\n        };\n        var updateData = new Dictionary<string, object> {\n            [\"price\"] = 15.25,\n            [\"color\"] = \"red\",\n            [\"year\"] = 1974\n        };\n        var mergedData = new Dictionary<string, object>();\n        foreach (var entry in baseData.Concat(updateData)) {\n            mergedData[entry.Key] = entry.Value;\n        }\n        foreach (var entry in mergedData) {\n            Console.WriteLine(entry);\n        }\n   }\n}\n"}
{"id": 139856, "name": "Associative array_Merging", "source": "Translate Swift to C#: let base : [String: Any] = [\"name\": \"Rocket Skates\", \"price\": 12.75, \"color\": \"yellow\"]\nlet update : [String: Any] = [\"price\": 15.25, \"color\": \"red\", \"year\": 1974]\n\nlet result = base.merging(update) { (_, new) in new }\n\nprint(result)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        var baseData = new Dictionary<string, object> {\n            [\"name\"] = \"Rocket Skates\",\n            [\"price\"] = 12.75,\n            [\"color\"] = \"yellow\"\n        };\n        var updateData = new Dictionary<string, object> {\n            [\"price\"] = 15.25,\n            [\"color\"] = \"red\",\n            [\"year\"] = 1974\n        };\n        var mergedData = new Dictionary<string, object>();\n        foreach (var entry in baseData.Concat(updateData)) {\n            mergedData[entry.Key] = entry.Value;\n        }\n        foreach (var entry in mergedData) {\n            Console.WriteLine(entry);\n        }\n   }\n}\n"}
{"id": 139859, "name": "Associative array_Merging", "source": "Translate Swift to Java: let base : [String: Any] = [\"name\": \"Rocket Skates\", \"price\": 12.75, \"color\": \"yellow\"]\nlet update : [String: Any] = [\"price\": 15.25, \"color\": \"red\", \"year\": 1974]\n\nlet result = base.merging(update) { (_, new) in new }\n\nprint(result)\n", "target": "import java.util.*;\n\nclass MergeMaps {\n    public static void main(String[] args) {\n        Map<String, Object> base = new HashMap<>();\n        base.put(\"name\", \"Rocket Skates\");\n        base.put(\"price\", 12.75);\n        base.put(\"color\", \"yellow\");\n        Map<String, Object> update = new HashMap<>();\n        update.put(\"price\", 15.25);\n        update.put(\"color\", \"red\");\n        update.put(\"year\", 1974);\n\n        Map<String, Object> result = new HashMap<>(base);\n        result.putAll(update);\n\n        System.out.println(result);\n    }\n}\n"}
{"id": 139860, "name": "Associative array_Merging", "source": "Translate Swift to Java: let base : [String: Any] = [\"name\": \"Rocket Skates\", \"price\": 12.75, \"color\": \"yellow\"]\nlet update : [String: Any] = [\"price\": 15.25, \"color\": \"red\", \"year\": 1974]\n\nlet result = base.merging(update) { (_, new) in new }\n\nprint(result)\n", "target": "import java.util.*;\n\nclass MergeMaps {\n    public static void main(String[] args) {\n        Map<String, Object> base = new HashMap<>();\n        base.put(\"name\", \"Rocket Skates\");\n        base.put(\"price\", 12.75);\n        base.put(\"color\", \"yellow\");\n        Map<String, Object> update = new HashMap<>();\n        update.put(\"price\", 15.25);\n        update.put(\"color\", \"red\");\n        update.put(\"year\", 1974);\n\n        Map<String, Object> result = new HashMap<>(base);\n        result.putAll(update);\n\n        System.out.println(result);\n    }\n}\n"}
{"id": 139861, "name": "Associative array_Merging", "source": "Translate Swift to Python: let base : [String: Any] = [\"name\": \"Rocket Skates\", \"price\": 12.75, \"color\": \"yellow\"]\nlet update : [String: Any] = [\"price\": 15.25, \"color\": \"red\", \"year\": 1974]\n\nlet result = base.merging(update) { (_, new) in new }\n\nprint(result)\n", "target": "base = {\"name\":\"Rocket Skates\", \"price\":12.75, \"color\":\"yellow\"}\nupdate = {\"price\":15.25, \"color\":\"red\", \"year\":1974}\n\nresult = {**base, **update}\n\nprint(result)\n"}
{"id": 139862, "name": "Associative array_Merging", "source": "Translate Swift to Python: let base : [String: Any] = [\"name\": \"Rocket Skates\", \"price\": 12.75, \"color\": \"yellow\"]\nlet update : [String: Any] = [\"price\": 15.25, \"color\": \"red\", \"year\": 1974]\n\nlet result = base.merging(update) { (_, new) in new }\n\nprint(result)\n", "target": "base = {\"name\":\"Rocket Skates\", \"price\":12.75, \"color\":\"yellow\"}\nupdate = {\"price\":15.25, \"color\":\"red\", \"year\":1974}\n\nresult = {**base, **update}\n\nprint(result)\n"}
{"id": 140129, "name": "Associative array_Iteration", "source": "Translate Swift to C#: let myMap = [\n\t   \"hello\": 13,\n\t   \"world\": 31,\n\t   \"!\"    : 71 ]\n\n\nfor (key, value) in myMap {\n\tprint(\"key = \\(key), value = \\(value)\")\n}\n\nfor key in myMap.keys\n{\n\tprint(\"key = \\(key)\")\n}\n\nfor value in myMap.values\n{\n\tprint(\"value = \\(value)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace AssocArrays\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n\n            Dictionary<string,int> assocArray = new Dictionary<string,int>();\n\n            assocArray[\"Hello\"] = 1;\n            assocArray.Add(\"World\", 2);\n            assocArray[\"!\"] = 3;\n\n            foreach (KeyValuePair<string, int> kvp in assocArray)\n            {\n                Console.WriteLine(kvp.Key + \"\u00a0: \" + kvp.Value);\n            }\n\n            foreach (string key in assocArray.Keys)\n            {\n                Console.WriteLine(key);\n            }\n\n            foreach (int val in assocArray.Values)\n            {\n                Console.WriteLine(val.ToString());\n            }\n        }\n    }\n}\n"}
{"id": 140131, "name": "Associative array_Iteration", "source": "Translate Swift to Java: let myMap = [\n\t   \"hello\": 13,\n\t   \"world\": 31,\n\t   \"!\"    : 71 ]\n\n\nfor (key, value) in myMap {\n\tprint(\"key = \\(key), value = \\(value)\")\n}\n\nfor key in myMap.keys\n{\n\tprint(\"key = \\(key)\")\n}\n\nfor value in myMap.values\n{\n\tprint(\"value = \\(value)\")\n}\n", "target": "Map<String, Integer> map = new HashMap<String, Integer>();\nmap.put(\"hello\", 1);\nmap.put(\"world\", 2);\nmap.put(\"!\", 3);\n\n\nfor (Map.Entry<String, Integer> e : map.entrySet()) {\n    String key = e.getKey();\n    Integer value = e.getValue();\n    System.out.println(\"key = \" + key + \", value = \" + value);\n}\n\n\nfor (String key : map.keySet()) {\n    System.out.println(\"key = \" + key);\n}\n\n\nfor (Integer value : map.values()) {\n    System.out.println(\"value = \" + value);\n}\n"}
{"id": 140132, "name": "Associative array_Iteration", "source": "Translate Swift to Python: let myMap = [\n\t   \"hello\": 13,\n\t   \"world\": 31,\n\t   \"!\"    : 71 ]\n\n\nfor (key, value) in myMap {\n\tprint(\"key = \\(key), value = \\(value)\")\n}\n\nfor key in myMap.keys\n{\n\tprint(\"key = \\(key)\")\n}\n\nfor value in myMap.values\n{\n\tprint(\"value = \\(value)\")\n}\n", "target": "myDict = { \"hello\": 13,\n\t   \"world\": 31,\n\t   \"!\"    : 71 }\n\n\nfor key, value in myDict.items():\n    print (\"key = %s, value = %s\" % (key, value))\n\n\nfor key in myDict:\n    print (\"key = %s\" % key)\n\nfor key in myDict.keys():\n    print (\"key = %s\" % key)\n\n\nfor value in myDict.values():\n    print (\"value = %s\" % value)\n"}
{"id": 140471, "name": "Knapsack problem_0-1", "source": "Translate Swift to C#: struct KnapsackItem {\n  var name: String\n  var weight: Int\n  var value: Int\n}\n\nfunc knapsack(items: [KnapsackItem], limit: Int) -> [KnapsackItem] {\n  var table = Array(repeating: Array(repeating: 0, count: limit + 1), count: items.count + 1)\n  \n  for j in 1..<items.count+1 {\n    let item = items[j-1]\n    \n    for w in 1..<limit+1 {\n      if item.weight > w {\n        table[j][w] = table[j-1][w]\n      } else {\n        table[j][w] = max(table[j-1][w], table[j-1][w-item.weight] + item.value)\n      }\n    }\n  }\n  \n  var result = [KnapsackItem]()\n  var w = limit\n  \n  for j in stride(from: items.count, to: 0, by: -1) where table[j][w] != table[j-1][w] {\n    let item = items[j-1]\n    \n    result.append(item)\n    \n    w -= item.weight\n  }\n  \n  return result\n}\n\nlet items = [\n  KnapsackItem(name: \"map\", weight: 9, value: 150), KnapsackItem(name: \"compass\", weight: 13, value: 35),\n  KnapsackItem(name: \"water\", weight: 153, value: 200), KnapsackItem(name: \"sandwich\", weight: 50, value: 160),\n  KnapsackItem(name: \"glucose\", weight: 15, value: 60), KnapsackItem(name: \"tin\", weight: 68, value: 45),\n  KnapsackItem(name: \"banana\", weight: 27, value: 60), KnapsackItem(name: \"apple\", weight: 39, value: 40),\n  KnapsackItem(name: \"cheese\", weight: 23, value: 30), KnapsackItem(name: \"beer\", weight: 52, value: 10),\n  KnapsackItem(name: \"suntan cream\", weight: 11, value: 70), KnapsackItem(name: \"camera\", weight: 32, value: 30),\n  KnapsackItem(name: \"t-shirt\", weight: 24, value: 15), KnapsackItem(name: \"trousers\", weight: 48, value: 10),\n  KnapsackItem(name: \"umbrella\", weight: 73, value: 40), KnapsackItem(name: \"waterproof trousers\", weight: 42, value: 70),\n  KnapsackItem(name: \"waterproof overclothes\", weight: 43, value: 75), KnapsackItem(name: \"note-case\", weight: 22, value: 80),\n  KnapsackItem(name: \"sunglasses\", weight: 7, value: 20), KnapsackItem(name: \"towel\", weight: 18, value: 12),\n  KnapsackItem(name: \"socks\", weight: 4, value: 50), KnapsackItem(name: \"book\", weight: 30, value: 10)\n]\n\nlet kept = knapsack(items: items, limit: 400)\n\nprint(\"Kept: \")\n\nfor item in kept {\n  print(\"  \\(item.name)\")\n}\n\nlet (tValue, tWeight) = kept.reduce((0, 0), { ($0.0 + $1.value, $0.1 + $1.weight) })\n\nprint(\"For a total value of \\(tValue) and a total weight of \\(tWeight)\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Tests_With_Framework_4\n{\n\nclass Bag : IEnumerable<Bag.Item>\n        {\n            List<Item> items;\n            const int MaxWeightAllowed = 400;\n\n            public Bag()\n            {\n                items = new List<Item>();\n            }\n\n            void AddItem(Item i)\n            {\n                if ((TotalWeight + i.Weight) <= MaxWeightAllowed)\n                    items.Add(i);\n            }\n\n            public void Calculate(List<Item> items)\n            {\n                foreach (Item i in Sorte(items))\n                {\n                    AddItem(i);\n                }\n            }\n\n            List<Item> Sorte(List<Item> inputItems)\n            {\n                List<Item> choosenItems = new List<Item>();\n                for (int i = 0; i < inputItems.Count; i++)\n                {\n                    int j = -1;\n                    if (i == 0)\n                    {\n                        choosenItems.Add(inputItems[i]);\n                    }\n                    if (i > 0)\n                    {\n                        if (!RecursiveF(inputItems, choosenItems, i, choosenItems.Count - 1, false, ref j))\n                        {\n                            choosenItems.Add(inputItems[i]);\n                        }\n                    }\n                }\n                return choosenItems;\n            }\n\n            bool RecursiveF(List<Item> knapsackItems, List<Item> choosenItems, int i, int lastBound, bool dec, ref int indxToAdd)\n            {\n                if (!(lastBound < 0))\n                {\n                    if ( knapsackItems[i].ResultWV < choosenItems[lastBound].ResultWV )\n                    {\n                        indxToAdd = lastBound;\n                    }\n                    return RecursiveF(knapsackItems, choosenItems, i, lastBound - 1, true, ref indxToAdd);\n                }\n                if (indxToAdd > -1)\n                {\n                    choosenItems.Insert(indxToAdd, knapsackItems[i]);\n                    return true;\n                }\n                return false;\n            }\n\n            #region IEnumerable<Item> Members\n            IEnumerator<Item> IEnumerable<Item>.GetEnumerator()\n            {\n                foreach (Item i in items)\n                    yield return i;\n            }\n            #endregion\n\n            #region IEnumerable Members\n            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()\n            {\n                return items.GetEnumerator();\n            }\n            #endregion\n\n            public int TotalWeight\n            {\n                get\n                {\n                    var sum = 0;\n                    foreach (Item i in this)\n                    {\n                        sum += i.Weight;\n                    }\n                    return sum;\n                }\n            }\n\n            public class Item\n            {\n                public string Name { get; set; } public int Weight { get; set; } public int Value { get; set; } public int ResultWV { get { return  Weight-Value; } }\n                public override string ToString()\n                {\n                    return \"Name\u00a0: \" + Name + \"        Wieght\u00a0: \" + Weight + \"       Value\u00a0: \" + Value + \"     ResultWV\u00a0: \" + ResultWV;\n                }\n            }\n        }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {List<Bag.Item> knapsackItems = new List<Bag.Item>();\n            knapsackItems.Add(new Bag.Item() { Name = \"Map\", Weight = 9, Value = 150 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Water\", Weight = 153, Value = 200 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Compass\", Weight = 13, Value = 35 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Sandwitch\", Weight = 50, Value = 160 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Glucose\", Weight = 15, Value = 60 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Tin\", Weight = 68, Value = 45 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Banana\", Weight = 27, Value = 60 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Apple\", Weight = 39, Value = 40 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Cheese\", Weight = 23, Value = 30 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Beer\", Weight = 52, Value = 10 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Suntan Cream\", Weight = 11, Value = 70 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Camera\", Weight = 32, Value = 30 });\n            knapsackItems.Add(new Bag.Item() { Name = \"T-shirt\", Weight = 24, Value = 15 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Trousers\", Weight = 48, Value = 10 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Umbrella\", Weight = 73, Value = 40 });\n            knapsackItems.Add(new Bag.Item() { Name = \"WaterProof Trousers\", Weight = 42, Value = 70 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Note-Case\", Weight = 22, Value = 80 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Sunglasses\", Weight = 7, Value = 20 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Towel\", Weight = 18, Value = 12 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Socks\", Weight = 4, Value = 50 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Book\", Weight = 30, Value = 10 });\n            knapsackItems.Add(new Bag.Item() { Name = \"waterproof overclothes \", Weight = 43, Value = 75 });\n\n            Bag b = new Bag();\n            b.Calculate(knapsackItems);\n            b.All(x => { Console.WriteLine(x); return true; });\n            Console.WriteLine(b.Sum(x => x.Weight));\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 140473, "name": "Knapsack problem_0-1", "source": "Translate Swift to Java: struct KnapsackItem {\n  var name: String\n  var weight: Int\n  var value: Int\n}\n\nfunc knapsack(items: [KnapsackItem], limit: Int) -> [KnapsackItem] {\n  var table = Array(repeating: Array(repeating: 0, count: limit + 1), count: items.count + 1)\n  \n  for j in 1..<items.count+1 {\n    let item = items[j-1]\n    \n    for w in 1..<limit+1 {\n      if item.weight > w {\n        table[j][w] = table[j-1][w]\n      } else {\n        table[j][w] = max(table[j-1][w], table[j-1][w-item.weight] + item.value)\n      }\n    }\n  }\n  \n  var result = [KnapsackItem]()\n  var w = limit\n  \n  for j in stride(from: items.count, to: 0, by: -1) where table[j][w] != table[j-1][w] {\n    let item = items[j-1]\n    \n    result.append(item)\n    \n    w -= item.weight\n  }\n  \n  return result\n}\n\nlet items = [\n  KnapsackItem(name: \"map\", weight: 9, value: 150), KnapsackItem(name: \"compass\", weight: 13, value: 35),\n  KnapsackItem(name: \"water\", weight: 153, value: 200), KnapsackItem(name: \"sandwich\", weight: 50, value: 160),\n  KnapsackItem(name: \"glucose\", weight: 15, value: 60), KnapsackItem(name: \"tin\", weight: 68, value: 45),\n  KnapsackItem(name: \"banana\", weight: 27, value: 60), KnapsackItem(name: \"apple\", weight: 39, value: 40),\n  KnapsackItem(name: \"cheese\", weight: 23, value: 30), KnapsackItem(name: \"beer\", weight: 52, value: 10),\n  KnapsackItem(name: \"suntan cream\", weight: 11, value: 70), KnapsackItem(name: \"camera\", weight: 32, value: 30),\n  KnapsackItem(name: \"t-shirt\", weight: 24, value: 15), KnapsackItem(name: \"trousers\", weight: 48, value: 10),\n  KnapsackItem(name: \"umbrella\", weight: 73, value: 40), KnapsackItem(name: \"waterproof trousers\", weight: 42, value: 70),\n  KnapsackItem(name: \"waterproof overclothes\", weight: 43, value: 75), KnapsackItem(name: \"note-case\", weight: 22, value: 80),\n  KnapsackItem(name: \"sunglasses\", weight: 7, value: 20), KnapsackItem(name: \"towel\", weight: 18, value: 12),\n  KnapsackItem(name: \"socks\", weight: 4, value: 50), KnapsackItem(name: \"book\", weight: 30, value: 10)\n]\n\nlet kept = knapsack(items: items, limit: 400)\n\nprint(\"Kept: \")\n\nfor item in kept {\n  print(\"  \\(item.name)\")\n}\n\nlet (tValue, tWeight) = kept.reduce((0, 0), { ($0.0 + $1.value, $0.1 + $1.weight) })\n\nprint(\"For a total value of \\(tValue) and a total weight of \\(tWeight)\")\n", "target": "package hu.pj.alg.test;\n\nimport hu.pj.alg.ZeroOneKnapsack;\nimport hu.pj.obj.Item;\nimport java.util.*;\nimport java.text.*;\n\npublic class ZeroOneKnapsackForTourists {\n\n    public ZeroOneKnapsackForTourists() {\n        ZeroOneKnapsack zok = new ZeroOneKnapsack(400); \n\n        \n        zok.add(\"map\", 9, 150);\n        zok.add(\"compass\", 13, 35);\n        zok.add(\"water\", 153, 200);\n        zok.add(\"sandwich\", 50, 160);\n        zok.add(\"glucose\", 15, 60);\n        zok.add(\"tin\", 68, 45);\n        zok.add(\"banana\", 27, 60);\n        zok.add(\"apple\", 39, 40);\n        zok.add(\"cheese\", 23, 30);\n        zok.add(\"beer\", 52, 10);\n        zok.add(\"suntan cream\", 11, 70);\n        zok.add(\"camera\", 32, 30);\n        zok.add(\"t-shirt\", 24, 15);\n        zok.add(\"trousers\", 48, 10);\n        zok.add(\"umbrella\", 73, 40);\n        zok.add(\"waterproof trousers\", 42, 70);\n        zok.add(\"waterproof overclothes\", 43, 75);\n        zok.add(\"note-case\", 22, 80);\n        zok.add(\"sunglasses\", 7, 20);\n        zok.add(\"towel\", 18, 12);\n        zok.add(\"socks\", 4, 50);\n        zok.add(\"book\", 30, 10);\n\n        \n        List<Item> itemList = zok.calcSolution();\n\n        \n        if (zok.isCalculated()) {\n            NumberFormat nf  = NumberFormat.getInstance();\n\n            System.out.println(\n                \"Maximal weight           = \" +\n                nf.format(zok.getMaxWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total weight of solution = \" +\n                nf.format(zok.getSolutionWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total value              = \" +\n                zok.getProfit()\n            );\n            System.out.println();\n            System.out.println(\n                \"You can carry the following materials \" +\n                \"in the knapsack:\"\n            );\n            for (Item item : itemList) {\n                if (item.getInKnapsack() == 1) {\n                    System.out.format(\n                        \"%1$-23s %2$-3s %3$-5s %4$-15s \\n\",\n                        item.getName(),\n                        item.getWeight(), \"dag  \",\n                        \"(value = \" + item.getValue() + \")\"\n                    );\n                }\n            }\n        } else {\n            System.out.println(\n                \"The problem is not solved. \" +\n                \"Maybe you gave wrong data.\"\n            );\n        }\n\n    }\n\n    public static void main(String[] args) {\n        new ZeroOneKnapsackForTourists();\n    }\n\n} \n"}
{"id": 140474, "name": "Knapsack problem_0-1", "source": "Translate Swift to Python: struct KnapsackItem {\n  var name: String\n  var weight: Int\n  var value: Int\n}\n\nfunc knapsack(items: [KnapsackItem], limit: Int) -> [KnapsackItem] {\n  var table = Array(repeating: Array(repeating: 0, count: limit + 1), count: items.count + 1)\n  \n  for j in 1..<items.count+1 {\n    let item = items[j-1]\n    \n    for w in 1..<limit+1 {\n      if item.weight > w {\n        table[j][w] = table[j-1][w]\n      } else {\n        table[j][w] = max(table[j-1][w], table[j-1][w-item.weight] + item.value)\n      }\n    }\n  }\n  \n  var result = [KnapsackItem]()\n  var w = limit\n  \n  for j in stride(from: items.count, to: 0, by: -1) where table[j][w] != table[j-1][w] {\n    let item = items[j-1]\n    \n    result.append(item)\n    \n    w -= item.weight\n  }\n  \n  return result\n}\n\nlet items = [\n  KnapsackItem(name: \"map\", weight: 9, value: 150), KnapsackItem(name: \"compass\", weight: 13, value: 35),\n  KnapsackItem(name: \"water\", weight: 153, value: 200), KnapsackItem(name: \"sandwich\", weight: 50, value: 160),\n  KnapsackItem(name: \"glucose\", weight: 15, value: 60), KnapsackItem(name: \"tin\", weight: 68, value: 45),\n  KnapsackItem(name: \"banana\", weight: 27, value: 60), KnapsackItem(name: \"apple\", weight: 39, value: 40),\n  KnapsackItem(name: \"cheese\", weight: 23, value: 30), KnapsackItem(name: \"beer\", weight: 52, value: 10),\n  KnapsackItem(name: \"suntan cream\", weight: 11, value: 70), KnapsackItem(name: \"camera\", weight: 32, value: 30),\n  KnapsackItem(name: \"t-shirt\", weight: 24, value: 15), KnapsackItem(name: \"trousers\", weight: 48, value: 10),\n  KnapsackItem(name: \"umbrella\", weight: 73, value: 40), KnapsackItem(name: \"waterproof trousers\", weight: 42, value: 70),\n  KnapsackItem(name: \"waterproof overclothes\", weight: 43, value: 75), KnapsackItem(name: \"note-case\", weight: 22, value: 80),\n  KnapsackItem(name: \"sunglasses\", weight: 7, value: 20), KnapsackItem(name: \"towel\", weight: 18, value: 12),\n  KnapsackItem(name: \"socks\", weight: 4, value: 50), KnapsackItem(name: \"book\", weight: 30, value: 10)\n]\n\nlet kept = knapsack(items: items, limit: 400)\n\nprint(\"Kept: \")\n\nfor item in kept {\n  print(\"  \\(item.name)\")\n}\n\nlet (tValue, tWeight) = kept.reduce((0, 0), { ($0.0 + $1.value, $0.1 + $1.weight) })\n\nprint(\"For a total value of \\(tValue) and a total weight of \\(tWeight)\")\n", "target": "from itertools import combinations\n\ndef anycomb(items):\n    ' return combinations of any length from the items '\n    return ( comb\n             for r in range(1, len(items)+1)\n             for comb in combinations(items, r)\n             )\n\ndef totalvalue(comb):\n    ' Totalise a particular combination of items'\n    totwt = totval = 0\n    for item, wt, val in comb:\n        totwt  += wt\n        totval += val\n    return (totval, -totwt) if totwt <= 400 else (0, 0)\n\nitems = (\n    (\"map\", 9, 150), (\"compass\", 13, 35), (\"water\", 153, 200), (\"sandwich\", 50, 160),\n    (\"glucose\", 15, 60), (\"tin\", 68, 45), (\"banana\", 27, 60), (\"apple\", 39, 40),\n    (\"cheese\", 23, 30), (\"beer\", 52, 10), (\"suntan cream\", 11, 70), (\"camera\", 32, 30),\n    (\"t-shirt\", 24, 15), (\"trousers\", 48, 10), (\"umbrella\", 73, 40),\n    (\"waterproof trousers\", 42, 70), (\"waterproof overclothes\", 43, 75),\n    (\"note-case\", 22, 80), (\"sunglasses\", 7, 20), (\"towel\", 18, 12),\n    (\"socks\", 4, 50), (\"book\", 30, 10),\n    )\nbagged = max( anycomb(items), key=totalvalue) \nprint(\"Bagged the following items\\n  \" +\n      '\\n  '.join(sorted(item for item,_,_ in bagged)))\nval, wt = totalvalue(bagged)\nprint(\"for a total value of %i and a total weight of %i\" % (val, -wt))\n"}
{"id": 140948, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Swift to C#: func doSqnc(m:Int) {\n    var aList = [Int](count: m + 1, repeatedValue: 0)\n    var k1 = 2\n    var lg2 = 1\n    var amax:Double = 0\n    aList[0] = 1\n    aList[1] = 1\n    \n    var v = aList[2]\n    \n    for n in 2...m {\n        let add = aList[v] + aList[n - v]\n        aList[n] = add\n        v = aList[n]\n        \n        if amax < Double(v) * 1.0 / Double(n) {\n            amax = Double(v) * 1.0 / Double(n)\n        }\n        \n        if (k1 & n == 0) {\n            println(\"Maximum between 2^\\(lg2) and 2^\\(lg2 + 1) was \\(amax)\")\n            amax = 0\n            lg2++\n        }\n        k1 = n\n    }\n}\n\ndoSqnc(1 << 20)\n", "target": "using System;\nusing System.Linq;\n\nnamespace HofstadterConway\n{\n    class Program\n    {\n        static int[] GenHofstadterConway(int max)\n        {\n            int[] result = new int[max];\n            result[0]=result[1]=1;\n            for (int ix = 2; ix < max; ix++)\n                result[ix] = result[result[ix - 1] - 1] + result[ix - result[ix - 1]];\n            return result;\n        }\n\n        static void Main(string[] args)\n        {\n            double[] adiv = new double[1 << 20];\n            {\n                int[] a = GenHofstadterConway(1 << 20);\n                for (int i = 0; i < 1 << 20; i++)\n                    adiv[i] = a[i] / (double)(i + 1);\n            }\n            for (int p = 2; p <= 20; p++)\n            {\n                var max = Enumerable.Range(\n                     (1 << (p - 1)) - 1,\n                     (1 << p) - (1 << (p - 1))\n                     )\n                     .Select(ix => new { I = ix + 1, A = adiv[ix] })\n                     .OrderByDescending(x => x.A)\n                     .First();\n                Console.WriteLine(\"Maximum from 2^{0} to 2^{1} is {2} at {3}\",\n                    p - 1, p, max.A, max.I);\n            }\n            Console.WriteLine(\"The winning number is {0}.\",\n                Enumerable.Range(0, 1 << 20)\n                    .Last(i => (adiv[i] > 0.55)) + 1\n                );\n        }\n    }\n}\n"}
{"id": 140949, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Swift to C#: func doSqnc(m:Int) {\n    var aList = [Int](count: m + 1, repeatedValue: 0)\n    var k1 = 2\n    var lg2 = 1\n    var amax:Double = 0\n    aList[0] = 1\n    aList[1] = 1\n    \n    var v = aList[2]\n    \n    for n in 2...m {\n        let add = aList[v] + aList[n - v]\n        aList[n] = add\n        v = aList[n]\n        \n        if amax < Double(v) * 1.0 / Double(n) {\n            amax = Double(v) * 1.0 / Double(n)\n        }\n        \n        if (k1 & n == 0) {\n            println(\"Maximum between 2^\\(lg2) and 2^\\(lg2 + 1) was \\(amax)\")\n            amax = 0\n            lg2++\n        }\n        k1 = n\n    }\n}\n\ndoSqnc(1 << 20)\n", "target": "using System;\nusing System.Linq;\n\nnamespace HofstadterConway\n{\n    class Program\n    {\n        static int[] GenHofstadterConway(int max)\n        {\n            int[] result = new int[max];\n            result[0]=result[1]=1;\n            for (int ix = 2; ix < max; ix++)\n                result[ix] = result[result[ix - 1] - 1] + result[ix - result[ix - 1]];\n            return result;\n        }\n\n        static void Main(string[] args)\n        {\n            double[] adiv = new double[1 << 20];\n            {\n                int[] a = GenHofstadterConway(1 << 20);\n                for (int i = 0; i < 1 << 20; i++)\n                    adiv[i] = a[i] / (double)(i + 1);\n            }\n            for (int p = 2; p <= 20; p++)\n            {\n                var max = Enumerable.Range(\n                     (1 << (p - 1)) - 1,\n                     (1 << p) - (1 << (p - 1))\n                     )\n                     .Select(ix => new { I = ix + 1, A = adiv[ix] })\n                     .OrderByDescending(x => x.A)\n                     .First();\n                Console.WriteLine(\"Maximum from 2^{0} to 2^{1} is {2} at {3}\",\n                    p - 1, p, max.A, max.I);\n            }\n            Console.WriteLine(\"The winning number is {0}.\",\n                Enumerable.Range(0, 1 << 20)\n                    .Last(i => (adiv[i] > 0.55)) + 1\n                );\n        }\n    }\n}\n"}
{"id": 140952, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Swift to Java: func doSqnc(m:Int) {\n    var aList = [Int](count: m + 1, repeatedValue: 0)\n    var k1 = 2\n    var lg2 = 1\n    var amax:Double = 0\n    aList[0] = 1\n    aList[1] = 1\n    \n    var v = aList[2]\n    \n    for n in 2...m {\n        let add = aList[v] + aList[n - v]\n        aList[n] = add\n        v = aList[n]\n        \n        if amax < Double(v) * 1.0 / Double(n) {\n            amax = Double(v) * 1.0 / Double(n)\n        }\n        \n        if (k1 & n == 0) {\n            println(\"Maximum between 2^\\(lg2) and 2^\\(lg2 + 1) was \\(amax)\")\n            amax = 0\n            lg2++\n        }\n        k1 = n\n    }\n}\n\ndoSqnc(1 << 20)\n", "target": "\n\npublic class HofstadterConwaySequence {\n\n    private static int MAX = (int) Math.pow(2, 20) + 1;\n    private static int[] HCS = new int[MAX];\n    static {\n        HCS[1] = 1;\n        HCS[2] = 1;\n        for ( int n = 3 ; n < MAX ; n++ ) {\n            int nm1 = HCS[n - 1];\n            HCS[n] = HCS[nm1] + HCS[n - nm1];\n        }\n    }\n    \n    public static void main(String[] args) {\n        int mNum = 0;\n        for ( int m = 1 ; m < 20 ; m++ ) {\n            int min = (int) Math.pow(2, m);\n            int max = min * 2;\n            double maxRatio = 0.0;\n            int nVal = 0;\n            for ( int n = min ; n <= max ; n ++ ) {\n                double ratio = (double) HCS[n] / n;\n                if ( ratio > maxRatio ) {\n                    maxRatio = Math.max(ratio,  maxRatio);\n                    nVal = n;\n                }\n                if ( ratio >= 0.55 ) {\n                    mNum = n;\n                }\n            }\n            System.out.printf(\"Max ratio between 2^%d and 2^%d is %f at n =\u00a0%,d%n\", m, m+1, maxRatio, nVal);\n        }\n        System.out.printf(\"Mallow's number is %d.%n\", mNum);\n    }\n\n}\n"}
{"id": 140953, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Swift to Java: func doSqnc(m:Int) {\n    var aList = [Int](count: m + 1, repeatedValue: 0)\n    var k1 = 2\n    var lg2 = 1\n    var amax:Double = 0\n    aList[0] = 1\n    aList[1] = 1\n    \n    var v = aList[2]\n    \n    for n in 2...m {\n        let add = aList[v] + aList[n - v]\n        aList[n] = add\n        v = aList[n]\n        \n        if amax < Double(v) * 1.0 / Double(n) {\n            amax = Double(v) * 1.0 / Double(n)\n        }\n        \n        if (k1 & n == 0) {\n            println(\"Maximum between 2^\\(lg2) and 2^\\(lg2 + 1) was \\(amax)\")\n            amax = 0\n            lg2++\n        }\n        k1 = n\n    }\n}\n\ndoSqnc(1 << 20)\n", "target": "\n\npublic class HofstadterConwaySequence {\n\n    private static int MAX = (int) Math.pow(2, 20) + 1;\n    private static int[] HCS = new int[MAX];\n    static {\n        HCS[1] = 1;\n        HCS[2] = 1;\n        for ( int n = 3 ; n < MAX ; n++ ) {\n            int nm1 = HCS[n - 1];\n            HCS[n] = HCS[nm1] + HCS[n - nm1];\n        }\n    }\n    \n    public static void main(String[] args) {\n        int mNum = 0;\n        for ( int m = 1 ; m < 20 ; m++ ) {\n            int min = (int) Math.pow(2, m);\n            int max = min * 2;\n            double maxRatio = 0.0;\n            int nVal = 0;\n            for ( int n = min ; n <= max ; n ++ ) {\n                double ratio = (double) HCS[n] / n;\n                if ( ratio > maxRatio ) {\n                    maxRatio = Math.max(ratio,  maxRatio);\n                    nVal = n;\n                }\n                if ( ratio >= 0.55 ) {\n                    mNum = n;\n                }\n            }\n            System.out.printf(\"Max ratio between 2^%d and 2^%d is %f at n =\u00a0%,d%n\", m, m+1, maxRatio, nVal);\n        }\n        System.out.printf(\"Mallow's number is %d.%n\", mNum);\n    }\n\n}\n"}
{"id": 140954, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Swift to Python: func doSqnc(m:Int) {\n    var aList = [Int](count: m + 1, repeatedValue: 0)\n    var k1 = 2\n    var lg2 = 1\n    var amax:Double = 0\n    aList[0] = 1\n    aList[1] = 1\n    \n    var v = aList[2]\n    \n    for n in 2...m {\n        let add = aList[v] + aList[n - v]\n        aList[n] = add\n        v = aList[n]\n        \n        if amax < Double(v) * 1.0 / Double(n) {\n            amax = Double(v) * 1.0 / Double(n)\n        }\n        \n        if (k1 & n == 0) {\n            println(\"Maximum between 2^\\(lg2) and 2^\\(lg2 + 1) was \\(amax)\")\n            amax = 0\n            lg2++\n        }\n        k1 = n\n    }\n}\n\ndoSqnc(1 << 20)\n", "target": "from __future__ import division\n\ndef maxandmallows(nmaxpower2):\n    nmax = 2**nmaxpower2\n    mx = (0.5, 2)\n    mxpow2 = []\n    mallows = None\n\n    \n    \n    hc = [None, 1, 1]\n\n    for n in range(2, nmax + 1):\n        ratio = hc[n] / n\n        if ratio > mx[0]:\n            mx = (ratio, n)\n        if ratio >= 0.55:\n            mallows = n\n        if ratio == 0.5:\n            print(\"In the region %7i < n <= %7i: max a(n)/n = %6.4f at  n = %i\" %\n\t\t  (n//2, n, mx[0], mx[1]))\n            mxpow2.append(mx[0])\n            mx = (ratio, n)\n        hc.append(hc[hc[n]] + hc[-hc[n]])\n\n    return hc, mallows if mxpow2 and mxpow2[-1] < 0.55 and n > 4 else None\n\nif __name__ == '__main__':\n    hc, mallows = maxandmallows(20)\n    if mallows:\n        print(\"\\nYou too might have won $1000 with the mallows number of %i\" % mallows)\n"}
{"id": 140955, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Swift to Python: func doSqnc(m:Int) {\n    var aList = [Int](count: m + 1, repeatedValue: 0)\n    var k1 = 2\n    var lg2 = 1\n    var amax:Double = 0\n    aList[0] = 1\n    aList[1] = 1\n    \n    var v = aList[2]\n    \n    for n in 2...m {\n        let add = aList[v] + aList[n - v]\n        aList[n] = add\n        v = aList[n]\n        \n        if amax < Double(v) * 1.0 / Double(n) {\n            amax = Double(v) * 1.0 / Double(n)\n        }\n        \n        if (k1 & n == 0) {\n            println(\"Maximum between 2^\\(lg2) and 2^\\(lg2 + 1) was \\(amax)\")\n            amax = 0\n            lg2++\n        }\n        k1 = n\n    }\n}\n\ndoSqnc(1 << 20)\n", "target": "from __future__ import division\n\ndef maxandmallows(nmaxpower2):\n    nmax = 2**nmaxpower2\n    mx = (0.5, 2)\n    mxpow2 = []\n    mallows = None\n\n    \n    \n    hc = [None, 1, 1]\n\n    for n in range(2, nmax + 1):\n        ratio = hc[n] / n\n        if ratio > mx[0]:\n            mx = (ratio, n)\n        if ratio >= 0.55:\n            mallows = n\n        if ratio == 0.5:\n            print(\"In the region %7i < n <= %7i: max a(n)/n = %6.4f at  n = %i\" %\n\t\t  (n//2, n, mx[0], mx[1]))\n            mxpow2.append(mx[0])\n            mx = (ratio, n)\n        hc.append(hc[hc[n]] + hc[-hc[n]])\n\n    return hc, mallows if mxpow2 and mxpow2[-1] < 0.55 and n > 4 else None\n\nif __name__ == '__main__':\n    hc, mallows = maxandmallows(20)\n    if mallows:\n        print(\"\\nYou too might have won $1000 with the mallows number of %i\" % mallows)\n"}
{"id": 141364, "name": "Tokenize a string with escaping", "source": "Translate Swift to C#: extension String {\n  func tokenize(separator: Character, escape: Character) -> [String] {\n    var token = \"\"\n    var tokens = [String]()\n    var chars = makeIterator()\n\n    while let char = chars.next() {\n      switch char {\n      case separator:\n        tokens.append(token)\n        token = \"\"\n      case escape:\n        if let next = chars.next() {\n          token.append(next)\n        }\n      case _:\n        token.append(char)\n      }\n    }\n\n    tokens.append(token)\n\n    return tokens\n  }\n}\n\nprint(\"one^|uno||three^^^^|four^^^|^cuatro|\".tokenize(separator: \"|\", escape: \"^\"))\n", "target": "using System;\nusing System.Text;\nusing System.Collections.Generic;\n\npublic class TokenizeAStringWithEscaping\n{\n    public static void Main() {\n        string testcase = \"one^|uno||three^^^^|four^^^|^cuatro|\";\n        foreach (var token in testcase.Tokenize(separator: '|', escape: '^')) {\n            Console.WriteLine(\": \" + token); \n        }\n    }\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> Tokenize(this string input, char separator, char escape) {\n        if (input == null) yield break;\n        var buffer = new StringBuilder();\n        bool escaping = false;\n        foreach (char c in input) {\n            if (escaping) {\n                buffer.Append(c);\n                escaping = false;\n            } else if (c == escape) {\n                escaping = true;\n            } else if (c == separator) {\n                yield return buffer.Flush();\n            } else {\n                buffer.Append(c);\n            }\n        }\n        if (buffer.Length > 0 || input[input.Length-1] == separator) yield return buffer.Flush();\n    }\n    \n    public static string Flush(this StringBuilder stringBuilder) {\n        string result = stringBuilder.ToString();\n        stringBuilder.Clear();\n        return result;\n    }\n}\n"}
{"id": 141366, "name": "Tokenize a string with escaping", "source": "Translate Swift to Java: extension String {\n  func tokenize(separator: Character, escape: Character) -> [String] {\n    var token = \"\"\n    var tokens = [String]()\n    var chars = makeIterator()\n\n    while let char = chars.next() {\n      switch char {\n      case separator:\n        tokens.append(token)\n        token = \"\"\n      case escape:\n        if let next = chars.next() {\n          token.append(next)\n        }\n      case _:\n        token.append(char)\n      }\n    }\n\n    tokens.append(token)\n\n    return tokens\n  }\n}\n\nprint(\"one^|uno||three^^^^|four^^^|^cuatro|\".tokenize(separator: \"|\", escape: \"^\"))\n", "target": "import java.util.*;\n\npublic class TokenizeStringWithEscaping {\n\n    public static void main(String[] args) {\n        String sample = \"one^|uno||three^^^^|four^^^|^cuatro|\";\n        char separator = '|';\n        char escape = '^';\n\n        System.out.println(sample);\n        try {\n            System.out.println(tokenizeString(sample, separator, escape));\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    public static List<String> tokenizeString(String s, char sep, char escape)\n            throws Exception {\n        List<String> tokens = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n\n        boolean inEscape = false;\n        for (char c : s.toCharArray()) {\n            if (inEscape) {\n                inEscape = false;\n            } else if (c == escape) {\n                inEscape = true;\n                continue;\n            } else if (c == sep) {\n                tokens.add(sb.toString());\n                sb.setLength(0);\n                continue;\n            }\n            sb.append(c);\n        }\n        if (inEscape)\n            throw new Exception(\"Invalid terminal escape\");\n\n        tokens.add(sb.toString());\n\n        return tokens;\n    }\n}\n"}
{"id": 141367, "name": "Tokenize a string with escaping", "source": "Translate Swift to Python: extension String {\n  func tokenize(separator: Character, escape: Character) -> [String] {\n    var token = \"\"\n    var tokens = [String]()\n    var chars = makeIterator()\n\n    while let char = chars.next() {\n      switch char {\n      case separator:\n        tokens.append(token)\n        token = \"\"\n      case escape:\n        if let next = chars.next() {\n          token.append(next)\n        }\n      case _:\n        token.append(char)\n      }\n    }\n\n    tokens.append(token)\n\n    return tokens\n  }\n}\n\nprint(\"one^|uno||three^^^^|four^^^|^cuatro|\".tokenize(separator: \"|\", escape: \"^\"))\n", "target": "def token_with_escape(a, escape = '^', separator = '|'):\n    \n    result = []\n    token = ''\n    state = 0\n    for c in a:\n        if state == 0:\n            if c == escape:\n                state = 1\n            elif c == separator:\n                result.append(token)\n                token = ''\n            else:\n                token += c\n        elif state == 1:\n            token += c\n            state = 0\n    result.append(token)\n    return result\n"}
{"id": 142347, "name": "String prepend", "source": "Translate Swift to C#: var str = \", World\"\nstr = \"Hello\" + str\nprint(str)\n", "target": "using System;\n\nnamespace PrependString\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string str = \"World\";\n            str = \"Hello \" + str;\n            Console.WriteLine(str);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 142349, "name": "String prepend", "source": "Translate Swift to Java: var str = \", World\"\nstr = \"Hello\" + str\nprint(str)\n", "target": "\npublic class Prepend {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"world\");\n        sb.insert(0, \"Hello, \");\n        System.out.println(sb);\n    }\n}\n"}
{"id": 142350, "name": "String prepend", "source": "Translate Swift to Python: var str = \", World\"\nstr = \"Hello\" + str\nprint(str)\n", "target": "\n\n\ns = \"12345678\"\ns = \"0\" + s  \nprint(s)\n"}
{"id": 142594, "name": "Currency", "source": "Translate Swift to C#: import Foundation\n\nextension Decimal {\n  func rounded(_ scale: Int, _ roundingMode: NSDecimalNumber.RoundingMode) -> Decimal {\n    var result = Decimal()\n    var localCopy = self\n    NSDecimalRound(&result, &localCopy, scale, roundingMode)\n    return result\n  }\n}\n\nlet costHamburgers = Decimal(4000000000000000) * Decimal(5.50)\nlet costMilkshakes = Decimal(2) * Decimal(2.86)\nlet totalBeforeTax = costMilkshakes + costHamburgers\nlet taxesToBeCollected = (Decimal(string: \"0.0765\")! * totalBeforeTax).rounded(2, .bankers)\n\nprint(\"Price before tax: $\\(totalBeforeTax)\")\nprint(\"Total tax to be collected: $\\(taxesToBeCollected)\")\nprint(\"Total with taxes: $\\(totalBeforeTax + taxesToBeCollected)\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Currency\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            MenuItem hamburger = new MenuItem() { Name = \"Hamburger\", Price = 5.5M };\n            MenuItem milkshake = new MenuItem() { Name = \"Milkshake\", Price = 2.86M };\n\n            IList<CartItem> cart = new List<CartItem>();\n            cart.Add(new CartItem() { item = hamburger, quantity = 4000000000000000 });\n            cart.Add(new CartItem() { item = milkshake, quantity = 2 });\n\n            decimal total = CalculateTotal(cart);\n\n            Console.WriteLine(string.Format(\"Total before tax: {0:C}\", total));\n\n            \n            decimal tax = total * 0.0765M;\n\n            Console.WriteLine(string.Format(\"Tax: {0:C}\", tax));\n\n            total += tax;\n\n            Console.WriteLine(string.Format(\"Total with tax: {0:C}\", total));\n        }\n\n        private static decimal CalculateTotal(IList<CartItem> cart)\n        {\n            decimal total = 0M;\n\n            foreach (CartItem item in cart)\n            {\n                total += item.quantity * item.item.Price;\n            }\n\n            return total;\n        }\n\n        private struct MenuItem\n        {\n            public string Name { get; set; }\n            public decimal Price { get; set; }\n        }\n\n        private struct CartItem\n        {\n            public MenuItem item { get; set; }\n            public decimal quantity { get; set; }\n        }\n    }\n}\n"}
{"id": 142595, "name": "Currency", "source": "Translate Swift to C#: import Foundation\n\nextension Decimal {\n  func rounded(_ scale: Int, _ roundingMode: NSDecimalNumber.RoundingMode) -> Decimal {\n    var result = Decimal()\n    var localCopy = self\n    NSDecimalRound(&result, &localCopy, scale, roundingMode)\n    return result\n  }\n}\n\nlet costHamburgers = Decimal(4000000000000000) * Decimal(5.50)\nlet costMilkshakes = Decimal(2) * Decimal(2.86)\nlet totalBeforeTax = costMilkshakes + costHamburgers\nlet taxesToBeCollected = (Decimal(string: \"0.0765\")! * totalBeforeTax).rounded(2, .bankers)\n\nprint(\"Price before tax: $\\(totalBeforeTax)\")\nprint(\"Total tax to be collected: $\\(taxesToBeCollected)\")\nprint(\"Total with taxes: $\\(totalBeforeTax + taxesToBeCollected)\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Currency\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            MenuItem hamburger = new MenuItem() { Name = \"Hamburger\", Price = 5.5M };\n            MenuItem milkshake = new MenuItem() { Name = \"Milkshake\", Price = 2.86M };\n\n            IList<CartItem> cart = new List<CartItem>();\n            cart.Add(new CartItem() { item = hamburger, quantity = 4000000000000000 });\n            cart.Add(new CartItem() { item = milkshake, quantity = 2 });\n\n            decimal total = CalculateTotal(cart);\n\n            Console.WriteLine(string.Format(\"Total before tax: {0:C}\", total));\n\n            \n            decimal tax = total * 0.0765M;\n\n            Console.WriteLine(string.Format(\"Tax: {0:C}\", tax));\n\n            total += tax;\n\n            Console.WriteLine(string.Format(\"Total with tax: {0:C}\", total));\n        }\n\n        private static decimal CalculateTotal(IList<CartItem> cart)\n        {\n            decimal total = 0M;\n\n            foreach (CartItem item in cart)\n            {\n                total += item.quantity * item.item.Price;\n            }\n\n            return total;\n        }\n\n        private struct MenuItem\n        {\n            public string Name { get; set; }\n            public decimal Price { get; set; }\n        }\n\n        private struct CartItem\n        {\n            public MenuItem item { get; set; }\n            public decimal quantity { get; set; }\n        }\n    }\n}\n"}
{"id": 142596, "name": "Currency", "source": "Translate Swift to Java: import Foundation\n\nextension Decimal {\n  func rounded(_ scale: Int, _ roundingMode: NSDecimalNumber.RoundingMode) -> Decimal {\n    var result = Decimal()\n    var localCopy = self\n    NSDecimalRound(&result, &localCopy, scale, roundingMode)\n    return result\n  }\n}\n\nlet costHamburgers = Decimal(4000000000000000) * Decimal(5.50)\nlet costMilkshakes = Decimal(2) * Decimal(2.86)\nlet totalBeforeTax = costMilkshakes + costHamburgers\nlet taxesToBeCollected = (Decimal(string: \"0.0765\")! * totalBeforeTax).rounded(2, .bankers)\n\nprint(\"Price before tax: $\\(totalBeforeTax)\")\nprint(\"Total tax to be collected: $\\(taxesToBeCollected)\")\nprint(\"Total with taxes: $\\(totalBeforeTax + taxesToBeCollected)\")\n", "target": "import java.math.*;\nimport java.util.*;\n\npublic class Currency {\n    final static String taxrate = \"7.65\";\n\n    enum MenuItem {\n\n        Hamburger(\"5.50\"), Milkshake(\"2.86\");\n\n        private MenuItem(String p) {\n            price = new BigDecimal(p);\n        }\n\n        public final BigDecimal price;\n    }\n\n    public static void main(String[] args) {\n        Locale.setDefault(Locale.ENGLISH);\n\n        MathContext mc = MathContext.DECIMAL128;\n\n        Map<MenuItem, BigDecimal> order = new HashMap<>();\n        order.put(MenuItem.Hamburger, new BigDecimal(\"4000000000000000\"));\n        order.put(MenuItem.Milkshake, new BigDecimal(\"2\"));\n\n        BigDecimal subtotal = BigDecimal.ZERO;\n        for (MenuItem it : order.keySet())\n            subtotal = subtotal.add(it.price.multiply(order.get(it), mc));\n\n        BigDecimal tax = new BigDecimal(taxrate, mc);\n        tax = tax.divide(new BigDecimal(\"100\"), mc);\n        tax = subtotal.multiply(tax, mc);\n\n        System.out.printf(\"Subtotal: %20.2f%n\", subtotal);\n        System.out.printf(\"     Tax: %20.2f%n\", tax);\n        System.out.printf(\"   Total: %20.2f%n\", subtotal.add(tax));\n    }\n}\n"}
{"id": 142597, "name": "Currency", "source": "Translate Swift to Java: import Foundation\n\nextension Decimal {\n  func rounded(_ scale: Int, _ roundingMode: NSDecimalNumber.RoundingMode) -> Decimal {\n    var result = Decimal()\n    var localCopy = self\n    NSDecimalRound(&result, &localCopy, scale, roundingMode)\n    return result\n  }\n}\n\nlet costHamburgers = Decimal(4000000000000000) * Decimal(5.50)\nlet costMilkshakes = Decimal(2) * Decimal(2.86)\nlet totalBeforeTax = costMilkshakes + costHamburgers\nlet taxesToBeCollected = (Decimal(string: \"0.0765\")! * totalBeforeTax).rounded(2, .bankers)\n\nprint(\"Price before tax: $\\(totalBeforeTax)\")\nprint(\"Total tax to be collected: $\\(taxesToBeCollected)\")\nprint(\"Total with taxes: $\\(totalBeforeTax + taxesToBeCollected)\")\n", "target": "import java.math.*;\nimport java.util.*;\n\npublic class Currency {\n    final static String taxrate = \"7.65\";\n\n    enum MenuItem {\n\n        Hamburger(\"5.50\"), Milkshake(\"2.86\");\n\n        private MenuItem(String p) {\n            price = new BigDecimal(p);\n        }\n\n        public final BigDecimal price;\n    }\n\n    public static void main(String[] args) {\n        Locale.setDefault(Locale.ENGLISH);\n\n        MathContext mc = MathContext.DECIMAL128;\n\n        Map<MenuItem, BigDecimal> order = new HashMap<>();\n        order.put(MenuItem.Hamburger, new BigDecimal(\"4000000000000000\"));\n        order.put(MenuItem.Milkshake, new BigDecimal(\"2\"));\n\n        BigDecimal subtotal = BigDecimal.ZERO;\n        for (MenuItem it : order.keySet())\n            subtotal = subtotal.add(it.price.multiply(order.get(it), mc));\n\n        BigDecimal tax = new BigDecimal(taxrate, mc);\n        tax = tax.divide(new BigDecimal(\"100\"), mc);\n        tax = subtotal.multiply(tax, mc);\n\n        System.out.printf(\"Subtotal: %20.2f%n\", subtotal);\n        System.out.printf(\"     Tax: %20.2f%n\", tax);\n        System.out.printf(\"   Total: %20.2f%n\", subtotal.add(tax));\n    }\n}\n"}
{"id": 142598, "name": "Currency", "source": "Translate Swift to Python: import Foundation\n\nextension Decimal {\n  func rounded(_ scale: Int, _ roundingMode: NSDecimalNumber.RoundingMode) -> Decimal {\n    var result = Decimal()\n    var localCopy = self\n    NSDecimalRound(&result, &localCopy, scale, roundingMode)\n    return result\n  }\n}\n\nlet costHamburgers = Decimal(4000000000000000) * Decimal(5.50)\nlet costMilkshakes = Decimal(2) * Decimal(2.86)\nlet totalBeforeTax = costMilkshakes + costHamburgers\nlet taxesToBeCollected = (Decimal(string: \"0.0765\")! * totalBeforeTax).rounded(2, .bankers)\n\nprint(\"Price before tax: $\\(totalBeforeTax)\")\nprint(\"Total tax to be collected: $\\(taxesToBeCollected)\")\nprint(\"Total with taxes: $\\(totalBeforeTax + taxesToBeCollected)\")\n", "target": "from decimal import Decimal as D\nfrom collections import namedtuple\n\nItem = namedtuple('Item', 'price, quant')\n\nitems = dict( hamburger=Item(D('5.50'), D('4000000000000000')),\n              milkshake=Item(D('2.86'), D('2')) )\ntax_rate = D('0.0765')\n\nfmt = \"%-10s %8s %18s %22s\"\nprint(fmt % tuple('Item Price Quantity Extension'.upper().split()))\n\ntotal_before_tax = 0\nfor item, (price, quant) in sorted(items.items()):\n    ext = price * quant\n    print(fmt % (item, price, quant, ext))\n    total_before_tax += ext\nprint(fmt % ('', '', '', '--------------------'))\nprint(fmt % ('', '', 'subtotal', total_before_tax))\n\ntax = (tax_rate * total_before_tax).quantize(D('0.00'))\nprint(fmt % ('', '', 'Tax', tax))\n\ntotal = total_before_tax + tax\nprint(fmt % ('', '', '', '--------------------'))\nprint(fmt % ('', '', 'Total', total))\n"}
{"id": 142599, "name": "Currency", "source": "Translate Swift to Python: import Foundation\n\nextension Decimal {\n  func rounded(_ scale: Int, _ roundingMode: NSDecimalNumber.RoundingMode) -> Decimal {\n    var result = Decimal()\n    var localCopy = self\n    NSDecimalRound(&result, &localCopy, scale, roundingMode)\n    return result\n  }\n}\n\nlet costHamburgers = Decimal(4000000000000000) * Decimal(5.50)\nlet costMilkshakes = Decimal(2) * Decimal(2.86)\nlet totalBeforeTax = costMilkshakes + costHamburgers\nlet taxesToBeCollected = (Decimal(string: \"0.0765\")! * totalBeforeTax).rounded(2, .bankers)\n\nprint(\"Price before tax: $\\(totalBeforeTax)\")\nprint(\"Total tax to be collected: $\\(taxesToBeCollected)\")\nprint(\"Total with taxes: $\\(totalBeforeTax + taxesToBeCollected)\")\n", "target": "from decimal import Decimal as D\nfrom collections import namedtuple\n\nItem = namedtuple('Item', 'price, quant')\n\nitems = dict( hamburger=Item(D('5.50'), D('4000000000000000')),\n              milkshake=Item(D('2.86'), D('2')) )\ntax_rate = D('0.0765')\n\nfmt = \"%-10s %8s %18s %22s\"\nprint(fmt % tuple('Item Price Quantity Extension'.upper().split()))\n\ntotal_before_tax = 0\nfor item, (price, quant) in sorted(items.items()):\n    ext = price * quant\n    print(fmt % (item, price, quant, ext))\n    total_before_tax += ext\nprint(fmt % ('', '', '', '--------------------'))\nprint(fmt % ('', '', 'subtotal', total_before_tax))\n\ntax = (tax_rate * total_before_tax).quantize(D('0.00'))\nprint(fmt % ('', '', 'Tax', tax))\n\ntotal = total_before_tax + tax\nprint(fmt % ('', '', '', '--------------------'))\nprint(fmt % ('', '', 'Total', total))\n"}
{"id": 142906, "name": "Fast Fourier transform", "source": "Translate Swift to C#: import Foundation\nimport Numerics\n\ntypealias Complex = Numerics.Complex<Double>\n\nextension Complex {\n  var exp: Complex {\n    Complex(cos(imaginary), sin(imaginary)) * Complex(cosh(real), sinh(real))\n  }\n\n  var pretty: String {\n    let fmt = { String(format: \"%1.3f\", $0) }\n    let re = fmt(real)\n    let im = fmt(abs(imaginary))\n\n    if im == \"0.000\" {\n      return re\n    } else if re == \"0.000\" {\n      return im\n    } else if imaginary > 0 {\n      return re + \" + \" + im + \"i\"\n    } else {\n      return re + \" - \" + im +  \"i\"\n    }\n  }\n}\n\nfunc fft(_ array: [Complex]) -> [Complex] { _fft(array, direction: Complex(0.0, 2.0), scalar: 1) }\nfunc rfft(_ array: [Complex]) -> [Complex] { _fft(array, direction: Complex(0.0, -2.0), scalar: 2) }\n\nprivate func _fft(_ arr: [Complex], direction: Complex, scalar: Double) -> [Complex] {\n  guard arr.count > 1 else {\n    return arr\n  }\n\n  let n = arr.count\n  let cScalar = Complex(scalar, 0)\n\n  precondition(n % 2 == 0, \"The Cooley-Tukey FFT algorithm only works when the length of the input is even.\")\n\n  var (evens, odds) = arr.lazy.enumerated().reduce(into: ([Complex](), [Complex]()), {res, cur in\n    if cur.offset & 1 == 0 {\n      res.0.append(cur.element)\n    } else {\n      res.1.append(cur.element)\n    }\n  })\n\n  evens = _fft(evens, direction: direction, scalar: scalar)\n  odds = _fft(odds, direction: direction, scalar: scalar)\n\n  let (left, right) = (0 ..< n / 2).map({i -> (Complex, Complex) in\n    let offset = (direction * Complex((.pi * Double(i) / Double(n)), 0)).exp * odds[i] / cScalar\n    let base = evens[i] / cScalar\n\n    return (base + offset, base - offset)\n  }).reduce(into: ([Complex](), [Complex]()), {res, cur in\n    res.0.append(cur.0)\n    res.1.append(cur.1)\n  })\n  \n  return left + right\n}\n\nlet dat = [Complex(1.0, 0.0), Complex(1.0, 0.0), Complex(1.0, 0.0), Complex(1.0, 0.0),\n           Complex(0.0, 0.0), Complex(0.0, 2.0), Complex(0.0, 0.0), Complex(0.0, 0.0)]\n\nprint(fft(dat).map({ $0.pretty }))\nprint(rfft(f).map({ $0.pretty }))\n", "target": "using System;\nusing System.Numerics;\nusing System.Linq;\nusing System.Diagnostics;\n\n\npublic class Program {\n\n    \n    public static int BitReverse(int n, int bits) {\n       int reversedN = n;\n       int count = bits - 1;\n\n       n >>= 1;\n       while (n > 0) {\n            reversedN = (reversedN << 1) | (n & 1);\n            count--;\n            n >>= 1;\n        }\n\n        return ((reversedN << count) & ((1 << bits) - 1));\n    }\n\n    \n    public static void FFT(Complex[] buffer) {\n#if false\n        int bits = (int)Math.Log(buffer.Length, 2);\n        for (int j = 1; j < buffer.Length / 2; j++) {\n\n            int swapPos = BitReverse(j, bits);\n            var temp = buffer[j];\n            buffer[j] = buffer[swapPos];\n            buffer[swapPos] = temp;\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#else\n            for (int j = 1; j < buffer.Length; j++)\n            {\n                int swapPos = BitReverse(j, bits);\n                if (swapPos <= j)\n                {\n                    continue;\n                }\n                var temp = buffer[j];\n                buffer[j] = buffer[swapPos];\n                buffer[swapPos] = temp;\n            }\n\n\n\n\n#endif\n\n        for (int N = 2; N <= buffer.Length; N <<= 1) {\n            for (int i = 0; i < buffer.Length; i += N) {\n                for (int k = 0; k < N / 2; k++) {\n\n                    int evenIndex = i + k;\n                    int oddIndex = i + k + (N / 2);\n                    var even = buffer[evenIndex];\n                    var odd = buffer[oddIndex];\n\n                    double term = -2 * Math.PI * k / (double)N;\n                    Complex exp = new Complex(Math.Cos(term), Math.Sin(term)) * odd;\n\n                    buffer[evenIndex] = even + exp;\n                    buffer[oddIndex] = even - exp;\n\n                }\n            }\n        }\n    }\n\n    public static void Main(string[] args) {\n        Complex[] input = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};       \n        \n        FFT(input);       \n                  \n        Console.WriteLine(\"Results:\");\n        foreach (Complex c in input) {\n            Console.WriteLine(c);   \n        }   \n    }\n}\n"}
{"id": 142907, "name": "Fast Fourier transform", "source": "Translate Swift to C#: import Foundation\nimport Numerics\n\ntypealias Complex = Numerics.Complex<Double>\n\nextension Complex {\n  var exp: Complex {\n    Complex(cos(imaginary), sin(imaginary)) * Complex(cosh(real), sinh(real))\n  }\n\n  var pretty: String {\n    let fmt = { String(format: \"%1.3f\", $0) }\n    let re = fmt(real)\n    let im = fmt(abs(imaginary))\n\n    if im == \"0.000\" {\n      return re\n    } else if re == \"0.000\" {\n      return im\n    } else if imaginary > 0 {\n      return re + \" + \" + im + \"i\"\n    } else {\n      return re + \" - \" + im +  \"i\"\n    }\n  }\n}\n\nfunc fft(_ array: [Complex]) -> [Complex] { _fft(array, direction: Complex(0.0, 2.0), scalar: 1) }\nfunc rfft(_ array: [Complex]) -> [Complex] { _fft(array, direction: Complex(0.0, -2.0), scalar: 2) }\n\nprivate func _fft(_ arr: [Complex], direction: Complex, scalar: Double) -> [Complex] {\n  guard arr.count > 1 else {\n    return arr\n  }\n\n  let n = arr.count\n  let cScalar = Complex(scalar, 0)\n\n  precondition(n % 2 == 0, \"The Cooley-Tukey FFT algorithm only works when the length of the input is even.\")\n\n  var (evens, odds) = arr.lazy.enumerated().reduce(into: ([Complex](), [Complex]()), {res, cur in\n    if cur.offset & 1 == 0 {\n      res.0.append(cur.element)\n    } else {\n      res.1.append(cur.element)\n    }\n  })\n\n  evens = _fft(evens, direction: direction, scalar: scalar)\n  odds = _fft(odds, direction: direction, scalar: scalar)\n\n  let (left, right) = (0 ..< n / 2).map({i -> (Complex, Complex) in\n    let offset = (direction * Complex((.pi * Double(i) / Double(n)), 0)).exp * odds[i] / cScalar\n    let base = evens[i] / cScalar\n\n    return (base + offset, base - offset)\n  }).reduce(into: ([Complex](), [Complex]()), {res, cur in\n    res.0.append(cur.0)\n    res.1.append(cur.1)\n  })\n  \n  return left + right\n}\n\nlet dat = [Complex(1.0, 0.0), Complex(1.0, 0.0), Complex(1.0, 0.0), Complex(1.0, 0.0),\n           Complex(0.0, 0.0), Complex(0.0, 2.0), Complex(0.0, 0.0), Complex(0.0, 0.0)]\n\nprint(fft(dat).map({ $0.pretty }))\nprint(rfft(f).map({ $0.pretty }))\n", "target": "using System;\nusing System.Numerics;\nusing System.Linq;\nusing System.Diagnostics;\n\n\npublic class Program {\n\n    \n    public static int BitReverse(int n, int bits) {\n       int reversedN = n;\n       int count = bits - 1;\n\n       n >>= 1;\n       while (n > 0) {\n            reversedN = (reversedN << 1) | (n & 1);\n            count--;\n            n >>= 1;\n        }\n\n        return ((reversedN << count) & ((1 << bits) - 1));\n    }\n\n    \n    public static void FFT(Complex[] buffer) {\n#if false\n        int bits = (int)Math.Log(buffer.Length, 2);\n        for (int j = 1; j < buffer.Length / 2; j++) {\n\n            int swapPos = BitReverse(j, bits);\n            var temp = buffer[j];\n            buffer[j] = buffer[swapPos];\n            buffer[swapPos] = temp;\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#else\n            for (int j = 1; j < buffer.Length; j++)\n            {\n                int swapPos = BitReverse(j, bits);\n                if (swapPos <= j)\n                {\n                    continue;\n                }\n                var temp = buffer[j];\n                buffer[j] = buffer[swapPos];\n                buffer[swapPos] = temp;\n            }\n\n\n\n\n#endif\n\n        for (int N = 2; N <= buffer.Length; N <<= 1) {\n            for (int i = 0; i < buffer.Length; i += N) {\n                for (int k = 0; k < N / 2; k++) {\n\n                    int evenIndex = i + k;\n                    int oddIndex = i + k + (N / 2);\n                    var even = buffer[evenIndex];\n                    var odd = buffer[oddIndex];\n\n                    double term = -2 * Math.PI * k / (double)N;\n                    Complex exp = new Complex(Math.Cos(term), Math.Sin(term)) * odd;\n\n                    buffer[evenIndex] = even + exp;\n                    buffer[oddIndex] = even - exp;\n\n                }\n            }\n        }\n    }\n\n    public static void Main(string[] args) {\n        Complex[] input = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};       \n        \n        FFT(input);       \n                  \n        Console.WriteLine(\"Results:\");\n        foreach (Complex c in input) {\n            Console.WriteLine(c);   \n        }   \n    }\n}\n"}
{"id": 142910, "name": "Fast Fourier transform", "source": "Translate Swift to Java: import Foundation\nimport Numerics\n\ntypealias Complex = Numerics.Complex<Double>\n\nextension Complex {\n  var exp: Complex {\n    Complex(cos(imaginary), sin(imaginary)) * Complex(cosh(real), sinh(real))\n  }\n\n  var pretty: String {\n    let fmt = { String(format: \"%1.3f\", $0) }\n    let re = fmt(real)\n    let im = fmt(abs(imaginary))\n\n    if im == \"0.000\" {\n      return re\n    } else if re == \"0.000\" {\n      return im\n    } else if imaginary > 0 {\n      return re + \" + \" + im + \"i\"\n    } else {\n      return re + \" - \" + im +  \"i\"\n    }\n  }\n}\n\nfunc fft(_ array: [Complex]) -> [Complex] { _fft(array, direction: Complex(0.0, 2.0), scalar: 1) }\nfunc rfft(_ array: [Complex]) -> [Complex] { _fft(array, direction: Complex(0.0, -2.0), scalar: 2) }\n\nprivate func _fft(_ arr: [Complex], direction: Complex, scalar: Double) -> [Complex] {\n  guard arr.count > 1 else {\n    return arr\n  }\n\n  let n = arr.count\n  let cScalar = Complex(scalar, 0)\n\n  precondition(n % 2 == 0, \"The Cooley-Tukey FFT algorithm only works when the length of the input is even.\")\n\n  var (evens, odds) = arr.lazy.enumerated().reduce(into: ([Complex](), [Complex]()), {res, cur in\n    if cur.offset & 1 == 0 {\n      res.0.append(cur.element)\n    } else {\n      res.1.append(cur.element)\n    }\n  })\n\n  evens = _fft(evens, direction: direction, scalar: scalar)\n  odds = _fft(odds, direction: direction, scalar: scalar)\n\n  let (left, right) = (0 ..< n / 2).map({i -> (Complex, Complex) in\n    let offset = (direction * Complex((.pi * Double(i) / Double(n)), 0)).exp * odds[i] / cScalar\n    let base = evens[i] / cScalar\n\n    return (base + offset, base - offset)\n  }).reduce(into: ([Complex](), [Complex]()), {res, cur in\n    res.0.append(cur.0)\n    res.1.append(cur.1)\n  })\n  \n  return left + right\n}\n\nlet dat = [Complex(1.0, 0.0), Complex(1.0, 0.0), Complex(1.0, 0.0), Complex(1.0, 0.0),\n           Complex(0.0, 0.0), Complex(0.0, 2.0), Complex(0.0, 0.0), Complex(0.0, 0.0)]\n\nprint(fft(dat).map({ $0.pretty }))\nprint(rfft(f).map({ $0.pretty }))\n", "target": "import static java.lang.Math.*;\n\npublic class FastFourierTransform {\n\n    public static int bitReverse(int n, int bits) {\n        int reversedN = n;\n        int count = bits - 1;\n\n        n >>= 1;\n        while (n > 0) {\n            reversedN = (reversedN << 1) | (n & 1);\n            count--;\n            n >>= 1;\n        }\n\n        return ((reversedN << count) & ((1 << bits) - 1));\n    }\n\n    static void fft(Complex[] buffer) {\n\n        int bits = (int) (log(buffer.length) / log(2));\n        for (int j = 1; j < buffer.length / 2; j++) {\n\n            int swapPos = bitReverse(j, bits);\n            Complex temp = buffer[j];\n            buffer[j] = buffer[swapPos];\n            buffer[swapPos] = temp;\n        }\n\n        for (int N = 2; N <= buffer.length; N <<= 1) {\n            for (int i = 0; i < buffer.length; i += N) {\n                for (int k = 0; k < N / 2; k++) {\n\n                    int evenIndex = i + k;\n                    int oddIndex = i + k + (N / 2);\n                    Complex even = buffer[evenIndex];\n                    Complex odd = buffer[oddIndex];\n\n                    double term = (-2 * PI * k) / (double) N;\n                    Complex exp = (new Complex(cos(term), sin(term)).mult(odd));\n\n                    buffer[evenIndex] = even.add(exp);\n                    buffer[oddIndex] = even.sub(exp);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        double[] input = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};\n\n        Complex[] cinput = new Complex[input.length];\n        for (int i = 0; i < input.length; i++)\n            cinput[i] = new Complex(input[i], 0.0);\n\n        fft(cinput);\n\n        System.out.println(\"Results:\");\n        for (Complex c : cinput) {\n            System.out.println(c);\n        }\n    }\n}\n\nclass Complex {\n    public final double re;\n    public final double im;\n\n    public Complex() {\n        this(0, 0);\n    }\n\n    public Complex(double r, double i) {\n        re = r;\n        im = i;\n    }\n\n    public Complex add(Complex b) {\n        return new Complex(this.re + b.re, this.im + b.im);\n    }\n\n    public Complex sub(Complex b) {\n        return new Complex(this.re - b.re, this.im - b.im);\n    }\n\n    public Complex mult(Complex b) {\n        return new Complex(this.re * b.re - this.im * b.im,\n                this.re * b.im + this.im * b.re);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"(%f,%f)\", re, im);\n    }\n}\n"}
{"id": 142911, "name": "Fast Fourier transform", "source": "Translate Swift to Java: import Foundation\nimport Numerics\n\ntypealias Complex = Numerics.Complex<Double>\n\nextension Complex {\n  var exp: Complex {\n    Complex(cos(imaginary), sin(imaginary)) * Complex(cosh(real), sinh(real))\n  }\n\n  var pretty: String {\n    let fmt = { String(format: \"%1.3f\", $0) }\n    let re = fmt(real)\n    let im = fmt(abs(imaginary))\n\n    if im == \"0.000\" {\n      return re\n    } else if re == \"0.000\" {\n      return im\n    } else if imaginary > 0 {\n      return re + \" + \" + im + \"i\"\n    } else {\n      return re + \" - \" + im +  \"i\"\n    }\n  }\n}\n\nfunc fft(_ array: [Complex]) -> [Complex] { _fft(array, direction: Complex(0.0, 2.0), scalar: 1) }\nfunc rfft(_ array: [Complex]) -> [Complex] { _fft(array, direction: Complex(0.0, -2.0), scalar: 2) }\n\nprivate func _fft(_ arr: [Complex], direction: Complex, scalar: Double) -> [Complex] {\n  guard arr.count > 1 else {\n    return arr\n  }\n\n  let n = arr.count\n  let cScalar = Complex(scalar, 0)\n\n  precondition(n % 2 == 0, \"The Cooley-Tukey FFT algorithm only works when the length of the input is even.\")\n\n  var (evens, odds) = arr.lazy.enumerated().reduce(into: ([Complex](), [Complex]()), {res, cur in\n    if cur.offset & 1 == 0 {\n      res.0.append(cur.element)\n    } else {\n      res.1.append(cur.element)\n    }\n  })\n\n  evens = _fft(evens, direction: direction, scalar: scalar)\n  odds = _fft(odds, direction: direction, scalar: scalar)\n\n  let (left, right) = (0 ..< n / 2).map({i -> (Complex, Complex) in\n    let offset = (direction * Complex((.pi * Double(i) / Double(n)), 0)).exp * odds[i] / cScalar\n    let base = evens[i] / cScalar\n\n    return (base + offset, base - offset)\n  }).reduce(into: ([Complex](), [Complex]()), {res, cur in\n    res.0.append(cur.0)\n    res.1.append(cur.1)\n  })\n  \n  return left + right\n}\n\nlet dat = [Complex(1.0, 0.0), Complex(1.0, 0.0), Complex(1.0, 0.0), Complex(1.0, 0.0),\n           Complex(0.0, 0.0), Complex(0.0, 2.0), Complex(0.0, 0.0), Complex(0.0, 0.0)]\n\nprint(fft(dat).map({ $0.pretty }))\nprint(rfft(f).map({ $0.pretty }))\n", "target": "import static java.lang.Math.*;\n\npublic class FastFourierTransform {\n\n    public static int bitReverse(int n, int bits) {\n        int reversedN = n;\n        int count = bits - 1;\n\n        n >>= 1;\n        while (n > 0) {\n            reversedN = (reversedN << 1) | (n & 1);\n            count--;\n            n >>= 1;\n        }\n\n        return ((reversedN << count) & ((1 << bits) - 1));\n    }\n\n    static void fft(Complex[] buffer) {\n\n        int bits = (int) (log(buffer.length) / log(2));\n        for (int j = 1; j < buffer.length / 2; j++) {\n\n            int swapPos = bitReverse(j, bits);\n            Complex temp = buffer[j];\n            buffer[j] = buffer[swapPos];\n            buffer[swapPos] = temp;\n        }\n\n        for (int N = 2; N <= buffer.length; N <<= 1) {\n            for (int i = 0; i < buffer.length; i += N) {\n                for (int k = 0; k < N / 2; k++) {\n\n                    int evenIndex = i + k;\n                    int oddIndex = i + k + (N / 2);\n                    Complex even = buffer[evenIndex];\n                    Complex odd = buffer[oddIndex];\n\n                    double term = (-2 * PI * k) / (double) N;\n                    Complex exp = (new Complex(cos(term), sin(term)).mult(odd));\n\n                    buffer[evenIndex] = even.add(exp);\n                    buffer[oddIndex] = even.sub(exp);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        double[] input = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};\n\n        Complex[] cinput = new Complex[input.length];\n        for (int i = 0; i < input.length; i++)\n            cinput[i] = new Complex(input[i], 0.0);\n\n        fft(cinput);\n\n        System.out.println(\"Results:\");\n        for (Complex c : cinput) {\n            System.out.println(c);\n        }\n    }\n}\n\nclass Complex {\n    public final double re;\n    public final double im;\n\n    public Complex() {\n        this(0, 0);\n    }\n\n    public Complex(double r, double i) {\n        re = r;\n        im = i;\n    }\n\n    public Complex add(Complex b) {\n        return new Complex(this.re + b.re, this.im + b.im);\n    }\n\n    public Complex sub(Complex b) {\n        return new Complex(this.re - b.re, this.im - b.im);\n    }\n\n    public Complex mult(Complex b) {\n        return new Complex(this.re * b.re - this.im * b.im,\n                this.re * b.im + this.im * b.re);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"(%f,%f)\", re, im);\n    }\n}\n"}
{"id": 142912, "name": "Fast Fourier transform", "source": "Translate Swift to Python: import Foundation\nimport Numerics\n\ntypealias Complex = Numerics.Complex<Double>\n\nextension Complex {\n  var exp: Complex {\n    Complex(cos(imaginary), sin(imaginary)) * Complex(cosh(real), sinh(real))\n  }\n\n  var pretty: String {\n    let fmt = { String(format: \"%1.3f\", $0) }\n    let re = fmt(real)\n    let im = fmt(abs(imaginary))\n\n    if im == \"0.000\" {\n      return re\n    } else if re == \"0.000\" {\n      return im\n    } else if imaginary > 0 {\n      return re + \" + \" + im + \"i\"\n    } else {\n      return re + \" - \" + im +  \"i\"\n    }\n  }\n}\n\nfunc fft(_ array: [Complex]) -> [Complex] { _fft(array, direction: Complex(0.0, 2.0), scalar: 1) }\nfunc rfft(_ array: [Complex]) -> [Complex] { _fft(array, direction: Complex(0.0, -2.0), scalar: 2) }\n\nprivate func _fft(_ arr: [Complex], direction: Complex, scalar: Double) -> [Complex] {\n  guard arr.count > 1 else {\n    return arr\n  }\n\n  let n = arr.count\n  let cScalar = Complex(scalar, 0)\n\n  precondition(n % 2 == 0, \"The Cooley-Tukey FFT algorithm only works when the length of the input is even.\")\n\n  var (evens, odds) = arr.lazy.enumerated().reduce(into: ([Complex](), [Complex]()), {res, cur in\n    if cur.offset & 1 == 0 {\n      res.0.append(cur.element)\n    } else {\n      res.1.append(cur.element)\n    }\n  })\n\n  evens = _fft(evens, direction: direction, scalar: scalar)\n  odds = _fft(odds, direction: direction, scalar: scalar)\n\n  let (left, right) = (0 ..< n / 2).map({i -> (Complex, Complex) in\n    let offset = (direction * Complex((.pi * Double(i) / Double(n)), 0)).exp * odds[i] / cScalar\n    let base = evens[i] / cScalar\n\n    return (base + offset, base - offset)\n  }).reduce(into: ([Complex](), [Complex]()), {res, cur in\n    res.0.append(cur.0)\n    res.1.append(cur.1)\n  })\n  \n  return left + right\n}\n\nlet dat = [Complex(1.0, 0.0), Complex(1.0, 0.0), Complex(1.0, 0.0), Complex(1.0, 0.0),\n           Complex(0.0, 0.0), Complex(0.0, 2.0), Complex(0.0, 0.0), Complex(0.0, 0.0)]\n\nprint(fft(dat).map({ $0.pretty }))\nprint(rfft(f).map({ $0.pretty }))\n", "target": "from cmath import exp, pi\n\ndef fft(x):\n    N = len(x)\n    if N <= 1: return x\n    even = fft(x[0::2])\n    odd =  fft(x[1::2])\n    T= [exp(-2j*pi*k/N)*odd[k] for k in range(N//2)]\n    return [even[k] + T[k] for k in range(N//2)] + \\\n           [even[k] - T[k] for k in range(N//2)]\n\nprint( ' '.join(\"%5.3f\" % abs(f) \n                for f in fft([1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0])) )\n"}
{"id": 142913, "name": "Fast Fourier transform", "source": "Translate Swift to Python: import Foundation\nimport Numerics\n\ntypealias Complex = Numerics.Complex<Double>\n\nextension Complex {\n  var exp: Complex {\n    Complex(cos(imaginary), sin(imaginary)) * Complex(cosh(real), sinh(real))\n  }\n\n  var pretty: String {\n    let fmt = { String(format: \"%1.3f\", $0) }\n    let re = fmt(real)\n    let im = fmt(abs(imaginary))\n\n    if im == \"0.000\" {\n      return re\n    } else if re == \"0.000\" {\n      return im\n    } else if imaginary > 0 {\n      return re + \" + \" + im + \"i\"\n    } else {\n      return re + \" - \" + im +  \"i\"\n    }\n  }\n}\n\nfunc fft(_ array: [Complex]) -> [Complex] { _fft(array, direction: Complex(0.0, 2.0), scalar: 1) }\nfunc rfft(_ array: [Complex]) -> [Complex] { _fft(array, direction: Complex(0.0, -2.0), scalar: 2) }\n\nprivate func _fft(_ arr: [Complex], direction: Complex, scalar: Double) -> [Complex] {\n  guard arr.count > 1 else {\n    return arr\n  }\n\n  let n = arr.count\n  let cScalar = Complex(scalar, 0)\n\n  precondition(n % 2 == 0, \"The Cooley-Tukey FFT algorithm only works when the length of the input is even.\")\n\n  var (evens, odds) = arr.lazy.enumerated().reduce(into: ([Complex](), [Complex]()), {res, cur in\n    if cur.offset & 1 == 0 {\n      res.0.append(cur.element)\n    } else {\n      res.1.append(cur.element)\n    }\n  })\n\n  evens = _fft(evens, direction: direction, scalar: scalar)\n  odds = _fft(odds, direction: direction, scalar: scalar)\n\n  let (left, right) = (0 ..< n / 2).map({i -> (Complex, Complex) in\n    let offset = (direction * Complex((.pi * Double(i) / Double(n)), 0)).exp * odds[i] / cScalar\n    let base = evens[i] / cScalar\n\n    return (base + offset, base - offset)\n  }).reduce(into: ([Complex](), [Complex]()), {res, cur in\n    res.0.append(cur.0)\n    res.1.append(cur.1)\n  })\n  \n  return left + right\n}\n\nlet dat = [Complex(1.0, 0.0), Complex(1.0, 0.0), Complex(1.0, 0.0), Complex(1.0, 0.0),\n           Complex(0.0, 0.0), Complex(0.0, 2.0), Complex(0.0, 0.0), Complex(0.0, 0.0)]\n\nprint(fft(dat).map({ $0.pretty }))\nprint(rfft(f).map({ $0.pretty }))\n", "target": "from cmath import exp, pi\n\ndef fft(x):\n    N = len(x)\n    if N <= 1: return x\n    even = fft(x[0::2])\n    odd =  fft(x[1::2])\n    T= [exp(-2j*pi*k/N)*odd[k] for k in range(N//2)]\n    return [even[k] + T[k] for k in range(N//2)] + \\\n           [even[k] - T[k] for k in range(N//2)]\n\nprint( ' '.join(\"%5.3f\" % abs(f) \n                for f in fft([1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0])) )\n"}
{"id": 143205, "name": "Increment a numerical string", "source": "Translate Swift to C#: let s = \"1234\"\nif let x = Int(s) {\n  print(\"\\(x + 1)\")\n}\n", "target": "string s = \"12345\";\ns = (int.Parse(s) + 1).ToString();\n\n\n\n\n\n\nusing System.Numerics;\nstring bis = \"123456789012345678999999999\";\nbis = (BigInteger.Parse(bis) + 1).ToString();\n\n\n"}
{"id": 143207, "name": "Increment a numerical string", "source": "Translate Swift to Java: let s = \"1234\"\nif let x = Int(s) {\n  print(\"\\(x + 1)\")\n}\n", "target": "String s = \"12345\";\nIntLiteral lit1 = new IntLiteral(s);\nIntLiteral lit2 = 6789;\n++lit1; \n++lit2; \n"}
{"id": 143208, "name": "Increment a numerical string", "source": "Translate Swift to Python: let s = \"1234\"\nif let x = Int(s) {\n  print(\"\\(x + 1)\")\n}\n", "target": "next = str(int('123') + 1)\n"}
{"id": 143676, "name": "Polynomial long division", "source": "Translate Swift to C#: protocol Dividable {\n  static func / (lhs: Self, rhs: Self) -> Self\n}\n\nextension Int: Dividable { }\n\nstruct Solution<T> {\n  var quotient: [T]\n  var remainder: [T]\n}\n\nfunc polyDegree<T: SignedNumeric>(_ p: [T]) -> Int {\n  for i in stride(from: p.count - 1, through: 0, by: -1) where p[i] != 0 {\n    return i\n  }\n\n  return Int.min\n}\n\nfunc polyShiftRight<T: SignedNumeric>(p: [T], places: Int) -> [T] {\n  guard places > 0 else {\n    return p\n  }\n\n  let deg = polyDegree(p)\n\n  assert(deg + places < p.count, \"Number of places to shift too large\")\n\n  var res = p\n\n  for i in stride(from: deg, through: 0, by: -1) {\n    res[i + places] = res[i]\n    res[i] = 0\n  }\n\n  return res\n}\n\nfunc polyMul<T: SignedNumeric>(_ p: inout [T], by: T) {\n  for i in 0..<p.count {\n    p[i] *= by\n  }\n}\n\nfunc polySub<T: SignedNumeric>(_ p: inout [T], by: [T]) {\n  for i in 0..<p.count {\n    p[i] -= by[i]\n  }\n}\n\nfunc polyLongDiv<T: SignedNumeric & Dividable>(numerator n: [T], denominator d: [T]) -> Solution<T>? {\n  guard n.count == d.count else {\n    return nil\n  }\n\n  var nDeg = polyDegree(n)\n  let dDeg = polyDegree(d)\n\n  guard dDeg >= 0, nDeg >= dDeg else {\n    return nil\n  }\n\n  var n2 = n\n  var quo = [T](repeating: 0, count: n.count)\n\n  while nDeg >= dDeg {\n    let i = nDeg - dDeg\n    var d2 = polyShiftRight(p: d, places: i)\n\n    quo[i] = n2[nDeg] / d2[nDeg]\n\n    polyMul(&d2, by: quo[i])\n    polySub(&n2, by: d2)\n\n    nDeg = polyDegree(n2)\n  }\n\n  return Solution(quotient: quo, remainder: n2)\n}\n\nfunc polyPrint<T: SignedNumeric & Comparable>(_ p: [T]) {\n  let deg = polyDegree(p)\n\n  for i in stride(from: deg, through: 0, by: -1) where p[i] != 0 {\n    let coeff = p[i]\n\n    switch coeff {\n    case 1 where i < deg:\n      print(\" + \", terminator: \"\")\n    case 1:\n      print(\"\", terminator: \"\")\n    case -1 where i < deg:\n      print(\" - \", terminator: \"\")\n    case -1:\n      print(\"-\", terminator: \"\")\n    case _ where coeff < 0 && i < deg:\n      print(\" - \\(-coeff)\", terminator: \"\")\n    case _ where i < deg:\n      print(\" + \\(coeff)\", terminator: \"\")\n    case _:\n      print(\"\\(coeff)\", terminator: \"\")\n    }\n\n    if i > 1 {\n      print(\"x^\\(i)\", terminator: \"\")\n    } else if i == 1 {\n      print(\"x\", terminator: \"\")\n    }\n  }\n\n  print()\n}\n\nlet n = [-42, 0, -12, 1]\nlet d = [-3, 1, 0, 0]\n\nprint(\"Numerator: \", terminator: \"\")\npolyPrint(n)\nprint(\"Denominator: \", terminator: \"\")\npolyPrint(d)\n\nguard let sol = polyLongDiv(numerator: n, denominator: d) else {\n  fatalError()\n}\n\nprint(\"----------\")\nprint(\"Quotient: \", terminator: \"\")\npolyPrint(sol.quotient)\nprint(\"Remainder: \", terminator: \"\")\npolyPrint(sol.remainder)\n", "target": "using System;\n\nnamespace PolynomialLongDivision {\n    class Solution {\n        public Solution(double[] q, double[] r) {\n            Quotient = q;\n            Remainder = r;\n        }\n\n        public double[] Quotient { get; }\n        public double[] Remainder { get; }\n    }\n\n    class Program {\n        static int PolyDegree(double[] p) {\n            for (int i = p.Length - 1; i >= 0; --i) {\n                if (p[i] != 0.0) return i;\n            }\n            return int.MinValue;\n        }\n\n        static double[] PolyShiftRight(double[] p, int places) {\n            if (places <= 0) return p;\n            int pd = PolyDegree(p);\n            if (pd + places >= p.Length) {\n                throw new ArgumentOutOfRangeException(\"The number of places to be shifted is too large\");\n            }\n            double[] d = new double[p.Length];\n            p.CopyTo(d, 0);\n            for (int i = pd; i >= 0; --i) {\n                d[i + places] = d[i];\n                d[i] = 0.0;\n            }\n            return d;\n        }\n\n        static void PolyMultiply(double[] p, double m) {\n            for (int i = 0; i < p.Length; ++i) {\n                p[i] *= m;\n            }\n        }\n\n        static void PolySubtract(double[] p, double[] s) {\n            for (int i = 0; i < p.Length; ++i) {\n                p[i] -= s[i];\n            }\n        }\n\n        static Solution PolyLongDiv(double[] n, double[] d) {\n            if (n.Length != d.Length) {\n                throw new ArgumentException(\"Numerator and denominator vectors must have the same size\");\n            }\n            int nd = PolyDegree(n);\n            int dd = PolyDegree(d);\n            if (dd < 0) {\n                throw new ArgumentException(\"Divisor must have at least one one-zero coefficient\");\n            }\n            if (nd < dd) {\n                throw new ArgumentException(\"The degree of the divisor cannot exceed that of the numerator\");\n            }\n            double[] n2 = new double[n.Length];\n            n.CopyTo(n2, 0);\n            double[] q = new double[n.Length];\n            while (nd >= dd) {\n                double[] d2 = PolyShiftRight(d, nd - dd);\n                q[nd - dd] = n2[nd] / d2[nd];\n                PolyMultiply(d2, q[nd - dd]);\n                PolySubtract(n2, d2);\n                nd = PolyDegree(n2);\n            }\n            return new Solution(q, n2);\n        }\n\n        static void PolyShow(double[] p) {\n            int pd = PolyDegree(p);\n            for (int i = pd; i >= 0; --i) {\n                double coeff = p[i];\n                if (coeff == 0.0) continue;\n                if (coeff == 1.0) {\n                    if (i < pd) {\n                        Console.Write(\" + \");\n                    }\n                } else if (coeff == -1.0) {\n                    if (i < pd) {\n                        Console.Write(\" - \");\n                    } else {\n                        Console.Write(\"-\");\n                    }\n                } else if (coeff < 0.0) {\n                    if (i < pd) {\n                        Console.Write(\" - {0:F1}\", -coeff);\n                    } else {\n                        Console.Write(\"{0:F1}\", coeff);\n                    }\n                } else {\n                    if (i < pd) {\n                        Console.Write(\" + {0:F1}\", coeff);\n                    } else {\n                        Console.Write(\"{0:F1}\", coeff);\n                    }\n                }\n                if (i > 1) Console.Write(\"x^{0}\", i);\n                else if (i == 1) Console.Write(\"x\");\n            }\n            Console.WriteLine();\n        }\n\n        static void Main(string[] args) {\n            double[] n = { -42.0, 0.0, -12.0, 1.0 };\n            double[] d = { -3.0, 1.0, 0.0, 0.0 };\n            Console.Write(\"Numerator  \u00a0: \");\n            PolyShow(n);\n            Console.Write(\"Denominator\u00a0: \");\n            PolyShow(d);\n            Console.WriteLine(\"-------------------------------------\");\n            Solution sol = PolyLongDiv(n, d);\n            Console.Write(\"Quotient   \u00a0: \");\n            PolyShow(sol.Quotient);\n            Console.Write(\"Remainder  \u00a0: \");\n            PolyShow(sol.Remainder);\n        }\n    }\n}\n"}
{"id": 143678, "name": "Polynomial long division", "source": "Translate Swift to Python: protocol Dividable {\n  static func / (lhs: Self, rhs: Self) -> Self\n}\n\nextension Int: Dividable { }\n\nstruct Solution<T> {\n  var quotient: [T]\n  var remainder: [T]\n}\n\nfunc polyDegree<T: SignedNumeric>(_ p: [T]) -> Int {\n  for i in stride(from: p.count - 1, through: 0, by: -1) where p[i] != 0 {\n    return i\n  }\n\n  return Int.min\n}\n\nfunc polyShiftRight<T: SignedNumeric>(p: [T], places: Int) -> [T] {\n  guard places > 0 else {\n    return p\n  }\n\n  let deg = polyDegree(p)\n\n  assert(deg + places < p.count, \"Number of places to shift too large\")\n\n  var res = p\n\n  for i in stride(from: deg, through: 0, by: -1) {\n    res[i + places] = res[i]\n    res[i] = 0\n  }\n\n  return res\n}\n\nfunc polyMul<T: SignedNumeric>(_ p: inout [T], by: T) {\n  for i in 0..<p.count {\n    p[i] *= by\n  }\n}\n\nfunc polySub<T: SignedNumeric>(_ p: inout [T], by: [T]) {\n  for i in 0..<p.count {\n    p[i] -= by[i]\n  }\n}\n\nfunc polyLongDiv<T: SignedNumeric & Dividable>(numerator n: [T], denominator d: [T]) -> Solution<T>? {\n  guard n.count == d.count else {\n    return nil\n  }\n\n  var nDeg = polyDegree(n)\n  let dDeg = polyDegree(d)\n\n  guard dDeg >= 0, nDeg >= dDeg else {\n    return nil\n  }\n\n  var n2 = n\n  var quo = [T](repeating: 0, count: n.count)\n\n  while nDeg >= dDeg {\n    let i = nDeg - dDeg\n    var d2 = polyShiftRight(p: d, places: i)\n\n    quo[i] = n2[nDeg] / d2[nDeg]\n\n    polyMul(&d2, by: quo[i])\n    polySub(&n2, by: d2)\n\n    nDeg = polyDegree(n2)\n  }\n\n  return Solution(quotient: quo, remainder: n2)\n}\n\nfunc polyPrint<T: SignedNumeric & Comparable>(_ p: [T]) {\n  let deg = polyDegree(p)\n\n  for i in stride(from: deg, through: 0, by: -1) where p[i] != 0 {\n    let coeff = p[i]\n\n    switch coeff {\n    case 1 where i < deg:\n      print(\" + \", terminator: \"\")\n    case 1:\n      print(\"\", terminator: \"\")\n    case -1 where i < deg:\n      print(\" - \", terminator: \"\")\n    case -1:\n      print(\"-\", terminator: \"\")\n    case _ where coeff < 0 && i < deg:\n      print(\" - \\(-coeff)\", terminator: \"\")\n    case _ where i < deg:\n      print(\" + \\(coeff)\", terminator: \"\")\n    case _:\n      print(\"\\(coeff)\", terminator: \"\")\n    }\n\n    if i > 1 {\n      print(\"x^\\(i)\", terminator: \"\")\n    } else if i == 1 {\n      print(\"x\", terminator: \"\")\n    }\n  }\n\n  print()\n}\n\nlet n = [-42, 0, -12, 1]\nlet d = [-3, 1, 0, 0]\n\nprint(\"Numerator: \", terminator: \"\")\npolyPrint(n)\nprint(\"Denominator: \", terminator: \"\")\npolyPrint(d)\n\nguard let sol = polyLongDiv(numerator: n, denominator: d) else {\n  fatalError()\n}\n\nprint(\"----------\")\nprint(\"Quotient: \", terminator: \"\")\npolyPrint(sol.quotient)\nprint(\"Remainder: \", terminator: \"\")\npolyPrint(sol.remainder)\n", "target": "\n\nfrom itertools import izip\n\ndef degree(poly):\n    while poly and poly[-1] == 0:\n        poly.pop()   \n    return len(poly)-1\n\ndef poly_div(N, D):\n    dD = degree(D)\n    dN = degree(N)\n    if dD < 0: raise ZeroDivisionError\n    if dN >= dD:\n        q = [0] * dN\n        while dN >= dD:\n            d = [0]*(dN - dD) + D\n            mult = q[dN - dD] = N[-1] / float(d[-1])\n            d = [coeff*mult for coeff in d]\n            N = [coeffN - coeffd for coeffN, coeffd in izip(N, d)]\n            dN = degree(N)\n        r = N\n    else:\n        q = [0]\n        r = N\n    return q, r\n\nif __name__ == '__main__':\n    print \"POLYNOMIAL LONG DIVISION\"\n    N = [-42, 0, -12, 1]\n    D = [-3, 1, 0, 0]\n    print \"  %s / %s =\" % (N,D),\n    print \" %s remainder %s\" % poly_div(N, D)\n"}
{"id": 145334, "name": "Sorting algorithms_Gnome sort", "source": "Translate Swift to C#: func gnomeSort<T: Comparable>(_ a: inout [T]) {\n    var i = 1\n    var j = 2\n    while i < a.count {\n        if a[i - 1] <= a[i] {\n            i = j\n            j += 1\n        } else {\n            a.swapAt(i - 1, i)\n            i -= 1\n            if i == 0 {\n                i = j\n                j += 1\n            }\n        }\n    }\n}\n\nvar array = [10, 8, 4, 3, 1, 9, 0, 2, 7, 5, 6]\nprint(\"before: \\(array)\")\ngnomeSort(&array)\nprint(\" after: \\(array)\")\n", "target": "        public static void gnomeSort(int[] anArray)\n        {\n            int first = 1;\n            int second = 2;\n\n            while (first < anArray.Length)\n            {\n                if (anArray[first - 1] <= anArray[first])\n                {\n                    first = second;\n                    second++;\n                }\n                else\n                {\n                    int tmp = anArray[first - 1];\n                    anArray[first - 1] = anArray[first];\n                    anArray[first] = tmp;\n                    first -= 1;\n                    if (first == 0)\n                    {\n                        first = 1;\n                        second = 2;\n                    }\n                }\n                \n            }\n        }\n"}
{"id": 145336, "name": "Sorting algorithms_Gnome sort", "source": "Translate Swift to Java: func gnomeSort<T: Comparable>(_ a: inout [T]) {\n    var i = 1\n    var j = 2\n    while i < a.count {\n        if a[i - 1] <= a[i] {\n            i = j\n            j += 1\n        } else {\n            a.swapAt(i - 1, i)\n            i -= 1\n            if i == 0 {\n                i = j\n                j += 1\n            }\n        }\n    }\n}\n\nvar array = [10, 8, 4, 3, 1, 9, 0, 2, 7, 5, 6]\nprint(\"before: \\(array)\")\ngnomeSort(&array)\nprint(\" after: \\(array)\")\n", "target": "public static void gnomeSort(int[] a)\n{\n  int i=1;\n  int j=2;\n \n  while(i < a.length) {\n    if ( a[i-1] <= a[i] ) {\n      i = j; j++;\n    } else {\n      int tmp = a[i-1];\n      a[i-1] = a[i];\n      a[i--] = tmp;\n      i = (i==0) ? j++ : i;\n    }\n  }\n}\n"}
{"id": 145337, "name": "Sorting algorithms_Gnome sort", "source": "Translate Swift to Python: func gnomeSort<T: Comparable>(_ a: inout [T]) {\n    var i = 1\n    var j = 2\n    while i < a.count {\n        if a[i - 1] <= a[i] {\n            i = j\n            j += 1\n        } else {\n            a.swapAt(i - 1, i)\n            i -= 1\n            if i == 0 {\n                i = j\n                j += 1\n            }\n        }\n    }\n}\n\nvar array = [10, 8, 4, 3, 1, 9, 0, 2, 7, 5, 6]\nprint(\"before: \\(array)\")\ngnomeSort(&array)\nprint(\" after: \\(array)\")\n", "target": ">>> def gnomesort(a):\n\ti,j,size = 1,2,len(a)\n\twhile i < size:\n\t\tif a[i-1] <= a[i]:\n\t\t\ti,j = j, j+1\n\t\telse:\n\t\t\ta[i-1],a[i] = a[i],a[i-1]\n\t\t\ti -= 1\n\t\t\tif i == 0:\n\t\t\t\ti,j = j, j+1\n\treturn a\n\n>>> gnomesort([3,4,2,5,1,6])\n[1, 2, 3, 4, 5, 6]\n>>>\n"}
{"id": 145695, "name": "9 billion names of God the integer", "source": "Translate Swift to C#: var cache = [[1]]\nfunc namesOfGod(n:Int) -> [Int] {\n    for l in cache.count...n {\n        var r = [0]\n        for x in 1...l {\n            r.append(r[r.count - 1] + cache[l - x][min(x, l-x)])\n        }\n        cache.append(r)\n    }\n    return cache[n]\n}\n\nfunc row(n:Int) -> [Int] {\n    let r = namesOfGod(n)\n    var returnArray = [Int]()\n    for i in 0...n - 1 {\n        returnArray.append(r[i + 1] - r[i])\n    }\n    return returnArray\n}\n\nprintln(\"rows:\")\nfor x in 1...25 {\n    println(\"\\(x): \\(row(x))\")\n}\n\nprintln(\"\\nsums: \")\n\nfor x in [23, 123, 1234, 12345] {\n    cache = [[1]]\n    var array = namesOfGod(x)\n    var numInt = array[array.count - 1]\n    println(\"\\(x): \\(numInt)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace NamesOfGod\n{\n    public class RowSummer\n    {\n        const int N = 100000;\n        public BigInteger[] p;\n\n        private void calc(int n)\n            \n        {\n            p[n] = 0;\n\n            for (int k = 1; k <= n; k++)\n            {\n                int d = n - k * (3 * k - 1) / 2;\n                if (d < 0) break;\n\n                if ((k & 1) != 0) p[n] += p[d];\n                else p[n] -= p[d];\n\n                d -= k;\n                if (d < 0) break;\n\n                if ((k & 1) != 0) p[n] += p[d];\n                else p[n] -= p[d];\n            }\n\n        }\n        public void PrintSums()\n            \n        {\n            p = new BigInteger[N + 1];\n            var idx = new int[] { 23, 123, 1234, 12345, 20000, 30000, 40000, 50000, N, 0 };\n            int at = 0;\n\n            p[0] = 1;\n\n            for (int i = 1; idx[at] > 0; i++)\n            {\n                calc(i);\n                if (i != idx[at]) continue;\n                Console.WriteLine(i + \":\\t\" + p[i]);\n                at++;\n            }\n        }\n    }\n\n    public class RowPrinter\n        \n    {\n        List<List<int>> cache;\n        public RowPrinter()\n        {\n            cache = new List<List<int>> { new List<int> { 1 } };\n        }\n        public List<int> cumu(int n)\n        {\n            for (int l = cache.Count; l < n + 1; l++)\n            {\n                var r = new List<int> { 0 };\n                for (int x = 1; x < l + 1; x++)\n                    r.Add(r.Last() + cache[l - x][Math.Min(x, l - x)]);\n                cache.Add(r);\n            }\n            return cache[n];\n        }\n        public List<int> row(int n)\n        {\n            var r = cumu(n);\n            return (from i in Enumerable.Range(0, n) select r[i + 1] - r[i]).ToList();\n        }\n        public void PrintRows()\n        {\n            var rows = Enumerable.Range(1, 25).Select(x => string.Join(\" \", row(x))).ToList();\n            var widest = rows.Last().Length;\n            foreach (var r in rows)\n                Console.WriteLine(new String(' ', (widest - r.Length) / 2) + r);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args) \n        {\n            var rpr = new RowPrinter();\n            rpr.PrintRows();\n            var ros = new RowSummer();\n            ros.PrintSums();\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 145696, "name": "9 billion names of God the integer", "source": "Translate Swift to C#: var cache = [[1]]\nfunc namesOfGod(n:Int) -> [Int] {\n    for l in cache.count...n {\n        var r = [0]\n        for x in 1...l {\n            r.append(r[r.count - 1] + cache[l - x][min(x, l-x)])\n        }\n        cache.append(r)\n    }\n    return cache[n]\n}\n\nfunc row(n:Int) -> [Int] {\n    let r = namesOfGod(n)\n    var returnArray = [Int]()\n    for i in 0...n - 1 {\n        returnArray.append(r[i + 1] - r[i])\n    }\n    return returnArray\n}\n\nprintln(\"rows:\")\nfor x in 1...25 {\n    println(\"\\(x): \\(row(x))\")\n}\n\nprintln(\"\\nsums: \")\n\nfor x in [23, 123, 1234, 12345] {\n    cache = [[1]]\n    var array = namesOfGod(x)\n    var numInt = array[array.count - 1]\n    println(\"\\(x): \\(numInt)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace NamesOfGod\n{\n    public class RowSummer\n    {\n        const int N = 100000;\n        public BigInteger[] p;\n\n        private void calc(int n)\n            \n        {\n            p[n] = 0;\n\n            for (int k = 1; k <= n; k++)\n            {\n                int d = n - k * (3 * k - 1) / 2;\n                if (d < 0) break;\n\n                if ((k & 1) != 0) p[n] += p[d];\n                else p[n] -= p[d];\n\n                d -= k;\n                if (d < 0) break;\n\n                if ((k & 1) != 0) p[n] += p[d];\n                else p[n] -= p[d];\n            }\n\n        }\n        public void PrintSums()\n            \n        {\n            p = new BigInteger[N + 1];\n            var idx = new int[] { 23, 123, 1234, 12345, 20000, 30000, 40000, 50000, N, 0 };\n            int at = 0;\n\n            p[0] = 1;\n\n            for (int i = 1; idx[at] > 0; i++)\n            {\n                calc(i);\n                if (i != idx[at]) continue;\n                Console.WriteLine(i + \":\\t\" + p[i]);\n                at++;\n            }\n        }\n    }\n\n    public class RowPrinter\n        \n    {\n        List<List<int>> cache;\n        public RowPrinter()\n        {\n            cache = new List<List<int>> { new List<int> { 1 } };\n        }\n        public List<int> cumu(int n)\n        {\n            for (int l = cache.Count; l < n + 1; l++)\n            {\n                var r = new List<int> { 0 };\n                for (int x = 1; x < l + 1; x++)\n                    r.Add(r.Last() + cache[l - x][Math.Min(x, l - x)]);\n                cache.Add(r);\n            }\n            return cache[n];\n        }\n        public List<int> row(int n)\n        {\n            var r = cumu(n);\n            return (from i in Enumerable.Range(0, n) select r[i + 1] - r[i]).ToList();\n        }\n        public void PrintRows()\n        {\n            var rows = Enumerable.Range(1, 25).Select(x => string.Join(\" \", row(x))).ToList();\n            var widest = rows.Last().Length;\n            foreach (var r in rows)\n                Console.WriteLine(new String(' ', (widest - r.Length) / 2) + r);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args) \n        {\n            var rpr = new RowPrinter();\n            rpr.PrintRows();\n            var ros = new RowSummer();\n            ros.PrintSums();\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 145699, "name": "9 billion names of God the integer", "source": "Translate Swift to Java: var cache = [[1]]\nfunc namesOfGod(n:Int) -> [Int] {\n    for l in cache.count...n {\n        var r = [0]\n        for x in 1...l {\n            r.append(r[r.count - 1] + cache[l - x][min(x, l-x)])\n        }\n        cache.append(r)\n    }\n    return cache[n]\n}\n\nfunc row(n:Int) -> [Int] {\n    let r = namesOfGod(n)\n    var returnArray = [Int]()\n    for i in 0...n - 1 {\n        returnArray.append(r[i + 1] - r[i])\n    }\n    return returnArray\n}\n\nprintln(\"rows:\")\nfor x in 1...25 {\n    println(\"\\(x): \\(row(x))\")\n}\n\nprintln(\"\\nsums: \")\n\nfor x in [23, 123, 1234, 12345] {\n    cache = [[1]]\n    var array = namesOfGod(x)\n    var numInt = array[array.count - 1]\n    println(\"\\(x): \\(numInt)\")\n}\n", "target": "import java.math.BigInteger;\nimport java.util.*;\nimport static java.util.Arrays.asList;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\nimport static java.lang.Math.min;\n\npublic class Test {\n\n    static List<BigInteger> cumu(int n) {\n        List<List<BigInteger>> cache = new ArrayList<>();\n        cache.add(asList(BigInteger.ONE));\n\n        for (int L = cache.size(); L < n + 1; L++) {\n            List<BigInteger> r = new ArrayList<>();\n            r.add(BigInteger.ZERO);\n            for (int x = 1; x < L + 1; x++)\n                r.add(r.get(r.size() - 1).add(cache.get(L - x).get(min(x, L - x))));\n            cache.add(r);\n        }\n        return cache.get(n);\n    }\n\n    static List<BigInteger> row(int n) {\n        List<BigInteger> r = cumu(n);\n        return range(0, n).mapToObj(i -> r.get(i + 1).subtract(r.get(i)))\n                .collect(toList());\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Rows:\");\n        for (int x = 1; x < 11; x++)\n            System.out.printf(\"%2d: %s%n\", x, row(x));\n\n        System.out.println(\"\\nSums:\");\n        for (int x : new int[]{23, 123, 1234}) {\n            List<BigInteger> c = cumu(x);\n            System.out.printf(\"%s %s%n\", x, c.get(c.size() - 1));\n        }\n    }\n}\n"}
{"id": 145700, "name": "9 billion names of God the integer", "source": "Translate Swift to Java: var cache = [[1]]\nfunc namesOfGod(n:Int) -> [Int] {\n    for l in cache.count...n {\n        var r = [0]\n        for x in 1...l {\n            r.append(r[r.count - 1] + cache[l - x][min(x, l-x)])\n        }\n        cache.append(r)\n    }\n    return cache[n]\n}\n\nfunc row(n:Int) -> [Int] {\n    let r = namesOfGod(n)\n    var returnArray = [Int]()\n    for i in 0...n - 1 {\n        returnArray.append(r[i + 1] - r[i])\n    }\n    return returnArray\n}\n\nprintln(\"rows:\")\nfor x in 1...25 {\n    println(\"\\(x): \\(row(x))\")\n}\n\nprintln(\"\\nsums: \")\n\nfor x in [23, 123, 1234, 12345] {\n    cache = [[1]]\n    var array = namesOfGod(x)\n    var numInt = array[array.count - 1]\n    println(\"\\(x): \\(numInt)\")\n}\n", "target": "import java.math.BigInteger;\nimport java.util.*;\nimport static java.util.Arrays.asList;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\nimport static java.lang.Math.min;\n\npublic class Test {\n\n    static List<BigInteger> cumu(int n) {\n        List<List<BigInteger>> cache = new ArrayList<>();\n        cache.add(asList(BigInteger.ONE));\n\n        for (int L = cache.size(); L < n + 1; L++) {\n            List<BigInteger> r = new ArrayList<>();\n            r.add(BigInteger.ZERO);\n            for (int x = 1; x < L + 1; x++)\n                r.add(r.get(r.size() - 1).add(cache.get(L - x).get(min(x, L - x))));\n            cache.add(r);\n        }\n        return cache.get(n);\n    }\n\n    static List<BigInteger> row(int n) {\n        List<BigInteger> r = cumu(n);\n        return range(0, n).mapToObj(i -> r.get(i + 1).subtract(r.get(i)))\n                .collect(toList());\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Rows:\");\n        for (int x = 1; x < 11; x++)\n            System.out.printf(\"%2d: %s%n\", x, row(x));\n\n        System.out.println(\"\\nSums:\");\n        for (int x : new int[]{23, 123, 1234}) {\n            List<BigInteger> c = cumu(x);\n            System.out.printf(\"%s %s%n\", x, c.get(c.size() - 1));\n        }\n    }\n}\n"}
{"id": 145701, "name": "9 billion names of God the integer", "source": "Translate Swift to Python: var cache = [[1]]\nfunc namesOfGod(n:Int) -> [Int] {\n    for l in cache.count...n {\n        var r = [0]\n        for x in 1...l {\n            r.append(r[r.count - 1] + cache[l - x][min(x, l-x)])\n        }\n        cache.append(r)\n    }\n    return cache[n]\n}\n\nfunc row(n:Int) -> [Int] {\n    let r = namesOfGod(n)\n    var returnArray = [Int]()\n    for i in 0...n - 1 {\n        returnArray.append(r[i + 1] - r[i])\n    }\n    return returnArray\n}\n\nprintln(\"rows:\")\nfor x in 1...25 {\n    println(\"\\(x): \\(row(x))\")\n}\n\nprintln(\"\\nsums: \")\n\nfor x in [23, 123, 1234, 12345] {\n    cache = [[1]]\n    var array = namesOfGod(x)\n    var numInt = array[array.count - 1]\n    println(\"\\(x): \\(numInt)\")\n}\n", "target": "cache = [[1]]\ndef cumu(n):\n    for l in range(len(cache), n+1):\n        r = [0]\n        for x in range(1, l+1):\n            r.append(r[-1] + cache[l-x][min(x, l-x)])\n        cache.append(r)\n    return cache[n]\n\ndef row(n):\n    r = cumu(n)\n    return [r[i+1] - r[i] for i in range(n)]\n\nprint \"rows:\"\nfor x in range(1, 11): print \"%2d:\"%x, row(x)\n\n\nprint \"\\nsums:\"\nfor x in [23, 123, 1234, 12345]: print x, cumu(x)[-1]\n"}
{"id": 145702, "name": "9 billion names of God the integer", "source": "Translate Swift to Python: var cache = [[1]]\nfunc namesOfGod(n:Int) -> [Int] {\n    for l in cache.count...n {\n        var r = [0]\n        for x in 1...l {\n            r.append(r[r.count - 1] + cache[l - x][min(x, l-x)])\n        }\n        cache.append(r)\n    }\n    return cache[n]\n}\n\nfunc row(n:Int) -> [Int] {\n    let r = namesOfGod(n)\n    var returnArray = [Int]()\n    for i in 0...n - 1 {\n        returnArray.append(r[i + 1] - r[i])\n    }\n    return returnArray\n}\n\nprintln(\"rows:\")\nfor x in 1...25 {\n    println(\"\\(x): \\(row(x))\")\n}\n\nprintln(\"\\nsums: \")\n\nfor x in [23, 123, 1234, 12345] {\n    cache = [[1]]\n    var array = namesOfGod(x)\n    var numInt = array[array.count - 1]\n    println(\"\\(x): \\(numInt)\")\n}\n", "target": "cache = [[1]]\ndef cumu(n):\n    for l in range(len(cache), n+1):\n        r = [0]\n        for x in range(1, l+1):\n            r.append(r[-1] + cache[l-x][min(x, l-x)])\n        cache.append(r)\n    return cache[n]\n\ndef row(n):\n    r = cumu(n)\n    return [r[i+1] - r[i] for i in range(n)]\n\nprint \"rows:\"\nfor x in range(1, 11): print \"%2d:\"%x, row(x)\n\n\nprint \"\\nsums:\"\nfor x in [23, 123, 1234, 12345]: print x, cumu(x)[-1]\n"}
{"id": 146197, "name": "Balanced brackets", "source": "Translate Swift to C#: import Foundation\n\nfunc isBal(str: String) -> Bool {\n  \n  var count = 0\n  \n  return !str.characters.contains { ($0 == \"[\"  ? ++count : --count) < 0 } && count == 0\n  \n}\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static bool IsBalanced(string text, char open = '[', char close = ']')\n    {\n        var level = 0;\n        foreach (var character in text)\n        {\n            if (character == close)\n            {\n                if (level == 0)\n                {\n                    return false;\n                }\n                level--;\n            }\n            if (character == open)\n            {\n                level++;\n            }\n        }\n        return level == 0;\n    }\n\n    static string RandomBrackets(int count, char open = '[', char close = ']')\n    {\n        var random = new Random();\n        return string.Join(string.Empty,\n                (new string(open, count) + new string(close, count)).OrderBy(c => random.Next()));\n    }\n\n    static void Main()\n    {\n        for (var count = 0; count < 9; count++)\n        {\n            var text = RandomBrackets(count);\n            Console.WriteLine(\"\\\"{0}\\\" is {1}balanced.\", text, IsBalanced(text) ? string.Empty : \"not \");\n        }\n    }\n}\n"}
{"id": 146200, "name": "Balanced brackets", "source": "Translate Swift to Java: import Foundation\n\nfunc isBal(str: String) -> Bool {\n  \n  var count = 0\n  \n  return !str.characters.contains { ($0 == \"[\"  ? ++count : --count) < 0 } && count == 0\n  \n}\n", "target": "module BalancedBrackets\n    {\n    Boolean balanced(String text)\n        {\n        Int depth = 0;\n        for (Char ch : text)\n            {\n            switch (ch, depth)\n                {\n                case ('[', _):\n                    ++depth;\n                    break;\n                case (']', 0):\n                    return False;\n                case (']', _):\n                    --depth;\n                    break;\n                }\n            }\n        return depth==0;\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        String[] tests =\n            [\n            \"[]\",\n            \"[][]\",\n            \"[]][[]\",\n            \"[[[]][]]\",\n            \"][[[[]][]]\",\n            \"[[[]][[]][]]\",\n            \"]][[]][[[[][]]\",\n            \"[[]]]][]][[][[[]\",\n            ];\n        Int longest = tests.map(s -> s.size).reduce(0, (max, len) -> max.maxOf(len));\n        for (String test : tests)\n            {\n            console.print($\"{test}{' ' * (longest-test.size)} {balanced(test)\u00a0? \"OK\"\u00a0: \"NOT OK\"}\");\n            }\n        }\n    }\n"}
{"id": 146201, "name": "Balanced brackets", "source": "Translate Swift to Java: import Foundation\n\nfunc isBal(str: String) -> Bool {\n  \n  var count = 0\n  \n  return !str.characters.contains { ($0 == \"[\"  ? ++count : --count) < 0 } && count == 0\n  \n}\n", "target": "module BalancedBrackets\n    {\n    Boolean balanced(String text)\n        {\n        Int depth = 0;\n        for (Char ch : text)\n            {\n            switch (ch, depth)\n                {\n                case ('[', _):\n                    ++depth;\n                    break;\n                case (']', 0):\n                    return False;\n                case (']', _):\n                    --depth;\n                    break;\n                }\n            }\n        return depth==0;\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        String[] tests =\n            [\n            \"[]\",\n            \"[][]\",\n            \"[]][[]\",\n            \"[[[]][]]\",\n            \"][[[[]][]]\",\n            \"[[[]][[]][]]\",\n            \"]][[]][[[[][]]\",\n            \"[[]]]][]][[][[[]\",\n            ];\n        Int longest = tests.map(s -> s.size).reduce(0, (max, len) -> max.maxOf(len));\n        for (String test : tests)\n            {\n            console.print($\"{test}{' ' * (longest-test.size)} {balanced(test)\u00a0? \"OK\"\u00a0: \"NOT OK\"}\");\n            }\n        }\n    }\n"}
{"id": 146202, "name": "Balanced brackets", "source": "Translate Swift to Python: import Foundation\n\nfunc isBal(str: String) -> Bool {\n  \n  var count = 0\n  \n  return !str.characters.contains { ($0 == \"[\"  ? ++count : --count) < 0 } && count == 0\n  \n}\n", "target": ">>> def gen(N):\n...     txt = ['[', ']'] * N\n...     random.shuffle( txt )\n...     return ''.join(txt)\n... \n>>> def balanced(txt):\n...     braced = 0\n...     for ch in txt:\n...         if ch == '[': braced += 1\n...         if ch == ']':\n...             braced -= 1\n...             if braced < 0: return False\n...     return braced == 0\n... \n>>> for txt in (gen(N) for N in range(10)):\n...     print (\"%-22r is%s balanced\" % (txt, '' if balanced(txt) else ' not'))\n... \n''                     is balanced\n'[]'                   is balanced\n'[][]'                 is balanced\n'][[[]]'               is not balanced\n'[]][[][]'             is not balanced\n'[][[][]]]['           is not balanced\n'][]][][[]][['         is not balanced\n'[[]]]]][]][[[['       is not balanced\n'[[[[]][]]][[][]]'     is balanced\n'][[][[]]][]]][[[[]'   is not balanced\n"}
{"id": 146203, "name": "Balanced brackets", "source": "Translate Swift to Python: import Foundation\n\nfunc isBal(str: String) -> Bool {\n  \n  var count = 0\n  \n  return !str.characters.contains { ($0 == \"[\"  ? ++count : --count) < 0 } && count == 0\n  \n}\n", "target": ">>> def gen(N):\n...     txt = ['[', ']'] * N\n...     random.shuffle( txt )\n...     return ''.join(txt)\n... \n>>> def balanced(txt):\n...     braced = 0\n...     for ch in txt:\n...         if ch == '[': braced += 1\n...         if ch == ']':\n...             braced -= 1\n...             if braced < 0: return False\n...     return braced == 0\n... \n>>> for txt in (gen(N) for N in range(10)):\n...     print (\"%-22r is%s balanced\" % (txt, '' if balanced(txt) else ' not'))\n... \n''                     is balanced\n'[]'                   is balanced\n'[][]'                 is balanced\n'][[[]]'               is not balanced\n'[]][[][]'             is not balanced\n'[][[][]]]['           is not balanced\n'][]][][[]][['         is not balanced\n'[[]]]]][]][[[['       is not balanced\n'[[[[]][]]][[][]]'     is balanced\n'][[][[]]][]]][[[[]'   is not balanced\n"}
{"id": 146490, "name": "Numerical integration", "source": "Translate Swift to C#: public enum IntegrationType : CaseIterable {\n  case rectangularLeft\n  case rectangularRight\n  case rectangularMidpoint\n  case trapezium\n  case simpson\n}\n\npublic func integrate(\n  from: Double,\n  to: Double,\n  n: Int,\n  using: IntegrationType = .simpson,\n  f: (Double) -> Double\n) -> Double {\n  let integrationFunc: (Double, Double, Int, (Double) -> Double) -> Double\n\n  switch using {\n  case .rectangularLeft:\n    integrationFunc = integrateRectL\n  case .rectangularRight:\n    integrationFunc = integrateRectR\n  case .rectangularMidpoint:\n    integrationFunc = integrateRectMid\n  case .trapezium:\n    integrationFunc = integrateTrapezium\n  case .simpson:\n    integrationFunc = integrateSimpson\n  }\n\n  return integrationFunc(from, to, n, f)\n}\n\nprivate func integrateRectL(from: Double, to: Double, n: Int, f: (Double) -> Double) -> Double {\n  let h = (to - from) / Double(n)\n  var x = from\n  var sum = 0.0\n\n  while x <= to - h {\n    sum += f(x)\n    x += h\n  }\n\n  return h * sum\n}\n\nprivate func integrateRectR(from: Double, to: Double, n: Int, f: (Double) -> Double) -> Double {\n  let h = (to - from) / Double(n)\n  var x = from\n  var sum = 0.0\n\n  while x <= to - h {\n    sum += f(x + h)\n    x += h\n  }\n\n  return h * sum\n}\n\nprivate func integrateRectMid(from: Double, to: Double, n: Int, f: (Double) -> Double) -> Double {\n  let h = (to - from) / Double(n)\n  var x = from\n  var sum = 0.0\n\n  while x <= to - h {\n    sum += f(x + h / 2.0)\n    x += h\n  }\n\n  return h * sum\n}\n\nprivate func integrateTrapezium(from: Double, to: Double, n: Int, f: (Double) -> Double) -> Double {\n  let h = (to - from) / Double(n)\n  var sum = f(from) + f(to)\n\n  for i in 1..<n {\n    sum += 2 * f(from + Double(i) * h)\n  }\n\n  return h * sum / 2\n}\n\nprivate func integrateSimpson(from: Double, to: Double, n: Int, f: (Double) -> Double) -> Double {\n  let h = (to - from) / Double(n)\n  var sum1 = 0.0\n  var sum2 = 0.0\n\n  for i in 0..<n {\n    sum1 += f(from + h * Double(i) + h / 2.0)\n  }\n\n  for i in 1..<n {\n    sum2 += f(from + h * Double(i))\n  }\n\n  return h / 6.0 * (f(from) + f(to) + 4.0 * sum1 + 2.0 * sum2)\n}\n\nlet types = IntegrationType.allCases\n\nprint(\"f(x) = x^3:\", types.map({ integrate(from: 0, to: 1, n: 100, using: $0, f: { pow($0, 3) }) }))\nprint(\"f(x) = 1 / x:\", types.map({ integrate(from: 1, to: 100, n: 1000, using: $0, f: { 1 / $0 }) }))\nprint(\"f(x) = x, 0 -> 5_000:\", types.map({ integrate(from: 0, to: 5_000, n: 5_000_000, using: $0, f: { $0 }) }))\nprint(\"f(x) = x, 0 -> 6_000:\", types.map({ integrate(from: 0, to: 6_000, n: 6_000_000, using: $0, f: { $0 }) }))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Interval\n{\n    public Interval(double leftEndpoint, double size)\n    {\n        LeftEndpoint = leftEndpoint;\n        RightEndpoint = leftEndpoint + size;\n    }\n\n    public double LeftEndpoint\n    {\n        get;\n        set;\n    }\n\n    public double RightEndpoint\n    {\n        get;\n        set;\n    }\n\n    public double Size\n    {\n        get\n        {\n            return RightEndpoint - LeftEndpoint;\n        }\n    }\n\n    public double Center\n    {\n        get\n        {\n            return (LeftEndpoint + RightEndpoint) / 2;\n        }\n    }\n\n    public IEnumerable<Interval> Subdivide(int subintervalCount)\n    {\n        double subintervalSize = Size / subintervalCount;\n        return Enumerable.Range(0, subintervalCount).Select(index => new Interval(LeftEndpoint + index * subintervalSize, subintervalSize));\n    }\n}\n\npublic class DefiniteIntegral\n{\n    public DefiniteIntegral(Func<double, double> integrand, Interval domain)\n    {\n        Integrand = integrand;\n        Domain = domain;\n    }\n\n    public Func<double, double> Integrand\n    {\n        get;\n        set;\n    }\n\n    public Interval Domain\n    {\n        get;\n        set;\n    }\n\n    public double SampleIntegrand(ApproximationMethod approximationMethod, Interval subdomain)\n    {\n        switch (approximationMethod)\n        {\n            case ApproximationMethod.RectangleLeft:\n                return Integrand(subdomain.LeftEndpoint);\n            case ApproximationMethod.RectangleMidpoint:\n                return Integrand(subdomain.Center);\n            case ApproximationMethod.RectangleRight:\n                return Integrand(subdomain.RightEndpoint);\n            case ApproximationMethod.Trapezium:\n                return (Integrand(subdomain.LeftEndpoint) + Integrand(subdomain.RightEndpoint)) / 2;\n            case ApproximationMethod.Simpson:\n                return (Integrand(subdomain.LeftEndpoint) + 4 * Integrand(subdomain.Center) + Integrand(subdomain.RightEndpoint)) / 6;\n            default:\n                throw new NotImplementedException();\n        }\n    }\n\n    public double Approximate(ApproximationMethod approximationMethod, int subdomainCount)\n    {\n        return Domain.Size * Domain.Subdivide(subdomainCount).Sum(subdomain => SampleIntegrand(approximationMethod, subdomain)) / subdomainCount;\n    }\n\n    public enum ApproximationMethod\n    {\n        RectangleLeft,\n        RectangleMidpoint,\n        RectangleRight,\n        Trapezium,\n        Simpson\n    }\n}\n\npublic class Program\n{\n    private static void TestApproximationMethods(DefiniteIntegral integral, int subdomainCount)\n    {\n        foreach (DefiniteIntegral.ApproximationMethod approximationMethod in Enum.GetValues(typeof(DefiniteIntegral.ApproximationMethod)))\n        {\n            Console.WriteLine(integral.Approximate(approximationMethod, subdomainCount));\n        }\n    }\n\n    public static void Main()\n    {\n        TestApproximationMethods(new DefiniteIntegral(x => x * x * x, new Interval(0, 1)), 10000);\n        TestApproximationMethods(new DefiniteIntegral(x => 1 / x, new Interval(1, 99)), 1000);\n        TestApproximationMethods(new DefiniteIntegral(x => x, new Interval(0, 5000)), 500000);\n        TestApproximationMethods(new DefiniteIntegral(x => x, new Interval(0, 6000)), 6000000);\n    }\n}\n"}
{"id": 146492, "name": "Numerical integration", "source": "Translate Swift to Java: public enum IntegrationType : CaseIterable {\n  case rectangularLeft\n  case rectangularRight\n  case rectangularMidpoint\n  case trapezium\n  case simpson\n}\n\npublic func integrate(\n  from: Double,\n  to: Double,\n  n: Int,\n  using: IntegrationType = .simpson,\n  f: (Double) -> Double\n) -> Double {\n  let integrationFunc: (Double, Double, Int, (Double) -> Double) -> Double\n\n  switch using {\n  case .rectangularLeft:\n    integrationFunc = integrateRectL\n  case .rectangularRight:\n    integrationFunc = integrateRectR\n  case .rectangularMidpoint:\n    integrationFunc = integrateRectMid\n  case .trapezium:\n    integrationFunc = integrateTrapezium\n  case .simpson:\n    integrationFunc = integrateSimpson\n  }\n\n  return integrationFunc(from, to, n, f)\n}\n\nprivate func integrateRectL(from: Double, to: Double, n: Int, f: (Double) -> Double) -> Double {\n  let h = (to - from) / Double(n)\n  var x = from\n  var sum = 0.0\n\n  while x <= to - h {\n    sum += f(x)\n    x += h\n  }\n\n  return h * sum\n}\n\nprivate func integrateRectR(from: Double, to: Double, n: Int, f: (Double) -> Double) -> Double {\n  let h = (to - from) / Double(n)\n  var x = from\n  var sum = 0.0\n\n  while x <= to - h {\n    sum += f(x + h)\n    x += h\n  }\n\n  return h * sum\n}\n\nprivate func integrateRectMid(from: Double, to: Double, n: Int, f: (Double) -> Double) -> Double {\n  let h = (to - from) / Double(n)\n  var x = from\n  var sum = 0.0\n\n  while x <= to - h {\n    sum += f(x + h / 2.0)\n    x += h\n  }\n\n  return h * sum\n}\n\nprivate func integrateTrapezium(from: Double, to: Double, n: Int, f: (Double) -> Double) -> Double {\n  let h = (to - from) / Double(n)\n  var sum = f(from) + f(to)\n\n  for i in 1..<n {\n    sum += 2 * f(from + Double(i) * h)\n  }\n\n  return h * sum / 2\n}\n\nprivate func integrateSimpson(from: Double, to: Double, n: Int, f: (Double) -> Double) -> Double {\n  let h = (to - from) / Double(n)\n  var sum1 = 0.0\n  var sum2 = 0.0\n\n  for i in 0..<n {\n    sum1 += f(from + h * Double(i) + h / 2.0)\n  }\n\n  for i in 1..<n {\n    sum2 += f(from + h * Double(i))\n  }\n\n  return h / 6.0 * (f(from) + f(to) + 4.0 * sum1 + 2.0 * sum2)\n}\n\nlet types = IntegrationType.allCases\n\nprint(\"f(x) = x^3:\", types.map({ integrate(from: 0, to: 1, n: 100, using: $0, f: { pow($0, 3) }) }))\nprint(\"f(x) = 1 / x:\", types.map({ integrate(from: 1, to: 100, n: 1000, using: $0, f: { 1 / $0 }) }))\nprint(\"f(x) = x, 0 -> 5_000:\", types.map({ integrate(from: 0, to: 5_000, n: 5_000_000, using: $0, f: { $0 }) }))\nprint(\"f(x) = x, 0 -> 6_000:\", types.map({ integrate(from: 0, to: 6_000, n: 6_000_000, using: $0, f: { $0 }) }))\n", "target": "class NumericalIntegration\n{\n\n  interface FPFunction\n  {\n    double eval(double n);\n  }\n  \n  public static double rectangularLeft(double a, double b, int n, FPFunction f)\n  {\n    return rectangular(a, b, n, f, 0);\n  }\n  \n  public static double rectangularMidpoint(double a, double b, int n, FPFunction f)\n  {\n    return rectangular(a, b, n, f, 1);\n  }\n  \n  public static double rectangularRight(double a, double b, int n, FPFunction f)\n  {\n    return rectangular(a, b, n, f, 2);\n  }\n  \n  public static double trapezium(double a, double b, int n, FPFunction f)\n  {\n    double range = checkParamsGetRange(a, b, n);\n    double nFloat = (double)n;\n    double sum = 0.0;\n    for (int i = 1; i < n; i++)\n    {\n      double x = a + range * (double)i / nFloat;\n      sum += f.eval(x);\n    }\n    sum += (f.eval(a) + f.eval(b)) / 2.0;\n    return sum * range / nFloat;\n  }\n  \n  public static double simpsons(double a, double b, int n, FPFunction f)\n  {\n    double range = checkParamsGetRange(a, b, n);\n    double nFloat = (double)n;\n    double sum1 = f.eval(a + range / (nFloat * 2.0));\n    double sum2 = 0.0;\n    for (int i = 1; i < n; i++)\n    {\n      double x1 = a + range * ((double)i + 0.5) / nFloat;\n      sum1 += f.eval(x1);\n      double x2 = a + range * (double)i / nFloat;\n      sum2 += f.eval(x2);\n    }\n    return (f.eval(a) + f.eval(b) + sum1 * 4.0 + sum2 * 2.0) * range / (nFloat * 6.0);\n  }\n  \n  private static double rectangular(double a, double b, int n, FPFunction f, int mode)\n  {\n    double range = checkParamsGetRange(a, b, n);\n    double modeOffset = (double)mode / 2.0;\n    double nFloat = (double)n;\n    double sum = 0.0;\n    for (int i = 0; i < n; i++)\n    {\n      double x = a + range * ((double)i + modeOffset) / nFloat;\n      sum += f.eval(x);\n    }\n    return sum * range / nFloat;\n  }\n  \n  private static double checkParamsGetRange(double a, double b, int n)\n  {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid value of n\");\n    double range = b - a;\n    if (range <= 0)\n      throw new IllegalArgumentException(\"Invalid range\");\n    return range;\n  }\n  \n  \n  private static void testFunction(String fname, double a, double b, int n, FPFunction f)\n  {\n    System.out.println(\"Testing function \\\"\" + fname + \"\\\", a=\" + a + \", b=\" + b + \", n=\" + n);\n    System.out.println(\"rectangularLeft: \" + rectangularLeft(a, b, n, f));\n    System.out.println(\"rectangularMidpoint: \" + rectangularMidpoint(a, b, n, f));\n    System.out.println(\"rectangularRight: \" + rectangularRight(a, b, n, f));\n    System.out.println(\"trapezium: \" + trapezium(a, b, n, f));\n    System.out.println(\"simpsons: \" + simpsons(a, b, n, f));\n    System.out.println();\n    return;\n  }\n  \n  public static void main(String[] args)\n  {\n    testFunction(\"x^3\", 0.0, 1.0, 100, new FPFunction() {\n        public double eval(double n) {\n          return n * n * n;\n        }\n      }\n    );\n    \n    testFunction(\"1/x\", 1.0, 100.0, 1000, new FPFunction() {\n        public double eval(double n) {\n          return 1.0 / n;\n        }\n      }\n    );\n    \n    testFunction(\"x\", 0.0, 5000.0, 5000000, new FPFunction() {\n        public double eval(double n) {\n          return n;\n        }\n      }\n    );\n    \n    testFunction(\"x\", 0.0, 6000.0, 6000000, new FPFunction() {\n        public double eval(double n) {\n          return n;\n        }\n      }\n    );\n    \n    return;\n  }\n}\n"}
{"id": 146493, "name": "Numerical integration", "source": "Translate Swift to Python: public enum IntegrationType : CaseIterable {\n  case rectangularLeft\n  case rectangularRight\n  case rectangularMidpoint\n  case trapezium\n  case simpson\n}\n\npublic func integrate(\n  from: Double,\n  to: Double,\n  n: Int,\n  using: IntegrationType = .simpson,\n  f: (Double) -> Double\n) -> Double {\n  let integrationFunc: (Double, Double, Int, (Double) -> Double) -> Double\n\n  switch using {\n  case .rectangularLeft:\n    integrationFunc = integrateRectL\n  case .rectangularRight:\n    integrationFunc = integrateRectR\n  case .rectangularMidpoint:\n    integrationFunc = integrateRectMid\n  case .trapezium:\n    integrationFunc = integrateTrapezium\n  case .simpson:\n    integrationFunc = integrateSimpson\n  }\n\n  return integrationFunc(from, to, n, f)\n}\n\nprivate func integrateRectL(from: Double, to: Double, n: Int, f: (Double) -> Double) -> Double {\n  let h = (to - from) / Double(n)\n  var x = from\n  var sum = 0.0\n\n  while x <= to - h {\n    sum += f(x)\n    x += h\n  }\n\n  return h * sum\n}\n\nprivate func integrateRectR(from: Double, to: Double, n: Int, f: (Double) -> Double) -> Double {\n  let h = (to - from) / Double(n)\n  var x = from\n  var sum = 0.0\n\n  while x <= to - h {\n    sum += f(x + h)\n    x += h\n  }\n\n  return h * sum\n}\n\nprivate func integrateRectMid(from: Double, to: Double, n: Int, f: (Double) -> Double) -> Double {\n  let h = (to - from) / Double(n)\n  var x = from\n  var sum = 0.0\n\n  while x <= to - h {\n    sum += f(x + h / 2.0)\n    x += h\n  }\n\n  return h * sum\n}\n\nprivate func integrateTrapezium(from: Double, to: Double, n: Int, f: (Double) -> Double) -> Double {\n  let h = (to - from) / Double(n)\n  var sum = f(from) + f(to)\n\n  for i in 1..<n {\n    sum += 2 * f(from + Double(i) * h)\n  }\n\n  return h * sum / 2\n}\n\nprivate func integrateSimpson(from: Double, to: Double, n: Int, f: (Double) -> Double) -> Double {\n  let h = (to - from) / Double(n)\n  var sum1 = 0.0\n  var sum2 = 0.0\n\n  for i in 0..<n {\n    sum1 += f(from + h * Double(i) + h / 2.0)\n  }\n\n  for i in 1..<n {\n    sum2 += f(from + h * Double(i))\n  }\n\n  return h / 6.0 * (f(from) + f(to) + 4.0 * sum1 + 2.0 * sum2)\n}\n\nlet types = IntegrationType.allCases\n\nprint(\"f(x) = x^3:\", types.map({ integrate(from: 0, to: 1, n: 100, using: $0, f: { pow($0, 3) }) }))\nprint(\"f(x) = 1 / x:\", types.map({ integrate(from: 1, to: 100, n: 1000, using: $0, f: { 1 / $0 }) }))\nprint(\"f(x) = x, 0 -> 5_000:\", types.map({ integrate(from: 0, to: 5_000, n: 5_000_000, using: $0, f: { $0 }) }))\nprint(\"f(x) = x, 0 -> 6_000:\", types.map({ integrate(from: 0, to: 6_000, n: 6_000_000, using: $0, f: { $0 }) }))\n", "target": "from fractions import Fraction\n\ndef left_rect(f,x,h):\n  return f(x)\n \ndef mid_rect(f,x,h):\n  return f(x + h/2)\n \ndef right_rect(f,x,h):\n  return f(x+h)\n \ndef trapezium(f,x,h):\n  return (f(x) + f(x+h))/2.0\n \ndef simpson(f,x,h):\n  return (f(x) + 4*f(x + h/2) + f(x+h))/6.0\n \ndef cube(x):\n  return x*x*x\n \ndef reciprocal(x):\n  return 1/x\n \ndef identity(x):\n  return x\n \ndef integrate( f, a, b, steps, meth):\n   h = (b-a)/steps\n   ival = h * sum(meth(f, a+i*h, h) for i in range(steps))\n   return ival  \n\n\nfor a, b, steps, func in ((0., 1., 100, cube), (1., 100., 1000, reciprocal)):\n    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):\n        print('%s integrated using %s\\n  from %r to %r (%i steps) = %r' %\n              (func.__name__, rule.__name__, a, b, steps,\n               integrate( func, a, b, steps, rule)))\n    a, b = Fraction.from_float(a), Fraction.from_float(b)\n    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):\n        print('%s integrated using %s\\n  from %r to %r (%i steps and fractions) = %r' %\n              (func.__name__, rule.__name__, a, b, steps,\n               float(integrate( func, a, b, steps, rule))))\n\n\nfor a, b, steps, func in ((0., 5000., 5000000, identity),\n                          (0., 6000., 6000000, identity)):\n    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):\n        print('%s integrated using %s\\n  from %r to %r (%i steps) = %r' %\n              (func.__name__, rule.__name__, a, b, steps,\n               integrate( func, a, b, steps, rule)))\n    a, b = Fraction.from_float(a), Fraction.from_float(b)\n    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):\n        print('%s integrated using %s\\n  from %r to %r (%i steps and fractions) = %r' %\n              (func.__name__, rule.__name__, a, b, steps,\n               float(integrate( func, a, b, steps, rule))))\n"}
{"id": 146981, "name": "Number names", "source": "Translate Swift to C#: extension Int {\n  private static let bigNames = [\n    1_000: \"thousand\",\n    1_000_000: \"million\",\n    1_000_000_000: \"billion\",\n    1_000_000_000_000: \"trillion\",\n    1_000_000_000_000_000: \"quadrillion\",\n    1_000_000_000_000_000_000: \"quintillion\"\n  ]\n\n  private static let names = [\n    1: \"one\",\n    2: \"two\",\n    3: \"three\",\n    4: \"four\",\n    5: \"five\",\n    6: \"six\",\n    7: \"seven\",\n    8: \"eight\",\n    9: \"nine\",\n    10: \"ten\",\n    11: \"eleven\",\n    12: \"twelve\",\n    13: \"thirteen\",\n    14: \"fourteen\",\n    15: \"fifteen\",\n    16: \"sixteen\",\n    17: \"seventeen\",\n    18: \"eighteen\",\n    19: \"nineteen\",\n    20: \"twenty\",\n    30: \"thirty\",\n    40: \"forty\",\n    50: \"fifty\",\n    60: \"sixty\",\n    70: \"seventy\",\n    80: \"eighty\",\n    90: \"ninety\"\n  ]\n\n  public var numberName: String {\n    guard self != 0 else {\n      return \"zero\"\n    }\n\n    let neg = self < 0\n    let maxNeg = self == Int.min\n    var nn: Int\n\n    if maxNeg {\n      nn = -(self + 1)\n    } else if neg {\n      nn = -self\n    } else {\n      nn = self\n    }\n\n    var digits3 = [Int](repeating: 0, count: 7)\n\n    for i in 0..<7 {\n      digits3[i] = (nn % 1000)\n      nn /= 1000\n    }\n\n    func threeDigitsToText(n: Int) -> String {\n      guard n != 0 else {\n        return \"\"\n      }\n\n      var ret = \"\"\n\n      let hundreds = n / 100\n      let remainder = n % 100\n\n      if hundreds > 0 {\n        ret += \"\\(Int.names[hundreds]!) hundred\"\n\n        if remainder > 0 {\n          ret += \" \"\n        }\n      }\n\n      if remainder > 0 {\n        let tens = remainder / 10\n        let units = remainder % 10\n\n        if tens > 1 {\n          ret += Int.names[tens * 10]!\n\n          if units > 0 {\n            ret += \"-\\(Int.names[units]!)\"\n          }\n        } else {\n          ret += Int.names[remainder]!\n        }\n      }\n\n      return ret\n    }\n\n    let strings = (0..<7).map({ threeDigitsToText(n: digits3[$0]) })\n    var name = strings[0]\n    var big = 1000\n\n    for i in 1...6 {\n      if digits3[i] > 0 {\n        var name2 = \"\\(strings[i]) \\(Int.bigNames[big]!)\"\n\n        if name.count > 0 {\n          name2 += \", \"\n        }\n\n        name = name2 + name\n      }\n\n      big &*= 1000\n    }\n\n    if maxNeg {\n      name = String(name.dropLast(5) + \"eight\")\n    }\n\n    return neg ? \"minus \\(name)\" : name  \n  }\n}\n\nlet nums = [\n  0, 1, 7, 10, 18, 22, 67, 99, 100, 105, 999, -1056, 1000005000,\n  2074000000, 1234000000745003, Int.min\n]\n\nfor number in nums {\n  print(\"\\(number) => \\(number.numberName)\")\n}\n", "target": "using System;\n\nclass NumberNamer {\n    static readonly string[] incrementsOfOne =\n            { \"zero\",    \"one\",     \"two\",       \"three\",    \"four\",\n              \"five\",    \"six\",     \"seven\",     \"eight\",    \"nine\",\n              \"ten\",     \"eleven\",  \"twelve\",    \"thirteen\", \"fourteen\",\n              \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\" };\n\n    static readonly string[] incrementsOfTen =\n            { \"\",      \"\",      \"twenty\",  \"thirty\", \"fourty\",\n              \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\" };\n\n    const string millionName = \"million\",\n                 thousandName = \"thousand\",\n                 hundredName = \"hundred\",\n                 andName = \"and\";\n\n\n    public static string GetName( int i ) {\n        string output = \"\";\n        if( i >= 1000000 ) {\n            output += ParseTriplet( i / 1000000 ) + \" \" + millionName;\n            i %= 1000000;\n            if( i == 0 ) return output;\n        }\n\n        if( i >= 1000 ) {\n            if( output.Length > 0 ) {\n                output += \", \";\n            }\n            output += ParseTriplet( i / 1000 ) + \" \" + thousandName;\n            i %= 1000;\n            if( i == 0 ) return output;\n        }\n\n        if( output.Length > 0 ) {\n            output += \", \";\n        }\n        output += ParseTriplet( i );\n        return output;\n    }\n\n\n    static string ParseTriplet( int i ) {\n        string output = \"\";\n        if( i >= 100 ) {\n            output += incrementsOfOne[i / 100] + \" \" + hundredName;\n            i %= 100;\n            if( i == 0 ) return output;\n        }\n\n        if( output.Length > 0 ) {\n            output += \" \" + andName + \" \";\n        }\n        if( i >= 20 ) {\n            output += incrementsOfTen[i / 10];\n            i %= 10;\n            if( i == 0 ) return output;\n        }\n\n        if( output.Length > 0 ) {\n            output += \" \";\n        }\n        output += incrementsOfOne[i];\n        return output;\n    }\n}\n\n\nclass Program { \n    static void Main( string[] args ) {\n        Console.WriteLine( NumberNamer.GetName( 1 ) );\n        Console.WriteLine( NumberNamer.GetName( 234 ) );\n        Console.WriteLine( NumberNamer.GetName( 31337 ) );\n        Console.WriteLine( NumberNamer.GetName( 987654321 ) );\n    }\n}\n"}
{"id": 146983, "name": "Number names", "source": "Translate Swift to Java: extension Int {\n  private static let bigNames = [\n    1_000: \"thousand\",\n    1_000_000: \"million\",\n    1_000_000_000: \"billion\",\n    1_000_000_000_000: \"trillion\",\n    1_000_000_000_000_000: \"quadrillion\",\n    1_000_000_000_000_000_000: \"quintillion\"\n  ]\n\n  private static let names = [\n    1: \"one\",\n    2: \"two\",\n    3: \"three\",\n    4: \"four\",\n    5: \"five\",\n    6: \"six\",\n    7: \"seven\",\n    8: \"eight\",\n    9: \"nine\",\n    10: \"ten\",\n    11: \"eleven\",\n    12: \"twelve\",\n    13: \"thirteen\",\n    14: \"fourteen\",\n    15: \"fifteen\",\n    16: \"sixteen\",\n    17: \"seventeen\",\n    18: \"eighteen\",\n    19: \"nineteen\",\n    20: \"twenty\",\n    30: \"thirty\",\n    40: \"forty\",\n    50: \"fifty\",\n    60: \"sixty\",\n    70: \"seventy\",\n    80: \"eighty\",\n    90: \"ninety\"\n  ]\n\n  public var numberName: String {\n    guard self != 0 else {\n      return \"zero\"\n    }\n\n    let neg = self < 0\n    let maxNeg = self == Int.min\n    var nn: Int\n\n    if maxNeg {\n      nn = -(self + 1)\n    } else if neg {\n      nn = -self\n    } else {\n      nn = self\n    }\n\n    var digits3 = [Int](repeating: 0, count: 7)\n\n    for i in 0..<7 {\n      digits3[i] = (nn % 1000)\n      nn /= 1000\n    }\n\n    func threeDigitsToText(n: Int) -> String {\n      guard n != 0 else {\n        return \"\"\n      }\n\n      var ret = \"\"\n\n      let hundreds = n / 100\n      let remainder = n % 100\n\n      if hundreds > 0 {\n        ret += \"\\(Int.names[hundreds]!) hundred\"\n\n        if remainder > 0 {\n          ret += \" \"\n        }\n      }\n\n      if remainder > 0 {\n        let tens = remainder / 10\n        let units = remainder % 10\n\n        if tens > 1 {\n          ret += Int.names[tens * 10]!\n\n          if units > 0 {\n            ret += \"-\\(Int.names[units]!)\"\n          }\n        } else {\n          ret += Int.names[remainder]!\n        }\n      }\n\n      return ret\n    }\n\n    let strings = (0..<7).map({ threeDigitsToText(n: digits3[$0]) })\n    var name = strings[0]\n    var big = 1000\n\n    for i in 1...6 {\n      if digits3[i] > 0 {\n        var name2 = \"\\(strings[i]) \\(Int.bigNames[big]!)\"\n\n        if name.count > 0 {\n          name2 += \", \"\n        }\n\n        name = name2 + name\n      }\n\n      big &*= 1000\n    }\n\n    if maxNeg {\n      name = String(name.dropLast(5) + \"eight\")\n    }\n\n    return neg ? \"minus \\(name)\" : name  \n  }\n}\n\nlet nums = [\n  0, 1, 7, 10, 18, 22, 67, 99, 100, 105, 999, -1056, 1000005000,\n  2074000000, 1234000000745003, Int.min\n]\n\nfor number in nums {\n  print(\"\\(number) => \\(number.numberName)\")\n}\n", "target": "module NumberNames\n    {\n    void run()\n        {\n        @Inject Console console;\n\n        Int[] tests = [0, 1, -1, 11, -17, 42, 99, 100, 101, -111, 1000, 1234, 10000, 100000,\n                       123456789000, 0x123456789ABCDEF];\n        for (Int test : tests)\n            {\n            console.print($\"{test} = {toEnglish(test)}\");\n            }\n        }\n\n    static String[] digits = [\"zero\", \"one\", \"two\", \"three\", \"four\",\n                              \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    static String[] teens  = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\",\n                              \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    static String[] tens   = [\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\",\n                              \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    static String[] ten3rd = [\"?\", \"thousand\", \"million\", \"billion\", \"trillion\",\n                              \"quadrillion\", \"quintillion\"];\n\n    static String toEnglish(Int n)\n        {\n        StringBuffer buf = new StringBuffer();\n        if (n < 0)\n            {\n            \"negative \".appendTo(buf);\n            n = -n;\n            }\n\n        format3digits(n, buf);\n        return buf.toString();\n        }\n\n    static void format3digits(Int n, StringBuffer buf, Int nested=0)\n        {\n        (Int left, Int right) = n /% 1000;\n        if (left != 0)\n            {\n            format3digits(left, buf, nested+1);\n            }\n\n        if (right != 0 || (left == 0 && nested==0))\n            {\n            if (right >= 100)\n                {\n                (left, right) = (right /% 100);\n                digits[left].appendTo(buf);\n                \" hundred \".appendTo(buf);\n                if (right != 0)\n                    {\n                    format2digits(right, buf);\n                    }\n                }\n            else\n                {\n                format2digits(right, buf);\n                }\n\n            if (nested > 0)\n                {\n                ten3rd[nested].appendTo(buf).add(' ');\n                }\n            }\n        }\n\n    static void format2digits(Int n, StringBuffer buf)\n        {\n        switch (n)\n            {\n            case 0..9:\n                digits[n].appendTo(buf).add(' ');\n                break;\n\n            case 10..19:\n                teens[n-10].appendTo(buf).add(' ');\n                break;\n\n            default:\n                (Int left, Int right) = n /% 10;\n                tens[left].appendTo(buf);\n                if (right == 0)\n                    {\n                    buf.add(' ');\n                    }\n                else\n                    {\n                    buf.add('-');\n                    digits[right].appendTo(buf).add(' ');\n                    }\n                break;\n            }\n        }\n    }\n"}
{"id": 146984, "name": "Number names", "source": "Translate Swift to Python: extension Int {\n  private static let bigNames = [\n    1_000: \"thousand\",\n    1_000_000: \"million\",\n    1_000_000_000: \"billion\",\n    1_000_000_000_000: \"trillion\",\n    1_000_000_000_000_000: \"quadrillion\",\n    1_000_000_000_000_000_000: \"quintillion\"\n  ]\n\n  private static let names = [\n    1: \"one\",\n    2: \"two\",\n    3: \"three\",\n    4: \"four\",\n    5: \"five\",\n    6: \"six\",\n    7: \"seven\",\n    8: \"eight\",\n    9: \"nine\",\n    10: \"ten\",\n    11: \"eleven\",\n    12: \"twelve\",\n    13: \"thirteen\",\n    14: \"fourteen\",\n    15: \"fifteen\",\n    16: \"sixteen\",\n    17: \"seventeen\",\n    18: \"eighteen\",\n    19: \"nineteen\",\n    20: \"twenty\",\n    30: \"thirty\",\n    40: \"forty\",\n    50: \"fifty\",\n    60: \"sixty\",\n    70: \"seventy\",\n    80: \"eighty\",\n    90: \"ninety\"\n  ]\n\n  public var numberName: String {\n    guard self != 0 else {\n      return \"zero\"\n    }\n\n    let neg = self < 0\n    let maxNeg = self == Int.min\n    var nn: Int\n\n    if maxNeg {\n      nn = -(self + 1)\n    } else if neg {\n      nn = -self\n    } else {\n      nn = self\n    }\n\n    var digits3 = [Int](repeating: 0, count: 7)\n\n    for i in 0..<7 {\n      digits3[i] = (nn % 1000)\n      nn /= 1000\n    }\n\n    func threeDigitsToText(n: Int) -> String {\n      guard n != 0 else {\n        return \"\"\n      }\n\n      var ret = \"\"\n\n      let hundreds = n / 100\n      let remainder = n % 100\n\n      if hundreds > 0 {\n        ret += \"\\(Int.names[hundreds]!) hundred\"\n\n        if remainder > 0 {\n          ret += \" \"\n        }\n      }\n\n      if remainder > 0 {\n        let tens = remainder / 10\n        let units = remainder % 10\n\n        if tens > 1 {\n          ret += Int.names[tens * 10]!\n\n          if units > 0 {\n            ret += \"-\\(Int.names[units]!)\"\n          }\n        } else {\n          ret += Int.names[remainder]!\n        }\n      }\n\n      return ret\n    }\n\n    let strings = (0..<7).map({ threeDigitsToText(n: digits3[$0]) })\n    var name = strings[0]\n    var big = 1000\n\n    for i in 1...6 {\n      if digits3[i] > 0 {\n        var name2 = \"\\(strings[i]) \\(Int.bigNames[big]!)\"\n\n        if name.count > 0 {\n          name2 += \", \"\n        }\n\n        name = name2 + name\n      }\n\n      big &*= 1000\n    }\n\n    if maxNeg {\n      name = String(name.dropLast(5) + \"eight\")\n    }\n\n    return neg ? \"minus \\(name)\" : name  \n  }\n}\n\nlet nums = [\n  0, 1, 7, 10, 18, 22, 67, 99, 100, 105, 999, -1056, 1000005000,\n  2074000000, 1234000000745003, Int.min\n]\n\nfor number in nums {\n  print(\"\\(number) => \\(number.numberName)\")\n}\n", "target": "TENS = [None, None, \"twenty\", \"thirty\", \"forty\",\n        \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\nSMALL = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n         \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\",\n         \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n         \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\nHUGE = [None, None] + [h + \"illion\" \n                       for h in (\"m\", \"b\", \"tr\", \"quadr\", \"quint\", \"sext\", \n                                  \"sept\", \"oct\", \"non\", \"dec\")]\n\ndef nonzero(c, n, connect=''):\n    return \"\" if n == 0 else connect + c + spell_integer(n)\n\ndef last_and(num):\n    if ',' in num:\n        pre, last = num.rsplit(',', 1)\n        if ' and ' not in last:\n            last = ' and' + last\n        num = ''.join([pre, ',', last])\n    return num\n    \ndef big(e, n):\n    if e == 0:\n        return spell_integer(n)\n    elif e == 1:\n        return spell_integer(n) + \" thousand\"\n    else:\n        return spell_integer(n) + \" \" + HUGE[e]\n\ndef base1000_rev(n):\n    \n    \n    while n != 0:\n        n, r = divmod(n, 1000)\n        yield r\n \ndef spell_integer(n):\n    if n < 0:\n        return \"minus \" + spell_integer(-n)\n    elif n < 20:\n        return SMALL[n]\n    elif n < 100:\n        a, b = divmod(n, 10)\n        return TENS[a] + nonzero(\"-\", b)\n    elif n < 1000:\n        a, b = divmod(n, 100)\n        return SMALL[a] + \" hundred\" + nonzero(\" \", b, ' and')\n    else:\n        num = \", \".join([big(e, x) for e, x in\n                         enumerate(base1000_rev(n)) if x][::-1])\n        return last_and(num)\n\nif __name__ == '__main__':\n    \n    for n in (0, -3, 5, -7, 11, -13, 17, -19, 23, -29):\n        print('%+4i -> %s' % (n, spell_integer(n)))\n    print('')  \n    \n    n = 201021002001\n    while n:\n        print('%-12i -> %s' % (n, spell_integer(n)))\n        n //= -10\n    print('%-12i -> %s' % (n, spell_integer(n)))\n    print('')\n"}
{"id": 147539, "name": "Sequence of primes by trial division", "source": "Translate Swift to C#: import Foundation\n\nextension SequenceType {\n  func takeWhile(include: Generator.Element -> Bool) -> AnyGenerator<Generator.Element> {\n    var g = self.generate()\n    return anyGenerator { g.next().flatMap{include($0) ? $0 : nil }}\n  }\n}\n\nvar pastPrimes = [2]\n\nvar primes = anyGenerator {\n  _ -> Int? in\n  defer {\n    pastPrimes.append(pastPrimes.last!)\n    let c = pastPrimes.count - 1\n    for p in anyGenerator({++pastPrimes[c]}) {\n      let lim = Int(sqrt(Double(p)))\n      if (!pastPrimes.takeWhile{$0 <= lim}.contains{p % $0 == 0}) { break }\n    }\n  }\n  return pastPrimes.last\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    static void Main() {\n        Console.WriteLine(string.Join(\" \", Primes(100)));\n    }\n\n    static IEnumerable<int> Primes(int limit) => Enumerable.Range(2, limit-1).Where(IsPrime);\n    static bool IsPrime(int n) => Enumerable.Range(2, (int)Math.Sqrt(n)-1).All(i => n % i != 0);\n}\n"}
{"id": 147541, "name": "Sequence of primes by trial division", "source": "Translate Swift to Java: import Foundation\n\nextension SequenceType {\n  func takeWhile(include: Generator.Element -> Bool) -> AnyGenerator<Generator.Element> {\n    var g = self.generate()\n    return anyGenerator { g.next().flatMap{include($0) ? $0 : nil }}\n  }\n}\n\nvar pastPrimes = [2]\n\nvar primes = anyGenerator {\n  _ -> Int? in\n  defer {\n    pastPrimes.append(pastPrimes.last!)\n    let c = pastPrimes.count - 1\n    for p in anyGenerator({++pastPrimes[c]}) {\n      let lim = Int(sqrt(Double(p)))\n      if (!pastPrimes.takeWhile{$0 <= lim}.contains{p % $0 == 0}) { break }\n    }\n  }\n  return pastPrimes.last\n}\n", "target": "import java.util.stream.IntStream;\n\npublic class Test {\n\n    static IntStream getPrimes(int start, int end) {\n        return IntStream.rangeClosed(start, end).filter(n -> isPrime(n));\n    }\n\n    public static boolean isPrime(long x) {\n        if (x < 3 || x % 2 == 0)\n            return x == 2;\n\n        long max = (long) Math.sqrt(x);\n        for (long n = 3; n <= max; n += 2) {\n            if (x % n == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        getPrimes(0, 100).forEach(p -> System.out.printf(\"%d, \", p));\n    }\n}\n"}
{"id": 147542, "name": "Sequence of primes by trial division", "source": "Translate Swift to Python: import Foundation\n\nextension SequenceType {\n  func takeWhile(include: Generator.Element -> Bool) -> AnyGenerator<Generator.Element> {\n    var g = self.generate()\n    return anyGenerator { g.next().flatMap{include($0) ? $0 : nil }}\n  }\n}\n\nvar pastPrimes = [2]\n\nvar primes = anyGenerator {\n  _ -> Int? in\n  defer {\n    pastPrimes.append(pastPrimes.last!)\n    let c = pastPrimes.count - 1\n    for p in anyGenerator({++pastPrimes[c]}) {\n      let lim = Int(sqrt(Double(p)))\n      if (!pastPrimes.takeWhile{$0 <= lim}.contains{p % $0 == 0}) { break }\n    }\n  }\n  return pastPrimes.last\n}\n", "target": "def prime(a):\n    return not (a < 2 or any(a % x == 0 for x in xrange(2, int(a**0.5) + 1)))\n\ndef primes_below(n):\n    return [i for i in range(n) if prime(i)]\n"}
{"id": 147758, "name": "Linear congruential generator", "source": "Translate Swift to C#: import Cocoa\n\nclass LinearCongruntialGenerator {\n    \n    var state = 0 \n    let a, c, m, shift: Int\n    \n    \n    init() {\n        self.a = 214013\n        self.c = 2531011\n        self.m = Int(pow(2.0, 31.0)) \n        self.shift = 16\n    }\n    \n    init(a: Int, c: Int, m: Int, shift: Int) {\n        self.a = a\n        self.c = c\n        self.m = m \n        self.shift = shift\n    }\n    \n    func seed(seed: Int) -> Void {\n        state = seed;\n    }\n    \n    func random() -> Int {\n        state = (a * state + c) % m\n        return state >> shift\n    }\n}\n\nlet microsoftLinearCongruntialGenerator = LinearCongruntialGenerator()\nlet BSDLinearCongruntialGenerator = LinearCongruntialGenerator(a: 1103515245, c: 12345, m: 2147483648, shift: 0)\n\nprint(\"Microsft Rand:\")\nfor(var i = 0; i < 10; i++)\n{\n    print(microsoftLinearCongruntialGenerator.random())\n}\n\nprint(\"\") \nprint(\"BSD Rand:\")\nfor(var i = 0; i < 10; i++)\n{\n    print(BSDLinearCongruntialGenerator.random())\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\n\nnamespace LinearCongruentialGenerator\n{\n    static class LinearCongruentialGenerator\n    {\n        static int _seed = (int)DateTime.Now.Ticks; \n        static int _bsdCurrent = _seed;\n        static int _msvcrtCurrent = _seed;\n\n        static int Next(int seed, int a, int b) => (a * seed + b) & int.MaxValue;\n\n        static int BsdRand() => _bsdCurrent = Next(_bsdCurrent, 1103515245, 12345); \n\n        static int MscvrtRand() => _msvcrtCurrent = Next (_msvcrtCurrent << 16,214013,2531011) >> 16;\n\n        static void PrintRandom(int count, bool isBsd)\n        {\n            var name = isBsd ? \"BSD\" : \"MS\";\n            WriteLine($\"{name} next {count} Random\");\n            var gen = isBsd ? (Func<int>)(BsdRand) : MscvrtRand;\n            foreach (var r in Enumerable.Repeat(gen, count))\n                WriteLine(r.Invoke());\n        }\n\n        static void Main(string[] args)\n        {\n            PrintRandom(10, true);\n            PrintRandom(10, false);\n            Read();\n        }\n    }\n}\n"}
{"id": 147760, "name": "Linear congruential generator", "source": "Translate Swift to Java: import Cocoa\n\nclass LinearCongruntialGenerator {\n    \n    var state = 0 \n    let a, c, m, shift: Int\n    \n    \n    init() {\n        self.a = 214013\n        self.c = 2531011\n        self.m = Int(pow(2.0, 31.0)) \n        self.shift = 16\n    }\n    \n    init(a: Int, c: Int, m: Int, shift: Int) {\n        self.a = a\n        self.c = c\n        self.m = m \n        self.shift = shift\n    }\n    \n    func seed(seed: Int) -> Void {\n        state = seed;\n    }\n    \n    func random() -> Int {\n        state = (a * state + c) % m\n        return state >> shift\n    }\n}\n\nlet microsoftLinearCongruntialGenerator = LinearCongruntialGenerator()\nlet BSDLinearCongruntialGenerator = LinearCongruntialGenerator(a: 1103515245, c: 12345, m: 2147483648, shift: 0)\n\nprint(\"Microsft Rand:\")\nfor(var i = 0; i < 10; i++)\n{\n    print(microsoftLinearCongruntialGenerator.random())\n}\n\nprint(\"\") \nprint(\"BSD Rand:\")\nfor(var i = 0; i < 10; i++)\n{\n    print(BSDLinearCongruntialGenerator.random())\n}\n", "target": "import java.util.stream.IntStream;\nimport static java.util.stream.IntStream.iterate;\n\npublic class LinearCongruentialGenerator {\n    final static int mask = (1 << 31) - 1;\n\n    public static void main(String[] args) {\n        System.out.println(\"BSD:\");\n        randBSD(0).limit(10).forEach(System.out::println);\n\n        System.out.println(\"\\nMS:\");\n        randMS(0).limit(10).forEach(System.out::println);\n    }\n\n    static IntStream randBSD(int seed) {\n        return iterate(seed, s -> (s * 1_103_515_245 + 12_345) & mask).skip(1);\n    }\n\n    static IntStream randMS(int seed) {\n        return iterate(seed, s -> (s * 214_013 + 2_531_011) & mask).skip(1)\n                .map(i -> i >> 16);\n    }\n}\n"}
{"id": 147761, "name": "Linear congruential generator", "source": "Translate Swift to Python: import Cocoa\n\nclass LinearCongruntialGenerator {\n    \n    var state = 0 \n    let a, c, m, shift: Int\n    \n    \n    init() {\n        self.a = 214013\n        self.c = 2531011\n        self.m = Int(pow(2.0, 31.0)) \n        self.shift = 16\n    }\n    \n    init(a: Int, c: Int, m: Int, shift: Int) {\n        self.a = a\n        self.c = c\n        self.m = m \n        self.shift = shift\n    }\n    \n    func seed(seed: Int) -> Void {\n        state = seed;\n    }\n    \n    func random() -> Int {\n        state = (a * state + c) % m\n        return state >> shift\n    }\n}\n\nlet microsoftLinearCongruntialGenerator = LinearCongruntialGenerator()\nlet BSDLinearCongruntialGenerator = LinearCongruntialGenerator(a: 1103515245, c: 12345, m: 2147483648, shift: 0)\n\nprint(\"Microsft Rand:\")\nfor(var i = 0; i < 10; i++)\n{\n    print(microsoftLinearCongruntialGenerator.random())\n}\n\nprint(\"\") \nprint(\"BSD Rand:\")\nfor(var i = 0; i < 10; i++)\n{\n    print(BSDLinearCongruntialGenerator.random())\n}\n", "target": "def bsd_rand(seed):\n   def rand():\n      rand.seed = (1103515245*rand.seed + 12345) & 0x7fffffff\n      return rand.seed\n   rand.seed = seed\n   return rand\n\ndef msvcrt_rand(seed):\n   def rand():\n      rand.seed = (214013*rand.seed + 2531011) & 0x7fffffff\n      return rand.seed >> 16\n   rand.seed = seed\n   return rand\n"}
{"id": 148025, "name": "Sorting algorithms_Selection sort", "source": "Translate Swift to C#: func selectionSort(inout arr:[Int]) {\n    var min:Int\n    \n    for n in 0..<arr.count {\n        min = n\n        \n        for x in n+1..<arr.count {\n            if (arr[x] < arr[min]) {\n                min = x\n            }\n        }\n        \n        if min != n {\n            let temp = arr[min]\n            arr[min] = arr[n]\n            arr[n] = temp\n        }\n    }\n}\n", "target": "class SelectionSort<T> where T : IComparable {\n    public T[] Sort(T[] list) {\n        int k;\n        T temp;\n\n        for (int i = 0; i < list.Length; i++) {\n            k = i;\n            for (int j=i + 1; j < list.Length; j++) {\n                if (list[j].CompareTo(list[k]) < 0) {\n                    k = j;\n                }\n            }\n            temp = list[i];\n            list[i] = list[k];\n            list[k] = temp;\n        }\n\n        return list;\n    }\n}\n"}
{"id": 148027, "name": "Sorting algorithms_Selection sort", "source": "Translate Swift to Java: func selectionSort(inout arr:[Int]) {\n    var min:Int\n    \n    for n in 0..<arr.count {\n        min = n\n        \n        for x in n+1..<arr.count {\n            if (arr[x] < arr[min]) {\n                min = x\n            }\n        }\n        \n        if min != n {\n            let temp = arr[min]\n            arr[min] = arr[n]\n            arr[n] = temp\n        }\n    }\n}\n", "target": "public static void sort(int[] nums){\n\tfor(int currentPlace = 0;currentPlace<nums.length-1;currentPlace++){\n\t\tint smallest = Integer.MAX_VALUE;\n\t\tint smallestAt = currentPlace+1;\n\t\tfor(int check = currentPlace; check<nums.length;check++){\n\t\t\tif(nums[check]<smallest){\n\t\t\t\tsmallestAt = check;\n\t\t\t\tsmallest = nums[check];\n\t\t\t}\n\t\t}\n\t\tint temp = nums[currentPlace];\n\t\tnums[currentPlace] = nums[smallestAt];\n\t\tnums[smallestAt] = temp;\n\t}\n}\n"}
{"id": 148028, "name": "Sorting algorithms_Selection sort", "source": "Translate Swift to Python: func selectionSort(inout arr:[Int]) {\n    var min:Int\n    \n    for n in 0..<arr.count {\n        min = n\n        \n        for x in n+1..<arr.count {\n            if (arr[x] < arr[min]) {\n                min = x\n            }\n        }\n        \n        if min != n {\n            let temp = arr[min]\n            arr[min] = arr[n]\n            arr[n] = temp\n        }\n    }\n}\n", "target": "def selection_sort(lst):\n    for i, e in enumerate(lst):\n        mn = min(range(i,len(lst)), key=lst.__getitem__)\n        lst[i], lst[mn] = lst[mn], e\n    return lst\n"}
{"id": 148281, "name": "Sorting algorithms_Comb sort", "source": "Translate Swift to C#: func combSort(inout list:[Int]) {\n    var swapped = true\n    var gap = list.count\n    \n    while gap > 1 || swapped {\n        gap = gap * 10 / 13\n        \n        if gap == 9 || gap == 10 {\n            gap = 11\n        } else if gap < 1 {\n            gap = 1\n        }\n        \n        swapped = false\n        \n        for var i = 0, j = gap; j < list.count; i++, j++ {\n            if list[i] > list[j] {\n                (list[i], list[j]) = (list[j], list[i])\n                swapped = true\n            }\n        }\n    }\n}\n", "target": "using System;\n\nnamespace CombSort\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] unsorted = new int[] { 3, 5, 1, 9, 7, 6, 8, 2, 4 };\n            Console.WriteLine(string.Join(\",\", combSort(unsorted)));\n        }\n        public static int[] combSort(int[] input)\n        {\n            double gap = input.Length;\n            bool swaps = true;\n            while (gap > 1 || swaps)\n            {\n                gap /= 1.247330950103979;\n                if (gap < 1) { gap = 1; }\n                int i = 0;\n                swaps = false;\n                while (i + gap < input.Length)\n                {\n                    int igap = i + (int)gap;\n                    if (input[i] > input[igap])\n                    {\n                        int swap = input[i];\n                        input[i] = input[igap];\n                        input[igap] = swap;\n                        swaps = true;\n                    }\n                    i++;\n                }\n            }\n            return input;\n        }\n    }\n}\n"}
{"id": 148283, "name": "Sorting algorithms_Comb sort", "source": "Translate Swift to Java: func combSort(inout list:[Int]) {\n    var swapped = true\n    var gap = list.count\n    \n    while gap > 1 || swapped {\n        gap = gap * 10 / 13\n        \n        if gap == 9 || gap == 10 {\n            gap = 11\n        } else if gap < 1 {\n            gap = 1\n        }\n        \n        swapped = false\n        \n        for var i = 0, j = gap; j < list.count; i++, j++ {\n            if list[i] > list[j] {\n                (list[i], list[j]) = (list[j], list[i])\n                swapped = true\n            }\n        }\n    }\n}\n", "target": "public static <E extends Comparable<? super E>> void sort(E[] input) {\n    int gap = input.length;\n    boolean swapped = true;\n    while (gap > 1 || swapped) {\n        if (gap > 1) {\n            gap = (int) (gap / 1.3);\n        }\n        swapped = false;\n        for (int i = 0; i + gap < input.length; i++) {\n            if (input[i].compareTo(input[i + gap]) > 0) {\n                E t = input[i];\n                input[i] = input[i + gap];\n                input[i + gap] = t;\n                swapped = true;\n            }\n        }\n    }\n}\n"}
{"id": 148284, "name": "Sorting algorithms_Comb sort", "source": "Translate Swift to Python: func combSort(inout list:[Int]) {\n    var swapped = true\n    var gap = list.count\n    \n    while gap > 1 || swapped {\n        gap = gap * 10 / 13\n        \n        if gap == 9 || gap == 10 {\n            gap = 11\n        } else if gap < 1 {\n            gap = 1\n        }\n        \n        swapped = false\n        \n        for var i = 0, j = gap; j < list.count; i++, j++ {\n            if list[i] > list[j] {\n                (list[i], list[j]) = (list[j], list[i])\n                swapped = true\n            }\n        }\n    }\n}\n", "target": ">>> def combsort(input):\n    gap = len(input)\n    swaps = True\n    while gap > 1 or swaps:\n        gap = max(1, int(gap / 1.25))  \n        swaps = False\n        for i in range(len(input) - gap):\n            j = i+gap\n            if input[i] > input[j]:\n                input[i], input[j] = input[j], input[i]\n                swaps = True\n\n                \n>>> y = [88, 18, 31, 44, 4, 0, 8, 81, 14, 78, 20, 76, 84, 33, 73, 75, 82, 5, 62, 70]\n>>> combsort(y)\n>>> assert y == sorted(y)\n>>> y\n[0, 4, 5, 8, 14, 18, 20, 31, 33, 44, 62, 70, 73, 75, 76, 78, 81, 82, 84, 88]\n>>>\n"}
{"id": 148822, "name": "Attractive numbers", "source": "Translate Swift to C#: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isAttractive: Bool {\n    return primeDecomposition().count.isPrime\n  }\n\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) {\n      if self % i == 0 {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nlet attractive = Array((1...).lazy.filter({ $0.isAttractive }).prefix(while: { $0 <= 120 }))\n\nprint(\"Attractive numbers up to and including 120: \\(attractive)\")\n", "target": "using System;\n\nnamespace AttractiveNumbers {\n    class Program {\n        const int MAX = 120;\n\n        static bool IsPrime(int n) {\n            if (n < 2) return false;\n            if (n % 2 == 0) return n == 2;\n            if (n % 3 == 0) return n == 3;\n            int d = 5;\n            while (d * d <= n) {\n                if (n % d == 0) return false;\n                d += 2;\n                if (n % d == 0) return false;\n                d += 4;\n            }\n            return true;\n        }\n\n        static int PrimeFactorCount(int n) {\n            if (n == 1) return 0;\n            if (IsPrime(n)) return 1;\n            int count = 0;\n            int f = 2;\n            while (true) {\n                if (n % f == 0) {\n                    count++;\n                    n /= f;\n                    if (n == 1) return count;\n                    if (IsPrime(n)) f = n;\n                } else if (f >= 3) {\n                    f += 2;\n                } else {\n                    f = 3;\n                }\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"The attractive numbers up to and including {0} are:\", MAX);\n            int i = 1;\n            int count = 0;\n            while (i <= MAX) {\n                int n = PrimeFactorCount(i);\n                if (IsPrime(n)) {\n                    Console.Write(\"{0,4}\", i);\n                    if (++count % 20 == 0) Console.WriteLine();\n                }\n                ++i;\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 148823, "name": "Attractive numbers", "source": "Translate Swift to C#: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isAttractive: Bool {\n    return primeDecomposition().count.isPrime\n  }\n\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) {\n      if self % i == 0 {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nlet attractive = Array((1...).lazy.filter({ $0.isAttractive }).prefix(while: { $0 <= 120 }))\n\nprint(\"Attractive numbers up to and including 120: \\(attractive)\")\n", "target": "using System;\n\nnamespace AttractiveNumbers {\n    class Program {\n        const int MAX = 120;\n\n        static bool IsPrime(int n) {\n            if (n < 2) return false;\n            if (n % 2 == 0) return n == 2;\n            if (n % 3 == 0) return n == 3;\n            int d = 5;\n            while (d * d <= n) {\n                if (n % d == 0) return false;\n                d += 2;\n                if (n % d == 0) return false;\n                d += 4;\n            }\n            return true;\n        }\n\n        static int PrimeFactorCount(int n) {\n            if (n == 1) return 0;\n            if (IsPrime(n)) return 1;\n            int count = 0;\n            int f = 2;\n            while (true) {\n                if (n % f == 0) {\n                    count++;\n                    n /= f;\n                    if (n == 1) return count;\n                    if (IsPrime(n)) f = n;\n                } else if (f >= 3) {\n                    f += 2;\n                } else {\n                    f = 3;\n                }\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"The attractive numbers up to and including {0} are:\", MAX);\n            int i = 1;\n            int count = 0;\n            while (i <= MAX) {\n                int n = PrimeFactorCount(i);\n                if (IsPrime(n)) {\n                    Console.Write(\"{0,4}\", i);\n                    if (++count % 20 == 0) Console.WriteLine();\n                }\n                ++i;\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 148826, "name": "Attractive numbers", "source": "Translate Swift to Java: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isAttractive: Bool {\n    return primeDecomposition().count.isPrime\n  }\n\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) {\n      if self % i == 0 {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nlet attractive = Array((1...).lazy.filter({ $0.isAttractive }).prefix(while: { $0 <= 120 }))\n\nprint(\"Attractive numbers up to and including 120: \\(attractive)\")\n", "target": "public class Attractive {\n\n    static boolean is_prime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d *d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    static int count_prime_factors(int n) {\n        if (n == 1) return 0;\n        if (is_prime(n)) return 1;\n        int count = 0, f = 2;\n        while (true) {\n            if (n % f == 0) {\n                count++;\n                n /= f;\n                if (n == 1) return count;\n                if (is_prime(n)) f = n;\n            }\n            else if (f >= 3) f += 2;\n            else f = 3;\n        }\n    }\n\n    public static void main(String[] args) {\n        final int max = 120;\n        System.out.printf(\"The attractive numbers up to and including %d are:\\n\", max);\n        for (int i = 1, count = 0; i <= max; ++i) {\n            int n = count_prime_factors(i);\n            if (is_prime(n)) {\n                System.out.printf(\"%4d\", i);\n                if (++count % 20 == 0) System.out.println();\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 148827, "name": "Attractive numbers", "source": "Translate Swift to Java: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isAttractive: Bool {\n    return primeDecomposition().count.isPrime\n  }\n\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) {\n      if self % i == 0 {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nlet attractive = Array((1...).lazy.filter({ $0.isAttractive }).prefix(while: { $0 <= 120 }))\n\nprint(\"Attractive numbers up to and including 120: \\(attractive)\")\n", "target": "public class Attractive {\n\n    static boolean is_prime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d *d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    static int count_prime_factors(int n) {\n        if (n == 1) return 0;\n        if (is_prime(n)) return 1;\n        int count = 0, f = 2;\n        while (true) {\n            if (n % f == 0) {\n                count++;\n                n /= f;\n                if (n == 1) return count;\n                if (is_prime(n)) f = n;\n            }\n            else if (f >= 3) f += 2;\n            else f = 3;\n        }\n    }\n\n    public static void main(String[] args) {\n        final int max = 120;\n        System.out.printf(\"The attractive numbers up to and including %d are:\\n\", max);\n        for (int i = 1, count = 0; i <= max; ++i) {\n            int n = count_prime_factors(i);\n            if (is_prime(n)) {\n                System.out.printf(\"%4d\", i);\n                if (++count % 20 == 0) System.out.println();\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 148828, "name": "Attractive numbers", "source": "Translate Swift to Python: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isAttractive: Bool {\n    return primeDecomposition().count.isPrime\n  }\n\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) {\n      if self % i == 0 {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nlet attractive = Array((1...).lazy.filter({ $0.isAttractive }).prefix(while: { $0 <= 120 }))\n\nprint(\"Attractive numbers up to and including 120: \\(attractive)\")\n", "target": "from sympy import sieve \n\ndef get_pfct(n): \n\ti = 2; factors = []\n\twhile i * i <= n:\n\t\tif n % i:\n\t\t\ti += 1\n\t\telse:\n\t\t\tn //= i\n\t\t\tfactors.append(i)\n\tif n > 1:\n\t\tfactors.append(n)\n\treturn len(factors) \n\nsieve.extend(110) \nprimes=sieve._list\n\npool=[]\n\nfor each in xrange(0,121):\n\tpool.append(get_pfct(each))\n\nfor i,each in enumerate(pool):\n\tif each in primes:\n\t\tprint i,\n"}
{"id": 148829, "name": "Attractive numbers", "source": "Translate Swift to Python: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isAttractive: Bool {\n    return primeDecomposition().count.isPrime\n  }\n\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) {\n      if self % i == 0 {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nlet attractive = Array((1...).lazy.filter({ $0.isAttractive }).prefix(while: { $0 <= 120 }))\n\nprint(\"Attractive numbers up to and including 120: \\(attractive)\")\n", "target": "from sympy import sieve \n\ndef get_pfct(n): \n\ti = 2; factors = []\n\twhile i * i <= n:\n\t\tif n % i:\n\t\t\ti += 1\n\t\telse:\n\t\t\tn //= i\n\t\t\tfactors.append(i)\n\tif n > 1:\n\t\tfactors.append(n)\n\treturn len(factors) \n\nsieve.extend(110) \nprimes=sieve._list\n\npool=[]\n\nfor each in xrange(0,121):\n\tpool.append(get_pfct(each))\n\nfor i,each in enumerate(pool):\n\tif each in primes:\n\t\tprint i,\n"}
{"id": 149054, "name": "Convex hull", "source": "Translate Swift to C#: public struct Point: Equatable, Hashable {\n  public var x: Double\n  public var y: Double\n\n  public init(fromTuple t: (Double, Double)) {\n    self.x = t.0\n    self.y = t.1\n  }\n}\n\npublic func calculateConvexHull(fromPoints points: [Point]) -> [Point] {\n  guard points.count >= 3 else {\n    return points\n  }\n\n  var hull = [Point]()\n  let (leftPointIdx, _) = points.enumerated().min(by: { $0.element.x < $1.element.x })!\n\n  var p = leftPointIdx\n  var q = 0\n\n  repeat {\n    hull.append(points[p])\n\n    q = (p + 1) % points.count\n\n    for i in 0..<points.count where calculateOrientation(points[p], points[i], points[q]) == .counterClockwise {\n      q = i\n    }\n\n    p = q\n  } while p != leftPointIdx\n\n  return hull\n}\n\nprivate func calculateOrientation(_ p: Point, _ q: Point, _ r: Point) -> Orientation {\n  let val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)\n\n  if val == 0 {\n    return .straight\n  } else if val > 0 {\n    return .clockwise\n  } else {\n    return .counterClockwise\n  }\n}\n\nprivate enum Orientation {\n  case straight, clockwise, counterClockwise\n}\n\nlet points = [\n  (16,3),\n  (12,17),\n  (0,6),\n  (-4,-6),\n  (16,6),\n  (16,-7),\n  (16,-3),\n  (17,-4),\n  (5,19),\n  (19,-8),\n  (3,16),\n  (12,13),\n  (3,-4),\n  (17,5),\n  (-3,15),\n  (-3,-9),\n  (0,11),\n  (-9,-3),\n  (-4,-2),\n  (12,10)\n].map(Point.init(fromTuple:))\n\nprint(\"Input: \\(points)\")\nprint(\"Output: \\(calculateConvexHull(fromPoints: points))\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ConvexHull {\n    class Point : IComparable<Point> {\n        private int x, y;\n\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int X { get => x; set => x = value; }\n        public int Y { get => y; set => y = value; }\n\n        public int CompareTo(Point other) {\n            return x.CompareTo(other.x);\n        }\n\n        public override string ToString() {\n            return string.Format(\"({0}, {1})\", x, y);\n        }\n    }\n\n    class Program {\n        private static List<Point> ConvexHull(List<Point> p) {\n            if (p.Count == 0) return new List<Point>();\n            p.Sort();\n            List<Point> h = new List<Point>();\n\n            \n            foreach (var pt in p) {\n                while (h.Count >= 2 && !Ccw(h[h.Count - 2], h[h.Count - 1], pt)) {\n                    h.RemoveAt(h.Count - 1);\n                }\n                h.Add(pt);\n            }\n\n            \n            int t = h.Count + 1;\n            for (int i = p.Count - 1; i >= 0; i--) {\n                Point pt = p[i];\n                while (h.Count >= t && !Ccw(h[h.Count - 2], h[h.Count - 1], pt)) {\n                    h.RemoveAt(h.Count - 1);\n                }\n                h.Add(pt);\n            }\n\n            h.RemoveAt(h.Count - 1);\n            return h;\n        }\n\n        private static bool Ccw(Point a, Point b, Point c) {\n            return ((b.X - a.X) * (c.Y - a.Y)) > ((b.Y - a.Y) * (c.X - a.X));\n        }\n\n        static void Main(string[] args) {\n            List<Point> points = new List<Point>() {\n                new Point(16, 3),\n                new Point(12, 17),\n                new Point(0, 6),\n                new Point(-4, -6),\n                new Point(16, 6),\n\n                new Point(16, -7),\n                new Point(16, -3),\n                new Point(17, -4),\n                new Point(5, 19),\n                new Point(19, -8),\n\n                new Point(3, 16),\n                new Point(12, 13),\n                new Point(3, -4),\n                new Point(17, 5),\n                new Point(-3, 15),\n\n                new Point(-3, -9),\n                new Point(0, 11),\n                new Point(-9, -3),\n                new Point(-4, -2),\n                new Point(12, 10)\n            };\n\n            List<Point> hull = ConvexHull(points);\n            Console.Write(\"Convex Hull: [\");\n            for (int i = 0; i < hull.Count; i++) {\n                if (i > 0) {\n                    Console.Write(\", \");\n                }\n                Point pt = hull[i];\n                Console.Write(pt);\n            }\n            Console.WriteLine(\"]\");\n        }\n    }\n}\n"}
{"id": 149056, "name": "Convex hull", "source": "Translate Swift to Java: public struct Point: Equatable, Hashable {\n  public var x: Double\n  public var y: Double\n\n  public init(fromTuple t: (Double, Double)) {\n    self.x = t.0\n    self.y = t.1\n  }\n}\n\npublic func calculateConvexHull(fromPoints points: [Point]) -> [Point] {\n  guard points.count >= 3 else {\n    return points\n  }\n\n  var hull = [Point]()\n  let (leftPointIdx, _) = points.enumerated().min(by: { $0.element.x < $1.element.x })!\n\n  var p = leftPointIdx\n  var q = 0\n\n  repeat {\n    hull.append(points[p])\n\n    q = (p + 1) % points.count\n\n    for i in 0..<points.count where calculateOrientation(points[p], points[i], points[q]) == .counterClockwise {\n      q = i\n    }\n\n    p = q\n  } while p != leftPointIdx\n\n  return hull\n}\n\nprivate func calculateOrientation(_ p: Point, _ q: Point, _ r: Point) -> Orientation {\n  let val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)\n\n  if val == 0 {\n    return .straight\n  } else if val > 0 {\n    return .clockwise\n  } else {\n    return .counterClockwise\n  }\n}\n\nprivate enum Orientation {\n  case straight, clockwise, counterClockwise\n}\n\nlet points = [\n  (16,3),\n  (12,17),\n  (0,6),\n  (-4,-6),\n  (16,6),\n  (16,-7),\n  (16,-3),\n  (17,-4),\n  (5,19),\n  (19,-8),\n  (3,16),\n  (12,13),\n  (3,-4),\n  (17,5),\n  (-3,15),\n  (-3,-9),\n  (0,11),\n  (-9,-3),\n  (-4,-2),\n  (12,10)\n].map(Point.init(fromTuple:))\n\nprint(\"Input: \\(points)\")\nprint(\"Output: \\(calculateConvexHull(fromPoints: points))\")\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport static java.util.Collections.emptyList;\n\npublic class ConvexHull {\n    private static class Point implements Comparable<Point> {\n        private int x, y;\n\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public int compareTo(Point o) {\n            return Integer.compare(x, o.x);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%d, %d)\", x, y);\n        }\n    }\n\n    private static List<Point> convexHull(List<Point> p) {\n        if (p.isEmpty()) return emptyList();\n        p.sort(Point::compareTo);\n        List<Point> h = new ArrayList<>();\n\n        \n        for (Point pt : p) {\n            while (h.size() >= 2 && !ccw(h.get(h.size() - 2), h.get(h.size() - 1), pt)) {\n                h.remove(h.size() - 1);\n            }\n            h.add(pt);\n        }\n\n        \n        int t = h.size() + 1;\n        for (int i = p.size() - 1; i >= 0; i--) {\n            Point pt = p.get(i);\n            while (h.size() >= t && !ccw(h.get(h.size() - 2), h.get(h.size() - 1), pt)) {\n                h.remove(h.size() - 1);\n            }\n            h.add(pt);\n        }\n\n        h.remove(h.size() - 1);\n        return h;\n    }\n\n    \n    private static boolean ccw(Point a, Point b, Point c) {\n        return ((b.x - a.x) * (c.y - a.y)) > ((b.y - a.y) * (c.x - a.x));\n    }\n\n    public static void main(String[] args) {\n        List<Point> points = Arrays.asList(new Point(16, 3),\n                                           new Point(12, 17),\n                                           new Point(0, 6),\n                                           new Point(-4, -6),\n                                           new Point(16, 6),\n\n                                           new Point(16, -7),\n                                           new Point(16, -3),\n                                           new Point(17, -4),\n                                           new Point(5, 19),\n                                           new Point(19, -8),\n\n                                           new Point(3, 16),\n                                           new Point(12, 13),\n                                           new Point(3, -4),\n                                           new Point(17, 5),\n                                           new Point(-3, 15),\n\n                                           new Point(-3, -9),\n                                           new Point(0, 11),\n                                           new Point(-9, -3),\n                                           new Point(-4, -2),\n                                           new Point(12, 10));\n\n        List<Point> hull = convexHull(points);\n        System.out.printf(\"Convex Hull: %s\\n\", hull);\n    }\n}\n"}
{"id": 149057, "name": "Convex hull", "source": "Translate Swift to Python: public struct Point: Equatable, Hashable {\n  public var x: Double\n  public var y: Double\n\n  public init(fromTuple t: (Double, Double)) {\n    self.x = t.0\n    self.y = t.1\n  }\n}\n\npublic func calculateConvexHull(fromPoints points: [Point]) -> [Point] {\n  guard points.count >= 3 else {\n    return points\n  }\n\n  var hull = [Point]()\n  let (leftPointIdx, _) = points.enumerated().min(by: { $0.element.x < $1.element.x })!\n\n  var p = leftPointIdx\n  var q = 0\n\n  repeat {\n    hull.append(points[p])\n\n    q = (p + 1) % points.count\n\n    for i in 0..<points.count where calculateOrientation(points[p], points[i], points[q]) == .counterClockwise {\n      q = i\n    }\n\n    p = q\n  } while p != leftPointIdx\n\n  return hull\n}\n\nprivate func calculateOrientation(_ p: Point, _ q: Point, _ r: Point) -> Orientation {\n  let val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)\n\n  if val == 0 {\n    return .straight\n  } else if val > 0 {\n    return .clockwise\n  } else {\n    return .counterClockwise\n  }\n}\n\nprivate enum Orientation {\n  case straight, clockwise, counterClockwise\n}\n\nlet points = [\n  (16,3),\n  (12,17),\n  (0,6),\n  (-4,-6),\n  (16,6),\n  (16,-7),\n  (16,-3),\n  (17,-4),\n  (5,19),\n  (19,-8),\n  (3,16),\n  (12,13),\n  (3,-4),\n  (17,5),\n  (-3,15),\n  (-3,-9),\n  (0,11),\n  (-9,-3),\n  (-4,-2),\n  (12,10)\n].map(Point.init(fromTuple:))\n\nprint(\"Input: \\(points)\")\nprint(\"Output: \\(calculateConvexHull(fromPoints: points))\")\n", "target": "from __future__ import print_function\nfrom shapely.geometry import MultiPoint\n\nif __name__==\"__main__\":\n\tpts = MultiPoint([(16,3), (12,17), (0,6), (-4,-6), (16,6), (16,-7), (16,-3), (17,-4), (5,19), (19,-8), (3,16), (12,13), (3,-4), (17,5), (-3,15), (-3,-9), (0,11), (-9,-3), (-4,-2), (12,10)])\n\tprint (pts.convex_hull)\n"}
{"id": 149569, "name": "Loops_For", "source": "Translate Swift to C#: for i in 1...5 {\n    for _ in 1...i {\n        print(\"*\", terminator: \"\")\n    }\n    print()\n}\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            for (int j = 0; j <= i; j++)\n            {\n                Console.Write(\"*\");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 149571, "name": "Loops_For", "source": "Translate Swift to Java: for i in 1...5 {\n    for _ in 1...i {\n        print(\"*\", terminator: \"\")\n    }\n    print()\n}\n", "target": "for (Integer i = 0; i < 5; i++) {\n    String line = '';\n\n    for (Integer j = 0; j < i; j++) {\n        line += '*';\n    }\n\n    System.debug(line);\n}\n\nList<String> lines = new List<String> {\n    '*',\n    '**',\n    '***',\n    '****',\n    '*****'\n};\n\nfor (String line : lines) {\n    System.debug(line);\n}\n"}
{"id": 149572, "name": "Loops_For", "source": "Translate Swift to Python: for i in 1...5 {\n    for _ in 1...i {\n        print(\"*\", terminator: \"\")\n    }\n    print()\n}\n", "target": "for i in 1..5:\n  for j in 1..i:\n    stdout.write(\"*\")\n  echo(\"\")\n"}
{"id": 149814, "name": "Loops_Downward for", "source": "Translate Swift to C#: for i in stride(from: 10, through: 0, by: -1) {\n  println(i)\n}\n", "target": "for (int i = 10; i >= 0; i--)\n{\n   Console.WriteLine(i);\n}\n"}
{"id": 149816, "name": "Loops_Downward for", "source": "Translate Swift to Java: for i in stride(from: 10, through: 0, by: -1) {\n  println(i)\n}\n", "target": "for (int i = 10; i >= 0; i--) {\n    System.out.println(i);\n}\n"}
{"id": 149817, "name": "Loops_Downward for", "source": "Translate Swift to Python: for i in stride(from: 10, through: 0, by: -1) {\n  println(i)\n}\n", "target": "for i in xrange(10, -1, -1):\n    print i\n"}
{"id": 150052, "name": "Entropy", "source": "Translate Swift to C#: import Foundation\n\nfunc entropy(of x: String) -> Double {\n  return x\n    .reduce(into: [String: Int](), {cur, char in\n      cur[String(char), default: 0] += 1\n    })\n    .values\n    .map({i in Double(i) / Double(x.count) } as (Int) -> Double)\n    .map({p in -p * log2(p) } as (Double) -> Double)\n    .reduce(0.0, +)\n}\n\nprint(entropy(of: \"1223334444\"))\n", "target": "using System;\nusing System.Collections.Generic;\nnamespace Entropy\n{\n\tclass Program\n\t{\n\t\tpublic static double logtwo(double num)\n\t\t{\n\t\t\treturn Math.Log(num)/Math.Log(2);\n\t\t}\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\tlabel1:\n\t\t\tstring input = Console.ReadLine();\n\t\t\tdouble infoC=0;\n\t\t\tDictionary<char,double> table = new Dictionary<char, double>();\n\n\t\t\t\n\t\t\tforeach (char c in input)\n\t\t\t{\n\t\t\t\tif (table.ContainsKey(c))\n\t\t\t\t\ttable[c]++;\n\t\t\t\t    else\n\t\t\t\t    \ttable.Add(c,1);\n\t\n\t\t\t}\n\t\t\tdouble freq;\n\t\t\tforeach (KeyValuePair<char,double> letter in table)\n\t\t\t{\n\t\t\t\tfreq=letter.Value/input.Length;\n\t\t\t\tinfoC+=freq*logtwo(freq);\n\t\t\t}\n\t\t\tinfoC*=-1;\n\t\t\tConsole.WriteLine(\"The Entropy of {0} is {1}\",input,infoC);\n\t\t\tgoto label1;\n\t\t\n\t\t}\n\t}\n}\n"}
{"id": 150054, "name": "Entropy", "source": "Translate Swift to Java: import Foundation\n\nfunc entropy(of x: String) -> Double {\n  return x\n    .reduce(into: [String: Int](), {cur, char in\n      cur[String(char), default: 0] += 1\n    })\n    .values\n    .map({i in Double(i) / Double(x.count) } as (Int) -> Double)\n    .map({p in -p * log2(p) } as (Double) -> Double)\n    .reduce(0.0, +)\n}\n\nprint(entropy(of: \"1223334444\"))\n", "target": "import java.lang.Math;\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class REntropy {\n\n  @SuppressWarnings(\"boxing\")\n  public static double getShannonEntropy(String s) {\n    int n = 0;\n    Map<Character, Integer> occ = new HashMap<>();\n\n    for (int c_ = 0; c_ < s.length(); ++c_) {\n      char cx = s.charAt(c_);\n      if (occ.containsKey(cx)) {\n        occ.put(cx, occ.get(cx) + 1);\n      } else {\n        occ.put(cx, 1);\n      }\n      ++n;\n    }\n\n    double e = 0.0;\n    for (Map.Entry<Character, Integer> entry : occ.entrySet()) {\n      char cx = entry.getKey();\n      double p = (double) entry.getValue() / n;\n      e += p * log2(p);\n    }\n    return -e;\n  }\n\n  private static double log2(double a) {\n    return Math.log(a) / Math.log(2);\n  }\n  public static void main(String[] args) {\n    String[] sstr = {\n      \"1223334444\",\n      \"1223334444555555555\", \n      \"122333\", \n      \"1227774444\",\n      \"aaBBcccDDDD\",\n      \"1234567890abcdefghijklmnopqrstuvwxyz\",\n      \"Rosetta Code\",\n    };\n\n    for (String ss : sstr) {\n      double entropy = REntropy.getShannonEntropy(ss);\n      System.out.printf(\"Shannon entropy of %40s:\u00a0%.12f%n\", \"\\\"\" + ss + \"\\\"\", entropy);\n    }\n    return;\n  }\n}\n"}
{"id": 150055, "name": "Entropy", "source": "Translate Swift to Python: import Foundation\n\nfunc entropy(of x: String) -> Double {\n  return x\n    .reduce(into: [String: Int](), {cur, char in\n      cur[String(char), default: 0] += 1\n    })\n    .values\n    .map({i in Double(i) / Double(x.count) } as (Int) -> Double)\n    .map({p in -p * log2(p) } as (Double) -> Double)\n    .reduce(0.0, +)\n}\n\nprint(entropy(of: \"1223334444\"))\n", "target": "from __future__ import division\nimport math\n\ndef hist(source):\n    hist = {}; l = 0;\n    for e in source:\n        l += 1\n        if e not in hist:\n            hist[e] = 0\n        hist[e] += 1\n    return (l,hist)\n\ndef entropy(hist,l):\n    elist = []\n    for v in hist.values():\n        c = v / l\n        elist.append(-c * math.log(c ,2))\n    return sum(elist)\n\ndef printHist(h):\n    flip = lambda (k,v) : (v,k)\n    h = sorted(h.iteritems(), key = flip)\n    print 'Sym\\thi\\tfi\\tInf'\n    for (k,v) in h:\n        print '%s\\t%f\\t%f\\t%f'%(k,v,v/l,-math.log(v/l, 2))\n    \n    \n\nsource = \"1223334444\"\n(l,h) = hist(source);\nprint '.[Results].'\nprint 'Length',l\nprint 'Entropy:', entropy(h, l)\nprintHist(h)\n"}
{"id": 150540, "name": "Currying", "source": "Translate Swift to C#: func addN(n:Int)->Int->Int { return {$0 + n} }\n\nvar add2 = addN(2)\nprintln(add2) \nprintln(add2(7)) \n", "target": "public delegate int Plus(int y); \npublic delegate Plus CurriedPlus(int x);\npublic static CurriedPlus plus = \n      delegate(int x) {return delegate(int y) {return x + y;};};\nstatic void Main()\n{\n    int sum = plus(3)(4); \n    int sum2= plus(2)(plus(3)(4)) \n}\n"}
{"id": 150541, "name": "Currying", "source": "Translate Swift to C#: func addN(n:Int)->Int->Int { return {$0 + n} }\n\nvar add2 = addN(2)\nprintln(add2) \nprintln(add2(7)) \n", "target": "public delegate int Plus(int y); \npublic delegate Plus CurriedPlus(int x);\npublic static CurriedPlus plus = \n      delegate(int x) {return delegate(int y) {return x + y;};};\nstatic void Main()\n{\n    int sum = plus(3)(4); \n    int sum2= plus(2)(plus(3)(4)) \n}\n"}
{"id": 150542, "name": "Currying", "source": "Translate Swift to Java: func addN(n:Int)->Int->Int { return {$0 + n} }\n\nvar add2 = addN(2)\nprintln(add2) \nprintln(add2(7)) \n", "target": "module CurryPower\n    {\n    @Inject Console console;\n    void run()\n        {\n        function Int(Int, Int) divide = (x,y) -> x / y;\n\n        function Int(Int) half = divide(_, 2);\n        function Int(Int) partsOf120 = divide(120, _);\n\n        console.print($|half of a dozen is {half(12)}\n                       |half of 120 is {partsOf120(2)}\n                       |a third is {partsOf120(3)}\n                       |and a quarter is {partsOf120(4)}\n                     );\n        }\n    }\n"}
{"id": 150543, "name": "Currying", "source": "Translate Swift to Java: func addN(n:Int)->Int->Int { return {$0 + n} }\n\nvar add2 = addN(2)\nprintln(add2) \nprintln(add2(7)) \n", "target": "module CurryPower\n    {\n    @Inject Console console;\n    void run()\n        {\n        function Int(Int, Int) divide = (x,y) -> x / y;\n\n        function Int(Int) half = divide(_, 2);\n        function Int(Int) partsOf120 = divide(120, _);\n\n        console.print($|half of a dozen is {half(12)}\n                       |half of 120 is {partsOf120(2)}\n                       |a third is {partsOf120(3)}\n                       |and a quarter is {partsOf120(4)}\n                     );\n        }\n    }\n"}
{"id": 150544, "name": "Currying", "source": "Translate Swift to Python: func addN(n:Int)->Int->Int { return {$0 + n} }\n\nvar add2 = addN(2)\nprintln(add2) \nprintln(add2(7)) \n", "target": " def addN(n):\n     def adder(x):\n         return x + n\n     return adder\n"}
{"id": 150545, "name": "Currying", "source": "Translate Swift to Python: func addN(n:Int)->Int->Int { return {$0 + n} }\n\nvar add2 = addN(2)\nprintln(add2) \nprintln(add2(7)) \n", "target": " def addN(n):\n     def adder(x):\n         return x + n\n     return adder\n"}
{"id": 151397, "name": "Identity matrix", "source": "Translate Swift to C#: func identityMatrix(size: Int) -> [[Int]] {\n  return (0..<size).map({i in\n    return (0..<size).map({ $0 == i ? 1 : 0})\n  })\n}\n\nprint(identityMatrix(size: 5))\n", "target": "using System;\nusing System.Linq;\n\nnamespace IdentityMatrix\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            if (args.Length != 1)\n            {\n                Console.WriteLine(\"Requires exactly one argument\");\n                return;\n            }\n            int n;\n            if (!int.TryParse(args[0], out n))\n            {\n                Console.WriteLine(\"Requires integer parameter\");\n                return;\n            }\n\n            var identity =\n                Enumerable.Range(0, n).Select(i => Enumerable.Repeat(0, n).Select((z,j) => j == i ? 1 : 0).ToList()).ToList();\n            foreach (var row in identity)\n            {\n                foreach (var elem in row)\n                {\n                    Console.Write(\" \" + elem);\n                }\n                Console.WriteLine();\n            }\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 151398, "name": "Identity matrix", "source": "Translate Swift to C#: func identityMatrix(size: Int) -> [[Int]] {\n  return (0..<size).map({i in\n    return (0..<size).map({ $0 == i ? 1 : 0})\n  })\n}\n\nprint(identityMatrix(size: 5))\n", "target": "using System;\nusing System.Linq;\n\nnamespace IdentityMatrix\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            if (args.Length != 1)\n            {\n                Console.WriteLine(\"Requires exactly one argument\");\n                return;\n            }\n            int n;\n            if (!int.TryParse(args[0], out n))\n            {\n                Console.WriteLine(\"Requires integer parameter\");\n                return;\n            }\n\n            var identity =\n                Enumerable.Range(0, n).Select(i => Enumerable.Repeat(0, n).Select((z,j) => j == i ? 1 : 0).ToList()).ToList();\n            foreach (var row in identity)\n            {\n                foreach (var elem in row)\n                {\n                    Console.Write(\" \" + elem);\n                }\n                Console.WriteLine();\n            }\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 151401, "name": "Identity matrix", "source": "Translate Swift to Java: func identityMatrix(size: Int) -> [[Int]] {\n  return (0..<size).map({i in\n    return (0..<size).map({ $0 == i ? 1 : 0})\n  })\n}\n\nprint(identityMatrix(size: 5))\n", "target": "public class PrintIdentityMatrix {\n\n    public static void main(String[] args) {\n        int n = 5;\n        int[][] array = new int[n][n];\n\n        IntStream.range(0, n).forEach(i -> array[i][i] = 1);\n\n        Arrays.stream(array)\n                .map((int[] a) -> Arrays.toString(a))\n                .forEach(System.out::println);\n    }\n}\n"}
{"id": 151402, "name": "Identity matrix", "source": "Translate Swift to Java: func identityMatrix(size: Int) -> [[Int]] {\n  return (0..<size).map({i in\n    return (0..<size).map({ $0 == i ? 1 : 0})\n  })\n}\n\nprint(identityMatrix(size: 5))\n", "target": "public class PrintIdentityMatrix {\n\n    public static void main(String[] args) {\n        int n = 5;\n        int[][] array = new int[n][n];\n\n        IntStream.range(0, n).forEach(i -> array[i][i] = 1);\n\n        Arrays.stream(array)\n                .map((int[] a) -> Arrays.toString(a))\n                .forEach(System.out::println);\n    }\n}\n"}
{"id": 151403, "name": "Identity matrix", "source": "Translate Swift to Python: func identityMatrix(size: Int) -> [[Int]] {\n  return (0..<size).map({i in\n    return (0..<size).map({ $0 == i ? 1 : 0})\n  })\n}\n\nprint(identityMatrix(size: 5))\n", "target": "def identity(size):\n    matrix = [[0]*size for i in range(size)]\n    \n\n    for i in range(size):\n        matrix[i][i] = 1\n    \n    for rows in matrix:\n        for elements in rows:\n            print elements,\n        print \"\"\n"}
{"id": 151404, "name": "Identity matrix", "source": "Translate Swift to Python: func identityMatrix(size: Int) -> [[Int]] {\n  return (0..<size).map({i in\n    return (0..<size).map({ $0 == i ? 1 : 0})\n  })\n}\n\nprint(identityMatrix(size: 5))\n", "target": "def identity(size):\n    matrix = [[0]*size for i in range(size)]\n    \n\n    for i in range(size):\n        matrix[i][i] = 1\n    \n    for rows in matrix:\n        for elements in rows:\n            print elements,\n        print \"\"\n"}
{"id": 151836, "name": "RIPEMD-160", "source": "Translate Swift to C#: \n\ninfix operator  ~<< { precedence 160 associativity none }\n\npublic func ~<< (lhs: UInt32, rhs: Int) -> UInt32 {\n    return (lhs << UInt32(rhs)) | (lhs >> UInt32(32 - rhs));\n}\n\n    public struct Block {\n        public init() {}\n        \n        var message: [UInt32] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        \n        var h\u2080: UInt32 = 0x67452301\n        var h\u2081: UInt32 = 0xEFCDAB89\n        var h\u2082: UInt32 = 0x98BADCFE\n        var h\u2083: UInt32 = 0x10325476\n        var h\u2084: UInt32 = 0xC3D2E1F0\n        \n        public var hash: [UInt32] {\n            return [h\u2080, h\u2081, h\u2082, h\u2083, h\u2084]\n        }\n        \n        \n        public mutating func compress (message: [UInt32]) -> () {\n            assert(count(message) == 16, \"Wrong message size\")\n            \n            var A\u1d38 = h\u2080\n            var B\u1d38 = h\u2081\n            var C\u1d38 = h\u2082\n            var D\u1d38 = h\u2083\n            var E\u1d38 = h\u2084\n            \n            var A\u1d3f = h\u2080\n            var B\u1d3f = h\u2081\n            var C\u1d3f = h\u2082\n            var D\u1d3f = h\u2083\n            var E\u1d3f = h\u2084\n            \n            for j in 0...79 {\n                \n                let word\u1d38 = message[r.Left[j]]\n                let function\u1d38 = f(j)\n                \n                let T\u1d38: UInt32 = ((A\u1d38 &+ function\u1d38(B\u1d38,C\u1d38,D\u1d38) &+ word\u1d38 &+ K.Left[j]) ~<< s.Left[j]) &+ E\u1d38\n                \n                A\u1d38 = E\u1d38\n                E\u1d38 = D\u1d38\n                D\u1d38 = C\u1d38 ~<< 10\n                C\u1d38 = B\u1d38\n                B\u1d38 = T\u1d38\n                \n                \n                let word\u1d3f = message[r.Right[j]]\n                let function\u1d3f = f(79 - j)\n                \n                let T\u1d3f: UInt32 = ((A\u1d3f &+ function\u1d3f(B\u1d3f,C\u1d3f,D\u1d3f) &+ word\u1d3f &+ K.Right[j]) ~<< s.Right[j]) &+ E\u1d3f\n                \n                A\u1d3f = E\u1d3f\n                E\u1d3f = D\u1d3f\n                D\u1d3f = C\u1d3f ~<< 10\n                C\u1d3f = B\u1d3f\n                B\u1d3f = T\u1d3f\n            }\n            \n            let T = h\u2081 &+ C\u1d38 &+ D\u1d3f\n            h\u2081 = h\u2082 &+ D\u1d38 &+ E\u1d3f\n            h\u2082 = h\u2083 &+ E\u1d38 &+ A\u1d3f\n            h\u2083 = h\u2084 &+ A\u1d38 &+ B\u1d3f\n            h\u2084 = h\u2080 &+ B\u1d38 &+ C\u1d3f\n            h\u2080 = T\n        }\n        \n        public func f (j: Int) -> ((UInt32, UInt32, UInt32) -> UInt32) {\n            switch j {\n            case let index where j < 0:\n                assert(false, \"Invalid j\")\n                return {(_, _, _) in 0 }\n            case let index where j <= 15:\n                return {(x, y, z) in  x ^ y ^ z }\n            case let index where j <= 31:\n                return {(x, y, z) in  (x & y) | (~x & z) }\n            case let index where j <= 47:\n                return {(x, y, z) in  (x | ~y) ^ z }\n            case let index where j <= 63:\n                return {(x, y, z) in  (x & z) | (y & ~z) }\n            case let index where j <= 79:\n                return {(x, y, z) in  x ^ (y | ~z) }\n            default:\n                assert(false, \"Invalid j\")\n                return {(_, _, _) in 0 }\n            }\n        }\n        \n        public enum K {\n            case Left, Right\n            \n            public subscript(j: Int) -> UInt32 {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    return self == .Left ? 0x00000000 : 0x50A28BE6\n                case let index where j <= 31:\n                    return self == .Left ? 0x5A827999 : 0x5C4DD124\n                case let index where j <= 47:\n                    return self == .Left ? 0x6ED9EBA1 : 0x6D703EF3\n                case let index where j <= 63:\n                    return self == .Left ? 0x8F1BBCDC : 0x7A6D76E9\n                case let index where j <= 79:\n                    return self == .Left ? 0xA953FD4E : 0x00000000\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                    }\n            }\n        }\n        \n        public enum r {\n            case Left, Right\n            \n            public subscript (j: Int) -> Int {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    if self == .Left {\n                        return index\n                    } else {\n                        return [5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12][index]\n                    }\n                case let index where j <= 31:\n                    if self == .Left {\n                        return [ 7, 4,13, 1,10, 6,15, 3,12, 0, 9, 5, 2,14,11, 8][index - 16]\n                    } else {\n                        return [ 6,11, 3, 7, 0,13, 5,10,14,15, 8,12, 4, 9, 1, 2][index - 16]\n                    }\n                case let index where j <= 47:\n                    if self == .Left {\n                        return [3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12][index - 32]\n                    } else {\n                        return [15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13][index - 32]\n                    }\n                case let index where j <= 63:\n                    if self == .Left {\n                        return [1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2][index - 48]\n                    } else {\n                        return [8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14][index - 48]\n                    }\n                case let index where j <= 79:\n                    if self == .Left {\n                        return [ 4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13][index - 64]\n                    } else {\n                        return [12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11][index - 64]\n                    }\n\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                }\n            }\n\n            \n        }\n        \n        public enum s {\n            case Left, Right\n            \n            public subscript(j: Int) -> Int {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    return (self == .Left ? [11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8] : [8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6])[j]\n                case let index where j <= 31:\n                    return (self == .Left ? [7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12] : [9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11])[j - 16]\n                case let index where j <= 47:\n                    return (self == .Left ? [11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5] : [9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5])[j - 32]\n                case let index where j <= 63:\n                    return (self == .Left ? [11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12] : [15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8])[j - 48]\n                case let index where j <= 79:\n                    return (self == .Left ? [9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6] : [8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11])[j - 64]\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                    }\n            }\n\n        }\n        \n        \n        \n    }\n", "target": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string text = \"Rosetta Code\";\n        byte[] bytes = Encoding.ASCII.GetBytes(text);\n        RIPEMD160 myRIPEMD160 = RIPEMD160Managed.Create();\n        byte[] hashValue = myRIPEMD160.ComputeHash(bytes);\n        var hexdigest = BitConverter.ToString(hashValue).Replace(\"-\", \"\").ToLower();\n        Console.WriteLine(hexdigest);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 151837, "name": "RIPEMD-160", "source": "Translate Swift to C#: \n\ninfix operator  ~<< { precedence 160 associativity none }\n\npublic func ~<< (lhs: UInt32, rhs: Int) -> UInt32 {\n    return (lhs << UInt32(rhs)) | (lhs >> UInt32(32 - rhs));\n}\n\n    public struct Block {\n        public init() {}\n        \n        var message: [UInt32] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        \n        var h\u2080: UInt32 = 0x67452301\n        var h\u2081: UInt32 = 0xEFCDAB89\n        var h\u2082: UInt32 = 0x98BADCFE\n        var h\u2083: UInt32 = 0x10325476\n        var h\u2084: UInt32 = 0xC3D2E1F0\n        \n        public var hash: [UInt32] {\n            return [h\u2080, h\u2081, h\u2082, h\u2083, h\u2084]\n        }\n        \n        \n        public mutating func compress (message: [UInt32]) -> () {\n            assert(count(message) == 16, \"Wrong message size\")\n            \n            var A\u1d38 = h\u2080\n            var B\u1d38 = h\u2081\n            var C\u1d38 = h\u2082\n            var D\u1d38 = h\u2083\n            var E\u1d38 = h\u2084\n            \n            var A\u1d3f = h\u2080\n            var B\u1d3f = h\u2081\n            var C\u1d3f = h\u2082\n            var D\u1d3f = h\u2083\n            var E\u1d3f = h\u2084\n            \n            for j in 0...79 {\n                \n                let word\u1d38 = message[r.Left[j]]\n                let function\u1d38 = f(j)\n                \n                let T\u1d38: UInt32 = ((A\u1d38 &+ function\u1d38(B\u1d38,C\u1d38,D\u1d38) &+ word\u1d38 &+ K.Left[j]) ~<< s.Left[j]) &+ E\u1d38\n                \n                A\u1d38 = E\u1d38\n                E\u1d38 = D\u1d38\n                D\u1d38 = C\u1d38 ~<< 10\n                C\u1d38 = B\u1d38\n                B\u1d38 = T\u1d38\n                \n                \n                let word\u1d3f = message[r.Right[j]]\n                let function\u1d3f = f(79 - j)\n                \n                let T\u1d3f: UInt32 = ((A\u1d3f &+ function\u1d3f(B\u1d3f,C\u1d3f,D\u1d3f) &+ word\u1d3f &+ K.Right[j]) ~<< s.Right[j]) &+ E\u1d3f\n                \n                A\u1d3f = E\u1d3f\n                E\u1d3f = D\u1d3f\n                D\u1d3f = C\u1d3f ~<< 10\n                C\u1d3f = B\u1d3f\n                B\u1d3f = T\u1d3f\n            }\n            \n            let T = h\u2081 &+ C\u1d38 &+ D\u1d3f\n            h\u2081 = h\u2082 &+ D\u1d38 &+ E\u1d3f\n            h\u2082 = h\u2083 &+ E\u1d38 &+ A\u1d3f\n            h\u2083 = h\u2084 &+ A\u1d38 &+ B\u1d3f\n            h\u2084 = h\u2080 &+ B\u1d38 &+ C\u1d3f\n            h\u2080 = T\n        }\n        \n        public func f (j: Int) -> ((UInt32, UInt32, UInt32) -> UInt32) {\n            switch j {\n            case let index where j < 0:\n                assert(false, \"Invalid j\")\n                return {(_, _, _) in 0 }\n            case let index where j <= 15:\n                return {(x, y, z) in  x ^ y ^ z }\n            case let index where j <= 31:\n                return {(x, y, z) in  (x & y) | (~x & z) }\n            case let index where j <= 47:\n                return {(x, y, z) in  (x | ~y) ^ z }\n            case let index where j <= 63:\n                return {(x, y, z) in  (x & z) | (y & ~z) }\n            case let index where j <= 79:\n                return {(x, y, z) in  x ^ (y | ~z) }\n            default:\n                assert(false, \"Invalid j\")\n                return {(_, _, _) in 0 }\n            }\n        }\n        \n        public enum K {\n            case Left, Right\n            \n            public subscript(j: Int) -> UInt32 {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    return self == .Left ? 0x00000000 : 0x50A28BE6\n                case let index where j <= 31:\n                    return self == .Left ? 0x5A827999 : 0x5C4DD124\n                case let index where j <= 47:\n                    return self == .Left ? 0x6ED9EBA1 : 0x6D703EF3\n                case let index where j <= 63:\n                    return self == .Left ? 0x8F1BBCDC : 0x7A6D76E9\n                case let index where j <= 79:\n                    return self == .Left ? 0xA953FD4E : 0x00000000\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                    }\n            }\n        }\n        \n        public enum r {\n            case Left, Right\n            \n            public subscript (j: Int) -> Int {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    if self == .Left {\n                        return index\n                    } else {\n                        return [5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12][index]\n                    }\n                case let index where j <= 31:\n                    if self == .Left {\n                        return [ 7, 4,13, 1,10, 6,15, 3,12, 0, 9, 5, 2,14,11, 8][index - 16]\n                    } else {\n                        return [ 6,11, 3, 7, 0,13, 5,10,14,15, 8,12, 4, 9, 1, 2][index - 16]\n                    }\n                case let index where j <= 47:\n                    if self == .Left {\n                        return [3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12][index - 32]\n                    } else {\n                        return [15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13][index - 32]\n                    }\n                case let index where j <= 63:\n                    if self == .Left {\n                        return [1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2][index - 48]\n                    } else {\n                        return [8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14][index - 48]\n                    }\n                case let index where j <= 79:\n                    if self == .Left {\n                        return [ 4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13][index - 64]\n                    } else {\n                        return [12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11][index - 64]\n                    }\n\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                }\n            }\n\n            \n        }\n        \n        public enum s {\n            case Left, Right\n            \n            public subscript(j: Int) -> Int {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    return (self == .Left ? [11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8] : [8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6])[j]\n                case let index where j <= 31:\n                    return (self == .Left ? [7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12] : [9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11])[j - 16]\n                case let index where j <= 47:\n                    return (self == .Left ? [11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5] : [9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5])[j - 32]\n                case let index where j <= 63:\n                    return (self == .Left ? [11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12] : [15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8])[j - 48]\n                case let index where j <= 79:\n                    return (self == .Left ? [9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6] : [8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11])[j - 64]\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                    }\n            }\n\n        }\n        \n        \n        \n    }\n", "target": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string text = \"Rosetta Code\";\n        byte[] bytes = Encoding.ASCII.GetBytes(text);\n        RIPEMD160 myRIPEMD160 = RIPEMD160Managed.Create();\n        byte[] hashValue = myRIPEMD160.ComputeHash(bytes);\n        var hexdigest = BitConverter.ToString(hashValue).Replace(\"-\", \"\").ToLower();\n        Console.WriteLine(hexdigest);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 151838, "name": "RIPEMD-160", "source": "Translate Swift to Java: \n\ninfix operator  ~<< { precedence 160 associativity none }\n\npublic func ~<< (lhs: UInt32, rhs: Int) -> UInt32 {\n    return (lhs << UInt32(rhs)) | (lhs >> UInt32(32 - rhs));\n}\n\n    public struct Block {\n        public init() {}\n        \n        var message: [UInt32] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        \n        var h\u2080: UInt32 = 0x67452301\n        var h\u2081: UInt32 = 0xEFCDAB89\n        var h\u2082: UInt32 = 0x98BADCFE\n        var h\u2083: UInt32 = 0x10325476\n        var h\u2084: UInt32 = 0xC3D2E1F0\n        \n        public var hash: [UInt32] {\n            return [h\u2080, h\u2081, h\u2082, h\u2083, h\u2084]\n        }\n        \n        \n        public mutating func compress (message: [UInt32]) -> () {\n            assert(count(message) == 16, \"Wrong message size\")\n            \n            var A\u1d38 = h\u2080\n            var B\u1d38 = h\u2081\n            var C\u1d38 = h\u2082\n            var D\u1d38 = h\u2083\n            var E\u1d38 = h\u2084\n            \n            var A\u1d3f = h\u2080\n            var B\u1d3f = h\u2081\n            var C\u1d3f = h\u2082\n            var D\u1d3f = h\u2083\n            var E\u1d3f = h\u2084\n            \n            for j in 0...79 {\n                \n                let word\u1d38 = message[r.Left[j]]\n                let function\u1d38 = f(j)\n                \n                let T\u1d38: UInt32 = ((A\u1d38 &+ function\u1d38(B\u1d38,C\u1d38,D\u1d38) &+ word\u1d38 &+ K.Left[j]) ~<< s.Left[j]) &+ E\u1d38\n                \n                A\u1d38 = E\u1d38\n                E\u1d38 = D\u1d38\n                D\u1d38 = C\u1d38 ~<< 10\n                C\u1d38 = B\u1d38\n                B\u1d38 = T\u1d38\n                \n                \n                let word\u1d3f = message[r.Right[j]]\n                let function\u1d3f = f(79 - j)\n                \n                let T\u1d3f: UInt32 = ((A\u1d3f &+ function\u1d3f(B\u1d3f,C\u1d3f,D\u1d3f) &+ word\u1d3f &+ K.Right[j]) ~<< s.Right[j]) &+ E\u1d3f\n                \n                A\u1d3f = E\u1d3f\n                E\u1d3f = D\u1d3f\n                D\u1d3f = C\u1d3f ~<< 10\n                C\u1d3f = B\u1d3f\n                B\u1d3f = T\u1d3f\n            }\n            \n            let T = h\u2081 &+ C\u1d38 &+ D\u1d3f\n            h\u2081 = h\u2082 &+ D\u1d38 &+ E\u1d3f\n            h\u2082 = h\u2083 &+ E\u1d38 &+ A\u1d3f\n            h\u2083 = h\u2084 &+ A\u1d38 &+ B\u1d3f\n            h\u2084 = h\u2080 &+ B\u1d38 &+ C\u1d3f\n            h\u2080 = T\n        }\n        \n        public func f (j: Int) -> ((UInt32, UInt32, UInt32) -> UInt32) {\n            switch j {\n            case let index where j < 0:\n                assert(false, \"Invalid j\")\n                return {(_, _, _) in 0 }\n            case let index where j <= 15:\n                return {(x, y, z) in  x ^ y ^ z }\n            case let index where j <= 31:\n                return {(x, y, z) in  (x & y) | (~x & z) }\n            case let index where j <= 47:\n                return {(x, y, z) in  (x | ~y) ^ z }\n            case let index where j <= 63:\n                return {(x, y, z) in  (x & z) | (y & ~z) }\n            case let index where j <= 79:\n                return {(x, y, z) in  x ^ (y | ~z) }\n            default:\n                assert(false, \"Invalid j\")\n                return {(_, _, _) in 0 }\n            }\n        }\n        \n        public enum K {\n            case Left, Right\n            \n            public subscript(j: Int) -> UInt32 {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    return self == .Left ? 0x00000000 : 0x50A28BE6\n                case let index where j <= 31:\n                    return self == .Left ? 0x5A827999 : 0x5C4DD124\n                case let index where j <= 47:\n                    return self == .Left ? 0x6ED9EBA1 : 0x6D703EF3\n                case let index where j <= 63:\n                    return self == .Left ? 0x8F1BBCDC : 0x7A6D76E9\n                case let index where j <= 79:\n                    return self == .Left ? 0xA953FD4E : 0x00000000\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                    }\n            }\n        }\n        \n        public enum r {\n            case Left, Right\n            \n            public subscript (j: Int) -> Int {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    if self == .Left {\n                        return index\n                    } else {\n                        return [5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12][index]\n                    }\n                case let index where j <= 31:\n                    if self == .Left {\n                        return [ 7, 4,13, 1,10, 6,15, 3,12, 0, 9, 5, 2,14,11, 8][index - 16]\n                    } else {\n                        return [ 6,11, 3, 7, 0,13, 5,10,14,15, 8,12, 4, 9, 1, 2][index - 16]\n                    }\n                case let index where j <= 47:\n                    if self == .Left {\n                        return [3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12][index - 32]\n                    } else {\n                        return [15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13][index - 32]\n                    }\n                case let index where j <= 63:\n                    if self == .Left {\n                        return [1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2][index - 48]\n                    } else {\n                        return [8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14][index - 48]\n                    }\n                case let index where j <= 79:\n                    if self == .Left {\n                        return [ 4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13][index - 64]\n                    } else {\n                        return [12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11][index - 64]\n                    }\n\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                }\n            }\n\n            \n        }\n        \n        public enum s {\n            case Left, Right\n            \n            public subscript(j: Int) -> Int {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    return (self == .Left ? [11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8] : [8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6])[j]\n                case let index where j <= 31:\n                    return (self == .Left ? [7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12] : [9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11])[j - 16]\n                case let index where j <= 47:\n                    return (self == .Left ? [11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5] : [9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5])[j - 32]\n                case let index where j <= 63:\n                    return (self == .Left ? [11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12] : [15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8])[j - 48]\n                case let index where j <= 79:\n                    return (self == .Left ? [9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6] : [8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11])[j - 64]\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                    }\n            }\n\n        }\n        \n        \n        \n    }\n", "target": "import org.bouncycastle.crypto.digests.RIPEMD160Digest;\nimport org.bouncycastle.util.encoders.Hex;\n\npublic class RosettaRIPEMD160\n{\n    public static void main (String[] argv) throws Exception\n    {\n        byte[] r = \"Rosetta Code\".getBytes(\"US-ASCII\");\n        RIPEMD160Digest d = new RIPEMD160Digest();\n        d.update (r, 0, r.length);\n        byte[] o = new byte[d.getDigestSize()];\n        d.doFinal (o, 0);\n        Hex.encode (o, System.out);\n        System.out.println();\n    }\n}\n"}
{"id": 151839, "name": "RIPEMD-160", "source": "Translate Swift to Java: \n\ninfix operator  ~<< { precedence 160 associativity none }\n\npublic func ~<< (lhs: UInt32, rhs: Int) -> UInt32 {\n    return (lhs << UInt32(rhs)) | (lhs >> UInt32(32 - rhs));\n}\n\n    public struct Block {\n        public init() {}\n        \n        var message: [UInt32] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        \n        var h\u2080: UInt32 = 0x67452301\n        var h\u2081: UInt32 = 0xEFCDAB89\n        var h\u2082: UInt32 = 0x98BADCFE\n        var h\u2083: UInt32 = 0x10325476\n        var h\u2084: UInt32 = 0xC3D2E1F0\n        \n        public var hash: [UInt32] {\n            return [h\u2080, h\u2081, h\u2082, h\u2083, h\u2084]\n        }\n        \n        \n        public mutating func compress (message: [UInt32]) -> () {\n            assert(count(message) == 16, \"Wrong message size\")\n            \n            var A\u1d38 = h\u2080\n            var B\u1d38 = h\u2081\n            var C\u1d38 = h\u2082\n            var D\u1d38 = h\u2083\n            var E\u1d38 = h\u2084\n            \n            var A\u1d3f = h\u2080\n            var B\u1d3f = h\u2081\n            var C\u1d3f = h\u2082\n            var D\u1d3f = h\u2083\n            var E\u1d3f = h\u2084\n            \n            for j in 0...79 {\n                \n                let word\u1d38 = message[r.Left[j]]\n                let function\u1d38 = f(j)\n                \n                let T\u1d38: UInt32 = ((A\u1d38 &+ function\u1d38(B\u1d38,C\u1d38,D\u1d38) &+ word\u1d38 &+ K.Left[j]) ~<< s.Left[j]) &+ E\u1d38\n                \n                A\u1d38 = E\u1d38\n                E\u1d38 = D\u1d38\n                D\u1d38 = C\u1d38 ~<< 10\n                C\u1d38 = B\u1d38\n                B\u1d38 = T\u1d38\n                \n                \n                let word\u1d3f = message[r.Right[j]]\n                let function\u1d3f = f(79 - j)\n                \n                let T\u1d3f: UInt32 = ((A\u1d3f &+ function\u1d3f(B\u1d3f,C\u1d3f,D\u1d3f) &+ word\u1d3f &+ K.Right[j]) ~<< s.Right[j]) &+ E\u1d3f\n                \n                A\u1d3f = E\u1d3f\n                E\u1d3f = D\u1d3f\n                D\u1d3f = C\u1d3f ~<< 10\n                C\u1d3f = B\u1d3f\n                B\u1d3f = T\u1d3f\n            }\n            \n            let T = h\u2081 &+ C\u1d38 &+ D\u1d3f\n            h\u2081 = h\u2082 &+ D\u1d38 &+ E\u1d3f\n            h\u2082 = h\u2083 &+ E\u1d38 &+ A\u1d3f\n            h\u2083 = h\u2084 &+ A\u1d38 &+ B\u1d3f\n            h\u2084 = h\u2080 &+ B\u1d38 &+ C\u1d3f\n            h\u2080 = T\n        }\n        \n        public func f (j: Int) -> ((UInt32, UInt32, UInt32) -> UInt32) {\n            switch j {\n            case let index where j < 0:\n                assert(false, \"Invalid j\")\n                return {(_, _, _) in 0 }\n            case let index where j <= 15:\n                return {(x, y, z) in  x ^ y ^ z }\n            case let index where j <= 31:\n                return {(x, y, z) in  (x & y) | (~x & z) }\n            case let index where j <= 47:\n                return {(x, y, z) in  (x | ~y) ^ z }\n            case let index where j <= 63:\n                return {(x, y, z) in  (x & z) | (y & ~z) }\n            case let index where j <= 79:\n                return {(x, y, z) in  x ^ (y | ~z) }\n            default:\n                assert(false, \"Invalid j\")\n                return {(_, _, _) in 0 }\n            }\n        }\n        \n        public enum K {\n            case Left, Right\n            \n            public subscript(j: Int) -> UInt32 {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    return self == .Left ? 0x00000000 : 0x50A28BE6\n                case let index where j <= 31:\n                    return self == .Left ? 0x5A827999 : 0x5C4DD124\n                case let index where j <= 47:\n                    return self == .Left ? 0x6ED9EBA1 : 0x6D703EF3\n                case let index where j <= 63:\n                    return self == .Left ? 0x8F1BBCDC : 0x7A6D76E9\n                case let index where j <= 79:\n                    return self == .Left ? 0xA953FD4E : 0x00000000\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                    }\n            }\n        }\n        \n        public enum r {\n            case Left, Right\n            \n            public subscript (j: Int) -> Int {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    if self == .Left {\n                        return index\n                    } else {\n                        return [5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12][index]\n                    }\n                case let index where j <= 31:\n                    if self == .Left {\n                        return [ 7, 4,13, 1,10, 6,15, 3,12, 0, 9, 5, 2,14,11, 8][index - 16]\n                    } else {\n                        return [ 6,11, 3, 7, 0,13, 5,10,14,15, 8,12, 4, 9, 1, 2][index - 16]\n                    }\n                case let index where j <= 47:\n                    if self == .Left {\n                        return [3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12][index - 32]\n                    } else {\n                        return [15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13][index - 32]\n                    }\n                case let index where j <= 63:\n                    if self == .Left {\n                        return [1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2][index - 48]\n                    } else {\n                        return [8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14][index - 48]\n                    }\n                case let index where j <= 79:\n                    if self == .Left {\n                        return [ 4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13][index - 64]\n                    } else {\n                        return [12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11][index - 64]\n                    }\n\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                }\n            }\n\n            \n        }\n        \n        public enum s {\n            case Left, Right\n            \n            public subscript(j: Int) -> Int {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    return (self == .Left ? [11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8] : [8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6])[j]\n                case let index where j <= 31:\n                    return (self == .Left ? [7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12] : [9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11])[j - 16]\n                case let index where j <= 47:\n                    return (self == .Left ? [11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5] : [9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5])[j - 32]\n                case let index where j <= 63:\n                    return (self == .Left ? [11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12] : [15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8])[j - 48]\n                case let index where j <= 79:\n                    return (self == .Left ? [9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6] : [8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11])[j - 64]\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                    }\n            }\n\n        }\n        \n        \n        \n    }\n", "target": "import org.bouncycastle.crypto.digests.RIPEMD160Digest;\nimport org.bouncycastle.util.encoders.Hex;\n\npublic class RosettaRIPEMD160\n{\n    public static void main (String[] argv) throws Exception\n    {\n        byte[] r = \"Rosetta Code\".getBytes(\"US-ASCII\");\n        RIPEMD160Digest d = new RIPEMD160Digest();\n        d.update (r, 0, r.length);\n        byte[] o = new byte[d.getDigestSize()];\n        d.doFinal (o, 0);\n        Hex.encode (o, System.out);\n        System.out.println();\n    }\n}\n"}
{"id": 151840, "name": "RIPEMD-160", "source": "Translate Swift to Python: \n\ninfix operator  ~<< { precedence 160 associativity none }\n\npublic func ~<< (lhs: UInt32, rhs: Int) -> UInt32 {\n    return (lhs << UInt32(rhs)) | (lhs >> UInt32(32 - rhs));\n}\n\n    public struct Block {\n        public init() {}\n        \n        var message: [UInt32] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        \n        var h\u2080: UInt32 = 0x67452301\n        var h\u2081: UInt32 = 0xEFCDAB89\n        var h\u2082: UInt32 = 0x98BADCFE\n        var h\u2083: UInt32 = 0x10325476\n        var h\u2084: UInt32 = 0xC3D2E1F0\n        \n        public var hash: [UInt32] {\n            return [h\u2080, h\u2081, h\u2082, h\u2083, h\u2084]\n        }\n        \n        \n        public mutating func compress (message: [UInt32]) -> () {\n            assert(count(message) == 16, \"Wrong message size\")\n            \n            var A\u1d38 = h\u2080\n            var B\u1d38 = h\u2081\n            var C\u1d38 = h\u2082\n            var D\u1d38 = h\u2083\n            var E\u1d38 = h\u2084\n            \n            var A\u1d3f = h\u2080\n            var B\u1d3f = h\u2081\n            var C\u1d3f = h\u2082\n            var D\u1d3f = h\u2083\n            var E\u1d3f = h\u2084\n            \n            for j in 0...79 {\n                \n                let word\u1d38 = message[r.Left[j]]\n                let function\u1d38 = f(j)\n                \n                let T\u1d38: UInt32 = ((A\u1d38 &+ function\u1d38(B\u1d38,C\u1d38,D\u1d38) &+ word\u1d38 &+ K.Left[j]) ~<< s.Left[j]) &+ E\u1d38\n                \n                A\u1d38 = E\u1d38\n                E\u1d38 = D\u1d38\n                D\u1d38 = C\u1d38 ~<< 10\n                C\u1d38 = B\u1d38\n                B\u1d38 = T\u1d38\n                \n                \n                let word\u1d3f = message[r.Right[j]]\n                let function\u1d3f = f(79 - j)\n                \n                let T\u1d3f: UInt32 = ((A\u1d3f &+ function\u1d3f(B\u1d3f,C\u1d3f,D\u1d3f) &+ word\u1d3f &+ K.Right[j]) ~<< s.Right[j]) &+ E\u1d3f\n                \n                A\u1d3f = E\u1d3f\n                E\u1d3f = D\u1d3f\n                D\u1d3f = C\u1d3f ~<< 10\n                C\u1d3f = B\u1d3f\n                B\u1d3f = T\u1d3f\n            }\n            \n            let T = h\u2081 &+ C\u1d38 &+ D\u1d3f\n            h\u2081 = h\u2082 &+ D\u1d38 &+ E\u1d3f\n            h\u2082 = h\u2083 &+ E\u1d38 &+ A\u1d3f\n            h\u2083 = h\u2084 &+ A\u1d38 &+ B\u1d3f\n            h\u2084 = h\u2080 &+ B\u1d38 &+ C\u1d3f\n            h\u2080 = T\n        }\n        \n        public func f (j: Int) -> ((UInt32, UInt32, UInt32) -> UInt32) {\n            switch j {\n            case let index where j < 0:\n                assert(false, \"Invalid j\")\n                return {(_, _, _) in 0 }\n            case let index where j <= 15:\n                return {(x, y, z) in  x ^ y ^ z }\n            case let index where j <= 31:\n                return {(x, y, z) in  (x & y) | (~x & z) }\n            case let index where j <= 47:\n                return {(x, y, z) in  (x | ~y) ^ z }\n            case let index where j <= 63:\n                return {(x, y, z) in  (x & z) | (y & ~z) }\n            case let index where j <= 79:\n                return {(x, y, z) in  x ^ (y | ~z) }\n            default:\n                assert(false, \"Invalid j\")\n                return {(_, _, _) in 0 }\n            }\n        }\n        \n        public enum K {\n            case Left, Right\n            \n            public subscript(j: Int) -> UInt32 {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    return self == .Left ? 0x00000000 : 0x50A28BE6\n                case let index where j <= 31:\n                    return self == .Left ? 0x5A827999 : 0x5C4DD124\n                case let index where j <= 47:\n                    return self == .Left ? 0x6ED9EBA1 : 0x6D703EF3\n                case let index where j <= 63:\n                    return self == .Left ? 0x8F1BBCDC : 0x7A6D76E9\n                case let index where j <= 79:\n                    return self == .Left ? 0xA953FD4E : 0x00000000\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                    }\n            }\n        }\n        \n        public enum r {\n            case Left, Right\n            \n            public subscript (j: Int) -> Int {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    if self == .Left {\n                        return index\n                    } else {\n                        return [5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12][index]\n                    }\n                case let index where j <= 31:\n                    if self == .Left {\n                        return [ 7, 4,13, 1,10, 6,15, 3,12, 0, 9, 5, 2,14,11, 8][index - 16]\n                    } else {\n                        return [ 6,11, 3, 7, 0,13, 5,10,14,15, 8,12, 4, 9, 1, 2][index - 16]\n                    }\n                case let index where j <= 47:\n                    if self == .Left {\n                        return [3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12][index - 32]\n                    } else {\n                        return [15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13][index - 32]\n                    }\n                case let index where j <= 63:\n                    if self == .Left {\n                        return [1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2][index - 48]\n                    } else {\n                        return [8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14][index - 48]\n                    }\n                case let index where j <= 79:\n                    if self == .Left {\n                        return [ 4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13][index - 64]\n                    } else {\n                        return [12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11][index - 64]\n                    }\n\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                }\n            }\n\n            \n        }\n        \n        public enum s {\n            case Left, Right\n            \n            public subscript(j: Int) -> Int {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    return (self == .Left ? [11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8] : [8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6])[j]\n                case let index where j <= 31:\n                    return (self == .Left ? [7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12] : [9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11])[j - 16]\n                case let index where j <= 47:\n                    return (self == .Left ? [11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5] : [9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5])[j - 32]\n                case let index where j <= 63:\n                    return (self == .Left ? [11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12] : [15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8])[j - 48]\n                case let index where j <= 79:\n                    return (self == .Left ? [9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6] : [8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11])[j - 64]\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                    }\n            }\n\n        }\n        \n        \n        \n    }\n", "target": "Python 3.3.0 (v3.3.0:bd8afb90ebf2, Sep 29 2012, 10:57:17) [MSC v.1600 64 bit (AMD64)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> import hashlib\n>>> h = hashlib.new('ripemd160')\n>>> h.update(b\"Rosetta Code\")\n>>> h.hexdigest()\n'b3be159860842cebaa7174c8fff0aa9e50a5199f'\n>>>\n"}
{"id": 151841, "name": "RIPEMD-160", "source": "Translate Swift to Python: \n\ninfix operator  ~<< { precedence 160 associativity none }\n\npublic func ~<< (lhs: UInt32, rhs: Int) -> UInt32 {\n    return (lhs << UInt32(rhs)) | (lhs >> UInt32(32 - rhs));\n}\n\n    public struct Block {\n        public init() {}\n        \n        var message: [UInt32] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        \n        var h\u2080: UInt32 = 0x67452301\n        var h\u2081: UInt32 = 0xEFCDAB89\n        var h\u2082: UInt32 = 0x98BADCFE\n        var h\u2083: UInt32 = 0x10325476\n        var h\u2084: UInt32 = 0xC3D2E1F0\n        \n        public var hash: [UInt32] {\n            return [h\u2080, h\u2081, h\u2082, h\u2083, h\u2084]\n        }\n        \n        \n        public mutating func compress (message: [UInt32]) -> () {\n            assert(count(message) == 16, \"Wrong message size\")\n            \n            var A\u1d38 = h\u2080\n            var B\u1d38 = h\u2081\n            var C\u1d38 = h\u2082\n            var D\u1d38 = h\u2083\n            var E\u1d38 = h\u2084\n            \n            var A\u1d3f = h\u2080\n            var B\u1d3f = h\u2081\n            var C\u1d3f = h\u2082\n            var D\u1d3f = h\u2083\n            var E\u1d3f = h\u2084\n            \n            for j in 0...79 {\n                \n                let word\u1d38 = message[r.Left[j]]\n                let function\u1d38 = f(j)\n                \n                let T\u1d38: UInt32 = ((A\u1d38 &+ function\u1d38(B\u1d38,C\u1d38,D\u1d38) &+ word\u1d38 &+ K.Left[j]) ~<< s.Left[j]) &+ E\u1d38\n                \n                A\u1d38 = E\u1d38\n                E\u1d38 = D\u1d38\n                D\u1d38 = C\u1d38 ~<< 10\n                C\u1d38 = B\u1d38\n                B\u1d38 = T\u1d38\n                \n                \n                let word\u1d3f = message[r.Right[j]]\n                let function\u1d3f = f(79 - j)\n                \n                let T\u1d3f: UInt32 = ((A\u1d3f &+ function\u1d3f(B\u1d3f,C\u1d3f,D\u1d3f) &+ word\u1d3f &+ K.Right[j]) ~<< s.Right[j]) &+ E\u1d3f\n                \n                A\u1d3f = E\u1d3f\n                E\u1d3f = D\u1d3f\n                D\u1d3f = C\u1d3f ~<< 10\n                C\u1d3f = B\u1d3f\n                B\u1d3f = T\u1d3f\n            }\n            \n            let T = h\u2081 &+ C\u1d38 &+ D\u1d3f\n            h\u2081 = h\u2082 &+ D\u1d38 &+ E\u1d3f\n            h\u2082 = h\u2083 &+ E\u1d38 &+ A\u1d3f\n            h\u2083 = h\u2084 &+ A\u1d38 &+ B\u1d3f\n            h\u2084 = h\u2080 &+ B\u1d38 &+ C\u1d3f\n            h\u2080 = T\n        }\n        \n        public func f (j: Int) -> ((UInt32, UInt32, UInt32) -> UInt32) {\n            switch j {\n            case let index where j < 0:\n                assert(false, \"Invalid j\")\n                return {(_, _, _) in 0 }\n            case let index where j <= 15:\n                return {(x, y, z) in  x ^ y ^ z }\n            case let index where j <= 31:\n                return {(x, y, z) in  (x & y) | (~x & z) }\n            case let index where j <= 47:\n                return {(x, y, z) in  (x | ~y) ^ z }\n            case let index where j <= 63:\n                return {(x, y, z) in  (x & z) | (y & ~z) }\n            case let index where j <= 79:\n                return {(x, y, z) in  x ^ (y | ~z) }\n            default:\n                assert(false, \"Invalid j\")\n                return {(_, _, _) in 0 }\n            }\n        }\n        \n        public enum K {\n            case Left, Right\n            \n            public subscript(j: Int) -> UInt32 {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    return self == .Left ? 0x00000000 : 0x50A28BE6\n                case let index where j <= 31:\n                    return self == .Left ? 0x5A827999 : 0x5C4DD124\n                case let index where j <= 47:\n                    return self == .Left ? 0x6ED9EBA1 : 0x6D703EF3\n                case let index where j <= 63:\n                    return self == .Left ? 0x8F1BBCDC : 0x7A6D76E9\n                case let index where j <= 79:\n                    return self == .Left ? 0xA953FD4E : 0x00000000\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                    }\n            }\n        }\n        \n        public enum r {\n            case Left, Right\n            \n            public subscript (j: Int) -> Int {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    if self == .Left {\n                        return index\n                    } else {\n                        return [5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12][index]\n                    }\n                case let index where j <= 31:\n                    if self == .Left {\n                        return [ 7, 4,13, 1,10, 6,15, 3,12, 0, 9, 5, 2,14,11, 8][index - 16]\n                    } else {\n                        return [ 6,11, 3, 7, 0,13, 5,10,14,15, 8,12, 4, 9, 1, 2][index - 16]\n                    }\n                case let index where j <= 47:\n                    if self == .Left {\n                        return [3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12][index - 32]\n                    } else {\n                        return [15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13][index - 32]\n                    }\n                case let index where j <= 63:\n                    if self == .Left {\n                        return [1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2][index - 48]\n                    } else {\n                        return [8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14][index - 48]\n                    }\n                case let index where j <= 79:\n                    if self == .Left {\n                        return [ 4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13][index - 64]\n                    } else {\n                        return [12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11][index - 64]\n                    }\n\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                }\n            }\n\n            \n        }\n        \n        public enum s {\n            case Left, Right\n            \n            public subscript(j: Int) -> Int {\n                switch j {\n                case let index where j < 0:\n                    assert(false, \"Invalid j\")\n                    return 0\n                case let index where j <= 15:\n                    return (self == .Left ? [11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8] : [8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6])[j]\n                case let index where j <= 31:\n                    return (self == .Left ? [7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12] : [9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11])[j - 16]\n                case let index where j <= 47:\n                    return (self == .Left ? [11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5] : [9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5])[j - 32]\n                case let index where j <= 63:\n                    return (self == .Left ? [11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12] : [15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8])[j - 48]\n                case let index where j <= 79:\n                    return (self == .Left ? [9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6] : [8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11])[j - 64]\n                default:\n                    assert(false, \"Invalid j\")\n                    return 0\n                    }\n            }\n\n        }\n        \n        \n        \n    }\n", "target": "Python 3.3.0 (v3.3.0:bd8afb90ebf2, Sep 29 2012, 10:57:17) [MSC v.1600 64 bit (AMD64)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> import hashlib\n>>> h = hashlib.new('ripemd160')\n>>> h.update(b\"Rosetta Code\")\n>>> h.hexdigest()\n'b3be159860842cebaa7174c8fff0aa9e50a5199f'\n>>>\n"}
{"id": 152707, "name": "Averages_Mean angle", "source": "Translate Swift to C#: import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (s, c) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * s, cInv * c))\n}\n\nlet fmt = { String(format: \"%lf\", $0) }\n\nprint(\"Mean of angles (350, 10) => \\(fmt(meanOfAngles([350, 10])))\")\nprint(\"Mean of angles (90, 180, 270, 360) => \\(fmt(meanOfAngles([90, 180, 270, 360])))\")\nprint(\"Mean of angles (10, 20, 30) => \\(fmt(meanOfAngles([10, 20, 30])))\")\n", "target": "using System;\nusing System.Linq;\nusing static System.Math;\nclass Program\n{\n    static double MeanAngle(double[] angles)\n    {\n        var x = angles.Sum(a => Cos(a * PI / 180)) / angles.Length;\n        var y = angles.Sum(a => Sin(a * PI / 180)) / angles.Length;\n        return Atan2(y, x) * 180 / PI;\n    }\n    static void Main()\n    {\n        Action<double[]> printMean = x => Console.WriteLine(\"{0:0.###}\", MeanAngle(x));\n        printMean(new double[] { 350, 10 });\n        printMean(new double[] { 90, 180, 270, 360 });\n        printMean(new double[] { 10, 20, 30 });\n    }\n}\n"}
{"id": 152708, "name": "Averages_Mean angle", "source": "Translate Swift to C#: import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (s, c) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * s, cInv * c))\n}\n\nlet fmt = { String(format: \"%lf\", $0) }\n\nprint(\"Mean of angles (350, 10) => \\(fmt(meanOfAngles([350, 10])))\")\nprint(\"Mean of angles (90, 180, 270, 360) => \\(fmt(meanOfAngles([90, 180, 270, 360])))\")\nprint(\"Mean of angles (10, 20, 30) => \\(fmt(meanOfAngles([10, 20, 30])))\")\n", "target": "using System;\nusing System.Linq;\nusing static System.Math;\nclass Program\n{\n    static double MeanAngle(double[] angles)\n    {\n        var x = angles.Sum(a => Cos(a * PI / 180)) / angles.Length;\n        var y = angles.Sum(a => Sin(a * PI / 180)) / angles.Length;\n        return Atan2(y, x) * 180 / PI;\n    }\n    static void Main()\n    {\n        Action<double[]> printMean = x => Console.WriteLine(\"{0:0.###}\", MeanAngle(x));\n        printMean(new double[] { 350, 10 });\n        printMean(new double[] { 90, 180, 270, 360 });\n        printMean(new double[] { 10, 20, 30 });\n    }\n}\n"}
{"id": 152711, "name": "Averages_Mean angle", "source": "Translate Swift to Java: import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (s, c) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * s, cInv * c))\n}\n\nlet fmt = { String(format: \"%lf\", $0) }\n\nprint(\"Mean of angles (350, 10) => \\(fmt(meanOfAngles([350, 10])))\")\nprint(\"Mean of angles (90, 180, 270, 360) => \\(fmt(meanOfAngles([90, 180, 270, 360])))\")\nprint(\"Mean of angles (10, 20, 30) => \\(fmt(meanOfAngles([10, 20, 30])))\")\n", "target": "import java.util.Arrays;\n\npublic class AverageMeanAngle {\n\n    public static void main(String[] args) {\n        printAverageAngle(350.0, 10.0);\n        printAverageAngle(90.0, 180.0, 270.0, 360.0);\n        printAverageAngle(10.0, 20.0, 30.0);\n        printAverageAngle(370.0);\n        printAverageAngle(180.0);\n    }\n\n    private static void printAverageAngle(double... sample) {\n        double meanAngle = getMeanAngle(sample);\n        System.out.printf(\"The mean angle of %s is %s%n\", Arrays.toString(sample), meanAngle);\n    }\n\n    public static double getMeanAngle(double... anglesDeg) {\n        double x = 0.0;\n        double y = 0.0;\n\n        for (double angleD : anglesDeg) {\n            double angleR = Math.toRadians(angleD);\n            x += Math.cos(angleR);\n            y += Math.sin(angleR);\n        }\n        double avgR = Math.atan2(y / anglesDeg.length, x / anglesDeg.length);\n        return Math.toDegrees(avgR);\n    }\n}\n"}
{"id": 152712, "name": "Averages_Mean angle", "source": "Translate Swift to Java: import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (s, c) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * s, cInv * c))\n}\n\nlet fmt = { String(format: \"%lf\", $0) }\n\nprint(\"Mean of angles (350, 10) => \\(fmt(meanOfAngles([350, 10])))\")\nprint(\"Mean of angles (90, 180, 270, 360) => \\(fmt(meanOfAngles([90, 180, 270, 360])))\")\nprint(\"Mean of angles (10, 20, 30) => \\(fmt(meanOfAngles([10, 20, 30])))\")\n", "target": "import java.util.Arrays;\n\npublic class AverageMeanAngle {\n\n    public static void main(String[] args) {\n        printAverageAngle(350.0, 10.0);\n        printAverageAngle(90.0, 180.0, 270.0, 360.0);\n        printAverageAngle(10.0, 20.0, 30.0);\n        printAverageAngle(370.0);\n        printAverageAngle(180.0);\n    }\n\n    private static void printAverageAngle(double... sample) {\n        double meanAngle = getMeanAngle(sample);\n        System.out.printf(\"The mean angle of %s is %s%n\", Arrays.toString(sample), meanAngle);\n    }\n\n    public static double getMeanAngle(double... anglesDeg) {\n        double x = 0.0;\n        double y = 0.0;\n\n        for (double angleD : anglesDeg) {\n            double angleR = Math.toRadians(angleD);\n            x += Math.cos(angleR);\n            y += Math.sin(angleR);\n        }\n        double avgR = Math.atan2(y / anglesDeg.length, x / anglesDeg.length);\n        return Math.toDegrees(avgR);\n    }\n}\n"}
{"id": 152713, "name": "Averages_Mean angle", "source": "Translate Swift to Python: import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (s, c) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * s, cInv * c))\n}\n\nlet fmt = { String(format: \"%lf\", $0) }\n\nprint(\"Mean of angles (350, 10) => \\(fmt(meanOfAngles([350, 10])))\")\nprint(\"Mean of angles (90, 180, 270, 360) => \\(fmt(meanOfAngles([90, 180, 270, 360])))\")\nprint(\"Mean of angles (10, 20, 30) => \\(fmt(meanOfAngles([10, 20, 30])))\")\n", "target": ">>> from cmath import rect, phase\n>>> from math import radians, degrees\n>>> def mean_angle(deg):\n...     return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))\n... \n>>> for angles in [[350, 10], [90, 180, 270, 360], [10, 20, 30]]:\n...     print('The mean angle of', angles, 'is:', round(mean_angle(angles), 12), 'degrees')\n...     \nThe mean angle of [350, 10] is: -0.0 degrees\nThe mean angle of [90, 180, 270, 360] is: -90.0 degrees\nThe mean angle of [10, 20, 30] is: 20.0 degrees\n>>>\n"}
{"id": 152714, "name": "Averages_Mean angle", "source": "Translate Swift to Python: import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (s, c) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * s, cInv * c))\n}\n\nlet fmt = { String(format: \"%lf\", $0) }\n\nprint(\"Mean of angles (350, 10) => \\(fmt(meanOfAngles([350, 10])))\")\nprint(\"Mean of angles (90, 180, 270, 360) => \\(fmt(meanOfAngles([90, 180, 270, 360])))\")\nprint(\"Mean of angles (10, 20, 30) => \\(fmt(meanOfAngles([10, 20, 30])))\")\n", "target": ">>> from cmath import rect, phase\n>>> from math import radians, degrees\n>>> def mean_angle(deg):\n...     return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))\n... \n>>> for angles in [[350, 10], [90, 180, 270, 360], [10, 20, 30]]:\n...     print('The mean angle of', angles, 'is:', round(mean_angle(angles), 12), 'degrees')\n...     \nThe mean angle of [350, 10] is: -0.0 degrees\nThe mean angle of [90, 180, 270, 360] is: -90.0 degrees\nThe mean angle of [10, 20, 30] is: 20.0 degrees\n>>>\n"}
{"id": 153273, "name": "Least common multiple", "source": "Translate Swift to C#: func lcm(a:Int, b:Int) -> Int {\n    return abs(a * b) / gcd_rec(a, b)\n}\n", "target": "Using System;\nclass Program\n{\n    static int gcd(int m, int n)\n    {\n        return n == 0 ? Math.Abs(m) : gcd(n, n % m);\n    }\n    static int lcm(int m, int n)\n    {\n        return Math.Abs(m * n) / gcd(m, n);\n    }\n    static void Main()\n    {\n        Console.WriteLine(\"lcm(12,18)=\" + lcm(12,18));\n    }\n}\n"}
{"id": 153276, "name": "Least common multiple", "source": "Translate Swift to Java: func lcm(a:Int, b:Int) -> Int {\n    return abs(a * b) / gcd_rec(a, b)\n}\n", "target": "import java.util.Scanner;\n\npublic class LCM{\n   public static void main(String[] args){\n      Scanner aScanner = new Scanner(System.in);\n   \n      \n      System.out.print(\"Enter the value of m:\");\n      int m = aScanner.nextInt();\n      System.out.print(\"Enter the value of n:\");\n      int n = aScanner.nextInt();\n      int lcm = (n == m || n == 1) ? m :(m == 1 ? n : 0);\n      \n      if (lcm == 0) {\n         int mm = m, nn = n;\n         while (mm != nn) {\n             while (mm < nn) { mm += m; }\n             while (nn < mm) { nn += n; }\n         }  \n         lcm = mm;\n      }\n      System.out.println(\"lcm(\" + m + \", \" + n + \") = \" + lcm);\n   }\n}\n"}
{"id": 153277, "name": "Least common multiple", "source": "Translate Swift to Java: func lcm(a:Int, b:Int) -> Int {\n    return abs(a * b) / gcd_rec(a, b)\n}\n", "target": "import java.util.Scanner;\n\npublic class LCM{\n   public static void main(String[] args){\n      Scanner aScanner = new Scanner(System.in);\n   \n      \n      System.out.print(\"Enter the value of m:\");\n      int m = aScanner.nextInt();\n      System.out.print(\"Enter the value of n:\");\n      int n = aScanner.nextInt();\n      int lcm = (n == m || n == 1) ? m :(m == 1 ? n : 0);\n      \n      if (lcm == 0) {\n         int mm = m, nn = n;\n         while (mm != nn) {\n             while (mm < nn) { mm += m; }\n             while (nn < mm) { nn += n; }\n         }  \n         lcm = mm;\n      }\n      System.out.println(\"lcm(\" + m + \", \" + n + \") = \" + lcm);\n   }\n}\n"}
{"id": 153278, "name": "Least common multiple", "source": "Translate Swift to Python: func lcm(a:Int, b:Int) -> Int {\n    return abs(a * b) / gcd_rec(a, b)\n}\n", "target": ">>> import fractions\n>>> def lcm(a,b): return abs(a * b) / fractions.gcd(a,b) if a and b else 0\n\n>>> lcm(12, 18)\n36\n>>> lcm(-6, 14)\n42\n>>> assert lcm(0, 2) == lcm(2, 0) == 0\n>>>\n"}
{"id": 153279, "name": "Least common multiple", "source": "Translate Swift to Python: func lcm(a:Int, b:Int) -> Int {\n    return abs(a * b) / gcd_rec(a, b)\n}\n", "target": ">>> import fractions\n>>> def lcm(a,b): return abs(a * b) / fractions.gcd(a,b) if a and b else 0\n\n>>> lcm(12, 18)\n36\n>>> lcm(-6, 14)\n42\n>>> assert lcm(0, 2) == lcm(2, 0) == 0\n>>>\n"}
{"id": 153713, "name": "Averages_Simple moving average", "source": "Translate Swift to C#: struct SimpleMovingAverage {\n  var period: Int\n  var numbers = [Double]()\n\n  mutating func addNumber(_ n: Double) -> Double {\n    numbers.append(n)\n\n    if numbers.count > period {\n      numbers.removeFirst()\n    }\n\n    guard !numbers.isEmpty else {\n      return 0\n    }\n\n    return numbers.reduce(0, +) / Double(numbers.count)\n  }\n}\n\nfor period in [3, 5] {\n  print(\"Moving average with period \\(period)\")\n\n  var averager = SimpleMovingAverage(period: period)\n\n  for n in [1.0, 2, 3, 4, 5, 5, 4, 3, 2, 1] {\n    print(\"n: \\(n); average \\(averager.addNumber(n))\")\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace SMA {\n    class Program {\n        static void Main(string[] args) {\n            var nums = Enumerable.Range(1, 5).Select(n => (double)n);\n            nums = nums.Concat(nums.Reverse());\n\n            var sma3 = SMA(3);\n            var sma5 = SMA(5);\n\n            foreach (var n in nums) {\n                Console.WriteLine(\"{0}    (sma3) {1,-16} (sma5) {2,-16}\", n, sma3(n), sma5(n));\n            }\n        }\n\n        static Func<double, double> SMA(int p) {\n            Queue<double> s = new Queue<double>(p);\n            return (x) => {\n                if (s.Count >= p) {\n                    s.Dequeue();\n                }\n                s.Enqueue(x);\n                return s.Average();\n            };\n        }\n    }\n}\n"}
{"id": 153715, "name": "Averages_Simple moving average", "source": "Translate Swift to Java: struct SimpleMovingAverage {\n  var period: Int\n  var numbers = [Double]()\n\n  mutating func addNumber(_ n: Double) -> Double {\n    numbers.append(n)\n\n    if numbers.count > period {\n      numbers.removeFirst()\n    }\n\n    guard !numbers.isEmpty else {\n      return 0\n    }\n\n    return numbers.reduce(0, +) / Double(numbers.count)\n  }\n}\n\nfor period in [3, 5] {\n  print(\"Moving average with period \\(period)\")\n\n  var averager = SimpleMovingAverage(period: period)\n\n  for n in [1.0, 2, 3, 4, 5, 5, 4, 3, 2, 1] {\n    print(\"n: \\(n); average \\(averager.addNumber(n))\")\n  }\n}\n", "target": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class MovingAverage {\n    private final Queue<Double> window = new LinkedList<Double>();\n    private final int period;\n    private double sum;\n\n    public MovingAverage(int period) {\n        assert period > 0 : \"Period must be a positive integer\";\n        this.period = period;\n    }\n\n    public void newNum(double num) {\n        sum += num;\n        window.add(num);\n        if (window.size() > period) {\n            sum -= window.remove();\n        }\n    }\n\n    public double getAvg() {\n        if (window.isEmpty()) return 0.0; \n        return sum / window.size();\n    }\n\n    public static void main(String[] args) {\n        double[] testData = {1, 2, 3, 4, 5, 5, 4, 3, 2, 1};\n        int[] windowSizes = {3, 5};\n        for (int windSize : windowSizes) {\n            MovingAverage ma = new MovingAverage(windSize);\n            for (double x : testData) {\n                ma.newNum(x);\n                System.out.println(\"Next number = \" + x + \", SMA = \" + ma.getAvg());\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 153716, "name": "Averages_Simple moving average", "source": "Translate Swift to Python: struct SimpleMovingAverage {\n  var period: Int\n  var numbers = [Double]()\n\n  mutating func addNumber(_ n: Double) -> Double {\n    numbers.append(n)\n\n    if numbers.count > period {\n      numbers.removeFirst()\n    }\n\n    guard !numbers.isEmpty else {\n      return 0\n    }\n\n    return numbers.reduce(0, +) / Double(numbers.count)\n  }\n}\n\nfor period in [3, 5] {\n  print(\"Moving average with period \\(period)\")\n\n  var averager = SimpleMovingAverage(period: period)\n\n  for n in [1.0, 2, 3, 4, 5, 5, 4, 3, 2, 1] {\n    print(\"n: \\(n); average \\(averager.addNumber(n))\")\n  }\n}\n", "target": "from collections import deque\n\ndef simplemovingaverage(period):\n    assert period == int(period) and period > 0, \"Period must be an integer >0\"\n    \n    summ = n = 0.0\n    values = deque([0.0] * period)     \n\n    def sma(x):\n        nonlocal summ, n\n        \n        values.append(x)\n        summ += x - values.popleft()\n        n = min(n+1, period)\n        return summ / n\n\n    return sma\n"}
{"id": 153949, "name": "Literals_Integer", "source": "Translate Swift to C#: let hex = 0x2F \nlet bin = 0b101111 \nlet oct = 0o57 \n", "target": "int a = 42;\nint b = 0x2a;\n"}
{"id": 153951, "name": "Literals_Integer", "source": "Translate Swift to Java: let hex = 0x2F \nlet bin = 0b101111 \nlet oct = 0o57 \n", "target": "public class IntegerLiterals {\n    public static void main(String[] args) {\n        System.out.println( 727 == 0x2d7 && \n                            727 == 01327   );\n    }\n}\n"}
{"id": 153952, "name": "Literals_Integer", "source": "Translate Swift to Python: let hex = 0x2F \nlet bin = 0b101111 \nlet oct = 0o57 \n", "target": ">>> \n>>> 0b1011010111 == 0o1327 == 727 == 0x2d7\nTrue\n>>>\n"}
{"id": 154164, "name": "JortSort", "source": "Translate Swift to C#: func jortSort<T:Comparable>(array: [T]) -> Bool {\n    return array == sorted(array)\n}\n", "target": "using System;\n\nclass Program\n{\n  public static bool JortSort<T>(T[] array) where T : IComparable, IEquatable<T>\n  {\n    \n    T[] originalArray = (T[]) array.Clone();\n    Array.Sort(array);\n\n    \n    for (var i = 0; i < originalArray.Length; i++)\n    {\n      if (!Equals(originalArray[i], array[i]))\n      {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n"}
{"id": 154166, "name": "JortSort", "source": "Translate Swift to Java: func jortSort<T:Comparable>(array: [T]) -> Bool {\n    return array == sorted(array)\n}\n", "target": "public class JortSort {\n    public static void main(String[] args) {\n        System.out.println(jortSort(new int[]{1, 2, 3}));\n    }\n\n    static boolean jortSort(int[] arr) {\n        return true;\n    }\n}\n"}
{"id": 154167, "name": "JortSort", "source": "Translate Swift to Python: func jortSort<T:Comparable>(array: [T]) -> Bool {\n    return array == sorted(array)\n}\n", "target": ">>> def jortsort(sequence):\n\treturn list(sequence) == sorted(sequence)\n>>> for data in [(1,2,4,3), (14,6,8), ['a', 'c'], ['s', 'u', 'x'], 'CVGH', 'PQRST']:\n\tprint(f'jortsort({repr(data)}) is {jortsort(data)}')\njortsort((1, 2, 4, 3)) is False\njortsort((14, 6, 8)) is False\njortsort(['a', 'c']) is True\njortsort(['s', 'u', 'x']) is True\njortsort('CVGH') is False\njortsort('PQRST') is True\n>>>\n"}
{"id": 154424, "name": "String concatenation", "source": "Translate Swift to C#: let s = \"hello\"\nprintln(s + \" literal\")\nlet s1 = s + \" literal\"\nprintln(s1)\n", "target": "using System;\nnamespace StringConcatenation\n{\n  class Program {\n    static void Main() {\n        String s = scope (\"hello\");\n        Console.Write(s);\n        Console.WriteLine(\" literal\");\n        s.Append(\" literal\");\n        Console.WriteLine(s);\n    }\n  }\n}\n"}
{"id": 154426, "name": "String concatenation", "source": "Translate Swift to Java: let s = \"hello\"\nprintln(s + \" literal\")\nlet s1 = s + \" literal\"\nprintln(s1)\n", "target": "public class Str{\n   public static void main(String[] args){\n      String s = \"hello\";\n      System.out.println(s + \" literal\");\n      String s2 = s + \" literal\";\n      System.out.println(s2);\n   }\n}\n"}
{"id": 154427, "name": "String concatenation", "source": "Translate Swift to Python: let s = \"hello\"\nprintln(s + \" literal\")\nlet s1 = s + \" literal\"\nprintln(s1)\n", "target": "s1 = \"hello\"\nprint s1 + \" world\"\n\ns2 = s1 + \" world\"\nprint s2\n"}
{"id": 155307, "name": "Repeat a string", "source": "Translate Swift to Python: print(String(repeating:\"*\", count: 5))\n", "target": "def setup():\n    rep = repeat(\"ha\", 5)\n    println(rep)\n\ndef repeat(s, times):\n    return s * times\n"}
{"id": 155548, "name": "Ethiopian multiplication", "source": "Translate Swift to C#: import Darwin\n\nfunc ethiopian(var #int1:Int, var #int2:Int) -> Int {\n  var lhs = [int1], rhs = [int2]\n  \n  func isEven(#n:Int) -> Bool {return n % 2 == 0}\n  func double(#n:Int) -> Int {return n * 2}\n  func halve(#n:Int) -> Int {return n / 2}\n  \n  while int1 != 1 {\n    lhs.append(halve(n: int1))\n    rhs.append(double(n: int2))\n    int1 = halve(n: int1)\n    int2 = double(n: int2)\n  }\n  \n  var returnInt = 0\n  for (a,b) in zip(lhs, rhs) {\n    if (!isEven(n: a)) {\n      returnInt += b\n    }\n  }\n  return returnInt\n}\n\nprintln(ethiopian(int1: 17, int2: 34))\n", "target": "using System;\nusing System.Linq;\n\nnamespace RosettaCode.Tasks\n{\n\tpublic static class EthiopianMultiplication_Task\n\t{\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Ethiopian Multiplication\" );\n\t\t\tint A = 17, B = 34;\n\t\t\tConsole.WriteLine ( \"Recursion: {0}*{1}={2}\", A, B, EM_Recursion ( A, B ) );\n\t\t\tConsole.WriteLine ( \"Linq: {0}*{1}={2}\", A, B, EM_Linq ( A, B ) );\n\t\t\tConsole.WriteLine ( \"Loop: {0}*{1}={2}\", A, B, EM_Loop ( A, B ) );\n\t\t\tConsole.WriteLine ( );\n\t\t}\n\n\t\tpublic static int Halve ( this int p_Number )\n\t\t{\n\t\t\treturn p_Number >> 1;\n\t\t}\n\t\tpublic static int Double ( this int p_Number )\n\t\t{\n\t\t\treturn p_Number << 1;\n\t\t}\n\t\tpublic static bool IsEven ( this int p_Number )\n\t\t{\n\t\t\treturn ( p_Number % 2 ) == 0;\n\t\t}\n\n\t\tpublic static int EM_Recursion ( int p_NumberA, int p_NumberB )\n\t\t{\n\t\t\t\n\t\t\treturn p_NumberA == 1 ? p_NumberB : EM_Recursion ( p_NumberA.Halve ( ), p_NumberB.Double ( ) ) + ( p_NumberA.IsEven ( ) ? 0 : p_NumberB );\n\t\t}\n\t\tpublic static int EM_Linq ( int p_NumberA, int p_NumberB )\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\treturn Enumerable.Range ( 1, Convert.ToInt32 ( Math.Log ( p_NumberA, Math.E ) / Math.Log ( 2, Math.E ) ) + 1 )\n\t\t\t\t\n\t\t\t\t.Select ( ( item ) => Enumerable.Repeat ( new { Col1 = p_NumberA, Col2 = p_NumberB }, item )\n\t\t\t\t\t\n\t\t\t\t\t.Aggregate ( ( agg_pair, orig_pair ) => new { Col1 = agg_pair.Col1.Halve ( ), Col2 = agg_pair.Col2.Double ( ) } ) )\n\t\t\t\t\n\t\t\t\t.Where ( pair => !pair.Col1.IsEven ( ) )\n\t\t\t\t\n\t\t\t\t.Sum ( pair => pair.Col2 );\n\t\t}\n\t\tpublic static int EM_Loop ( int p_NumberA, int p_NumberB )\n\t\t{\n\t\t\tint RetVal = 0;\n\t\t\twhile ( p_NumberA >= 1 )\n\t\t\t{\n\t\t\t\tRetVal += p_NumberA.IsEven ( ) ? 0 : p_NumberB;\n\t\t\t\tp_NumberA = p_NumberA.Halve ( );\n\t\t\t\tp_NumberB = p_NumberB.Double ( );\n\t\t\t}\n\t\t\treturn RetVal;\n\t\t}\n\t}\n}\n"}
{"id": 155550, "name": "Ethiopian multiplication", "source": "Translate Swift to Java: import Darwin\n\nfunc ethiopian(var #int1:Int, var #int2:Int) -> Int {\n  var lhs = [int1], rhs = [int2]\n  \n  func isEven(#n:Int) -> Bool {return n % 2 == 0}\n  func double(#n:Int) -> Int {return n * 2}\n  func halve(#n:Int) -> Int {return n / 2}\n  \n  while int1 != 1 {\n    lhs.append(halve(n: int1))\n    rhs.append(double(n: int2))\n    int1 = halve(n: int1)\n    int2 = double(n: int2)\n  }\n  \n  var returnInt = 0\n  for (a,b) in zip(lhs, rhs) {\n    if (!isEven(n: a)) {\n      returnInt += b\n    }\n  }\n  return returnInt\n}\n\nprintln(ethiopian(int1: 17, int2: 34))\n", "target": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\npublic class Mult{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    int first = sc.nextInt();\n    int second = sc.nextInt();\n\n    if(first < 0){\n        first = -first;\n        second = -second;\n    }\n\n    Map<Integer, Integer> columns = new HashMap<Integer, Integer>();\n        columns.put(first, second);\n    int sum = isEven(first)? 0 : second;\n    do{\n      first = halveInt(first);\n      second = doubleInt(second);\n      columns.put(first, second);\n      if(!isEven(first)){\n          sum += second;\n      }\n    }while(first > 1);\n \n    System.out.println(sum);\n  }\n\n  public static int doubleInt(int doubleMe){\n    return doubleMe << 1; \n  }\n\n  public static int halveInt(int halveMe){\n    return halveMe >>> 1; \n  }\n\n  public static boolean isEven(int num){\n    return (num & 1) == 0;\n  }\n}\n"}
{"id": 155551, "name": "Ethiopian multiplication", "source": "Translate Swift to Python: import Darwin\n\nfunc ethiopian(var #int1:Int, var #int2:Int) -> Int {\n  var lhs = [int1], rhs = [int2]\n  \n  func isEven(#n:Int) -> Bool {return n % 2 == 0}\n  func double(#n:Int) -> Int {return n * 2}\n  func halve(#n:Int) -> Int {return n / 2}\n  \n  while int1 != 1 {\n    lhs.append(halve(n: int1))\n    rhs.append(double(n: int2))\n    int1 = halve(n: int1)\n    int2 = double(n: int2)\n  }\n  \n  var returnInt = 0\n  for (a,b) in zip(lhs, rhs) {\n    if (!isEven(n: a)) {\n      returnInt += b\n    }\n  }\n  return returnInt\n}\n\nprintln(ethiopian(int1: 17, int2: 34))\n", "target": "tutor = True\n\ndef halve(x):\n    return x // 2\n\ndef double(x):\n    return x * 2\n\ndef even(x):\n    return not x % 2\n\ndef ethiopian(multiplier, multiplicand):\n    if tutor:\n        print(\"Ethiopian multiplication of %i and %i\" %\n              (multiplier, multiplicand))\n    result = 0\n    while multiplier >= 1:\n        if even(multiplier):\n            if tutor:\n                print(\"%4i %6i STRUCK\" %\n                      (multiplier, multiplicand))\n        else:\n            if tutor:\n                print(\"%4i %6i KEPT\" %\n                      (multiplier, multiplicand))\n            result += multiplicand\n        multiplier   = halve(multiplier)\n        multiplicand = double(multiplicand)\n    if tutor:\n        print()\n    return result\n"}
{"id": 156144, "name": "Multisplit", "source": "Translate Swift to C#: extension String {\n  func multiSplit(on seps: [String]) -> ([Substring], [(String, (start: String.Index, end: String.Index))]) {\n    var matches = [Substring]()\n    var matched = [(String, (String.Index, String.Index))]()\n    var i = startIndex\n    var lastMatch = startIndex\n\n    main: while i != endIndex {\n      for sep in seps where self[i...].hasPrefix(sep) {\n        if i > lastMatch {\n          matches.append(self[lastMatch..<i])\n        } else {\n          matches.append(\"\")\n        }\n\n        lastMatch = index(i, offsetBy: sep.count)\n        matched.append((sep, (i, lastMatch)))\n        i = lastMatch\n\n        continue main\n      }\n\n      i = index(i, offsetBy: 1)\n    }\n\n    if i > lastMatch {\n      matches.append(self[lastMatch..<i])\n    }\n\n    return (matches, matched)\n  }\n}\n\nlet (matches, matchedSeps) = \"a!===b=!=c\".multiSplit(on: [\"==\", \"!=\", \"=\"])\n\nprint(matches, matchedSeps.map({ $0.0 }))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Multisplit\n{\n    internal static class Program\n    {\n        private static void Main(string[] args)\n        {\n            foreach (var s in \"a!===b=!=c\".Multisplit(true, \"==\", \"!=\", \"=\")) \n            {\n                Console.Write(s); \n            }\n            Console.WriteLine();\n        }\n\n        private static IEnumerable<string> Multisplit(this string s, bool returnSeparators = false,\n                                                      params string[] delimiters)\n        {\n            var currentString = new StringBuilder(); \n\n            int index = 0; \n\n            while (index < s.Length) \n            {\n                \n                string foundDelimiter =\n                    (from delimiter in delimiters\n                     where s.Length >= index + delimiter.Length &&\n                           s.Substring(index, delimiter.Length) == delimiter\n                     select delimiter).FirstOrDefault();\n\n                if (foundDelimiter != null)\n                {\n                    yield return currentString.ToString(); \n                    if (returnSeparators) \n                        yield return\n                            string.Format(\"{{\\\"{0}\\\", ({1}, {2})}}\",\n                                          foundDelimiter,\n                                          index, index + foundDelimiter.Length);\n                    currentString.Clear(); \n                    index += foundDelimiter.Length; \n                }\n                else\n                {\n                    currentString.Append(s[index++]); \n                }\n            }\n\n            if (currentString.Length > 0)\n                yield return currentString.ToString(); \n        }\n    }\n}\n"}
{"id": 156145, "name": "Multisplit", "source": "Translate Swift to C#: extension String {\n  func multiSplit(on seps: [String]) -> ([Substring], [(String, (start: String.Index, end: String.Index))]) {\n    var matches = [Substring]()\n    var matched = [(String, (String.Index, String.Index))]()\n    var i = startIndex\n    var lastMatch = startIndex\n\n    main: while i != endIndex {\n      for sep in seps where self[i...].hasPrefix(sep) {\n        if i > lastMatch {\n          matches.append(self[lastMatch..<i])\n        } else {\n          matches.append(\"\")\n        }\n\n        lastMatch = index(i, offsetBy: sep.count)\n        matched.append((sep, (i, lastMatch)))\n        i = lastMatch\n\n        continue main\n      }\n\n      i = index(i, offsetBy: 1)\n    }\n\n    if i > lastMatch {\n      matches.append(self[lastMatch..<i])\n    }\n\n    return (matches, matched)\n  }\n}\n\nlet (matches, matchedSeps) = \"a!===b=!=c\".multiSplit(on: [\"==\", \"!=\", \"=\"])\n\nprint(matches, matchedSeps.map({ $0.0 }))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Multisplit\n{\n    internal static class Program\n    {\n        private static void Main(string[] args)\n        {\n            foreach (var s in \"a!===b=!=c\".Multisplit(true, \"==\", \"!=\", \"=\")) \n            {\n                Console.Write(s); \n            }\n            Console.WriteLine();\n        }\n\n        private static IEnumerable<string> Multisplit(this string s, bool returnSeparators = false,\n                                                      params string[] delimiters)\n        {\n            var currentString = new StringBuilder(); \n\n            int index = 0; \n\n            while (index < s.Length) \n            {\n                \n                string foundDelimiter =\n                    (from delimiter in delimiters\n                     where s.Length >= index + delimiter.Length &&\n                           s.Substring(index, delimiter.Length) == delimiter\n                     select delimiter).FirstOrDefault();\n\n                if (foundDelimiter != null)\n                {\n                    yield return currentString.ToString(); \n                    if (returnSeparators) \n                        yield return\n                            string.Format(\"{{\\\"{0}\\\", ({1}, {2})}}\",\n                                          foundDelimiter,\n                                          index, index + foundDelimiter.Length);\n                    currentString.Clear(); \n                    index += foundDelimiter.Length; \n                }\n                else\n                {\n                    currentString.Append(s[index++]); \n                }\n            }\n\n            if (currentString.Length > 0)\n                yield return currentString.ToString(); \n        }\n    }\n}\n"}
{"id": 156148, "name": "Multisplit", "source": "Translate Swift to Java: extension String {\n  func multiSplit(on seps: [String]) -> ([Substring], [(String, (start: String.Index, end: String.Index))]) {\n    var matches = [Substring]()\n    var matched = [(String, (String.Index, String.Index))]()\n    var i = startIndex\n    var lastMatch = startIndex\n\n    main: while i != endIndex {\n      for sep in seps where self[i...].hasPrefix(sep) {\n        if i > lastMatch {\n          matches.append(self[lastMatch..<i])\n        } else {\n          matches.append(\"\")\n        }\n\n        lastMatch = index(i, offsetBy: sep.count)\n        matched.append((sep, (i, lastMatch)))\n        i = lastMatch\n\n        continue main\n      }\n\n      i = index(i, offsetBy: 1)\n    }\n\n    if i > lastMatch {\n      matches.append(self[lastMatch..<i])\n    }\n\n    return (matches, matched)\n  }\n}\n\nlet (matches, matchedSeps) = \"a!===b=!=c\".multiSplit(on: [\"==\", \"!=\", \"=\"])\n\nprint(matches, matchedSeps.map({ $0.0 }))\n", "target": "import java.util.*;\n\npublic class MultiSplit {\n\n    public static void main(String[] args) {\n        System.out.println(\"Regex split:\");\n        System.out.println(Arrays.toString(\"a!===b=!=c\".split(\"==|!=|=\")));\n\n        System.out.println(\"\\nManual split:\");\n        for (String s : multiSplit(\"a!===b=!=c\", new String[]{\"==\", \"!=\", \"=\"}))\n            System.out.printf(\"\\\"%s\\\" \", s);\n    }\n\n    static List<String> multiSplit(String txt, String[] separators) {\n        List<String> result = new ArrayList<>();\n        int txtLen = txt.length(), from = 0;\n\n        for (int to = 0; to < txtLen; to++) {\n            for (String sep : separators) {\n                int sepLen = sep.length();\n                if (txt.regionMatches(to, sep, 0, sepLen)) {\n                    result.add(txt.substring(from, to));\n                    from = to + sepLen;\n                    to = from - 1; \n                    break;\n                }\n            }\n        }\n        if (from < txtLen)\n            result.add(txt.substring(from));\n        return result;\n    }\n}\n"}
{"id": 156149, "name": "Multisplit", "source": "Translate Swift to Java: extension String {\n  func multiSplit(on seps: [String]) -> ([Substring], [(String, (start: String.Index, end: String.Index))]) {\n    var matches = [Substring]()\n    var matched = [(String, (String.Index, String.Index))]()\n    var i = startIndex\n    var lastMatch = startIndex\n\n    main: while i != endIndex {\n      for sep in seps where self[i...].hasPrefix(sep) {\n        if i > lastMatch {\n          matches.append(self[lastMatch..<i])\n        } else {\n          matches.append(\"\")\n        }\n\n        lastMatch = index(i, offsetBy: sep.count)\n        matched.append((sep, (i, lastMatch)))\n        i = lastMatch\n\n        continue main\n      }\n\n      i = index(i, offsetBy: 1)\n    }\n\n    if i > lastMatch {\n      matches.append(self[lastMatch..<i])\n    }\n\n    return (matches, matched)\n  }\n}\n\nlet (matches, matchedSeps) = \"a!===b=!=c\".multiSplit(on: [\"==\", \"!=\", \"=\"])\n\nprint(matches, matchedSeps.map({ $0.0 }))\n", "target": "import java.util.*;\n\npublic class MultiSplit {\n\n    public static void main(String[] args) {\n        System.out.println(\"Regex split:\");\n        System.out.println(Arrays.toString(\"a!===b=!=c\".split(\"==|!=|=\")));\n\n        System.out.println(\"\\nManual split:\");\n        for (String s : multiSplit(\"a!===b=!=c\", new String[]{\"==\", \"!=\", \"=\"}))\n            System.out.printf(\"\\\"%s\\\" \", s);\n    }\n\n    static List<String> multiSplit(String txt, String[] separators) {\n        List<String> result = new ArrayList<>();\n        int txtLen = txt.length(), from = 0;\n\n        for (int to = 0; to < txtLen; to++) {\n            for (String sep : separators) {\n                int sepLen = sep.length();\n                if (txt.regionMatches(to, sep, 0, sepLen)) {\n                    result.add(txt.substring(from, to));\n                    from = to + sepLen;\n                    to = from - 1; \n                    break;\n                }\n            }\n        }\n        if (from < txtLen)\n            result.add(txt.substring(from));\n        return result;\n    }\n}\n"}
{"id": 156150, "name": "Multisplit", "source": "Translate Swift to Python: extension String {\n  func multiSplit(on seps: [String]) -> ([Substring], [(String, (start: String.Index, end: String.Index))]) {\n    var matches = [Substring]()\n    var matched = [(String, (String.Index, String.Index))]()\n    var i = startIndex\n    var lastMatch = startIndex\n\n    main: while i != endIndex {\n      for sep in seps where self[i...].hasPrefix(sep) {\n        if i > lastMatch {\n          matches.append(self[lastMatch..<i])\n        } else {\n          matches.append(\"\")\n        }\n\n        lastMatch = index(i, offsetBy: sep.count)\n        matched.append((sep, (i, lastMatch)))\n        i = lastMatch\n\n        continue main\n      }\n\n      i = index(i, offsetBy: 1)\n    }\n\n    if i > lastMatch {\n      matches.append(self[lastMatch..<i])\n    }\n\n    return (matches, matched)\n  }\n}\n\nlet (matches, matchedSeps) = \"a!===b=!=c\".multiSplit(on: [\"==\", \"!=\", \"=\"])\n\nprint(matches, matchedSeps.map({ $0.0 }))\n", "target": ">>> import re\n>>> def ms2(txt=\"a!===b=!=c\", sep=[\"==\", \"!=\", \"=\"]):\n\tif not txt or not sep:\n\t\treturn []\n\tans = m = []\n\tfor m in re.finditer('(.*?)(?:' + '|'.join('('+re.escape(s)+')' for s in sep) + ')', txt):\n\t\tans += [m.group(1), (m.lastindex-2, m.start(m.lastindex))]\n\tif m and txt[m.end(m.lastindex):]:\n\t\tans += [txt[m.end(m.lastindex):]]\n\treturn ans\n\n>>> ms2()\n['a', (1, 1), '', (0, 3), 'b', (2, 6), '', (1, 7), 'c']\n>>> ms2(txt=\"a!===b=!=c\", sep=[\"=\", \"!=\", \"==\"])\n['a', (1, 1), '', (0, 3), '', (0, 4), 'b', (0, 6), '', (1, 7), 'c']\n"}
{"id": 156151, "name": "Multisplit", "source": "Translate Swift to Python: extension String {\n  func multiSplit(on seps: [String]) -> ([Substring], [(String, (start: String.Index, end: String.Index))]) {\n    var matches = [Substring]()\n    var matched = [(String, (String.Index, String.Index))]()\n    var i = startIndex\n    var lastMatch = startIndex\n\n    main: while i != endIndex {\n      for sep in seps where self[i...].hasPrefix(sep) {\n        if i > lastMatch {\n          matches.append(self[lastMatch..<i])\n        } else {\n          matches.append(\"\")\n        }\n\n        lastMatch = index(i, offsetBy: sep.count)\n        matched.append((sep, (i, lastMatch)))\n        i = lastMatch\n\n        continue main\n      }\n\n      i = index(i, offsetBy: 1)\n    }\n\n    if i > lastMatch {\n      matches.append(self[lastMatch..<i])\n    }\n\n    return (matches, matched)\n  }\n}\n\nlet (matches, matchedSeps) = \"a!===b=!=c\".multiSplit(on: [\"==\", \"!=\", \"=\"])\n\nprint(matches, matchedSeps.map({ $0.0 }))\n", "target": ">>> import re\n>>> def ms2(txt=\"a!===b=!=c\", sep=[\"==\", \"!=\", \"=\"]):\n\tif not txt or not sep:\n\t\treturn []\n\tans = m = []\n\tfor m in re.finditer('(.*?)(?:' + '|'.join('('+re.escape(s)+')' for s in sep) + ')', txt):\n\t\tans += [m.group(1), (m.lastindex-2, m.start(m.lastindex))]\n\tif m and txt[m.end(m.lastindex):]:\n\t\tans += [txt[m.end(m.lastindex):]]\n\treturn ans\n\n>>> ms2()\n['a', (1, 1), '', (0, 3), 'b', (2, 6), '', (1, 7), 'c']\n>>> ms2(txt=\"a!===b=!=c\", sep=[\"=\", \"!=\", \"==\"])\n['a', (1, 1), '', (0, 3), '', (0, 4), 'b', (0, 6), '', (1, 7), 'c']\n"}
{"id": 156949, "name": "Van Eck sequence", "source": "Translate Swift to C#: struct VanEckSequence: Sequence, IteratorProtocol {\n    private var index = 0\n    private var lastTerm = 0\n    private var lastPos = Dictionary<Int, Int>()\n    \n    mutating func next() -> Int? {\n        let result = lastTerm\n        var nextTerm = 0\n        if let v = lastPos[lastTerm] {\n            nextTerm = index - v\n        }\n        lastPos[lastTerm] = index\n        lastTerm = nextTerm\n        index += 1\n        return result\n    }\n}\n \nlet seq = VanEckSequence().prefix(1000)\n\nprint(\"First 10 terms of the Van Eck sequence:\")\nfor n in seq.prefix(10) {\n    print(n, terminator: \" \")\n}\nprint(\"\\nTerms 991 to 1000 of the Van Eck sequence:\")\nfor n in seq.dropFirst(990) {\n    print(n, terminator: \" \")\n}\nprint()\n", "target": "using System.Linq; class Program { static void Main() {\n    int a, b, c, d, e, f, g; int[] h = new int[g = 1000];\n    for (a = 0, b = 1, c = 2; c < g; a = b, b = c++)\n        for (d = a, e = b - d, f = h[b]; e <= b; e++)\n            if (f == h[d--]) { h[c] = e; break; }\n    void sho(int i) { System.Console.WriteLine(string.Join(\" \",\n        h.Skip(i).Take(10))); } sho(0); sho(990); } }\n"}
{"id": 156950, "name": "Van Eck sequence", "source": "Translate Swift to C#: struct VanEckSequence: Sequence, IteratorProtocol {\n    private var index = 0\n    private var lastTerm = 0\n    private var lastPos = Dictionary<Int, Int>()\n    \n    mutating func next() -> Int? {\n        let result = lastTerm\n        var nextTerm = 0\n        if let v = lastPos[lastTerm] {\n            nextTerm = index - v\n        }\n        lastPos[lastTerm] = index\n        lastTerm = nextTerm\n        index += 1\n        return result\n    }\n}\n \nlet seq = VanEckSequence().prefix(1000)\n\nprint(\"First 10 terms of the Van Eck sequence:\")\nfor n in seq.prefix(10) {\n    print(n, terminator: \" \")\n}\nprint(\"\\nTerms 991 to 1000 of the Van Eck sequence:\")\nfor n in seq.dropFirst(990) {\n    print(n, terminator: \" \")\n}\nprint()\n", "target": "using System.Linq; class Program { static void Main() {\n    int a, b, c, d, e, f, g; int[] h = new int[g = 1000];\n    for (a = 0, b = 1, c = 2; c < g; a = b, b = c++)\n        for (d = a, e = b - d, f = h[b]; e <= b; e++)\n            if (f == h[d--]) { h[c] = e; break; }\n    void sho(int i) { System.Console.WriteLine(string.Join(\" \",\n        h.Skip(i).Take(10))); } sho(0); sho(990); } }\n"}
{"id": 156953, "name": "Van Eck sequence", "source": "Translate Swift to Java: struct VanEckSequence: Sequence, IteratorProtocol {\n    private var index = 0\n    private var lastTerm = 0\n    private var lastPos = Dictionary<Int, Int>()\n    \n    mutating func next() -> Int? {\n        let result = lastTerm\n        var nextTerm = 0\n        if let v = lastPos[lastTerm] {\n            nextTerm = index - v\n        }\n        lastPos[lastTerm] = index\n        lastTerm = nextTerm\n        index += 1\n        return result\n    }\n}\n \nlet seq = VanEckSequence().prefix(1000)\n\nprint(\"First 10 terms of the Van Eck sequence:\")\nfor n in seq.prefix(10) {\n    print(n, terminator: \" \")\n}\nprint(\"\\nTerms 991 to 1000 of the Van Eck sequence:\")\nfor n in seq.dropFirst(990) {\n    print(n, terminator: \" \")\n}\nprint()\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VanEckSequence {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 10 terms of Van Eck's sequence:\");\n        vanEck(1, 10);\n        System.out.println(\"\");\n        System.out.println(\"Terms 991 to 1000 of Van Eck's sequence:\");\n        vanEck(991, 1000);\n    }\n    \n    private static void vanEck(int firstIndex, int lastIndex) {\n        Map<Integer,Integer> vanEckMap = new HashMap<>();        \n        int last = 0;\n        if ( firstIndex == 1 ) {\n            System.out.printf(\"VanEck[%d] = %d%n\", 1, 0);\n        }\n        for ( int n = 2 ; n <= lastIndex ; n++ ) {\n            int vanEck = vanEckMap.containsKey(last) ? n - vanEckMap.get(last) : 0;\n            vanEckMap.put(last, n);\n            last = vanEck;\n            if ( n >= firstIndex ) {\n                System.out.printf(\"VanEck[%d] = %d%n\", n, vanEck);\n            }\n        }\n        \n    }\n\n}\n"}
{"id": 156954, "name": "Van Eck sequence", "source": "Translate Swift to Java: struct VanEckSequence: Sequence, IteratorProtocol {\n    private var index = 0\n    private var lastTerm = 0\n    private var lastPos = Dictionary<Int, Int>()\n    \n    mutating func next() -> Int? {\n        let result = lastTerm\n        var nextTerm = 0\n        if let v = lastPos[lastTerm] {\n            nextTerm = index - v\n        }\n        lastPos[lastTerm] = index\n        lastTerm = nextTerm\n        index += 1\n        return result\n    }\n}\n \nlet seq = VanEckSequence().prefix(1000)\n\nprint(\"First 10 terms of the Van Eck sequence:\")\nfor n in seq.prefix(10) {\n    print(n, terminator: \" \")\n}\nprint(\"\\nTerms 991 to 1000 of the Van Eck sequence:\")\nfor n in seq.dropFirst(990) {\n    print(n, terminator: \" \")\n}\nprint()\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VanEckSequence {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 10 terms of Van Eck's sequence:\");\n        vanEck(1, 10);\n        System.out.println(\"\");\n        System.out.println(\"Terms 991 to 1000 of Van Eck's sequence:\");\n        vanEck(991, 1000);\n    }\n    \n    private static void vanEck(int firstIndex, int lastIndex) {\n        Map<Integer,Integer> vanEckMap = new HashMap<>();        \n        int last = 0;\n        if ( firstIndex == 1 ) {\n            System.out.printf(\"VanEck[%d] = %d%n\", 1, 0);\n        }\n        for ( int n = 2 ; n <= lastIndex ; n++ ) {\n            int vanEck = vanEckMap.containsKey(last) ? n - vanEckMap.get(last) : 0;\n            vanEckMap.put(last, n);\n            last = vanEck;\n            if ( n >= firstIndex ) {\n                System.out.printf(\"VanEck[%d] = %d%n\", n, vanEck);\n            }\n        }\n        \n    }\n\n}\n"}
{"id": 156955, "name": "Van Eck sequence", "source": "Translate Swift to Python: struct VanEckSequence: Sequence, IteratorProtocol {\n    private var index = 0\n    private var lastTerm = 0\n    private var lastPos = Dictionary<Int, Int>()\n    \n    mutating func next() -> Int? {\n        let result = lastTerm\n        var nextTerm = 0\n        if let v = lastPos[lastTerm] {\n            nextTerm = index - v\n        }\n        lastPos[lastTerm] = index\n        lastTerm = nextTerm\n        index += 1\n        return result\n    }\n}\n \nlet seq = VanEckSequence().prefix(1000)\n\nprint(\"First 10 terms of the Van Eck sequence:\")\nfor n in seq.prefix(10) {\n    print(n, terminator: \" \")\n}\nprint(\"\\nTerms 991 to 1000 of the Van Eck sequence:\")\nfor n in seq.dropFirst(990) {\n    print(n, terminator: \" \")\n}\nprint()\n", "target": "def van_eck():\n    n, seen, val = 0, {}, 0\n    while True:\n        yield val\n        last = {val: n}\n        val = n - seen.get(val, n)\n        seen.update(last)\n        n += 1\n\nif __name__ == '__main__':\n    print(\"Van Eck: first 10 terms:  \", list(islice(van_eck(), 10)))\n    print(\"Van Eck: terms 991 - 1000:\", list(islice(van_eck(), 1000))[-10:])\n"}
{"id": 156956, "name": "Van Eck sequence", "source": "Translate Swift to Python: struct VanEckSequence: Sequence, IteratorProtocol {\n    private var index = 0\n    private var lastTerm = 0\n    private var lastPos = Dictionary<Int, Int>()\n    \n    mutating func next() -> Int? {\n        let result = lastTerm\n        var nextTerm = 0\n        if let v = lastPos[lastTerm] {\n            nextTerm = index - v\n        }\n        lastPos[lastTerm] = index\n        lastTerm = nextTerm\n        index += 1\n        return result\n    }\n}\n \nlet seq = VanEckSequence().prefix(1000)\n\nprint(\"First 10 terms of the Van Eck sequence:\")\nfor n in seq.prefix(10) {\n    print(n, terminator: \" \")\n}\nprint(\"\\nTerms 991 to 1000 of the Van Eck sequence:\")\nfor n in seq.dropFirst(990) {\n    print(n, terminator: \" \")\n}\nprint()\n", "target": "def van_eck():\n    n, seen, val = 0, {}, 0\n    while True:\n        yield val\n        last = {val: n}\n        val = n - seen.get(val, n)\n        seen.update(last)\n        n += 1\n\nif __name__ == '__main__':\n    print(\"Van Eck: first 10 terms:  \", list(islice(van_eck(), 10)))\n    print(\"Van Eck: terms 991 - 1000:\", list(islice(van_eck(), 1000))[-10:])\n"}
{"id": 157290, "name": "Permutations", "source": "Translate Swift to C#: func perms<T>(var ar: [T]) -> [[T]] {\n  return heaps(&ar, ar.count)\n}\n\nfunc heaps<T>(inout ar: [T], n: Int) -> [[T]] {\n  return n == 1 ? [ar] :\n    Swift.reduce(0..<n, [[T]]()) {\n      (var shuffles, i) in\n      shuffles.extend(heaps(&ar, n - 1))\n      swap(&ar[n % 2 == 0 ? i : 0], &ar[n - 1])\n      return shuffles\n  }\n}\n\nperms([1, 2, 3]) \n", "target": "public static class Extension\n{\n    public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values) where T : IComparable<T>\n    {\n        if (values.Count() == 1)\n            return new[] { values };\n        return values.SelectMany(v => Permutations(values.Where(x => x.CompareTo(v) != 0)), (v, p) => p.Prepend(v));\n    }\n}\n"}
{"id": 157292, "name": "Permutations", "source": "Translate Swift to Java: func perms<T>(var ar: [T]) -> [[T]] {\n  return heaps(&ar, ar.count)\n}\n\nfunc heaps<T>(inout ar: [T], n: Int) -> [[T]] {\n  return n == 1 ? [ar] :\n    Swift.reduce(0..<n, [[T]]()) {\n      (var shuffles, i) in\n      shuffles.extend(heaps(&ar, n - 1))\n      swap(&ar[n % 2 == 0 ? i : 0], &ar[n - 1])\n      return shuffles\n  }\n}\n\nperms([1, 2, 3]) \n", "target": "\nmodule Permutations\n    {\n    static Int[][] permut(Int items)\n        {\n        if (items <= 1)\n            {\n            \n            return items == 1 ? [[0]] : [];\n            }\n\n        \n        \n        Int[][] pattern = permut(items - 1);\n\n        \n        \n        Int[][] result = new Int[][];\n        for (Int prefix : 0 ..< items)\n            {\n            for (Int[] suffix : pattern)\n                {\n                result.add(new Int[items](i -> i == 0 ? prefix : (prefix + suffix[i-1] + 1) % items));\n                }\n            }\n        return result;\n        }\n\n    void run()\n        {\n        @Inject Console console;\n        console.print($\"permut(3) = {permut(3)}\");\n        }\n    }\n"}
{"id": 157293, "name": "Permutations", "source": "Translate Swift to Python: func perms<T>(var ar: [T]) -> [[T]] {\n  return heaps(&ar, ar.count)\n}\n\nfunc heaps<T>(inout ar: [T], n: Int) -> [[T]] {\n  return n == 1 ? [ar] :\n    Swift.reduce(0..<n, [[T]]()) {\n      (var shuffles, i) in\n      shuffles.extend(heaps(&ar, n - 1))\n      swap(&ar[n % 2 == 0 ? i : 0], &ar[n - 1])\n      return shuffles\n  }\n}\n\nperms([1, 2, 3]) \n", "target": "import itertools\nfor values in itertools.permutations([1,2,3]):\n    print (values)\n"}
{"id": 157499, "name": "Proper divisors", "source": "Translate Swift to C#: func properDivs1(n: Int) -> [Int] {\n\n    return filter (1 ..< n) { n % $0 == 0 }\n}\n", "target": "namespace RosettaCode.ProperDivisors\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    internal static class Program\n    {\n        private static IEnumerable<int> ProperDivisors(int number)\n        {\n            return\n                Enumerable.Range(1, number / 2)\n                    .Where(divisor => number % divisor == 0);\n        }\n\n        private static void Main()\n        {\n            foreach (var number in Enumerable.Range(1, 10))\n            {\n                Console.WriteLine(\"{0}: {{{1}}}\", number,\n                    string.Join(\", \", ProperDivisors(number)));\n            }\n\n            var record = Enumerable.Range(1, 20000).Select(number => new\n            {\n                Number = number,\n                Count = ProperDivisors(number).Count()\n            }).OrderByDescending(currentRecord => currentRecord.Count).First();\n            Console.WriteLine(\"{0}: {1}\", record.Number, record.Count);\n        }\n    }\n}\n"}
{"id": 157501, "name": "Proper divisors", "source": "Translate Swift to Java: func properDivs1(n: Int) -> [Int] {\n\n    return filter (1 ..< n) { n % $0 == 0 }\n}\n", "target": "import java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Proper{\n    public static List<Integer> properDivs(int n){\n        List<Integer> divs = new LinkedList<Integer>();\n        if(n == 1) return divs;\n        divs.add(1);\n        for(int x = 2; x < n; x++){\n            if(n % x == 0) divs.add(x);\n        }\n        \n        Collections.sort(divs);\n        \n        return divs;\n    }\n    \n    public static void main(String[] args){\n        for(int x = 1; x <= 10; x++){\n            System.out.println(x + \": \" + properDivs(x));\n        }\n        \n        int x = 0, count = 0;\n        for(int n = 1; n <= 20000; n++){\n            if(properDivs(n).size() > count){\n                x = n;\n                count = properDivs(n).size();\n            }\n        }\n        System.out.println(x + \": \" + count);\n    }\n}\n"}
{"id": 157502, "name": "Proper divisors", "source": "Translate Swift to Python: func properDivs1(n: Int) -> [Int] {\n\n    return filter (1 ..< n) { n % $0 == 0 }\n}\n", "target": ">>> def proper_divs2(n):\n...     return {x for x in range(1, (n + 1) // 2 + 1) if n % x == 0 and n != x}\n... \n>>> [proper_divs2(n) for n in range(1, 11)]\n[set(), {1}, {1}, {1, 2}, {1}, {1, 2, 3}, {1}, {1, 2, 4}, {1, 3}, {1, 2, 5}]\n>>> \n>>> n, length = max(((n, len(proper_divs2(n))) for n in range(1, 20001)), key=lambda pd: pd[1])\n>>> n\n15120\n>>> length\n79\n>>>\n"}
{"id": 157668, "name": "Define a primitive data type", "source": "Translate Swift to C#: struct SmallInt {\n  var value: Int\n\n  init(value: Int) {\n    guard value >= 1 && value <= 10 else {\n      fatalError(\"SmallInts must be in the range [1, 10]\")\n    }\n\n    self.value = value\n  }\n\n  static func +(_ lhs: SmallInt, _ rhs: SmallInt) -> SmallInt { SmallInt(value: lhs.value + rhs.value) }\n  static func -(_ lhs: SmallInt, _ rhs: SmallInt) -> SmallInt { SmallInt(value: lhs.value - rhs.value) }\n  static func *(_ lhs: SmallInt, _ rhs: SmallInt) -> SmallInt { SmallInt(value: lhs.value * rhs.value) }\n  static func /(_ lhs: SmallInt, _ rhs: SmallInt) -> SmallInt { SmallInt(value: lhs.value / rhs.value) }\n}\n\nextension SmallInt: ExpressibleByIntegerLiteral {\n  public init(integerLiteral value: Int) { self.init(value: value) }\n}\n\nextension SmallInt: CustomStringConvertible {\n  public var description: String { \"\\(value)\" }\n}\n\nlet a: SmallInt = 1\nlet b: SmallInt = 9\nlet c: SmallInt = 10\nlet d: SmallInt = 2\n\nprint(a + b)\nprint(c - b)\nprint(a * c)\nprint(c / d)\nprint(a + c)\n", "target": "using System;\nusing System.Globalization;\n\nstruct LimitedInt : IComparable, IComparable<LimitedInt>, IConvertible, IEquatable<LimitedInt>, IFormattable\n{\n    const int MIN_VALUE = 1;\n    const int MAX_VALUE = 10;\n\n    public static readonly LimitedInt MinValue = new LimitedInt(MIN_VALUE);\n    public static readonly LimitedInt MaxValue = new LimitedInt(MAX_VALUE);\n\n    static bool IsValidValue(int value) => value >= MIN_VALUE && value <= MAX_VALUE;\n\n    readonly int _value;\n    public int Value => this._value == 0 ? MIN_VALUE : this._value; \n\n    public LimitedInt(int value)\n    {\n        if (!IsValidValue(value))\n            throw new ArgumentOutOfRangeException(nameof(value), value, $\"Value must be between {MIN_VALUE} and {MAX_VALUE}.\");\n        this._value = value;\n    }\n\n    #region IComparable\n    public int CompareTo(object obj)\n    {\n        if (obj is LimitedInt l) return this.Value.CompareTo(l);\n        throw new ArgumentException(\"Object must be of type \" + nameof(LimitedInt), nameof(obj));\n    }\n    #endregion\n\n    #region IComparable<LimitedInt>\n    public int CompareTo(LimitedInt other) => this.Value.CompareTo(other.Value);\n    #endregion\n\n    #region IConvertible\n    public TypeCode GetTypeCode() => this.Value.GetTypeCode();\n    bool IConvertible.ToBoolean(IFormatProvider provider) => ((IConvertible)this.Value).ToBoolean(provider);\n    byte IConvertible.ToByte(IFormatProvider provider) => ((IConvertible)this.Value).ToByte(provider);\n    char IConvertible.ToChar(IFormatProvider provider) => ((IConvertible)this.Value).ToChar(provider);\n    DateTime IConvertible.ToDateTime(IFormatProvider provider) => ((IConvertible)this.Value).ToDateTime(provider);\n    decimal IConvertible.ToDecimal(IFormatProvider provider) => ((IConvertible)this.Value).ToDecimal(provider);\n    double IConvertible.ToDouble(IFormatProvider provider) => ((IConvertible)this.Value).ToDouble(provider);\n    short IConvertible.ToInt16(IFormatProvider provider) => ((IConvertible)this.Value).ToInt16(provider);\n    int IConvertible.ToInt32(IFormatProvider provider) => ((IConvertible)this.Value).ToInt32(provider);\n    long IConvertible.ToInt64(IFormatProvider provider) => ((IConvertible)this.Value).ToInt64(provider);\n    sbyte IConvertible.ToSByte(IFormatProvider provider) => ((IConvertible)this.Value).ToSByte(provider);\n    float IConvertible.ToSingle(IFormatProvider provider) => ((IConvertible)this.Value).ToSingle(provider);\n    string IConvertible.ToString(IFormatProvider provider) => this.Value.ToString(provider);\n    object IConvertible.ToType(Type conversionType, IFormatProvider provider) => ((IConvertible)this.Value).ToType(conversionType, provider);\n    ushort IConvertible.ToUInt16(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt16(provider);\n    uint IConvertible.ToUInt32(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt32(provider);\n    ulong IConvertible.ToUInt64(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt64(provider);\n    #endregion\n\n    #region IEquatable<LimitedInt>\n    public bool Equals(LimitedInt other) => this == other;\n    #endregion\n\n    #region IFormattable\n    public string ToString(string format, IFormatProvider formatProvider) => this.Value.ToString(format, formatProvider);\n    #endregion\n\n    #region operators\n    public static bool operator ==(LimitedInt left, LimitedInt right) => left.Value == right.Value;\n    public static bool operator !=(LimitedInt left, LimitedInt right) => left.Value != right.Value;\n    public static bool operator <(LimitedInt left, LimitedInt right) => left.Value < right.Value;\n    public static bool operator >(LimitedInt left, LimitedInt right) => left.Value > right.Value;\n    public static bool operator <=(LimitedInt left, LimitedInt right) => left.Value <= right.Value;\n    public static bool operator >=(LimitedInt left, LimitedInt right) => left.Value >= right.Value;\n\n    public static LimitedInt operator ++(LimitedInt left) => (LimitedInt)(left.Value + 1);\n    public static LimitedInt operator --(LimitedInt left) => (LimitedInt)(left.Value - 1);\n\n    public static LimitedInt operator +(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value + right.Value);\n    public static LimitedInt operator -(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value - right.Value);\n    public static LimitedInt operator *(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value * right.Value);\n    public static LimitedInt operator /(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value / right.Value);\n    public static LimitedInt operator %(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value % right.Value);\n\n    public static LimitedInt operator &(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value & right.Value);\n    public static LimitedInt operator |(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value | right.Value);\n    public static LimitedInt operator ^(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value ^ right.Value);\n    public static LimitedInt operator ~(LimitedInt left) => (LimitedInt)~left.Value;\n\n    public static LimitedInt operator >>(LimitedInt left, int right) => (LimitedInt)(left.Value >> right);\n    public static LimitedInt operator <<(LimitedInt left, int right) => (LimitedInt)(left.Value << right);\n\n    public static implicit operator int(LimitedInt value) => value.Value;\n    public static explicit operator LimitedInt(int value)\n    {\n        if (!IsValidValue(value)) throw new OverflowException();\n        return new LimitedInt(value);\n    }\n    #endregion\n\n    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default, IFormatProvider provider = null)\n        => this.Value.TryFormat(destination, out charsWritten, format, provider);\n\n    public override int GetHashCode() => this.Value.GetHashCode();\n    public override bool Equals(object obj) => obj is LimitedInt l && this.Equals(l);\n    public override string ToString() => this.Value.ToString();\n\n    #region static methods\n    public static bool TryParse(ReadOnlySpan<char> s, out int result) => int.TryParse(s, out result);\n    public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out int result) => int.TryParse(s, style, provider, out result);\n    public static int Parse(string s, IFormatProvider provider) => int.Parse(s, provider);\n    public static int Parse(string s, NumberStyles style, IFormatProvider provider) => int.Parse(s, style, provider);\n    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, ref int result) => int.TryParse(s, style, provider, out result);\n    public static int Parse(string s) => int.Parse(s);\n    public static int Parse(string s, NumberStyles style) => int.Parse(s, style);\n    public static int Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.Integer, IFormatProvider provider = null) => int.Parse(s, style, provider);\n    public static bool TryParse(string s, ref int result) => int.TryParse(s, out result);\n    #endregion\n}\n"}
{"id": 157670, "name": "Define a primitive data type", "source": "Translate Swift to Java: struct SmallInt {\n  var value: Int\n\n  init(value: Int) {\n    guard value >= 1 && value <= 10 else {\n      fatalError(\"SmallInts must be in the range [1, 10]\")\n    }\n\n    self.value = value\n  }\n\n  static func +(_ lhs: SmallInt, _ rhs: SmallInt) -> SmallInt { SmallInt(value: lhs.value + rhs.value) }\n  static func -(_ lhs: SmallInt, _ rhs: SmallInt) -> SmallInt { SmallInt(value: lhs.value - rhs.value) }\n  static func *(_ lhs: SmallInt, _ rhs: SmallInt) -> SmallInt { SmallInt(value: lhs.value * rhs.value) }\n  static func /(_ lhs: SmallInt, _ rhs: SmallInt) -> SmallInt { SmallInt(value: lhs.value / rhs.value) }\n}\n\nextension SmallInt: ExpressibleByIntegerLiteral {\n  public init(integerLiteral value: Int) { self.init(value: value) }\n}\n\nextension SmallInt: CustomStringConvertible {\n  public var description: String { \"\\(value)\" }\n}\n\nlet a: SmallInt = 1\nlet b: SmallInt = 9\nlet c: SmallInt = 10\nlet d: SmallInt = 2\n\nprint(a + b)\nprint(c - b)\nprint(a * c)\nprint(c / d)\nprint(a + c)\n", "target": "class BoundedIntOutOfBoundsException extends Exception\n{\n  public BoundedIntOutOfBoundsException(int v, int l, int u) {\n    super(\"value \" + v + \" is out of bounds [\" + l + \",\" + u + \"]\");\n  }\n}\n\nclass BoundedInt {\n  private int value;\n  private int lower;\n  private int upper;\n\n  public BoundedInt(int l, int u) {\n    lower = Math.min(l, u);\n    upper = Math.max(l, u);\n  }\n\n  private boolean checkBounds(int v) {\n    return (v >= this.lower) && (v <= this.upper);\n  }\n\n  public void assign(BoundedInt i) throws BoundedIntOutOfBoundsException {{\n    assign(i.value()); \n  }\n\n  public void assign(int v) throws BoundedIntOutOfBoundsException {\n    if ( checkBounds(v) ) {\n      this.value = v;\n    } else {\n      throw new BoundedIntOutOfBoundsException(v, this.lower, this.upper);\n    }\n  }\n\n  public int add(BoundedInt i) throws BoundedIntOutOfBoundsException {\n    return add(i.value());\n  }\n\n  public int add(int i) throws BoundedIntOutOfBoundsException {\n    if ( checkBounds(this.value + i) ) {\n      this.value += i;\n    }  else {\n      throw new BoundedIntOutOfBoundsException(this.value + i, this.lower, this.upper);\n    }\n    return this.value;\n  }\n\n  public int value() {\n    return this.value;\n  }\n}\n\n\npublic class Bounded {\n  public static void main(String[] args) throws BoundedIntOutOfBoundsException {\n    BoundedInt a = new BoundedInt(1, 10);\n    BoundedInt b = new BoundedInt(1, 10);\n\n    a.assign(6);\n    try {\n      b.assign(12);\n    } catch (Exception e) {\n      System.out.println(e.getMessage());\n    }\n    b.assign(9);\n    try {\n      a.add(b.value());\n    } catch (Exception e) {\n      System.out.println(e.getMessage());\n    }\n  }\n}\n"}
{"id": 157671, "name": "Define a primitive data type", "source": "Translate Swift to Python: struct SmallInt {\n  var value: Int\n\n  init(value: Int) {\n    guard value >= 1 && value <= 10 else {\n      fatalError(\"SmallInts must be in the range [1, 10]\")\n    }\n\n    self.value = value\n  }\n\n  static func +(_ lhs: SmallInt, _ rhs: SmallInt) -> SmallInt { SmallInt(value: lhs.value + rhs.value) }\n  static func -(_ lhs: SmallInt, _ rhs: SmallInt) -> SmallInt { SmallInt(value: lhs.value - rhs.value) }\n  static func *(_ lhs: SmallInt, _ rhs: SmallInt) -> SmallInt { SmallInt(value: lhs.value * rhs.value) }\n  static func /(_ lhs: SmallInt, _ rhs: SmallInt) -> SmallInt { SmallInt(value: lhs.value / rhs.value) }\n}\n\nextension SmallInt: ExpressibleByIntegerLiteral {\n  public init(integerLiteral value: Int) { self.init(value: value) }\n}\n\nextension SmallInt: CustomStringConvertible {\n  public var description: String { \"\\(value)\" }\n}\n\nlet a: SmallInt = 1\nlet b: SmallInt = 9\nlet c: SmallInt = 10\nlet d: SmallInt = 2\n\nprint(a + b)\nprint(c - b)\nprint(a * c)\nprint(c / d)\nprint(a + c)\n", "target": ">>> class num(int):\n    def __init__(self, b):\n        if 1 <= b <= 10:\n            return int.__init__(self+0)\n        else:\n            raise ValueError,\"Value %s should be >=0 and <= 10\" % b\n\n        \n>>> x = num(3)\n>>> x = num(11)\n\nTraceback (most recent call last):\n  File \"<pyshell\n    x = num(11)\n  File \"<pyshell\n    raise ValueError,\"Value %s should be >=0 and <= 10\" % b\nValueError: Value 11 should be >=0 and <= 10\n>>> x\n3\n>>> type(x)\n<class '__main__.num'>\n>>>\n"}
{"id": 157792, "name": "Palindrome dates", "source": "Translate Swift to C#: import Foundation\n\nfunc isPalindrome(_ string: String) -> Bool {\n    let chars = string.lazy\n    return chars.elementsEqual(chars.reversed())\n}\n\nlet format = DateFormatter()\nformat.dateFormat = \"yyyyMMdd\"\n\nlet outputFormat = DateFormatter()\noutputFormat.dateFormat = \"yyyy-MM-dd\"\n\nvar count = 0\nlet limit = 15\nlet calendar = Calendar.current\nvar date = Date()\n\nwhile count < limit {\n    if isPalindrome(format.string(from: date)) {\n        print(outputFormat.string(from: date))\n        count += 1\n    }\n    date = calendar.date(byAdding: .day, value: 1, to: date)!\n}\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    static void Main()\n    {\n        foreach (var date in PalindromicDates(2021).Take(15)) WriteLine(date.ToString(\"yyyy-MM-dd\"));\n    }\n\n    public static IEnumerable<DateTime> PalindromicDates(int startYear) {\n        for (int y = startYear; ; y++) {\n            int m = Reverse(y % 100);\n            int d = Reverse(y / 100);\n            if (IsValidDate(y, m, d, out var date)) yield return date;\n        }\n\n        int Reverse(int x) => x % 10 * 10 + x / 10;\n        bool IsValidDate(int y, int m, int d, out DateTime date) => DateTime.TryParse($\"{y}-{m}-{d}\", out date);\n    }\n}\n"}
{"id": 157794, "name": "Palindrome dates", "source": "Translate Swift to Java: import Foundation\n\nfunc isPalindrome(_ string: String) -> Bool {\n    let chars = string.lazy\n    return chars.elementsEqual(chars.reversed())\n}\n\nlet format = DateFormatter()\nformat.dateFormat = \"yyyyMMdd\"\n\nlet outputFormat = DateFormatter()\noutputFormat.dateFormat = \"yyyy-MM-dd\"\n\nvar count = 0\nlet limit = 15\nlet calendar = Calendar.current\nvar date = Date()\n\nwhile count < limit {\n    if isPalindrome(format.string(from: date)) {\n        print(outputFormat.string(from: date))\n        count += 1\n    }\n    date = calendar.date(byAdding: .day, value: 1, to: date)!\n}\n", "target": "import java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\n\npublic class PalindromeDates {\n\n    public static void main(String[] args) {\n        LocalDate date = LocalDate.of(2020, 2, 3);\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyyMMdd\");\n        DateTimeFormatter formatterDash = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n        System.out.printf(\"First 15 palindrome dates after 2020-02-02 are:%n\");\n        for ( int count = 0 ; count < 15 ; date = date.plusDays(1) ) {\n            String dateFormatted = date.format(formatter);\n            if ( dateFormatted.compareTo(new StringBuilder(dateFormatted).reverse().toString()) == 0 ) {\n                count++;\n                System.out.printf(\"date = %s%n\", date.format(formatterDash));\n            }\n        }\n    }\n\n}\n"}
{"id": 157795, "name": "Palindrome dates", "source": "Translate Swift to Python: import Foundation\n\nfunc isPalindrome(_ string: String) -> Bool {\n    let chars = string.lazy\n    return chars.elementsEqual(chars.reversed())\n}\n\nlet format = DateFormatter()\nformat.dateFormat = \"yyyyMMdd\"\n\nlet outputFormat = DateFormatter()\noutputFormat.dateFormat = \"yyyy-MM-dd\"\n\nvar count = 0\nlet limit = 15\nlet calendar = Calendar.current\nvar date = Date()\n\nwhile count < limit {\n    if isPalindrome(format.string(from: date)) {\n        print(outputFormat.string(from: date))\n        count += 1\n    }\n    date = calendar.date(byAdding: .day, value: 1, to: date)!\n}\n", "target": "\n\nfrom datetime import datetime\nfrom itertools import chain\n\n\n\ndef palinDay(y):\n    \n    s = str(y)\n    r = s[::-1]\n    iso = '-'.join([s, r[0:2], r[2:]])\n    try:\n        datetime.strptime(iso, '%Y-%m-%d')\n        return [iso]\n    except ValueError:\n        return []\n\n\n\n\ndef main():\n    \n    palinDates = list(chain.from_iterable(\n        map(palinDay, range(2021, 10000))\n    ))\n    for x in [\n            'Count of palindromic dates [2021..9999]:',\n            len(palinDates),\n            '\\nFirst 15:',\n            '\\n'.join(palinDates[0:15]),\n            '\\nLast 15:',\n            '\\n'.join(palinDates[-15:])\n    ]:\n        print(x)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 158064, "name": "Phrase reversals", "source": "Translate Swift to C#: func reverseString(s:String)->String{\n    var temp = [Character]()\n    for i in s.characters{\n        temp.append(i)\n    }\n    var j=s.characters.count-1\n    for i in s.characters{\n        temp[j]=i\n        j-=1\n    }\n    return String(temp)\n} \n\nfunc reverseWord(s:String)->String{\n    var temp = [Character]()\n    var result:String=\"\"\n    for i in s.characters{\n        if i==\" \"{\n            result += \"\\(reverseString(s:String(temp))) \"\n            temp=[Character]()\n        }\n        else {\n            temp.append(i)\n        }\n        if i==s[s.index(before: s.endIndex)]{\n            result += (reverseString(s:String(temp)))\n        }\n    }\n    return result\n}\n\nfunc flipString(s:String)->String{\n    return reverseWord(s:reverseString(s:s))\n}\nprint(str)\nprint(reverseString(s:str))\nprint(reverseWord(s:str))\nprint(flipString(s:str))\n", "target": "using System;\nusing System.Linq;\nnamespace ConsoleApplication\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            \n            Func<string, string> reverse = s => new string(s.Reverse().ToArray());\n\n            string phrase = \"rosetta code phrase reversal\";\n            \n            Console.WriteLine(reverse(phrase));\n            \n            Console.WriteLine(string.Join(\" \", phrase.Split(' ').Select(word => reverse(word))));\n            \n            Console.WriteLine(string.Join(\" \", phrase.Split(' ').Reverse()));\n        }\n    }\n}\n"}
{"id": 158066, "name": "Phrase reversals", "source": "Translate Swift to Java: func reverseString(s:String)->String{\n    var temp = [Character]()\n    for i in s.characters{\n        temp.append(i)\n    }\n    var j=s.characters.count-1\n    for i in s.characters{\n        temp[j]=i\n        j-=1\n    }\n    return String(temp)\n} \n\nfunc reverseWord(s:String)->String{\n    var temp = [Character]()\n    var result:String=\"\"\n    for i in s.characters{\n        if i==\" \"{\n            result += \"\\(reverseString(s:String(temp))) \"\n            temp=[Character]()\n        }\n        else {\n            temp.append(i)\n        }\n        if i==s[s.index(before: s.endIndex)]{\n            result += (reverseString(s:String(temp)))\n        }\n    }\n    return result\n}\n\nfunc flipString(s:String)->String{\n    return reverseWord(s:reverseString(s:s))\n}\nprint(str)\nprint(reverseString(s:str))\nprint(reverseWord(s:str))\nprint(flipString(s:str))\n", "target": "import java.util.Arrays;\n\npublic class PhraseRev{\n\tprivate static String reverse(String x){\n\t\treturn new StringBuilder(x).reverse().toString();\n\t}\n\t\n\tprivate static <T> T[] reverse(T[] x){\n\t\tT[] rev = Arrays.copyOf(x, x.length);\n\t\tfor(int i = x.length - 1; i >= 0; i--){\n\t\t\trev[x.length - 1 - i] = x[i];\n\t\t}\n\t\treturn rev;\n\t}\n\t\n\tprivate static String join(String[] arr, String joinStr){\n\t\tStringBuilder joined = new StringBuilder();\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tjoined.append(arr[i]);\n\t\t\tif(i < arr.length - 1) joined.append(joinStr);\n\t\t}\n\t\treturn joined.toString();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tString str = \"rosetta code phrase reversal\";\n\t\t\n\t\tSystem.out.println(\"Straight-up reversed: \" + reverse(str));\n\t\tString[] words = str.split(\" \");\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\twords[i] = reverse(words[i]);\n\t\t}\n\t\tSystem.out.println(\"Reversed words: \" + join(words, \" \"));\n\t\tSystem.out.println(\"Reversed word order: \" + join(reverse(str.split(\" \")), \" \"));\n\t}\n}\n"}
{"id": 158067, "name": "Phrase reversals", "source": "Translate Swift to Python: func reverseString(s:String)->String{\n    var temp = [Character]()\n    for i in s.characters{\n        temp.append(i)\n    }\n    var j=s.characters.count-1\n    for i in s.characters{\n        temp[j]=i\n        j-=1\n    }\n    return String(temp)\n} \n\nfunc reverseWord(s:String)->String{\n    var temp = [Character]()\n    var result:String=\"\"\n    for i in s.characters{\n        if i==\" \"{\n            result += \"\\(reverseString(s:String(temp))) \"\n            temp=[Character]()\n        }\n        else {\n            temp.append(i)\n        }\n        if i==s[s.index(before: s.endIndex)]{\n            result += (reverseString(s:String(temp)))\n        }\n    }\n    return result\n}\n\nfunc flipString(s:String)->String{\n    return reverseWord(s:reverseString(s:s))\n}\nprint(str)\nprint(reverseString(s:str))\nprint(reverseWord(s:str))\nprint(flipString(s:str))\n", "target": ">>> phrase = \"rosetta code phrase reversal\"\n>>> phrase[::-1]\t\t\t\t\t  \n'lasrever esarhp edoc attesor'\n>>> ' '.join(word[::-1] for word in phrase.split())\t  \n'attesor edoc esarhp lasrever'\n>>> ' '.join(phrase.split()[::-1])\t                  \n'reversal phrase code rosetta'\n>>>\n"}
{"id": 158580, "name": "Move-to-front algorithm", "source": "Translate Swift to C#: var str=\"broood\"\nvar number:[Int]=[1,17,15,0,0,5]\n\n\nfunc encode(st:String)->[Int]\n{\n\t\nvar array:[Character]=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n\t\n\tvar num:[Int]=[]\n\tvar temp:Character=\"a\"\n\tvar i1:Int=0\n\tfor i in st.characters\n\t{\n\t\tfor j in 0...25\n\t\t{\n\t\t\tif i==array[j]\n\t\t\t{\n\t\t\t\tnum.append(j)\n\t\t\t\ttemp=array[j]\n\t\t\t\ti1=j\n\t\t\t\twhile(i1>0)\n\t\t\t\t{\n\t\t\t\t\tarray[i1]=array[i1-1]\n\t\t\t\t\ti1=i1-1\n\t\t\n\t\t\t\t}\n\t\t\t\tarray[0]=temp\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\treturn num\n\t\n}\n\nfunc decode(s:[Int])->[Character]\n{\n\t\n\tvar st1:[Character]=[]\n\tvar alph:[Character]=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n\tvar temp1:Character=\"a\"\n\tvar i2:Int=0\n\tfor i in 0...s.character.count-1\n\t{\n\t\ti2=s[i]\n\t\tst1.append(alph[i2])\n\t\ttemp1=alph[i2]\n\t\t\t\n\t\t\t\twhile(i2>0)\n\t\t\t\t{\n\t\t\t\t\talph[i2]=alph[i2-1]\n\t\t\t\t\ti2=i2-1\n\t\t\n\t\t\t\t}\n\t\t\t\talph[0]=temp1\n\t\t\n\t}\n\treturn st1\t\t\t\t\t  \n\t\n}\n\nvar encarr:[Int]=encode(st:str)\nvar decarr:[Character]=decode(s:number)\nprint(encarr)\nprint(decarr)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace MoveToFront\n{\n    class Program\n    {\n        private static char[] symbolTable;\n        private static void setSymbolTable()\n        {\n            symbolTable = \"abcdefghijklmnopqrstuvwxyz\".ToCharArray();\n        }\n\n        private static void moveToFront(int charIndex)\n        {\n            char toFront = symbolTable[charIndex];\n            for (int j = charIndex; j > 0; j--)\n            {\n                symbolTable[j] = symbolTable[j - 1];\n            }\n            symbolTable[0] = toFront;\n        }\n\n        public static int[] Encode(string input)\n        {\n            setSymbolTable();\n            var output = new List<int>();\n            foreach (char c in input)\n            {\n                for (int i = 0; i < 26; i++)\n                {\n                    if (symbolTable[i] == c)\n                    {\n                        output.Add(i);\n                        moveToFront(i);\n                        break;\n                    }\n                }\n            }         \n            return output.ToArray();\n        }\n\n        public static string Decode(int[] input)\n        {\n            setSymbolTable();\n            var output = new StringBuilder(input.Length);\n            foreach (int n in input)\n            {\n                output.Append(symbolTable[n]);\n                moveToFront(n);\n            }\n            return output.ToString();\n        }\n\n        static void Main(string[] args)\n        {\n            string[] testInputs = new string[] { \"broood\", \"bananaaa\", \"hiphophiphop\" };\n            int[] encoding;\n            foreach (string s in testInputs) \n            {\n                Console.WriteLine($\"Encoding for '{s}':\");\n                encoding = Encode(s);\n                foreach (int i in encoding)\n                {\n                    Console.Write($\"{i} \");\n                }\n                Console.WriteLine($\"\\nDecoding for '{s}':\");\n                Console.WriteLine($\"{Decode(encoding)}\\n\");\n            }\n        }\n    }\n}\n"}
{"id": 158582, "name": "Move-to-front algorithm", "source": "Translate Swift to Java: var str=\"broood\"\nvar number:[Int]=[1,17,15,0,0,5]\n\n\nfunc encode(st:String)->[Int]\n{\n\t\nvar array:[Character]=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n\t\n\tvar num:[Int]=[]\n\tvar temp:Character=\"a\"\n\tvar i1:Int=0\n\tfor i in st.characters\n\t{\n\t\tfor j in 0...25\n\t\t{\n\t\t\tif i==array[j]\n\t\t\t{\n\t\t\t\tnum.append(j)\n\t\t\t\ttemp=array[j]\n\t\t\t\ti1=j\n\t\t\t\twhile(i1>0)\n\t\t\t\t{\n\t\t\t\t\tarray[i1]=array[i1-1]\n\t\t\t\t\ti1=i1-1\n\t\t\n\t\t\t\t}\n\t\t\t\tarray[0]=temp\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\treturn num\n\t\n}\n\nfunc decode(s:[Int])->[Character]\n{\n\t\n\tvar st1:[Character]=[]\n\tvar alph:[Character]=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n\tvar temp1:Character=\"a\"\n\tvar i2:Int=0\n\tfor i in 0...s.character.count-1\n\t{\n\t\ti2=s[i]\n\t\tst1.append(alph[i2])\n\t\ttemp1=alph[i2]\n\t\t\t\n\t\t\t\twhile(i2>0)\n\t\t\t\t{\n\t\t\t\t\talph[i2]=alph[i2-1]\n\t\t\t\t\ti2=i2-1\n\t\t\n\t\t\t\t}\n\t\t\t\talph[0]=temp1\n\t\t\n\t}\n\treturn st1\t\t\t\t\t  \n\t\n}\n\nvar encarr:[Int]=encode(st:str)\nvar decarr:[Character]=decode(s:number)\nprint(encarr)\nprint(decarr)\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\npublic class MTF{\n\tpublic static List<Integer> encode(String msg, String symTable){\n\t\tList<Integer> output = new LinkedList<Integer>();\n\t\tStringBuilder s = new StringBuilder(symTable);\n\t\tfor(char c : msg.toCharArray()){\n\t\t\tint idx = s.indexOf(\"\" + c);\n\t\t\toutput.add(idx);\n\t\t\ts = s.deleteCharAt(idx).insert(0, c);\n\t\t}\n\t\treturn output;\n\t}\n\t\n\tpublic static String decode(List<Integer> idxs, String symTable){\n\t\tStringBuilder output = new StringBuilder();\n\t\tStringBuilder s = new StringBuilder(symTable);\n\t\tfor(int idx : idxs){\n\t\t\tchar c = s.charAt(idx);\n\t\t\toutput = output.append(c);\n\t\t\ts = s.deleteCharAt(idx).insert(0, c);\n\t\t}\n\t\treturn output.toString();\n\t}\n\t\n\tprivate static void test(String toEncode, String symTable){\n\t\tList<Integer> encoded = encode(toEncode, symTable);\n\t\tSystem.out.println(toEncode + \": \" + encoded);\n\t\tString decoded = decode(encoded, symTable);\n\t\tSystem.out.println((toEncode.equals(decoded) ? \"\" : \"in\") + \"correctly decoded to \" + decoded);\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tString symTable = \"abcdefghijklmnopqrstuvwxyz\";\n\t\ttest(\"broood\", symTable);\n\t\ttest(\"bananaaa\", symTable);\n\t\ttest(\"hiphophiphop\", symTable);\n\t}\n}\n"}
{"id": 158583, "name": "Move-to-front algorithm", "source": "Translate Swift to Python: var str=\"broood\"\nvar number:[Int]=[1,17,15,0,0,5]\n\n\nfunc encode(st:String)->[Int]\n{\n\t\nvar array:[Character]=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n\t\n\tvar num:[Int]=[]\n\tvar temp:Character=\"a\"\n\tvar i1:Int=0\n\tfor i in st.characters\n\t{\n\t\tfor j in 0...25\n\t\t{\n\t\t\tif i==array[j]\n\t\t\t{\n\t\t\t\tnum.append(j)\n\t\t\t\ttemp=array[j]\n\t\t\t\ti1=j\n\t\t\t\twhile(i1>0)\n\t\t\t\t{\n\t\t\t\t\tarray[i1]=array[i1-1]\n\t\t\t\t\ti1=i1-1\n\t\t\n\t\t\t\t}\n\t\t\t\tarray[0]=temp\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\treturn num\n\t\n}\n\nfunc decode(s:[Int])->[Character]\n{\n\t\n\tvar st1:[Character]=[]\n\tvar alph:[Character]=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n\tvar temp1:Character=\"a\"\n\tvar i2:Int=0\n\tfor i in 0...s.character.count-1\n\t{\n\t\ti2=s[i]\n\t\tst1.append(alph[i2])\n\t\ttemp1=alph[i2]\n\t\t\t\n\t\t\t\twhile(i2>0)\n\t\t\t\t{\n\t\t\t\t\talph[i2]=alph[i2-1]\n\t\t\t\t\ti2=i2-1\n\t\t\n\t\t\t\t}\n\t\t\t\talph[0]=temp1\n\t\t\n\t}\n\treturn st1\t\t\t\t\t  \n\t\n}\n\nvar encarr:[Int]=encode(st:str)\nvar decarr:[Character]=decode(s:number)\nprint(encarr)\nprint(decarr)\n", "target": "from __future__ import print_function\nfrom string import ascii_lowercase\n\nSYMBOLTABLE = list(ascii_lowercase)\n\ndef move2front_encode(strng, symboltable):\n    sequence, pad = [], symboltable[::]\n    for char in strng:\n        indx = pad.index(char)\n        sequence.append(indx)\n        pad = [pad.pop(indx)] + pad\n    return sequence\n\ndef move2front_decode(sequence, symboltable):\n    chars, pad = [], symboltable[::]\n    for indx in sequence:\n        char = pad[indx]\n        chars.append(char)\n        pad = [pad.pop(indx)] + pad\n    return ''.join(chars)\n\nif __name__ == '__main__':\n    for s in ['broood', 'bananaaa', 'hiphophiphop']:\n        encode = move2front_encode(s, SYMBOLTABLE)\n        print('%14r encodes to %r' % (s, encode), end=', ')\n        decode = move2front_decode(encode, SYMBOLTABLE)\n        print('which decodes back to %r' % decode)\n        assert s == decode, 'Whoops!'\n"}
{"id": 158772, "name": "Get system command output", "source": "Translate Swift to C#: import Foundation\n\nlet process = Process()\n\nprocess.launchPath = \"/usr/bin/env\"\nprocess.arguments = [\"pwd\"]\n\nlet pipe = Pipe()\nprocess.standardOutput = pipe\n\nprocess.launch()\n\nlet data = pipe.fileHandleForReading.readDataToEndOfFile()\nlet output = String.init(data: data, encoding: String.Encoding.utf8)\n\nprint(output!)\n", "target": "using System;\n\nnamespace GetSystemCommandOutput {\n    class Program {\n        static void Main(string[] args) {\n            System.Diagnostics.Process process = new System.Diagnostics.Process();\n            System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo();\n            startInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;\n            startInfo.FileName = \"cmd.exe\";\n            startInfo.Arguments = \"/c echo Hello World\";\n            startInfo.RedirectStandardOutput = true;\n            startInfo.UseShellExecute = false;\n            process.StartInfo = startInfo;\n            process.Start();\n\n            string output = process.StandardOutput.ReadToEnd();\n            Console.WriteLine(\"Output is {0}\", output);\n        }\n    }\n}\n"}
{"id": 158774, "name": "Get system command output", "source": "Translate Swift to Java: import Foundation\n\nlet process = Process()\n\nprocess.launchPath = \"/usr/bin/env\"\nprocess.arguments = [\"pwd\"]\n\nlet pipe = Pipe()\nprocess.standardOutput = pipe\n\nprocess.launch()\n\nlet data = pipe.fileHandleForReading.readDataToEndOfFile()\nlet output = String.init(data: data, encoding: String.Encoding.utf8)\n\nprint(output!)\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class SystemCommand {\n\n    public static void main(String args[]) throws IOException {\n\n        String command = \"cmd /c dir\";\n        Process p = Runtime.getRuntime().exec(command);\n\n        try (Scanner sc = new Scanner(p.getInputStream())) {\n\n            System.out.printf(\"Output of the command: %s %n%n\", command);\n            while (sc.hasNext()) {\n                System.out.println(sc.nextLine());\n            }\n        }\n    }\n}\n"}
{"id": 158775, "name": "Get system command output", "source": "Translate Swift to Python: import Foundation\n\nlet process = Process()\n\nprocess.launchPath = \"/usr/bin/env\"\nprocess.arguments = [\"pwd\"]\n\nlet pipe = Pipe()\nprocess.standardOutput = pipe\n\nprocess.launch()\n\nlet data = pipe.fileHandleForReading.readDataToEndOfFile()\nlet output = String.init(data: data, encoding: String.Encoding.utf8)\n\nprint(output!)\n", "target": ">>> import subprocess\n>>> returned_text = subprocess.check_output(\"dir\", shell=True, universal_newlines=True)\n>>> type(returned_text)\n<class 'str'>\n>>> print(returned_text)\n Volume in drive C is Windows\n Volume Serial Number is 44X7-73CE\n\n Directory of C:\\Python33\n\n04/07/2013  06:40    <DIR>          .\n04/07/2013  06:40    <DIR>          ..\n27/05/2013  07:10    <DIR>          DLLs\n27/05/2013  07:10    <DIR>          Doc\n27/05/2013  07:10    <DIR>          include\n27/05/2013  07:10    <DIR>          Lib\n27/05/2013  07:10    <DIR>          libs\n16/05/2013  00:15            33,326 LICENSE.txt\n15/05/2013  22:49           214,554 NEWS.txt\n16/05/2013  00:03            26,624 python.exe\n16/05/2013  00:03            27,136 pythonw.exe\n15/05/2013  22:49             6,701 README.txt\n27/05/2013  07:10    <DIR>          tcl\n27/05/2013  07:10    <DIR>          Tools\n16/05/2013  00:02            43,008 w9xpopen.exe\n               6 File(s)        351,349 bytes\n               9 Dir(s)  46,326,947,840 bytes free\n\n>>> \n"}
{"id": 158926, "name": "Integer overflow", "source": "Translate Swift to C#: \n\n\nvar int32:Int32\nvar int64:Int64\nvar uInt32:UInt32\nvar uInt64:UInt64\n\nprintln(\"signed 32-bit int:\")\nint32 = -1 &* (-2147483647 - 1)\nprintln(int32)\nint32 = 2000000000 &+ 2000000000\nprintln(int32)\nint32 = -2147483647 &- 2147483647\nprintln(int32)\nint32 = 46341 &* 46341\nprintln(int32)\nint32 = (-2147483647-1) &/ -1\nprintln(int32)\nprintln()\n\nprintln(\"signed 64-bit int:\")\nint64 = -1 &* (-9223372036854775807 - 1)\nprintln(int64)\nint64 = 5000000000000000000&+5000000000000000000\nprintln(int64)\nint64 = -9223372036854775807 &- 9223372036854775807\nprintln(int64)\nint64 = 3037000500 &* 3037000500\nprintln(int64)\nint64 = (-9223372036854775807-1) &/ -1\nprintln(int64)\nprintln()\n\nprintln(\"unsigned 32-bit int:\")\nprintln(\"-4294967295 is caught as a compile time error\")\nuInt32 = 3000000000 &+ 3000000000\nprintln(uInt32)\nuInt32 = 2147483647 &- 4294967295\nprintln(uInt32)\nuInt32 = 65537 &* 65537\nprintln(uInt32)\nprintln()\n\nprintln(\"unsigned 64-bit int:\")\nprintln(\"-18446744073709551615 is caught as a compile time error\")\nuInt64 = 10000000000000000000 &+ 10000000000000000000\nprintln(uInt64)\nuInt64 = 9223372036854775807 &- 18446744073709551615\nprintln(uInt64)\nuInt64 = 4294967296 &* 4294967296\nprintln(uInt64)\n", "target": "using System;\n    \npublic class IntegerOverflow\n{\n    public static void Main() {\n        unchecked {\n            Console.WriteLine(\"For 32-bit signed integers:\");\n            Console.WriteLine(-(-2147483647 - 1));\n            Console.WriteLine(2000000000 + 2000000000);\n            Console.WriteLine(-2147483647 - 2147483647);\n            Console.WriteLine(46341 * 46341);\n            Console.WriteLine((-2147483647 - 1) / -1);\n            Console.WriteLine();\n            \n            Console.WriteLine(\"For 64-bit signed integers:\");\n            Console.WriteLine(-(-9223372036854775807L - 1));\n            Console.WriteLine(5000000000000000000L + 5000000000000000000L);\n            Console.WriteLine(-9223372036854775807L - 9223372036854775807L);\n            Console.WriteLine(3037000500L * 3037000500L);\n            Console.WriteLine((-9223372036854775807L - 1) / -1);\n            Console.WriteLine();\n\n            Console.WriteLine(\"For 32-bit unsigned integers:\");\n            \n            Console.WriteLine(-4294967295U);\n            Console.WriteLine(3000000000U + 3000000000U);\n            Console.WriteLine(2147483647U - 4294967295U);\n            Console.WriteLine(65537U * 65537U);\n            Console.WriteLine();\n\n            Console.WriteLine(\"For 64-bit unsigned integers:\");\n            \n            \n            Console.WriteLine(10000000000000000000UL + 10000000000000000000UL);\n            Console.WriteLine(9223372036854775807UL - 18446744073709551615UL);\n            Console.WriteLine(4294967296UL * 4294967296UL);\n            Console.WriteLine();\n        }\n        \n        int i = 2147483647;\n        Console.WriteLine(i + 1);\n        try {\n            checked { Console.WriteLine(i + 1); }\n        } catch (OverflowException) {\n            Console.WriteLine(\"Overflow!\");\n        }\n    }\n    \n}\n"}
{"id": 158928, "name": "Integer overflow", "source": "Translate Swift to Java: \n\n\nvar int32:Int32\nvar int64:Int64\nvar uInt32:UInt32\nvar uInt64:UInt64\n\nprintln(\"signed 32-bit int:\")\nint32 = -1 &* (-2147483647 - 1)\nprintln(int32)\nint32 = 2000000000 &+ 2000000000\nprintln(int32)\nint32 = -2147483647 &- 2147483647\nprintln(int32)\nint32 = 46341 &* 46341\nprintln(int32)\nint32 = (-2147483647-1) &/ -1\nprintln(int32)\nprintln()\n\nprintln(\"signed 64-bit int:\")\nint64 = -1 &* (-9223372036854775807 - 1)\nprintln(int64)\nint64 = 5000000000000000000&+5000000000000000000\nprintln(int64)\nint64 = -9223372036854775807 &- 9223372036854775807\nprintln(int64)\nint64 = 3037000500 &* 3037000500\nprintln(int64)\nint64 = (-9223372036854775807-1) &/ -1\nprintln(int64)\nprintln()\n\nprintln(\"unsigned 32-bit int:\")\nprintln(\"-4294967295 is caught as a compile time error\")\nuInt32 = 3000000000 &+ 3000000000\nprintln(uInt32)\nuInt32 = 2147483647 &- 4294967295\nprintln(uInt32)\nuInt32 = 65537 &* 65537\nprintln(uInt32)\nprintln()\n\nprintln(\"unsigned 64-bit int:\")\nprintln(\"-18446744073709551615 is caught as a compile time error\")\nuInt64 = 10000000000000000000 &+ 10000000000000000000\nprintln(uInt64)\nuInt64 = 9223372036854775807 &- 18446744073709551615\nprintln(uInt64)\nuInt64 = 4294967296 &* 4294967296\nprintln(uInt64)\n", "target": "public class IntegerOverflow {\n    public static void main(String[] args) {\n        System.out.println(\"Signed 32-bit:\");\n        System.out.println(-(-2147483647 - 1));\n        System.out.println(2000000000 + 2000000000);\n        System.out.println(-2147483647 - 2147483647);\n        System.out.println(46341 * 46341);\n        System.out.println((-2147483647 - 1) / -1);\n        System.out.println(\"Signed 64-bit:\");\n        System.out.println(-(-9223372036854775807L - 1));\n        System.out.println(5000000000000000000L + 5000000000000000000L);\n        System.out.println(-9223372036854775807L - 9223372036854775807L);\n        System.out.println(3037000500L * 3037000500L);\n        System.out.println((-9223372036854775807L - 1) / -1);\n    }\n}\n"}
{"id": 158929, "name": "Integer overflow", "source": "Translate Swift to Python: \n\n\nvar int32:Int32\nvar int64:Int64\nvar uInt32:UInt32\nvar uInt64:UInt64\n\nprintln(\"signed 32-bit int:\")\nint32 = -1 &* (-2147483647 - 1)\nprintln(int32)\nint32 = 2000000000 &+ 2000000000\nprintln(int32)\nint32 = -2147483647 &- 2147483647\nprintln(int32)\nint32 = 46341 &* 46341\nprintln(int32)\nint32 = (-2147483647-1) &/ -1\nprintln(int32)\nprintln()\n\nprintln(\"signed 64-bit int:\")\nint64 = -1 &* (-9223372036854775807 - 1)\nprintln(int64)\nint64 = 5000000000000000000&+5000000000000000000\nprintln(int64)\nint64 = -9223372036854775807 &- 9223372036854775807\nprintln(int64)\nint64 = 3037000500 &* 3037000500\nprintln(int64)\nint64 = (-9223372036854775807-1) &/ -1\nprintln(int64)\nprintln()\n\nprintln(\"unsigned 32-bit int:\")\nprintln(\"-4294967295 is caught as a compile time error\")\nuInt32 = 3000000000 &+ 3000000000\nprintln(uInt32)\nuInt32 = 2147483647 &- 4294967295\nprintln(uInt32)\nuInt32 = 65537 &* 65537\nprintln(uInt32)\nprintln()\n\nprintln(\"unsigned 64-bit int:\")\nprintln(\"-18446744073709551615 is caught as a compile time error\")\nuInt64 = 10000000000000000000 &+ 10000000000000000000\nprintln(uInt64)\nuInt64 = 9223372036854775807 &- 18446744073709551615\nprintln(uInt64)\nuInt64 = 4294967296 &* 4294967296\nprintln(uInt64)\n", "target": "Python 2.7.5 (default, May 15 2013, 22:43:36) [MSC v.1500 32 bit (Intel)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> for calc in .split('\\n'):\n\tans = eval(calc)\n\tprint('Expression: %r evaluates to %s of type %s'\n\t      % (calc.strip(), ans, type(ans)))\n\n\t\nExpression: '-(-2147483647-1)' evaluates to 2147483648 of type <type 'long'>\nExpression: '2000000000 + 2000000000' evaluates to 4000000000 of type <type 'long'>\nExpression: '-2147483647 - 2147483647' evaluates to -4294967294 of type <type 'long'>\nExpression: '46341 * 46341' evaluates to 2147488281 of type <type 'long'>\nExpression: '(-2147483647-1) / -1' evaluates to 2147483648 of type <type 'long'>\n>>>\n"}
{"id": 159150, "name": "Semordnilap", "source": "Translate Swift to C#: guard let data = try? String(contentsOfFile: \"unixdict.txt\") else {\n  fatalError()\n}\n\nlet words = Set(data.components(separatedBy: \"\\n\"))\nlet pairs = words\n  .map({ ($0, String($0.reversed())) })\n  .filter({ $0.0 < $0.1 && words.contains($0.1) })\n\nprint(\"Found \\(pairs.count) pairs\")\nprint(\"Five examples: \\(pairs.prefix(5))\")\n", "target": "using System;\nusing System.Net;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n\npublic class Semordnilap\n{\n    public static void Main() {\n        var results = FindSemordnilaps(\"http:\n        Console.WriteLine(results.Count);\n        var random = new Random();\n        Console.WriteLine(\"5 random results:\");\n        foreach (string s in results.OrderBy(_ => random.Next()).Distinct().Take(5)) Console.WriteLine(s + \" \" + Reversed(s));\n    }\n    \n    private static IEnumerable<string> FindSemordnilaps(string url) {\n        var found = new HashSet<string>();\n        foreach (string line in GetLines(url)) {\n            string reversed = Reversed(line);\n            \n            if (line.CompareTo(reversed) != 0) {\n                if (found.Remove(reversed)) yield return reversed;\n                else found.Add(line);\n            }\n        }\n    }\n    \n    private static IEnumerable<string> GetLines(string url) {\n        WebRequest request = WebRequest.Create(url);\n        using (var reader = new StreamReader(request.GetResponse().GetResponseStream(), true)) {\n            while (!reader.EndOfStream) {\n                yield return reader.ReadLine();\n            }\n        }\n    }\n    \n    private static string Reversed(string value) => new string(value.Reverse().ToArray());\n}\n"}
{"id": 159152, "name": "Semordnilap", "source": "Translate Swift to Java: guard let data = try? String(contentsOfFile: \"unixdict.txt\") else {\n  fatalError()\n}\n\nlet words = Set(data.components(separatedBy: \"\\n\"))\nlet pairs = words\n  .map({ ($0, String($0.reversed())) })\n  .filter({ $0.0 < $0.1 && words.contains($0.1) })\n\nprint(\"Found \\(pairs.count) pairs\")\nprint(\"Five examples: \\(pairs.prefix(5))\")\n", "target": "import java.nio.file.*;\nimport java.util.*;\n\npublic class Semordnilap {\n\n    public static void main(String[] args) throws Exception {\n        List<String> lst = Files.readAllLines(Paths.get(\"unixdict.txt\"));\n        Set<String> seen = new HashSet<>();\n        int count = 0;\n        for (String w : lst) {\n            w = w.toLowerCase();\n            String r = new StringBuilder(w).reverse().toString();\n            if (seen.contains(r)) {\n                if (count++ < 5)\n                    System.out.printf(\"%-10s\u00a0%-10s\\n\", w, r);\n            } else seen.add(w);\n        }\n        System.out.println(\"\\nSemordnilap pairs found: \" + count);\n    }\n}\n"}
{"id": 159153, "name": "Semordnilap", "source": "Translate Swift to Python: guard let data = try? String(contentsOfFile: \"unixdict.txt\") else {\n  fatalError()\n}\n\nlet words = Set(data.components(separatedBy: \"\\n\"))\nlet pairs = words\n  .map({ ($0, String($0.reversed())) })\n  .filter({ $0.0 < $0.1 && words.contains($0.1) })\n\nprint(\"Found \\(pairs.count) pairs\")\nprint(\"Five examples: \\(pairs.prefix(5))\")\n", "target": ">>> with open('unixdict.txt') as f:\n\twordset = set(f.read().strip().split())\n\n>>> revlist = (''.join(word[::-1]) for word in wordset)\n>>> pairs   = set((word, rev) for word, rev in zip(wordset, revlist) \n                  if word < rev and rev in wordset)\n>>> len(pairs)\n158\n>>> sorted(pairs, key=lambda p: (len(p[0]), p))[-5:]\n[('damon', 'nomad'), ('lager', 'regal'), ('leper', 'repel'), ('lever', 'revel'), ('kramer', 'remark')]\n>>>\n"}
{"id": 159459, "name": "Longest common substring", "source": "Translate Swift to C#: func lComSubStr<\n  S0: Sliceable, S1: Sliceable, T: Equatable where\n  S0.Generator.Element == T, S1.Generator.Element == T,\n  S0.Index.Distance == Int, S1.Index.Distance == Int\n  >(w1: S0, _ w2: S1) -> S0.SubSlice {\n    \n    var (len, end) = (0, 0)\n    \n    let empty = Array(Repeat(count: w2.count + 1, repeatedValue: 0))\n    var mat: [[Int]] = Array(Repeat(count: w1.count + 1, repeatedValue: empty))\n    \n    for (i, sLett) in w1.enumerate() {\n      for (j, tLett) in w2.enumerate() where tLett == sLett {\n        let curLen = mat[i][j] + 1\n        mat[i + 1][j + 1] = curLen\n        if curLen > len {\n          len = curLen\n          end = i\n        }\n      }\n    }\n    return w1[advance(w1.startIndex, (end + 1) - len)...advance(w1.startIndex, end)]\n}\n\nfunc lComSubStr(w1: String, _ w2: String) -> String {\n  return String(lComSubStr(w1.characters, w2.characters))\n}\n", "target": "using System;\n\nnamespace LongestCommonSubstring\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(lcs(\"thisisatest\", \"testing123testing\"));\n            Console.ReadKey(true);\n        }\n\n        public static string lcs(string a, string b)\n        {\n            var lengths = new int[a.Length, b.Length];\n            int greatestLength = 0;\n            string output = \"\";\n            for (int i = 0; i < a.Length; i++)\n            {\n                for (int j = 0; j < b.Length; j++)\n                {\n                    if (a[i] == b[j])\n                    {\n                        lengths[i, j] = i == 0 || j == 0 ? 1 : lengths[i - 1, j - 1] + 1;\n                        if (lengths[i, j] > greatestLength)\n                        {\n                            greatestLength = lengths[i, j];\n                            output = a.Substring(i - greatestLength + 1, greatestLength);\n                        }\n                    }\n                    else\n                    {\n                        lengths[i, j] = 0;\n                    }\n                }\n            }\n            return output;\n        }\n    }\n}\n"}
{"id": 159461, "name": "Longest common substring", "source": "Translate Swift to Java: func lComSubStr<\n  S0: Sliceable, S1: Sliceable, T: Equatable where\n  S0.Generator.Element == T, S1.Generator.Element == T,\n  S0.Index.Distance == Int, S1.Index.Distance == Int\n  >(w1: S0, _ w2: S1) -> S0.SubSlice {\n    \n    var (len, end) = (0, 0)\n    \n    let empty = Array(Repeat(count: w2.count + 1, repeatedValue: 0))\n    var mat: [[Int]] = Array(Repeat(count: w1.count + 1, repeatedValue: empty))\n    \n    for (i, sLett) in w1.enumerate() {\n      for (j, tLett) in w2.enumerate() where tLett == sLett {\n        let curLen = mat[i][j] + 1\n        mat[i + 1][j + 1] = curLen\n        if curLen > len {\n          len = curLen\n          end = i\n        }\n      }\n    }\n    return w1[advance(w1.startIndex, (end + 1) - len)...advance(w1.startIndex, end)]\n}\n\nfunc lComSubStr(w1: String, _ w2: String) -> String {\n  return String(lComSubStr(w1.characters, w2.characters))\n}\n", "target": "public class LongestCommonSubstring {\n\n    public static void main(String[] args) {\n        System.out.println(lcs(\"testing123testing\", \"thisisatest\"));\n        System.out.println(lcs(\"test\", \"thisisatest\"));\n        System.out.println(lcs(\"testing\", \"sting\"));\n        System.out.println(lcs(\"testing\", \"thisisasting\"));\n    }\n\n    static String lcs(String a, String b) {\n        if (a.length() > b.length())\n            return lcs(b, a);\n\n        String res = \"\";\n        for (int ai = 0; ai < a.length(); ai++) {\n            for (int len = a.length() - ai; len > 0; len--) {\n\n                for (int bi = 0; bi <= b.length() - len; bi++) {\n\n                    if (a.regionMatches(ai, b, bi, len) && len > res.length()) {\n                        res = a.substring(ai, ai + len);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n"}
{"id": 159462, "name": "Longest common substring", "source": "Translate Swift to Python: func lComSubStr<\n  S0: Sliceable, S1: Sliceable, T: Equatable where\n  S0.Generator.Element == T, S1.Generator.Element == T,\n  S0.Index.Distance == Int, S1.Index.Distance == Int\n  >(w1: S0, _ w2: S1) -> S0.SubSlice {\n    \n    var (len, end) = (0, 0)\n    \n    let empty = Array(Repeat(count: w2.count + 1, repeatedValue: 0))\n    var mat: [[Int]] = Array(Repeat(count: w1.count + 1, repeatedValue: empty))\n    \n    for (i, sLett) in w1.enumerate() {\n      for (j, tLett) in w2.enumerate() where tLett == sLett {\n        let curLen = mat[i][j] + 1\n        mat[i + 1][j + 1] = curLen\n        if curLen > len {\n          len = curLen\n          end = i\n        }\n      }\n    }\n    return w1[advance(w1.startIndex, (end + 1) - len)...advance(w1.startIndex, end)]\n}\n\nfunc lComSubStr(w1: String, _ w2: String) -> String {\n  return String(lComSubStr(w1.characters, w2.characters))\n}\n", "target": "s1 = \"thisisatest\"\ns2 = \"testing123testing\"\nlen1, len2 = len(s1), len(s2)\nir, jr = 0, -1\nfor i1 in range(len1):\n    i2 = s2.find(s1[i1])\n    while i2 >= 0:\n        j1, j2 = i1, i2\n        while j1 < len1 and j2 < len2 and s2[j2] == s1[j1]:\n            if j1-i1 >= jr-ir:\n                ir, jr = i1, j1\n            j1 += 1; j2 += 1\n        i2 = s2.find(s1[i1], i2+1)\nprint (s1[ir:jr+1])\n"}
{"id": 159639, "name": "Password generator", "source": "Translate Swift to C#: import Foundation\nimport GameplayKit  \n\n\nfunc printHelp() -> Void {\n    print(\"Usage: PasswordGenerator [-l:length] [-c:count] [-s:seed] [-x:exclude] [-h:help]\")\n    print(\"\\t-l: length of the passwords (at leas 4 characters)\")\n    print(\"\\t-c: number of passwords to generate\")\n    print(\"\\t-s: seed of the random number generator\")\n    print(\"\\t-x: exclude of visually similar characters \\\"Il1O05S2Z\\\"\")\n    print(\"\\t-h: print this help\")\n    exit(0)\n}\n\n\nlet _lower:String = \"abcdefghijklmnopqrstuvwxyz\"\nlet _lowerWithoutSimilar:String = \"abcdefghijkmnopqrstuvwxyz\"\nlet _upper:String = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nlet _upperWithoutSimilar = \"ABCDEFGHJKLMNPQRTUVWXY\"\nlet _number:String = \"0123456789\"\nlet _numerWithoutSimilar:String = \"1346789\"\nlet _other:String = \"!\\\"#$%&'()*+,-./:;<=>?@[]^_{|}~\"\n\n\nlet upper = Array(_upper.characters)\nlet upperWithoutSimilar = Array(_upperWithoutSimilar.characters)\nlet lower = Array(_lower.characters)\nlet lowerWithoutSimilar = Array(_lowerWithoutSimilar.characters)\nlet other = Array(_other.characters)\nlet number = Array(_number.characters)\nlet numberWithoutSimilar = Array(_numerWithoutSimilar.characters)\n\nvar length:Int=0, count:Int=0, seed:Int=0, xclude:Bool=false\n\n\nfor i in 1..<CommandLine.arguments.count{\n    var arg = CommandLine.arguments[i]\n    var argument = arg.components(separatedBy: \":\")\n    switch(argument[0]){\n    case \"-l\":\n        length=Int(argument[1])!\n        if length < 4 {\n            print(\"A password must contain of at least 4 characters.\")\n            exit(-1)\n        }\n        break\n    case \"-c\":\n        count=Int(argument[1])!\n        break\n    case \"-s\":\n        seed=Int(argument[1])!\n        break\n    case \"-x\":\n        xclude=true\n        break\n    case \"-h\":\n        printHelp()\n    default:\n        print(\"Could not parse CLI arguments. Use -h for help.\")\n        exit(0)\n    }\n}\n\n\nfunc generatePassword(length len:Int, exclude xcl:Bool) -> String{\n    \n    var ret:String = \"\", loopCount:Int = 0\n    \n    while(loopCount < len){\n        if ret.characters.count < len {\n            if xcl {\n                ret += String(upperWithoutSimilar[Int(getRand(Int32(upperWithoutSimilar.count-1)))])\n            }\n            else {\n                ret += String(upper[Int(getRand(Int32(upper.count)))])\n            }\n        }\n        \n        if ret.characters.count < len {\n            if xcl {\n                ret += String(lowerWithoutSimilar[Int(getRand(Int32(lowerWithoutSimilar.count-1)))])\n            }\n            else {\n                ret += String(lower[Int(getRand(Int32(lower.count-1)))])\n            }\n        }\n        \n        if ret.characters.count < len {\n            if xcl {\n                ret += String(numberWithoutSimilar[Int(getRand(Int32(numberWithoutSimilar.count-1)))])\n            }\n            else {\n                ret += String(number[Int(getRand(Int32(number.count-1)))])\n            }\n        }\n        \n        if ret.characters.count < len {\n            ret += String(other[Int(getRand(Int32(other.count-1)))])\n        }\n        loopCount += 4\n    }\n    \n    \n    let shuffled = GKRandomSource.sharedRandom().arrayByShufflingObjects(in: Array(ret.characters))\n    ret = \"\"\n    for element in shuffled {\n        ret += String(describing: element)\n    }\n    return ret\n}\n\nif xclude {\n    print(\"Generating \\(count) passwords with length \\(length) excluding visually similar characters...\")\n}\nelse {\n    print(\"Generating \\(count) passwords with length \\(length) not excluding visually similar characters...\")\n}\n\ninitRandom(UInt32(0))    \n\n\nfor i in 1...count {\n    print(\"\\(i).\\t\\(generatePassword(length:length,exclude:xclude))\")\n}\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    const string Lower = \"abcdefghijklmnopqrstuvwxyz\";\n    const string Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    const string Digits = \"0123456789\";\n    const string Symbols = \"!\\\"#$%&'()*+,-./:;<=>?@[]^_{|}~\";\n    static readonly string[] Full = {Lower, Upper, Digits, Symbols, Lower + Upper + Digits + Symbols};\n\n    const string Similar = \"Il1O05S2Z\";\n    static readonly string[] Excluded = Full.Select(x => new string(x.Except(Similar).ToArray())).ToArray();\n\n    static Random _rng = new Random();\n    static string[] _symbolSet = Full;\n\n    static void Main(string[] args)\n    {\n        int length = 12, count = 1;\n        try\n        {\n            foreach (var x in args.Select(arg => arg.Split(':')))\n            {\n                switch (x[0])\n                {\n                    case \"-l\": length = int.Parse(x[1]); break;\n                    case \"-c\": count = int.Parse(x[1]); break;\n                    case \"-s\": _rng = new Random(x[1].GetHashCode()); break;\n                    case \"-x\": _symbolSet = bool.Parse(x[1]) ? Excluded : Full; break;\n                    default: throw new FormatException(\"Could not parse arguments\");\n                }\n            }\n        }\n        catch { ShowUsage(); return; }\n        try\n        {\n            for (int i = 0; i < count; i++)\n                Console.WriteLine(GeneratePass(length));\n        }\n        catch (Exception ex) { Console.WriteLine(\"Error: \" + ex.Message); }\n    }\n\n    static void ShowUsage()\n    {\n        Console.WriteLine(\"Usage: PASSGEN [-l:length] [-c:count] [-s:seed] [-x:(true|false)]\");\n        Console.WriteLine(\"\\t-l: the length of the generated passwords\");\n        Console.WriteLine(\"\\t-c: the number of passwords to generate\");\n        Console.WriteLine(\"\\t-s: seed for the random number generator\");\n        Console.WriteLine(\"\\t-x: exclude similar characters: \" + Similar);\n        Console.WriteLine(\"Example: PASSGEN -l:10 -c:5 -s:\\\"Sample Seed\\\" -x:true\");\n    }\n\n    static string GeneratePass(int length)\n    {\n        var minLength = _symbolSet.Length - 1;\n        if(length < minLength)\n            throw new Exception(\"password length must be \" + minLength + \" or greater\");\n\n        int[] usesRemaining = Enumerable.Repeat(1, _symbolSet.Length).ToArray();\n        usesRemaining[minLength] = length - minLength;\n        var password = new char[length];\n        for (int ii = 0; ii < length; ii++)\n        {\n            int set = _rng.Next(0, _symbolSet.Length);\n            if (usesRemaining[set] > 0)\n            {\n                usesRemaining[set]--;\n                password[ii] = _symbolSet[set][_rng.Next(0, _symbolSet[set].Length)];\n            }\n            else ii--;\n        }\n        return new string(password);\n    }\n}\n"}
{"id": 159641, "name": "Password generator", "source": "Translate Swift to Java: import Foundation\nimport GameplayKit  \n\n\nfunc printHelp() -> Void {\n    print(\"Usage: PasswordGenerator [-l:length] [-c:count] [-s:seed] [-x:exclude] [-h:help]\")\n    print(\"\\t-l: length of the passwords (at leas 4 characters)\")\n    print(\"\\t-c: number of passwords to generate\")\n    print(\"\\t-s: seed of the random number generator\")\n    print(\"\\t-x: exclude of visually similar characters \\\"Il1O05S2Z\\\"\")\n    print(\"\\t-h: print this help\")\n    exit(0)\n}\n\n\nlet _lower:String = \"abcdefghijklmnopqrstuvwxyz\"\nlet _lowerWithoutSimilar:String = \"abcdefghijkmnopqrstuvwxyz\"\nlet _upper:String = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nlet _upperWithoutSimilar = \"ABCDEFGHJKLMNPQRTUVWXY\"\nlet _number:String = \"0123456789\"\nlet _numerWithoutSimilar:String = \"1346789\"\nlet _other:String = \"!\\\"#$%&'()*+,-./:;<=>?@[]^_{|}~\"\n\n\nlet upper = Array(_upper.characters)\nlet upperWithoutSimilar = Array(_upperWithoutSimilar.characters)\nlet lower = Array(_lower.characters)\nlet lowerWithoutSimilar = Array(_lowerWithoutSimilar.characters)\nlet other = Array(_other.characters)\nlet number = Array(_number.characters)\nlet numberWithoutSimilar = Array(_numerWithoutSimilar.characters)\n\nvar length:Int=0, count:Int=0, seed:Int=0, xclude:Bool=false\n\n\nfor i in 1..<CommandLine.arguments.count{\n    var arg = CommandLine.arguments[i]\n    var argument = arg.components(separatedBy: \":\")\n    switch(argument[0]){\n    case \"-l\":\n        length=Int(argument[1])!\n        if length < 4 {\n            print(\"A password must contain of at least 4 characters.\")\n            exit(-1)\n        }\n        break\n    case \"-c\":\n        count=Int(argument[1])!\n        break\n    case \"-s\":\n        seed=Int(argument[1])!\n        break\n    case \"-x\":\n        xclude=true\n        break\n    case \"-h\":\n        printHelp()\n    default:\n        print(\"Could not parse CLI arguments. Use -h for help.\")\n        exit(0)\n    }\n}\n\n\nfunc generatePassword(length len:Int, exclude xcl:Bool) -> String{\n    \n    var ret:String = \"\", loopCount:Int = 0\n    \n    while(loopCount < len){\n        if ret.characters.count < len {\n            if xcl {\n                ret += String(upperWithoutSimilar[Int(getRand(Int32(upperWithoutSimilar.count-1)))])\n            }\n            else {\n                ret += String(upper[Int(getRand(Int32(upper.count)))])\n            }\n        }\n        \n        if ret.characters.count < len {\n            if xcl {\n                ret += String(lowerWithoutSimilar[Int(getRand(Int32(lowerWithoutSimilar.count-1)))])\n            }\n            else {\n                ret += String(lower[Int(getRand(Int32(lower.count-1)))])\n            }\n        }\n        \n        if ret.characters.count < len {\n            if xcl {\n                ret += String(numberWithoutSimilar[Int(getRand(Int32(numberWithoutSimilar.count-1)))])\n            }\n            else {\n                ret += String(number[Int(getRand(Int32(number.count-1)))])\n            }\n        }\n        \n        if ret.characters.count < len {\n            ret += String(other[Int(getRand(Int32(other.count-1)))])\n        }\n        loopCount += 4\n    }\n    \n    \n    let shuffled = GKRandomSource.sharedRandom().arrayByShufflingObjects(in: Array(ret.characters))\n    ret = \"\"\n    for element in shuffled {\n        ret += String(describing: element)\n    }\n    return ret\n}\n\nif xclude {\n    print(\"Generating \\(count) passwords with length \\(length) excluding visually similar characters...\")\n}\nelse {\n    print(\"Generating \\(count) passwords with length \\(length) not excluding visually similar characters...\")\n}\n\ninitRandom(UInt32(0))    \n\n\nfor i in 1...count {\n    print(\"\\(i).\\t\\(generatePassword(length:length,exclude:xclude))\")\n}\n", "target": "import java.util.*;\n\npublic class PasswordGenerator {\n    final static Random rand = new Random();\n\n    public static void main(String[] args) {\n        int num, len;\n\n        try {\n            if (args.length != 2)\n                throw new IllegalArgumentException();\n\n            len = Integer.parseInt(args[0]);\n            if (len < 4 || len > 16)\n                throw new IllegalArgumentException();\n\n            num = Integer.parseInt(args[1]);\n            if (num < 1 || num > 10)\n                throw new IllegalArgumentException();\n\n            for (String pw : generatePasswords(num, len))\n                System.out.println(pw);\n\n        } catch (IllegalArgumentException e) {\n            String s = \"Provide the length of the passwords (min 4, max 16) you \"\n                    + \"want to generate,\\nand how many (min 1, max 10)\";\n            System.out.println(s);\n        }\n    }\n\n    private static List<String> generatePasswords(int num, int len) {\n        final String s = \"!\\\"#$%&'()*+,-./:;<=>?@[]^_{|}~\";\n\n        List<String> result = new ArrayList<>();\n\n        for (int i = 0; i < num; i++) {\n            StringBuilder sb = new StringBuilder();\n            sb.append(s.charAt(rand.nextInt(s.length())));\n            sb.append((char) (rand.nextInt(10) + '0'));\n            sb.append((char) (rand.nextInt(26) + 'a'));\n            sb.append((char) (rand.nextInt(26) + 'A'));\n\n            for (int j = 4; j < len; j++) {\n                int r = rand.nextInt(93) + '!';\n                if (r == 92 || r == 96) {\n                    j--;\n                } else {\n                    sb.append((char) r);\n                }\n            }\n            result.add(shuffle(sb));\n        }\n        return result;\n    }\n\n    public static String shuffle(StringBuilder sb) {\n        int len = sb.length();\n        for (int i = len - 1; i > 0; i--) {\n            int r = rand.nextInt(i);\n            char tmp = sb.charAt(i);\n            sb.setCharAt(i, sb.charAt(r));\n            sb.setCharAt(r, tmp);\n        }\n        return sb.toString();\n    }\n}\n"}
{"id": 159642, "name": "Password generator", "source": "Translate Swift to Python: import Foundation\nimport GameplayKit  \n\n\nfunc printHelp() -> Void {\n    print(\"Usage: PasswordGenerator [-l:length] [-c:count] [-s:seed] [-x:exclude] [-h:help]\")\n    print(\"\\t-l: length of the passwords (at leas 4 characters)\")\n    print(\"\\t-c: number of passwords to generate\")\n    print(\"\\t-s: seed of the random number generator\")\n    print(\"\\t-x: exclude of visually similar characters \\\"Il1O05S2Z\\\"\")\n    print(\"\\t-h: print this help\")\n    exit(0)\n}\n\n\nlet _lower:String = \"abcdefghijklmnopqrstuvwxyz\"\nlet _lowerWithoutSimilar:String = \"abcdefghijkmnopqrstuvwxyz\"\nlet _upper:String = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nlet _upperWithoutSimilar = \"ABCDEFGHJKLMNPQRTUVWXY\"\nlet _number:String = \"0123456789\"\nlet _numerWithoutSimilar:String = \"1346789\"\nlet _other:String = \"!\\\"#$%&'()*+,-./:;<=>?@[]^_{|}~\"\n\n\nlet upper = Array(_upper.characters)\nlet upperWithoutSimilar = Array(_upperWithoutSimilar.characters)\nlet lower = Array(_lower.characters)\nlet lowerWithoutSimilar = Array(_lowerWithoutSimilar.characters)\nlet other = Array(_other.characters)\nlet number = Array(_number.characters)\nlet numberWithoutSimilar = Array(_numerWithoutSimilar.characters)\n\nvar length:Int=0, count:Int=0, seed:Int=0, xclude:Bool=false\n\n\nfor i in 1..<CommandLine.arguments.count{\n    var arg = CommandLine.arguments[i]\n    var argument = arg.components(separatedBy: \":\")\n    switch(argument[0]){\n    case \"-l\":\n        length=Int(argument[1])!\n        if length < 4 {\n            print(\"A password must contain of at least 4 characters.\")\n            exit(-1)\n        }\n        break\n    case \"-c\":\n        count=Int(argument[1])!\n        break\n    case \"-s\":\n        seed=Int(argument[1])!\n        break\n    case \"-x\":\n        xclude=true\n        break\n    case \"-h\":\n        printHelp()\n    default:\n        print(\"Could not parse CLI arguments. Use -h for help.\")\n        exit(0)\n    }\n}\n\n\nfunc generatePassword(length len:Int, exclude xcl:Bool) -> String{\n    \n    var ret:String = \"\", loopCount:Int = 0\n    \n    while(loopCount < len){\n        if ret.characters.count < len {\n            if xcl {\n                ret += String(upperWithoutSimilar[Int(getRand(Int32(upperWithoutSimilar.count-1)))])\n            }\n            else {\n                ret += String(upper[Int(getRand(Int32(upper.count)))])\n            }\n        }\n        \n        if ret.characters.count < len {\n            if xcl {\n                ret += String(lowerWithoutSimilar[Int(getRand(Int32(lowerWithoutSimilar.count-1)))])\n            }\n            else {\n                ret += String(lower[Int(getRand(Int32(lower.count-1)))])\n            }\n        }\n        \n        if ret.characters.count < len {\n            if xcl {\n                ret += String(numberWithoutSimilar[Int(getRand(Int32(numberWithoutSimilar.count-1)))])\n            }\n            else {\n                ret += String(number[Int(getRand(Int32(number.count-1)))])\n            }\n        }\n        \n        if ret.characters.count < len {\n            ret += String(other[Int(getRand(Int32(other.count-1)))])\n        }\n        loopCount += 4\n    }\n    \n    \n    let shuffled = GKRandomSource.sharedRandom().arrayByShufflingObjects(in: Array(ret.characters))\n    ret = \"\"\n    for element in shuffled {\n        ret += String(describing: element)\n    }\n    return ret\n}\n\nif xclude {\n    print(\"Generating \\(count) passwords with length \\(length) excluding visually similar characters...\")\n}\nelse {\n    print(\"Generating \\(count) passwords with length \\(length) not excluding visually similar characters...\")\n}\n\ninitRandom(UInt32(0))    \n\n\nfor i in 1...count {\n    print(\"\\(i).\\t\\(generatePassword(length:length,exclude:xclude))\")\n}\n", "target": "import random\n\nlowercase = 'abcdefghijklmnopqrstuvwxyz' \nuppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' \ndigits = '0123456789'                    \npunctuation = '!\"\n\nallowed = lowercase + uppercase + digits + punctuation\n\nvisually_similar = 'Il1O05S2Z'\n\n\ndef new_password(length:int, readable=True) -> str:\n    if length < 4:\n        print(\"password length={} is too short,\".format(length),\n            \"minimum length=4\")\n        return ''\n    choice = random.SystemRandom().choice\n    while True:\n        password_chars = [\n            choice(lowercase),\n            choice(uppercase),\n            choice(digits),\n            choice(punctuation)\n            ] + random.sample(allowed, length-4)\n        if (not readable or \n                all(c not in visually_similar for c in password_chars)):\n            random.SystemRandom().shuffle(password_chars)\n            return ''.join(password_chars)\n\n\ndef password_generator(length, qty=1, readable=True):\n    for i in range(qty):\n        print(new_password(length, readable))\n"}
{"id": 160547, "name": "Top rank per group", "source": "Translate Swift to C#: struct Employee {\n  var name: String\n  var id: String\n  var salary: Int\n  var department: String\n}\n\nlet employees = [\n  Employee(name: \"Tyler Bennett\", id: \"E10297\", salary: 32000, department: \"D101\"),\n  Employee(name: \"John Rappl\", id: \"E21437\", salary: 47000, department: \"D050\"),\n  Employee(name: \"George Woltman\", id: \"E00127\", salary: 53500, department: \"D101\"),\n  Employee(name: \"Adam Smith\", id: \"E63535\", salary: 18000, department: \"D202\"),\n  Employee(name: \"Claire Buckman\", id: \"E39876\", salary: 27800, department: \"D202\"),\n  Employee(name: \"David McClellan\", id: \"E04242\", salary: 41500, department: \"D101\"),\n  Employee(name: \"Rich Holcomb\", id: \"E01234\", salary: 49500, department: \"D202\"),\n  Employee(name: \"Nathan Adams\", id: \"E41298\", salary: 21900, department: \"D050\"),\n  Employee(name: \"Richard Potter\", id: \"E43128\", salary: 15900, department: \"D101\"),\n  Employee(name: \"David Motsinger\", id: \"E27002\", salary: 19250, department: \"D202\"),\n  Employee(name: \"Tim Sampair\", id: \"E03033\", salary: 27000, department: \"D101\"),\n  Employee(name: \"Kim Arlich\", id: \"E10001\", salary: 57000, department: \"D190\"),\n  Employee(name: \"Timothy Grove\", id: \"E16398\", salary: 29900, department: \"D190\")\n]\n\nfunc highestSalaries(employees: [Employee], n: Int = 1) -> [String: [Employee]] {\n  return employees.reduce(into: [:], {acc, employee in\n    guard var cur = acc[employee.department] else {\n      acc[employee.department] = [employee]\n\n      return\n    }\n\n    if cur.count < n {\n      cur.append(employee)\n    } else if cur.last!.salary < employee.salary {\n      cur[n - 1] = employee\n    }\n\n    acc[employee.department] = cur.sorted(by: { $0.salary > $1.salary })\n  })\n}\n\nfor (dept, employees) in highestSalaries(employees: employees, n: 3) {\n  let employeeString = employees.map({ \"\\($0.name): \\($0.salary)\" }).joined(separator: \"\\n\\t\")\n\n  print(\"\\(dept)'s highest paid employees are: \\n\\t\\(employeeString)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    class Employee\n    {\n        public Employee(string name, string id, int salary, string department)\n        {\n            Name = name;\n            Id = id;\n            Salary = salary;\n            Department = department;\n        }\n\n        public string Name { get; private set; }\n        public string Id { get; private set; }\n        public int Salary { get; private set; }\n        public string Department { get; private set; }\n\n        public override string ToString()\n        {\n            return String.Format(\"{0, -25}\\t{1}\\t{2}\", Name, Id, Salary);\n        }\n    }\n\n    private static void Main(string[] args)\n    {\n        var employees = new List<Employee>\n                        {\n                            new Employee(\"Tyler Bennett\", \"E10297\", 32000, \"D101\"),\n                            new Employee(\"John Rappl\", \"E21437\", 47000, \"D050\"),\n                            new Employee(\"George Woltman\", \"E21437\", 53500, \"D101\"),\n                            new Employee(\"Adam Smith\", \"E21437\", 18000, \"D202\"),\n                            new Employee(\"Claire Buckman\", \"E39876\", 27800, \"D202\"),\n                            new Employee(\"David McClellan\", \"E04242\", 41500, \"D101\"),\n                            new Employee(\"Rich Holcomb\", \"E01234\", 49500, \"D202\"),\n                            new Employee(\"Nathan Adams\", \"E41298\", 21900, \"D050\"),\n                            new Employee(\"Richard Potter\", \"E43128\", 15900, \"D101\"),\n                            new Employee(\"David Motsinger\", \"E27002\", 19250, \"D202\"),\n                            new Employee(\"Tim Sampair\", \"E03033\", 27000, \"D101\"),\n                            new Employee(\"Kim Arlich\", \"E10001\", 57000, \"D190\"),\n                            new Employee(\"Timothy Grove\", \"E16398\", 29900, \"D190\")\n                        };\n\n        DisplayTopNPerDepartment(employees, 2);\n    }\n\n    static void DisplayTopNPerDepartment(IEnumerable<Employee> employees, int n)\n    {\n        var topSalariesByDepartment =\n            from employee in employees\n            group employee by employee.Department\n            into g\n            select new\n                    {\n                        Department = g.Key,\n                        TopEmployeesBySalary = g.OrderByDescending(e => e.Salary).Take(n)\n                    };\n\n        foreach (var x in topSalariesByDepartment)\n        {\n            Console.WriteLine(\"Department: \" + x.Department);\n            foreach (var employee in x.TopEmployeesBySalary)\n                Console.WriteLine(employee);\n            Console.WriteLine(\"----------------------------\");\n        }\n    }\n}\n"}
{"id": 160549, "name": "Top rank per group", "source": "Translate Swift to Java: struct Employee {\n  var name: String\n  var id: String\n  var salary: Int\n  var department: String\n}\n\nlet employees = [\n  Employee(name: \"Tyler Bennett\", id: \"E10297\", salary: 32000, department: \"D101\"),\n  Employee(name: \"John Rappl\", id: \"E21437\", salary: 47000, department: \"D050\"),\n  Employee(name: \"George Woltman\", id: \"E00127\", salary: 53500, department: \"D101\"),\n  Employee(name: \"Adam Smith\", id: \"E63535\", salary: 18000, department: \"D202\"),\n  Employee(name: \"Claire Buckman\", id: \"E39876\", salary: 27800, department: \"D202\"),\n  Employee(name: \"David McClellan\", id: \"E04242\", salary: 41500, department: \"D101\"),\n  Employee(name: \"Rich Holcomb\", id: \"E01234\", salary: 49500, department: \"D202\"),\n  Employee(name: \"Nathan Adams\", id: \"E41298\", salary: 21900, department: \"D050\"),\n  Employee(name: \"Richard Potter\", id: \"E43128\", salary: 15900, department: \"D101\"),\n  Employee(name: \"David Motsinger\", id: \"E27002\", salary: 19250, department: \"D202\"),\n  Employee(name: \"Tim Sampair\", id: \"E03033\", salary: 27000, department: \"D101\"),\n  Employee(name: \"Kim Arlich\", id: \"E10001\", salary: 57000, department: \"D190\"),\n  Employee(name: \"Timothy Grove\", id: \"E16398\", salary: 29900, department: \"D190\")\n]\n\nfunc highestSalaries(employees: [Employee], n: Int = 1) -> [String: [Employee]] {\n  return employees.reduce(into: [:], {acc, employee in\n    guard var cur = acc[employee.department] else {\n      acc[employee.department] = [employee]\n\n      return\n    }\n\n    if cur.count < n {\n      cur.append(employee)\n    } else if cur.last!.salary < employee.salary {\n      cur[n - 1] = employee\n    }\n\n    acc[employee.department] = cur.sorted(by: { $0.salary > $1.salary })\n  })\n}\n\nfor (dept, employees) in highestSalaries(employees: employees, n: 3) {\n  let employeeString = employees.map({ \"\\($0.name): \\($0.salary)\" }).joined(separator: \"\\n\\t\")\n\n  print(\"\\(dept)'s highest paid employees are: \\n\\t\\(employeeString)\")\n}\n", "target": "import java.io.File;\nimport java.util.*;\n\npublic class TopRankPerGroup {\n\n    private static class Employee {\n        final String name;\n        final String id;\n        final String department;\n        final int salary;\n\n        Employee(String[] rec) {\n            name = rec[0];\n            id = rec[1];\n            salary = Integer.parseInt(rec[2]);\n            department = rec[3];\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s %s %d %s\", id, name, salary, department);\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int N = args.length > 0 ? Integer.parseInt(args[0]) : 3;\n\n        Map<String, List<Employee>> records = new TreeMap<>();\n        try (Scanner sc = new Scanner(new File(\"data.txt\"))) {\n            while (sc.hasNextLine()) {\n                String[] rec = sc.nextLine().trim().split(\", \");\n\n                List<Employee> lst = records.get(rec[3]);\n                if (lst == null) {\n                    lst = new ArrayList<>();\n                    records.put(rec[3], lst);\n                }\n                lst.add(new Employee(rec));\n            }\n        }\n\n        records.forEach((key, val) -> {\n            System.out.printf(\"%nDepartment %s%n\", key);\n            val.stream()\n                .sorted((a, b) -> Integer.compare(b.salary, a.salary))\n                .limit(N).forEach(System.out::println);\n        });\n    }\n}\n"}
{"id": 160550, "name": "Top rank per group", "source": "Translate Swift to Python: struct Employee {\n  var name: String\n  var id: String\n  var salary: Int\n  var department: String\n}\n\nlet employees = [\n  Employee(name: \"Tyler Bennett\", id: \"E10297\", salary: 32000, department: \"D101\"),\n  Employee(name: \"John Rappl\", id: \"E21437\", salary: 47000, department: \"D050\"),\n  Employee(name: \"George Woltman\", id: \"E00127\", salary: 53500, department: \"D101\"),\n  Employee(name: \"Adam Smith\", id: \"E63535\", salary: 18000, department: \"D202\"),\n  Employee(name: \"Claire Buckman\", id: \"E39876\", salary: 27800, department: \"D202\"),\n  Employee(name: \"David McClellan\", id: \"E04242\", salary: 41500, department: \"D101\"),\n  Employee(name: \"Rich Holcomb\", id: \"E01234\", salary: 49500, department: \"D202\"),\n  Employee(name: \"Nathan Adams\", id: \"E41298\", salary: 21900, department: \"D050\"),\n  Employee(name: \"Richard Potter\", id: \"E43128\", salary: 15900, department: \"D101\"),\n  Employee(name: \"David Motsinger\", id: \"E27002\", salary: 19250, department: \"D202\"),\n  Employee(name: \"Tim Sampair\", id: \"E03033\", salary: 27000, department: \"D101\"),\n  Employee(name: \"Kim Arlich\", id: \"E10001\", salary: 57000, department: \"D190\"),\n  Employee(name: \"Timothy Grove\", id: \"E16398\", salary: 29900, department: \"D190\")\n]\n\nfunc highestSalaries(employees: [Employee], n: Int = 1) -> [String: [Employee]] {\n  return employees.reduce(into: [:], {acc, employee in\n    guard var cur = acc[employee.department] else {\n      acc[employee.department] = [employee]\n\n      return\n    }\n\n    if cur.count < n {\n      cur.append(employee)\n    } else if cur.last!.salary < employee.salary {\n      cur[n - 1] = employee\n    }\n\n    acc[employee.department] = cur.sorted(by: { $0.salary > $1.salary })\n  })\n}\n\nfor (dept, employees) in highestSalaries(employees: employees, n: 3) {\n  let employeeString = employees.map({ \"\\($0.name): \\($0.salary)\" }).joined(separator: \"\\n\\t\")\n\n  print(\"\\(dept)'s highest paid employees are: \\n\\t\\(employeeString)\")\n}\n", "target": "from collections import defaultdict\nfrom heapq import nlargest\n \ndata = [('Employee Name', 'Employee ID', 'Salary', 'Department'),\n        ('Tyler Bennett', 'E10297', 32000, 'D101'),\n        ('John Rappl', 'E21437', 47000, 'D050'),\n        ('George Woltman', 'E00127', 53500, 'D101'),\n        ('Adam Smith', 'E63535', 18000, 'D202'),\n        ('Claire Buckman', 'E39876', 27800, 'D202'),\n        ('David McClellan', 'E04242', 41500, 'D101'),\n        ('Rich Holcomb', 'E01234', 49500, 'D202'),\n        ('Nathan Adams', 'E41298', 21900, 'D050'),\n        ('Richard Potter', 'E43128', 15900, 'D101'),\n        ('David Motsinger', 'E27002', 19250, 'D202'),\n        ('Tim Sampair', 'E03033', 27000, 'D101'),\n        ('Kim Arlich', 'E10001', 57000, 'D190'),\n        ('Timothy Grove', 'E16398', 29900, 'D190')]\n \ndepartments = defaultdict(list)\nfor rec in data[1:]:\n    departments[rec[-1]].append(rec)\n \nN = 3\nformat = \" %-15s \" * len(data[0])\nfor department, recs in sorted(departments.items()):\n    print (\"Department %s\" % department)\n    print (format % data[0])\n    for rec in nlargest(N, recs, key=lambda rec: rec[-2]):\n        print (format % rec)\n    print('')\n"}
{"id": 160750, "name": "Subleq", "source": "Translate Swift to C#: func subleq(_ inst: inout [Int]) {\n  var i = 0\n  \n  while i >= 0 {\n    if inst[i] == -1 {\n      inst[inst[i + 1]] = Int(readLine(strippingNewline: true)!.unicodeScalars.first!.value)\n    } else if inst[i + 1] == -1 {\n      print(String(UnicodeScalar(inst[inst[i]])!), terminator: \"\")\n    } else {\n      inst[inst[i + 1]] -= inst[inst[i]]\n      \n      if inst[inst[i + 1]] <= 0 {\n        i = inst[i + 2]\n        continue\n      }\n    }\n    \n    i += 3\n  }\n}\n\nvar prog = [\n  15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15,\n  0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111,\n  114, 108, 100, 33, 10, 0\n]\n\nsubleq(&prog)\n", "target": "using System;\n\nnamespace Subleq {\n    class Program {\n        static void Main(string[] args) {\n            int[] mem = {\n                15, 17, -1, 17, -1, -1, 16, 1, -1, 16,\n                3, -1, 15, 15, 0, 0, -1, 72, 101, 108,\n                108, 111, 44, 32, 119, 111, 114, 108, 100, 33,\n                10, 0,\n            };\n\n            int instructionPointer = 0;\n\n            do {\n                int a = mem[instructionPointer];\n                int b = mem[instructionPointer + 1];\n\n                if (a == -1) {\n                    mem[b] = Console.Read();\n                }\n                else if (b == -1) {\n                    Console.Write((char)mem[a]);\n                }\n                else {\n                    mem[b] -= mem[a];\n                    if (mem[b] < 1) {\n                        instructionPointer = mem[instructionPointer + 2];\n                        continue;\n                    }\n                }\n\n                instructionPointer += 3;\n            } while (instructionPointer >= 0);\n        }\n    }\n}\n"}
{"id": 160752, "name": "Subleq", "source": "Translate Swift to Java: func subleq(_ inst: inout [Int]) {\n  var i = 0\n  \n  while i >= 0 {\n    if inst[i] == -1 {\n      inst[inst[i + 1]] = Int(readLine(strippingNewline: true)!.unicodeScalars.first!.value)\n    } else if inst[i + 1] == -1 {\n      print(String(UnicodeScalar(inst[inst[i]])!), terminator: \"\")\n    } else {\n      inst[inst[i + 1]] -= inst[inst[i]]\n      \n      if inst[inst[i + 1]] <= 0 {\n        i = inst[i + 2]\n        continue\n      }\n    }\n    \n    i += 3\n  }\n}\n\nvar prog = [\n  15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15,\n  0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111,\n  114, 108, 100, 33, 10, 0\n]\n\nsubleq(&prog)\n", "target": "import java.util.Scanner;\n\npublic class Subleq {\n\n    public static void main(String[] args) {\n        int[] mem = {15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15, 0, 0,\n            -1, 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 10, 0};\n\n        Scanner input = new Scanner(System.in);\n        int instructionPointer = 0;\n\n        do {\n            int a = mem[instructionPointer];\n            int b = mem[instructionPointer + 1];\n\n            if (a == -1) {\n                mem[b] = input.nextInt();\n\n            } else if (b == -1) {\n                System.out.printf(\"%c\", (char) mem[a]);\n\n            } else {\n\n                mem[b] -= mem[a];\n                if (mem[b] < 1) {\n                    instructionPointer = mem[instructionPointer + 2];\n                    continue;\n                }\n            }\n\n            instructionPointer += 3;\n\n        } while (instructionPointer >= 0);\n    }\n}\n"}
{"id": 160753, "name": "Subleq", "source": "Translate Swift to Python: func subleq(_ inst: inout [Int]) {\n  var i = 0\n  \n  while i >= 0 {\n    if inst[i] == -1 {\n      inst[inst[i + 1]] = Int(readLine(strippingNewline: true)!.unicodeScalars.first!.value)\n    } else if inst[i + 1] == -1 {\n      print(String(UnicodeScalar(inst[inst[i]])!), terminator: \"\")\n    } else {\n      inst[inst[i + 1]] -= inst[inst[i]]\n      \n      if inst[inst[i + 1]] <= 0 {\n        i = inst[i + 2]\n        continue\n      }\n    }\n    \n    i += 3\n  }\n}\n\nvar prog = [\n  15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15,\n  0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111,\n  114, 108, 100, 33, 10, 0\n]\n\nsubleq(&prog)\n", "target": "import sys\n\ndef subleq(a):\n    i = 0\n    try:\n        while i >= 0:\n            if a[i] == -1:\n                a[a[i + 1]] = ord(sys.stdin.read(1))\n            elif a[i + 1] == -1:\n                print(chr(a[a[i]]), end=\"\")\n            else:\n                a[a[i + 1]] -= a[a[i]]\n                if a[a[i + 1]] <= 0:\n                    i = a[i + 2]\n                    continue\n            i += 3\n    except (ValueError, IndexError, KeyboardInterrupt):\n        print(\"abort\")\n        print(a)\n\nsubleq([15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15,\n        0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111,\n        114, 108, 100, 33, 10, 0])\n"}
{"id": 161131, "name": "Range extraction", "source": "Translate Swift to C#: import Darwin\n\nfunc ranges(from ints:[Int]) -> [(Int, Int)] {\n \n\tvar range : (Int, Int)?\n\tvar ranges = [(Int, Int)]()\n\tfor this in ints {\n\t\tif let (start, end) = range {\n\t\t\tif this == end + 1 {\n\t\t\t\trange = (start, this)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tranges.append(range!)\n\t\t\t\trange = (this, this)\n\t\t\t}\n\t\t}\n\t\telse { range = (this, this) }\n\t}\n\tranges.append(range!)\n \n\treturn ranges\n}\n \nfunc description(from ranges:[(Int, Int)]) -> String {\n\tvar desc = \"\"\n\tfor (start, end) in ranges {\n\t\tdesc += desc.isEmpty ? \"\" : \",\"\n\t\tif start == end {\n\t\t\tdesc += \"\\(start)\"\n\t\t}\n\t\telse if end == start + 1 {\n\t\t\tdesc += \"\\(start),\\(end)\"\n\t\t}\n\t\telse {\n\t\t\tdesc += \"\\(start)-\\(end)\"\n\t\t}\n\t}\n\treturn desc\n}\n \n \nlet ex = [-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20]\nlet longer = [0,  1,  2,  4,  6,  7,  8, 11, 12, 14,\n\t15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n\t25, 27, 28, 29, 30, 31, 32, 33, 35, 36,\n\t37, 38, 39]\n \nprint(description(from: ranges(from: ex)))\nprint(description(from: ranges(from: longer)))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass RangeExtraction\n{\n    static void Main()\n    {\n        const string testString = \"0,  1,  2,  4,  6,  7,  8, 11, 12, 14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24,25, 27, 28, 29, 30, 31, 32, 33, 35, 36,37, 38, 39\";\n        var result = String.Join(\",\", RangesToStrings(GetRanges(testString)));\n        Console.Out.WriteLine(result);\n    }\n\n    public static IEnumerable<IEnumerable<int>> GetRanges(string testString)\n    {\n        var numbers = testString.Split(new[] { ',' }).Select(x => Convert.ToInt32(x));\n        var current = new List<int>();\n        foreach (var n in numbers)\n        {\n            if (current.Count == 0)\n            {\n                current.Add(n);\n            }\n            else\n            {\n                if (current.Max() + 1 == n)\n                {\n                    current.Add(n);\n                }\n                else\n                {\n                    yield return current;\n                    current = new List<int> { n };\n                }\n            }\n        }\n        yield return current;\n    }\n\n    public static IEnumerable<string> RangesToStrings(IEnumerable<IEnumerable<int>> ranges)\n    {\n        foreach (var range in ranges)\n        {\n            if (range.Count() == 1)\n            {\n                yield return range.Single().ToString();\n            }\n            else if (range.Count() == 2)\n            {\n                yield return range.Min() + \",\" + range.Max();\n            }\n            else\n            {\n                yield return range.Min() + \"-\" + range.Max();\n            }\n        }\n    }\n}\n"}
{"id": 161133, "name": "Range extraction", "source": "Translate Swift to Java: import Darwin\n\nfunc ranges(from ints:[Int]) -> [(Int, Int)] {\n \n\tvar range : (Int, Int)?\n\tvar ranges = [(Int, Int)]()\n\tfor this in ints {\n\t\tif let (start, end) = range {\n\t\t\tif this == end + 1 {\n\t\t\t\trange = (start, this)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tranges.append(range!)\n\t\t\t\trange = (this, this)\n\t\t\t}\n\t\t}\n\t\telse { range = (this, this) }\n\t}\n\tranges.append(range!)\n \n\treturn ranges\n}\n \nfunc description(from ranges:[(Int, Int)]) -> String {\n\tvar desc = \"\"\n\tfor (start, end) in ranges {\n\t\tdesc += desc.isEmpty ? \"\" : \",\"\n\t\tif start == end {\n\t\t\tdesc += \"\\(start)\"\n\t\t}\n\t\telse if end == start + 1 {\n\t\t\tdesc += \"\\(start),\\(end)\"\n\t\t}\n\t\telse {\n\t\t\tdesc += \"\\(start)-\\(end)\"\n\t\t}\n\t}\n\treturn desc\n}\n \n \nlet ex = [-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20]\nlet longer = [0,  1,  2,  4,  6,  7,  8, 11, 12, 14,\n\t15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n\t25, 27, 28, 29, 30, 31, 32, 33, 35, 36,\n\t37, 38, 39]\n \nprint(description(from: ranges(from: ex)))\nprint(description(from: ranges(from: longer)))\n", "target": "public class RangeExtraction {\n\n    public static void main(String[] args) {\n        int[] arr = {0, 1, 2, 4, 6, 7, 8, 11, 12, 14,\n            15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 27, 28, 29, 30, 31, 32, 33, 35, 36,\n            37, 38, 39};\n\n        int len = arr.length;\n        int idx = 0, idx2 = 0;\n        while (idx < len) {\n            while (++idx2 < len && arr[idx2] - arr[idx2 - 1] == 1);\n            if (idx2 - idx > 2) {\n                System.out.printf(\"%s-%s,\", arr[idx], arr[idx2 - 1]);\n                idx = idx2;\n            } else {\n                for (; idx < idx2; idx++)\n                    System.out.printf(\"%s,\", arr[idx]);\n            }\n        }\n    }\n}\n"}
{"id": 161134, "name": "Range extraction", "source": "Translate Swift to Python: import Darwin\n\nfunc ranges(from ints:[Int]) -> [(Int, Int)] {\n \n\tvar range : (Int, Int)?\n\tvar ranges = [(Int, Int)]()\n\tfor this in ints {\n\t\tif let (start, end) = range {\n\t\t\tif this == end + 1 {\n\t\t\t\trange = (start, this)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tranges.append(range!)\n\t\t\t\trange = (this, this)\n\t\t\t}\n\t\t}\n\t\telse { range = (this, this) }\n\t}\n\tranges.append(range!)\n \n\treturn ranges\n}\n \nfunc description(from ranges:[(Int, Int)]) -> String {\n\tvar desc = \"\"\n\tfor (start, end) in ranges {\n\t\tdesc += desc.isEmpty ? \"\" : \",\"\n\t\tif start == end {\n\t\t\tdesc += \"\\(start)\"\n\t\t}\n\t\telse if end == start + 1 {\n\t\t\tdesc += \"\\(start),\\(end)\"\n\t\t}\n\t\telse {\n\t\t\tdesc += \"\\(start)-\\(end)\"\n\t\t}\n\t}\n\treturn desc\n}\n \n \nlet ex = [-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20]\nlet longer = [0,  1,  2,  4,  6,  7,  8, 11, 12, 14,\n\t15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n\t25, 27, 28, 29, 30, 31, 32, 33, 35, 36,\n\t37, 38, 39]\n \nprint(description(from: ranges(from: ex)))\nprint(description(from: ranges(from: longer)))\n", "target": "def range_extract(lst):\n    'Yield 2-tuple ranges or 1-tuple single elements from list of increasing ints'\n    lenlst = len(lst)\n    i = 0\n    while i< lenlst:\n        low = lst[i]\n        while i <lenlst-1 and lst[i]+1 == lst[i+1]: i +=1\n        hi = lst[i]\n        if   hi - low >= 2:\n            yield (low, hi)\n        elif hi - low == 1:\n            yield (low,)\n            yield (hi,)\n        else:\n            yield (low,)\n        i += 1\n\ndef printr(ranges):\n    print( ','.join( (('%i-%i' % r) if len(r) == 2 else '%i' % r)\n                     for r in ranges ) )\n\nif __name__ == '__main__':\n    for lst in [[-8, -7, -6, -3, -2, -1, 0, 1, 3, 4, 5, 7,\n                 8, 9, 10, 11, 14, 15, 17, 18, 19, 20],\n                [0, 1, 2, 4, 6, 7, 8, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n                 23, 24, 25, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39]]:\n        \n        printr(range_extract(lst))\n"}
{"id": 161710, "name": "Reverse words in a string", "source": "Translate Swift to C#: import Foundation\n\n\nextension String {\n    var lines: [String] {\n        get {\n            return self.componentsSeparatedByCharactersInSet(NSCharacterSet.newlineCharacterSet())\n        }\n    }\n    var words: [String] {\n        get {\n            return self.componentsSeparatedByCharactersInSet(NSCharacterSet.whitespaceCharacterSet())\n        }\n    }\n}\n\nlet input = \"---------- Ice and Fire ------------\\n\\nfire, in end will world the say Some\\nice. in say Some\\ndesire of tasted I've what From\\nfire. favor who those with hold I\\n\\n... elided paragraph last ...\\n\\nFrost Robert -----------------------\\n\"\n\nlet output = input.lines.map { $0.words.reverse().joinWithSeparator(\" \") }.joinWithSeparator(\"\\n\")\n\nprint(output)\n", "target": "using System;\n\npublic class ReverseWordsInString\n{\n    public static void Main(string[] args)\n    {\n        string text = @\"\n            ---------- Ice and Fire ------------\n\n            fire, in end will world the say Some\n            ice. in say Some\n            desire of tasted I've what From\n            fire. favor who those with hold I\n\n            ... elided paragraph last ...\n\n            Frost Robert -----------------------\n            \";\n\n        foreach (string line in text.Split(Environment.NewLine)) {\n            \n            string[] words = line.Split(default(char[]), StringSplitOptions.RemoveEmptyEntries);\n            Array.Reverse(words);\n            WriteLine(string.Join(\" \", words));\n        }\n    }\n}\n"}
{"id": 161712, "name": "Reverse words in a string", "source": "Translate Swift to Java: import Foundation\n\n\nextension String {\n    var lines: [String] {\n        get {\n            return self.componentsSeparatedByCharactersInSet(NSCharacterSet.newlineCharacterSet())\n        }\n    }\n    var words: [String] {\n        get {\n            return self.componentsSeparatedByCharactersInSet(NSCharacterSet.whitespaceCharacterSet())\n        }\n    }\n}\n\nlet input = \"---------- Ice and Fire ------------\\n\\nfire, in end will world the say Some\\nice. in say Some\\ndesire of tasted I've what From\\nfire. favor who those with hold I\\n\\n... elided paragraph last ...\\n\\nFrost Robert -----------------------\\n\"\n\nlet output = input.lines.map { $0.words.reverse().joinWithSeparator(\" \") }.joinWithSeparator(\"\\n\")\n\nprint(output)\n", "target": "public class ReverseWords {\n\n    static final String[] lines = {\n        \" ----------- Ice and Fire ----------- \",\n        \"                                      \",\n        \" fire, in end will world the say Some \",\n        \" ice. in say Some                     \",\n        \" desire of tasted I've what From      \",\n        \" fire. favor who those with hold I    \",\n        \"                                      \",\n        \" ... elided paragraph last ...        \",\n        \" Frost Robert ----------------------- \"};\n\n    public static void main(String[] args) {\n        for (String line : lines) {\n            String[] words = line.split(\"\\\\s\");\n            for (int i = words.length - 1; i >= 0; i--)\n                System.out.printf(\"%s \", words[i]);\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 161713, "name": "Reverse words in a string", "source": "Translate Swift to Python: import Foundation\n\n\nextension String {\n    var lines: [String] {\n        get {\n            return self.componentsSeparatedByCharactersInSet(NSCharacterSet.newlineCharacterSet())\n        }\n    }\n    var words: [String] {\n        get {\n            return self.componentsSeparatedByCharactersInSet(NSCharacterSet.whitespaceCharacterSet())\n        }\n    }\n}\n\nlet input = \"---------- Ice and Fire ------------\\n\\nfire, in end will world the say Some\\nice. in say Some\\ndesire of tasted I've what From\\nfire. favor who those with hold I\\n\\n... elided paragraph last ...\\n\\nFrost Robert -----------------------\\n\"\n\nlet output = input.lines.map { $0.words.reverse().joinWithSeparator(\" \") }.joinWithSeparator(\"\\n\")\n\nprint(output)\n", "target": " text = \n\nfor line in text.split('\\n'): print(' '.join(line.split()[::-1]))\n"}
{"id": 161905, "name": "Iterated digits squaring", "source": "Translate Swift to C#: import BigInt\n\nfunc is89(_ n: Int) -> Bool {\n  var n = n\n\n  while true {\n    var s = 0\n\n    repeat {\n      s += (n%10) * (n%10)\n      n /= 10\n    } while n > 0\n\n    if s == 89 {\n      return true\n    } else if s == 1 {\n      return false\n    }\n\n    n = s\n  }\n}\n\nfunc iterSquare(upToPower pow: Int) {\n  var sums = [BigInt](repeating: 0, count: pow * 81 + 1)\n  sums[0] = 1\n\n  for n in 1...pow {\n    var i = n * 81\n\n    while i > 0 {\n      for j in 1..<10 {\n        let s = j * j\n        guard s <= i else { break }\n        sums[i] += sums[i-s]\n      }\n\n      i -= 1\n    }\n\n    var count89 = BigInt(0)\n\n    for x in 1..<n*81 + 1 {\n      guard is89(x) else { continue }\n\n      count89 += sums[x]\n    }\n\n    print(\"1->10^\\(n): \\(count89)\")\n  }\n}\n\niterSquare(upToPower: 8)\n", "target": "using System;\npublic static class IteratedDigitsSquaring\n{\n    public static void Main() {\n        Console.WriteLine(Count89s(1_000_000));\n        Console.WriteLine(Count89s(100_000_000));\n    }\n\n    public static int Count89s(int limit) {\n        if (limit < 1) return 0;\n        int[] end = new int[Math.Min(limit, 9 * 9 * 9 + 2)];\n        int result = 0;\n\n        for (int i = 1; i < end.Length; i++) {\n            for (end[i] = i; end[i] != 1 && end[i] != 89; end[i] = SquareDigitSum(end[i])) { }\n            if (end[i] == 89) result++;\n        }\n        for (int i = end.Length; i < limit; i++) {\n            if (end[SquareDigitSum(i)] == 89) result++;\n        }\n        return result;\n\n        int SquareDigitSum(int n) {\n            int sum = 0;\n            while (n > 0) {\n                int digit = n % 10;\n                sum += digit * digit;\n                n /= 10;\n            }\n            return sum;\n        }\n    }\n\n}\n"}
{"id": 161907, "name": "Iterated digits squaring", "source": "Translate Swift to Java: import BigInt\n\nfunc is89(_ n: Int) -> Bool {\n  var n = n\n\n  while true {\n    var s = 0\n\n    repeat {\n      s += (n%10) * (n%10)\n      n /= 10\n    } while n > 0\n\n    if s == 89 {\n      return true\n    } else if s == 1 {\n      return false\n    }\n\n    n = s\n  }\n}\n\nfunc iterSquare(upToPower pow: Int) {\n  var sums = [BigInt](repeating: 0, count: pow * 81 + 1)\n  sums[0] = 1\n\n  for n in 1...pow {\n    var i = n * 81\n\n    while i > 0 {\n      for j in 1..<10 {\n        let s = j * j\n        guard s <= i else { break }\n        sums[i] += sums[i-s]\n      }\n\n      i -= 1\n    }\n\n    var count89 = BigInt(0)\n\n    for x in 1..<n*81 + 1 {\n      guard is89(x) else { continue }\n\n      count89 += sums[x]\n    }\n\n    print(\"1->10^\\(n): \\(count89)\")\n  }\n}\n\niterSquare(upToPower: 8)\n", "target": "import java.util.stream.IntStream;\n\npublic class IteratedDigitsSquaring {\n\n    public static void main(String[] args) {\n        long r = IntStream.range(1, 100_000_000)\n                .parallel()\n                .filter(n -> calc(n) == 89)\n                .count();\n        System.out.println(r);\n    }\n\n    private static int calc(int n) {\n        while (n != 89 && n != 1) {\n            int total = 0;\n            while (n > 0) {\n                total += Math.pow(n % 10, 2);\n                n /= 10;\n            }\n            n = total;\n        }\n        return n;\n    }\n}\n"}
{"id": 161908, "name": "Iterated digits squaring", "source": "Translate Swift to Python: import BigInt\n\nfunc is89(_ n: Int) -> Bool {\n  var n = n\n\n  while true {\n    var s = 0\n\n    repeat {\n      s += (n%10) * (n%10)\n      n /= 10\n    } while n > 0\n\n    if s == 89 {\n      return true\n    } else if s == 1 {\n      return false\n    }\n\n    n = s\n  }\n}\n\nfunc iterSquare(upToPower pow: Int) {\n  var sums = [BigInt](repeating: 0, count: pow * 81 + 1)\n  sums[0] = 1\n\n  for n in 1...pow {\n    var i = n * 81\n\n    while i > 0 {\n      for j in 1..<10 {\n        let s = j * j\n        guard s <= i else { break }\n        sums[i] += sums[i-s]\n      }\n\n      i -= 1\n    }\n\n    var count89 = BigInt(0)\n\n    for x in 1..<n*81 + 1 {\n      guard is89(x) else { continue }\n\n      count89 += sums[x]\n    }\n\n    print(\"1->10^\\(n): \\(count89)\")\n  }\n}\n\niterSquare(upToPower: 8)\n", "target": ">>> step = lambda x: sum(int(d) ** 2 for d in str(x))\n>>> iterate = lambda x: x if x in [1, 89] else iterate(step(x))\n>>> [iterate(x) for x in xrange(1, 20)]\n[1, 89, 89, 89, 89, 89, 1, 89, 89, 1, 89, 89, 1, 89, 89, 89, 89, 89, 1]\n"}
{"id": 162122, "name": "Middle three digits", "source": "Translate Swift to C#: var num:Int = \\\\enter your number here\nif num<0{num = -num}\nvar numArray:[Int]=[]\nwhile num>0{\n\tvar temp:Int=num%10\n\tnumArray.append(temp)\n\tnum=num/10\n}\nvar i:Int=numArray.count\nif i<3||i%2==0{\n\tprint(\"Invalid Input\")\n}\nelse{\n\ti=i/2\n\tprint(\"\\(numArray[i+1]),\\(numArray[i]),\\(numArray[i-1])\")\n}\n", "target": "using System;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string text = Math.Abs(int.Parse(Console.ReadLine())).ToString();\n            Console.WriteLine(text.Length < 2 || text.Length % 2 == 0 ? \"Error\" : text.Substring((text.Length - 3) / 2, 3));\n        }\n    }\n}\n"}
{"id": 162124, "name": "Middle three digits", "source": "Translate Swift to Java: var num:Int = \\\\enter your number here\nif num<0{num = -num}\nvar numArray:[Int]=[]\nwhile num>0{\n\tvar temp:Int=num%10\n\tnumArray.append(temp)\n\tnum=num/10\n}\nvar i:Int=numArray.count\nif i<3||i%2==0{\n\tprint(\"Invalid Input\")\n}\nelse{\n\ti=i/2\n\tprint(\"\\(numArray[i+1]),\\(numArray[i]),\\(numArray[i-1])\")\n}\n", "target": "public class MiddleThreeDigits {\n\n    public static void main(String[] args) {\n        final long[] passing = {123, 12345, 1234567, 987654321, 10001, -10001,\n            -123, -100, 100, -12345, Long.MIN_VALUE, Long.MAX_VALUE};\n\n        final int[] failing = {1, 2, -1, -10, 2002, -2002, 0, Integer.MIN_VALUE,\n            Integer.MAX_VALUE};\n\n        for (long n : passing)\n            System.out.printf(\"middleThreeDigits(%s): %s\\n\", n, middleThreeDigits(n));\n\n        for (int n : failing)\n            System.out.printf(\"middleThreeDigits(%s): %s\\n\", n, middleThreeDigits(n));\n    }\n\n    public static <T> String middleThreeDigits(T n) {\n        String s = String.valueOf(n);\n        if (s.charAt(0) == '-')\n            s = s.substring(1);\n        int len = s.length();\n        if (len < 3 || len % 2 == 0)\n            return \"Need odd and >= 3 digits\";\n        int mid = len / 2;\n        return s.substring(mid - 1, mid + 2);\n    }\n}\n"}
{"id": 162125, "name": "Middle three digits", "source": "Translate Swift to Python: var num:Int = \\\\enter your number here\nif num<0{num = -num}\nvar numArray:[Int]=[]\nwhile num>0{\n\tvar temp:Int=num%10\n\tnumArray.append(temp)\n\tnum=num/10\n}\nvar i:Int=numArray.count\nif i<3||i%2==0{\n\tprint(\"Invalid Input\")\n}\nelse{\n\ti=i/2\n\tprint(\"\\(numArray[i+1]),\\(numArray[i]),\\(numArray[i-1])\")\n}\n", "target": ">>> def middle_three_digits(i):\n\ts = str(abs(i))\n\tlength = len(s)\n\tassert length >= 3 and length % 2 == 1, \"Need odd and >= 3 digits\"\n\tmid = length // 2\n\treturn s[mid-1:mid+2]\n\n>>> passing = [123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345]\n>>> failing = [1, 2, -1, -10, 2002, -2002, 0]\n>>> for x in passing + failing:\n\ttry:\n\t\tanswer = middle_three_digits(x)\n\texcept AssertionError as error:\n\t\tanswer = error\n\tprint(\"middle_three_digits(%s) returned: %r\" % (x, answer))\n\n\t\nmiddle_three_digits(123) returned: '123'\nmiddle_three_digits(12345) returned: '234'\nmiddle_three_digits(1234567) returned: '345'\nmiddle_three_digits(987654321) returned: '654'\nmiddle_three_digits(10001) returned: '000'\nmiddle_three_digits(-10001) returned: '000'\nmiddle_three_digits(-123) returned: '123'\nmiddle_three_digits(-100) returned: '100'\nmiddle_three_digits(100) returned: '100'\nmiddle_three_digits(-12345) returned: '234'\nmiddle_three_digits(1) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(2) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(-1) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(-10) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(2002) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(-2002) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(0) returned: AssertionError('Need odd and >= 3 digits',)\n>>>\n"}
{"id": 162636, "name": "Narcissist", "source": "Translate Swift to C#: #! /usr/bin/swift\nimport Foundation\n\nlet script = CommandLine.arguments[0]\nprint(script)\nlet mytext = try? String.init(contentsOfFile: script, encoding: .utf8)\n\nvar enteredtext = readLine()\nif mytext == enteredtext {\n    print(\"Accept\")\n} else {\n    print(\"Reject\")\n}\n", "target": "using System;\nusing System.IO;\nusing System.Text;\nusing System.Text.RegularExpressions;\nnamespace Narcisisst\n{\n\tclass Program\n\t{\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tconst string path = @\"E:\\Narcisisst\";\n\t\t\tstring[] thisFile = Directory.GetFiles(path , \"Program.cs\");\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\n\t\t\t\tforeach (string readLine in File.ReadLines(thisFile[0]))\n\t\t\t\t{\n\t\t\t\t\tsb.Append(readLine);\n\t\t\t\t\tsb.Append(\"\\n\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\tConsole.WriteLine(sb);\n\t\t\tstring input =String.Empty;\n\t\t\t       \tinput = Console.ReadLine();\n\t\t\t       \tConsole.WriteLine((Regex.IsMatch(sb.ToString(),input))?\"accept\":\"reject\");\n\t\t\t       \tConsole.ReadKey();\n\t\t\t }\n\t}\n}\n"}
{"id": 162637, "name": "Narcissist", "source": "Translate Swift to Java: #! /usr/bin/swift\nimport Foundation\n\nlet script = CommandLine.arguments[0]\nprint(script)\nlet mytext = try? String.init(contentsOfFile: script, encoding: .utf8)\n\nvar enteredtext = readLine()\nif mytext == enteredtext {\n    print(\"Accept\")\n} else {\n    print(\"Reject\")\n}\n", "target": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Narcissist {\n    private static final String SOURCE = \"import java.io.BufferedReader;%nimport java.io.IOException;%nimport java.io.InputStreamReader;%n%npublic class Narcissist {%n    private static final String SOURCE = %c%s%c;%n    private static final char QUOTE = 0x22;%n%n    public static void main(String[] args) throws IOException {%n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));%n        StringBuilder sb = new StringBuilder();%n%n        while (true) {%n            String line = br.readLine();%n            if (null == line) break;%n            sb.append(line).append(System.lineSeparator());%n        }%n%n        String program = String.format(SOURCE, QUOTE, SOURCE, QUOTE, QUOTE, QUOTE, QUOTE, QUOTE);%n        if (program.equals(sb.toString())) {%n            System.out.println(%caccept%c);%n        } else {%n            System.out.println(%creject%c);%n        }%n    }%n}%n\";\n    private static final char QUOTE = 0x22;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb = new StringBuilder();\n\n        while (true) {\n            String line = br.readLine();\n            if (null == line) break;\n            sb.append(line).append(System.lineSeparator());\n        }\n\n        String program = String.format(SOURCE, QUOTE, SOURCE, QUOTE, QUOTE, QUOTE, QUOTE, QUOTE);\n        if (program.equals(sb.toString())) {\n            System.out.println(\"accept\");\n        } else {\n            System.out.println(\"reject\");\n        }\n    }\n}\n"}
{"id": 162638, "name": "Narcissist", "source": "Translate Swift to Python: #! /usr/bin/swift\nimport Foundation\n\nlet script = CommandLine.arguments[0]\nprint(script)\nlet mytext = try? String.init(contentsOfFile: script, encoding: .utf8)\n\nvar enteredtext = readLine()\nif mytext == enteredtext {\n    print(\"Accept\")\n} else {\n    print(\"Reject\")\n}\n", "target": "import sys\nwith open(sys.argv[0]) as quine:\n    code = raw_input(\"Enter source code: \")\n    if code == quine.read():\n        print(\"Accept\")\n    else:\n        print(\"Reject\")\n"}
{"id": 162813, "name": "Modular inverse", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func modInv(_ mod: Self) -> Self {\n    var (m, n) = (mod, self)\n    var (x, y) = (Self(0), Self(1))\n\n    while n != 0 {\n      (x, y) = (y, x - (m / n) * y)\n      (m, n) = (n, m % n)\n    }\n\n    while x < 0 {\n      x += mod\n    }\n\n    return x\n  }\n}\n\nprint(42.modInv(2017))\n", "target": "public class Program\n{\n    static void Main()\n    {\n        System.Console.WriteLine(42.ModInverse(2017));\n    }\n}\n\npublic static class IntExtensions\n{\n    public static int ModInverse(this int a, int m)\n    {\n        if (m == 1) return 0;\n        int m0 = m;\n        (int x, int y) = (1, 0);\n\n        while (a > 1) {\n            int q = a / m;\n            (a, m) = (m, a % m);\n            (x, y) = (y, x - q * y);\n        }\n        return x < 0 ? x + m0 : x;\n    }\n}\n"}
{"id": 162815, "name": "Modular inverse", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func modInv(_ mod: Self) -> Self {\n    var (m, n) = (mod, self)\n    var (x, y) = (Self(0), Self(1))\n\n    while n != 0 {\n      (x, y) = (y, x - (m / n) * y)\n      (m, n) = (n, m % n)\n    }\n\n    while x < 0 {\n      x += mod\n    }\n\n    return x\n  }\n}\n\nprint(42.modInv(2017))\n", "target": "System.out.println(BigInteger.valueOf(42).modInverse(BigInteger.valueOf(2017)));\n"}
{"id": 162816, "name": "Modular inverse", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func modInv(_ mod: Self) -> Self {\n    var (m, n) = (mod, self)\n    var (x, y) = (Self(0), Self(1))\n\n    while n != 0 {\n      (x, y) = (y, x - (m / n) * y)\n      (m, n) = (n, m % n)\n    }\n\n    while x < 0 {\n      x += mod\n    }\n\n    return x\n  }\n}\n\nprint(42.modInv(2017))\n", "target": ">>> def extended_gcd(aa, bb):\n    lastremainder, remainder = abs(aa), abs(bb)\n    x, lastx, y, lasty = 0, 1, 1, 0\n    while remainder:\n        lastremainder, (quotient, remainder) = remainder, divmod(lastremainder, remainder)\n        x, lastx = lastx - quotient*x, x\n        y, lasty = lasty - quotient*y, y\n    return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1)\n\n>>> def modinv(a, m):\n\tg, x, y = extended_gcd(a, m)\n\tif g != 1:\n\t\traise ValueError\n\treturn x % m\n\n>>> modinv(42, 2017)\n1969\n>>>\n"}
{"id": 162986, "name": "Kernighans large earthquake problem", "source": "Translate Swift to C#: import Foundation\n\nguard let path = Array(CommandLine.arguments.dropFirst()).first else {\n  fatalError()\n}\n\nlet fileData = FileManager.default.contents(atPath: path)!\nlet eventData = String(data: fileData, encoding: .utf8)!\n\nfor line in eventData.components(separatedBy: \"\\n\") {\n  guard let lastSpace = line.lastIndex(of: \" \"), \n        line.index(after: lastSpace) != line.endIndex, \n        let magnitude = Double(String(line[line.index(after: lastSpace)])),\n        magnitude > 6 else { \n    continue\n  }\n\n  print(line)\n}\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    static void Main() {\n        foreach (var earthquake in LargeEarthquakes(\"data.txt\", 6))\n            Console.WriteLine(string.Join(\" \", earthquake));\n    }\n\n    static IEnumerable<string[]> LargeEarthquakes(string filename, double limit) =>\n        from line in File.ReadLines(filename)\n        let parts = line.Split(default(char[]), StringSplitOptions.RemoveEmptyEntries)\n        where double.Parse(parts[2]) > limit\n        select parts;\n\n}\n"}
{"id": 162988, "name": "Kernighans large earthquake problem", "source": "Translate Swift to Java: import Foundation\n\nguard let path = Array(CommandLine.arguments.dropFirst()).first else {\n  fatalError()\n}\n\nlet fileData = FileManager.default.contents(atPath: path)!\nlet eventData = String(data: fileData, encoding: .utf8)!\n\nfor line in eventData.components(separatedBy: \"\\n\") {\n  guard let lastSpace = line.lastIndex(of: \" \"), \n        line.index(after: lastSpace) != line.endIndex, \n        let magnitude = Double(String(line[line.index(after: lastSpace)])),\n        magnitude > 6 else { \n    continue\n  }\n\n  print(line)\n}\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class KernighansLargeEarthquakeProblem {\n\n    public static void main(String[] args) throws Exception {\n        try (BufferedReader reader  = new BufferedReader(new FileReader(\"data.txt\")); ) {\n            String inLine = null;\n            while ( (inLine = reader.readLine()) != null ) {\n                String[] split = inLine.split(\"\\\\s+\");\n                double magnitude = Double.parseDouble(split[2]);\n                if ( magnitude > 6 ) {\n                    System.out.println(inLine);\n                }\n            }\n        }\n\n    }\n\n}\n"}
{"id": 162989, "name": "Kernighans large earthquake problem", "source": "Translate Swift to Python: import Foundation\n\nguard let path = Array(CommandLine.arguments.dropFirst()).first else {\n  fatalError()\n}\n\nlet fileData = FileManager.default.contents(atPath: path)!\nlet eventData = String(data: fileData, encoding: .utf8)!\n\nfor line in eventData.components(separatedBy: \"\\n\") {\n  guard let lastSpace = line.lastIndex(of: \" \"), \n        line.index(after: lastSpace) != line.endIndex, \n        let magnitude = Double(String(line[line.index(after: lastSpace)])),\n        magnitude > 6 else { \n    continue\n  }\n\n  print(line)\n}\n", "target": "python -c '\nwith open(\"data.txt\") as f:\n    for ln in f:\n        if float(ln.strip().split()[2]) > 6:\n            print(ln.strip())'\n"}
{"id": 163129, "name": "UTF-8 encode and decode", "source": "Translate Swift to C#: import Foundation\n\nfunc encode(_ scalar: UnicodeScalar) -> Data {\n  return Data(String(scalar).utf8)\n}\n\nfunc decode(_ data: Data) -> UnicodeScalar? {\n  guard let string = String(data: data, encoding: .utf8) else {\n    assertionFailure(\"Failed to convert data to a valid String\")\n    return nil\n  }\n  assert(string.unicodeScalars.count == 1, \"Data should contain one scalar!\")\n  return string.unicodeScalars.first\n}\n\nfor scalar in \"A\u00f6\u0416\u20ac\ud834\udd1e\".unicodeScalars {\n  let bytes = encode(scalar)\n  let formattedBytes = bytes.map({ String($0, radix: 16)}).joined(separator: \" \")\n  let decoded = decode(bytes)!\n  print(\"character: \\(decoded), code point: U+\\(String(scalar.value, radix: 16)), \\tutf-8: \\(formattedBytes)\")\n}\n", "target": "using System;\nusing System.Text;\n\nnamespace Rosetta\n{\n    class Program\n    {\n        static byte[] MyEncoder(int codepoint) => Encoding.UTF8.GetBytes(char.ConvertFromUtf32(codepoint));\n        static string MyDecoder(byte[] utf8bytes) => Encoding.UTF8.GetString(utf8bytes);\n        static void Main(string[] args)\n        {\n            Console.OutputEncoding = Encoding.UTF8;  \n            foreach (int unicodePoint in new int[] {  0x0041, 0x00F6, 0x0416, 0x20AC, 0x1D11E})\n            {\n                byte[] asUtf8bytes = MyEncoder(unicodePoint);\n                string theCharacter = MyDecoder(asUtf8bytes);\n                Console.WriteLine(\"{0,8} {1,5}     {2,-15}\", unicodePoint.ToString(\"X4\"), theCharacter, BitConverter.ToString(asUtf8bytes));\n            }\n        }\n    }\n}\n\n"}
{"id": 163130, "name": "UTF-8 encode and decode", "source": "Translate Swift to Java: import Foundation\n\nfunc encode(_ scalar: UnicodeScalar) -> Data {\n  return Data(String(scalar).utf8)\n}\n\nfunc decode(_ data: Data) -> UnicodeScalar? {\n  guard let string = String(data: data, encoding: .utf8) else {\n    assertionFailure(\"Failed to convert data to a valid String\")\n    return nil\n  }\n  assert(string.unicodeScalars.count == 1, \"Data should contain one scalar!\")\n  return string.unicodeScalars.first\n}\n\nfor scalar in \"A\u00f6\u0416\u20ac\ud834\udd1e\".unicodeScalars {\n  let bytes = encode(scalar)\n  let formattedBytes = bytes.map({ String($0, radix: 16)}).joined(separator: \" \")\n  let decoded = decode(bytes)!\n  print(\"character: \\(decoded), code point: U+\\(String(scalar.value, radix: 16)), \\tutf-8: \\(formattedBytes)\")\n}\n", "target": "import java.nio.charset.StandardCharsets;\nimport java.util.Formatter;\n\npublic class UTF8EncodeDecode {\n\n    public static byte[] utf8encode(int codepoint) {\n        return new String(new int[]{codepoint}, 0, 1).getBytes(StandardCharsets.UTF_8);\n    }\n\n    public static int utf8decode(byte[] bytes) {\n        return new String(bytes, StandardCharsets.UTF_8).codePointAt(0);\n    }\n\n    public static void main(String[] args) {\n        System.out.printf(\"%-7s\u00a0%-43s %7s\\t%s\\t%7s%n\",\n                \"Char\", \"Name\", \"Unicode\", \"UTF-8 encoded\", \"Decoded\");\n\n        for (int codepoint : new int[]{0x0041, 0x00F6, 0x0416, 0x20AC, 0x1D11E}) {\n            byte[] encoded = utf8encode(codepoint);\n            Formatter formatter = new Formatter();\n            for (byte b : encoded) {\n                formatter.format(\"%02X \", b);\n            }\n            String encodedHex = formatter.toString();\n            int decoded = utf8decode(encoded);\n            System.out.printf(\"%-7c\u00a0%-43s U+%04X\\t%-12s\\tU+%04X%n\",\n                    codepoint, Character.getName(codepoint), codepoint, encodedHex, decoded);\n        }\n    }\n}\n"}
{"id": 163131, "name": "UTF-8 encode and decode", "source": "Translate Swift to Python: import Foundation\n\nfunc encode(_ scalar: UnicodeScalar) -> Data {\n  return Data(String(scalar).utf8)\n}\n\nfunc decode(_ data: Data) -> UnicodeScalar? {\n  guard let string = String(data: data, encoding: .utf8) else {\n    assertionFailure(\"Failed to convert data to a valid String\")\n    return nil\n  }\n  assert(string.unicodeScalars.count == 1, \"Data should contain one scalar!\")\n  return string.unicodeScalars.first\n}\n\nfor scalar in \"A\u00f6\u0416\u20ac\ud834\udd1e\".unicodeScalars {\n  let bytes = encode(scalar)\n  let formattedBytes = bytes.map({ String($0, radix: 16)}).joined(separator: \" \")\n  let decoded = decode(bytes)!\n  print(\"character: \\(decoded), code point: U+\\(String(scalar.value, radix: 16)), \\tutf-8: \\(formattedBytes)\")\n}\n", "target": "\nfrom unicodedata import name\n\n\ndef unicode_code(ch):\n    return 'U+{:04x}'.format(ord(ch))\n\n\ndef utf8hex(ch):\n    return \" \".join([hex(c)[2:] for c in ch.encode('utf8')]).upper()\n\n\nif __name__ == \"__main__\":\n    print('{:<11} {:<36} {:<15} {:<15}'.format('Character', 'Name', 'Unicode', 'UTF-8 encoding (hex)'))\n    chars = ['A', '\u00f6', '\u0416', '\u20ac', '\ud834\udd1e']\n    for char in chars:\n        print('{:<11} {:<36} {:<15} {:<15}'.format(char, name(char), unicode_code(char), utf8hex(char)))\n"}
{"id": 163577, "name": "Stern-Brocot sequence", "source": "Translate Swift to C#: struct SternBrocot: Sequence, IteratorProtocol {\n  private var seq = [1, 1]\n\n  mutating func next() -> Int? {\n    seq += [seq[0] + seq[1], seq[1]]\n\n    return seq.removeFirst()\n  }\n}\n\nfunc gcd<T: BinaryInteger>(_ a: T, _ b: T) -> T {\n  guard a != 0 else {\n    return b\n  }\n\n  return a < b ? gcd(b % a, a) : gcd(a % b, b)\n}\n\nprint(\"First 15: \\(Array(SternBrocot().prefix(15)))\")\n\nvar found = Set<Int>()\n\nfor (i, val) in SternBrocot().enumerated() {\n  switch val {\n  case 1...10 where !found.contains(val), 100 where !found.contains(val):\n    print(\"First \\(val) at \\(i + 1)\")\n    found.insert(val)\n  case _:\n    continue\n  }\n\n  if found.count == 11 {\n    break\n  }\n}\n\nlet firstThousand = SternBrocot().prefix(1000)\nlet gcdIsOne = zip(firstThousand, firstThousand.dropFirst()).allSatisfy({ gcd($0.0, $0.1) == 1 })\n\nprint(\"GCDs of all two consecutive members are \\(gcdIsOne ? \"\" : \"not\")one\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static List<int> l = new List<int>() { 1, 1 };\n\n    static int gcd(int a, int b) {\n        return a > 0 ? a < b ? gcd(b % a, a) : gcd(a % b, b) : b; }\n\n    static void Main(string[] args) {\n        int max = 1000; int take = 15; int i = 1;\n        int[] selection = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100 };\n        do { l.AddRange(new List<int>() { l[i] + l[i - 1], l[i] }); i += 1; }\n        while (l.Count < max || l[l.Count - 2] != selection.Last());\n        Console.Write(\"The first {0} items In the Stern-Brocot sequence: \", take);\n        Console.WriteLine(\"{0}\\n\", string.Join(\", \", l.Take(take)));\n        Console.WriteLine(\"The locations of where the selected numbers (1-to-10, & 100) first appear:\");\n        foreach (int ii in selection) {\n            int j = l.FindIndex(x => x == ii) + 1; Console.WriteLine(\"{0,3}: {1:n0}\", ii, j); }\n        Console.WriteLine(); bool good = true;\n        for (i = 1; i <= max; i++) { if (gcd(l[i], l[i - 1]) != 1) { good = false; break; } }\n        Console.WriteLine(\"The greatest common divisor of all the two consecutive items of the\" + \n                          \" series up to the {0}th item is {1}always one.\", max, good ? \"\" : \"not \");\n    }\n}\n"}
{"id": 163579, "name": "Stern-Brocot sequence", "source": "Translate Swift to Java: struct SternBrocot: Sequence, IteratorProtocol {\n  private var seq = [1, 1]\n\n  mutating func next() -> Int? {\n    seq += [seq[0] + seq[1], seq[1]]\n\n    return seq.removeFirst()\n  }\n}\n\nfunc gcd<T: BinaryInteger>(_ a: T, _ b: T) -> T {\n  guard a != 0 else {\n    return b\n  }\n\n  return a < b ? gcd(b % a, a) : gcd(a % b, b)\n}\n\nprint(\"First 15: \\(Array(SternBrocot().prefix(15)))\")\n\nvar found = Set<Int>()\n\nfor (i, val) in SternBrocot().enumerated() {\n  switch val {\n  case 1...10 where !found.contains(val), 100 where !found.contains(val):\n    print(\"First \\(val) at \\(i + 1)\")\n    found.insert(val)\n  case _:\n    continue\n  }\n\n  if found.count == 11 {\n    break\n  }\n}\n\nlet firstThousand = SternBrocot().prefix(1000)\nlet gcdIsOne = zip(firstThousand, firstThousand.dropFirst()).allSatisfy({ gcd($0.0, $0.1) == 1 })\n\nprint(\"GCDs of all two consecutive members are \\(gcdIsOne ? \"\" : \"not\")one\")\n", "target": "import java.math.BigInteger;\nimport java.util.LinkedList;\n\npublic class SternBrocot {\n\tstatic LinkedList<Integer> sequence = new LinkedList<Integer>(){{\n\t\tadd(1); add(1);\n\t}};\n\t\n\tprivate static void genSeq(int n){\n\t\tfor(int conIdx = 1; sequence.size() < n; conIdx++){\n\t\t\tint consider = sequence.get(conIdx);\n\t\t\tint pre = sequence.get(conIdx - 1);\n\t\t\tsequence.add(consider + pre);\n\t\t\tsequence.add(consider);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tgenSeq(1200);\n\t\tSystem.out.println(\"The first 15 elements are: \" + sequence.subList(0, 15));\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"First occurrence of \" + i + \" is at \" + (sequence.indexOf(i) + 1));\n\t\t}\n\t\t\n\t\tSystem.out.println(\"First occurrence of 100 is at \" + (sequence.indexOf(100) + 1));\n\t\t\n\t\tboolean failure = false;\n\t\tfor(int i = 0; i < 999; i++){\n\t\t\tfailure |= !BigInteger.valueOf(sequence.get(i)).gcd(BigInteger.valueOf(sequence.get(i + 1))).equals(BigInteger.ONE);\n\t\t}\n\t\tSystem.out.println(\"All GCDs are\" + (failure ? \" not\" : \"\") + \" 1\");\n\t}\n}\n"}
{"id": 163580, "name": "Stern-Brocot sequence", "source": "Translate Swift to Python: struct SternBrocot: Sequence, IteratorProtocol {\n  private var seq = [1, 1]\n\n  mutating func next() -> Int? {\n    seq += [seq[0] + seq[1], seq[1]]\n\n    return seq.removeFirst()\n  }\n}\n\nfunc gcd<T: BinaryInteger>(_ a: T, _ b: T) -> T {\n  guard a != 0 else {\n    return b\n  }\n\n  return a < b ? gcd(b % a, a) : gcd(a % b, b)\n}\n\nprint(\"First 15: \\(Array(SternBrocot().prefix(15)))\")\n\nvar found = Set<Int>()\n\nfor (i, val) in SternBrocot().enumerated() {\n  switch val {\n  case 1...10 where !found.contains(val), 100 where !found.contains(val):\n    print(\"First \\(val) at \\(i + 1)\")\n    found.insert(val)\n  case _:\n    continue\n  }\n\n  if found.count == 11 {\n    break\n  }\n}\n\nlet firstThousand = SternBrocot().prefix(1000)\nlet gcdIsOne = zip(firstThousand, firstThousand.dropFirst()).allSatisfy({ gcd($0.0, $0.1) == 1 })\n\nprint(\"GCDs of all two consecutive members are \\(gcdIsOne ? \"\" : \"not\")one\")\n", "target": "def stern_brocot(predicate=lambda series: len(series) < 20):\n    \n\n    sb, i = [1, 1], 0\n    while predicate(sb):\n        sb += [sum(sb[i:i + 2]), sb[i + 1]]\n        i += 1\n    return sb\n\n\nif __name__ == '__main__':\n    from fractions import gcd\n\n    n_first = 15\n    print('The first %i values:\\n  ' % n_first,\n          stern_brocot(lambda series: len(series) < n_first)[:n_first])\n    print()\n    n_max = 10\n    for n_occur in list(range(1, n_max + 1)) + [100]:\n        print('1-based index of the first occurrence of %3i in the series:' % n_occur,\n              stern_brocot(lambda series: n_occur not in series).index(n_occur) + 1)\n              \n              \n\n    print()\n    n_gcd = 1000\n    s = stern_brocot(lambda series: len(series) < n_gcd)[:n_gcd]\n    assert all(gcd(prev, this) == 1\n               for prev, this in zip(s, s[1:])), 'A fraction from adjacent terms is reducible'\n"}
{"id": 163808, "name": "Temperature conversion", "source": "Translate Swift to C#: func KtoC(kelvin : Double)->Double{\n    \n    return kelvin-273.15\n}\n\nfunc KtoF(kelvin : Double)->Double{\n    \n    return ((kelvin-273.15)*1.8)+32\n}\n\nfunc KtoR(kelvin : Double)->Double{\n    \n    return ((kelvin-273.15)*1.8)+491.67\n}\n\nvar k\nprint(\"\\(k) Kelvin\")\nvar c=KtoC(kelvin : k)\nprint(\"\\(c) Celsius\")\nvar f=KtoF(kelvin : k)\nprint(\"\\(f) Fahrenheit\")\nvar r=KtoR(kelvin : k)\nprint(\"\\(r) Rankine\")\n", "target": "using System;\n\nnamespace TemperatureConversion\n{\n    class Program\n    {\n        static Func<double, double> ConvertKelvinToFahrenheit = x => (x * 1.8) - 459.67;\n        static Func<double, double> ConvertKelvinToRankine = x => x * 1.8;\n        static Func<double, double> ConvertKelvinToCelsius = x => x = 273.13;\n\n        static void Main(string[] args)\n        {\n            Console.Write(\"Enter a Kelvin Temperature: \");\n            string inputVal = Console.ReadLine();\n            double kelvinTemp = 0f;\n\n            if (double.TryParse(inputVal, out kelvinTemp))\n            {\n                Console.WriteLine(string.Format(\"Kelvin: {0}\", kelvinTemp));\n                Console.WriteLine(string.Format(\"Fahrenheit: {0}\", ConvertKelvinToFahrenheit(kelvinTemp)));\n                Console.WriteLine(string.Format(\"Rankine: {0}\", ConvertKelvinToRankine(kelvinTemp)));\n                Console.WriteLine(string.Format(\"Celsius: {0}\", ConvertKelvinToCelsius(kelvinTemp)));\n                Console.ReadKey();\n            }\n            else\n            {\n                Console.WriteLine(\"Invalid input value: \" + inputVal);\n            }\n        }\n    }\n}\n"}
{"id": 163810, "name": "Temperature conversion", "source": "Translate Swift to Java: func KtoC(kelvin : Double)->Double{\n    \n    return kelvin-273.15\n}\n\nfunc KtoF(kelvin : Double)->Double{\n    \n    return ((kelvin-273.15)*1.8)+32\n}\n\nfunc KtoR(kelvin : Double)->Double{\n    \n    return ((kelvin-273.15)*1.8)+491.67\n}\n\nvar k\nprint(\"\\(k) Kelvin\")\nvar c=KtoC(kelvin : k)\nprint(\"\\(c) Celsius\")\nvar f=KtoF(kelvin : k)\nprint(\"\\(f) Fahrenheit\")\nvar r=KtoR(kelvin : k)\nprint(\"\\(r) Rankine\")\n", "target": "public class TemperatureConversion {\n    public static void main(String args[]) {\n        if (args.length == 1) {\n            try {\n                double kelvin = Double.parseDouble(args[0]);\n                if (kelvin >= 0) {\n                    System.out.printf(\"K  %2.2f\\n\", kelvin);\n                    System.out.printf(\"C  %2.2f\\n\", kelvinToCelsius(kelvin));\n                    System.out.printf(\"F  %2.2f\\n\", kelvinToFahrenheit(kelvin));\n                    System.out.printf(\"R  %2.2f\\n\", kelvinToRankine(kelvin));\n                } else {\n                    System.out.printf(\"%2.2f K is below absolute zero\", kelvin);\n                }\n            } catch (NumberFormatException e) {\n                System.out.println(e);\n            }\n        }\n    }\n\n    public static double kelvinToCelsius(double k) {\n        return k - 273.15;\n    }\n\n    public static double kelvinToFahrenheit(double k) {\n        return k * 1.8 - 459.67;\n    }\n\n    public static double kelvinToRankine(double k) {\n        return k * 1.8;\n    }\n}\n"}
{"id": 163811, "name": "Temperature conversion", "source": "Translate Swift to Python: func KtoC(kelvin : Double)->Double{\n    \n    return kelvin-273.15\n}\n\nfunc KtoF(kelvin : Double)->Double{\n    \n    return ((kelvin-273.15)*1.8)+32\n}\n\nfunc KtoR(kelvin : Double)->Double{\n    \n    return ((kelvin-273.15)*1.8)+491.67\n}\n\nvar k\nprint(\"\\(k) Kelvin\")\nvar c=KtoC(kelvin : k)\nprint(\"\\(c) Celsius\")\nvar f=KtoF(kelvin : k)\nprint(\"\\(f) Fahrenheit\")\nvar r=KtoR(kelvin : k)\nprint(\"\\(r) Rankine\")\n", "target": ">>> while True:\n    k = float(input('K\u00a0? '))\n    print(\"%g Kelvin = %g Celsius = %g Fahrenheit = %g Rankine degrees.\"\n          % (k, k - 273.15, k * 1.8 - 459.67, k * 1.8))\n\n    \nK ? 21.0\n21 Kelvin = -252.15 Celsius = -421.87 Fahrenheit = 37.8 Rankine degrees.\nK ? 222.2\n222.2 Kelvin = -50.95 Celsius = -59.71 Fahrenheit = 399.96 Rankine degrees.\nK ?\n"}
{"id": 164259, "name": "Square but not cube", "source": "Translate Swift to C#: var s = 1, c = 1, cube = 1, n = 0\nwhile n < 30 {\n    let square = s * s\n    while cube < square {\n        c += 1\n        cube = c * c * c\n    }\n    if cube == square {\n        print(\"\\(square) is a square and a cube.\")\n    } else {\n        print(square)\n        n += 1\n    }\n    s += 1\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Linq.Enumerable;\n\npublic static class SquareButNotCube\n{\n    public static void Main() {\n        var squares = from i in Integers() select i * i;\n        var cubes = from i in Integers() select i * i * i;\n\n        foreach (var x in Merge().Take(33)) {\n            WriteLine(x.isCube ? x.n + \" (also cube)\" : x.n + \"\");\n        }\n        \n        IEnumerable<int> Integers() {\n            for (int i = 1; ;i++) yield return i;\n        }\n\n        IEnumerable<(int n, bool isCube)> Merge() {\n            using (var s = squares.GetEnumerator())\n            using (var c = cubes.GetEnumerator()) {\n                s.MoveNext();\n                c.MoveNext();\n                while (true) {\n                    if (s.Current < c.Current) {\n                        yield return (s.Current, false);\n                        s.MoveNext();\n                    } else if (s.Current == c.Current) {\n                        yield return (s.Current, true);\n                        s.MoveNext();\n                        c.MoveNext();\n                    } else {\n                        c.MoveNext();\n                    }\n                }\n            }\n        }\n\n    }\n}\n"}
{"id": 164261, "name": "Square but not cube", "source": "Translate Swift to Java: var s = 1, c = 1, cube = 1, n = 0\nwhile n < 30 {\n    let square = s * s\n    while cube < square {\n        c += 1\n        cube = c * c * c\n    }\n    if cube == square {\n        print(\"\\(square) is a square and a cube.\")\n    } else {\n        print(square)\n        n += 1\n    }\n    s += 1\n}\n", "target": "public class SquaresCubes {\n    public static boolean isPerfectCube(long n) {\n        long c = (long)Math.cbrt((double)n);\n        return ((c * c * c) == n);\n    }\n    \n    public static void main(String... args) {\n        long n = 1;\n        int squareOnlyCount = 0;\n        int squareCubeCount = 0;\n        while ((squareOnlyCount < 30) || (squareCubeCount < 3)) {\n            long sq = n * n;\n            if (isPerfectCube(sq)) {\n                squareCubeCount++;\n                System.out.println(\"Square and cube: \" + sq);\n            }\n            else {\n                squareOnlyCount++;\n                System.out.println(\"Square: \" + sq);\n            }\n            n++;\n        }\n    }\n}\n"}
{"id": 164262, "name": "Square but not cube", "source": "Translate Swift to Python: var s = 1, c = 1, cube = 1, n = 0\nwhile n < 30 {\n    let square = s * s\n    while cube < square {\n        c += 1\n        cube = c * c * c\n    }\n    if cube == square {\n        print(\"\\(square) is a square and a cube.\")\n    } else {\n        print(square)\n        n += 1\n    }\n    s += 1\n}\n", "target": "\ndef nonCubeSquares(n):\n    upto = enumFromTo(1)\n    ns = upto(n)\n    setCubes = set(x ** 3 for x in ns)\n    ms = upto(n + len(set(x * x for x in ns).intersection(\n        setCubes\n    )))\n    return list(tuple([x * x, x in setCubes]) for x in ms)\n\n\n\ndef squareListing(xs):\n    justifyIdx = justifyRight(len(str(1 + len(xs))))(' ')\n    justifySqr = justifyRight(1 + len(str(xs[-1][0])))(' ')\n    return list(\n        '(' + str(1 + idx) + '^2 = ' + str(n) +\n        ' = ' + str(round(n ** (1 / 3))) + '^3)' if bln else (\n            justifyIdx(1 + idx) + ' ->' +\n            justifySqr(n)\n        )\n        for idx, (n, bln) in enumerate(xs)\n    )\n\n\ndef main():\n    print(\n        unlines(\n            squareListing(\n                nonCubeSquares(30)\n            )\n        )\n    )\n\n\n\n\n\ndef enumFromTo(m):\n    return lambda n: list(range(m, 1 + n))\n\n\n\ndef justifyRight(n):\n    return lambda cFiller: lambda a: (\n        ((n * cFiller) + str(a))[-n:]\n    )\n\n\n\ndef unlines(xs):\n    return '\\n'.join(xs)\n\n\nmain()\n"}
{"id": 164446, "name": "Egyptian division", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func egyptianDivide(by divisor: Self) -> (quo: Self, rem: Self) {\n    let table =\n      (0...).lazy\n        .map({i -> (Self, Self) in\n          let power = Self(2).power(Self(i))\n\n          return (power, power * divisor)\n        })\n        .prefix(while: { $0.1 <= self })\n        .reversed()\n\n    let (answer, acc) = table.reduce((Self(0), Self(0)), {cur, row in\n      let ((ans, acc), (power, doubling)) = (cur, row)\n\n      return acc + doubling <= self ? (ans + power, doubling + acc) : cur\n    })\n\n    return (answer, Self((acc - self).magnitude))\n  }\n\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nlet dividend = 580\nlet divisor = 34\nlet (quo, rem) = dividend.egyptianDivide(by: divisor)\n\nprint(\"\\(dividend) divided by \\(divisor) = \\(quo) rem \\(rem)\")\n", "target": "using System;\nusing System.Collections;\n\nnamespace Egyptian_division\n{\n\tclass Program\n\t{\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\" Egyptian division \");\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\" Enter value of dividend\u00a0: \");\n\t\t\tint dividend = int.Parse(Console.ReadLine());\n\t\t\t     \n\t\t\tConsole.Write(\" Enter value of divisor\u00a0: \");\n\t\t\tint divisor = int.Parse(Console.ReadLine());\n\t\t\t                         \n\t\t\tDivide(dividend, divisor);\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tstatic void Divide(int dividend, int divisor)\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tint result   = 0;\n\t\t\tint reminder = 0;\n\t\t\t\n\t\t\tint powers_of_two = 0;\n\t\t\tint doublings \t  = 0;\n\t\t\t\n\t\t\tint answer \t= 0;\n\t\t\tint accumulator = 0;\n\t\t\t\n\t\t\tint two = 2;\n\t\t\tint pow = 0;\n\t\t\tint row = 0;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tArrayList table_powers_of_two = new ArrayList();\n\t\t\tArrayList table_doublings     = new ArrayList();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(\"                           \");\n\t\t\tConsole.WriteLine(\" powers_of_2     doublings \");\n\t\t\tConsole.WriteLine(\"                           \");\n\t\t\t\n\t\t\t\n\t\t\tpowers_of_two = 1;\n\t\t\tdoublings = divisor;\n\t\t\twhile( doublings <= dividend )\n\t\t\t{\n\t\t\t\t\n\t\t\t\ttable_powers_of_two.Add( powers_of_two );\n\t\t\t\ttable_doublings.Add( doublings );\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tConsole.WriteLine(\"{0,8}{1,16}\",powers_of_two, doublings);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tpow++;\n\t\t\t\t\n\t\t\t\tpowers_of_two = (int)Math.Pow( two, pow );\n\t\t\t\tdoublings = powers_of_two * divisor;\n\t\t\t}\n\t\t\tConsole.WriteLine(\"                           \");\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\trow = pow - 1;\n\t\t\tConsole.WriteLine(\"                                                 \");\n\t\t\tConsole.WriteLine(\" powers_of_2     doublings   answer   accumulator\");\n\t\t\tConsole.WriteLine(\"                                                 \");\n\t\t\tConsole.SetCursorPosition(Console.CursorLeft, Console.CursorTop + row);\n\t\t\t\n\t\t\tpow--;\n\t\t\twhile( pow >= 0 && accumulator < dividend )\n\t\t\t{\n\t\t\t\t\n\t\t\t\tdoublings = int.Parse(table_doublings[pow].ToString());\n\t\t\t\tpowers_of_two = int.Parse(table_powers_of_two[pow].ToString());\n\t\t\t\t\n\t\t\t\tif(accumulator + int.Parse(table_doublings[pow].ToString()) <= dividend )\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\taccumulator += doublings;\n\t\t\t\t\tanswer += powers_of_two;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tConsole.ForegroundColor = ConsoleColor.Green;\n\t\t\t\t\tConsole.Write(\"{0,8}{1,16}\",powers_of_two, doublings);\n\t\t\t\t\tConsole.ForegroundColor = ConsoleColor.Green;\n\t\t\t\t\tConsole.WriteLine(\"{0,10}{1,12}\", answer, accumulator);\n\t\t\t\t\tConsole.SetCursorPosition(Console.CursorLeft, Console.CursorTop - 2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tConsole.ForegroundColor = ConsoleColor.DarkGray;\n\t\t\t\t\tConsole.Write(\"{0,8}{1,16}\",powers_of_two, doublings);\n\t\t\t\t\tConsole.ForegroundColor = ConsoleColor.Gray;\n\t\t\t\t\tConsole.WriteLine(\"{0,10}{1,12}\", answer, accumulator);\n\t\t\t\t\tConsole.SetCursorPosition(Console.CursorLeft, Console.CursorTop - 2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tpow--;\n\t\t\t}\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.SetCursorPosition(Console.CursorLeft, Console.CursorTop + row + 2);\n\t\t\tConsole.ResetColor();\n\t\t\t\n\t\t\t\n\t\t\tresult = answer;\n\t\t\tif( accumulator < dividend )\n\t\t\t{\n\t\t\t\treminder = dividend - accumulator;\n\t\t\t\t\n\t\t\t\tConsole.WriteLine(\" So \" + dividend +\n\t\t\t\t                  \" divided by \" + divisor +\n\t\t\t\t                  \" using the Egyptian method is \\n \" + result +\n\t\t\t\t                  \" remainder (\" + dividend + \" - \" + accumulator +\n\t\t\t\t                  \") or \" + reminder);\n\t\t\t\tConsole.WriteLine();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treminder = 0;\n\t\t\t\t\n\t\t\t\tConsole.WriteLine(\" So \" + dividend +\n\t\t\t\t                  \" divided by \" + divisor +\n\t\t\t\t                  \" using the Egyptian method is \\n \" + result +\n\t\t\t\t                  \" remainder \" + reminder);\n\t\t\t\tConsole.WriteLine();\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 164448, "name": "Egyptian division", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func egyptianDivide(by divisor: Self) -> (quo: Self, rem: Self) {\n    let table =\n      (0...).lazy\n        .map({i -> (Self, Self) in\n          let power = Self(2).power(Self(i))\n\n          return (power, power * divisor)\n        })\n        .prefix(while: { $0.1 <= self })\n        .reversed()\n\n    let (answer, acc) = table.reduce((Self(0), Self(0)), {cur, row in\n      let ((ans, acc), (power, doubling)) = (cur, row)\n\n      return acc + doubling <= self ? (ans + power, doubling + acc) : cur\n    })\n\n    return (answer, Self((acc - self).magnitude))\n  }\n\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nlet dividend = 580\nlet divisor = 34\nlet (quo, rem) = dividend.egyptianDivide(by: divisor)\n\nprint(\"\\(dividend) divided by \\(divisor) = \\(quo) rem \\(rem)\")\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class EgyptianDivision {\n\n    \n    public static void main(String[] args) {\n\n        divide(580, 34);\n\n    }\n\n    \n    public static void divide(int dividend, int divisor) {\n\n        List<Integer> powersOf2 = new ArrayList<>();\n        List<Integer> doublings = new ArrayList<>();\n\n        \n        int line = 0;\n        while ((Math.pow(2, line) * divisor) <= dividend) { \n            int powerOf2 = (int) Math.pow(2, line);\n            powersOf2.add(powerOf2);\n            doublings.add(powerOf2 * divisor);\n            line++;\n        }\n\n        int answer = 0;\n        int accumulator = 0;\n\n        \n        for (int i = powersOf2.size() - 1; i >= 0; i--) {\n            if (accumulator + doublings.get(i) <= dividend) {\n                accumulator += doublings.get(i);\n                answer += powersOf2.get(i);\n            }\n        }\n\n        System.out.println(String.format(\"%d, remainder %d\", answer, dividend - accumulator));\n    }\n}\n"}
{"id": 164449, "name": "Egyptian division", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func egyptianDivide(by divisor: Self) -> (quo: Self, rem: Self) {\n    let table =\n      (0...).lazy\n        .map({i -> (Self, Self) in\n          let power = Self(2).power(Self(i))\n\n          return (power, power * divisor)\n        })\n        .prefix(while: { $0.1 <= self })\n        .reversed()\n\n    let (answer, acc) = table.reduce((Self(0), Self(0)), {cur, row in\n      let ((ans, acc), (power, doubling)) = (cur, row)\n\n      return acc + doubling <= self ? (ans + power, doubling + acc) : cur\n    })\n\n    return (answer, Self((acc - self).magnitude))\n  }\n\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nlet dividend = 580\nlet divisor = 34\nlet (quo, rem) = dividend.egyptianDivide(by: divisor)\n\nprint(\"\\(dividend) divided by \\(divisor) = \\(quo) rem \\(rem)\")\n", "target": "from itertools import product\n\ndef egyptian_divmod(dividend, divisor):\n    assert divisor != 0\n    pwrs, dbls = [1], [divisor]\n    while dbls[-1] <= dividend:\n        pwrs.append(pwrs[-1] * 2)\n        dbls.append(pwrs[-1] * divisor)\n    ans, accum = 0, 0\n    for pwr, dbl in zip(pwrs[-2::-1], dbls[-2::-1]):\n        if accum + dbl <= dividend:\n            accum += dbl\n            ans += pwr\n    return ans, abs(accum - dividend)\n\nif __name__ == \"__main__\":\n    \n    for i, j in product(range(13), range(1, 13)):\n            assert egyptian_divmod(i, j) == divmod(i, j)\n    \n    i, j = 580, 34\n    print(f'{i} divided by {j} using the Egyption method is %i remainder %i'\n          % egyptian_divmod(i, j))\n"}
{"id": 164668, "name": "One of n lines in a file", "source": "Translate Swift to C#: func one_of_n(n: Int) -> Int {\n  var result = 1\n  for i in 2...n {\n    if arc4random_uniform(UInt32(i)) < 1 {\n      result = i\n    }\n  }\n  return result\n}\n\nvar counts = [0,0,0,0,0,0,0,0,0,0]\nfor _ in 1..1_000_000 {\n  counts[one_of_n(10)-1]++\n}\n  \nprintln(counts)\n", "target": "    class Program\n    {\n        private static Random rnd = new Random();\n        public static int one_of_n(int n)\n        {\n            int currentChoice = 1;\n            for (int i = 2; i <= n; i++)\n            {\n                double outerLimit = 1D / (double)i;\n                if (rnd.NextDouble() < outerLimit)\n                    currentChoice = i;\n            }\n            return currentChoice;\n        }\n\n        static void Main(string[] args)\n        {\n            Dictionary<int, int> results = new Dictionary<int, int>();\n            for (int i = 1; i < 11; i++)\n                results.Add(i, 0);\n\n            for (int i = 0; i < 1000000; i++)\n            {\n                int result = one_of_n(10);\n                results[result] = results[result] + 1;\n            }\n\n            for (int i = 1; i < 11; i++)\n                Console.WriteLine(\"{0}\\t{1}\", i, results[i]);\n            Console.ReadLine();\n        }\n    }\n"}
{"id": 164670, "name": "One of n lines in a file", "source": "Translate Swift to Java: func one_of_n(n: Int) -> Int {\n  var result = 1\n  for i in 2...n {\n    if arc4random_uniform(UInt32(i)) < 1 {\n      result = i\n    }\n  }\n  return result\n}\n\nvar counts = [0,0,0,0,0,0,0,0,0,0]\nfor _ in 1..1_000_000 {\n  counts[one_of_n(10)-1]++\n}\n  \nprintln(counts)\n", "target": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class OneOfNLines {\n\n\tstatic Random rand;\n\t\n\tpublic static int oneOfN(int n) {\n\t\tint choice = 0;\n\t\t\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tif(rand.nextInt(i+1) == 0)\n\t\t\t\tchoice = i;\n\t\t}\n\t\t\n\t\treturn choice;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tint n = 10;\n\t\tint trials = 1000000;\n\t\tint[] bins = new int[n];\n\t\trand = new Random();\n\t\t\n\t\tfor(int i = 0; i < trials; i++)\n\t\t\tbins[oneOfN(n)]++;\n\t\t\n\t\t\n\t\tSystem.out.println(Arrays.toString(bins));\n\t}\n}\n"}
{"id": 164671, "name": "One of n lines in a file", "source": "Translate Swift to Python: func one_of_n(n: Int) -> Int {\n  var result = 1\n  for i in 2...n {\n    if arc4random_uniform(UInt32(i)) < 1 {\n      result = i\n    }\n  }\n  return result\n}\n\nvar counts = [0,0,0,0,0,0,0,0,0,0]\nfor _ in 1..1_000_000 {\n  counts[one_of_n(10)-1]++\n}\n  \nprintln(counts)\n", "target": "from random import randrange\ntry:\n    range = xrange\nexcept: pass\n\ndef one_of_n(lines): \n    choice = None\n    for i, line in enumerate(lines):\n        if randrange(i+1) == 0:\n            choice = line\n    return choice\n            \ndef one_of_n_test(n=10, trials=1000000):\n    bins = [0] * n\n    if n:\n        for i in range(trials):\n            bins[one_of_n(range(n))] += 1\n    return bins\n\nprint(one_of_n_test())\n"}
{"id": 165017, "name": "Repeat", "source": "Translate Swift to C#: func repeat(n: Int, f: () -> ()) {\n  for _ in 0..<n {\n    f()\n  }\n}\n\nrepeat(4) { println(\"Example\") }\n", "target": "using System;\n\nnamespace Repeat {\n    class Program {\n        static void Repeat(int count, Action<int> fn) {\n            if (null == fn) {\n                throw new ArgumentNullException(\"fn\");\n            }\n            for (int i = 0; i < count; i++) {\n                fn.Invoke(i + 1);\n            }\n        }\n\n        static void Main(string[] args) {\n            Repeat(3, x => Console.WriteLine(\"Example {0}\", x));\n        }\n    }\n}\n"}
{"id": 165019, "name": "Repeat", "source": "Translate Swift to Java: func repeat(n: Int, f: () -> ()) {\n  for _ in 0..<n {\n    f()\n  }\n}\n\nrepeat(4) { println(\"Example\") }\n", "target": "import java.util.function.Consumer;\nimport java.util.stream.IntStream;\n\npublic class Repeat {\n\n    public static void main(String[] args) {\n        repeat(3, (x) -> System.out.println(\"Example \" + x));\n    }\n\n    static void repeat (int n, Consumer<Integer> fun) {\n        IntStream.range(0, n).forEach(i -> fun.accept(i + 1));\n    }\n}\n"}
{"id": 165020, "name": "Repeat", "source": "Translate Swift to Python: func repeat(n: Int, f: () -> ()) {\n  for _ in 0..<n {\n    f()\n  }\n}\n\nrepeat(4) { println(\"Example\") }\n", "target": "\ndef repeat(f,n):\n  for i in range(n):\n    f();\n\ndef procedure():\n  print(\"Example\");\n\nrepeat(procedure,3); \n"}
{"id": 165323, "name": "The Twelve Days of Christmas", "source": "Translate Swift to C#: let gifts = [ \"partridge in a pear tree\", \"Two turtle doves\", \n              \"Three French hens\",        \"Four calling birds\",       \n              \"Five gold rings\",          \"Six geese a-laying\", \n              \"Seven swans a-swimming\",   \"Eight maids a-milking\",\n              \"Nine ladies dancing\",      \"Ten lords a-leaping\", \n              \"Eleven pipers piping\",     \"Twelve drummers drumming\" ]\n\nlet nth = [ \"first\",   \"second\", \"third\", \"fourth\", \"fifth\",    \"sixth\",\n            \"seventh\", \"eighth\", \"ninth\", \"tenth\",  \"eleventh\", \"twelfth\" ]\n\nfunc giftsForDay(day: Int) -> String {\n  var result = \"On the \\(nth[day-1]) day of Christmas, my true love sent to me:\\n\"\n  if day > 1 {\n    for again in 1...day-1 {\n      let n = day - again \n      result += gifts[n]\n      if n > 1 { result += \",\" }\n      result += \"\\n\"\n    }\n    result += \"And a \"\n  } else {\n    result += \"A \"\n  }\n  return result + gifts[0] + \".\\n\";\n}\n\nfor day in 1...12 {\n  print(giftsForDay(day))\n}\n", "target": "using System;\n\npublic class TwelveDaysOfChristmas {\n\n    public static void Main() {\n\n        string[] days = new string[12] {\n            \"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\", \"eighth\", \"ninth\",\n            \"tenth\", \"eleventh\", \"twelfth\",\n        };\n\n        string[] gifts = new string[12] {\n            \"A partridge in a pear tree\",\n            \"Two turtle doves\",\n            \"Three french hens\",\n            \"Four calling birds\",\n            \"Five golden rings\",\n            \"Six geese a-laying\",\n            \"Seven swans a-swimming\",\n            \"Eight maids a-milking\",\n            \"Nine ladies dancing\",\n            \"Ten lords a-leaping\",\n            \"Eleven pipers piping\",\n            \"Twelve drummers drumming\"\n        };\n\n        for ( int i = 0; i < 12; i++ ) {\n\n            Console.WriteLine(\"On the \" + days[i] + \" day of Christmas, my true love gave to me\");\n\n            int j = i + 1;\n            while ( j-- > 0 )\n                Console.WriteLine(gifts[j]);\n\n            Console.WriteLine();\n\n            if ( i == 0 )\n                gifts[0] = \"And a partridge in a pear tree\";\n        }\n\n    }\n\n}\n"}
{"id": 165325, "name": "The Twelve Days of Christmas", "source": "Translate Swift to Java: let gifts = [ \"partridge in a pear tree\", \"Two turtle doves\", \n              \"Three French hens\",        \"Four calling birds\",       \n              \"Five gold rings\",          \"Six geese a-laying\", \n              \"Seven swans a-swimming\",   \"Eight maids a-milking\",\n              \"Nine ladies dancing\",      \"Ten lords a-leaping\", \n              \"Eleven pipers piping\",     \"Twelve drummers drumming\" ]\n\nlet nth = [ \"first\",   \"second\", \"third\", \"fourth\", \"fifth\",    \"sixth\",\n            \"seventh\", \"eighth\", \"ninth\", \"tenth\",  \"eleventh\", \"twelfth\" ]\n\nfunc giftsForDay(day: Int) -> String {\n  var result = \"On the \\(nth[day-1]) day of Christmas, my true love sent to me:\\n\"\n  if day > 1 {\n    for again in 1...day-1 {\n      let n = day - again \n      result += gifts[n]\n      if n > 1 { result += \",\" }\n      result += \"\\n\"\n    }\n    result += \"And a \"\n  } else {\n    result += \"A \"\n  }\n  return result + gifts[0] + \".\\n\";\n}\n\nfor day in 1...12 {\n  print(giftsForDay(day))\n}\n", "target": "public class TwelveDaysOfChristmas {\n\n    final static String[] gifts = {\n        \"A partridge in a pear tree.\", \"Two turtle doves and\",\n        \"Three french hens\", \"Four calling birds\",\n        \"Five golden rings\", \"Six geese a-laying\",\n        \"Seven swans a-swimming\", \"Eight maids a-milking\",\n        \"Nine ladies dancing\", \"Ten lords a-leaping\",\n        \"Eleven pipers piping\", \"Twelve drummers drumming\",\n        \"And a partridge in a pear tree.\", \"Two turtle doves\"\n    };\n\n    final static String[] days = {\n        \"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\",\n        \"eighth\", \"ninth\", \"tenth\", \"eleventh\", \"Twelfth\"\n    };\n\n    public static void main(String[] args) {\n        for (int i = 0; i < days.length; i++) {\n            System.out.printf(\"%nOn the %s day of Christmas%n\", days[i]);\n            System.out.println(\"My true love gave to me:\");\n            for (int j = i; j >= 0; j--)\n                System.out.println(gifts[i == 11 && j < 2 ? j + 12 : j]);\n        }\n    }\n}\n"}
{"id": 165326, "name": "The Twelve Days of Christmas", "source": "Translate Swift to Python: let gifts = [ \"partridge in a pear tree\", \"Two turtle doves\", \n              \"Three French hens\",        \"Four calling birds\",       \n              \"Five gold rings\",          \"Six geese a-laying\", \n              \"Seven swans a-swimming\",   \"Eight maids a-milking\",\n              \"Nine ladies dancing\",      \"Ten lords a-leaping\", \n              \"Eleven pipers piping\",     \"Twelve drummers drumming\" ]\n\nlet nth = [ \"first\",   \"second\", \"third\", \"fourth\", \"fifth\",    \"sixth\",\n            \"seventh\", \"eighth\", \"ninth\", \"tenth\",  \"eleventh\", \"twelfth\" ]\n\nfunc giftsForDay(day: Int) -> String {\n  var result = \"On the \\(nth[day-1]) day of Christmas, my true love sent to me:\\n\"\n  if day > 1 {\n    for again in 1...day-1 {\n      let n = day - again \n      result += gifts[n]\n      if n > 1 { result += \",\" }\n      result += \"\\n\"\n    }\n    result += \"And a \"\n  } else {\n    result += \"A \"\n  }\n  return result + gifts[0] + \".\\n\";\n}\n\nfor day in 1...12 {\n  print(giftsForDay(day))\n}\n", "target": "gifts = .split('\\n')\n\ndays = .split()\n\nfor n, day in enumerate(days, 1):\n    g = gifts[:n][::-1]\n    print(('\\nOn the %s day of Christmas\\nMy true love gave to me:\\n' % day) +\n          '\\n'.join(g[:-1]) +\n          (' and\\n' + g[-1] if n > 1 else g[-1].capitalize()))\n"}

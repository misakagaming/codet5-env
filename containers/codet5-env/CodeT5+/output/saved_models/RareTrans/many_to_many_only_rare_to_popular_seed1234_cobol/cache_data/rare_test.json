{"id": 388001, "name": "String comparison", "source": "Translate COBOL to Java: \"hello\" = \"hello\"   \n\"helloo\" <> \"hello\" \n\"aello\" < \"hello\"   \n", "target": "public class Compare\n{\n\t\n    \n    public static void compare (String A, String B)\n    {\n        if (A.equals(B))\n            System.debug(A + ' and  ' + B + ' are lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not lexically equal.');\n\n        if (A.equalsIgnoreCase(B))\n            System.debug(A + ' and  ' + B + ' are case-insensitive lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not case-insensitive lexically equal.');\n \n        if (A.compareTo(B) < 0)\n            System.debug(A + ' is lexically before ' + B);\n        else if (A.compareTo(B) > 0)\n            System.debug(A + ' is lexically after ' + B);\n \n        if (A.compareTo(B) >= 0)\n            System.debug(A + ' is not lexically before ' + B);\n        if (A.compareTo(B) <= 0)\n            System.debug(A + ' is not lexically after ' + B);\n \n        System.debug('The lexical relationship is: ' + A.compareTo(B));\n    }\n}\n"}
{"id": 388002, "name": "Use another language to call a function", "source": "Translate COBOL to Java:        identification division.\n       program-id. Query.\n\n       environment division.\n       configuration section.\n       special-names.\n           call-convention 0 is extern.\n\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 query-result.\n          05 filler value \"Here I am\".\n\n       linkage section.\n       01 data-reference.\n          05 data-buffer   pic x occurs 0 to 8192 times\n                                 depending on length-reference.\n       01 length-reference usage binary-long.\n\n       procedure division extern using data-reference length-reference.\n\n       if length(query-result) less than or equal to length-reference\n                           and length-reference less than 8193 then\n           move query-result to data-reference\n           move length(query-result) to length-reference\n           move 1 to return-code\n       end-if\n\n       goback.\n       end program Query.\n", "target": "\npublic class Query {\n    public static boolean call(byte[] data, int[] length)\n\tthrows java.io.UnsupportedEncodingException\n    {\n\tString message = \"Here am I\";\n\tbyte[] mb = message.getBytes(\"utf-8\");\n\tif (length[0] < mb.length)\n\t    return false;\n\tlength[0] = mb.length;\n\tSystem.arraycopy(mb, 0, data, 0, mb.length);\n\treturn true;\n    }\n}\n"}
{"id": 388003, "name": "Colour bars_Display", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. terminal-colour-bars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  width           PIC 9(3).\n       01  height          PIC 9(3).\n\n       01  interval        PIC 9(3).\n\n       01  colours-area.\n           03  colour-values.\n               05  FILLER  PIC 9 VALUE 0. \n               05  FILLER  PIC 9 VALUE 4. \n               05  FILLER  PIC 9 VALUE 2. \n               05  FILLER  PIC 9 VALUE 1. \n               05  FILLER  PIC 9 VALUE 5. \n               05  FILLER  PIC 9 VALUE 3. \n               05  FILLER  PIC 9 VALUE 6. \n               05  FILLER  PIC 9 VALUE 7. \n\n           03  colour-table REDEFINES colour-values.\n               05  colours PIC 9 OCCURS 8 TIMES INDEXED BY colour-index.\n\n       01  i               PIC 9(3).\n       01  j               PIC 9(3).\n\n       PROCEDURE DIVISION.\n           ACCEPT width FROM COLUMNS\n           ACCEPT height FROM LINES\n           DIVIDE width BY 8 GIVING interval\n\n           PERFORM VARYING i FROM 1 BY 1 UNTIL height < i\n               PERFORM VARYING j FROM 1 BY 1 UNTIL width < j\n                  COMPUTE colour-index = (j / interval) + 1\n                  \n                  IF 8 < colour-index\n                      SET colour-index TO 8\n                  END-IF\n\n                  \n                  \n                  \n                  DISPLAY SPACE AT LINE i COLUMN j\n                      WITH BACKGROUND-COLOR colours (colour-index)\n               END-PERFORM\n           END-PERFORM\n\n           ACCEPT i \n\n           GOBACK\n           .\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\n\npublic class ColorFrame extends JFrame {\n\tpublic ColorFrame(int width, int height) {\n\t\tthis.setDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tthis.setSize(width, height);\n\t\tthis.setVisible(true);\n\t}\n\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tColor[] colors = { Color.black, Color.red, Color.green, Color.blue,\n\t\t\t\tColor.pink, Color.CYAN, Color.yellow, Color.white };\n\n\t\tfor (int i = 0; i < colors.length; i++) {\n\t\t\tg.setColor(colors[i]);\n\t\t\tg.fillRect(this.getWidth() / colors.length * i, 0, this.getWidth()\n\t\t\t\t\t/ colors.length, this.getHeight());\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tnew ColorFrame(200, 200);\n\t}\n}\n"}
{"id": 388004, "name": "Colour bars_Display", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. terminal-colour-bars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  width           PIC 9(3).\n       01  height          PIC 9(3).\n\n       01  interval        PIC 9(3).\n\n       01  colours-area.\n           03  colour-values.\n               05  FILLER  PIC 9 VALUE 0. \n               05  FILLER  PIC 9 VALUE 4. \n               05  FILLER  PIC 9 VALUE 2. \n               05  FILLER  PIC 9 VALUE 1. \n               05  FILLER  PIC 9 VALUE 5. \n               05  FILLER  PIC 9 VALUE 3. \n               05  FILLER  PIC 9 VALUE 6. \n               05  FILLER  PIC 9 VALUE 7. \n\n           03  colour-table REDEFINES colour-values.\n               05  colours PIC 9 OCCURS 8 TIMES INDEXED BY colour-index.\n\n       01  i               PIC 9(3).\n       01  j               PIC 9(3).\n\n       PROCEDURE DIVISION.\n           ACCEPT width FROM COLUMNS\n           ACCEPT height FROM LINES\n           DIVIDE width BY 8 GIVING interval\n\n           PERFORM VARYING i FROM 1 BY 1 UNTIL height < i\n               PERFORM VARYING j FROM 1 BY 1 UNTIL width < j\n                  COMPUTE colour-index = (j / interval) + 1\n                  \n                  IF 8 < colour-index\n                      SET colour-index TO 8\n                  END-IF\n\n                  \n                  \n                  \n                  DISPLAY SPACE AT LINE i COLUMN j\n                      WITH BACKGROUND-COLOR colours (colour-index)\n               END-PERFORM\n           END-PERFORM\n\n           ACCEPT i \n\n           GOBACK\n           .\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\n\npublic class ColorFrame extends JFrame {\n\tpublic ColorFrame(int width, int height) {\n\t\tthis.setDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tthis.setSize(width, height);\n\t\tthis.setVisible(true);\n\t}\n\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tColor[] colors = { Color.black, Color.red, Color.green, Color.blue,\n\t\t\t\tColor.pink, Color.CYAN, Color.yellow, Color.white };\n\n\t\tfor (int i = 0; i < colors.length; i++) {\n\t\t\tg.setColor(colors[i]);\n\t\t\tg.fillRect(this.getWidth() / colors.length * i, 0, this.getWidth()\n\t\t\t\t\t/ colors.length, this.getHeight());\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tnew ColorFrame(200, 200);\n\t}\n}\n"}
{"id": 388005, "name": "Enforced immutability", "source": "Translate COBOL to Java: ENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nSPECIAL-NAMES.\n    SYMBOLIC CHARACTERS NUL IS 0, TAB IS 9.\n", "target": "final int immutableInt = 4;\nint mutableInt = 4;\nmutableInt = 6; \nimmutableInt = 6; \n"}
{"id": 388006, "name": "Strange numbers", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. STRANGE-NUMBERS.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 COMPUTATION.\n           02 NUM           PIC 999.\n           02 DIGITS        REDEFINES NUM PIC 9 OCCURS 3 TIMES.\n           02 DIGIT-PRIME   PIC 9.\n              88 PRIME      VALUES 2 3 5 7.\n           02 CUR-DIGIT     PIC 9.\n        01 OUTPUT-FORMAT.\n           02 N-OUT         PIC ZZ9.\n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM STRANGE-TEST\n                VARYING NUM FROM 100 BY 1\n                UNTIL NUM IS GREATER THAN 500.\n            STOP RUN.\n        \n        STRANGE-TEST SECTION.\n        BEGIN.\n            SET CUR-DIGIT TO 1.\n        STEP.   \n            IF DIGITS(CUR-DIGIT) IS LESS THAN DIGITS(CUR-DIGIT + 1)\n                SUBTRACT DIGITS(CUR-DIGIT + 1) FROM DIGITS(CUR-DIGIT) \n                    GIVING DIGIT-PRIME\n            ELSE\n                SUBTRACT DIGITS(CUR-DIGIT) FROM DIGITS(CUR-DIGIT + 1)\n                    GIVING DIGIT-PRIME.\n            IF PRIME NEXT SENTENCE ELSE GO TO DONE.\n            ADD 1 TO CUR-DIGIT.\n            IF CUR-DIGIT IS LESS THAN 3 GO TO STEP.\n            MOVE NUM TO N-OUT.\n            DISPLAY N-OUT.\n        DONE. EXIT.\n", "target": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class StrangeNumbers {\n    private static List<Integer> digits(int n) {\n        var result = new LinkedList<Integer>();\n        while (n > 0) {\n            var rem = n % 10;\n            result.addFirst(rem);\n            n /= 10;\n        }\n        return result;\n    }\n\n    private static boolean isStrange(int n) {\n        BiPredicate<Integer, Integer> test = (a, b) -> {\n            var abs = Math.abs(a - b);\n            return abs == 2 || abs == 3 || abs == 5 || abs == 7;\n        };\n\n        var xs = digits(n);\n        for (int i = 1; i < xs.size(); i++) {\n            if (test.negate().test(xs.get(i - 1), xs.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        var xs = IntStream.rangeClosed(100, 500)\n            .filter(StrangeNumbers::isStrange)\n            .boxed()\n            .collect(Collectors.toList());\n\n        System.out.println(\"Strange numbers in range [100..500]\");\n        System.out.printf(\"(Total: %d)\\n\\n\", xs.size());\n\n        for (int i = 0; i < xs.size(); i++) {\n            Integer x = xs.get(i);\n            System.out.print(x);\n\n            if ((i + 1) % 10 == 0) {\n                System.out.println();\n            } else {\n                System.out.print(' ');\n            }\n        }\n    }\n}\n"}
{"id": 388007, "name": "Strange numbers", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. STRANGE-NUMBERS.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 COMPUTATION.\n           02 NUM           PIC 999.\n           02 DIGITS        REDEFINES NUM PIC 9 OCCURS 3 TIMES.\n           02 DIGIT-PRIME   PIC 9.\n              88 PRIME      VALUES 2 3 5 7.\n           02 CUR-DIGIT     PIC 9.\n        01 OUTPUT-FORMAT.\n           02 N-OUT         PIC ZZ9.\n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM STRANGE-TEST\n                VARYING NUM FROM 100 BY 1\n                UNTIL NUM IS GREATER THAN 500.\n            STOP RUN.\n        \n        STRANGE-TEST SECTION.\n        BEGIN.\n            SET CUR-DIGIT TO 1.\n        STEP.   \n            IF DIGITS(CUR-DIGIT) IS LESS THAN DIGITS(CUR-DIGIT + 1)\n                SUBTRACT DIGITS(CUR-DIGIT + 1) FROM DIGITS(CUR-DIGIT) \n                    GIVING DIGIT-PRIME\n            ELSE\n                SUBTRACT DIGITS(CUR-DIGIT) FROM DIGITS(CUR-DIGIT + 1)\n                    GIVING DIGIT-PRIME.\n            IF PRIME NEXT SENTENCE ELSE GO TO DONE.\n            ADD 1 TO CUR-DIGIT.\n            IF CUR-DIGIT IS LESS THAN 3 GO TO STEP.\n            MOVE NUM TO N-OUT.\n            DISPLAY N-OUT.\n        DONE. EXIT.\n", "target": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class StrangeNumbers {\n    private static List<Integer> digits(int n) {\n        var result = new LinkedList<Integer>();\n        while (n > 0) {\n            var rem = n % 10;\n            result.addFirst(rem);\n            n /= 10;\n        }\n        return result;\n    }\n\n    private static boolean isStrange(int n) {\n        BiPredicate<Integer, Integer> test = (a, b) -> {\n            var abs = Math.abs(a - b);\n            return abs == 2 || abs == 3 || abs == 5 || abs == 7;\n        };\n\n        var xs = digits(n);\n        for (int i = 1; i < xs.size(); i++) {\n            if (test.negate().test(xs.get(i - 1), xs.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        var xs = IntStream.rangeClosed(100, 500)\n            .filter(StrangeNumbers::isStrange)\n            .boxed()\n            .collect(Collectors.toList());\n\n        System.out.println(\"Strange numbers in range [100..500]\");\n        System.out.printf(\"(Total: %d)\\n\\n\", xs.size());\n\n        for (int i = 0; i < xs.size(); i++) {\n            Integer x = xs.get(i);\n            System.out.print(x);\n\n            if ((i + 1) % 10 == 0) {\n                System.out.println();\n            } else {\n                System.out.print(' ');\n            }\n        }\n    }\n}\n"}
{"id": 388008, "name": "Hofstadter Q sequence", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. Q-SEQ.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 SEQ.\n           02 Q         PIC 9(3) OCCURS 1000 TIMES.\n           02 Q-TMP1    PIC 9(3).\n           02 Q-TMP2    PIC 9(3).\n           02 N         PIC 9(4).\n        01 DISPLAYING.\n           02 ITEM      PIC Z(3).\n           02 IX        PIC Z(4).\n            \n        PROCEDURE DIVISION.\n        MAIN-PROGRAM.    \n            PERFORM GENERATE-SEQUENCE.\n            PERFORM SHOW-ITEM\n                VARYING N FROM 1 BY 1 \n                UNTIL N IS GREATER THAN 10.\n            SET N TO 1000.\n            PERFORM SHOW-ITEM.\n            STOP RUN.\n        \n        GENERATE-SEQUENCE.\n            SET Q(1) TO 1.\n            SET Q(2) TO 1.            \n            PERFORM GENERATE-ITEM \n                VARYING N FROM 3 BY 1\n                UNTIL N IS GREATER THAN 1000.\n        \n        GENERATE-ITEM.\n            COMPUTE Q-TMP1 = N - Q(N - 1).\n            COMPUTE Q-TMP2 = N - Q(N - 2).\n            COMPUTE Q(N) = Q(Q-TMP1) + Q(Q-TMP2).\n                        \n        SHOW-ITEM.\n            MOVE N TO IX.\n            MOVE Q(N) TO ITEM.\n            DISPLAY 'Q(' IX ') = ' ITEM.\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HofQ {\n\tprivate static Map<Integer, Integer> q = new HashMap<Integer, Integer>(){{\n\t\tput(1, 1);\n\t\tput(2, 1);\n\t}};\n\t\n\tprivate static int[] nUses = new int[100001];\n\t\n\tpublic static int Q(int n){\n\t\tnUses[n]++;\n\t\tif(q.containsKey(n)){\n\t\t\treturn q.get(n);\n\t\t}\n\t\tint ans = Q(n - Q(n - 1)) + Q(n - Q(n - 2));\n\t\tq.put(n, ans);\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"Q(\" + i + \") = \" + Q(i));\n\t\t}\n\t\tint last = 6;\n\t\tint count = 0;\n\t\tfor(int i = 11; i <= 100000; i++){\n\t\t\tint curr = Q(i);\n\t\t\tif(curr < last) count++;\n\t\t\tlast = curr;\n\t\t\tif(i == 1000) System.out.println(\"Q(1000) = \" + curr);\n\t\t}\n\t\tSystem.out.println(\"Q(i) is less than Q(i-1) for i <= 100000 \" + count + \" times\");\n\t\t\n\t\t\n\t\tint maxUses = 0, maxN = 0;\n\t\tfor(int i = 1; i<nUses.length;i++){\n\t\t\tif(nUses[i] > maxUses){\n\t\t\t\tmaxUses = nUses[i];\n\t\t\t\tmaxN = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Q(\" + maxN + \") was called the most with \" + maxUses + \" calls\");\n\t}\n}\n"}
{"id": 388009, "name": "Hofstadter Q sequence", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. Q-SEQ.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 SEQ.\n           02 Q         PIC 9(3) OCCURS 1000 TIMES.\n           02 Q-TMP1    PIC 9(3).\n           02 Q-TMP2    PIC 9(3).\n           02 N         PIC 9(4).\n        01 DISPLAYING.\n           02 ITEM      PIC Z(3).\n           02 IX        PIC Z(4).\n            \n        PROCEDURE DIVISION.\n        MAIN-PROGRAM.    \n            PERFORM GENERATE-SEQUENCE.\n            PERFORM SHOW-ITEM\n                VARYING N FROM 1 BY 1 \n                UNTIL N IS GREATER THAN 10.\n            SET N TO 1000.\n            PERFORM SHOW-ITEM.\n            STOP RUN.\n        \n        GENERATE-SEQUENCE.\n            SET Q(1) TO 1.\n            SET Q(2) TO 1.            \n            PERFORM GENERATE-ITEM \n                VARYING N FROM 3 BY 1\n                UNTIL N IS GREATER THAN 1000.\n        \n        GENERATE-ITEM.\n            COMPUTE Q-TMP1 = N - Q(N - 1).\n            COMPUTE Q-TMP2 = N - Q(N - 2).\n            COMPUTE Q(N) = Q(Q-TMP1) + Q(Q-TMP2).\n                        \n        SHOW-ITEM.\n            MOVE N TO IX.\n            MOVE Q(N) TO ITEM.\n            DISPLAY 'Q(' IX ') = ' ITEM.\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HofQ {\n\tprivate static Map<Integer, Integer> q = new HashMap<Integer, Integer>(){{\n\t\tput(1, 1);\n\t\tput(2, 1);\n\t}};\n\t\n\tprivate static int[] nUses = new int[100001];\n\t\n\tpublic static int Q(int n){\n\t\tnUses[n]++;\n\t\tif(q.containsKey(n)){\n\t\t\treturn q.get(n);\n\t\t}\n\t\tint ans = Q(n - Q(n - 1)) + Q(n - Q(n - 2));\n\t\tq.put(n, ans);\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"Q(\" + i + \") = \" + Q(i));\n\t\t}\n\t\tint last = 6;\n\t\tint count = 0;\n\t\tfor(int i = 11; i <= 100000; i++){\n\t\t\tint curr = Q(i);\n\t\t\tif(curr < last) count++;\n\t\t\tlast = curr;\n\t\t\tif(i == 1000) System.out.println(\"Q(1000) = \" + curr);\n\t\t}\n\t\tSystem.out.println(\"Q(i) is less than Q(i-1) for i <= 100000 \" + count + \" times\");\n\t\t\n\t\t\n\t\tint maxUses = 0, maxN = 0;\n\t\tfor(int i = 1; i<nUses.length;i++){\n\t\t\tif(nUses[i] > maxUses){\n\t\t\t\tmaxUses = nUses[i];\n\t\t\t\tmaxN = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Q(\" + maxN + \") was called the most with \" + maxUses + \" calls\");\n\t}\n}\n"}
{"id": 388010, "name": "Count occurrences of a substring", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. testing.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  occurrences             PIC 99.\n\n       PROCEDURE DIVISION.\n           INSPECT \"the three truths\" TALLYING occurrences FOR ALL \"th\"\n           DISPLAY occurrences\n\n           MOVE 0 TO occurrences\n           INSPECT \"ababababab\" TALLYING occurrences FOR ALL \"abab\"\n           DISPLAY occurrences\n           \n           MOVE 0 TO occurrences\n           INSPECT \"abaabba*bbaba*bbab\" TALLYING occurrences\n               FOR ALL \"a*b\"\n           DISPLAY occurrences\n\n           GOBACK\n           .\n", "target": "public class CountSubstring {\n\tpublic static int countSubstring(String subStr, String str){\n\t\treturn (str.length() - str.replace(subStr, \"\").length()) / subStr.length();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(countSubstring(\"th\", \"the three truths\"));\n\t\tSystem.out.println(countSubstring(\"abab\", \"ababababab\"));\n\t\tSystem.out.println(countSubstring(\"a*b\", \"abaabba*bbaba*bbab\"));\n\t}\n}\n"}
{"id": 388011, "name": "Hickerson series of almost integers", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. hickerson-series.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION ALL INTRINSIC\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  n                                   PIC 99 COMP.\n\n01  h                                   PIC Z(19)9.9(10).\n\n01  First-Decimal-Digit-Pos             CONSTANT 22.\n\nPROCEDURE DIVISION.\n    PERFORM VARYING n FROM 0 BY 1 UNTIL n > 17\n        COMPUTE h = FACTORIAL(n) / (2 * LOG(2) ** (n + 1))\n        DISPLAY \"h(\" n \") = \" h \" which is \" NO ADVANCING\n        IF h (First-Decimal-Digit-Pos:1) = \"0\" OR \"9\"\n            DISPLAY \"an almost integer.\"\n        ELSE\n            DISPLAY \"not an almost integer.\"\n        END-IF\n    END-PERFORM\n    .\nEND PROGRAM hickerson-series.\n", "target": "import java.math.*;\n\npublic class Hickerson {\n\n    final static String LN2 = \"0.693147180559945309417232121458\";\n\n    public static void main(String[] args) {\n        for (int n = 1; n <= 17; n++)\n            System.out.printf(\"%2s is almost integer: %s%n\", n, almostInteger(n));\n    }\n\n    static boolean almostInteger(int n) {\n        BigDecimal a = new BigDecimal(LN2);\n        a = a.pow(n + 1).multiply(BigDecimal.valueOf(2));\n\n        long f = n;\n        while (--n > 1)\n            f *= n;\n\n        BigDecimal b = new BigDecimal(f);\n        b = b.divide(a, MathContext.DECIMAL128);\n\n        BigInteger c = b.movePointRight(1).toBigInteger().mod(BigInteger.TEN);\n\n        return c.toString().matches(\"0|9\");\n    }\n}\n"}
{"id": 388012, "name": "Hickerson series of almost integers", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. hickerson-series.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION ALL INTRINSIC\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  n                                   PIC 99 COMP.\n\n01  h                                   PIC Z(19)9.9(10).\n\n01  First-Decimal-Digit-Pos             CONSTANT 22.\n\nPROCEDURE DIVISION.\n    PERFORM VARYING n FROM 0 BY 1 UNTIL n > 17\n        COMPUTE h = FACTORIAL(n) / (2 * LOG(2) ** (n + 1))\n        DISPLAY \"h(\" n \") = \" h \" which is \" NO ADVANCING\n        IF h (First-Decimal-Digit-Pos:1) = \"0\" OR \"9\"\n            DISPLAY \"an almost integer.\"\n        ELSE\n            DISPLAY \"not an almost integer.\"\n        END-IF\n    END-PERFORM\n    .\nEND PROGRAM hickerson-series.\n", "target": "import java.math.*;\n\npublic class Hickerson {\n\n    final static String LN2 = \"0.693147180559945309417232121458\";\n\n    public static void main(String[] args) {\n        for (int n = 1; n <= 17; n++)\n            System.out.printf(\"%2s is almost integer: %s%n\", n, almostInteger(n));\n    }\n\n    static boolean almostInteger(int n) {\n        BigDecimal a = new BigDecimal(LN2);\n        a = a.pow(n + 1).multiply(BigDecimal.valueOf(2));\n\n        long f = n;\n        while (--n > 1)\n            f *= n;\n\n        BigDecimal b = new BigDecimal(f);\n        b = b.divide(a, MathContext.DECIMAL128);\n\n        BigInteger c = b.movePointRight(1).toBigInteger().mod(BigInteger.TEN);\n\n        return c.toString().matches(\"0|9\");\n    }\n}\n"}
{"id": 388013, "name": "Read a configuration file", "source": "Translate COBOL to Java:        identification division.\n       program-id. ReadConfiguration.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select config-file     assign to \"Configuration.txt\"\n                                  organization line sequential.\n       data division.\n       file section.\n\n       fd  config-file.\n       01  config-record          pic is x(128).\n\n       working-storage section.\n       77  idx                    pic 9(3).\n       77  pos                    pic 9(3).\n       77  last-pos               pic 9(3).\n       77  config-key             pic x(32).\n       77  config-value           pic x(64).\n       77  multi-value            pic x(64).\n       77  full-name              pic x(64).\n       77  favourite-fruit        pic x(64).\n       77  other-family           pic x(64) occurs 10.\n       77  need-speeling          pic x(5) value \"false\".\n       77  seeds-removed          pic x(5) value \"false\".\n\n       procedure division.\n       main.\n           open input config-file\n           perform until exit\n              read config-file\n                 at end\n                    exit perform\n              end-read  \n              move trim(config-record) to config-record\n              if config-record(1:1) = \"#\" or \";\" or spaces\n                 exit perform cycle\n              end-if\n              unstring config-record delimited by spaces into config-key\n              move trim(config-record(length(trim(config-key)) + 1:)) to config-value\n              if config-value(1:1) = \"=\"\n                 move trim(config-value(2:)) to config-value\n              end-if\n              evaluate upper-case(config-key)\n                 when \"FULLNAME\"\n                    move config-value to full-name\n                 when \"FAVOURITEFRUIT\"\n                    move config-value to favourite-fruit\n                 when \"NEEDSPEELING\"\n                    if config-value = spaces\n                       move \"true\" to config-value\n                    end-if\n                    if config-value = \"true\" or \"false\"\n                       move config-value to need-speeling\n                    end-if\n                 when \"SEEDSREMOVED\"\n                    if config-value = spaces\n                       move \"true\" to config-value\n                    end-if,\n                    if config-value = \"true\" or \"false\"\n                       move config-value to seeds-removed\n                    end-if\n                 when \"OTHERFAMILY\"\n                    move 1 to idx, pos\n                    perform until exit\n                       unstring config-value delimited by \",\" into multi-value with pointer pos\n                          on overflow\n                             move trim(multi-value) to other-family(idx)\n                             move pos to last-pos\n                          not on overflow\n                             if config-value(last-pos:) <> spaces\n                                move trim(config-value(last-pos:)) to other-family(idx)\n                             end-if,\n                             exit perform\n                       end-unstring\n                       add 1 to idx\n                    end-perform\n              end-evaluate\n           end-perform\n           close config-file\n\n           display \"fullname = \" full-name\n           display \"favouritefruit = \" favourite-fruit\n           display \"needspeeling = \" need-speeling\n           display \"seedsremoved = \" seeds-removed\n           perform varying idx from 1 by 1 until idx > 10\n              if other-family(idx) <> low-values\n                 display \"otherfamily(\" idx \") = \" other-family(idx)\n              end-if\n           end-perform\n           .\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ConfigReader {\n    private static final Pattern             LINE_PATTERN = Pattern.compile( \"([^ =]+)[ =]?(.*)\" );\n    private static final Map<String, Object> DEFAULTS     = new HashMap<String, Object>() {{\n        put( \"needspeeling\", false );\n        put( \"seedsremoved\", false );\n    }};\n\n    public static void main( final String[] args ) {\n        System.out.println( parseFile( args[ 0 ] ) );\n    }\n\n    public static Map<String, Object> parseFile( final String fileName ) {\n        final Map<String, Object> result = new HashMap<String, Object>( DEFAULTS );\n         BufferedReader      reader = null;\n\n        try {\n            reader = new BufferedReader( new FileReader( fileName ) );\n            for ( String line; null != ( line = reader.readLine() );  ) {\n                parseLine( line, result );\n            }\n        } catch ( final IOException x ) {\n            throw new RuntimeException( \"Oops: \" + x, x );\n        } finally {\n            if ( null != reader ) try {\n                reader.close();\n            } catch ( final IOException x2 ) {\n                System.err.println( \"Could not close \" + fileName + \" - \" + x2 );\n            }\n        }\n\n        return result;\n    }\n\n    private static void parseLine( final String line, final Map<String, Object> map ) {\n        if ( \"\".equals( line.trim() ) || line.startsWith( \"#\" ) || line.startsWith( \";\" ) )\n            return;\n\n        final Matcher matcher = LINE_PATTERN.matcher( line );\n\n        if ( ! matcher.matches() ) {\n            System.err.println( \"Bad config line: \" + line );\n            return;\n        }\n\n        final String key   = matcher.group( 1 ).trim().toLowerCase();\n        final String value = matcher.group( 2 ).trim();\n\n        if ( \"\".equals( value ) ) {\n            map.put( key, true );\n        } else if ( -1 == value.indexOf( ',' ) ) {\n            map.put( key, value );\n        } else {\n            final String[] values = value.split( \",\" );\n\n            for ( int i = 0; i < values.length; i++ ) {\n                values[ i ] = values[ i ].trim();\n            }\n            map.put( key, Arrays.asList( values ) );\n        }\n    }\n}\n"}
{"id": 388014, "name": "Additive primes", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ADDITIVE-PRIMES.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 MAXIMUM            PIC 999.\n          03 AMOUNT             PIC 999.\n          03 CANDIDATE          PIC 999.\n          03 DIGIT              PIC 9 OCCURS 3 TIMES, \n                                REDEFINES CANDIDATE.\n          03 DIGITSUM           PIC 99.\n          \n       01 PRIME-DATA.\n          03 COMPOSITE-FLAG     PIC X OCCURS 500 TIMES.\n             88 PRIME           VALUE ' '.\n          03 SIEVE-PRIME        PIC 999.\n          03 SIEVE-COMP-START   PIC 999.\n          03 SIEVE-COMP         PIC 999.\n          03 SIEVE-MAX          PIC 999.\n       \n       01 OUT-FMT.\n          03 NUM-FMT            PIC ZZZ9.\n          03 OUT-LINE           PIC X(40).\n          03 OUT-PTR            PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 500 TO MAXIMUM.\n           MOVE 1 TO OUT-PTR.\n           PERFORM SIEVE.\n           MOVE ZERO TO AMOUNT.\n           PERFORM TEST-NUMBER \n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN MAXIMUM.\n           DISPLAY OUT-LINE.\n           DISPLAY SPACES.\n           MOVE AMOUNT TO NUM-FMT.\n           DISPLAY 'Amount of additive primes found: ' NUM-FMT.\n           STOP RUN.\n\n       TEST-NUMBER.\n           ADD DIGIT(1), DIGIT(2), DIGIT(3) GIVING DIGITSUM.\n           IF PRIME(CANDIDATE) AND PRIME(DIGITSUM),\n               ADD 1 TO AMOUNT,\n               PERFORM WRITE-NUMBER.\n       \n       WRITE-NUMBER.\n           MOVE CANDIDATE TO NUM-FMT.\n           STRING NUM-FMT DELIMITED BY SIZE INTO OUT-LINE \n               WITH POINTER OUT-PTR.\n           IF OUT-PTR IS GREATER THAN 40,\n               DISPLAY OUT-LINE,\n               MOVE SPACES TO OUT-LINE,\n               MOVE 1 TO OUT-PTR.               \n       \n       SIEVE.\n           MOVE SPACES TO PRIME-DATA.\n           DIVIDE MAXIMUM BY 2 GIVING SIEVE-MAX.\n           PERFORM SIEVE-OUTER-LOOP\n               VARYING SIEVE-PRIME FROM 2 BY 1\n               UNTIL SIEVE-PRIME IS GREATER THAN SIEVE-MAX.\n          \n       SIEVE-OUTER-LOOP.\n           IF PRIME(SIEVE-PRIME),\n               MULTIPLY SIEVE-PRIME BY 2 GIVING SIEVE-COMP-START,\n               PERFORM SIEVE-INNER-LOOP\n                   VARYING SIEVE-COMP \n                       FROM SIEVE-COMP-START BY SIEVE-PRIME\n                   UNTIL SIEVE-COMP IS GREATER THAN MAXIMUM.\n       \n       SIEVE-INNER-LOOP.\n           MOVE 'X' TO COMPOSITE-FLAG(SIEVE-COMP).\n", "target": "public class additivePrimes {\n\n    public static void main(String[] args) {\n        int additive_primes = 0;\n        for (int i = 2; i < 500; i++) {\n            if(isPrime(i) && isPrime(digitSum(i))){\n                additive_primes++;\n                System.out.print(i + \" \");\n            }\n        }\n        System.out.print(\"\\nFound \" + additive_primes + \" additive primes less than 500\");\n    }\n\n    static boolean isPrime(int n) {\n        int counter = 1;\n        if (n < 2 || (n != 2 && n % 2 == 0) || (n != 3 && n % 3 == 0)) {\n            return false;\n        }\n        while (counter * 6 - 1 <= Math.sqrt(n)) {\n            if (n % (counter * 6 - 1) == 0 || n % (counter * 6 + 1) == 0) {\n                return false;\n            } else {\n                counter++;\n            }\n        }\n        return true;\n    }\n\n    static int digitSum(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"id": 388015, "name": "Sorting algorithms_Stooge sort", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. stooge-sort-test.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  Arr-Len                             CONSTANT 7.\n\n01  arr-area                            VALUE \"00004001000020000005000230000000000\".\n    03  arr-elt                         PIC 9(5) OCCURS Arr-Len TIMES\n                                        INDEXED BY arr-idx.\n\nPROCEDURE DIVISION.\n    DISPLAY \"Unsorted: \" NO ADVANCING\n    PERFORM VARYING arr-idx FROM 1 BY 1 UNTIL Arr-Len < arr-idx\n        DISPLAY arr-elt (arr-idx) \" \" NO ADVANCING\n    END-PERFORM\n    DISPLAY SPACE\n\n    CALL \"stooge-sort\" USING arr-area, OMITTED, OMITTED\n\n    DISPLAY \"Sorted:   \" NO ADVANCING\n    PERFORM VARYING arr-idx FROM 1 BY 1 UNTIL Arr-Len < arr-idx\n        DISPLAY arr-elt (arr-idx) \" \" NO ADVANCING\n    END-PERFORM\n    DISPLAY SPACE\n    .\nEND PROGRAM stooge-sort-test.\n    \n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. stooge-sort RECURSIVE.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  Arr-Len                             CONSTANT 7.\n\n01  i                                   PIC 99 COMP.\n01  j                                   PIC 99 COMP.\n\n01  temp                                PIC 9(5).\n\n01  t                                   PIC 99 COMP.\n\nLINKAGE SECTION.\n01  arr-area.\n    03  arr-elt                         PIC 9(5) OCCURS Arr-Len TIMES.\n\n01  i-val                               PIC 99 COMP.\n01  j-val                               PIC 99 COMP.\n\nPROCEDURE DIVISION USING arr-area, OPTIONAL i-val, OPTIONAL j-val.\n    IF i-val IS OMITTED\n        MOVE 1 TO i\n    ELSE\n        MOVE i-val TO i\n    END-IF\n    IF j-val IS OMITTED\n        MOVE Arr-Len TO j\n    ELSE\n        MOVE j-val TO j\n    END-IF\n    \n    IF arr-elt (j) < arr-elt (i)\n        MOVE arr-elt (i) TO temp\n        MOVE arr-elt (j) TO arr-elt (i)\n        MOVE temp TO arr-elt (j)\n    END-IF   \n    \n    IF j - i + 1 >= 3\n        COMPUTE t = (j - i + 1) / 3\n        SUBTRACT t FROM j\n        CALL \"stooge-sort\" USING arr-area, CONTENT i, j\n        ADD t TO i, j\n        CALL \"stooge-sort\" USING arr-area, CONTENT i, j\n        SUBTRACT t FROM i, j\n        CALL \"stooge-sort\" USING arr-area, CONTENT i, j\n    END-IF\n    .\nEND PROGRAM stooge-sort.\n", "target": "import java.util.Arrays;\n\npublic class Stooge {\n    public static void main(String[] args) {\n        int[] nums = {1, 4, 5, 3, -6, 3, 7, 10, -2, -5};\n        stoogeSort(nums);\n        System.out.println(Arrays.toString(nums));\n    }\n\n    public static void stoogeSort(int[] L) {\n        stoogeSort(L, 0, L.length - 1);\n    }\n\n    public static void stoogeSort(int[] L, int i, int j) {\n        if (L[j] < L[i]) {\n            int tmp = L[i];\n            L[i] = L[j];\n            L[j] = tmp;\n        }\n        if (j - i > 1) {\n            int t = (j - i + 1) / 3;\n            stoogeSort(L, i, j - t);\n            stoogeSort(L, i + t, j);\n            stoogeSort(L, i, j - t);\n        }\n    }\n}\n"}
{"id": 388016, "name": "Sorting algorithms_Shell sort", "source": "Translate COBOL to Java:       *******************************************************           \n       IDENTIFICATION DIVISION.                                         \n      *******************************************************           \n       PROGRAM-ID.      SHELLSRT.                                       \n      ************************************************************      \n      *** SHELLSORT                                           ****      \n      ************************************************************      \n       ENVIRONMENT DIVISION.                                            \n       DATA DIVISION.                                                   \n       WORKING-STORAGE SECTION.                                         \n       01 II                        PIC S9(008) COMP-5.                 \n       01 IJ                        PIC S9(008) COMP-5.                 \n       01 IZ                        PIC S9(008) COMP-5.                 \n       01 IA                        PIC S9(008) COMP-5.                 \n       01 STRT1                     PIC S9(008) COMP-5.                 \n       01 STRT2                     PIC S9(008) COMP-5.                 \n       01 LGT                       PIC S9(008) COMP-5.                 \n       01 ORG                       PIC S9(008) COMP-5.                 \n       01 DST                       PIC S9(008) COMP-5.                 \n      *                                                                 \n       01 GAP                       PIC S9(008) COMP-5.                 \n       01 NEGAP                     PIC S9(008) COMP-5.                 \n       01 TEMP                      PIC X(32768).                       \n       77 KEY-RESULT                PIC X.                              \n      *                                                                 \n       LINKAGE SECTION.                                                 \n       01 SRT-ARRAY                 PIC  X(1000000).                    \n       01 NUM-ITEM                  PIC  9(008) COMP-5.                 \n       01 SRT-DATA.                                                     \n          03 LGT-ITEM               PIC  9(004) COMP-5.                 \n          03 SRT-KEYS.                                                  \n             05 SRT-KEY OCCURS 10.                                      \n                07 K-START         PIC S9(004) COMP-5.                  \n                07 K-LENGTH        PIC S9(004) COMP-5.                  \n                07 K-ASC           PIC X.                               \n      *                                                                 \n      *    P R O C E D U R E      D I V I S I O N                       \n      *                                                                 \n       PROCEDURE DIVISION USING SRT-ARRAY NUM-ITEM SRT-DATA.                \n                                                                        \n           COMPUTE GAP = NUM-ITEM / 2.                                  \n           PERFORM UNTIL GAP < 1                                        \n              COMPUTE NEGAP = GAP * -1                                  \n              PERFORM VARYING II FROM GAP BY 1                          \n                        UNTIL II GREATER  NUM-ITEM                      \n                 MOVE ' ' TO KEY-RESULT                                 \n                 COMPUTE ORG = (II - 1) * LGT-ITEM + 1                  \n                 MOVE SRT-ARRAY(ORG:LGT-ITEM) TO TEMP(1:LGT-ITEM)       \n                 PERFORM VARYING IJ FROM II BY NEGAP                    \n                           UNTIL IJ NOT GREATER  GAP                    \n                              OR (KEY-RESULT NOT EQUAL '<' AND ' ')     \n                    COMPUTE IA = IJ - GAP                               \n                    IF IA < 1                                           \n                       MOVE 1 TO IA                                     \n                    END-IF                                              \n                    PERFORM COMPARE-KEYS                                \n                    IF KEY-RESULT = '<'                                 \n                       COMPUTE ORG = (IA - 1) * LGT-ITEM + 1            \n                       COMPUTE DST = (IJ - 1) * LGT-ITEM + 1            \n                       MOVE SRT-ARRAY(ORG:LGT-ITEM)                     \n                         TO SRT-ARRAY(DST:LGT-ITEM)                     \n                       COMPUTE DST = (IA - 1) * LGT-ITEM + 1            \n                       MOVE TEMP(1:LGT-ITEM) TO SRT-ARRAY(DST:LGT-ITEM) \n                    END-IF                                              \n                 END-PERFORM                                            \n              END-PERFORM                                               \n              IF GAP = 2                                                \n                 MOVE 1 TO GAP                                          \n              ELSE                                                      \n                 COMPUTE GAP = GAP / 2.2                                \n              END-IF                                                    \n           END-PERFORM.                                                 \n           GOBACK.                                                      \n      *                                                                 \n       COMPARE-KEYS.                                                    \n           MOVE ' ' TO KEY-RESULT                                       \n           PERFORM VARYING IZ FROM 1 BY 1                               \n                     UNTIL IZ GREATER 10                                \n                        OR (KEY-RESULT NOT EQUAL '=' AND ' ')           \n              IF SRT-KEY(IZ) GREATER LOW-VALUES                         \n                 COMPUTE STRT1 = (IJ - 1) * LGT-ITEM + K-START(IZ)      \n                 COMPUTE STRT2 = (IA - 1) * LGT-ITEM + K-START(IZ)      \n                 MOVE K-LENGTH(IZ) TO LGT                               \n                 IF SRT-ARRAY(STRT1:LGT) > SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'A'                                 \n                 OR SRT-ARRAY(STRT1:LGT) < SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'D'                                 \n                    MOVE '>' TO KEY-RESULT                              \n                 END-IF                                                 \n                 IF SRT-ARRAY(STRT1:LGT) < SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'A'                                 \n                 OR SRT-ARRAY(STRT1:LGT) > SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'D'                                 \n                    MOVE '<' TO KEY-RESULT                              \n                 END-IF                                                 \n              END-IF                                                    \n           END-PERFORM.                                                 \n           IF KEY-RESULT = ' '                                          \n              MOVE '=' TO KEY-RESULT                                    \n           END-IF.\n", "target": "public static void shell(int[] a) {\n\tint increment = a.length / 2;\n\twhile (increment > 0) {\n\t\tfor (int i = increment; i < a.length; i++) {\n\t\t\tint j = i;\n\t\t\tint temp = a[i];\n\t\t\twhile (j >= increment && a[j - increment] > temp) {\n\t\t\t\ta[j] = a[j - increment];\n\t\t\t\tj = j - increment;\n\t\t\t}\n\t\t\ta[j] = temp;\n\t\t}\n\t\tif (increment == 2) {\n\t\t\tincrement = 1;\n\t\t} else {\n\t\t\tincrement *= (5.0 / 11);\n\t\t}\n\t}\n}\n"}
{"id": 388017, "name": "McNuggets problem", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MCNUGGETS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 NUGGETS.\n          03 NUGGET-FLAGS     PIC X OCCURS 100 TIMES.\n             88 IS-NUGGET     VALUE 'X'.\n\n       01 A                   PIC 999.\n       01 B                   PIC 999.\n       01 C                   PIC 999.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE SPACES TO NUGGETS.\n           PERFORM A-LOOP VARYING A FROM 0 BY 6\n               UNTIL A IS GREATER THAN 100.\n           MOVE 100 TO A.\n\n       FIND-LARGEST.\n           IF IS-NUGGET(A), SUBTRACT 1 FROM A, GO TO FIND-LARGEST.\n           DISPLAY 'Largest non-McNugget number: ', A.\n           STOP RUN.\n \n       A-LOOP.\n           PERFORM B-LOOP VARYING B FROM A BY 9\n               UNTIL B IS GREATER THAN 100.\n\n       B-LOOP.\n           PERFORM C-LOOP VARYING C FROM B BY 20\n               UNTIL C IS GREATER THAN 100.\n \n       C-LOOP.\n           IF C IS NOT EQUAL TO ZERO, MOVE 'X' TO NUGGET-FLAGS(C).\n", "target": "public class McNuggets {\n\n    public static void main(String... args) {\n        int[] SIZES = new int[] { 6, 9, 20 };\n        int MAX_TOTAL = 100;\n        \n        int numSizes = SIZES.length;\n        int[] counts = new int[numSizes];\n        int maxFound = MAX_TOTAL + 1;\n        boolean[] found = new boolean[maxFound];\n        int numFound = 0;\n        int total = 0;\n        boolean advancedState = false;\n        do {\n            if (!found[total]) {\n                found[total] = true;\n                numFound++;\n            }\n            \n            \n            advancedState = false;\n            for (int i = 0; i < numSizes; i++) {\n                int curSize = SIZES[i];\n                if ((total + curSize) > MAX_TOTAL) {\n                    \n                    total -= counts[i] * curSize;\n                    counts[i] = 0;\n                }\n                else {\n                    \n                    counts[i]++;\n                    total += curSize;\n                    advancedState = true;\n                    break;\n                }\n            }\n            \n        } while ((numFound < maxFound) && advancedState);\n        \n        if (numFound < maxFound) {\n            \n            for (int i = MAX_TOTAL; i >= 0; i--) {\n                if (!found[i]) {\n                    System.out.println(\"Largest non-McNugget number in the search space is \" + i);\n                    break;\n                }\n            }\n        }\n        else {\n            System.out.println(\"All numbers in the search space are McNugget numbers\");\n        }\n        \n        return;\n    }\n}\n"}
{"id": 388018, "name": "Idiomatically determine all the lowercase and uppercase letters", "source": "Translate COBOL to Java:        identification division.\n       program-id. determine.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 tx pic x.\n       01 lower-8bit pic x(256).\n       01 upper-8bit pic x(256).\n\n      \n      \n      \n\n       01 low-slide usage index.\n       01 high-slide usage index.\n\n       procedure division.\n       determining.\n\n      \n       set low-slide to 0\n       set high-slide to 0\n       perform varying tally from 1 by 1 until tally > 256\n           move char(tally) to tx\n           if tx is alphabetic-lower then\n               set low-slide up by 1\n               move tx to lower-8bit(low-slide:1)\n           end-if\n           if tx is alphabetic-upper then\n               set high-slide up by 1\n               move tx to upper-8bit(high-slide:1)\n           end-if\n       end-perform\n       if low-slide equal 0 then\n           display \"no lower case letters detected\" upon syserr\n       else\n           display lower-8bit(1:low-slide)\n       end-if\n       if high-slide equal 0 then\n           display \"no upper case letters detected\" upon syserr\n       else\n           display upper-8bit(1:high-slide)        \n       end-if\n\n      \n      \n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n\n       goback.\n       end program determine.\n", "target": "import java.util.stream.IntStream;\n\npublic class Letters {\n    public static void main(String[] args) throws Exception {\n        System.out.print(\"Upper case: \");\n        IntStream.rangeClosed(0, 0x10FFFF)\n                 .filter(Character::isUpperCase)\n                 .limit(72)\n                 .forEach(n -> System.out.printf(\"%c\", n));\n        System.out.println(\"...\");\n\n        System.out.print(\"Lower case: \");\n        IntStream.rangeClosed(0, 0x10FFFF)\n                 .filter(Character::isLowerCase)\n                 .limit(72)\n                 .forEach(n -> System.out.printf(\"%c\", n));\n        System.out.println(\"...\");\n    }\n}\n"}
{"id": 388019, "name": "Jaro similarity", "source": "Translate COBOL to Java:        identification division.\n       program-id. JaroDistance.\n \n       environment division.\n       configuration section.\n       repository.\n           function length intrinsic\n           function trim intrinsic\n           function max intrinsic\n           function min intrinsic\n           .\n \n       data division.\n       working-storage section.\n       77  s                      pic x(255).\n       77  t                      pic x(255).\n       77  s-length               pic 9(3).\n       77  t-length               pic 9(3).\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).\n       77  k                      pic 9(3).\n       77  start-pos              pic 9(3).\n       77  end-pos                pic 9(3).\n       77  match-distance         pic 9(3).\n       77  matches                pic 9(3).\n       77  transpositions         pic 9(3).\n       77  distance               pic 9v9(8).\n       \n       01  jaro-table.\n           05 filler              occurs 255.\n              10 filler           pic 9(1).\n                 88 s-matches     value 1 when set to false is 0.\n              10 filler           pic 9(1).\n                 88 t-matches     value 1 when set to false is 0.\n\n       procedure division.\n       main.\n           move \"MARTHA\" to s\n           move \"MARHTA\" to t\n           perform jaro-calc-and-show\n           move \"DIXON\" to s\n           move \"DICKSONX\" to t\n           perform jaro-calc-and-show\n           move \"JELLYFISH\" to s\n           move \"SMELLYFISH\" to t\n           perform jaro-calc-and-show\n           stop run\n           .\n       jaro-calc-and-show.\n           perform jaro-distance\n           display trim(s) \" -> \" trim(t) \", distance=\" distance\n           .           \n       jaro-distance.\n           move length(trim(s)) to s-length\n           move length(trim(t)) to t-length\n           if s-length = zeros and t-length = zeros\n              move 1 to distance\n              exit paragraph\n           end-if\n\n           compute match-distance = max(s-length, t-length) / 2 - 1\n           move low-values to jaro-table\n           move zeros to matches\n           move zeros to transpositions\n           perform varying i from 1 by 1 until i > s-length\n              move max(1, i - match-distance) to start-pos\n              move min(i + match-distance, t-length) to end-pos\n              perform varying j from start-pos by 1 until j > end-pos\n                 if t-matches(j) or s(i:1) <> t(j:1) \n                    exit perform cycle\n                 end-if,\n                 set s-matches(i), t-matches(j) to true\n                 add 1 to matches\n                 exit perform\n              end-perform\n           end-perform\n           if matches = zeros\n              move matches to distance\n              exit paragraph\n           end-if\n\n           move 1 to k\n           perform varying i from 1 by 1 until i > s-length\n              if not s-matches(i)\n                 exit perform cycle\n              end-if\n              perform until t-matches(k)\n                 add 1 to k\n              end-perform\n              if s(i:1) <> t(k:1)\n                 add 1 to transpositions\n              end-if\n              add 1 to k\n           end-perform\n\n           compute distance = ((matches / s-length) + (matches / t-length) +\n                               ((matches - transpositions / 2) / matches)) / 3\n           .\n", "target": "public class JaroDistance {\n    public static double jaro(String s, String t) {\n        int s_len = s.length();\n        int t_len = t.length();\n\n        if (s_len == 0 && t_len == 0) return 1;\n\n        int match_distance = Integer.max(s_len, t_len) / 2 - 1;\n\n        boolean[] s_matches = new boolean[s_len];\n        boolean[] t_matches = new boolean[t_len];\n\n        int matches = 0;\n        int transpositions = 0;\n\n        for (int i = 0; i < s_len; i++) {\n            int start = Integer.max(0, i-match_distance);\n            int end = Integer.min(i+match_distance+1, t_len);\n\n            for (int j = start; j < end; j++) {\n                if (t_matches[j]) continue;\n                if (s.charAt(i) != t.charAt(j)) continue;\n                s_matches[i] = true;\n                t_matches[j] = true;\n                matches++;\n                break;\n            }\n        }\n\n        if (matches == 0) return 0;\n\n        int k = 0;\n        for (int i = 0; i < s_len; i++) {\n            if (!s_matches[i]) continue;\n            while (!t_matches[k]) k++;\n            if (s.charAt(i) != t.charAt(k)) transpositions++;\n            k++;\n        }\n\n        return (((double)matches / s_len) +\n                ((double)matches / t_len) +\n                (((double)matches - transpositions/2.0) / matches)) / 3.0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(jaro(   \"MARTHA\",      \"MARHTA\"));\n        System.out.println(jaro(    \"DIXON\",    \"DICKSONX\"));\n        System.out.println(jaro(\"JELLYFISH\",  \"SMELLYFISH\"));\n    }\n}\n"}
{"id": 388020, "name": "Decision tables", "source": "Translate COBOL to Java:         >> SOURCE FORMAT FREE\nidentification division.\nprogram-id. 'decisiontable'.\n\nenvironment division.\nconfiguration section.\nrepository.\n    function all intrinsic.\n\ndata division.\n\nworking-storage section.\n\n01  conditions.\n    03  notprinting pic x.\n    03  flashing pic x.\n    03  notrecognized pic x.\n\nprocedure division.\nstart-decision-table.\n\ndisplay space \n\ndisplay 'The printer does not print (Y or N) ' with no advancing\naccept notprinting\n\ndisplay 'A red light is flashing (Y or N) ' with no advancing\naccept flashing\n\ndisplay 'The printer is unrecognized (Y or N) ' with no advancing\naccept notrecognized\n\nmove upper-case(conditions) to conditions\n\ndisplay space\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nevaluate notprinting also flashing also notrecognized\n\nwhen 'Y' also 'Y' also 'Y'\n    display 'Check the printer-computer cable'\n    display 'Ensure printer software is installed'\n    display 'Check/replace ink'\n\nwhen 'Y' also 'Y' also 'N'\n    display 'Check/replace ink'\n    display 'Check for paper jam'\n\nwhen 'Y' also 'N' also 'Y'\n    display 'Check the power cable'\n    display 'Check the printer-computer cable'\n    display 'Ensure printer software is installed'\n\nwhen 'Y' also 'N' also 'N'\n    display 'Check for paper jam'\n\nwhen 'N' also 'Y' also 'Y'\n    display 'Ensure printer software is installed'\n    display 'Check/replace ink'\n\nwhen 'N' also 'Y' also 'N'\n    display 'Check/replace ink'\n\nwhen 'N' also 'N' also 'Y'\n    display 'Ensure printer software is installed'\n\nwhen 'N' also 'N' also 'N'\n    display 'no action found'\n\nwhen other\n    display 'invalid input: ' notprinting space flashing space notrecognized\n\nend-evaluate\n\ndisplay space\n\nstop run\n.\n\nend program 'decisiontable'.\n", "target": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class DecisionTables {\n    private static class Pair<T, U> {\n        private final T t;\n        private final U u;\n\n        public static <T, U> Pair<T, U> of(T t, U u) {\n            return new Pair<>(t, u);\n        }\n\n        public Pair(T t, U u) {\n            this.t = t;\n            this.u = u;\n        }\n\n        public T getFirst() {\n            return t;\n        }\n\n        public U getSecond() {\n            return u;\n        }\n    }\n\n    private static final List<Pair<String, String>> conditions = List.of(\n        Pair.of(\"Printer prints\", \"NNNNYYYY\"),\n        Pair.of(\"A red light is flashing\", \"YYNNYYNN\"),\n        Pair.of(\"Printer is recognized by computer\", \"NYNYNYNY\")\n    );\n\n    private static final List<Pair<String, String>> actions = List.of(\n        Pair.of(\"Check the power cable\", \"NNYNNNNN\"),\n        Pair.of(\"Check the printer-computer cable\", \"YNYNNNNN\"),\n        Pair.of(\"Ensure printer software is installed\", \"YNYNYNYN\"),\n        Pair.of(\"Check/replace ink\", \"YYNNNYNN\"),\n        Pair.of(\"Check for paper jam\", \"NYNYNNNN\")\n    );\n\n    public static void main(String[] args) throws IOException {\n        final int nc = conditions.size();\n        final int na = actions.size();\n        final int nr = conditions.get(0).getSecond().length();\n        final int np = 7;\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        System.out.println(\"Please answer the following questions with a y or n:\");\n        final boolean[] answers = new boolean[nc];\n        for (int c = 0; c < nc; ++c) {\n            String input;\n            do {\n                System.out.printf(\"  %s\u00a0? \", conditions.get(c).getFirst());\n                input = br.readLine().toUpperCase();\n            } while (!Objects.equals(input, \"Y\") && !Objects.equals(input, \"N\"));\n            answers[c] = Objects.equals(input, \"Y\");\n        }\n        System.out.println(\"\\nRecommended action(s)\");\n\n        outer:\n        for (int r = 0; r < nr; ++r) {\n            for (int c = 0; c < nc; ++c) {\n                char yn = answers[c] ? 'Y' : 'N';\n                if (conditions.get(c).getSecond().charAt(r) != yn) {\n                    continue outer;\n                }\n            }\n            if (r == np) {\n                System.out.println(\"  None (no problem detected)\");\n            } else {\n                for (Pair<String, String> action : actions) {\n                    if (action.getSecond().charAt(r) == 'Y') {\n                        System.out.printf(\"  %s\\n\", action.getFirst());\n                    }\n                }\n            }\n            break;\n        }\n    }\n}\n"}
{"id": 388021, "name": "Hello world_Newbie", "source": "Translate COBOL to Java: program-id. hello-world.\n\nprocedure division.\n  display \"Hello, World!\"\n\n  goback\n  .\n", "target": "public class HelloWorld {\n    public static void main(String[] args) {\n        \n        System.out.println(\"Hello world!\");\n    }\n}\n"}
{"id": 388022, "name": "Hello world_Newbie", "source": "Translate COBOL to Java: program-id. hello-world.\n\nprocedure division.\n  display \"Hello, World!\"\n\n  goback\n  .\n", "target": "public class HelloWorld {\n    public static void main(String[] args) {\n        \n        System.out.println(\"Hello world!\");\n    }\n}\n"}
{"id": 388023, "name": "Loops_Infinite", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Spam.\n\n       PROCEDURE DIVISION.\n           PERFORM UNTIL 1 <> 1\n               DISPLAY \"SPAM\"\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "while (true) {\n   System.out.println(\"SPAM\");\n}\n"}
{"id": 388024, "name": "Function definition", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. myTest.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  x   PIC 9(3) VALUE 3.\n       01  y   PIC 9(3) VALUE 2.\n       01  z   PIC 9(9).\n       PROCEDURE DIVISION.\n           CALL \"myMultiply\" USING \n               BY CONTENT x, BY CONTENT y, \n               BY REFERENCE z.\n           DISPLAY z.\n           STOP RUN.\n       END PROGRAM myTest.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. myMultiply.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  x   PIC 9(3).\n       01  y   PIC 9(3).\n       01  z   PIC 9(9).\n       PROCEDURE DIVISION USING x, y, z.\n           MULTIPLY x BY y GIVING z.\n           EXIT PROGRAM.\n       END PROGRAM myMultiply.\n", "target": "module MultiplyExample\n    {\n    static <Value extends Number> Value multiply(Value n1, Value n2)\n        {\n        return n1 * n2;\n        }\n\n    void run()\n        {\n        (Int i1, Int i2) = (7, 3);\n        Int i3 = multiply(i1, i2);\n        (Double d1, Double d2) = (2.7182818, 3.1415);\n        Double d3 = multiply(d1, d2);\n        @Inject Console console;\n        console.print($\"{i1}*{i2}={i3}, {d1}*{d2}={d3}\");\n        }\n    }\n"}
{"id": 388025, "name": "Create a file on magnetic tape", "source": "Translate COBOL to Java:        >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. MAKE-TAPE-FILE.\n\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT TAPE-FILE\n        ASSIGN \"./TAPE.FILE\"\n        ORGANIZATION IS LINE SEQUENTIAL.\n\nDATA DIVISION.\nFILE SECTION.\nFD TAPE-FILE.\n01 TAPE-FILE-RECORD PIC X(51).\n\nPROCEDURE DIVISION.\n    OPEN OUTPUT SHARING WITH ALL OTHER TAPE-FILE\n    WRITE TAPE-FILE-RECORD \n        FROM \"COBOL treats tape files and text files identically.\"\n    END-WRITE\n    STOP RUN.\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\n\npublic class CreateFile {\n    public static void main(String[] args) throws IOException {\n        String os = System.getProperty(\"os.name\");\n        if (os.contains(\"Windows\")) {\n            Path path = Paths.get(\"tape.file\");\n            Files.write(path, Collections.singletonList(\"Hello World!\"));\n        } else {\n            Path path = Paths.get(\"/dev/tape\");\n            Files.write(path, Collections.singletonList(\"Hello World!\"));\n        }\n    }\n}\n"}
{"id": 388026, "name": "Recaman's sequence", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. RECAMAN.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 RECAMAN-SEQUENCE COMP.\n           02 A     PIC 999 OCCURS 99 TIMES INDEXED BY I.\n           02 N     PIC 999 VALUE 0.\n           \n        01 VARIABLES COMP.\n           02 ADDC  PIC S999.\n           02 SUBC  PIC S999.\n           02 SPTR  PIC 99 VALUE 1.\n           \n        01 OUTPUT-FORMAT.\n           02 OUTI  PIC Z9.\n           02 OUTN  PIC BZ9.\n           02 OUTS  PIC X(79).\n           \n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM GENERATE-NEXT-ITEM 15 TIMES.\n            PERFORM COLLATE-ITEM VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN 15.\n            DISPLAY 'First 15 items:' OUTS.\n        \n        FIND-REPEATING.\n            PERFORM GENERATE-NEXT-ITEM.\n            SET I TO 1.\n            SEARCH A VARYING I\n                WHEN I IS NOT LESS THAN N \n                    NEXT SENTENCE\n                WHEN A(I) IS EQUAL TO A(N)\n                    SUBTRACT 1 FROM N GIVING OUTI\n                    MOVE A(N) TO OUTN\n                    DISPLAY 'First repeated item: A(' OUTI ') =' OUTN\n                    STOP RUN.\n            GO TO FIND-REPEATING.\n        \n        GENERATE-NEXT-ITEM.\n            IF N IS EQUAL TO ZERO\n                MOVE ZERO TO A(1)\n            ELSE\n                ADD N, A(N) GIVING ADDC\n                SUBTRACT N FROM A(N) GIVING SUBC\n                IF SUBC IS NOT GREATER THAN ZERO\n                    MOVE ADDC TO A(N + 1)\n                ELSE\n                    SET I TO 1\n                    SEARCH A VARYING I\n                        WHEN I IS NOT LESS THAN N\n                            MOVE SUBC TO A(N + 1)\n                        WHEN A(I) IS EQUAL TO SUBC\n                            MOVE ADDC TO A(N + 1).\n            ADD 1 TO N.\n            \n        COLLATE-ITEM.\n            MOVE A(I) TO OUTN.\n            STRING OUTN DELIMITED BY SIZE INTO OUTS WITH POINTER SPTR.\n", "target": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class RecamanSequence {\n    public static void main(String[] args) {\n        List<Integer> a = new ArrayList<>();\n        a.add(0);\n\n        Set<Integer> used = new HashSet<>();\n        used.add(0);\n\n        Set<Integer> used1000 = new HashSet<>();\n        used1000.add(0);\n\n        boolean foundDup = false;\n        int n = 1;\n        while (n <= 15 || !foundDup || used1000.size() < 1001) {\n            int next = a.get(n - 1) - n;\n            if (next < 1 || used.contains(next)) {\n                next += 2 * n;\n            }\n            boolean alreadyUsed = used.contains(next);\n            a.add(next);\n            if (!alreadyUsed) {\n                used.add(next);\n                if (0 <= next && next <= 1000) {\n                    used1000.add(next);\n                }\n            }\n            if (n == 14) {\n                System.out.printf(\"The first 15 terms of the Recaman sequence are\u00a0: %s\\n\", a);\n            }\n            if (!foundDup && alreadyUsed) {\n                System.out.printf(\"The first duplicate term is a[%d] = %d\\n\", n, next);\n                foundDup = true;\n            }\n            if (used1000.size() == 1001) {\n                System.out.printf(\"Terms up to a[%d] are needed to generate 0 to 1000\\n\", n);\n            }\n            n++;\n        }\n    }\n}\n"}
{"id": 388027, "name": "Recaman's sequence", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. RECAMAN.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 RECAMAN-SEQUENCE COMP.\n           02 A     PIC 999 OCCURS 99 TIMES INDEXED BY I.\n           02 N     PIC 999 VALUE 0.\n           \n        01 VARIABLES COMP.\n           02 ADDC  PIC S999.\n           02 SUBC  PIC S999.\n           02 SPTR  PIC 99 VALUE 1.\n           \n        01 OUTPUT-FORMAT.\n           02 OUTI  PIC Z9.\n           02 OUTN  PIC BZ9.\n           02 OUTS  PIC X(79).\n           \n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM GENERATE-NEXT-ITEM 15 TIMES.\n            PERFORM COLLATE-ITEM VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN 15.\n            DISPLAY 'First 15 items:' OUTS.\n        \n        FIND-REPEATING.\n            PERFORM GENERATE-NEXT-ITEM.\n            SET I TO 1.\n            SEARCH A VARYING I\n                WHEN I IS NOT LESS THAN N \n                    NEXT SENTENCE\n                WHEN A(I) IS EQUAL TO A(N)\n                    SUBTRACT 1 FROM N GIVING OUTI\n                    MOVE A(N) TO OUTN\n                    DISPLAY 'First repeated item: A(' OUTI ') =' OUTN\n                    STOP RUN.\n            GO TO FIND-REPEATING.\n        \n        GENERATE-NEXT-ITEM.\n            IF N IS EQUAL TO ZERO\n                MOVE ZERO TO A(1)\n            ELSE\n                ADD N, A(N) GIVING ADDC\n                SUBTRACT N FROM A(N) GIVING SUBC\n                IF SUBC IS NOT GREATER THAN ZERO\n                    MOVE ADDC TO A(N + 1)\n                ELSE\n                    SET I TO 1\n                    SEARCH A VARYING I\n                        WHEN I IS NOT LESS THAN N\n                            MOVE SUBC TO A(N + 1)\n                        WHEN A(I) IS EQUAL TO SUBC\n                            MOVE ADDC TO A(N + 1).\n            ADD 1 TO N.\n            \n        COLLATE-ITEM.\n            MOVE A(I) TO OUTN.\n            STRING OUTN DELIMITED BY SIZE INTO OUTS WITH POINTER SPTR.\n", "target": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class RecamanSequence {\n    public static void main(String[] args) {\n        List<Integer> a = new ArrayList<>();\n        a.add(0);\n\n        Set<Integer> used = new HashSet<>();\n        used.add(0);\n\n        Set<Integer> used1000 = new HashSet<>();\n        used1000.add(0);\n\n        boolean foundDup = false;\n        int n = 1;\n        while (n <= 15 || !foundDup || used1000.size() < 1001) {\n            int next = a.get(n - 1) - n;\n            if (next < 1 || used.contains(next)) {\n                next += 2 * n;\n            }\n            boolean alreadyUsed = used.contains(next);\n            a.add(next);\n            if (!alreadyUsed) {\n                used.add(next);\n                if (0 <= next && next <= 1000) {\n                    used1000.add(next);\n                }\n            }\n            if (n == 14) {\n                System.out.printf(\"The first 15 terms of the Recaman sequence are\u00a0: %s\\n\", a);\n            }\n            if (!foundDup && alreadyUsed) {\n                System.out.printf(\"The first duplicate term is a[%d] = %d\\n\", n, next);\n                foundDup = true;\n            }\n            if (used1000.size() == 1001) {\n                System.out.printf(\"Terms up to a[%d] are needed to generate 0 to 1000\\n\", n);\n            }\n            n++;\n        }\n    }\n}\n"}
{"id": 388028, "name": "Sorting algorithms_Bead sort", "source": "Translate COBOL to Java:         >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. beadsort.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n01  filler.\n    03  row occurs 9 pic x(9).\n    03  r pic 99.\n    03  r1 pic 99.\n    03  r2 pic 99.\n    03  pole pic 99.\n    03  a-lim pic 99 value 9.\n    03  a pic 99.\n    03  array occurs 9 pic 9.\n01  NL pic x value x'0A'.\nprocedure division.\nstart-beadsort.\n\n    \n    compute a = random(seconds-past-midnight)\n    perform varying a from 1 by 1 until a > a-lim\n        compute array(a) = random() * 10\n    end-perform\n\n    perform display-array\n    display space 'initial array'\n\n    \n    perform varying r from 1 by 1 until r > a-lim\n        move all '.' to row(r)\n        perform varying pole from 1 by 1 until pole > array(r)\n            move 'o' to row(r)(pole:1)\n        end-perform\n    end-perform\n    display NL 'initial beads'\n    perform display-beads\n\n    \n    perform varying pole from 1 by 1 until pole > a-lim\n        move a-lim to r2\n        perform find-opening\n        compute r1 = r2 - 1\n        perform find-bead\n        perform until r1 = 0 \n            \n            move '.' to row(r1)(pole:1)\n            move 'o' to row(r2)(pole:1)\n            \n            compute r2 = r2 - 1\n            perform find-opening\n            compute r1 = r2 - 1\n            perform find-bead\n        end-perform\n    end-perform\n    display NL 'dropped beads'\n    perform display-beads\n\n    \n    perform varying r from 1 by 1 until r > a-lim\n        move 0 to array(r)\n        inspect row(r) tallying array(r)\n            for all 'o' before initial '.'\n    end-perform\n\n    perform display-array\n    display space 'sorted array'\n\n    stop run\n    .\nfind-opening.\n    perform varying r2 from r2 by -1\n    until r2 = 1 or row(r2)(pole:1) = '.'\n        continue\n    end-perform\n    .\nfind-bead.\n    perform varying r1 from r1 by -1\n    until r1 = 0 or row(r1)(pole:1) = 'o'\n        continue\n    end-perform\n    .\ndisplay-array.\n    display space\n    perform varying a from 1 by 1 until a > a-lim\n        display space array(a) with no advancing\n    end-perform\n    .\ndisplay-beads.\n    perform varying r from 1 by 1 until r > a-lim\n        display row(r)\n    end-perform\n    .\nend program beadsort.\n", "target": "public class BeadSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tBeadSort now=new BeadSort();\n\t\tint[] arr=new int[(int)(Math.random()*11)+5];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tarr[i]=(int)(Math.random()*10);\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tint[] sort=now.beadSort(arr);\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(sort);\n\t}\n\tint[] beadSort(int[] arr)\n\t{\n\t\tint max=a[0];\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]>max)\n\t\t\t\tmax=arr[i];\n\t\t\n\t\t\n\t\tchar[][] grid=new char[arr.length][max];\n\t\tint[] levelcount=new int[max];\n\t\tfor(int i=0;i<max;i++)\n\t\t{\n\t\t\tlevelcount[i]=0;\n\t\t\tfor(int j=0;j<arr.length;j++)\n\t\t\t\tgrid[j][i]='_';\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint num=arr[i];\n\t\t\tfor(int j=0;num>0;j++)\n\t\t\t{\n\t\t\t\tgrid[levelcount[j]++][j]='*';\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\tdisplay2D(grid);\n\t\t\n\t\tint[] sorted=new int[arr.length];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint putt=0;\n\t\t\tfor(int j=0;j<max&&grid[arr.length-1-i][j]=='*';j++)\n\t\t\t\tputt++;\n\t\t\tsorted[i]=putt;\n\t\t}\n\t\t\n\t\treturn sorted;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display1D(char[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display2D(char[][] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tdisplay1D(arr[i]);\n\t\tSystem.out.println();\n\t}\n}\n"}
{"id": 388029, "name": "Simple database", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. simple-database.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT OPTIONAL database-file ASSIGN Database-Path\n               ORGANIZATION INDEXED\n               ACCESS SEQUENTIAL\n               RECORD KEY data-title\n               ALTERNATE RECORD KEY data-tag\n                   WITH DUPLICATES\n               ALTERNATE RECORD KEY date-added\n                   WITH DUPLICATES\n               FILE STATUS file-status\n               .\n       DATA DIVISION.\n       FILE SECTION.\n       FD  database-file.\n       01  database-record.\n           \n           03  date-added          PIC 9(8).\n           03  data-tag            PIC X(20).\n           03  data-title          PIC X(50).\n           03  data-contents       PIC X(200).\n           \n           \n           03  FILLER              PIC X(50).\n\n       WORKING-STORAGE SECTION.\n       78  Database-Path           VALUE \"database.dat\".\n\n       01  file-status             PIC XX.\n           88  file-ok             VALUE \"00\".\n           88  duplicate-key       VALUE \"22\".\n           88  key-not-found       VALUE \"23\".\n\n       01  num-args                PIC 99.\n\n       01  action                  PIC XX.\n           88  create-entry        VALUE \"-c\".\n           88  remove-entry        VALUE \"-r\".\n           88  find-entry          VALUE \"-f\".\n           88  print-latest        VALUE \"-l\".\n           88  print-database      VALUES \"-a\", \"-d\", \"-t\".\n           \n           88  print-by-title      VALUE \"-a\".\n           88  print-by-date       VALUE \"-d\".\n           88  print-by-tag        VALUE \"-t\".\n           88  print-help          VALUES \"-h\", SPACES.\n\n       01  read-direction-flag     PIC X VALUE SPACE.\n           88  read-backwards      VALUE \"B\".\n\n       01  edited-date             PIC 9(4)/99/99.\n       PROCEDURE DIVISION.\n       DECLARATIVES.\n       database-file-error SECTION.\n           USE AFTER ERROR ON database-file\n\n           DISPLAY \"An error has occurred while using \" Database-Path\n               \". Error no. \" file-status\n           DISPLAY \"The program will terminate.\"\n\n           CLOSE database-file\n\n           GOBACK\n           .\n       END DECLARATIVES.\n\n       main-line.\n           DISPLAY 1 UPON ARGUMENT-NUMBER\n           ACCEPT action FROM ARGUMENT-VALUE\n\n           ACCEPT num-args FROM ARGUMENT-NUMBER\n\n           EVALUATE TRUE\n               WHEN create-entry\n                   IF num-args >= 4\n                       PERFORM write-entry\n                   ELSE\n                       DISPLAY \"-a requires arguments to enter in the \"\n                           \"database. See help (-h) for details.\"\n                   END-IF\n\n               WHEN remove-entry\n                   IF num-args >= 2\n                       PERFORM delete-entry\n                   ELSE\n                       DISPLAY \"-r requires the title of the entry to \"\n                           \"delete.\"\n                   END-IF\n\n               WHEN find-entry\n                   IF num-args >= 2\n                       PERFORM display-specified-entry\n                   ELSE\n                       DISPLAY \"-f requires the title of the entry to \"\n                           \"find.\"\n                   END-IF\n\n               WHEN print-latest\n                   PERFORM show-latest\n\n               WHEN print-database\n                   PERFORM show-database\n\n               WHEN print-help\n                   PERFORM show-general-help\n\n               WHEN OTHER\n                   DISPLAY action \" is not a valid option.\"\n           END-EVALUATE\n           \n           GOBACK\n           .\n       write-entry.\n           OPEN EXTEND database-file\n\n           DISPLAY 2 UPON ARGUMENT-NUMBER\n           ACCEPT data-tag FROM ARGUMENT-VALUE\n           DISPLAY 3 UPON ARGUMENT-NUMBER\n           ACCEPT data-title FROM ARGUMENT-VALUE\n           IF data-title = SPACES\n               DISPLAY \"The title cannot be blank.\"\n               PERFORM close-and-terminate\n           END-IF\n\n           DISPLAY 4 UPON ARGUMENT-NUMBER\n           ACCEPT data-contents FROM ARGUMENT-VALUE\n\n           ACCEPT date-added FROM DATE YYYYMMDD\n\n           WRITE database-record\n               INVALID KEY\n                   IF duplicate-key\n                       DISPLAY \"An entry in the database already has \"\n                           \"that title. Please choose a different \"\n                           \"title or remove the entry.\"\n                   ELSE\n                       PERFORM database-file-error\n                   END-IF\n           END-WRITE\n\n           PERFORM close-database\n           .\n       delete-entry.\n           PERFORM get-title-arg\n           OPEN I-O database-file\n           PERFORM read-title\n\n           DELETE database-file\n\n           PERFORM close-database\n           .\n       display-specified-entry.\n           PERFORM get-title-arg\n           OPEN INPUT database-file\n           PERFORM read-title\n\n           PERFORM show-record\n\n           PERFORM close-database\n           .\n       get-title-arg.\n           DISPLAY 2 UPON ARGUMENT-NUMBER\n           ACCEPT data-title FROM ARGUMENT-VALUE\n           .\n       read-title.\n           START database-file KEY IS = data-title\n               INVALID KEY\n                   IF key-not-found\n                       DISPLAY \"An entry with that title was not found.\"\n                       PERFORM close-and-terminate\n                   ELSE\n                       PERFORM database-file-error\n                   END-IF\n           END-START\n\n           READ database-file\n           .\n       close-and-terminate.\n            PERFORM close-database\n            GOBACK\n            .\n       show-latest.\n           OPEN INPUT database-file\n\n           PERFORM start-at-last-date\n           READ database-file\n           PERFORM show-record\n\n           PERFORM close-database\n           .\n       show-database.\n           OPEN INPUT database-file\n\n           EVALUATE TRUE\n               WHEN print-by-title\n                   \n                   CONTINUE\n               WHEN print-by-tag\n                   MOVE LOW-VALUES TO data-tag\n                   START database-file KEY IS > data-tag\n               WHEN print-by-date\n                   PERFORM start-at-last-date\n                   SET read-backwards TO TRUE\n           END-EVALUATE\n\n           PERFORM FOREVER\n               \n               IF NOT read-backwards\n                   READ database-file NEXT\n                       AT END\n                           EXIT PERFORM\n                   END-READ\n               ELSE\n                   READ database-file PREVIOUS\n                       AT END\n                           EXIT PERFORM\n                   END-READ\n               END-IF\n\n               PERFORM show-record\n               DISPLAY SPACE\n           END-PERFORM\n\n           PERFORM close-database\n           .\n       start-at-last-date.\n           MOVE HIGH-VALUES TO date-added\n           START database-file KEY IS < date-added\n           .\n       close-database.\n           CLOSE database-file\n           .\n       show-record.\n           MOVE date-added TO edited-date\n           DISPLAY \"Date added: \" edited-date \" Tag: \" data-tag\n           DISPLAY \"Title: \" data-title\n           DISPLAY \"Contents:\"\n           DISPLAY \"  \" FUNCTION TRIM(data-contents)\n           .\n       show-general-help.\n           DISPLAY \"Help: Possible options are:\"\n           DISPLAY \"  -a - Show all the entries (sorted by title).\"\n           DISPLAY \"  -c - Create a new entry in the database. -c needs\"\n               \" further arguments in this format:\"\n           DISPLAY '    \"tag\" \"title\" \"content\"'\n           DISPLAY \"    Max argument sizes (in characters): tag - 20, \"\n               \"title - 50, content - 200\"\n           DISPLAY \"    The title must be unique and not be blank.\"\n           DISPLAY \"  -d - Show all the entries sorted by date added.\"\n           DISPLAY \"  -f - Finds and displays entry with the title \"\n               \"provided. The title should be specified as shown for \"\n               \"-c.\"\n           DISPLAY \"  -h - Show this help menu.\"\n           DISPLAY \"  -l - Show the latest entry.\"\n           DISPLAY \"  -r - Remove the entry with the title provided. \"\n               \"The title should be specified as shown for -c.\"\n           DISPLAY \"  -t - Show all the entries sorted by tag.\"\n           .\n", "target": "import java.io.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class SimpleDatabase {\n\n    final static String filename = \"simdb.csv\";\n\n    public static void main(String[] args) {\n        if (args.length < 1 || args.length > 3) {\n            printUsage();\n            return;\n        }\n\n        switch (args[0].toLowerCase()) {\n            case \"add\":\n                addItem(args);\n                break;\n            case \"latest\":\n                printLatest(args);\n                break;\n            case \"all\":\n                printAll();\n                break;\n            default:\n                printUsage();\n                break;\n        }\n    }\n\n    private static class Item implements Comparable<Item>{\n        final String name;\n        final String date;\n        final String category;\n\n        Item(String n, String d, String c) {\n            name = n;\n            date = d;\n            category = c;\n        }\n\n        @Override\n        public int compareTo(Item item){\n            return date.compareTo(item.date);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s,%s,%s%n\", name, date, category);\n        }\n    }\n\n    private static void addItem(String[] input) {\n        if (input.length < 2) {\n            printUsage();\n            return;\n        }\n        List<Item> db = load();\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        String date = sdf.format(new Date());\n        String cat = (input.length == 3) ? input[2] : \"none\";\n        db.add(new Item(input[1], date, cat));\n        store(db);\n    }\n\n    private static void printLatest(String[] a) {\n        List<Item> db = load();\n        if (db.isEmpty()) {\n            System.out.println(\"No entries in database.\");\n            return;\n        }\n        Collections.sort(db);\n        if (a.length == 2) {\n            for (Item item : db)\n                if (item.category.equals(a[1]))\n                    System.out.println(item);\n        } else {\n            System.out.println(db.get(0));\n        }\n    }\n\n    private static void printAll() {\n        List<Item> db = load();\n        if (db.isEmpty()) {\n            System.out.println(\"No entries in database.\");\n            return;\n        }\n        Collections.sort(db);\n        for (Item item : db)\n            System.out.println(item);\n    }\n\n    private static List<Item> load() {\n        List<Item> db = new ArrayList<>();\n        try (Scanner sc = new Scanner(new File(filename))) {\n            while (sc.hasNext()) {\n                String[] item = sc.nextLine().split(\",\");\n                db.add(new Item(item[0], item[1], item[2]));\n            }\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n        return db;\n    }\n\n    private static void store(List<Item> db) {\n        try (FileWriter fw = new FileWriter(filename)) {\n            for (Item item : db)\n                fw.write(item.toString());\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n\n    private static void printUsage() {\n         System.out.println(\"Usage:\");\n         System.out.println(\"  simdb cmd [categoryName]\");\n         System.out.println(\"  add     add item, followed by optional category\");\n         System.out.println(\"  latest  print last added item(s), followed by \"\n                 + \"optional category\");\n         System.out.println(\"  all     print all\");\n         System.out.println(\"  For instance: add \\\"some item name\\\" \"\n                 + \"\\\"some category name\\\"\");\n    }\n}\n"}
{"id": 388030, "name": "Tau function", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. TAU-FUNCTION.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 TAU-VARS.\n          03 TOTAL              PIC 999.\n          03 N                  PIC 999.\n          03 FILLER             REDEFINES N.\n             05 FILLER          PIC 99.\n             05 FILLER          PIC 9.\n                88 N-EVEN       VALUES 0, 2, 4, 6, 8.\n          03 P                  PIC 999.\n          03 P-SQUARED          PIC 999.\n          03 N-DIV-P            PIC 999V999.\n          03 FILLER             REDEFINES N-DIV-P.\n             05 NEXT-N          PIC 999.\n             05 FILLER          PIC 999.\n                88 DIVISIBLE    VALUE ZERO.\n          03 F-COUNT            PIC 999.\n       01 CONTROL-VARS.\n          03 I                  PIC 999.\n       01 OUT-VARS.\n          03 OUT-ITM            PIC ZZ9.\n          03 OUT-STR            PIC X(80) VALUE SPACES.\n          03 OUT-PTR            PIC 99 VALUE 1.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SHOW-TAU VARYING I FROM 1 BY 1\n               UNTIL I IS GREATER THAN 100.\n           STOP RUN.\n       \n       SHOW-TAU.\n           MOVE I TO N.\n           PERFORM TAU.\n           MOVE TOTAL TO OUT-ITM.\n           STRING OUT-ITM DELIMITED BY SIZE INTO OUT-STR\n               WITH POINTER OUT-PTR.\n           IF OUT-PTR IS EQUAL TO 61,\n               DISPLAY OUT-STR,\n               MOVE 1 TO OUT-PTR.\n\n       TAU.\n           MOVE 1 TO TOTAL.\n           PERFORM POWER-OF-2 UNTIL NOT N-EVEN.\n           MOVE ZERO TO P-SQUARED.\n           PERFORM ODD-FACTOR THRU ODD-FACTOR-LOOP\n               VARYING P FROM 3 BY 2\n               UNTIL P-SQUARED IS GREATER THAN N.\n           IF N IS GREATER THAN 1,\n               MULTIPLY 2 BY TOTAL.\n       POWER-OF-2.\n           ADD 1 TO TOTAL.\n           DIVIDE 2 INTO N.\n       ODD-FACTOR.\n           MULTIPLY P BY P GIVING P-SQUARED.\n           MOVE 1 TO F-COUNT.\n       ODD-FACTOR-LOOP.\n           DIVIDE N BY P GIVING N-DIV-P.\n           IF DIVISIBLE,\n               MOVE NEXT-N TO N,\n               ADD 1 TO F-COUNT,\n               GO TO ODD-FACTOR-LOOP.\n           MULTIPLY F-COUNT BY TOTAL.\n", "target": "public class TauFunction {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 100;\n        System.out.printf(\"Count of divisors for the first %d positive integers:\\n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%3d\", divisorCount(n));\n            if (n % 20 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 388031, "name": "Tau function", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. TAU-FUNCTION.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 TAU-VARS.\n          03 TOTAL              PIC 999.\n          03 N                  PIC 999.\n          03 FILLER             REDEFINES N.\n             05 FILLER          PIC 99.\n             05 FILLER          PIC 9.\n                88 N-EVEN       VALUES 0, 2, 4, 6, 8.\n          03 P                  PIC 999.\n          03 P-SQUARED          PIC 999.\n          03 N-DIV-P            PIC 999V999.\n          03 FILLER             REDEFINES N-DIV-P.\n             05 NEXT-N          PIC 999.\n             05 FILLER          PIC 999.\n                88 DIVISIBLE    VALUE ZERO.\n          03 F-COUNT            PIC 999.\n       01 CONTROL-VARS.\n          03 I                  PIC 999.\n       01 OUT-VARS.\n          03 OUT-ITM            PIC ZZ9.\n          03 OUT-STR            PIC X(80) VALUE SPACES.\n          03 OUT-PTR            PIC 99 VALUE 1.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SHOW-TAU VARYING I FROM 1 BY 1\n               UNTIL I IS GREATER THAN 100.\n           STOP RUN.\n       \n       SHOW-TAU.\n           MOVE I TO N.\n           PERFORM TAU.\n           MOVE TOTAL TO OUT-ITM.\n           STRING OUT-ITM DELIMITED BY SIZE INTO OUT-STR\n               WITH POINTER OUT-PTR.\n           IF OUT-PTR IS EQUAL TO 61,\n               DISPLAY OUT-STR,\n               MOVE 1 TO OUT-PTR.\n\n       TAU.\n           MOVE 1 TO TOTAL.\n           PERFORM POWER-OF-2 UNTIL NOT N-EVEN.\n           MOVE ZERO TO P-SQUARED.\n           PERFORM ODD-FACTOR THRU ODD-FACTOR-LOOP\n               VARYING P FROM 3 BY 2\n               UNTIL P-SQUARED IS GREATER THAN N.\n           IF N IS GREATER THAN 1,\n               MULTIPLY 2 BY TOTAL.\n       POWER-OF-2.\n           ADD 1 TO TOTAL.\n           DIVIDE 2 INTO N.\n       ODD-FACTOR.\n           MULTIPLY P BY P GIVING P-SQUARED.\n           MOVE 1 TO F-COUNT.\n       ODD-FACTOR-LOOP.\n           DIVIDE N BY P GIVING N-DIV-P.\n           IF DIVISIBLE,\n               MOVE NEXT-N TO N,\n               ADD 1 TO F-COUNT,\n               GO TO ODD-FACTOR-LOOP.\n           MULTIPLY F-COUNT BY TOTAL.\n", "target": "public class TauFunction {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 100;\n        System.out.printf(\"Count of divisors for the first %d positive integers:\\n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%3d\", divisorCount(n));\n            if (n % 20 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 388032, "name": "Mertens function", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MERTENS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 M             PIC S99 OCCURS 1000 TIMES.\n          03 N             PIC 9(4).\n          03 K             PIC 9(4).\n          03 V             PIC 9(4).\n          03 IS-ZERO       PIC 99 VALUE 0.\n          03 CROSS-ZERO    PIC 99 VALUE 0.\n\n       01 OUTPUT-FORMAT.\n          03 OUT-ITEM. \n             05 OUT-NUM    PIC -9.\n             05 FILLER     PIC X VALUE SPACE.\n          03 OUT-LINE      PIC X(30) VALUE SPACES.\n          03 OUT-PTR       PIC 99 VALUE 4.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM GENERATE-MERTENS.\n           PERFORM WRITE-TABLE.\n           PERFORM COUNT-ZEROES.\n           STOP RUN.\n\n       GENERATE-MERTENS.\n           MOVE 1 TO M(1).\n           PERFORM MERTENS-OUTER-LOOP VARYING N FROM 2 BY 1\n               UNTIL N IS GREATER THAN 1000.\n    \n       MERTENS-OUTER-LOOP.\n           MOVE 1 TO M(N).\n           PERFORM MERTENS-INNER-LOOP VARYING K FROM 2 BY 1\n               UNTIL K IS GREATER THAN N.\n\n       MERTENS-INNER-LOOP.\n           DIVIDE N BY K GIVING V.\n           SUBTRACT M(V) FROM M(N).\n\n       WRITE-TABLE.\n           DISPLAY \"The first 99 Mertens numbers are: \"\n           PERFORM WRITE-ITEM VARYING N FROM 1 BY 1\n               UNTIL N IS GREATER THAN 99.\n  \n       WRITE-ITEM.\n           MOVE M(N) TO OUT-NUM.\n           STRING OUT-ITEM DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER OUT-PTR.\n           IF OUT-PTR IS EQUAL TO 31,\n               DISPLAY OUT-LINE,\n               MOVE 1 TO OUT-PTR.\n\n       COUNT-ZEROES.\n           PERFORM TEST-N-ZERO VARYING N FROM 2 BY 1\n               UNTIL N IS GREATER THAN 1000.\n           DISPLAY \"M(N) is zero \" IS-ZERO \" times.\".\n           DISPLAY \"M(N) crosses zero \" CROSS-ZERO \" times.\".\n\n       TEST-N-ZERO.\n           IF M(N) IS EQUAL TO ZERO,\n               ADD 1 TO IS-ZERO,\n               SUBTRACT 1 FROM N GIVING K,\n               IF M(K) IS NOT EQUAL TO ZERO,\n                   ADD 1 TO CROSS-ZERO.\n", "target": "public class MertensFunction {\n\n    public static void main(String[] args) {\n        System.out.printf(\"First 199 terms of the merten function are as follows:%n    \");\n        for ( int n = 1 ; n < 200 ; n++ ) {\n            System.out.printf(\"%2d  \", mertenFunction(n));\n            if ( (n+1) % 20 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n        \n        for ( int exponent = 3 ; exponent<= 8 ; exponent++ ) {\n            int zeroCount = 0;\n            int zeroCrossingCount = 0;\n            int positiveCount = 0;\n            int negativeCount = 0;\n            int mSum = 0;\n            int mMin = Integer.MAX_VALUE;\n            int mMinIndex = 0;\n            int mMax = Integer.MIN_VALUE;\n            int mMaxIndex = 0;\n            int nMax = (int) Math.pow(10, exponent);\n            for ( int n = 1 ; n <= nMax ; n++ ) {\n                int m = mertenFunction(n);\n                mSum += m;\n                if ( m < mMin ) {\n                    mMin = m;\n                    mMinIndex = n;\n                }\n                if ( m > mMax ) {\n                    mMax = m;\n                    mMaxIndex = n;\n                }\n                if ( m > 0 ) {\n                    positiveCount++;\n                }\n                if ( m < 0 ) {\n                    negativeCount++;\n                }\n                if ( m == 0 ) {\n                    zeroCount++;\n                }\n                if ( m == 0 && mertenFunction(n - 1) != 0 ) {\n                    zeroCrossingCount++;\n                }\n            }\n            System.out.printf(\"%nFor M(x) with x from 1 to\u00a0%,d%n\", nMax);        \n            System.out.printf(\"The maximum of M(x) is M(%,d) =\u00a0%,d.%n\", mMaxIndex, mMax);\n            System.out.printf(\"The minimum of M(x) is M(%,d) =\u00a0%,d.%n\", mMinIndex, mMin);\n            System.out.printf(\"The sum of M(x) is\u00a0%,d.%n\", mSum);\n            System.out.printf(\"The count of positive M(x) is\u00a0%,d, count of negative M(x) is\u00a0%,d.%n\", positiveCount, negativeCount);\n            System.out.printf(\"M(x) has\u00a0%,d zeroes in the interval.%n\", zeroCount);\n            System.out.printf(\"M(x) has\u00a0%,d crossings in the interval.%n\", zeroCrossingCount);\n        }\n    }\n    \n    private static int MU_MAX = 100_000_000;\n    private static int[] MU = null;\n    private static int[] MERTEN = null;\n        \n    \n    private static int mertenFunction(int n) {\n        if ( MERTEN != null ) {\n            return MERTEN[n];\n        }\n        \n        \n        MU = new int[MU_MAX+1];\n        MERTEN = new int[MU_MAX+1];\n        MERTEN[1] = 1;\n        int sqrt = (int) Math.sqrt(MU_MAX);\n        for ( int i = 0 ; i < MU_MAX ; i++ ) {\n            MU[i] = 1;\n        }\n        \n        for ( int i = 2 ; i <= sqrt ; i++ ) {\n            if ( MU[i] == 1 ) {\n                \n                for ( int j = i ; j <= MU_MAX ; j += i ) {\n                    MU[j] *= -i;\n                }\n                \n                for ( int j = i*i ; j <= MU_MAX ; j += i*i ) {\n                    MU[j] = 0;\n                }\n            }\n        }\n        \n        int sum = 1;\n        for ( int i = 2 ; i <= MU_MAX ; i++ ) {\n            if ( MU[i] == i ) {\n                MU[i] = 1;\n            }\n            else if ( MU[i] == -i ) {\n                MU[i] = -1;\n            }\n            else if ( MU[i] < 0 ) {\n                MU[i] = 1;               \n            }\n            else if ( MU[i] > 0 ) {\n                MU[i] = -1;\n            }\n            sum += MU[i];\n            MERTEN[i] = sum;\n        }\n        return MERTEN[n];\n    }\n\n}\n"}
{"id": 388033, "name": "Product of divisors", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  PRODUCT-OF-DIVISORS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 DIVISOR-PRODUCTS    PIC 9(9) OCCURS 50 TIMES.\n          03 NUM                 PIC 999.\n          03 MUL                 PIC 999.\n      \n       01 OUTPUT-FORMAT.\n          03 NUM-OUT             PIC Z(9)9.\n          03 LINE-PTR            PIC 99 VALUE 1.\n          03 OUT-LINE            PIC X(50) VALUE SPACES.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM INIT VARYING NUM FROM 1 BY 1\n               UNTIL NUM IS GREATER THAN 50.\n           PERFORM CALCULATE-MULTIPLES VARYING MUL FROM 1 BY 1\n               UNTIL MUL IS GREATER THAN 50.\n           PERFORM OUTPUT-NUM VARYING NUM FROM 1 BY 1\n               UNTIL NUM IS GREATER THAN 50.\n           STOP RUN.\n\n       INIT.\n           MOVE 1 TO DIVISOR-PRODUCTS(NUM).\n       \n       CALCULATE-MULTIPLES.\n           PERFORM MULTIPLY-NUM VARYING NUM FROM MUL BY MUL\n               UNTIL NUM IS GREATER THAN 50.\n \n       MULTIPLY-NUM.\n           MULTIPLY MUL BY DIVISOR-PRODUCTS(NUM).\n\n       OUTPUT-NUM.\n           MOVE DIVISOR-PRODUCTS(NUM) TO NUM-OUT.\n           STRING NUM-OUT DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER LINE-PTR.\n           IF LINE-PTR IS EQUAL TO 51,\n               DISPLAY OUT-LINE,\n               MOVE SPACES TO OUT-LINE,\n               MOVE 1 TO LINE-PTR.\n", "target": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 388034, "name": "Product of divisors", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  PRODUCT-OF-DIVISORS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 DIVISOR-PRODUCTS    PIC 9(9) OCCURS 50 TIMES.\n          03 NUM                 PIC 999.\n          03 MUL                 PIC 999.\n      \n       01 OUTPUT-FORMAT.\n          03 NUM-OUT             PIC Z(9)9.\n          03 LINE-PTR            PIC 99 VALUE 1.\n          03 OUT-LINE            PIC X(50) VALUE SPACES.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM INIT VARYING NUM FROM 1 BY 1\n               UNTIL NUM IS GREATER THAN 50.\n           PERFORM CALCULATE-MULTIPLES VARYING MUL FROM 1 BY 1\n               UNTIL MUL IS GREATER THAN 50.\n           PERFORM OUTPUT-NUM VARYING NUM FROM 1 BY 1\n               UNTIL NUM IS GREATER THAN 50.\n           STOP RUN.\n\n       INIT.\n           MOVE 1 TO DIVISOR-PRODUCTS(NUM).\n       \n       CALCULATE-MULTIPLES.\n           PERFORM MULTIPLY-NUM VARYING NUM FROM MUL BY MUL\n               UNTIL NUM IS GREATER THAN 50.\n \n       MULTIPLY-NUM.\n           MULTIPLY MUL BY DIVISOR-PRODUCTS(NUM).\n\n       OUTPUT-NUM.\n           MOVE DIVISOR-PRODUCTS(NUM) TO NUM-OUT.\n           STRING NUM-OUT DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER LINE-PTR.\n           IF LINE-PTR IS EQUAL TO 51,\n               DISPLAY OUT-LINE,\n               MOVE SPACES TO OUT-LINE,\n               MOVE 1 TO LINE-PTR.\n", "target": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 388035, "name": "Playing cards", "source": "Translate COBOL to Java:        identification division.\n       program-id. playing-cards.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       77 card             usage index.\n       01 deck.\n          05 cards occurs 52 times ascending key slot indexed by card.\n             10 slot       pic 99.\n             10 hand       pic 99.\n             10 suit       pic 9.\n             10 symbol     pic x(4).\n             10 rank       pic 99.\n\n       01 filler.\n          05 suit-name     pic x(8) occurs 4 times.\n\n      \n       01 base-s           constant as 4036985504.\n       01 base-h           constant as 4036985520.\n       01 base-d           constant as 4036985728.\n       01 base-c           constant as 4036985744.\n\n       01 sym              pic x(4) comp-x.\n       01 symx             redefines sym pic x(4).\n       77 s                pic 9.\n       77 r                pic 99.\n       77 c                pic 99.\n       77 hit              pic 9.\n       77 limiter          pic 9(6).\n\n       01 spades           constant as 1.\n       01 hearts           constant as 2.\n       01 diamonds         constant as 3.\n       01 clubs            constant as 4.\n\n       01 players          constant as 3.\n       01 cards-per        constant as 5.\n       01 deal             pic 99.\n       01 player           pic 99.\n\n       01 show-tally       pic zz.\n       01 show-rank        pic z(5).\n       01 arg              pic 9(10).\n       \n       procedure division.\n       cards-main.\n       perform seed\n       perform initialize-deck\n       perform shuffle-deck\n       perform deal-deck\n       perform display-hands\n       goback.\n      \n      \n       seed.\n           accept arg from command-line\n           if arg not equal 0 then\n               move random(arg) to c\n           end-if\n       .\n\n       initialize-deck.\n           move \"spades\" to suit-name(spades)\n           move \"hearts\" to suit-name(hearts)\n           move \"diamonds\" to suit-name(diamonds)\n           move \"clubs\" to suit-name(clubs)\n\n           perform varying s from 1 by 1 until s > 4\n                     after r from 1 by 1 until r > 13\n                   compute c = (s - 1) * 13 + r\n                   evaluate s\n                       when spades compute sym = base-s + r\n                       when hearts compute sym = base-h + r\n                       when diamonds compute sym = base-d + r\n                       when clubs compute sym = base-c + r\n                   end-evaluate\n                   if r > 11 then compute sym = sym + 1 end-if\n                   move s to suit(c)\n                   move r to rank(c)\n                   move symx to symbol(c)\n                   move zero to slot(c)\n                   move zero to hand(c)\n           end-perform\n       .\n\n       shuffle-deck.\n           move zero to limiter\n           perform until exit\n               compute c = random() * 52.0 + 1.0\n               move zero to hit\n               perform varying tally from 1 by 1 until tally > 52\n                   if slot(tally) equal c then\n                       move 1 to hit\n                       exit perform\n                   end-if\n                   if slot(tally) equal 0 then\n                       if tally < 52 then move 1 to hit end-if\n                       move c to slot(tally)\n                       exit perform\n                   end-if\n               end-perform\n               if hit equal zero then exit perform end-if\n               if limiter > 999999 then\n                   display \"too many shuffles, deck invalid\" upon syserr\n                   exit perform\n               end-if\n               add 1 to limiter\n           end-perform\n           sort cards ascending key slot\n       .\n\n       display-card.\n       >>IF ENGLISH IS DEFINED\n               move rank(tally) to show-rank\n               evaluate rank(tally) \n                   when 1 display \"  ace\" with no advancing\n                   when 2 thru 10 display show-rank with no advancing\n                   when 11 display \" jack\" with no advancing\n                   when 12 display \"queen\" with no advancing\n                   when 13 display \" king\" with no advancing\n               end-evaluate\n               display \" of \" suit-name(suit(tally)) with no advancing\n       >>ELSE\n               display symbol(tally) with no advancing\n       >>END-IF\n       .\n\n       display-deck.\n           perform varying tally from 1 by 1 until tally > 52\n               move tally to show-tally\n               display \"Card: \" show-tally\n                       \" currently in hand \" hand(tally)\n                       \" is \" with no advancing\n               perform display-card\n               display space\n           end-perform\n       .\n\n       display-hands.\n           perform varying player from 1 by 1 until player > players\n               move player to tally\n               display \"Player \" player \": \" with no advancing\n               perform varying deal from 1 by 1 until deal > cards-per\n                  perform display-card\n                  add players to tally\n               end-perform\n               display space\n           end-perform\n           display \"Stock: \" with no advancing\n           subtract players from tally\n           add 1 to tally\n           perform varying tally from tally by 1 until tally > 52\n               perform display-card\n       >>IF ENGLISH IS DEFINED\n               display space\n       >>END-IF\n           end-perform\n           display space\n       .\n\n       deal-deck.\n           display \"Dealing \" cards-per \" cards to \" players \" players\"\n           move 1 to tally\n           perform varying deal from 1 by 1 until deal > cards-per\n                     after player from 1 by 1 until player > players\n               move player to hand(tally)\n               add 1 to tally\n           end-perform\n       .\n\n       end program playing-cards.\n", "target": "public enum Pip { Two, Three, Four, Five, Six, Seven, \n    Eight, Nine, Ten, Jack, Queen, King, Ace }\n"}
{"id": 388036, "name": "Find the last Sunday of each month", "source": "Translate COBOL to Java:        program-id. last-sun.\n       data division.\n       working-storage section.\n       1 wk-date.\n        2 yr pic 9999.\n        2 mo pic 99 value 1.\n        2 da pic 99 value 1.\n       1 rd-date redefines wk-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 sunday pic 9(4) value 7.\n       procedure division.\n           display \"Enter a calendar year (1601 thru 9999): \"\n               with no advancing\n           accept yr\n           if yr >= 1601 and <= 9999\n               continue\n           else\n               display \"Invalid year\"\n               stop run\n           end-if\n           perform 12 times\n               move 1 to da\n               add 1 to mo\n               if mo > 12              \n                   move 12 to mo\n                   move 31 to da\n               end-if\n               compute int-date = function\n                   integer-of-date (rd-date)\n               if mo =12 and da = 31   \n                   continue\n               else\n                   subtract 1 from int-date\n               end-if\n               compute rd-date = function\n                   date-of-integer (int-date)\n               compute dow = function mod\n                   ((int-date - 1) 7) + 1\n               compute dow = function mod ((dow - sunday) 7)\n               subtract dow from da\n               display yr \"-\" mo \"-\" da\n               add 1 to mo\n           end-perform\n           stop run\n           .\n       end program last-sun.\n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 388037, "name": "Find the last Sunday of each month", "source": "Translate COBOL to Java:        program-id. last-sun.\n       data division.\n       working-storage section.\n       1 wk-date.\n        2 yr pic 9999.\n        2 mo pic 99 value 1.\n        2 da pic 99 value 1.\n       1 rd-date redefines wk-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 sunday pic 9(4) value 7.\n       procedure division.\n           display \"Enter a calendar year (1601 thru 9999): \"\n               with no advancing\n           accept yr\n           if yr >= 1601 and <= 9999\n               continue\n           else\n               display \"Invalid year\"\n               stop run\n           end-if\n           perform 12 times\n               move 1 to da\n               add 1 to mo\n               if mo > 12              \n                   move 12 to mo\n                   move 31 to da\n               end-if\n               compute int-date = function\n                   integer-of-date (rd-date)\n               if mo =12 and da = 31   \n                   continue\n               else\n                   subtract 1 from int-date\n               end-if\n               compute rd-date = function\n                   date-of-integer (int-date)\n               compute dow = function mod\n                   ((int-date - 1) 7) + 1\n               compute dow = function mod ((dow - sunday) 7)\n               subtract dow from da\n               display yr \"-\" mo \"-\" da\n               add 1 to mo\n           end-perform\n           stop run\n           .\n       end program last-sun.\n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 388038, "name": "Strange plus numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. STRANGE-PLUS-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE            PIC 999.\n          03 DIGITS               REDEFINES CANDIDATE,\n                                  PIC 9 OCCURS 3 TIMES.\n          03 LEFT-PAIR            PIC 99.\n             88 LEFT-PAIR-PRIME   VALUES 2, 3, 5, 7, 11, 13, 17.\n          03 RIGHT-PAIR           PIC 99. \n             88 RIGHT-PAIR-PRIME  VALUES 2, 3, 5, 7, 11, 13, 17.\n       01 OUT.\n          03 ROW                  PIC X(40) VALUE SPACES.\n          03 PTR                  PIC 99 VALUE 1.\n       \n       PROCEDURE DIVISION. \n       BEGIN. \n           PERFORM CHECK-STRANGE-NUMBER\n           VARYING CANDIDATE FROM 100 BY 1\n           UNTIL CANDIDATE IS GREATER THAN 500.\n           DISPLAY ROW.\n           STOP RUN.\n\n       CHECK-STRANGE-NUMBER. \n           ADD DIGITS(1), DIGITS(2) GIVING LEFT-PAIR.\n           ADD DIGITS(2), DIGITS(3) GIVING RIGHT-PAIR. \n           IF LEFT-PAIR-PRIME AND RIGHT-PAIR-PRIME,\n               PERFORM WRITE-STRANGE-NUMBER.\n\n       WRITE-STRANGE-NUMBER.\n           STRING CANDIDATE DELIMITED BY SIZE INTO ROW\n           WITH POINTER PTR.\n           ADD 1 TO PTR.\n           IF PTR IS GREATER THAN 40,\n               DISPLAY ROW,\n               MOVE SPACES TO ROW,\n               MOVE 1 TO PTR.\n", "target": "public class Strange {\n    private static final boolean[] p = {\n        false, false, true,  true,  false,\n        true,  false, true,  false, false,\n        false, true,  false, true,  false,\n        false, false, true,  false\n    };\n\n    public static boolean isstrange(long n) {\n        if (n < 10) return false;\n        for (; n >= 10; n /= 10) {\n            if (!p[(int)(n%10 + (n/10)%10)]) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        long nMin = Long.parseLong(args[0]);\n        long nMax = Long.parseLong(args[1]);\n        int k = 0;\n     \n        for (long n = nMin; n <= nMax; n++) {\n            if (isstrange(n)) {\n                System.out.print(n + (++k%10 != 0 ? \" \" : \"\\n\"));\n            }\n        }\n    }\n}\n"}
{"id": 388039, "name": "Strange plus numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. STRANGE-PLUS-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE            PIC 999.\n          03 DIGITS               REDEFINES CANDIDATE,\n                                  PIC 9 OCCURS 3 TIMES.\n          03 LEFT-PAIR            PIC 99.\n             88 LEFT-PAIR-PRIME   VALUES 2, 3, 5, 7, 11, 13, 17.\n          03 RIGHT-PAIR           PIC 99. \n             88 RIGHT-PAIR-PRIME  VALUES 2, 3, 5, 7, 11, 13, 17.\n       01 OUT.\n          03 ROW                  PIC X(40) VALUE SPACES.\n          03 PTR                  PIC 99 VALUE 1.\n       \n       PROCEDURE DIVISION. \n       BEGIN. \n           PERFORM CHECK-STRANGE-NUMBER\n           VARYING CANDIDATE FROM 100 BY 1\n           UNTIL CANDIDATE IS GREATER THAN 500.\n           DISPLAY ROW.\n           STOP RUN.\n\n       CHECK-STRANGE-NUMBER. \n           ADD DIGITS(1), DIGITS(2) GIVING LEFT-PAIR.\n           ADD DIGITS(2), DIGITS(3) GIVING RIGHT-PAIR. \n           IF LEFT-PAIR-PRIME AND RIGHT-PAIR-PRIME,\n               PERFORM WRITE-STRANGE-NUMBER.\n\n       WRITE-STRANGE-NUMBER.\n           STRING CANDIDATE DELIMITED BY SIZE INTO ROW\n           WITH POINTER PTR.\n           ADD 1 TO PTR.\n           IF PTR IS GREATER THAN 40,\n               DISPLAY ROW,\n               MOVE SPACES TO ROW,\n               MOVE 1 TO PTR.\n", "target": "public class Strange {\n    private static final boolean[] p = {\n        false, false, true,  true,  false,\n        true,  false, true,  false, false,\n        false, true,  false, true,  false,\n        false, false, true,  false\n    };\n\n    public static boolean isstrange(long n) {\n        if (n < 10) return false;\n        for (; n >= 10; n /= 10) {\n            if (!p[(int)(n%10 + (n/10)%10)]) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        long nMin = Long.parseLong(args[0]);\n        long nMax = Long.parseLong(args[1]);\n        int k = 0;\n     \n        for (long n = nMin; n <= nMax; n++) {\n            if (isstrange(n)) {\n                System.out.print(n + (++k%10 != 0 ? \" \" : \"\\n\"));\n            }\n        }\n    }\n}\n"}
{"id": 388040, "name": "Test integerness", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. INTEGERNESS-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  INTEGERS-OR-ARE-THEY.\n    05 POSSIBLE-INTEGER PIC S9(9)V9(9).\n    05 DEFINITE-INTEGER PIC S9(9).\n01  COMPLEX-NUMBER.\n    05 REAL-PART        PIC S9(9)V9(9).\n    05 IMAGINARY-PART   PIC S9(9)V9(9).\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    MOVE ZERO TO IMAGINARY-PART.\n    DIVIDE -28 BY 7 GIVING POSSIBLE-INTEGER.\n    PERFORM INTEGER-PARAGRAPH.\n    DIVIDE 28 BY 18 GIVING POSSIBLE-INTEGER.\n    PERFORM INTEGER-PARAGRAPH.\n    DIVIDE 3 BY 10000000000 GIVING POSSIBLE-INTEGER.\n    PERFORM INTEGER-PARAGRAPH.\nTEST-COMPLEX-PARAGRAPH.\n    MOVE ZERO TO REAL-PART.\n    MOVE 1 TO IMAGINARY-PART.\n    MOVE REAL-PART TO POSSIBLE-INTEGER.\n    PERFORM INTEGER-PARAGRAPH.\n    STOP RUN.\nINTEGER-PARAGRAPH.\n    IF IMAGINARY-PART IS EQUAL TO ZERO THEN PERFORM REAL-PARAGRAPH,\n    ELSE PERFORM COMPLEX-PARAGRAPH.\nREAL-PARAGRAPH.\n    MOVE POSSIBLE-INTEGER TO DEFINITE-INTEGER.\n    IF DEFINITE-INTEGER IS EQUAL TO POSSIBLE-INTEGER\n    THEN DISPLAY POSSIBLE-INTEGER ' IS AN INTEGER.',\n    ELSE DISPLAY POSSIBLE-INTEGER ' IS NOT AN INTEGER.'.\nCOMPLEX-PARAGRAPH.\n    DISPLAY REAL-PART '+' IMAGINARY-PART 'i IS NOT AN INTEGER.'.\n", "target": "import java.math.BigDecimal;\nimport java.util.List;\n\npublic class TestIntegerness {\n    private static boolean isLong(double d) {\n        return isLong(d, 0.0);\n    }\n\n    private static boolean isLong(double d, double tolerance) {\n        return (d - Math.floor(d)) <= tolerance || (Math.ceil(d) - d) <= tolerance;\n    }\n\n    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n    private static boolean isBigInteger(BigDecimal bd) {\n        try {\n            bd.toBigIntegerExact();\n            return true;\n        } catch (ArithmeticException ex) {\n            return false;\n        }\n    }\n\n    private static class Rational {\n        long num;\n        long denom;\n\n        Rational(int num, int denom) {\n            this.num = num;\n            this.denom = denom;\n        }\n\n        boolean isLong() {\n            return num % denom == 0;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s/%s\", num, denom);\n        }\n    }\n\n    private static class Complex {\n        double real;\n        double imag;\n\n        Complex(double real, double imag) {\n            this.real = real;\n            this.imag = imag;\n        }\n\n        boolean isLong() {\n            return TestIntegerness.isLong(real) && imag == 0.0;\n        }\n\n        @Override\n        public String toString() {\n            if (imag >= 0.0) {\n                return String.format(\"%s + %si\", real, imag);\n            }\n            return String.format(\"%s - %si\", real, imag);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Double> da = List.of(25.000000, 24.999999, 25.000100);\n        for (Double d : da) {\n            boolean exact = isLong(d);\n            System.out.printf(\"%.6f is %s integer%n\", d, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        double tolerance = 0.00001;\n        System.out.printf(\"With a tolerance of\u00a0%.5f:%n\", tolerance);\n        for (Double d : da) {\n            boolean fuzzy = isLong(d, tolerance);\n            System.out.printf(\"%.6f is %s integer%n\", d, fuzzy ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Double> fa = List.of(-2.1e120, -5e-2, Double.NaN, Double.POSITIVE_INFINITY);\n        for (Double f : fa) {\n            boolean exact = !f.isNaN() && !f.isInfinite() && isBigInteger(new BigDecimal(f.toString()));\n            System.out.printf(\"%s is %s integer%n\", f, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Complex> ca = List.of(new Complex(5.0, 0.0), new Complex(5.0, -5.0));\n        for (Complex c : ca) {\n            boolean exact = c.isLong();\n            System.out.printf(\"%s is %s integer%n\", c, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Rational> ra = List.of(new Rational(24, 8), new Rational(-5, 1), new Rational(17, 2));\n        for (Rational r : ra) {\n            boolean exact = r.isLong();\n            System.out.printf(\"%s is %s integer%n\", r, exact ? \"an\" : \"not an\");\n        }\n    }\n}\n"}
{"id": 388041, "name": "Selective file copy", "source": "Translate COBOL to Java:        01 ws-input-record.\n       :INPUT-RECORD:\n", "target": "import java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Scanner;\n\nclass CopysJ {\n\n  public static void main(String[] args) {\n    String ddname_IN  = \"copys.in.txt\";\n    String ddname_OUT = \"copys.out.txt\";\n    if (args.length >= 1) { ddname_IN  = args[0].length() > 0 ? args[0] : ddname_IN; }\n    if (args.length >= 2) { ddname_OUT = args[1].length() > 0 ? args[1] : ddname_OUT; }\n\n    File dd_IN = new File(ddname_IN);\n    File dd_OUT = new File(ddname_OUT);\n\n    try (\n      Scanner scanner_IN = new Scanner(dd_IN);\n      BufferedWriter writer_OUT = new BufferedWriter(new FileWriter(dd_OUT))\n      ) {\n      String a;\n      String b;\n      String c;\n      String d;\n      String c1;\n      String x = \"XXXXX\";\n      String data_IN;\n      String data_OUT;\n      int ib;\n\n      while (scanner_IN.hasNextLine()) {\n        data_IN = scanner_IN.nextLine();\n        ib = 0;\n        a = data_IN.substring(ib, ib += 5);\n        b = data_IN.substring(ib, ib += 5);\n        c = data_IN.substring(ib, ib += 4);\n        c1=Integer.toHexString(new Byte((c.getBytes())[0]).intValue());\n        if (c1.length()<2) { c1=\"0\" + c1; }\n        data_OUT = a + c1 + x;\n        writer_OUT.write(data_OUT);\n        writer_OUT.newLine();\n        System.out.println(data_IN);\n        System.out.println(data_OUT);\n        System.out.println();\n      }\n    }\n    catch (IOException ex) {\n      ex.printStackTrace();\n    }\n    return;\n  }\n}\n"}
{"id": 388042, "name": "Safe mode", "source": "Translate COBOL to Java:        identification division.\n       program-id. rexxtrial.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n\n       procedure division.\n      \n       display rexx(\"ADDRESS SYSTEM; 'ls rexxtrial.cob'; return 'fail'\")\n       display \"Exception: \" exception-status\n\n      \n       display \"Try with rexx-unrestricted\"\n       display rexx-unrestricted(\n           \"ADDRESS SYSTEM; 'ls -l rexxtrial.cob'; return 'success'\")\n       display \"No exception raised: \" exception-status\n       goback.\n       end program rexxtrial.\n", "target": "frink.parser.Frink interp = new frink.parser.Frink();\ninterp.setRestrictiveSecurity(true);\n"}
{"id": 388043, "name": "Window creation_X11", "source": "Translate COBOL to Java:        identification division.\n       program-id. x11-hello.\n       installation. cobc -x x11-hello.cob -lX11\n       remarks. Use of private data is likely not cross platform.\n\n       data division.\n       working-storage section.\n       01 msg.\n          05 filler            value z\"S'up, Earth?\".\n       01 msg-len              usage binary-long value 12.\n\n       01 x-display            usage pointer.\n       01 x-window             usage binary-c-long.\n\n      \n      \n      \n      \n       01 x-display-private    based.\n          05 x-ext-data        usage pointer sync.\n          05 private1          usage pointer.\n          05 x-fd              usage binary-long.\n          05 private2          usage binary-long.\n          05 proto-major-version   usage binary-long.\n          05 proto-minor-version   usage binary-long.\n          05 vendor            usage pointer sync.\n          05 private3          usage pointer.\n          05 private4          usage pointer.\n          05 private5          usage pointer.\n          05 private6          usage binary-long.\n          05 allocator         usage program-pointer sync.\n          05 byte-order        usage binary-long.\n          05 bitmap-unit       usage binary-long.\n          05 bitmap-pad        usage binary-long.\n          05 bitmap-bit-order  usage binary-long.\n          05 nformats          usage binary-long.\n          05 screen-format     usage pointer sync.\n          05 private8          usage binary-long.\n          05 x-release         usage binary-long.\n          05 private9          usage pointer sync.\n          05 private10         usage pointer sync.\n          05 qlen              usage binary-long.\n          05 last-request-read usage binary-c-long unsigned sync.\n          05 request           usage binary-c-long unsigned sync.\n          05 private11         usage pointer sync.\n          05 private12         usage pointer.\n          05 private13         usage pointer.\n          05 private14         usage pointer.\n          05 max-request-size  usage binary-long unsigned.\n          05 x-db              usage pointer sync.\n          05 private15         usage program-pointer sync.\n          05 display-name      usage pointer.\n          05 default-screen    usage binary-long.\n          05 nscreens          usage binary-long.\n          05 screens           usage pointer sync.\n          05 motion-buffer     usage binary-c-long unsigned.\n          05 private16         usage binary-c-long unsigned.\n          05 min-keycode       usage binary-long.\n          05 max-keycode       usage binary-long.\n          05 private17         usage pointer sync.\n          05 private18         usage pointer.\n          05 private19         usage binary-long.\n          05 x-defaults        usage pointer sync.\n          05 filler            pic x(256).\n\n       01 x-screen-private     based.\n          05 scr-ext-data      usage pointer sync.\n          05 display-back      usage pointer.\n          05 root              usage binary-c-long.\n          05 x-width           usage binary-long.\n          05 x-height          usage binary-long.\n          05 m-width           usage binary-long.\n          05 m-height          usage binary-long.\n          05 x-ndepths         usage binary-long.\n          05 depths            usage pointer sync.\n          05 root-depth        usage binary-long.\n          05 root-visual       usage pointer sync.\n          05 default-gc        usage pointer.\n          05 cmap              usage pointer.\n          05 white-pixel       usage binary-c-long unsigned sync.\n          05 black-pixel       usage binary-c-long unsigned.\n          05 max-maps          usage binary-long.\n          05 min-maps          usage binary-long.\n          05 backing-store     usage binary-long.\n          05 save_unders       usage binary-char.\n          05 root-input-mask   usage binary-c-long sync.\n          05 filler            pic x(256).\n\n       01 event.\n          05 e-type usage      binary-long.\n          05 filler            pic x(188).\n          05 filler            pic x(256).\n       01 Expose               constant as 12.\n       01 KeyPress             constant as 2.\n\n      \n       01 event-mask           usage binary-c-long value 32769.\n\n      \n       01 x-char-struct.\n          05 lbearing          usage binary-short.\n          05 rbearing          usage binary-short.\n          05 string-width      usage binary-short.\n          05 ascent            usage binary-short.\n          05 descent           usage binary-short.\n          05 attributes        usage binary-short unsigned.\n       01 font-direction       usage binary-long.\n       01 font-ascent          usage binary-long.\n       01 font-descent         usage binary-long.\n\n       01 XGContext            usage binary-c-long.\n       01 box-width            usage binary-long.\n       01 box-height           usage binary-long.\n\n      \n       procedure division.\n\n       call \"XOpenDisplay\" using by reference null returning x-display\n           on exception\n               display function module-id \" Error: \"\n                       \"no XOpenDisplay linkage, requires libX11\"\n                  upon syserr\n               stop run returning 1\n       end-call\n       if x-display equal null then\n           display function module-id \" Error: \"\n                   \"XOpenDisplay returned null\" upon syserr\n           stop run returning 1\n       end-if\n       set address of x-display-private to x-display\n\n       if screens equal null then\n           display function module-id \" Error: \"\n                   \"XOpenDisplay associated screen null\" upon syserr\n           stop run returning 1\n       end-if\n       set address of x-screen-private to screens\n\n       call \"XCreateSimpleWindow\" using\n           by value x-display root 10 10 200 50 1\n                    black-pixel white-pixel\n           returning x-window\n       call \"XStoreName\" using\n           by value x-display x-window by reference msg\n\n       call \"XSelectInput\" using by value x-display x-window event-mask\n\n       call \"XMapWindow\" using by value x-display x-window\n\n       call \"XGContextFromGC\" using by value default-gc\n           returning XGContext\n       call \"XQueryTextExtents\" using by value x-display XGContext\n           by reference msg by value msg-len\n           by reference font-direction font-ascent font-descent\n           x-char-struct\n       compute box-width = string-width + 8\n       compute box-height = font-ascent + font-descent + 8\n\n       perform forever\n          call \"XNextEvent\" using by value x-display by reference event\n          if e-type equal Expose then\n              call \"XDrawRectangle\" using\n                  by value x-display x-window default-gc 5 5\n                           box-width box-height\n              call \"XDrawString\" using\n                  by value x-display x-window default-gc 10 20\n                  by reference msg by value msg-len\n          end-if\n          if e-type equal KeyPress then exit perform end-if\n       end-perform\n\n       call \"XCloseDisplay\" using by value x-display\n\n       goback.\n       end program x11-hello.\n", "target": "import javax.swing.JFrame;\nimport javax.swing.SwingUtilities;\n\npublic class WindowExample {\n\n  public static void main(String[] args) {\n    Runnable runnable = new Runnable() {\n      public void run() {\n\tcreateAndShow();\n      }\n    };\n    SwingUtilities.invokeLater(runnable);\n  }\n\t\n  static void createAndShow() {\n    JFrame frame = new JFrame(\"Hello World\");\n    frame.setSize(640,480);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n  }\n}\n"}
{"id": 388044, "name": "Print debugging statement", "source": "Translate COBOL to Java: gcobol\n      \n      \n      \n      \n       identification division.\n       program-id. steptrace.\n\n       data division.\n       working-storage section.\n\n       procedure division.\n       steptrace-main.\n\n       display \"explicit line\" upon syserr\n\n    >>Ddisplay \"debug line\" upon syserr\n\n       display \"from \" FUNCTION MODULE-ID \" in \" FUNCTION MODULE-SOURCE\n       goback.\n       end program steptrace.\n", "target": "import java.util.Objects;\n\npublic class PrintDebugStatement {\n    \n    private static void printDebug(String message) {\n        Objects.requireNonNull(message);\n\n        RuntimeException exception = new RuntimeException();\n        StackTraceElement[] stackTrace = exception.getStackTrace();\n        \n        \n        StackTraceElement stackTraceElement = stackTrace[1];\n        String fileName = stackTraceElement.getFileName();\n        String className = stackTraceElement.getClassName();\n        String methodName = stackTraceElement.getMethodName();\n        int lineNumber = stackTraceElement.getLineNumber();\n\n        System.out.printf(\"[DEBUG][%s %s.%s#%d] %s\\n\", fileName, className, methodName, lineNumber, message);\n    }\n\n    private static void blah() {\n        printDebug(\"Made It!\");\n    }\n\n    public static void main(String[] args) {\n        printDebug(\"Hello world.\");\n        blah();\n\n        Runnable oops = () -> printDebug(\"oops\");\n        oops.run();\n    }\n}\n"}
{"id": 414313, "name": "Enforced immutability", "source": "Translate COBOL to C#: ENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nSPECIAL-NAMES.\n    SYMBOLIC CHARACTERS NUL IS 0, TAB IS 9.\n", "target": "readonly DateTime now = DateTime.Now;\n"}
{"id": 414314, "name": "Address of a variable", "source": "Translate COBOL to C#: data division.\nworking-storage section.\n01 ptr usage pointer.\n01 var pic x(64).\n\nprocedure division.\nset ptr to address of var.\n", "target": "int i = 5;\nint* p = &i;\n"}
{"id": 414315, "name": "Loops_Infinite", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Spam.\n\n       PROCEDURE DIVISION.\n           PERFORM UNTIL 1 <> 1\n               DISPLAY \"SPAM\"\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "while (true)\n{\n    Console.WriteLine(\"SPAM\");\n}\n"}
{"id": 414316, "name": "Function definition", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. myTest.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  x   PIC 9(3) VALUE 3.\n       01  y   PIC 9(3) VALUE 2.\n       01  z   PIC 9(9).\n       PROCEDURE DIVISION.\n           CALL \"myMultiply\" USING \n               BY CONTENT x, BY CONTENT y, \n               BY REFERENCE z.\n           DISPLAY z.\n           STOP RUN.\n       END PROGRAM myTest.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. myMultiply.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  x   PIC 9(3).\n       01  y   PIC 9(3).\n       01  z   PIC 9(9).\n       PROCEDURE DIVISION USING x, y, z.\n           MULTIPLY x BY y GIVING z.\n           EXIT PROGRAM.\n       END PROGRAM myMultiply.\n", "target": "static double multiply(double a, double b)\n{\n    return a * b;\n}\n"}
{"id": 414317, "name": "Terminal control_Dimensions", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. terminal-dimensions.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  num-lines PIC 9(3).\n       01  num-cols  PIC 9(3).\n\n       SCREEN SECTION.\n       01  display-screen.\n           03  LINE 01 COL 01 PIC 9(3) FROM num-lines.\n           03  LINE 01 COL 05 VALUE \"rows by \" .\n           03  LINE 01 COL 13 PIC 9(3) FROM num-cols.\n           03  LINE 01 COL 16 VALUE \" columns.\".\n\n       PROCEDURE DIVISION.\n           ACCEPT num-lines FROM LINES\n           ACCEPT num-cols FROM COLUMNS\n\n           DISPLAY display-screen\n\n      *    This pauses the program, as ncurses will immediately revert\n      *    back to the console when the program ends.\n           CALL \"C$SLEEP\" USING BY CONTENT 3\n\n           GOBACK\n           .\n", "target": "static void Main(string[] args)\n{\n    int bufferHeight = Console.BufferHeight;\n    int bufferWidth = Console.BufferWidth;\n    int windowHeight = Console.WindowHeight;\n    int windowWidth = Console.WindowWidth;\n\n    Console.Write(\"Buffer Height: \");\n    Console.WriteLine(bufferHeight);\n    Console.Write(\"Buffer Width: \");\n    Console.WriteLine(bufferWidth);\n    Console.Write(\"Window Height: \");\n    Console.WriteLine(windowHeight);\n    Console.Write(\"Window Width: \");\n    Console.WriteLine(windowWidth);\n    Console.ReadLine();\n}\n"}
{"id": 414318, "name": "Recaman's sequence", "source": "Translate COBOL to C#:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. RECAMAN.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 RECAMAN-SEQUENCE COMP.\n           02 A     PIC 999 OCCURS 99 TIMES INDEXED BY I.\n           02 N     PIC 999 VALUE 0.\n           \n        01 VARIABLES COMP.\n           02 ADDC  PIC S999.\n           02 SUBC  PIC S999.\n           02 SPTR  PIC 99 VALUE 1.\n           \n        01 OUTPUT-FORMAT.\n           02 OUTI  PIC Z9.\n           02 OUTN  PIC BZ9.\n           02 OUTS  PIC X(79).\n           \n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM GENERATE-NEXT-ITEM 15 TIMES.\n            PERFORM COLLATE-ITEM VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN 15.\n            DISPLAY 'First 15 items:' OUTS.\n        \n        FIND-REPEATING.\n            PERFORM GENERATE-NEXT-ITEM.\n            SET I TO 1.\n            SEARCH A VARYING I\n                WHEN I IS NOT LESS THAN N \n                    NEXT SENTENCE\n                WHEN A(I) IS EQUAL TO A(N)\n                    SUBTRACT 1 FROM N GIVING OUTI\n                    MOVE A(N) TO OUTN\n                    DISPLAY 'First repeated item: A(' OUTI ') =' OUTN\n                    STOP RUN.\n            GO TO FIND-REPEATING.\n        \n        GENERATE-NEXT-ITEM.\n            IF N IS EQUAL TO ZERO\n                MOVE ZERO TO A(1)\n            ELSE\n                ADD N, A(N) GIVING ADDC\n                SUBTRACT N FROM A(N) GIVING SUBC\n                IF SUBC IS NOT GREATER THAN ZERO\n                    MOVE ADDC TO A(N + 1)\n                ELSE\n                    SET I TO 1\n                    SEARCH A VARYING I\n                        WHEN I IS NOT LESS THAN N\n                            MOVE SUBC TO A(N + 1)\n                        WHEN A(I) IS EQUAL TO SUBC\n                            MOVE ADDC TO A(N + 1).\n            ADD 1 TO N.\n            \n        COLLATE-ITEM.\n            MOVE A(I) TO OUTN.\n            STRING OUTN DELIMITED BY SIZE INTO OUTS WITH POINTER SPTR.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RecamanSequence {\n    class Program {\n        static void Main(string[] args) {\n            List<int> a = new List<int>() { 0 };\n            HashSet<int> used = new HashSet<int>() { 0 };\n            HashSet<int> used1000 = new HashSet<int>() { 0 };\n            bool foundDup = false;\n            int n = 1;\n            while (n <= 15 || !foundDup || used1000.Count < 1001) {\n                int next = a[n - 1] - n;\n                if (next < 1 || used.Contains(next)) {\n                    next += 2 * n;\n                }\n                bool alreadyUsed = used.Contains(next);\n                a.Add(next);\n                if (!alreadyUsed) {\n                    used.Add(next);\n                    if (0 <= next && next <= 1000) {\n                        used1000.Add(next);\n                    }\n                }\n                if (n == 14) {\n                    Console.WriteLine(\"The first 15 terms of the Recaman sequence are: [{0}]\", string.Join(\", \", a));\n                }\n                if (!foundDup && alreadyUsed) {\n                    Console.WriteLine(\"The first duplicated term is a[{0}] = {1}\", n, next);\n                    foundDup = true;\n                }\n                if (used1000.Count == 1001) {\n                    Console.WriteLine(\"Terms up to a[{0}] are needed to generate 0 to 1000\", n);\n                }\n                n++;\n            }\n        }\n    }\n}\n"}
{"id": 414319, "name": "Recaman's sequence", "source": "Translate COBOL to C#:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. RECAMAN.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 RECAMAN-SEQUENCE COMP.\n           02 A     PIC 999 OCCURS 99 TIMES INDEXED BY I.\n           02 N     PIC 999 VALUE 0.\n           \n        01 VARIABLES COMP.\n           02 ADDC  PIC S999.\n           02 SUBC  PIC S999.\n           02 SPTR  PIC 99 VALUE 1.\n           \n        01 OUTPUT-FORMAT.\n           02 OUTI  PIC Z9.\n           02 OUTN  PIC BZ9.\n           02 OUTS  PIC X(79).\n           \n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM GENERATE-NEXT-ITEM 15 TIMES.\n            PERFORM COLLATE-ITEM VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN 15.\n            DISPLAY 'First 15 items:' OUTS.\n        \n        FIND-REPEATING.\n            PERFORM GENERATE-NEXT-ITEM.\n            SET I TO 1.\n            SEARCH A VARYING I\n                WHEN I IS NOT LESS THAN N \n                    NEXT SENTENCE\n                WHEN A(I) IS EQUAL TO A(N)\n                    SUBTRACT 1 FROM N GIVING OUTI\n                    MOVE A(N) TO OUTN\n                    DISPLAY 'First repeated item: A(' OUTI ') =' OUTN\n                    STOP RUN.\n            GO TO FIND-REPEATING.\n        \n        GENERATE-NEXT-ITEM.\n            IF N IS EQUAL TO ZERO\n                MOVE ZERO TO A(1)\n            ELSE\n                ADD N, A(N) GIVING ADDC\n                SUBTRACT N FROM A(N) GIVING SUBC\n                IF SUBC IS NOT GREATER THAN ZERO\n                    MOVE ADDC TO A(N + 1)\n                ELSE\n                    SET I TO 1\n                    SEARCH A VARYING I\n                        WHEN I IS NOT LESS THAN N\n                            MOVE SUBC TO A(N + 1)\n                        WHEN A(I) IS EQUAL TO SUBC\n                            MOVE ADDC TO A(N + 1).\n            ADD 1 TO N.\n            \n        COLLATE-ITEM.\n            MOVE A(I) TO OUTN.\n            STRING OUTN DELIMITED BY SIZE INTO OUTS WITH POINTER SPTR.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RecamanSequence {\n    class Program {\n        static void Main(string[] args) {\n            List<int> a = new List<int>() { 0 };\n            HashSet<int> used = new HashSet<int>() { 0 };\n            HashSet<int> used1000 = new HashSet<int>() { 0 };\n            bool foundDup = false;\n            int n = 1;\n            while (n <= 15 || !foundDup || used1000.Count < 1001) {\n                int next = a[n - 1] - n;\n                if (next < 1 || used.Contains(next)) {\n                    next += 2 * n;\n                }\n                bool alreadyUsed = used.Contains(next);\n                a.Add(next);\n                if (!alreadyUsed) {\n                    used.Add(next);\n                    if (0 <= next && next <= 1000) {\n                        used1000.Add(next);\n                    }\n                }\n                if (n == 14) {\n                    Console.WriteLine(\"The first 15 terms of the Recaman sequence are: [{0}]\", string.Join(\", \", a));\n                }\n                if (!foundDup && alreadyUsed) {\n                    Console.WriteLine(\"The first duplicated term is a[{0}] = {1}\", n, next);\n                    foundDup = true;\n                }\n                if (used1000.Count == 1001) {\n                    Console.WriteLine(\"Terms up to a[{0}] are needed to generate 0 to 1000\", n);\n                }\n                n++;\n            }\n        }\n    }\n}\n"}
{"id": 414320, "name": "Execute HQ9+", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Exec-Hq9.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       78  Code-Length VALUE 256.\n\n       01  i           PIC 999.\n       01  accumulator PIC 999.\n\n       01  bottles     PIC 999.\n\n       LINKAGE SECTION.\n       01  hq9-code    PIC X(Code-Length).\n       \n       PROCEDURE DIVISION USING BY VALUE hq9-code.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL Code-Length < i\n               EVALUATE hq9-code (i:1)\n                   WHEN \"Q\"\n                       DISPLAY FUNCTION TRIM(hq9-code)\n\n                   WHEN \"H\"\n                       DISPLAY \"Hello, World!\"\n\n                   WHEN \"9\"\n                       MOVE 99 TO bottles\n                       PERFORM UNTIL bottles = ZERO\n                           DISPLAY\n                               bottles \" bottles of beer on the wall\"\n                           DISPLAY bottles \" bottles of beer\"\n                           DISPLAY \"Take one down, pass it around\"\n                           SUBTRACT 1 FROM bottles\n                           DISPLAY\n                               bottles \" bottles of beer on the wall\"\n                           DISPLAY SPACE\n                       END-PERFORM\n\n                   WHEN \"+\"\n                       ADD 1 TO accumulator\n               END-EVALUATE\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void RunCode(string code)\n    {\n        int accumulator = 0;\n        var opcodes = new Dictionary<char, Action>\n        {\n            {'H', () => Console.WriteLine(\"Hello, World!\"))},\n            {'Q', () => Console.WriteLine(code) },\n            {'9', () => Console.WriteLine(Enumerable.Range(1,100).Reverse().Select(n => string.Format(\"{0} bottles of beer on the wall\\n{0} bottles of beer\\nTake one down, pass it around\\n{1} bottles of beer on the wall\\n\", n, n-1)).Aggregate((a,b) => a + \"\\n\" + b))},\n            {'+', () => accumulator++ }\n        }\n\n        foreach(var c in code)\n            opcodes[c]();\n    }\n}\n"}
{"id": 414321, "name": "Execute HQ9+", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Exec-Hq9.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       78  Code-Length VALUE 256.\n\n       01  i           PIC 999.\n       01  accumulator PIC 999.\n\n       01  bottles     PIC 999.\n\n       LINKAGE SECTION.\n       01  hq9-code    PIC X(Code-Length).\n       \n       PROCEDURE DIVISION USING BY VALUE hq9-code.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL Code-Length < i\n               EVALUATE hq9-code (i:1)\n                   WHEN \"Q\"\n                       DISPLAY FUNCTION TRIM(hq9-code)\n\n                   WHEN \"H\"\n                       DISPLAY \"Hello, World!\"\n\n                   WHEN \"9\"\n                       MOVE 99 TO bottles\n                       PERFORM UNTIL bottles = ZERO\n                           DISPLAY\n                               bottles \" bottles of beer on the wall\"\n                           DISPLAY bottles \" bottles of beer\"\n                           DISPLAY \"Take one down, pass it around\"\n                           SUBTRACT 1 FROM bottles\n                           DISPLAY\n                               bottles \" bottles of beer on the wall\"\n                           DISPLAY SPACE\n                       END-PERFORM\n\n                   WHEN \"+\"\n                       ADD 1 TO accumulator\n               END-EVALUATE\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void RunCode(string code)\n    {\n        int accumulator = 0;\n        var opcodes = new Dictionary<char, Action>\n        {\n            {'H', () => Console.WriteLine(\"Hello, World!\"))},\n            {'Q', () => Console.WriteLine(code) },\n            {'9', () => Console.WriteLine(Enumerable.Range(1,100).Reverse().Select(n => string.Format(\"{0} bottles of beer on the wall\\n{0} bottles of beer\\nTake one down, pass it around\\n{1} bottles of beer on the wall\\n\", n, n-1)).Aggregate((a,b) => a + \"\\n\" + b))},\n            {'+', () => accumulator++ }\n        }\n\n        foreach(var c in code)\n            opcodes[c]();\n    }\n}\n"}
{"id": 414322, "name": "Playing cards", "source": "Translate COBOL to C#:        identification division.\n       program-id. playing-cards.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       77 card             usage index.\n       01 deck.\n          05 cards occurs 52 times ascending key slot indexed by card.\n             10 slot       pic 99.\n             10 hand       pic 99.\n             10 suit       pic 9.\n             10 symbol     pic x(4).\n             10 rank       pic 99.\n\n       01 filler.\n          05 suit-name     pic x(8) occurs 4 times.\n\n      \n       01 base-s           constant as 4036985504.\n       01 base-h           constant as 4036985520.\n       01 base-d           constant as 4036985728.\n       01 base-c           constant as 4036985744.\n\n       01 sym              pic x(4) comp-x.\n       01 symx             redefines sym pic x(4).\n       77 s                pic 9.\n       77 r                pic 99.\n       77 c                pic 99.\n       77 hit              pic 9.\n       77 limiter          pic 9(6).\n\n       01 spades           constant as 1.\n       01 hearts           constant as 2.\n       01 diamonds         constant as 3.\n       01 clubs            constant as 4.\n\n       01 players          constant as 3.\n       01 cards-per        constant as 5.\n       01 deal             pic 99.\n       01 player           pic 99.\n\n       01 show-tally       pic zz.\n       01 show-rank        pic z(5).\n       01 arg              pic 9(10).\n       \n       procedure division.\n       cards-main.\n       perform seed\n       perform initialize-deck\n       perform shuffle-deck\n       perform deal-deck\n       perform display-hands\n       goback.\n      \n      \n       seed.\n           accept arg from command-line\n           if arg not equal 0 then\n               move random(arg) to c\n           end-if\n       .\n\n       initialize-deck.\n           move \"spades\" to suit-name(spades)\n           move \"hearts\" to suit-name(hearts)\n           move \"diamonds\" to suit-name(diamonds)\n           move \"clubs\" to suit-name(clubs)\n\n           perform varying s from 1 by 1 until s > 4\n                     after r from 1 by 1 until r > 13\n                   compute c = (s - 1) * 13 + r\n                   evaluate s\n                       when spades compute sym = base-s + r\n                       when hearts compute sym = base-h + r\n                       when diamonds compute sym = base-d + r\n                       when clubs compute sym = base-c + r\n                   end-evaluate\n                   if r > 11 then compute sym = sym + 1 end-if\n                   move s to suit(c)\n                   move r to rank(c)\n                   move symx to symbol(c)\n                   move zero to slot(c)\n                   move zero to hand(c)\n           end-perform\n       .\n\n       shuffle-deck.\n           move zero to limiter\n           perform until exit\n               compute c = random() * 52.0 + 1.0\n               move zero to hit\n               perform varying tally from 1 by 1 until tally > 52\n                   if slot(tally) equal c then\n                       move 1 to hit\n                       exit perform\n                   end-if\n                   if slot(tally) equal 0 then\n                       if tally < 52 then move 1 to hit end-if\n                       move c to slot(tally)\n                       exit perform\n                   end-if\n               end-perform\n               if hit equal zero then exit perform end-if\n               if limiter > 999999 then\n                   display \"too many shuffles, deck invalid\" upon syserr\n                   exit perform\n               end-if\n               add 1 to limiter\n           end-perform\n           sort cards ascending key slot\n       .\n\n       display-card.\n       >>IF ENGLISH IS DEFINED\n               move rank(tally) to show-rank\n               evaluate rank(tally) \n                   when 1 display \"  ace\" with no advancing\n                   when 2 thru 10 display show-rank with no advancing\n                   when 11 display \" jack\" with no advancing\n                   when 12 display \"queen\" with no advancing\n                   when 13 display \" king\" with no advancing\n               end-evaluate\n               display \" of \" suit-name(suit(tally)) with no advancing\n       >>ELSE\n               display symbol(tally) with no advancing\n       >>END-IF\n       .\n\n       display-deck.\n           perform varying tally from 1 by 1 until tally > 52\n               move tally to show-tally\n               display \"Card: \" show-tally\n                       \" currently in hand \" hand(tally)\n                       \" is \" with no advancing\n               perform display-card\n               display space\n           end-perform\n       .\n\n       display-hands.\n           perform varying player from 1 by 1 until player > players\n               move player to tally\n               display \"Player \" player \": \" with no advancing\n               perform varying deal from 1 by 1 until deal > cards-per\n                  perform display-card\n                  add players to tally\n               end-perform\n               display space\n           end-perform\n           display \"Stock: \" with no advancing\n           subtract players from tally\n           add 1 to tally\n           perform varying tally from tally by 1 until tally > 52\n               perform display-card\n       >>IF ENGLISH IS DEFINED\n               display space\n       >>END-IF\n           end-perform\n           display space\n       .\n\n       deal-deck.\n           display \"Dealing \" cards-per \" cards to \" players \" players\"\n           move 1 to tally\n           perform varying deal from 1 by 1 until deal > cards-per\n                     after player from 1 by 1 until player > players\n               move player to hand(tally)\n               add 1 to tally\n           end-perform\n       .\n\n       end program playing-cards.\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic struct Card\n{\n    public Card(string rank, string suit) : this()\n    {\n        Rank = rank;\n        Suit = suit;\n    }\n\n    public string Rank { get; }\n    public string Suit { get; }\n\n    public override string ToString() => $\"{Rank} of {Suit}\";\n}\n\npublic class Deck : IEnumerable<Card>\n{\n    static readonly string[] ranks = { \"Two\", \"Three\", \"Four\", \"Five\", \"Six\",\n        \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Jack\", \"Queen\", \"King\", \"Ace\" };\n    static readonly string[] suits = { \"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\" };\n    readonly List<Card> cards;\n \n    public Deck() {\n        cards = (from suit in suits\n                from rank in ranks\n                select new Card(rank, suit)).ToList();\n    }\n\n    public int Count => cards.Count;\n\n    public void Shuffle() {\n        \n        var random = new Random();\n        for (int i = 0; i < cards.Count; i++) {\n            int r = random.Next(i, cards.Count);\n            var temp = cards[i];\n            cards[i] = cards[r];\n            cards[r] = temp;\n        }\n    }\n\n    public Card Deal() {\n        int last = cards.Count - 1;\n        Card card = cards[last];\n        \n        \n        cards.RemoveAt(last);\n        return card;\n    }\n\n    public IEnumerator<Card> GetEnumerator() {\n        \n        \n        for (int i = cards.Count - 1; i >= 0; i--)\n            yield return cards[i];\n    }\n\n    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n}\n"}
{"id": 414323, "name": "Find the last Sunday of each month", "source": "Translate COBOL to C#:        program-id. last-sun.\n       data division.\n       working-storage section.\n       1 wk-date.\n        2 yr pic 9999.\n        2 mo pic 99 value 1.\n        2 da pic 99 value 1.\n       1 rd-date redefines wk-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 sunday pic 9(4) value 7.\n       procedure division.\n           display \"Enter a calendar year (1601 thru 9999): \"\n               with no advancing\n           accept yr\n           if yr >= 1601 and <= 9999\n               continue\n           else\n               display \"Invalid year\"\n               stop run\n           end-if\n           perform 12 times\n               move 1 to da\n               add 1 to mo\n               if mo > 12              \n                   move 12 to mo\n                   move 31 to da\n               end-if\n               compute int-date = function\n                   integer-of-date (rd-date)\n               if mo =12 and da = 31   \n                   continue\n               else\n                   subtract 1 from int-date\n               end-if\n               compute rd-date = function\n                   date-of-integer (int-date)\n               compute dow = function mod\n                   ((int-date - 1) 7) + 1\n               compute dow = function mod ((dow - sunday) 7)\n               subtract dow from da\n               display yr \"-\" mo \"-\" da\n               add 1 to mo\n           end-perform\n           stop run\n           .\n       end program last-sun.\n", "target": "using System;\n\nnamespace LastSundayOfEachMonth\n{\n    class Program\n    {\n        static void Main()\n        {\n            Console.Write(\"Year to calculate: \");\n\n            string strYear = Console.ReadLine();\n            int year = Convert.ToInt32(strYear);\n\n            DateTime date;\n            for (int i = 1; i <= 12; i++)\n            {\n                date = new DateTime(year, i, DateTime.DaysInMonth(year, i), System.Globalization.CultureInfo.CurrentCulture.Calendar);\n                \n                \n                int daysOffset = date.DayOfWeek - dayOfWeek; \n                if (daysOffset < 0) daysOffset += 7; \n                date = date.AddDays(-daysOffset ); \n                Console.WriteLine(date.ToString(\"yyyy-MM-dd\"));\n            }\n        }\n    }\n}\n"}
{"id": 414324, "name": "Find the last Sunday of each month", "source": "Translate COBOL to C#:        program-id. last-sun.\n       data division.\n       working-storage section.\n       1 wk-date.\n        2 yr pic 9999.\n        2 mo pic 99 value 1.\n        2 da pic 99 value 1.\n       1 rd-date redefines wk-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 sunday pic 9(4) value 7.\n       procedure division.\n           display \"Enter a calendar year (1601 thru 9999): \"\n               with no advancing\n           accept yr\n           if yr >= 1601 and <= 9999\n               continue\n           else\n               display \"Invalid year\"\n               stop run\n           end-if\n           perform 12 times\n               move 1 to da\n               add 1 to mo\n               if mo > 12              \n                   move 12 to mo\n                   move 31 to da\n               end-if\n               compute int-date = function\n                   integer-of-date (rd-date)\n               if mo =12 and da = 31   \n                   continue\n               else\n                   subtract 1 from int-date\n               end-if\n               compute rd-date = function\n                   date-of-integer (int-date)\n               compute dow = function mod\n                   ((int-date - 1) 7) + 1\n               compute dow = function mod ((dow - sunday) 7)\n               subtract dow from da\n               display yr \"-\" mo \"-\" da\n               add 1 to mo\n           end-perform\n           stop run\n           .\n       end program last-sun.\n", "target": "using System;\n\nnamespace LastSundayOfEachMonth\n{\n    class Program\n    {\n        static void Main()\n        {\n            Console.Write(\"Year to calculate: \");\n\n            string strYear = Console.ReadLine();\n            int year = Convert.ToInt32(strYear);\n\n            DateTime date;\n            for (int i = 1; i <= 12; i++)\n            {\n                date = new DateTime(year, i, DateTime.DaysInMonth(year, i), System.Globalization.CultureInfo.CurrentCulture.Calendar);\n                \n                \n                int daysOffset = date.DayOfWeek - dayOfWeek; \n                if (daysOffset < 0) daysOffset += 7; \n                date = date.AddDays(-daysOffset ); \n                Console.WriteLine(date.ToString(\"yyyy-MM-dd\"));\n            }\n        }\n    }\n}\n"}
{"id": 414325, "name": "Smallest square that begins with n", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. SMALLEST-SQUARE-BEGINS-WITH-N.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 N            PIC 99.\n       01 SQUARE-NO    PIC 999.\n       01 SQUARE       PIC 9(5).\n       01 OUT-FMT      PIC Z(4)9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SMALLEST-SQUARE THRU SQUARE-START-TEST\n               VARYING N FROM 1 BY 1 UNTIL N IS EQUAL TO 50.\n           STOP RUN.\n\n       SMALLEST-SQUARE.\n           MOVE ZERO TO SQUARE-NO.\n       SQUARE-LOOP.\n           ADD 1 TO SQUARE-NO.\n           MULTIPLY SQUARE-NO BY SQUARE-NO GIVING SQUARE.\n       SQUARE-START-TEST.\n           IF SQUARE IS GREATER THAN N\n               DIVIDE 10 INTO SQUARE\n               GO TO SQUARE-START-TEST.\n           IF SQUARE IS NOT EQUAL TO N\n               GO TO SQUARE-LOOP.\n           MULTIPLY SQUARE-NO BY SQUARE-NO GIVING OUT-FMT.\n           DISPLAY OUT-FMT.\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int i, d, s, t, n = 50, c = 1;\n        var sw = new int[n];\n        for (i = d = s = 1; c < n; i++, s += d += 2)\n            for (t = s; t > 0; t /= 10)\n                if (t < n && sw[t] < 1)\n                    Console.Write(\"\", sw[t] = s, c++);\n        Console.Write(string.Join(\" \", sw).Substring(2));\n    }\n}\n"}
{"id": 414326, "name": "Smallest square that begins with n", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. SMALLEST-SQUARE-BEGINS-WITH-N.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 N            PIC 99.\n       01 SQUARE-NO    PIC 999.\n       01 SQUARE       PIC 9(5).\n       01 OUT-FMT      PIC Z(4)9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SMALLEST-SQUARE THRU SQUARE-START-TEST\n               VARYING N FROM 1 BY 1 UNTIL N IS EQUAL TO 50.\n           STOP RUN.\n\n       SMALLEST-SQUARE.\n           MOVE ZERO TO SQUARE-NO.\n       SQUARE-LOOP.\n           ADD 1 TO SQUARE-NO.\n           MULTIPLY SQUARE-NO BY SQUARE-NO GIVING SQUARE.\n       SQUARE-START-TEST.\n           IF SQUARE IS GREATER THAN N\n               DIVIDE 10 INTO SQUARE\n               GO TO SQUARE-START-TEST.\n           IF SQUARE IS NOT EQUAL TO N\n               GO TO SQUARE-LOOP.\n           MULTIPLY SQUARE-NO BY SQUARE-NO GIVING OUT-FMT.\n           DISPLAY OUT-FMT.\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int i, d, s, t, n = 50, c = 1;\n        var sw = new int[n];\n        for (i = d = s = 1; c < n; i++, s += d += 2)\n            for (t = s; t > 0; t /= 10)\n                if (t < n && sw[t] < 1)\n                    Console.Write(\"\", sw[t] = s, c++);\n        Console.Write(string.Join(\" \", sw).Substring(2));\n    }\n}\n"}
{"id": 414327, "name": "Special divisors", "source": "Translate COBOL to C#:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. SPECIAL-DIVISORS.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 VARIABLES.\n           02 CANDIDATE         PIC 999.\n           02 CAND-REV          PIC 999.\n           02 REVERSE           PIC 999.\n           02 REV-DIGITS        REDEFINES REVERSE PIC 9 OCCURS 3 TIMES.\n           02 DIVMAX            PIC 999.\n           02 DIVISOR           PIC 999.\n           02 DIVRSLT           PIC 999V999.\n           02 FILLER            REDEFINES DIVRSLT.\n              03 FILLER         PIC 999.\n              03 FILLER         PIC 999.\n                 88 DIVISIBLE   VALUE 0.\n           02 TEMP              PIC 9.\n           02 RD                PIC 9 COMP.\n           02 STATUS-FLAG       PIC X.\n              88 OK             VALUE 'Y'.    \n           02 SPECIAL-N         PIC ZZ9.           \n\n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM CHECK-SPECIAL-DIVISOR\n                VARYING CANDIDATE FROM 1 BY 1\n                UNTIL CANDIDATE IS EQUAL TO 200.\n            STOP RUN.\n        \n        CHECK-SPECIAL-DIVISOR.\n            MOVE CANDIDATE TO REVERSE.\n            PERFORM REVERSE-NUMBER.\n            MOVE REVERSE TO CAND-REV.\n            DIVIDE CANDIDATE BY 2 GIVING DIVMAX.\n            MOVE 'Y' TO STATUS-FLAG.\n            PERFORM TRY-DIVISOR\n                VARYING DIVISOR FROM 1 BY 1\n                UNTIL DIVISOR IS GREATER THAN DIVMAX.\n            IF OK\n                MOVE CANDIDATE TO SPECIAL-N\n                DISPLAY SPECIAL-N.\n        \n        TRY-DIVISOR.\n            IF OK\n                DIVIDE CANDIDATE BY DIVISOR GIVING DIVRSLT\n                IF DIVISIBLE\n                    MOVE DIVISOR TO REVERSE\n                    PERFORM REVERSE-NUMBER\n                    DIVIDE CAND-REV BY REVERSE GIVING DIVRSLT\n                    IF NOT DIVISIBLE MOVE 'N' TO STATUS-FLAG.\n        \n        REVERSE-NUMBER.\n            SET RD TO 1.\n            INSPECT REVERSE TALLYING RD FOR LEADING '0'.\n            MOVE REV-DIGITS(RD) TO TEMP.\n            MOVE REV-DIGITS(3) TO REV-DIGITS(RD).\n            MOVE TEMP TO REV-DIGITS(3).\n", "target": "using System;\n\nnamespace SpecialDivisors {\n    class Program {\n        static int Reverse(int n) {\n            int result = 0;\n            while (n > 0) {\n                result = 10 * result + n % 10;\n                n /= 10;\n            }\n            return result;\n        }\n\n        static void Main() {\n            const int LIMIT = 200;\n\n            int row = 0;\n            int num = 0;\n\n            for (int n = 1; n < LIMIT; n++) {\n                bool flag = true;\n                int revNum = Reverse(n);\n\n                for (int m = 1; m < n / 2; m++) {\n                    int revDiv = Reverse(m);\n                    if (n % m == 0) {\n                        if (revNum % revDiv == 0) {\n                            flag = true;\n                        } else {\n                            flag = false;\n                            break;\n                        }\n                    }\n                }\n\n                if (flag) {\n                    num++;\n                    row++;\n                    Console.Write(\"{0,4}\", n);\n                    if (row % 10 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine();\n            Console.WriteLine();\n            Console.WriteLine(\"Found {0} special divisors N that reverse(D) divides reverse(N) for all divisors D of N, where N < 200\", num);\n        }\n    }\n}\n"}
{"id": 421516, "name": "Pseudo-random numbers_Middle-square method", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. MIDDLE-SQUARE.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 STATE.\n          03 SEED         PIC 9(6) VALUE 675248.\n          03 SQUARE       PIC 9(12).\n          03 FILLER       REDEFINES SQUARE.\n             05 FILLER    PIC 9(3).\n             05 NEXT-SEED PIC 9(6).\n             05 FILLER    PIC 9(3).\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SHOW-NUM 5 TIMES.\n           STOP RUN.\n       \n       SHOW-NUM.\n           PERFORM MAKE-RANDOM.\n           DISPLAY SEED.\n       \n       MAKE-RANDOM.\n           MULTIPLY SEED BY SEED GIVING SQUARE.\n           MOVE NEXT-SEED TO SEED.\n", "target": "seed = 675248\ndef random():\n    global seed\n    seed = int(str(seed ** 2).zfill(12)[3:9])\n    return seed\nfor _ in range(5):\n    print(random())\n"}
{"id": 421517, "name": "Use another language to call a function", "source": "Translate COBOL to Python:        identification division.\n       program-id. Query.\n\n       environment division.\n       configuration section.\n       special-names.\n           call-convention 0 is extern.\n\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 query-result.\n          05 filler value \"Here I am\".\n\n       linkage section.\n       01 data-reference.\n          05 data-buffer   pic x occurs 0 to 8192 times\n                                 depending on length-reference.\n       01 length-reference usage binary-long.\n\n       procedure division extern using data-reference length-reference.\n\n       if length(query-result) less than or equal to length-reference\n                           and length-reference less than 8193 then\n           move query-result to data-reference\n           move length(query-result) to length-reference\n           move 1 to return-code\n       end-if\n\n       goback.\n       end program Query.\n", "target": "\n\ndef query(buffer_length):\n    message = b'Here am I'\n    L = len(message)\n    return message[0:L*(L <= buffer_length)]\n"}
{"id": 421518, "name": "Colour bars_Display", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. terminal-colour-bars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  width           PIC 9(3).\n       01  height          PIC 9(3).\n\n       01  interval        PIC 9(3).\n\n       01  colours-area.\n           03  colour-values.\n               05  FILLER  PIC 9 VALUE 0. \n               05  FILLER  PIC 9 VALUE 4. \n               05  FILLER  PIC 9 VALUE 2. \n               05  FILLER  PIC 9 VALUE 1. \n               05  FILLER  PIC 9 VALUE 5. \n               05  FILLER  PIC 9 VALUE 3. \n               05  FILLER  PIC 9 VALUE 6. \n               05  FILLER  PIC 9 VALUE 7. \n\n           03  colour-table REDEFINES colour-values.\n               05  colours PIC 9 OCCURS 8 TIMES INDEXED BY colour-index.\n\n       01  i               PIC 9(3).\n       01  j               PIC 9(3).\n\n       PROCEDURE DIVISION.\n           ACCEPT width FROM COLUMNS\n           ACCEPT height FROM LINES\n           DIVIDE width BY 8 GIVING interval\n\n           PERFORM VARYING i FROM 1 BY 1 UNTIL height < i\n               PERFORM VARYING j FROM 1 BY 1 UNTIL width < j\n                  COMPUTE colour-index = (j / interval) + 1\n                  \n                  IF 8 < colour-index\n                      SET colour-index TO 8\n                  END-IF\n\n                  \n                  \n                  \n                  DISPLAY SPACE AT LINE i COLUMN j\n                      WITH BACKGROUND-COLOR colours (colour-index)\n               END-PERFORM\n           END-PERFORM\n\n           ACCEPT i \n\n           GOBACK\n           .\n", "target": "\n\n\nfrom livewires import *\n\nhoriz=640; vert=480\nbegin_graphics(width=horiz,height=vert,title=\"v_stripes\",background=Colour.black)\nNameColors=[\"black\",\"red\",\"green\",\"dark_blue\",\"purple\",\"blue\",\"yellow\",\"white\"]\nstepik=horiz/len(NameColors)\n\nfor index,each in enumerate(NameColors):\n\tExcStrng=\"set_colour(Colour.\"+each+\")\"\n\texec ExcStrng\n\tbox(index*stepik,0,(index+1)*stepik,vert,filled=1)\n\nwhile keys_pressed() != ['x']: \n\tpass\n\nend_graphics()\n"}
{"id": 421519, "name": "Colour bars_Display", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. terminal-colour-bars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  width           PIC 9(3).\n       01  height          PIC 9(3).\n\n       01  interval        PIC 9(3).\n\n       01  colours-area.\n           03  colour-values.\n               05  FILLER  PIC 9 VALUE 0. \n               05  FILLER  PIC 9 VALUE 4. \n               05  FILLER  PIC 9 VALUE 2. \n               05  FILLER  PIC 9 VALUE 1. \n               05  FILLER  PIC 9 VALUE 5. \n               05  FILLER  PIC 9 VALUE 3. \n               05  FILLER  PIC 9 VALUE 6. \n               05  FILLER  PIC 9 VALUE 7. \n\n           03  colour-table REDEFINES colour-values.\n               05  colours PIC 9 OCCURS 8 TIMES INDEXED BY colour-index.\n\n       01  i               PIC 9(3).\n       01  j               PIC 9(3).\n\n       PROCEDURE DIVISION.\n           ACCEPT width FROM COLUMNS\n           ACCEPT height FROM LINES\n           DIVIDE width BY 8 GIVING interval\n\n           PERFORM VARYING i FROM 1 BY 1 UNTIL height < i\n               PERFORM VARYING j FROM 1 BY 1 UNTIL width < j\n                  COMPUTE colour-index = (j / interval) + 1\n                  \n                  IF 8 < colour-index\n                      SET colour-index TO 8\n                  END-IF\n\n                  \n                  \n                  \n                  DISPLAY SPACE AT LINE i COLUMN j\n                      WITH BACKGROUND-COLOR colours (colour-index)\n               END-PERFORM\n           END-PERFORM\n\n           ACCEPT i \n\n           GOBACK\n           .\n", "target": "\n\n\nfrom livewires import *\n\nhoriz=640; vert=480\nbegin_graphics(width=horiz,height=vert,title=\"v_stripes\",background=Colour.black)\nNameColors=[\"black\",\"red\",\"green\",\"dark_blue\",\"purple\",\"blue\",\"yellow\",\"white\"]\nstepik=horiz/len(NameColors)\n\nfor index,each in enumerate(NameColors):\n\tExcStrng=\"set_colour(Colour.\"+each+\")\"\n\texec ExcStrng\n\tbox(index*stepik,0,(index+1)*stepik,vert,filled=1)\n\nwhile keys_pressed() != ['x']: \n\tpass\n\nend_graphics()\n"}
{"id": 421520, "name": "Enforced immutability", "source": "Translate COBOL to Python: ENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nSPECIAL-NAMES.\n    SYMBOLIC CHARACTERS NUL IS 0, TAB IS 9.\n", "target": ">>> s = \"Hello\"\n>>> s[0] = \"h\"\n\nTraceback (most recent call last):\n  File \"<pyshell\n    s[0] = \"h\"\nTypeError: 'str' object does not support item assignment\n"}
{"id": 421521, "name": "Strange numbers", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. STRANGE-NUMBERS.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 COMPUTATION.\n           02 NUM           PIC 999.\n           02 DIGITS        REDEFINES NUM PIC 9 OCCURS 3 TIMES.\n           02 DIGIT-PRIME   PIC 9.\n              88 PRIME      VALUES 2 3 5 7.\n           02 CUR-DIGIT     PIC 9.\n        01 OUTPUT-FORMAT.\n           02 N-OUT         PIC ZZ9.\n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM STRANGE-TEST\n                VARYING NUM FROM 100 BY 1\n                UNTIL NUM IS GREATER THAN 500.\n            STOP RUN.\n        \n        STRANGE-TEST SECTION.\n        BEGIN.\n            SET CUR-DIGIT TO 1.\n        STEP.   \n            IF DIGITS(CUR-DIGIT) IS LESS THAN DIGITS(CUR-DIGIT + 1)\n                SUBTRACT DIGITS(CUR-DIGIT + 1) FROM DIGITS(CUR-DIGIT) \n                    GIVING DIGIT-PRIME\n            ELSE\n                SUBTRACT DIGITS(CUR-DIGIT) FROM DIGITS(CUR-DIGIT + 1)\n                    GIVING DIGIT-PRIME.\n            IF PRIME NEXT SENTENCE ELSE GO TO DONE.\n            ADD 1 TO CUR-DIGIT.\n            IF CUR-DIGIT IS LESS THAN 3 GO TO STEP.\n            MOVE NUM TO N-OUT.\n            DISPLAY N-OUT.\n        DONE. EXIT.\n", "target": "\n\n\n\ndef isStrange(n):\n    \n    def test(a, b):\n        return abs(a - b) in [2, 3, 5, 7]\n\n    xs = digits(n)\n    return all(map(test, xs, xs[1:]))\n\n\n\n\ndef main():\n    \n\n    xs = [\n        n for n in range(100, 1 + 500)\n        if isStrange(n)\n    ]\n    print('\\nStrange numbers in range [100..500]\\n')\n    print('(Total: ' + str(len(xs)) + ')\\n')\n    print(\n        '\\n'.join(\n            ' '.join(\n                str(x) for x in row\n            ) for row in chunksOf(10)(xs)\n        )\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digits(n):\n    \n    return [int(c) for c in str(n)]\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 421522, "name": "Strange numbers", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. STRANGE-NUMBERS.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 COMPUTATION.\n           02 NUM           PIC 999.\n           02 DIGITS        REDEFINES NUM PIC 9 OCCURS 3 TIMES.\n           02 DIGIT-PRIME   PIC 9.\n              88 PRIME      VALUES 2 3 5 7.\n           02 CUR-DIGIT     PIC 9.\n        01 OUTPUT-FORMAT.\n           02 N-OUT         PIC ZZ9.\n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM STRANGE-TEST\n                VARYING NUM FROM 100 BY 1\n                UNTIL NUM IS GREATER THAN 500.\n            STOP RUN.\n        \n        STRANGE-TEST SECTION.\n        BEGIN.\n            SET CUR-DIGIT TO 1.\n        STEP.   \n            IF DIGITS(CUR-DIGIT) IS LESS THAN DIGITS(CUR-DIGIT + 1)\n                SUBTRACT DIGITS(CUR-DIGIT + 1) FROM DIGITS(CUR-DIGIT) \n                    GIVING DIGIT-PRIME\n            ELSE\n                SUBTRACT DIGITS(CUR-DIGIT) FROM DIGITS(CUR-DIGIT + 1)\n                    GIVING DIGIT-PRIME.\n            IF PRIME NEXT SENTENCE ELSE GO TO DONE.\n            ADD 1 TO CUR-DIGIT.\n            IF CUR-DIGIT IS LESS THAN 3 GO TO STEP.\n            MOVE NUM TO N-OUT.\n            DISPLAY N-OUT.\n        DONE. EXIT.\n", "target": "\n\n\n\ndef isStrange(n):\n    \n    def test(a, b):\n        return abs(a - b) in [2, 3, 5, 7]\n\n    xs = digits(n)\n    return all(map(test, xs, xs[1:]))\n\n\n\n\ndef main():\n    \n\n    xs = [\n        n for n in range(100, 1 + 500)\n        if isStrange(n)\n    ]\n    print('\\nStrange numbers in range [100..500]\\n')\n    print('(Total: ' + str(len(xs)) + ')\\n')\n    print(\n        '\\n'.join(\n            ' '.join(\n                str(x) for x in row\n            ) for row in chunksOf(10)(xs)\n        )\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digits(n):\n    \n    return [int(c) for c in str(n)]\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 421523, "name": "Hofstadter Q sequence", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. Q-SEQ.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 SEQ.\n           02 Q         PIC 9(3) OCCURS 1000 TIMES.\n           02 Q-TMP1    PIC 9(3).\n           02 Q-TMP2    PIC 9(3).\n           02 N         PIC 9(4).\n        01 DISPLAYING.\n           02 ITEM      PIC Z(3).\n           02 IX        PIC Z(4).\n            \n        PROCEDURE DIVISION.\n        MAIN-PROGRAM.    \n            PERFORM GENERATE-SEQUENCE.\n            PERFORM SHOW-ITEM\n                VARYING N FROM 1 BY 1 \n                UNTIL N IS GREATER THAN 10.\n            SET N TO 1000.\n            PERFORM SHOW-ITEM.\n            STOP RUN.\n        \n        GENERATE-SEQUENCE.\n            SET Q(1) TO 1.\n            SET Q(2) TO 1.            \n            PERFORM GENERATE-ITEM \n                VARYING N FROM 3 BY 1\n                UNTIL N IS GREATER THAN 1000.\n        \n        GENERATE-ITEM.\n            COMPUTE Q-TMP1 = N - Q(N - 1).\n            COMPUTE Q-TMP2 = N - Q(N - 2).\n            COMPUTE Q(N) = Q(Q-TMP1) + Q(Q-TMP2).\n                        \n        SHOW-ITEM.\n            MOVE N TO IX.\n            MOVE Q(N) TO ITEM.\n            DISPLAY 'Q(' IX ') = ' ITEM.\n", "target": "def q(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return q.seq[n]\n    except IndexError:\n        ans = q(n - q(n - 1)) + q(n - q(n - 2))\n        q.seq.append(ans)\n        return ans\nq.seq = [None, 1, 1]\n\nif __name__ == '__main__':\n    first10 = [q(i) for i in range(1,11)]\n    assert first10 == [1, 1, 2, 3, 3, 4, 5, 5, 6, 6], \"Q() value error(s)\"\n    print(\"Q(n) for n = [1..10] is:\", ', '.join(str(i) for i in first10))\n    assert q(1000) == 502, \"Q(1000) value error\"\n    print(\"Q(1000) =\", q(1000))\n"}
{"id": 421524, "name": "Hofstadter Q sequence", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. Q-SEQ.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 SEQ.\n           02 Q         PIC 9(3) OCCURS 1000 TIMES.\n           02 Q-TMP1    PIC 9(3).\n           02 Q-TMP2    PIC 9(3).\n           02 N         PIC 9(4).\n        01 DISPLAYING.\n           02 ITEM      PIC Z(3).\n           02 IX        PIC Z(4).\n            \n        PROCEDURE DIVISION.\n        MAIN-PROGRAM.    \n            PERFORM GENERATE-SEQUENCE.\n            PERFORM SHOW-ITEM\n                VARYING N FROM 1 BY 1 \n                UNTIL N IS GREATER THAN 10.\n            SET N TO 1000.\n            PERFORM SHOW-ITEM.\n            STOP RUN.\n        \n        GENERATE-SEQUENCE.\n            SET Q(1) TO 1.\n            SET Q(2) TO 1.            \n            PERFORM GENERATE-ITEM \n                VARYING N FROM 3 BY 1\n                UNTIL N IS GREATER THAN 1000.\n        \n        GENERATE-ITEM.\n            COMPUTE Q-TMP1 = N - Q(N - 1).\n            COMPUTE Q-TMP2 = N - Q(N - 2).\n            COMPUTE Q(N) = Q(Q-TMP1) + Q(Q-TMP2).\n                        \n        SHOW-ITEM.\n            MOVE N TO IX.\n            MOVE Q(N) TO ITEM.\n            DISPLAY 'Q(' IX ') = ' ITEM.\n", "target": "def q(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return q.seq[n]\n    except IndexError:\n        ans = q(n - q(n - 1)) + q(n - q(n - 2))\n        q.seq.append(ans)\n        return ans\nq.seq = [None, 1, 1]\n\nif __name__ == '__main__':\n    first10 = [q(i) for i in range(1,11)]\n    assert first10 == [1, 1, 2, 3, 3, 4, 5, 5, 6, 6], \"Q() value error(s)\"\n    print(\"Q(n) for n = [1..10] is:\", ', '.join(str(i) for i in first10))\n    assert q(1000) == 502, \"Q(1000) value error\"\n    print(\"Q(1000) =\", q(1000))\n"}
{"id": 421525, "name": "Count occurrences of a substring", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. testing.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  occurrences             PIC 99.\n\n       PROCEDURE DIVISION.\n           INSPECT \"the three truths\" TALLYING occurrences FOR ALL \"th\"\n           DISPLAY occurrences\n\n           MOVE 0 TO occurrences\n           INSPECT \"ababababab\" TALLYING occurrences FOR ALL \"abab\"\n           DISPLAY occurrences\n           \n           MOVE 0 TO occurrences\n           INSPECT \"abaabba*bbaba*bbab\" TALLYING occurrences\n               FOR ALL \"a*b\"\n           DISPLAY occurrences\n\n           GOBACK\n           .\n", "target": ">>> \"the three truths\".count(\"th\")\n3\n>>> \"ababababab\".count(\"abab\")\n2\n"}
{"id": 421526, "name": "Hickerson series of almost integers", "source": "Translate COBOL to Python:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. hickerson-series.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION ALL INTRINSIC\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  n                                   PIC 99 COMP.\n\n01  h                                   PIC Z(19)9.9(10).\n\n01  First-Decimal-Digit-Pos             CONSTANT 22.\n\nPROCEDURE DIVISION.\n    PERFORM VARYING n FROM 0 BY 1 UNTIL n > 17\n        COMPUTE h = FACTORIAL(n) / (2 * LOG(2) ** (n + 1))\n        DISPLAY \"h(\" n \") = \" h \" which is \" NO ADVANCING\n        IF h (First-Decimal-Digit-Pos:1) = \"0\" OR \"9\"\n            DISPLAY \"an almost integer.\"\n        ELSE\n            DISPLAY \"not an almost integer.\"\n        END-IF\n    END-PERFORM\n    .\nEND PROGRAM hickerson-series.\n", "target": "from decimal import Decimal\nimport math\n\ndef h(n):\n    'Simple, reduced precision calculation'\n    return math.factorial(n) / (2 * math.log(2) ** (n + 1))\n    \ndef h2(n):\n    'Extended precision Hickerson function'\n    return Decimal(math.factorial(n)) / (2 * Decimal(2).ln() ** (n + 1))\n\nfor n in range(18):\n    x = h2(n)\n    norm = str(x.normalize())\n    almostinteger = (' Nearly integer' \n                     if 'E' not in norm and ('.0' in norm or '.9' in norm) \n                     else ' NOT nearly integer!')\n    print('n:%2i h:%s%s' % (n, norm, almostinteger))\n"}
{"id": 421527, "name": "Hickerson series of almost integers", "source": "Translate COBOL to Python:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. hickerson-series.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION ALL INTRINSIC\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  n                                   PIC 99 COMP.\n\n01  h                                   PIC Z(19)9.9(10).\n\n01  First-Decimal-Digit-Pos             CONSTANT 22.\n\nPROCEDURE DIVISION.\n    PERFORM VARYING n FROM 0 BY 1 UNTIL n > 17\n        COMPUTE h = FACTORIAL(n) / (2 * LOG(2) ** (n + 1))\n        DISPLAY \"h(\" n \") = \" h \" which is \" NO ADVANCING\n        IF h (First-Decimal-Digit-Pos:1) = \"0\" OR \"9\"\n            DISPLAY \"an almost integer.\"\n        ELSE\n            DISPLAY \"not an almost integer.\"\n        END-IF\n    END-PERFORM\n    .\nEND PROGRAM hickerson-series.\n", "target": "from decimal import Decimal\nimport math\n\ndef h(n):\n    'Simple, reduced precision calculation'\n    return math.factorial(n) / (2 * math.log(2) ** (n + 1))\n    \ndef h2(n):\n    'Extended precision Hickerson function'\n    return Decimal(math.factorial(n)) / (2 * Decimal(2).ln() ** (n + 1))\n\nfor n in range(18):\n    x = h2(n)\n    norm = str(x.normalize())\n    almostinteger = (' Nearly integer' \n                     if 'E' not in norm and ('.0' in norm or '.9' in norm) \n                     else ' NOT nearly integer!')\n    print('n:%2i h:%s%s' % (n, norm, almostinteger))\n"}
{"id": 421528, "name": "Read a configuration file", "source": "Translate COBOL to Python:        identification division.\n       program-id. ReadConfiguration.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select config-file     assign to \"Configuration.txt\"\n                                  organization line sequential.\n       data division.\n       file section.\n\n       fd  config-file.\n       01  config-record          pic is x(128).\n\n       working-storage section.\n       77  idx                    pic 9(3).\n       77  pos                    pic 9(3).\n       77  last-pos               pic 9(3).\n       77  config-key             pic x(32).\n       77  config-value           pic x(64).\n       77  multi-value            pic x(64).\n       77  full-name              pic x(64).\n       77  favourite-fruit        pic x(64).\n       77  other-family           pic x(64) occurs 10.\n       77  need-speeling          pic x(5) value \"false\".\n       77  seeds-removed          pic x(5) value \"false\".\n\n       procedure division.\n       main.\n           open input config-file\n           perform until exit\n              read config-file\n                 at end\n                    exit perform\n              end-read  \n              move trim(config-record) to config-record\n              if config-record(1:1) = \"#\" or \";\" or spaces\n                 exit perform cycle\n              end-if\n              unstring config-record delimited by spaces into config-key\n              move trim(config-record(length(trim(config-key)) + 1:)) to config-value\n              if config-value(1:1) = \"=\"\n                 move trim(config-value(2:)) to config-value\n              end-if\n              evaluate upper-case(config-key)\n                 when \"FULLNAME\"\n                    move config-value to full-name\n                 when \"FAVOURITEFRUIT\"\n                    move config-value to favourite-fruit\n                 when \"NEEDSPEELING\"\n                    if config-value = spaces\n                       move \"true\" to config-value\n                    end-if\n                    if config-value = \"true\" or \"false\"\n                       move config-value to need-speeling\n                    end-if\n                 when \"SEEDSREMOVED\"\n                    if config-value = spaces\n                       move \"true\" to config-value\n                    end-if,\n                    if config-value = \"true\" or \"false\"\n                       move config-value to seeds-removed\n                    end-if\n                 when \"OTHERFAMILY\"\n                    move 1 to idx, pos\n                    perform until exit\n                       unstring config-value delimited by \",\" into multi-value with pointer pos\n                          on overflow\n                             move trim(multi-value) to other-family(idx)\n                             move pos to last-pos\n                          not on overflow\n                             if config-value(last-pos:) <> spaces\n                                move trim(config-value(last-pos:)) to other-family(idx)\n                             end-if,\n                             exit perform\n                       end-unstring\n                       add 1 to idx\n                    end-perform\n              end-evaluate\n           end-perform\n           close config-file\n\n           display \"fullname = \" full-name\n           display \"favouritefruit = \" favourite-fruit\n           display \"needspeeling = \" need-speeling\n           display \"seedsremoved = \" seeds-removed\n           perform varying idx from 1 by 1 until idx > 10\n              if other-family(idx) <> low-values\n                 display \"otherfamily(\" idx \") = \" other-family(idx)\n              end-if\n           end-perform\n           .\n", "target": "def readconf(fn):\n    ret = {}\n    with file(fn) as fp:\n        for line in fp:\n            \n            line = line.strip()\n            if not line or line.startswith('\n            \n            boolval = True\n            \n            if line.startswith(';'):\n                \n                line = line.lstrip(';')\n                \n                if len(line.split()) != 1: continue\n                boolval = False\n            \n            bits = line.split(None, 1)\n            if len(bits) == 1:\n                \n                k = bits[0]\n                v = boolval\n            else:\n                \n                k, v = bits\n            ret[k.lower()] = v\n    return ret\n\n\nif __name__ == '__main__':\n    import sys\n    conf = readconf(sys.argv[1])\n    for k, v in sorted(conf.items()):\n        print k, '=', v\n"}
{"id": 421529, "name": "Additive primes", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ADDITIVE-PRIMES.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 MAXIMUM            PIC 999.\n          03 AMOUNT             PIC 999.\n          03 CANDIDATE          PIC 999.\n          03 DIGIT              PIC 9 OCCURS 3 TIMES, \n                                REDEFINES CANDIDATE.\n          03 DIGITSUM           PIC 99.\n          \n       01 PRIME-DATA.\n          03 COMPOSITE-FLAG     PIC X OCCURS 500 TIMES.\n             88 PRIME           VALUE ' '.\n          03 SIEVE-PRIME        PIC 999.\n          03 SIEVE-COMP-START   PIC 999.\n          03 SIEVE-COMP         PIC 999.\n          03 SIEVE-MAX          PIC 999.\n       \n       01 OUT-FMT.\n          03 NUM-FMT            PIC ZZZ9.\n          03 OUT-LINE           PIC X(40).\n          03 OUT-PTR            PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 500 TO MAXIMUM.\n           MOVE 1 TO OUT-PTR.\n           PERFORM SIEVE.\n           MOVE ZERO TO AMOUNT.\n           PERFORM TEST-NUMBER \n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN MAXIMUM.\n           DISPLAY OUT-LINE.\n           DISPLAY SPACES.\n           MOVE AMOUNT TO NUM-FMT.\n           DISPLAY 'Amount of additive primes found: ' NUM-FMT.\n           STOP RUN.\n\n       TEST-NUMBER.\n           ADD DIGIT(1), DIGIT(2), DIGIT(3) GIVING DIGITSUM.\n           IF PRIME(CANDIDATE) AND PRIME(DIGITSUM),\n               ADD 1 TO AMOUNT,\n               PERFORM WRITE-NUMBER.\n       \n       WRITE-NUMBER.\n           MOVE CANDIDATE TO NUM-FMT.\n           STRING NUM-FMT DELIMITED BY SIZE INTO OUT-LINE \n               WITH POINTER OUT-PTR.\n           IF OUT-PTR IS GREATER THAN 40,\n               DISPLAY OUT-LINE,\n               MOVE SPACES TO OUT-LINE,\n               MOVE 1 TO OUT-PTR.               \n       \n       SIEVE.\n           MOVE SPACES TO PRIME-DATA.\n           DIVIDE MAXIMUM BY 2 GIVING SIEVE-MAX.\n           PERFORM SIEVE-OUTER-LOOP\n               VARYING SIEVE-PRIME FROM 2 BY 1\n               UNTIL SIEVE-PRIME IS GREATER THAN SIEVE-MAX.\n          \n       SIEVE-OUTER-LOOP.\n           IF PRIME(SIEVE-PRIME),\n               MULTIPLY SIEVE-PRIME BY 2 GIVING SIEVE-COMP-START,\n               PERFORM SIEVE-INNER-LOOP\n                   VARYING SIEVE-COMP \n                       FROM SIEVE-COMP-START BY SIEVE-PRIME\n                   UNTIL SIEVE-COMP IS GREATER THAN MAXIMUM.\n       \n       SIEVE-INNER-LOOP.\n           MOVE 'X' TO COMPOSITE-FLAG(SIEVE-COMP).\n", "target": "def is_prime(n: int) -> bool:\n    if n <= 3:\n        return n > 1\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i ** 2 <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef digit_sum(n: int) -> int:\n    sum = 0\n    while n > 0:\n        sum += n % 10\n        n //= 10\n    return sum\n\ndef main() -> None:\n    additive_primes = 0\n    for i in range(2, 500):\n        if is_prime(i) and is_prime(digit_sum(i)):\n            additive_primes += 1\n            print(i, end=\" \")\n    print(f\"\\nFound {additive_primes} additive primes less than 500\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 421530, "name": "Sorting algorithms_Stooge sort", "source": "Translate COBOL to Python:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. stooge-sort-test.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  Arr-Len                             CONSTANT 7.\n\n01  arr-area                            VALUE \"00004001000020000005000230000000000\".\n    03  arr-elt                         PIC 9(5) OCCURS Arr-Len TIMES\n                                        INDEXED BY arr-idx.\n\nPROCEDURE DIVISION.\n    DISPLAY \"Unsorted: \" NO ADVANCING\n    PERFORM VARYING arr-idx FROM 1 BY 1 UNTIL Arr-Len < arr-idx\n        DISPLAY arr-elt (arr-idx) \" \" NO ADVANCING\n    END-PERFORM\n    DISPLAY SPACE\n\n    CALL \"stooge-sort\" USING arr-area, OMITTED, OMITTED\n\n    DISPLAY \"Sorted:   \" NO ADVANCING\n    PERFORM VARYING arr-idx FROM 1 BY 1 UNTIL Arr-Len < arr-idx\n        DISPLAY arr-elt (arr-idx) \" \" NO ADVANCING\n    END-PERFORM\n    DISPLAY SPACE\n    .\nEND PROGRAM stooge-sort-test.\n    \n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. stooge-sort RECURSIVE.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  Arr-Len                             CONSTANT 7.\n\n01  i                                   PIC 99 COMP.\n01  j                                   PIC 99 COMP.\n\n01  temp                                PIC 9(5).\n\n01  t                                   PIC 99 COMP.\n\nLINKAGE SECTION.\n01  arr-area.\n    03  arr-elt                         PIC 9(5) OCCURS Arr-Len TIMES.\n\n01  i-val                               PIC 99 COMP.\n01  j-val                               PIC 99 COMP.\n\nPROCEDURE DIVISION USING arr-area, OPTIONAL i-val, OPTIONAL j-val.\n    IF i-val IS OMITTED\n        MOVE 1 TO i\n    ELSE\n        MOVE i-val TO i\n    END-IF\n    IF j-val IS OMITTED\n        MOVE Arr-Len TO j\n    ELSE\n        MOVE j-val TO j\n    END-IF\n    \n    IF arr-elt (j) < arr-elt (i)\n        MOVE arr-elt (i) TO temp\n        MOVE arr-elt (j) TO arr-elt (i)\n        MOVE temp TO arr-elt (j)\n    END-IF   \n    \n    IF j - i + 1 >= 3\n        COMPUTE t = (j - i + 1) / 3\n        SUBTRACT t FROM j\n        CALL \"stooge-sort\" USING arr-area, CONTENT i, j\n        ADD t TO i, j\n        CALL \"stooge-sort\" USING arr-area, CONTENT i, j\n        SUBTRACT t FROM i, j\n        CALL \"stooge-sort\" USING arr-area, CONTENT i, j\n    END-IF\n    .\nEND PROGRAM stooge-sort.\n", "target": ">>> data = [1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7]\n>>> def stoogesort(L, i=0, j=None):\n\tif j is None:\n\t\tj = len(L) - 1\n\tif L[j] < L[i]:\n\t\tL[i], L[j] = L[j], L[i]\n\tif j - i > 1:\n\t\tt = (j - i + 1) // 3\n\t\tstoogesort(L, i  , j-t)\n\t\tstoogesort(L, i+t, j  )\n\t\tstoogesort(L, i  , j-t)\n\treturn L\n\n>>> stoogesort(data)\n[-6, -5, -3, -2, 1, 3, 3, 4, 5, 5, 7, 7, 7, 9, 10]\n"}
{"id": 421531, "name": "Sorting algorithms_Shell sort", "source": "Translate COBOL to Python:       *******************************************************           \n       IDENTIFICATION DIVISION.                                         \n      *******************************************************           \n       PROGRAM-ID.      SHELLSRT.                                       \n      ************************************************************      \n      *** SHELLSORT                                           ****      \n      ************************************************************      \n       ENVIRONMENT DIVISION.                                            \n       DATA DIVISION.                                                   \n       WORKING-STORAGE SECTION.                                         \n       01 II                        PIC S9(008) COMP-5.                 \n       01 IJ                        PIC S9(008) COMP-5.                 \n       01 IZ                        PIC S9(008) COMP-5.                 \n       01 IA                        PIC S9(008) COMP-5.                 \n       01 STRT1                     PIC S9(008) COMP-5.                 \n       01 STRT2                     PIC S9(008) COMP-5.                 \n       01 LGT                       PIC S9(008) COMP-5.                 \n       01 ORG                       PIC S9(008) COMP-5.                 \n       01 DST                       PIC S9(008) COMP-5.                 \n      *                                                                 \n       01 GAP                       PIC S9(008) COMP-5.                 \n       01 NEGAP                     PIC S9(008) COMP-5.                 \n       01 TEMP                      PIC X(32768).                       \n       77 KEY-RESULT                PIC X.                              \n      *                                                                 \n       LINKAGE SECTION.                                                 \n       01 SRT-ARRAY                 PIC  X(1000000).                    \n       01 NUM-ITEM                  PIC  9(008) COMP-5.                 \n       01 SRT-DATA.                                                     \n          03 LGT-ITEM               PIC  9(004) COMP-5.                 \n          03 SRT-KEYS.                                                  \n             05 SRT-KEY OCCURS 10.                                      \n                07 K-START         PIC S9(004) COMP-5.                  \n                07 K-LENGTH        PIC S9(004) COMP-5.                  \n                07 K-ASC           PIC X.                               \n      *                                                                 \n      *    P R O C E D U R E      D I V I S I O N                       \n      *                                                                 \n       PROCEDURE DIVISION USING SRT-ARRAY NUM-ITEM SRT-DATA.                \n                                                                        \n           COMPUTE GAP = NUM-ITEM / 2.                                  \n           PERFORM UNTIL GAP < 1                                        \n              COMPUTE NEGAP = GAP * -1                                  \n              PERFORM VARYING II FROM GAP BY 1                          \n                        UNTIL II GREATER  NUM-ITEM                      \n                 MOVE ' ' TO KEY-RESULT                                 \n                 COMPUTE ORG = (II - 1) * LGT-ITEM + 1                  \n                 MOVE SRT-ARRAY(ORG:LGT-ITEM) TO TEMP(1:LGT-ITEM)       \n                 PERFORM VARYING IJ FROM II BY NEGAP                    \n                           UNTIL IJ NOT GREATER  GAP                    \n                              OR (KEY-RESULT NOT EQUAL '<' AND ' ')     \n                    COMPUTE IA = IJ - GAP                               \n                    IF IA < 1                                           \n                       MOVE 1 TO IA                                     \n                    END-IF                                              \n                    PERFORM COMPARE-KEYS                                \n                    IF KEY-RESULT = '<'                                 \n                       COMPUTE ORG = (IA - 1) * LGT-ITEM + 1            \n                       COMPUTE DST = (IJ - 1) * LGT-ITEM + 1            \n                       MOVE SRT-ARRAY(ORG:LGT-ITEM)                     \n                         TO SRT-ARRAY(DST:LGT-ITEM)                     \n                       COMPUTE DST = (IA - 1) * LGT-ITEM + 1            \n                       MOVE TEMP(1:LGT-ITEM) TO SRT-ARRAY(DST:LGT-ITEM) \n                    END-IF                                              \n                 END-PERFORM                                            \n              END-PERFORM                                               \n              IF GAP = 2                                                \n                 MOVE 1 TO GAP                                          \n              ELSE                                                      \n                 COMPUTE GAP = GAP / 2.2                                \n              END-IF                                                    \n           END-PERFORM.                                                 \n           GOBACK.                                                      \n      *                                                                 \n       COMPARE-KEYS.                                                    \n           MOVE ' ' TO KEY-RESULT                                       \n           PERFORM VARYING IZ FROM 1 BY 1                               \n                     UNTIL IZ GREATER 10                                \n                        OR (KEY-RESULT NOT EQUAL '=' AND ' ')           \n              IF SRT-KEY(IZ) GREATER LOW-VALUES                         \n                 COMPUTE STRT1 = (IJ - 1) * LGT-ITEM + K-START(IZ)      \n                 COMPUTE STRT2 = (IA - 1) * LGT-ITEM + K-START(IZ)      \n                 MOVE K-LENGTH(IZ) TO LGT                               \n                 IF SRT-ARRAY(STRT1:LGT) > SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'A'                                 \n                 OR SRT-ARRAY(STRT1:LGT) < SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'D'                                 \n                    MOVE '>' TO KEY-RESULT                              \n                 END-IF                                                 \n                 IF SRT-ARRAY(STRT1:LGT) < SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'A'                                 \n                 OR SRT-ARRAY(STRT1:LGT) > SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'D'                                 \n                    MOVE '<' TO KEY-RESULT                              \n                 END-IF                                                 \n              END-IF                                                    \n           END-PERFORM.                                                 \n           IF KEY-RESULT = ' '                                          \n              MOVE '=' TO KEY-RESULT                                    \n           END-IF.\n", "target": "def shell(seq):\n    inc = len(seq) // 2\n    while inc:\n        for i, el in enumerate(seq[inc:], inc):\n            while i >= inc and seq[i - inc] > el:\n                seq[i] = seq[i - inc]\n                i -= inc\n            seq[i] = el\n        inc = 1 if inc == 2 else inc * 5 // 11\n"}
{"id": 421532, "name": "Digit fifth powers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DIGIT-FIFTH-POWER.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE          PIC 9(6).\n          03 MAXIMUM            PIC 9(6).\n          03 DIGITS             PIC 9 OCCURS 6 TIMES,\n                                REDEFINES CANDIDATE.\n          03 DIGIT              PIC 9.\n          03 POWER-SUM          PIC 9(6).\n          03 TOTAL              PIC 9(6).\n\n       01 OUT-FORMAT.\n          03 OUT-NUM            PIC Z(5)9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE ZERO TO TOTAL.\n           COMPUTE MAXIMUM = 9 ** 5 * 6.\n           PERFORM TEST-NUMBER\n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN MAXIMUM.\n           DISPLAY '------ +'.\n           DISPLAY TOTAL.\n           STOP RUN.\n\n       TEST-NUMBER.\n           MOVE ZERO TO POWER-SUM.\n           PERFORM ADD-DIGIT-POWER\n               VARYING DIGIT FROM 1 BY 1\n               UNTIL DIGIT IS GREATER THAN 6.\n           IF POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO OUT-NUM,\n               DISPLAY OUT-NUM,\n               ADD CANDIDATE TO TOTAL.\n       \n       ADD-DIGIT-POWER.\n           COMPUTE POWER-SUM = POWER-SUM + DIGITS(DIGIT) ** 5.\n", "target": "from time import time\n\n\nst = time()\nprint(sum([n for n in range(2, 6*9**5) if sum(int(i)**5 for i in str(n)) == n]), \"  \", (time() - st) * 1000, \"ms\")\n\n\nst = time()\nnums = list(range(10))\nnu = list(range(((6 * 9**5) // 100000) + 1))\nnumbers = []\np5 = []\nfor i in nums: p5.append(i**5)\nfor i in nu:\n    im = i * 100000\n    ip = p5[i]\n    for j in nums:\n        jm = im + 10000 * j\n        jp = ip + p5[j]\n        for k in nums:\n            km = jm + 1000 * k\n            kp = jp + p5[k]\n            for l in nums:\n                lm = km + 100 * l\n                lp = kp + p5[l]\n                for m in nums:\n                    mm = lm + 10 * m\n                    mp = lp + p5[m]\n                    for n in nums:\n                        nm = mm + n\n                        np = mp + p5[n]\n                        if np == nm:\n                            if nm > 1: numbers.append(nm)\nprint(sum(numbers), \"  \", (time() - st) * 1000, \"ms\", end = \"\")\n"}
{"id": 421533, "name": "Digit fifth powers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DIGIT-FIFTH-POWER.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE          PIC 9(6).\n          03 MAXIMUM            PIC 9(6).\n          03 DIGITS             PIC 9 OCCURS 6 TIMES,\n                                REDEFINES CANDIDATE.\n          03 DIGIT              PIC 9.\n          03 POWER-SUM          PIC 9(6).\n          03 TOTAL              PIC 9(6).\n\n       01 OUT-FORMAT.\n          03 OUT-NUM            PIC Z(5)9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE ZERO TO TOTAL.\n           COMPUTE MAXIMUM = 9 ** 5 * 6.\n           PERFORM TEST-NUMBER\n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN MAXIMUM.\n           DISPLAY '------ +'.\n           DISPLAY TOTAL.\n           STOP RUN.\n\n       TEST-NUMBER.\n           MOVE ZERO TO POWER-SUM.\n           PERFORM ADD-DIGIT-POWER\n               VARYING DIGIT FROM 1 BY 1\n               UNTIL DIGIT IS GREATER THAN 6.\n           IF POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO OUT-NUM,\n               DISPLAY OUT-NUM,\n               ADD CANDIDATE TO TOTAL.\n       \n       ADD-DIGIT-POWER.\n           COMPUTE POWER-SUM = POWER-SUM + DIGITS(DIGIT) ** 5.\n", "target": "from time import time\n\n\nst = time()\nprint(sum([n for n in range(2, 6*9**5) if sum(int(i)**5 for i in str(n)) == n]), \"  \", (time() - st) * 1000, \"ms\")\n\n\nst = time()\nnums = list(range(10))\nnu = list(range(((6 * 9**5) // 100000) + 1))\nnumbers = []\np5 = []\nfor i in nums: p5.append(i**5)\nfor i in nu:\n    im = i * 100000\n    ip = p5[i]\n    for j in nums:\n        jm = im + 10000 * j\n        jp = ip + p5[j]\n        for k in nums:\n            km = jm + 1000 * k\n            kp = jp + p5[k]\n            for l in nums:\n                lm = km + 100 * l\n                lp = kp + p5[l]\n                for m in nums:\n                    mm = lm + 10 * m\n                    mp = lp + p5[m]\n                    for n in nums:\n                        nm = mm + n\n                        np = mp + p5[n]\n                        if np == nm:\n                            if nm > 1: numbers.append(nm)\nprint(sum(numbers), \"  \", (time() - st) * 1000, \"ms\", end = \"\")\n"}
{"id": 421534, "name": "McNuggets problem", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MCNUGGETS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 NUGGETS.\n          03 NUGGET-FLAGS     PIC X OCCURS 100 TIMES.\n             88 IS-NUGGET     VALUE 'X'.\n\n       01 A                   PIC 999.\n       01 B                   PIC 999.\n       01 C                   PIC 999.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE SPACES TO NUGGETS.\n           PERFORM A-LOOP VARYING A FROM 0 BY 6\n               UNTIL A IS GREATER THAN 100.\n           MOVE 100 TO A.\n\n       FIND-LARGEST.\n           IF IS-NUGGET(A), SUBTRACT 1 FROM A, GO TO FIND-LARGEST.\n           DISPLAY 'Largest non-McNugget number: ', A.\n           STOP RUN.\n \n       A-LOOP.\n           PERFORM B-LOOP VARYING B FROM A BY 9\n               UNTIL B IS GREATER THAN 100.\n\n       B-LOOP.\n           PERFORM C-LOOP VARYING C FROM B BY 20\n               UNTIL C IS GREATER THAN 100.\n \n       C-LOOP.\n           IF C IS NOT EQUAL TO ZERO, MOVE 'X' TO NUGGET-FLAGS(C).\n", "target": ">>> from itertools import product\n>>> nuggets = set(range(101))\n>>> for s, n, t in product(range(100//6+1), range(100//9+1), range(100//20+1)):\n\tnuggets.discard(6*s + 9*n + 20*t)\n\n\t\n>>> max(nuggets)\n43\n>>>\n"}
{"id": 421535, "name": "Idiomatically determine all the lowercase and uppercase letters", "source": "Translate COBOL to Python:        identification division.\n       program-id. determine.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 tx pic x.\n       01 lower-8bit pic x(256).\n       01 upper-8bit pic x(256).\n\n      \n      \n      \n\n       01 low-slide usage index.\n       01 high-slide usage index.\n\n       procedure division.\n       determining.\n\n      \n       set low-slide to 0\n       set high-slide to 0\n       perform varying tally from 1 by 1 until tally > 256\n           move char(tally) to tx\n           if tx is alphabetic-lower then\n               set low-slide up by 1\n               move tx to lower-8bit(low-slide:1)\n           end-if\n           if tx is alphabetic-upper then\n               set high-slide up by 1\n               move tx to upper-8bit(high-slide:1)\n           end-if\n       end-perform\n       if low-slide equal 0 then\n           display \"no lower case letters detected\" upon syserr\n       else\n           display lower-8bit(1:low-slide)\n       end-if\n       if high-slide equal 0 then\n           display \"no upper case letters detected\" upon syserr\n       else\n           display upper-8bit(1:high-slide)        \n       end-if\n\n      \n      \n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n\n       goback.\n       end program determine.\n", "target": "classes = (str.isupper, str.islower, str.isalnum, str.isalpha, str.isdecimal,\n           str.isdigit, str.isidentifier, str.isnumeric, str.isprintable,\n           str.isspace, str.istitle)\n\nfor stringclass in classes:\n    chars = ''.join(chr(i) for i in range(0x10FFFF+1) if stringclass(chr(i)))\n    print('\\nString class %s has %i characters the first of which are:\\n  %r'\n          % (stringclass.__name__, len(chars), chars[:100]))\n"}
{"id": 421536, "name": "Jaro similarity", "source": "Translate COBOL to Python:        identification division.\n       program-id. JaroDistance.\n \n       environment division.\n       configuration section.\n       repository.\n           function length intrinsic\n           function trim intrinsic\n           function max intrinsic\n           function min intrinsic\n           .\n \n       data division.\n       working-storage section.\n       77  s                      pic x(255).\n       77  t                      pic x(255).\n       77  s-length               pic 9(3).\n       77  t-length               pic 9(3).\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).\n       77  k                      pic 9(3).\n       77  start-pos              pic 9(3).\n       77  end-pos                pic 9(3).\n       77  match-distance         pic 9(3).\n       77  matches                pic 9(3).\n       77  transpositions         pic 9(3).\n       77  distance               pic 9v9(8).\n       \n       01  jaro-table.\n           05 filler              occurs 255.\n              10 filler           pic 9(1).\n                 88 s-matches     value 1 when set to false is 0.\n              10 filler           pic 9(1).\n                 88 t-matches     value 1 when set to false is 0.\n\n       procedure division.\n       main.\n           move \"MARTHA\" to s\n           move \"MARHTA\" to t\n           perform jaro-calc-and-show\n           move \"DIXON\" to s\n           move \"DICKSONX\" to t\n           perform jaro-calc-and-show\n           move \"JELLYFISH\" to s\n           move \"SMELLYFISH\" to t\n           perform jaro-calc-and-show\n           stop run\n           .\n       jaro-calc-and-show.\n           perform jaro-distance\n           display trim(s) \" -> \" trim(t) \", distance=\" distance\n           .           \n       jaro-distance.\n           move length(trim(s)) to s-length\n           move length(trim(t)) to t-length\n           if s-length = zeros and t-length = zeros\n              move 1 to distance\n              exit paragraph\n           end-if\n\n           compute match-distance = max(s-length, t-length) / 2 - 1\n           move low-values to jaro-table\n           move zeros to matches\n           move zeros to transpositions\n           perform varying i from 1 by 1 until i > s-length\n              move max(1, i - match-distance) to start-pos\n              move min(i + match-distance, t-length) to end-pos\n              perform varying j from start-pos by 1 until j > end-pos\n                 if t-matches(j) or s(i:1) <> t(j:1) \n                    exit perform cycle\n                 end-if,\n                 set s-matches(i), t-matches(j) to true\n                 add 1 to matches\n                 exit perform\n              end-perform\n           end-perform\n           if matches = zeros\n              move matches to distance\n              exit paragraph\n           end-if\n\n           move 1 to k\n           perform varying i from 1 by 1 until i > s-length\n              if not s-matches(i)\n                 exit perform cycle\n              end-if\n              perform until t-matches(k)\n                 add 1 to k\n              end-perform\n              if s(i:1) <> t(k:1)\n                 add 1 to transpositions\n              end-if\n              add 1 to k\n           end-perform\n\n           compute distance = ((matches / s-length) + (matches / t-length) +\n                               ((matches - transpositions / 2) / matches)) / 3\n           .\n", "target": "\n\nfrom __future__ import division\n\n\ndef jaro(s, t):\n    \n    s_len = len(s)\n    t_len = len(t)\n\n    if s_len == 0 and t_len == 0:\n        return 1\n\n    match_distance = (max(s_len, t_len) // 2) - 1\n\n    s_matches = [False] * s_len\n    t_matches = [False] * t_len\n\n    matches = 0\n    transpositions = 0\n\n    for i in range(s_len):\n        start = max(0, i - match_distance)\n        end = min(i + match_distance + 1, t_len)\n\n        for j in range(start, end):\n            if t_matches[j]:\n                continue\n            if s[i] != t[j]:\n                continue\n            s_matches[i] = True\n            t_matches[j] = True\n            matches += 1\n            break\n\n    if matches == 0:\n        return 0\n\n    k = 0\n    for i in range(s_len):\n        if not s_matches[i]:\n            continue\n        while not t_matches[k]:\n            k += 1\n        if s[i] != t[k]:\n            transpositions += 1\n        k += 1\n\n    return ((matches / s_len) +\n            (matches / t_len) +\n            ((matches - transpositions / 2) / matches)) / 3\n\n\ndef main():\n    \n\n    for s, t in [('MARTHA', 'MARHTA'),\n                 ('DIXON', 'DICKSONX'),\n                 ('JELLYFISH', 'SMELLYFISH')]:\n        print(\"jaro(%r, %r) = %.10f\" % (s, t, jaro(s, t)))\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 421537, "name": "Decision tables", "source": "Translate COBOL to Python:         >> SOURCE FORMAT FREE\nidentification division.\nprogram-id. 'decisiontable'.\n\nenvironment division.\nconfiguration section.\nrepository.\n    function all intrinsic.\n\ndata division.\n\nworking-storage section.\n\n01  conditions.\n    03  notprinting pic x.\n    03  flashing pic x.\n    03  notrecognized pic x.\n\nprocedure division.\nstart-decision-table.\n\ndisplay space \n\ndisplay 'The printer does not print (Y or N) ' with no advancing\naccept notprinting\n\ndisplay 'A red light is flashing (Y or N) ' with no advancing\naccept flashing\n\ndisplay 'The printer is unrecognized (Y or N) ' with no advancing\naccept notrecognized\n\nmove upper-case(conditions) to conditions\n\ndisplay space\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nevaluate notprinting also flashing also notrecognized\n\nwhen 'Y' also 'Y' also 'Y'\n    display 'Check the printer-computer cable'\n    display 'Ensure printer software is installed'\n    display 'Check/replace ink'\n\nwhen 'Y' also 'Y' also 'N'\n    display 'Check/replace ink'\n    display 'Check for paper jam'\n\nwhen 'Y' also 'N' also 'Y'\n    display 'Check the power cable'\n    display 'Check the printer-computer cable'\n    display 'Ensure printer software is installed'\n\nwhen 'Y' also 'N' also 'N'\n    display 'Check for paper jam'\n\nwhen 'N' also 'Y' also 'Y'\n    display 'Ensure printer software is installed'\n    display 'Check/replace ink'\n\nwhen 'N' also 'Y' also 'N'\n    display 'Check/replace ink'\n\nwhen 'N' also 'N' also 'Y'\n    display 'Ensure printer software is installed'\n\nwhen 'N' also 'N' also 'N'\n    display 'no action found'\n\nwhen other\n    display 'invalid input: ' notprinting space flashing space notrecognized\n\nend-evaluate\n\ndisplay space\n\nstop run\n.\n\nend program 'decisiontable'.\n", "target": "\n\ndef dt_creator():\n    print(\"\\n\\nCREATING THE DECISION TABLE\\n\")\n    conditions = input(\"Input conditions, in order, separated by commas: \")\n    conditions = [c.strip() for c in conditions.split(',')]\n    print( (\"\\nThat was %s conditions:\\n  \" % len(conditions))\n           + '\\n  '.join(\"%i: %s\" % x for x in enumerate(conditions, 1)) )\n    print(\"\\nInput an action, a semicolon, then a list of tuples of rules that trigger it. End with a blank line\")\n    action2rules, action = [], ' '\n    while action:\n        action = input(\"%i: \" % (len(action2rules) + 1)).strip()\n        if action:\n            name, _, rules = [x.strip() for x in action.partition(';')]\n            rules = eval(rules)\n            assert all(len(rule) == len(conditions) for rule in rules), \\\n                   \"The number of conditions in a rule to trigger this action is wrong\" \n            action2rules.append((name, rules))\n    actions = [x[0] for x in action2rules]\n    \n    rule2actions = dict((y,[]) for y in set(sum((x[1] for x in action2rules), [])))\n    for action, rules in action2rules:\n        for r in rules:\n            rule2actions[r].append( action )\n    return conditions, rule2actions\n\ndef dt_user(dt, default=['Pray!']):\n    conditions, rule2actions = dt\n    print(\"\\n\\nUSING THE DECISION TABLE\\n\")\n    rule = tuple(int('y' == input(\"%s? (Answer y if statement is true or n): \" % c)) for c in conditions)\n    print(\"Try this:\\n  \" + '\\n  '.join(rule2actions.get(rule, default)))\n\nif __name__ == '__main__':\n    dt = dt_creator()\n    dt_user(dt)\n    dt_user(dt)\n    dt_user(dt)\n"}
{"id": 421538, "name": "Find words which contains more than 3 e vowels", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. E-WORDS.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT DICT ASSIGN TO DISK\n           ORGANIZATION LINE SEQUENTIAL.\n           \n       DATA DIVISION.\n       FILE SECTION.\n       FD DICT \n           LABEL RECORD STANDARD\n           VALUE OF FILE-ID IS \"unixdict.txt\".\n       01 WORD            PIC X(64).\n       \n       WORKING-STORAGE SECTION.\n       01 E               PIC 99.\n       01 OTHER           PIC 99.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           OPEN INPUT DICT.\n           \n       READ-WORD.\n           READ DICT, AT END CLOSE DICT, STOP RUN.\n           PERFORM CHECK-WORD.\n           GO TO READ-WORD.\n           \n       CHECK-WORD.\n           MOVE ZERO TO E, OTHER.\n           INSPECT WORD TALLYING OTHER FOR ALL 'a'.\n           INSPECT WORD TALLYING E FOR ALL 'e'.\n           INSPECT WORD TALLYING OTHER FOR ALL 'i'.\n           INSPECT WORD TALLYING OTHER FOR ALL 'o'.\n           INSPECT WORD TALLYING OTHER FOR ALL 'u'.\n           IF E IS GREATER THAN 3 AND OTHER IS EQUAL TO ZERO,\n               DISPLAY WORD.\n", "target": "with open('unixdict.txt', 'rt') as f:\n    for line in f.readlines():\n        if not any(c in 'aiou' for c in line) and sum(c=='e' for c in line)>3:\n            print(line.strip())\n"}
{"id": 421539, "name": "Numbers divisible by their individual digits, but not by the product of their digits.", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. DIV-BY-DGTS-BUT-NOT-PROD.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 CALCULATION.\n           02 N             PIC 9(4).\n           02 DGT-PROD      PIC 9(3).\n           02 NSTART        PIC 9.\n           02 D             PIC 9.\n           02 N-INDEXING    REDEFINES N.\n              03 DIGIT      PIC 9 OCCURS 4 TIMES.\n           02 NDIV          PIC 9(4).\n           02 OK            PIC 9.\n        01 OUTPUT-FORMAT.\n           02 DISP-N        PIC Z(4).\n           \n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM CHECK VARYING N FROM 1 BY 1 \n                    UNTIL N IS EQUAL TO 1000.\n            STOP RUN.\n            \n        CHECK SECTION.\n        BEGIN.\n            SET NSTART TO 1.\n            INSPECT N TALLYING NSTART FOR LEADING '0'.\n            \n            SET DGT-PROD TO 1.\n            PERFORM MUL-DIGIT VARYING D FROM NSTART BY 1\n                    UNTIL D IS GREATER THAN 4.\n            IF DGT-PROD = 0 GO TO NOPE.\n            SET OK TO 1.\n            PERFORM CHECK-DIGIT VARYING D FROM NSTART BY 1\n                    UNTIL D IS GREATER THAN 4.\n            IF OK = 0 GO TO NOPE.\n            DIVIDE N BY DGT-PROD GIVING NDIV.\n            MULTIPLY DGT-PROD BY NDIV.\n            IF NDIV IS EQUAL TO N GO TO NOPE.\n            MOVE N TO DISP-N.\n            DISPLAY DISP-N.\n        MUL-DIGIT.\n            IF D IS GREATER THAN 4 GO TO NOPE.\n            MULTIPLY DIGIT(D) BY DGT-PROD.\n        CHECK-DIGIT.\n            IF D IS GREATER THAN 4 GO TO NOPE.\n            DIVIDE N BY DIGIT(D) GIVING NDIV.\n            MULTIPLY DIGIT(D) BY NDIV.\n            IF NDIV IS NOT EQUAL TO N SET OK TO 0.\n        NOPE. EXIT.\n", "target": "\n\nfrom functools import reduce\nfrom operator import mul\n\n\n\ndef p(n):\n    \n    digits = [int(c) for c in str(n)]\n    return not 0 in digits and (\n        0 != (n % reduce(mul, digits, 1))\n    ) and all(0 == n % d for d in digits)\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 1000)\n        if p(n)\n    ]\n    w = len(xs[-1])\n    print(f'{len(xs)} matching numbers:\\n')\n    print('\\n'.join(\n        ' '.join(cell.rjust(w, ' ') for cell in row)\n        for row in chunksOf(10)(xs)\n    ))\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 421540, "name": "Day of the week of Christmas and New Year", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. XMASNY.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 WEEKDAYS.\n          03 DAY-NAMES.\n             05 FILLER   PIC X(9) VALUE \"Saturday \".\n             05 FILLER   PIC X(9) VALUE \"Sunday   \".\n             05 FILLER   PIC X(9) VALUE \"Monday   \".\n             05 FILLER   PIC X(9) VALUE \"Tuesday  \".\n             05 FILLER   PIC X(9) VALUE \"Wednesday\".\n             05 FILLER   PIC X(9) VALUE \"Thursday \".\n             05 FILLER   PIC X(9) VALUE \"Friday   \".\n          03 DAYS        PIC X(9) OCCURS 7 TIMES,\n                         REDEFINES DAY-NAMES.\n       01 OUT-FMT.\n          03 OUT-MONTH   PIC 99.\n          03 FILLER      PIC X VALUE \"/\".\n          03 OUT-DAY     PIC 99.\n          03 FILLER      PIC X VALUE \"/\".\n          03 OUT-YEAR    PIC 9(4).\n          03 FILLER      PIC X(6) VALUE \" is a \".\n          03 OUT-DAYNAME PIC X(9).\n       \n       01 VARIABLES.\n          03 CDATE.\n             05 D-MONTH  PIC 99.\n             05 D-DAY    PIC 99.\n             05 D-YEAR   PIC 9999.\n          03 ZELLER-DATA.\n             05 M        PIC 99.\n             05 Y        PIC 99.\n             05 D        PIC 999.\n             05 D7       PIC 999.\n             05 J        PIC 99.\n             05 K        PIC 99.\n             05 DAY-NAME PIC X(9).\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE \"25122021\" TO CDATE.\n           PERFORM SHOW-WEEKDAY.\n           MOVE \"01012022\" TO CDATE.\n           PERFORM SHOW-WEEKDAY.\n           STOP RUN.\n       \n       SHOW-WEEKDAY.\n           MOVE D-MONTH TO OUT-MONTH.\n           MOVE D-DAY TO OUT-DAY.\n           MOVE D-YEAR TO OUT-YEAR.\n           PERFORM ZELLER.\n           MOVE DAY-NAME TO OUT-DAYNAME.\n           DISPLAY OUT-FMT.\n       \n       ZELLER.\n           MOVE D-MONTH TO M.\n           MOVE D-YEAR TO Y.\n           IF M IS NOT GREATER THAN 2,\n               ADD 12 TO M,\n               SUBTRACT 1 FROM Y.\n           DIVIDE Y BY 100 GIVING J.\n           COMPUTE K = Y - J * 100.\n           COMPUTE D = (M + 1) * 26.\n           DIVIDE 10 INTO D.\n           ADD K TO D.\n           DIVIDE 4 INTO K.\n           ADD K TO D.\n           COMPUTE D = D + 5 * J.\n           DIVIDE 4 INTO J.\n           COMPUTE D = D + J + D-DAY.\n           DIVIDE D BY 7 GIVING D7.\n           MULTIPLY 7 BY D7.\n           COMPUTE D = D - D7 + 1.\n           MOVE DAYS(D) TO DAY-NAME.\n", "target": "import datetime\n\nweekDays = (\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\")\nthisXMas  = datetime.date(2021,12,25)\nthisXMasDay = thisXMas.weekday()\nthisXMasDayAsString = weekDays[thisXMasDay]\nprint(\"This year's Christmas is on a {}\".format(thisXMasDayAsString))\n\nnextNewYear = datetime.date(2022,1,1)\nnextNewYearDay = nextNewYear.weekday()\nnextNewYearDayAsString = weekDays[nextNewYearDay]\nprint(\"Next new year is on a {}\".format(nextNewYearDayAsString))\n"}
{"id": 421541, "name": "Base 16 numbers needing a to f", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. BASE-16.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 VARIABLES        COMP.\n           02 STRP          PIC 99 VALUE 1.\n           02 N             PIC 999.\n           02 NTEMP         PIC 999.\n           02 N16           PIC 999.\n           02 NMOD16        PIC 99.\n           02 BASE16-FLAG   PIC 9.\n              88 BASE16     VALUE 1.\n           02 AMOUNT        PIC 999 VALUE 0.\n           \n        01 OUTPUT-FORMAT.\n           02 LINESTR       PIC X(72).\n           02 OUTN          PIC BZZ9.\n           \n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM NONDEC VARYING N FROM 1 BY 1 \n                UNTIL N IS GREATER THAN 500.\n            PERFORM DISPLAY-LINE.\n            DISPLAY ' '.\n            MOVE AMOUNT TO OUTN.\n            DISPLAY OUTN ' numbers found.'\n            STOP RUN.\n        \n        NONDEC.\n            MOVE N TO NTEMP.\n            PERFORM IS-NONDEC.\n            IF BASE16\n                MOVE N TO OUTN\n                STRING OUTN DELIMITED BY SIZE INTO LINESTR\n                    WITH POINTER STRP\n                ADD 1 TO AMOUNT\n                IF STRP IS EQUAL TO 73 PERFORM DISPLAY-LINE.\n                        \n        DISPLAY-LINE.\n            IF STRP IS NOT EQUAL TO 1 DISPLAY LINESTR.\n            MOVE 1 TO STRP.\n            MOVE ' ' TO LINESTR.\n            \n        IS-NONDEC.\n            IF NTEMP IS EQUAL TO ZERO\n                MOVE 0 TO BASE16-FLAG\n            ELSE\n                DIVIDE NTEMP BY 16 GIVING N16\n                COMPUTE NMOD16 = NTEMP - N16 * 16\n                IF NMOD16 IS NOT LESS THAN 10\n                    MOVE 1 TO BASE16-FLAG\n                ELSE\n                    MOVE N16 TO NTEMP\n                    GO TO IS-NONDEC.\n", "target": "\n\n\n\ndef p(n):\n    \n    return 9 < n and (9 < n % 16 or p(n // 16))\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 1 + 500)\n        if p(n)\n    ]\n    print(f'{len(xs)} matches for the predicate:\\n')\n    print(\n        table(6)(xs)\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 421542, "name": "Base 16 numbers needing a to f", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. BASE-16.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 VARIABLES        COMP.\n           02 STRP          PIC 99 VALUE 1.\n           02 N             PIC 999.\n           02 NTEMP         PIC 999.\n           02 N16           PIC 999.\n           02 NMOD16        PIC 99.\n           02 BASE16-FLAG   PIC 9.\n              88 BASE16     VALUE 1.\n           02 AMOUNT        PIC 999 VALUE 0.\n           \n        01 OUTPUT-FORMAT.\n           02 LINESTR       PIC X(72).\n           02 OUTN          PIC BZZ9.\n           \n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM NONDEC VARYING N FROM 1 BY 1 \n                UNTIL N IS GREATER THAN 500.\n            PERFORM DISPLAY-LINE.\n            DISPLAY ' '.\n            MOVE AMOUNT TO OUTN.\n            DISPLAY OUTN ' numbers found.'\n            STOP RUN.\n        \n        NONDEC.\n            MOVE N TO NTEMP.\n            PERFORM IS-NONDEC.\n            IF BASE16\n                MOVE N TO OUTN\n                STRING OUTN DELIMITED BY SIZE INTO LINESTR\n                    WITH POINTER STRP\n                ADD 1 TO AMOUNT\n                IF STRP IS EQUAL TO 73 PERFORM DISPLAY-LINE.\n                        \n        DISPLAY-LINE.\n            IF STRP IS NOT EQUAL TO 1 DISPLAY LINESTR.\n            MOVE 1 TO STRP.\n            MOVE ' ' TO LINESTR.\n            \n        IS-NONDEC.\n            IF NTEMP IS EQUAL TO ZERO\n                MOVE 0 TO BASE16-FLAG\n            ELSE\n                DIVIDE NTEMP BY 16 GIVING N16\n                COMPUTE NMOD16 = NTEMP - N16 * 16\n                IF NMOD16 IS NOT LESS THAN 10\n                    MOVE 1 TO BASE16-FLAG\n                ELSE\n                    MOVE N16 TO NTEMP\n                    GO TO IS-NONDEC.\n", "target": "\n\n\n\ndef p(n):\n    \n    return 9 < n and (9 < n % 16 or p(n // 16))\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 1 + 500)\n        if p(n)\n    ]\n    print(f'{len(xs)} matches for the predicate:\\n')\n    print(\n        table(6)(xs)\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 421543, "name": "Address of a variable", "source": "Translate COBOL to Python: data division.\nworking-storage section.\n01 ptr usage pointer.\n01 var pic x(64).\n\nprocedure division.\nset ptr to address of var.\n", "target": "var num = 12\nvar pointer = ptr(num) \n\nprint pointer \n\n@unsafe \npointer.addr = 0xFFFE \n"}
{"id": 421544, "name": "Fixed length records", "source": "Translate COBOL to Python:       \n      \n      \n       identification division.\n       program-id. lrecl80.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select infile\n               assign to infile-name\n               organization is sequential\n               file status is infile-status\n           .\n           select outfile\n               assign to outfile-name\n               organization is sequential\n               file status is outfile-status\n           .\n\n       data division.\n       file section.\n       fd infile.\n           01 input-text pic x(80).\n\n       fd outfile.\n           01 output-text pic x(80).\n\n       working-storage section.\n       01 infile-name.\n          05 value \"infile.dat\".\n       01 infile-status pic xx.\n          88 ok-input value '00'.\n          88 eof-input value '10'.\n\n       01 outfile-name.\n          05 value \"outfile.dat\".\n       01 outfile-status pic xx.\n          88 ok-output value '00'.\n\n       procedure division.\n\n       open input infile\n       if not ok-input then\n           display \"error opening input \" infile-name upon syserr\n           goback\n       end-if\n\n       open output outfile\n       if not ok-output\n           display \"error opening output \" outfile-name upon syserr\n           goback\n       end-if\n\n      \n       read infile\n       perform until not ok-input\n           move function reverse(input-text) to output-text\n\n           write output-text\n           if not ok-output then\n               display \"error writing: \" output-text upon syserr\n           end-if\n           read infile\n       end-perform\n\n       close infile outfile\n\n      \n       open input outfile\n       if not ok-output then\n           display \"error opening input \" outfile-name upon syserr\n           goback\n       end-if\n\n       read outfile\n       perform until not ok-output\n           display function trim(output-text trailing)\n           read outfile\n       end-perform\n\n       close outfile\n\n       goback.\n       end program lrecl80.\n", "target": "infile = open('infile.dat', 'rb')\noutfile = open('outfile.dat', 'wb')\n\nwhile True:\n    onerecord = infile.read(80)\n    if len(onerecord) < 80:\n        break\n    onerecordreversed = bytes(reversed(onerecord))\n    outfile.write(onerecordreversed)\n\ninfile.close()\noutfile.close()\n"}
{"id": 421545, "name": "Find words which contains all the vowels", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ALL-VOWELS.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT DICT ASSIGN TO DISK\n           ORGANIZATION LINE SEQUENTIAL.\n           \n       DATA DIVISION.\n       FILE SECTION.\n       FD DICT \n           LABEL RECORD STANDARD\n           VALUE OF FILE-ID IS \"unixdict.txt\".\n       01 WORD            PIC X(64).\n       \n       WORKING-STORAGE SECTION.\n       01 A               PIC 99.\n       01 E               PIC 99.\n       01 I               PIC 99.\n       01 O               PIC 99.\n       01 U               PIC 99.\n       01 LEN             PIC 99.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           OPEN INPUT DICT.\n           \n       READ-WORD.\n           READ DICT, AT END CLOSE DICT, STOP RUN.\n           PERFORM CHECK-WORD.\n           GO TO READ-WORD.\n           \n       CHECK-WORD.\n           MOVE ZERO TO LEN, A, E, I, O, U.\n           INSPECT WORD TALLYING LEN FOR CHARACTERS \n               BEFORE INITIAL SPACE.\n           INSPECT WORD TALLYING A FOR ALL 'a'.\n           INSPECT WORD TALLYING E FOR ALL 'e'.\n           INSPECT WORD TALLYING I FOR ALL 'i'.\n           INSPECT WORD TALLYING O FOR ALL 'o'.\n           INSPECT WORD TALLYING U FOR ALL 'u'.\n           IF LEN IS GREATER THAN 10\n              AND 1 IS EQUAL TO A AND E AND I AND O AND U,\n               DISPLAY WORD.\n", "target": "import urllib.request\nfrom collections import Counter\n\nurllib.request.urlretrieve(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\", \"unixdict.txt\")\n\ndictionary = open(\"unixdict.txt\",\"r\")\n\nwordList = dictionary.read().split('\\n')\n\ndictionary.close()\n\nfor word in wordList:\n    if len(word)>10:\n        frequency = Counter(word.lower())\n        if frequency['a']==frequency['e']==frequency['i']==frequency['o']==frequency['u']==1:\n            print(word)\n"}
{"id": 421546, "name": "Loops_Infinite", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Spam.\n\n       PROCEDURE DIVISION.\n           PERFORM UNTIL 1 <> 1\n               DISPLAY \"SPAM\"\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "while 1:\n   print \"SPAM\"\n"}
{"id": 421547, "name": "Function definition", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. myTest.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  x   PIC 9(3) VALUE 3.\n       01  y   PIC 9(3) VALUE 2.\n       01  z   PIC 9(9).\n       PROCEDURE DIVISION.\n           CALL \"myMultiply\" USING \n               BY CONTENT x, BY CONTENT y, \n               BY REFERENCE z.\n           DISPLAY z.\n           STOP RUN.\n       END PROGRAM myTest.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. myMultiply.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  x   PIC 9(3).\n       01  y   PIC 9(3).\n       01  z   PIC 9(9).\n       PROCEDURE DIVISION USING x, y, z.\n           MULTIPLY x BY y GIVING z.\n           EXIT PROGRAM.\n       END PROGRAM myMultiply.\n", "target": "def multiply(x, y):\n    return x * y\n"}
{"id": 421548, "name": "Terminal control_Dimensions", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. terminal-dimensions.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  num-lines PIC 9(3).\n       01  num-cols  PIC 9(3).\n\n       SCREEN SECTION.\n       01  display-screen.\n           03  LINE 01 COL 01 PIC 9(3) FROM num-lines.\n           03  LINE 01 COL 05 VALUE \"rows by \" .\n           03  LINE 01 COL 13 PIC 9(3) FROM num-cols.\n           03  LINE 01 COL 16 VALUE \" columns.\".\n\n       PROCEDURE DIVISION.\n           ACCEPT num-lines FROM LINES\n           ACCEPT num-cols FROM COLUMNS\n\n           DISPLAY display-screen\n\n      *    This pauses the program, as ncurses will immediately revert\n      *    back to the console when the program ends.\n           CALL \"C$SLEEP\" USING BY CONTENT 3\n\n           GOBACK\n           .\n", "target": "import os\n\ndef get_windows_terminal():\n    from ctypes import windll, create_string_buffer\n    h = windll.kernel32.GetStdHandle(-12)\n    csbi = create_string_buffer(22)\n    res = windll.kernel32.GetConsoleScreenBufferInfo(h, csbi)\n\n    \n    if not res: return 80, 25 \n\n    import struct\n    (bufx, bufy, curx, cury, wattr, left, top, right, bottom, maxx, maxy)\\\n    = struct.unpack(\"hhhhHhhhhhh\", csbi.raw)\n    width = right - left + 1\n    height = bottom - top + 1\n\n    return width, height\n\ndef get_linux_terminal():\n    width = os.popen('tput cols', 'r').readline()\n    height = os.popen('tput lines', 'r').readline()\n\n    return int(width), int(height)\n\nprint get_linux_terminal() if os.name == 'posix' else get_windows_terminal()\n"}
{"id": 421549, "name": "Sum of the digits of n is substring of n", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. SUM-SUBSTRING.\n            \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 CALCULATION.\n           02 N         PIC 9999.\n           02 X         PIC 9.\n           02 DSUM      PIC 99.\n           02 N-DIGITS  REDEFINES N.\n              03 ND     PIC 9 OCCURS 4 TIMES.\n           02 S-DIGITS  REDEFINES DSUM.\n              03 SUMD   PIC 9 OCCURS 2 TIMES.\n        01 OUTPUT-FORMAT.\n           02 N-OUT     PIC ZZZ9.\n        \n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM TESTNUMBER VARYING N FROM 0 BY 1\n                    UNTIL N IS EQUAL TO 1000.\n            STOP RUN.\n        \n        TESTNUMBER SECTION.\n        BEGIN.\n            PERFORM SUM-DIGITS.\n            SET X TO 1.\n            IF DSUM IS LESS THAN 10 GO TO ONE-DIGIT-CHECK.\n        \n        TWO-DIGIT-CHECK.\n            IF X IS GREATER THAN 3 GO TO DONE.\n            IF ND(X) = SUMD(1) AND ND(X + 1) = SUMD(2) GO TO SHOW.\n            ADD 1 TO X.\n            GO TO TWO-DIGIT-CHECK.\n            \n        ONE-DIGIT-CHECK.\n            IF X IS GREATER THAN 4 GO TO DONE.\n            IF ND(X) = SUMD(2) GO TO SHOW.\n            ADD 1 TO X.\n            GO TO ONE-DIGIT-CHECK.\n        \n        SHOW.\n            MOVE N TO N-OUT.\n            DISPLAY N-OUT.\n        DONE. EXIT.\n        \n        SUM-DIGITS SECTION.\n        BEGIN.\n            SET DSUM TO 0.\n            SET X TO 1.\n        LOOP.    \n            ADD ND(X) TO DSUM.\n            ADD 1 TO X.\n            IF X IS LESS THAN 5 GO TO LOOP.\n", "target": "Python 3.9.0 (tags/v3.9.0:9cf6752, Oct  5 2020, 15:34:40) [MSC v.1927 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> x = [n for n in range(1000) if str(sum(int(d) for d in str(n))) in str(n)]\n>>> len(x)\n48\n>>> for i in range(0, len(x), (stride:= 10)): print(str(x[i:i+stride])[1:-1])\n\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n10, 20, 30, 40, 50, 60, 70, 80, 90, 100\n109, 119, 129, 139, 149, 159, 169, 179, 189, 199\n200, 300, 400, 500, 600, 700, 800, 900, 910, 911\n912, 913, 914, 915, 916, 917, 918, 919\n>>>\n"}
{"id": 421550, "name": "Sum of the digits of n is substring of n", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. SUM-SUBSTRING.\n            \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 CALCULATION.\n           02 N         PIC 9999.\n           02 X         PIC 9.\n           02 DSUM      PIC 99.\n           02 N-DIGITS  REDEFINES N.\n              03 ND     PIC 9 OCCURS 4 TIMES.\n           02 S-DIGITS  REDEFINES DSUM.\n              03 SUMD   PIC 9 OCCURS 2 TIMES.\n        01 OUTPUT-FORMAT.\n           02 N-OUT     PIC ZZZ9.\n        \n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM TESTNUMBER VARYING N FROM 0 BY 1\n                    UNTIL N IS EQUAL TO 1000.\n            STOP RUN.\n        \n        TESTNUMBER SECTION.\n        BEGIN.\n            PERFORM SUM-DIGITS.\n            SET X TO 1.\n            IF DSUM IS LESS THAN 10 GO TO ONE-DIGIT-CHECK.\n        \n        TWO-DIGIT-CHECK.\n            IF X IS GREATER THAN 3 GO TO DONE.\n            IF ND(X) = SUMD(1) AND ND(X + 1) = SUMD(2) GO TO SHOW.\n            ADD 1 TO X.\n            GO TO TWO-DIGIT-CHECK.\n            \n        ONE-DIGIT-CHECK.\n            IF X IS GREATER THAN 4 GO TO DONE.\n            IF ND(X) = SUMD(2) GO TO SHOW.\n            ADD 1 TO X.\n            GO TO ONE-DIGIT-CHECK.\n        \n        SHOW.\n            MOVE N TO N-OUT.\n            DISPLAY N-OUT.\n        DONE. EXIT.\n        \n        SUM-DIGITS SECTION.\n        BEGIN.\n            SET DSUM TO 0.\n            SET X TO 1.\n        LOOP.    \n            ADD ND(X) TO DSUM.\n            ADD 1 TO X.\n            IF X IS LESS THAN 5 GO TO LOOP.\n", "target": "Python 3.9.0 (tags/v3.9.0:9cf6752, Oct  5 2020, 15:34:40) [MSC v.1927 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> x = [n for n in range(1000) if str(sum(int(d) for d in str(n))) in str(n)]\n>>> len(x)\n48\n>>> for i in range(0, len(x), (stride:= 10)): print(str(x[i:i+stride])[1:-1])\n\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n10, 20, 30, 40, 50, 60, 70, 80, 90, 100\n109, 119, 129, 139, 149, 159, 169, 179, 189, 199\n200, 300, 400, 500, 600, 700, 800, 900, 910, 911\n912, 913, 914, 915, 916, 917, 918, 919\n>>>\n"}
{"id": 421551, "name": "Create a file on magnetic tape", "source": "Translate COBOL to Python:        >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. MAKE-TAPE-FILE.\n\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT TAPE-FILE\n        ASSIGN \"./TAPE.FILE\"\n        ORGANIZATION IS LINE SEQUENTIAL.\n\nDATA DIVISION.\nFILE SECTION.\nFD TAPE-FILE.\n01 TAPE-FILE-RECORD PIC X(51).\n\nPROCEDURE DIVISION.\n    OPEN OUTPUT SHARING WITH ALL OTHER TAPE-FILE\n    WRITE TAPE-FILE-RECORD \n        FROM \"COBOL treats tape files and text files identically.\"\n    END-WRITE\n    STOP RUN.\n", "target": ">>> with open('/dev/tape', 'w') as t: t.write('Hi Tape!\\n')\n... \n>>>\n"}
{"id": 421552, "name": "Recaman's sequence", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. RECAMAN.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 RECAMAN-SEQUENCE COMP.\n           02 A     PIC 999 OCCURS 99 TIMES INDEXED BY I.\n           02 N     PIC 999 VALUE 0.\n           \n        01 VARIABLES COMP.\n           02 ADDC  PIC S999.\n           02 SUBC  PIC S999.\n           02 SPTR  PIC 99 VALUE 1.\n           \n        01 OUTPUT-FORMAT.\n           02 OUTI  PIC Z9.\n           02 OUTN  PIC BZ9.\n           02 OUTS  PIC X(79).\n           \n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM GENERATE-NEXT-ITEM 15 TIMES.\n            PERFORM COLLATE-ITEM VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN 15.\n            DISPLAY 'First 15 items:' OUTS.\n        \n        FIND-REPEATING.\n            PERFORM GENERATE-NEXT-ITEM.\n            SET I TO 1.\n            SEARCH A VARYING I\n                WHEN I IS NOT LESS THAN N \n                    NEXT SENTENCE\n                WHEN A(I) IS EQUAL TO A(N)\n                    SUBTRACT 1 FROM N GIVING OUTI\n                    MOVE A(N) TO OUTN\n                    DISPLAY 'First repeated item: A(' OUTI ') =' OUTN\n                    STOP RUN.\n            GO TO FIND-REPEATING.\n        \n        GENERATE-NEXT-ITEM.\n            IF N IS EQUAL TO ZERO\n                MOVE ZERO TO A(1)\n            ELSE\n                ADD N, A(N) GIVING ADDC\n                SUBTRACT N FROM A(N) GIVING SUBC\n                IF SUBC IS NOT GREATER THAN ZERO\n                    MOVE ADDC TO A(N + 1)\n                ELSE\n                    SET I TO 1\n                    SEARCH A VARYING I\n                        WHEN I IS NOT LESS THAN N\n                            MOVE SUBC TO A(N + 1)\n                        WHEN A(I) IS EQUAL TO SUBC\n                            MOVE ADDC TO A(N + 1).\n            ADD 1 TO N.\n            \n        COLLATE-ITEM.\n            MOVE A(I) TO OUTN.\n            STRING OUTN DELIMITED BY SIZE INTO OUTS WITH POINTER SPTR.\n", "target": "from itertools import islice\n\nclass Recamans():\n    \"Recam\u00e1n's sequence generator callable class\"\n    def __init__(self):\n        self.a = None   \n        self.n = None   \n    \n    def __call__(self):\n        \"Recam\u00e1n's sequence  generator\"\n        nxt = 0\n        a, n = {nxt}, 0\n        self.a = a\n        self.n = n\n        yield nxt\n        while True:\n            an1, n = nxt, n + 1\n            nxt = an1 - n\n            if nxt < 0 or nxt in a:\n                nxt = an1 + n\n            a.add(nxt)\n            self.n = n\n            yield nxt\n\nif __name__ == '__main__':\n    recamans = Recamans()\n    print(\"First fifteen members of Recamans sequence:\", \n          list(islice(recamans(), 15)))\n\n    so_far = set()\n    for term in recamans():\n        if term in so_far:\n            print(f\"First duplicate number in series is: a({recamans.n}) = {term}\")\n            break\n        so_far.add(term)\n    \n    n = 1_000\n    setn = set(range(n + 1))    \n    for _ in recamans():\n        if setn.issubset(recamans.a):\n            print(f\"Range 0 ..{n} is covered by terms up to a({recamans.n})\")\n            break\n"}
{"id": 421553, "name": "Recaman's sequence", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. RECAMAN.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 RECAMAN-SEQUENCE COMP.\n           02 A     PIC 999 OCCURS 99 TIMES INDEXED BY I.\n           02 N     PIC 999 VALUE 0.\n           \n        01 VARIABLES COMP.\n           02 ADDC  PIC S999.\n           02 SUBC  PIC S999.\n           02 SPTR  PIC 99 VALUE 1.\n           \n        01 OUTPUT-FORMAT.\n           02 OUTI  PIC Z9.\n           02 OUTN  PIC BZ9.\n           02 OUTS  PIC X(79).\n           \n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM GENERATE-NEXT-ITEM 15 TIMES.\n            PERFORM COLLATE-ITEM VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN 15.\n            DISPLAY 'First 15 items:' OUTS.\n        \n        FIND-REPEATING.\n            PERFORM GENERATE-NEXT-ITEM.\n            SET I TO 1.\n            SEARCH A VARYING I\n                WHEN I IS NOT LESS THAN N \n                    NEXT SENTENCE\n                WHEN A(I) IS EQUAL TO A(N)\n                    SUBTRACT 1 FROM N GIVING OUTI\n                    MOVE A(N) TO OUTN\n                    DISPLAY 'First repeated item: A(' OUTI ') =' OUTN\n                    STOP RUN.\n            GO TO FIND-REPEATING.\n        \n        GENERATE-NEXT-ITEM.\n            IF N IS EQUAL TO ZERO\n                MOVE ZERO TO A(1)\n            ELSE\n                ADD N, A(N) GIVING ADDC\n                SUBTRACT N FROM A(N) GIVING SUBC\n                IF SUBC IS NOT GREATER THAN ZERO\n                    MOVE ADDC TO A(N + 1)\n                ELSE\n                    SET I TO 1\n                    SEARCH A VARYING I\n                        WHEN I IS NOT LESS THAN N\n                            MOVE SUBC TO A(N + 1)\n                        WHEN A(I) IS EQUAL TO SUBC\n                            MOVE ADDC TO A(N + 1).\n            ADD 1 TO N.\n            \n        COLLATE-ITEM.\n            MOVE A(I) TO OUTN.\n            STRING OUTN DELIMITED BY SIZE INTO OUTS WITH POINTER SPTR.\n", "target": "from itertools import islice\n\nclass Recamans():\n    \"Recam\u00e1n's sequence generator callable class\"\n    def __init__(self):\n        self.a = None   \n        self.n = None   \n    \n    def __call__(self):\n        \"Recam\u00e1n's sequence  generator\"\n        nxt = 0\n        a, n = {nxt}, 0\n        self.a = a\n        self.n = n\n        yield nxt\n        while True:\n            an1, n = nxt, n + 1\n            nxt = an1 - n\n            if nxt < 0 or nxt in a:\n                nxt = an1 + n\n            a.add(nxt)\n            self.n = n\n            yield nxt\n\nif __name__ == '__main__':\n    recamans = Recamans()\n    print(\"First fifteen members of Recamans sequence:\", \n          list(islice(recamans(), 15)))\n\n    so_far = set()\n    for term in recamans():\n        if term in so_far:\n            print(f\"First duplicate number in series is: a({recamans.n}) = {term}\")\n            break\n        so_far.add(term)\n    \n    n = 1_000\n    setn = set(range(n + 1))    \n    for _ in recamans():\n        if setn.issubset(recamans.a):\n            print(f\"Range 0 ..{n} is covered by terms up to a({recamans.n})\")\n            break\n"}
{"id": 421554, "name": "Sorting algorithms_Bead sort", "source": "Translate COBOL to Python:         >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. beadsort.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n01  filler.\n    03  row occurs 9 pic x(9).\n    03  r pic 99.\n    03  r1 pic 99.\n    03  r2 pic 99.\n    03  pole pic 99.\n    03  a-lim pic 99 value 9.\n    03  a pic 99.\n    03  array occurs 9 pic 9.\n01  NL pic x value x'0A'.\nprocedure division.\nstart-beadsort.\n\n    \n    compute a = random(seconds-past-midnight)\n    perform varying a from 1 by 1 until a > a-lim\n        compute array(a) = random() * 10\n    end-perform\n\n    perform display-array\n    display space 'initial array'\n\n    \n    perform varying r from 1 by 1 until r > a-lim\n        move all '.' to row(r)\n        perform varying pole from 1 by 1 until pole > array(r)\n            move 'o' to row(r)(pole:1)\n        end-perform\n    end-perform\n    display NL 'initial beads'\n    perform display-beads\n\n    \n    perform varying pole from 1 by 1 until pole > a-lim\n        move a-lim to r2\n        perform find-opening\n        compute r1 = r2 - 1\n        perform find-bead\n        perform until r1 = 0 \n            \n            move '.' to row(r1)(pole:1)\n            move 'o' to row(r2)(pole:1)\n            \n            compute r2 = r2 - 1\n            perform find-opening\n            compute r1 = r2 - 1\n            perform find-bead\n        end-perform\n    end-perform\n    display NL 'dropped beads'\n    perform display-beads\n\n    \n    perform varying r from 1 by 1 until r > a-lim\n        move 0 to array(r)\n        inspect row(r) tallying array(r)\n            for all 'o' before initial '.'\n    end-perform\n\n    perform display-array\n    display space 'sorted array'\n\n    stop run\n    .\nfind-opening.\n    perform varying r2 from r2 by -1\n    until r2 = 1 or row(r2)(pole:1) = '.'\n        continue\n    end-perform\n    .\nfind-bead.\n    perform varying r1 from r1 by -1\n    until r1 = 0 or row(r1)(pole:1) = 'o'\n        continue\n    end-perform\n    .\ndisplay-array.\n    display space\n    perform varying a from 1 by 1 until a > a-lim\n        display space array(a) with no advancing\n    end-perform\n    .\ndisplay-beads.\n    perform varying r from 1 by 1 until r > a-lim\n        display row(r)\n    end-perform\n    .\nend program beadsort.\n", "target": "\nfrom itertools import zip_longest\n\n\ndef beadsort(l):\n    return list(map(sum, zip_longest(*[[1] * e for e in l], fillvalue=0)))\n\n\n\nprint(beadsort([5,3,1,7,4,1,1]))\n"}
{"id": 421555, "name": "Simple database", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. simple-database.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT OPTIONAL database-file ASSIGN Database-Path\n               ORGANIZATION INDEXED\n               ACCESS SEQUENTIAL\n               RECORD KEY data-title\n               ALTERNATE RECORD KEY data-tag\n                   WITH DUPLICATES\n               ALTERNATE RECORD KEY date-added\n                   WITH DUPLICATES\n               FILE STATUS file-status\n               .\n       DATA DIVISION.\n       FILE SECTION.\n       FD  database-file.\n       01  database-record.\n           \n           03  date-added          PIC 9(8).\n           03  data-tag            PIC X(20).\n           03  data-title          PIC X(50).\n           03  data-contents       PIC X(200).\n           \n           \n           03  FILLER              PIC X(50).\n\n       WORKING-STORAGE SECTION.\n       78  Database-Path           VALUE \"database.dat\".\n\n       01  file-status             PIC XX.\n           88  file-ok             VALUE \"00\".\n           88  duplicate-key       VALUE \"22\".\n           88  key-not-found       VALUE \"23\".\n\n       01  num-args                PIC 99.\n\n       01  action                  PIC XX.\n           88  create-entry        VALUE \"-c\".\n           88  remove-entry        VALUE \"-r\".\n           88  find-entry          VALUE \"-f\".\n           88  print-latest        VALUE \"-l\".\n           88  print-database      VALUES \"-a\", \"-d\", \"-t\".\n           \n           88  print-by-title      VALUE \"-a\".\n           88  print-by-date       VALUE \"-d\".\n           88  print-by-tag        VALUE \"-t\".\n           88  print-help          VALUES \"-h\", SPACES.\n\n       01  read-direction-flag     PIC X VALUE SPACE.\n           88  read-backwards      VALUE \"B\".\n\n       01  edited-date             PIC 9(4)/99/99.\n       PROCEDURE DIVISION.\n       DECLARATIVES.\n       database-file-error SECTION.\n           USE AFTER ERROR ON database-file\n\n           DISPLAY \"An error has occurred while using \" Database-Path\n               \". Error no. \" file-status\n           DISPLAY \"The program will terminate.\"\n\n           CLOSE database-file\n\n           GOBACK\n           .\n       END DECLARATIVES.\n\n       main-line.\n           DISPLAY 1 UPON ARGUMENT-NUMBER\n           ACCEPT action FROM ARGUMENT-VALUE\n\n           ACCEPT num-args FROM ARGUMENT-NUMBER\n\n           EVALUATE TRUE\n               WHEN create-entry\n                   IF num-args >= 4\n                       PERFORM write-entry\n                   ELSE\n                       DISPLAY \"-a requires arguments to enter in the \"\n                           \"database. See help (-h) for details.\"\n                   END-IF\n\n               WHEN remove-entry\n                   IF num-args >= 2\n                       PERFORM delete-entry\n                   ELSE\n                       DISPLAY \"-r requires the title of the entry to \"\n                           \"delete.\"\n                   END-IF\n\n               WHEN find-entry\n                   IF num-args >= 2\n                       PERFORM display-specified-entry\n                   ELSE\n                       DISPLAY \"-f requires the title of the entry to \"\n                           \"find.\"\n                   END-IF\n\n               WHEN print-latest\n                   PERFORM show-latest\n\n               WHEN print-database\n                   PERFORM show-database\n\n               WHEN print-help\n                   PERFORM show-general-help\n\n               WHEN OTHER\n                   DISPLAY action \" is not a valid option.\"\n           END-EVALUATE\n           \n           GOBACK\n           .\n       write-entry.\n           OPEN EXTEND database-file\n\n           DISPLAY 2 UPON ARGUMENT-NUMBER\n           ACCEPT data-tag FROM ARGUMENT-VALUE\n           DISPLAY 3 UPON ARGUMENT-NUMBER\n           ACCEPT data-title FROM ARGUMENT-VALUE\n           IF data-title = SPACES\n               DISPLAY \"The title cannot be blank.\"\n               PERFORM close-and-terminate\n           END-IF\n\n           DISPLAY 4 UPON ARGUMENT-NUMBER\n           ACCEPT data-contents FROM ARGUMENT-VALUE\n\n           ACCEPT date-added FROM DATE YYYYMMDD\n\n           WRITE database-record\n               INVALID KEY\n                   IF duplicate-key\n                       DISPLAY \"An entry in the database already has \"\n                           \"that title. Please choose a different \"\n                           \"title or remove the entry.\"\n                   ELSE\n                       PERFORM database-file-error\n                   END-IF\n           END-WRITE\n\n           PERFORM close-database\n           .\n       delete-entry.\n           PERFORM get-title-arg\n           OPEN I-O database-file\n           PERFORM read-title\n\n           DELETE database-file\n\n           PERFORM close-database\n           .\n       display-specified-entry.\n           PERFORM get-title-arg\n           OPEN INPUT database-file\n           PERFORM read-title\n\n           PERFORM show-record\n\n           PERFORM close-database\n           .\n       get-title-arg.\n           DISPLAY 2 UPON ARGUMENT-NUMBER\n           ACCEPT data-title FROM ARGUMENT-VALUE\n           .\n       read-title.\n           START database-file KEY IS = data-title\n               INVALID KEY\n                   IF key-not-found\n                       DISPLAY \"An entry with that title was not found.\"\n                       PERFORM close-and-terminate\n                   ELSE\n                       PERFORM database-file-error\n                   END-IF\n           END-START\n\n           READ database-file\n           .\n       close-and-terminate.\n            PERFORM close-database\n            GOBACK\n            .\n       show-latest.\n           OPEN INPUT database-file\n\n           PERFORM start-at-last-date\n           READ database-file\n           PERFORM show-record\n\n           PERFORM close-database\n           .\n       show-database.\n           OPEN INPUT database-file\n\n           EVALUATE TRUE\n               WHEN print-by-title\n                   \n                   CONTINUE\n               WHEN print-by-tag\n                   MOVE LOW-VALUES TO data-tag\n                   START database-file KEY IS > data-tag\n               WHEN print-by-date\n                   PERFORM start-at-last-date\n                   SET read-backwards TO TRUE\n           END-EVALUATE\n\n           PERFORM FOREVER\n               \n               IF NOT read-backwards\n                   READ database-file NEXT\n                       AT END\n                           EXIT PERFORM\n                   END-READ\n               ELSE\n                   READ database-file PREVIOUS\n                       AT END\n                           EXIT PERFORM\n                   END-READ\n               END-IF\n\n               PERFORM show-record\n               DISPLAY SPACE\n           END-PERFORM\n\n           PERFORM close-database\n           .\n       start-at-last-date.\n           MOVE HIGH-VALUES TO date-added\n           START database-file KEY IS < date-added\n           .\n       close-database.\n           CLOSE database-file\n           .\n       show-record.\n           MOVE date-added TO edited-date\n           DISPLAY \"Date added: \" edited-date \" Tag: \" data-tag\n           DISPLAY \"Title: \" data-title\n           DISPLAY \"Contents:\"\n           DISPLAY \"  \" FUNCTION TRIM(data-contents)\n           .\n       show-general-help.\n           DISPLAY \"Help: Possible options are:\"\n           DISPLAY \"  -a - Show all the entries (sorted by title).\"\n           DISPLAY \"  -c - Create a new entry in the database. -c needs\"\n               \" further arguments in this format:\"\n           DISPLAY '    \"tag\" \"title\" \"content\"'\n           DISPLAY \"    Max argument sizes (in characters): tag - 20, \"\n               \"title - 50, content - 200\"\n           DISPLAY \"    The title must be unique and not be blank.\"\n           DISPLAY \"  -d - Show all the entries sorted by date added.\"\n           DISPLAY \"  -f - Finds and displays entry with the title \"\n               \"provided. The title should be specified as shown for \"\n               \"-c.\"\n           DISPLAY \"  -h - Show this help menu.\"\n           DISPLAY \"  -l - Show the latest entry.\"\n           DISPLAY \"  -r - Remove the entry with the title provided. \"\n               \"The title should be specified as shown for -c.\"\n           DISPLAY \"  -t - Show all the entries sorted by tag.\"\n           .\n", "target": "\n\n\n\nimport argparse\nfrom argparse import Namespace\nimport datetime\nimport shlex\n\n\ndef parse_args():\n    'Set up, parse, and return arguments'\n    \n    parser = argparse.ArgumentParser(epilog=globals()['__doc__'])\n\n    parser.add_argument('command', choices='add pl plc pa'.split(),\n                        help=)\n    parser.add_argument('-d', '--description',\n                        help='A description of the item. (e.g., title, name)')\n    parser.add_argument('-t', '--tag',\n                        help=(\n                              ))\n    parser.add_argument('-f', '--field', nargs=2, action='append', \n                        help='Other optional fields with value (can be repeated)')\n\n    return parser\n\ndef do_add(args, dbname):\n    'Add a new entry'\n    if args.description is None:\n        args.description = ''\n    if args.tag is None:\n        args.tag = ''\n    del args.command\n    print('Writing record to %s' % dbname)\n    with open(dbname, 'a') as db:\n        db.write('%r\\n' % args)\n    \ndef do_pl(args, dbname):\n    'Print the latest entry'\n    print('Getting last record from %s' % dbname)\n    with open(dbname, 'r') as db:\n        for line in db: pass\n    record = eval(line)\n    del record._date\n    print(str(record))\n    \ndef do_plc(args, dbname):\n    'Print the latest entry for each category/tag'\n    print('Getting latest record for each tag from %s' % dbname)\n    with open(dbname, 'r') as db:\n        records = [eval(line) for line in db]\n    tags = set(record.tag for record in records)\n    records.reverse()\n    for record in records:\n        if record.tag in tags:\n            del record._date\n            print(str(record))\n            tags.discard(record.tag)\n            if not tags: break\n\ndef do_pa(args, dbname):\n    'Print all entries sorted by a date'\n    print('Getting all records by date from %s' % dbname)\n    with open(dbname, 'r') as db:\n        records = [eval(line) for line in db]\n    for record in records:\n        del record._date\n        print(str(record))\n\ndef test():\n    import time\n    parser = parse_args()\n    for cmdline in [\n                    ,\n                    ,\n                    ,\n                    ,\n                    ,\n                    ]:\n        args = parser.parse_args(shlex.split(cmdline))\n        now = datetime.datetime.utcnow()\n        args._date = now.isoformat()\n        do_command[args.command](args, dbname)\n        time.sleep(0.5)\n\n\n    \ndo_command = dict(add=do_add, pl=do_pl, plc=do_plc, pa=do_pa)\ndbname = '_simple_db_db.py'\n\n\nif __name__ == '__main__':\n    if 0:\n        test()\n    else:\n        parser = parse_args()\n        args = parser.parse_args()\n        now = datetime.datetime.utcnow()\n        args._date = now.isoformat()\n        do_command[args.command](args, dbname)\n"}
{"id": 421556, "name": "Tau function", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. TAU-FUNCTION.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 TAU-VARS.\n          03 TOTAL              PIC 999.\n          03 N                  PIC 999.\n          03 FILLER             REDEFINES N.\n             05 FILLER          PIC 99.\n             05 FILLER          PIC 9.\n                88 N-EVEN       VALUES 0, 2, 4, 6, 8.\n          03 P                  PIC 999.\n          03 P-SQUARED          PIC 999.\n          03 N-DIV-P            PIC 999V999.\n          03 FILLER             REDEFINES N-DIV-P.\n             05 NEXT-N          PIC 999.\n             05 FILLER          PIC 999.\n                88 DIVISIBLE    VALUE ZERO.\n          03 F-COUNT            PIC 999.\n       01 CONTROL-VARS.\n          03 I                  PIC 999.\n       01 OUT-VARS.\n          03 OUT-ITM            PIC ZZ9.\n          03 OUT-STR            PIC X(80) VALUE SPACES.\n          03 OUT-PTR            PIC 99 VALUE 1.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SHOW-TAU VARYING I FROM 1 BY 1\n               UNTIL I IS GREATER THAN 100.\n           STOP RUN.\n       \n       SHOW-TAU.\n           MOVE I TO N.\n           PERFORM TAU.\n           MOVE TOTAL TO OUT-ITM.\n           STRING OUT-ITM DELIMITED BY SIZE INTO OUT-STR\n               WITH POINTER OUT-PTR.\n           IF OUT-PTR IS EQUAL TO 61,\n               DISPLAY OUT-STR,\n               MOVE 1 TO OUT-PTR.\n\n       TAU.\n           MOVE 1 TO TOTAL.\n           PERFORM POWER-OF-2 UNTIL NOT N-EVEN.\n           MOVE ZERO TO P-SQUARED.\n           PERFORM ODD-FACTOR THRU ODD-FACTOR-LOOP\n               VARYING P FROM 3 BY 2\n               UNTIL P-SQUARED IS GREATER THAN N.\n           IF N IS GREATER THAN 1,\n               MULTIPLY 2 BY TOTAL.\n       POWER-OF-2.\n           ADD 1 TO TOTAL.\n           DIVIDE 2 INTO N.\n       ODD-FACTOR.\n           MULTIPLY P BY P GIVING P-SQUARED.\n           MOVE 1 TO F-COUNT.\n       ODD-FACTOR-LOOP.\n           DIVIDE N BY P GIVING N-DIV-P.\n           IF DIVISIBLE,\n               MOVE NEXT-N TO N,\n               ADD 1 TO F-COUNT,\n               GO TO ODD-FACTOR-LOOP.\n           MULTIPLY F-COUNT BY TOTAL.\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef tau(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= 1 + k\n    return ans\n\nif __name__ == \"__main__\":\n    print(*map(tau, range(1, 101)))\n"}
{"id": 421557, "name": "Tau function", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. TAU-FUNCTION.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 TAU-VARS.\n          03 TOTAL              PIC 999.\n          03 N                  PIC 999.\n          03 FILLER             REDEFINES N.\n             05 FILLER          PIC 99.\n             05 FILLER          PIC 9.\n                88 N-EVEN       VALUES 0, 2, 4, 6, 8.\n          03 P                  PIC 999.\n          03 P-SQUARED          PIC 999.\n          03 N-DIV-P            PIC 999V999.\n          03 FILLER             REDEFINES N-DIV-P.\n             05 NEXT-N          PIC 999.\n             05 FILLER          PIC 999.\n                88 DIVISIBLE    VALUE ZERO.\n          03 F-COUNT            PIC 999.\n       01 CONTROL-VARS.\n          03 I                  PIC 999.\n       01 OUT-VARS.\n          03 OUT-ITM            PIC ZZ9.\n          03 OUT-STR            PIC X(80) VALUE SPACES.\n          03 OUT-PTR            PIC 99 VALUE 1.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SHOW-TAU VARYING I FROM 1 BY 1\n               UNTIL I IS GREATER THAN 100.\n           STOP RUN.\n       \n       SHOW-TAU.\n           MOVE I TO N.\n           PERFORM TAU.\n           MOVE TOTAL TO OUT-ITM.\n           STRING OUT-ITM DELIMITED BY SIZE INTO OUT-STR\n               WITH POINTER OUT-PTR.\n           IF OUT-PTR IS EQUAL TO 61,\n               DISPLAY OUT-STR,\n               MOVE 1 TO OUT-PTR.\n\n       TAU.\n           MOVE 1 TO TOTAL.\n           PERFORM POWER-OF-2 UNTIL NOT N-EVEN.\n           MOVE ZERO TO P-SQUARED.\n           PERFORM ODD-FACTOR THRU ODD-FACTOR-LOOP\n               VARYING P FROM 3 BY 2\n               UNTIL P-SQUARED IS GREATER THAN N.\n           IF N IS GREATER THAN 1,\n               MULTIPLY 2 BY TOTAL.\n       POWER-OF-2.\n           ADD 1 TO TOTAL.\n           DIVIDE 2 INTO N.\n       ODD-FACTOR.\n           MULTIPLY P BY P GIVING P-SQUARED.\n           MOVE 1 TO F-COUNT.\n       ODD-FACTOR-LOOP.\n           DIVIDE N BY P GIVING N-DIV-P.\n           IF DIVISIBLE,\n               MOVE NEXT-N TO N,\n               ADD 1 TO F-COUNT,\n               GO TO ODD-FACTOR-LOOP.\n           MULTIPLY F-COUNT BY TOTAL.\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef tau(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= 1 + k\n    return ans\n\nif __name__ == \"__main__\":\n    print(*map(tau, range(1, 101)))\n"}
{"id": 421558, "name": "Mertens function", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MERTENS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 M             PIC S99 OCCURS 1000 TIMES.\n          03 N             PIC 9(4).\n          03 K             PIC 9(4).\n          03 V             PIC 9(4).\n          03 IS-ZERO       PIC 99 VALUE 0.\n          03 CROSS-ZERO    PIC 99 VALUE 0.\n\n       01 OUTPUT-FORMAT.\n          03 OUT-ITEM. \n             05 OUT-NUM    PIC -9.\n             05 FILLER     PIC X VALUE SPACE.\n          03 OUT-LINE      PIC X(30) VALUE SPACES.\n          03 OUT-PTR       PIC 99 VALUE 4.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM GENERATE-MERTENS.\n           PERFORM WRITE-TABLE.\n           PERFORM COUNT-ZEROES.\n           STOP RUN.\n\n       GENERATE-MERTENS.\n           MOVE 1 TO M(1).\n           PERFORM MERTENS-OUTER-LOOP VARYING N FROM 2 BY 1\n               UNTIL N IS GREATER THAN 1000.\n    \n       MERTENS-OUTER-LOOP.\n           MOVE 1 TO M(N).\n           PERFORM MERTENS-INNER-LOOP VARYING K FROM 2 BY 1\n               UNTIL K IS GREATER THAN N.\n\n       MERTENS-INNER-LOOP.\n           DIVIDE N BY K GIVING V.\n           SUBTRACT M(V) FROM M(N).\n\n       WRITE-TABLE.\n           DISPLAY \"The first 99 Mertens numbers are: \"\n           PERFORM WRITE-ITEM VARYING N FROM 1 BY 1\n               UNTIL N IS GREATER THAN 99.\n  \n       WRITE-ITEM.\n           MOVE M(N) TO OUT-NUM.\n           STRING OUT-ITEM DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER OUT-PTR.\n           IF OUT-PTR IS EQUAL TO 31,\n               DISPLAY OUT-LINE,\n               MOVE 1 TO OUT-PTR.\n\n       COUNT-ZEROES.\n           PERFORM TEST-N-ZERO VARYING N FROM 2 BY 1\n               UNTIL N IS GREATER THAN 1000.\n           DISPLAY \"M(N) is zero \" IS-ZERO \" times.\".\n           DISPLAY \"M(N) crosses zero \" CROSS-ZERO \" times.\".\n\n       TEST-N-ZERO.\n           IF M(N) IS EQUAL TO ZERO,\n               ADD 1 TO IS-ZERO,\n               SUBTRACT 1 FROM N GIVING K,\n               IF M(K) IS NOT EQUAL TO ZERO,\n                   ADD 1 TO CROSS-ZERO.\n", "target": "def mertens(count):\n    \n    m = [None, 1]\n    for n in range(2, count+1):\n        m.append(1)\n        for k in range(2, n+1):\n            m[n] -= m[n//k]\n    return m\n    \n\nms = mertens(1000)\n\nprint(\"The first 99 Mertens numbers are:\")\nprint(\"  \", end=' ')\ncol = 1\nfor n in ms[1:100]:\n    print(\"{:2d}\".format(n), end=' ')\n    col += 1\n    if col == 10:\n        print()\n        col = 0\n        \nzeroes = sum(x==0 for x in ms)\ncrosses = sum(a!=0 and b==0 for a,b in zip(ms, ms[1:]))\nprint(\"M(N) equals zero {} times.\".format(zeroes))\nprint(\"M(N) crosses zero {} times.\".format(crosses))\n"}
{"id": 421559, "name": "Product of divisors", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  PRODUCT-OF-DIVISORS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 DIVISOR-PRODUCTS    PIC 9(9) OCCURS 50 TIMES.\n          03 NUM                 PIC 999.\n          03 MUL                 PIC 999.\n      \n       01 OUTPUT-FORMAT.\n          03 NUM-OUT             PIC Z(9)9.\n          03 LINE-PTR            PIC 99 VALUE 1.\n          03 OUT-LINE            PIC X(50) VALUE SPACES.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM INIT VARYING NUM FROM 1 BY 1\n               UNTIL NUM IS GREATER THAN 50.\n           PERFORM CALCULATE-MULTIPLES VARYING MUL FROM 1 BY 1\n               UNTIL MUL IS GREATER THAN 50.\n           PERFORM OUTPUT-NUM VARYING NUM FROM 1 BY 1\n               UNTIL NUM IS GREATER THAN 50.\n           STOP RUN.\n\n       INIT.\n           MOVE 1 TO DIVISOR-PRODUCTS(NUM).\n       \n       CALCULATE-MULTIPLES.\n           PERFORM MULTIPLY-NUM VARYING NUM FROM MUL BY MUL\n               UNTIL NUM IS GREATER THAN 50.\n \n       MULTIPLY-NUM.\n           MULTIPLY MUL BY DIVISOR-PRODUCTS(NUM).\n\n       OUTPUT-NUM.\n           MOVE DIVISOR-PRODUCTS(NUM) TO NUM-OUT.\n           STRING NUM-OUT DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER LINE-PTR.\n           IF LINE-PTR IS EQUAL TO 51,\n               DISPLAY OUT-LINE,\n               MOVE SPACES TO OUT-LINE,\n               MOVE 1 TO LINE-PTR.\n", "target": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])\n"}
{"id": 421560, "name": "Product of divisors", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  PRODUCT-OF-DIVISORS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 DIVISOR-PRODUCTS    PIC 9(9) OCCURS 50 TIMES.\n          03 NUM                 PIC 999.\n          03 MUL                 PIC 999.\n      \n       01 OUTPUT-FORMAT.\n          03 NUM-OUT             PIC Z(9)9.\n          03 LINE-PTR            PIC 99 VALUE 1.\n          03 OUT-LINE            PIC X(50) VALUE SPACES.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM INIT VARYING NUM FROM 1 BY 1\n               UNTIL NUM IS GREATER THAN 50.\n           PERFORM CALCULATE-MULTIPLES VARYING MUL FROM 1 BY 1\n               UNTIL MUL IS GREATER THAN 50.\n           PERFORM OUTPUT-NUM VARYING NUM FROM 1 BY 1\n               UNTIL NUM IS GREATER THAN 50.\n           STOP RUN.\n\n       INIT.\n           MOVE 1 TO DIVISOR-PRODUCTS(NUM).\n       \n       CALCULATE-MULTIPLES.\n           PERFORM MULTIPLY-NUM VARYING NUM FROM MUL BY MUL\n               UNTIL NUM IS GREATER THAN 50.\n \n       MULTIPLY-NUM.\n           MULTIPLY MUL BY DIVISOR-PRODUCTS(NUM).\n\n       OUTPUT-NUM.\n           MOVE DIVISOR-PRODUCTS(NUM) TO NUM-OUT.\n           STRING NUM-OUT DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER LINE-PTR.\n           IF LINE-PTR IS EQUAL TO 51,\n               DISPLAY OUT-LINE,\n               MOVE SPACES TO OUT-LINE,\n               MOVE 1 TO LINE-PTR.\n", "target": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])\n"}
{"id": 421561, "name": "Playing cards", "source": "Translate COBOL to Python:        identification division.\n       program-id. playing-cards.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       77 card             usage index.\n       01 deck.\n          05 cards occurs 52 times ascending key slot indexed by card.\n             10 slot       pic 99.\n             10 hand       pic 99.\n             10 suit       pic 9.\n             10 symbol     pic x(4).\n             10 rank       pic 99.\n\n       01 filler.\n          05 suit-name     pic x(8) occurs 4 times.\n\n      \n       01 base-s           constant as 4036985504.\n       01 base-h           constant as 4036985520.\n       01 base-d           constant as 4036985728.\n       01 base-c           constant as 4036985744.\n\n       01 sym              pic x(4) comp-x.\n       01 symx             redefines sym pic x(4).\n       77 s                pic 9.\n       77 r                pic 99.\n       77 c                pic 99.\n       77 hit              pic 9.\n       77 limiter          pic 9(6).\n\n       01 spades           constant as 1.\n       01 hearts           constant as 2.\n       01 diamonds         constant as 3.\n       01 clubs            constant as 4.\n\n       01 players          constant as 3.\n       01 cards-per        constant as 5.\n       01 deal             pic 99.\n       01 player           pic 99.\n\n       01 show-tally       pic zz.\n       01 show-rank        pic z(5).\n       01 arg              pic 9(10).\n       \n       procedure division.\n       cards-main.\n       perform seed\n       perform initialize-deck\n       perform shuffle-deck\n       perform deal-deck\n       perform display-hands\n       goback.\n      \n      \n       seed.\n           accept arg from command-line\n           if arg not equal 0 then\n               move random(arg) to c\n           end-if\n       .\n\n       initialize-deck.\n           move \"spades\" to suit-name(spades)\n           move \"hearts\" to suit-name(hearts)\n           move \"diamonds\" to suit-name(diamonds)\n           move \"clubs\" to suit-name(clubs)\n\n           perform varying s from 1 by 1 until s > 4\n                     after r from 1 by 1 until r > 13\n                   compute c = (s - 1) * 13 + r\n                   evaluate s\n                       when spades compute sym = base-s + r\n                       when hearts compute sym = base-h + r\n                       when diamonds compute sym = base-d + r\n                       when clubs compute sym = base-c + r\n                   end-evaluate\n                   if r > 11 then compute sym = sym + 1 end-if\n                   move s to suit(c)\n                   move r to rank(c)\n                   move symx to symbol(c)\n                   move zero to slot(c)\n                   move zero to hand(c)\n           end-perform\n       .\n\n       shuffle-deck.\n           move zero to limiter\n           perform until exit\n               compute c = random() * 52.0 + 1.0\n               move zero to hit\n               perform varying tally from 1 by 1 until tally > 52\n                   if slot(tally) equal c then\n                       move 1 to hit\n                       exit perform\n                   end-if\n                   if slot(tally) equal 0 then\n                       if tally < 52 then move 1 to hit end-if\n                       move c to slot(tally)\n                       exit perform\n                   end-if\n               end-perform\n               if hit equal zero then exit perform end-if\n               if limiter > 999999 then\n                   display \"too many shuffles, deck invalid\" upon syserr\n                   exit perform\n               end-if\n               add 1 to limiter\n           end-perform\n           sort cards ascending key slot\n       .\n\n       display-card.\n       >>IF ENGLISH IS DEFINED\n               move rank(tally) to show-rank\n               evaluate rank(tally) \n                   when 1 display \"  ace\" with no advancing\n                   when 2 thru 10 display show-rank with no advancing\n                   when 11 display \" jack\" with no advancing\n                   when 12 display \"queen\" with no advancing\n                   when 13 display \" king\" with no advancing\n               end-evaluate\n               display \" of \" suit-name(suit(tally)) with no advancing\n       >>ELSE\n               display symbol(tally) with no advancing\n       >>END-IF\n       .\n\n       display-deck.\n           perform varying tally from 1 by 1 until tally > 52\n               move tally to show-tally\n               display \"Card: \" show-tally\n                       \" currently in hand \" hand(tally)\n                       \" is \" with no advancing\n               perform display-card\n               display space\n           end-perform\n       .\n\n       display-hands.\n           perform varying player from 1 by 1 until player > players\n               move player to tally\n               display \"Player \" player \": \" with no advancing\n               perform varying deal from 1 by 1 until deal > cards-per\n                  perform display-card\n                  add players to tally\n               end-perform\n               display space\n           end-perform\n           display \"Stock: \" with no advancing\n           subtract players from tally\n           add 1 to tally\n           perform varying tally from tally by 1 until tally > 52\n               perform display-card\n       >>IF ENGLISH IS DEFINED\n               display space\n       >>END-IF\n           end-perform\n           display space\n       .\n\n       deal-deck.\n           display \"Dealing \" cards-per \" cards to \" players \" players\"\n           move 1 to tally\n           perform varying deal from 1 by 1 until deal > cards-per\n                     after player from 1 by 1 until player > players\n               move player to hand(tally)\n               add 1 to tally\n           end-perform\n       .\n\n       end program playing-cards.\n", "target": "import random\n\nclass Card(object):\n    suits = (\"Clubs\",\"Hearts\",\"Spades\",\"Diamonds\")\n    pips = (\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"Jack\",\"Queen\",\"King\",\"Ace\")\n\n    def __init__(self, pip,suit):\n        self.pip=pip\n        self.suit=suit\n\n    def __str__(self):\n        return \"%s %s\"%(self.pip,self.suit)\n\nclass Deck(object):\n    def __init__(self):\n        self.deck = [Card(pip,suit) for suit in Card.suits for pip in Card.pips]\n\n    def __str__(self):\n        return \"[%s]\"%\", \".join( (str(card) for card in self.deck))\n\n    def shuffle(self):\n        random.shuffle(self.deck)\n\n    def deal(self):\n        self.shuffle()  \n        return self.deck.pop(0)\n"}
{"id": 421562, "name": "Find the last Sunday of each month", "source": "Translate COBOL to Python:        program-id. last-sun.\n       data division.\n       working-storage section.\n       1 wk-date.\n        2 yr pic 9999.\n        2 mo pic 99 value 1.\n        2 da pic 99 value 1.\n       1 rd-date redefines wk-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 sunday pic 9(4) value 7.\n       procedure division.\n           display \"Enter a calendar year (1601 thru 9999): \"\n               with no advancing\n           accept yr\n           if yr >= 1601 and <= 9999\n               continue\n           else\n               display \"Invalid year\"\n               stop run\n           end-if\n           perform 12 times\n               move 1 to da\n               add 1 to mo\n               if mo > 12              \n                   move 12 to mo\n                   move 31 to da\n               end-if\n               compute int-date = function\n                   integer-of-date (rd-date)\n               if mo =12 and da = 31   \n                   continue\n               else\n                   subtract 1 from int-date\n               end-if\n               compute rd-date = function\n                   date-of-integer (int-date)\n               compute dow = function mod\n                   ((int-date - 1) 7) + 1\n               compute dow = function mod ((dow - sunday) 7)\n               subtract dow from da\n               display yr \"-\" mo \"-\" da\n               add 1 to mo\n           end-perform\n           stop run\n           .\n       end program last-sun.\n", "target": "import sys\nimport calendar\n\nyear = 2013\nif len(sys.argv) > 1:\n    try:\n        year = int(sys.argv[-1])\n    except ValueError:\n        pass\n\nfor month in range(1, 13):\n    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))\n    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday))\n"}
{"id": 421563, "name": "Find the last Sunday of each month", "source": "Translate COBOL to Python:        program-id. last-sun.\n       data division.\n       working-storage section.\n       1 wk-date.\n        2 yr pic 9999.\n        2 mo pic 99 value 1.\n        2 da pic 99 value 1.\n       1 rd-date redefines wk-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 sunday pic 9(4) value 7.\n       procedure division.\n           display \"Enter a calendar year (1601 thru 9999): \"\n               with no advancing\n           accept yr\n           if yr >= 1601 and <= 9999\n               continue\n           else\n               display \"Invalid year\"\n               stop run\n           end-if\n           perform 12 times\n               move 1 to da\n               add 1 to mo\n               if mo > 12              \n                   move 12 to mo\n                   move 31 to da\n               end-if\n               compute int-date = function\n                   integer-of-date (rd-date)\n               if mo =12 and da = 31   \n                   continue\n               else\n                   subtract 1 from int-date\n               end-if\n               compute rd-date = function\n                   date-of-integer (int-date)\n               compute dow = function mod\n                   ((int-date - 1) 7) + 1\n               compute dow = function mod ((dow - sunday) 7)\n               subtract dow from da\n               display yr \"-\" mo \"-\" da\n               add 1 to mo\n           end-perform\n           stop run\n           .\n       end program last-sun.\n", "target": "import sys\nimport calendar\n\nyear = 2013\nif len(sys.argv) > 1:\n    try:\n        year = int(sys.argv[-1])\n    except ValueError:\n        pass\n\nfor month in range(1, 13):\n    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))\n    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday))\n"}
{"id": 421564, "name": "Odd and square numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ODD-AND-SQUARE.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 N              PIC 999.\n          03 SQR            PIC 9999 VALUE 0.\n          03 FILLER         REDEFINES SQR.\n             05 FILLER      PIC 999.\n             05 FILLER      PIC 9.\n                88 ODD      VALUE 1, 3, 5, 7, 9.\n          03 FMT            PIC ZZ9.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM CHECK VARYING N FROM 10 BY 1\n                UNTIL SQR IS NOT LESS THAN 1000.\n           STOP RUN.\n       \n       CHECK.\n           MULTIPLY N BY N GIVING SQR.\n           IF ODD, MOVE SQR TO FMT, DISPLAY FMT.\n", "target": "import math\nszamok=[]\nlimit = 1000\n\nfor i in range(1,int(math.ceil(math.sqrt(limit))),2):\n    num = i*i\n    if (num < 1000 and num > 99):\n        szamok.append(num)\n\nprint(szamok)\n"}
{"id": 421565, "name": "Sum of square and cube digits of an integer are primes", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. SQUARE-CUBE-DIGITS-PRIME.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 NUMBER-SEARCH-VARS.\n          03 CAND             PIC 9(6).\n          03 SQUARE           PIC 9(6).\n          03 CUBE             PIC 9(6).\n          \n       01 SUM-DIGITS-VARS.\n          03 SUM-NUM          PIC 9(6).\n          03 DIGITS           PIC 9 OCCURS 6 TIMES INDEXED BY D\n                              REDEFINES SUM-NUM.\n          03 SUM              PIC 99.\n       \n       01 PRIME-TEST-VARS.\n          03 DIVISOR          PIC 99.\n          03 DIV-TEST         PIC 99V9999.\n          03 FILLER           REDEFINES DIV-TEST.\n             05 FILLER        PIC 99.\n             05 FILLER        PIC 9999.\n                88 DIVISIBLE  VALUE ZERO.\n          03 PRIME-FLAG       PIC X.\n             88 PRIME         VALUE '*'.\n       \n       01 OUT-FMT             PIC Z9.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM CHECK-NUMBER VARYING CAND FROM 1 BY 1\n           UNTIL CAND IS EQUAL TO 100.\n           STOP RUN.\n       \n       CHECK-NUMBER.\n           MULTIPLY CAND BY CAND GIVING SQUARE.\n           MULTIPLY CAND BY SQUARE GIVING CUBE.\n           MOVE SQUARE TO SUM-NUM.\n           PERFORM SUM-DIGITS.\n           PERFORM PRIME-TEST.\n           IF PRIME,\n               MOVE CUBE TO SUM-NUM,\n               PERFORM SUM-DIGITS,\n               PERFORM PRIME-TEST,\n               IF PRIME,\n                   MOVE CAND TO OUT-FMT,\n                   DISPLAY OUT-FMT.\n           \n       SUM-DIGITS.\n           MOVE ZERO TO SUM.\n           PERFORM SUM-DIGIT VARYING D FROM 1 BY 1\n           UNTIL D IS GREATER THAN 6.\n           \n       SUM-DIGIT.\n           ADD DIGITS(D) TO SUM.\n       \n       PRIME-TEST.\n           MOVE '*' TO PRIME-FLAG.\n           PERFORM CHECK-DIVISOR VARYING DIVISOR FROM 2 BY 1\n           UNTIL NOT PRIME, OR DIVISOR IS EQUAL TO SUM.\n       \n       CHECK-DIVISOR.\n           DIVIDE SUM BY DIVISOR GIVING DIV-TEST.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef digSum(n, b):\n    s = 0\n    while n:\n        s += (n % b)\n        n = n // b\n    return s\n\nif __name__ == '__main__':\n    for n in range(11, 99):\n        if isPrime(digSum(n**3, 10)) and isPrime(digSum(n**2, 10)):\n            print(n, end = \"  \")\n"}
{"id": 421566, "name": "Harmonic series", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. HARMONIC.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARS.\n          03 N           PIC 9(5) VALUE ZERO.\n          03 HN          PIC 9(2)V9(12) VALUE ZERO.\n          03 INT         PIC 99 VALUE ZERO.\n       01 OUT-VARS.\n          03 POS         PIC Z(4)9.\n          03 FILLER      PIC X(3) VALUE SPACES.\n          03 H-OUT       PIC Z9.9(12).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           DISPLAY \"First 20 harmonic numbers:\"\n           PERFORM SHOW-HARMONIC 20 TIMES.\n           DISPLAY SPACES.\n           MOVE ZERO TO N, HN.\n           DISPLAY \"First harmonic number to exceed whole number:\"\n           PERFORM EXCEED-INT 10 TIMES.\n           STOP RUN.\n\n       SHOW-HARMONIC.\n           PERFORM NEXT-HARMONIC.\n           MOVE HN TO H-OUT.\n           DISPLAY H-OUT.\n\n       EXCEED-INT.\n           ADD 1 TO INT.\n           PERFORM NEXT-HARMONIC UNTIL HN IS GREATER THAN INT.\n           MOVE N TO POS.\n           MOVE HN TO H-OUT.\n           DISPLAY OUT-VARS.\n\n       NEXT-HARMONIC.\n           ADD 1 TO N.\n           COMPUTE HN = HN + 1 / N.\n", "target": "from  fractions import Fraction\n\ndef harmonic_series():\n    n, h = Fraction(1), Fraction(1)\n    while True:\n        yield h\n        h += 1 / (n + 1)\n        n += 1\n\nif __name__ == '__main__':\n    from itertools import islice\n    for n, d in (h.as_integer_ratio() for h in islice(harmonic_series(), 20)):\n        print(n, '/', d)\n"}
{"id": 421567, "name": "Comments", "source": "Translate COBOL to Python:       * an asterisk in 7th column comments the line out\n", "target": "\n\nvar x = 0 \n\nvar y = 0 \n\n\nThere are also multi-line comments\nEverything inside of \n]\n\n\n\ndiscard \n"}
{"id": 421568, "name": "Find squares n where n+1 is prime", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. SQUARE-PLUS-1-PRIME.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 N                   PIC 999.\n       01 P                   PIC 9999 VALUE ZERO.\n       01 PRIMETEST.\n          03 DSOR             PIC 9999.\n          03 PRIME-FLAG       PIC X.\n             88 PRIME         VALUE '*'.\n          03 DIVTEST          PIC 9999V999.\n          03 FILLER           REDEFINES DIVTEST.\n             05 FILLER        PIC 9999.\n             05 FILLER        PIC 999.\n                88 DIVISIBLE  VALUE ZERO.\n           \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM CHECK-N VARYING N FROM 1 BY 1 \n                UNTIL P IS GREATER THAN 1000.\n           STOP RUN.\n       \n       CHECK-N.\n           MULTIPLY N BY N GIVING P.\n           ADD 1 TO P.\n           PERFORM CHECK-PRIME.\n           SUBTRACT 1 FROM P.\n           IF PRIME, DISPLAY P.\n           \n       CHECK-PRIME.\n           IF P IS LESS THAN 2, MOVE SPACE TO PRIME-FLAG,\n           ELSE, MOVE '*' TO PRIME-FLAG.\n           PERFORM CHECK-DSOR VARYING DSOR FROM 2 BY 1\n               UNTIL NOT PRIME OR DSOR IS GREATER THAN N.\n       \n       CHECK-DSOR.\n           DIVIDE P BY DSOR GIVING DIVTEST.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n", "target": "limit = 1000\nprint(\"working...\")\n\ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef issquare(x):\n\tfor n in range(1,x+1):\n\t\tif (x == n*n):\n\t\t\treturn 1\n\treturn 0\n\nfor n in range(limit-1):\n\tif issquare(n) and isprime(n+1):\n\t\tprint(n,end=\" \")\n\nprint()\nprint(\"done...\")\n"}
{"id": 421569, "name": "Find squares n where n+1 is prime", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. SQUARE-PLUS-1-PRIME.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 N                   PIC 999.\n       01 P                   PIC 9999 VALUE ZERO.\n       01 PRIMETEST.\n          03 DSOR             PIC 9999.\n          03 PRIME-FLAG       PIC X.\n             88 PRIME         VALUE '*'.\n          03 DIVTEST          PIC 9999V999.\n          03 FILLER           REDEFINES DIVTEST.\n             05 FILLER        PIC 9999.\n             05 FILLER        PIC 999.\n                88 DIVISIBLE  VALUE ZERO.\n           \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM CHECK-N VARYING N FROM 1 BY 1 \n                UNTIL P IS GREATER THAN 1000.\n           STOP RUN.\n       \n       CHECK-N.\n           MULTIPLY N BY N GIVING P.\n           ADD 1 TO P.\n           PERFORM CHECK-PRIME.\n           SUBTRACT 1 FROM P.\n           IF PRIME, DISPLAY P.\n           \n       CHECK-PRIME.\n           IF P IS LESS THAN 2, MOVE SPACE TO PRIME-FLAG,\n           ELSE, MOVE '*' TO PRIME-FLAG.\n           PERFORM CHECK-DSOR VARYING DSOR FROM 2 BY 1\n               UNTIL NOT PRIME OR DSOR IS GREATER THAN N.\n       \n       CHECK-DSOR.\n           DIVIDE P BY DSOR GIVING DIVTEST.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n", "target": "limit = 1000\nprint(\"working...\")\n\ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef issquare(x):\n\tfor n in range(1,x+1):\n\t\tif (x == n*n):\n\t\t\treturn 1\n\treturn 0\n\nfor n in range(limit-1):\n\tif issquare(n) and isprime(n+1):\n\t\tprint(n,end=\" \")\n\nprint()\nprint(\"done...\")\n"}
{"id": 421570, "name": "Smallest square that begins with n", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. SMALLEST-SQUARE-BEGINS-WITH-N.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 N            PIC 99.\n       01 SQUARE-NO    PIC 999.\n       01 SQUARE       PIC 9(5).\n       01 OUT-FMT      PIC Z(4)9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SMALLEST-SQUARE THRU SQUARE-START-TEST\n               VARYING N FROM 1 BY 1 UNTIL N IS EQUAL TO 50.\n           STOP RUN.\n\n       SMALLEST-SQUARE.\n           MOVE ZERO TO SQUARE-NO.\n       SQUARE-LOOP.\n           ADD 1 TO SQUARE-NO.\n           MULTIPLY SQUARE-NO BY SQUARE-NO GIVING SQUARE.\n       SQUARE-START-TEST.\n           IF SQUARE IS GREATER THAN N\n               DIVIDE 10 INTO SQUARE\n               GO TO SQUARE-START-TEST.\n           IF SQUARE IS NOT EQUAL TO N\n               GO TO SQUARE-LOOP.\n           MULTIPLY SQUARE-NO BY SQUARE-NO GIVING OUT-FMT.\n           DISPLAY OUT-FMT.\n", "target": "\n\nfrom itertools import count\n\n\n\ndef firstSquareWithPrefix(n):\n    \n    pfx = str(n)\n    lng = len(pfx)\n    return int(\n        next(\n            s for s in (\n                str(x * x) for x in count(0)\n            )\n            if pfx == s[0:lng]\n        )\n    )\n\n\n\ndef main():\n    \n\n    print('\\n'.join([\n        str(firstSquareWithPrefix(x)) for x in range(1, 50)\n    ]))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 421571, "name": "Smallest square that begins with n", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. SMALLEST-SQUARE-BEGINS-WITH-N.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 N            PIC 99.\n       01 SQUARE-NO    PIC 999.\n       01 SQUARE       PIC 9(5).\n       01 OUT-FMT      PIC Z(4)9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SMALLEST-SQUARE THRU SQUARE-START-TEST\n               VARYING N FROM 1 BY 1 UNTIL N IS EQUAL TO 50.\n           STOP RUN.\n\n       SMALLEST-SQUARE.\n           MOVE ZERO TO SQUARE-NO.\n       SQUARE-LOOP.\n           ADD 1 TO SQUARE-NO.\n           MULTIPLY SQUARE-NO BY SQUARE-NO GIVING SQUARE.\n       SQUARE-START-TEST.\n           IF SQUARE IS GREATER THAN N\n               DIVIDE 10 INTO SQUARE\n               GO TO SQUARE-START-TEST.\n           IF SQUARE IS NOT EQUAL TO N\n               GO TO SQUARE-LOOP.\n           MULTIPLY SQUARE-NO BY SQUARE-NO GIVING OUT-FMT.\n           DISPLAY OUT-FMT.\n", "target": "\n\nfrom itertools import count\n\n\n\ndef firstSquareWithPrefix(n):\n    \n    pfx = str(n)\n    lng = len(pfx)\n    return int(\n        next(\n            s for s in (\n                str(x * x) for x in count(0)\n            )\n            if pfx == s[0:lng]\n        )\n    )\n\n\n\ndef main():\n    \n\n    print('\\n'.join([\n        str(firstSquareWithPrefix(x)) for x in range(1, 50)\n    ]))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 421572, "name": "Machine code", "source": "Translate COBOL to Python:        >>SOURCE FORMAT IS FIXED\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. MC.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n           01 INSTRUCTIONS.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'55'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'48'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'89'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'E5'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'89'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'7D'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'FC'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'89'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'75'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'F8'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'8B'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'75'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'FC'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'03'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'75'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'F8'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'89'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'75'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'F4'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'8B'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'45'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'F4'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'5D'.\n              03 USAGE BINARY-CHAR UNSIGNED VALUE H'C3'.\n           01 MMAP.\n              03 MMAP-ADDR   USAGE POINTER VALUE NULL.\n              03 MMAP-LEN    USAGE BINARY-LONG UNSIGNED VALUE 24.\n              03 MMAP-PROT   USAGE BINARY-INT VALUE H'0007'.\n              03 MMAP-FLAGS  USAGE BINARY-INT VALUE H'1002'.\n              03 MMAP-FD     USAGE BINARY-INT VALUE -1.\n              03 MMAP-OFFSET USAGE BINARY-LONG VALUE 0.\n           03 CODE-PTR USAGE PROCEDURE-POINTER.\n           01 ARG-A USAGE BINARY-INT VALUE 7.\n           01 ARG-B USAGE BINARY-INT VALUE 12.\n           01 RESULT USAGE BINARY-INT.\n       LINKAGE SECTION.\n           01 MACHINE-CODE PIC X(24).\n       PROCEDURE DIVISION.\n       MAIN SECTION.\n           PERFORM SET-UP.\n           CALL CODE-PTR USING\n              BY VALUE ARG-A\n              BY VALUE ARG-B\n              RETURNING RESULT.\n           DISPLAY RESULT.\n           PERFORM TEAR-DOWN.\n           STOP RUN.\n\n       SET-UP SECTION.\n           CALL 'mmap' USING\n              BY VALUE MMAP-ADDR\n              BY VALUE MMAP-LEN\n              BY VALUE MMAP-PROT\n              BY VALUE MMAP-FLAGS\n              BY VALUE MMAP-FD\n              BY VALUE MMAP-OFFSET\n              RETURNING CODE-PTR.\n           SET ADDRESS OF MACHINE-CODE TO CODE-PTR.\n           MOVE INSTRUCTIONS TO MACHINE-CODE.\n\n       TEAR-DOWN SECTION.\n           SET ADDRESS OF MACHINE-CODE TO NULL.\n           CALL 'munmap' USING\n              BY VALUE CODE-PTR\n              BY VALUE MMAP-LEN.\n", "target": "import ctypes\nimport os\nfrom ctypes import c_ubyte, c_int\n\ncode = bytes([0x8b, 0x44, 0x24, 0x04, 0x03, 0x44, 0x24, 0x08, 0xc3])\n\ncode_size = len(code)\n\nif (os.name == 'posix'):\n    import mmap\n    executable_map = mmap.mmap(-1, code_size, mmap.MAP_PRIVATE | mmap.MAP_ANON, mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC)\n    \n    executable_map.write(code)\n    \n    \n    func_address = ctypes.addressof(c_ubyte.from_buffer(executable_map))\nelif (os.name == 'nt'):\n    \n    code_buffer = ctypes.create_string_buffer(code)\n    PAGE_EXECUTE_READWRITE = 0x40  \n    MEM_COMMIT = 0x1000\n    executable_buffer_address = ctypes.windll.kernel32.VirtualAlloc(0, code_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE)\n    if (executable_buffer_address == 0):\n        print('Warning: Failed to enable code execution, call will likely cause a protection fault.')\n        func_address = ctypes.addressof(code_buffer)\n    else:\n        ctypes.memmove(executable_buffer_address, code_buffer, code_size)\n        func_address = executable_buffer_address\nelse:\n    \n    code_buffer = ctypes.create_string_buffer(code)\n    func_address = ctypes.addressof(code_buffer)\n\nprototype = ctypes.CFUNCTYPE(c_int, c_ubyte, c_ubyte) \nfunc = prototype(func_address)                        \nres = func(7,12)\nprint(res)\n"}
{"id": 421573, "name": "Minimum number of cells after, before, above and below NxN squares", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. MINIMUM-CELLS-N-BY-N.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 TABLE-SIZE        PIC 99 VALUE 10.\n       01 X                 PIC 99.\n       01 Y                 PIC 99.\n       01 ITEM              PIC 99.\n       01 MIN               PIC 99.\n       \n       01 FMT               PIC ZZ9.\n       01 TABLE-LINE        PIC X(72).\n       01 LINE-PTR          PIC 99.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM MAKE-LINE VARYING Y FROM 0 BY 1 \n               UNTIL Y IS EQUAL TO TABLE-SIZE.\n           STOP RUN.\n       \n       MAKE-LINE.\n           MOVE SPACES TO TABLE-LINE.\n           MOVE 1 TO LINE-PTR.\n           PERFORM ADD-ITEM VARYING X FROM 0 BY 1\n               UNTIL X IS EQUAL TO TABLE-SIZE.\n           DISPLAY TABLE-LINE.\n           \n       ADD-ITEM.\n           PERFORM FIND-MINIMUM-VALUE.\n           MOVE MIN TO FMT.\n           STRING FMT DELIMITED BY SIZE INTO TABLE-LINE \n               WITH POINTER LINE-PTR.\n       \n       FIND-MINIMUM-VALUE.\n           MOVE X TO MIN.\n           MOVE Y TO ITEM.\n           PERFORM CHECK-MINIMUM.\n           COMPUTE ITEM = TABLE-SIZE - Y - 1.\n           PERFORM CHECK-MINIMUM.\n           COMPUTE ITEM = TABLE-SIZE - X - 1.\n           PERFORM CHECK-MINIMUM.\n       \n       CHECK-MINIMUM.\n           IF ITEM IS LESS THAN MIN, MOVE ITEM TO MIN.\n", "target": "def min_cells_matrix(siz):\n    return [[min(row, col, siz - row - 1, siz - col - 1) for col in range(siz)] for row in range(siz)]\n\ndef display_matrix(mat):\n    siz = len(mat)\n    spaces = 2 if siz < 20 else 3 if siz < 200 else 4\n    print(f\"\\nMinimum number of cells after, before, above and below {siz} x {siz} square:\")\n    for row in range(siz):\n        print(\"\".join([f\"{n:{spaces}}\" for n in mat[row]]))\n\ndef test_min_mat():\n    for siz in [23, 10, 9, 2, 1]:\n        display_matrix(min_cells_matrix(siz))\n\nif __name__ == \"__main__\":\n    test_min_mat()\n"}
{"id": 421574, "name": "Strange plus numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. STRANGE-PLUS-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE            PIC 999.\n          03 DIGITS               REDEFINES CANDIDATE,\n                                  PIC 9 OCCURS 3 TIMES.\n          03 LEFT-PAIR            PIC 99.\n             88 LEFT-PAIR-PRIME   VALUES 2, 3, 5, 7, 11, 13, 17.\n          03 RIGHT-PAIR           PIC 99. \n             88 RIGHT-PAIR-PRIME  VALUES 2, 3, 5, 7, 11, 13, 17.\n       01 OUT.\n          03 ROW                  PIC X(40) VALUE SPACES.\n          03 PTR                  PIC 99 VALUE 1.\n       \n       PROCEDURE DIVISION. \n       BEGIN. \n           PERFORM CHECK-STRANGE-NUMBER\n           VARYING CANDIDATE FROM 100 BY 1\n           UNTIL CANDIDATE IS GREATER THAN 500.\n           DISPLAY ROW.\n           STOP RUN.\n\n       CHECK-STRANGE-NUMBER. \n           ADD DIGITS(1), DIGITS(2) GIVING LEFT-PAIR.\n           ADD DIGITS(2), DIGITS(3) GIVING RIGHT-PAIR. \n           IF LEFT-PAIR-PRIME AND RIGHT-PAIR-PRIME,\n               PERFORM WRITE-STRANGE-NUMBER.\n\n       WRITE-STRANGE-NUMBER.\n           STRING CANDIDATE DELIMITED BY SIZE INTO ROW\n           WITH POINTER PTR.\n           ADD 1 TO PTR.\n           IF PTR IS GREATER THAN 40,\n               DISPLAY ROW,\n               MOVE SPACES TO ROW,\n               MOVE 1 TO PTR.\n", "target": "Python 3.8.5 (default, Sep  3 2020, 21:29:08) [MSC v.1916 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> from sympy import isprime\n\n>>> [x for x in range(101,500) \n if isprime(sum(int(c) for c in str(x)[:2])) and\n    isprime(sum(int(c) for c in str(x)[1:]))]\n[111, 112, 114, 116, 120, 121, 123, 125, 129, 141, 143, 147, 149, 161, 165, 167, 202, 203, 205, 207, 211, 212, 214, 216, 230, 232, 234, 238, 250, 252, 256, 258, 292, 294, 298, 302, 303, 305, 307, 320, 321, 323, 325, 329, 341, 343, 347, 349, 383, 385, 389, 411, 412, 414, 416, 430, 432, 434, 438, 470, 474, 476, 492, 494, 498]\n>>>\n"}
{"id": 421575, "name": "Strange plus numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. STRANGE-PLUS-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE            PIC 999.\n          03 DIGITS               REDEFINES CANDIDATE,\n                                  PIC 9 OCCURS 3 TIMES.\n          03 LEFT-PAIR            PIC 99.\n             88 LEFT-PAIR-PRIME   VALUES 2, 3, 5, 7, 11, 13, 17.\n          03 RIGHT-PAIR           PIC 99. \n             88 RIGHT-PAIR-PRIME  VALUES 2, 3, 5, 7, 11, 13, 17.\n       01 OUT.\n          03 ROW                  PIC X(40) VALUE SPACES.\n          03 PTR                  PIC 99 VALUE 1.\n       \n       PROCEDURE DIVISION. \n       BEGIN. \n           PERFORM CHECK-STRANGE-NUMBER\n           VARYING CANDIDATE FROM 100 BY 1\n           UNTIL CANDIDATE IS GREATER THAN 500.\n           DISPLAY ROW.\n           STOP RUN.\n\n       CHECK-STRANGE-NUMBER. \n           ADD DIGITS(1), DIGITS(2) GIVING LEFT-PAIR.\n           ADD DIGITS(2), DIGITS(3) GIVING RIGHT-PAIR. \n           IF LEFT-PAIR-PRIME AND RIGHT-PAIR-PRIME,\n               PERFORM WRITE-STRANGE-NUMBER.\n\n       WRITE-STRANGE-NUMBER.\n           STRING CANDIDATE DELIMITED BY SIZE INTO ROW\n           WITH POINTER PTR.\n           ADD 1 TO PTR.\n           IF PTR IS GREATER THAN 40,\n               DISPLAY ROW,\n               MOVE SPACES TO ROW,\n               MOVE 1 TO PTR.\n", "target": "Python 3.8.5 (default, Sep  3 2020, 21:29:08) [MSC v.1916 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> from sympy import isprime\n\n>>> [x for x in range(101,500) \n if isprime(sum(int(c) for c in str(x)[:2])) and\n    isprime(sum(int(c) for c in str(x)[1:]))]\n[111, 112, 114, 116, 120, 121, 123, 125, 129, 141, 143, 147, 149, 161, 165, 167, 202, 203, 205, 207, 211, 212, 214, 216, 230, 232, 234, 238, 250, 252, 256, 258, 292, 294, 298, 302, 303, 305, 307, 320, 321, 323, 325, 329, 341, 343, 347, 349, 383, 385, 389, 411, 412, 414, 416, 430, 432, 434, 438, 470, 474, 476, 492, 494, 498]\n>>>\n"}
{"id": 421576, "name": "Minimum multiple of m where digital sum equals m", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. A131382.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 MAXIMUM      PIC 99 VALUE 40.\n          03 N            PIC 999.\n          03 M            PIC 9(9).\n          03 N-TIMES-M    PIC 9(9).\n          03 DIGITS       PIC 9 OCCURS 9 TIMES,\n                          REDEFINES N-TIMES-M,\n                          INDEXED BY D.\n          03 DIGITSUM     PIC 999 VALUE ZERO.\n       01 OUTFMT.\n          03 FILLER       PIC XX VALUE \"A(\".\n          03 N-OUT        PIC Z9.\n          03 FILLER       PIC X(4) VALUE \") = \".\n          03 M-OUT        PIC Z(8)9.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM CALC-A131382 VARYING N FROM 1 BY 1\n           UNTIL N IS GREATER THAN MAXIMUM.\n           STOP RUN.\n       \n       CALC-A131382.\n           PERFORM FIND-LEAST-M VARYING M FROM 1 BY 1\n           UNTIL DIGITSUM IS EQUAL TO N.\n           SUBTRACT 1 FROM M.\n           MOVE N TO N-OUT.\n           MOVE M TO M-OUT.\n           DISPLAY OUTFMT.\n           \n       FIND-LEAST-M.\n           MOVE ZERO TO DIGITSUM.\n           MULTIPLY N BY M GIVING N-TIMES-M.\n           PERFORM ADD-DIGIT VARYING D FROM 1 BY 1\n           UNTIL D IS GREATER THAN 9.\n       \n       ADD-DIGIT.\n           ADD DIGITS(D) TO DIGITSUM.\n", "target": "\n\nfrom itertools import count, islice\n\n\n\ndef a131382():\n    \n    return (\n        elemIndex(x)(\n            productDigitSums(x)\n        ) for x in count(1)\n    )\n\n\n\ndef productDigitSums(n):\n    \n    return (digitSum(n * x) for x in count(0))\n\n\n\n\ndef main():\n    \n\n    print(\n        table(10)([\n            str(x) for x in islice(\n                a131382(),\n                40\n            )\n        ])\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digitSum(n):\n    \n    return sum(int(x) for x in list(str(n)))\n\n\n\ndef elemIndex(x):\n    \n    def go(xs):\n        try:\n            return next(\n                i for i, v in enumerate(xs) if x == v\n            )\n        except StopIteration:\n            return None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 421577, "name": "Test integerness", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. INTEGERNESS-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  INTEGERS-OR-ARE-THEY.\n    05 POSSIBLE-INTEGER PIC S9(9)V9(9).\n    05 DEFINITE-INTEGER PIC S9(9).\n01  COMPLEX-NUMBER.\n    05 REAL-PART        PIC S9(9)V9(9).\n    05 IMAGINARY-PART   PIC S9(9)V9(9).\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    MOVE ZERO TO IMAGINARY-PART.\n    DIVIDE -28 BY 7 GIVING POSSIBLE-INTEGER.\n    PERFORM INTEGER-PARAGRAPH.\n    DIVIDE 28 BY 18 GIVING POSSIBLE-INTEGER.\n    PERFORM INTEGER-PARAGRAPH.\n    DIVIDE 3 BY 10000000000 GIVING POSSIBLE-INTEGER.\n    PERFORM INTEGER-PARAGRAPH.\nTEST-COMPLEX-PARAGRAPH.\n    MOVE ZERO TO REAL-PART.\n    MOVE 1 TO IMAGINARY-PART.\n    MOVE REAL-PART TO POSSIBLE-INTEGER.\n    PERFORM INTEGER-PARAGRAPH.\n    STOP RUN.\nINTEGER-PARAGRAPH.\n    IF IMAGINARY-PART IS EQUAL TO ZERO THEN PERFORM REAL-PARAGRAPH,\n    ELSE PERFORM COMPLEX-PARAGRAPH.\nREAL-PARAGRAPH.\n    MOVE POSSIBLE-INTEGER TO DEFINITE-INTEGER.\n    IF DEFINITE-INTEGER IS EQUAL TO POSSIBLE-INTEGER\n    THEN DISPLAY POSSIBLE-INTEGER ' IS AN INTEGER.',\n    ELSE DISPLAY POSSIBLE-INTEGER ' IS NOT AN INTEGER.'.\nCOMPLEX-PARAGRAPH.\n    DISPLAY REAL-PART '+' IMAGINARY-PART 'i IS NOT AN INTEGER.'.\n", "target": ">>> def isint(f): \n    return complex(f).imag == 0 and complex(f).real.is_integer()\n\n>>> [isint(f) for f in (1.0, 2, (3.0+0.0j), 4.1, (3+4j), (5.6+0j))]\n[True, True, True, False, False, False]\n\n>>> \n...\n>>> isint(25.000000)\nTrue\n>>> isint(24.999999)\nFalse\n>>> isint(25.000100)\nFalse\n>>> isint(-2.1e120)\nTrue\n>>> isint(-5e-2)\nFalse\n>>> isint(float('nan'))\nFalse\n>>> isint(float('inf'))\nFalse\n>>> isint(5.0+0.0j)\nTrue\n>>> isint(5-5j)\nFalse\n"}
{"id": 421578, "name": "Window creation_X11", "source": "Translate COBOL to Python:        identification division.\n       program-id. x11-hello.\n       installation. cobc -x x11-hello.cob -lX11\n       remarks. Use of private data is likely not cross platform.\n\n       data division.\n       working-storage section.\n       01 msg.\n          05 filler            value z\"S'up, Earth?\".\n       01 msg-len              usage binary-long value 12.\n\n       01 x-display            usage pointer.\n       01 x-window             usage binary-c-long.\n\n      \n      \n      \n      \n       01 x-display-private    based.\n          05 x-ext-data        usage pointer sync.\n          05 private1          usage pointer.\n          05 x-fd              usage binary-long.\n          05 private2          usage binary-long.\n          05 proto-major-version   usage binary-long.\n          05 proto-minor-version   usage binary-long.\n          05 vendor            usage pointer sync.\n          05 private3          usage pointer.\n          05 private4          usage pointer.\n          05 private5          usage pointer.\n          05 private6          usage binary-long.\n          05 allocator         usage program-pointer sync.\n          05 byte-order        usage binary-long.\n          05 bitmap-unit       usage binary-long.\n          05 bitmap-pad        usage binary-long.\n          05 bitmap-bit-order  usage binary-long.\n          05 nformats          usage binary-long.\n          05 screen-format     usage pointer sync.\n          05 private8          usage binary-long.\n          05 x-release         usage binary-long.\n          05 private9          usage pointer sync.\n          05 private10         usage pointer sync.\n          05 qlen              usage binary-long.\n          05 last-request-read usage binary-c-long unsigned sync.\n          05 request           usage binary-c-long unsigned sync.\n          05 private11         usage pointer sync.\n          05 private12         usage pointer.\n          05 private13         usage pointer.\n          05 private14         usage pointer.\n          05 max-request-size  usage binary-long unsigned.\n          05 x-db              usage pointer sync.\n          05 private15         usage program-pointer sync.\n          05 display-name      usage pointer.\n          05 default-screen    usage binary-long.\n          05 nscreens          usage binary-long.\n          05 screens           usage pointer sync.\n          05 motion-buffer     usage binary-c-long unsigned.\n          05 private16         usage binary-c-long unsigned.\n          05 min-keycode       usage binary-long.\n          05 max-keycode       usage binary-long.\n          05 private17         usage pointer sync.\n          05 private18         usage pointer.\n          05 private19         usage binary-long.\n          05 x-defaults        usage pointer sync.\n          05 filler            pic x(256).\n\n       01 x-screen-private     based.\n          05 scr-ext-data      usage pointer sync.\n          05 display-back      usage pointer.\n          05 root              usage binary-c-long.\n          05 x-width           usage binary-long.\n          05 x-height          usage binary-long.\n          05 m-width           usage binary-long.\n          05 m-height          usage binary-long.\n          05 x-ndepths         usage binary-long.\n          05 depths            usage pointer sync.\n          05 root-depth        usage binary-long.\n          05 root-visual       usage pointer sync.\n          05 default-gc        usage pointer.\n          05 cmap              usage pointer.\n          05 white-pixel       usage binary-c-long unsigned sync.\n          05 black-pixel       usage binary-c-long unsigned.\n          05 max-maps          usage binary-long.\n          05 min-maps          usage binary-long.\n          05 backing-store     usage binary-long.\n          05 save_unders       usage binary-char.\n          05 root-input-mask   usage binary-c-long sync.\n          05 filler            pic x(256).\n\n       01 event.\n          05 e-type usage      binary-long.\n          05 filler            pic x(188).\n          05 filler            pic x(256).\n       01 Expose               constant as 12.\n       01 KeyPress             constant as 2.\n\n      \n       01 event-mask           usage binary-c-long value 32769.\n\n      \n       01 x-char-struct.\n          05 lbearing          usage binary-short.\n          05 rbearing          usage binary-short.\n          05 string-width      usage binary-short.\n          05 ascent            usage binary-short.\n          05 descent           usage binary-short.\n          05 attributes        usage binary-short unsigned.\n       01 font-direction       usage binary-long.\n       01 font-ascent          usage binary-long.\n       01 font-descent         usage binary-long.\n\n       01 XGContext            usage binary-c-long.\n       01 box-width            usage binary-long.\n       01 box-height           usage binary-long.\n\n      \n       procedure division.\n\n       call \"XOpenDisplay\" using by reference null returning x-display\n           on exception\n               display function module-id \" Error: \"\n                       \"no XOpenDisplay linkage, requires libX11\"\n                  upon syserr\n               stop run returning 1\n       end-call\n       if x-display equal null then\n           display function module-id \" Error: \"\n                   \"XOpenDisplay returned null\" upon syserr\n           stop run returning 1\n       end-if\n       set address of x-display-private to x-display\n\n       if screens equal null then\n           display function module-id \" Error: \"\n                   \"XOpenDisplay associated screen null\" upon syserr\n           stop run returning 1\n       end-if\n       set address of x-screen-private to screens\n\n       call \"XCreateSimpleWindow\" using\n           by value x-display root 10 10 200 50 1\n                    black-pixel white-pixel\n           returning x-window\n       call \"XStoreName\" using\n           by value x-display x-window by reference msg\n\n       call \"XSelectInput\" using by value x-display x-window event-mask\n\n       call \"XMapWindow\" using by value x-display x-window\n\n       call \"XGContextFromGC\" using by value default-gc\n           returning XGContext\n       call \"XQueryTextExtents\" using by value x-display XGContext\n           by reference msg by value msg-len\n           by reference font-direction font-ascent font-descent\n           x-char-struct\n       compute box-width = string-width + 8\n       compute box-height = font-ascent + font-descent + 8\n\n       perform forever\n          call \"XNextEvent\" using by value x-display by reference event\n          if e-type equal Expose then\n              call \"XDrawRectangle\" using\n                  by value x-display x-window default-gc 5 5\n                           box-width box-height\n              call \"XDrawString\" using\n                  by value x-display x-window default-gc 10 20\n                  by reference msg by value msg-len\n          end-if\n          if e-type equal KeyPress then exit perform end-if\n       end-perform\n\n       call \"XCloseDisplay\" using by value x-display\n\n       goback.\n       end program x11-hello.\n", "target": "from Xlib import X, display\n\nclass Window:\n    def __init__(self, display, msg):\n        self.display = display\n        self.msg = msg\n        \n        self.screen = self.display.screen()\n        self.window = self.screen.root.create_window(\n            10, 10, 100, 100, 1,\n            self.screen.root_depth,\n            background_pixel=self.screen.white_pixel,\n            event_mask=X.ExposureMask | X.KeyPressMask,\n            )\n        self.gc = self.window.create_gc(\n            foreground = self.screen.black_pixel,\n            background = self.screen.white_pixel,\n            )\n\n        self.window.map()\n\n    def loop(self):\n        while True:\n            e = self.display.next_event()\n                \n            if e.type == X.Expose:\n                self.window.fill_rectangle(self.gc, 20, 20, 10, 10)\n                self.window.draw_text(self.gc, 10, 50, self.msg)\n            elif e.type == X.KeyPress:\n                raise SystemExit\n\n                \nif __name__ == \"__main__\":\n    Window(display.Display(), \"Hello, World!\").loop()\n"}
{"id": 421579, "name": "Biorhythms", "source": "Translate COBOL to Python:  \n\n       identification division.\n       program-id.             bio.\n       environment division. \n      *************************************************************\n      **** To execute on command line enter program name followed \n      **** by birth date ccyymmdd and then target date. \n      **** Example: bio 18090102 18631117\n      **** Will display the three cycles:  \n      **** Physcial 23 days, Emotional 28 days, Mental 33 days \n      **** for that date. \n      ****\n      *************************************************************\n       configuration section.\n       source-computer.\n           System76 \n      *           with debugging mode\n           .\n       repository.    \n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 w-d1                                              pic x(08).\n       01 w-d2                                              pic x(08).\n       01 n-d1                                              pic 9(08).\n       01 n-d2                                              pic 9(08).\n       01 w-i1                                       comp-x pic x(04).\n       01 w-i2                                       comp-x pic x(04).\n       01 w-days                                            pic 9(07).\n       01 arg-knt                                    comp-5 pic x(01).\n       01 bx                                       pic 9.    \n       01 bio-tbl  value 'Physical 23Emotional28Mental   33'.\n               05  bio-entry  occurs 3 times.\n                   10  bio-cyc                     pic x(09).\n                   10  bio-lth                     pic 9(02).\n       01 bio-data occurs 3 times.\n          05  bio-mod                              pic 9(02).\n          05  bio-sin                              pic s999v9.     \n          05  bio-dsc                              pic x(09). \n\n       procedure division.\n           accept arg-knt from argument-number\n           if arg-knt <> 2\n           then\n            display 'two arguments are required:' upon SYSERR\n            display ' 1. first  date ccyymmdd'    upon SYSERR\n            display ' 2. second date ccyymmdd'    upon SYSERR\n            stop run returning -1\n           end-if\n           accept w-d1 from argument-value\n           if  w-d1 not numeric\n               display ' first date not numeric ' upon syserr\n               move 2 to return-code\n               stop run \n           end-if\n           move w-d1 to n-d1\n           if  (n-d1 > 99991231)\n               display ' first date must be less than 99991232' \n                       upon syserr\n               move 3 to return-code\n               stop run\n           end-if\n           if  (n-d1 < 16010101)\n               display ' first date must be greater than 16010100' \n                       upon syserr\n               move 4 to return-code\n               stop run\n           end-if\n           if  ((n-d1(5:2) = '00') \n               or\n                (n-d1(5:2) > '12'))\n               display ' invalid month for first date ' upon syserr\n               move 5 to return-code\n               stop run\n           end-if\n           if  ((n-d1(7:2) = '00')\n               or\n                (n-d1(7:2) > '31'))\n               display ' invalid day for first date ' upon syserr\n               move 6 to return-code\n               stop run\n           end-if\n           accept w-d2 from argument-value\n           if  w-d2 not numeric\n               display 'second date not numeric ' upon syserr\n               move 12 to return-code\n               stop run\n           end-if\n           move w-d2 to n-d2\n           if  (n-d2 > 99991231)\n               display ' second date must be less than 99991232' \n                       upon syserr\n               move 13 to return-code\n               stop run\n           end-if\n           if  (n-d2 < 16010101)\n               display ' second date must be greater than 16010100'  \n                       upon syserr\n               move 14 to return-code\n               stop run\n           end-if\n           if  ((n-d2(5:2) = '00')\n               or\n                (n-d2(5:2) > '12'))\n               display ' invalid month for second date ' upon syserr\n               move 15 to return-code\n               stop run\n           end-if\n           if  ((n-d2(7:2) = '00')\n               or\n                (n-d2(7:2) > '31'))\n               display ' invalid day for second date ' upon syserr\n               move 16 to return-code\n               stop run\n           end-if\n           move w-d1 to n-d1\n           move w-d2 to n-d2\n           move integer-of-date(n-d1) to w-i1\n           move integer-of-date(n-d2) to w-i2\n           compute w-days = w-i1 - w-i2\n           display w-days\n           perform  varying  bx from 1 by 1 until bx greater than 3 \n               move mod(w-days, bio-lth(bx)) to bio-mod(bx) \n               compute bio-sin(bx) rounded \n                  = 100 * sin(2 * PI * bio-mod(bx) / bio-lth(bx)) \n               end-compute\n               display bio-cyc(bx) \" \" \n                       bio-mod(bx) \":\" \n                       bio-sin(bx) \"%\" with no advancing \n               end-display                 \n               if  bio-sin(bx) > 95\n                   move  \" peak\" to bio-dsc(bx)\n               end-if \n               if  bio-sin(bx) < -95\n                   move  \" valley\" to bio-dsc(bx)\n               end-if   \n               if  abs(bio-sin(bx)) < 5\n                   move \" critical\" to bio-dsc(bx)  \n               end-if        \n               display bio-dsc(bx)  \n           end-perform\n           move 0 to return-code\n           goback\n           .\n", "target": "\n\nfrom datetime import date, timedelta\nfrom math import floor, sin, pi\n\ndef biorhythms(birthdate,targetdate):\n    \n    \n    \n    \n    print(\"Born: \"+birthdate+\" Target: \"+targetdate)    \n    \n    \n    \n    birthdate = date.fromisoformat(birthdate)\n    targetdate = date.fromisoformat(targetdate)\n    \n    \n    \n    days = (targetdate - birthdate).days\n    \n    print(\"Day: \"+str(days))\n    \n    \n    \n    cycle_labels = [\"Physical\", \"Emotional\", \"Mental\"]\n    cycle_lengths = [23, 28, 33]\n    quadrants = [(\"up and rising\", \"peak\"), (\"up but falling\", \"transition\"),\n                   (\"down and falling\", \"valley\"), (\"down but rising\", \"transition\")]\n    \n    for i in range(3):\n        label = cycle_labels[i]\n        length = cycle_lengths[i]\n        position = days % length\n        quadrant = int(floor((4 * position) / length))\n        percentage = int(round(100 * sin(2 * pi * position / length),0))\n        transition_date = targetdate + timedelta(days=floor((quadrant + 1)/4 * length) - position)\n        trend, next = quadrants[quadrant]\n        \n        if percentage > 95:\n            description = \"peak\"\n        elif percentage < -95:\n             description = \"valley\"\n        elif abs(percentage) < 5:\n             description = \"critical transition\"\n        else:\n             description = str(percentage)+\"% (\"+trend+\", next \"+next+\" \"+str(transition_date)+\")\"\n        print(label+\" day \"+str(position)+\": \"+description)\n    \n    \nbiorhythms(\"1943-03-09\",\"1972-07-11\")\n"}
{"id": 421580, "name": "Biorhythms", "source": "Translate COBOL to Python:  \n\n       identification division.\n       program-id.             bio.\n       environment division. \n      *************************************************************\n      **** To execute on command line enter program name followed \n      **** by birth date ccyymmdd and then target date. \n      **** Example: bio 18090102 18631117\n      **** Will display the three cycles:  \n      **** Physcial 23 days, Emotional 28 days, Mental 33 days \n      **** for that date. \n      ****\n      *************************************************************\n       configuration section.\n       source-computer.\n           System76 \n      *           with debugging mode\n           .\n       repository.    \n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 w-d1                                              pic x(08).\n       01 w-d2                                              pic x(08).\n       01 n-d1                                              pic 9(08).\n       01 n-d2                                              pic 9(08).\n       01 w-i1                                       comp-x pic x(04).\n       01 w-i2                                       comp-x pic x(04).\n       01 w-days                                            pic 9(07).\n       01 arg-knt                                    comp-5 pic x(01).\n       01 bx                                       pic 9.    \n       01 bio-tbl  value 'Physical 23Emotional28Mental   33'.\n               05  bio-entry  occurs 3 times.\n                   10  bio-cyc                     pic x(09).\n                   10  bio-lth                     pic 9(02).\n       01 bio-data occurs 3 times.\n          05  bio-mod                              pic 9(02).\n          05  bio-sin                              pic s999v9.     \n          05  bio-dsc                              pic x(09). \n\n       procedure division.\n           accept arg-knt from argument-number\n           if arg-knt <> 2\n           then\n            display 'two arguments are required:' upon SYSERR\n            display ' 1. first  date ccyymmdd'    upon SYSERR\n            display ' 2. second date ccyymmdd'    upon SYSERR\n            stop run returning -1\n           end-if\n           accept w-d1 from argument-value\n           if  w-d1 not numeric\n               display ' first date not numeric ' upon syserr\n               move 2 to return-code\n               stop run \n           end-if\n           move w-d1 to n-d1\n           if  (n-d1 > 99991231)\n               display ' first date must be less than 99991232' \n                       upon syserr\n               move 3 to return-code\n               stop run\n           end-if\n           if  (n-d1 < 16010101)\n               display ' first date must be greater than 16010100' \n                       upon syserr\n               move 4 to return-code\n               stop run\n           end-if\n           if  ((n-d1(5:2) = '00') \n               or\n                (n-d1(5:2) > '12'))\n               display ' invalid month for first date ' upon syserr\n               move 5 to return-code\n               stop run\n           end-if\n           if  ((n-d1(7:2) = '00')\n               or\n                (n-d1(7:2) > '31'))\n               display ' invalid day for first date ' upon syserr\n               move 6 to return-code\n               stop run\n           end-if\n           accept w-d2 from argument-value\n           if  w-d2 not numeric\n               display 'second date not numeric ' upon syserr\n               move 12 to return-code\n               stop run\n           end-if\n           move w-d2 to n-d2\n           if  (n-d2 > 99991231)\n               display ' second date must be less than 99991232' \n                       upon syserr\n               move 13 to return-code\n               stop run\n           end-if\n           if  (n-d2 < 16010101)\n               display ' second date must be greater than 16010100'  \n                       upon syserr\n               move 14 to return-code\n               stop run\n           end-if\n           if  ((n-d2(5:2) = '00')\n               or\n                (n-d2(5:2) > '12'))\n               display ' invalid month for second date ' upon syserr\n               move 15 to return-code\n               stop run\n           end-if\n           if  ((n-d2(7:2) = '00')\n               or\n                (n-d2(7:2) > '31'))\n               display ' invalid day for second date ' upon syserr\n               move 16 to return-code\n               stop run\n           end-if\n           move w-d1 to n-d1\n           move w-d2 to n-d2\n           move integer-of-date(n-d1) to w-i1\n           move integer-of-date(n-d2) to w-i2\n           compute w-days = w-i1 - w-i2\n           display w-days\n           perform  varying  bx from 1 by 1 until bx greater than 3 \n               move mod(w-days, bio-lth(bx)) to bio-mod(bx) \n               compute bio-sin(bx) rounded \n                  = 100 * sin(2 * PI * bio-mod(bx) / bio-lth(bx)) \n               end-compute\n               display bio-cyc(bx) \" \" \n                       bio-mod(bx) \":\" \n                       bio-sin(bx) \"%\" with no advancing \n               end-display                 \n               if  bio-sin(bx) > 95\n                   move  \" peak\" to bio-dsc(bx)\n               end-if \n               if  bio-sin(bx) < -95\n                   move  \" valley\" to bio-dsc(bx)\n               end-if   \n               if  abs(bio-sin(bx)) < 5\n                   move \" critical\" to bio-dsc(bx)  \n               end-if        \n               display bio-dsc(bx)  \n           end-perform\n           move 0 to return-code\n           goback\n           .\n", "target": "\n\nfrom datetime import date, timedelta\nfrom math import floor, sin, pi\n\ndef biorhythms(birthdate,targetdate):\n    \n    \n    \n    \n    print(\"Born: \"+birthdate+\" Target: \"+targetdate)    \n    \n    \n    \n    birthdate = date.fromisoformat(birthdate)\n    targetdate = date.fromisoformat(targetdate)\n    \n    \n    \n    days = (targetdate - birthdate).days\n    \n    print(\"Day: \"+str(days))\n    \n    \n    \n    cycle_labels = [\"Physical\", \"Emotional\", \"Mental\"]\n    cycle_lengths = [23, 28, 33]\n    quadrants = [(\"up and rising\", \"peak\"), (\"up but falling\", \"transition\"),\n                   (\"down and falling\", \"valley\"), (\"down but rising\", \"transition\")]\n    \n    for i in range(3):\n        label = cycle_labels[i]\n        length = cycle_lengths[i]\n        position = days % length\n        quadrant = int(floor((4 * position) / length))\n        percentage = int(round(100 * sin(2 * pi * position / length),0))\n        transition_date = targetdate + timedelta(days=floor((quadrant + 1)/4 * length) - position)\n        trend, next = quadrants[quadrant]\n        \n        if percentage > 95:\n            description = \"peak\"\n        elif percentage < -95:\n             description = \"valley\"\n        elif abs(percentage) < 5:\n             description = \"critical transition\"\n        else:\n             description = str(percentage)+\"% (\"+trend+\", next \"+next+\" \"+str(transition_date)+\")\"\n        print(label+\" day \"+str(position)+\": \"+description)\n    \n    \nbiorhythms(\"1943-03-09\",\"1972-07-11\")\n"}
{"id": 421581, "name": "Print debugging statement", "source": "Translate COBOL to Python: gcobol\n      \n      \n      \n      \n       identification division.\n       program-id. steptrace.\n\n       data division.\n       working-storage section.\n\n       procedure division.\n       steptrace-main.\n\n       display \"explicit line\" upon syserr\n\n    >>Ddisplay \"debug line\" upon syserr\n\n       display \"from \" FUNCTION MODULE-ID \" in \" FUNCTION MODULE-SOURCE\n       goback.\n       end program steptrace.\n", "target": "import logging, logging.handlers\n\nLOG_FILENAME = \"logdemo.log\"\nFORMAT_STRING = \"%(levelname)s:%(asctime)s:%(name)s:%(funcName)s:line-%(lineno)d: %(message)s\"\nLOGLEVEL = logging.DEBUG\n\n\ndef print_squares(number):\n    logger.info(\"In print_squares\")\n    for i in range(number):\n        print(\"square of {0} is {1}\".format(i , i*i))\n        logger.debug(f'square of {i} is {i*i}')\n\ndef print_cubes(number):\n    logger.info(\"In print_cubes\")\n    for j in range(number):\n        print(\"cube of {0} is {1}\".format(j, j*j*j))\n        logger.debug(f'cube of {j} is {j*j*j}')\n\nif __name__ == \"__main__\":\n\n    logger = logging.getLogger(\"logdemo\")\n    logger.setLevel(LOGLEVEL)\n    handler = logging.FileHandler(LOG_FILENAME)\n    handler.setFormatter(logging.Formatter(FORMAT_STRING))\n    logger.addHandler(handler)\n\n    print_squares(10)\n    print_cubes(10)\n\n    logger.info(\"All done\")\n"}
{"id": 421582, "name": "Special divisors", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. SPECIAL-DIVISORS.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 VARIABLES.\n           02 CANDIDATE         PIC 999.\n           02 CAND-REV          PIC 999.\n           02 REVERSE           PIC 999.\n           02 REV-DIGITS        REDEFINES REVERSE PIC 9 OCCURS 3 TIMES.\n           02 DIVMAX            PIC 999.\n           02 DIVISOR           PIC 999.\n           02 DIVRSLT           PIC 999V999.\n           02 FILLER            REDEFINES DIVRSLT.\n              03 FILLER         PIC 999.\n              03 FILLER         PIC 999.\n                 88 DIVISIBLE   VALUE 0.\n           02 TEMP              PIC 9.\n           02 RD                PIC 9 COMP.\n           02 STATUS-FLAG       PIC X.\n              88 OK             VALUE 'Y'.    \n           02 SPECIAL-N         PIC ZZ9.           \n\n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM CHECK-SPECIAL-DIVISOR\n                VARYING CANDIDATE FROM 1 BY 1\n                UNTIL CANDIDATE IS EQUAL TO 200.\n            STOP RUN.\n        \n        CHECK-SPECIAL-DIVISOR.\n            MOVE CANDIDATE TO REVERSE.\n            PERFORM REVERSE-NUMBER.\n            MOVE REVERSE TO CAND-REV.\n            DIVIDE CANDIDATE BY 2 GIVING DIVMAX.\n            MOVE 'Y' TO STATUS-FLAG.\n            PERFORM TRY-DIVISOR\n                VARYING DIVISOR FROM 1 BY 1\n                UNTIL DIVISOR IS GREATER THAN DIVMAX.\n            IF OK\n                MOVE CANDIDATE TO SPECIAL-N\n                DISPLAY SPECIAL-N.\n        \n        TRY-DIVISOR.\n            IF OK\n                DIVIDE CANDIDATE BY DIVISOR GIVING DIVRSLT\n                IF DIVISIBLE\n                    MOVE DIVISOR TO REVERSE\n                    PERFORM REVERSE-NUMBER\n                    DIVIDE CAND-REV BY REVERSE GIVING DIVRSLT\n                    IF NOT DIVISIBLE MOVE 'N' TO STATUS-FLAG.\n        \n        REVERSE-NUMBER.\n            SET RD TO 1.\n            INSPECT REVERSE TALLYING RD FOR LEADING '0'.\n            MOVE REV-DIGITS(RD) TO TEMP.\n            MOVE REV-DIGITS(3) TO REV-DIGITS(RD).\n            MOVE TEMP TO REV-DIGITS(3).\n", "target": "\n\ndef reverse(n):\n    u = 0\n    while n:\n        u = 10 * u + n % 10\n        n = int(n / 10)\n    return u\n\nc = 0\nfor n in range(1, 200):\n    u = reverse(n)\n    s = True\n    \n    for d in range (1, n):\n        if n % d == 0:\n            b = reverse(d)\n            if u % b != 0:\n                s = False\n    if s:\n        c = c + 1\n        print(n, end='\\t')\n                \nprint(\"\\nEncontrados \", c, \"divisores especiales.\")\n"}
{"id": 421583, "name": "Product of min and max prime factors", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. MIN-MAX-PRIME-FACTOR-PRODUCT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION. \n       01 SIEVE-DATA.\n          03 FLAG-DATA          PIC X(100) VALUE SPACES.\n          03 FLAGS              REDEFINES FLAG-DATA, \n                                PIC X OCCURS 100 TIMES.\n             88 PRIME           VALUE SPACE.\n          03 CUR-PRIME          PIC 9(3).\n          03 CUR-PRIME-SQ       PIC 9(6) VALUE ZERO.\n          03 CUR-COMP           PIC 9(3).\n\n       01 MAIN-VARS.\n          03 CUR                PIC 9(3).\n          03 STEP               PIC S9.\n          03 LOW-FACTOR         PIC 9(3).\n          03 HIGH-FACTOR        PIC 9(3).\n          03 PRODUCT            PIC 9(6).\n          03 CUR-FACTOR         PIC 9(3).\n          03 FACTOR-TEST        PIC 9(3)V9(3) VALUE 0.1.\n          03 FILLER             REDEFINES FACTOR-TEST.\n             05 FILLER          PIC 9(3).\n             05 FILLER          PIC 9(3).\n                88 FACTOR       VALUE ZERO.\n\n       01 OUT-VARS. \n          03 PRODUCT-FMT        PIC Z(5)9.\n          03 TABLE-LINE         PIC X(60) VALUE SPACES.\n          03 TABLE-POS          PIC 99 VALUE 1.\n\n       PROCEDURE DIVISION.\n       BEGIN. \n           PERFORM SIEVE.       \n           PERFORM FACTORS-PRODUCT VARYING CUR FROM 1 BY 1\n           UNTIL CUR IS NOT LESS THAN 100.\n\n       FACTORS-PRODUCT.\n           IF CUR IS EQUAL TO 1,\n               MOVE 1 TO LOW-FACTOR, HIGH-FACTOR,\n           ELSE\n               PERFORM FIND-LOW-FACTOR,\n               PERFORM FIND-HIGH-FACTOR.\n           MULTIPLY LOW-FACTOR BY HIGH-FACTOR GIVING PRODUCT.\n           PERFORM WRITE-PRODUCT.\n\n       FIND-LOW-FACTOR.\n           MOVE 2 TO CUR-FACTOR.\n           MOVE 1 TO STEP.\n           PERFORM FIND-FACTOR.\n           MOVE CUR-FACTOR TO LOW-FACTOR.\n\n       FIND-HIGH-FACTOR.\n           MOVE CUR TO CUR-FACTOR.\n           MOVE -1 TO STEP.\n           PERFORM FIND-FACTOR.\n           MOVE CUR-FACTOR TO HIGH-FACTOR.\n\n       FIND-FACTOR.\n           DIVIDE CUR BY CUR-FACTOR GIVING FACTOR-TEST.\n           IF NOT (PRIME(CUR-FACTOR) AND FACTOR), \n               ADD STEP TO CUR-FACTOR, \n               GO TO FIND-FACTOR.\n\n       WRITE-PRODUCT.\n           MOVE PRODUCT TO PRODUCT-FMT.\n           STRING PRODUCT-FMT DELIMITED BY SIZE INTO TABLE-LINE\n           WITH POINTER TABLE-POS.\n           IF TABLE-POS IS GREATER THAN 60,\n               DISPLAY TABLE-LINE,\n               MOVE 1 TO TABLE-POS.\n\n       SIEVE.\n           MOVE 'C' TO FLAGS(1).\n           PERFORM MARK-COMPOSITES VARYING CUR-PRIME FROM 2 BY 1\n           UNTIL CUR-PRIME-SQ IS GREATER THAN 100. \n\n       MARK-COMPOSITES.\n           MULTIPLY CUR-PRIME BY CUR-PRIME GIVING CUR-PRIME-SQ.\n           PERFORM MARK-COMPOSITE\n           VARYING CUR-COMP FROM CUR-PRIME-SQ BY CUR-PRIME\n           UNTIL CUR-COMP IS GREATER THAN 100.\n    \n       MARK-COMPOSITE.\n           MOVE 'C' TO FLAGS(CUR-COMP).\n", "target": "\n\n\nfrom sympy import factorint\n\nNUM_WANTED = 100\n\nfor num in range(1, NUM_WANTED + 1):\n    fac = factorint(num, multiple=True)\n    product = fac[0] * fac[-1] if len(fac) > 0 else 1\n    print(f'{product:5}', end='\\n' if num % 10 == 0 else '')\n"}

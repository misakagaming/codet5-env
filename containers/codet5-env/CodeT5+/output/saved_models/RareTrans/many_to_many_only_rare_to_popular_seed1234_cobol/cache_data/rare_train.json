{"id": 206, "name": "Arithmetic_Integer", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Arithmetic.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01 A      PIC S9(10).\n       01 B      PIC S9(10).\n       01 Result PIC S9(10).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"First number: \" WITH NO ADVANCING\n           ACCEPT A\n           DISPLAY \"Second number: \" WITH NO ADVANCING\n           ACCEPT B\n           \n*          \n*          \n*          \n*          \n\n           ADD A TO B GIVING Result\n           DISPLAY \"A + B = \" Result\n\n           SUBTRACT B FROM A GIVING Result\n           DISPLAY \"A - B = \" Result\n\n           MULTIPLY A BY B GIVING Result\n           DISPLAY \"A * B = \" Result\n\n*          \n*          \n*          \n           DIVIDE A BY B GIVING Result\n           DISPLAY \"A / B = \" Result\n\n           COMPUTE Result = A ^ B\n           DISPLAY \"A ^ B = \" Result\n       \n*          \n           DISPLAY \"A\u00a0% B = \" FUNCTION REM(A, B)\n\n           GOBACK\n           .\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int a = Convert.ToInt32(args[0]);\n        int b = Convert.ToInt32(args[1]);\n\n        Console.WriteLine(\"{0} + {1} = {2}\", a, b, a + b);\n        Console.WriteLine(\"{0} - {1} = {2}\", a, b, a - b);\n        Console.WriteLine(\"{0} * {1} = {2}\", a, b, a * b);\n        Console.WriteLine(\"{0} / {1} = {2}\", a, b, a / b); \n        Console.WriteLine(\"{0}\u00a0% {1} = {2}\", a, b, a % b); \n        Console.WriteLine(\"{0} to the power of {1} = {2}\", a, b, Math.Pow(a, b));\n    }\n}\n"}
{"id": 208, "name": "Arithmetic_Integer", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Arithmetic.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01 A      PIC S9(10).\n       01 B      PIC S9(10).\n       01 Result PIC S9(10).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"First number: \" WITH NO ADVANCING\n           ACCEPT A\n           DISPLAY \"Second number: \" WITH NO ADVANCING\n           ACCEPT B\n           \n*          \n*          \n*          \n*          \n\n           ADD A TO B GIVING Result\n           DISPLAY \"A + B = \" Result\n\n           SUBTRACT B FROM A GIVING Result\n           DISPLAY \"A - B = \" Result\n\n           MULTIPLY A BY B GIVING Result\n           DISPLAY \"A * B = \" Result\n\n*          \n*          \n*          \n           DIVIDE A BY B GIVING Result\n           DISPLAY \"A / B = \" Result\n\n           COMPUTE Result = A ^ B\n           DISPLAY \"A ^ B = \" Result\n       \n*          \n           DISPLAY \"A\u00a0% B = \" FUNCTION REM(A, B)\n\n           GOBACK\n           .\n", "target": "import java.util.Scanner;\n\npublic class IntegerArithmetic {\n    public static void main(String[] args) {\n        \n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n\n        int sum = a + b;        \n        int difference = a - b; \n        int product = a * b;    \n        int division = a / b;   \n        int remainder = a % b;  \n\n        System.out.println(\"a + b = \" + sum);\n        System.out.println(\"a - b = \" + difference);\n        System.out.println(\"a * b = \" + product);\n        System.out.println(\"quotient of a / b = \" + division);   \n        System.out.println(\"remainder of a / b = \" + remainder);   \n    }\n}\n"}
{"id": 209, "name": "Arithmetic_Integer", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Arithmetic.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01 A      PIC S9(10).\n       01 B      PIC S9(10).\n       01 Result PIC S9(10).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"First number: \" WITH NO ADVANCING\n           ACCEPT A\n           DISPLAY \"Second number: \" WITH NO ADVANCING\n           ACCEPT B\n           \n*          \n*          \n*          \n*          \n\n           ADD A TO B GIVING Result\n           DISPLAY \"A + B = \" Result\n\n           SUBTRACT B FROM A GIVING Result\n           DISPLAY \"A - B = \" Result\n\n           MULTIPLY A BY B GIVING Result\n           DISPLAY \"A * B = \" Result\n\n*          \n*          \n*          \n           DIVIDE A BY B GIVING Result\n           DISPLAY \"A / B = \" Result\n\n           COMPUTE Result = A ^ B\n           DISPLAY \"A ^ B = \" Result\n       \n*          \n           DISPLAY \"A\u00a0% B = \" FUNCTION REM(A, B)\n\n           GOBACK\n           .\n", "target": "x = int(raw_input(\"Number 1: \"))\ny = int(raw_input(\"Number 2: \"))\n\nprint \"Sum: %d\" % (x + y)\nprint \"Difference: %d\" % (x - y)\nprint \"Product: %d\" % (x * y)\nprint \"Quotient: %d\" % (x / y)     \n                                   \nprint \"Remainder: %d\" % (x % y)    \nprint \"Quotient: %d with Remainder: %d\" % divmod(x, y)\nprint \"Power: %d\" % x**y\n\n\nraw_input( )\n"}
{"id": 446, "name": "Null object", "source": "Translate COBOL to C#:        identification division.\n       program-id. null-objects.\n       remarks. test with cobc -x -j null-objects.cob\n\n       data division.\n       working-storage section.\n       01 thing-not-thing      usage pointer.\n\n      \n      \n      \n      \n      \n       procedure division.\n       call \"test-null\" using thing-not-thing omitted returning nothing\n       goback.\n       end program null-objects.\n\n      \n      \n      \n       identification division.\n       program-id. test-null.\n\n       data division.\n       linkage section.\n       01 thing-one            usage pointer.\n       01 thing-two            pic x.\n\n       procedure division using\n           thing-one\n           optional thing-two\n           returning omitted.\n\n       if thing-one equal null then\n           display \"thing-one pointer to null\" upon syserr\n       end-if\n\n       if thing-two omitted then\n           display \"no thing-two was passed\" upon syserr\n       end-if\n       goback.\n       end program test-null.\n", "target": "if (foo == null)\n    Console.WriteLine(\"foo is null\");\n"}
{"id": 448, "name": "Null object", "source": "Translate COBOL to Java:        identification division.\n       program-id. null-objects.\n       remarks. test with cobc -x -j null-objects.cob\n\n       data division.\n       working-storage section.\n       01 thing-not-thing      usage pointer.\n\n      \n      \n      \n      \n      \n       procedure division.\n       call \"test-null\" using thing-not-thing omitted returning nothing\n       goback.\n       end program null-objects.\n\n      \n      \n      \n       identification division.\n       program-id. test-null.\n\n       data division.\n       linkage section.\n       01 thing-one            usage pointer.\n       01 thing-two            pic x.\n\n       procedure division using\n           thing-one\n           optional thing-two\n           returning omitted.\n\n       if thing-one equal null then\n           display \"thing-one pointer to null\" upon syserr\n       end-if\n\n       if thing-two omitted then\n           display \"no thing-two was passed\" upon syserr\n       end-if\n       goback.\n       end program test-null.\n", "target": "module NullObject\n    {\n    void run()\n        {\n        @Inject Console console;\n        console.print($\"Null value={Null}, Null.toString()={Null.toString()}\");\n\n     \n        String? s = Null;       \n        String s2 = \"test\";\n        console.print($\"s={s}, s2={s2}, (s==s2)={s==s2}\");\n\n     \n        Int len = s?.size : 0;\n        console.print($\"len={len}\");\n\n        if (String test ?= s)\n            {\n            \n            }\n        else\n            {\n            s = \"a non-null value\";\n            }\n\n     \n        s2 = s;                 \n        console.print($\"s={s}, s2={s2}, (s==s2)={s==s2}\");\n        }\n    }\n"}
{"id": 449, "name": "Null object", "source": "Translate COBOL to Python:        identification division.\n       program-id. null-objects.\n       remarks. test with cobc -x -j null-objects.cob\n\n       data division.\n       working-storage section.\n       01 thing-not-thing      usage pointer.\n\n      \n      \n      \n      \n      \n       procedure division.\n       call \"test-null\" using thing-not-thing omitted returning nothing\n       goback.\n       end program null-objects.\n\n      \n      \n      \n       identification division.\n       program-id. test-null.\n\n       data division.\n       linkage section.\n       01 thing-one            usage pointer.\n       01 thing-two            pic x.\n\n       procedure division using\n           thing-one\n           optional thing-two\n           returning omitted.\n\n       if thing-one equal null then\n           display \"thing-one pointer to null\" upon syserr\n       end-if\n\n       if thing-two omitted then\n           display \"no thing-two was passed\" upon syserr\n       end-if\n       goback.\n       end program test-null.\n", "target": "x = None\nif x is None:\n  print \"x is None\"\nelse:\n  print \"x is not None\"\n"}
{"id": 938, "name": "Bitwise operations", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. bitwise-ops.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  a                       PIC 1(32) USAGE BIT.\n       01  b                       PIC 1(32) USAGE BIT.\n\n       01  result                  PIC 1(32) USAGE BIT.\n       01  result-disp             REDEFINES result PIC S9(9) COMP.\n\n       LINKAGE SECTION.\n       01  a-int                   USAGE BINARY-LONG.\n       01  b-int                   USAGE BINARY-LONG.\n\n       PROCEDURE DIVISION USING a-int, b-int.\n           MOVE FUNCTION BOOLEAN-OF-INTEGER(a-int, 32) TO a\n           MOVE FUNCTION BOOLEAN-OF-INTEGER(b-int, 32) TO b\n\n           COMPUTE result = a B-AND b\n           DISPLAY \"a and b is \" result-disp\n\n           COMPUTE result = a B-OR b\n           DISPLAY \"a or b is \" result-disp\n\n           COMPUTE result = B-NOT a\n           DISPLAY \"Not a is \" result-disp\n\n           COMPUTE result = a B-XOR b\n           DISPLAY \"a exclusive-or b is \" result-disp\n\n           \n\n           GOBACK\n           .\n", "target": "static void bitwise(int a, int b)\n        {\n            Console.WriteLine(\"a and b is {0}\", a & b);\n            Console.WriteLine(\"a or b is {0}\", a | b);\n            Console.WriteLine(\"a xor b is {0}\", a ^ b);\n            Console.WriteLine(\"not a is {0}\", ~a);\n            Console.WriteLine(\"a lshift b is {0}\", a << b);\n            Console.WriteLine(\"a arshift b is {0}\", a >> b); \n                                                             \n            uint c = (uint)a;\n            Console.WriteLine(\"c rshift b is {0}\", c >> b); \n                                                            \n            \n        }\n"}
{"id": 940, "name": "Bitwise operations", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. bitwise-ops.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  a                       PIC 1(32) USAGE BIT.\n       01  b                       PIC 1(32) USAGE BIT.\n\n       01  result                  PIC 1(32) USAGE BIT.\n       01  result-disp             REDEFINES result PIC S9(9) COMP.\n\n       LINKAGE SECTION.\n       01  a-int                   USAGE BINARY-LONG.\n       01  b-int                   USAGE BINARY-LONG.\n\n       PROCEDURE DIVISION USING a-int, b-int.\n           MOVE FUNCTION BOOLEAN-OF-INTEGER(a-int, 32) TO a\n           MOVE FUNCTION BOOLEAN-OF-INTEGER(b-int, 32) TO b\n\n           COMPUTE result = a B-AND b\n           DISPLAY \"a and b is \" result-disp\n\n           COMPUTE result = a B-OR b\n           DISPLAY \"a or b is \" result-disp\n\n           COMPUTE result = B-NOT a\n           DISPLAY \"Not a is \" result-disp\n\n           COMPUTE result = a B-XOR b\n           DISPLAY \"a exclusive-or b is \" result-disp\n\n           \n\n           GOBACK\n           .\n", "target": "module BitwiseOps\n    {\n    @Inject Console console;\n    void run()\n        {\n        for ((Int64 n1, Int64 n2) : [0=7, 1=5, 42=2, 0x123456789ABCDEF=0xFF])  \n            {\n            static String hex(Int64 n)   \n                {\n                \n                return n.toByteArray() [(n.leadingZeroCount / 8).minOf(7) ..< 8].toString();\n                }\n\n            console.print($|For values {n1} ({hex(n1)}) and {n2} ({hex(n2)}):\n                           |  {hex(n1)} AND {hex(n2)} = {hex(n1 & n2)}\n                           |  {hex(n1)} OR {hex(n2)} = {hex(n1 | n2)}\n                           |  {hex(n1)} XOR {hex(n2)} = {hex(n1 ^ n2)}\n                           |  NOT {hex(n1)} = {hex(~n1)}\n                           |  left shift {hex(n1)} by {n2} = {hex(n1 << n2)}\n                           |  right shift {hex(n1)} by {n2} = {hex(n1 >> n2)}\n                           |  right arithmetic shift {hex(n1)} by {n2} = {hex(n1 >>> n2)}\n                           |  left rotate {hex(n1)} by {n2} = {hex(n1.rotateLeft(n2))}\n                           |  right rotate {hex(n1)} by {n2} = {hex(n1.rotateRight(n2))}\n                           |  leftmost bit of {hex(n1)} = {hex(n1.leftmostBit)}\n                           |  rightmost bit of {hex(n1)} = {hex(n1.rightmostBit)}\n                           |  leading zero count of {hex(n1)} = {n1.leadingZeroCount}\n                           |  trailing zero count of {hex(n1)} = {n1.trailingZeroCount}\n                           |  bit count (aka \"population\") of {hex(n1)} = {n1.bitCount}\n                           |  reversed bits of {hex(n1)} = {hex(n1.reverseBits())}\n                           |  reverse bytes of {hex(n1)} = {hex(n1.reverseBytes())}\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 941, "name": "Bitwise operations", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. bitwise-ops.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  a                       PIC 1(32) USAGE BIT.\n       01  b                       PIC 1(32) USAGE BIT.\n\n       01  result                  PIC 1(32) USAGE BIT.\n       01  result-disp             REDEFINES result PIC S9(9) COMP.\n\n       LINKAGE SECTION.\n       01  a-int                   USAGE BINARY-LONG.\n       01  b-int                   USAGE BINARY-LONG.\n\n       PROCEDURE DIVISION USING a-int, b-int.\n           MOVE FUNCTION BOOLEAN-OF-INTEGER(a-int, 32) TO a\n           MOVE FUNCTION BOOLEAN-OF-INTEGER(b-int, 32) TO b\n\n           COMPUTE result = a B-AND b\n           DISPLAY \"a and b is \" result-disp\n\n           COMPUTE result = a B-OR b\n           DISPLAY \"a or b is \" result-disp\n\n           COMPUTE result = B-NOT a\n           DISPLAY \"Not a is \" result-disp\n\n           COMPUTE result = a B-XOR b\n           DISPLAY \"a exclusive-or b is \" result-disp\n\n           \n\n           GOBACK\n           .\n", "target": "def bitwise_built_ins(width, a, b):\n    mask = (1 << width) - 1\n    print(f)\n\ndef rotr(width, a, n):\n    \"Rotate a, n times to the right\"\n    if n < 0:\n        return rotl(width, a, -n)\n    elif n == 0:\n        return a\n    else:\n        mask = (1 << width) - 1\n        a, n = a & mask, n % width\n        return ((a >> n)    \n                | ((a & ((1 << n) - 1))   \n                   << (width - n)))  \n\ndef rotl(width, a, n):\n    \"Rotate a, n times to the left\"\n    if n < 0:\n        return rotr(width, a, -n)\n    elif n == 0:\n        return a\n    else:\n        mask = (1 << width) - 1\n        a, n = a & mask, n % width\n        return (((a << n) & mask)      \n                | (a >> (width - n)))  \n    \ndef asr(width, a, n):\n    \"Arithmetic shift a, n times to the right. (sign preserving).\"\n    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)\n    if n < 0:\n        return  (a << -n) & mask\n    elif n == 0:\n        return a\n    elif n >= width:\n        return mask if a & top_bit_mask else 0\n    else:\n        a = a & mask\n        if a & top_bit_mask:    \n            signs = (1 << n) - 1\n            return a >> n | (signs << width - n)\n        else:\n            return a >> n\n    \n      \ndef helper_funcs(width, a):\n    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)\n    aa = a | top_bit_mask  \n    print(f)\n\nif __name__ == '__main__':\n    bitwise_built_ins(8, 27, 125)\n    helper_funcs(8, 27)\n"}
{"id": 1817, "name": "Calendar", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  CALEND.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       DATA DIVISION.\n \n       WORKING-STORAGE SECTION.\n       01  WS-DAY-NAMES-DEF.\n         03 FILLER PIC X(09) VALUE 'SUNDAY   '.\n         03 FILLER PIC X(09) VALUE 'MONDAY   '.\n         03 FILLER PIC X(09) VALUE 'TUESDAY  '.\n         03 FILLER PIC X(09) VALUE 'WEDNESDAY'.\n         03 FILLER PIC X(09) VALUE 'THURSDAY '.\n         03 FILLER PIC X(09) VALUE 'FRIDAY   '.\n         03 FILLER PIC X(09) VALUE 'SATURDAY '.\n       01  FILLER REDEFINES WS-DAY-NAMES-DEF.\n         03  WS-DAY-NAME       PIC X(09) OCCURS 07 TIMES.\n \n       01  WS-MTH-INFO-DEF.\n         03 FILLER PIC X(11) VALUE 'JANUARY  31'.\n         03 FILLER PIC X(11) VALUE 'FEBRUARY 28'.\n         03 FILLER PIC X(11) VALUE 'MARCH    31'.\n         03 FILLER PIC X(11) VALUE 'APRIL    30'.\n         03 FILLER PIC X(11) VALUE 'MAY      31'.\n         03 FILLER PIC X(11) VALUE 'JUNE     30'.\n         03 FILLER PIC X(11) VALUE 'JULY     31'.\n         03 FILLER PIC X(11) VALUE 'AUGUST   31'.\n         03 FILLER PIC X(11) VALUE 'SEPTEMBER30'.\n         03 FILLER PIC X(11) VALUE 'OCTOBER  31'.\n         03 FILLER PIC X(11) VALUE 'NOVEMBER 30'.\n         03 FILLER PIC X(11) VALUE 'DECEMBER 31'.\n       01  FILLER REDEFINES WS-MTH-INFO-DEF.\n         03  WS-MTH-INFO-TABLE OCCURS 12 TIMES.\n           05  WS-MTH-INFO-NAME   PIC X(09).\n           05  WS-MTH-INFO-DAYS   PIC 9(02).\n\n       01  WS-MTH-AREA.\n         03  WS-MTH-DD         PIC S99.\n         03  WS-DAY1           PIC   9.\n         03  WS-DAYS           PIC  99.\n         03  WS-DD             PIC   9.\n         03  WS-WK             PIC   9.\n         03  WS-MM             PIC  99.\n         03  WS-QQ             PIC  99.\n \n         03  WS-MTH-MONTH  OCCURS 12 TIMES.\n           05  WS-MTH-WEEK OCCURS 6 TIMES.\n             07  WS-DAY-FLD      OCCURS 7 TIMES.\n               09  WS-DAY        PIC ZZ.\n       01  INPDATE-RECORD.\n           05  INPD-YEAR          PIC 9(04).\n           05  FILLER             PIC X(01).\n           05  INPD-MONTH         PIC 9(02).\n           05  FILLER             PIC X(01).\n           05  INPD-DAY           PIC 9(02).\n       01  WMS-DOW                PIC 9(01).\n       01  WS-PRT                 PIC X(132).\n       01  WS-COL                 PIC  9(03) VALUE 0.\n       01  WS-PP                  PIC  9(03) VALUE 0.\n       01  WS-CFGN.\n         03  FILLER               PIC  9(03) VALUE  80.\n         03  FILLER               PIC  9(02) VALUE  5.\n         03  FILLER               PIC  9(01) VALUE  1.\n         03  FILLER               PIC  9(02) VALUE  5.\n         03  FILLER               PIC  9(01) VALUE  2.\n       01  WS-CFGW.\n         03  FILLER               PIC  9(03) VALUE 120.\n         03  FILLER               PIC  9(02) VALUE 10.\n         03  FILLER               PIC  9(01) VALUE  2.\n         03  FILLER               PIC  9(02) VALUE 10.\n         03  FILLER               PIC  9(01) VALUE  3.\n       01  WS-CFG.\n         03  WS-LS                PIC  9(03) VALUE 120.\n         03  WS-LMAR              PIC  9(02) VALUE 10.\n         03  WS-SPBD              PIC  9(01) VALUE  2.\n         03  WS-SPBC              PIC  9(02) VALUE 10.\n         03  WS-DNMW              PIC  9(01) VALUE  3.\n       PROCEDURE DIVISION.\n           MOVE '1969-01-01' TO INPDATE-RECORD\n           MOVE WS-CFGN   TO WS-CFG\n           IF  (FUNCTION MOD ( INPD-YEAR , 400 ) = 0\n           OR  (FUNCTION MOD ( INPD-YEAR , 4   ) = 0\n               AND\n               FUNCTION MOD ( INPD-YEAR , 100 ) NOT = 0))\n             MOVE 29         TO WS-MTH-INFO-DAYS (02)\n           ELSE\n             MOVE 28         TO WS-MTH-INFO-DAYS (02)\n           END-IF\n \n           PERFORM VARYING WS-MM FROM 1 BY +1\n           UNTIL WS-MM > 12\n           MOVE WS-MM TO INPD-MONTH\n           CALL 'DATE2DOW' USING INPDATE-RECORD, WMS-DOW\n           COMPUTE WS-MTH-DD = 1 - WMS-DOW\n           COMPUTE WS-DAYS = WS-MTH-INFO-DAYS (INPD-MONTH)\n           PERFORM VARYING WS-WK FROM 1 BY +1\n           UNTIL WS-WK > 6\n             PERFORM VARYING WS-DD FROM 1 BY +1\n             UNTIL WS-DD > 7\n               COMPUTE WS-MTH-DD = WS-MTH-DD + 1\n               IF (WS-MTH-DD < 1)\n               OR (WS-MTH-DD > WS-DAYS)\n                 MOVE 0         TO WS-DAY (WS-MM, WS-WK, WS-DD)\n               ELSE\n                 MOVE WS-MTH-DD TO WS-DAY (WS-MM, WS-WK, WS-DD)\n               END-IF\n             END-PERFORM\n           END-PERFORM\n           END-PERFORM\n \n           COMPUTE WS-MM = 0\n           PERFORM VARYING WS-QQ FROM 1 BY +1\n           UNTIL WS-QQ > 4\n \n             INITIALIZE WS-PRT\n             COMPUTE WS-PP = 1\n             PERFORM VARYING WS-COL FROM 1 BY +1\n             UNTIL WS-COL > 3\n             COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n               IF WS-COL = 1\n                 COMPUTE WS-PP = WS-PP + WS-LMAR + 2 - WS-DNMW\n               ELSE\n                 COMPUTE WS-PP = WS-PP + WS-SPBC + 2 - WS-DNMW\n               END-IF\n               MOVE WS-MTH-INFO-NAME (WS-MM)\n                             TO WS-PRT(WS-PP:9)\n               COMPUTE WS-PP\n               =       WS-PP + ( 2 * 7 + WS-SPBD * 6 + WS-SPBD - 1)\n               -       4\n               MOVE INPD-YEAR TO WS-PRT (WS-PP:4)\n               COMPUTE WS-PP = WS-PP + 4\n             END-PERFORM\n             DISPLAY WS-PRT (1:WS-LS)\n \n             INITIALIZE WS-PRT\n             COMPUTE WS-PP = 1\n             PERFORM VARYING WS-COL FROM 1 BY +1\n             UNTIL WS-COL > 3\n             COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n               IF WS-COL = 1\n                 COMPUTE WS-PP = WS-PP + WS-LMAR + 2 - WS-DNMW\n               ELSE\n                 COMPUTE WS-PP = WS-PP + WS-SPBC + 2 - WS-DNMW\n               END-IF\n               PERFORM VARYING WS-DD FROM 1 BY +1\n               UNTIL WS-DD > 7\n                 IF WS-DD > 1\n                   COMPUTE WS-PP = WS-PP + WS-SPBD + 2 - WS-DNMW\n                 END-IF\n                 MOVE WS-DAY-NAME (WS-DD) (1:WS-DNMW)\n                             TO WS-PRT (WS-PP:WS-DNMW)\n                 COMPUTE WS-PP = WS-PP + WS-DNMW\n               END-PERFORM\n             END-PERFORM\n             DISPLAY WS-PRT (1:WS-LS)\n \n             PERFORM VARYING WS-WK FROM 1 BY +1\n             UNTIL WS-WK > 6\n               INITIALIZE WS-PRT\n               COMPUTE WS-PP = 1\n               PERFORM VARYING WS-COL FROM 1 BY +1\n               UNTIL WS-COL > 3\n               COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n                 IF WS-COL = 1\n                   COMPUTE WS-PP = WS-PP + WS-LMAR\n                 ELSE\n                   COMPUTE WS-PP = WS-PP + WS-SPBC\n                 END-IF\n                 PERFORM VARYING WS-DD FROM 1 BY +1\n                 UNTIL WS-DD > 7\n                   IF WS-DD > 1\n                     COMPUTE WS-PP = WS-PP + WS-SPBD\n                   END-IF\n                   MOVE WS-DAY (WS-MM, WS-WK, WS-DD)\n                               TO WS-PRT (WS-PP:2)\n                   COMPUTE WS-PP = WS-PP + 2\n                 END-PERFORM\n               END-PERFORM\n               DISPLAY WS-PRT (1:WS-LS)\n             END-PERFORM\n             DISPLAY ' '\n           END-PERFORM\n           GOBACK\n           .\n       END PROGRAM CALEND.\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  DATE2DOW.\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  WMS-WORK-AREA.\n         03  WMS-YEAR       PIC 9(04).\n         03  WMS-MONTH      PIC 9(02).\n         03  WMS-CSYS       PIC 9(01) VALUE 1.\n         03  WMS-SUM        pic 9(04).\n       LINKAGE SECTION.\n       01  INPDATE-RECORD.\n           05  INPD-YEAR          PIC 9(04).\n           05  FILLER             PIC X(01).\n           05  INPD-MONTH         PIC 9(02).\n           05  FILLER             PIC X(01).\n           05  INPD-DAY           PIC 9(02).\n       01  WMS-DOW                PIC 9(01).\n       PROCEDURE DIVISION USING INPDATE-RECORD, WMS-DOW.\n       1010-CONVERT-DATE-TO-DOW.\n           IF INPD-MONTH < 3\n               COMPUTE WMS-MONTH = INPD-MONTH + 12\n               COMPUTE WMS-YEAR  = INPD-YEAR - 1\n           ELSE\n               COMPUTE WMS-MONTH = INPD-MONTH\n               COMPUTE WMS-YEAR  = INPD-YEAR\n           END-IF\n           COMPUTE WMS-SUM  = \n                            ( INPD-DAY + 2 * WMS-MONTH + WMS-YEAR\n                            + FUNCTION INTEGER (6 * (WMS-MONTH + 1) / 10)\n                            + FUNCTION INTEGER ( WMS-YEAR / 4   )\n                            - FUNCTION INTEGER ( WMS-YEAR / 100 )\n                            + FUNCTION INTEGER ( WMS-YEAR / 400 )\n                            + WMS-CSYS )\n           COMPUTE WMS-DOW = FUNCTION MOD (WMS-SUM, 7) + 1\n           GOBACK\n           .\n       END PROGRAM DATE2DOW.\n", "target": "using System;\nusing System.Collections.Generic; \nusing System.Linq;\nusing System.Text;\n\nnamespace CalendarStuff\n{\n \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WindowHeight = 46;\n            Console.Write(buildMonths(new DateTime(1969, 1, 1)));\n            Console.Read(); \n        }\n        private static string buildMonths(DateTime date)\n        {\n            StringBuilder sb = new StringBuilder();\n            sb.AppendLine(center(\"[Snoop]\", 24 * 3));\n            sb.AppendLine();\n            sb.AppendLine(center(date.Year.ToString(), 24 * 3));\n\n            List<DateTime> dts = new List<DateTime>();\n            while (true)\n            {\n                dts.Add(date);\n                if (date.Year != ((date = date.AddMonths(1)).Year))\n                {\n                    break;\n                }\n            }\n            var jd = dts.Select(a => buildMonth(a).GetEnumerator()).ToArray();\n            \n            int sCur=0;\n            while (sCur<dts.Count)\n            {\n                sb.AppendLine();\n                int curMonth=0; \n                var j = jd.Where(a => curMonth++ >= sCur && curMonth - 1 < sCur + 3).ToArray(); \n                sCur += j.Length; \n                bool breakOut = false;\n                while (!breakOut)\n                {\n                    int inj = 1;\n                    foreach (var cd in j)\n                    {\n                        if (cd.MoveNext())\n                        {\n                            sb.Append((cd.Current.Length == 21 ? cd.Current : cd.Current.PadRight(21, ' ')) + \"     \");\n                        }\n                        else\n                        {\n                            sb.Append(\"\".PadRight(21, ' ') + \"     \");\n                            breakOut = true;\n                        }\n                        if (inj++ % 3 == 0) sb.AppendLine();\n                    }\n                }\n\n            }\n            return sb.ToString();\n        }\n\n\n        private static IEnumerable<string> buildMonth(DateTime date)\n        {\n            yield return center(date.ToString(\"MMMM\"),7*3);\n            var j = DateTime.DaysInMonth(date.Year, date.Month);\n            yield return Enum.GetNames(typeof(DayOfWeek)).Aggregate(\"\", (current, result) => current + (result.Substring(0, 2).ToUpper() + \" \"));\n            string cur = \"\";\n            int total = 0;\n\n            foreach (var day in Enumerable.Range(-((int)date.DayOfWeek),j + (int)date.DayOfWeek))\n            {\n                cur += (day < 0 ? \"  \" : ((day < 9 ? \" \" : \"\") + (day + 1))) +\" \";\n                if (total++ > 0 && (total ) % 7 == 0)\n                {\n                    yield return cur;\n                    cur = \"\";\n                }\n            }\n            yield return cur;\n        }\n        private static string center(string s, int len)\n        {\n            return (s.PadLeft((len - s.Length) / 2 + s.Length, ' ').PadRight((len), ' '));\n        } \n    }\n}\n"}
{"id": 1818, "name": "Calendar", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  CALEND.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       DATA DIVISION.\n \n       WORKING-STORAGE SECTION.\n       01  WS-DAY-NAMES-DEF.\n         03 FILLER PIC X(09) VALUE 'SUNDAY   '.\n         03 FILLER PIC X(09) VALUE 'MONDAY   '.\n         03 FILLER PIC X(09) VALUE 'TUESDAY  '.\n         03 FILLER PIC X(09) VALUE 'WEDNESDAY'.\n         03 FILLER PIC X(09) VALUE 'THURSDAY '.\n         03 FILLER PIC X(09) VALUE 'FRIDAY   '.\n         03 FILLER PIC X(09) VALUE 'SATURDAY '.\n       01  FILLER REDEFINES WS-DAY-NAMES-DEF.\n         03  WS-DAY-NAME       PIC X(09) OCCURS 07 TIMES.\n \n       01  WS-MTH-INFO-DEF.\n         03 FILLER PIC X(11) VALUE 'JANUARY  31'.\n         03 FILLER PIC X(11) VALUE 'FEBRUARY 28'.\n         03 FILLER PIC X(11) VALUE 'MARCH    31'.\n         03 FILLER PIC X(11) VALUE 'APRIL    30'.\n         03 FILLER PIC X(11) VALUE 'MAY      31'.\n         03 FILLER PIC X(11) VALUE 'JUNE     30'.\n         03 FILLER PIC X(11) VALUE 'JULY     31'.\n         03 FILLER PIC X(11) VALUE 'AUGUST   31'.\n         03 FILLER PIC X(11) VALUE 'SEPTEMBER30'.\n         03 FILLER PIC X(11) VALUE 'OCTOBER  31'.\n         03 FILLER PIC X(11) VALUE 'NOVEMBER 30'.\n         03 FILLER PIC X(11) VALUE 'DECEMBER 31'.\n       01  FILLER REDEFINES WS-MTH-INFO-DEF.\n         03  WS-MTH-INFO-TABLE OCCURS 12 TIMES.\n           05  WS-MTH-INFO-NAME   PIC X(09).\n           05  WS-MTH-INFO-DAYS   PIC 9(02).\n\n       01  WS-MTH-AREA.\n         03  WS-MTH-DD         PIC S99.\n         03  WS-DAY1           PIC   9.\n         03  WS-DAYS           PIC  99.\n         03  WS-DD             PIC   9.\n         03  WS-WK             PIC   9.\n         03  WS-MM             PIC  99.\n         03  WS-QQ             PIC  99.\n \n         03  WS-MTH-MONTH  OCCURS 12 TIMES.\n           05  WS-MTH-WEEK OCCURS 6 TIMES.\n             07  WS-DAY-FLD      OCCURS 7 TIMES.\n               09  WS-DAY        PIC ZZ.\n       01  INPDATE-RECORD.\n           05  INPD-YEAR          PIC 9(04).\n           05  FILLER             PIC X(01).\n           05  INPD-MONTH         PIC 9(02).\n           05  FILLER             PIC X(01).\n           05  INPD-DAY           PIC 9(02).\n       01  WMS-DOW                PIC 9(01).\n       01  WS-PRT                 PIC X(132).\n       01  WS-COL                 PIC  9(03) VALUE 0.\n       01  WS-PP                  PIC  9(03) VALUE 0.\n       01  WS-CFGN.\n         03  FILLER               PIC  9(03) VALUE  80.\n         03  FILLER               PIC  9(02) VALUE  5.\n         03  FILLER               PIC  9(01) VALUE  1.\n         03  FILLER               PIC  9(02) VALUE  5.\n         03  FILLER               PIC  9(01) VALUE  2.\n       01  WS-CFGW.\n         03  FILLER               PIC  9(03) VALUE 120.\n         03  FILLER               PIC  9(02) VALUE 10.\n         03  FILLER               PIC  9(01) VALUE  2.\n         03  FILLER               PIC  9(02) VALUE 10.\n         03  FILLER               PIC  9(01) VALUE  3.\n       01  WS-CFG.\n         03  WS-LS                PIC  9(03) VALUE 120.\n         03  WS-LMAR              PIC  9(02) VALUE 10.\n         03  WS-SPBD              PIC  9(01) VALUE  2.\n         03  WS-SPBC              PIC  9(02) VALUE 10.\n         03  WS-DNMW              PIC  9(01) VALUE  3.\n       PROCEDURE DIVISION.\n           MOVE '1969-01-01' TO INPDATE-RECORD\n           MOVE WS-CFGN   TO WS-CFG\n           IF  (FUNCTION MOD ( INPD-YEAR , 400 ) = 0\n           OR  (FUNCTION MOD ( INPD-YEAR , 4   ) = 0\n               AND\n               FUNCTION MOD ( INPD-YEAR , 100 ) NOT = 0))\n             MOVE 29         TO WS-MTH-INFO-DAYS (02)\n           ELSE\n             MOVE 28         TO WS-MTH-INFO-DAYS (02)\n           END-IF\n \n           PERFORM VARYING WS-MM FROM 1 BY +1\n           UNTIL WS-MM > 12\n           MOVE WS-MM TO INPD-MONTH\n           CALL 'DATE2DOW' USING INPDATE-RECORD, WMS-DOW\n           COMPUTE WS-MTH-DD = 1 - WMS-DOW\n           COMPUTE WS-DAYS = WS-MTH-INFO-DAYS (INPD-MONTH)\n           PERFORM VARYING WS-WK FROM 1 BY +1\n           UNTIL WS-WK > 6\n             PERFORM VARYING WS-DD FROM 1 BY +1\n             UNTIL WS-DD > 7\n               COMPUTE WS-MTH-DD = WS-MTH-DD + 1\n               IF (WS-MTH-DD < 1)\n               OR (WS-MTH-DD > WS-DAYS)\n                 MOVE 0         TO WS-DAY (WS-MM, WS-WK, WS-DD)\n               ELSE\n                 MOVE WS-MTH-DD TO WS-DAY (WS-MM, WS-WK, WS-DD)\n               END-IF\n             END-PERFORM\n           END-PERFORM\n           END-PERFORM\n \n           COMPUTE WS-MM = 0\n           PERFORM VARYING WS-QQ FROM 1 BY +1\n           UNTIL WS-QQ > 4\n \n             INITIALIZE WS-PRT\n             COMPUTE WS-PP = 1\n             PERFORM VARYING WS-COL FROM 1 BY +1\n             UNTIL WS-COL > 3\n             COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n               IF WS-COL = 1\n                 COMPUTE WS-PP = WS-PP + WS-LMAR + 2 - WS-DNMW\n               ELSE\n                 COMPUTE WS-PP = WS-PP + WS-SPBC + 2 - WS-DNMW\n               END-IF\n               MOVE WS-MTH-INFO-NAME (WS-MM)\n                             TO WS-PRT(WS-PP:9)\n               COMPUTE WS-PP\n               =       WS-PP + ( 2 * 7 + WS-SPBD * 6 + WS-SPBD - 1)\n               -       4\n               MOVE INPD-YEAR TO WS-PRT (WS-PP:4)\n               COMPUTE WS-PP = WS-PP + 4\n             END-PERFORM\n             DISPLAY WS-PRT (1:WS-LS)\n \n             INITIALIZE WS-PRT\n             COMPUTE WS-PP = 1\n             PERFORM VARYING WS-COL FROM 1 BY +1\n             UNTIL WS-COL > 3\n             COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n               IF WS-COL = 1\n                 COMPUTE WS-PP = WS-PP + WS-LMAR + 2 - WS-DNMW\n               ELSE\n                 COMPUTE WS-PP = WS-PP + WS-SPBC + 2 - WS-DNMW\n               END-IF\n               PERFORM VARYING WS-DD FROM 1 BY +1\n               UNTIL WS-DD > 7\n                 IF WS-DD > 1\n                   COMPUTE WS-PP = WS-PP + WS-SPBD + 2 - WS-DNMW\n                 END-IF\n                 MOVE WS-DAY-NAME (WS-DD) (1:WS-DNMW)\n                             TO WS-PRT (WS-PP:WS-DNMW)\n                 COMPUTE WS-PP = WS-PP + WS-DNMW\n               END-PERFORM\n             END-PERFORM\n             DISPLAY WS-PRT (1:WS-LS)\n \n             PERFORM VARYING WS-WK FROM 1 BY +1\n             UNTIL WS-WK > 6\n               INITIALIZE WS-PRT\n               COMPUTE WS-PP = 1\n               PERFORM VARYING WS-COL FROM 1 BY +1\n               UNTIL WS-COL > 3\n               COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n                 IF WS-COL = 1\n                   COMPUTE WS-PP = WS-PP + WS-LMAR\n                 ELSE\n                   COMPUTE WS-PP = WS-PP + WS-SPBC\n                 END-IF\n                 PERFORM VARYING WS-DD FROM 1 BY +1\n                 UNTIL WS-DD > 7\n                   IF WS-DD > 1\n                     COMPUTE WS-PP = WS-PP + WS-SPBD\n                   END-IF\n                   MOVE WS-DAY (WS-MM, WS-WK, WS-DD)\n                               TO WS-PRT (WS-PP:2)\n                   COMPUTE WS-PP = WS-PP + 2\n                 END-PERFORM\n               END-PERFORM\n               DISPLAY WS-PRT (1:WS-LS)\n             END-PERFORM\n             DISPLAY ' '\n           END-PERFORM\n           GOBACK\n           .\n       END PROGRAM CALEND.\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  DATE2DOW.\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  WMS-WORK-AREA.\n         03  WMS-YEAR       PIC 9(04).\n         03  WMS-MONTH      PIC 9(02).\n         03  WMS-CSYS       PIC 9(01) VALUE 1.\n         03  WMS-SUM        pic 9(04).\n       LINKAGE SECTION.\n       01  INPDATE-RECORD.\n           05  INPD-YEAR          PIC 9(04).\n           05  FILLER             PIC X(01).\n           05  INPD-MONTH         PIC 9(02).\n           05  FILLER             PIC X(01).\n           05  INPD-DAY           PIC 9(02).\n       01  WMS-DOW                PIC 9(01).\n       PROCEDURE DIVISION USING INPDATE-RECORD, WMS-DOW.\n       1010-CONVERT-DATE-TO-DOW.\n           IF INPD-MONTH < 3\n               COMPUTE WMS-MONTH = INPD-MONTH + 12\n               COMPUTE WMS-YEAR  = INPD-YEAR - 1\n           ELSE\n               COMPUTE WMS-MONTH = INPD-MONTH\n               COMPUTE WMS-YEAR  = INPD-YEAR\n           END-IF\n           COMPUTE WMS-SUM  = \n                            ( INPD-DAY + 2 * WMS-MONTH + WMS-YEAR\n                            + FUNCTION INTEGER (6 * (WMS-MONTH + 1) / 10)\n                            + FUNCTION INTEGER ( WMS-YEAR / 4   )\n                            - FUNCTION INTEGER ( WMS-YEAR / 100 )\n                            + FUNCTION INTEGER ( WMS-YEAR / 400 )\n                            + WMS-CSYS )\n           COMPUTE WMS-DOW = FUNCTION MOD (WMS-SUM, 7) + 1\n           GOBACK\n           .\n       END PROGRAM DATE2DOW.\n", "target": "import java.text.*;\nimport java.util.*;\n\npublic class CalendarTask {\n\n    public static void main(String[] args) {\n        printCalendar(1969, 3);\n    }\n\n    static void printCalendar(int year, int nCols) {\n        if (nCols < 1 || nCols > 12)\n            throw new IllegalArgumentException(\"Illegal column width.\");\n\n        Calendar date = new GregorianCalendar(year, 0, 1);\n\n        int nRows = (int) Math.ceil(12.0 / nCols);\n        int offs = date.get(Calendar.DAY_OF_WEEK) - 1;\n        int w = nCols * 24;\n\n        String[] monthNames = new DateFormatSymbols(Locale.US).getMonths();\n\n        String[][] mons = new String[12][8];\n        for (int m = 0; m < 12; m++) {\n\n            String name = monthNames[m];\n            int len = 11 + name.length() / 2;\n            String format = MessageFormat.format(\"%{0}s%{1}s\", len, 21 - len);\n\n            mons[m][0] = String.format(format, name, \"\");\n            mons[m][1] = \" Su Mo Tu We Th Fr Sa\";\n            int dim = date.getActualMaximum(Calendar.DAY_OF_MONTH);\n\n            for (int d = 1; d < 43; d++) {\n                boolean isDay = d > offs && d <= offs + dim;\n                String entry = isDay ? String.format(\" %2s\", d - offs) : \"   \";\n                if (d % 7 == 1)\n                    mons[m][2 + (d - 1) / 7] = entry;\n                else\n                    mons[m][2 + (d - 1) / 7] += entry;\n            }\n            offs = (offs + dim) % 7;\n            date.add(Calendar.MONTH, 1);\n        }\n\n        System.out.printf(\"%\" + (w / 2 + 10) + \"s%n\", \"[Snoopy Picture]\");\n        System.out.printf(\"%\" + (w / 2 + 4) + \"s%n%n\", year);\n\n        for (int r = 0; r < nRows; r++) {\n            for (int i = 0; i < 8; i++) {\n                for (int c = r * nCols; c < (r + 1) * nCols && c < 12; c++)\n                    System.out.printf(\"   %s\", mons[c][i]);\n                System.out.println();\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 1819, "name": "Calendar", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  CALEND.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       DATA DIVISION.\n \n       WORKING-STORAGE SECTION.\n       01  WS-DAY-NAMES-DEF.\n         03 FILLER PIC X(09) VALUE 'SUNDAY   '.\n         03 FILLER PIC X(09) VALUE 'MONDAY   '.\n         03 FILLER PIC X(09) VALUE 'TUESDAY  '.\n         03 FILLER PIC X(09) VALUE 'WEDNESDAY'.\n         03 FILLER PIC X(09) VALUE 'THURSDAY '.\n         03 FILLER PIC X(09) VALUE 'FRIDAY   '.\n         03 FILLER PIC X(09) VALUE 'SATURDAY '.\n       01  FILLER REDEFINES WS-DAY-NAMES-DEF.\n         03  WS-DAY-NAME       PIC X(09) OCCURS 07 TIMES.\n \n       01  WS-MTH-INFO-DEF.\n         03 FILLER PIC X(11) VALUE 'JANUARY  31'.\n         03 FILLER PIC X(11) VALUE 'FEBRUARY 28'.\n         03 FILLER PIC X(11) VALUE 'MARCH    31'.\n         03 FILLER PIC X(11) VALUE 'APRIL    30'.\n         03 FILLER PIC X(11) VALUE 'MAY      31'.\n         03 FILLER PIC X(11) VALUE 'JUNE     30'.\n         03 FILLER PIC X(11) VALUE 'JULY     31'.\n         03 FILLER PIC X(11) VALUE 'AUGUST   31'.\n         03 FILLER PIC X(11) VALUE 'SEPTEMBER30'.\n         03 FILLER PIC X(11) VALUE 'OCTOBER  31'.\n         03 FILLER PIC X(11) VALUE 'NOVEMBER 30'.\n         03 FILLER PIC X(11) VALUE 'DECEMBER 31'.\n       01  FILLER REDEFINES WS-MTH-INFO-DEF.\n         03  WS-MTH-INFO-TABLE OCCURS 12 TIMES.\n           05  WS-MTH-INFO-NAME   PIC X(09).\n           05  WS-MTH-INFO-DAYS   PIC 9(02).\n\n       01  WS-MTH-AREA.\n         03  WS-MTH-DD         PIC S99.\n         03  WS-DAY1           PIC   9.\n         03  WS-DAYS           PIC  99.\n         03  WS-DD             PIC   9.\n         03  WS-WK             PIC   9.\n         03  WS-MM             PIC  99.\n         03  WS-QQ             PIC  99.\n \n         03  WS-MTH-MONTH  OCCURS 12 TIMES.\n           05  WS-MTH-WEEK OCCURS 6 TIMES.\n             07  WS-DAY-FLD      OCCURS 7 TIMES.\n               09  WS-DAY        PIC ZZ.\n       01  INPDATE-RECORD.\n           05  INPD-YEAR          PIC 9(04).\n           05  FILLER             PIC X(01).\n           05  INPD-MONTH         PIC 9(02).\n           05  FILLER             PIC X(01).\n           05  INPD-DAY           PIC 9(02).\n       01  WMS-DOW                PIC 9(01).\n       01  WS-PRT                 PIC X(132).\n       01  WS-COL                 PIC  9(03) VALUE 0.\n       01  WS-PP                  PIC  9(03) VALUE 0.\n       01  WS-CFGN.\n         03  FILLER               PIC  9(03) VALUE  80.\n         03  FILLER               PIC  9(02) VALUE  5.\n         03  FILLER               PIC  9(01) VALUE  1.\n         03  FILLER               PIC  9(02) VALUE  5.\n         03  FILLER               PIC  9(01) VALUE  2.\n       01  WS-CFGW.\n         03  FILLER               PIC  9(03) VALUE 120.\n         03  FILLER               PIC  9(02) VALUE 10.\n         03  FILLER               PIC  9(01) VALUE  2.\n         03  FILLER               PIC  9(02) VALUE 10.\n         03  FILLER               PIC  9(01) VALUE  3.\n       01  WS-CFG.\n         03  WS-LS                PIC  9(03) VALUE 120.\n         03  WS-LMAR              PIC  9(02) VALUE 10.\n         03  WS-SPBD              PIC  9(01) VALUE  2.\n         03  WS-SPBC              PIC  9(02) VALUE 10.\n         03  WS-DNMW              PIC  9(01) VALUE  3.\n       PROCEDURE DIVISION.\n           MOVE '1969-01-01' TO INPDATE-RECORD\n           MOVE WS-CFGN   TO WS-CFG\n           IF  (FUNCTION MOD ( INPD-YEAR , 400 ) = 0\n           OR  (FUNCTION MOD ( INPD-YEAR , 4   ) = 0\n               AND\n               FUNCTION MOD ( INPD-YEAR , 100 ) NOT = 0))\n             MOVE 29         TO WS-MTH-INFO-DAYS (02)\n           ELSE\n             MOVE 28         TO WS-MTH-INFO-DAYS (02)\n           END-IF\n \n           PERFORM VARYING WS-MM FROM 1 BY +1\n           UNTIL WS-MM > 12\n           MOVE WS-MM TO INPD-MONTH\n           CALL 'DATE2DOW' USING INPDATE-RECORD, WMS-DOW\n           COMPUTE WS-MTH-DD = 1 - WMS-DOW\n           COMPUTE WS-DAYS = WS-MTH-INFO-DAYS (INPD-MONTH)\n           PERFORM VARYING WS-WK FROM 1 BY +1\n           UNTIL WS-WK > 6\n             PERFORM VARYING WS-DD FROM 1 BY +1\n             UNTIL WS-DD > 7\n               COMPUTE WS-MTH-DD = WS-MTH-DD + 1\n               IF (WS-MTH-DD < 1)\n               OR (WS-MTH-DD > WS-DAYS)\n                 MOVE 0         TO WS-DAY (WS-MM, WS-WK, WS-DD)\n               ELSE\n                 MOVE WS-MTH-DD TO WS-DAY (WS-MM, WS-WK, WS-DD)\n               END-IF\n             END-PERFORM\n           END-PERFORM\n           END-PERFORM\n \n           COMPUTE WS-MM = 0\n           PERFORM VARYING WS-QQ FROM 1 BY +1\n           UNTIL WS-QQ > 4\n \n             INITIALIZE WS-PRT\n             COMPUTE WS-PP = 1\n             PERFORM VARYING WS-COL FROM 1 BY +1\n             UNTIL WS-COL > 3\n             COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n               IF WS-COL = 1\n                 COMPUTE WS-PP = WS-PP + WS-LMAR + 2 - WS-DNMW\n               ELSE\n                 COMPUTE WS-PP = WS-PP + WS-SPBC + 2 - WS-DNMW\n               END-IF\n               MOVE WS-MTH-INFO-NAME (WS-MM)\n                             TO WS-PRT(WS-PP:9)\n               COMPUTE WS-PP\n               =       WS-PP + ( 2 * 7 + WS-SPBD * 6 + WS-SPBD - 1)\n               -       4\n               MOVE INPD-YEAR TO WS-PRT (WS-PP:4)\n               COMPUTE WS-PP = WS-PP + 4\n             END-PERFORM\n             DISPLAY WS-PRT (1:WS-LS)\n \n             INITIALIZE WS-PRT\n             COMPUTE WS-PP = 1\n             PERFORM VARYING WS-COL FROM 1 BY +1\n             UNTIL WS-COL > 3\n             COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n               IF WS-COL = 1\n                 COMPUTE WS-PP = WS-PP + WS-LMAR + 2 - WS-DNMW\n               ELSE\n                 COMPUTE WS-PP = WS-PP + WS-SPBC + 2 - WS-DNMW\n               END-IF\n               PERFORM VARYING WS-DD FROM 1 BY +1\n               UNTIL WS-DD > 7\n                 IF WS-DD > 1\n                   COMPUTE WS-PP = WS-PP + WS-SPBD + 2 - WS-DNMW\n                 END-IF\n                 MOVE WS-DAY-NAME (WS-DD) (1:WS-DNMW)\n                             TO WS-PRT (WS-PP:WS-DNMW)\n                 COMPUTE WS-PP = WS-PP + WS-DNMW\n               END-PERFORM\n             END-PERFORM\n             DISPLAY WS-PRT (1:WS-LS)\n \n             PERFORM VARYING WS-WK FROM 1 BY +1\n             UNTIL WS-WK > 6\n               INITIALIZE WS-PRT\n               COMPUTE WS-PP = 1\n               PERFORM VARYING WS-COL FROM 1 BY +1\n               UNTIL WS-COL > 3\n               COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n                 IF WS-COL = 1\n                   COMPUTE WS-PP = WS-PP + WS-LMAR\n                 ELSE\n                   COMPUTE WS-PP = WS-PP + WS-SPBC\n                 END-IF\n                 PERFORM VARYING WS-DD FROM 1 BY +1\n                 UNTIL WS-DD > 7\n                   IF WS-DD > 1\n                     COMPUTE WS-PP = WS-PP + WS-SPBD\n                   END-IF\n                   MOVE WS-DAY (WS-MM, WS-WK, WS-DD)\n                               TO WS-PRT (WS-PP:2)\n                   COMPUTE WS-PP = WS-PP + 2\n                 END-PERFORM\n               END-PERFORM\n               DISPLAY WS-PRT (1:WS-LS)\n             END-PERFORM\n             DISPLAY ' '\n           END-PERFORM\n           GOBACK\n           .\n       END PROGRAM CALEND.\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  DATE2DOW.\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  WMS-WORK-AREA.\n         03  WMS-YEAR       PIC 9(04).\n         03  WMS-MONTH      PIC 9(02).\n         03  WMS-CSYS       PIC 9(01) VALUE 1.\n         03  WMS-SUM        pic 9(04).\n       LINKAGE SECTION.\n       01  INPDATE-RECORD.\n           05  INPD-YEAR          PIC 9(04).\n           05  FILLER             PIC X(01).\n           05  INPD-MONTH         PIC 9(02).\n           05  FILLER             PIC X(01).\n           05  INPD-DAY           PIC 9(02).\n       01  WMS-DOW                PIC 9(01).\n       PROCEDURE DIVISION USING INPDATE-RECORD, WMS-DOW.\n       1010-CONVERT-DATE-TO-DOW.\n           IF INPD-MONTH < 3\n               COMPUTE WMS-MONTH = INPD-MONTH + 12\n               COMPUTE WMS-YEAR  = INPD-YEAR - 1\n           ELSE\n               COMPUTE WMS-MONTH = INPD-MONTH\n               COMPUTE WMS-YEAR  = INPD-YEAR\n           END-IF\n           COMPUTE WMS-SUM  = \n                            ( INPD-DAY + 2 * WMS-MONTH + WMS-YEAR\n                            + FUNCTION INTEGER (6 * (WMS-MONTH + 1) / 10)\n                            + FUNCTION INTEGER ( WMS-YEAR / 4   )\n                            - FUNCTION INTEGER ( WMS-YEAR / 100 )\n                            + FUNCTION INTEGER ( WMS-YEAR / 400 )\n                            + WMS-CSYS )\n           COMPUTE WMS-DOW = FUNCTION MOD (WMS-SUM, 7) + 1\n           GOBACK\n           .\n       END PROGRAM DATE2DOW.\n", "target": ">>> import calendar\n>>> help(calendar.prcal)\nHelp on method pryear in module calendar:\n\npryear(self, theyear, w=0, l=0, c=6, m=3) method of calendar.TextCalendar instance\n    Print a years calendar.\n\n>>> calendar.prcal(1969)\n                                  1969\n\n      January                   February                   March\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n       1  2  3  4  5                      1  2                      1  2\n 6  7  8  9 10 11 12       3  4  5  6  7  8  9       3  4  5  6  7  8  9\n13 14 15 16 17 18 19      10 11 12 13 14 15 16      10 11 12 13 14 15 16\n20 21 22 23 24 25 26      17 18 19 20 21 22 23      17 18 19 20 21 22 23\n27 28 29 30 31            24 25 26 27 28            24 25 26 27 28 29 30\n                                                    31\n\n       April                      May                       June\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n    1  2  3  4  5  6                1  2  3  4                         1\n 7  8  9 10 11 12 13       5  6  7  8  9 10 11       2  3  4  5  6  7  8\n14 15 16 17 18 19 20      12 13 14 15 16 17 18       9 10 11 12 13 14 15\n21 22 23 24 25 26 27      19 20 21 22 23 24 25      16 17 18 19 20 21 22\n28 29 30                  26 27 28 29 30 31         23 24 25 26 27 28 29\n                                                    30\n\n        July                     August                  September\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n    1  2  3  4  5  6                   1  2  3       1  2  3  4  5  6  7\n 7  8  9 10 11 12 13       4  5  6  7  8  9 10       8  9 10 11 12 13 14\n14 15 16 17 18 19 20      11 12 13 14 15 16 17      15 16 17 18 19 20 21\n21 22 23 24 25 26 27      18 19 20 21 22 23 24      22 23 24 25 26 27 28\n28 29 30 31               25 26 27 28 29 30 31      29 30\n\n      October                   November                  December\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n       1  2  3  4  5                      1  2       1  2  3  4  5  6  7\n 6  7  8  9 10 11 12       3  4  5  6  7  8  9       8  9 10 11 12 13 14\n13 14 15 16 17 18 19      10 11 12 13 14 15 16      15 16 17 18 19 20 21\n20 21 22 23 24 25 26      17 18 19 20 21 22 23      22 23 24 25 26 27 28\n27 28 29 30 31            24 25 26 27 28 29 30      29 30 31\n"}
{"id": 2240, "name": "String interpolation (included)", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. interpolation-included.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  extra PIC X(6) VALUE \"little\".\n\n       PROCEDURE DIVISION.\n           DISPLAY FUNCTION SUBSTITUTE(\"Mary had a X lamb.\", \"X\", extra)\n\n           GOBACK\n           .\n", "target": "class Program\n{\n    static void Main()\n    {\n        string extra = \"little\";\n        string formatted = $\"Mary had a {extra} lamb.\";\n        System.Console.WriteLine(formatted);\n    }\n}\n"}
{"id": 2242, "name": "String interpolation (included)", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. interpolation-included.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  extra PIC X(6) VALUE \"little\".\n\n       PROCEDURE DIVISION.\n           DISPLAY FUNCTION SUBSTITUTE(\"Mary had a X lamb.\", \"X\", extra)\n\n           GOBACK\n           .\n", "target": "String original = \"Mary had a X lamb\";\nString little = \"little\";\nString replaced = original.replace(\"X\", little); \nSystem.out.println(replaced);\n\nSystem.out.printf(\"Mary had a %s lamb.\", little);\n\nString formatted = String.format(\"Mary had a %s lamb.\", little);\nSystem.out.println(formatted);\n"}
{"id": 2243, "name": "String interpolation (included)", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. interpolation-included.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  extra PIC X(6) VALUE \"little\".\n\n       PROCEDURE DIVISION.\n           DISPLAY FUNCTION SUBSTITUTE(\"Mary had a X lamb.\", \"X\", extra)\n\n           GOBACK\n           .\n", "target": ">>> original = 'Mary had a %s lamb.'\n>>> extra = 'little'\n>>> original % extra\n'Mary had a little lamb.'\n"}
{"id": 2683, "name": "Babbage problem", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. BABBAGE-PROGRAM.\n* A line beginning with an asterisk is an explanatory note.\n* The machine will disregard any such line.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n* In this part of the program we reserve the storage space we shall\n* be using for our variables, using a 'PICTURE' clause to specify\n* how many digits the machine is to keep free.\n* The prefixed number 77 indicates that these variables do not form part\n* of any larger 'record' that we might want to deal with as a whole.\n77  N           PICTURE 99999.\n* We know that 99,736 is a valid answer.\n77  N-SQUARED   PICTURE 9999999999.\n77  LAST-SIX    PICTURE 999999.\nPROCEDURE DIVISION.\n* Here we specify the calculations that the machine is to carry out.\nCONTROL-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING N FROM 1 BY 1\n    UNTIL LAST-SIX IS EQUAL TO 269696.\n    STOP RUN.\nCOMPUTATION-PARAGRAPH.\n    MULTIPLY N BY N GIVING N-SQUARED.\n    MOVE N-SQUARED TO LAST-SIX.\n* Since the variable LAST-SIX can hold a maximum of six digits,\n* only the final six digits of N-SQUARED will be moved into it:\n* the rest will not fit and will simply be discarded.\n    IF LAST-SIX IS EQUAL TO 269696 THEN DISPLAY N.\n", "target": "namespace Babbage_Problem\n{\n    class iterateNumbers\n    {\n        public iterateNumbers()\n        {\n            long baseNumberSquared = 0; \n            long baseNumber = 0;  \n\n            do  \n            {\n                baseNumber += 1; \n                baseNumberSquared = baseNumber * baseNumber; \n            }\n            while (Right6Digits(baseNumberSquared) != 269696); \n\n            Console.WriteLine(\"The smallest integer whose square ends in 269,696 is \" + baseNumber);\n            Console.WriteLine(\"The square is \" + baseNumberSquared);\n\n        }\n\n        private long Right6Digits(long baseNumberSquared)\n        {\n\n            string numberAsString = baseNumberSquared.ToString(); \n\n            if (numberAsString.Length < 6) { return baseNumberSquared; }; \n\n            numberAsString = numberAsString.Substring(numberAsString.Length - 6);  \n\n            return long.Parse(numberAsString); \n\n        }\n    }\n}}\n"}
{"id": 2684, "name": "Babbage problem", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. BABBAGE-PROGRAM.\n* A line beginning with an asterisk is an explanatory note.\n* The machine will disregard any such line.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n* In this part of the program we reserve the storage space we shall\n* be using for our variables, using a 'PICTURE' clause to specify\n* how many digits the machine is to keep free.\n* The prefixed number 77 indicates that these variables do not form part\n* of any larger 'record' that we might want to deal with as a whole.\n77  N           PICTURE 99999.\n* We know that 99,736 is a valid answer.\n77  N-SQUARED   PICTURE 9999999999.\n77  LAST-SIX    PICTURE 999999.\nPROCEDURE DIVISION.\n* Here we specify the calculations that the machine is to carry out.\nCONTROL-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING N FROM 1 BY 1\n    UNTIL LAST-SIX IS EQUAL TO 269696.\n    STOP RUN.\nCOMPUTATION-PARAGRAPH.\n    MULTIPLY N BY N GIVING N-SQUARED.\n    MOVE N-SQUARED TO LAST-SIX.\n* Since the variable LAST-SIX can hold a maximum of six digits,\n* only the final six digits of N-SQUARED will be moved into it:\n* the rest will not fit and will simply be discarded.\n    IF LAST-SIX IS EQUAL TO 269696 THEN DISPLAY N.\n", "target": "namespace Babbage_Problem\n{\n    class iterateNumbers\n    {\n        public iterateNumbers()\n        {\n            long baseNumberSquared = 0; \n            long baseNumber = 0;  \n\n            do  \n            {\n                baseNumber += 1; \n                baseNumberSquared = baseNumber * baseNumber; \n            }\n            while (Right6Digits(baseNumberSquared) != 269696); \n\n            Console.WriteLine(\"The smallest integer whose square ends in 269,696 is \" + baseNumber);\n            Console.WriteLine(\"The square is \" + baseNumberSquared);\n\n        }\n\n        private long Right6Digits(long baseNumberSquared)\n        {\n\n            string numberAsString = baseNumberSquared.ToString(); \n\n            if (numberAsString.Length < 6) { return baseNumberSquared; }; \n\n            numberAsString = numberAsString.Substring(numberAsString.Length - 6);  \n\n            return long.Parse(numberAsString); \n\n        }\n    }\n}}\n"}
{"id": 2687, "name": "Babbage problem", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. BABBAGE-PROGRAM.\n* A line beginning with an asterisk is an explanatory note.\n* The machine will disregard any such line.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n* In this part of the program we reserve the storage space we shall\n* be using for our variables, using a 'PICTURE' clause to specify\n* how many digits the machine is to keep free.\n* The prefixed number 77 indicates that these variables do not form part\n* of any larger 'record' that we might want to deal with as a whole.\n77  N           PICTURE 99999.\n* We know that 99,736 is a valid answer.\n77  N-SQUARED   PICTURE 9999999999.\n77  LAST-SIX    PICTURE 999999.\nPROCEDURE DIVISION.\n* Here we specify the calculations that the machine is to carry out.\nCONTROL-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING N FROM 1 BY 1\n    UNTIL LAST-SIX IS EQUAL TO 269696.\n    STOP RUN.\nCOMPUTATION-PARAGRAPH.\n    MULTIPLY N BY N GIVING N-SQUARED.\n    MOVE N-SQUARED TO LAST-SIX.\n* Since the variable LAST-SIX can hold a maximum of six digits,\n* only the final six digits of N-SQUARED will be moved into it:\n* the rest will not fit and will simply be discarded.\n    IF LAST-SIX IS EQUAL TO 269696 THEN DISPLAY N.\n", "target": "public class Test {\n\n    public static void main(String[] args) {\n\n        \n        int n = 0;\n\n        \n        do {\n\n            \n            n++;\n\n        \n        } while (n * n % 1000_000 != 269696);\n\n        \n        System.out.println(n);\n    }\n}\n"}
{"id": 2688, "name": "Babbage problem", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. BABBAGE-PROGRAM.\n* A line beginning with an asterisk is an explanatory note.\n* The machine will disregard any such line.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n* In this part of the program we reserve the storage space we shall\n* be using for our variables, using a 'PICTURE' clause to specify\n* how many digits the machine is to keep free.\n* The prefixed number 77 indicates that these variables do not form part\n* of any larger 'record' that we might want to deal with as a whole.\n77  N           PICTURE 99999.\n* We know that 99,736 is a valid answer.\n77  N-SQUARED   PICTURE 9999999999.\n77  LAST-SIX    PICTURE 999999.\nPROCEDURE DIVISION.\n* Here we specify the calculations that the machine is to carry out.\nCONTROL-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING N FROM 1 BY 1\n    UNTIL LAST-SIX IS EQUAL TO 269696.\n    STOP RUN.\nCOMPUTATION-PARAGRAPH.\n    MULTIPLY N BY N GIVING N-SQUARED.\n    MOVE N-SQUARED TO LAST-SIX.\n* Since the variable LAST-SIX can hold a maximum of six digits,\n* only the final six digits of N-SQUARED will be moved into it:\n* the rest will not fit and will simply be discarded.\n    IF LAST-SIX IS EQUAL TO 269696 THEN DISPLAY N.\n", "target": "public class Test {\n\n    public static void main(String[] args) {\n\n        \n        int n = 0;\n\n        \n        do {\n\n            \n            n++;\n\n        \n        } while (n * n % 1000_000 != 269696);\n\n        \n        System.out.println(n);\n    }\n}\n"}
{"id": 2689, "name": "Babbage problem", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. BABBAGE-PROGRAM.\n* A line beginning with an asterisk is an explanatory note.\n* The machine will disregard any such line.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n* In this part of the program we reserve the storage space we shall\n* be using for our variables, using a 'PICTURE' clause to specify\n* how many digits the machine is to keep free.\n* The prefixed number 77 indicates that these variables do not form part\n* of any larger 'record' that we might want to deal with as a whole.\n77  N           PICTURE 99999.\n* We know that 99,736 is a valid answer.\n77  N-SQUARED   PICTURE 9999999999.\n77  LAST-SIX    PICTURE 999999.\nPROCEDURE DIVISION.\n* Here we specify the calculations that the machine is to carry out.\nCONTROL-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING N FROM 1 BY 1\n    UNTIL LAST-SIX IS EQUAL TO 269696.\n    STOP RUN.\nCOMPUTATION-PARAGRAPH.\n    MULTIPLY N BY N GIVING N-SQUARED.\n    MOVE N-SQUARED TO LAST-SIX.\n* Since the variable LAST-SIX can hold a maximum of six digits,\n* only the final six digits of N-SQUARED will be moved into it:\n* the rest will not fit and will simply be discarded.\n    IF LAST-SIX IS EQUAL TO 269696 THEN DISPLAY N.\n", "target": "\n\n\nn=0 \n\n\n\n\nwhile n**2 % 1000000 != 269696:\n\n    \n    \n    \n    \n    n += 1 \n\nprint(n) \n"}
{"id": 2690, "name": "Babbage problem", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. BABBAGE-PROGRAM.\n* A line beginning with an asterisk is an explanatory note.\n* The machine will disregard any such line.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n* In this part of the program we reserve the storage space we shall\n* be using for our variables, using a 'PICTURE' clause to specify\n* how many digits the machine is to keep free.\n* The prefixed number 77 indicates that these variables do not form part\n* of any larger 'record' that we might want to deal with as a whole.\n77  N           PICTURE 99999.\n* We know that 99,736 is a valid answer.\n77  N-SQUARED   PICTURE 9999999999.\n77  LAST-SIX    PICTURE 999999.\nPROCEDURE DIVISION.\n* Here we specify the calculations that the machine is to carry out.\nCONTROL-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING N FROM 1 BY 1\n    UNTIL LAST-SIX IS EQUAL TO 269696.\n    STOP RUN.\nCOMPUTATION-PARAGRAPH.\n    MULTIPLY N BY N GIVING N-SQUARED.\n    MOVE N-SQUARED TO LAST-SIX.\n* Since the variable LAST-SIX can hold a maximum of six digits,\n* only the final six digits of N-SQUARED will be moved into it:\n* the rest will not fit and will simply be discarded.\n    IF LAST-SIX IS EQUAL TO 269696 THEN DISPLAY N.\n", "target": "\n\n\nn=0 \n\n\n\n\nwhile n**2 % 1000000 != 269696:\n\n    \n    \n    \n    \n    n += 1 \n\nprint(n) \n"}
{"id": 3388, "name": "Find limit of recursion", "source": "Translate COBOL to C#: identification division.\nprogram-id. recurse.\ndata division.\nworking-storage section.\n01 depth-counter\tpic 9(3).\n01  install-address   \tusage is procedure-pointer.\n01  install-flag      \tpic x comp-x value 0.\n01  status-code       \tpic x(2) comp-5.\n01  ind               \tpic s9(9) comp-5.\n\n\nlinkage section.\n01  err-msg           \tpic x(325).\n\nprocedure division.\n100-main.\n\n\tset install-address to entry \"300-err\".\n\t\n\tcall \"CBL_ERROR_PROC\" using install-flag\n\t\tinstall-address\n\t\treturning status-code.\n\n\tif status-code not = 0\n\t\tdisplay \"ERROR INSTALLING ERROR PROC\"\n\t\tstop run\n        end-if\n\n \tmove 0 to depth-counter.\n\tdisplay 'Mung until no good.'.\n\tperform 200-mung.\n\tdisplay 'No good.'.\n\tstop run.\n\n200-mung.\n\tadd 1 to depth-counter.\n\tdisplay depth-counter.\n\tperform 200-mung.\n300-err.\n\tentry \"300-err\" using err-msg.\n\tperform varying ind from 1 by 1\n\t\tuntil (err-msg(ind:1) = x\"00\") or (ind = length of err-msg)\n\t\t\tcontinue\n\tend-perform\n\n\tdisplay err-msg(1:ind).\n\n\n\t\n\texit program.\n", "target": "using System;\nclass RecursionLimit\n{\n  static void Main(string[] args)\n  {\n    Recur(0);\n  }\n \n  private static void Recur(int i) \n  {\n    Console.WriteLine(i);\n    Recur(i + 1);\n  }\n}\n"}
{"id": 3389, "name": "Find limit of recursion", "source": "Translate COBOL to C#: identification division.\nprogram-id. recurse.\ndata division.\nworking-storage section.\n01 depth-counter\tpic 9(3).\n01  install-address   \tusage is procedure-pointer.\n01  install-flag      \tpic x comp-x value 0.\n01  status-code       \tpic x(2) comp-5.\n01  ind               \tpic s9(9) comp-5.\n\n\nlinkage section.\n01  err-msg           \tpic x(325).\n\nprocedure division.\n100-main.\n\n\tset install-address to entry \"300-err\".\n\t\n\tcall \"CBL_ERROR_PROC\" using install-flag\n\t\tinstall-address\n\t\treturning status-code.\n\n\tif status-code not = 0\n\t\tdisplay \"ERROR INSTALLING ERROR PROC\"\n\t\tstop run\n        end-if\n\n \tmove 0 to depth-counter.\n\tdisplay 'Mung until no good.'.\n\tperform 200-mung.\n\tdisplay 'No good.'.\n\tstop run.\n\n200-mung.\n\tadd 1 to depth-counter.\n\tdisplay depth-counter.\n\tperform 200-mung.\n300-err.\n\tentry \"300-err\" using err-msg.\n\tperform varying ind from 1 by 1\n\t\tuntil (err-msg(ind:1) = x\"00\") or (ind = length of err-msg)\n\t\t\tcontinue\n\tend-perform\n\n\tdisplay err-msg(1:ind).\n\n\n\t\n\texit program.\n", "target": "using System;\nclass RecursionLimit\n{\n  static void Main(string[] args)\n  {\n    Recur(0);\n  }\n \n  private static void Recur(int i) \n  {\n    Console.WriteLine(i);\n    Recur(i + 1);\n  }\n}\n"}
{"id": 3392, "name": "Find limit of recursion", "source": "Translate COBOL to Java: identification division.\nprogram-id. recurse.\ndata division.\nworking-storage section.\n01 depth-counter\tpic 9(3).\n01  install-address   \tusage is procedure-pointer.\n01  install-flag      \tpic x comp-x value 0.\n01  status-code       \tpic x(2) comp-5.\n01  ind               \tpic s9(9) comp-5.\n\n\nlinkage section.\n01  err-msg           \tpic x(325).\n\nprocedure division.\n100-main.\n\n\tset install-address to entry \"300-err\".\n\t\n\tcall \"CBL_ERROR_PROC\" using install-flag\n\t\tinstall-address\n\t\treturning status-code.\n\n\tif status-code not = 0\n\t\tdisplay \"ERROR INSTALLING ERROR PROC\"\n\t\tstop run\n        end-if\n\n \tmove 0 to depth-counter.\n\tdisplay 'Mung until no good.'.\n\tperform 200-mung.\n\tdisplay 'No good.'.\n\tstop run.\n\n200-mung.\n\tadd 1 to depth-counter.\n\tdisplay depth-counter.\n\tperform 200-mung.\n300-err.\n\tentry \"300-err\" using err-msg.\n\tperform varying ind from 1 by 1\n\t\tuntil (err-msg(ind:1) = x\"00\") or (ind = length of err-msg)\n\t\t\tcontinue\n\tend-perform\n\n\tdisplay err-msg(1:ind).\n\n\n\t\n\texit program.\n", "target": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}\n"}
{"id": 3393, "name": "Find limit of recursion", "source": "Translate COBOL to Java: identification division.\nprogram-id. recurse.\ndata division.\nworking-storage section.\n01 depth-counter\tpic 9(3).\n01  install-address   \tusage is procedure-pointer.\n01  install-flag      \tpic x comp-x value 0.\n01  status-code       \tpic x(2) comp-5.\n01  ind               \tpic s9(9) comp-5.\n\n\nlinkage section.\n01  err-msg           \tpic x(325).\n\nprocedure division.\n100-main.\n\n\tset install-address to entry \"300-err\".\n\t\n\tcall \"CBL_ERROR_PROC\" using install-flag\n\t\tinstall-address\n\t\treturning status-code.\n\n\tif status-code not = 0\n\t\tdisplay \"ERROR INSTALLING ERROR PROC\"\n\t\tstop run\n        end-if\n\n \tmove 0 to depth-counter.\n\tdisplay 'Mung until no good.'.\n\tperform 200-mung.\n\tdisplay 'No good.'.\n\tstop run.\n\n200-mung.\n\tadd 1 to depth-counter.\n\tdisplay depth-counter.\n\tperform 200-mung.\n300-err.\n\tentry \"300-err\" using err-msg.\n\tperform varying ind from 1 by 1\n\t\tuntil (err-msg(ind:1) = x\"00\") or (ind = length of err-msg)\n\t\t\tcontinue\n\tend-perform\n\n\tdisplay err-msg(1:ind).\n\n\n\t\n\texit program.\n", "target": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}\n"}
{"id": 3394, "name": "Find limit of recursion", "source": "Translate COBOL to Python: identification division.\nprogram-id. recurse.\ndata division.\nworking-storage section.\n01 depth-counter\tpic 9(3).\n01  install-address   \tusage is procedure-pointer.\n01  install-flag      \tpic x comp-x value 0.\n01  status-code       \tpic x(2) comp-5.\n01  ind               \tpic s9(9) comp-5.\n\n\nlinkage section.\n01  err-msg           \tpic x(325).\n\nprocedure division.\n100-main.\n\n\tset install-address to entry \"300-err\".\n\t\n\tcall \"CBL_ERROR_PROC\" using install-flag\n\t\tinstall-address\n\t\treturning status-code.\n\n\tif status-code not = 0\n\t\tdisplay \"ERROR INSTALLING ERROR PROC\"\n\t\tstop run\n        end-if\n\n \tmove 0 to depth-counter.\n\tdisplay 'Mung until no good.'.\n\tperform 200-mung.\n\tdisplay 'No good.'.\n\tstop run.\n\n200-mung.\n\tadd 1 to depth-counter.\n\tdisplay depth-counter.\n\tperform 200-mung.\n300-err.\n\tentry \"300-err\" using err-msg.\n\tperform varying ind from 1 by 1\n\t\tuntil (err-msg(ind:1) = x\"00\") or (ind = length of err-msg)\n\t\t\tcontinue\n\tend-perform\n\n\tdisplay err-msg(1:ind).\n\n\n\t\n\texit program.\n", "target": "import sys\nprint(sys.getrecursionlimit())\n"}
{"id": 3395, "name": "Find limit of recursion", "source": "Translate COBOL to Python: identification division.\nprogram-id. recurse.\ndata division.\nworking-storage section.\n01 depth-counter\tpic 9(3).\n01  install-address   \tusage is procedure-pointer.\n01  install-flag      \tpic x comp-x value 0.\n01  status-code       \tpic x(2) comp-5.\n01  ind               \tpic s9(9) comp-5.\n\n\nlinkage section.\n01  err-msg           \tpic x(325).\n\nprocedure division.\n100-main.\n\n\tset install-address to entry \"300-err\".\n\t\n\tcall \"CBL_ERROR_PROC\" using install-flag\n\t\tinstall-address\n\t\treturning status-code.\n\n\tif status-code not = 0\n\t\tdisplay \"ERROR INSTALLING ERROR PROC\"\n\t\tstop run\n        end-if\n\n \tmove 0 to depth-counter.\n\tdisplay 'Mung until no good.'.\n\tperform 200-mung.\n\tdisplay 'No good.'.\n\tstop run.\n\n200-mung.\n\tadd 1 to depth-counter.\n\tdisplay depth-counter.\n\tperform 200-mung.\n300-err.\n\tentry \"300-err\" using err-msg.\n\tperform varying ind from 1 by 1\n\t\tuntil (err-msg(ind:1) = x\"00\") or (ind = length of err-msg)\n\t\t\tcontinue\n\tend-perform\n\n\tdisplay err-msg(1:ind).\n\n\n\t\n\texit program.\n", "target": "import sys\nprint(sys.getrecursionlimit())\n"}
{"id": 4321, "name": "CSV data manipulation", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CSV.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  19 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   CSVs are something COBOL does pretty well.\n      **     The commented out CONCATENATE statements are a\n      **     second method other than the STRING method.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n           REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT CSV-File ASSIGN TO \"csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Out-File ASSIGN TO \"new.csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  CSV-File \n           DATA RECORD IS CSV-Record.\n       01  CSV-Record.\n           05 Field1                  PIC X(64).\n       \n       FD  Out-File\n           DATA RECORD IS Out-Line.\n       01  Out-Line   PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       \n       01  CSV-Data.\n           05  CSV-Col1             PIC 9(5).\n           05  CSV-Col2             PIC 9(5).\n           05  CSV-Col3             PIC 9(5).\n           05  CSV-Col4             PIC 9(5).\n           05  CSV-Col5             PIC 9(5).\n\n        01  CSV-Sum                  PIC ZZZ9.\n        01  CSV-Sum-Alpha           \n                REDEFINES     CSV-Sum  PIC X(4).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  CSV-File\n           OPEN OUTPUT Out-File\n           PERFORM Read-a-Record\n           PERFORM Build-Header\n           PERFORM UNTIL Eof = 'T'\n              PERFORM Read-a-Record\n              IF Eof NOT EQUAL 'T' PERFORM Process-a-Record\n           END-PERFORM\n           CLOSE CSV-File\n           CLOSE Out-File\n           STOP RUN.\n       \n       Read-a-Record.\n           READ CSV-File \n              AT END MOVE 'T' TO Eof\n           END-READ.\n\n        Build-Header.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",SUM\"\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",SUM\" INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n\n        Process-a-Record.\n            UNSTRING CSV-Record DELIMITED BY ',' INTO\n                  CSV-Col1 CSV-Col2 CSV-Col3 CSV-Col4 CSV-Col5.\n            COMPUTE CSV-Sum = \n                  CSV-Col1 + CSV-Col2 + CSV-Col3 + CSV-Col4 + CSV-Col5.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha))\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha)\n                   INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n       \n       END-PROGRAM.\n", "target": "using System.IO;\nusing System.Linq;\n\nnamespace CSV_data_manipulation\n{\n    class Program\n    {\n        static void Main()\n        {\n            var input = File.ReadAllLines(\"test_in.csv\");\n            var output = input.Select((line, i) =>\n            {\n                if (i == 0)\n                    return line + \",SUM\";\n                var sum = line.Split(',').Select(int.Parse).Sum();\n                return line + \",\" + sum;\n            }).ToArray();\n            File.WriteAllLines(\"test_out.csv\", output);\n        }\n    }\n}\n"}
{"id": 4322, "name": "CSV data manipulation", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CSV.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  19 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   CSVs are something COBOL does pretty well.\n      **     The commented out CONCATENATE statements are a\n      **     second method other than the STRING method.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n           REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT CSV-File ASSIGN TO \"csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Out-File ASSIGN TO \"new.csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  CSV-File \n           DATA RECORD IS CSV-Record.\n       01  CSV-Record.\n           05 Field1                  PIC X(64).\n       \n       FD  Out-File\n           DATA RECORD IS Out-Line.\n       01  Out-Line   PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       \n       01  CSV-Data.\n           05  CSV-Col1             PIC 9(5).\n           05  CSV-Col2             PIC 9(5).\n           05  CSV-Col3             PIC 9(5).\n           05  CSV-Col4             PIC 9(5).\n           05  CSV-Col5             PIC 9(5).\n\n        01  CSV-Sum                  PIC ZZZ9.\n        01  CSV-Sum-Alpha           \n                REDEFINES     CSV-Sum  PIC X(4).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  CSV-File\n           OPEN OUTPUT Out-File\n           PERFORM Read-a-Record\n           PERFORM Build-Header\n           PERFORM UNTIL Eof = 'T'\n              PERFORM Read-a-Record\n              IF Eof NOT EQUAL 'T' PERFORM Process-a-Record\n           END-PERFORM\n           CLOSE CSV-File\n           CLOSE Out-File\n           STOP RUN.\n       \n       Read-a-Record.\n           READ CSV-File \n              AT END MOVE 'T' TO Eof\n           END-READ.\n\n        Build-Header.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",SUM\"\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",SUM\" INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n\n        Process-a-Record.\n            UNSTRING CSV-Record DELIMITED BY ',' INTO\n                  CSV-Col1 CSV-Col2 CSV-Col3 CSV-Col4 CSV-Col5.\n            COMPUTE CSV-Sum = \n                  CSV-Col1 + CSV-Col2 + CSV-Col3 + CSV-Col4 + CSV-Col5.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha))\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha)\n                   INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n       \n       END-PROGRAM.\n", "target": "using System.IO;\nusing System.Linq;\n\nnamespace CSV_data_manipulation\n{\n    class Program\n    {\n        static void Main()\n        {\n            var input = File.ReadAllLines(\"test_in.csv\");\n            var output = input.Select((line, i) =>\n            {\n                if (i == 0)\n                    return line + \",SUM\";\n                var sum = line.Split(',').Select(int.Parse).Sum();\n                return line + \",\" + sum;\n            }).ToArray();\n            File.WriteAllLines(\"test_out.csv\", output);\n        }\n    }\n}\n"}
{"id": 4325, "name": "CSV data manipulation", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CSV.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  19 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   CSVs are something COBOL does pretty well.\n      **     The commented out CONCATENATE statements are a\n      **     second method other than the STRING method.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n           REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT CSV-File ASSIGN TO \"csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Out-File ASSIGN TO \"new.csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  CSV-File \n           DATA RECORD IS CSV-Record.\n       01  CSV-Record.\n           05 Field1                  PIC X(64).\n       \n       FD  Out-File\n           DATA RECORD IS Out-Line.\n       01  Out-Line   PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       \n       01  CSV-Data.\n           05  CSV-Col1             PIC 9(5).\n           05  CSV-Col2             PIC 9(5).\n           05  CSV-Col3             PIC 9(5).\n           05  CSV-Col4             PIC 9(5).\n           05  CSV-Col5             PIC 9(5).\n\n        01  CSV-Sum                  PIC ZZZ9.\n        01  CSV-Sum-Alpha           \n                REDEFINES     CSV-Sum  PIC X(4).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  CSV-File\n           OPEN OUTPUT Out-File\n           PERFORM Read-a-Record\n           PERFORM Build-Header\n           PERFORM UNTIL Eof = 'T'\n              PERFORM Read-a-Record\n              IF Eof NOT EQUAL 'T' PERFORM Process-a-Record\n           END-PERFORM\n           CLOSE CSV-File\n           CLOSE Out-File\n           STOP RUN.\n       \n       Read-a-Record.\n           READ CSV-File \n              AT END MOVE 'T' TO Eof\n           END-READ.\n\n        Build-Header.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",SUM\"\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",SUM\" INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n\n        Process-a-Record.\n            UNSTRING CSV-Record DELIMITED BY ',' INTO\n                  CSV-Col1 CSV-Col2 CSV-Col3 CSV-Col4 CSV-Col5.\n            COMPUTE CSV-Sum = \n                  CSV-Col1 + CSV-Col2 + CSV-Col3 + CSV-Col4 + CSV-Col5.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha))\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha)\n                   INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n       \n       END-PROGRAM.\n", "target": "import java.io.*;\nimport java.awt.Point;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class CSV {\n\n    private HashMap<Point, String> _map = new HashMap<Point, String>();\n    private int _cols;\n    private int _rows;\n\n    public void open(File file) throws FileNotFoundException, IOException {\n        open(file, ',');\n    }\n\n    public void open(File file, char delimiter)\n            throws FileNotFoundException, IOException {\n        Scanner scanner = new Scanner(file);\n        scanner.useDelimiter(Character.toString(delimiter));\n\n        clear();\n\n        while(scanner.hasNextLine()) {\n            String[] values = scanner.nextLine().split(Character.toString(delimiter));\n\n            int col = 0;\n            for ( String value: values ) {\n                _map.put(new Point(col, _rows), value);\n                _cols = Math.max(_cols, ++col);\n            }\n            _rows++;\n        }\n        scanner.close();\n    }\n\n    public void save(File file) throws IOException {\n        save(file, ',');\n    }\n\n    public void save(File file, char delimiter) throws IOException {\n        FileWriter fw = new FileWriter(file);\n        BufferedWriter bw = new BufferedWriter(fw);\n\n        for (int row = 0; row < _rows; row++) {\n            for (int col = 0; col < _cols; col++) {\n                Point key = new Point(col, row);\n                if (_map.containsKey(key)) {\n                    bw.write(_map.get(key));\n                }\n\n                if ((col + 1) < _cols) {\n                    bw.write(delimiter);\n                }\n            }\n            bw.newLine();\n        }\n        bw.flush();\n        bw.close();\n    }\n\n    public String get(int col, int row) {\n        String val = \"\";\n        Point key = new Point(col, row);\n        if (_map.containsKey(key)) {\n            val = _map.get(key);\n        }\n        return val;\n    }\n\n    public void put(int col, int row, String value) {\n        _map.put(new Point(col, row), value);\n        _cols = Math.max(_cols, col+1);\n        _rows = Math.max(_rows, row+1);\n    }\n\n    public void clear() {\n        _map.clear();\n        _cols = 0;\n        _rows = 0;\n    }\n\n    public int rows() {\n        return _rows;\n    }\n\n    public int cols() {\n        return _cols;\n    }\n\n    public static void main(String[] args) {\n        try {\n            CSV csv = new CSV();\n\n            csv.open(new File(\"test_in.csv\"));\n            csv.put(0, 0, \"Column0\");\n            csv.put(1, 1, \"100\");\n            csv.put(2, 2, \"200\");\n            csv.put(3, 3, \"300\");\n            csv.put(4, 4, \"400\");\n            csv.save(new File(\"test_out.csv\"));\n        } catch (Exception e) {\n        }\n    }\n}\n"}
{"id": 4326, "name": "CSV data manipulation", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CSV.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  19 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   CSVs are something COBOL does pretty well.\n      **     The commented out CONCATENATE statements are a\n      **     second method other than the STRING method.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n           REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT CSV-File ASSIGN TO \"csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Out-File ASSIGN TO \"new.csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  CSV-File \n           DATA RECORD IS CSV-Record.\n       01  CSV-Record.\n           05 Field1                  PIC X(64).\n       \n       FD  Out-File\n           DATA RECORD IS Out-Line.\n       01  Out-Line   PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       \n       01  CSV-Data.\n           05  CSV-Col1             PIC 9(5).\n           05  CSV-Col2             PIC 9(5).\n           05  CSV-Col3             PIC 9(5).\n           05  CSV-Col4             PIC 9(5).\n           05  CSV-Col5             PIC 9(5).\n\n        01  CSV-Sum                  PIC ZZZ9.\n        01  CSV-Sum-Alpha           \n                REDEFINES     CSV-Sum  PIC X(4).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  CSV-File\n           OPEN OUTPUT Out-File\n           PERFORM Read-a-Record\n           PERFORM Build-Header\n           PERFORM UNTIL Eof = 'T'\n              PERFORM Read-a-Record\n              IF Eof NOT EQUAL 'T' PERFORM Process-a-Record\n           END-PERFORM\n           CLOSE CSV-File\n           CLOSE Out-File\n           STOP RUN.\n       \n       Read-a-Record.\n           READ CSV-File \n              AT END MOVE 'T' TO Eof\n           END-READ.\n\n        Build-Header.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",SUM\"\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",SUM\" INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n\n        Process-a-Record.\n            UNSTRING CSV-Record DELIMITED BY ',' INTO\n                  CSV-Col1 CSV-Col2 CSV-Col3 CSV-Col4 CSV-Col5.\n            COMPUTE CSV-Sum = \n                  CSV-Col1 + CSV-Col2 + CSV-Col3 + CSV-Col4 + CSV-Col5.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha))\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha)\n                   INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n       \n       END-PROGRAM.\n", "target": "import java.io.*;\nimport java.awt.Point;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class CSV {\n\n    private HashMap<Point, String> _map = new HashMap<Point, String>();\n    private int _cols;\n    private int _rows;\n\n    public void open(File file) throws FileNotFoundException, IOException {\n        open(file, ',');\n    }\n\n    public void open(File file, char delimiter)\n            throws FileNotFoundException, IOException {\n        Scanner scanner = new Scanner(file);\n        scanner.useDelimiter(Character.toString(delimiter));\n\n        clear();\n\n        while(scanner.hasNextLine()) {\n            String[] values = scanner.nextLine().split(Character.toString(delimiter));\n\n            int col = 0;\n            for ( String value: values ) {\n                _map.put(new Point(col, _rows), value);\n                _cols = Math.max(_cols, ++col);\n            }\n            _rows++;\n        }\n        scanner.close();\n    }\n\n    public void save(File file) throws IOException {\n        save(file, ',');\n    }\n\n    public void save(File file, char delimiter) throws IOException {\n        FileWriter fw = new FileWriter(file);\n        BufferedWriter bw = new BufferedWriter(fw);\n\n        for (int row = 0; row < _rows; row++) {\n            for (int col = 0; col < _cols; col++) {\n                Point key = new Point(col, row);\n                if (_map.containsKey(key)) {\n                    bw.write(_map.get(key));\n                }\n\n                if ((col + 1) < _cols) {\n                    bw.write(delimiter);\n                }\n            }\n            bw.newLine();\n        }\n        bw.flush();\n        bw.close();\n    }\n\n    public String get(int col, int row) {\n        String val = \"\";\n        Point key = new Point(col, row);\n        if (_map.containsKey(key)) {\n            val = _map.get(key);\n        }\n        return val;\n    }\n\n    public void put(int col, int row, String value) {\n        _map.put(new Point(col, row), value);\n        _cols = Math.max(_cols, col+1);\n        _rows = Math.max(_rows, row+1);\n    }\n\n    public void clear() {\n        _map.clear();\n        _cols = 0;\n        _rows = 0;\n    }\n\n    public int rows() {\n        return _rows;\n    }\n\n    public int cols() {\n        return _cols;\n    }\n\n    public static void main(String[] args) {\n        try {\n            CSV csv = new CSV();\n\n            csv.open(new File(\"test_in.csv\"));\n            csv.put(0, 0, \"Column0\");\n            csv.put(1, 1, \"100\");\n            csv.put(2, 2, \"200\");\n            csv.put(3, 3, \"300\");\n            csv.put(4, 4, \"400\");\n            csv.save(new File(\"test_out.csv\"));\n        } catch (Exception e) {\n        }\n    }\n}\n"}
{"id": 4327, "name": "CSV data manipulation", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CSV.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  19 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   CSVs are something COBOL does pretty well.\n      **     The commented out CONCATENATE statements are a\n      **     second method other than the STRING method.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n           REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT CSV-File ASSIGN TO \"csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Out-File ASSIGN TO \"new.csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  CSV-File \n           DATA RECORD IS CSV-Record.\n       01  CSV-Record.\n           05 Field1                  PIC X(64).\n       \n       FD  Out-File\n           DATA RECORD IS Out-Line.\n       01  Out-Line   PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       \n       01  CSV-Data.\n           05  CSV-Col1             PIC 9(5).\n           05  CSV-Col2             PIC 9(5).\n           05  CSV-Col3             PIC 9(5).\n           05  CSV-Col4             PIC 9(5).\n           05  CSV-Col5             PIC 9(5).\n\n        01  CSV-Sum                  PIC ZZZ9.\n        01  CSV-Sum-Alpha           \n                REDEFINES     CSV-Sum  PIC X(4).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  CSV-File\n           OPEN OUTPUT Out-File\n           PERFORM Read-a-Record\n           PERFORM Build-Header\n           PERFORM UNTIL Eof = 'T'\n              PERFORM Read-a-Record\n              IF Eof NOT EQUAL 'T' PERFORM Process-a-Record\n           END-PERFORM\n           CLOSE CSV-File\n           CLOSE Out-File\n           STOP RUN.\n       \n       Read-a-Record.\n           READ CSV-File \n              AT END MOVE 'T' TO Eof\n           END-READ.\n\n        Build-Header.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",SUM\"\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",SUM\" INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n\n        Process-a-Record.\n            UNSTRING CSV-Record DELIMITED BY ',' INTO\n                  CSV-Col1 CSV-Col2 CSV-Col3 CSV-Col4 CSV-Col5.\n            COMPUTE CSV-Sum = \n                  CSV-Col1 + CSV-Col2 + CSV-Col3 + CSV-Col4 + CSV-Col5.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha))\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha)\n                   INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n       \n       END-PROGRAM.\n", "target": "import fileinput\n\nchangerow, changecolumn, changevalue = 2, 4, '\"Spam\"'\n\nwith fileinput.input('csv_data_manipulation.csv', inplace=True) as f:\n    for line in f:\n        if fileinput.filelineno() == changerow:\n            fields = line.rstrip().split(',')\n            fields[changecolumn-1] = changevalue\n            line = ','.join(fields) + '\\n'\n        print(line, end='')\n"}
{"id": 4328, "name": "CSV data manipulation", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CSV.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  19 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   CSVs are something COBOL does pretty well.\n      **     The commented out CONCATENATE statements are a\n      **     second method other than the STRING method.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n           REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT CSV-File ASSIGN TO \"csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Out-File ASSIGN TO \"new.csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  CSV-File \n           DATA RECORD IS CSV-Record.\n       01  CSV-Record.\n           05 Field1                  PIC X(64).\n       \n       FD  Out-File\n           DATA RECORD IS Out-Line.\n       01  Out-Line   PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       \n       01  CSV-Data.\n           05  CSV-Col1             PIC 9(5).\n           05  CSV-Col2             PIC 9(5).\n           05  CSV-Col3             PIC 9(5).\n           05  CSV-Col4             PIC 9(5).\n           05  CSV-Col5             PIC 9(5).\n\n        01  CSV-Sum                  PIC ZZZ9.\n        01  CSV-Sum-Alpha           \n                REDEFINES     CSV-Sum  PIC X(4).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  CSV-File\n           OPEN OUTPUT Out-File\n           PERFORM Read-a-Record\n           PERFORM Build-Header\n           PERFORM UNTIL Eof = 'T'\n              PERFORM Read-a-Record\n              IF Eof NOT EQUAL 'T' PERFORM Process-a-Record\n           END-PERFORM\n           CLOSE CSV-File\n           CLOSE Out-File\n           STOP RUN.\n       \n       Read-a-Record.\n           READ CSV-File \n              AT END MOVE 'T' TO Eof\n           END-READ.\n\n        Build-Header.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",SUM\"\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",SUM\" INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n\n        Process-a-Record.\n            UNSTRING CSV-Record DELIMITED BY ',' INTO\n                  CSV-Col1 CSV-Col2 CSV-Col3 CSV-Col4 CSV-Col5.\n            COMPUTE CSV-Sum = \n                  CSV-Col1 + CSV-Col2 + CSV-Col3 + CSV-Col4 + CSV-Col5.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha))\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha)\n                   INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n       \n       END-PROGRAM.\n", "target": "import fileinput\n\nchangerow, changecolumn, changevalue = 2, 4, '\"Spam\"'\n\nwith fileinput.input('csv_data_manipulation.csv', inplace=True) as f:\n    for line in f:\n        if fileinput.filelineno() == changerow:\n            fields = line.rstrip().split(',')\n            fields[changecolumn-1] = changevalue\n            line = ','.join(fields) + '\\n'\n        print(line, end='')\n"}
{"id": 6666, "name": "Collections", "source": "Translate COBOL to C#:        identification division.\n       program-id. collections.\n\n       data division.\n       working-storage section.\n       01 sample-table.\n          05 sample-record occurs 1 to 3 times depending on the-index.\n             10 sample-alpha   pic x(4).\n             10 filler         pic x value \":\".\n             10 sample-number  pic 9(4).\n             10 filler         pic x value space.\n       77 the-index            usage index.\n\n       procedure division.\n       collections-main.\n\n       set the-index to 3\n       move 1234 to sample-number(1)\n       move \"abcd\" to sample-alpha(1)\n\n       move \"test\" to sample-alpha(2)\n\n       move 6789 to sample-number(3)\n       move \"wxyz\" to sample-alpha(3)\n\n       display \"sample-table   \u00a0: \" sample-table\n       display \"sample-number(1): \" sample-number(1)\n       display \"sample-record(2): \" sample-record(2)\n       display \"sample-number(3): \" sample-number(3)\n\n      \n       set the-index down by 1\n       display \"sample-table   \u00a0: \" sample-table\n       display \"sample-number(3): \" sample-number(3)\n\n       goback.\n       end program collections.\n", "target": "\nint[] intArray = new int[5] { 1, 2, 3, 4, 5 };\n\nint[] intArray = new int[]{ 1, 2, 3, 4, 5 };\n\nint[] intArray = { 1, 2, 3, 4, 5 };\n\n\nstring[] stringArr = new string[5];\nstringArr[0] = \"string\";\n"}
{"id": 6668, "name": "Collections", "source": "Translate COBOL to Java:        identification division.\n       program-id. collections.\n\n       data division.\n       working-storage section.\n       01 sample-table.\n          05 sample-record occurs 1 to 3 times depending on the-index.\n             10 sample-alpha   pic x(4).\n             10 filler         pic x value \":\".\n             10 sample-number  pic 9(4).\n             10 filler         pic x value space.\n       77 the-index            usage index.\n\n       procedure division.\n       collections-main.\n\n       set the-index to 3\n       move 1234 to sample-number(1)\n       move \"abcd\" to sample-alpha(1)\n\n       move \"test\" to sample-alpha(2)\n\n       move 6789 to sample-number(3)\n       move \"wxyz\" to sample-alpha(3)\n\n       display \"sample-table   \u00a0: \" sample-table\n       display \"sample-number(1): \" sample-number(1)\n       display \"sample-record(2): \" sample-record(2)\n       display \"sample-number(3): \" sample-number(3)\n\n      \n       set the-index down by 1\n       display \"sample-table   \u00a0: \" sample-table\n       display \"sample-number(3): \" sample-number(3)\n\n       goback.\n       end program collections.\n", "target": "List arrayList = new ArrayList();\narrayList.add(new Integer(0));\n\narrayList.add(0); \n\n\n\nList<Integer> myarrlist = new ArrayList<Integer>();\n\n\nint sum;\nfor(int i = 0; i < 10; i++) {\n    myarrlist.add(i);\n}\n"}
{"id": 6669, "name": "Collections", "source": "Translate COBOL to Python:        identification division.\n       program-id. collections.\n\n       data division.\n       working-storage section.\n       01 sample-table.\n          05 sample-record occurs 1 to 3 times depending on the-index.\n             10 sample-alpha   pic x(4).\n             10 filler         pic x value \":\".\n             10 sample-number  pic 9(4).\n             10 filler         pic x value space.\n       77 the-index            usage index.\n\n       procedure division.\n       collections-main.\n\n       set the-index to 3\n       move 1234 to sample-number(1)\n       move \"abcd\" to sample-alpha(1)\n\n       move \"test\" to sample-alpha(2)\n\n       move 6789 to sample-number(3)\n       move \"wxyz\" to sample-alpha(3)\n\n       display \"sample-table   \u00a0: \" sample-table\n       display \"sample-number(1): \" sample-number(1)\n       display \"sample-record(2): \" sample-record(2)\n       display \"sample-number(3): \" sample-number(3)\n\n      \n       set the-index down by 1\n       display \"sample-table   \u00a0: \" sample-table\n       display \"sample-number(3): \" sample-number(3)\n\n       goback.\n       end program collections.\n", "target": "collection = [0, '1']                 \nx = collection[0]                     \ncollection.append(2)                  \ncollection.insert(0, '-1')            \ny = collection[0]                     \ncollection.extend([2,'3'])            \ncollection += [2,'3']                 \ncollection[2:6]                       \nlen(collection)                       \ncollection = (0, 1)                   \ncollection[:]                         \ncollection[-4:-1]                     \ncollection[::2]                       \ncollection=\"some string\"              \nx = collection[::-1]                  \ncollection[::2] == \"some string\"[::2] \ncollection.__getitem__(slice(0,len(collection),2))  \ncollection = {0: \"zero\", 1: \"one\"}    \ncollection['zero'] = 2                \ncollection = set([0, '1'])            \n"}
{"id": 7950, "name": "Jump anywhere", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. JUMPS-PROGRAM.\n* Nobody writes like this, of course; but...\nPROCEDURE DIVISION.\n* You can jump anywhere you like.\nSTART-PARAGRAPH.\n    GO TO AN-ARBITRARY-PARAGRAPH.\nYET-ANOTHER-PARAGRAPH.\n    ALTER START-PARAGRAPH TO PROCEED TO A-PARAGRAPH-SOMEWHERE.\n* That's right, folks: we don't just have GO TOs, we have GO TOs whose\n* destinations can be changed at will, from anywhere in the program,\n* at run time.\n    GO TO START-PARAGRAPH.\n* But bear in mind: once you get there, the GO TO no longer goes to\n* where it says it goes to.\nA-PARAGRAPH-SOMEWHERE.\n    DISPLAY 'Never heard of him.'\n    STOP RUN.\nSOME-OTHER-PARAGRAPH.\n* You think that's bad? You ain't seen nothing.\n    GO TO YET-ANOTHER-PARAGRAPH.\nAN-ARBITRARY-PARAGRAPH.\n    DISPLAY 'Edsger who now?'\n    GO TO SOME-OTHER-PARAGRAPH.\n", "target": "if (x > 0) goto positive;\nelse goto negative;\n\npositive:\n    Console.WriteLine(\"pos\\n\"); goto both;\n\nnegative:\n    Console.WriteLine(\"neg\\n\");\n\nboth:\n    ...\n"}
{"id": 7951, "name": "Jump anywhere", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. JUMPS-PROGRAM.\n* Nobody writes like this, of course; but...\nPROCEDURE DIVISION.\n* You can jump anywhere you like.\nSTART-PARAGRAPH.\n    GO TO AN-ARBITRARY-PARAGRAPH.\nYET-ANOTHER-PARAGRAPH.\n    ALTER START-PARAGRAPH TO PROCEED TO A-PARAGRAPH-SOMEWHERE.\n* That's right, folks: we don't just have GO TOs, we have GO TOs whose\n* destinations can be changed at will, from anywhere in the program,\n* at run time.\n    GO TO START-PARAGRAPH.\n* But bear in mind: once you get there, the GO TO no longer goes to\n* where it says it goes to.\nA-PARAGRAPH-SOMEWHERE.\n    DISPLAY 'Never heard of him.'\n    STOP RUN.\nSOME-OTHER-PARAGRAPH.\n* You think that's bad? You ain't seen nothing.\n    GO TO YET-ANOTHER-PARAGRAPH.\nAN-ARBITRARY-PARAGRAPH.\n    DISPLAY 'Edsger who now?'\n    GO TO SOME-OTHER-PARAGRAPH.\n", "target": "if (x > 0) goto positive;\nelse goto negative;\n\npositive:\n    Console.WriteLine(\"pos\\n\"); goto both;\n\nnegative:\n    Console.WriteLine(\"neg\\n\");\n\nboth:\n    ...\n"}
{"id": 7954, "name": "Jump anywhere", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. JUMPS-PROGRAM.\n* Nobody writes like this, of course; but...\nPROCEDURE DIVISION.\n* You can jump anywhere you like.\nSTART-PARAGRAPH.\n    GO TO AN-ARBITRARY-PARAGRAPH.\nYET-ANOTHER-PARAGRAPH.\n    ALTER START-PARAGRAPH TO PROCEED TO A-PARAGRAPH-SOMEWHERE.\n* That's right, folks: we don't just have GO TOs, we have GO TOs whose\n* destinations can be changed at will, from anywhere in the program,\n* at run time.\n    GO TO START-PARAGRAPH.\n* But bear in mind: once you get there, the GO TO no longer goes to\n* where it says it goes to.\nA-PARAGRAPH-SOMEWHERE.\n    DISPLAY 'Never heard of him.'\n    STOP RUN.\nSOME-OTHER-PARAGRAPH.\n* You think that's bad? You ain't seen nothing.\n    GO TO YET-ANOTHER-PARAGRAPH.\nAN-ARBITRARY-PARAGRAPH.\n    DISPLAY 'Edsger who now?'\n    GO TO SOME-OTHER-PARAGRAPH.\n", "target": "loop1: while (x != 0) {\n    loop2: for (int i = 0; i < 10; i++) {\n        loop3: do {\n            \n            if () {\n                \n                continue loop1;\n            }\n            \n            if () {\n                \n                break loop2;\n            }\n        } while (y < 10);\n        \n    }\n    \n}\n"}
{"id": 7955, "name": "Jump anywhere", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. JUMPS-PROGRAM.\n* Nobody writes like this, of course; but...\nPROCEDURE DIVISION.\n* You can jump anywhere you like.\nSTART-PARAGRAPH.\n    GO TO AN-ARBITRARY-PARAGRAPH.\nYET-ANOTHER-PARAGRAPH.\n    ALTER START-PARAGRAPH TO PROCEED TO A-PARAGRAPH-SOMEWHERE.\n* That's right, folks: we don't just have GO TOs, we have GO TOs whose\n* destinations can be changed at will, from anywhere in the program,\n* at run time.\n    GO TO START-PARAGRAPH.\n* But bear in mind: once you get there, the GO TO no longer goes to\n* where it says it goes to.\nA-PARAGRAPH-SOMEWHERE.\n    DISPLAY 'Never heard of him.'\n    STOP RUN.\nSOME-OTHER-PARAGRAPH.\n* You think that's bad? You ain't seen nothing.\n    GO TO YET-ANOTHER-PARAGRAPH.\nAN-ARBITRARY-PARAGRAPH.\n    DISPLAY 'Edsger who now?'\n    GO TO SOME-OTHER-PARAGRAPH.\n", "target": "loop1: while (x != 0) {\n    loop2: for (int i = 0; i < 10; i++) {\n        loop3: do {\n            \n            if () {\n                \n                continue loop1;\n            }\n            \n            if () {\n                \n                break loop2;\n            }\n        } while (y < 10);\n        \n    }\n    \n}\n"}
{"id": 7956, "name": "Jump anywhere", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. JUMPS-PROGRAM.\n* Nobody writes like this, of course; but...\nPROCEDURE DIVISION.\n* You can jump anywhere you like.\nSTART-PARAGRAPH.\n    GO TO AN-ARBITRARY-PARAGRAPH.\nYET-ANOTHER-PARAGRAPH.\n    ALTER START-PARAGRAPH TO PROCEED TO A-PARAGRAPH-SOMEWHERE.\n* That's right, folks: we don't just have GO TOs, we have GO TOs whose\n* destinations can be changed at will, from anywhere in the program,\n* at run time.\n    GO TO START-PARAGRAPH.\n* But bear in mind: once you get there, the GO TO no longer goes to\n* where it says it goes to.\nA-PARAGRAPH-SOMEWHERE.\n    DISPLAY 'Never heard of him.'\n    STOP RUN.\nSOME-OTHER-PARAGRAPH.\n* You think that's bad? You ain't seen nothing.\n    GO TO YET-ANOTHER-PARAGRAPH.\nAN-ARBITRARY-PARAGRAPH.\n    DISPLAY 'Edsger who now?'\n    GO TO SOME-OTHER-PARAGRAPH.\n", "target": "\nfrom goto import goto, label\nlabel .start\nfor i in range(1, 4):\n    print i\n    if i == 2:\n        try:\n            output = message\n        except NameError:\n            print \"Oops - forgot to define 'message'!  Start again.\"\n            message = \"Hello world\"\n            goto .start\nprint output, \"\\n\"\n"}
{"id": 7957, "name": "Jump anywhere", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. JUMPS-PROGRAM.\n* Nobody writes like this, of course; but...\nPROCEDURE DIVISION.\n* You can jump anywhere you like.\nSTART-PARAGRAPH.\n    GO TO AN-ARBITRARY-PARAGRAPH.\nYET-ANOTHER-PARAGRAPH.\n    ALTER START-PARAGRAPH TO PROCEED TO A-PARAGRAPH-SOMEWHERE.\n* That's right, folks: we don't just have GO TOs, we have GO TOs whose\n* destinations can be changed at will, from anywhere in the program,\n* at run time.\n    GO TO START-PARAGRAPH.\n* But bear in mind: once you get there, the GO TO no longer goes to\n* where it says it goes to.\nA-PARAGRAPH-SOMEWHERE.\n    DISPLAY 'Never heard of him.'\n    STOP RUN.\nSOME-OTHER-PARAGRAPH.\n* You think that's bad? You ain't seen nothing.\n    GO TO YET-ANOTHER-PARAGRAPH.\nAN-ARBITRARY-PARAGRAPH.\n    DISPLAY 'Edsger who now?'\n    GO TO SOME-OTHER-PARAGRAPH.\n", "target": "\nfrom goto import goto, label\nlabel .start\nfor i in range(1, 4):\n    print i\n    if i == 2:\n        try:\n            output = message\n        except NameError:\n            print \"Oops - forgot to define 'message'!  Start again.\"\n            message = \"Hello world\"\n            goto .start\nprint output, \"\\n\"\n"}
{"id": 8782, "name": "Department numbers", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DEPARTMENT-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.       \n       01 BANNER        PIC X(24) VALUE \"POLICE  SANITATION  FIRE\".\n       01 COMBINATION.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 POLICE     PIC 9.\n          03 FILLER     PIC X(11) VALUE SPACES.\n          03 SANITATION PIC 9.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 FIRE       PIC 9.\n       01 TOTAL         PIC 99.\n\n       PROCEDURE DIVISION.\n       BEGIN. \n           DISPLAY BANNER.\n           PERFORM POLICE-LOOP VARYING POLICE FROM 2 BY 2\n           UNTIL POLICE IS GREATER THAN 6.\n           STOP RUN.\n \n       POLICE-LOOP. \n           PERFORM SANITATION-LOOP VARYING SANITATION FROM 1 BY 1\n           UNTIL SANITATION IS GREATER THAN 7.\n  \n       SANITATION-LOOP.\n           PERFORM FIRE-LOOP VARYING FIRE FROM 1 BY 1\n           UNTIL FIRE IS GREATER THAN 7.\n \n       FIRE-LOOP.\n           ADD POLICE, SANITATION, FIRE GIVING TOTAL.\n           IF POLICE IS NOT EQUAL TO SANITATION\n               AND POLICE IS NOT EQUAL TO FIRE\n               AND SANITATION IS NOT EQUAL TO FIRE\n               AND TOTAL IS EQUAL TO 12,\n               DISPLAY COMBINATION.\n", "target": "using System;\npublic class Program\n{\n    public static void Main() {\n        for (int p = 2; p <= 7; p+=2) {\n            for (int s = 1; s <= 7; s++) {\n                int f = 12 - p - s;\n                if (s >= f) break;\n                if (f > 7) continue;\n                if (s == p || f == p) continue; \n                Console.WriteLine($\"Police:{p}, Sanitation:{s}, Fire:{f}\");\n                Console.WriteLine($\"Police:{p}, Sanitation:{f}, Fire:{s}\");\n            }\n        }\n    }\n}\n"}
{"id": 8783, "name": "Department numbers", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DEPARTMENT-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.       \n       01 BANNER        PIC X(24) VALUE \"POLICE  SANITATION  FIRE\".\n       01 COMBINATION.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 POLICE     PIC 9.\n          03 FILLER     PIC X(11) VALUE SPACES.\n          03 SANITATION PIC 9.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 FIRE       PIC 9.\n       01 TOTAL         PIC 99.\n\n       PROCEDURE DIVISION.\n       BEGIN. \n           DISPLAY BANNER.\n           PERFORM POLICE-LOOP VARYING POLICE FROM 2 BY 2\n           UNTIL POLICE IS GREATER THAN 6.\n           STOP RUN.\n \n       POLICE-LOOP. \n           PERFORM SANITATION-LOOP VARYING SANITATION FROM 1 BY 1\n           UNTIL SANITATION IS GREATER THAN 7.\n  \n       SANITATION-LOOP.\n           PERFORM FIRE-LOOP VARYING FIRE FROM 1 BY 1\n           UNTIL FIRE IS GREATER THAN 7.\n \n       FIRE-LOOP.\n           ADD POLICE, SANITATION, FIRE GIVING TOTAL.\n           IF POLICE IS NOT EQUAL TO SANITATION\n               AND POLICE IS NOT EQUAL TO FIRE\n               AND SANITATION IS NOT EQUAL TO FIRE\n               AND TOTAL IS EQUAL TO 12,\n               DISPLAY COMBINATION.\n", "target": "using System;\npublic class Program\n{\n    public static void Main() {\n        for (int p = 2; p <= 7; p+=2) {\n            for (int s = 1; s <= 7; s++) {\n                int f = 12 - p - s;\n                if (s >= f) break;\n                if (f > 7) continue;\n                if (s == p || f == p) continue; \n                Console.WriteLine($\"Police:{p}, Sanitation:{s}, Fire:{f}\");\n                Console.WriteLine($\"Police:{p}, Sanitation:{f}, Fire:{s}\");\n            }\n        }\n    }\n}\n"}
{"id": 8786, "name": "Department numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DEPARTMENT-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.       \n       01 BANNER        PIC X(24) VALUE \"POLICE  SANITATION  FIRE\".\n       01 COMBINATION.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 POLICE     PIC 9.\n          03 FILLER     PIC X(11) VALUE SPACES.\n          03 SANITATION PIC 9.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 FIRE       PIC 9.\n       01 TOTAL         PIC 99.\n\n       PROCEDURE DIVISION.\n       BEGIN. \n           DISPLAY BANNER.\n           PERFORM POLICE-LOOP VARYING POLICE FROM 2 BY 2\n           UNTIL POLICE IS GREATER THAN 6.\n           STOP RUN.\n \n       POLICE-LOOP. \n           PERFORM SANITATION-LOOP VARYING SANITATION FROM 1 BY 1\n           UNTIL SANITATION IS GREATER THAN 7.\n  \n       SANITATION-LOOP.\n           PERFORM FIRE-LOOP VARYING FIRE FROM 1 BY 1\n           UNTIL FIRE IS GREATER THAN 7.\n \n       FIRE-LOOP.\n           ADD POLICE, SANITATION, FIRE GIVING TOTAL.\n           IF POLICE IS NOT EQUAL TO SANITATION\n               AND POLICE IS NOT EQUAL TO FIRE\n               AND SANITATION IS NOT EQUAL TO FIRE\n               AND TOTAL IS EQUAL TO 12,\n               DISPLAY COMBINATION.\n", "target": "public class DepartmentNumbers {\n    public static void main(String[] args) {\n        System.out.println(\"Police  Sanitation  Fire\");\n        System.out.println(\"------  ----------  ----\");\n        int count = 0;\n        for (int i = 2; i <= 6; i += 2) {\n            for (int j = 1; j <= 7; ++j) {\n                if (j == i) continue;\n                for (int k = 1; k <= 7; ++k) {\n                    if (k == i || k == j) continue;\n                    if (i + j + k != 12) continue;\n                    System.out.printf(\"  %d         %d         %d\\n\", i, j, k);\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"\\n%d valid combinations\", count);\n    }\n}\n"}
{"id": 8787, "name": "Department numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DEPARTMENT-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.       \n       01 BANNER        PIC X(24) VALUE \"POLICE  SANITATION  FIRE\".\n       01 COMBINATION.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 POLICE     PIC 9.\n          03 FILLER     PIC X(11) VALUE SPACES.\n          03 SANITATION PIC 9.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 FIRE       PIC 9.\n       01 TOTAL         PIC 99.\n\n       PROCEDURE DIVISION.\n       BEGIN. \n           DISPLAY BANNER.\n           PERFORM POLICE-LOOP VARYING POLICE FROM 2 BY 2\n           UNTIL POLICE IS GREATER THAN 6.\n           STOP RUN.\n \n       POLICE-LOOP. \n           PERFORM SANITATION-LOOP VARYING SANITATION FROM 1 BY 1\n           UNTIL SANITATION IS GREATER THAN 7.\n  \n       SANITATION-LOOP.\n           PERFORM FIRE-LOOP VARYING FIRE FROM 1 BY 1\n           UNTIL FIRE IS GREATER THAN 7.\n \n       FIRE-LOOP.\n           ADD POLICE, SANITATION, FIRE GIVING TOTAL.\n           IF POLICE IS NOT EQUAL TO SANITATION\n               AND POLICE IS NOT EQUAL TO FIRE\n               AND SANITATION IS NOT EQUAL TO FIRE\n               AND TOTAL IS EQUAL TO 12,\n               DISPLAY COMBINATION.\n", "target": "public class DepartmentNumbers {\n    public static void main(String[] args) {\n        System.out.println(\"Police  Sanitation  Fire\");\n        System.out.println(\"------  ----------  ----\");\n        int count = 0;\n        for (int i = 2; i <= 6; i += 2) {\n            for (int j = 1; j <= 7; ++j) {\n                if (j == i) continue;\n                for (int k = 1; k <= 7; ++k) {\n                    if (k == i || k == j) continue;\n                    if (i + j + k != 12) continue;\n                    System.out.printf(\"  %d         %d         %d\\n\", i, j, k);\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"\\n%d valid combinations\", count);\n    }\n}\n"}
{"id": 8788, "name": "Department numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DEPARTMENT-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.       \n       01 BANNER        PIC X(24) VALUE \"POLICE  SANITATION  FIRE\".\n       01 COMBINATION.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 POLICE     PIC 9.\n          03 FILLER     PIC X(11) VALUE SPACES.\n          03 SANITATION PIC 9.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 FIRE       PIC 9.\n       01 TOTAL         PIC 99.\n\n       PROCEDURE DIVISION.\n       BEGIN. \n           DISPLAY BANNER.\n           PERFORM POLICE-LOOP VARYING POLICE FROM 2 BY 2\n           UNTIL POLICE IS GREATER THAN 6.\n           STOP RUN.\n \n       POLICE-LOOP. \n           PERFORM SANITATION-LOOP VARYING SANITATION FROM 1 BY 1\n           UNTIL SANITATION IS GREATER THAN 7.\n  \n       SANITATION-LOOP.\n           PERFORM FIRE-LOOP VARYING FIRE FROM 1 BY 1\n           UNTIL FIRE IS GREATER THAN 7.\n \n       FIRE-LOOP.\n           ADD POLICE, SANITATION, FIRE GIVING TOTAL.\n           IF POLICE IS NOT EQUAL TO SANITATION\n               AND POLICE IS NOT EQUAL TO FIRE\n               AND SANITATION IS NOT EQUAL TO FIRE\n               AND TOTAL IS EQUAL TO 12,\n               DISPLAY COMBINATION.\n", "target": "from itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n"}
{"id": 8789, "name": "Department numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DEPARTMENT-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.       \n       01 BANNER        PIC X(24) VALUE \"POLICE  SANITATION  FIRE\".\n       01 COMBINATION.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 POLICE     PIC 9.\n          03 FILLER     PIC X(11) VALUE SPACES.\n          03 SANITATION PIC 9.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 FIRE       PIC 9.\n       01 TOTAL         PIC 99.\n\n       PROCEDURE DIVISION.\n       BEGIN. \n           DISPLAY BANNER.\n           PERFORM POLICE-LOOP VARYING POLICE FROM 2 BY 2\n           UNTIL POLICE IS GREATER THAN 6.\n           STOP RUN.\n \n       POLICE-LOOP. \n           PERFORM SANITATION-LOOP VARYING SANITATION FROM 1 BY 1\n           UNTIL SANITATION IS GREATER THAN 7.\n  \n       SANITATION-LOOP.\n           PERFORM FIRE-LOOP VARYING FIRE FROM 1 BY 1\n           UNTIL FIRE IS GREATER THAN 7.\n \n       FIRE-LOOP.\n           ADD POLICE, SANITATION, FIRE GIVING TOTAL.\n           IF POLICE IS NOT EQUAL TO SANITATION\n               AND POLICE IS NOT EQUAL TO FIRE\n               AND SANITATION IS NOT EQUAL TO FIRE\n               AND TOTAL IS EQUAL TO 12,\n               DISPLAY COMBINATION.\n", "target": "from itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n"}
{"id": 10523, "name": "Nth root", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Nth-Root.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  \n       DATE-WRITTEN.  4 Feb 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Compute the Nth Root of a positive real number.\n      **   \n      **   Takes values from console.  If Precision is left\n      **   blank defaults to 0.001.\n      **   \n      **   Enter 0 for first value to terminate program.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Root-File ASSIGN TO \"Root-File\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Root-File\n           DATA RECORD IS Parameters.\n       01  Parameters.\n           05 Root                       PIC 9(5).\n           05 Num                        PIC 9(5)V9(5).\n           05 Precision                  PIC 9V9(9).\n\n       \n       WORKING-STORAGE SECTION.\n       \n       01  TEMP0                         PIC 9(9)V9(9).\n       01  TEMP1                         PIC 9(9)V9(9).\n       01  RESULTS.\n           05  Field1                        PIC ZZZZZ.ZZZZZ.\n           05  FILLER                        PIC X(5).\n           05  Field2                        PIC ZZZZ9.\n           05  FILLER                        PIC X(14).\n           05  Field3                        PIC 9.999999999.\n\n       01  HEADER.\n           05  FILLER                        PIC X(72) \n               VALUE \"   Number           Root           Precision.\".\n       \n       01  Disp-Root                         PIC ZZZZZ.ZZZZZ.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           PERFORM FOREVER\n           \n              PERFORM Get-Input\n              IF Precision = 0.0 \n                  THEN MOVE 0.001 to Precision\n              END-IF\n\n              PERFORM Compute-Root\n\n              MOVE Root TO Field2\n              MOVE Num TO Field1\n              MOVE Precision TO Field3\n              DISPLAY HEADER\n              DISPLAY RESULTS\n              DISPLAY \" \"\n              MOVE TEMP1 TO Disp-Root\n              DISPLAY \"The Root is: \" Disp-Root\n           END-PERFORM.\n       \n       Get-Input.\n           DISPLAY \"Input Base Number: \" WITH NO ADVANCING\n           ACCEPT Num\n           IF Num EQUALS ZERO\n              THEN \n                   DISPLAY \"Good Bye.\"\n                   STOP RUN\n           END-IF\n           DISPLAY \"Input Root: \" WITH NO ADVANCING\n           ACCEPT Root\n           DISPLAY \"Input Desired Precision: \" WITH NO ADVANCING\n           ACCEPT Precision.\n\n       Compute-Root.\n          MOVE Root TO TEMP0\n          DIVIDE Num BY Root GIVING TEMP1\n\n          PERFORM UNTIL FUNCTION ABS(TEMP0 - TEMP1) \n                                    LESS THAN Precision \n               MOVE TEMP1 TO TEMP0\n               COMPUTE TEMP1 = (( Root - 1.0) * TEMP1 + Num / \n                                        TEMP1 ** (Root - 1.0)) / Root\n          END-PERFORM.\n       \n       END-PROGRAM.\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(NthRoot(81,2,.001));\n        Console.WriteLine(NthRoot(1000,3,.001));\n        Console.ReadLine();\n}\n\npublic static double NthRoot(double A,int n,  double p)\n{\n\tdouble _n= (double) n;\n\tdouble[] x = new double[2];\t\t\n\tx[0] = A;\n\tx[1] = A/_n;\n\twhile(Math.Abs(x[0] -x[1] ) > p)\n\t{\n\t\tx[1] = x[0];\n\t\tx[0] = (1/_n)*(((_n-1)*x[1]) + (A/Math.Pow(x[1],_n-1)));\n\t\t\t\n\t}\n\treturn x[0];\n}\n"}
{"id": 10525, "name": "Nth root", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Nth-Root.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  \n       DATE-WRITTEN.  4 Feb 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Compute the Nth Root of a positive real number.\n      **   \n      **   Takes values from console.  If Precision is left\n      **   blank defaults to 0.001.\n      **   \n      **   Enter 0 for first value to terminate program.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Root-File ASSIGN TO \"Root-File\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Root-File\n           DATA RECORD IS Parameters.\n       01  Parameters.\n           05 Root                       PIC 9(5).\n           05 Num                        PIC 9(5)V9(5).\n           05 Precision                  PIC 9V9(9).\n\n       \n       WORKING-STORAGE SECTION.\n       \n       01  TEMP0                         PIC 9(9)V9(9).\n       01  TEMP1                         PIC 9(9)V9(9).\n       01  RESULTS.\n           05  Field1                        PIC ZZZZZ.ZZZZZ.\n           05  FILLER                        PIC X(5).\n           05  Field2                        PIC ZZZZ9.\n           05  FILLER                        PIC X(14).\n           05  Field3                        PIC 9.999999999.\n\n       01  HEADER.\n           05  FILLER                        PIC X(72) \n               VALUE \"   Number           Root           Precision.\".\n       \n       01  Disp-Root                         PIC ZZZZZ.ZZZZZ.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           PERFORM FOREVER\n           \n              PERFORM Get-Input\n              IF Precision = 0.0 \n                  THEN MOVE 0.001 to Precision\n              END-IF\n\n              PERFORM Compute-Root\n\n              MOVE Root TO Field2\n              MOVE Num TO Field1\n              MOVE Precision TO Field3\n              DISPLAY HEADER\n              DISPLAY RESULTS\n              DISPLAY \" \"\n              MOVE TEMP1 TO Disp-Root\n              DISPLAY \"The Root is: \" Disp-Root\n           END-PERFORM.\n       \n       Get-Input.\n           DISPLAY \"Input Base Number: \" WITH NO ADVANCING\n           ACCEPT Num\n           IF Num EQUALS ZERO\n              THEN \n                   DISPLAY \"Good Bye.\"\n                   STOP RUN\n           END-IF\n           DISPLAY \"Input Root: \" WITH NO ADVANCING\n           ACCEPT Root\n           DISPLAY \"Input Desired Precision: \" WITH NO ADVANCING\n           ACCEPT Precision.\n\n       Compute-Root.\n          MOVE Root TO TEMP0\n          DIVIDE Num BY Root GIVING TEMP1\n\n          PERFORM UNTIL FUNCTION ABS(TEMP0 - TEMP1) \n                                    LESS THAN Precision \n               MOVE TEMP1 TO TEMP0\n               COMPUTE TEMP1 = (( Root - 1.0) * TEMP1 + Num / \n                                        TEMP1 ** (Root - 1.0)) / Root\n          END-PERFORM.\n       \n       END-PROGRAM.\n", "target": "public static double nthroot(int n, double A) {\n\treturn nthroot(n, A, .001);\n}\npublic static double nthroot(int n, double A, double p) {\n\tif(A < 0) {\n\t\tSystem.err.println(\"A < 0\");\n\t\treturn -1;\n\t} else if(A == 0) {\n\t\treturn 0;\n\t}\n\tdouble x_prev = A;\n\tdouble x = A / n;  \n\twhile(Math.abs(x - x_prev) > p) {\n\t\tx_prev = x;\n\t\tx = ((n - 1.0) * x + A / Math.pow(x, n - 1.0)) / n;\n\t}\n\treturn x;\n}\n"}
{"id": 10526, "name": "Nth root", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Nth-Root.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  \n       DATE-WRITTEN.  4 Feb 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Compute the Nth Root of a positive real number.\n      **   \n      **   Takes values from console.  If Precision is left\n      **   blank defaults to 0.001.\n      **   \n      **   Enter 0 for first value to terminate program.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Root-File ASSIGN TO \"Root-File\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Root-File\n           DATA RECORD IS Parameters.\n       01  Parameters.\n           05 Root                       PIC 9(5).\n           05 Num                        PIC 9(5)V9(5).\n           05 Precision                  PIC 9V9(9).\n\n       \n       WORKING-STORAGE SECTION.\n       \n       01  TEMP0                         PIC 9(9)V9(9).\n       01  TEMP1                         PIC 9(9)V9(9).\n       01  RESULTS.\n           05  Field1                        PIC ZZZZZ.ZZZZZ.\n           05  FILLER                        PIC X(5).\n           05  Field2                        PIC ZZZZ9.\n           05  FILLER                        PIC X(14).\n           05  Field3                        PIC 9.999999999.\n\n       01  HEADER.\n           05  FILLER                        PIC X(72) \n               VALUE \"   Number           Root           Precision.\".\n       \n       01  Disp-Root                         PIC ZZZZZ.ZZZZZ.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           PERFORM FOREVER\n           \n              PERFORM Get-Input\n              IF Precision = 0.0 \n                  THEN MOVE 0.001 to Precision\n              END-IF\n\n              PERFORM Compute-Root\n\n              MOVE Root TO Field2\n              MOVE Num TO Field1\n              MOVE Precision TO Field3\n              DISPLAY HEADER\n              DISPLAY RESULTS\n              DISPLAY \" \"\n              MOVE TEMP1 TO Disp-Root\n              DISPLAY \"The Root is: \" Disp-Root\n           END-PERFORM.\n       \n       Get-Input.\n           DISPLAY \"Input Base Number: \" WITH NO ADVANCING\n           ACCEPT Num\n           IF Num EQUALS ZERO\n              THEN \n                   DISPLAY \"Good Bye.\"\n                   STOP RUN\n           END-IF\n           DISPLAY \"Input Root: \" WITH NO ADVANCING\n           ACCEPT Root\n           DISPLAY \"Input Desired Precision: \" WITH NO ADVANCING\n           ACCEPT Precision.\n\n       Compute-Root.\n          MOVE Root TO TEMP0\n          DIVIDE Num BY Root GIVING TEMP1\n\n          PERFORM UNTIL FUNCTION ABS(TEMP0 - TEMP1) \n                                    LESS THAN Precision \n               MOVE TEMP1 TO TEMP0\n               COMPUTE TEMP1 = (( Root - 1.0) * TEMP1 + Num / \n                                        TEMP1 ** (Root - 1.0)) / Root\n          END-PERFORM.\n       \n       END-PROGRAM.\n", "target": "from decimal import Decimal, getcontext\n\ndef nthroot (n, A, precision):\n    getcontext().prec = precision\n    \n    n = Decimal(n)\n    x_0 = A / n \n    x_1 = 1     \n    while True:\n        \n        x_0, x_1 = x_1, (1 / n)*((n - 1)*x_0 + (A / (x_0 ** (n - 1))))\n        if x_0 == x_1:\n            return x_1\n"}
{"id": 11494, "name": "Hailstone sequence", "source": "Translate COBOL to C#:        identification division.\n       program-id. hailstones.\n       remarks. cobc -x hailstones.cob.\n\n       data division.\n       working-storage section.\n       01 most                 constant as 1000000.\n       01 coverage             constant as 100000.       \n       01 stones               usage binary-long.\n       01 n                    usage binary-long.\n       01 storm                usage binary-long.\n\n       01 show-arg             pic 9(6).\n       01 show-default         pic 99 value 27.\n       01 show-sequence        usage binary-long.\n       01 longest              usage binary-long occurs 2 times.\n\n       01 filler.\n          05 hail              usage binary-long\n                               occurs 0 to most depending on stones.\n       01 show                 pic z(10).\n       01 low-range            usage binary-long.\n       01 high-range           usage binary-long.\n       01 range                usage binary-long.\n        \n\n       01 remain               usage binary-long.\n       01 unused               usage binary-long.\n\n       procedure division.\n       accept show-arg from command-line\n       if show-arg less than 1 or greater than coverage then\n           move show-default to show-arg\n       end-if\n       move show-arg to show-sequence\n\n       move 1 to longest(1)\n       perform hailstone varying storm\n                         from 1 by 1 until storm > coverage\n       display \"Longest at: \" longest(2) \" with \" longest(1) \" elements\"\n       goback.\n\n      \n       hailstone.\n       move 0 to stones\n       move storm to n\n       perform until n equal 1\n           if stones > most then\n               display \"too many hailstones\" upon syserr\n               stop run\n           end-if\n\n           add 1 to stones\n           move n to hail(stones)\n           divide n by 2 giving unused remainder remain\n           if remain equal 0 then\n               divide 2 into n\n           else\n               compute n = 3 * n + 1\n           end-if\n       end-perform\n       add 1 to stones\n       move n to hail(stones)\n\n       if stones > longest(1) then\n           move stones to longest(1)\n           move storm to longest(2)\n       end-if\n\n       if storm equal show-sequence then\n           display show-sequence \": \" with no advancing\n           perform varying range from 1 by 1 until range > stones\n               move 5 to low-range\n               compute high-range = stones - 4\n               if range < low-range or range > high-range then\n                   move hail(range) to show\n                   display function trim(show) with no advancing\n                   if range < stones then\n                       display \", \" with no advancing\n                   end-if\n               end-if\n               if range = low-range and stones > 8 then\n                   display \"..., \" with no advancing\n               end-if\n           end-perform\n           display \": \" stones \" elements\"\n       end-if\n       .\n\n       end program hailstones.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Hailstone\n{\n    class Program\n    {\n        public static List<int> hs(int n,List<int> seq)\n        {\n            List<int> sequence = seq;\n            sequence.Add(n);\n            if (n == 1)\n            {\n                return sequence;\n            }else{\n                int newn = (n % 2 == 0) ? n / 2 : (3 * n) + 1;\n                return hs(newn, sequence);\n            }                        \n        }\n\n        static void Main(string[] args)\n        {\n            int n = 27;\n            List<int> sequence = hs(n,new List<int>());\n            Console.WriteLine(sequence.Count + \" Elements\");\n            List<int> start = sequence.GetRange(0, 4);\n            List<int> end = sequence.GetRange(sequence.Count - 4, 4);\n            Console.WriteLine(\"Starting with\u00a0: \" + string.Join(\",\", start) + \" and ending with\u00a0: \" + string.Join(\",\", end));            \n            int number = 0, longest = 0;            \n            for (int i = 1; i < 100000; i++)\n            {\n                int count = (hs(i, new List<int>())).Count;\n                if (count > longest)\n                {\n                    longest = count;\n                    number = i;\n                }\n            }\n            Console.WriteLine(\"Number < 100000 with longest Hailstone seq.: \" + number + \" with length of \" + longest);\n       }\n    }\n}\n"}
{"id": 11495, "name": "Hailstone sequence", "source": "Translate COBOL to C#:        identification division.\n       program-id. hailstones.\n       remarks. cobc -x hailstones.cob.\n\n       data division.\n       working-storage section.\n       01 most                 constant as 1000000.\n       01 coverage             constant as 100000.       \n       01 stones               usage binary-long.\n       01 n                    usage binary-long.\n       01 storm                usage binary-long.\n\n       01 show-arg             pic 9(6).\n       01 show-default         pic 99 value 27.\n       01 show-sequence        usage binary-long.\n       01 longest              usage binary-long occurs 2 times.\n\n       01 filler.\n          05 hail              usage binary-long\n                               occurs 0 to most depending on stones.\n       01 show                 pic z(10).\n       01 low-range            usage binary-long.\n       01 high-range           usage binary-long.\n       01 range                usage binary-long.\n        \n\n       01 remain               usage binary-long.\n       01 unused               usage binary-long.\n\n       procedure division.\n       accept show-arg from command-line\n       if show-arg less than 1 or greater than coverage then\n           move show-default to show-arg\n       end-if\n       move show-arg to show-sequence\n\n       move 1 to longest(1)\n       perform hailstone varying storm\n                         from 1 by 1 until storm > coverage\n       display \"Longest at: \" longest(2) \" with \" longest(1) \" elements\"\n       goback.\n\n      \n       hailstone.\n       move 0 to stones\n       move storm to n\n       perform until n equal 1\n           if stones > most then\n               display \"too many hailstones\" upon syserr\n               stop run\n           end-if\n\n           add 1 to stones\n           move n to hail(stones)\n           divide n by 2 giving unused remainder remain\n           if remain equal 0 then\n               divide 2 into n\n           else\n               compute n = 3 * n + 1\n           end-if\n       end-perform\n       add 1 to stones\n       move n to hail(stones)\n\n       if stones > longest(1) then\n           move stones to longest(1)\n           move storm to longest(2)\n       end-if\n\n       if storm equal show-sequence then\n           display show-sequence \": \" with no advancing\n           perform varying range from 1 by 1 until range > stones\n               move 5 to low-range\n               compute high-range = stones - 4\n               if range < low-range or range > high-range then\n                   move hail(range) to show\n                   display function trim(show) with no advancing\n                   if range < stones then\n                       display \", \" with no advancing\n                   end-if\n               end-if\n               if range = low-range and stones > 8 then\n                   display \"..., \" with no advancing\n               end-if\n           end-perform\n           display \": \" stones \" elements\"\n       end-if\n       .\n\n       end program hailstones.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Hailstone\n{\n    class Program\n    {\n        public static List<int> hs(int n,List<int> seq)\n        {\n            List<int> sequence = seq;\n            sequence.Add(n);\n            if (n == 1)\n            {\n                return sequence;\n            }else{\n                int newn = (n % 2 == 0) ? n / 2 : (3 * n) + 1;\n                return hs(newn, sequence);\n            }                        \n        }\n\n        static void Main(string[] args)\n        {\n            int n = 27;\n            List<int> sequence = hs(n,new List<int>());\n            Console.WriteLine(sequence.Count + \" Elements\");\n            List<int> start = sequence.GetRange(0, 4);\n            List<int> end = sequence.GetRange(sequence.Count - 4, 4);\n            Console.WriteLine(\"Starting with\u00a0: \" + string.Join(\",\", start) + \" and ending with\u00a0: \" + string.Join(\",\", end));            \n            int number = 0, longest = 0;            \n            for (int i = 1; i < 100000; i++)\n            {\n                int count = (hs(i, new List<int>())).Count;\n                if (count > longest)\n                {\n                    longest = count;\n                    number = i;\n                }\n            }\n            Console.WriteLine(\"Number < 100000 with longest Hailstone seq.: \" + number + \" with length of \" + longest);\n       }\n    }\n}\n"}
{"id": 11498, "name": "Hailstone sequence", "source": "Translate COBOL to Java:        identification division.\n       program-id. hailstones.\n       remarks. cobc -x hailstones.cob.\n\n       data division.\n       working-storage section.\n       01 most                 constant as 1000000.\n       01 coverage             constant as 100000.       \n       01 stones               usage binary-long.\n       01 n                    usage binary-long.\n       01 storm                usage binary-long.\n\n       01 show-arg             pic 9(6).\n       01 show-default         pic 99 value 27.\n       01 show-sequence        usage binary-long.\n       01 longest              usage binary-long occurs 2 times.\n\n       01 filler.\n          05 hail              usage binary-long\n                               occurs 0 to most depending on stones.\n       01 show                 pic z(10).\n       01 low-range            usage binary-long.\n       01 high-range           usage binary-long.\n       01 range                usage binary-long.\n        \n\n       01 remain               usage binary-long.\n       01 unused               usage binary-long.\n\n       procedure division.\n       accept show-arg from command-line\n       if show-arg less than 1 or greater than coverage then\n           move show-default to show-arg\n       end-if\n       move show-arg to show-sequence\n\n       move 1 to longest(1)\n       perform hailstone varying storm\n                         from 1 by 1 until storm > coverage\n       display \"Longest at: \" longest(2) \" with \" longest(1) \" elements\"\n       goback.\n\n      \n       hailstone.\n       move 0 to stones\n       move storm to n\n       perform until n equal 1\n           if stones > most then\n               display \"too many hailstones\" upon syserr\n               stop run\n           end-if\n\n           add 1 to stones\n           move n to hail(stones)\n           divide n by 2 giving unused remainder remain\n           if remain equal 0 then\n               divide 2 into n\n           else\n               compute n = 3 * n + 1\n           end-if\n       end-perform\n       add 1 to stones\n       move n to hail(stones)\n\n       if stones > longest(1) then\n           move stones to longest(1)\n           move storm to longest(2)\n       end-if\n\n       if storm equal show-sequence then\n           display show-sequence \": \" with no advancing\n           perform varying range from 1 by 1 until range > stones\n               move 5 to low-range\n               compute high-range = stones - 4\n               if range < low-range or range > high-range then\n                   move hail(range) to show\n                   display function trim(show) with no advancing\n                   if range < stones then\n                       display \", \" with no advancing\n                   end-if\n               end-if\n               if range = low-range and stones > 8 then\n                   display \"..., \" with no advancing\n               end-if\n           end-perform\n           display \": \" stones \" elements\"\n       end-if\n       .\n\n       end program hailstones.\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Hailstone {\n\n  public static List<Long> getHailstoneSequence(long n) {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid starting sequence number\");\n    List<Long> list = new ArrayList<Long>();\n    list.add(Long.valueOf(n));\n    while (n != 1) {\n      if ((n & 1) == 0)\n        n = n / 2;\n      else\n        n = 3 * n + 1;\n      list.add(Long.valueOf(n));\n    }\n    return list;\n  }\n  \n  public static void main(String[] args) {\n    List<Long> sequence27 = getHailstoneSequence(27);\n    System.out.println(\"Sequence for 27 has \" + sequence27.size() + \" elements: \" + sequence27);\n    \n    long MAX = 100000;\n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = getHailstoneSequence(i).size();\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 1, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = 1;\n        long n = i;\n        while (n != 1) {\n          if ((n & 1) == 0)\n            n = n / 2;\n          else\n            n = 3 * n + 1;\n          count++;\n        }\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 2, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      long highestCount = 1;\n      Map<Long, Integer> sequenceMap = new HashMap<Long, Integer>();\n      sequenceMap.put(Long.valueOf(1), Integer.valueOf(1));\n      \n      List<Long> currentList = new ArrayList<Long>();\n      for (long i = 2; i < MAX; i++) {\n        currentList.clear();\n        Long n = Long.valueOf(i);\n        Integer count = null;\n        while ((count = sequenceMap.get(n)) == null) {\n          currentList.add(n);\n          long nValue = n.longValue();\n          if ((nValue & 1) == 0)\n            n = Long.valueOf(nValue / 2);\n          else\n            n = Long.valueOf(3 * nValue + 1);\n        }\n        int curCount = count.intValue();\n        for (int j = currentList.size() - 1; j >= 0; j--)\n          sequenceMap.put(currentList.get(j), Integer.valueOf(++curCount));\n        if (curCount > highestCount) {\n          highestCount = curCount;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 3, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    return;\n  }\n}\n"}
{"id": 11499, "name": "Hailstone sequence", "source": "Translate COBOL to Java:        identification division.\n       program-id. hailstones.\n       remarks. cobc -x hailstones.cob.\n\n       data division.\n       working-storage section.\n       01 most                 constant as 1000000.\n       01 coverage             constant as 100000.       \n       01 stones               usage binary-long.\n       01 n                    usage binary-long.\n       01 storm                usage binary-long.\n\n       01 show-arg             pic 9(6).\n       01 show-default         pic 99 value 27.\n       01 show-sequence        usage binary-long.\n       01 longest              usage binary-long occurs 2 times.\n\n       01 filler.\n          05 hail              usage binary-long\n                               occurs 0 to most depending on stones.\n       01 show                 pic z(10).\n       01 low-range            usage binary-long.\n       01 high-range           usage binary-long.\n       01 range                usage binary-long.\n        \n\n       01 remain               usage binary-long.\n       01 unused               usage binary-long.\n\n       procedure division.\n       accept show-arg from command-line\n       if show-arg less than 1 or greater than coverage then\n           move show-default to show-arg\n       end-if\n       move show-arg to show-sequence\n\n       move 1 to longest(1)\n       perform hailstone varying storm\n                         from 1 by 1 until storm > coverage\n       display \"Longest at: \" longest(2) \" with \" longest(1) \" elements\"\n       goback.\n\n      \n       hailstone.\n       move 0 to stones\n       move storm to n\n       perform until n equal 1\n           if stones > most then\n               display \"too many hailstones\" upon syserr\n               stop run\n           end-if\n\n           add 1 to stones\n           move n to hail(stones)\n           divide n by 2 giving unused remainder remain\n           if remain equal 0 then\n               divide 2 into n\n           else\n               compute n = 3 * n + 1\n           end-if\n       end-perform\n       add 1 to stones\n       move n to hail(stones)\n\n       if stones > longest(1) then\n           move stones to longest(1)\n           move storm to longest(2)\n       end-if\n\n       if storm equal show-sequence then\n           display show-sequence \": \" with no advancing\n           perform varying range from 1 by 1 until range > stones\n               move 5 to low-range\n               compute high-range = stones - 4\n               if range < low-range or range > high-range then\n                   move hail(range) to show\n                   display function trim(show) with no advancing\n                   if range < stones then\n                       display \", \" with no advancing\n                   end-if\n               end-if\n               if range = low-range and stones > 8 then\n                   display \"..., \" with no advancing\n               end-if\n           end-perform\n           display \": \" stones \" elements\"\n       end-if\n       .\n\n       end program hailstones.\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Hailstone {\n\n  public static List<Long> getHailstoneSequence(long n) {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid starting sequence number\");\n    List<Long> list = new ArrayList<Long>();\n    list.add(Long.valueOf(n));\n    while (n != 1) {\n      if ((n & 1) == 0)\n        n = n / 2;\n      else\n        n = 3 * n + 1;\n      list.add(Long.valueOf(n));\n    }\n    return list;\n  }\n  \n  public static void main(String[] args) {\n    List<Long> sequence27 = getHailstoneSequence(27);\n    System.out.println(\"Sequence for 27 has \" + sequence27.size() + \" elements: \" + sequence27);\n    \n    long MAX = 100000;\n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = getHailstoneSequence(i).size();\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 1, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = 1;\n        long n = i;\n        while (n != 1) {\n          if ((n & 1) == 0)\n            n = n / 2;\n          else\n            n = 3 * n + 1;\n          count++;\n        }\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 2, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      long highestCount = 1;\n      Map<Long, Integer> sequenceMap = new HashMap<Long, Integer>();\n      sequenceMap.put(Long.valueOf(1), Integer.valueOf(1));\n      \n      List<Long> currentList = new ArrayList<Long>();\n      for (long i = 2; i < MAX; i++) {\n        currentList.clear();\n        Long n = Long.valueOf(i);\n        Integer count = null;\n        while ((count = sequenceMap.get(n)) == null) {\n          currentList.add(n);\n          long nValue = n.longValue();\n          if ((nValue & 1) == 0)\n            n = Long.valueOf(nValue / 2);\n          else\n            n = Long.valueOf(3 * nValue + 1);\n        }\n        int curCount = count.intValue();\n        for (int j = currentList.size() - 1; j >= 0; j--)\n          sequenceMap.put(currentList.get(j), Integer.valueOf(++curCount));\n        if (curCount > highestCount) {\n          highestCount = curCount;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 3, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    return;\n  }\n}\n"}
{"id": 11500, "name": "Hailstone sequence", "source": "Translate COBOL to Python:        identification division.\n       program-id. hailstones.\n       remarks. cobc -x hailstones.cob.\n\n       data division.\n       working-storage section.\n       01 most                 constant as 1000000.\n       01 coverage             constant as 100000.       \n       01 stones               usage binary-long.\n       01 n                    usage binary-long.\n       01 storm                usage binary-long.\n\n       01 show-arg             pic 9(6).\n       01 show-default         pic 99 value 27.\n       01 show-sequence        usage binary-long.\n       01 longest              usage binary-long occurs 2 times.\n\n       01 filler.\n          05 hail              usage binary-long\n                               occurs 0 to most depending on stones.\n       01 show                 pic z(10).\n       01 low-range            usage binary-long.\n       01 high-range           usage binary-long.\n       01 range                usage binary-long.\n        \n\n       01 remain               usage binary-long.\n       01 unused               usage binary-long.\n\n       procedure division.\n       accept show-arg from command-line\n       if show-arg less than 1 or greater than coverage then\n           move show-default to show-arg\n       end-if\n       move show-arg to show-sequence\n\n       move 1 to longest(1)\n       perform hailstone varying storm\n                         from 1 by 1 until storm > coverage\n       display \"Longest at: \" longest(2) \" with \" longest(1) \" elements\"\n       goback.\n\n      \n       hailstone.\n       move 0 to stones\n       move storm to n\n       perform until n equal 1\n           if stones > most then\n               display \"too many hailstones\" upon syserr\n               stop run\n           end-if\n\n           add 1 to stones\n           move n to hail(stones)\n           divide n by 2 giving unused remainder remain\n           if remain equal 0 then\n               divide 2 into n\n           else\n               compute n = 3 * n + 1\n           end-if\n       end-perform\n       add 1 to stones\n       move n to hail(stones)\n\n       if stones > longest(1) then\n           move stones to longest(1)\n           move storm to longest(2)\n       end-if\n\n       if storm equal show-sequence then\n           display show-sequence \": \" with no advancing\n           perform varying range from 1 by 1 until range > stones\n               move 5 to low-range\n               compute high-range = stones - 4\n               if range < low-range or range > high-range then\n                   move hail(range) to show\n                   display function trim(show) with no advancing\n                   if range < stones then\n                       display \", \" with no advancing\n                   end-if\n               end-if\n               if range = low-range and stones > 8 then\n                   display \"..., \" with no advancing\n               end-if\n           end-perform\n           display \": \" stones \" elements\"\n       end-if\n       .\n\n       end program hailstones.\n", "target": "def hailstone(n):\n    seq = [n]\n    while n > 1:\n        n = 3 * n + 1 if n & 1 else n // 2\n        seq.append(n)\n    return seq\n\n\nif __name__ == '__main__':\n    h = hailstone(27)\n    assert (len(h) == 112\n            and h[:4] == [27, 82, 41, 124]\n            and h[-4:] == [8, 4, 2, 1])\n    max_length, n = max((len(hailstone(i)), i) for i in range(1, 100_000))\n    print(f\"Maximum length {max_length} was found for hailstone({n}) \"\n          f\"for numbers <100,000\")\n"}
{"id": 11501, "name": "Hailstone sequence", "source": "Translate COBOL to Python:        identification division.\n       program-id. hailstones.\n       remarks. cobc -x hailstones.cob.\n\n       data division.\n       working-storage section.\n       01 most                 constant as 1000000.\n       01 coverage             constant as 100000.       \n       01 stones               usage binary-long.\n       01 n                    usage binary-long.\n       01 storm                usage binary-long.\n\n       01 show-arg             pic 9(6).\n       01 show-default         pic 99 value 27.\n       01 show-sequence        usage binary-long.\n       01 longest              usage binary-long occurs 2 times.\n\n       01 filler.\n          05 hail              usage binary-long\n                               occurs 0 to most depending on stones.\n       01 show                 pic z(10).\n       01 low-range            usage binary-long.\n       01 high-range           usage binary-long.\n       01 range                usage binary-long.\n        \n\n       01 remain               usage binary-long.\n       01 unused               usage binary-long.\n\n       procedure division.\n       accept show-arg from command-line\n       if show-arg less than 1 or greater than coverage then\n           move show-default to show-arg\n       end-if\n       move show-arg to show-sequence\n\n       move 1 to longest(1)\n       perform hailstone varying storm\n                         from 1 by 1 until storm > coverage\n       display \"Longest at: \" longest(2) \" with \" longest(1) \" elements\"\n       goback.\n\n      \n       hailstone.\n       move 0 to stones\n       move storm to n\n       perform until n equal 1\n           if stones > most then\n               display \"too many hailstones\" upon syserr\n               stop run\n           end-if\n\n           add 1 to stones\n           move n to hail(stones)\n           divide n by 2 giving unused remainder remain\n           if remain equal 0 then\n               divide 2 into n\n           else\n               compute n = 3 * n + 1\n           end-if\n       end-perform\n       add 1 to stones\n       move n to hail(stones)\n\n       if stones > longest(1) then\n           move stones to longest(1)\n           move storm to longest(2)\n       end-if\n\n       if storm equal show-sequence then\n           display show-sequence \": \" with no advancing\n           perform varying range from 1 by 1 until range > stones\n               move 5 to low-range\n               compute high-range = stones - 4\n               if range < low-range or range > high-range then\n                   move hail(range) to show\n                   display function trim(show) with no advancing\n                   if range < stones then\n                       display \", \" with no advancing\n                   end-if\n               end-if\n               if range = low-range and stones > 8 then\n                   display \"..., \" with no advancing\n               end-if\n           end-perform\n           display \": \" stones \" elements\"\n       end-if\n       .\n\n       end program hailstones.\n", "target": "def hailstone(n):\n    seq = [n]\n    while n > 1:\n        n = 3 * n + 1 if n & 1 else n // 2\n        seq.append(n)\n    return seq\n\n\nif __name__ == '__main__':\n    h = hailstone(27)\n    assert (len(h) == 112\n            and h[:4] == [27, 82, 41, 124]\n            and h[-4:] == [8, 4, 2, 1])\n    max_length, n = max((len(hailstone(i)), i) for i in range(1, 100_000))\n    print(f\"Maximum length {max_length} was found for hailstone({n}) \"\n          f\"for numbers <100,000\")\n"}
{"id": 12965, "name": "Hello world_Newline omission", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. GOODBYE-WORLD.\n\nPROCEDURE DIVISION.\nDISPLAY 'Goodbye, World!'\n    WITH NO ADVANCING\nEND-DISPLAY\n.\nSTOP RUN.\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        Console.WriteLine(\"Goodbye, World!\");\n\n        \n        Console.Write(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 12967, "name": "Hello world_Newline omission", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. GOODBYE-WORLD.\n\nPROCEDURE DIVISION.\nDISPLAY 'Goodbye, World!'\n    WITH NO ADVANCING\nEND-DISPLAY\n.\nSTOP RUN.\n", "target": "public class HelloWorld\n{\n public static void main(String[] args)\n {\n  System.out.print(\"Goodbye, World!\");\n }\n}\n"}
{"id": 12968, "name": "Hello world_Newline omission", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. GOODBYE-WORLD.\n\nPROCEDURE DIVISION.\nDISPLAY 'Goodbye, World!'\n    WITH NO ADVANCING\nEND-DISPLAY\n.\nSTOP RUN.\n", "target": "import sys\nsys.stdout.write(\"Goodbye, World!\")\n"}
{"id": 13699, "name": "Hello world_Standard error", "source": "Translate COBOL to C#: \tprogram-id. ehello.\n\tprocedure division.\n\t\tdisplay \"Goodbye, world!\"  upon syserr.\n\t\tstop run.\n", "target": "static class StdErr\n{\n    static void Main(string[] args)\n    {\n        Console.Error.WriteLine(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 13701, "name": "Hello world_Standard error", "source": "Translate COBOL to Java: \tprogram-id. ehello.\n\tprocedure division.\n\t\tdisplay \"Goodbye, world!\"  upon syserr.\n\t\tstop run.\n", "target": "public class Err{\n   public static void main(String[] args){\n      System.err.println(\"Goodbye, World!\");\n   }\n}\n"}
{"id": 13702, "name": "Hello world_Standard error", "source": "Translate COBOL to Python: \tprogram-id. ehello.\n\tprocedure division.\n\t\tdisplay \"Goodbye, world!\"  upon syserr.\n\t\tstop run.\n", "target": "import sys\n\nprint >> sys.stderr, \"Goodbye, World!\"\n"}
{"id": 13910, "name": "SEDOLs", "source": "Translate COBOL to C#:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. sedol.\n\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT sedol-file ASSIGN \"sedol.txt\"\n        ORGANIZATION LINE SEQUENTIAL\n        FILE STATUS sedol-file-status.\n\nDATA DIVISION.\nFILE SECTION.\nFD  sedol-file.\n01  sedol                               PIC X(6).\n\nWORKING-STORAGE SECTION.\n01  sedol-file-status                   PIC XX.\n    88  sedol-file-ok                   VALUE \"00\".\n\n01  digit-num                           PIC 9 COMP.\n    \n01  digit-weights-area                  VALUE \"1317391\".\n    03  digit-weights                   PIC 9 OCCURS 7 TIMES.\n    \n01  weighted-sum-parts-area.\n    03  weighted-sum-parts              PIC 9(3) COMP OCCURS 6 TIMES.\n\n01  weighted-sum                        PIC 9(3) COMP.\n\n01  check-digit                         PIC 9.\n\nPROCEDURE DIVISION.\n    OPEN INPUT sedol-file\n    PERFORM UNTIL NOT sedol-file-ok\n        READ sedol-file\n            AT END\n                EXIT PERFORM\n        END-READ\n\n        MOVE FUNCTION UPPER-CASE(sedol) TO sedol\n        \n        PERFORM VARYING digit-num FROM 1 BY 1 UNTIL digit-num > 6\n            EVALUATE TRUE\n                WHEN sedol (digit-num:1) IS ALPHABETIC-UPPER\n                    IF sedol (digit-num:1) = \"A\" OR \"E\" OR \"I\" OR \"O\" OR \"U\"\n                        DISPLAY \"Invalid SEDOL: \" sedol\n                        EXIT PERFORM CYCLE\n                    END-IF\n                \n                    COMPUTE weighted-sum-parts (digit-num) =\n                        (FUNCTION ORD(sedol (digit-num:1)) - FUNCTION ORD(\"A\")\n                        + 10) * digit-weights (digit-num)\n                        \n                WHEN sedol (digit-num:1) IS NUMERIC\n                    MULTIPLY FUNCTION NUMVAL(sedol (digit-num:1))\n                        BY digit-weights (digit-num)\n                        GIVING weighted-sum-parts (digit-num)\n                        \n                WHEN OTHER\n                    DISPLAY \"Invalid SEDOL: \" sedol\n                    EXIT PERFORM CYCLE\n            END-EVALUATE\n        END-PERFORM\n\n        INITIALIZE weighted-sum\n        PERFORM VARYING digit-num FROM 1 BY 1 UNTIL digit-num > 6\n            ADD weighted-sum-parts (digit-num) TO weighted-sum\n        END-PERFORM\n        \n        COMPUTE check-digit =\n            FUNCTION MOD(10 - FUNCTION MOD(weighted-sum, 10), 10)\n\n        DISPLAY sedol check-digit\n    END-PERFORM\n    \n    CLOSE sedol-file\n    .\nEND PROGRAM sedol.\n", "target": "static int[] sedol_weights = { 1, 3, 1, 7, 3, 9 };\nstatic int sedolChecksum(string sedol)\n{\n    int len = sedol.Length;\n    int sum = 0;\n\n    if (len == 7) \n        return (int)sedol[6];\n\n    if ((len > 7) || (len < 6) || System.Text.RegularExpressions.Regex.IsMatch(sedol, \"[AEIOUaeiou]+\")) \n        return -1;\n\n    for (int i = 0; i < 6; i++)\n    {\n        if (Char.IsDigit(sedol[i]))\n            sum += (((int)sedol[i] - 48) * sedol_weights[i]);\n\n        else if (Char.IsLetter(sedol[i]))\n            sum += (((int)Char.ToUpper(sedol[i]) - 55) * sedol_weights[i]);\n\n        else\n            return -1;\n\n    }\n\n    return (10 - (sum % 10)) % 10;\n}\n"}
{"id": 13912, "name": "SEDOLs", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. sedol.\n\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT sedol-file ASSIGN \"sedol.txt\"\n        ORGANIZATION LINE SEQUENTIAL\n        FILE STATUS sedol-file-status.\n\nDATA DIVISION.\nFILE SECTION.\nFD  sedol-file.\n01  sedol                               PIC X(6).\n\nWORKING-STORAGE SECTION.\n01  sedol-file-status                   PIC XX.\n    88  sedol-file-ok                   VALUE \"00\".\n\n01  digit-num                           PIC 9 COMP.\n    \n01  digit-weights-area                  VALUE \"1317391\".\n    03  digit-weights                   PIC 9 OCCURS 7 TIMES.\n    \n01  weighted-sum-parts-area.\n    03  weighted-sum-parts              PIC 9(3) COMP OCCURS 6 TIMES.\n\n01  weighted-sum                        PIC 9(3) COMP.\n\n01  check-digit                         PIC 9.\n\nPROCEDURE DIVISION.\n    OPEN INPUT sedol-file\n    PERFORM UNTIL NOT sedol-file-ok\n        READ sedol-file\n            AT END\n                EXIT PERFORM\n        END-READ\n\n        MOVE FUNCTION UPPER-CASE(sedol) TO sedol\n        \n        PERFORM VARYING digit-num FROM 1 BY 1 UNTIL digit-num > 6\n            EVALUATE TRUE\n                WHEN sedol (digit-num:1) IS ALPHABETIC-UPPER\n                    IF sedol (digit-num:1) = \"A\" OR \"E\" OR \"I\" OR \"O\" OR \"U\"\n                        DISPLAY \"Invalid SEDOL: \" sedol\n                        EXIT PERFORM CYCLE\n                    END-IF\n                \n                    COMPUTE weighted-sum-parts (digit-num) =\n                        (FUNCTION ORD(sedol (digit-num:1)) - FUNCTION ORD(\"A\")\n                        + 10) * digit-weights (digit-num)\n                        \n                WHEN sedol (digit-num:1) IS NUMERIC\n                    MULTIPLY FUNCTION NUMVAL(sedol (digit-num:1))\n                        BY digit-weights (digit-num)\n                        GIVING weighted-sum-parts (digit-num)\n                        \n                WHEN OTHER\n                    DISPLAY \"Invalid SEDOL: \" sedol\n                    EXIT PERFORM CYCLE\n            END-EVALUATE\n        END-PERFORM\n\n        INITIALIZE weighted-sum\n        PERFORM VARYING digit-num FROM 1 BY 1 UNTIL digit-num > 6\n            ADD weighted-sum-parts (digit-num) TO weighted-sum\n        END-PERFORM\n        \n        COMPUTE check-digit =\n            FUNCTION MOD(10 - FUNCTION MOD(weighted-sum, 10), 10)\n\n        DISPLAY sedol check-digit\n    END-PERFORM\n    \n    CLOSE sedol-file\n    .\nEND PROGRAM sedol.\n", "target": "import java.util.Scanner;\n\npublic class SEDOL{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString sedol = sc.next();\n\t\t\tSystem.out.println(sedol + getSedolCheckDigit(sedol));\n\t\t}\n\t}\n\t\n\tprivate static final int[] mult = {1, 3, 1, 7, 3, 9};\n\t\n\tpublic static int getSedolCheckDigit(String str){\n\t    if(!validateSedol(str)){\n\t    \tSystem.err.println(\"SEDOL strings must contain six characters with no vowels.\");\n\t    \treturn -1;\n\t    }\n\t    str = str.toUpperCase();\n\t    int total = 0;\n\t    for(int i = 0;i < 6; i++){\n\t        char s = str.charAt(i);\n\t        total += Character.digit(s, 36) * mult[i];\n\t    }\n\t    return (10 - (total % 10)) % 10;\n\t}\n\n\tpublic static boolean validateSedol(String str){\n\t\treturn (str.length() == 6) && !str.toUpperCase().matches(\".*?[AEIOU].*?\");\n\t}\n}\n"}
{"id": 13913, "name": "SEDOLs", "source": "Translate COBOL to Python:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. sedol.\n\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT sedol-file ASSIGN \"sedol.txt\"\n        ORGANIZATION LINE SEQUENTIAL\n        FILE STATUS sedol-file-status.\n\nDATA DIVISION.\nFILE SECTION.\nFD  sedol-file.\n01  sedol                               PIC X(6).\n\nWORKING-STORAGE SECTION.\n01  sedol-file-status                   PIC XX.\n    88  sedol-file-ok                   VALUE \"00\".\n\n01  digit-num                           PIC 9 COMP.\n    \n01  digit-weights-area                  VALUE \"1317391\".\n    03  digit-weights                   PIC 9 OCCURS 7 TIMES.\n    \n01  weighted-sum-parts-area.\n    03  weighted-sum-parts              PIC 9(3) COMP OCCURS 6 TIMES.\n\n01  weighted-sum                        PIC 9(3) COMP.\n\n01  check-digit                         PIC 9.\n\nPROCEDURE DIVISION.\n    OPEN INPUT sedol-file\n    PERFORM UNTIL NOT sedol-file-ok\n        READ sedol-file\n            AT END\n                EXIT PERFORM\n        END-READ\n\n        MOVE FUNCTION UPPER-CASE(sedol) TO sedol\n        \n        PERFORM VARYING digit-num FROM 1 BY 1 UNTIL digit-num > 6\n            EVALUATE TRUE\n                WHEN sedol (digit-num:1) IS ALPHABETIC-UPPER\n                    IF sedol (digit-num:1) = \"A\" OR \"E\" OR \"I\" OR \"O\" OR \"U\"\n                        DISPLAY \"Invalid SEDOL: \" sedol\n                        EXIT PERFORM CYCLE\n                    END-IF\n                \n                    COMPUTE weighted-sum-parts (digit-num) =\n                        (FUNCTION ORD(sedol (digit-num:1)) - FUNCTION ORD(\"A\")\n                        + 10) * digit-weights (digit-num)\n                        \n                WHEN sedol (digit-num:1) IS NUMERIC\n                    MULTIPLY FUNCTION NUMVAL(sedol (digit-num:1))\n                        BY digit-weights (digit-num)\n                        GIVING weighted-sum-parts (digit-num)\n                        \n                WHEN OTHER\n                    DISPLAY \"Invalid SEDOL: \" sedol\n                    EXIT PERFORM CYCLE\n            END-EVALUATE\n        END-PERFORM\n\n        INITIALIZE weighted-sum\n        PERFORM VARYING digit-num FROM 1 BY 1 UNTIL digit-num > 6\n            ADD weighted-sum-parts (digit-num) TO weighted-sum\n        END-PERFORM\n        \n        COMPUTE check-digit =\n            FUNCTION MOD(10 - FUNCTION MOD(weighted-sum, 10), 10)\n\n        DISPLAY sedol check-digit\n    END-PERFORM\n    \n    CLOSE sedol-file\n    .\nEND PROGRAM sedol.\n", "target": "def char2value(c):\n  assert c not in 'AEIOU', \"No vowels\"\n  return int(c, 36)\n\nsedolweight = [1,3,1,7,3,9]\n\ndef checksum(sedol):\n    tmp = sum(map(lambda ch, weight: char2value(ch) * weight,\n                  sedol, sedolweight)\n               )\n    return str((10 - (tmp % 10)) % 10)\n\nfor sedol in .split():\n    print sedol + checksum(sedol)\n"}
{"id": 14566, "name": "Create a file", "source": "Translate COBOL to C#:        identification division.\n       program-id. create-a-file.\n\n       data division.\n       working-storage section.\n       01 skip                 pic 9 value 2.\n       01 file-name.\n          05 value \"/output.txt\".\n       01 dir-name.\n          05 value \"/docs\".\n       01 file-handle          usage binary-long.\n\n       procedure division.\n       files-main.\n\n      \n       perform create-file-and-dir\n\n      \n       move 1 to skip\n       perform create-file-and-dir\n\n       goback.\n\n       create-file-and-dir.\n      \n       call \"CBL_CREATE_FILE\" using file-name(skip:) 3 0 0 file-handle\n       if return-code not equal 0 then\n           display \"error: CBL_CREATE_FILE \" file-name(skip:) \": \"\n                   file-handle \", \" return-code upon syserr\n       end-if\n\n      \n       call \"CBL_CREATE_DIR\" using dir-name(skip:)\n       if return-code not equal 0 then\n           display \"error: CBL_CREATE_DIR \" dir-name(skip:) \": \"\n                   return-code upon syserr\n       end-if\n       .\n\n       end program create-a-file.\n", "target": "using System;\nusing System.IO;\n\nclass Program {\n    static void Main(string[] args) {\n        File.Create(\"output.txt\");\n        File.Create(@\"\\output.txt\");\n\n        Directory.CreateDirectory(\"docs\");\n        Directory.CreateDirectory(@\"\\docs\");\n    }\n}\n"}
{"id": 14568, "name": "Create a file", "source": "Translate COBOL to Java:        identification division.\n       program-id. create-a-file.\n\n       data division.\n       working-storage section.\n       01 skip                 pic 9 value 2.\n       01 file-name.\n          05 value \"/output.txt\".\n       01 dir-name.\n          05 value \"/docs\".\n       01 file-handle          usage binary-long.\n\n       procedure division.\n       files-main.\n\n      \n       perform create-file-and-dir\n\n      \n       move 1 to skip\n       perform create-file-and-dir\n\n       goback.\n\n       create-file-and-dir.\n      \n       call \"CBL_CREATE_FILE\" using file-name(skip:) 3 0 0 file-handle\n       if return-code not equal 0 then\n           display \"error: CBL_CREATE_FILE \" file-name(skip:) \": \"\n                   file-handle \", \" return-code upon syserr\n       end-if\n\n      \n       call \"CBL_CREATE_DIR\" using dir-name(skip:)\n       if return-code not equal 0 then\n           display \"error: CBL_CREATE_DIR \" dir-name(skip:) \": \"\n                   return-code upon syserr\n       end-if\n       .\n\n       end program create-a-file.\n", "target": "import java.io.*;\npublic class CreateFileTest {\n\tpublic static void main(String args[]) {\n\t\ttry {\n\t\t\tnew File(\"output.txt\").createNewFile();\n\t\t\tnew File(File.separator + \"output.txt\").createNewFile();\n\t\t\tnew File(\"docs\").mkdir();\n\t\t\tnew File(File.separator + \"docs\").mkdir();\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t}\n\t}\n}\n"}
{"id": 14569, "name": "Create a file", "source": "Translate COBOL to Python:        identification division.\n       program-id. create-a-file.\n\n       data division.\n       working-storage section.\n       01 skip                 pic 9 value 2.\n       01 file-name.\n          05 value \"/output.txt\".\n       01 dir-name.\n          05 value \"/docs\".\n       01 file-handle          usage binary-long.\n\n       procedure division.\n       files-main.\n\n      \n       perform create-file-and-dir\n\n      \n       move 1 to skip\n       perform create-file-and-dir\n\n       goback.\n\n       create-file-and-dir.\n      \n       call \"CBL_CREATE_FILE\" using file-name(skip:) 3 0 0 file-handle\n       if return-code not equal 0 then\n           display \"error: CBL_CREATE_FILE \" file-name(skip:) \": \"\n                   file-handle \", \" return-code upon syserr\n       end-if\n\n      \n       call \"CBL_CREATE_DIR\" using dir-name(skip:)\n       if return-code not equal 0 then\n           display \"error: CBL_CREATE_DIR \" dir-name(skip:) \": \"\n                   return-code upon syserr\n       end-if\n       .\n\n       end program create-a-file.\n", "target": "import os\nfor directory in ['/', './']:\n  open(directory + 'output.txt', 'w').close()  \n  os.mkdir(directory + 'docs')                 \n"}
{"id": 15003, "name": "Almost prime", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ALMOST-PRIME.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 CONTROL-VARS.\n          03 K              PIC 9.\n          03 I              PIC 999.\n          03 SEEN           PIC 99.\n          03 N              PIC 999.\n          03 P              PIC 99.\n          03 P-SQUARED      PIC 9(4).\n          03 F              PIC 99.\n          03 N-DIV-P        PIC 999V999.\n          03 FILLER         REDEFINES N-DIV-P.\n             05 NEXT-N      PIC 999.\n             05 FILLER      PIC 999.\n                88 N-DIVS-P VALUE ZERO.\n          \n       01 OUT-VARS.\n          03 K-LN           PIC X(70).\n          03 K-LN-PTR       PIC 99.\n          03 LN-HDR.\n             05 FILLER      PIC X(4) VALUE \"K = \".\n             05 K-OUT       PIC 9.\n             05 FILLER      PIC X VALUE \":\".\n          03 I-FMT.\n             05 FILLER      PIC X VALUE SPACE.\n             05 I-OUT       PIC ZZ9.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM K-ALMOST-PRIMES VARYING K FROM 1 BY 1\n               UNTIL K IS GREATER THAN 5.\n           STOP RUN.\n           \n       K-ALMOST-PRIMES.\n           MOVE SPACES TO K-LN.\n           MOVE 1 TO K-LN-PTR.\n           MOVE ZERO TO SEEN.\n           MOVE K TO K-OUT.\n           STRING LN-HDR DELIMITED BY SIZE INTO K-LN \n               WITH POINTER K-LN-PTR.\n           PERFORM I-K-ALMOST-PRIME VARYING I FROM 2 BY 1\n               UNTIL SEEN IS EQUAL TO 10.\n           DISPLAY K-LN.\n       \n       I-K-ALMOST-PRIME.\n           MOVE ZERO TO F, P-SQUARED.\n           MOVE I TO N.\n           PERFORM PRIME-FACTOR VARYING P FROM 2 BY 1\n               UNTIL F IS NOT LESS THAN K \n               OR P-SQUARED IS GREATER THAN N. \n           IF N IS GREATER THAN 1, ADD 1 TO F.\n           IF F IS EQUAL TO K,\n               MOVE I TO I-OUT,\n               ADD 1 TO SEEN,\n               STRING I-FMT DELIMITED BY SIZE INTO K-LN\n                   WITH POINTER K-LN-PTR.\n       \n       PRIME-FACTOR.\n           MULTIPLY P BY P GIVING P-SQUARED.\n           DIVIDE N BY P GIVING N-DIV-P.\n           PERFORM DIVIDE-FACTOR UNTIL NOT N-DIVS-P.\n           \n       DIVIDE-FACTOR.\n           MOVE NEXT-N TO N.\n           ADD 1 TO F.\n           DIVIDE N BY P GIVING N-DIV-P.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AlmostPrime\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            foreach (int k in Enumerable.Range(1, 5))\n            {\n                KPrime kprime = new KPrime() { K = k };\n                Console.WriteLine(\"k = {0}: {1}\",\n                    k, string.Join<int>(\" \", kprime.GetFirstN(10)));\n            }\n        }\n    }\n\n    class KPrime\n    {\n        public int K { get; set; }\n\n        public bool IsKPrime(int number)\n        {\n            int primes = 0;\n            for (int p = 2; p * p <= number && primes < K; ++p)\n            {\n                while (number % p == 0 && primes < K)\n                {\n                    number /= p;\n                    ++primes;\n                }\n            }\n            if (number > 1)\n            {\n                ++primes;\n            }\n            return primes == K;\n        }\n\n        public List<int> GetFirstN(int n)\n        {\n            List<int> result = new List<int>();\n            for (int number = 2; result.Count < n; ++number)\n            {\n                if (IsKPrime(number))\n                {\n                    result.Add(number);\n                }\n            }\n            return result;\n        }\n    }\n}\n"}
{"id": 15005, "name": "Almost prime", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ALMOST-PRIME.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 CONTROL-VARS.\n          03 K              PIC 9.\n          03 I              PIC 999.\n          03 SEEN           PIC 99.\n          03 N              PIC 999.\n          03 P              PIC 99.\n          03 P-SQUARED      PIC 9(4).\n          03 F              PIC 99.\n          03 N-DIV-P        PIC 999V999.\n          03 FILLER         REDEFINES N-DIV-P.\n             05 NEXT-N      PIC 999.\n             05 FILLER      PIC 999.\n                88 N-DIVS-P VALUE ZERO.\n          \n       01 OUT-VARS.\n          03 K-LN           PIC X(70).\n          03 K-LN-PTR       PIC 99.\n          03 LN-HDR.\n             05 FILLER      PIC X(4) VALUE \"K = \".\n             05 K-OUT       PIC 9.\n             05 FILLER      PIC X VALUE \":\".\n          03 I-FMT.\n             05 FILLER      PIC X VALUE SPACE.\n             05 I-OUT       PIC ZZ9.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM K-ALMOST-PRIMES VARYING K FROM 1 BY 1\n               UNTIL K IS GREATER THAN 5.\n           STOP RUN.\n           \n       K-ALMOST-PRIMES.\n           MOVE SPACES TO K-LN.\n           MOVE 1 TO K-LN-PTR.\n           MOVE ZERO TO SEEN.\n           MOVE K TO K-OUT.\n           STRING LN-HDR DELIMITED BY SIZE INTO K-LN \n               WITH POINTER K-LN-PTR.\n           PERFORM I-K-ALMOST-PRIME VARYING I FROM 2 BY 1\n               UNTIL SEEN IS EQUAL TO 10.\n           DISPLAY K-LN.\n       \n       I-K-ALMOST-PRIME.\n           MOVE ZERO TO F, P-SQUARED.\n           MOVE I TO N.\n           PERFORM PRIME-FACTOR VARYING P FROM 2 BY 1\n               UNTIL F IS NOT LESS THAN K \n               OR P-SQUARED IS GREATER THAN N. \n           IF N IS GREATER THAN 1, ADD 1 TO F.\n           IF F IS EQUAL TO K,\n               MOVE I TO I-OUT,\n               ADD 1 TO SEEN,\n               STRING I-FMT DELIMITED BY SIZE INTO K-LN\n                   WITH POINTER K-LN-PTR.\n       \n       PRIME-FACTOR.\n           MULTIPLY P BY P GIVING P-SQUARED.\n           DIVIDE N BY P GIVING N-DIV-P.\n           PERFORM DIVIDE-FACTOR UNTIL NOT N-DIVS-P.\n           \n       DIVIDE-FACTOR.\n           MOVE NEXT-N TO N.\n           ADD 1 TO F.\n           DIVIDE N BY P GIVING N-DIV-P.\n", "target": "public class AlmostPrime {\n    public static void main(String[] args) {\n        for (int k = 1; k <= 5; k++) {\n            System.out.print(\"k = \" + k + \":\");\n\n            for (int i = 2, c = 0; c < 10; i++) {\n                if (kprime(i, k)) {\n                    System.out.print(\" \" + i);\n                    c++;\n                }\n            }\n\n            System.out.println(\"\");\n        }\n    }\n\n    public static boolean kprime(int n, int k) {\n        int f = 0;\n        for (int p = 2; f < k && p * p <= n; p++) {\n            while (n % p == 0) {\n                n /= p;\n                f++;\n            }\n        }\n        return f + ((n > 1) ? 1 : 0) == k;\n    }\n}\n"}
{"id": 15006, "name": "Almost prime", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ALMOST-PRIME.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 CONTROL-VARS.\n          03 K              PIC 9.\n          03 I              PIC 999.\n          03 SEEN           PIC 99.\n          03 N              PIC 999.\n          03 P              PIC 99.\n          03 P-SQUARED      PIC 9(4).\n          03 F              PIC 99.\n          03 N-DIV-P        PIC 999V999.\n          03 FILLER         REDEFINES N-DIV-P.\n             05 NEXT-N      PIC 999.\n             05 FILLER      PIC 999.\n                88 N-DIVS-P VALUE ZERO.\n          \n       01 OUT-VARS.\n          03 K-LN           PIC X(70).\n          03 K-LN-PTR       PIC 99.\n          03 LN-HDR.\n             05 FILLER      PIC X(4) VALUE \"K = \".\n             05 K-OUT       PIC 9.\n             05 FILLER      PIC X VALUE \":\".\n          03 I-FMT.\n             05 FILLER      PIC X VALUE SPACE.\n             05 I-OUT       PIC ZZ9.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM K-ALMOST-PRIMES VARYING K FROM 1 BY 1\n               UNTIL K IS GREATER THAN 5.\n           STOP RUN.\n           \n       K-ALMOST-PRIMES.\n           MOVE SPACES TO K-LN.\n           MOVE 1 TO K-LN-PTR.\n           MOVE ZERO TO SEEN.\n           MOVE K TO K-OUT.\n           STRING LN-HDR DELIMITED BY SIZE INTO K-LN \n               WITH POINTER K-LN-PTR.\n           PERFORM I-K-ALMOST-PRIME VARYING I FROM 2 BY 1\n               UNTIL SEEN IS EQUAL TO 10.\n           DISPLAY K-LN.\n       \n       I-K-ALMOST-PRIME.\n           MOVE ZERO TO F, P-SQUARED.\n           MOVE I TO N.\n           PERFORM PRIME-FACTOR VARYING P FROM 2 BY 1\n               UNTIL F IS NOT LESS THAN K \n               OR P-SQUARED IS GREATER THAN N. \n           IF N IS GREATER THAN 1, ADD 1 TO F.\n           IF F IS EQUAL TO K,\n               MOVE I TO I-OUT,\n               ADD 1 TO SEEN,\n               STRING I-FMT DELIMITED BY SIZE INTO K-LN\n                   WITH POINTER K-LN-PTR.\n       \n       PRIME-FACTOR.\n           MULTIPLY P BY P GIVING P-SQUARED.\n           DIVIDE N BY P GIVING N-DIV-P.\n           PERFORM DIVIDE-FACTOR UNTIL NOT N-DIVS-P.\n           \n       DIVIDE-FACTOR.\n           MOVE NEXT-N TO N.\n           ADD 1 TO F.\n           DIVIDE N BY P GIVING N-DIV-P.\n", "target": "from prime_decomposition import decompose\nfrom itertools import islice, count\ntry: \n    from functools import reduce\nexcept: \n    pass\n\n\ndef almostprime(n, k=2):\n    d = decompose(n)\n    try:\n        terms = [next(d) for i in range(k)]\n        return reduce(int.__mul__, terms, 1) == n\n    except:\n        return False\n\nif __name__ == '__main__':\n    for k in range(1,6):\n        print('%i: %r' % (k, list(islice((n for n in count() if almostprime(n, k)), 10))))\n"}
{"id": 15283, "name": "Integer comparison", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Compare.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A PIC 9(10).\n       01  B PIC 9(10).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"First number: \" WITH NO ADVANCING\n           ACCEPT A\n           DISPLAY \"Second number: \" WITH NO ADVANCING\n           ACCEPT B \n\n*          \n*          \n           IF A < B\n               DISPLAY A \" is less than \" B\n           ELSE IF A = B\n               DISPLAY A \" is equal to \" B\n           ELSE IF A > B\n               DISPLAY A \" is larger than \" B\n           END-IF.\n\n           GOBACK\n           .\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        int a = int.Parse(Console.ReadLine());\n        int b = int.Parse(Console.ReadLine());\n        if (a < b)\n            Console.WriteLine(\"{0} is less than {1}\", a, b);\n        if (a == b)\n            Console.WriteLine(\"{0} equals {1}\", a, b);\n        if (a > b)\n            Console.WriteLine(\"{0} is greater than {1}\", a, b);\n    }\n}\n"}
{"id": 15285, "name": "Integer comparison", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Compare.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A PIC 9(10).\n       01  B PIC 9(10).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"First number: \" WITH NO ADVANCING\n           ACCEPT A\n           DISPLAY \"Second number: \" WITH NO ADVANCING\n           ACCEPT B \n\n*          \n*          \n           IF A < B\n               DISPLAY A \" is less than \" B\n           ELSE IF A = B\n               DISPLAY A \" is equal to \" B\n           ELSE IF A > B\n               DISPLAY A \" is larger than \" B\n           END-IF.\n\n           GOBACK\n           .\n", "target": "import java.io.*;\n\npublic class compInt {\n   public static void main(String[] args) {\n       try {\n           BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n           int nbr1 = Integer.parseInt(in.readLine());\n           int nbr2 = Integer.parseInt(in.readLine());\n\n           if(nbr1<nbr2)\n               System.out.println(nbr1 + \" is less than \" + nbr2);\n\n           if(nbr1>nbr2)\n                System.out.println(nbr1 + \" is greater than \" + nbr2);\n\n           if(nbr1==nbr2)\n                System.out.println(nbr1 + \" is equal to \" + nbr2);\n       } catch(IOException e) { }\n   }\n}\n"}
{"id": 15286, "name": "Integer comparison", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Compare.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A PIC 9(10).\n       01  B PIC 9(10).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"First number: \" WITH NO ADVANCING\n           ACCEPT A\n           DISPLAY \"Second number: \" WITH NO ADVANCING\n           ACCEPT B \n\n*          \n*          \n           IF A < B\n               DISPLAY A \" is less than \" B\n           ELSE IF A = B\n               DISPLAY A \" is equal to \" B\n           ELSE IF A > B\n               DISPLAY A \" is larger than \" B\n           END-IF.\n\n           GOBACK\n           .\n", "target": "let a = input('Enter value of a: ')\nlet b = input('Enter value of b: ')\n\nif a < b:\n    print 'a is less than b'\nelif a > b:\n    print 'a is greater than b'\nelif a == b:\n    print 'a is equal to b'\n"}
{"id": 15499, "name": "Environment variables", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Environment-Vars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  home PIC X(75).\n\n       PROCEDURE DIVISION.\n*          \n           ACCEPT home FROM ENVIRONMENT \"HOME\"\n           DISPLAY home\n\n*          \n           DISPLAY \"HOME\" UPON ENVIRONMENT-NAME\n           ACCEPT home FROM ENVIRONMENT-VALUE\n\n           GOBACK\n           .\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main() {\n            string temp = Environment.GetEnvironmentVariable(\"TEMP\");\n            Console.WriteLine(\"TEMP is \" + temp);\n        }\n    }\n}\n"}
{"id": 15501, "name": "Environment variables", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Environment-Vars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  home PIC X(75).\n\n       PROCEDURE DIVISION.\n*          \n           ACCEPT home FROM ENVIRONMENT \"HOME\"\n           DISPLAY home\n\n*          \n           DISPLAY \"HOME\" UPON ENVIRONMENT-NAME\n           ACCEPT home FROM ENVIRONMENT-VALUE\n\n           GOBACK\n           .\n", "target": "System.getenv(\"HOME\") \nSystem.getenv()       \n"}
{"id": 15502, "name": "Environment variables", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Environment-Vars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  home PIC X(75).\n\n       PROCEDURE DIVISION.\n*          \n           ACCEPT home FROM ENVIRONMENT \"HOME\"\n           DISPLAY home\n\n*          \n           DISPLAY \"HOME\" UPON ENVIRONMENT-NAME\n           ACCEPT home FROM ENVIRONMENT-VALUE\n\n           GOBACK\n           .\n", "target": "import os\nos.environ['HOME']\n"}
{"id": 15746, "name": "Substring", "source": "Translate COBOL to C#:        identification division.\n       program-id. substring.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 original.\n          05 value \"this is a string\".\n       01 starting  pic 99 value 3.\n       01 width     pic 99 value 8.\n       01 pos       pic 99.\n       01 ender     pic 99.\n       01 looking   pic 99.\n       01 indicator pic x.\n          88 found  value high-value when set to false is low-value.\n       01 look-for  pic x(8).\n\n       procedure division.\n       substring-main.\n\n       display \"Original |\" original \"|, n = \" starting \" m = \" width\n       display original(starting : width)\n       display original(starting :)\n       display original(1 : length(original) - 1)\n\n       move \"a\" to look-for\n       move 1 to looking\n       perform find-position\n       if found\n           display original(pos : width)\n       end-if\n\n       move \"is a st\" to look-for\n       move length(trim(look-for)) to looking\n       perform find-position\n       if found\n           display original(pos : width)\n       end-if\n       goback.\n\n       find-position.\n       set found to false\n       compute ender = length(original) - looking\n       perform varying pos from 1 by 1 until pos > ender\n           if original(pos : looking) equal look-for then\n               set found to true\n               exit perform\n           end-if\n       end-perform\n       .\n\n       end program substring.\n", "target": "using System;\nnamespace SubString\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string s = \"0123456789\";\n            const int n = 3;\n            const int m = 2;\n            const char c = '3';\n            const string z = \"345\";\n\n            \n            Console.WriteLine(s.Substring(n, m));\n            \n            Console.WriteLine(s.Substring(n, s.Length - n));\n            \n            Console.WriteLine(s.Substring(0, s.Length - 1));\n            \n            Console.WriteLine(s.Substring(s.IndexOf(c), m));\n            \n            Console.WriteLine(s.Substring(s.IndexOf(z), m));\n        }\n    }\n}\n"}
{"id": 15748, "name": "Substring", "source": "Translate COBOL to Java:        identification division.\n       program-id. substring.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 original.\n          05 value \"this is a string\".\n       01 starting  pic 99 value 3.\n       01 width     pic 99 value 8.\n       01 pos       pic 99.\n       01 ender     pic 99.\n       01 looking   pic 99.\n       01 indicator pic x.\n          88 found  value high-value when set to false is low-value.\n       01 look-for  pic x(8).\n\n       procedure division.\n       substring-main.\n\n       display \"Original |\" original \"|, n = \" starting \" m = \" width\n       display original(starting : width)\n       display original(starting :)\n       display original(1 : length(original) - 1)\n\n       move \"a\" to look-for\n       move 1 to looking\n       perform find-position\n       if found\n           display original(pos : width)\n       end-if\n\n       move \"is a st\" to look-for\n       move length(trim(look-for)) to looking\n       perform find-position\n       if found\n           display original(pos : width)\n       end-if\n       goback.\n\n       find-position.\n       set found to false\n       compute ender = length(original) - looking\n       perform varying pos from 1 by 1 until pos > ender\n           if original(pos : looking) equal look-for then\n               set found to true\n               exit perform\n           end-if\n       end-perform\n       .\n\n       end program substring.\n", "target": "public static String Substring(String str, int n, int m){\n    return str.substring(n, n+m);\n}\npublic static String Substring(String str, int n){\n    return str.substring(n);\n}\npublic static String Substring(String str){\n    return str.substring(0, str.length()-1);\n}\npublic static String Substring(String str, char c, int m){\n    return str.substring(str.indexOf(c), str.indexOf(c)+m+1);\n}\npublic static String Substring(String str, String sub, int m){\n    return str.substring(str.indexOf(sub), str.indexOf(sub)+m+1);\n}\n"}
{"id": 15749, "name": "Substring", "source": "Translate COBOL to Python:        identification division.\n       program-id. substring.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 original.\n          05 value \"this is a string\".\n       01 starting  pic 99 value 3.\n       01 width     pic 99 value 8.\n       01 pos       pic 99.\n       01 ender     pic 99.\n       01 looking   pic 99.\n       01 indicator pic x.\n          88 found  value high-value when set to false is low-value.\n       01 look-for  pic x(8).\n\n       procedure division.\n       substring-main.\n\n       display \"Original |\" original \"|, n = \" starting \" m = \" width\n       display original(starting : width)\n       display original(starting :)\n       display original(1 : length(original) - 1)\n\n       move \"a\" to look-for\n       move 1 to looking\n       perform find-position\n       if found\n           display original(pos : width)\n       end-if\n\n       move \"is a st\" to look-for\n       move length(trim(look-for)) to looking\n       perform find-position\n       if found\n           display original(pos : width)\n       end-if\n       goback.\n\n       find-position.\n       set found to false\n       compute ender = length(original) - looking\n       perform varying pos from 1 by 1 until pos > ender\n           if original(pos : looking) equal look-for then\n               set found to true\n               exit perform\n           end-if\n       end-perform\n       .\n\n       end program substring.\n", "target": ">>> s = 'abcdefgh'\n>>> n, m, char, chars = 2, 3, 'd', 'cd'\n>>> \n>>> s[n-1:n+m-1]\n'bcd'\n>>> \n>>> s[n-1:]\n'bcdefgh'\n>>> \n>>> s[:-1]\n'abcdefg'\n>>> \n>>> indx = s.index(char)\n>>> s[indx:indx+m]\n'def'\n>>> \n>>> indx = s.index(chars)\n>>> s[indx:indx+m]\n'cde'\n>>>\n"}
{"id": 16241, "name": "Append a record to the end of a text file", "source": "Translate COBOL to C#:       \n      \n      \n      \n       identification division.\n       program-id. append.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select pass-file\n           assign to pass-filename\n           organization is line sequential\n           status is pass-status.\n\n       REPLACE ==:LRECL:== BY ==2048==.\n\n       data division.\n       file section.\n       fd pass-file record varying depending on pass-length.\n       01 fd-pass-record.\n          05 filler pic x occurs 0 to :LRECL: times\n                          depending on pass-length.\n\n       working-storage section.\n       01 pass-filename.\n          05 filler            value \"passfile\".\n       01 pass-status          pic xx.\n          88 ok-status         values '00' thru '09'.\n          88 eof-pass          value '10'.\n\n       01 pass-length          usage index.\n       01 total-length         usage index.\n\n       77 file-action          pic x(11).\n\n       01 pass-record.\n          05 account           pic x(64).\n             88 key-account    value \"xyz\".\n          05 password          pic x(64).\n          05 uid               pic z(4)9.\n          05 gid               pic z(4)9.\n          05 details.\n             10 fullname       pic x(128).\n             10 office         pic x(128).\n             10 extension      pic x(32).\n             10 homephone      pic x(32).\n             10 email          pic x(256).\n          05 homedir           pic x(256).\n          05 shell             pic x(256).\n\n       77 colon                pic x value \":\".\n       77 comma-mark           pic x value \",\".\n       77 newline              pic x value x\"0a\".\n\n      \n       procedure division.\n       main-routine.\n       perform initial-fill\n\n       >>IF DEBUG IS DEFINED \n       display \"Initial data:\"\n       perform show-records\n       >>END-IF\n\n       perform append-record\n \n       >>IF DEBUG IS DEFINED \n       display newline \"After append:\"\n       perform show-records\n       >>END-IF\n\n       perform verify-append\n       goback\n       .\n\n      \n       initial-fill.\n       perform open-output-pass-file\n\n       move \"jsmith\" to account\n       move \"x\" to password\n       move 1001 to uid\n       move 1000 to gid\n       move \"Joe Smith\" to fullname\n       move \"Room 1007\" to office\n       move \"(234)555-8917\" to extension\n       move \"(234)555-0077\" to homephone\n       move \"jsmith@rosettacode.org\" to email\n       move \"/home/jsmith\" to homedir\n       move \"/bin/bash\" to shell\n       perform write-pass-record\n\n       move \"jdoe\" to account\n       move \"x\" to password\n       move 1002 to uid\n       move 1000 to gid\n       move \"Jane Doe\" to fullname\n       move \"Room 1004\" to office\n       move \"(234)555-8914\" to extension\n       move \"(234)555-0044\" to homephone\n       move \"jdoe@rosettacode.org\" to email\n       move \"/home/jdoe\" to homedir\n       move \"/bin/bash\" to shell\n       perform write-pass-record\n\n       perform close-pass-file\n       .\n\n      \n       check-pass-file.\n       if not ok-status then\n           perform file-error\n       end-if\n       .\n\n      \n       check-pass-with-eof.\n       if not ok-status and not eof-pass then\n           perform file-error\n       end-if\n       .\n\n      \n       file-error.\n       display \"error \" file-action space pass-filename\n               space pass-status upon syserr\n       move 1 to return-code\n       goback\n       .\n\n      \n       append-record.\n       move \"xyz\" to account\n       move \"x\" to password\n       move 1003 to uid\n       move 1000 to gid\n       move \"X Yz\" to fullname\n       move \"Room 1003\" to office\n       move \"(234)555-8913\" to extension\n       move \"(234)555-0033\" to homephone\n       move \"xyz@rosettacode.org\" to email\n       move \"/home/xyz\" to homedir\n       move \"/bin/bash\" to shell\n\n       perform open-extend-pass-file\n       perform write-pass-record\n       perform close-pass-file\n       .\n\n      \n       open-output-pass-file.\n       open output pass-file with lock\n       move \"open output\" to file-action\n       perform check-pass-file\n       .\n\n      \n       open-extend-pass-file.\n       open extend pass-file with lock\n       move \"open extend\" to file-action\n       perform check-pass-file\n       .\n\n      \n       open-input-pass-file.\n       open input pass-file\n       move \"open input\" to file-action\n       perform check-pass-file\n       .\n\n      \n       close-pass-file.\n       close pass-file\n       move \"closing\" to file-action\n       perform check-pass-file\n       .\n\n      \n       write-pass-record.\n       set total-length to 1\n       set pass-length to :LRECL:\n       string\n           account delimited by space\n           colon\n           password delimited by space\n           colon\n           trim(uid leading) delimited by size\n           colon\n           trim(gid leading) delimited by size\n           colon\n           trim(fullname trailing) delimited by size\n           comma-mark\n           trim(office trailing) delimited by size\n           comma-mark\n           trim(extension trailing) delimited by size\n           comma-mark\n           trim(homephone trailing) delimited by size\n           comma-mark\n           email delimited by space\n           colon\n           trim(homedir trailing) delimited by size\n           colon\n           trim(shell trailing) delimited by size\n           into fd-pass-record with pointer total-length\n           on overflow\n               display \"error: fd-pass-record truncated at \"\n                       total-length upon syserr\n       end-string\n       set pass-length to total-length\n       set pass-length down by 1\n\n       write fd-pass-record\n       move \"writing\" to file-action\n       perform check-pass-file\n       .\n\n      \n       read-pass-file.\n       read pass-file\n       move \"reading\" to file-action\n       perform check-pass-with-eof\n       .\n\n      \n       show-records.\n       perform open-input-pass-file\n\n       perform read-pass-file\n       perform until eof-pass\n           perform show-pass-record\n           perform read-pass-file\n       end-perform\n\n       perform close-pass-file\n       .\n\n      \n       show-pass-record.\n       display fd-pass-record\n       .\n\n      \n       verify-append.\n       perform open-input-pass-file\n\n       move 0 to tally\n       perform read-pass-file\n       perform until eof-pass\n           add 1 to tally\n           unstring fd-pass-record delimited by colon\n               into account\n           if key-account then exit perform end-if\n           perform read-pass-file\n       end-perform\n       if (key-account and tally not > 2) or (not key-account) then\n           display\n               \"error: appended record not found in correct position\"\n              upon syserr\n       else\n           display \"Appended record: \" with no advancing\n           perform show-pass-record\n       end-if\n\n       perform close-pass-file\n       .\n\n       end program append.\n", "target": "using System;\nusing System.IO;\n\nnamespace AppendPwdRosetta\n{\n    class PasswordRecord\n    {\n        public string account, password, fullname, office, extension, homephone, email, directory, shell;\n        public int UID, GID;\n        public PasswordRecord(string account, string password, int UID, int GID, string fullname, string office, string extension, string homephone, \n            string email, string directory, string shell)\n        {\n            this.account = account; this.password = password; this.UID = UID; this.GID = GID; this.fullname = fullname; this.office = office;\n            this.extension = extension; this.homephone = homephone; this.email = email; this.directory = directory; this.shell = shell;\n        }\n        public override string ToString()\n        {\n            var gecos = string.Join(\",\", new string[] { fullname, office, extension, homephone, email });\n            return string.Join(\":\", new string[] { account, password, UID.ToString(), GID.ToString(), gecos, directory, shell });\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var jsmith = new PasswordRecord(\"jsmith\", \"x\", 1001, 1000, \"Joe Smith\", \"Room 1007\", \"(234)555-8917\", \"(234)555-0077\", \"jsmith@rosettacode.org\", \n                \"/home/jsmith\", \"/bin/bash\");\n            var jdoe = new PasswordRecord(\"jdoe\", \"x\", 1002, 1000, \"Jane Doe\", \"Room 1004\", \"(234)555-8914\", \"(234)555-0044\", \"jdoe@rosettacode.org\", \"/home/jdoe\", \n                \"/bin/bash\");\n            var xyz = new PasswordRecord(\"xyz\", \"x\", 1003, 1000, \"X Yz\", \"Room 1003\", \"(234)555-8913\", \"(234)555-0033\", \"xyz@rosettacode.org\", \"/home/xyz\", \"/bin/bash\");\n\n            \n            File.WriteAllLines(\"passwd.txt\", new string[] { jsmith.ToString(), jdoe.ToString() });\n\n            \n            File.AppendAllText(\"passwd.txt\", xyz.ToString());\n\n            \n            string[] lines = File.ReadAllLines(\"passwd.txt\");\n            Console.WriteLine(\"Appended record: \" + lines[2]);\n        }\n    }\n}\n"}
{"id": 16243, "name": "Append a record to the end of a text file", "source": "Translate COBOL to Java:       \n      \n      \n      \n       identification division.\n       program-id. append.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select pass-file\n           assign to pass-filename\n           organization is line sequential\n           status is pass-status.\n\n       REPLACE ==:LRECL:== BY ==2048==.\n\n       data division.\n       file section.\n       fd pass-file record varying depending on pass-length.\n       01 fd-pass-record.\n          05 filler pic x occurs 0 to :LRECL: times\n                          depending on pass-length.\n\n       working-storage section.\n       01 pass-filename.\n          05 filler            value \"passfile\".\n       01 pass-status          pic xx.\n          88 ok-status         values '00' thru '09'.\n          88 eof-pass          value '10'.\n\n       01 pass-length          usage index.\n       01 total-length         usage index.\n\n       77 file-action          pic x(11).\n\n       01 pass-record.\n          05 account           pic x(64).\n             88 key-account    value \"xyz\".\n          05 password          pic x(64).\n          05 uid               pic z(4)9.\n          05 gid               pic z(4)9.\n          05 details.\n             10 fullname       pic x(128).\n             10 office         pic x(128).\n             10 extension      pic x(32).\n             10 homephone      pic x(32).\n             10 email          pic x(256).\n          05 homedir           pic x(256).\n          05 shell             pic x(256).\n\n       77 colon                pic x value \":\".\n       77 comma-mark           pic x value \",\".\n       77 newline              pic x value x\"0a\".\n\n      \n       procedure division.\n       main-routine.\n       perform initial-fill\n\n       >>IF DEBUG IS DEFINED \n       display \"Initial data:\"\n       perform show-records\n       >>END-IF\n\n       perform append-record\n \n       >>IF DEBUG IS DEFINED \n       display newline \"After append:\"\n       perform show-records\n       >>END-IF\n\n       perform verify-append\n       goback\n       .\n\n      \n       initial-fill.\n       perform open-output-pass-file\n\n       move \"jsmith\" to account\n       move \"x\" to password\n       move 1001 to uid\n       move 1000 to gid\n       move \"Joe Smith\" to fullname\n       move \"Room 1007\" to office\n       move \"(234)555-8917\" to extension\n       move \"(234)555-0077\" to homephone\n       move \"jsmith@rosettacode.org\" to email\n       move \"/home/jsmith\" to homedir\n       move \"/bin/bash\" to shell\n       perform write-pass-record\n\n       move \"jdoe\" to account\n       move \"x\" to password\n       move 1002 to uid\n       move 1000 to gid\n       move \"Jane Doe\" to fullname\n       move \"Room 1004\" to office\n       move \"(234)555-8914\" to extension\n       move \"(234)555-0044\" to homephone\n       move \"jdoe@rosettacode.org\" to email\n       move \"/home/jdoe\" to homedir\n       move \"/bin/bash\" to shell\n       perform write-pass-record\n\n       perform close-pass-file\n       .\n\n      \n       check-pass-file.\n       if not ok-status then\n           perform file-error\n       end-if\n       .\n\n      \n       check-pass-with-eof.\n       if not ok-status and not eof-pass then\n           perform file-error\n       end-if\n       .\n\n      \n       file-error.\n       display \"error \" file-action space pass-filename\n               space pass-status upon syserr\n       move 1 to return-code\n       goback\n       .\n\n      \n       append-record.\n       move \"xyz\" to account\n       move \"x\" to password\n       move 1003 to uid\n       move 1000 to gid\n       move \"X Yz\" to fullname\n       move \"Room 1003\" to office\n       move \"(234)555-8913\" to extension\n       move \"(234)555-0033\" to homephone\n       move \"xyz@rosettacode.org\" to email\n       move \"/home/xyz\" to homedir\n       move \"/bin/bash\" to shell\n\n       perform open-extend-pass-file\n       perform write-pass-record\n       perform close-pass-file\n       .\n\n      \n       open-output-pass-file.\n       open output pass-file with lock\n       move \"open output\" to file-action\n       perform check-pass-file\n       .\n\n      \n       open-extend-pass-file.\n       open extend pass-file with lock\n       move \"open extend\" to file-action\n       perform check-pass-file\n       .\n\n      \n       open-input-pass-file.\n       open input pass-file\n       move \"open input\" to file-action\n       perform check-pass-file\n       .\n\n      \n       close-pass-file.\n       close pass-file\n       move \"closing\" to file-action\n       perform check-pass-file\n       .\n\n      \n       write-pass-record.\n       set total-length to 1\n       set pass-length to :LRECL:\n       string\n           account delimited by space\n           colon\n           password delimited by space\n           colon\n           trim(uid leading) delimited by size\n           colon\n           trim(gid leading) delimited by size\n           colon\n           trim(fullname trailing) delimited by size\n           comma-mark\n           trim(office trailing) delimited by size\n           comma-mark\n           trim(extension trailing) delimited by size\n           comma-mark\n           trim(homephone trailing) delimited by size\n           comma-mark\n           email delimited by space\n           colon\n           trim(homedir trailing) delimited by size\n           colon\n           trim(shell trailing) delimited by size\n           into fd-pass-record with pointer total-length\n           on overflow\n               display \"error: fd-pass-record truncated at \"\n                       total-length upon syserr\n       end-string\n       set pass-length to total-length\n       set pass-length down by 1\n\n       write fd-pass-record\n       move \"writing\" to file-action\n       perform check-pass-file\n       .\n\n      \n       read-pass-file.\n       read pass-file\n       move \"reading\" to file-action\n       perform check-pass-with-eof\n       .\n\n      \n       show-records.\n       perform open-input-pass-file\n\n       perform read-pass-file\n       perform until eof-pass\n           perform show-pass-record\n           perform read-pass-file\n       end-perform\n\n       perform close-pass-file\n       .\n\n      \n       show-pass-record.\n       display fd-pass-record\n       .\n\n      \n       verify-append.\n       perform open-input-pass-file\n\n       move 0 to tally\n       perform read-pass-file\n       perform until eof-pass\n           add 1 to tally\n           unstring fd-pass-record delimited by colon\n               into account\n           if key-account then exit perform end-if\n           perform read-pass-file\n       end-perform\n       if (key-account and tally not > 2) or (not key-account) then\n           display\n               \"error: appended record not found in correct position\"\n              upon syserr\n       else\n           display \"Appended record: \" with no advancing\n           perform show-pass-record\n       end-if\n\n       perform close-pass-file\n       .\n\n       end program append.\n", "target": "import static java.util.Objects.requireNonNull;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class RecordAppender {\n    static class Record {\n        private final String account;\n        private final String password;\n        private final int uid;\n        private final int gid;\n        private final List<String> gecos;\n        private final String directory;\n        private final String shell;\n\n        public Record(String account, String password, int uid, int gid, List<String> gecos, String directory, String shell) {\n            this.account = requireNonNull(account);\n            this.password = requireNonNull(password);\n            this.uid = uid;\n            this.gid = gid;\n            this.gecos = requireNonNull(gecos);\n            this.directory = requireNonNull(directory);\n            this.shell = requireNonNull(shell);\n        }\n\n        @Override\n        public String toString() {\n            return account + ':' + password + ':' + uid + ':' + gid + ':' + String.join(\",\", gecos) + ':' + directory + ':' + shell;\n        }\n\n        public static Record parse(String text) {\n            String[] tokens = text.split(\":\");\n            return new Record(\n                    tokens[0],\n                    tokens[1],\n                    Integer.parseInt(tokens[2]),\n                    Integer.parseInt(tokens[3]),\n                    Arrays.asList(tokens[4].split(\",\")),\n                    tokens[5],\n                    tokens[6]);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        List<String> rawData = Arrays.asList(\n                \"jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,[email protected]:/home/jsmith:/bin/bash\",\n                \"jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,[email protected]:/home/jdoe:/bin/bash\",\n                \"xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,[email protected]:/home/xyz:/bin/bash\"\n        );\n\n        List<Record> records = rawData.stream().map(Record::parse).collect(Collectors.toList());\n\n        Path tmp = Paths.get(\"_rosetta\", \".passwd\");\n        Files.createDirectories(tmp.getParent());\n        Files.write(tmp, (Iterable<String>) records.stream().limit(2).map(Record::toString)::iterator);\n\n        Files.write(tmp, Collections.singletonList(records.get(2).toString()), StandardOpenOption.APPEND);\n\n        try (Stream<String> lines = Files.lines(tmp)) {\n            lines.map(Record::parse).forEach(System.out::println);\n        }\n    }\n}\n"}
{"id": 16244, "name": "Append a record to the end of a text file", "source": "Translate COBOL to Python:       \n      \n      \n      \n       identification division.\n       program-id. append.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select pass-file\n           assign to pass-filename\n           organization is line sequential\n           status is pass-status.\n\n       REPLACE ==:LRECL:== BY ==2048==.\n\n       data division.\n       file section.\n       fd pass-file record varying depending on pass-length.\n       01 fd-pass-record.\n          05 filler pic x occurs 0 to :LRECL: times\n                          depending on pass-length.\n\n       working-storage section.\n       01 pass-filename.\n          05 filler            value \"passfile\".\n       01 pass-status          pic xx.\n          88 ok-status         values '00' thru '09'.\n          88 eof-pass          value '10'.\n\n       01 pass-length          usage index.\n       01 total-length         usage index.\n\n       77 file-action          pic x(11).\n\n       01 pass-record.\n          05 account           pic x(64).\n             88 key-account    value \"xyz\".\n          05 password          pic x(64).\n          05 uid               pic z(4)9.\n          05 gid               pic z(4)9.\n          05 details.\n             10 fullname       pic x(128).\n             10 office         pic x(128).\n             10 extension      pic x(32).\n             10 homephone      pic x(32).\n             10 email          pic x(256).\n          05 homedir           pic x(256).\n          05 shell             pic x(256).\n\n       77 colon                pic x value \":\".\n       77 comma-mark           pic x value \",\".\n       77 newline              pic x value x\"0a\".\n\n      \n       procedure division.\n       main-routine.\n       perform initial-fill\n\n       >>IF DEBUG IS DEFINED \n       display \"Initial data:\"\n       perform show-records\n       >>END-IF\n\n       perform append-record\n \n       >>IF DEBUG IS DEFINED \n       display newline \"After append:\"\n       perform show-records\n       >>END-IF\n\n       perform verify-append\n       goback\n       .\n\n      \n       initial-fill.\n       perform open-output-pass-file\n\n       move \"jsmith\" to account\n       move \"x\" to password\n       move 1001 to uid\n       move 1000 to gid\n       move \"Joe Smith\" to fullname\n       move \"Room 1007\" to office\n       move \"(234)555-8917\" to extension\n       move \"(234)555-0077\" to homephone\n       move \"jsmith@rosettacode.org\" to email\n       move \"/home/jsmith\" to homedir\n       move \"/bin/bash\" to shell\n       perform write-pass-record\n\n       move \"jdoe\" to account\n       move \"x\" to password\n       move 1002 to uid\n       move 1000 to gid\n       move \"Jane Doe\" to fullname\n       move \"Room 1004\" to office\n       move \"(234)555-8914\" to extension\n       move \"(234)555-0044\" to homephone\n       move \"jdoe@rosettacode.org\" to email\n       move \"/home/jdoe\" to homedir\n       move \"/bin/bash\" to shell\n       perform write-pass-record\n\n       perform close-pass-file\n       .\n\n      \n       check-pass-file.\n       if not ok-status then\n           perform file-error\n       end-if\n       .\n\n      \n       check-pass-with-eof.\n       if not ok-status and not eof-pass then\n           perform file-error\n       end-if\n       .\n\n      \n       file-error.\n       display \"error \" file-action space pass-filename\n               space pass-status upon syserr\n       move 1 to return-code\n       goback\n       .\n\n      \n       append-record.\n       move \"xyz\" to account\n       move \"x\" to password\n       move 1003 to uid\n       move 1000 to gid\n       move \"X Yz\" to fullname\n       move \"Room 1003\" to office\n       move \"(234)555-8913\" to extension\n       move \"(234)555-0033\" to homephone\n       move \"xyz@rosettacode.org\" to email\n       move \"/home/xyz\" to homedir\n       move \"/bin/bash\" to shell\n\n       perform open-extend-pass-file\n       perform write-pass-record\n       perform close-pass-file\n       .\n\n      \n       open-output-pass-file.\n       open output pass-file with lock\n       move \"open output\" to file-action\n       perform check-pass-file\n       .\n\n      \n       open-extend-pass-file.\n       open extend pass-file with lock\n       move \"open extend\" to file-action\n       perform check-pass-file\n       .\n\n      \n       open-input-pass-file.\n       open input pass-file\n       move \"open input\" to file-action\n       perform check-pass-file\n       .\n\n      \n       close-pass-file.\n       close pass-file\n       move \"closing\" to file-action\n       perform check-pass-file\n       .\n\n      \n       write-pass-record.\n       set total-length to 1\n       set pass-length to :LRECL:\n       string\n           account delimited by space\n           colon\n           password delimited by space\n           colon\n           trim(uid leading) delimited by size\n           colon\n           trim(gid leading) delimited by size\n           colon\n           trim(fullname trailing) delimited by size\n           comma-mark\n           trim(office trailing) delimited by size\n           comma-mark\n           trim(extension trailing) delimited by size\n           comma-mark\n           trim(homephone trailing) delimited by size\n           comma-mark\n           email delimited by space\n           colon\n           trim(homedir trailing) delimited by size\n           colon\n           trim(shell trailing) delimited by size\n           into fd-pass-record with pointer total-length\n           on overflow\n               display \"error: fd-pass-record truncated at \"\n                       total-length upon syserr\n       end-string\n       set pass-length to total-length\n       set pass-length down by 1\n\n       write fd-pass-record\n       move \"writing\" to file-action\n       perform check-pass-file\n       .\n\n      \n       read-pass-file.\n       read pass-file\n       move \"reading\" to file-action\n       perform check-pass-with-eof\n       .\n\n      \n       show-records.\n       perform open-input-pass-file\n\n       perform read-pass-file\n       perform until eof-pass\n           perform show-pass-record\n           perform read-pass-file\n       end-perform\n\n       perform close-pass-file\n       .\n\n      \n       show-pass-record.\n       display fd-pass-record\n       .\n\n      \n       verify-append.\n       perform open-input-pass-file\n\n       move 0 to tally\n       perform read-pass-file\n       perform until eof-pass\n           add 1 to tally\n           unstring fd-pass-record delimited by colon\n               into account\n           if key-account then exit perform end-if\n           perform read-pass-file\n       end-perform\n       if (key-account and tally not > 2) or (not key-account) then\n           display\n               \"error: appended record not found in correct position\"\n              upon syserr\n       else\n           display \"Appended record: \" with no advancing\n           perform show-pass-record\n       end-if\n\n       perform close-pass-file\n       .\n\n       end program append.\n", "target": "\n\n\n\npasswd_list=[\n  dict(account='jsmith', password='x', UID=1001, GID=1000, \n       GECOS=dict(fullname='Joe Smith', office='Room 1007', extension='(234)555-8917',\n                  homephone='(234)555-0077', email='jsmith@rosettacode.org'),\n                  directory='/home/jsmith', shell='/bin/bash'),\n  dict(account='jdoe', password='x', UID=1002, GID=1000,\n       GECOS=dict(fullname='Jane Doe', office='Room 1004', extension='(234)555-8914',\n                  homephone='(234)555-0044', email='jdoe@rosettacode.org'),\n       directory='/home/jdoe', shell='/bin/bash')\n]\n\npasswd_fields=\"account password UID GID GECOS directory shell\".split()\nGECOS_fields=\"fullname office extension homephone email\".split()\n\ndef passwd_text_repr(passwd_rec):\n\n  passwd_rec[\"GECOS\"]=\",\".join([ passwd_rec[\"GECOS\"][field] for field in GECOS_fields])\n  for field in passwd_rec: \n    if not isinstance(passwd_rec[field], str):\n      passwd_rec[field]=`passwd_rec[field]`\n  return \":\".join([ passwd_rec[field] for field in passwd_fields ])\n\npasswd_text=open(\"passwd.txt\",\"w\")\nfor passwd_rec in passwd_list:\n  print >> passwd_text,passwd_text_repr(passwd_rec)\npasswd_text.close()\n\n\n\n\npasswd_text=open(\"passwd.txt\",\"a+\")\nnew_rec=dict(account='xyz', password='x', UID=1003, GID=1000,\n             GECOS=dict(fullname='X Yz', office='Room 1003', extension='(234)555-8913',\n                        homephone='(234)555-0033', email='xyz@rosettacode.org'),\n             directory='/home/xyz', shell='/bin/bash')\nprint >> passwd_text,  passwd_text_repr(new_rec)\npasswd_text.close()\n\n\n\n\npasswd_list=list(open(\"passwd.txt\",\"r\"))\nif \"xyz\" in passwd_list[-1]:\n  print \"Appended record:\",passwd_list[-1][:-1]\n"}
{"id": 16635, "name": "Perfect numbers", "source": "Translate COBOL to C#:       $set REPOSITORY \"UPDATE ON\"\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. perfect-main.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION perfect\n           .\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i                      PIC 9(8).  \n       \n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 2 BY 1 UNTIL 33550337 = i\n               IF FUNCTION perfect(i) = 0\n                   DISPLAY i\n               END-IF\n           END-PERFORM\n       \n           GOBACK\n           .\n       END PROGRAM perfect-main.\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(\"Perfect numbers from 1 to 33550337:\");\n\n\tfor (int x = 0; x < 33550337; x++)\n\t{\n\t\tif (IsPerfect(x))\n\t\t\tConsole.WriteLine(x + \" is perfect.\");\n\t}\n\n\tConsole.ReadLine();\n}\n\nstatic bool IsPerfect(int num) \n{\n\tint sum = 0;\n\tfor (int i = 1; i < num; i++)\n\t{\n\t\tif (num % i == 0)\n\t\t\tsum += i;\n\t}\n\n\treturn sum == num ;\n}\n"}
{"id": 16637, "name": "Perfect numbers", "source": "Translate COBOL to Java:       $set REPOSITORY \"UPDATE ON\"\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. perfect-main.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION perfect\n           .\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i                      PIC 9(8).  \n       \n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 2 BY 1 UNTIL 33550337 = i\n               IF FUNCTION perfect(i) = 0\n                   DISPLAY i\n               END-IF\n           END-PERFORM\n       \n           GOBACK\n           .\n       END PROGRAM perfect-main.\n", "target": "public static boolean perf(int n){\n\tint sum= 0;\n\tfor(int i= 1;i < n;i++){\n\t\tif(n % i == 0){\n\t\t\tsum+= i;\n\t\t}\n\t}\n\treturn sum == n;\n}\n"}
{"id": 16638, "name": "Perfect numbers", "source": "Translate COBOL to Python:       $set REPOSITORY \"UPDATE ON\"\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. perfect-main.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION perfect\n           .\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i                      PIC 9(8).  \n       \n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 2 BY 1 UNTIL 33550337 = i\n               IF FUNCTION perfect(i) = 0\n                   DISPLAY i\n               END-IF\n           END-PERFORM\n       \n           GOBACK\n           .\n       END PROGRAM perfect-main.\n", "target": "def perf1(n):\n    sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum += i\n    return sum == n\n"}
{"id": 16960, "name": "Abbreviations, automatic", "source": "Translate COBOL to C#:             IDENTIFICATION DIVISION.\n            PROGRAM-ID. AUTO-ABBREVIATIONS.\n\n            ENVIRONMENT DIVISION.\n\n            INPUT-OUTPUT SECTION.\n            FILE-CONTROL.\n              SELECT DOW ASSIGN TO \"days-of-week.txt\"\n              ORGANIZATION IS LINE SEQUENTIAL.\n\n            DATA DIVISION.\n              FILE SECTION.\n              FD DOW.\n              01 DOW-FILE PIC X(200).\n\n              WORKING-STORAGE SECTION. \n              01 DOW-LINE PIC X(200).\n              01 ENDO PIC 9(1).\n              01 ENDO2 PIC 9(1).\n              01 CURDAY PIC X(50).\n              01 ABPTR PIC 999.\n              01 LINE-NUM PIC 9(3) VALUE 1.\n              01 CHARAMT PIC 9(3) VALUE 1.\n              01 LARGESTCHARAMT PIC 9(3).\n              01 DAYNUM PIC 9(3) VALUE 1.\n              01 ABRESTART PIC 9(1).\n              01 CURABBR PIC X(50).\n              01 TMP1 PIC 9(3).\n              01 TMP2 PIC 9(3).\n              01 TINDEX PIC 9(3) VALUE 1.\n              01 ABBRLIST.\n                05 ABBRITEM PIC X(50) OCCURS 7 TIMES.\n              \n\n            PROCEDURE DIVISION.\n              OPEN INPUT DOW.\n                PERFORM UNTIL ENDO = 1\n                  READ DOW INTO DOW-LINE\n                    AT END MOVE 1 TO ENDO\n                    NOT AT END PERFORM\n                      \n                      IF DOW-LINE = \"\" THEN\n                        DISPLAY \"\"\n                      ELSE\n                        MOVE 0 TO ENDO2\n                        MOVE 0 TO CHARAMT\n\n                        PERFORM UNTIL ENDO2 > 0\n                          MOVE 1 TO ABPTR\n                          MOVE 1 TO DAYNUM\n                          MOVE 0 TO ABRESTART\n\n                          ADD 1 TO CHARAMT\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE SPACE TO ABBRITEM(TINDEX)\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n\n                          \n                          PERFORM 7 TIMES\n                            UNSTRING DOW-LINE DELIMITED BY SPACE\n                              INTO CURDAY\n                              WITH POINTER ABPTR\n                            END-UNSTRING\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURDAY\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURDAY\n                              TALLYING TMP2 FOR ALL SPACE\n                            SUBTRACT TMP2 FROM TMP1\n                            IF TMP1 > LARGESTCHARAMT THEN\n                              MOVE TMP1 TO LARGESTCHARAMT\n                            END-IF\n\n                            \n                            IF CURDAY = \"\" THEN\n                              MOVE 3 TO ENDO2\n                            END-IF\n\n                            MOVE CURDAY(1:CHARAMT) TO CURABBR\n\n                            \n                            MOVE 1 TO TINDEX\n                            PERFORM 7 TIMES\n                              IF ABBRITEM(TINDEX) = CURABBR THEN\n                                MOVE 1 TO ABRESTART\n                              END-IF\n                              ADD 1 TO TINDEX\n                            END-PERFORM\n\n                            MOVE CURABBR TO ABBRITEM(DAYNUM)\n\n                            ADD 1 TO DAYNUM\n\n                          END-PERFORM\n\n                          IF ABRESTART = 0 THEN\n                            MOVE 1 TO ENDO2\n                          END-IF\n\n                          \n                          IF CHARAMT > LARGESTCHARAMT THEN\n                            MOVE 2 TO ENDO2\n                          END-IF\n\n                        END-PERFORM\n\n                        DISPLAY \"Line \" LINE-NUM \": \" WITH NO ADVANCING\n\n                        IF ENDO2 = 3 THEN\n                          DISPLAY \"Error: not enough \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE IF ENDO2 = 2 THEN\n                          DISPLAY \"Error: identical \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE\n                          DISPLAY CHARAMT \": \" WITH NO ADVANCING\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE ABBRITEM(TINDEX) TO CURABBR\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURABBR\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURABBR\n                              TALLYING TMP2 FOR TRAILING SPACES\n                            SUBTRACT TMP2 FROM TMP1\n\n                            DISPLAY CURABBR(1:TMP1) WITH NO ADVANCING\n                            DISPLAY \".\" WITH NO ADVANCING\n\n                            IF TINDEX < 7 THEN\n                              DISPLAY SPACE WITH NO ADVANCING\n                            ELSE\n                              DISPLAY X\"0a\" WITH NO ADVANCING \n                            END-IF\n\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n                        END-IF\n\n                      END-IF\n\n                    END-PERFORM\n                  END-READ\n\n                  ADD 1 TO LINE-NUM\n                END-PERFORM.\n              CLOSE DOW.\n              STOP RUN.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Abbreviations {\n    class Program {\n        static void Main(string[] args) {\n            string[] lines = System.IO.File.ReadAllLines(\"days_of_week.txt\");\n            int i = 0;\n\n            foreach (string line in lines) {\n                i++;\n                if (line.Length > 0) {\n                    var days = line.Split();\n                    if (days.Length != 7) {\n                        throw new Exception(\"There aren't 7 days in line \" + i);\n                    }\n\n                    Dictionary<string, int> temp = new Dictionary<string, int>();\n                    foreach (string day in days) {\n                        if (temp.ContainsKey(day)) {\n                            Console.WriteLine(\" \u221e  {0}\", line);\n                            continue;\n                        }\n                        temp.Add(day, 1);\n                    }\n\n                    int len = 1;\n                    while (true) {\n                        temp.Clear();\n                        foreach(string day in days) {\n                            string key;\n                            if (len < day.Length) {\n                                key = day.Substring(0, len);\n                            } else {\n                                key = day;\n                            }\n                            if (temp.ContainsKey(key)) {\n                                break;\n                            }\n                            temp.Add(key, 1);\n                        }\n                        if (temp.Count == 7) {\n                            Console.WriteLine(\"{0,2:D}  {1}\", len, line);\n                            break;\n                        }\n                        len++;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 16961, "name": "Abbreviations, automatic", "source": "Translate COBOL to C#:             IDENTIFICATION DIVISION.\n            PROGRAM-ID. AUTO-ABBREVIATIONS.\n\n            ENVIRONMENT DIVISION.\n\n            INPUT-OUTPUT SECTION.\n            FILE-CONTROL.\n              SELECT DOW ASSIGN TO \"days-of-week.txt\"\n              ORGANIZATION IS LINE SEQUENTIAL.\n\n            DATA DIVISION.\n              FILE SECTION.\n              FD DOW.\n              01 DOW-FILE PIC X(200).\n\n              WORKING-STORAGE SECTION. \n              01 DOW-LINE PIC X(200).\n              01 ENDO PIC 9(1).\n              01 ENDO2 PIC 9(1).\n              01 CURDAY PIC X(50).\n              01 ABPTR PIC 999.\n              01 LINE-NUM PIC 9(3) VALUE 1.\n              01 CHARAMT PIC 9(3) VALUE 1.\n              01 LARGESTCHARAMT PIC 9(3).\n              01 DAYNUM PIC 9(3) VALUE 1.\n              01 ABRESTART PIC 9(1).\n              01 CURABBR PIC X(50).\n              01 TMP1 PIC 9(3).\n              01 TMP2 PIC 9(3).\n              01 TINDEX PIC 9(3) VALUE 1.\n              01 ABBRLIST.\n                05 ABBRITEM PIC X(50) OCCURS 7 TIMES.\n              \n\n            PROCEDURE DIVISION.\n              OPEN INPUT DOW.\n                PERFORM UNTIL ENDO = 1\n                  READ DOW INTO DOW-LINE\n                    AT END MOVE 1 TO ENDO\n                    NOT AT END PERFORM\n                      \n                      IF DOW-LINE = \"\" THEN\n                        DISPLAY \"\"\n                      ELSE\n                        MOVE 0 TO ENDO2\n                        MOVE 0 TO CHARAMT\n\n                        PERFORM UNTIL ENDO2 > 0\n                          MOVE 1 TO ABPTR\n                          MOVE 1 TO DAYNUM\n                          MOVE 0 TO ABRESTART\n\n                          ADD 1 TO CHARAMT\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE SPACE TO ABBRITEM(TINDEX)\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n\n                          \n                          PERFORM 7 TIMES\n                            UNSTRING DOW-LINE DELIMITED BY SPACE\n                              INTO CURDAY\n                              WITH POINTER ABPTR\n                            END-UNSTRING\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURDAY\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURDAY\n                              TALLYING TMP2 FOR ALL SPACE\n                            SUBTRACT TMP2 FROM TMP1\n                            IF TMP1 > LARGESTCHARAMT THEN\n                              MOVE TMP1 TO LARGESTCHARAMT\n                            END-IF\n\n                            \n                            IF CURDAY = \"\" THEN\n                              MOVE 3 TO ENDO2\n                            END-IF\n\n                            MOVE CURDAY(1:CHARAMT) TO CURABBR\n\n                            \n                            MOVE 1 TO TINDEX\n                            PERFORM 7 TIMES\n                              IF ABBRITEM(TINDEX) = CURABBR THEN\n                                MOVE 1 TO ABRESTART\n                              END-IF\n                              ADD 1 TO TINDEX\n                            END-PERFORM\n\n                            MOVE CURABBR TO ABBRITEM(DAYNUM)\n\n                            ADD 1 TO DAYNUM\n\n                          END-PERFORM\n\n                          IF ABRESTART = 0 THEN\n                            MOVE 1 TO ENDO2\n                          END-IF\n\n                          \n                          IF CHARAMT > LARGESTCHARAMT THEN\n                            MOVE 2 TO ENDO2\n                          END-IF\n\n                        END-PERFORM\n\n                        DISPLAY \"Line \" LINE-NUM \": \" WITH NO ADVANCING\n\n                        IF ENDO2 = 3 THEN\n                          DISPLAY \"Error: not enough \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE IF ENDO2 = 2 THEN\n                          DISPLAY \"Error: identical \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE\n                          DISPLAY CHARAMT \": \" WITH NO ADVANCING\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE ABBRITEM(TINDEX) TO CURABBR\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURABBR\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURABBR\n                              TALLYING TMP2 FOR TRAILING SPACES\n                            SUBTRACT TMP2 FROM TMP1\n\n                            DISPLAY CURABBR(1:TMP1) WITH NO ADVANCING\n                            DISPLAY \".\" WITH NO ADVANCING\n\n                            IF TINDEX < 7 THEN\n                              DISPLAY SPACE WITH NO ADVANCING\n                            ELSE\n                              DISPLAY X\"0a\" WITH NO ADVANCING \n                            END-IF\n\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n                        END-IF\n\n                      END-IF\n\n                    END-PERFORM\n                  END-READ\n\n                  ADD 1 TO LINE-NUM\n                END-PERFORM.\n              CLOSE DOW.\n              STOP RUN.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Abbreviations {\n    class Program {\n        static void Main(string[] args) {\n            string[] lines = System.IO.File.ReadAllLines(\"days_of_week.txt\");\n            int i = 0;\n\n            foreach (string line in lines) {\n                i++;\n                if (line.Length > 0) {\n                    var days = line.Split();\n                    if (days.Length != 7) {\n                        throw new Exception(\"There aren't 7 days in line \" + i);\n                    }\n\n                    Dictionary<string, int> temp = new Dictionary<string, int>();\n                    foreach (string day in days) {\n                        if (temp.ContainsKey(day)) {\n                            Console.WriteLine(\" \u221e  {0}\", line);\n                            continue;\n                        }\n                        temp.Add(day, 1);\n                    }\n\n                    int len = 1;\n                    while (true) {\n                        temp.Clear();\n                        foreach(string day in days) {\n                            string key;\n                            if (len < day.Length) {\n                                key = day.Substring(0, len);\n                            } else {\n                                key = day;\n                            }\n                            if (temp.ContainsKey(key)) {\n                                break;\n                            }\n                            temp.Add(key, 1);\n                        }\n                        if (temp.Count == 7) {\n                            Console.WriteLine(\"{0,2:D}  {1}\", len, line);\n                            break;\n                        }\n                        len++;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 16964, "name": "Abbreviations, automatic", "source": "Translate COBOL to Java:             IDENTIFICATION DIVISION.\n            PROGRAM-ID. AUTO-ABBREVIATIONS.\n\n            ENVIRONMENT DIVISION.\n\n            INPUT-OUTPUT SECTION.\n            FILE-CONTROL.\n              SELECT DOW ASSIGN TO \"days-of-week.txt\"\n              ORGANIZATION IS LINE SEQUENTIAL.\n\n            DATA DIVISION.\n              FILE SECTION.\n              FD DOW.\n              01 DOW-FILE PIC X(200).\n\n              WORKING-STORAGE SECTION. \n              01 DOW-LINE PIC X(200).\n              01 ENDO PIC 9(1).\n              01 ENDO2 PIC 9(1).\n              01 CURDAY PIC X(50).\n              01 ABPTR PIC 999.\n              01 LINE-NUM PIC 9(3) VALUE 1.\n              01 CHARAMT PIC 9(3) VALUE 1.\n              01 LARGESTCHARAMT PIC 9(3).\n              01 DAYNUM PIC 9(3) VALUE 1.\n              01 ABRESTART PIC 9(1).\n              01 CURABBR PIC X(50).\n              01 TMP1 PIC 9(3).\n              01 TMP2 PIC 9(3).\n              01 TINDEX PIC 9(3) VALUE 1.\n              01 ABBRLIST.\n                05 ABBRITEM PIC X(50) OCCURS 7 TIMES.\n              \n\n            PROCEDURE DIVISION.\n              OPEN INPUT DOW.\n                PERFORM UNTIL ENDO = 1\n                  READ DOW INTO DOW-LINE\n                    AT END MOVE 1 TO ENDO\n                    NOT AT END PERFORM\n                      \n                      IF DOW-LINE = \"\" THEN\n                        DISPLAY \"\"\n                      ELSE\n                        MOVE 0 TO ENDO2\n                        MOVE 0 TO CHARAMT\n\n                        PERFORM UNTIL ENDO2 > 0\n                          MOVE 1 TO ABPTR\n                          MOVE 1 TO DAYNUM\n                          MOVE 0 TO ABRESTART\n\n                          ADD 1 TO CHARAMT\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE SPACE TO ABBRITEM(TINDEX)\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n\n                          \n                          PERFORM 7 TIMES\n                            UNSTRING DOW-LINE DELIMITED BY SPACE\n                              INTO CURDAY\n                              WITH POINTER ABPTR\n                            END-UNSTRING\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURDAY\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURDAY\n                              TALLYING TMP2 FOR ALL SPACE\n                            SUBTRACT TMP2 FROM TMP1\n                            IF TMP1 > LARGESTCHARAMT THEN\n                              MOVE TMP1 TO LARGESTCHARAMT\n                            END-IF\n\n                            \n                            IF CURDAY = \"\" THEN\n                              MOVE 3 TO ENDO2\n                            END-IF\n\n                            MOVE CURDAY(1:CHARAMT) TO CURABBR\n\n                            \n                            MOVE 1 TO TINDEX\n                            PERFORM 7 TIMES\n                              IF ABBRITEM(TINDEX) = CURABBR THEN\n                                MOVE 1 TO ABRESTART\n                              END-IF\n                              ADD 1 TO TINDEX\n                            END-PERFORM\n\n                            MOVE CURABBR TO ABBRITEM(DAYNUM)\n\n                            ADD 1 TO DAYNUM\n\n                          END-PERFORM\n\n                          IF ABRESTART = 0 THEN\n                            MOVE 1 TO ENDO2\n                          END-IF\n\n                          \n                          IF CHARAMT > LARGESTCHARAMT THEN\n                            MOVE 2 TO ENDO2\n                          END-IF\n\n                        END-PERFORM\n\n                        DISPLAY \"Line \" LINE-NUM \": \" WITH NO ADVANCING\n\n                        IF ENDO2 = 3 THEN\n                          DISPLAY \"Error: not enough \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE IF ENDO2 = 2 THEN\n                          DISPLAY \"Error: identical \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE\n                          DISPLAY CHARAMT \": \" WITH NO ADVANCING\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE ABBRITEM(TINDEX) TO CURABBR\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURABBR\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURABBR\n                              TALLYING TMP2 FOR TRAILING SPACES\n                            SUBTRACT TMP2 FROM TMP1\n\n                            DISPLAY CURABBR(1:TMP1) WITH NO ADVANCING\n                            DISPLAY \".\" WITH NO ADVANCING\n\n                            IF TINDEX < 7 THEN\n                              DISPLAY SPACE WITH NO ADVANCING\n                            ELSE\n                              DISPLAY X\"0a\" WITH NO ADVANCING \n                            END-IF\n\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n                        END-IF\n\n                      END-IF\n\n                    END-PERFORM\n                  END-READ\n\n                  ADD 1 TO LINE-NUM\n                END-PERFORM.\n              CLOSE DOW.\n              STOP RUN.\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Abbreviations {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"days_of_week.txt\");\n        List<String> readAllLines = Files.readAllLines(path);\n        for (int i = 0; i < readAllLines.size(); i++) {\n            String line = readAllLines.get(i);\n            if (line.length() == 0) continue;\n\n            String[] days = line.split(\" \");\n            if (days.length != 7) throw new RuntimeException(\"There aren't 7 days on line \" + (i + 1));\n\n            Map<String, Integer> temp = new HashMap<>();\n            for (String day : days) {\n                Integer count = temp.getOrDefault(day, 0);\n                temp.put(day, count + 1);\n            }\n            if (temp.size() < 7) {\n                System.out.print(\" \u221e  \");\n                System.out.println(line);\n                continue;\n            }\n\n            int len = 1;\n            while (true) {\n                temp.clear();\n                for (String day : days) {\n                    String sd;\n                    if (len >= day.length()) {\n                        sd = day;\n                    } else {\n                        sd = day.substring(0, len);\n                    }\n                    Integer count = temp.getOrDefault(sd, 0);\n                    temp.put(sd, count + 1);\n                }\n                if (temp.size() == 7) {\n                    System.out.printf(\"%2d  %s\\n\", len, line);\n                    break;\n                }\n                len++;\n            }\n        }\n    }\n}\n"}
{"id": 16965, "name": "Abbreviations, automatic", "source": "Translate COBOL to Java:             IDENTIFICATION DIVISION.\n            PROGRAM-ID. AUTO-ABBREVIATIONS.\n\n            ENVIRONMENT DIVISION.\n\n            INPUT-OUTPUT SECTION.\n            FILE-CONTROL.\n              SELECT DOW ASSIGN TO \"days-of-week.txt\"\n              ORGANIZATION IS LINE SEQUENTIAL.\n\n            DATA DIVISION.\n              FILE SECTION.\n              FD DOW.\n              01 DOW-FILE PIC X(200).\n\n              WORKING-STORAGE SECTION. \n              01 DOW-LINE PIC X(200).\n              01 ENDO PIC 9(1).\n              01 ENDO2 PIC 9(1).\n              01 CURDAY PIC X(50).\n              01 ABPTR PIC 999.\n              01 LINE-NUM PIC 9(3) VALUE 1.\n              01 CHARAMT PIC 9(3) VALUE 1.\n              01 LARGESTCHARAMT PIC 9(3).\n              01 DAYNUM PIC 9(3) VALUE 1.\n              01 ABRESTART PIC 9(1).\n              01 CURABBR PIC X(50).\n              01 TMP1 PIC 9(3).\n              01 TMP2 PIC 9(3).\n              01 TINDEX PIC 9(3) VALUE 1.\n              01 ABBRLIST.\n                05 ABBRITEM PIC X(50) OCCURS 7 TIMES.\n              \n\n            PROCEDURE DIVISION.\n              OPEN INPUT DOW.\n                PERFORM UNTIL ENDO = 1\n                  READ DOW INTO DOW-LINE\n                    AT END MOVE 1 TO ENDO\n                    NOT AT END PERFORM\n                      \n                      IF DOW-LINE = \"\" THEN\n                        DISPLAY \"\"\n                      ELSE\n                        MOVE 0 TO ENDO2\n                        MOVE 0 TO CHARAMT\n\n                        PERFORM UNTIL ENDO2 > 0\n                          MOVE 1 TO ABPTR\n                          MOVE 1 TO DAYNUM\n                          MOVE 0 TO ABRESTART\n\n                          ADD 1 TO CHARAMT\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE SPACE TO ABBRITEM(TINDEX)\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n\n                          \n                          PERFORM 7 TIMES\n                            UNSTRING DOW-LINE DELIMITED BY SPACE\n                              INTO CURDAY\n                              WITH POINTER ABPTR\n                            END-UNSTRING\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURDAY\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURDAY\n                              TALLYING TMP2 FOR ALL SPACE\n                            SUBTRACT TMP2 FROM TMP1\n                            IF TMP1 > LARGESTCHARAMT THEN\n                              MOVE TMP1 TO LARGESTCHARAMT\n                            END-IF\n\n                            \n                            IF CURDAY = \"\" THEN\n                              MOVE 3 TO ENDO2\n                            END-IF\n\n                            MOVE CURDAY(1:CHARAMT) TO CURABBR\n\n                            \n                            MOVE 1 TO TINDEX\n                            PERFORM 7 TIMES\n                              IF ABBRITEM(TINDEX) = CURABBR THEN\n                                MOVE 1 TO ABRESTART\n                              END-IF\n                              ADD 1 TO TINDEX\n                            END-PERFORM\n\n                            MOVE CURABBR TO ABBRITEM(DAYNUM)\n\n                            ADD 1 TO DAYNUM\n\n                          END-PERFORM\n\n                          IF ABRESTART = 0 THEN\n                            MOVE 1 TO ENDO2\n                          END-IF\n\n                          \n                          IF CHARAMT > LARGESTCHARAMT THEN\n                            MOVE 2 TO ENDO2\n                          END-IF\n\n                        END-PERFORM\n\n                        DISPLAY \"Line \" LINE-NUM \": \" WITH NO ADVANCING\n\n                        IF ENDO2 = 3 THEN\n                          DISPLAY \"Error: not enough \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE IF ENDO2 = 2 THEN\n                          DISPLAY \"Error: identical \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE\n                          DISPLAY CHARAMT \": \" WITH NO ADVANCING\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE ABBRITEM(TINDEX) TO CURABBR\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURABBR\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURABBR\n                              TALLYING TMP2 FOR TRAILING SPACES\n                            SUBTRACT TMP2 FROM TMP1\n\n                            DISPLAY CURABBR(1:TMP1) WITH NO ADVANCING\n                            DISPLAY \".\" WITH NO ADVANCING\n\n                            IF TINDEX < 7 THEN\n                              DISPLAY SPACE WITH NO ADVANCING\n                            ELSE\n                              DISPLAY X\"0a\" WITH NO ADVANCING \n                            END-IF\n\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n                        END-IF\n\n                      END-IF\n\n                    END-PERFORM\n                  END-READ\n\n                  ADD 1 TO LINE-NUM\n                END-PERFORM.\n              CLOSE DOW.\n              STOP RUN.\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Abbreviations {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"days_of_week.txt\");\n        List<String> readAllLines = Files.readAllLines(path);\n        for (int i = 0; i < readAllLines.size(); i++) {\n            String line = readAllLines.get(i);\n            if (line.length() == 0) continue;\n\n            String[] days = line.split(\" \");\n            if (days.length != 7) throw new RuntimeException(\"There aren't 7 days on line \" + (i + 1));\n\n            Map<String, Integer> temp = new HashMap<>();\n            for (String day : days) {\n                Integer count = temp.getOrDefault(day, 0);\n                temp.put(day, count + 1);\n            }\n            if (temp.size() < 7) {\n                System.out.print(\" \u221e  \");\n                System.out.println(line);\n                continue;\n            }\n\n            int len = 1;\n            while (true) {\n                temp.clear();\n                for (String day : days) {\n                    String sd;\n                    if (len >= day.length()) {\n                        sd = day;\n                    } else {\n                        sd = day.substring(0, len);\n                    }\n                    Integer count = temp.getOrDefault(sd, 0);\n                    temp.put(sd, count + 1);\n                }\n                if (temp.size() == 7) {\n                    System.out.printf(\"%2d  %s\\n\", len, line);\n                    break;\n                }\n                len++;\n            }\n        }\n    }\n}\n"}
{"id": 16966, "name": "Abbreviations, automatic", "source": "Translate COBOL to Python:             IDENTIFICATION DIVISION.\n            PROGRAM-ID. AUTO-ABBREVIATIONS.\n\n            ENVIRONMENT DIVISION.\n\n            INPUT-OUTPUT SECTION.\n            FILE-CONTROL.\n              SELECT DOW ASSIGN TO \"days-of-week.txt\"\n              ORGANIZATION IS LINE SEQUENTIAL.\n\n            DATA DIVISION.\n              FILE SECTION.\n              FD DOW.\n              01 DOW-FILE PIC X(200).\n\n              WORKING-STORAGE SECTION. \n              01 DOW-LINE PIC X(200).\n              01 ENDO PIC 9(1).\n              01 ENDO2 PIC 9(1).\n              01 CURDAY PIC X(50).\n              01 ABPTR PIC 999.\n              01 LINE-NUM PIC 9(3) VALUE 1.\n              01 CHARAMT PIC 9(3) VALUE 1.\n              01 LARGESTCHARAMT PIC 9(3).\n              01 DAYNUM PIC 9(3) VALUE 1.\n              01 ABRESTART PIC 9(1).\n              01 CURABBR PIC X(50).\n              01 TMP1 PIC 9(3).\n              01 TMP2 PIC 9(3).\n              01 TINDEX PIC 9(3) VALUE 1.\n              01 ABBRLIST.\n                05 ABBRITEM PIC X(50) OCCURS 7 TIMES.\n              \n\n            PROCEDURE DIVISION.\n              OPEN INPUT DOW.\n                PERFORM UNTIL ENDO = 1\n                  READ DOW INTO DOW-LINE\n                    AT END MOVE 1 TO ENDO\n                    NOT AT END PERFORM\n                      \n                      IF DOW-LINE = \"\" THEN\n                        DISPLAY \"\"\n                      ELSE\n                        MOVE 0 TO ENDO2\n                        MOVE 0 TO CHARAMT\n\n                        PERFORM UNTIL ENDO2 > 0\n                          MOVE 1 TO ABPTR\n                          MOVE 1 TO DAYNUM\n                          MOVE 0 TO ABRESTART\n\n                          ADD 1 TO CHARAMT\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE SPACE TO ABBRITEM(TINDEX)\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n\n                          \n                          PERFORM 7 TIMES\n                            UNSTRING DOW-LINE DELIMITED BY SPACE\n                              INTO CURDAY\n                              WITH POINTER ABPTR\n                            END-UNSTRING\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURDAY\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURDAY\n                              TALLYING TMP2 FOR ALL SPACE\n                            SUBTRACT TMP2 FROM TMP1\n                            IF TMP1 > LARGESTCHARAMT THEN\n                              MOVE TMP1 TO LARGESTCHARAMT\n                            END-IF\n\n                            \n                            IF CURDAY = \"\" THEN\n                              MOVE 3 TO ENDO2\n                            END-IF\n\n                            MOVE CURDAY(1:CHARAMT) TO CURABBR\n\n                            \n                            MOVE 1 TO TINDEX\n                            PERFORM 7 TIMES\n                              IF ABBRITEM(TINDEX) = CURABBR THEN\n                                MOVE 1 TO ABRESTART\n                              END-IF\n                              ADD 1 TO TINDEX\n                            END-PERFORM\n\n                            MOVE CURABBR TO ABBRITEM(DAYNUM)\n\n                            ADD 1 TO DAYNUM\n\n                          END-PERFORM\n\n                          IF ABRESTART = 0 THEN\n                            MOVE 1 TO ENDO2\n                          END-IF\n\n                          \n                          IF CHARAMT > LARGESTCHARAMT THEN\n                            MOVE 2 TO ENDO2\n                          END-IF\n\n                        END-PERFORM\n\n                        DISPLAY \"Line \" LINE-NUM \": \" WITH NO ADVANCING\n\n                        IF ENDO2 = 3 THEN\n                          DISPLAY \"Error: not enough \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE IF ENDO2 = 2 THEN\n                          DISPLAY \"Error: identical \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE\n                          DISPLAY CHARAMT \": \" WITH NO ADVANCING\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE ABBRITEM(TINDEX) TO CURABBR\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURABBR\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURABBR\n                              TALLYING TMP2 FOR TRAILING SPACES\n                            SUBTRACT TMP2 FROM TMP1\n\n                            DISPLAY CURABBR(1:TMP1) WITH NO ADVANCING\n                            DISPLAY \".\" WITH NO ADVANCING\n\n                            IF TINDEX < 7 THEN\n                              DISPLAY SPACE WITH NO ADVANCING\n                            ELSE\n                              DISPLAY X\"0a\" WITH NO ADVANCING \n                            END-IF\n\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n                        END-IF\n\n                      END-IF\n\n                    END-PERFORM\n                  END-READ\n\n                  ADD 1 TO LINE-NUM\n                END-PERFORM.\n              CLOSE DOW.\n              STOP RUN.\n", "target": "def shortest_abbreviation_length(line, list_size):\n    words = line.split()\n    word_count = len(words)\n    \n    if word_count != list_size:\n        raise ValueError(f'Not enough entries, expected {list_size} found {word_count}')\n\n    \n    abbreviation_length = 1\n    abbreviations = set()\n    while(True):\n        abbreviations = {word[:abbreviation_length] for word in words}\n        if len(abbreviations) == list_size:\n            return abbreviation_length\n        abbreviation_length += 1\n        abbreviations.clear()\n\ndef automatic_abbreviations(filename, words_per_line):\n    with open(filename) as file:\n        for line in file:\n            line = line.rstrip()\n            if len(line) > 0:\n                length = shortest_abbreviation_length(line, words_per_line)\n                print(f'{length:2} {line}')\n            else:\n                print()\n\nautomatic_abbreviations('daysOfWeek.txt', 7)\n"}
{"id": 16967, "name": "Abbreviations, automatic", "source": "Translate COBOL to Python:             IDENTIFICATION DIVISION.\n            PROGRAM-ID. AUTO-ABBREVIATIONS.\n\n            ENVIRONMENT DIVISION.\n\n            INPUT-OUTPUT SECTION.\n            FILE-CONTROL.\n              SELECT DOW ASSIGN TO \"days-of-week.txt\"\n              ORGANIZATION IS LINE SEQUENTIAL.\n\n            DATA DIVISION.\n              FILE SECTION.\n              FD DOW.\n              01 DOW-FILE PIC X(200).\n\n              WORKING-STORAGE SECTION. \n              01 DOW-LINE PIC X(200).\n              01 ENDO PIC 9(1).\n              01 ENDO2 PIC 9(1).\n              01 CURDAY PIC X(50).\n              01 ABPTR PIC 999.\n              01 LINE-NUM PIC 9(3) VALUE 1.\n              01 CHARAMT PIC 9(3) VALUE 1.\n              01 LARGESTCHARAMT PIC 9(3).\n              01 DAYNUM PIC 9(3) VALUE 1.\n              01 ABRESTART PIC 9(1).\n              01 CURABBR PIC X(50).\n              01 TMP1 PIC 9(3).\n              01 TMP2 PIC 9(3).\n              01 TINDEX PIC 9(3) VALUE 1.\n              01 ABBRLIST.\n                05 ABBRITEM PIC X(50) OCCURS 7 TIMES.\n              \n\n            PROCEDURE DIVISION.\n              OPEN INPUT DOW.\n                PERFORM UNTIL ENDO = 1\n                  READ DOW INTO DOW-LINE\n                    AT END MOVE 1 TO ENDO\n                    NOT AT END PERFORM\n                      \n                      IF DOW-LINE = \"\" THEN\n                        DISPLAY \"\"\n                      ELSE\n                        MOVE 0 TO ENDO2\n                        MOVE 0 TO CHARAMT\n\n                        PERFORM UNTIL ENDO2 > 0\n                          MOVE 1 TO ABPTR\n                          MOVE 1 TO DAYNUM\n                          MOVE 0 TO ABRESTART\n\n                          ADD 1 TO CHARAMT\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE SPACE TO ABBRITEM(TINDEX)\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n\n                          \n                          PERFORM 7 TIMES\n                            UNSTRING DOW-LINE DELIMITED BY SPACE\n                              INTO CURDAY\n                              WITH POINTER ABPTR\n                            END-UNSTRING\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURDAY\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURDAY\n                              TALLYING TMP2 FOR ALL SPACE\n                            SUBTRACT TMP2 FROM TMP1\n                            IF TMP1 > LARGESTCHARAMT THEN\n                              MOVE TMP1 TO LARGESTCHARAMT\n                            END-IF\n\n                            \n                            IF CURDAY = \"\" THEN\n                              MOVE 3 TO ENDO2\n                            END-IF\n\n                            MOVE CURDAY(1:CHARAMT) TO CURABBR\n\n                            \n                            MOVE 1 TO TINDEX\n                            PERFORM 7 TIMES\n                              IF ABBRITEM(TINDEX) = CURABBR THEN\n                                MOVE 1 TO ABRESTART\n                              END-IF\n                              ADD 1 TO TINDEX\n                            END-PERFORM\n\n                            MOVE CURABBR TO ABBRITEM(DAYNUM)\n\n                            ADD 1 TO DAYNUM\n\n                          END-PERFORM\n\n                          IF ABRESTART = 0 THEN\n                            MOVE 1 TO ENDO2\n                          END-IF\n\n                          \n                          IF CHARAMT > LARGESTCHARAMT THEN\n                            MOVE 2 TO ENDO2\n                          END-IF\n\n                        END-PERFORM\n\n                        DISPLAY \"Line \" LINE-NUM \": \" WITH NO ADVANCING\n\n                        IF ENDO2 = 3 THEN\n                          DISPLAY \"Error: not enough \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE IF ENDO2 = 2 THEN\n                          DISPLAY \"Error: identical \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE\n                          DISPLAY CHARAMT \": \" WITH NO ADVANCING\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE ABBRITEM(TINDEX) TO CURABBR\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURABBR\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURABBR\n                              TALLYING TMP2 FOR TRAILING SPACES\n                            SUBTRACT TMP2 FROM TMP1\n\n                            DISPLAY CURABBR(1:TMP1) WITH NO ADVANCING\n                            DISPLAY \".\" WITH NO ADVANCING\n\n                            IF TINDEX < 7 THEN\n                              DISPLAY SPACE WITH NO ADVANCING\n                            ELSE\n                              DISPLAY X\"0a\" WITH NO ADVANCING \n                            END-IF\n\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n                        END-IF\n\n                      END-IF\n\n                    END-PERFORM\n                  END-READ\n\n                  ADD 1 TO LINE-NUM\n                END-PERFORM.\n              CLOSE DOW.\n              STOP RUN.\n", "target": "def shortest_abbreviation_length(line, list_size):\n    words = line.split()\n    word_count = len(words)\n    \n    if word_count != list_size:\n        raise ValueError(f'Not enough entries, expected {list_size} found {word_count}')\n\n    \n    abbreviation_length = 1\n    abbreviations = set()\n    while(True):\n        abbreviations = {word[:abbreviation_length] for word in words}\n        if len(abbreviations) == list_size:\n            return abbreviation_length\n        abbreviation_length += 1\n        abbreviations.clear()\n\ndef automatic_abbreviations(filename, words_per_line):\n    with open(filename) as file:\n        for line in file:\n            line = line.rstrip()\n            if len(line) > 0:\n                length = shortest_abbreviation_length(line, words_per_line)\n                print(f'{length:2} {line}')\n            else:\n                print()\n\nautomatic_abbreviations('daysOfWeek.txt', 7)\n"}
{"id": 17294, "name": "Cantor set", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CANTOR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 SETTINGS.\n          03 NUM-LINES     PIC 9 VALUE 5.\n          03 FILL-CHAR     PIC X VALUE '#'.\n       01 VARIABLES.\n          03 CUR-LINE.\n             05 CHAR       PIC X OCCURS 81 TIMES.\n          03 WIDTH         PIC 99.\n          03 CUR-SIZE      PIC 99.\n          03 POS           PIC 99.\n          03 MAXPOS        PIC 99.\n          03 NEXTPOS       PIC 99.\n          03 I             PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           COMPUTE WIDTH = 3 ** (NUM-LINES - 1).\n           PERFORM INIT.\n           MOVE WIDTH TO CUR-SIZE.\n           DISPLAY CUR-LINE.\n           PERFORM DO-LINE UNTIL CUR-SIZE IS EQUAL TO 1.\n           STOP RUN.\n           \n       INIT.\n           PERFORM INIT-CHAR VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN WIDTH.\n       \n       INIT-CHAR.\n           MOVE FILL-CHAR TO CHAR(I).\n           \n       DO-LINE.\n           DIVIDE 3 INTO CUR-SIZE.\n           MOVE 1 TO POS.\n           SUBTRACT CUR-SIZE FROM WIDTH GIVING MAXPOS.\n           PERFORM BLANK-REGIONS UNTIL POS IS GREATER THAN MAXPOS.\n           DISPLAY CUR-LINE.\n       \n       BLANK-REGIONS.\n           ADD CUR-SIZE TO POS.\n           PERFORM BLANK-CHAR CUR-SIZE TIMES.\n           \n       BLANK-CHAR.\n           MOVE SPACE TO CHAR(POS).\n           ADD 1 TO POS.\n", "target": "using System;\n\nnamespace CantorSet {\n    class Program {\n        const int WIDTH = 81;\n        const int HEIGHT = 5;\n        private static char[,] lines = new char[HEIGHT, WIDTH];\n\n        static Program() {\n            for (int i = 0; i < HEIGHT; i++) {\n                for (int j = 0; j < WIDTH; j++) {\n                    lines[i, j] = '*';\n                }\n            }\n        }\n\n        private static void Cantor(int start, int len, int index) {\n            int seg = len / 3;\n            if (seg == 0) return;\n            for (int i = index; i < HEIGHT; i++) {\n                for (int j = start + seg; j < start + seg * 2; j++) {\n                    lines[i, j] = ' ';\n                }\n            }\n            Cantor(start, seg, index + 1);\n            Cantor(start + seg * 2, seg, index + 1);\n        }\n\n        static void Main(string[] args) {\n            Cantor(0, WIDTH, 1);\n            for (int i = 0; i < HEIGHT; i++) {\n                for (int j = 0; j < WIDTH; j++) {\n                    Console.Write(lines[i,j]);\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 17295, "name": "Cantor set", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CANTOR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 SETTINGS.\n          03 NUM-LINES     PIC 9 VALUE 5.\n          03 FILL-CHAR     PIC X VALUE '#'.\n       01 VARIABLES.\n          03 CUR-LINE.\n             05 CHAR       PIC X OCCURS 81 TIMES.\n          03 WIDTH         PIC 99.\n          03 CUR-SIZE      PIC 99.\n          03 POS           PIC 99.\n          03 MAXPOS        PIC 99.\n          03 NEXTPOS       PIC 99.\n          03 I             PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           COMPUTE WIDTH = 3 ** (NUM-LINES - 1).\n           PERFORM INIT.\n           MOVE WIDTH TO CUR-SIZE.\n           DISPLAY CUR-LINE.\n           PERFORM DO-LINE UNTIL CUR-SIZE IS EQUAL TO 1.\n           STOP RUN.\n           \n       INIT.\n           PERFORM INIT-CHAR VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN WIDTH.\n       \n       INIT-CHAR.\n           MOVE FILL-CHAR TO CHAR(I).\n           \n       DO-LINE.\n           DIVIDE 3 INTO CUR-SIZE.\n           MOVE 1 TO POS.\n           SUBTRACT CUR-SIZE FROM WIDTH GIVING MAXPOS.\n           PERFORM BLANK-REGIONS UNTIL POS IS GREATER THAN MAXPOS.\n           DISPLAY CUR-LINE.\n       \n       BLANK-REGIONS.\n           ADD CUR-SIZE TO POS.\n           PERFORM BLANK-CHAR CUR-SIZE TIMES.\n           \n       BLANK-CHAR.\n           MOVE SPACE TO CHAR(POS).\n           ADD 1 TO POS.\n", "target": "using System;\n\nnamespace CantorSet {\n    class Program {\n        const int WIDTH = 81;\n        const int HEIGHT = 5;\n        private static char[,] lines = new char[HEIGHT, WIDTH];\n\n        static Program() {\n            for (int i = 0; i < HEIGHT; i++) {\n                for (int j = 0; j < WIDTH; j++) {\n                    lines[i, j] = '*';\n                }\n            }\n        }\n\n        private static void Cantor(int start, int len, int index) {\n            int seg = len / 3;\n            if (seg == 0) return;\n            for (int i = index; i < HEIGHT; i++) {\n                for (int j = start + seg; j < start + seg * 2; j++) {\n                    lines[i, j] = ' ';\n                }\n            }\n            Cantor(start, seg, index + 1);\n            Cantor(start + seg * 2, seg, index + 1);\n        }\n\n        static void Main(string[] args) {\n            Cantor(0, WIDTH, 1);\n            for (int i = 0; i < HEIGHT; i++) {\n                for (int j = 0; j < WIDTH; j++) {\n                    Console.Write(lines[i,j]);\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 17298, "name": "Cantor set", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CANTOR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 SETTINGS.\n          03 NUM-LINES     PIC 9 VALUE 5.\n          03 FILL-CHAR     PIC X VALUE '#'.\n       01 VARIABLES.\n          03 CUR-LINE.\n             05 CHAR       PIC X OCCURS 81 TIMES.\n          03 WIDTH         PIC 99.\n          03 CUR-SIZE      PIC 99.\n          03 POS           PIC 99.\n          03 MAXPOS        PIC 99.\n          03 NEXTPOS       PIC 99.\n          03 I             PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           COMPUTE WIDTH = 3 ** (NUM-LINES - 1).\n           PERFORM INIT.\n           MOVE WIDTH TO CUR-SIZE.\n           DISPLAY CUR-LINE.\n           PERFORM DO-LINE UNTIL CUR-SIZE IS EQUAL TO 1.\n           STOP RUN.\n           \n       INIT.\n           PERFORM INIT-CHAR VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN WIDTH.\n       \n       INIT-CHAR.\n           MOVE FILL-CHAR TO CHAR(I).\n           \n       DO-LINE.\n           DIVIDE 3 INTO CUR-SIZE.\n           MOVE 1 TO POS.\n           SUBTRACT CUR-SIZE FROM WIDTH GIVING MAXPOS.\n           PERFORM BLANK-REGIONS UNTIL POS IS GREATER THAN MAXPOS.\n           DISPLAY CUR-LINE.\n       \n       BLANK-REGIONS.\n           ADD CUR-SIZE TO POS.\n           PERFORM BLANK-CHAR CUR-SIZE TIMES.\n           \n       BLANK-CHAR.\n           MOVE SPACE TO CHAR(POS).\n           ADD 1 TO POS.\n", "target": "public class App {\n    private static final int WIDTH = 81;\n    private static final int HEIGHT = 5;\n\n    private static char[][] lines;\n    static {\n        lines = new char[HEIGHT][WIDTH];\n        for (int i = 0; i < HEIGHT; i++) {\n            for (int j = 0; j < WIDTH; j++) {\n                lines[i][j] = '*';\n            }\n        }\n    }\n\n    private static void cantor(int start, int len, int index) {\n        int seg = len / 3;\n        if (seg == 0) return;\n        for (int i = index; i < HEIGHT; i++) {\n            for (int j = start + seg; j < start + seg * 2; j++) {\n                lines[i][j] = ' ';\n            }\n        }\n        cantor(start, seg, index + 1);\n        cantor(start + seg * 2, seg, index + 1);\n    }\n\n    public static void main(String[] args) {\n        cantor(0, WIDTH, 1);\n        for (int i = 0; i < HEIGHT; i++) {\n            for (int j = 0; j < WIDTH; j++) {\n                System.out.print(lines[i][j]);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 17299, "name": "Cantor set", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CANTOR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 SETTINGS.\n          03 NUM-LINES     PIC 9 VALUE 5.\n          03 FILL-CHAR     PIC X VALUE '#'.\n       01 VARIABLES.\n          03 CUR-LINE.\n             05 CHAR       PIC X OCCURS 81 TIMES.\n          03 WIDTH         PIC 99.\n          03 CUR-SIZE      PIC 99.\n          03 POS           PIC 99.\n          03 MAXPOS        PIC 99.\n          03 NEXTPOS       PIC 99.\n          03 I             PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           COMPUTE WIDTH = 3 ** (NUM-LINES - 1).\n           PERFORM INIT.\n           MOVE WIDTH TO CUR-SIZE.\n           DISPLAY CUR-LINE.\n           PERFORM DO-LINE UNTIL CUR-SIZE IS EQUAL TO 1.\n           STOP RUN.\n           \n       INIT.\n           PERFORM INIT-CHAR VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN WIDTH.\n       \n       INIT-CHAR.\n           MOVE FILL-CHAR TO CHAR(I).\n           \n       DO-LINE.\n           DIVIDE 3 INTO CUR-SIZE.\n           MOVE 1 TO POS.\n           SUBTRACT CUR-SIZE FROM WIDTH GIVING MAXPOS.\n           PERFORM BLANK-REGIONS UNTIL POS IS GREATER THAN MAXPOS.\n           DISPLAY CUR-LINE.\n       \n       BLANK-REGIONS.\n           ADD CUR-SIZE TO POS.\n           PERFORM BLANK-CHAR CUR-SIZE TIMES.\n           \n       BLANK-CHAR.\n           MOVE SPACE TO CHAR(POS).\n           ADD 1 TO POS.\n", "target": "public class App {\n    private static final int WIDTH = 81;\n    private static final int HEIGHT = 5;\n\n    private static char[][] lines;\n    static {\n        lines = new char[HEIGHT][WIDTH];\n        for (int i = 0; i < HEIGHT; i++) {\n            for (int j = 0; j < WIDTH; j++) {\n                lines[i][j] = '*';\n            }\n        }\n    }\n\n    private static void cantor(int start, int len, int index) {\n        int seg = len / 3;\n        if (seg == 0) return;\n        for (int i = index; i < HEIGHT; i++) {\n            for (int j = start + seg; j < start + seg * 2; j++) {\n                lines[i][j] = ' ';\n            }\n        }\n        cantor(start, seg, index + 1);\n        cantor(start + seg * 2, seg, index + 1);\n    }\n\n    public static void main(String[] args) {\n        cantor(0, WIDTH, 1);\n        for (int i = 0; i < HEIGHT; i++) {\n            for (int j = 0; j < WIDTH; j++) {\n                System.out.print(lines[i][j]);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 17300, "name": "Cantor set", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CANTOR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 SETTINGS.\n          03 NUM-LINES     PIC 9 VALUE 5.\n          03 FILL-CHAR     PIC X VALUE '#'.\n       01 VARIABLES.\n          03 CUR-LINE.\n             05 CHAR       PIC X OCCURS 81 TIMES.\n          03 WIDTH         PIC 99.\n          03 CUR-SIZE      PIC 99.\n          03 POS           PIC 99.\n          03 MAXPOS        PIC 99.\n          03 NEXTPOS       PIC 99.\n          03 I             PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           COMPUTE WIDTH = 3 ** (NUM-LINES - 1).\n           PERFORM INIT.\n           MOVE WIDTH TO CUR-SIZE.\n           DISPLAY CUR-LINE.\n           PERFORM DO-LINE UNTIL CUR-SIZE IS EQUAL TO 1.\n           STOP RUN.\n           \n       INIT.\n           PERFORM INIT-CHAR VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN WIDTH.\n       \n       INIT-CHAR.\n           MOVE FILL-CHAR TO CHAR(I).\n           \n       DO-LINE.\n           DIVIDE 3 INTO CUR-SIZE.\n           MOVE 1 TO POS.\n           SUBTRACT CUR-SIZE FROM WIDTH GIVING MAXPOS.\n           PERFORM BLANK-REGIONS UNTIL POS IS GREATER THAN MAXPOS.\n           DISPLAY CUR-LINE.\n       \n       BLANK-REGIONS.\n           ADD CUR-SIZE TO POS.\n           PERFORM BLANK-CHAR CUR-SIZE TIMES.\n           \n       BLANK-CHAR.\n           MOVE SPACE TO CHAR(POS).\n           ADD 1 TO POS.\n", "target": "WIDTH = 81\nHEIGHT = 5\n\nlines=[]\ndef cantor(start, len, index):\n    seg = len / 3\n    if seg == 0:\n        return None\n    for it in xrange(HEIGHT-index):\n        i = index + it\n        for jt in xrange(seg):\n            j = start + seg + jt\n            pos = i * WIDTH + j\n            lines[pos] = ' '\n    cantor(start,           seg, index + 1)\n    cantor(start + seg * 2, seg, index + 1)\n    return None\n\nlines = ['*'] * (WIDTH*HEIGHT)\ncantor(0, WIDTH, 1)\n\nfor i in xrange(HEIGHT):\n    beg = WIDTH * i\n    print ''.join(lines[beg : beg+WIDTH])\n"}
{"id": 17301, "name": "Cantor set", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CANTOR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 SETTINGS.\n          03 NUM-LINES     PIC 9 VALUE 5.\n          03 FILL-CHAR     PIC X VALUE '#'.\n       01 VARIABLES.\n          03 CUR-LINE.\n             05 CHAR       PIC X OCCURS 81 TIMES.\n          03 WIDTH         PIC 99.\n          03 CUR-SIZE      PIC 99.\n          03 POS           PIC 99.\n          03 MAXPOS        PIC 99.\n          03 NEXTPOS       PIC 99.\n          03 I             PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           COMPUTE WIDTH = 3 ** (NUM-LINES - 1).\n           PERFORM INIT.\n           MOVE WIDTH TO CUR-SIZE.\n           DISPLAY CUR-LINE.\n           PERFORM DO-LINE UNTIL CUR-SIZE IS EQUAL TO 1.\n           STOP RUN.\n           \n       INIT.\n           PERFORM INIT-CHAR VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN WIDTH.\n       \n       INIT-CHAR.\n           MOVE FILL-CHAR TO CHAR(I).\n           \n       DO-LINE.\n           DIVIDE 3 INTO CUR-SIZE.\n           MOVE 1 TO POS.\n           SUBTRACT CUR-SIZE FROM WIDTH GIVING MAXPOS.\n           PERFORM BLANK-REGIONS UNTIL POS IS GREATER THAN MAXPOS.\n           DISPLAY CUR-LINE.\n       \n       BLANK-REGIONS.\n           ADD CUR-SIZE TO POS.\n           PERFORM BLANK-CHAR CUR-SIZE TIMES.\n           \n       BLANK-CHAR.\n           MOVE SPACE TO CHAR(POS).\n           ADD 1 TO POS.\n", "target": "WIDTH = 81\nHEIGHT = 5\n\nlines=[]\ndef cantor(start, len, index):\n    seg = len / 3\n    if seg == 0:\n        return None\n    for it in xrange(HEIGHT-index):\n        i = index + it\n        for jt in xrange(seg):\n            j = start + seg + jt\n            pos = i * WIDTH + j\n            lines[pos] = ' '\n    cantor(start,           seg, index + 1)\n    cantor(start + seg * 2, seg, index + 1)\n    return None\n\nlines = ['*'] * (WIDTH*HEIGHT)\ncantor(0, WIDTH, 1)\n\nfor i in xrange(HEIGHT):\n    beg = WIDTH * i\n    print ''.join(lines[beg : beg+WIDTH])\n"}
{"id": 18097, "name": "Munchausen numbers", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MUNCHAUSEN.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE   PIC 9(4).\n          03 DIGITS      PIC 9 OCCURS 4 TIMES, REDEFINES CANDIDATE.\n          03 DIGIT       PIC 9.\n          03 POWER-SUM   PIC 9(5).\n\n       01 OUTPUT-LINE.\n          03 OUT-NUM     PIC ZZZ9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM MUNCHAUSEN-TEST VARYING CANDIDATE FROM 1 BY 1\n               UNTIL CANDIDATE IS GREATER THAN 6000.\n           STOP RUN.\n\n       MUNCHAUSEN-TEST.\n           MOVE ZERO TO POWER-SUM.\n           MOVE 1 TO DIGIT.\n           INSPECT CANDIDATE TALLYING DIGIT FOR LEADING '0'.\n           PERFORM ADD-DIGIT-POWER VARYING DIGIT FROM DIGIT BY 1\n               UNTIL DIGIT IS GREATER THAN 4.\n           IF POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO OUT-NUM,\n               DISPLAY OUTPUT-LINE.\n        \n       ADD-DIGIT-POWER.\n           COMPUTE POWER-SUM = \n                     POWER-SUM + DIGITS(DIGIT) ** DIGITS(DIGIT)\n", "target": "Func<char, int> toInt = c => c-'0';\n\nforeach (var i in Enumerable.Range(1,5000)\n\t.Where(n => n == n.ToString()\n\t\t.Sum(x => Math.Pow(toInt(x), toInt(x)))))\n\tConsole.WriteLine(i);\n"}
{"id": 18098, "name": "Munchausen numbers", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MUNCHAUSEN.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE   PIC 9(4).\n          03 DIGITS      PIC 9 OCCURS 4 TIMES, REDEFINES CANDIDATE.\n          03 DIGIT       PIC 9.\n          03 POWER-SUM   PIC 9(5).\n\n       01 OUTPUT-LINE.\n          03 OUT-NUM     PIC ZZZ9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM MUNCHAUSEN-TEST VARYING CANDIDATE FROM 1 BY 1\n               UNTIL CANDIDATE IS GREATER THAN 6000.\n           STOP RUN.\n\n       MUNCHAUSEN-TEST.\n           MOVE ZERO TO POWER-SUM.\n           MOVE 1 TO DIGIT.\n           INSPECT CANDIDATE TALLYING DIGIT FOR LEADING '0'.\n           PERFORM ADD-DIGIT-POWER VARYING DIGIT FROM DIGIT BY 1\n               UNTIL DIGIT IS GREATER THAN 4.\n           IF POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO OUT-NUM,\n               DISPLAY OUTPUT-LINE.\n        \n       ADD-DIGIT-POWER.\n           COMPUTE POWER-SUM = \n                     POWER-SUM + DIGITS(DIGIT) ** DIGITS(DIGIT)\n", "target": "Func<char, int> toInt = c => c-'0';\n\nforeach (var i in Enumerable.Range(1,5000)\n\t.Where(n => n == n.ToString()\n\t\t.Sum(x => Math.Pow(toInt(x), toInt(x)))))\n\tConsole.WriteLine(i);\n"}
{"id": 18101, "name": "Munchausen numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MUNCHAUSEN.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE   PIC 9(4).\n          03 DIGITS      PIC 9 OCCURS 4 TIMES, REDEFINES CANDIDATE.\n          03 DIGIT       PIC 9.\n          03 POWER-SUM   PIC 9(5).\n\n       01 OUTPUT-LINE.\n          03 OUT-NUM     PIC ZZZ9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM MUNCHAUSEN-TEST VARYING CANDIDATE FROM 1 BY 1\n               UNTIL CANDIDATE IS GREATER THAN 6000.\n           STOP RUN.\n\n       MUNCHAUSEN-TEST.\n           MOVE ZERO TO POWER-SUM.\n           MOVE 1 TO DIGIT.\n           INSPECT CANDIDATE TALLYING DIGIT FOR LEADING '0'.\n           PERFORM ADD-DIGIT-POWER VARYING DIGIT FROM DIGIT BY 1\n               UNTIL DIGIT IS GREATER THAN 4.\n           IF POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO OUT-NUM,\n               DISPLAY OUTPUT-LINE.\n        \n       ADD-DIGIT-POWER.\n           COMPUTE POWER-SUM = \n                     POWER-SUM + DIGITS(DIGIT) ** DIGITS(DIGIT)\n", "target": "public class Main {\n    public static void main(String[] args) {\n        for(int i = 0 ; i <= 5000 ; i++ ){\n            int val = String.valueOf(i).chars().map(x -> (int) Math.pow( x-48 ,x-48)).sum();\n            if( i == val){\n                System.out.println( i + \" (munchausen)\");\n            }\n        }\n    }\n}\n"}
{"id": 18102, "name": "Munchausen numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MUNCHAUSEN.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE   PIC 9(4).\n          03 DIGITS      PIC 9 OCCURS 4 TIMES, REDEFINES CANDIDATE.\n          03 DIGIT       PIC 9.\n          03 POWER-SUM   PIC 9(5).\n\n       01 OUTPUT-LINE.\n          03 OUT-NUM     PIC ZZZ9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM MUNCHAUSEN-TEST VARYING CANDIDATE FROM 1 BY 1\n               UNTIL CANDIDATE IS GREATER THAN 6000.\n           STOP RUN.\n\n       MUNCHAUSEN-TEST.\n           MOVE ZERO TO POWER-SUM.\n           MOVE 1 TO DIGIT.\n           INSPECT CANDIDATE TALLYING DIGIT FOR LEADING '0'.\n           PERFORM ADD-DIGIT-POWER VARYING DIGIT FROM DIGIT BY 1\n               UNTIL DIGIT IS GREATER THAN 4.\n           IF POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO OUT-NUM,\n               DISPLAY OUTPUT-LINE.\n        \n       ADD-DIGIT-POWER.\n           COMPUTE POWER-SUM = \n                     POWER-SUM + DIGITS(DIGIT) ** DIGITS(DIGIT)\n", "target": "public class Main {\n    public static void main(String[] args) {\n        for(int i = 0 ; i <= 5000 ; i++ ){\n            int val = String.valueOf(i).chars().map(x -> (int) Math.pow( x-48 ,x-48)).sum();\n            if( i == val){\n                System.out.println( i + \" (munchausen)\");\n            }\n        }\n    }\n}\n"}
{"id": 18103, "name": "Munchausen numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MUNCHAUSEN.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE   PIC 9(4).\n          03 DIGITS      PIC 9 OCCURS 4 TIMES, REDEFINES CANDIDATE.\n          03 DIGIT       PIC 9.\n          03 POWER-SUM   PIC 9(5).\n\n       01 OUTPUT-LINE.\n          03 OUT-NUM     PIC ZZZ9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM MUNCHAUSEN-TEST VARYING CANDIDATE FROM 1 BY 1\n               UNTIL CANDIDATE IS GREATER THAN 6000.\n           STOP RUN.\n\n       MUNCHAUSEN-TEST.\n           MOVE ZERO TO POWER-SUM.\n           MOVE 1 TO DIGIT.\n           INSPECT CANDIDATE TALLYING DIGIT FOR LEADING '0'.\n           PERFORM ADD-DIGIT-POWER VARYING DIGIT FROM DIGIT BY 1\n               UNTIL DIGIT IS GREATER THAN 4.\n           IF POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO OUT-NUM,\n               DISPLAY OUTPUT-LINE.\n        \n       ADD-DIGIT-POWER.\n           COMPUTE POWER-SUM = \n                     POWER-SUM + DIGITS(DIGIT) ** DIGITS(DIGIT)\n", "target": "for i in range(5000):\n    if i == sum(int(x) ** int(x) for x in str(i)):\n        print(i)\n"}
{"id": 18104, "name": "Munchausen numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MUNCHAUSEN.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE   PIC 9(4).\n          03 DIGITS      PIC 9 OCCURS 4 TIMES, REDEFINES CANDIDATE.\n          03 DIGIT       PIC 9.\n          03 POWER-SUM   PIC 9(5).\n\n       01 OUTPUT-LINE.\n          03 OUT-NUM     PIC ZZZ9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM MUNCHAUSEN-TEST VARYING CANDIDATE FROM 1 BY 1\n               UNTIL CANDIDATE IS GREATER THAN 6000.\n           STOP RUN.\n\n       MUNCHAUSEN-TEST.\n           MOVE ZERO TO POWER-SUM.\n           MOVE 1 TO DIGIT.\n           INSPECT CANDIDATE TALLYING DIGIT FOR LEADING '0'.\n           PERFORM ADD-DIGIT-POWER VARYING DIGIT FROM DIGIT BY 1\n               UNTIL DIGIT IS GREATER THAN 4.\n           IF POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO OUT-NUM,\n               DISPLAY OUTPUT-LINE.\n        \n       ADD-DIGIT-POWER.\n           COMPUTE POWER-SUM = \n                     POWER-SUM + DIGITS(DIGIT) ** DIGITS(DIGIT)\n", "target": "for i in range(5000):\n    if i == sum(int(x) ** int(x) for x in str(i)):\n        print(i)\n"}
{"id": 18705, "name": "Arithmetic_Complex", "source": "Translate COBOL to C#:       $SET SOURCEFORMAT \"FREE\"\n$SET ILUSING \"System\"\n$SET ILUSING \"System.Numerics\"\nclass-id Prog.\nmethod-id. Main static.\nprocedure division.\n    declare num as type Complex = type Complex::ImaginaryOne()\n    declare results as type Complex occurs any\n    set content of results to ((num + num), (num * num), (- num), (1 / num), type Complex::Conjugate(num))\n    perform varying result as type Complex thru results\n        display result\n    end-perform\nend method.\nend class.\n", "target": "namespace RosettaCode.Arithmetic.Complex\n{\n    using System;\n    using System.Numerics;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            var number = Complex.ImaginaryOne;\n            foreach (var result in new[] { number + number, number * number, -number, 1 / number, Complex.Conjugate(number) })\n            {\n                Console.WriteLine(result);\n            }\n        }\n    }\n}\n"}
{"id": 18707, "name": "Arithmetic_Complex", "source": "Translate COBOL to Java:       $SET SOURCEFORMAT \"FREE\"\n$SET ILUSING \"System\"\n$SET ILUSING \"System.Numerics\"\nclass-id Prog.\nmethod-id. Main static.\nprocedure division.\n    declare num as type Complex = type Complex::ImaginaryOne()\n    declare results as type Complex occurs any\n    set content of results to ((num + num), (num * num), (- num), (1 / num), type Complex::Conjugate(num))\n    perform varying result as type Complex thru results\n        display result\n    end-perform\nend method.\nend class.\n", "target": "public class Complex {\n    public final double real;\n    public final double imag;\n\n    public Complex() {\n        this(0, 0);\n    }\n\n    public Complex(double r, double i) {\n        real = r;\n        imag = i;\n    }\n\n    public Complex add(Complex b) {\n        return new Complex(this.real + b.real, this.imag + b.imag);\n    }\n\n    public Complex mult(Complex b) {\n        \n        return new Complex(this.real * b.real - this.imag * b.imag,\n                this.real * b.imag + this.imag * b.real);\n    }\n\n    public Complex inv() {\n        \n        double denom = real * real + imag * imag;\n        return new Complex(real / denom, -imag / denom);\n    }\n\n    public Complex neg() {\n        return new Complex(-real, -imag);\n    }\n\n    public Complex conj() {\n        return new Complex(real, -imag);\n    }\n\n    @Override\n    public String toString() {\n        return real + \" + \" + imag + \" * i\";\n    }\n\n    public static void main(String[] args) {\n        Complex a = new Complex(Math.PI, -5); \n        Complex b = new Complex(-1, 2.5);\n        System.out.println(a.neg());\n        System.out.println(a.add(b));\n        System.out.println(a.inv());\n        System.out.println(a.mult(b));\n        System.out.println(a.conj());\n    }\n}\n"}
{"id": 18708, "name": "Arithmetic_Complex", "source": "Translate COBOL to Python:       $SET SOURCEFORMAT \"FREE\"\n$SET ILUSING \"System\"\n$SET ILUSING \"System.Numerics\"\nclass-id Prog.\nmethod-id. Main static.\nprocedure division.\n    declare num as type Complex = type Complex::ImaginaryOne()\n    declare results as type Complex occurs any\n    set content of results to ((num + num), (num * num), (- num), (1 / num), type Complex::Conjugate(num))\n    perform varying result as type Complex thru results\n        display result\n    end-perform\nend method.\nend class.\n", "target": ">>> z1 = 1.5 + 3j\n>>> z2 = 1.5 + 1.5j\n>>> z1 + z2\n(3+4.5j)\n>>> z1 - z2\n1.5j\n>>> z1 * z2\n(-2.25+6.75j)\n>>> z1 / z2\n(1.5+0.5j)\n>>> - z1\n(-1.5-3j)\n>>> z1.conjugate()\n(1.5-3j)\n>>> abs(z1)\n3.3541019662496847\n>>> z1 ** z2\n(-1.1024829553277784-0.38306415117199333j)\n>>> z1.real\n1.5\n>>> z1.imag\n3.0\n>>>\n"}
{"id": 19446, "name": "Handle a signal", "source": "Translate COBOL to C#:        identification division.\n       program-id. signals.\n       data division.\n       working-storage section.\n       01 signal-flag  pic 9 external.\n          88 signalled value 1.\n       01 half-seconds usage binary-long.\n       01 start-time   usage binary-c-long.\n       01 end-time     usage binary-c-long.\n       01 handler      usage program-pointer.\n       01 SIGINT       constant as 2.\n\n       procedure division.\n       call \"gettimeofday\" using start-time null\n       set handler to entry \"handle-sigint\"\n       call \"signal\" using by value SIGINT by value handler\n\n       perform until exit\n           if signalled then exit perform end-if\n           call \"CBL_OC_NANOSLEEP\" using 500000000\n           if signalled then exit perform end-if\n           add 1 to half-seconds\n           display half-seconds\n       end-perform\n\n       call \"gettimeofday\" using end-time null\n       subtract start-time from end-time\n       display \"Program ran for \" end-time \" seconds\"\n       goback.\n       end program signals.\n\n       identification division.\n       program-id. handle-sigint.\n       data division.\n       working-storage section.\n       01 signal-flag  pic 9 external.\n\n       linkage section.\n       01 the-signal   usage binary-long.\n\n       procedure division using by value the-signal returning omitted.\n       move 1 to signal-flag\n       goback.\n       end program handle-sigint.\n", "target": "using System; \nclass Program\n{\n    static DateTime start;\n    static void Main(string[] args)\n    {\n        start = DateTime.Now;\n        \n        Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);\n        int counter = 0;\n        while (true)\n        {\n            Console.WriteLine(++counter);\n            System.Threading.Thread.Sleep(500);\n        }\n    }\n    static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n    {\n        var end = DateTime.Now;\n        Console.WriteLine(\"This program ran for {0:000.000} seconds.\", (end - start).TotalMilliseconds / 1000);\n        Environment.Exit(0);\n    }\n}\n"}
{"id": 19448, "name": "Handle a signal", "source": "Translate COBOL to Java:        identification division.\n       program-id. signals.\n       data division.\n       working-storage section.\n       01 signal-flag  pic 9 external.\n          88 signalled value 1.\n       01 half-seconds usage binary-long.\n       01 start-time   usage binary-c-long.\n       01 end-time     usage binary-c-long.\n       01 handler      usage program-pointer.\n       01 SIGINT       constant as 2.\n\n       procedure division.\n       call \"gettimeofday\" using start-time null\n       set handler to entry \"handle-sigint\"\n       call \"signal\" using by value SIGINT by value handler\n\n       perform until exit\n           if signalled then exit perform end-if\n           call \"CBL_OC_NANOSLEEP\" using 500000000\n           if signalled then exit perform end-if\n           add 1 to half-seconds\n           display half-seconds\n       end-perform\n\n       call \"gettimeofday\" using end-time null\n       subtract start-time from end-time\n       display \"Program ran for \" end-time \" seconds\"\n       goback.\n       end program signals.\n\n       identification division.\n       program-id. handle-sigint.\n       data division.\n       working-storage section.\n       01 signal-flag  pic 9 external.\n\n       linkage section.\n       01 the-signal   usage binary-long.\n\n       procedure division using by value the-signal returning omitted.\n       move 1 to signal-flag\n       goback.\n       end program handle-sigint.\n", "target": "import sun.misc.Signal;\nimport sun.misc.SignalHandler;\n\npublic class ExampleSignalHandler {\n    public static void main(String... args) throws InterruptedException {\n        final long start = System.nanoTime();\n        Signal.handle(new Signal(\"INT\"), new SignalHandler() {\n            public void handle(Signal sig) {\n                System.out.format(\"\\nProgram execution took %f seconds\\n\", (System.nanoTime() - start) / 1e9f);\n                System.exit(0);\n            }\n        });\n        int counter = 0;\n        while(true) {\n            System.out.println(counter++);\n            Thread.sleep(500);\n        }\n    }\n}\n"}
{"id": 19449, "name": "Handle a signal", "source": "Translate COBOL to Python:        identification division.\n       program-id. signals.\n       data division.\n       working-storage section.\n       01 signal-flag  pic 9 external.\n          88 signalled value 1.\n       01 half-seconds usage binary-long.\n       01 start-time   usage binary-c-long.\n       01 end-time     usage binary-c-long.\n       01 handler      usage program-pointer.\n       01 SIGINT       constant as 2.\n\n       procedure division.\n       call \"gettimeofday\" using start-time null\n       set handler to entry \"handle-sigint\"\n       call \"signal\" using by value SIGINT by value handler\n\n       perform until exit\n           if signalled then exit perform end-if\n           call \"CBL_OC_NANOSLEEP\" using 500000000\n           if signalled then exit perform end-if\n           add 1 to half-seconds\n           display half-seconds\n       end-perform\n\n       call \"gettimeofday\" using end-time null\n       subtract start-time from end-time\n       display \"Program ran for \" end-time \" seconds\"\n       goback.\n       end program signals.\n\n       identification division.\n       program-id. handle-sigint.\n       data division.\n       working-storage section.\n       01 signal-flag  pic 9 external.\n\n       linkage section.\n       01 the-signal   usage binary-long.\n\n       procedure division using by value the-signal returning omitted.\n       move 1 to signal-flag\n       goback.\n       end program handle-sigint.\n", "target": "import time\n\ndef counter():\n    n = 0\n    t1 = time.time()\n    while True:\n        try:\n            time.sleep(0.5)\n            n += 1\n            print n\n        except KeyboardInterrupt, e:\n            print 'Program has run for %5.3f seconds.' % (time.time() - t1)\n            break\n\ncounter()\n"}
{"id": 20689, "name": "Call a function in a shared library", "source": "Translate COBOL to C#:        identification division.\n       program-id. callsym.\n\n       data division.\n       working-storage section.\n       01 handle usage pointer.\n       01 addr   usage program-pointer.\n\n       procedure division.\n       call \"dlopen\" using\n           by reference null\n           by value 1\n           returning handle\n           on exception\n               display function exception-statement upon syserr\n               goback\n       end-call\n       if handle equal null then\n           display function module-id \": error getting dlopen handle\"\n             upon syserr\n           goback\n       end-if\n\n       call \"dlsym\" using\n           by value handle\n           by content z\"perror\"\n           returning addr\n       end-call\n       if addr equal null then\n           display function module-id \": error getting perror symbol\"\n              upon syserr\n       else\n           call addr returning omitted\n       end-if\n\n       goback.\n       end program callsym.\n", "target": "using System.Runtime.InteropServices;\n\nclass Program {\n    [DllImport(\"fakelib.dll\")]\n    public static extern int fakefunction(int args);\n\n    static void Main(string[] args) {\n        int r = fakefunction(10);\n    }\n}\n"}
{"id": 20690, "name": "Call a function in a shared library", "source": "Translate COBOL to Java:        identification division.\n       program-id. callsym.\n\n       data division.\n       working-storage section.\n       01 handle usage pointer.\n       01 addr   usage program-pointer.\n\n       procedure division.\n       call \"dlopen\" using\n           by reference null\n           by value 1\n           returning handle\n           on exception\n               display function exception-statement upon syserr\n               goback\n       end-call\n       if handle equal null then\n           display function module-id \": error getting dlopen handle\"\n             upon syserr\n           goback\n       end-if\n\n       call \"dlsym\" using\n           by value handle\n           by content z\"perror\"\n           returning addr\n       end-call\n       if addr equal null then\n           display function module-id \": error getting perror symbol\"\n              upon syserr\n       else\n           call addr returning omitted\n       end-if\n\n       goback.\n       end program callsym.\n", "target": "\n\nimport java.util.Collections;\nimport java.util.Random;\n\npublic class TrySort {\n    static boolean useC;\n    static {\n\ttry {\n\t    System.loadLibrary(\"TrySort\");\n\t    useC = true;\n\t} catch(UnsatisfiedLinkError e) {\n\t    useC = false;\n\t}\n    }\n    \n    static native void sortInC(int[] ary);\n    \n    static class IntList extends java.util.AbstractList<Integer> {\n\tint[] ary;\n\tIntList(int[] ary) { this.ary = ary; }\n\tpublic Integer get(int i) { return ary[i]; }\n\tpublic Integer set(int i, Integer j) {\n\t    Integer o = ary[i]; ary[i] = j; return o;\n\t}\n\tpublic int size() { return ary.length; }\n    }\n\n    static class ReverseAbsCmp\n\timplements java.util.Comparator<Integer>\n    {\n\tpublic int compare(Integer pa, Integer pb) {\n\t    \n\t    int a = pa > 0 ? -pa : pa;\n\t    int b = pb > 0 ? -pb : pb;\n\t    return a < b ? -1 : a > b ? 1 : 0;\n\t}\n    }\n    \n    static void sortInJava(int[] ary) {\n\tCollections.sort(new IntList(ary), new ReverseAbsCmp());\n    }\n\n    public static void main(String[] args) {\n\t\n\tint[] ary = new int[1000000];\n\tRandom rng = new Random();\n\tfor (int i = 0; i < ary.length; i++)\n\t    ary[i] = rng.nextInt();\n\n\t\n\tif (useC) {\n\t    System.out.print(\"Sorting in C...  \");\n\t    sortInC(ary);\n\t} else {\n\t    System.out.print\n\t\t(\"Missing library for C!  Sorting in Java...  \");\n\t    sortInJava(ary);\n\t}\n\n\tfor (int i = 0; i < ary.length - 1; i++) {\n\t    int a = ary[i];\n\t    int b = ary[i + 1];\n\t    if ((a > 0 ? -a : a) > (b > 0 ? -b : b)) {\n\t\tSystem.out.println(\"*BUG IN SORT*\");\n\t\tSystem.exit(1);\n\t    }\n\t}\n\tSystem.out.println(\"ok\");\n    }\n}\n"}
{"id": 20691, "name": "Call a function in a shared library", "source": "Translate COBOL to Python:        identification division.\n       program-id. callsym.\n\n       data division.\n       working-storage section.\n       01 handle usage pointer.\n       01 addr   usage program-pointer.\n\n       procedure division.\n       call \"dlopen\" using\n           by reference null\n           by value 1\n           returning handle\n           on exception\n               display function exception-statement upon syserr\n               goback\n       end-call\n       if handle equal null then\n           display function module-id \": error getting dlopen handle\"\n             upon syserr\n           goback\n       end-if\n\n       call \"dlsym\" using\n           by value handle\n           by content z\"perror\"\n           returning addr\n       end-call\n       if addr equal null then\n           display function module-id \": error getting perror symbol\"\n              upon syserr\n       else\n           call addr returning omitted\n       end-if\n\n       goback.\n       end program callsym.\n", "target": "import ctypes\n  \nuser32_dll = ctypes.cdll.LoadLibrary('User32.dll')\nprint user32_dll.GetDoubleClickTime()\n"}
{"id": 21757, "name": "Formatted numeric output", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. NUMERIC-OUTPUT-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-EXAMPLE.\n    05 X            PIC  9(5)V9(3).\nPROCEDURE DIVISION.\n    MOVE     7.125  TO   X.\n    DISPLAY  X      UPON CONSOLE.\n    STOP RUN.\n", "target": "class Program\n    {\n\n\n        static void Main(string[] args)\n        {\n\n            float myNumbers = 7.125F;\n            \n            string strnumber = Convert.ToString(myNumbers);\n                       \n            Console.WriteLine(strnumber.PadLeft(9, '0'));\n           \n            Console.ReadLine();\n        }\n        \n\n             \n       \n    }\n"}
{"id": 21759, "name": "Formatted numeric output", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. NUMERIC-OUTPUT-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-EXAMPLE.\n    05 X            PIC  9(5)V9(3).\nPROCEDURE DIVISION.\n    MOVE     7.125  TO   X.\n    DISPLAY  X      UPON CONSOLE.\n    STOP RUN.\n", "target": "public class Printing{\n\tpublic static void main(String[] args){\n\t\tdouble value = 7.125;\n\t\tSystem.out.printf(\"%09.3f\",value); \n\t\tSystem.out.println(String.format(\"%09.3f\",value));\n\t}\n}\n"}
{"id": 21760, "name": "Formatted numeric output", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. NUMERIC-OUTPUT-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-EXAMPLE.\n    05 X            PIC  9(5)V9(3).\nPROCEDURE DIVISION.\n    MOVE     7.125  TO   X.\n    DISPLAY  X      UPON CONSOLE.\n    STOP RUN.\n", "target": "from math import pi, exp\nr = exp(pi)-pi\nprint r\nprint \"e=%e f=%f g=%g G=%G s=%s r=%r!\"%(r,r,r,r,r,r)\nprint \"e=%9.4e f=%9.4f g=%9.4g!\"%(-r,-r,-r)\nprint \"e=%9.4e f=%9.4f g=%9.4g!\"%(r,r,r)\nprint \"e=%-9.4e f=%-9.4f g=%-9.4g!\"%(r,r,r)\nprint \"e=%09.4e f=%09.4f g=%09.4g!\"%(-r,-r,-r)\nprint \"e=%09.4e f=%09.4f g=%09.4g!\"%(r,r,r)\nprint \"e=%-09.4e f=%-09.4f g=%-09.4g!\"%(r,r,r)\n"}
{"id": 23620, "name": "String case", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. string-case-85.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  example PIC X(9) VALUE \"alphaBETA\".\n\n       01  result  PIC X(9).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Example: \" example\n\n           \n           DISPLAY \"Lower-case: \" FUNCTION LOWER-CASE(example)\n\n           DISPLAY \"Upper-case: \" FUNCTION UPPER-CASE(example)\n\n           \n           MOVE example TO result\n           INSPECT result CONVERTING \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n               TO \"abcdefghijklmnopqrstuvwxyz\"\n           DISPLAY \"Lower-case: \" result\n\n           MOVE example TO result\n           INSPECT result CONVERTING \"abcdefghijklmnopqrstuvwxyz\"\n               TO  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n           DISPLAY \"Upper-case: \" result\n\n           GOBACK\n           .\n", "target": "using System;\n\nnamespace StringCase\n{\n  class Program\n  {\n    public static void Main()\n    {\n      String input = scope .(\"alphaBETA\");\n      input.ToUpper();\n      Console.WriteLine(input);\n      input.ToLower();\n      Console.WriteLine(input);\n    }\n  }\n}\n"}
{"id": 23622, "name": "String case", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. string-case-85.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  example PIC X(9) VALUE \"alphaBETA\".\n\n       01  result  PIC X(9).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Example: \" example\n\n           \n           DISPLAY \"Lower-case: \" FUNCTION LOWER-CASE(example)\n\n           DISPLAY \"Upper-case: \" FUNCTION UPPER-CASE(example)\n\n           \n           MOVE example TO result\n           INSPECT result CONVERTING \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n               TO \"abcdefghijklmnopqrstuvwxyz\"\n           DISPLAY \"Lower-case: \" result\n\n           MOVE example TO result\n           INSPECT result CONVERTING \"abcdefghijklmnopqrstuvwxyz\"\n               TO  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n           DISPLAY \"Upper-case: \" result\n\n           GOBACK\n           .\n", "target": "String str = \"alphaBETA\";\nSystem.out.println(str.toUpperCase());\nSystem.out.println(str.toLowerCase());\n\nSystem.out.println(\"\u00e4\u00e0\u00e2\u00e1\u00e7\u00f1\u00df\u00e6\u03b5\u0431\u1ebf\".toUpperCase());\nSystem.out.println(\"\u00c4\u00c0\u00c2\u00c1\u00c7\u00d1SS\u00c6\u0395\u0411\u1ebe\".toLowerCase()); \n"}
{"id": 23623, "name": "String case", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. string-case-85.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  example PIC X(9) VALUE \"alphaBETA\".\n\n       01  result  PIC X(9).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Example: \" example\n\n           \n           DISPLAY \"Lower-case: \" FUNCTION LOWER-CASE(example)\n\n           DISPLAY \"Upper-case: \" FUNCTION UPPER-CASE(example)\n\n           \n           MOVE example TO result\n           INSPECT result CONVERTING \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n               TO \"abcdefghijklmnopqrstuvwxyz\"\n           DISPLAY \"Lower-case: \" result\n\n           MOVE example TO result\n           INSPECT result CONVERTING \"abcdefghijklmnopqrstuvwxyz\"\n               TO  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n           DISPLAY \"Upper-case: \" result\n\n           GOBACK\n           .\n", "target": "s = \"alphaBETA\"\nprint s.upper() \nprint s.lower() \n\nprint s.swapcase() \n\nprint \"fOo bAR\".capitalize() \nprint \"fOo bAR\".title() \n\nimport string\nprint string.capwords(\"fOo bAR\") \n"}
{"id": 24460, "name": "Arithmetic-geometric mean", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. ARITHMETIC-GEOMETRIC-MEAN-PROG.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  AGM-VARS.\n    05 A       PIC 9V9(16).\n    05 A-ZERO  PIC 9V9(16).\n    05 G       PIC 9V9(16).\n    05 DIFF    PIC 9V9(16) VALUE 1.\n* Initialize DIFF with a non-zero value, otherwise AGM-PARAGRAPH\n* is never performed at all.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    MOVE    1 TO A.\n    COMPUTE G = 1 / FUNCTION SQRT(2).\n* The program will run with the test values. If you would rather\n* calculate the AGM of numbers input at the console, comment out\n* TEST-PARAGRAPH and un-comment-out INPUT-A-AND-G-PARAGRAPH.\n* INPUT-A-AND-G-PARAGRAPH.\n*     DISPLAY 'Enter two numbers.'\n*     ACCEPT  A.\n*     ACCEPT  G.\nCONTROL-PARAGRAPH.\n    PERFORM AGM-PARAGRAPH UNTIL DIFF IS LESS THAN 0.000000000000001.\n    DISPLAY A.\n    STOP RUN.\nAGM-PARAGRAPH.\n    MOVE     A TO A-ZERO.\n    COMPUTE  A = (A-ZERO + G) / 2.\n    MULTIPLY A-ZERO BY G GIVING G.\n    COMPUTE  G = FUNCTION SQRT(G).\n    SUBTRACT A FROM G GIVING DIFF.\n    COMPUTE  DIFF = FUNCTION ABS(DIFF).\n", "target": "namespace RosettaCode.ArithmeticGeometricMean\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n\n    internal static class Program\n    {\n        private static double ArithmeticGeometricMean(double number,\n                                                      double otherNumber,\n                                                      IEqualityComparer<double>\n                                                          comparer)\n        {\n            return comparer.Equals(number, otherNumber)\n                       ? number\n                       : ArithmeticGeometricMean(\n                           ArithmeticMean(number, otherNumber),\n                           GeometricMean(number, otherNumber), comparer);\n        }\n\n        private static double ArithmeticMean(double number, double otherNumber)\n        {\n            return 0.5 * (number + otherNumber);\n        }\n\n        private static double GeometricMean(double number, double otherNumber)\n        {\n            return Math.Sqrt(number * otherNumber);\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),\n                                        new RelativeDifferenceComparer(1e-5)).\n                    ToString(CultureInfo.InvariantCulture));\n        }\n\n        private class RelativeDifferenceComparer : IEqualityComparer<double>\n        {\n            private readonly double _maximumRelativeDifference;\n\n            internal RelativeDifferenceComparer(double maximumRelativeDifference)\n            {\n                _maximumRelativeDifference = maximumRelativeDifference;\n            }\n\n            public bool Equals(double number, double otherNumber)\n            {\n                return RelativeDifference(number, otherNumber) <=\n                       _maximumRelativeDifference;\n            }\n\n            public int GetHashCode(double number)\n            {\n                return number.GetHashCode();\n            }\n\n            private static double RelativeDifference(double number,\n                                                     double otherNumber)\n            {\n                return AbsoluteDifference(number, otherNumber) /\n                       Norm(number, otherNumber);\n            }\n\n            private static double AbsoluteDifference(double number,\n                                                     double otherNumber)\n            {\n                return Math.Abs(number - otherNumber);\n            }\n\n            private static double Norm(double number, double otherNumber)\n            {\n                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));\n            }\n        }\n    }\n}\n"}
{"id": 24461, "name": "Arithmetic-geometric mean", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. ARITHMETIC-GEOMETRIC-MEAN-PROG.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  AGM-VARS.\n    05 A       PIC 9V9(16).\n    05 A-ZERO  PIC 9V9(16).\n    05 G       PIC 9V9(16).\n    05 DIFF    PIC 9V9(16) VALUE 1.\n* Initialize DIFF with a non-zero value, otherwise AGM-PARAGRAPH\n* is never performed at all.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    MOVE    1 TO A.\n    COMPUTE G = 1 / FUNCTION SQRT(2).\n* The program will run with the test values. If you would rather\n* calculate the AGM of numbers input at the console, comment out\n* TEST-PARAGRAPH and un-comment-out INPUT-A-AND-G-PARAGRAPH.\n* INPUT-A-AND-G-PARAGRAPH.\n*     DISPLAY 'Enter two numbers.'\n*     ACCEPT  A.\n*     ACCEPT  G.\nCONTROL-PARAGRAPH.\n    PERFORM AGM-PARAGRAPH UNTIL DIFF IS LESS THAN 0.000000000000001.\n    DISPLAY A.\n    STOP RUN.\nAGM-PARAGRAPH.\n    MOVE     A TO A-ZERO.\n    COMPUTE  A = (A-ZERO + G) / 2.\n    MULTIPLY A-ZERO BY G GIVING G.\n    COMPUTE  G = FUNCTION SQRT(G).\n    SUBTRACT A FROM G GIVING DIFF.\n    COMPUTE  DIFF = FUNCTION ABS(DIFF).\n", "target": "namespace RosettaCode.ArithmeticGeometricMean\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n\n    internal static class Program\n    {\n        private static double ArithmeticGeometricMean(double number,\n                                                      double otherNumber,\n                                                      IEqualityComparer<double>\n                                                          comparer)\n        {\n            return comparer.Equals(number, otherNumber)\n                       ? number\n                       : ArithmeticGeometricMean(\n                           ArithmeticMean(number, otherNumber),\n                           GeometricMean(number, otherNumber), comparer);\n        }\n\n        private static double ArithmeticMean(double number, double otherNumber)\n        {\n            return 0.5 * (number + otherNumber);\n        }\n\n        private static double GeometricMean(double number, double otherNumber)\n        {\n            return Math.Sqrt(number * otherNumber);\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),\n                                        new RelativeDifferenceComparer(1e-5)).\n                    ToString(CultureInfo.InvariantCulture));\n        }\n\n        private class RelativeDifferenceComparer : IEqualityComparer<double>\n        {\n            private readonly double _maximumRelativeDifference;\n\n            internal RelativeDifferenceComparer(double maximumRelativeDifference)\n            {\n                _maximumRelativeDifference = maximumRelativeDifference;\n            }\n\n            public bool Equals(double number, double otherNumber)\n            {\n                return RelativeDifference(number, otherNumber) <=\n                       _maximumRelativeDifference;\n            }\n\n            public int GetHashCode(double number)\n            {\n                return number.GetHashCode();\n            }\n\n            private static double RelativeDifference(double number,\n                                                     double otherNumber)\n            {\n                return AbsoluteDifference(number, otherNumber) /\n                       Norm(number, otherNumber);\n            }\n\n            private static double AbsoluteDifference(double number,\n                                                     double otherNumber)\n            {\n                return Math.Abs(number - otherNumber);\n            }\n\n            private static double Norm(double number, double otherNumber)\n            {\n                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));\n            }\n        }\n    }\n}\n"}
{"id": 24464, "name": "Arithmetic-geometric mean", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. ARITHMETIC-GEOMETRIC-MEAN-PROG.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  AGM-VARS.\n    05 A       PIC 9V9(16).\n    05 A-ZERO  PIC 9V9(16).\n    05 G       PIC 9V9(16).\n    05 DIFF    PIC 9V9(16) VALUE 1.\n* Initialize DIFF with a non-zero value, otherwise AGM-PARAGRAPH\n* is never performed at all.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    MOVE    1 TO A.\n    COMPUTE G = 1 / FUNCTION SQRT(2).\n* The program will run with the test values. If you would rather\n* calculate the AGM of numbers input at the console, comment out\n* TEST-PARAGRAPH and un-comment-out INPUT-A-AND-G-PARAGRAPH.\n* INPUT-A-AND-G-PARAGRAPH.\n*     DISPLAY 'Enter two numbers.'\n*     ACCEPT  A.\n*     ACCEPT  G.\nCONTROL-PARAGRAPH.\n    PERFORM AGM-PARAGRAPH UNTIL DIFF IS LESS THAN 0.000000000000001.\n    DISPLAY A.\n    STOP RUN.\nAGM-PARAGRAPH.\n    MOVE     A TO A-ZERO.\n    COMPUTE  A = (A-ZERO + G) / 2.\n    MULTIPLY A-ZERO BY G GIVING G.\n    COMPUTE  G = FUNCTION SQRT(G).\n    SUBTRACT A FROM G GIVING DIFF.\n    COMPUTE  DIFF = FUNCTION ABS(DIFF).\n", "target": "\npublic class ArithmeticGeometricMean {\n\n    public static double agm(double a, double g) {\n        double a1 = a;\n        double g1 = g;\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\n            double arith = (a1 + g1) / 2.0;\n            double geom = Math.sqrt(a1 * g1);\n            a1 = arith;\n            g1 = geom;\n        }\n        return a1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\n    }\n}\n"}
{"id": 24465, "name": "Arithmetic-geometric mean", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. ARITHMETIC-GEOMETRIC-MEAN-PROG.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  AGM-VARS.\n    05 A       PIC 9V9(16).\n    05 A-ZERO  PIC 9V9(16).\n    05 G       PIC 9V9(16).\n    05 DIFF    PIC 9V9(16) VALUE 1.\n* Initialize DIFF with a non-zero value, otherwise AGM-PARAGRAPH\n* is never performed at all.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    MOVE    1 TO A.\n    COMPUTE G = 1 / FUNCTION SQRT(2).\n* The program will run with the test values. If you would rather\n* calculate the AGM of numbers input at the console, comment out\n* TEST-PARAGRAPH and un-comment-out INPUT-A-AND-G-PARAGRAPH.\n* INPUT-A-AND-G-PARAGRAPH.\n*     DISPLAY 'Enter two numbers.'\n*     ACCEPT  A.\n*     ACCEPT  G.\nCONTROL-PARAGRAPH.\n    PERFORM AGM-PARAGRAPH UNTIL DIFF IS LESS THAN 0.000000000000001.\n    DISPLAY A.\n    STOP RUN.\nAGM-PARAGRAPH.\n    MOVE     A TO A-ZERO.\n    COMPUTE  A = (A-ZERO + G) / 2.\n    MULTIPLY A-ZERO BY G GIVING G.\n    COMPUTE  G = FUNCTION SQRT(G).\n    SUBTRACT A FROM G GIVING DIFF.\n    COMPUTE  DIFF = FUNCTION ABS(DIFF).\n", "target": "\npublic class ArithmeticGeometricMean {\n\n    public static double agm(double a, double g) {\n        double a1 = a;\n        double g1 = g;\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\n            double arith = (a1 + g1) / 2.0;\n            double geom = Math.sqrt(a1 * g1);\n            a1 = arith;\n            g1 = geom;\n        }\n        return a1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\n    }\n}\n"}
{"id": 24466, "name": "Arithmetic-geometric mean", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. ARITHMETIC-GEOMETRIC-MEAN-PROG.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  AGM-VARS.\n    05 A       PIC 9V9(16).\n    05 A-ZERO  PIC 9V9(16).\n    05 G       PIC 9V9(16).\n    05 DIFF    PIC 9V9(16) VALUE 1.\n* Initialize DIFF with a non-zero value, otherwise AGM-PARAGRAPH\n* is never performed at all.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    MOVE    1 TO A.\n    COMPUTE G = 1 / FUNCTION SQRT(2).\n* The program will run with the test values. If you would rather\n* calculate the AGM of numbers input at the console, comment out\n* TEST-PARAGRAPH and un-comment-out INPUT-A-AND-G-PARAGRAPH.\n* INPUT-A-AND-G-PARAGRAPH.\n*     DISPLAY 'Enter two numbers.'\n*     ACCEPT  A.\n*     ACCEPT  G.\nCONTROL-PARAGRAPH.\n    PERFORM AGM-PARAGRAPH UNTIL DIFF IS LESS THAN 0.000000000000001.\n    DISPLAY A.\n    STOP RUN.\nAGM-PARAGRAPH.\n    MOVE     A TO A-ZERO.\n    COMPUTE  A = (A-ZERO + G) / 2.\n    MULTIPLY A-ZERO BY G GIVING G.\n    COMPUTE  G = FUNCTION SQRT(G).\n    SUBTRACT A FROM G GIVING DIFF.\n    COMPUTE  DIFF = FUNCTION ABS(DIFF).\n", "target": "from math import sqrt\n\ndef agm(a0, g0, tolerance=1e-10):\n    \n    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)\n    while abs(an - gn) > tolerance:\n        an, gn = (an + gn) / 2.0, sqrt(an * gn)\n    return an\n\nprint agm(1, 1 / sqrt(2))\n"}
{"id": 24467, "name": "Arithmetic-geometric mean", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. ARITHMETIC-GEOMETRIC-MEAN-PROG.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  AGM-VARS.\n    05 A       PIC 9V9(16).\n    05 A-ZERO  PIC 9V9(16).\n    05 G       PIC 9V9(16).\n    05 DIFF    PIC 9V9(16) VALUE 1.\n* Initialize DIFF with a non-zero value, otherwise AGM-PARAGRAPH\n* is never performed at all.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    MOVE    1 TO A.\n    COMPUTE G = 1 / FUNCTION SQRT(2).\n* The program will run with the test values. If you would rather\n* calculate the AGM of numbers input at the console, comment out\n* TEST-PARAGRAPH and un-comment-out INPUT-A-AND-G-PARAGRAPH.\n* INPUT-A-AND-G-PARAGRAPH.\n*     DISPLAY 'Enter two numbers.'\n*     ACCEPT  A.\n*     ACCEPT  G.\nCONTROL-PARAGRAPH.\n    PERFORM AGM-PARAGRAPH UNTIL DIFF IS LESS THAN 0.000000000000001.\n    DISPLAY A.\n    STOP RUN.\nAGM-PARAGRAPH.\n    MOVE     A TO A-ZERO.\n    COMPUTE  A = (A-ZERO + G) / 2.\n    MULTIPLY A-ZERO BY G GIVING G.\n    COMPUTE  G = FUNCTION SQRT(G).\n    SUBTRACT A FROM G GIVING DIFF.\n    COMPUTE  DIFF = FUNCTION ABS(DIFF).\n", "target": "from math import sqrt\n\ndef agm(a0, g0, tolerance=1e-10):\n    \n    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)\n    while abs(an - gn) > tolerance:\n        an, gn = (an + gn) / 2.0, sqrt(an * gn)\n    return an\n\nprint agm(1, 1 / sqrt(2))\n"}
{"id": 25622, "name": "Day of the week", "source": "Translate COBOL to C#:        program-id. dec25.\n       data division.\n       working-storage section.\n       1 work-date.\n        2 yr pic 9(4) value 2008.\n        2 mo-da pic 9(4) value 1225. \n       1 wk-date redefines work-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n       procedure division.\n           perform varying yr from 2008 by 1\n           until yr > 2121\n               compute int-date = function integer-of-date (wk-date)\n               compute dow = function mod ((int-date - 1) 7) + 1\n               if dow = 7  \n                   display yr\n               end-if\n           end-perform\n           stop run\n           .\n       end program dec25.\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 2008; i <= 2121; i++)\n        {\n            DateTime date = new DateTime(i, 12, 25);\n            if (date.DayOfWeek == DayOfWeek.Sunday)\n            {\n                Console.WriteLine(date.ToString(\"dd MMM yyyy\"));\n            }\n        }\n    }\n}\n"}
{"id": 25624, "name": "Day of the week", "source": "Translate COBOL to Java:        program-id. dec25.\n       data division.\n       working-storage section.\n       1 work-date.\n        2 yr pic 9(4) value 2008.\n        2 mo-da pic 9(4) value 1225. \n       1 wk-date redefines work-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n       procedure division.\n           perform varying yr from 2008 by 1\n           until yr > 2121\n               compute int-date = function integer-of-date (wk-date)\n               compute dow = function mod ((int-date - 1) 7) + 1\n               if dow = 7  \n                   display yr\n               end-if\n           end-perform\n           stop run\n           .\n       end program dec25.\n", "target": "import java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\n\npublic class Yuletide{\n\tpublic static void main(String[] args) {\n\t\tfor(int i = 2008;i<=2121;i++){\n\t\t\tCalendar cal = new GregorianCalendar(i, Calendar.DECEMBER,\n\t\t\t\t\t25);\n\t\t\tif(cal.get(Calendar.DAY_OF_WEEK)==Calendar.SUNDAY){\n\t\t\t\tSystem.out.println(cal.getTime());\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 25625, "name": "Day of the week", "source": "Translate COBOL to Python:        program-id. dec25.\n       data division.\n       working-storage section.\n       1 work-date.\n        2 yr pic 9(4) value 2008.\n        2 mo-da pic 9(4) value 1225. \n       1 wk-date redefines work-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n       procedure division.\n           perform varying yr from 2008 by 1\n           until yr > 2121\n               compute int-date = function integer-of-date (wk-date)\n               compute dow = function mod ((int-date - 1) 7) + 1\n               if dow = 7  \n                   display yr\n               end-if\n           end-perform\n           stop run\n           .\n       end program dec25.\n", "target": "from calendar import weekday, SUNDAY\n\n[year for year in range(2008, 2122) if weekday(year, 12, 25) == SUNDAY]\n"}
{"id": 26702, "name": "ISBN13 check digit", "source": "Translate COBOL to C#:       ******************************************************************\n      * Author: Jay Moseley\n      * Date: November 10, 2019\n      * Purpose: Testing various subprograms/ functions.\n      * Tectonics: cobc -xj testSubs.cbl\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       PROGRAM-ID. testSubs.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC\n           FUNCTION validISBN13.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  IX                          PIC S9(4) COMP.\n       01  TEST-ISBNS.\n           02  FILLER                  PIC X(14) VALUE '978-1734314502'.\n           02  FILLER                  PIC X(14) VALUE '978-1734314509'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399081'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399083'.\n       01  TEST-ISBN                   REDEFINES TEST-ISBNS\n                                       OCCURS 4 TIMES\n                                       PIC X(14).\n\n       PROCEDURE DIVISION.\n\n       MAIN-PROCEDURE.\n\n           PERFORM \n             VARYING IX \n             FROM 1\n             BY 1\n             UNTIL IX > 4\n\n             DISPLAY TEST-ISBN (IX) '   ' WITH NO ADVANCING\n             END-DISPLAY\n             IF validISBN13(TEST-ISBN (IX)) = -1\n               DISPLAY '(bad)'\n             ELSE\n               DISPLAY '(good)'\n             END-IF\n\n           END-PERFORM.\n\n           GOBACK.\n\n       END PROGRAM testSubs.\n\n      ******************************************************************\n      * Author: Jay Moseley\n      * Date: May 19, 2016\n      * Purpose: validate ISBN-13 (International Standard\n      *          Book Number).\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       FUNCTION-ID. validISBN13.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  PASSED-SIZE                 PIC S9(6) COMP-5.\n       01  IX                          PIC S9(4) COMP.\n\n       01  WORK-FIELDS.\n           02  WF-DIGIT                PIC X.\n           02  WF-COUNT                PIC 9(2).\n               88  WEIGHT-1  VALUE 1, 3, 5, 7, 9, 11, 13.\n               88  WEIGHT-3  VALUE 2, 4, 6, 8, 10, 12.\n           02  WF-SUM                  PIC S9(8) COMP.\n\n       LINKAGE SECTION.\n\n       01  PASSED-ISBN                 PIC X ANY LENGTH.\n       01  RETURN-VALUE                PIC S9.\n\n       PROCEDURE DIVISION USING PASSED-ISBN\n                          RETURNING RETURN-VALUE.\n\n           CALL 'C$PARAMSIZE'\n             USING 1\n             GIVING PASSED-SIZE\n           END-CALL.\n       \n       COMPUTE-CKDIGIT.\n\n           INITIALIZE WORK-FIELDS.\n           PERFORM \n             VARYING IX \n             FROM 1 \n             BY 1\n             UNTIL IX GREATER THAN PASSED-SIZE\n\n               MOVE PASSED-ISBN (IX:1) TO WF-DIGIT\n               IF WF-DIGIT IS NUMERIC\n                 ADD 1 TO WF-COUNT\n                 IF WEIGHT-1\n                   ADD NUMVAL(WF-DIGIT) TO WF-SUM\n                 ELSE\n                   COMPUTE WF-SUM = WF-SUM + \n                     (NUMVAL(WF-DIGIT) * 3)\n                   END-COMPUTE\n                 END-IF\n               END-IF\n\n           END-PERFORM.\n\n           IF MOD(WF-SUM, 10) = 0\n             MOVE +0 TO RETURN-VALUE\n           ELSE\n             MOVE -1 TO RETURN-VALUE\n           END-IF.\n\n           GOBACK.\n      * - - - - - - - - - - - - - - - - - - - - - - PROGRAM EXIT POINT\n\n       END FUNCTION validISBN13.\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(CheckISBN13(\"978-1734314502\"));\n        Console.WriteLine(CheckISBN13(\"978-1734314509\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399081\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399083\"));\n\n        static bool CheckISBN13(string code) {\n            code = code.Replace(\"-\", \"\").Replace(\" \", \"\");\n            if (code.Length != 13) return false;\n            int sum = 0;\n            foreach (var (index, digit) in code.Select((digit, index) => (index, digit))) {\n                if (char.IsDigit(digit)) sum += (digit - '0') * (index % 2 == 0 ? 1 : 3);\n                else return false;\n            }\n            return sum % 10 == 0;\n        }\n    }\n}\n"}
{"id": 26703, "name": "ISBN13 check digit", "source": "Translate COBOL to C#:       ******************************************************************\n      * Author: Jay Moseley\n      * Date: November 10, 2019\n      * Purpose: Testing various subprograms/ functions.\n      * Tectonics: cobc -xj testSubs.cbl\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       PROGRAM-ID. testSubs.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC\n           FUNCTION validISBN13.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  IX                          PIC S9(4) COMP.\n       01  TEST-ISBNS.\n           02  FILLER                  PIC X(14) VALUE '978-1734314502'.\n           02  FILLER                  PIC X(14) VALUE '978-1734314509'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399081'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399083'.\n       01  TEST-ISBN                   REDEFINES TEST-ISBNS\n                                       OCCURS 4 TIMES\n                                       PIC X(14).\n\n       PROCEDURE DIVISION.\n\n       MAIN-PROCEDURE.\n\n           PERFORM \n             VARYING IX \n             FROM 1\n             BY 1\n             UNTIL IX > 4\n\n             DISPLAY TEST-ISBN (IX) '   ' WITH NO ADVANCING\n             END-DISPLAY\n             IF validISBN13(TEST-ISBN (IX)) = -1\n               DISPLAY '(bad)'\n             ELSE\n               DISPLAY '(good)'\n             END-IF\n\n           END-PERFORM.\n\n           GOBACK.\n\n       END PROGRAM testSubs.\n\n      ******************************************************************\n      * Author: Jay Moseley\n      * Date: May 19, 2016\n      * Purpose: validate ISBN-13 (International Standard\n      *          Book Number).\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       FUNCTION-ID. validISBN13.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  PASSED-SIZE                 PIC S9(6) COMP-5.\n       01  IX                          PIC S9(4) COMP.\n\n       01  WORK-FIELDS.\n           02  WF-DIGIT                PIC X.\n           02  WF-COUNT                PIC 9(2).\n               88  WEIGHT-1  VALUE 1, 3, 5, 7, 9, 11, 13.\n               88  WEIGHT-3  VALUE 2, 4, 6, 8, 10, 12.\n           02  WF-SUM                  PIC S9(8) COMP.\n\n       LINKAGE SECTION.\n\n       01  PASSED-ISBN                 PIC X ANY LENGTH.\n       01  RETURN-VALUE                PIC S9.\n\n       PROCEDURE DIVISION USING PASSED-ISBN\n                          RETURNING RETURN-VALUE.\n\n           CALL 'C$PARAMSIZE'\n             USING 1\n             GIVING PASSED-SIZE\n           END-CALL.\n       \n       COMPUTE-CKDIGIT.\n\n           INITIALIZE WORK-FIELDS.\n           PERFORM \n             VARYING IX \n             FROM 1 \n             BY 1\n             UNTIL IX GREATER THAN PASSED-SIZE\n\n               MOVE PASSED-ISBN (IX:1) TO WF-DIGIT\n               IF WF-DIGIT IS NUMERIC\n                 ADD 1 TO WF-COUNT\n                 IF WEIGHT-1\n                   ADD NUMVAL(WF-DIGIT) TO WF-SUM\n                 ELSE\n                   COMPUTE WF-SUM = WF-SUM + \n                     (NUMVAL(WF-DIGIT) * 3)\n                   END-COMPUTE\n                 END-IF\n               END-IF\n\n           END-PERFORM.\n\n           IF MOD(WF-SUM, 10) = 0\n             MOVE +0 TO RETURN-VALUE\n           ELSE\n             MOVE -1 TO RETURN-VALUE\n           END-IF.\n\n           GOBACK.\n      * - - - - - - - - - - - - - - - - - - - - - - PROGRAM EXIT POINT\n\n       END FUNCTION validISBN13.\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(CheckISBN13(\"978-1734314502\"));\n        Console.WriteLine(CheckISBN13(\"978-1734314509\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399081\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399083\"));\n\n        static bool CheckISBN13(string code) {\n            code = code.Replace(\"-\", \"\").Replace(\" \", \"\");\n            if (code.Length != 13) return false;\n            int sum = 0;\n            foreach (var (index, digit) in code.Select((digit, index) => (index, digit))) {\n                if (char.IsDigit(digit)) sum += (digit - '0') * (index % 2 == 0 ? 1 : 3);\n                else return false;\n            }\n            return sum % 10 == 0;\n        }\n    }\n}\n"}
{"id": 26706, "name": "ISBN13 check digit", "source": "Translate COBOL to Java:       ******************************************************************\n      * Author: Jay Moseley\n      * Date: November 10, 2019\n      * Purpose: Testing various subprograms/ functions.\n      * Tectonics: cobc -xj testSubs.cbl\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       PROGRAM-ID. testSubs.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC\n           FUNCTION validISBN13.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  IX                          PIC S9(4) COMP.\n       01  TEST-ISBNS.\n           02  FILLER                  PIC X(14) VALUE '978-1734314502'.\n           02  FILLER                  PIC X(14) VALUE '978-1734314509'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399081'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399083'.\n       01  TEST-ISBN                   REDEFINES TEST-ISBNS\n                                       OCCURS 4 TIMES\n                                       PIC X(14).\n\n       PROCEDURE DIVISION.\n\n       MAIN-PROCEDURE.\n\n           PERFORM \n             VARYING IX \n             FROM 1\n             BY 1\n             UNTIL IX > 4\n\n             DISPLAY TEST-ISBN (IX) '   ' WITH NO ADVANCING\n             END-DISPLAY\n             IF validISBN13(TEST-ISBN (IX)) = -1\n               DISPLAY '(bad)'\n             ELSE\n               DISPLAY '(good)'\n             END-IF\n\n           END-PERFORM.\n\n           GOBACK.\n\n       END PROGRAM testSubs.\n\n      ******************************************************************\n      * Author: Jay Moseley\n      * Date: May 19, 2016\n      * Purpose: validate ISBN-13 (International Standard\n      *          Book Number).\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       FUNCTION-ID. validISBN13.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  PASSED-SIZE                 PIC S9(6) COMP-5.\n       01  IX                          PIC S9(4) COMP.\n\n       01  WORK-FIELDS.\n           02  WF-DIGIT                PIC X.\n           02  WF-COUNT                PIC 9(2).\n               88  WEIGHT-1  VALUE 1, 3, 5, 7, 9, 11, 13.\n               88  WEIGHT-3  VALUE 2, 4, 6, 8, 10, 12.\n           02  WF-SUM                  PIC S9(8) COMP.\n\n       LINKAGE SECTION.\n\n       01  PASSED-ISBN                 PIC X ANY LENGTH.\n       01  RETURN-VALUE                PIC S9.\n\n       PROCEDURE DIVISION USING PASSED-ISBN\n                          RETURNING RETURN-VALUE.\n\n           CALL 'C$PARAMSIZE'\n             USING 1\n             GIVING PASSED-SIZE\n           END-CALL.\n       \n       COMPUTE-CKDIGIT.\n\n           INITIALIZE WORK-FIELDS.\n           PERFORM \n             VARYING IX \n             FROM 1 \n             BY 1\n             UNTIL IX GREATER THAN PASSED-SIZE\n\n               MOVE PASSED-ISBN (IX:1) TO WF-DIGIT\n               IF WF-DIGIT IS NUMERIC\n                 ADD 1 TO WF-COUNT\n                 IF WEIGHT-1\n                   ADD NUMVAL(WF-DIGIT) TO WF-SUM\n                 ELSE\n                   COMPUTE WF-SUM = WF-SUM + \n                     (NUMVAL(WF-DIGIT) * 3)\n                   END-COMPUTE\n                 END-IF\n               END-IF\n\n           END-PERFORM.\n\n           IF MOD(WF-SUM, 10) = 0\n             MOVE +0 TO RETURN-VALUE\n           ELSE\n             MOVE -1 TO RETURN-VALUE\n           END-IF.\n\n           GOBACK.\n      * - - - - - - - - - - - - - - - - - - - - - - PROGRAM EXIT POINT\n\n       END FUNCTION validISBN13.\n", "target": "public static void main(){\n        System.out.println(isISBN13(\"978-1734314502\"));\n        System.out.println(isISBN13(\"978-1734314509\"));\n        System.out.println(isISBN13(\"978-1788399081\"));\n        System.out.println(isISBN13(\"978-1788399083\"));\n    }\npublic static boolean isISBN13(String in){\n        int pre = Integer.parseInt(in.substring(0,3));\n        if (pre!=978)return false;\n        String postStr = in.substring(4);\n        if (postStr.length()!=10)return false;\n        int post = Integer.parseInt(postStr);\n        int sum = 38;\n        for(int x = 0; x<10;x+=2)\n        sum += (postStr.charAt(x)-48)*3 + ((postStr.charAt(x+1)-48));\n        if(sum%10==0) return true;\n        return false;\n    }\n"}
{"id": 26707, "name": "ISBN13 check digit", "source": "Translate COBOL to Java:       ******************************************************************\n      * Author: Jay Moseley\n      * Date: November 10, 2019\n      * Purpose: Testing various subprograms/ functions.\n      * Tectonics: cobc -xj testSubs.cbl\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       PROGRAM-ID. testSubs.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC\n           FUNCTION validISBN13.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  IX                          PIC S9(4) COMP.\n       01  TEST-ISBNS.\n           02  FILLER                  PIC X(14) VALUE '978-1734314502'.\n           02  FILLER                  PIC X(14) VALUE '978-1734314509'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399081'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399083'.\n       01  TEST-ISBN                   REDEFINES TEST-ISBNS\n                                       OCCURS 4 TIMES\n                                       PIC X(14).\n\n       PROCEDURE DIVISION.\n\n       MAIN-PROCEDURE.\n\n           PERFORM \n             VARYING IX \n             FROM 1\n             BY 1\n             UNTIL IX > 4\n\n             DISPLAY TEST-ISBN (IX) '   ' WITH NO ADVANCING\n             END-DISPLAY\n             IF validISBN13(TEST-ISBN (IX)) = -1\n               DISPLAY '(bad)'\n             ELSE\n               DISPLAY '(good)'\n             END-IF\n\n           END-PERFORM.\n\n           GOBACK.\n\n       END PROGRAM testSubs.\n\n      ******************************************************************\n      * Author: Jay Moseley\n      * Date: May 19, 2016\n      * Purpose: validate ISBN-13 (International Standard\n      *          Book Number).\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       FUNCTION-ID. validISBN13.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  PASSED-SIZE                 PIC S9(6) COMP-5.\n       01  IX                          PIC S9(4) COMP.\n\n       01  WORK-FIELDS.\n           02  WF-DIGIT                PIC X.\n           02  WF-COUNT                PIC 9(2).\n               88  WEIGHT-1  VALUE 1, 3, 5, 7, 9, 11, 13.\n               88  WEIGHT-3  VALUE 2, 4, 6, 8, 10, 12.\n           02  WF-SUM                  PIC S9(8) COMP.\n\n       LINKAGE SECTION.\n\n       01  PASSED-ISBN                 PIC X ANY LENGTH.\n       01  RETURN-VALUE                PIC S9.\n\n       PROCEDURE DIVISION USING PASSED-ISBN\n                          RETURNING RETURN-VALUE.\n\n           CALL 'C$PARAMSIZE'\n             USING 1\n             GIVING PASSED-SIZE\n           END-CALL.\n       \n       COMPUTE-CKDIGIT.\n\n           INITIALIZE WORK-FIELDS.\n           PERFORM \n             VARYING IX \n             FROM 1 \n             BY 1\n             UNTIL IX GREATER THAN PASSED-SIZE\n\n               MOVE PASSED-ISBN (IX:1) TO WF-DIGIT\n               IF WF-DIGIT IS NUMERIC\n                 ADD 1 TO WF-COUNT\n                 IF WEIGHT-1\n                   ADD NUMVAL(WF-DIGIT) TO WF-SUM\n                 ELSE\n                   COMPUTE WF-SUM = WF-SUM + \n                     (NUMVAL(WF-DIGIT) * 3)\n                   END-COMPUTE\n                 END-IF\n               END-IF\n\n           END-PERFORM.\n\n           IF MOD(WF-SUM, 10) = 0\n             MOVE +0 TO RETURN-VALUE\n           ELSE\n             MOVE -1 TO RETURN-VALUE\n           END-IF.\n\n           GOBACK.\n      * - - - - - - - - - - - - - - - - - - - - - - PROGRAM EXIT POINT\n\n       END FUNCTION validISBN13.\n", "target": "public static void main(){\n        System.out.println(isISBN13(\"978-1734314502\"));\n        System.out.println(isISBN13(\"978-1734314509\"));\n        System.out.println(isISBN13(\"978-1788399081\"));\n        System.out.println(isISBN13(\"978-1788399083\"));\n    }\npublic static boolean isISBN13(String in){\n        int pre = Integer.parseInt(in.substring(0,3));\n        if (pre!=978)return false;\n        String postStr = in.substring(4);\n        if (postStr.length()!=10)return false;\n        int post = Integer.parseInt(postStr);\n        int sum = 38;\n        for(int x = 0; x<10;x+=2)\n        sum += (postStr.charAt(x)-48)*3 + ((postStr.charAt(x+1)-48));\n        if(sum%10==0) return true;\n        return false;\n    }\n"}
{"id": 26708, "name": "ISBN13 check digit", "source": "Translate COBOL to Python:       ******************************************************************\n      * Author: Jay Moseley\n      * Date: November 10, 2019\n      * Purpose: Testing various subprograms/ functions.\n      * Tectonics: cobc -xj testSubs.cbl\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       PROGRAM-ID. testSubs.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC\n           FUNCTION validISBN13.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  IX                          PIC S9(4) COMP.\n       01  TEST-ISBNS.\n           02  FILLER                  PIC X(14) VALUE '978-1734314502'.\n           02  FILLER                  PIC X(14) VALUE '978-1734314509'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399081'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399083'.\n       01  TEST-ISBN                   REDEFINES TEST-ISBNS\n                                       OCCURS 4 TIMES\n                                       PIC X(14).\n\n       PROCEDURE DIVISION.\n\n       MAIN-PROCEDURE.\n\n           PERFORM \n             VARYING IX \n             FROM 1\n             BY 1\n             UNTIL IX > 4\n\n             DISPLAY TEST-ISBN (IX) '   ' WITH NO ADVANCING\n             END-DISPLAY\n             IF validISBN13(TEST-ISBN (IX)) = -1\n               DISPLAY '(bad)'\n             ELSE\n               DISPLAY '(good)'\n             END-IF\n\n           END-PERFORM.\n\n           GOBACK.\n\n       END PROGRAM testSubs.\n\n      ******************************************************************\n      * Author: Jay Moseley\n      * Date: May 19, 2016\n      * Purpose: validate ISBN-13 (International Standard\n      *          Book Number).\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       FUNCTION-ID. validISBN13.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  PASSED-SIZE                 PIC S9(6) COMP-5.\n       01  IX                          PIC S9(4) COMP.\n\n       01  WORK-FIELDS.\n           02  WF-DIGIT                PIC X.\n           02  WF-COUNT                PIC 9(2).\n               88  WEIGHT-1  VALUE 1, 3, 5, 7, 9, 11, 13.\n               88  WEIGHT-3  VALUE 2, 4, 6, 8, 10, 12.\n           02  WF-SUM                  PIC S9(8) COMP.\n\n       LINKAGE SECTION.\n\n       01  PASSED-ISBN                 PIC X ANY LENGTH.\n       01  RETURN-VALUE                PIC S9.\n\n       PROCEDURE DIVISION USING PASSED-ISBN\n                          RETURNING RETURN-VALUE.\n\n           CALL 'C$PARAMSIZE'\n             USING 1\n             GIVING PASSED-SIZE\n           END-CALL.\n       \n       COMPUTE-CKDIGIT.\n\n           INITIALIZE WORK-FIELDS.\n           PERFORM \n             VARYING IX \n             FROM 1 \n             BY 1\n             UNTIL IX GREATER THAN PASSED-SIZE\n\n               MOVE PASSED-ISBN (IX:1) TO WF-DIGIT\n               IF WF-DIGIT IS NUMERIC\n                 ADD 1 TO WF-COUNT\n                 IF WEIGHT-1\n                   ADD NUMVAL(WF-DIGIT) TO WF-SUM\n                 ELSE\n                   COMPUTE WF-SUM = WF-SUM + \n                     (NUMVAL(WF-DIGIT) * 3)\n                   END-COMPUTE\n                 END-IF\n               END-IF\n\n           END-PERFORM.\n\n           IF MOD(WF-SUM, 10) = 0\n             MOVE +0 TO RETURN-VALUE\n           ELSE\n             MOVE -1 TO RETURN-VALUE\n           END-IF.\n\n           GOBACK.\n      * - - - - - - - - - - - - - - - - - - - - - - PROGRAM EXIT POINT\n\n       END FUNCTION validISBN13.\n", "target": "def is_isbn13(n):\n    n = n.replace('-','').replace(' ', '')\n    if len(n) != 13:\n        return False\n    product = (sum(int(ch) for ch in n[::2]) \n               + sum(int(ch) * 3 for ch in n[1::2]))\n    return product % 10 == 0\n\nif __name__ == '__main__':\n    tests = .strip().split()\n    for t in tests:\n        print(f\"ISBN13 {t} validates {is_isbn13(t)}\")\n"}
{"id": 26709, "name": "ISBN13 check digit", "source": "Translate COBOL to Python:       ******************************************************************\n      * Author: Jay Moseley\n      * Date: November 10, 2019\n      * Purpose: Testing various subprograms/ functions.\n      * Tectonics: cobc -xj testSubs.cbl\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       PROGRAM-ID. testSubs.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC\n           FUNCTION validISBN13.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  IX                          PIC S9(4) COMP.\n       01  TEST-ISBNS.\n           02  FILLER                  PIC X(14) VALUE '978-1734314502'.\n           02  FILLER                  PIC X(14) VALUE '978-1734314509'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399081'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399083'.\n       01  TEST-ISBN                   REDEFINES TEST-ISBNS\n                                       OCCURS 4 TIMES\n                                       PIC X(14).\n\n       PROCEDURE DIVISION.\n\n       MAIN-PROCEDURE.\n\n           PERFORM \n             VARYING IX \n             FROM 1\n             BY 1\n             UNTIL IX > 4\n\n             DISPLAY TEST-ISBN (IX) '   ' WITH NO ADVANCING\n             END-DISPLAY\n             IF validISBN13(TEST-ISBN (IX)) = -1\n               DISPLAY '(bad)'\n             ELSE\n               DISPLAY '(good)'\n             END-IF\n\n           END-PERFORM.\n\n           GOBACK.\n\n       END PROGRAM testSubs.\n\n      ******************************************************************\n      * Author: Jay Moseley\n      * Date: May 19, 2016\n      * Purpose: validate ISBN-13 (International Standard\n      *          Book Number).\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       FUNCTION-ID. validISBN13.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  PASSED-SIZE                 PIC S9(6) COMP-5.\n       01  IX                          PIC S9(4) COMP.\n\n       01  WORK-FIELDS.\n           02  WF-DIGIT                PIC X.\n           02  WF-COUNT                PIC 9(2).\n               88  WEIGHT-1  VALUE 1, 3, 5, 7, 9, 11, 13.\n               88  WEIGHT-3  VALUE 2, 4, 6, 8, 10, 12.\n           02  WF-SUM                  PIC S9(8) COMP.\n\n       LINKAGE SECTION.\n\n       01  PASSED-ISBN                 PIC X ANY LENGTH.\n       01  RETURN-VALUE                PIC S9.\n\n       PROCEDURE DIVISION USING PASSED-ISBN\n                          RETURNING RETURN-VALUE.\n\n           CALL 'C$PARAMSIZE'\n             USING 1\n             GIVING PASSED-SIZE\n           END-CALL.\n       \n       COMPUTE-CKDIGIT.\n\n           INITIALIZE WORK-FIELDS.\n           PERFORM \n             VARYING IX \n             FROM 1 \n             BY 1\n             UNTIL IX GREATER THAN PASSED-SIZE\n\n               MOVE PASSED-ISBN (IX:1) TO WF-DIGIT\n               IF WF-DIGIT IS NUMERIC\n                 ADD 1 TO WF-COUNT\n                 IF WEIGHT-1\n                   ADD NUMVAL(WF-DIGIT) TO WF-SUM\n                 ELSE\n                   COMPUTE WF-SUM = WF-SUM + \n                     (NUMVAL(WF-DIGIT) * 3)\n                   END-COMPUTE\n                 END-IF\n               END-IF\n\n           END-PERFORM.\n\n           IF MOD(WF-SUM, 10) = 0\n             MOVE +0 TO RETURN-VALUE\n           ELSE\n             MOVE -1 TO RETURN-VALUE\n           END-IF.\n\n           GOBACK.\n      * - - - - - - - - - - - - - - - - - - - - - - PROGRAM EXIT POINT\n\n       END FUNCTION validISBN13.\n", "target": "def is_isbn13(n):\n    n = n.replace('-','').replace(' ', '')\n    if len(n) != 13:\n        return False\n    product = (sum(int(ch) for ch in n[::2]) \n               + sum(int(ch) * 3 for ch in n[1::2]))\n    return product % 10 == 0\n\nif __name__ == '__main__':\n    tests = .strip().split()\n    for t in tests:\n        print(f\"ISBN13 {t} validates {is_isbn13(t)}\")\n"}
{"id": 26997, "name": "Days between dates", "source": "Translate COBOL to C#: COBOL \n      \n\n       identification division.\n       program-id. days-between.\n\n       procedure division.\n       compute tally = \n         function integer-of-formatted-date('YYYY-MM-DD', '2019-11-24')\n         -\n         function integer-of-formatted-date('YYYY-MM-DD', '2000-01-01')\n       display tally\n\n       compute tally = \n         function integer-of-formatted-date('YYYYMMDD', '20191124')\n         -\n         function integer-of-formatted-date('YYYYMMDD', '20000101')\n       display tally\n\n       goback.\n       end program days-between.\n", "target": "using System;\nusing System.Globalization;\n\npublic class Program\n{\n    public static void Main() => WriteLine(DateDiff(\"1970-01-01\", \"2019-10-18\"));\n\n    public static int DateDiff(string d1, string d2) {\n        var a = DateTime.ParseExact(d1, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        var b = DateTime.ParseExact(d2, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        return (int)(b - a).TotalDays;\n    }\n}\n"}
{"id": 26998, "name": "Days between dates", "source": "Translate COBOL to C#: COBOL \n      \n\n       identification division.\n       program-id. days-between.\n\n       procedure division.\n       compute tally = \n         function integer-of-formatted-date('YYYY-MM-DD', '2019-11-24')\n         -\n         function integer-of-formatted-date('YYYY-MM-DD', '2000-01-01')\n       display tally\n\n       compute tally = \n         function integer-of-formatted-date('YYYYMMDD', '20191124')\n         -\n         function integer-of-formatted-date('YYYYMMDD', '20000101')\n       display tally\n\n       goback.\n       end program days-between.\n", "target": "using System;\nusing System.Globalization;\n\npublic class Program\n{\n    public static void Main() => WriteLine(DateDiff(\"1970-01-01\", \"2019-10-18\"));\n\n    public static int DateDiff(string d1, string d2) {\n        var a = DateTime.ParseExact(d1, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        var b = DateTime.ParseExact(d2, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        return (int)(b - a).TotalDays;\n    }\n}\n"}
{"id": 27001, "name": "Days between dates", "source": "Translate COBOL to Java: COBOL \n      \n\n       identification division.\n       program-id. days-between.\n\n       procedure division.\n       compute tally = \n         function integer-of-formatted-date('YYYY-MM-DD', '2019-11-24')\n         -\n         function integer-of-formatted-date('YYYY-MM-DD', '2000-01-01')\n       display tally\n\n       compute tally = \n         function integer-of-formatted-date('YYYYMMDD', '20191124')\n         -\n         function integer-of-formatted-date('YYYYMMDD', '20000101')\n       display tally\n\n       goback.\n       end program days-between.\n", "target": "import java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class DaysBetweenDates {\n    public static void main(String[] args) {\n        LocalDate fromDate = LocalDate.parse(\"2019-01-01\");\n        LocalDate toDate = LocalDate.parse(\"2019-10-19\");\n        long diff = ChronoUnit.DAYS.between(fromDate, toDate);\n        System.out.printf(\"Number of days between %s and %s: %d\\n\", fromDate, toDate, diff);\n    }\n}\n"}
{"id": 27002, "name": "Days between dates", "source": "Translate COBOL to Java: COBOL \n      \n\n       identification division.\n       program-id. days-between.\n\n       procedure division.\n       compute tally = \n         function integer-of-formatted-date('YYYY-MM-DD', '2019-11-24')\n         -\n         function integer-of-formatted-date('YYYY-MM-DD', '2000-01-01')\n       display tally\n\n       compute tally = \n         function integer-of-formatted-date('YYYYMMDD', '20191124')\n         -\n         function integer-of-formatted-date('YYYYMMDD', '20000101')\n       display tally\n\n       goback.\n       end program days-between.\n", "target": "import java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class DaysBetweenDates {\n    public static void main(String[] args) {\n        LocalDate fromDate = LocalDate.parse(\"2019-01-01\");\n        LocalDate toDate = LocalDate.parse(\"2019-10-19\");\n        long diff = ChronoUnit.DAYS.between(fromDate, toDate);\n        System.out.printf(\"Number of days between %s and %s: %d\\n\", fromDate, toDate, diff);\n    }\n}\n"}
{"id": 27003, "name": "Days between dates", "source": "Translate COBOL to Python: COBOL \n      \n\n       identification division.\n       program-id. days-between.\n\n       procedure division.\n       compute tally = \n         function integer-of-formatted-date('YYYY-MM-DD', '2019-11-24')\n         -\n         function integer-of-formatted-date('YYYY-MM-DD', '2000-01-01')\n       display tally\n\n       compute tally = \n         function integer-of-formatted-date('YYYYMMDD', '20191124')\n         -\n         function integer-of-formatted-date('YYYYMMDD', '20000101')\n       display tally\n\n       goback.\n       end program days-between.\n", "target": "\nimport sys\n\n\n\ndef days( y,m,d ):\n  \n  m = (m + 9) % 12 \n  y = y - m/10\n\n  \n  result = 365*y + y/4 - y/100 + y/400 + (m*306 + 5)/10 + ( d - 1 )\n  return result\n\ndef diff(one,two):\n  [y1,m1,d1] = one.split('-')\n  [y2,m2,d2] = two.split('-')\n  \n  year2 = days( int(y2),int(m2),int(d2))\n  year1 = days( int(y1), int(m1), int(d1) )\n  return year2 - year1\n\nif __name__ == \"__main__\":\n  one = sys.argv[1]\n  two = sys.argv[2]\n  print diff(one,two)\n"}
{"id": 27004, "name": "Days between dates", "source": "Translate COBOL to Python: COBOL \n      \n\n       identification division.\n       program-id. days-between.\n\n       procedure division.\n       compute tally = \n         function integer-of-formatted-date('YYYY-MM-DD', '2019-11-24')\n         -\n         function integer-of-formatted-date('YYYY-MM-DD', '2000-01-01')\n       display tally\n\n       compute tally = \n         function integer-of-formatted-date('YYYYMMDD', '20191124')\n         -\n         function integer-of-formatted-date('YYYYMMDD', '20000101')\n       display tally\n\n       goback.\n       end program days-between.\n", "target": "\nimport sys\n\n\n\ndef days( y,m,d ):\n  \n  m = (m + 9) % 12 \n  y = y - m/10\n\n  \n  result = 365*y + y/4 - y/100 + y/400 + (m*306 + 5)/10 + ( d - 1 )\n  return result\n\ndef diff(one,two):\n  [y1,m1,d1] = one.split('-')\n  [y2,m2,d2] = two.split('-')\n  \n  year2 = days( int(y2),int(m2),int(d2))\n  year1 = days( int(y1), int(m1), int(d1) )\n  return year2 - year1\n\nif __name__ == \"__main__\":\n  one = sys.argv[1]\n  two = sys.argv[2]\n  print diff(one,two)\n"}
{"id": 27269, "name": "Look-and-say sequence", "source": "Translate COBOL to C#:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. LOOK-AND-SAY-SEQ.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 SEQUENCES.\n           02 CUR-SEQ       PIC X(80) VALUE \"1\".\n           02 CUR-CHARS     REDEFINES CUR-SEQ \n                            PIC X OCCURS 80 TIMES INDEXED BY CI.\n           02 CUR-LENGTH    PIC 99 COMP VALUE 1.\n           02 NEXT-SEQ      PIC X(80).\n           02 NEXT-CHARS    REDEFINES NEXT-SEQ \n                            PIC X OCCURS 80 TIMES INDEXED BY NI.\n        01 ALG-STATE.\n           02 STEP-AMOUNT   PIC 99 VALUE 14.\n           02 ITEM-COUNT    PIC 9.\n           \n        PROCEDURE DIVISION.\n        LOOK-AND-SAY.\n            DISPLAY CUR-SEQ.\n            SET CI TO 1.\n            SET NI TO 1.\n        MAKE-NEXT-ENTRY.\n            MOVE 0 TO ITEM-COUNT.\n            IF CI IS GREATER THAN CUR-LENGTH GO TO STEP-DONE.\n        TALLY-ITEM.\n            ADD 1 TO ITEM-COUNT.\n            SET CI UP BY 1.\n            IF CI IS NOT GREATER THAN CUR-LENGTH\n               AND CUR-CHARS(CI) IS EQUAL TO CUR-CHARS(CI - 1) \n                GO TO TALLY-ITEM.\n        INSERT-ENTRY.\n            MOVE ITEM-COUNT TO NEXT-CHARS(NI).\n            MOVE CUR-CHARS(CI - 1) TO NEXT-CHARS(NI + 1).\n            SET NI UP BY 2.\n            GO TO MAKE-NEXT-ENTRY.\n        STEP-DONE.\n            MOVE NEXT-SEQ TO CUR-SEQ.\n            SET NI DOWN BY 1.\n            SET CUR-LENGTH TO NI.\n            SUBTRACT 1 FROM STEP-AMOUNT.\n            IF STEP-AMOUNT IS NOT EQUAL TO ZERO GO TO LOOK-AND-SAY.\n            STOP RUN.\n", "target": "using System;\nusing System.Text;\nusing System.Linq;\n\nclass Program\n{\n    static string lookandsay(string number)\n    {\n        StringBuilder result = new StringBuilder();\n\n        char repeat = number[0];\n        number = number.Substring(1, number.Length-1)+\" \";\n        int times = 1;\n      \n        foreach (char actual in number)\n        {\n            if (actual != repeat)\n            {\n                result.Append(Convert.ToString(times)+repeat);\n                times = 1;\n                repeat = actual;\n            }\n            else\n            {\n                times += 1;\n            }\n        }\n        return result.ToString();\n    }\n\n    static void Main(string[] args)\n    {\n        string num = \"1\"; \n\n        foreach (int i in Enumerable.Range(1, 10)) {\n             Console.WriteLine(num);\n             num = lookandsay(num);             \n        }\n    }\n}\n"}
{"id": 27271, "name": "Look-and-say sequence", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. LOOK-AND-SAY-SEQ.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 SEQUENCES.\n           02 CUR-SEQ       PIC X(80) VALUE \"1\".\n           02 CUR-CHARS     REDEFINES CUR-SEQ \n                            PIC X OCCURS 80 TIMES INDEXED BY CI.\n           02 CUR-LENGTH    PIC 99 COMP VALUE 1.\n           02 NEXT-SEQ      PIC X(80).\n           02 NEXT-CHARS    REDEFINES NEXT-SEQ \n                            PIC X OCCURS 80 TIMES INDEXED BY NI.\n        01 ALG-STATE.\n           02 STEP-AMOUNT   PIC 99 VALUE 14.\n           02 ITEM-COUNT    PIC 9.\n           \n        PROCEDURE DIVISION.\n        LOOK-AND-SAY.\n            DISPLAY CUR-SEQ.\n            SET CI TO 1.\n            SET NI TO 1.\n        MAKE-NEXT-ENTRY.\n            MOVE 0 TO ITEM-COUNT.\n            IF CI IS GREATER THAN CUR-LENGTH GO TO STEP-DONE.\n        TALLY-ITEM.\n            ADD 1 TO ITEM-COUNT.\n            SET CI UP BY 1.\n            IF CI IS NOT GREATER THAN CUR-LENGTH\n               AND CUR-CHARS(CI) IS EQUAL TO CUR-CHARS(CI - 1) \n                GO TO TALLY-ITEM.\n        INSERT-ENTRY.\n            MOVE ITEM-COUNT TO NEXT-CHARS(NI).\n            MOVE CUR-CHARS(CI - 1) TO NEXT-CHARS(NI + 1).\n            SET NI UP BY 2.\n            GO TO MAKE-NEXT-ENTRY.\n        STEP-DONE.\n            MOVE NEXT-SEQ TO CUR-SEQ.\n            SET NI DOWN BY 1.\n            SET CUR-LENGTH TO NI.\n            SUBTRACT 1 FROM STEP-AMOUNT.\n            IF STEP-AMOUNT IS NOT EQUAL TO ZERO GO TO LOOK-AND-SAY.\n            STOP RUN.\n", "target": "public static String lookandsay(String number){\n\tStringBuilder result= new StringBuilder();\n\n\tchar repeat= number.charAt(0);\n\tnumber= number.substring(1) + \" \";\n\tint times= 1;\n\n\tfor(char actual: number.toCharArray()){\n\t\tif(actual != repeat){\n\t\t\tresult.append(times + \"\" + repeat);\n\t\t\ttimes= 1;\n\t\t\trepeat= actual;\n\t\t}else{\n\t\t\ttimes+= 1;\n\t\t}\n\t}\n\treturn result.toString();\n}\n"}
{"id": 27272, "name": "Look-and-say sequence", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. LOOK-AND-SAY-SEQ.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 SEQUENCES.\n           02 CUR-SEQ       PIC X(80) VALUE \"1\".\n           02 CUR-CHARS     REDEFINES CUR-SEQ \n                            PIC X OCCURS 80 TIMES INDEXED BY CI.\n           02 CUR-LENGTH    PIC 99 COMP VALUE 1.\n           02 NEXT-SEQ      PIC X(80).\n           02 NEXT-CHARS    REDEFINES NEXT-SEQ \n                            PIC X OCCURS 80 TIMES INDEXED BY NI.\n        01 ALG-STATE.\n           02 STEP-AMOUNT   PIC 99 VALUE 14.\n           02 ITEM-COUNT    PIC 9.\n           \n        PROCEDURE DIVISION.\n        LOOK-AND-SAY.\n            DISPLAY CUR-SEQ.\n            SET CI TO 1.\n            SET NI TO 1.\n        MAKE-NEXT-ENTRY.\n            MOVE 0 TO ITEM-COUNT.\n            IF CI IS GREATER THAN CUR-LENGTH GO TO STEP-DONE.\n        TALLY-ITEM.\n            ADD 1 TO ITEM-COUNT.\n            SET CI UP BY 1.\n            IF CI IS NOT GREATER THAN CUR-LENGTH\n               AND CUR-CHARS(CI) IS EQUAL TO CUR-CHARS(CI - 1) \n                GO TO TALLY-ITEM.\n        INSERT-ENTRY.\n            MOVE ITEM-COUNT TO NEXT-CHARS(NI).\n            MOVE CUR-CHARS(CI - 1) TO NEXT-CHARS(NI + 1).\n            SET NI UP BY 2.\n            GO TO MAKE-NEXT-ENTRY.\n        STEP-DONE.\n            MOVE NEXT-SEQ TO CUR-SEQ.\n            SET NI DOWN BY 1.\n            SET CUR-LENGTH TO NI.\n            SUBTRACT 1 FROM STEP-AMOUNT.\n            IF STEP-AMOUNT IS NOT EQUAL TO ZERO GO TO LOOK-AND-SAY.\n            STOP RUN.\n", "target": "def lookandsay(number):\n    result = \"\"\n\n    repeat = number[0]\n    number = number[1:]+\" \"\n    times = 1\n\n    for actual in number:\n        if actual != repeat:\n            result += str(times)+repeat\n            times = 1\n            repeat = actual\n        else:\n            times += 1\n\n    return result\n\nnum = \"1\"\n\nfor i in range(10):\n    print num\n    num = lookandsay(num)\n"}
{"id": 28366, "name": "Caesar cipher", "source": "Translate COBOL to C#:        identification division.\n       program-id. caesar.\n       data division.\n       1 msg pic x(50)\n           value \"The quick brown fox jumped over the lazy dog.\".\n       1 offset binary pic 9(4) value 7.\n       1 from-chars pic x(52).\n       1 to-chars pic x(52).\n       1 tabl.\n        2 pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n        2 pic x(26) value \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n        2 pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n        2 pic x(26) value \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n       procedure division.\n       begin.\n           display msg\n           perform encrypt\n           display msg\n           perform decrypt\n           display msg\n           stop run\n           .\n\n       encrypt.\n           move tabl (1:52) to from-chars\n           move tabl (1 + offset:52) to to-chars\n           inspect msg converting from-chars\n               to to-chars\n           .\n\n       decrypt.\n           move tabl (1 + offset:52) to from-chars\n           move tabl (1:52) to to-chars\n           inspect msg converting from-chars\n               to to-chars\n           .\n       end program caesar.\n", "target": "using System;\nusing System.Linq;\n\nnamespace CaesarCypher\n{\n    class Program\n    {\n        static char Encrypt(char ch, int code)\n        {\n            if (!char.IsLetter(ch)) return ch;\n\n            char offset = char.IsUpper(ch) ? 'A' : 'a';\n            return (char)((ch + code - offset) % 26 + offset);\n        }\n\n        static string Encrypt(string input, int code)\n        {\n            return new string(input.Select(ch => Encrypt(ch, code)).ToArray());\n        }\n\n        static string Decrypt(string input, int code)\n        {\n            return Encrypt(input, 26 - code);\n        }\n\n        const string TestCase = \"Pack my box with five dozen liquor jugs.\";\n\n        static void Main()\n        {\n            string str = TestCase;\n\n            Console.WriteLine(str);\n            str = Encrypt(str, 5);\n            Console.WriteLine(\"Encrypted: \" + str);\n            str = Decrypt(str, 5);\n            Console.WriteLine(\"Decrypted: \" + str);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 28368, "name": "Caesar cipher", "source": "Translate COBOL to Java:        identification division.\n       program-id. caesar.\n       data division.\n       1 msg pic x(50)\n           value \"The quick brown fox jumped over the lazy dog.\".\n       1 offset binary pic 9(4) value 7.\n       1 from-chars pic x(52).\n       1 to-chars pic x(52).\n       1 tabl.\n        2 pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n        2 pic x(26) value \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n        2 pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n        2 pic x(26) value \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n       procedure division.\n       begin.\n           display msg\n           perform encrypt\n           display msg\n           perform decrypt\n           display msg\n           stop run\n           .\n\n       encrypt.\n           move tabl (1:52) to from-chars\n           move tabl (1 + offset:52) to to-chars\n           inspect msg converting from-chars\n               to to-chars\n           .\n\n       decrypt.\n           move tabl (1 + offset:52) to from-chars\n           move tabl (1:52) to to-chars\n           inspect msg converting from-chars\n               to to-chars\n           .\n       end program caesar.\n", "target": "public class Cipher {\n    public static void main(String[] args) {\n\n        String str = \"The quick brown fox Jumped over the lazy Dog\";\n\n        System.out.println( Cipher.encode( str, 12 ));\n        System.out.println( Cipher.decode( Cipher.encode( str, 12), 12 ));\n    }\n\n    public static String decode(String enc, int offset) {\n        return encode(enc, 26-offset);\n    }\n\n    public static String encode(String enc, int offset) {\n        offset = offset % 26 + 26;\n        StringBuilder encoded = new StringBuilder();\n        for (char i : enc.toCharArray()) {\n            if (Character.isLetter(i)) {\n                if (Character.isUpperCase(i)) {\n                    encoded.append((char) ('A' + (i - 'A' + offset) % 26 ));\n                } else {\n                    encoded.append((char) ('a' + (i - 'a' + offset) % 26 ));\n                }\n            } else {\n                encoded.append(i);\n            }\n        }\n        return encoded.toString();\n    }\n}\n"}
{"id": 28369, "name": "Caesar cipher", "source": "Translate COBOL to Python:        identification division.\n       program-id. caesar.\n       data division.\n       1 msg pic x(50)\n           value \"The quick brown fox jumped over the lazy dog.\".\n       1 offset binary pic 9(4) value 7.\n       1 from-chars pic x(52).\n       1 to-chars pic x(52).\n       1 tabl.\n        2 pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n        2 pic x(26) value \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n        2 pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n        2 pic x(26) value \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n       procedure division.\n       begin.\n           display msg\n           perform encrypt\n           display msg\n           perform decrypt\n           display msg\n           stop run\n           .\n\n       encrypt.\n           move tabl (1:52) to from-chars\n           move tabl (1 + offset:52) to to-chars\n           inspect msg converting from-chars\n               to to-chars\n           .\n\n       decrypt.\n           move tabl (1 + offset:52) to from-chars\n           move tabl (1:52) to to-chars\n           inspect msg converting from-chars\n               to to-chars\n           .\n       end program caesar.\n", "target": "fun caesar(s, k, decode: false):\n    if decode:\n        k = 26 - k\n    result = ''\n    for i in s.uppercase() where 65 <= ord(i) <= 90:\n        result.push! char(ord(i) - 65 + k) mod 26 + 65\n    return result\n\nlet message = \"The quick brown fox jumped over the lazy dogs\"\nlet encrypted = caesar(msg, 11)\nlet decrypted = caesar(enc, 11, decode: true)\n\nprint(message, encrypted, decrypted, sep: '\\n')\n"}
{"id": 28935, "name": "FizzBuzz", "source": "Translate COBOL to C#:       * FIZZBUZZ.COB\n      * cobc -x -g FIZZBUZZ.COB\n      *\n       IDENTIFICATION        DIVISION.\n       PROGRAM-ID.           fizzbuzz.\n       DATA                  DIVISION.\n       WORKING-STORAGE       SECTION.\n       01 CNT      PIC 9(03) VALUE 1.\n       01 REM      PIC 9(03) VALUE 0.\n       01 QUOTIENT PIC 9(03) VALUE 0.\n       PROCEDURE             DIVISION.\n      *\n       PERFORM UNTIL CNT > 100\n         DIVIDE 15 INTO CNT GIVING QUOTIENT REMAINDER REM\n         IF REM = 0\n           THEN\n             DISPLAY \"FizzBuzz \" WITH NO ADVANCING\n           ELSE\n             DIVIDE 3 INTO CNT GIVING QUOTIENT REMAINDER REM\n             IF REM = 0\n               THEN\n                 DISPLAY \"Fizz \" WITH NO ADVANCING\n               ELSE\n                 DIVIDE 5 INTO CNT GIVING QUOTIENT REMAINDER REM\n                 IF REM = 0\n                   THEN\n                     DISPLAY \"Buzz \" WITH NO ADVANCING\n                   ELSE\n                     DISPLAY CNT \" \" WITH NO ADVANCING\n                 END-IF\n             END-IF\n         END-IF\n         ADD 1 TO CNT\n       END-PERFORM\n       DISPLAY \"\"\n       STOP RUN.\n", "target": "class Program\n{\n    public void FizzBuzzGo()\n    {\n        Boolean Fizz = false;\n        Boolean Buzz = false;\n        for (int count = 1; count <= 100; count ++)\n        {\n            Fizz = count % 3 == 0;\n            Buzz = count % 5 == 0;\n            if (Fizz && Buzz)\n            {\n                Console.WriteLine(\"Fizz Buzz\");\n                listBox1.Items.Add(\"Fizz Buzz\");\n            }\n            else if (Fizz)\n            {\n                Console.WriteLine(\"Fizz\");\n                listBox1.Items.Add(\"Fizz\");\n            }\n            else if (Buzz)\n            {\n                Console.WriteLine(\"Buzz\");\n                listBox1.Items.Add(\"Buzz\");\n            }\n            else\n            {\n                Console.WriteLine(count);\n                listBox1.Items.Add(count);\n            }\n        }\n    }\n}\n"}
{"id": 28937, "name": "FizzBuzz", "source": "Translate COBOL to Java:       * FIZZBUZZ.COB\n      * cobc -x -g FIZZBUZZ.COB\n      *\n       IDENTIFICATION        DIVISION.\n       PROGRAM-ID.           fizzbuzz.\n       DATA                  DIVISION.\n       WORKING-STORAGE       SECTION.\n       01 CNT      PIC 9(03) VALUE 1.\n       01 REM      PIC 9(03) VALUE 0.\n       01 QUOTIENT PIC 9(03) VALUE 0.\n       PROCEDURE             DIVISION.\n      *\n       PERFORM UNTIL CNT > 100\n         DIVIDE 15 INTO CNT GIVING QUOTIENT REMAINDER REM\n         IF REM = 0\n           THEN\n             DISPLAY \"FizzBuzz \" WITH NO ADVANCING\n           ELSE\n             DIVIDE 3 INTO CNT GIVING QUOTIENT REMAINDER REM\n             IF REM = 0\n               THEN\n                 DISPLAY \"Fizz \" WITH NO ADVANCING\n               ELSE\n                 DIVIDE 5 INTO CNT GIVING QUOTIENT REMAINDER REM\n                 IF REM = 0\n                   THEN\n                     DISPLAY \"Buzz \" WITH NO ADVANCING\n                   ELSE\n                     DISPLAY CNT \" \" WITH NO ADVANCING\n                 END-IF\n             END-IF\n         END-IF\n         ADD 1 TO CNT\n       END-PERFORM\n       DISPLAY \"\"\n       STOP RUN.\n", "target": "module FizzBuzz\n    {\n    void run()\n        {\n        @Inject Console console;\n        for (Int x : 1..100)\n            {\n            console.print(switch (x % 3, x % 5)\n                {\n                case (0, 0): \"FizzBuzz\";\n                case (0, _): \"Fizz\";\n                case (_, 0): \"Buzz\";\n                case (_, _): x.toString();\n                });\n            }\n        }\n    }\n"}
{"id": 28938, "name": "FizzBuzz", "source": "Translate COBOL to Python:       * FIZZBUZZ.COB\n      * cobc -x -g FIZZBUZZ.COB\n      *\n       IDENTIFICATION        DIVISION.\n       PROGRAM-ID.           fizzbuzz.\n       DATA                  DIVISION.\n       WORKING-STORAGE       SECTION.\n       01 CNT      PIC 9(03) VALUE 1.\n       01 REM      PIC 9(03) VALUE 0.\n       01 QUOTIENT PIC 9(03) VALUE 0.\n       PROCEDURE             DIVISION.\n      *\n       PERFORM UNTIL CNT > 100\n         DIVIDE 15 INTO CNT GIVING QUOTIENT REMAINDER REM\n         IF REM = 0\n           THEN\n             DISPLAY \"FizzBuzz \" WITH NO ADVANCING\n           ELSE\n             DIVIDE 3 INTO CNT GIVING QUOTIENT REMAINDER REM\n             IF REM = 0\n               THEN\n                 DISPLAY \"Fizz \" WITH NO ADVANCING\n               ELSE\n                 DIVIDE 5 INTO CNT GIVING QUOTIENT REMAINDER REM\n                 IF REM = 0\n                   THEN\n                     DISPLAY \"Buzz \" WITH NO ADVANCING\n                   ELSE\n                     DISPLAY CNT \" \" WITH NO ADVANCING\n                 END-IF\n             END-IF\n         END-IF\n         ADD 1 TO CNT\n       END-PERFORM\n       DISPLAY \"\"\n       STOP RUN.\n", "target": "for i in xrange(1, 101):\n    if i % 15 == 0:\n        print \"FizzBuzz\"\n    elif i % 3 == 0:\n        print \"Fizz\"\n    elif i % 5 == 0:\n        print \"Buzz\"\n    else:\n        print i\n"}
{"id": 29173, "name": "Monty Hall problem", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. monty-hall.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Num-Games               VALUE 1000000.\n\n       \n       \n       01  One                     PIC 9 VALUE 1.\n       01  Three                   PIC 9 VALUE 3.\n\n       01  doors-area.\n           03  doors               PIC 9 OCCURS 3 TIMES.\n\n       01  choice                  PIC 9.\n       01  shown                   PIC 9.\n       01  winner                  PIC 9.\n\n       01  switch-wins             PIC 9(7).\n       01  stay-wins               PIC 9(7).\n\n       01  stay-wins-percent       PIC Z9.99.\n       01  switch-wins-percent     PIC Z9.99.\n\n       PROCEDURE DIVISION.\n           PERFORM Num-Games TIMES\n               MOVE 0 TO doors (winner)\n\n               CALL \"get-rand-int\" USING CONTENT One, Three,\n                   REFERENCE winner\n               MOVE 1 TO doors (winner)\n               \n               CALL \"get-rand-int\" USING CONTENT One, Three,\n                   REFERENCE choice\n    \n               PERFORM WITH TEST AFTER\n                       UNTIL NOT(shown = winner OR choice)\n                   CALL \"get-rand-int\" USING CONTENT One, Three,\n                       REFERENCE shown\n               END-PERFORM\n    \n               ADD doors (choice) TO stay-wins\n               ADD doors (6 - choice - shown) TO switch-wins\n           END-PERFORM\n    \n           COMPUTE stay-wins-percent ROUNDED =\n               stay-wins / Num-Games * 100\n           COMPUTE switch-wins-percent ROUNDED =\n               switch-wins / Num-Games * 100\n\n           DISPLAY \"Staying wins   \" stay-wins \" times (\"\n               stay-wins-percent \"%).\"\n           DISPLAY \"Switching wins \" switch-wins \" times (\"\n               switch-wins-percent \"%).\"\n           .\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. get-rand-int.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  call-flag               PIC X VALUE \"Y\".\n           88  first-call          VALUE \"Y\", FALSE \"N\".\n\n       01  num-range               PIC 9.\n\n       LINKAGE SECTION.\n       01  min-num                 PIC 9.\n       01  max-num                 PIC 9.\n\n       01  ret                     PIC 9.\n\n       PROCEDURE DIVISION USING min-num, max-num, ret.\n           \n           IF first-call\n               MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (9:8))\n                   TO num-range\n               SET first-call TO FALSE\n           END-IF\n\n           COMPUTE num-range = max-num - min-num + 1\n           COMPUTE ret =\n              FUNCTION MOD(FUNCTION RANDOM * 100000, num-range)\n              + min-num\n           .\n       END PROGRAM get-rand-int.\n\n       END PROGRAM monty-hall.\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int switchWins = 0;\n        int stayWins = 0;\n\n        Random gen = new Random();\n\t\t    \n        for(int plays = 0; plays < 1000000; plays++ )\n        {\n            int[] doors = {0,0,0};\n\n            var winner = gen.Next(3);\n            doors[winner] = 1; \n                \n\t    int choice = gen.Next(3); \n\t    int shown; \n\t    do\n            {\n\t        shown = gen.Next(3);\n\t    }\n            while (doors[shown] == 1 || shown == choice); \n     \n\t    stayWins += doors[choice]; \n     \n            \n            switchWins += doors[3 - choice - shown];\n        }\n\n        Console.Out.WriteLine(\"Staying wins \" + stayWins + \" times.\");\n        Console.Out.WriteLine(\"Switching wins \" + switchWins + \" times.\");\n    }\n}\n"}
{"id": 29175, "name": "Monty Hall problem", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. monty-hall.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Num-Games               VALUE 1000000.\n\n       \n       \n       01  One                     PIC 9 VALUE 1.\n       01  Three                   PIC 9 VALUE 3.\n\n       01  doors-area.\n           03  doors               PIC 9 OCCURS 3 TIMES.\n\n       01  choice                  PIC 9.\n       01  shown                   PIC 9.\n       01  winner                  PIC 9.\n\n       01  switch-wins             PIC 9(7).\n       01  stay-wins               PIC 9(7).\n\n       01  stay-wins-percent       PIC Z9.99.\n       01  switch-wins-percent     PIC Z9.99.\n\n       PROCEDURE DIVISION.\n           PERFORM Num-Games TIMES\n               MOVE 0 TO doors (winner)\n\n               CALL \"get-rand-int\" USING CONTENT One, Three,\n                   REFERENCE winner\n               MOVE 1 TO doors (winner)\n               \n               CALL \"get-rand-int\" USING CONTENT One, Three,\n                   REFERENCE choice\n    \n               PERFORM WITH TEST AFTER\n                       UNTIL NOT(shown = winner OR choice)\n                   CALL \"get-rand-int\" USING CONTENT One, Three,\n                       REFERENCE shown\n               END-PERFORM\n    \n               ADD doors (choice) TO stay-wins\n               ADD doors (6 - choice - shown) TO switch-wins\n           END-PERFORM\n    \n           COMPUTE stay-wins-percent ROUNDED =\n               stay-wins / Num-Games * 100\n           COMPUTE switch-wins-percent ROUNDED =\n               switch-wins / Num-Games * 100\n\n           DISPLAY \"Staying wins   \" stay-wins \" times (\"\n               stay-wins-percent \"%).\"\n           DISPLAY \"Switching wins \" switch-wins \" times (\"\n               switch-wins-percent \"%).\"\n           .\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. get-rand-int.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  call-flag               PIC X VALUE \"Y\".\n           88  first-call          VALUE \"Y\", FALSE \"N\".\n\n       01  num-range               PIC 9.\n\n       LINKAGE SECTION.\n       01  min-num                 PIC 9.\n       01  max-num                 PIC 9.\n\n       01  ret                     PIC 9.\n\n       PROCEDURE DIVISION USING min-num, max-num, ret.\n           \n           IF first-call\n               MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (9:8))\n                   TO num-range\n               SET first-call TO FALSE\n           END-IF\n\n           COMPUTE num-range = max-num - min-num + 1\n           COMPUTE ret =\n              FUNCTION MOD(FUNCTION RANDOM * 100000, num-range)\n              + min-num\n           .\n       END PROGRAM get-rand-int.\n\n       END PROGRAM monty-hall.\n", "target": "import java.util.Random;\npublic class Monty{\n\tpublic static void main(String[] args){\n\t\tint switchWins = 0;\n\t\tint stayWins = 0;\n\t\tRandom gen = new Random();\n\t\tfor(int plays = 0;plays < 32768;plays++ ){\n\t\t\tint[] doors = {0,0,0};\n\t\t\tdoors[gen.nextInt(3)] = 1;\n\t\t\tint choice = gen.nextInt(3); \n\t\t\tint shown; \n\t\t\tdo{\n\t\t\t\tshown = gen.nextInt(3);\n\t\t\t\n\t\t\t}while(doors[shown] == 1 || shown == choice);\n\t\t\t\n\t\t\tstayWins += doors[choice];\n\t\t\t\n\t\t\t\n\t\t\tswitchWins += doors[3 - choice - shown];\n\t\t}\n\t\tSystem.out.println(\"Switching wins \" + switchWins + \" times.\");\n\t\tSystem.out.println(\"Staying wins \" + stayWins + \" times.\");\n\t}\n}\n"}
{"id": 29176, "name": "Monty Hall problem", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. monty-hall.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Num-Games               VALUE 1000000.\n\n       \n       \n       01  One                     PIC 9 VALUE 1.\n       01  Three                   PIC 9 VALUE 3.\n\n       01  doors-area.\n           03  doors               PIC 9 OCCURS 3 TIMES.\n\n       01  choice                  PIC 9.\n       01  shown                   PIC 9.\n       01  winner                  PIC 9.\n\n       01  switch-wins             PIC 9(7).\n       01  stay-wins               PIC 9(7).\n\n       01  stay-wins-percent       PIC Z9.99.\n       01  switch-wins-percent     PIC Z9.99.\n\n       PROCEDURE DIVISION.\n           PERFORM Num-Games TIMES\n               MOVE 0 TO doors (winner)\n\n               CALL \"get-rand-int\" USING CONTENT One, Three,\n                   REFERENCE winner\n               MOVE 1 TO doors (winner)\n               \n               CALL \"get-rand-int\" USING CONTENT One, Three,\n                   REFERENCE choice\n    \n               PERFORM WITH TEST AFTER\n                       UNTIL NOT(shown = winner OR choice)\n                   CALL \"get-rand-int\" USING CONTENT One, Three,\n                       REFERENCE shown\n               END-PERFORM\n    \n               ADD doors (choice) TO stay-wins\n               ADD doors (6 - choice - shown) TO switch-wins\n           END-PERFORM\n    \n           COMPUTE stay-wins-percent ROUNDED =\n               stay-wins / Num-Games * 100\n           COMPUTE switch-wins-percent ROUNDED =\n               switch-wins / Num-Games * 100\n\n           DISPLAY \"Staying wins   \" stay-wins \" times (\"\n               stay-wins-percent \"%).\"\n           DISPLAY \"Switching wins \" switch-wins \" times (\"\n               switch-wins-percent \"%).\"\n           .\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. get-rand-int.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  call-flag               PIC X VALUE \"Y\".\n           88  first-call          VALUE \"Y\", FALSE \"N\".\n\n       01  num-range               PIC 9.\n\n       LINKAGE SECTION.\n       01  min-num                 PIC 9.\n       01  max-num                 PIC 9.\n\n       01  ret                     PIC 9.\n\n       PROCEDURE DIVISION USING min-num, max-num, ret.\n           \n           IF first-call\n               MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (9:8))\n                   TO num-range\n               SET first-call TO FALSE\n           END-IF\n\n           COMPUTE num-range = max-num - min-num + 1\n           COMPUTE ret =\n              FUNCTION MOD(FUNCTION RANDOM * 100000, num-range)\n              + min-num\n           .\n       END PROGRAM get-rand-int.\n\n       END PROGRAM monty-hall.\n", "target": "\nfrom random import randrange\n\ndoors, iterations = 3,100000  \n\ndef monty_hall(choice, switch=False, doorCount=doors):\n  \n  door = [False]*doorCount\n  \n  door[randrange(doorCount)] = True\n\n  chosen = door[choice]\n\n  unpicked = door\n  del unpicked[choice]\n\n  \n  \n  \n  alternative = True in unpicked\n\n  if switch:\n    return alternative\n  else:\n    return chosen\n\nprint \"\\nMonty Hall problem simulation:\"\nprint doors, \"doors,\", iterations, \"iterations.\\n\"\n\nprint \"Not switching allows you to win\",\nprint sum(monty_hall(randrange(3), switch=False)\n          for x in range(iterations)),\nprint \"out of\", iterations, \"times.\"\nprint \"Switching allows you to win\",\nprint sum(monty_hall(randrange(3), switch=True)\n          for x in range(iterations)),\nprint \"out of\", iterations, \"times.\\n\"\n"}
{"id": 29588, "name": "User input_Text", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Get-Input.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Input-String PIC X(30).\n       01  Input-Int    PIC 9(5).\n\n       PROCEDURE DIVISION.\n       DISPLAY \"Enter a string:\"\n       ACCEPT Input-String\n\n       DISPLAY \"Enter a number:\"\n       ACCEPT Input-Int\n\n       GOBACK\n       .\n", "target": "using System;\n\nnamespace C_Sharp_Console {\n\n    class example {\n\n        static void Main() {\n            string word;\n            int num;\n            \n            Console.Write(\"Enter an integer: \");\n            num = Console.Read();\n            Console.Write(\"Enter a String: \");\n            word = Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 29590, "name": "User input_Text", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Get-Input.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Input-String PIC X(30).\n       01  Input-Int    PIC 9(5).\n\n       PROCEDURE DIVISION.\n       DISPLAY \"Enter a string:\"\n       ACCEPT Input-String\n\n       DISPLAY \"Enter a number:\"\n       ACCEPT Input-Int\n\n       GOBACK\n       .\n", "target": "import java.util.Scanner;\n\npublic class GetInput {\n    public static void main(String[] args) throws Exception {\n        Scanner s = new Scanner(System.in);\n        System.out.print(\"Enter a string: \");\n        String str = s.nextLine();\n        System.out.print(\"Enter an integer: \");\n        int i = Integer.parseInt(s.next());\n    }\n}\n"}
{"id": 29591, "name": "User input_Text", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Get-Input.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Input-String PIC X(30).\n       01  Input-Int    PIC 9(5).\n\n       PROCEDURE DIVISION.\n       DISPLAY \"Enter a string:\"\n       ACCEPT Input-String\n\n       DISPLAY \"Enter a number:\"\n       ACCEPT Input-Int\n\n       GOBACK\n       .\n", "target": "   string = raw_input(\"Input a string: \")\n"}
{"id": 29994, "name": "Show the epoch", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. epoch.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  epoch-date.\n           03  year                PIC 9(4).\n           03  month               PIC 99.\n           03  dday                PIC 99.\n\n       PROCEDURE DIVISION.\n           MOVE FUNCTION DATE-OF-INTEGER(1) TO epoch-date\n\n           DISPLAY year \"-\" month \"-\" dday\n\n           GOBACK\n           .\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(new DateTime());\n    }\n}\n"}
{"id": 29995, "name": "Show the epoch", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. epoch.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  epoch-date.\n           03  year                PIC 9(4).\n           03  month               PIC 99.\n           03  dday                PIC 99.\n\n       PROCEDURE DIVISION.\n           MOVE FUNCTION DATE-OF-INTEGER(1) TO epoch-date\n\n           DISPLAY year \"-\" month \"-\" dday\n\n           GOBACK\n           .\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(new DateTime());\n    }\n}\n"}
{"id": 29998, "name": "Show the epoch", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. epoch.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  epoch-date.\n           03  year                PIC 9(4).\n           03  month               PIC 99.\n           03  dday                PIC 99.\n\n       PROCEDURE DIVISION.\n           MOVE FUNCTION DATE-OF-INTEGER(1) TO epoch-date\n\n           DISPLAY year \"-\" month \"-\" dday\n\n           GOBACK\n           .\n", "target": "import java.text.DateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\npublic class DateTest{\n    public static void main(String[] args) {\n        Date date = new Date(0);\n        DateFormat format = DateFormat.getDateTimeInstance();\n        format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        System.out.println(format.format(date));\n    }\n}\n"}
{"id": 29999, "name": "Show the epoch", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. epoch.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  epoch-date.\n           03  year                PIC 9(4).\n           03  month               PIC 99.\n           03  dday                PIC 99.\n\n       PROCEDURE DIVISION.\n           MOVE FUNCTION DATE-OF-INTEGER(1) TO epoch-date\n\n           DISPLAY year \"-\" month \"-\" dday\n\n           GOBACK\n           .\n", "target": "import java.text.DateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\npublic class DateTest{\n    public static void main(String[] args) {\n        Date date = new Date(0);\n        DateFormat format = DateFormat.getDateTimeInstance();\n        format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        System.out.println(format.format(date));\n    }\n}\n"}
{"id": 30000, "name": "Show the epoch", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. epoch.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  epoch-date.\n           03  year                PIC 9(4).\n           03  month               PIC 99.\n           03  dday                PIC 99.\n\n       PROCEDURE DIVISION.\n           MOVE FUNCTION DATE-OF-INTEGER(1) TO epoch-date\n\n           DISPLAY year \"-\" month \"-\" dday\n\n           GOBACK\n           .\n", "target": ">>> import time\n>>> time.asctime(time.gmtime(0))\n'Thu Jan  1 00:00:00 1970'\n>>>\n"}
{"id": 30001, "name": "Show the epoch", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. epoch.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  epoch-date.\n           03  year                PIC 9(4).\n           03  month               PIC 99.\n           03  dday                PIC 99.\n\n       PROCEDURE DIVISION.\n           MOVE FUNCTION DATE-OF-INTEGER(1) TO epoch-date\n\n           DISPLAY year \"-\" month \"-\" dday\n\n           GOBACK\n           .\n", "target": ">>> import time\n>>> time.asctime(time.gmtime(0))\n'Thu Jan  1 00:00:00 1970'\n>>>\n"}
{"id": 30317, "name": "File size", "source": "Translate COBOL to C#:        identification division.\n       program-id. FileInfo.\n\n       data division.\n       working-storage section.\n       01  file-name              pic x(256).\n       01  file-size-edited       pic zzz,zzz,zzz.\n       01  file-details.\n           05 file-size           pic x(8) comp-x.\n           05 file-date.\n              10 file-day         pic x comp-x.\n              10 file-month       pic x comp-x.\n              10 file-year        pic xx comp-x.\n           05 file-time.\n              10 file-hour        pic x comp-x.\n              10 file-minute      pic x comp-x.\n              10 file-second      pic x comp-x.\n              10 file-hundredths  pic x comp-x.\n\n       procedure division.\n       main.\n           move \"input.txt\" to file-name\n           perform file-info\n           \n           move \"\\input.txt\" to file-name\n           perform file-info\n\n           stop run\n           .\n\n       file-info.\n           call \"CBL_CHECK_FILE_EXIST\" \n              using file-name, file-details\n              returning return-code\n           if return-code = 0\n              move file-size to file-size-edited\n              display function trim(file-name) \" \"\n                      function trim(file-size-edited) \" Bytes\"\n           else\n              display function trim(file-name) \" not found!\"\n           end-if\n           .\n", "target": "using System;\nusing System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(new FileInfo(\"/input.txt\").Length);\n        Console.WriteLine(new FileInfo(\"input.txt\").Length);\n    }\n}\n"}
{"id": 30319, "name": "File size", "source": "Translate COBOL to Java:        identification division.\n       program-id. FileInfo.\n\n       data division.\n       working-storage section.\n       01  file-name              pic x(256).\n       01  file-size-edited       pic zzz,zzz,zzz.\n       01  file-details.\n           05 file-size           pic x(8) comp-x.\n           05 file-date.\n              10 file-day         pic x comp-x.\n              10 file-month       pic x comp-x.\n              10 file-year        pic xx comp-x.\n           05 file-time.\n              10 file-hour        pic x comp-x.\n              10 file-minute      pic x comp-x.\n              10 file-second      pic x comp-x.\n              10 file-hundredths  pic x comp-x.\n\n       procedure division.\n       main.\n           move \"input.txt\" to file-name\n           perform file-info\n           \n           move \"\\input.txt\" to file-name\n           perform file-info\n\n           stop run\n           .\n\n       file-info.\n           call \"CBL_CHECK_FILE_EXIST\" \n              using file-name, file-details\n              returning return-code\n           if return-code = 0\n              move file-size to file-size-edited\n              display function trim(file-name) \" \"\n                      function trim(file-size-edited) \" Bytes\"\n           else\n              display function trim(file-name) \" not found!\"\n           end-if\n           .\n", "target": "import java.io.File;\n\npublic class FileSize\n{\n    public static void main ( String[] args )\n    {\n        System.out.println(\"input.txt \u00a0: \" + new File(\"input.txt\").length() + \" bytes\");\n        System.out.println(\"/input.txt\u00a0: \" + new File(\"/input.txt\").length() + \" bytes\");\n    }\n}\n"}
{"id": 30320, "name": "File size", "source": "Translate COBOL to Python:        identification division.\n       program-id. FileInfo.\n\n       data division.\n       working-storage section.\n       01  file-name              pic x(256).\n       01  file-size-edited       pic zzz,zzz,zzz.\n       01  file-details.\n           05 file-size           pic x(8) comp-x.\n           05 file-date.\n              10 file-day         pic x comp-x.\n              10 file-month       pic x comp-x.\n              10 file-year        pic xx comp-x.\n           05 file-time.\n              10 file-hour        pic x comp-x.\n              10 file-minute      pic x comp-x.\n              10 file-second      pic x comp-x.\n              10 file-hundredths  pic x comp-x.\n\n       procedure division.\n       main.\n           move \"input.txt\" to file-name\n           perform file-info\n           \n           move \"\\input.txt\" to file-name\n           perform file-info\n\n           stop run\n           .\n\n       file-info.\n           call \"CBL_CHECK_FILE_EXIST\" \n              using file-name, file-details\n              returning return-code\n           if return-code = 0\n              move file-size to file-size-edited\n              display function trim(file-name) \" \"\n                      function trim(file-size-edited) \" Bytes\"\n           else\n              display function trim(file-name) \" not found!\"\n           end-if\n           .\n", "target": "import os\n\nsize = os.path.getsize('input.txt')\nsize = os.path.getsize('/input.txt')\n"}
{"id": 31205, "name": "Sort numbers lexicographically", "source": "Translate COBOL to C#:        identification division.\n       program-id. LexicographicalNumbers.\n\n       data division.\n       working-storage section.\n       78  MAX-NUMBERS            value 21.\n       77  i                      pic 9(2).\n       77  edited-number          pic z(2).\n       \n       01  lex-table.\n           05 table-itms occurs MAX-NUMBERS.\n              10 number-lex       pic x(2).\n\n       procedure division.\n       main.\n      \n           perform varying i from 1 by 1 until i > MAX-NUMBERS\n              move i to edited-number\n              move edited-number to number-lex(i)\n              call \"C$JUSTIFY\" using number-lex(i), \"Left\"\n           end-perform\n\n      \n           sort table-itms ascending number-lex\n\n      \n           display \"[\" no advancing\n           perform varying i from 1 by 1 until i > MAX-NUMBERS\n              display function trim(number-lex(i)) no advancing\n              if i < MAX-NUMBERS\n                 display \", \" no advancing\n              end-if\n           end-perform\n           display \"]\"\n           stop run\n           .\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    public static void Main() {\n        foreach (int n in new [] { 0, 5, 13, 21, -22 }) WriteLine($\"{n}: {string.Join(\", \", LexOrder(n))}\");\n    }\n\n    public static IEnumerable<int> LexOrder(int n) => (n < 1 ? Range(n, 2 - n) : Range(1, n)).OrderBy(i => i.ToString());\n}\n"}
{"id": 31207, "name": "Sort numbers lexicographically", "source": "Translate COBOL to Java:        identification division.\n       program-id. LexicographicalNumbers.\n\n       data division.\n       working-storage section.\n       78  MAX-NUMBERS            value 21.\n       77  i                      pic 9(2).\n       77  edited-number          pic z(2).\n       \n       01  lex-table.\n           05 table-itms occurs MAX-NUMBERS.\n              10 number-lex       pic x(2).\n\n       procedure division.\n       main.\n      \n           perform varying i from 1 by 1 until i > MAX-NUMBERS\n              move i to edited-number\n              move edited-number to number-lex(i)\n              call \"C$JUSTIFY\" using number-lex(i), \"Left\"\n           end-perform\n\n      \n           sort table-itms ascending number-lex\n\n      \n           display \"[\" no advancing\n           perform varying i from 1 by 1 until i > MAX-NUMBERS\n              display function trim(number-lex(i)) no advancing\n              if i < MAX-NUMBERS\n                 display \", \" no advancing\n              end-if\n           end-perform\n           display \"]\"\n           stop run\n           .\n", "target": "import java.util.List;\nimport java.util.stream.*;\n\npublic class LexicographicalNumbers {\n\n    static List<Integer> lexOrder(int n) {\n        int first = 1, last = n;\n        if (n < 1) {\n            first = n;\n            last = 1;\n        }\n        return IntStream.rangeClosed(first, last)\n                        .mapToObj(Integer::toString)\n                        .sorted()\n                        .map(Integer::valueOf)\n                        .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"In lexicographical order:\\n\");\n        int[] ints = {0, 5, 13, 21, -22};\n        for (int n : ints) {\n           System.out.printf(\"%3d: %s\\n\", n, lexOrder(n));\n        }\n    }\n}\n"}
{"id": 31208, "name": "Sort numbers lexicographically", "source": "Translate COBOL to Python:        identification division.\n       program-id. LexicographicalNumbers.\n\n       data division.\n       working-storage section.\n       78  MAX-NUMBERS            value 21.\n       77  i                      pic 9(2).\n       77  edited-number          pic z(2).\n       \n       01  lex-table.\n           05 table-itms occurs MAX-NUMBERS.\n              10 number-lex       pic x(2).\n\n       procedure division.\n       main.\n      \n           perform varying i from 1 by 1 until i > MAX-NUMBERS\n              move i to edited-number\n              move edited-number to number-lex(i)\n              call \"C$JUSTIFY\" using number-lex(i), \"Left\"\n           end-perform\n\n      \n           sort table-itms ascending number-lex\n\n      \n           display \"[\" no advancing\n           perform varying i from 1 by 1 until i > MAX-NUMBERS\n              display function trim(number-lex(i)) no advancing\n              if i < MAX-NUMBERS\n                 display \", \" no advancing\n              end-if\n           end-perform\n           display \"]\"\n           stop run\n           .\n", "target": "n=13\nprint(sorted(range(1,n+1), key=str))\n"}
{"id": 32036, "name": "Guess the number_With feedback", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Guess-With-Feedback.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  Seed       PIC 9(8).\n       01  Random-Num PIC 99.\n       01  Guess      PIC 99.\n \n       PROCEDURE DIVISION.\n           ACCEPT Seed FROM TIME\n           COMPUTE Random-Num =\n               FUNCTION REM(FUNCTION RANDOM(Seed) * 1000, 10) + 1\n\n           DISPLAY \"Guess a number between 1 and 10:\"\n \n           PERFORM FOREVER\n               ACCEPT Guess\n \n               IF Guess > Random-Num\n                   DISPLAY \"Your guess was too high.\"\n               ELSE IF Guess < Random-Num\n                   DISPLAY \"Your guess was too low.\"\n               ELSE\n                   DISPLAY \"Well guessed!\"\n                   EXIT PERFORM\n           END-PERFORM\n \n           GOBACK\n           .\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        const int from = 1;\n        const int to = 10;\n\n        int randomNumber = new Random().Next(from, to);\n        int guessedNumber;\n\n        Console.Write(\"The number is between {0} and {1}. \", from, to);\n        while (true)\n        {\n            Console.Write(\"Make a guess: \");\n            if (int.TryParse(Console.ReadLine(), out guessedNumber))\n            {\n                if (guessedNumber == randomNumber)\n                {\n                    Console.WriteLine(\"You guessed the right number!\");\n                    break;\n                }\n                else\n                {\n                    Console.WriteLine(\"Your guess was too {0}.\", (guessedNumber > randomNumber) ? \"high\" : \"low\");\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"Input was not an integer.\");\n            }\n        }\n\n        Console.WriteLine();\n        Console.WriteLine(\"Press any key to exit.\");\n        Console.ReadKey();\n    }\n}\n"}
{"id": 32038, "name": "Guess the number_With feedback", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Guess-With-Feedback.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  Seed       PIC 9(8).\n       01  Random-Num PIC 99.\n       01  Guess      PIC 99.\n \n       PROCEDURE DIVISION.\n           ACCEPT Seed FROM TIME\n           COMPUTE Random-Num =\n               FUNCTION REM(FUNCTION RANDOM(Seed) * 1000, 10) + 1\n\n           DISPLAY \"Guess a number between 1 and 10:\"\n \n           PERFORM FOREVER\n               ACCEPT Guess\n \n               IF Guess > Random-Num\n                   DISPLAY \"Your guess was too high.\"\n               ELSE IF Guess < Random-Num\n                   DISPLAY \"Your guess was too low.\"\n               ELSE\n                   DISPLAY \"Well guessed!\"\n                   EXIT PERFORM\n           END-PERFORM\n \n           GOBACK\n           .\n", "target": "import java.util.Random;\nimport java.util.Scanner;\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        Scanner scan = new Scanner(System.in);\n        Random random = new Random();\n        long from = 1;\n        long to = 100;\n        int randomNumber = random.nextInt(to - from + 1) + from;\n        int guessedNumber = 0;\n\n        System.out.printf(\"The number is between %d and %d.\\n\", from, to);\n\n        do\n        {\n            System.out.print(\"Guess what the number is: \");\n            guessedNumber = scan.nextInt();\n            if (guessedNumber > randomNumber)\n                System.out.println(\"Your guess is too high!\");\n            else if (guessedNumber < randomNumber)\n                System.out.println(\"Your guess is too low!\");\n            else\n                System.out.println(\"You got it!\");\n        } while (guessedNumber != randomNumber);\n    }\n}\n"}
{"id": 32039, "name": "Guess the number_With feedback", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Guess-With-Feedback.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  Seed       PIC 9(8).\n       01  Random-Num PIC 99.\n       01  Guess      PIC 99.\n \n       PROCEDURE DIVISION.\n           ACCEPT Seed FROM TIME\n           COMPUTE Random-Num =\n               FUNCTION REM(FUNCTION RANDOM(Seed) * 1000, 10) + 1\n\n           DISPLAY \"Guess a number between 1 and 10:\"\n \n           PERFORM FOREVER\n               ACCEPT Guess\n \n               IF Guess > Random-Num\n                   DISPLAY \"Your guess was too high.\"\n               ELSE IF Guess < Random-Num\n                   DISPLAY \"Your guess was too low.\"\n               ELSE\n                   DISPLAY \"Well guessed!\"\n                   EXIT PERFORM\n           END-PERFORM\n \n           GOBACK\n           .\n", "target": "import random\n\ninclusive_range = (1, 100)\n\nprint(\"Guess my target number that is between %i and %i (inclusive).\\n\"\n      % inclusive_range)\ntarget = random.randint(*inclusive_range)\nanswer, i = None, 0\nwhile answer != target:\n    i += 1\n    txt = input(\"Your guess(%i): \" % i)\n    try:\n        answer = int(txt)\n    except ValueError:\n        print(\"  I don't understand your input of '%s'\u00a0?\" % txt)\n        continue\n    if answer < inclusive_range[0] or answer > inclusive_range[1]:\n        print(\"  Out of range!\")\n        continue\n    if answer == target:\n        print(\"  Ye-Haw!!\")\n        break\n    if answer < target: print(\"  Too low.\")\n    if answer > target: print(\"  Too high.\")\n\nprint(\"\\nThanks for playing.\")\n"}
{"id": 32279, "name": "Compound data type", "source": "Translate COBOL to C#: 01 Point.\n   05 x            pic 9(3).\n   05 y            pic 9(3).\n", "target": "struct Point\n{\n  public int x, y;\n  public Point(int x, int y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n"}
{"id": 32281, "name": "Compound data type", "source": "Translate COBOL to Java: 01 Point.\n   05 x            pic 9(3).\n   05 y            pic 9(3).\n", "target": "public class Point\n{\n  public int x, y;\n  public Point() { this(0); }\n  public Point(int x0) { this(x0,0); }\n  public Point(int x0, int y0) { x = x0; y = y0; }\n\n  public static void main(String args[])\n  {\n    Point point = new Point(1,2);\n    System.out.println(\"x = \" + point.x );\n    System.out.println(\"y = \" + point.y );\n  }\n}\n"}
{"id": 32282, "name": "Compound data type", "source": "Translate COBOL to Python: 01 Point.\n   05 x            pic 9(3).\n   05 y            pic 9(3).\n", "target": "X, Y = 0, 1\np = (3, 4)\np = [3, 4]\n\nprint p[X]\n"}
{"id": 32545, "name": "Sorting algorithms_Bogosort", "source": "Translate COBOL to C#: identification division.\nprogram-id. bogo-sort-program.\ndata division.\nworking-storage section.\n01  array-to-sort.\n    05 item-table.\n        10 item          pic 999\n            occurs 10 times.\n01  randomization.\n    05 random-seed       pic 9(8).\n    05 random-index      pic 9.\n01  flags-counters-etc.\n    05 array-index       pic 99.\n    05 adjusted-index    pic 99.\n    05 temporary-storage pic 999.\n    05 shuffles          pic 9(8)\n        value zero.\n    05 sorted            pic 9.\n01  numbers-without-leading-zeros.\n    05 item-no-zeros     pic z(4).\n    05 shuffles-no-zeros pic z(8).\nprocedure division.\ncontrol-paragraph.\n    accept random-seed from time.\n    move function random(random-seed) to item(1).\n    perform random-item-paragraph varying array-index from 2 by 1\n    until array-index is greater than 10.\n    display 'BEFORE SORT:' with no advancing.\n    perform show-array-paragraph varying array-index from 1 by 1\n    until array-index is greater than 10.\n    display ''.\n    perform shuffle-paragraph through is-it-sorted-paragraph\n    until sorted is equal to 1.\n    display 'AFTER SORT: ' with no advancing.\n    perform show-array-paragraph varying array-index from 1 by 1\n    until array-index is greater than 10.\n    display ''.\n    move shuffles to shuffles-no-zeros.\n    display shuffles-no-zeros ' SHUFFLES PERFORMED.'\n    stop run.\nrandom-item-paragraph.\n    move function random to item(array-index).\nshow-array-paragraph.\n    move item(array-index) to item-no-zeros.\n    display item-no-zeros with no advancing.\nshuffle-paragraph.\n    perform shuffle-items-paragraph,\n    varying array-index from 1 by 1\n    until array-index is greater than 10.\n    add 1 to shuffles.\nis-it-sorted-paragraph.\n    move 1 to sorted.\n    perform item-in-order-paragraph varying array-index from 1 by 1,\n    until sorted is equal to zero\n    or array-index is equal to 10.\nshuffle-items-paragraph.\n    move function random to random-index.\n    add 1 to random-index giving adjusted-index.\n    move item(array-index) to temporary-storage.\n    move item(adjusted-index) to item(array-index).\n    move temporary-storage to item(adjusted-index).\nitem-in-order-paragraph.\n    add 1 to array-index giving adjusted-index.\n    if item(array-index) is greater than item(adjusted-index)\n    then move zero to sorted.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.BogoSort\n{\n    public static class BogoSorter\n    {\n        public static void Sort<T>(List<T> list) where T:IComparable\n        {\n            while (!list.isSorted())\n            {\n                list.Shuffle();\n            }\n        }\n\n        private static bool isSorted<T>(this IList<T> list) where T:IComparable\n        {\n            if(list.Count<=1)\n                return true;\n            for (int i = 1 ; i < list.Count; i++)\n                if(list[i].CompareTo(list[i-1])<0) return false;\n            return true;\n        }\n\n        private static void Shuffle<T>(this IList<T> list)\n        {\n            Random rand = new Random();\n            for (int i = 0; i < list.Count; i++)\n            {\n                int swapIndex = rand.Next(list.Count);\n                T temp = list[swapIndex];\n                list[swapIndex] = list[i];\n                list[i] = temp;\n            }\n        }\n    }\n\n    class TestProgram\n    {\n        static void Main()\n        {\n            List<int> testList = new List<int> { 3, 4, 1, 8, 7, 4, -2 };\n            BogoSorter.Sort(testList);\n            foreach (int i in testList) Console.Write(i + \" \");\n        }\n\n    }\n}\n"}
{"id": 32547, "name": "Sorting algorithms_Bogosort", "source": "Translate COBOL to Java: identification division.\nprogram-id. bogo-sort-program.\ndata division.\nworking-storage section.\n01  array-to-sort.\n    05 item-table.\n        10 item          pic 999\n            occurs 10 times.\n01  randomization.\n    05 random-seed       pic 9(8).\n    05 random-index      pic 9.\n01  flags-counters-etc.\n    05 array-index       pic 99.\n    05 adjusted-index    pic 99.\n    05 temporary-storage pic 999.\n    05 shuffles          pic 9(8)\n        value zero.\n    05 sorted            pic 9.\n01  numbers-without-leading-zeros.\n    05 item-no-zeros     pic z(4).\n    05 shuffles-no-zeros pic z(8).\nprocedure division.\ncontrol-paragraph.\n    accept random-seed from time.\n    move function random(random-seed) to item(1).\n    perform random-item-paragraph varying array-index from 2 by 1\n    until array-index is greater than 10.\n    display 'BEFORE SORT:' with no advancing.\n    perform show-array-paragraph varying array-index from 1 by 1\n    until array-index is greater than 10.\n    display ''.\n    perform shuffle-paragraph through is-it-sorted-paragraph\n    until sorted is equal to 1.\n    display 'AFTER SORT: ' with no advancing.\n    perform show-array-paragraph varying array-index from 1 by 1\n    until array-index is greater than 10.\n    display ''.\n    move shuffles to shuffles-no-zeros.\n    display shuffles-no-zeros ' SHUFFLES PERFORMED.'\n    stop run.\nrandom-item-paragraph.\n    move function random to item(array-index).\nshow-array-paragraph.\n    move item(array-index) to item-no-zeros.\n    display item-no-zeros with no advancing.\nshuffle-paragraph.\n    perform shuffle-items-paragraph,\n    varying array-index from 1 by 1\n    until array-index is greater than 10.\n    add 1 to shuffles.\nis-it-sorted-paragraph.\n    move 1 to sorted.\n    perform item-in-order-paragraph varying array-index from 1 by 1,\n    until sorted is equal to zero\n    or array-index is equal to 10.\nshuffle-items-paragraph.\n    move function random to random-index.\n    add 1 to random-index giving adjusted-index.\n    move item(array-index) to temporary-storage.\n    move item(adjusted-index) to item(array-index).\n    move temporary-storage to item(adjusted-index).\nitem-in-order-paragraph.\n    add 1 to array-index giving adjusted-index.\n    if item(array-index) is greater than item(adjusted-index)\n    then move zero to sorted.\n", "target": "public class BogoSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tint[] arr={4,5,6,0,7,8,9,1,2,3};\n\t\t\n\t\tBogoSort now=new BogoSort();\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tnow.bogo(arr);\n\t\t\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(arr);\n\t}\n\tvoid bogo(int[] arr)\n\t{\n\t\t\n\t\tint shuffle=1;\n\t\tfor(;!isSorted(arr);shuffle++)\n\t\t\tshuffle(arr);\n\t\t\n\t\tSystem.out.println(\"This took \"+shuffle+\" shuffles.\");\n\t}\n\tvoid shuffle(int[] arr)\n\t{\n\t\t\n\t\tint i=arr.length-1;\n\t\twhile(i>0)\n\t\t\tswap(arr,i--,(int)(Math.random()*i));\n\t}\n\tvoid swap(int[] arr,int i,int j)\n\t{\n\t\tint temp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=temp;\n\t}\n\tboolean isSorted(int[] arr)\n\t{\n\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]<arr[i-1])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\n}\n"}
{"id": 32548, "name": "Sorting algorithms_Bogosort", "source": "Translate COBOL to Python: identification division.\nprogram-id. bogo-sort-program.\ndata division.\nworking-storage section.\n01  array-to-sort.\n    05 item-table.\n        10 item          pic 999\n            occurs 10 times.\n01  randomization.\n    05 random-seed       pic 9(8).\n    05 random-index      pic 9.\n01  flags-counters-etc.\n    05 array-index       pic 99.\n    05 adjusted-index    pic 99.\n    05 temporary-storage pic 999.\n    05 shuffles          pic 9(8)\n        value zero.\n    05 sorted            pic 9.\n01  numbers-without-leading-zeros.\n    05 item-no-zeros     pic z(4).\n    05 shuffles-no-zeros pic z(8).\nprocedure division.\ncontrol-paragraph.\n    accept random-seed from time.\n    move function random(random-seed) to item(1).\n    perform random-item-paragraph varying array-index from 2 by 1\n    until array-index is greater than 10.\n    display 'BEFORE SORT:' with no advancing.\n    perform show-array-paragraph varying array-index from 1 by 1\n    until array-index is greater than 10.\n    display ''.\n    perform shuffle-paragraph through is-it-sorted-paragraph\n    until sorted is equal to 1.\n    display 'AFTER SORT: ' with no advancing.\n    perform show-array-paragraph varying array-index from 1 by 1\n    until array-index is greater than 10.\n    display ''.\n    move shuffles to shuffles-no-zeros.\n    display shuffles-no-zeros ' SHUFFLES PERFORMED.'\n    stop run.\nrandom-item-paragraph.\n    move function random to item(array-index).\nshow-array-paragraph.\n    move item(array-index) to item-no-zeros.\n    display item-no-zeros with no advancing.\nshuffle-paragraph.\n    perform shuffle-items-paragraph,\n    varying array-index from 1 by 1\n    until array-index is greater than 10.\n    add 1 to shuffles.\nis-it-sorted-paragraph.\n    move 1 to sorted.\n    perform item-in-order-paragraph varying array-index from 1 by 1,\n    until sorted is equal to zero\n    or array-index is equal to 10.\nshuffle-items-paragraph.\n    move function random to random-index.\n    add 1 to random-index giving adjusted-index.\n    move item(array-index) to temporary-storage.\n    move item(adjusted-index) to item(array-index).\n    move temporary-storage to item(adjusted-index).\nitem-in-order-paragraph.\n    add 1 to array-index giving adjusted-index.\n    if item(array-index) is greater than item(adjusted-index)\n    then move zero to sorted.\n", "target": "import random\n\ndef bogosort(l):\n    while not in_order(l):\n        random.shuffle(l)\n    return l\n\ndef in_order(l):\n    if not l:\n        return True\n    last = l[0]\n    for x in l[1:]:\n        if x < last:\n            return False\n        last = x\n    return True\n"}
{"id": 32815, "name": "Cumulative standard deviation", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. run-stddev.\nenvironment division.\ninput-output section.\nfile-control.\n  select input-file assign to \"input.txt\"\n    organization is line sequential.\ndata division.\nfile section.\nfd input-file.\n  01  inp-record.\n    03  inp-fld  pic 9(03).\nworking-storage section.\n01  filler pic 9(01)   value 0.\n  88 no-more-input     value 1.\n01  ws-tb-data.\n  03  ws-tb-size         pic 9(03).\n  03  ws-tb-table.\n    05  ws-tb-fld     pic s9(05)v9999 comp-3 occurs 0 to 100 times \n        depending on ws-tb-size.\n01 ws-stddev       pic s9(05)v9999 comp-3.\nPROCEDURE DIVISION.\n  move 0 to ws-tb-size \n  open  input input-file\n    read input-file\n    at end\n      set no-more-input to true\n    end-read\n    perform\n      test after\n    until no-more-input\n      add 1 to ws-tb-size\n      move inp-fld to ws-tb-fld (ws-tb-size)\n      call 'stddev' using  by reference ws-tb-data \n         ws-stddev\n      display  'inp=' inp-fld ' stddev=' ws-stddev\n      read input-file at end set no-more-input to true end-read\n    end-perform\n  close input-file\n  stop run.\nend program run-stddev.\nIDENTIFICATION DIVISION.\nPROGRAM-ID. stddev.\ndata division.\nworking-storage section.\n01 ws-tbx             pic s9(03) comp.\n01 ws-tb-work.\n  03  ws-sum          pic s9(05)v9999 comp-3 value +0.\n  03  ws-sumsq        pic s9(05)v9999 comp-3 value +0.\n  03  ws-avg          pic s9(05)v9999 comp-3 value +0.\nlinkage section.\n01  ws-tb-data.\n  03  ws-tb-size         pic 9(03).\n  03  ws-tb-table.\n    05  ws-tb-fld     pic s9(05)v9999 comp-3 occurs 0 to 100 times \n        depending on ws-tb-size.\n01  ws-stddev       pic s9(05)v9999 comp-3.\nPROCEDURE DIVISION using  ws-tb-data  ws-stddev.\n    compute ws-sum = 0\n    perform test before varying ws-tbx from 1 by +1 until ws-tbx > ws-tb-size\n        compute ws-sum = ws-sum + ws-tb-fld (ws-tbx) \n    end-perform\n    compute ws-avg rounded = ws-sum / ws-tb-size\n    compute ws-sumsq = 0\n    perform test before varying ws-tbx from 1 by +1 until ws-tbx > ws-tb-size\n        compute ws-sumsq = ws-sumsq\n        + (ws-tb-fld (ws-tbx) - ws-avg) ** 2.0\n    end-perform\n    compute ws-stddev = ( ws-sumsq / ws-tb-size) ** 0.5 \n    goback.\nend program stddev.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace standardDeviation\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<double> nums = new List<double> { 2, 4, 4, 4, 5, 5, 7, 9 };\n            for (int i = 1; i <= nums.Count; i++)            \n                Console.WriteLine(sdev(nums.GetRange(0, i)));\n        }\n\n        static double sdev(List<double> nums)\n        {\n            List<double> store = new List<double>();\n            foreach (double n in nums)\n                store.Add((n - nums.Average()) * (n - nums.Average()));           \n\n            return Math.Sqrt(store.Sum() / store.Count);\n        }\n    }\n}\n"}
{"id": 32817, "name": "Cumulative standard deviation", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. run-stddev.\nenvironment division.\ninput-output section.\nfile-control.\n  select input-file assign to \"input.txt\"\n    organization is line sequential.\ndata division.\nfile section.\nfd input-file.\n  01  inp-record.\n    03  inp-fld  pic 9(03).\nworking-storage section.\n01  filler pic 9(01)   value 0.\n  88 no-more-input     value 1.\n01  ws-tb-data.\n  03  ws-tb-size         pic 9(03).\n  03  ws-tb-table.\n    05  ws-tb-fld     pic s9(05)v9999 comp-3 occurs 0 to 100 times \n        depending on ws-tb-size.\n01 ws-stddev       pic s9(05)v9999 comp-3.\nPROCEDURE DIVISION.\n  move 0 to ws-tb-size \n  open  input input-file\n    read input-file\n    at end\n      set no-more-input to true\n    end-read\n    perform\n      test after\n    until no-more-input\n      add 1 to ws-tb-size\n      move inp-fld to ws-tb-fld (ws-tb-size)\n      call 'stddev' using  by reference ws-tb-data \n         ws-stddev\n      display  'inp=' inp-fld ' stddev=' ws-stddev\n      read input-file at end set no-more-input to true end-read\n    end-perform\n  close input-file\n  stop run.\nend program run-stddev.\nIDENTIFICATION DIVISION.\nPROGRAM-ID. stddev.\ndata division.\nworking-storage section.\n01 ws-tbx             pic s9(03) comp.\n01 ws-tb-work.\n  03  ws-sum          pic s9(05)v9999 comp-3 value +0.\n  03  ws-sumsq        pic s9(05)v9999 comp-3 value +0.\n  03  ws-avg          pic s9(05)v9999 comp-3 value +0.\nlinkage section.\n01  ws-tb-data.\n  03  ws-tb-size         pic 9(03).\n  03  ws-tb-table.\n    05  ws-tb-fld     pic s9(05)v9999 comp-3 occurs 0 to 100 times \n        depending on ws-tb-size.\n01  ws-stddev       pic s9(05)v9999 comp-3.\nPROCEDURE DIVISION using  ws-tb-data  ws-stddev.\n    compute ws-sum = 0\n    perform test before varying ws-tbx from 1 by +1 until ws-tbx > ws-tb-size\n        compute ws-sum = ws-sum + ws-tb-fld (ws-tbx) \n    end-perform\n    compute ws-avg rounded = ws-sum / ws-tb-size\n    compute ws-sumsq = 0\n    perform test before varying ws-tbx from 1 by +1 until ws-tbx > ws-tb-size\n        compute ws-sumsq = ws-sumsq\n        + (ws-tb-fld (ws-tbx) - ws-avg) ** 2.0\n    end-perform\n    compute ws-stddev = ( ws-sumsq / ws-tb-size) ** 0.5 \n    goback.\nend program stddev.\n", "target": "public class StdDev {\n    int n = 0;\n    double sum = 0;\n    double sum2 = 0;\n\n    public double sd(double x) {\n\tn++;\n\tsum += x;\n\tsum2 += x*x;\n\n\treturn Math.sqrt(sum2/n - sum*sum/n/n);\n    }\n\n    public static void main(String[] args) {\n        double[] testData = {2,4,4,4,5,5,7,9};\n        StdDev sd = new StdDev();\n\n        for (double x : testData) {\n            System.out.println(sd.sd(x));\n        }\n    }\n}\n"}
{"id": 32818, "name": "Cumulative standard deviation", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. run-stddev.\nenvironment division.\ninput-output section.\nfile-control.\n  select input-file assign to \"input.txt\"\n    organization is line sequential.\ndata division.\nfile section.\nfd input-file.\n  01  inp-record.\n    03  inp-fld  pic 9(03).\nworking-storage section.\n01  filler pic 9(01)   value 0.\n  88 no-more-input     value 1.\n01  ws-tb-data.\n  03  ws-tb-size         pic 9(03).\n  03  ws-tb-table.\n    05  ws-tb-fld     pic s9(05)v9999 comp-3 occurs 0 to 100 times \n        depending on ws-tb-size.\n01 ws-stddev       pic s9(05)v9999 comp-3.\nPROCEDURE DIVISION.\n  move 0 to ws-tb-size \n  open  input input-file\n    read input-file\n    at end\n      set no-more-input to true\n    end-read\n    perform\n      test after\n    until no-more-input\n      add 1 to ws-tb-size\n      move inp-fld to ws-tb-fld (ws-tb-size)\n      call 'stddev' using  by reference ws-tb-data \n         ws-stddev\n      display  'inp=' inp-fld ' stddev=' ws-stddev\n      read input-file at end set no-more-input to true end-read\n    end-perform\n  close input-file\n  stop run.\nend program run-stddev.\nIDENTIFICATION DIVISION.\nPROGRAM-ID. stddev.\ndata division.\nworking-storage section.\n01 ws-tbx             pic s9(03) comp.\n01 ws-tb-work.\n  03  ws-sum          pic s9(05)v9999 comp-3 value +0.\n  03  ws-sumsq        pic s9(05)v9999 comp-3 value +0.\n  03  ws-avg          pic s9(05)v9999 comp-3 value +0.\nlinkage section.\n01  ws-tb-data.\n  03  ws-tb-size         pic 9(03).\n  03  ws-tb-table.\n    05  ws-tb-fld     pic s9(05)v9999 comp-3 occurs 0 to 100 times \n        depending on ws-tb-size.\n01  ws-stddev       pic s9(05)v9999 comp-3.\nPROCEDURE DIVISION using  ws-tb-data  ws-stddev.\n    compute ws-sum = 0\n    perform test before varying ws-tbx from 1 by +1 until ws-tbx > ws-tb-size\n        compute ws-sum = ws-sum + ws-tb-fld (ws-tbx) \n    end-perform\n    compute ws-avg rounded = ws-sum / ws-tb-size\n    compute ws-sumsq = 0\n    perform test before varying ws-tbx from 1 by +1 until ws-tbx > ws-tb-size\n        compute ws-sumsq = ws-sumsq\n        + (ws-tb-fld (ws-tbx) - ws-avg) ** 2.0\n    end-perform\n    compute ws-stddev = ( ws-sumsq / ws-tb-size) ** 0.5 \n    goback.\nend program stddev.\n", "target": ">>> from math import sqrt\n>>> def sd(x):\n    sd.sum  += x\n    sd.sum2 += x*x\n    sd.n    += 1.0\n    sum, sum2, n = sd.sum, sd.sum2, sd.n\n    return sqrt(sum2/n - sum*sum/n/n)\n\n>>> sd.sum = sd.sum2 = sd.n = 0\n>>> for value in (2,4,4,4,5,5,7,9):\n    print (value, sd(value))\n\n    \n(2, 0.0)\n(4, 1.0)\n(4, 0.94280904158206258)\n(4, 0.8660254037844386)\n(5, 0.97979589711327075)\n(5, 1.0)\n(7, 1.3997084244475311)\n(9, 2.0)\n>>>\n"}
{"id": 33096, "name": "Palindrome detection", "source": "Translate COBOL to C#:        identification division.\n       function-id. palindromic-test.\n\n       data division.\n       linkage section.\n       01 test-text            pic x any length.\n       01 result               pic x.\n          88 palindromic       value high-value\n                               when set to false low-value.\n\n       procedure division using test-text returning result.\n\n       set palindromic to false\n       if test-text equal function reverse(test-text) then\n           set palindromic to true\n       end-if\n\n       goback.\n       end function palindromic-test.\n", "target": "using System;\n\nclass Program\n{\n    static string Reverse(string value)\n    {\n        char[] chars = value.ToCharArray();\n        Array.Reverse(chars);\n        return new string(chars);\n    }\n\n    static bool IsPalindrome(string value)\n    {\n        return value == Reverse(value);\n    }\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(IsPalindrome(\"ingirumimusnocteetconsumimurigni\"));\n    }\n}\n"}
{"id": 33098, "name": "Palindrome detection", "source": "Translate COBOL to Java:        identification division.\n       function-id. palindromic-test.\n\n       data division.\n       linkage section.\n       01 test-text            pic x any length.\n       01 result               pic x.\n          88 palindromic       value high-value\n                               when set to false low-value.\n\n       procedure division using test-text returning result.\n\n       set palindromic to false\n       if test-text equal function reverse(test-text) then\n           set palindromic to true\n       end-if\n\n       goback.\n       end function palindromic-test.\n", "target": "public static boolean pali(String testMe){\n\tStringBuilder sb = new StringBuilder(testMe);\n\treturn testMe.equals(sb.reverse().toString());\n}\n"}
{"id": 33099, "name": "Palindrome detection", "source": "Translate COBOL to Python:        identification division.\n       function-id. palindromic-test.\n\n       data division.\n       linkage section.\n       01 test-text            pic x any length.\n       01 result               pic x.\n          88 palindromic       value high-value\n                               when set to false low-value.\n\n       procedure division using test-text returning result.\n\n       set palindromic to false\n       if test-text equal function reverse(test-text) then\n           set palindromic to true\n       end-if\n\n       goback.\n       end function palindromic-test.\n", "target": "def is_palindrome(s):\n  return s == s[::-1]\n"}
{"id": 33374, "name": "Loop over multiple arrays simultaneously", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Loop-Over-Multiple-Tables.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A VALUE \"abc\".\n           03  A-Vals PIC X OCCURS 3 TIMES.\n\n       01  B VALUE \"ABC\".\n           03  B-Vals PIC X OCCURS 3 TIMES.\n\n       01  C VALUE \"123\".\n           03  C-Vals PIC 9 OCCURS 3 TIMES.\n\n       01  I PIC 9.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING I FROM 1 BY 1 UNTIL 3 < I\n               DISPLAY A-Vals (I) B-Vals (I) C-Vals (I)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        char[] a = { 'a', 'b', 'c' };\n        char[] b = { 'A', 'B', 'C' };\n        int[] c = { 1, 2, 3 };\n        int min = Math.Min(a.Length, b.Length);\n        min = Math.Min(min, c.Length);\n        for (int i = 0; i < min; i++)\n            Console.WriteLine(\"{0}{1}{2}\", a[i], b[i], c[i]);\n    }             \n}\n"}
{"id": 33376, "name": "Loop over multiple arrays simultaneously", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Loop-Over-Multiple-Tables.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A VALUE \"abc\".\n           03  A-Vals PIC X OCCURS 3 TIMES.\n\n       01  B VALUE \"ABC\".\n           03  B-Vals PIC X OCCURS 3 TIMES.\n\n       01  C VALUE \"123\".\n           03  C-Vals PIC 9 OCCURS 3 TIMES.\n\n       01  I PIC 9.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING I FROM 1 BY 1 UNTIL 3 < I\n               DISPLAY A-Vals (I) B-Vals (I) C-Vals (I)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "module LoopOverMultipleArrays\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Char[]   chars   = ['a', 'b', 'c'];\n        String[] strings = [\"A\", \"B\", \"C\"];\n        Int[]    ints    = [ 1,   2,   3 ];\n\n        console.print(\"Using array indexing:\");\n        for (Int i = 0, Int longest = chars.size.maxOf(strings.size.maxOf(ints.size)); i < longest; ++i)\n            {\n            console.print($|{i < chars.size   ? chars[i].toString() : \"\"}\\\n                           |{i < strings.size ? strings[i]          : \"\"}\\\n                           |{i < ints.size    ? ints[i].toString()  : \"\"}\n                         );\n            }\n\n        console.print(\"\\nUsing array iterators:\");\n        val charIter   = chars.iterator();\n        val stringIter = strings.iterator();\n        val intIter    = ints.iterator();\n        while (True)\n            {\n            StringBuffer buf = new StringBuffer();\n            if (Char ch := charIter.next())\n                {\n                buf.add(ch);\n                }\n            if (String s := stringIter.next())\n                {\n                s.appendTo(buf);\n                }\n            if (Int n := intIter.next())\n                {\n                n.appendTo(buf);\n                }\n            if (buf.size == 0)\n                {\n                break;\n                }\n            console.print(buf);\n            }\n        }\n    }\n"}
{"id": 33377, "name": "Loop over multiple arrays simultaneously", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Loop-Over-Multiple-Tables.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A VALUE \"abc\".\n           03  A-Vals PIC X OCCURS 3 TIMES.\n\n       01  B VALUE \"ABC\".\n           03  B-Vals PIC X OCCURS 3 TIMES.\n\n       01  C VALUE \"123\".\n           03  C-Vals PIC 9 OCCURS 3 TIMES.\n\n       01  I PIC 9.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING I FROM 1 BY 1 UNTIL 3 < I\n               DISPLAY A-Vals (I) B-Vals (I) C-Vals (I)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": ">>> print ( '\\n'.join(''.join(x) for x in \nzip('abc', 'ABC', '123')) )\naA1\nbB2\ncC3\n>>>\n"}
{"id": 33625, "name": "Sorting algorithms_Cocktail sort", "source": "Translate COBOL to C#:        C-SORT SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           MOVE 2       TO WC-START\n           MOVE WC-SIZE TO WC-END.\n           MOVE 1       TO WC-DIRECTION\n                           WC-LAST-CHANGE.\n           PERFORM E-SHAKER UNTIL WC-END * WC-DIRECTION <\n                                  WC-START * WC-DIRECTION.\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       E-SHAKER SECTION.\n       E-000.\n           PERFORM F-PASS VARYING WB-IX-1 FROM WC-START BY WC-DIRECTION\n                          UNTIL WB-IX-1 = WC-END + WC-DIRECTION.\n\n           MOVE WC-START TO WC-END.\n           SUBTRACT WC-DIRECTION FROM WC-LAST-CHANGE GIVING WC-START.\n           MULTIPLY WC-DIRECTION BY -1 GIVING WC-DIRECTION.\n\n       E-999.\n           EXIT.\n\n       F-PASS SECTION.\n       F-000.\n           IF WB-ENTRY(WB-IX-1 - 1) > WB-ENTRY(WB-IX-1)\n              SET  WC-LAST-CHANGE        TO WB-IX-1\n              MOVE WB-ENTRY(WB-IX-1 - 1) TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1)     TO WB-ENTRY(WB-IX-1 - 1)\n              MOVE WC-TEMP               TO WB-ENTRY(WB-IX-1).\n\n       F-999.\n           EXIT.\n", "target": "public static void cocktailSort(int[] A)\n    {\n        bool swapped;\n        do\n        {\n            swapped = false;\n            for (int i = 0; i <= A.Length - 2; i++)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    \n                    int temp = A[i];\n                    A[i] = A[i + 1];\n                    A[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            if (!swapped)\n            {\n                \n                break;\n            }\n            swapped = false;\n            for (int i = A.Length - 2; i >= 0; i--)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    int temp = A[i];\n                    A[i] = A[i + 1];\n                    A[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            \n        } while (swapped);\n    }\n"}
{"id": 33627, "name": "Sorting algorithms_Cocktail sort", "source": "Translate COBOL to Java:        C-SORT SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           MOVE 2       TO WC-START\n           MOVE WC-SIZE TO WC-END.\n           MOVE 1       TO WC-DIRECTION\n                           WC-LAST-CHANGE.\n           PERFORM E-SHAKER UNTIL WC-END * WC-DIRECTION <\n                                  WC-START * WC-DIRECTION.\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       E-SHAKER SECTION.\n       E-000.\n           PERFORM F-PASS VARYING WB-IX-1 FROM WC-START BY WC-DIRECTION\n                          UNTIL WB-IX-1 = WC-END + WC-DIRECTION.\n\n           MOVE WC-START TO WC-END.\n           SUBTRACT WC-DIRECTION FROM WC-LAST-CHANGE GIVING WC-START.\n           MULTIPLY WC-DIRECTION BY -1 GIVING WC-DIRECTION.\n\n       E-999.\n           EXIT.\n\n       F-PASS SECTION.\n       F-000.\n           IF WB-ENTRY(WB-IX-1 - 1) > WB-ENTRY(WB-IX-1)\n              SET  WC-LAST-CHANGE        TO WB-IX-1\n              MOVE WB-ENTRY(WB-IX-1 - 1) TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1)     TO WB-ENTRY(WB-IX-1 - 1)\n              MOVE WC-TEMP               TO WB-ENTRY(WB-IX-1).\n\n       F-999.\n           EXIT.\n", "target": "public static void cocktailSort( int[] A ){\n\tboolean swapped;\n\tdo {\n\t\tswapped = false;\n\t\tfor (int i =0; i<=  A.length  - 2;i++) {\n\t\t\tif (A[ i ] > A[ i + 1 ]) {\n\t\t\t\t\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i+1];\n\t\t\t\tA[i+1]=temp;\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!swapped) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tswapped = false;\n\t\tfor (int i= A.length - 2;i>=0;i--) {\n\t\t\tif (A[ i ] > A[ i + 1 ]) {\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i+1];\n\t\t\t\tA[i+1]=temp;\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\t\t\n\t} while (swapped);\n}\n"}
{"id": 33628, "name": "Sorting algorithms_Cocktail sort", "source": "Translate COBOL to Python:        C-SORT SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           MOVE 2       TO WC-START\n           MOVE WC-SIZE TO WC-END.\n           MOVE 1       TO WC-DIRECTION\n                           WC-LAST-CHANGE.\n           PERFORM E-SHAKER UNTIL WC-END * WC-DIRECTION <\n                                  WC-START * WC-DIRECTION.\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       E-SHAKER SECTION.\n       E-000.\n           PERFORM F-PASS VARYING WB-IX-1 FROM WC-START BY WC-DIRECTION\n                          UNTIL WB-IX-1 = WC-END + WC-DIRECTION.\n\n           MOVE WC-START TO WC-END.\n           SUBTRACT WC-DIRECTION FROM WC-LAST-CHANGE GIVING WC-START.\n           MULTIPLY WC-DIRECTION BY -1 GIVING WC-DIRECTION.\n\n       E-999.\n           EXIT.\n\n       F-PASS SECTION.\n       F-000.\n           IF WB-ENTRY(WB-IX-1 - 1) > WB-ENTRY(WB-IX-1)\n              SET  WC-LAST-CHANGE        TO WB-IX-1\n              MOVE WB-ENTRY(WB-IX-1 - 1) TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1)     TO WB-ENTRY(WB-IX-1 - 1)\n              MOVE WC-TEMP               TO WB-ENTRY(WB-IX-1).\n\n       F-999.\n           EXIT.\n", "target": "def cocktailSort(A):\n    up = range(len(A)-1)\n    while True:\n        for indices in (up, reversed(up)):\n            swapped = False\n            for i in indices:\n                if A[i] > A[i+1]:  \n                    A[i], A[i+1] =  A[i+1], A[i]\n                    swapped = True\n            if not swapped:\n                return\n"}
{"id": 34706, "name": "Check output device is a terminal", "source": "Translate COBOL to C#:       \n      \n      \n      \n      \n       identification division.\n       program-id. istty.\n\n       data division.\n       working-storage section.\n       01 rc usage binary-long.\n\n       procedure division.\n       sample-main.\n\n       call \"isatty\" using by value 0 returning rc\n       display \"fd 0 tty: \" rc\n\n       call \"isatty\" using by value 1 returning rc\n       display \"fd 1 tty: \" rc upon syserr\n\n       call \"isatty\" using by value 2 returning rc\n       display \"fd 2 tty: \" rc\n\n       goback.\n       end program istty.\n", "target": "using System;\n\nnamespace CheckTerminal {\n    class Program {\n        static void Main(string[] args) {\n            Console.WriteLine(\"Stdout is tty: {0}\", Console.IsOutputRedirected);\n        }\n    }\n}\n"}
{"id": 34707, "name": "Check output device is a terminal", "source": "Translate COBOL to C#:       \n      \n      \n      \n      \n       identification division.\n       program-id. istty.\n\n       data division.\n       working-storage section.\n       01 rc usage binary-long.\n\n       procedure division.\n       sample-main.\n\n       call \"isatty\" using by value 0 returning rc\n       display \"fd 0 tty: \" rc\n\n       call \"isatty\" using by value 1 returning rc\n       display \"fd 1 tty: \" rc upon syserr\n\n       call \"isatty\" using by value 2 returning rc\n       display \"fd 2 tty: \" rc\n\n       goback.\n       end program istty.\n", "target": "using System;\n\nnamespace CheckTerminal {\n    class Program {\n        static void Main(string[] args) {\n            Console.WriteLine(\"Stdout is tty: {0}\", Console.IsOutputRedirected);\n        }\n    }\n}\n"}
{"id": 34710, "name": "Check output device is a terminal", "source": "Translate COBOL to Python:       \n      \n      \n      \n      \n       identification division.\n       program-id. istty.\n\n       data division.\n       working-storage section.\n       01 rc usage binary-long.\n\n       procedure division.\n       sample-main.\n\n       call \"isatty\" using by value 0 returning rc\n       display \"fd 0 tty: \" rc\n\n       call \"isatty\" using by value 1 returning rc\n       display \"fd 1 tty: \" rc upon syserr\n\n       call \"isatty\" using by value 2 returning rc\n       display \"fd 2 tty: \" rc\n\n       goback.\n       end program istty.\n", "target": "from sys import stdout\nif stdout.isatty():\n    print 'The output device is a teletype. Or something like a teletype.'\nelse:\n    print 'The output device isn\\'t like a teletype.'\n"}
{"id": 34711, "name": "Check output device is a terminal", "source": "Translate COBOL to Python:       \n      \n      \n      \n      \n       identification division.\n       program-id. istty.\n\n       data division.\n       working-storage section.\n       01 rc usage binary-long.\n\n       procedure division.\n       sample-main.\n\n       call \"isatty\" using by value 0 returning rc\n       display \"fd 0 tty: \" rc\n\n       call \"isatty\" using by value 1 returning rc\n       display \"fd 1 tty: \" rc upon syserr\n\n       call \"isatty\" using by value 2 returning rc\n       display \"fd 2 tty: \" rc\n\n       goback.\n       end program istty.\n", "target": "from sys import stdout\nif stdout.isatty():\n    print 'The output device is a teletype. Or something like a teletype.'\nelse:\n    print 'The output device isn\\'t like a teletype.'\n"}
{"id": 35001, "name": "Averages_Median", "source": "Translate COBOL to C#: FUNCTION MEDIAN(some-table (ALL))\n", "target": "using System;\nusing System.Linq;\n\nnamespace Test\n{\n    class Program\n    {\n        static void Main()\n        {\n            double[] myArr = new double[] { 1, 5, 3, 6, 4, 2 };\n\n            myArr = myArr.OrderBy(i => i).ToArray();\n            \n\n            int mid = myArr.Length / 2;\n            double median;\n\n            if (myArr.Length % 2 == 0)\n            {\n                \n                median = (myArr[mid] + myArr[mid - 1]) / 2.0;\n            }\n            else\n            {\n                \n                median = myArr[mid];\n            }\n\n            Console.WriteLine(median);\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 35003, "name": "Averages_Median", "source": "Translate COBOL to Java: FUNCTION MEDIAN(some-table (ALL))\n", "target": "\npublic static double median(List<Double> list) {\n    Collections.sort(list);\n    return (list.get(list.size() / 2) + list.get((list.size() - 1) / 2)) / 2;\n}\n"}
{"id": 35004, "name": "Averages_Median", "source": "Translate COBOL to Python: FUNCTION MEDIAN(some-table (ALL))\n", "target": "def median(aray):\n    srtd = sorted(aray)\n    alen = len(srtd)\n    return 0.5*( srtd[(alen-1)//2] + srtd[alen//2])\n\na = (4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2)\nprint a, median(a)\na = (4.1, 7.2, 1.7, 9.3, 4.4, 3.2)\nprint a, median(a)\n"}
{"id": 35161, "name": "Pointers and references", "source": "Translate COBOL to C#:        01  ptr                     USAGE POINTER TO Some-Type.\n       01  prog-ptr                USAGE PROGRAM-POINTER \"some-program\". \n", "target": "static void Main(string[] args)\n{\n\tint p;\n\n\tp = 1;\n\tConsole.WriteLine(\"Ref Before: \" + p);\n\tValue(ref p);\n\tConsole.WriteLine(\"Ref After\u00a0: \" + p);\n\n\tp = 1;\n\tConsole.WriteLine(\"Val Before: \" + p);\n\tValue(p);\n\tConsole.WriteLine(\"Val After\u00a0: \" + p);\n\n\tConsole.ReadLine();\n}\n\nprivate static void Value(ref int Value)\n{\n\tValue += 1;\n}\nprivate static void Value(int Value)\n{\n\tValue += 1;\n}\n"}
{"id": 35163, "name": "Pointers and references", "source": "Translate COBOL to Java:        01  ptr                     USAGE POINTER TO Some-Type.\n       01  prog-ptr                USAGE PROGRAM-POINTER \"some-program\". \n", "target": " public class Foo { public int x = 0; }\n\n void somefunction() {\n     Foo a; \n     a = new Foo(); \n     Foo b = a; \n     a.x = 5; \n     System.out.println(b.x); \n }\n"}
{"id": 35164, "name": "Pointers and references", "source": "Translate COBOL to Python:        01  ptr                     USAGE POINTER TO Some-Type.\n       01  prog-ptr                USAGE PROGRAM-POINTER \"some-program\". \n", "target": " \n a = \"foo\"\n \n b = []\n \n class Foo(object):\n     pass\n c = Foo()\n \n class Bar(object):\n     def __init__(self, initializer = None)\n         \n         if initializer is not None:\n            self.value = initializer\n d = Bar(10)\n print d.value\n \n if a is b: pass\n \n if id(a) == id(b): pass\n \n def a(fmt, *args):\n     if fmt is None:\n         fmt = \"%s\"\n      print fmt % (args)\n \n b.append(a)\n \n del(a)\n \n b[0](\"foo\")  \n              \n"}
{"id": 35422, "name": "Sierpinski triangle", "source": "Translate COBOL to C#: identification division.\nprogram-id. sierpinski-triangle-program.\ndata division.\nworking-storage section.\n01  sierpinski.\n    05 n              pic 99.\n    05 i              pic 999.\n    05 k              pic 999.\n    05 m              pic 999.\n    05 c              pic 9(18).\n    05 i-limit        pic 999.\n    05 q              pic 9(18).\n    05 r              pic 9.\nprocedure division.\ncontrol-paragraph.\n    move 4 to n.\n    multiply n by 4 giving i-limit.\n    subtract 1 from i-limit.\n    perform sierpinski-paragraph\n    varying i from 0 by 1 until i is greater than i-limit.\n    stop run.\nsierpinski-paragraph.\n    subtract i from i-limit giving m.\n    multiply m by 2 giving m.\n    perform m times,\n    display space with no advancing,\n    end-perform.\n    move 1 to c.\n    perform inner-loop-paragraph\n    varying k from 0 by 1 until k is greater than i.\n    display ''.\ninner-loop-paragraph.\n    divide c by 2 giving q remainder r.\n    if r is equal to zero then display '  * ' with no advancing.\n    if r is not equal to zero then display '    ' with no advancing.\n    compute c = c * (i - k) / (k + 1).\n", "target": "using System;\nusing System.Collections;\n\nnamespace RosettaCode {\n    class SierpinskiTriangle {\n        int len;\n        BitArray b;\n\n        public SierpinskiTriangle(int n) {\n            if (n < 1) {\n                throw new ArgumentOutOfRangeException(\"Order must be greater than zero\");\n            }\n            len = 1 << (n+1);\n            b = new BitArray(len+1, false);\n            b[len>>1] = true;\n        }\n\n        public void Display() {\n            for (int j = 0; j < len / 2; j++) {\n                for (int i = 0; i < b.Count; i++) {\n                    Console.Write(\"{0}\", b[i] ? \"*\" : \" \");\n                }\n                Console.WriteLine();\n                NextGen();\n            }\n        }\n\n        private void NextGen() {\n            BitArray next = new BitArray(b.Count, false);\n            for (int i = 0; i < b.Count; i++) {\n                if (b[i]) {\n                    next[i - 1] = next[i - 1] ^ true;\n                    next[i + 1] = next[i + 1] ^ true;\n                }\n            }\n            b = next;\n        }\n    }\n}\n"}
{"id": 35424, "name": "Sierpinski triangle", "source": "Translate COBOL to Java: identification division.\nprogram-id. sierpinski-triangle-program.\ndata division.\nworking-storage section.\n01  sierpinski.\n    05 n              pic 99.\n    05 i              pic 999.\n    05 k              pic 999.\n    05 m              pic 999.\n    05 c              pic 9(18).\n    05 i-limit        pic 999.\n    05 q              pic 9(18).\n    05 r              pic 9.\nprocedure division.\ncontrol-paragraph.\n    move 4 to n.\n    multiply n by 4 giving i-limit.\n    subtract 1 from i-limit.\n    perform sierpinski-paragraph\n    varying i from 0 by 1 until i is greater than i-limit.\n    stop run.\nsierpinski-paragraph.\n    subtract i from i-limit giving m.\n    multiply m by 2 giving m.\n    perform m times,\n    display space with no advancing,\n    end-perform.\n    move 1 to c.\n    perform inner-loop-paragraph\n    varying k from 0 by 1 until k is greater than i.\n    display ''.\ninner-loop-paragraph.\n    divide c by 2 giving q remainder r.\n    if r is equal to zero then display '  * ' with no advancing.\n    if r is not equal to zero then display '    ' with no advancing.\n    compute c = c * (i - k) / (k + 1).\n", "target": "public class SierpinskiTriangle {\n\n    public static void main(String[] args) {\n        System.out.println(getSierpinskiTriangle(4));\n    }\n    \n    private static final String getSierpinskiTriangle(int n) {\n        if ( n == 0 ) {\n            return \"*\";\n        }\n\n        String s = getSierpinskiTriangle(n-1);\n        String [] split = s.split(\"\\n\");\n        int length = split.length;\n\n        \n        StringBuilder sb = new StringBuilder();\n        String top = buildSpace((int)Math.pow(2, n-1));\n        for ( int i = 0 ; i < length ;i++ ) {\n            sb.append(top);\n            sb.append(split[i]);\n            sb.append(\"\\n\");\n        }\n        \n        \n        for ( int i = 0 ; i < length ;i++ ) {\n            sb.append(split[i]);\n            sb.append(buildSpace(length-i));\n            sb.append(split[i]);\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n    \n    private static String buildSpace(int n) {\n        StringBuilder sb = new StringBuilder();\n        while ( n > 0 ) {\n            sb.append(\" \");\n            n--;\n        }\n        return sb.toString();\n    }\n    \n}\n"}
{"id": 35425, "name": "Sierpinski triangle", "source": "Translate COBOL to Python: identification division.\nprogram-id. sierpinski-triangle-program.\ndata division.\nworking-storage section.\n01  sierpinski.\n    05 n              pic 99.\n    05 i              pic 999.\n    05 k              pic 999.\n    05 m              pic 999.\n    05 c              pic 9(18).\n    05 i-limit        pic 999.\n    05 q              pic 9(18).\n    05 r              pic 9.\nprocedure division.\ncontrol-paragraph.\n    move 4 to n.\n    multiply n by 4 giving i-limit.\n    subtract 1 from i-limit.\n    perform sierpinski-paragraph\n    varying i from 0 by 1 until i is greater than i-limit.\n    stop run.\nsierpinski-paragraph.\n    subtract i from i-limit giving m.\n    multiply m by 2 giving m.\n    perform m times,\n    display space with no advancing,\n    end-perform.\n    move 1 to c.\n    perform inner-loop-paragraph\n    varying k from 0 by 1 until k is greater than i.\n    display ''.\ninner-loop-paragraph.\n    divide c by 2 giving q remainder r.\n    if r is equal to zero then display '  * ' with no advancing.\n    if r is not equal to zero then display '    ' with no advancing.\n    compute c = c * (i - k) / (k + 1).\n", "target": "def sierpinski(n):\n    d = [\"*\"]\n    for i in xrange(n):\n        sp = \" \" * (2 ** i)\n        d = [sp+x+sp for x in d] + [x+\" \"+x for x in d]\n    return d\n\nprint \"\\n\".join(sierpinski(4))\n"}
{"id": 36154, "name": "Continued fraction", "source": "Translate COBOL to C#:        identification division.\n       program-id. show-continued-fractions.\n\n       environment division.\n       configuration section.\n       repository.\n           function continued-fractions\n           function all intrinsic.\n\n       procedure division.\n       fractions-main.\n\n       display \"Square root 2 approximately  \u00a0: \"\n               continued-fractions(\"sqrt-2-alpha\", \"sqrt-2-beta\", 100)\n       display \"Napier constant approximately\u00a0: \"\n               continued-fractions(\"napier-alpha\", \"napier-beta\", 40)\n       display \"Pi approximately             \u00a0: \"\n               continued-fractions(\"pi-alpha\", \"pi-beta\", 10000)\n\n       goback.\n       end program show-continued-fractions.\n\n      \n       identification division.\n       function-id. continued-fractions.\n      \n       data division.\n       working-storage section.\n       01 alpha-function       usage program-pointer.\n       01 beta-function        usage program-pointer.\n       01 alpha                usage float-long.\n       01 beta                 usage float-long.\n       01 running              usage float-long.\n       01 i                    usage binary-long.\n\n       linkage section.\n       01 alpha-name           pic x any length.\n       01 beta-name            pic x any length.\n       01 iterations           pic 9 any length.\n       01 approximation        usage float-long.\n\n       procedure division using\n           alpha-name beta-name iterations\n           returning approximation.\n\n       set alpha-function to entry alpha-name\n       if alpha-function = null then\n           display \"error: no \" alpha-name \" function\" upon syserr\n           goback\n       end-if\n       set beta-function to entry beta-name\n       if beta-function = null then\n           display \"error: no \" beta-name \" function\" upon syserr\n           goback\n       end-if\n\n       move 0 to alpha beta running\n       perform varying i from iterations by -1 until i = 0\n           call alpha-function using i returning alpha\n           call beta-function using i returning beta\n           compute running = beta / (alpha + running)\n       end-perform\n       call alpha-function using 0 returning alpha\n       compute approximation = alpha + running\n\n       goback.\n       end function continued-fractions.\n\n      \n       identification division.\n       program-id. sqrt-2-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 1.0 to result\n       else\n           move 2.0 to result\n       end-if\n\n       goback.\n       end program sqrt-2-alpha.\n\n      \n       identification division.\n       program-id. sqrt-2-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       move 1.0 to result\n\n       goback.\n       end program sqrt-2-beta.\n\n      \n       identification division.\n       program-id. napier-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 2.0 to result\n       else\n           move iteration to result\n       end-if\n\n       goback.\n       end program napier-alpha.\n\n      \n       identification division.\n       program-id. napier-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration = 1 then\n           move 1.0 to result\n       else\n           compute result = iteration - 1.0\n       end-if\n\n       goback.\n       end program napier-beta.\n\n      \n       identification division.\n       program-id. pi-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 3.0 to result\n       else\n           move 6.0 to result\n       end-if\n\n       goback.\n       end program pi-alpha.\n\n      \n       identification division.\n       program-id. pi-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       compute result = (2 * iteration - 1) ** 2\n\n       goback.\n       end program pi-beta.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ContinuedFraction {\n    class Program {\n        static double Calc(Func<int, int[]> f, int n) {\n            double temp = 0.0;\n            for (int ni = n; ni >= 1; ni--) {\n                int[] p = f(ni);\n                temp = p[1] / (p[0] + temp);\n            }\n            return f(0)[0] + temp;\n        }\n\n        static void Main(string[] args) {\n            List<Func<int, int[]>> fList = new List<Func<int, int[]>>();\n            fList.Add(n => new int[] { n > 0 ? 2 : 1, 1 });\n            fList.Add(n => new int[] { n > 0 ? n : 2, n > 1 ? (n - 1) : 1 });\n            fList.Add(n => new int[] { n > 0 ? 6 : 3, (int) Math.Pow(2 * n - 1, 2) });\n\n            foreach (var f in fList) {\n                Console.WriteLine(Calc(f, 200));\n            }\n        }\n    }\n}\n"}
{"id": 36155, "name": "Continued fraction", "source": "Translate COBOL to C#:        identification division.\n       program-id. show-continued-fractions.\n\n       environment division.\n       configuration section.\n       repository.\n           function continued-fractions\n           function all intrinsic.\n\n       procedure division.\n       fractions-main.\n\n       display \"Square root 2 approximately  \u00a0: \"\n               continued-fractions(\"sqrt-2-alpha\", \"sqrt-2-beta\", 100)\n       display \"Napier constant approximately\u00a0: \"\n               continued-fractions(\"napier-alpha\", \"napier-beta\", 40)\n       display \"Pi approximately             \u00a0: \"\n               continued-fractions(\"pi-alpha\", \"pi-beta\", 10000)\n\n       goback.\n       end program show-continued-fractions.\n\n      \n       identification division.\n       function-id. continued-fractions.\n      \n       data division.\n       working-storage section.\n       01 alpha-function       usage program-pointer.\n       01 beta-function        usage program-pointer.\n       01 alpha                usage float-long.\n       01 beta                 usage float-long.\n       01 running              usage float-long.\n       01 i                    usage binary-long.\n\n       linkage section.\n       01 alpha-name           pic x any length.\n       01 beta-name            pic x any length.\n       01 iterations           pic 9 any length.\n       01 approximation        usage float-long.\n\n       procedure division using\n           alpha-name beta-name iterations\n           returning approximation.\n\n       set alpha-function to entry alpha-name\n       if alpha-function = null then\n           display \"error: no \" alpha-name \" function\" upon syserr\n           goback\n       end-if\n       set beta-function to entry beta-name\n       if beta-function = null then\n           display \"error: no \" beta-name \" function\" upon syserr\n           goback\n       end-if\n\n       move 0 to alpha beta running\n       perform varying i from iterations by -1 until i = 0\n           call alpha-function using i returning alpha\n           call beta-function using i returning beta\n           compute running = beta / (alpha + running)\n       end-perform\n       call alpha-function using 0 returning alpha\n       compute approximation = alpha + running\n\n       goback.\n       end function continued-fractions.\n\n      \n       identification division.\n       program-id. sqrt-2-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 1.0 to result\n       else\n           move 2.0 to result\n       end-if\n\n       goback.\n       end program sqrt-2-alpha.\n\n      \n       identification division.\n       program-id. sqrt-2-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       move 1.0 to result\n\n       goback.\n       end program sqrt-2-beta.\n\n      \n       identification division.\n       program-id. napier-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 2.0 to result\n       else\n           move iteration to result\n       end-if\n\n       goback.\n       end program napier-alpha.\n\n      \n       identification division.\n       program-id. napier-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration = 1 then\n           move 1.0 to result\n       else\n           compute result = iteration - 1.0\n       end-if\n\n       goback.\n       end program napier-beta.\n\n      \n       identification division.\n       program-id. pi-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 3.0 to result\n       else\n           move 6.0 to result\n       end-if\n\n       goback.\n       end program pi-alpha.\n\n      \n       identification division.\n       program-id. pi-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       compute result = (2 * iteration - 1) ** 2\n\n       goback.\n       end program pi-beta.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ContinuedFraction {\n    class Program {\n        static double Calc(Func<int, int[]> f, int n) {\n            double temp = 0.0;\n            for (int ni = n; ni >= 1; ni--) {\n                int[] p = f(ni);\n                temp = p[1] / (p[0] + temp);\n            }\n            return f(0)[0] + temp;\n        }\n\n        static void Main(string[] args) {\n            List<Func<int, int[]>> fList = new List<Func<int, int[]>>();\n            fList.Add(n => new int[] { n > 0 ? 2 : 1, 1 });\n            fList.Add(n => new int[] { n > 0 ? n : 2, n > 1 ? (n - 1) : 1 });\n            fList.Add(n => new int[] { n > 0 ? 6 : 3, (int) Math.Pow(2 * n - 1, 2) });\n\n            foreach (var f in fList) {\n                Console.WriteLine(Calc(f, 200));\n            }\n        }\n    }\n}\n"}
{"id": 36158, "name": "Continued fraction", "source": "Translate COBOL to Java:        identification division.\n       program-id. show-continued-fractions.\n\n       environment division.\n       configuration section.\n       repository.\n           function continued-fractions\n           function all intrinsic.\n\n       procedure division.\n       fractions-main.\n\n       display \"Square root 2 approximately  \u00a0: \"\n               continued-fractions(\"sqrt-2-alpha\", \"sqrt-2-beta\", 100)\n       display \"Napier constant approximately\u00a0: \"\n               continued-fractions(\"napier-alpha\", \"napier-beta\", 40)\n       display \"Pi approximately             \u00a0: \"\n               continued-fractions(\"pi-alpha\", \"pi-beta\", 10000)\n\n       goback.\n       end program show-continued-fractions.\n\n      \n       identification division.\n       function-id. continued-fractions.\n      \n       data division.\n       working-storage section.\n       01 alpha-function       usage program-pointer.\n       01 beta-function        usage program-pointer.\n       01 alpha                usage float-long.\n       01 beta                 usage float-long.\n       01 running              usage float-long.\n       01 i                    usage binary-long.\n\n       linkage section.\n       01 alpha-name           pic x any length.\n       01 beta-name            pic x any length.\n       01 iterations           pic 9 any length.\n       01 approximation        usage float-long.\n\n       procedure division using\n           alpha-name beta-name iterations\n           returning approximation.\n\n       set alpha-function to entry alpha-name\n       if alpha-function = null then\n           display \"error: no \" alpha-name \" function\" upon syserr\n           goback\n       end-if\n       set beta-function to entry beta-name\n       if beta-function = null then\n           display \"error: no \" beta-name \" function\" upon syserr\n           goback\n       end-if\n\n       move 0 to alpha beta running\n       perform varying i from iterations by -1 until i = 0\n           call alpha-function using i returning alpha\n           call beta-function using i returning beta\n           compute running = beta / (alpha + running)\n       end-perform\n       call alpha-function using 0 returning alpha\n       compute approximation = alpha + running\n\n       goback.\n       end function continued-fractions.\n\n      \n       identification division.\n       program-id. sqrt-2-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 1.0 to result\n       else\n           move 2.0 to result\n       end-if\n\n       goback.\n       end program sqrt-2-alpha.\n\n      \n       identification division.\n       program-id. sqrt-2-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       move 1.0 to result\n\n       goback.\n       end program sqrt-2-beta.\n\n      \n       identification division.\n       program-id. napier-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 2.0 to result\n       else\n           move iteration to result\n       end-if\n\n       goback.\n       end program napier-alpha.\n\n      \n       identification division.\n       program-id. napier-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration = 1 then\n           move 1.0 to result\n       else\n           compute result = iteration - 1.0\n       end-if\n\n       goback.\n       end program napier-beta.\n\n      \n       identification division.\n       program-id. pi-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 3.0 to result\n       else\n           move 6.0 to result\n       end-if\n\n       goback.\n       end program pi-alpha.\n\n      \n       identification division.\n       program-id. pi-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       compute result = (2 * iteration - 1) ** 2\n\n       goback.\n       end program pi-beta.\n", "target": "import static java.lang.Math.pow;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Test {\n    static double calc(Function<Integer, Integer[]> f, int n) {\n        double temp = 0;\n\n        for (int ni = n; ni >= 1; ni--) {\n            Integer[] p = f.apply(ni);\n            temp = p[1] / (double) (p[0] + temp);\n        }\n        return f.apply(0)[0] + temp;\n    }\n\n    public static void main(String[] args) {\n        List<Function<Integer, Integer[]>> fList = new ArrayList<>();\n        fList.add(n -> new Integer[]{n > 0 ? 2 : 1, 1});\n        fList.add(n -> new Integer[]{n > 0 ? n : 2, n > 1 ? (n - 1) : 1});\n        fList.add(n -> new Integer[]{n > 0 ? 6 : 3, (int) pow(2 * n - 1, 2)});\n\n        for (Function<Integer, Integer[]> f : fList)\n            System.out.println(calc(f, 200));\n    }\n}\n"}
{"id": 36159, "name": "Continued fraction", "source": "Translate COBOL to Java:        identification division.\n       program-id. show-continued-fractions.\n\n       environment division.\n       configuration section.\n       repository.\n           function continued-fractions\n           function all intrinsic.\n\n       procedure division.\n       fractions-main.\n\n       display \"Square root 2 approximately  \u00a0: \"\n               continued-fractions(\"sqrt-2-alpha\", \"sqrt-2-beta\", 100)\n       display \"Napier constant approximately\u00a0: \"\n               continued-fractions(\"napier-alpha\", \"napier-beta\", 40)\n       display \"Pi approximately             \u00a0: \"\n               continued-fractions(\"pi-alpha\", \"pi-beta\", 10000)\n\n       goback.\n       end program show-continued-fractions.\n\n      \n       identification division.\n       function-id. continued-fractions.\n      \n       data division.\n       working-storage section.\n       01 alpha-function       usage program-pointer.\n       01 beta-function        usage program-pointer.\n       01 alpha                usage float-long.\n       01 beta                 usage float-long.\n       01 running              usage float-long.\n       01 i                    usage binary-long.\n\n       linkage section.\n       01 alpha-name           pic x any length.\n       01 beta-name            pic x any length.\n       01 iterations           pic 9 any length.\n       01 approximation        usage float-long.\n\n       procedure division using\n           alpha-name beta-name iterations\n           returning approximation.\n\n       set alpha-function to entry alpha-name\n       if alpha-function = null then\n           display \"error: no \" alpha-name \" function\" upon syserr\n           goback\n       end-if\n       set beta-function to entry beta-name\n       if beta-function = null then\n           display \"error: no \" beta-name \" function\" upon syserr\n           goback\n       end-if\n\n       move 0 to alpha beta running\n       perform varying i from iterations by -1 until i = 0\n           call alpha-function using i returning alpha\n           call beta-function using i returning beta\n           compute running = beta / (alpha + running)\n       end-perform\n       call alpha-function using 0 returning alpha\n       compute approximation = alpha + running\n\n       goback.\n       end function continued-fractions.\n\n      \n       identification division.\n       program-id. sqrt-2-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 1.0 to result\n       else\n           move 2.0 to result\n       end-if\n\n       goback.\n       end program sqrt-2-alpha.\n\n      \n       identification division.\n       program-id. sqrt-2-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       move 1.0 to result\n\n       goback.\n       end program sqrt-2-beta.\n\n      \n       identification division.\n       program-id. napier-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 2.0 to result\n       else\n           move iteration to result\n       end-if\n\n       goback.\n       end program napier-alpha.\n\n      \n       identification division.\n       program-id. napier-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration = 1 then\n           move 1.0 to result\n       else\n           compute result = iteration - 1.0\n       end-if\n\n       goback.\n       end program napier-beta.\n\n      \n       identification division.\n       program-id. pi-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 3.0 to result\n       else\n           move 6.0 to result\n       end-if\n\n       goback.\n       end program pi-alpha.\n\n      \n       identification division.\n       program-id. pi-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       compute result = (2 * iteration - 1) ** 2\n\n       goback.\n       end program pi-beta.\n", "target": "import static java.lang.Math.pow;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Test {\n    static double calc(Function<Integer, Integer[]> f, int n) {\n        double temp = 0;\n\n        for (int ni = n; ni >= 1; ni--) {\n            Integer[] p = f.apply(ni);\n            temp = p[1] / (double) (p[0] + temp);\n        }\n        return f.apply(0)[0] + temp;\n    }\n\n    public static void main(String[] args) {\n        List<Function<Integer, Integer[]>> fList = new ArrayList<>();\n        fList.add(n -> new Integer[]{n > 0 ? 2 : 1, 1});\n        fList.add(n -> new Integer[]{n > 0 ? n : 2, n > 1 ? (n - 1) : 1});\n        fList.add(n -> new Integer[]{n > 0 ? 6 : 3, (int) pow(2 * n - 1, 2)});\n\n        for (Function<Integer, Integer[]> f : fList)\n            System.out.println(calc(f, 200));\n    }\n}\n"}
{"id": 36160, "name": "Continued fraction", "source": "Translate COBOL to Python:        identification division.\n       program-id. show-continued-fractions.\n\n       environment division.\n       configuration section.\n       repository.\n           function continued-fractions\n           function all intrinsic.\n\n       procedure division.\n       fractions-main.\n\n       display \"Square root 2 approximately  \u00a0: \"\n               continued-fractions(\"sqrt-2-alpha\", \"sqrt-2-beta\", 100)\n       display \"Napier constant approximately\u00a0: \"\n               continued-fractions(\"napier-alpha\", \"napier-beta\", 40)\n       display \"Pi approximately             \u00a0: \"\n               continued-fractions(\"pi-alpha\", \"pi-beta\", 10000)\n\n       goback.\n       end program show-continued-fractions.\n\n      \n       identification division.\n       function-id. continued-fractions.\n      \n       data division.\n       working-storage section.\n       01 alpha-function       usage program-pointer.\n       01 beta-function        usage program-pointer.\n       01 alpha                usage float-long.\n       01 beta                 usage float-long.\n       01 running              usage float-long.\n       01 i                    usage binary-long.\n\n       linkage section.\n       01 alpha-name           pic x any length.\n       01 beta-name            pic x any length.\n       01 iterations           pic 9 any length.\n       01 approximation        usage float-long.\n\n       procedure division using\n           alpha-name beta-name iterations\n           returning approximation.\n\n       set alpha-function to entry alpha-name\n       if alpha-function = null then\n           display \"error: no \" alpha-name \" function\" upon syserr\n           goback\n       end-if\n       set beta-function to entry beta-name\n       if beta-function = null then\n           display \"error: no \" beta-name \" function\" upon syserr\n           goback\n       end-if\n\n       move 0 to alpha beta running\n       perform varying i from iterations by -1 until i = 0\n           call alpha-function using i returning alpha\n           call beta-function using i returning beta\n           compute running = beta / (alpha + running)\n       end-perform\n       call alpha-function using 0 returning alpha\n       compute approximation = alpha + running\n\n       goback.\n       end function continued-fractions.\n\n      \n       identification division.\n       program-id. sqrt-2-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 1.0 to result\n       else\n           move 2.0 to result\n       end-if\n\n       goback.\n       end program sqrt-2-alpha.\n\n      \n       identification division.\n       program-id. sqrt-2-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       move 1.0 to result\n\n       goback.\n       end program sqrt-2-beta.\n\n      \n       identification division.\n       program-id. napier-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 2.0 to result\n       else\n           move iteration to result\n       end-if\n\n       goback.\n       end program napier-alpha.\n\n      \n       identification division.\n       program-id. napier-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration = 1 then\n           move 1.0 to result\n       else\n           compute result = iteration - 1.0\n       end-if\n\n       goback.\n       end program napier-beta.\n\n      \n       identification division.\n       program-id. pi-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 3.0 to result\n       else\n           move 6.0 to result\n       end-if\n\n       goback.\n       end program pi-alpha.\n\n      \n       identification division.\n       program-id. pi-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       compute result = (2 * iteration - 1) ** 2\n\n       goback.\n       end program pi-beta.\n", "target": "from fractions import Fraction\nimport itertools\ntry: zip = itertools.izip\nexcept: pass\n \n\ndef CF(a, b, t):\n  terms = list(itertools.islice(zip(a, b), t))\n  z = Fraction(1,1)\n  for a, b in reversed(terms):\n    z = a + b / z\n  return z\n \n\ndef pRes(x, d):\n  q, x = divmod(x, 1)\n  res = str(q)\n  res += \".\"\n  for i in range(d):\n    x *= 10\n    q, x = divmod(x, 1)\n    res += str(q)\n  return res\n \n\ndef sqrt2_a():\n  yield 1\n  for x in itertools.repeat(2):\n    yield x\n \ndef sqrt2_b():\n  for x in itertools.repeat(1):\n    yield x\n \ncf = CF(sqrt2_a(), sqrt2_b(), 950)\nprint(pRes(cf, 200))\n\n \n \n\ndef Napier_a():\n  yield 2\n  for x in itertools.count(1):\n    yield x\n \ndef Napier_b():\n  yield 1\n  for x in itertools.count(1):\n    yield x\n \ncf = CF(Napier_a(), Napier_b(), 950)\nprint(pRes(cf, 200))\n\n \n\ndef Pi_a():\n  yield 3\n  for x in itertools.repeat(6):\n    yield x\n \ndef Pi_b():\n  for x in itertools.count(1,2):\n    yield x*x\n \ncf = CF(Pi_a(), Pi_b(), 950)\nprint(pRes(cf, 10))\n\n"}
{"id": 36161, "name": "Continued fraction", "source": "Translate COBOL to Python:        identification division.\n       program-id. show-continued-fractions.\n\n       environment division.\n       configuration section.\n       repository.\n           function continued-fractions\n           function all intrinsic.\n\n       procedure division.\n       fractions-main.\n\n       display \"Square root 2 approximately  \u00a0: \"\n               continued-fractions(\"sqrt-2-alpha\", \"sqrt-2-beta\", 100)\n       display \"Napier constant approximately\u00a0: \"\n               continued-fractions(\"napier-alpha\", \"napier-beta\", 40)\n       display \"Pi approximately             \u00a0: \"\n               continued-fractions(\"pi-alpha\", \"pi-beta\", 10000)\n\n       goback.\n       end program show-continued-fractions.\n\n      \n       identification division.\n       function-id. continued-fractions.\n      \n       data division.\n       working-storage section.\n       01 alpha-function       usage program-pointer.\n       01 beta-function        usage program-pointer.\n       01 alpha                usage float-long.\n       01 beta                 usage float-long.\n       01 running              usage float-long.\n       01 i                    usage binary-long.\n\n       linkage section.\n       01 alpha-name           pic x any length.\n       01 beta-name            pic x any length.\n       01 iterations           pic 9 any length.\n       01 approximation        usage float-long.\n\n       procedure division using\n           alpha-name beta-name iterations\n           returning approximation.\n\n       set alpha-function to entry alpha-name\n       if alpha-function = null then\n           display \"error: no \" alpha-name \" function\" upon syserr\n           goback\n       end-if\n       set beta-function to entry beta-name\n       if beta-function = null then\n           display \"error: no \" beta-name \" function\" upon syserr\n           goback\n       end-if\n\n       move 0 to alpha beta running\n       perform varying i from iterations by -1 until i = 0\n           call alpha-function using i returning alpha\n           call beta-function using i returning beta\n           compute running = beta / (alpha + running)\n       end-perform\n       call alpha-function using 0 returning alpha\n       compute approximation = alpha + running\n\n       goback.\n       end function continued-fractions.\n\n      \n       identification division.\n       program-id. sqrt-2-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 1.0 to result\n       else\n           move 2.0 to result\n       end-if\n\n       goback.\n       end program sqrt-2-alpha.\n\n      \n       identification division.\n       program-id. sqrt-2-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       move 1.0 to result\n\n       goback.\n       end program sqrt-2-beta.\n\n      \n       identification division.\n       program-id. napier-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 2.0 to result\n       else\n           move iteration to result\n       end-if\n\n       goback.\n       end program napier-alpha.\n\n      \n       identification division.\n       program-id. napier-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration = 1 then\n           move 1.0 to result\n       else\n           compute result = iteration - 1.0\n       end-if\n\n       goback.\n       end program napier-beta.\n\n      \n       identification division.\n       program-id. pi-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 3.0 to result\n       else\n           move 6.0 to result\n       end-if\n\n       goback.\n       end program pi-alpha.\n\n      \n       identification division.\n       program-id. pi-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       compute result = (2 * iteration - 1) ** 2\n\n       goback.\n       end program pi-beta.\n", "target": "from fractions import Fraction\nimport itertools\ntry: zip = itertools.izip\nexcept: pass\n \n\ndef CF(a, b, t):\n  terms = list(itertools.islice(zip(a, b), t))\n  z = Fraction(1,1)\n  for a, b in reversed(terms):\n    z = a + b / z\n  return z\n \n\ndef pRes(x, d):\n  q, x = divmod(x, 1)\n  res = str(q)\n  res += \".\"\n  for i in range(d):\n    x *= 10\n    q, x = divmod(x, 1)\n    res += str(q)\n  return res\n \n\ndef sqrt2_a():\n  yield 1\n  for x in itertools.repeat(2):\n    yield x\n \ndef sqrt2_b():\n  for x in itertools.repeat(1):\n    yield x\n \ncf = CF(sqrt2_a(), sqrt2_b(), 950)\nprint(pRes(cf, 200))\n\n \n \n\ndef Napier_a():\n  yield 2\n  for x in itertools.count(1):\n    yield x\n \ndef Napier_b():\n  yield 1\n  for x in itertools.count(1):\n    yield x\n \ncf = CF(Napier_a(), Napier_b(), 950)\nprint(pRes(cf, 200))\n\n \n\ndef Pi_a():\n  yield 3\n  for x in itertools.repeat(6):\n    yield x\n \ndef Pi_b():\n  for x in itertools.count(1,2):\n    yield x*x\n \ncf = CF(Pi_a(), Pi_b(), 950)\nprint(pRes(cf, 10))\n\n"}
{"id": 36644, "name": "Quine", "source": "Translate COBOL to C#: linkage section. 78 c value \"display 'linkage section. 78 c value ' x'22' c x'222e20' c.\". display 'linkage section. 78 c value ' x'22' c x'222e20' c.\n", "target": "class Program { static void Main() { var s = \"class Program {{ static void Main() {{ var s = {0}{1}{0}; System.Console.WriteLine(s, (char)34, s); }} }}\"; System.Console.WriteLine(s, (char)34, s); } }\n"}
{"id": 36645, "name": "Quine", "source": "Translate COBOL to C#: linkage section. 78 c value \"display 'linkage section. 78 c value ' x'22' c x'222e20' c.\". display 'linkage section. 78 c value ' x'22' c x'222e20' c.\n", "target": "class Program { static void Main() { var s = \"class Program {{ static void Main() {{ var s = {0}{1}{0}; System.Console.WriteLine(s, (char)34, s); }} }}\"; System.Console.WriteLine(s, (char)34, s); } }\n"}
{"id": 36648, "name": "Quine", "source": "Translate COBOL to Java: linkage section. 78 c value \"display 'linkage section. 78 c value ' x'22' c x'222e20' c.\". display 'linkage section. 78 c value ' x'22' c x'222e20' c.\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        console.print($./test.x);\n        }\n    }\n"}
{"id": 36649, "name": "Quine", "source": "Translate COBOL to Java: linkage section. 78 c value \"display 'linkage section. 78 c value ' x'22' c x'222e20' c.\". display 'linkage section. 78 c value ' x'22' c x'222e20' c.\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        console.print($./test.x);\n        }\n    }\n"}
{"id": 36650, "name": "Quine", "source": "Translate COBOL to Python: linkage section. 78 c value \"display 'linkage section. 78 c value ' x'22' c x'222e20' c.\". display 'linkage section. 78 c value ' x'22' c x'222e20' c.\n", "target": "w = \"print('w = ' + chr(34) + w + chr(34) + chr(10) + w)\"\nprint('w = ' + chr(34) + w + chr(34) + chr(10) + w)\n"}
{"id": 36651, "name": "Quine", "source": "Translate COBOL to Python: linkage section. 78 c value \"display 'linkage section. 78 c value ' x'22' c x'222e20' c.\". display 'linkage section. 78 c value ' x'22' c x'222e20' c.\n", "target": "w = \"print('w = ' + chr(34) + w + chr(34) + chr(10) + w)\"\nprint('w = ' + chr(34) + w + chr(34) + chr(10) + w)\n"}
{"id": 37310, "name": "Sequence of non-squares", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. NONSQR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 NEWTON.\n          03 SQR-INP           PIC 9(7)V9(5).\n          03 SQUARE-ROOT       PIC 9(7)V9(5).\n          03 FILLER            REDEFINES SQUARE-ROOT.\n             05 FILLER         PIC 9(7).\n             05 FILLER         PIC 9(5).\n                88 SQUARE      VALUE ZERO.\n          03 SQR-TEMP          PIC 9(7)V9(5).\n       01 SEQUENCE-VARS.\n          03 N                 PIC 9(7).\n          03 SEQ               PIC 9(7).\n       01 SMALL-FMT.\n          03 N-O               PIC Z9.\n          03 FILLER            PIC XX VALUE \": \".  \n          03 SEQ-O             PIC Z9.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           DISPLAY \"Sequence of non-squares from 1 to 22:\"\n           PERFORM SMALL-NUMS VARYING N FROM 1 BY 1\n               UNTIL N IS GREATER THAN 22.\n           \n           DISPLAY SPACES.\n           DISPLAY \"Checking items up to 1 million...\"\n           PERFORM CHECK-NONSQUARE VARYING N FROM 1 BY 1\n               UNTIL SQUARE OR N IS GREATER THAN 1000000.\n           \n           IF SQUARE, DISPLAY \"Square found at N = \" N,\n           ELSE, DISPLAY \"No squares found up to 1 million.\".\n           STOP RUN.\n           \n       SMALL-NUMS.\n           PERFORM NONSQUARE.\n           MOVE N TO N-O.\n           MOVE SEQ TO SEQ-O.\n           DISPLAY SMALL-FMT.\n           \n       CHECK-NONSQUARE.\n           PERFORM NONSQUARE.\n           MOVE SEQ TO SQR-INP.\n           PERFORM SQRT.\n       \n       NONSQUARE.\n           MOVE N TO SQR-INP.\n           PERFORM SQRT.\n           ADD 0.5, SQUARE-ROOT GIVING SEQ.\n           ADD N TO SEQ.\n       \n       SQRT.\n           MOVE SQR-INP TO SQUARE-ROOT.\n           COMPUTE SQR-TEMP = \n               (SQUARE-ROOT + SQR-INP / SQUARE-ROOT) / 2.\n           PERFORM SQRT-LOOP UNTIL SQUARE-ROOT IS EQUAL TO SQR-TEMP.\n       SQRT-LOOP.\n           MOVE SQR-TEMP TO SQUARE-ROOT.\n           COMPUTE SQR-TEMP = \n               (SQUARE-ROOT + SQR-INP / SQUARE-ROOT) / 2.\n", "target": "using System;\nusing System.Diagnostics;\n\nnamespace sons\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 1; i < 23; i++)            \n                Console.WriteLine(nonsqr(i));            \n\n            for (int i = 1; i < 1000000; i++)\n            {\n                double j = Math.Sqrt(nonsqr(i));\n                Debug.Assert(j != Math.Floor(j),\"Square\");\n            }            \n        }\n\n        static int nonsqr(int i)\n        {\n            return (int)(i + Math.Floor(0.5 + Math.Sqrt(i)));\n        }\n    }\n}\n"}
{"id": 37312, "name": "Sequence of non-squares", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. NONSQR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 NEWTON.\n          03 SQR-INP           PIC 9(7)V9(5).\n          03 SQUARE-ROOT       PIC 9(7)V9(5).\n          03 FILLER            REDEFINES SQUARE-ROOT.\n             05 FILLER         PIC 9(7).\n             05 FILLER         PIC 9(5).\n                88 SQUARE      VALUE ZERO.\n          03 SQR-TEMP          PIC 9(7)V9(5).\n       01 SEQUENCE-VARS.\n          03 N                 PIC 9(7).\n          03 SEQ               PIC 9(7).\n       01 SMALL-FMT.\n          03 N-O               PIC Z9.\n          03 FILLER            PIC XX VALUE \": \".  \n          03 SEQ-O             PIC Z9.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           DISPLAY \"Sequence of non-squares from 1 to 22:\"\n           PERFORM SMALL-NUMS VARYING N FROM 1 BY 1\n               UNTIL N IS GREATER THAN 22.\n           \n           DISPLAY SPACES.\n           DISPLAY \"Checking items up to 1 million...\"\n           PERFORM CHECK-NONSQUARE VARYING N FROM 1 BY 1\n               UNTIL SQUARE OR N IS GREATER THAN 1000000.\n           \n           IF SQUARE, DISPLAY \"Square found at N = \" N,\n           ELSE, DISPLAY \"No squares found up to 1 million.\".\n           STOP RUN.\n           \n       SMALL-NUMS.\n           PERFORM NONSQUARE.\n           MOVE N TO N-O.\n           MOVE SEQ TO SEQ-O.\n           DISPLAY SMALL-FMT.\n           \n       CHECK-NONSQUARE.\n           PERFORM NONSQUARE.\n           MOVE SEQ TO SQR-INP.\n           PERFORM SQRT.\n       \n       NONSQUARE.\n           MOVE N TO SQR-INP.\n           PERFORM SQRT.\n           ADD 0.5, SQUARE-ROOT GIVING SEQ.\n           ADD N TO SEQ.\n       \n       SQRT.\n           MOVE SQR-INP TO SQUARE-ROOT.\n           COMPUTE SQR-TEMP = \n               (SQUARE-ROOT + SQR-INP / SQUARE-ROOT) / 2.\n           PERFORM SQRT-LOOP UNTIL SQUARE-ROOT IS EQUAL TO SQR-TEMP.\n       SQRT-LOOP.\n           MOVE SQR-TEMP TO SQUARE-ROOT.\n           COMPUTE SQR-TEMP = \n               (SQUARE-ROOT + SQR-INP / SQUARE-ROOT) / 2.\n", "target": "public class SeqNonSquares {\n    public static int nonsqr(int n) {\n        return n + (int)Math.round(Math.sqrt(n));\n    }\n    \n    public static void main(String[] args) {\n        \n        for (int i = 1; i < 23; i++)\n            System.out.print(nonsqr(i) + \" \");\n        System.out.println();\n        \n        \n        for (int i = 1; i < 1000000; i++) {\n            double j = Math.sqrt(nonsqr(i));\n            assert j != Math.floor(j);\n        }\n    }\n}\n"}
{"id": 37313, "name": "Sequence of non-squares", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. NONSQR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 NEWTON.\n          03 SQR-INP           PIC 9(7)V9(5).\n          03 SQUARE-ROOT       PIC 9(7)V9(5).\n          03 FILLER            REDEFINES SQUARE-ROOT.\n             05 FILLER         PIC 9(7).\n             05 FILLER         PIC 9(5).\n                88 SQUARE      VALUE ZERO.\n          03 SQR-TEMP          PIC 9(7)V9(5).\n       01 SEQUENCE-VARS.\n          03 N                 PIC 9(7).\n          03 SEQ               PIC 9(7).\n       01 SMALL-FMT.\n          03 N-O               PIC Z9.\n          03 FILLER            PIC XX VALUE \": \".  \n          03 SEQ-O             PIC Z9.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           DISPLAY \"Sequence of non-squares from 1 to 22:\"\n           PERFORM SMALL-NUMS VARYING N FROM 1 BY 1\n               UNTIL N IS GREATER THAN 22.\n           \n           DISPLAY SPACES.\n           DISPLAY \"Checking items up to 1 million...\"\n           PERFORM CHECK-NONSQUARE VARYING N FROM 1 BY 1\n               UNTIL SQUARE OR N IS GREATER THAN 1000000.\n           \n           IF SQUARE, DISPLAY \"Square found at N = \" N,\n           ELSE, DISPLAY \"No squares found up to 1 million.\".\n           STOP RUN.\n           \n       SMALL-NUMS.\n           PERFORM NONSQUARE.\n           MOVE N TO N-O.\n           MOVE SEQ TO SEQ-O.\n           DISPLAY SMALL-FMT.\n           \n       CHECK-NONSQUARE.\n           PERFORM NONSQUARE.\n           MOVE SEQ TO SQR-INP.\n           PERFORM SQRT.\n       \n       NONSQUARE.\n           MOVE N TO SQR-INP.\n           PERFORM SQRT.\n           ADD 0.5, SQUARE-ROOT GIVING SEQ.\n           ADD N TO SEQ.\n       \n       SQRT.\n           MOVE SQR-INP TO SQUARE-ROOT.\n           COMPUTE SQR-TEMP = \n               (SQUARE-ROOT + SQR-INP / SQUARE-ROOT) / 2.\n           PERFORM SQRT-LOOP UNTIL SQUARE-ROOT IS EQUAL TO SQR-TEMP.\n       SQRT-LOOP.\n           MOVE SQR-TEMP TO SQUARE-ROOT.\n           COMPUTE SQR-TEMP = \n               (SQUARE-ROOT + SQR-INP / SQUARE-ROOT) / 2.\n", "target": ">>> from math import floor, sqrt\n>>> def non_square(n):\n        return n + floor(1/2 + sqrt(n))\n\n>>> \n>>> print(*map(non_square, range(1, 23)))\n2 3 5 6 7 8 10 11 12 13 14 15 17 18 19 20 21 22 23 24 26 27\n\n>>> \n>>> def is_square(n):\n        return sqrt(n).is_integer()\n\n>>> non_squares = map(non_square, range(1, 10 ** 6))\n>>> next(filter(is_square, non_squares))\nStopIteration                             Traceback (most recent call last)\n<ipython-input-45-f32645fc1c0a> in <module>()\n      1 non_squares = map(non_square, range(1, 10 ** 6))\n----> 2 next(filter(is_square, non_squares))\n\nStopIteration:\n"}
{"id": 38069, "name": "Character codes", "source": "Translate COBOL to C#:        identification division.\n       program-id. character-codes.\n       remarks. COBOL is an ordinal language, first is 1.\n       remarks. 42nd ASCII code is \")\" not, \"*\".\n       procedure division.\n       display function char(42)\n       display function ord('*')\n       goback.\n       end program character-codes.\n", "target": "using System;\n\nnamespace RosettaCode.CharacterCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine((int) 'a');   \n            Console.WriteLine((char) 97);   \n        }\n    }\n}\n"}
{"id": 38071, "name": "Character codes", "source": "Translate COBOL to Java:        identification division.\n       program-id. character-codes.\n       remarks. COBOL is an ordinal language, first is 1.\n       remarks. 42nd ASCII code is \")\" not, \"*\".\n       procedure division.\n       display function char(42)\n       display function ord('*')\n       goback.\n       end program character-codes.\n", "target": "module CharacterCodes\n    {\n    @Inject Console console;\n    void run()\n        {\n        for (Char char : ['\\0', '\\d', 'A', '$', '\u00a2', '~', '\u02dc'])\n            {\n            \n            UInt32 codepoint = char.codepoint;\n\n            \n            Char fromCodePoint = codepoint.toChar();   \n\n            console.print($|Character {char.quoted()}:\\\n                           | Unicode codepoint={char.codepoint},\\\n                           | ASCII={char.ascii},\\\n                           | UTF8 bytes={char.utf8()},\\\n                           | char from codepoint={fromCodePoint.quoted()}\n                         );\n            }\n        }\n    }\n"}
{"id": 38072, "name": "Character codes", "source": "Translate COBOL to Python:        identification division.\n       program-id. character-codes.\n       remarks. COBOL is an ordinal language, first is 1.\n       remarks. 42nd ASCII code is \")\" not, \"*\".\n       procedure division.\n       display function char(42)\n       display function ord('*')\n       goback.\n       end program character-codes.\n", "target": "print ord('a') \nprint chr(97)  \n"}
{"id": 38892, "name": "Generic swap", "source": "Translate COBOL to C#:        PROGRAM-ID. SWAP-DEMO.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   A simple program to demonstrate the SWAP subprogram.\n      **     \n      ************************************************************\n       \n       DATA DIVISION.\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Val1                 PIC X(72).\n       01  Val2                 PIC X(72).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n\n          DISPLAY 'Enter a Value: ' WITH NO ADVANCING.\n          ACCEPT Val1.\n          DISPLAY 'Enter another Value: ' WITH NO ADVANCING.\n          ACCEPT Val2.\n          DISPLAY ' ' .\n          DISPLAY 'First value: ' FUNCTION TRIM(Val1) .\n          DISPLAY 'Second value: ' FUNCTION TRIM(Val2) .\n\n           CALL \"SWAP\" USING BY REFERENCE Val1,  BY REFERENCE Val2.\n\n          DISPLAY ' '.\n          DISPLAY 'After SWAP '.\n          DISPLAY ' '.\n          DISPLAY 'First value: ' FUNCTION TRIM(Val1).\n          DISPLAY 'Second value: ' FUNCTION TRIM(Val2).\n\n           STOP RUN.\n       \n       END PROGRAM SWAP-DEMO.\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. SWAP.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   SWAP any Alphanumeric value.  Only limit is 72\n      **     character size.  But that can be adjusted for\n      **     whatever use one needs.\n      ************************************************************\n\n       DATA DIVISION.\n\n       WORKING-STORAGE SECTION.\n\n       01  TEMP                  PIC X(72).\n\n       LINKAGE SECTION.\n\n       01  Field1                PIC X(72).\n       01  Field2                PIC X(72).\n\n       PROCEDURE DIVISION \n               USING BY REFERENCE Field1, BY REFERENCE Field2.\n\n       MOVE Field1 to TEMP.\n       MOVE Field2 to Field1.\n       MOVE TEMP to Field2.\n\n       GOBACK.\n\n       END PROGRAM SWAP.\n", "target": "static void Swap<T>(ref T a, ref T b)\n{\n    T temp = a;\n    a = b;\n    b = temp;\n}\n"}
{"id": 38894, "name": "Generic swap", "source": "Translate COBOL to Java:        PROGRAM-ID. SWAP-DEMO.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   A simple program to demonstrate the SWAP subprogram.\n      **     \n      ************************************************************\n       \n       DATA DIVISION.\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Val1                 PIC X(72).\n       01  Val2                 PIC X(72).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n\n          DISPLAY 'Enter a Value: ' WITH NO ADVANCING.\n          ACCEPT Val1.\n          DISPLAY 'Enter another Value: ' WITH NO ADVANCING.\n          ACCEPT Val2.\n          DISPLAY ' ' .\n          DISPLAY 'First value: ' FUNCTION TRIM(Val1) .\n          DISPLAY 'Second value: ' FUNCTION TRIM(Val2) .\n\n           CALL \"SWAP\" USING BY REFERENCE Val1,  BY REFERENCE Val2.\n\n          DISPLAY ' '.\n          DISPLAY 'After SWAP '.\n          DISPLAY ' '.\n          DISPLAY 'First value: ' FUNCTION TRIM(Val1).\n          DISPLAY 'Second value: ' FUNCTION TRIM(Val2).\n\n           STOP RUN.\n       \n       END PROGRAM SWAP-DEMO.\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. SWAP.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   SWAP any Alphanumeric value.  Only limit is 72\n      **     character size.  But that can be adjusted for\n      **     whatever use one needs.\n      ************************************************************\n\n       DATA DIVISION.\n\n       WORKING-STORAGE SECTION.\n\n       01  TEMP                  PIC X(72).\n\n       LINKAGE SECTION.\n\n       01  Field1                PIC X(72).\n       01  Field2                PIC X(72).\n\n       PROCEDURE DIVISION \n               USING BY REFERENCE Field1, BY REFERENCE Field2.\n\n       MOVE Field1 to TEMP.\n       MOVE Field2 to Field1.\n       MOVE TEMP to Field2.\n\n       GOBACK.\n\n       END PROGRAM SWAP.\n", "target": "class Pair<T> {\n    T first;\n    T second;\n}\npublic static <T> void swap(Pair<T> p) {\n   T temp = p.first;\n   p.first = p.second;\n   p.second = temp;\n}\n"}
{"id": 38895, "name": "Generic swap", "source": "Translate COBOL to Python:        PROGRAM-ID. SWAP-DEMO.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   A simple program to demonstrate the SWAP subprogram.\n      **     \n      ************************************************************\n       \n       DATA DIVISION.\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Val1                 PIC X(72).\n       01  Val2                 PIC X(72).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n\n          DISPLAY 'Enter a Value: ' WITH NO ADVANCING.\n          ACCEPT Val1.\n          DISPLAY 'Enter another Value: ' WITH NO ADVANCING.\n          ACCEPT Val2.\n          DISPLAY ' ' .\n          DISPLAY 'First value: ' FUNCTION TRIM(Val1) .\n          DISPLAY 'Second value: ' FUNCTION TRIM(Val2) .\n\n           CALL \"SWAP\" USING BY REFERENCE Val1,  BY REFERENCE Val2.\n\n          DISPLAY ' '.\n          DISPLAY 'After SWAP '.\n          DISPLAY ' '.\n          DISPLAY 'First value: ' FUNCTION TRIM(Val1).\n          DISPLAY 'Second value: ' FUNCTION TRIM(Val2).\n\n           STOP RUN.\n       \n       END PROGRAM SWAP-DEMO.\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. SWAP.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   SWAP any Alphanumeric value.  Only limit is 72\n      **     character size.  But that can be adjusted for\n      **     whatever use one needs.\n      ************************************************************\n\n       DATA DIVISION.\n\n       WORKING-STORAGE SECTION.\n\n       01  TEMP                  PIC X(72).\n\n       LINKAGE SECTION.\n\n       01  Field1                PIC X(72).\n       01  Field2                PIC X(72).\n\n       PROCEDURE DIVISION \n               USING BY REFERENCE Field1, BY REFERENCE Field2.\n\n       MOVE Field1 to TEMP.\n       MOVE Field2 to Field1.\n       MOVE TEMP to Field2.\n\n       GOBACK.\n\n       END PROGRAM SWAP.\n", "target": "a, b = b, a\n"}
{"id": 39615, "name": "String append", "source": "Translate COBOL to C#:       identification division.                                         \n       program-id. string-append.                                       \n\n       data division.\n       working-storage section.\n       01 some-string.\n          05 elements pic x occurs 0 to 80 times depending on limiter.\n       01 limiter     usage index value 7.\n       01 current     usage index.\n\n       procedure division.\n       append-main.\n\n       move \"Hello, \" to some-string\n\n      \n       set current to length of some-string\n       set limiter up by 5\n       move \"world\" to some-string(current + 1:)\n       display some-string\n\n       goback.\n       end program string-append.\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        string x = \"foo\";\n        x += \"bar\";\n        System.Console.WriteLine(x);\n    }\n}\n"}
{"id": 39617, "name": "String append", "source": "Translate COBOL to Java:       identification division.                                         \n       program-id. string-append.                                       \n\n       data division.\n       working-storage section.\n       01 some-string.\n          05 elements pic x occurs 0 to 80 times depending on limiter.\n       01 limiter     usage index value 7.\n       01 current     usage index.\n\n       procedure division.\n       append-main.\n\n       move \"Hello, \" to some-string\n\n      \n       set current to length of some-string\n       set limiter up by 5\n       move \"world\" to some-string(current + 1:)\n       display some-string\n\n       goback.\n       end program string-append.\n", "target": "String sa = \"Hello\";\nsa += \", World!\";\nSystem.out.println(sa);\n\nStringBuilder ba = new StringBuilder();\nba.append(\"Hello\");\nba.append(\", World!\");\nSystem.out.println(ba.toString());\n"}
{"id": 39618, "name": "String append", "source": "Translate COBOL to Python:       identification division.                                         \n       program-id. string-append.                                       \n\n       data division.\n       working-storage section.\n       01 some-string.\n          05 elements pic x occurs 0 to 80 times depending on limiter.\n       01 limiter     usage index value 7.\n       01 current     usage index.\n\n       procedure division.\n       append-main.\n\n       move \"Hello, \" to some-string\n\n      \n       set current to length of some-string\n       set limiter up by 5\n       move \"world\" to some-string(current + 1:)\n       display some-string\n\n       goback.\n       end program string-append.\n", "target": "\n\n\nstr = \"12345678\";\nstr += \"9!\";\nprint(str)\n"}
{"id": 39847, "name": "Count in octal", "source": "Translate COBOL to C#:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. count-in-octal.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION dec-to-oct\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  i                                   PIC 9(18).\n\nPROCEDURE DIVISION.\n    PERFORM VARYING i FROM 1 BY 1 UNTIL i = 0\n        DISPLAY FUNCTION dec-to-oct(i)\n    END-PERFORM\n    .\nEND PROGRAM count-in-octal.\n\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. dec-to-oct.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  rem                                 PIC 9.\n\n01  dec                                 PIC 9(18).\n\nLINKAGE SECTION.\n01  dec-arg                             PIC 9(18).\n\n01  oct                                 PIC 9(18).\n\nPROCEDURE DIVISION USING dec-arg RETURNING oct.\n    MOVE dec-arg TO dec \n    PERFORM WITH TEST AFTER UNTIL dec = 0\n        MOVE FUNCTION REM(dec, 8) TO rem\n        STRING rem, oct DELIMITED BY SPACES INTO oct\n        DIVIDE 8 INTO dec\n    END-PERFORM\n    .\nEND FUNCTION dec-to-oct.\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        var number = 0;\n        do\n        {\n            Console.WriteLine(Convert.ToString(number, 8));\n        } while (++number > 0);\n    }\n}\n"}
{"id": 39849, "name": "Count in octal", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. count-in-octal.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION dec-to-oct\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  i                                   PIC 9(18).\n\nPROCEDURE DIVISION.\n    PERFORM VARYING i FROM 1 BY 1 UNTIL i = 0\n        DISPLAY FUNCTION dec-to-oct(i)\n    END-PERFORM\n    .\nEND PROGRAM count-in-octal.\n\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. dec-to-oct.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  rem                                 PIC 9.\n\n01  dec                                 PIC 9(18).\n\nLINKAGE SECTION.\n01  dec-arg                             PIC 9(18).\n\n01  oct                                 PIC 9(18).\n\nPROCEDURE DIVISION USING dec-arg RETURNING oct.\n    MOVE dec-arg TO dec \n    PERFORM WITH TEST AFTER UNTIL dec = 0\n        MOVE FUNCTION REM(dec, 8) TO rem\n        STRING rem, oct DELIMITED BY SPACES INTO oct\n        DIVIDE 8 INTO dec\n    END-PERFORM\n    .\nEND FUNCTION dec-to-oct.\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(int i = 0;i >= 0;i++){\n            System.out.println(Integer.toOctalString(i)); \n        }\n    }\n}\n"}
{"id": 39850, "name": "Count in octal", "source": "Translate COBOL to Python:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. count-in-octal.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION dec-to-oct\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  i                                   PIC 9(18).\n\nPROCEDURE DIVISION.\n    PERFORM VARYING i FROM 1 BY 1 UNTIL i = 0\n        DISPLAY FUNCTION dec-to-oct(i)\n    END-PERFORM\n    .\nEND PROGRAM count-in-octal.\n\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. dec-to-oct.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  rem                                 PIC 9.\n\n01  dec                                 PIC 9(18).\n\nLINKAGE SECTION.\n01  dec-arg                             PIC 9(18).\n\n01  oct                                 PIC 9(18).\n\nPROCEDURE DIVISION USING dec-arg RETURNING oct.\n    MOVE dec-arg TO dec \n    PERFORM WITH TEST AFTER UNTIL dec = 0\n        MOVE FUNCTION REM(dec, 8) TO rem\n        STRING rem, oct DELIMITED BY SPACES INTO oct\n        DIVIDE 8 INTO dec\n    END-PERFORM\n    .\nEND FUNCTION dec-to-oct.\n", "target": "import sys\nfor n in xrange(sys.maxint):\n    print oct(n)\n"}
{"id": 40118, "name": "Delete a file", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Delete-Files.\n\n       PROCEDURE DIVISION.\n           CALL \"CBL_DELETE_FILE\" USING \"input.txt\"\n           CALL \"CBL_DELETE_DIR\"  USING \"docs\"\n           CALL \"CBL_DELETE_FILE\" USING \"/input.txt\"\n           CALL \"CBL_DELETE_DIR\"  USING \"/docs\"\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.IO;\n\nnamespace DeleteFile {\n  class Program {\n    static void Main() {\n      File.Delete(\"input.txt\");\n      Directory.Delete(\"docs\");\n      File.Delete(\"/input.txt\");\n      Directory.Delete(\"/docs\");\n    }\n  }\n}\n"}
{"id": 40120, "name": "Delete a file", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Delete-Files.\n\n       PROCEDURE DIVISION.\n           CALL \"CBL_DELETE_FILE\" USING \"input.txt\"\n           CALL \"CBL_DELETE_DIR\"  USING \"docs\"\n           CALL \"CBL_DELETE_FILE\" USING \"/input.txt\"\n           CALL \"CBL_DELETE_DIR\"  USING \"/docs\"\n\n           GOBACK\n           .\n", "target": "import java.io.File;\n\npublic class FileDeleteTest {\n    public static boolean deleteFile(String filename) {\n        boolean exists = new File(filename).delete();\n        return exists;\n    }\n    \n    public static void test(String type, String filename) {\n        System.out.println(\"The following \" + type + \" called \" + filename + \n            (deleteFile(filename) ? \" was deleted.\" : \" could not be deleted.\")\n        );\n    }\n\n    public static void main(String args[]) {\n        test(\"file\", \"input.txt\");\n        test(\"file\", File.seperator + \"input.txt\");\n        test(\"directory\", \"docs\");\n        test(\"directory\", File.seperator + \"docs\" + File.seperator);\n    }\n}\n"}
{"id": 40121, "name": "Delete a file", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Delete-Files.\n\n       PROCEDURE DIVISION.\n           CALL \"CBL_DELETE_FILE\" USING \"input.txt\"\n           CALL \"CBL_DELETE_DIR\"  USING \"docs\"\n           CALL \"CBL_DELETE_FILE\" USING \"/input.txt\"\n           CALL \"CBL_DELETE_DIR\"  USING \"/docs\"\n\n           GOBACK\n           .\n", "target": "import os\n\nos.remove(\"output.txt\")\nos.rmdir(\"docs\")\n\nos.remove(\"/output.txt\")\nos.rmdir(\"/docs\")\n"}
{"id": 40401, "name": "Sum of a series", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. sum-of-series.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  N                       VALUE 1000.\n\n       01  series-term             USAGE FLOAT-LONG.\n       01  i                       PIC 9(4).\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL N < i\n               COMPUTE series-term = series-term + (1 / i ** 2)\n           END-PERFORM\n\n           DISPLAY series-term\n\n           GOBACK\n           .\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        \n\n        List<double> myList = new List<double>();\n        for (double i = 1; i < 1001; i++)\n        {\n            myList.Add(i);\n        }\n        \n\n        var sum = myList.Sum(x => 1/(x*x));\n\n        Console.WriteLine(sum);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 40403, "name": "Sum of a series", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. sum-of-series.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  N                       VALUE 1000.\n\n       01  series-term             USAGE FLOAT-LONG.\n       01  i                       PIC 9(4).\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL N < i\n               COMPUTE series-term = series-term + (1 / i ** 2)\n           END-PERFORM\n\n           DISPLAY series-term\n\n           GOBACK\n           .\n", "target": "public class Sum{\n    public static double f(double x){\n       return 1/(x*x);\n    }\n \n    public static void main(String[] args){\n       double start = 1;\n       double end = 1000;\n       double sum = 0;\n \n       for(double x = start;x <= end;x++) sum += f(x);\n \n       System.out.println(\"Sum of f(x) from \" + start + \" to \" + end +\" is \" + sum);\n    }\n}\n"}
{"id": 40404, "name": "Sum of a series", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. sum-of-series.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  N                       VALUE 1000.\n\n       01  series-term             USAGE FLOAT-LONG.\n       01  i                       PIC 9(4).\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL N < i\n               COMPUTE series-term = series-term + (1 / i ** 2)\n           END-PERFORM\n\n           DISPLAY series-term\n\n           GOBACK\n           .\n", "target": "print ( sum(1.0 / (x * x) for x in range(1, 1001)) )\n"}
{"id": 41303, "name": "Read a file line by line", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. read-file-line-by-line.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT input-file ASSIGN TO \"input.txt\"\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS input-file-status.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  input-file.\n       01  input-record PIC X(256).\n\n       WORKING-STORAGE SECTION.\n       01  input-file-status PIC 99.\n           88  file-is-ok    VALUE 0.\n           88  end-of-file   VALUE 10.\n\n       01  line-count        PIC 9(6).\n\n       PROCEDURE DIVISION.\n           OPEN INPUT input-file\n           IF NOT file-is-ok\n               DISPLAY \"The file could not be opened.\"\n               GOBACK\n           END-IF\n\n           PERFORM VARYING line-count FROM 1 BY 1 UNTIL end-of-file\n               READ input-file\n               DISPLAY line-count \": \" FUNCTION TRIM(input-record)\n           END-PERFORM\n\n           CLOSE input-file\n\n           GOBACK\n           .\n", "target": "foreach (string readLine in File.ReadLines(\"FileName\"))\n  DoSomething(readLine);\n"}
{"id": 41305, "name": "Read a file line by line", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. read-file-line-by-line.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT input-file ASSIGN TO \"input.txt\"\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS input-file-status.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  input-file.\n       01  input-record PIC X(256).\n\n       WORKING-STORAGE SECTION.\n       01  input-file-status PIC 99.\n           88  file-is-ok    VALUE 0.\n           88  end-of-file   VALUE 10.\n\n       01  line-count        PIC 9(6).\n\n       PROCEDURE DIVISION.\n           OPEN INPUT input-file\n           IF NOT file-is-ok\n               DISPLAY \"The file could not be opened.\"\n               GOBACK\n           END-IF\n\n           PERFORM VARYING line-count FROM 1 BY 1 UNTIL end-of-file\n               READ input-file\n               DISPLAY line-count \": \" FUNCTION TRIM(input-record)\n           END-PERFORM\n\n           CLOSE input-file\n\n           GOBACK\n           .\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\n\npublic class ReadFileByLines {\n    private static void processLine(int lineNo, String line) {\n        \n    }\n\n    public static void main(String[] args) {\n        for (String filename : args) {\n            BufferedReader br = null;\n            FileReader fr = null;\n            try {\n                fr = new FileReader(filename);\n                br = new BufferedReader(fr);\n                String line;\n                int lineNo = 0;\n                while ((line = br.readLine()) != null) {\n                    processLine(++lineNo, line);\n                }\n            }\n            catch (Exception x) {\n                x.printStackTrace();\n            }\n            finally {\n                if (fr != null) {\n                    try {br.close();} catch (Exception ignoreMe) {}\n                    try {fr.close();} catch (Exception ignoreMe) {}\n                }\n            }\n        }\n    }\n}\n"}
{"id": 41306, "name": "Read a file line by line", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. read-file-line-by-line.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT input-file ASSIGN TO \"input.txt\"\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS input-file-status.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  input-file.\n       01  input-record PIC X(256).\n\n       WORKING-STORAGE SECTION.\n       01  input-file-status PIC 99.\n           88  file-is-ok    VALUE 0.\n           88  end-of-file   VALUE 10.\n\n       01  line-count        PIC 9(6).\n\n       PROCEDURE DIVISION.\n           OPEN INPUT input-file\n           IF NOT file-is-ok\n               DISPLAY \"The file could not be opened.\"\n               GOBACK\n           END-IF\n\n           PERFORM VARYING line-count FROM 1 BY 1 UNTIL end-of-file\n               READ input-file\n               DISPLAY line-count \": \" FUNCTION TRIM(input-record)\n           END-PERFORM\n\n           CLOSE input-file\n\n           GOBACK\n           .\n", "target": "for line in lines open('input.txt'):\n    print line\n"}
{"id": 41541, "name": "Write entire file", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Overwrite.\n       AUTHOR. Bill Gunshannon. \n       INSTALLATION.  Home.\n       DATE-WRITTEN.  31 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   Simple COBOL task.  Open file for output.  Write\n      **     data to file. Close file.  Done...        \n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT File-Name ASSIGN TO \"File.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  File-Name\n           DATA RECORD IS Record-Name.\n       01  Record-Name.\n           02 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 New-Val                   PIC X(80)\n              VALUE 'Hello World'.\n       \n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT File-Name.\n           WRITE Record-Name FROM New-Val.\n           CLOSE File-Name.\n           STOP RUN.\n       \n       END-PROGRAM.\n", "target": "System.IO.File.WriteAllText(\"filename.txt\", \"This file contains a string.\");\n"}
{"id": 41543, "name": "Write entire file", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Overwrite.\n       AUTHOR. Bill Gunshannon. \n       INSTALLATION.  Home.\n       DATE-WRITTEN.  31 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   Simple COBOL task.  Open file for output.  Write\n      **     data to file. Close file.  Done...        \n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT File-Name ASSIGN TO \"File.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  File-Name\n           DATA RECORD IS Record-Name.\n       01  Record-Name.\n           02 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 New-Val                   PIC X(80)\n              VALUE 'Hello World'.\n       \n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT File-Name.\n           WRITE Record-Name FROM New-Val.\n           CLOSE File-Name.\n           STOP RUN.\n       \n       END-PROGRAM.\n", "target": "import java.io.*;\n\npublic class Test {\n\n    public static void main(String[] args) throws IOException {\n        try (BufferedWriter bw = new BufferedWriter(new FileWriter(\"test.txt\"))) {\n            bw.write(\"abc\");\n        }\n    }\n}\n"}
{"id": 41544, "name": "Write entire file", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Overwrite.\n       AUTHOR. Bill Gunshannon. \n       INSTALLATION.  Home.\n       DATE-WRITTEN.  31 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   Simple COBOL task.  Open file for output.  Write\n      **     data to file. Close file.  Done...        \n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT File-Name ASSIGN TO \"File.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  File-Name\n           DATA RECORD IS Record-Name.\n       01  Record-Name.\n           02 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 New-Val                   PIC X(80)\n              VALUE 'Hello World'.\n       \n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT File-Name.\n           WRITE Record-Name FROM New-Val.\n           CLOSE File-Name.\n           STOP RUN.\n       \n       END-PROGRAM.\n", "target": "with open(filename, 'w') as f:\n    f.write(data)\n"}
{"id": 42538, "name": "Narcissistic decimal number", "source": "Translate COBOL to C#:        PROGRAM-ID. NARCISSIST-NUMS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n \n           01 num-length PIC 9(2) value 0.\n           01 in-sum PIC  9(9) value 0.\n           01 counter PIC  9(9) value 0.\n           01 current-number PIC  9(9) value 0.\n           01 narcissist PIC Z(9).\n           01 temp PIC  9(9) value 0.\n           01 modulo PIC  9(9) value 0.\n           01 answer PIC  9 .\n \n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"the first 20 narcissist numbers:\" .\n \n           MOVE 20 TO counter.\n           PERFORM UNTIL counter=0\n \n               PERFORM 000-NARCISSIST-PARA\n \n                   IF answer = 1 \n                       SUBTRACT 1 from counter\n                       GIVING counter\n                       MOVE current-number TO narcissist\n                       DISPLAY narcissist\n                   END-IF\n \n                   ADD 1 TO current-number\n \n               END-PERFORM\n \n            STOP RUN.\n \n       000-NARCISSIST-PARA.\n \n             MOVE ZERO TO in-sum.\n             MOVE current-number TO temp.\n             COMPUTE num-length =1+  FUNCTION Log10(temp)\n \n             PERFORM  UNTIL temp=0\n \n                  DIVIDE temp BY 10 GIVING temp\n                            REMAINDER  modulo\n \n                  COMPUTE modulo=modulo**num-length\n                  ADD modulo to in-sum GIVING in-sum\n \n            END-PERFORM.\n \n               IF current-number=in-sum\n                   MOVE 1 TO answer\n                   ELSE MOVE 0 TO answer\n               END-IF.\n \n       END PROGRAM NARCISSIST-NUMS.\n", "target": "using System;\n\nnamespace Narcissistic\n{\n    class Narcissistic\n    {\n        public bool isNarcissistic(int z)\n        {\n            if (z < 0) return false;\n            string n = z.ToString();\n            int t = 0, l = n.Length;\n            foreach (char c in n)\n                t += Convert.ToInt32(Math.Pow(Convert.ToDouble(c - 48), l));\n\n            return t == z;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Narcissistic n = new Narcissistic();\n            int c = 0, x = 0;\n            while (c < 25)\n            {\n                if (n.isNarcissistic(x))\n                {\n                    if (c % 5 == 0) Console.WriteLine();\n                    Console.Write(\"{0,7} \", x);\n                    c++;\n                }\n                x++;\n            }\n            Console.WriteLine(\"\\n\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 42539, "name": "Narcissistic decimal number", "source": "Translate COBOL to C#:        PROGRAM-ID. NARCISSIST-NUMS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n \n           01 num-length PIC 9(2) value 0.\n           01 in-sum PIC  9(9) value 0.\n           01 counter PIC  9(9) value 0.\n           01 current-number PIC  9(9) value 0.\n           01 narcissist PIC Z(9).\n           01 temp PIC  9(9) value 0.\n           01 modulo PIC  9(9) value 0.\n           01 answer PIC  9 .\n \n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"the first 20 narcissist numbers:\" .\n \n           MOVE 20 TO counter.\n           PERFORM UNTIL counter=0\n \n               PERFORM 000-NARCISSIST-PARA\n \n                   IF answer = 1 \n                       SUBTRACT 1 from counter\n                       GIVING counter\n                       MOVE current-number TO narcissist\n                       DISPLAY narcissist\n                   END-IF\n \n                   ADD 1 TO current-number\n \n               END-PERFORM\n \n            STOP RUN.\n \n       000-NARCISSIST-PARA.\n \n             MOVE ZERO TO in-sum.\n             MOVE current-number TO temp.\n             COMPUTE num-length =1+  FUNCTION Log10(temp)\n \n             PERFORM  UNTIL temp=0\n \n                  DIVIDE temp BY 10 GIVING temp\n                            REMAINDER  modulo\n \n                  COMPUTE modulo=modulo**num-length\n                  ADD modulo to in-sum GIVING in-sum\n \n            END-PERFORM.\n \n               IF current-number=in-sum\n                   MOVE 1 TO answer\n                   ELSE MOVE 0 TO answer\n               END-IF.\n \n       END PROGRAM NARCISSIST-NUMS.\n", "target": "using System;\n\nnamespace Narcissistic\n{\n    class Narcissistic\n    {\n        public bool isNarcissistic(int z)\n        {\n            if (z < 0) return false;\n            string n = z.ToString();\n            int t = 0, l = n.Length;\n            foreach (char c in n)\n                t += Convert.ToInt32(Math.Pow(Convert.ToDouble(c - 48), l));\n\n            return t == z;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Narcissistic n = new Narcissistic();\n            int c = 0, x = 0;\n            while (c < 25)\n            {\n                if (n.isNarcissistic(x))\n                {\n                    if (c % 5 == 0) Console.WriteLine();\n                    Console.Write(\"{0,7} \", x);\n                    c++;\n                }\n                x++;\n            }\n            Console.WriteLine(\"\\n\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 42542, "name": "Narcissistic decimal number", "source": "Translate COBOL to Java:        PROGRAM-ID. NARCISSIST-NUMS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n \n           01 num-length PIC 9(2) value 0.\n           01 in-sum PIC  9(9) value 0.\n           01 counter PIC  9(9) value 0.\n           01 current-number PIC  9(9) value 0.\n           01 narcissist PIC Z(9).\n           01 temp PIC  9(9) value 0.\n           01 modulo PIC  9(9) value 0.\n           01 answer PIC  9 .\n \n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"the first 20 narcissist numbers:\" .\n \n           MOVE 20 TO counter.\n           PERFORM UNTIL counter=0\n \n               PERFORM 000-NARCISSIST-PARA\n \n                   IF answer = 1 \n                       SUBTRACT 1 from counter\n                       GIVING counter\n                       MOVE current-number TO narcissist\n                       DISPLAY narcissist\n                   END-IF\n \n                   ADD 1 TO current-number\n \n               END-PERFORM\n \n            STOP RUN.\n \n       000-NARCISSIST-PARA.\n \n             MOVE ZERO TO in-sum.\n             MOVE current-number TO temp.\n             COMPUTE num-length =1+  FUNCTION Log10(temp)\n \n             PERFORM  UNTIL temp=0\n \n                  DIVIDE temp BY 10 GIVING temp\n                            REMAINDER  modulo\n \n                  COMPUTE modulo=modulo**num-length\n                  ADD modulo to in-sum GIVING in-sum\n \n            END-PERFORM.\n \n               IF current-number=in-sum\n                   MOVE 1 TO answer\n                   ELSE MOVE 0 TO answer\n               END-IF.\n \n       END PROGRAM NARCISSIST-NUMS.\n", "target": "public class Narc{\n\tpublic static boolean isNarc(long x){\n\t\tif(x < 0) return false;\n\t\t\n\t\tString xStr = Long.toString(x);\n\t\tint m = xStr.length();\n\t\tlong sum = 0;\n\t\t\n\t\tfor(char c : xStr.toCharArray()){\n\t\t\tsum += Math.pow(Character.digit(c, 10), m);\n\t\t}\n\t\treturn sum == x;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(long x = 0, count = 0; count < 25; x++){\n\t\t\tif(isNarc(x)){\n\t\t\t\tSystem.out.print(x + \" \");\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 42543, "name": "Narcissistic decimal number", "source": "Translate COBOL to Java:        PROGRAM-ID. NARCISSIST-NUMS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n \n           01 num-length PIC 9(2) value 0.\n           01 in-sum PIC  9(9) value 0.\n           01 counter PIC  9(9) value 0.\n           01 current-number PIC  9(9) value 0.\n           01 narcissist PIC Z(9).\n           01 temp PIC  9(9) value 0.\n           01 modulo PIC  9(9) value 0.\n           01 answer PIC  9 .\n \n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"the first 20 narcissist numbers:\" .\n \n           MOVE 20 TO counter.\n           PERFORM UNTIL counter=0\n \n               PERFORM 000-NARCISSIST-PARA\n \n                   IF answer = 1 \n                       SUBTRACT 1 from counter\n                       GIVING counter\n                       MOVE current-number TO narcissist\n                       DISPLAY narcissist\n                   END-IF\n \n                   ADD 1 TO current-number\n \n               END-PERFORM\n \n            STOP RUN.\n \n       000-NARCISSIST-PARA.\n \n             MOVE ZERO TO in-sum.\n             MOVE current-number TO temp.\n             COMPUTE num-length =1+  FUNCTION Log10(temp)\n \n             PERFORM  UNTIL temp=0\n \n                  DIVIDE temp BY 10 GIVING temp\n                            REMAINDER  modulo\n \n                  COMPUTE modulo=modulo**num-length\n                  ADD modulo to in-sum GIVING in-sum\n \n            END-PERFORM.\n \n               IF current-number=in-sum\n                   MOVE 1 TO answer\n                   ELSE MOVE 0 TO answer\n               END-IF.\n \n       END PROGRAM NARCISSIST-NUMS.\n", "target": "public class Narc{\n\tpublic static boolean isNarc(long x){\n\t\tif(x < 0) return false;\n\t\t\n\t\tString xStr = Long.toString(x);\n\t\tint m = xStr.length();\n\t\tlong sum = 0;\n\t\t\n\t\tfor(char c : xStr.toCharArray()){\n\t\t\tsum += Math.pow(Character.digit(c, 10), m);\n\t\t}\n\t\treturn sum == x;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(long x = 0, count = 0; count < 25; x++){\n\t\t\tif(isNarc(x)){\n\t\t\t\tSystem.out.print(x + \" \");\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 42544, "name": "Narcissistic decimal number", "source": "Translate COBOL to Python:        PROGRAM-ID. NARCISSIST-NUMS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n \n           01 num-length PIC 9(2) value 0.\n           01 in-sum PIC  9(9) value 0.\n           01 counter PIC  9(9) value 0.\n           01 current-number PIC  9(9) value 0.\n           01 narcissist PIC Z(9).\n           01 temp PIC  9(9) value 0.\n           01 modulo PIC  9(9) value 0.\n           01 answer PIC  9 .\n \n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"the first 20 narcissist numbers:\" .\n \n           MOVE 20 TO counter.\n           PERFORM UNTIL counter=0\n \n               PERFORM 000-NARCISSIST-PARA\n \n                   IF answer = 1 \n                       SUBTRACT 1 from counter\n                       GIVING counter\n                       MOVE current-number TO narcissist\n                       DISPLAY narcissist\n                   END-IF\n \n                   ADD 1 TO current-number\n \n               END-PERFORM\n \n            STOP RUN.\n \n       000-NARCISSIST-PARA.\n \n             MOVE ZERO TO in-sum.\n             MOVE current-number TO temp.\n             COMPUTE num-length =1+  FUNCTION Log10(temp)\n \n             PERFORM  UNTIL temp=0\n \n                  DIVIDE temp BY 10 GIVING temp\n                            REMAINDER  modulo\n \n                  COMPUTE modulo=modulo**num-length\n                  ADD modulo to in-sum GIVING in-sum\n \n            END-PERFORM.\n \n               IF current-number=in-sum\n                   MOVE 1 TO answer\n                   ELSE MOVE 0 TO answer\n               END-IF.\n \n       END PROGRAM NARCISSIST-NUMS.\n", "target": "from __future__ import print_function\nfrom itertools import count, islice\n\ndef narcissists():\n    for digits in count(0):\n        digitpowers = [i**digits for i in range(10)]\n        for n in range(int(10**(digits-1)), 10**digits):\n            div, digitpsum = n, 0\n            while div:\n                div, mod = divmod(div, 10)\n                digitpsum += digitpowers[mod]\n            if n == digitpsum:\n                yield n\n\nfor i, n in enumerate(islice(narcissists(), 25), 1):\n    print(n, end=' ')\n    if i % 5 == 0: print() \nprint()\n"}
{"id": 42545, "name": "Narcissistic decimal number", "source": "Translate COBOL to Python:        PROGRAM-ID. NARCISSIST-NUMS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n \n           01 num-length PIC 9(2) value 0.\n           01 in-sum PIC  9(9) value 0.\n           01 counter PIC  9(9) value 0.\n           01 current-number PIC  9(9) value 0.\n           01 narcissist PIC Z(9).\n           01 temp PIC  9(9) value 0.\n           01 modulo PIC  9(9) value 0.\n           01 answer PIC  9 .\n \n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"the first 20 narcissist numbers:\" .\n \n           MOVE 20 TO counter.\n           PERFORM UNTIL counter=0\n \n               PERFORM 000-NARCISSIST-PARA\n \n                   IF answer = 1 \n                       SUBTRACT 1 from counter\n                       GIVING counter\n                       MOVE current-number TO narcissist\n                       DISPLAY narcissist\n                   END-IF\n \n                   ADD 1 TO current-number\n \n               END-PERFORM\n \n            STOP RUN.\n \n       000-NARCISSIST-PARA.\n \n             MOVE ZERO TO in-sum.\n             MOVE current-number TO temp.\n             COMPUTE num-length =1+  FUNCTION Log10(temp)\n \n             PERFORM  UNTIL temp=0\n \n                  DIVIDE temp BY 10 GIVING temp\n                            REMAINDER  modulo\n \n                  COMPUTE modulo=modulo**num-length\n                  ADD modulo to in-sum GIVING in-sum\n \n            END-PERFORM.\n \n               IF current-number=in-sum\n                   MOVE 1 TO answer\n                   ELSE MOVE 0 TO answer\n               END-IF.\n \n       END PROGRAM NARCISSIST-NUMS.\n", "target": "from __future__ import print_function\nfrom itertools import count, islice\n\ndef narcissists():\n    for digits in count(0):\n        digitpowers = [i**digits for i in range(10)]\n        for n in range(int(10**(digits-1)), 10**digits):\n            div, digitpsum = n, 0\n            while div:\n                div, mod = divmod(div, 10)\n                digitpsum += digitpowers[mod]\n            if n == digitpsum:\n                yield n\n\nfor i, n in enumerate(islice(narcissists(), 25), 1):\n    print(n, end=' ')\n    if i % 5 == 0: print() \nprint()\n"}
{"id": 42822, "name": "Strip whitespace from a string_Top and tail", "source": "Translate COBOL to C#: DISPLAY \"'\" FUNCTION TRIM(str, LEADING) \"'\"\nDISPLAY \"'\" FUNCTION TRIM(str, TRAILING) \"'\"\nDISPLAY \"'\" FUNCTION TRIM(str) \"'\"\n", "target": "using System;\n\npublic class TrimExample\n{\n    public static void Main(String[] args)\n    {\n        const string toTrim = \" Trim me \";\n        Console.WriteLine(Wrap(toTrim.TrimStart()));\n        Console.WriteLine(Wrap(toTrim.TrimEnd()));\n        Console.WriteLine(Wrap(toTrim.Trim()));\n    }\n\n    private static string Wrap(string s)\n    {\n        return \"'\" + s + \"'\";\n    }\n}\n"}
{"id": 42824, "name": "Strip whitespace from a string_Top and tail", "source": "Translate COBOL to Java: DISPLAY \"'\" FUNCTION TRIM(str, LEADING) \"'\"\nDISPLAY \"'\" FUNCTION TRIM(str, TRAILING) \"'\"\nDISPLAY \"'\" FUNCTION TRIM(str) \"'\"\n", "target": "public class Trims{\n    public static String ltrim(String s) {\n        int i = 0;\n        while (i < s.length() && Character.isWhitespace(s.charAt(i))) {\n            i++;\n        }\n        return s.substring(i);\n    }\n\n    public static String rtrim(String s) {\n        int i = s.length() - 1;\n        while (i > 0 && Character.isWhitespace(s.charAt(i))) {\n            i--;\n        }\n        return s.substring(0, i + 1);\n    }\n\n    public static String trim(String s) {\n    \treturn rtrim(ltrim(s));\n    }\n\n    public static void main(String[] args) {\n        String s = \" \\t \\r \\n String with spaces \\u2009 \\t  \\r  \\n  \";\n        System.out.printf(\"[%s]\\n\", ltrim(s));\n        System.out.printf(\"[%s]\\n\", rtrim(s));\n        System.out.printf(\"[%s]\\n\", trim(s));\n    }\n}\n"}
{"id": 42825, "name": "Strip whitespace from a string_Top and tail", "source": "Translate COBOL to Python: DISPLAY \"'\" FUNCTION TRIM(str, LEADING) \"'\"\nDISPLAY \"'\" FUNCTION TRIM(str, TRAILING) \"'\"\nDISPLAY \"'\" FUNCTION TRIM(str) \"'\"\n", "target": ">>> s = ' \\t \\r \\n String with spaces  \\t  \\r  \\n  '\n>>> s\n' \\t \\r \\n String with spaces  \\t  \\r  \\n  '\n>>> s.lstrip()\n'String with spaces  \\t  \\r  \\n  '\n>>> s.rstrip()\n' \\t \\r \\n String with spaces'\n>>> s.strip()\n'String with spaces'\n>>>\n"}
{"id": 43078, "name": "Strip comments from a string", "source": "Translate COBOL to C#:        identification division.\n       program-id. StripComments.\n\n       data division.\n       working-storage section.\n       01  line-text              pic x(64).\n\n       procedure division.\n       main.\n           move \"apples, pears # and bananas\" to line-text\n           perform show-striped-text\n\n           move \"apples, pears\u00a0; and bananas\" to line-text\n           perform show-striped-text\n\n           stop run\n           .\n       show-striped-text.\n           unstring line-text delimited by \"#\" or \";\" into line-text\n           display quote, function trim(line-text), quote\n           .\n", "target": "using System.Text.RegularExpressions;\n\nstring RemoveComments(string str, string delimiter)\n        {\n            \n            \n            \n            return Regex.Replace(str, delimiter + \".+\", string.Empty).Trim();\n        }\n"}
{"id": 43080, "name": "Strip comments from a string", "source": "Translate COBOL to Java:        identification division.\n       program-id. StripComments.\n\n       data division.\n       working-storage section.\n       01  line-text              pic x(64).\n\n       procedure division.\n       main.\n           move \"apples, pears # and bananas\" to line-text\n           perform show-striped-text\n\n           move \"apples, pears\u00a0; and bananas\" to line-text\n           perform show-striped-text\n\n           stop run\n           .\n       show-striped-text.\n           unstring line-text delimited by \"#\" or \";\" into line-text\n           display quote, function trim(line-text), quote\n           .\n", "target": "import java.io.*;\n\npublic class StripLineComments{\n    public static void main( String[] args ){\n\tif( args.length < 1 ){\n\t    System.out.println(\"Usage: java StripLineComments StringToProcess\");\n\t}\n\telse{\n\t    String inputFile = args[0];\n\t    String input = \"\";\n\t    try{\n\t\tBufferedReader reader = new BufferedReader( new FileReader( inputFile ) );\n\t\tString line = \"\";\n\t\twhile((line = reader.readLine()) != null){\n\t\t    System.out.println( line.split(\"[#;]\")[0] );\n\t\t}\n\t    }\n\t    catch( Exception e ){\n\t\te.printStackTrace();\n\t    }\n\t}\n    }\n}\n"}
{"id": 43081, "name": "Strip comments from a string", "source": "Translate COBOL to Python:        identification division.\n       program-id. StripComments.\n\n       data division.\n       working-storage section.\n       01  line-text              pic x(64).\n\n       procedure division.\n       main.\n           move \"apples, pears # and bananas\" to line-text\n           perform show-striped-text\n\n           move \"apples, pears\u00a0; and bananas\" to line-text\n           perform show-striped-text\n\n           stop run\n           .\n       show-striped-text.\n           unstring line-text delimited by \"#\" or \";\" into line-text\n           display quote, function trim(line-text), quote\n           .\n", "target": "def remove_comments(line, sep):\n    for s in sep:\n        i = line.find(s)\n        if i >= 0:\n            line = line[:i]\n    return line.strip()\n\n\nprint remove_comments('apples\u00a0; pears \nprint remove_comments('apples\u00a0; pears \n"}
{"id": 43438, "name": "Function prototype", "source": "Translate COBOL to C#:        \n       PROGRAM-ID. no-args PROTOTYPE.\n       END PROGRAM no-args.\n\n       \n       \n       PROGRAM-ID. two-args PROTOTYPE.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  arg-1 PIC 9(8).\n       01  arg-2 PIC 9(8).\n       01  ret   PIC 9(8).\n       PROCEDURE DIVISION USING arg-1, arg-2 RETURNING ret.\n       END PROGRAM two-args.\n\n       \n       \n       \n       PROGRAM-ID. optional-args PROTOTYPE.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  arg-1 PIC 9(8).\n       01  arg-2 PIC 9(8).\n       PROCEDURE DIVISION USING OPTIONAL arg-1, OPTIONAL arg-2.\n       END PROGRAM optional-args.\n\n       \n\n       \n       \n       PROGRAM-ID. foreign-func PROTOTYPE.\n       OPTIONS.\n           ENTRY-CONVENTION some-langauge.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  arg PIC S9(9) USAGE COMP-5.\n       01  ret PIC S9(9) USAGE COMP-5.\n       PROCEDURE DIVISION USING arg RETURNING ret.\n       END PROGRAM foreign-func.\n", "target": "using System;\nabstract class Printer\n{\n    public abstract void Print();\n}\n\nclass PrinterImpl : Printer\n{\n    public override void Print() {\n        Console.WriteLine(\"Hello world!\");\n    }\n}\n"}
{"id": 43439, "name": "Function prototype", "source": "Translate COBOL to C#:        \n       PROGRAM-ID. no-args PROTOTYPE.\n       END PROGRAM no-args.\n\n       \n       \n       PROGRAM-ID. two-args PROTOTYPE.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  arg-1 PIC 9(8).\n       01  arg-2 PIC 9(8).\n       01  ret   PIC 9(8).\n       PROCEDURE DIVISION USING arg-1, arg-2 RETURNING ret.\n       END PROGRAM two-args.\n\n       \n       \n       \n       PROGRAM-ID. optional-args PROTOTYPE.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  arg-1 PIC 9(8).\n       01  arg-2 PIC 9(8).\n       PROCEDURE DIVISION USING OPTIONAL arg-1, OPTIONAL arg-2.\n       END PROGRAM optional-args.\n\n       \n\n       \n       \n       PROGRAM-ID. foreign-func PROTOTYPE.\n       OPTIONS.\n           ENTRY-CONVENTION some-langauge.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  arg PIC S9(9) USAGE COMP-5.\n       01  ret PIC S9(9) USAGE COMP-5.\n       PROCEDURE DIVISION USING arg RETURNING ret.\n       END PROGRAM foreign-func.\n", "target": "using System;\nabstract class Printer\n{\n    public abstract void Print();\n}\n\nclass PrinterImpl : Printer\n{\n    public override void Print() {\n        Console.WriteLine(\"Hello world!\");\n    }\n}\n"}
{"id": 43965, "name": "Determine if a string is numeric", "source": "Translate COBOL to C#:         program-id. is-numeric.\n        procedure division.\n        display function test-numval-f(\"abc\") end-display\n        display function test-numval-f(\"-123.01E+3\") end-display\n        if function test-numval-f(\"+123.123\") equal zero then\n            display \"is numeric\" end-display\n        else\n            display \"failed numval-f test\" end-display\n        end-if\n        goback.\n", "target": "public static bool IsNumeric(string s)\n{\n    double Result;\n    return double.TryParse(s, out Result);  \n}        \n\nstring value = \"123\";\nif (IsNumeric(value)) \n{\n  \n}\n"}
{"id": 43967, "name": "Determine if a string is numeric", "source": "Translate COBOL to Java:         program-id. is-numeric.\n        procedure division.\n        display function test-numval-f(\"abc\") end-display\n        display function test-numval-f(\"-123.01E+3\") end-display\n        if function test-numval-f(\"+123.123\") equal zero then\n            display \"is numeric\" end-display\n        else\n            display \"failed numval-f test\" end-display\n        end-if\n        goback.\n", "target": "public boolean isNumeric(String input) {\n  try {\n    Integer.parseInt(input);\n    return true;\n  }\n  catch (NumberFormatException e) {\n    \n    return false;\n  }\n}\n"}
{"id": 43968, "name": "Determine if a string is numeric", "source": "Translate COBOL to Python:         program-id. is-numeric.\n        procedure division.\n        display function test-numval-f(\"abc\") end-display\n        display function test-numval-f(\"-123.01E+3\") end-display\n        if function test-numval-f(\"+123.123\") equal zero then\n            display \"is numeric\" end-display\n        else\n            display \"failed numval-f test\" end-display\n        end-if\n        goback.\n", "target": "def is_numeric(s):\n    try:\n        float(s)\n        return True\n    except (ValueError, TypeError):\n        return False\n\nis_numeric('123.0')\n"}
{"id": 44218, "name": "One-dimensional cellular automata", "source": "Translate COBOL to C#:  Identification division.                                        \n Program-id. rc-1d-cell.                                         \n \n Data division.                                                  \n Working-storage section.                                        \n \n\n 01 max-gens            pic  999  value   9.                     \n 01 state-width         pic   99  value  20.                     \n 01 state-table-init    pic x(20) value \".@@@.@@.@.@.@.@..@..\".  \n 01 alive               pic    x  value \"@\".                     \n 01 dead                pic    x  value \".\".                     \n \n\n 01 state-gen           pic  999  value   0.                     \n 01 state-row.                                                  \n    05 state-row-gen   pic zz9.                                \n    05 filler          pic  xx   value \": \".                   \n    05 state-table.                                            \n        10 state-cells pic   x   occurs 20 times.              \n \n\n 01 new-state-table.                                            \n    05 new-state-cells pic   x   occurs 20 times.              \n \n\n 01 cell-index          pic   99.                               \n    88 at-beginning    value  1.                               \n    88 is-inside       values 2 thru 19.                       \n    88 at-end          value 20.                               \n \n\n 01 neighbor-count-def.                          \n   03 neighbor-count      pic   9.\n     88 is-comfy        value 1.                    \n     88 is-ripe         value 2.                    \n \n Procedure division.                                \n     Perform Init-state-table.                      \n     Perform max-gens times                         \n         perform Display-row                        \n         perform Next-state                         \n     end-perform.                                   \n     Perform Display-row.                           \n     Stop run.                                      \n \n Display-row.                                       \n     Move state-gen to state-row-gen.     \n     Display state-row.                   \n \n\n Next-state.                              \n     Add 1 to state-gen.                  \n     Move state-table to new-state-table. \n \n     Perform with test after              \n         varying cell-index from 1 by 1   \n         until at-end                     \n         perform Count-neighbors          \n         perform Die-off                             \n         perform New-births                          \n     end-perform                                     \n \n     move new-state-table to state-table.            \n \n\n Die-off.                                            \n     if state-cells(cell-index) =                    \n     alive and not is-comfy    \n         then move dead to new-state-cells(cell-index)           \n     end-if                                                      \n     .                                                           \n \n\n New-births.                                                     \n     if state-cells(cell-index) = dead and is-ripe\n         then move alive to new-state-cells(cell-index)          \n     end-if                                                      \n    .                                                           \n\n Count-neighbors.                                                \n     Move 0 to neighbor-count                        \n     if at-beginning or at-end then                              \n         add 1 to neighbor-count                      \n     else                                                        \n       if is-inside and state-cells(cell-index - 1) = alive        \n       then                                                        \n           add 1 to neighbor-count                     \n       end-if                                                      \n       if is-inside and state-cells(cell-index + 1) = alive        \n       then                                                        \n           add 1 to neighbor-count                     \n       end-if                                                       \n     end-if                                                        \n     .                                                             \n \n\n\n\n \n Init-state-table.                                                 \n     Perform with test after                    \n         varying cell-index from 1 by 1         \n         until at-end                           \n         move state-table-init(cell-index:1)    \n           to state-cells(cell-index)           \n      end-perform\n      .\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\n\t\tconst int n_iter = 10;\n\t\tstatic int[] f = { 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0 };\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfor( int i=0; i<f.Length; i++ )\n\t\t\t\tConsole.Write( f[i]==0 ? \"-\" : \"#\" );\n\t\t\tConsole.WriteLine(\"\");\t\t\t\n\t\t\t\n\t\t\tint[] g = new int[f.Length];\n\t\t\tfor( int n=n_iter; n!=0; n-- )\n\t\t\t{\n\t\t\t\tfor( int i=1; i<f.Length-1; i++ )\n\t\t\t\t{\n\t\t\t\t\tif ( (f[i-1] ^ f[i+1]) == 1 ) g[i] = f[i];\n\t\t\t\t\telse if ( f[i] == 0 && (f[i-1] & f[i+1]) == 1 ) g[i] = 1;\n\t\t\t\t\telse g[i] = 0;\n\t\t\t\t}\n\t\t\t\tg[0] = ( (f[0] & f[1]) == 1 ) ? 1 : 0;\n\t\t\t\tg[g.Length-1] = ( (f[f.Length-1] & f[f.Length-2]) == 1 ) ? 1 : 0;\n\t\t\t\t\n\t\t\t\tint[] tmp = f;\n\t\t\t\tf = g;\n\t\t\t\tg = tmp;\n\t\t\t\t\n\t\t\t\tfor( int i=0; i<f.Length; i++ )\n\t\t\t\t\tConsole.Write( f[i]==0 ? \"-\" : \"#\" );\n\t\t\t\tConsole.WriteLine(\"\");\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}\n"}
{"id": 44220, "name": "One-dimensional cellular automata", "source": "Translate COBOL to Java:  Identification division.                                        \n Program-id. rc-1d-cell.                                         \n \n Data division.                                                  \n Working-storage section.                                        \n \n\n 01 max-gens            pic  999  value   9.                     \n 01 state-width         pic   99  value  20.                     \n 01 state-table-init    pic x(20) value \".@@@.@@.@.@.@.@..@..\".  \n 01 alive               pic    x  value \"@\".                     \n 01 dead                pic    x  value \".\".                     \n \n\n 01 state-gen           pic  999  value   0.                     \n 01 state-row.                                                  \n    05 state-row-gen   pic zz9.                                \n    05 filler          pic  xx   value \": \".                   \n    05 state-table.                                            \n        10 state-cells pic   x   occurs 20 times.              \n \n\n 01 new-state-table.                                            \n    05 new-state-cells pic   x   occurs 20 times.              \n \n\n 01 cell-index          pic   99.                               \n    88 at-beginning    value  1.                               \n    88 is-inside       values 2 thru 19.                       \n    88 at-end          value 20.                               \n \n\n 01 neighbor-count-def.                          \n   03 neighbor-count      pic   9.\n     88 is-comfy        value 1.                    \n     88 is-ripe         value 2.                    \n \n Procedure division.                                \n     Perform Init-state-table.                      \n     Perform max-gens times                         \n         perform Display-row                        \n         perform Next-state                         \n     end-perform.                                   \n     Perform Display-row.                           \n     Stop run.                                      \n \n Display-row.                                       \n     Move state-gen to state-row-gen.     \n     Display state-row.                   \n \n\n Next-state.                              \n     Add 1 to state-gen.                  \n     Move state-table to new-state-table. \n \n     Perform with test after              \n         varying cell-index from 1 by 1   \n         until at-end                     \n         perform Count-neighbors          \n         perform Die-off                             \n         perform New-births                          \n     end-perform                                     \n \n     move new-state-table to state-table.            \n \n\n Die-off.                                            \n     if state-cells(cell-index) =                    \n     alive and not is-comfy    \n         then move dead to new-state-cells(cell-index)           \n     end-if                                                      \n     .                                                           \n \n\n New-births.                                                     \n     if state-cells(cell-index) = dead and is-ripe\n         then move alive to new-state-cells(cell-index)          \n     end-if                                                      \n    .                                                           \n\n Count-neighbors.                                                \n     Move 0 to neighbor-count                        \n     if at-beginning or at-end then                              \n         add 1 to neighbor-count                      \n     else                                                        \n       if is-inside and state-cells(cell-index - 1) = alive        \n       then                                                        \n           add 1 to neighbor-count                     \n       end-if                                                      \n       if is-inside and state-cells(cell-index + 1) = alive        \n       then                                                        \n           add 1 to neighbor-count                     \n       end-if                                                       \n     end-if                                                        \n     .                                                             \n \n\n\n\n \n Init-state-table.                                                 \n     Perform with test after                    \n         varying cell-index from 1 by 1         \n         until at-end                           \n         move state-table-init(cell-index:1)    \n           to state-cells(cell-index)           \n      end-perform\n      .\n", "target": "public class Life{\n\tpublic static void main(String[] args) throws Exception{\n\t\tString start= \"_###_##_#_#_#_#__#__\";\n\t\tint numGens = 10;\n\t\tfor(int i= 0; i < numGens; i++){\n\t\t\tSystem.out.println(\"Generation \" + i + \": \" + start);\n\t\t\tstart= life(start);\n\t\t}\n\t}\n\n\tpublic static String life(String lastGen){\n\t\tString newGen= \"\";\n\t\tfor(int i= 0; i < lastGen.length(); i++){\n\t\t\tint neighbors= 0;\n\t\t\tif (i == 0){\n\t\t\t\tneighbors= lastGen.charAt(1) == '#' ? 1 : 0;\n\t\t\t} else if (i == lastGen.length() - 1){\n\t\t\t\tneighbors= lastGen.charAt(i - 1) == '#' ? 1 : 0;\n\t\t\t} else{\n\t\t\t\tneighbors= getNeighbors(lastGen.substring(i - 1, i + 2));\n\t\t\t}\n\n\t\t\tif (neighbors == 0){\n\t\t\t\tnewGen+= \"_\";\n\t\t\t}\n\t\t\tif (neighbors == 1){\n\t\t\t\tnewGen+= lastGen.charAt(i);\n\t\t\t}\n\t\t\tif (neighbors == 2){\n\t\t\t\tnewGen+= lastGen.charAt(i) == '#' ? \"_\" : \"#\";\n\t\t\t}\n\t\t}\n\t\treturn newGen;\n\t}\n\n\tpublic static int getNeighbors(String group){\n\t\tint ans= 0;\n\t\tif (group.charAt(0) == '#') ans++;\n\t\tif (group.charAt(2) == '#') ans++;\n\t\treturn ans;\n\t}\n}\n"}
{"id": 44221, "name": "One-dimensional cellular automata", "source": "Translate COBOL to Python:  Identification division.                                        \n Program-id. rc-1d-cell.                                         \n \n Data division.                                                  \n Working-storage section.                                        \n \n\n 01 max-gens            pic  999  value   9.                     \n 01 state-width         pic   99  value  20.                     \n 01 state-table-init    pic x(20) value \".@@@.@@.@.@.@.@..@..\".  \n 01 alive               pic    x  value \"@\".                     \n 01 dead                pic    x  value \".\".                     \n \n\n 01 state-gen           pic  999  value   0.                     \n 01 state-row.                                                  \n    05 state-row-gen   pic zz9.                                \n    05 filler          pic  xx   value \": \".                   \n    05 state-table.                                            \n        10 state-cells pic   x   occurs 20 times.              \n \n\n 01 new-state-table.                                            \n    05 new-state-cells pic   x   occurs 20 times.              \n \n\n 01 cell-index          pic   99.                               \n    88 at-beginning    value  1.                               \n    88 is-inside       values 2 thru 19.                       \n    88 at-end          value 20.                               \n \n\n 01 neighbor-count-def.                          \n   03 neighbor-count      pic   9.\n     88 is-comfy        value 1.                    \n     88 is-ripe         value 2.                    \n \n Procedure division.                                \n     Perform Init-state-table.                      \n     Perform max-gens times                         \n         perform Display-row                        \n         perform Next-state                         \n     end-perform.                                   \n     Perform Display-row.                           \n     Stop run.                                      \n \n Display-row.                                       \n     Move state-gen to state-row-gen.     \n     Display state-row.                   \n \n\n Next-state.                              \n     Add 1 to state-gen.                  \n     Move state-table to new-state-table. \n \n     Perform with test after              \n         varying cell-index from 1 by 1   \n         until at-end                     \n         perform Count-neighbors          \n         perform Die-off                             \n         perform New-births                          \n     end-perform                                     \n \n     move new-state-table to state-table.            \n \n\n Die-off.                                            \n     if state-cells(cell-index) =                    \n     alive and not is-comfy    \n         then move dead to new-state-cells(cell-index)           \n     end-if                                                      \n     .                                                           \n \n\n New-births.                                                     \n     if state-cells(cell-index) = dead and is-ripe\n         then move alive to new-state-cells(cell-index)          \n     end-if                                                      \n    .                                                           \n\n Count-neighbors.                                                \n     Move 0 to neighbor-count                        \n     if at-beginning or at-end then                              \n         add 1 to neighbor-count                      \n     else                                                        \n       if is-inside and state-cells(cell-index - 1) = alive        \n       then                                                        \n           add 1 to neighbor-count                     \n       end-if                                                      \n       if is-inside and state-cells(cell-index + 1) = alive        \n       then                                                        \n           add 1 to neighbor-count                     \n       end-if                                                       \n     end-if                                                        \n     .                                                             \n \n\n\n\n \n Init-state-table.                                                 \n     Perform with test after                    \n         varying cell-index from 1 by 1         \n         until at-end                           \n         move state-table-init(cell-index:1)    \n           to state-cells(cell-index)           \n      end-perform\n      .\n", "target": "import random\n\nprintdead, printlive = '_\nmaxgenerations = 10\ncellcount = 20\noffendvalue = '0'\n\nuniverse = ''.join(random.choice('01') for i in range(cellcount))\n\nneighbours2newstate = {\n '000': '0',\n '001': '0',\n '010': '0',\n '011': '1',\n '100': '0',\n '101': '1',\n '110': '1',\n '111': '0',\n }\n\nfor i in range(maxgenerations):\n    print \"Generation %3i:  %s\" % ( i,\n          universe.replace('0', printdead).replace('1', printlive) )\n    universe = offendvalue + universe + offendvalue\n    universe = ''.join(neighbours2newstate[universe[i:i+3]] for i in range(cellcount))\n"}
{"id": 44751, "name": "Inheritance_Multiple", "source": "Translate COBOL to C#:        CLASS-ID. Camera.\n           \n       END CLASS Camera.\n       \n       CLASS-ID. Mobile-Phone.\n           \n       END CLASS Mobile-Phone.\n       \n       CLASS-ID. Camera-Phone INHERITS Camera, Mobile-Phone.    \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Camera\n           CLASS Mobile-Phone.\n           \n           \n       END CLASS Camera-Phone.\n", "target": "interface ICamera {\n    \n}\n\nclass MobilePhone {\n    \n}\n\nclass CameraPhone: ICamera, MobilePhone {\n    \n}\n"}
{"id": 44753, "name": "Inheritance_Multiple", "source": "Translate COBOL to Java:        CLASS-ID. Camera.\n           \n       END CLASS Camera.\n       \n       CLASS-ID. Mobile-Phone.\n           \n       END CLASS Mobile-Phone.\n       \n       CLASS-ID. Camera-Phone INHERITS Camera, Mobile-Phone.    \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Camera\n           CLASS Mobile-Phone.\n           \n           \n       END CLASS Camera-Phone.\n", "target": "public interface Camera{\n   \n   \n   \n}\n"}
{"id": 44754, "name": "Inheritance_Multiple", "source": "Translate COBOL to Python:        CLASS-ID. Camera.\n           \n       END CLASS Camera.\n       \n       CLASS-ID. Mobile-Phone.\n           \n       END CLASS Mobile-Phone.\n       \n       CLASS-ID. Camera-Phone INHERITS Camera, Mobile-Phone.    \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Camera\n           CLASS Mobile-Phone.\n           \n           \n       END CLASS Camera-Phone.\n", "target": "class Camera:\n  pass \n"}
{"id": 45079, "name": "Zero to the zero power", "source": "Translate COBOL to C#: identification division.\nprogram-id. zero-power-zero-program.\ndata division.\nworking-storage section.\n77  n                         pic 9.\nprocedure division.\n    compute n = 0**0.\n    display n upon console.\n    stop run.\n", "target": "using System;\n\nnamespace ZeroToTheZeroeth\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double k = Math.Pow(0, 0);\n            Console.Write(\"0^0 is {0}\", k);           \n        }\n    }\n}\n"}
{"id": 45080, "name": "Zero to the zero power", "source": "Translate COBOL to C#: identification division.\nprogram-id. zero-power-zero-program.\ndata division.\nworking-storage section.\n77  n                         pic 9.\nprocedure division.\n    compute n = 0**0.\n    display n upon console.\n    stop run.\n", "target": "using System;\n\nnamespace ZeroToTheZeroeth\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double k = Math.Pow(0, 0);\n            Console.Write(\"0^0 is {0}\", k);           \n        }\n    }\n}\n"}
{"id": 45083, "name": "Zero to the zero power", "source": "Translate COBOL to Java: identification division.\nprogram-id. zero-power-zero-program.\ndata division.\nworking-storage section.\n77  n                         pic 9.\nprocedure division.\n    compute n = 0**0.\n    display n upon console.\n    stop run.\n", "target": "System.out.println(Math.pow(0, 0));\n"}
{"id": 45084, "name": "Zero to the zero power", "source": "Translate COBOL to Java: identification division.\nprogram-id. zero-power-zero-program.\ndata division.\nworking-storage section.\n77  n                         pic 9.\nprocedure division.\n    compute n = 0**0.\n    display n upon console.\n    stop run.\n", "target": "System.out.println(Math.pow(0, 0));\n"}
{"id": 45085, "name": "Zero to the zero power", "source": "Translate COBOL to Python: identification division.\nprogram-id. zero-power-zero-program.\ndata division.\nworking-storage section.\n77  n                         pic 9.\nprocedure division.\n    compute n = 0**0.\n    display n upon console.\n    stop run.\n", "target": "from decimal import Decimal\nfrom fractions import Fraction\nfrom itertools import product\n\nzeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]\nfor i, j in product(zeroes, repeat=2):\n    try:\n        ans = i**j\n    except:\n        ans = '<Exception raised>'\n    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')\n"}
{"id": 45086, "name": "Zero to the zero power", "source": "Translate COBOL to Python: identification division.\nprogram-id. zero-power-zero-program.\ndata division.\nworking-storage section.\n77  n                         pic 9.\nprocedure division.\n    compute n = 0**0.\n    display n upon console.\n    stop run.\n", "target": "from decimal import Decimal\nfrom fractions import Fraction\nfrom itertools import product\n\nzeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]\nfor i, j in product(zeroes, repeat=2):\n    try:\n        ans = i**j\n    except:\n        ans = '<Exception raised>'\n    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')\n"}
{"id": 45726, "name": "Multiplication tables", "source": "Translate COBOL to C#:        identification division.\n       program-id. multiplication-table.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 multiplication.\n          05 rows occurs 12 times.\n             10 colm occurs 12 times.\n                15 num    pic 999.\n       77 cand pic 99.\n       77 ier  pic 99.\n       77 ind  pic z9.\n       77 show pic zz9.\n\n       procedure division.\n       sample-main.\n       perform varying cand from 1 by 1 until cand greater than 12\n                  after ier from 1 by 1 until ier greater than 12\n           multiply cand by ier giving num(cand, ier)\n       end-perform\n\n       perform varying cand from 1 by 1 until cand greater than 12\n           move cand to ind\n           display \"x \" ind \"| \" with no advancing\n           perform varying ier from 1 by 1 until ier greater than 12\n               if ier greater than or equal to cand then\n                   move num(cand, ier) to show\n                   display show with no advancing\n                   if ier equal to 12 then\n                       display \"|\"\n                   else\n                       display space with no advancing\n                   end-if\n               else\n                   display \"    \" with no advancing\n               end-if\n           end-perform\n       end-perform\n\n       goback.\n       end program multiplication-table.\n", "target": "using System;\n\nnamespace multtbl\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Write(\" X\".PadRight(4));\n            for (int i = 1; i <= 12; i++)\n                Console.Write(i.ToString(\"####\").PadLeft(4));\n\n            Console.WriteLine();\n            Console.Write(\" ___\");\n\n            for (int i = 1; i <= 12; i++)\n                Console.Write(\" ___\");\n\n            Console.WriteLine();\n            for (int row = 1; row <= 12; row++)\n            {\n                Console.Write(row.ToString(\"###\").PadLeft(3).PadRight(4));\n                for (int col = 1; col <= 12; col++)\n                {\n                    if (row <= col)\n                        Console.Write((row * col).ToString(\"###\").PadLeft(4));\n                    else\n                        Console.Write(\"\".PadLeft(4));\n                }\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine();\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 45728, "name": "Multiplication tables", "source": "Translate COBOL to Java:        identification division.\n       program-id. multiplication-table.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 multiplication.\n          05 rows occurs 12 times.\n             10 colm occurs 12 times.\n                15 num    pic 999.\n       77 cand pic 99.\n       77 ier  pic 99.\n       77 ind  pic z9.\n       77 show pic zz9.\n\n       procedure division.\n       sample-main.\n       perform varying cand from 1 by 1 until cand greater than 12\n                  after ier from 1 by 1 until ier greater than 12\n           multiply cand by ier giving num(cand, ier)\n       end-perform\n\n       perform varying cand from 1 by 1 until cand greater than 12\n           move cand to ind\n           display \"x \" ind \"| \" with no advancing\n           perform varying ier from 1 by 1 until ier greater than 12\n               if ier greater than or equal to cand then\n                   move num(cand, ier) to show\n                   display show with no advancing\n                   if ier equal to 12 then\n                       display \"|\"\n                   else\n                       display space with no advancing\n                   end-if\n               else\n                   display \"    \" with no advancing\n               end-if\n           end-perform\n       end-perform\n\n       goback.\n       end program multiplication-table.\n", "target": "public class MultiplicationTable {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 12; i++)\n            System.out.print(\"\\t\" + i);\n        \n        System.out.println();\n        for (int i = 0; i < 100; i++)\n            System.out.print(\"-\");\n        System.out.println();\n        for (int i = 1; i <= 12; i++) {\n            System.out.print(i + \"|\");\n            for(int j = 1; j <= 12; j++) {\n                System.out.print(\"\\t\");\n                if (j >= i)\n                    System.out.print(\"\\t\" + i * j);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 45729, "name": "Multiplication tables", "source": "Translate COBOL to Python:        identification division.\n       program-id. multiplication-table.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 multiplication.\n          05 rows occurs 12 times.\n             10 colm occurs 12 times.\n                15 num    pic 999.\n       77 cand pic 99.\n       77 ier  pic 99.\n       77 ind  pic z9.\n       77 show pic zz9.\n\n       procedure division.\n       sample-main.\n       perform varying cand from 1 by 1 until cand greater than 12\n                  after ier from 1 by 1 until ier greater than 12\n           multiply cand by ier giving num(cand, ier)\n       end-perform\n\n       perform varying cand from 1 by 1 until cand greater than 12\n           move cand to ind\n           display \"x \" ind \"| \" with no advancing\n           perform varying ier from 1 by 1 until ier greater than 12\n               if ier greater than or equal to cand then\n                   move num(cand, ier) to show\n                   display show with no advancing\n                   if ier equal to 12 then\n                       display \"|\"\n                   else\n                       display space with no advancing\n                   end-if\n               else\n                   display \"    \" with no advancing\n               end-if\n           end-perform\n       end-perform\n\n       goback.\n       end program multiplication-table.\n", "target": ">>> size = 12\n>>> width = len(str(size**2))\n>>> for row in range(-1,size+1):\n\tif row==0:\n\t\tprint(\"\u2500\"*width + \"\u253c\"+\"\u2500\"*((width+1)*size-1))\n\telse:\n\t\tprint(\"\".join(\"%*s%1s\" % ((width,) + ((\"x\",\"\u2502\")      if row==-1 and col==0\n\t\t\t\t\t              else (row,\"\u2502\") if row>0   and col==0\n\t\t\t\t\t              else (col,\"\")  if row==-1\n\t\t\t\t\t              else (\"\",\"\")   if row>col\n\t\t\t\t\t              else (row*col,\"\")))\n\t\t\t       for col in range(size+1)))\n\n\t\t\n  x\u2502  1   2   3   4   5   6   7   8   9  10  11  12 \n\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  1\u2502  1   2   3   4   5   6   7   8   9  10  11  12 \n  2\u2502      4   6   8  10  12  14  16  18  20  22  24 \n  3\u2502          9  12  15  18  21  24  27  30  33  36 \n  4\u2502             16  20  24  28  32  36  40  44  48 \n  5\u2502                 25  30  35  40  45  50  55  60 \n  6\u2502                     36  42  48  54  60  66  72 \n  7\u2502                         49  56  63  70  77  84 \n  8\u2502                             64  72  80  88  96 \n  9\u2502                                 81  90  99 108 \n 10\u2502                                    100 110 120 \n 11\u2502                                        121 132 \n 12\u2502                                            144 \n>>>\n"}
{"id": 46109, "name": "Comma quibbling", "source": "Translate COBOL to C#:        >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. comma-quibbling-test.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION comma-quibbling\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\nPROCEDURE DIVISION.\n    MOVE \"ABC\" TO strs (1)\n    MOVE \"DEF\" TO strs (2)\n    MOVE \"G\" TO strs (3)\n    MOVE \"H\" TO strs (4)\n\n    PERFORM VARYING strs-len FROM 0 BY 1 UNTIL strs-len > 4\n        DISPLAY FUNCTION comma-quibbling(strs-area)\n    END-PERFORM\n    .\nEND PROGRAM comma-quibbling-test.\n\n \nIDENTIFICATION DIVISION.\nFUNCTION-ID. comma-quibbling.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  i                             PIC 9.\n\n01  num-extra-words               PIC 9.\n\nLINKAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\n01  str                           PIC X(50).\n\nPROCEDURE DIVISION USING strs-area RETURNING str.\n    EVALUATE strs-len\n        WHEN ZERO\n            MOVE \"{}\" TO str\n            GOBACK\n\n        WHEN 1\n            MOVE FUNCTION CONCATENATE(\"{\", FUNCTION TRIM(strs (1)), \"}\")\n                TO str\n            GOBACK\n    END-EVALUATE\n\n    MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (strs-len - 1)),\n        \" and \", FUNCTION TRIM(strs (strs-len)), \"}\")\n        TO str\n\n    IF strs-len > 2\n        SUBTRACT 2 FROM strs-len GIVING num-extra-words\n        PERFORM VARYING i FROM num-extra-words BY -1 UNTIL i = 0\n            MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (i)), \", \", str)\n                TO str\n        END-PERFORM\n    END-IF\n    \n    MOVE FUNCTION CONCATENATE(\"{\", str) TO str\n    .\nEND FUNCTION comma-quibbling.\n", "target": "using System;\nusing System.Linq;\n\nnamespace CommaQuibbling\n{\n    internal static class Program\n    {\n        #region Static Members\n\tprivate static string Quibble(string[] input)\n\t{\n            return\n                String.Format(\"{{{0}}}\",\n                    String.Join(\"\",\n                        input.Reverse().Zip(\n                            new [] { \"\", \" and \" }.Concat(Enumerable.Repeat(\", \", int.MaxValue)),\n                            (x, y) => x + y).Reverse()));\n\t}\n\n\n        private static void Main()\n        {\n            Console.WriteLine( Quibble( new string[] {} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\", \"G\", \"H\"} ) );\n\n            Console.WriteLine( \"< Press Any Key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 46110, "name": "Comma quibbling", "source": "Translate COBOL to C#:        >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. comma-quibbling-test.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION comma-quibbling\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\nPROCEDURE DIVISION.\n    MOVE \"ABC\" TO strs (1)\n    MOVE \"DEF\" TO strs (2)\n    MOVE \"G\" TO strs (3)\n    MOVE \"H\" TO strs (4)\n\n    PERFORM VARYING strs-len FROM 0 BY 1 UNTIL strs-len > 4\n        DISPLAY FUNCTION comma-quibbling(strs-area)\n    END-PERFORM\n    .\nEND PROGRAM comma-quibbling-test.\n\n \nIDENTIFICATION DIVISION.\nFUNCTION-ID. comma-quibbling.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  i                             PIC 9.\n\n01  num-extra-words               PIC 9.\n\nLINKAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\n01  str                           PIC X(50).\n\nPROCEDURE DIVISION USING strs-area RETURNING str.\n    EVALUATE strs-len\n        WHEN ZERO\n            MOVE \"{}\" TO str\n            GOBACK\n\n        WHEN 1\n            MOVE FUNCTION CONCATENATE(\"{\", FUNCTION TRIM(strs (1)), \"}\")\n                TO str\n            GOBACK\n    END-EVALUATE\n\n    MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (strs-len - 1)),\n        \" and \", FUNCTION TRIM(strs (strs-len)), \"}\")\n        TO str\n\n    IF strs-len > 2\n        SUBTRACT 2 FROM strs-len GIVING num-extra-words\n        PERFORM VARYING i FROM num-extra-words BY -1 UNTIL i = 0\n            MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (i)), \", \", str)\n                TO str\n        END-PERFORM\n    END-IF\n    \n    MOVE FUNCTION CONCATENATE(\"{\", str) TO str\n    .\nEND FUNCTION comma-quibbling.\n", "target": "using System;\nusing System.Linq;\n\nnamespace CommaQuibbling\n{\n    internal static class Program\n    {\n        #region Static Members\n\tprivate static string Quibble(string[] input)\n\t{\n            return\n                String.Format(\"{{{0}}}\",\n                    String.Join(\"\",\n                        input.Reverse().Zip(\n                            new [] { \"\", \" and \" }.Concat(Enumerable.Repeat(\", \", int.MaxValue)),\n                            (x, y) => x + y).Reverse()));\n\t}\n\n\n        private static void Main()\n        {\n            Console.WriteLine( Quibble( new string[] {} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\", \"G\", \"H\"} ) );\n\n            Console.WriteLine( \"< Press Any Key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 46113, "name": "Comma quibbling", "source": "Translate COBOL to Java:        >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. comma-quibbling-test.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION comma-quibbling\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\nPROCEDURE DIVISION.\n    MOVE \"ABC\" TO strs (1)\n    MOVE \"DEF\" TO strs (2)\n    MOVE \"G\" TO strs (3)\n    MOVE \"H\" TO strs (4)\n\n    PERFORM VARYING strs-len FROM 0 BY 1 UNTIL strs-len > 4\n        DISPLAY FUNCTION comma-quibbling(strs-area)\n    END-PERFORM\n    .\nEND PROGRAM comma-quibbling-test.\n\n \nIDENTIFICATION DIVISION.\nFUNCTION-ID. comma-quibbling.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  i                             PIC 9.\n\n01  num-extra-words               PIC 9.\n\nLINKAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\n01  str                           PIC X(50).\n\nPROCEDURE DIVISION USING strs-area RETURNING str.\n    EVALUATE strs-len\n        WHEN ZERO\n            MOVE \"{}\" TO str\n            GOBACK\n\n        WHEN 1\n            MOVE FUNCTION CONCATENATE(\"{\", FUNCTION TRIM(strs (1)), \"}\")\n                TO str\n            GOBACK\n    END-EVALUATE\n\n    MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (strs-len - 1)),\n        \" and \", FUNCTION TRIM(strs (strs-len)), \"}\")\n        TO str\n\n    IF strs-len > 2\n        SUBTRACT 2 FROM strs-len GIVING num-extra-words\n        PERFORM VARYING i FROM num-extra-words BY -1 UNTIL i = 0\n            MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (i)), \", \", str)\n                TO str\n        END-PERFORM\n    END-IF\n    \n    MOVE FUNCTION CONCATENATE(\"{\", str) TO str\n    .\nEND FUNCTION comma-quibbling.\n", "target": "public class Quibbler {\n\n\tpublic static String quibble(String[] words) {\n\t\tString qText = \"{\";\n\t\tfor(int wIndex = 0; wIndex < words.length; wIndex++) {\n\t\t\tqText += words[wIndex] + (wIndex == words.length-1 ? \"\" : \n\t\t\t\t\t\t  wIndex == words.length-2 ? \" and \" :\n\t\t\t\t\t\t  \", \";\n\t\t}\n\t\tqText += \"}\";\n\t\treturn qText;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(quibble(new String[]{}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\", \"H\"}));\n\t}\n}\n"}
{"id": 46114, "name": "Comma quibbling", "source": "Translate COBOL to Java:        >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. comma-quibbling-test.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION comma-quibbling\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\nPROCEDURE DIVISION.\n    MOVE \"ABC\" TO strs (1)\n    MOVE \"DEF\" TO strs (2)\n    MOVE \"G\" TO strs (3)\n    MOVE \"H\" TO strs (4)\n\n    PERFORM VARYING strs-len FROM 0 BY 1 UNTIL strs-len > 4\n        DISPLAY FUNCTION comma-quibbling(strs-area)\n    END-PERFORM\n    .\nEND PROGRAM comma-quibbling-test.\n\n \nIDENTIFICATION DIVISION.\nFUNCTION-ID. comma-quibbling.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  i                             PIC 9.\n\n01  num-extra-words               PIC 9.\n\nLINKAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\n01  str                           PIC X(50).\n\nPROCEDURE DIVISION USING strs-area RETURNING str.\n    EVALUATE strs-len\n        WHEN ZERO\n            MOVE \"{}\" TO str\n            GOBACK\n\n        WHEN 1\n            MOVE FUNCTION CONCATENATE(\"{\", FUNCTION TRIM(strs (1)), \"}\")\n                TO str\n            GOBACK\n    END-EVALUATE\n\n    MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (strs-len - 1)),\n        \" and \", FUNCTION TRIM(strs (strs-len)), \"}\")\n        TO str\n\n    IF strs-len > 2\n        SUBTRACT 2 FROM strs-len GIVING num-extra-words\n        PERFORM VARYING i FROM num-extra-words BY -1 UNTIL i = 0\n            MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (i)), \", \", str)\n                TO str\n        END-PERFORM\n    END-IF\n    \n    MOVE FUNCTION CONCATENATE(\"{\", str) TO str\n    .\nEND FUNCTION comma-quibbling.\n", "target": "public class Quibbler {\n\n\tpublic static String quibble(String[] words) {\n\t\tString qText = \"{\";\n\t\tfor(int wIndex = 0; wIndex < words.length; wIndex++) {\n\t\t\tqText += words[wIndex] + (wIndex == words.length-1 ? \"\" : \n\t\t\t\t\t\t  wIndex == words.length-2 ? \" and \" :\n\t\t\t\t\t\t  \", \";\n\t\t}\n\t\tqText += \"}\";\n\t\treturn qText;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(quibble(new String[]{}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\", \"H\"}));\n\t}\n}\n"}
{"id": 46115, "name": "Comma quibbling", "source": "Translate COBOL to Python:        >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. comma-quibbling-test.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION comma-quibbling\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\nPROCEDURE DIVISION.\n    MOVE \"ABC\" TO strs (1)\n    MOVE \"DEF\" TO strs (2)\n    MOVE \"G\" TO strs (3)\n    MOVE \"H\" TO strs (4)\n\n    PERFORM VARYING strs-len FROM 0 BY 1 UNTIL strs-len > 4\n        DISPLAY FUNCTION comma-quibbling(strs-area)\n    END-PERFORM\n    .\nEND PROGRAM comma-quibbling-test.\n\n \nIDENTIFICATION DIVISION.\nFUNCTION-ID. comma-quibbling.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  i                             PIC 9.\n\n01  num-extra-words               PIC 9.\n\nLINKAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\n01  str                           PIC X(50).\n\nPROCEDURE DIVISION USING strs-area RETURNING str.\n    EVALUATE strs-len\n        WHEN ZERO\n            MOVE \"{}\" TO str\n            GOBACK\n\n        WHEN 1\n            MOVE FUNCTION CONCATENATE(\"{\", FUNCTION TRIM(strs (1)), \"}\")\n                TO str\n            GOBACK\n    END-EVALUATE\n\n    MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (strs-len - 1)),\n        \" and \", FUNCTION TRIM(strs (strs-len)), \"}\")\n        TO str\n\n    IF strs-len > 2\n        SUBTRACT 2 FROM strs-len GIVING num-extra-words\n        PERFORM VARYING i FROM num-extra-words BY -1 UNTIL i = 0\n            MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (i)), \", \", str)\n                TO str\n        END-PERFORM\n    END-IF\n    \n    MOVE FUNCTION CONCATENATE(\"{\", str) TO str\n    .\nEND FUNCTION comma-quibbling.\n", "target": "fun quibble(s):\n    let result = s.join(' and ').replace(|| and ||, \", \", length(s) - 1)\n    return \"{ $result }\"\n\nlet s = [\n    []\n    [\"ABC\"]\n    [\"ABC\", \"DEF\"]\n    [\"ABC\", \"DEF\", \"G\", \"H\"]\n]\n\nfor i in s:\n    print(quibble i)\n"}
{"id": 46116, "name": "Comma quibbling", "source": "Translate COBOL to Python:        >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. comma-quibbling-test.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION comma-quibbling\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\nPROCEDURE DIVISION.\n    MOVE \"ABC\" TO strs (1)\n    MOVE \"DEF\" TO strs (2)\n    MOVE \"G\" TO strs (3)\n    MOVE \"H\" TO strs (4)\n\n    PERFORM VARYING strs-len FROM 0 BY 1 UNTIL strs-len > 4\n        DISPLAY FUNCTION comma-quibbling(strs-area)\n    END-PERFORM\n    .\nEND PROGRAM comma-quibbling-test.\n\n \nIDENTIFICATION DIVISION.\nFUNCTION-ID. comma-quibbling.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  i                             PIC 9.\n\n01  num-extra-words               PIC 9.\n\nLINKAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\n01  str                           PIC X(50).\n\nPROCEDURE DIVISION USING strs-area RETURNING str.\n    EVALUATE strs-len\n        WHEN ZERO\n            MOVE \"{}\" TO str\n            GOBACK\n\n        WHEN 1\n            MOVE FUNCTION CONCATENATE(\"{\", FUNCTION TRIM(strs (1)), \"}\")\n                TO str\n            GOBACK\n    END-EVALUATE\n\n    MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (strs-len - 1)),\n        \" and \", FUNCTION TRIM(strs (strs-len)), \"}\")\n        TO str\n\n    IF strs-len > 2\n        SUBTRACT 2 FROM strs-len GIVING num-extra-words\n        PERFORM VARYING i FROM num-extra-words BY -1 UNTIL i = 0\n            MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (i)), \", \", str)\n                TO str\n        END-PERFORM\n    END-IF\n    \n    MOVE FUNCTION CONCATENATE(\"{\", str) TO str\n    .\nEND FUNCTION comma-quibbling.\n", "target": "fun quibble(s):\n    let result = s.join(' and ').replace(|| and ||, \", \", length(s) - 1)\n    return \"{ $result }\"\n\nlet s = [\n    []\n    [\"ABC\"]\n    [\"ABC\", \"DEF\"]\n    [\"ABC\", \"DEF\", \"G\", \"H\"]\n]\n\nfor i in s:\n    print(quibble i)\n"}
{"id": 46603, "name": "Count the coins", "source": "Translate COBOL to C#:        identification division.\n       program-id. CountCoins.\n\n       data division.\n       working-storage section.\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).  \n       77  m                      pic 9(3) value 4.\n       77  n                      pic 9(3) value 100.  \n       77  edited-value           pic z(18).\n       01  coins-table            value \"01051025\".\n           05 coin                pic 9(2) occurs 4.\n       01  ways-table.\n           05 way                 pic 9(18) occurs 100.\n\n       procedure division.\n       main.\n           perform calc-count\n           move way(n) to edited-value\n           display function trim(edited-value)\n           stop run\n           .\n       calc-count.\n           initialize ways-table\n           move 1 to way(1)\n           perform varying i from 1 by 1 until i > m\n              perform varying j from coin(i) by 1 until j > n\n                 add way(j - coin(i)) to way(j)\n              end-perform\n           end-perform\n           .\n", "target": "    \n    class Program\n    {\n        static long Count(int[] C, int m, int n)\n        {\n            var table = new long[n + 1];\n            table[0] = 1;\n            for (int i = 0; i < m; i++)\n                for (int j = C[i]; j <= n; j++)\n                    table[j] += table[j - C[i]];\n            return table[n];\n        }\n        static void Main(string[] args)\n        {\n            var C = new int[] { 1, 5, 10, 25 };\n            int m = C.Length;\n            int n = 100;\n            Console.WriteLine(Count(C, m, n));  \n            Console.ReadLine();\n        }\n    }\n"}
{"id": 46604, "name": "Count the coins", "source": "Translate COBOL to C#:        identification division.\n       program-id. CountCoins.\n\n       data division.\n       working-storage section.\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).  \n       77  m                      pic 9(3) value 4.\n       77  n                      pic 9(3) value 100.  \n       77  edited-value           pic z(18).\n       01  coins-table            value \"01051025\".\n           05 coin                pic 9(2) occurs 4.\n       01  ways-table.\n           05 way                 pic 9(18) occurs 100.\n\n       procedure division.\n       main.\n           perform calc-count\n           move way(n) to edited-value\n           display function trim(edited-value)\n           stop run\n           .\n       calc-count.\n           initialize ways-table\n           move 1 to way(1)\n           perform varying i from 1 by 1 until i > m\n              perform varying j from coin(i) by 1 until j > n\n                 add way(j - coin(i)) to way(j)\n              end-perform\n           end-perform\n           .\n", "target": "    \n    class Program\n    {\n        static long Count(int[] C, int m, int n)\n        {\n            var table = new long[n + 1];\n            table[0] = 1;\n            for (int i = 0; i < m; i++)\n                for (int j = C[i]; j <= n; j++)\n                    table[j] += table[j - C[i]];\n            return table[n];\n        }\n        static void Main(string[] args)\n        {\n            var C = new int[] { 1, 5, 10, 25 };\n            int m = C.Length;\n            int n = 100;\n            Console.WriteLine(Count(C, m, n));  \n            Console.ReadLine();\n        }\n    }\n"}
{"id": 46607, "name": "Count the coins", "source": "Translate COBOL to Java:        identification division.\n       program-id. CountCoins.\n\n       data division.\n       working-storage section.\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).  \n       77  m                      pic 9(3) value 4.\n       77  n                      pic 9(3) value 100.  \n       77  edited-value           pic z(18).\n       01  coins-table            value \"01051025\".\n           05 coin                pic 9(2) occurs 4.\n       01  ways-table.\n           05 way                 pic 9(18) occurs 100.\n\n       procedure division.\n       main.\n           perform calc-count\n           move way(n) to edited-value\n           display function trim(edited-value)\n           stop run\n           .\n       calc-count.\n           initialize ways-table\n           move 1 to way(1)\n           perform varying i from 1 by 1 until i > m\n              perform varying j from coin(i) by 1 until j > n\n                 add way(j - coin(i)) to way(j)\n              end-perform\n           end-perform\n           .\n", "target": "import java.util.Arrays;\nimport java.math.BigInteger;\n\nclass CountTheCoins {\n    private static BigInteger countChanges(int amount, int[] coins){\n        final int n = coins.length;\n        int cycle = 0;\n        for (int c : coins)\n            if (c <= amount && c >= cycle)\n                cycle = c + 1;\n        cycle *= n;\n        BigInteger[] table = new BigInteger[cycle];\n        Arrays.fill(table, 0, n, BigInteger.ONE);\n        Arrays.fill(table, n, cycle, BigInteger.ZERO);\n\n        int pos = n;\n        for (int s = 1; s <= amount; s++) {\n            for (int i = 0; i < n; i++) {\n                if (i == 0 && pos >= cycle)\n                    pos = 0;\n                if (coins[i] <= s) {\n                    final int q = pos - (coins[i] * n);\n                    table[pos] = (q >= 0) ? table[q] : table[q + cycle];\n                }\n                if (i != 0)\n                    table[pos] = table[pos].add(table[pos - 1]);\n                pos++;\n            }\n        }\n\n        return table[pos - 1];\n    }\n\n    public static void main(String[] args) {\n        final int[][] coinsUsEu = {{100, 50, 25, 10, 5, 1},\n                                   {200, 100, 50, 20, 10, 5, 2, 1}};\n\n        for (int[] coins : coinsUsEu) {\n            System.out.println(countChanges(     100,\n                Arrays.copyOfRange(coins, 2, coins.length)));\n            System.out.println(countChanges(  100000, coins));\n            System.out.println(countChanges( 1000000, coins));\n            System.out.println(countChanges(10000000, coins) + \"\\n\");\n        }\n    }\n}\n"}
{"id": 46608, "name": "Count the coins", "source": "Translate COBOL to Java:        identification division.\n       program-id. CountCoins.\n\n       data division.\n       working-storage section.\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).  \n       77  m                      pic 9(3) value 4.\n       77  n                      pic 9(3) value 100.  \n       77  edited-value           pic z(18).\n       01  coins-table            value \"01051025\".\n           05 coin                pic 9(2) occurs 4.\n       01  ways-table.\n           05 way                 pic 9(18) occurs 100.\n\n       procedure division.\n       main.\n           perform calc-count\n           move way(n) to edited-value\n           display function trim(edited-value)\n           stop run\n           .\n       calc-count.\n           initialize ways-table\n           move 1 to way(1)\n           perform varying i from 1 by 1 until i > m\n              perform varying j from coin(i) by 1 until j > n\n                 add way(j - coin(i)) to way(j)\n              end-perform\n           end-perform\n           .\n", "target": "import java.util.Arrays;\nimport java.math.BigInteger;\n\nclass CountTheCoins {\n    private static BigInteger countChanges(int amount, int[] coins){\n        final int n = coins.length;\n        int cycle = 0;\n        for (int c : coins)\n            if (c <= amount && c >= cycle)\n                cycle = c + 1;\n        cycle *= n;\n        BigInteger[] table = new BigInteger[cycle];\n        Arrays.fill(table, 0, n, BigInteger.ONE);\n        Arrays.fill(table, n, cycle, BigInteger.ZERO);\n\n        int pos = n;\n        for (int s = 1; s <= amount; s++) {\n            for (int i = 0; i < n; i++) {\n                if (i == 0 && pos >= cycle)\n                    pos = 0;\n                if (coins[i] <= s) {\n                    final int q = pos - (coins[i] * n);\n                    table[pos] = (q >= 0) ? table[q] : table[q + cycle];\n                }\n                if (i != 0)\n                    table[pos] = table[pos].add(table[pos - 1]);\n                pos++;\n            }\n        }\n\n        return table[pos - 1];\n    }\n\n    public static void main(String[] args) {\n        final int[][] coinsUsEu = {{100, 50, 25, 10, 5, 1},\n                                   {200, 100, 50, 20, 10, 5, 2, 1}};\n\n        for (int[] coins : coinsUsEu) {\n            System.out.println(countChanges(     100,\n                Arrays.copyOfRange(coins, 2, coins.length)));\n            System.out.println(countChanges(  100000, coins));\n            System.out.println(countChanges( 1000000, coins));\n            System.out.println(countChanges(10000000, coins) + \"\\n\");\n        }\n    }\n}\n"}
{"id": 46609, "name": "Count the coins", "source": "Translate COBOL to Python:        identification division.\n       program-id. CountCoins.\n\n       data division.\n       working-storage section.\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).  \n       77  m                      pic 9(3) value 4.\n       77  n                      pic 9(3) value 100.  \n       77  edited-value           pic z(18).\n       01  coins-table            value \"01051025\".\n           05 coin                pic 9(2) occurs 4.\n       01  ways-table.\n           05 way                 pic 9(18) occurs 100.\n\n       procedure division.\n       main.\n           perform calc-count\n           move way(n) to edited-value\n           display function trim(edited-value)\n           stop run\n           .\n       calc-count.\n           initialize ways-table\n           move 1 to way(1)\n           perform varying i from 1 by 1 until i > m\n              perform varying j from coin(i) by 1 until j > n\n                 add way(j - coin(i)) to way(j)\n              end-perform\n           end-perform\n           .\n", "target": "def changes(amount, coins):\n    ways = [0] * (amount + 1)\n    ways[0] = 1\n    for coin in coins:\n        for j in xrange(coin, amount + 1):\n            ways[j] += ways[j - coin]\n    return ways[amount]\n\nprint changes(100, [1, 5, 10, 25])\nprint changes(100000, [1, 5, 10, 25, 50, 100])\n"}
{"id": 46610, "name": "Count the coins", "source": "Translate COBOL to Python:        identification division.\n       program-id. CountCoins.\n\n       data division.\n       working-storage section.\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).  \n       77  m                      pic 9(3) value 4.\n       77  n                      pic 9(3) value 100.  \n       77  edited-value           pic z(18).\n       01  coins-table            value \"01051025\".\n           05 coin                pic 9(2) occurs 4.\n       01  ways-table.\n           05 way                 pic 9(18) occurs 100.\n\n       procedure division.\n       main.\n           perform calc-count\n           move way(n) to edited-value\n           display function trim(edited-value)\n           stop run\n           .\n       calc-count.\n           initialize ways-table\n           move 1 to way(1)\n           perform varying i from 1 by 1 until i > m\n              perform varying j from coin(i) by 1 until j > n\n                 add way(j - coin(i)) to way(j)\n              end-perform\n           end-perform\n           .\n", "target": "def changes(amount, coins):\n    ways = [0] * (amount + 1)\n    ways[0] = 1\n    for coin in coins:\n        for j in xrange(coin, amount + 1):\n            ways[j] += ways[j - coin]\n    return ways[amount]\n\nprint changes(100, [1, 5, 10, 25])\nprint changes(100000, [1, 5, 10, 25, 50, 100])\n"}
{"id": 47108, "name": "Ackermann function", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Ackermann.\n\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  M          USAGE UNSIGNED-LONG.\n       01  N          USAGE UNSIGNED-LONG.\n\n       01  Return-Val USAGE UNSIGNED-LONG.\n\n       PROCEDURE DIVISION USING M N Return-Val.\n           EVALUATE M ALSO N\n               WHEN 0 ALSO ANY\n                   ADD 1 TO N GIVING Return-Val\n\n               WHEN NOT 0 ALSO 0\n                   SUBTRACT 1 FROM M\n                   CALL \"Ackermann\" USING BY CONTENT M BY CONTENT 1\n                       BY REFERENCE Return-Val\n\n               WHEN NOT 0 ALSO NOT 0\n                   SUBTRACT 1 FROM N\n                   CALL \"Ackermann\" USING BY CONTENT M BY CONTENT N\n                       BY REFERENCE Return-Val\n                       \n                   SUBTRACT 1 FROM M\n                   CALL \"Ackermann\" USING BY CONTENT M\n                       BY CONTENT Return-Val BY REFERENCE Return-Val\n           END-EVALUATE\n\n           GOBACK\n           .\n", "target": "using System;\nclass Program\n{\n    public static long Ackermann(long m, long n)\n    {\n        if(m > 0)\n        {\n            if (n > 0)\n                return Ackermann(m - 1, Ackermann(m, n - 1));\n            else if (n == 0)\n                return Ackermann(m - 1, 1);\n        }\n        else if(m == 0)\n        {\n            if(n >= 0) \n                return n + 1;\n        }\n\n        throw new System.ArgumentOutOfRangeException();\n    }\n    \n    static void Main()\n    {\n        for (long m = 0; m <= 3; ++m)\n        {\n            for (long n = 0; n <= 4; ++n)\n            {\n                Console.WriteLine(\"Ackermann({0}, {1}) = {2}\", m, n, Ackermann(m, n));\n            }\n        }\n    }\n}\n"}
{"id": 47110, "name": "Ackermann function", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Ackermann.\n\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  M          USAGE UNSIGNED-LONG.\n       01  N          USAGE UNSIGNED-LONG.\n\n       01  Return-Val USAGE UNSIGNED-LONG.\n\n       PROCEDURE DIVISION USING M N Return-Val.\n           EVALUATE M ALSO N\n               WHEN 0 ALSO ANY\n                   ADD 1 TO N GIVING Return-Val\n\n               WHEN NOT 0 ALSO 0\n                   SUBTRACT 1 FROM M\n                   CALL \"Ackermann\" USING BY CONTENT M BY CONTENT 1\n                       BY REFERENCE Return-Val\n\n               WHEN NOT 0 ALSO NOT 0\n                   SUBTRACT 1 FROM N\n                   CALL \"Ackermann\" USING BY CONTENT M BY CONTENT N\n                       BY REFERENCE Return-Val\n                       \n                   SUBTRACT 1 FROM M\n                   CALL \"Ackermann\" USING BY CONTENT M\n                       BY CONTENT Return-Val BY REFERENCE Return-Val\n           END-EVALUATE\n\n           GOBACK\n           .\n", "target": "import java.math.BigInteger;\n\npublic static BigInteger ack(BigInteger m, BigInteger n) {\n    return m.equals(BigInteger.ZERO)\n            ? n.add(BigInteger.ONE)\n            : ack(m.subtract(BigInteger.ONE),\n                        n.equals(BigInteger.ZERO) ? BigInteger.ONE : ack(m, n.subtract(BigInteger.ONE)));\n}\n"}
{"id": 47111, "name": "Ackermann function", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Ackermann.\n\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  M          USAGE UNSIGNED-LONG.\n       01  N          USAGE UNSIGNED-LONG.\n\n       01  Return-Val USAGE UNSIGNED-LONG.\n\n       PROCEDURE DIVISION USING M N Return-Val.\n           EVALUATE M ALSO N\n               WHEN 0 ALSO ANY\n                   ADD 1 TO N GIVING Return-Val\n\n               WHEN NOT 0 ALSO 0\n                   SUBTRACT 1 FROM M\n                   CALL \"Ackermann\" USING BY CONTENT M BY CONTENT 1\n                       BY REFERENCE Return-Val\n\n               WHEN NOT 0 ALSO NOT 0\n                   SUBTRACT 1 FROM N\n                   CALL \"Ackermann\" USING BY CONTENT M BY CONTENT N\n                       BY REFERENCE Return-Val\n                       \n                   SUBTRACT 1 FROM M\n                   CALL \"Ackermann\" USING BY CONTENT M\n                       BY CONTENT Return-Val BY REFERENCE Return-Val\n           END-EVALUATE\n\n           GOBACK\n           .\n", "target": "from __future__ import print_function\n\ndef setup():\n    for m in range(4):\n        for n in range(7):\n            print(\"{} \".format(ackermann(m, n)), end = \"\")\n        print()\n    \n\ndef ackermann(m, n):\n    if m == 0:\n        return n + 1\n    elif m > 0 and n == 0:\n        return ackermann(m - 1, 1)\n    else:\n        return ackermann(m - 1, ackermann(m, n - 1))\n"}
{"id": 47926, "name": "Hello world_Text", "source": "Translate COBOL to C#: \tprogram-id. hello.\n\tprocedure division.\n\t\tdisplay \"Hello world!\".\n\t\tstop run.\n", "target": "Using System;\nnamespace HelloWorld {\n  class Program\n  {\n    static void Main()\n    {\n      Console.Writeln(\"Hello World!\");\n    }\n  }\n}\n"}
{"id": 47928, "name": "Hello world_Text", "source": "Translate COBOL to Java: \tprogram-id. hello.\n\tprocedure division.\n\t\tdisplay \"Hello world!\".\n\t\tstop run.\n", "target": "module HelloWorld\n    {\n    void run()\n        {\n        @Inject Console console;\n        console.print(\"Hello World!\");\n        }\n    }\n"}
{"id": 49040, "name": "Digital root", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DIGITAL-ROOT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 INPUT-NUMBER     PIC 9(16).\n          03 INPUT-DIGITS     REDEFINES INPUT-NUMBER,\n                              PIC 9 OCCURS 16 TIMES.\n          03 DIGIT-SUM        PIC 999.\n          03 DIGIT-NO         PIC 99.\n          03 PERSISTENCE      PIC 9.\n\n       01 OUTPUT-FORMAT.\n          03 O-NUMBER         PIC Z(15)9.\n          03 FILLER           PIC X(16) VALUE ': PERSISTENCE = '.\n          03 O-PERSISTENCE    PIC Z9.\n          03 FILLER           PIC X(9) VALUE ', ROOT = '.\n          03 O-ROOT           PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 627615 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 39390 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 393900588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           STOP RUN.\n\n       FIND-DIGITAL-ROOT.\n           MOVE ZERO TO PERSISTENCE.\n           MOVE INPUT-NUMBER TO O-NUMBER.\n           PERFORM SUMMATION UNTIL INPUT-NUMBER IS LESS THAN 10.\n           MOVE INPUT-NUMBER TO O-ROOT.\n           MOVE PERSISTENCE TO O-PERSISTENCE.\n           DISPLAY OUTPUT-FORMAT.\n\n       SUMMATION.\n           MOVE ZERO TO DIGIT-SUM.\n           ADD 1 TO PERSISTENCE.\n           PERFORM ADD-DIGIT VARYING DIGIT-NO FROM 1 BY 1\n               UNTIL DIGIT-NO IS GREATER THAN 16.\n           MOVE DIGIT-SUM TO INPUT-NUMBER.\n\n       ADD-DIGIT.\n           ADD INPUT-DIGITS(DIGIT-NO) TO DIGIT-SUM.\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static Tuple<int, int> DigitalRoot(long num)\n    {\n        int additivepersistence = 0;\n        while (num > 9)\n        {\n            num = num.ToString().ToCharArray().Sum(x => x - '0');\n            additivepersistence++;\n        }\n        return new Tuple<int, int>(additivepersistence, (int)num);\n    }\n    static void Main(string[] args)\n    {\n        foreach (long num in new long[] { 627615, 39390, 588225, 393900588225 })\n        {\n            var t = DigitalRoot(num);\n            Console.WriteLine(\"{0} has additive persistence {1} and digital root {2}\", num, t.Item1, t.Item2);\n        }\n    }\n}\n"}
{"id": 49041, "name": "Digital root", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DIGITAL-ROOT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 INPUT-NUMBER     PIC 9(16).\n          03 INPUT-DIGITS     REDEFINES INPUT-NUMBER,\n                              PIC 9 OCCURS 16 TIMES.\n          03 DIGIT-SUM        PIC 999.\n          03 DIGIT-NO         PIC 99.\n          03 PERSISTENCE      PIC 9.\n\n       01 OUTPUT-FORMAT.\n          03 O-NUMBER         PIC Z(15)9.\n          03 FILLER           PIC X(16) VALUE ': PERSISTENCE = '.\n          03 O-PERSISTENCE    PIC Z9.\n          03 FILLER           PIC X(9) VALUE ', ROOT = '.\n          03 O-ROOT           PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 627615 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 39390 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 393900588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           STOP RUN.\n\n       FIND-DIGITAL-ROOT.\n           MOVE ZERO TO PERSISTENCE.\n           MOVE INPUT-NUMBER TO O-NUMBER.\n           PERFORM SUMMATION UNTIL INPUT-NUMBER IS LESS THAN 10.\n           MOVE INPUT-NUMBER TO O-ROOT.\n           MOVE PERSISTENCE TO O-PERSISTENCE.\n           DISPLAY OUTPUT-FORMAT.\n\n       SUMMATION.\n           MOVE ZERO TO DIGIT-SUM.\n           ADD 1 TO PERSISTENCE.\n           PERFORM ADD-DIGIT VARYING DIGIT-NO FROM 1 BY 1\n               UNTIL DIGIT-NO IS GREATER THAN 16.\n           MOVE DIGIT-SUM TO INPUT-NUMBER.\n\n       ADD-DIGIT.\n           ADD INPUT-DIGITS(DIGIT-NO) TO DIGIT-SUM.\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static Tuple<int, int> DigitalRoot(long num)\n    {\n        int additivepersistence = 0;\n        while (num > 9)\n        {\n            num = num.ToString().ToCharArray().Sum(x => x - '0');\n            additivepersistence++;\n        }\n        return new Tuple<int, int>(additivepersistence, (int)num);\n    }\n    static void Main(string[] args)\n    {\n        foreach (long num in new long[] { 627615, 39390, 588225, 393900588225 })\n        {\n            var t = DigitalRoot(num);\n            Console.WriteLine(\"{0} has additive persistence {1} and digital root {2}\", num, t.Item1, t.Item2);\n        }\n    }\n}\n"}
{"id": 49044, "name": "Digital root", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DIGITAL-ROOT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 INPUT-NUMBER     PIC 9(16).\n          03 INPUT-DIGITS     REDEFINES INPUT-NUMBER,\n                              PIC 9 OCCURS 16 TIMES.\n          03 DIGIT-SUM        PIC 999.\n          03 DIGIT-NO         PIC 99.\n          03 PERSISTENCE      PIC 9.\n\n       01 OUTPUT-FORMAT.\n          03 O-NUMBER         PIC Z(15)9.\n          03 FILLER           PIC X(16) VALUE ': PERSISTENCE = '.\n          03 O-PERSISTENCE    PIC Z9.\n          03 FILLER           PIC X(9) VALUE ', ROOT = '.\n          03 O-ROOT           PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 627615 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 39390 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 393900588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           STOP RUN.\n\n       FIND-DIGITAL-ROOT.\n           MOVE ZERO TO PERSISTENCE.\n           MOVE INPUT-NUMBER TO O-NUMBER.\n           PERFORM SUMMATION UNTIL INPUT-NUMBER IS LESS THAN 10.\n           MOVE INPUT-NUMBER TO O-ROOT.\n           MOVE PERSISTENCE TO O-PERSISTENCE.\n           DISPLAY OUTPUT-FORMAT.\n\n       SUMMATION.\n           MOVE ZERO TO DIGIT-SUM.\n           ADD 1 TO PERSISTENCE.\n           PERFORM ADD-DIGIT VARYING DIGIT-NO FROM 1 BY 1\n               UNTIL DIGIT-NO IS GREATER THAN 16.\n           MOVE DIGIT-SUM TO INPUT-NUMBER.\n\n       ADD-DIGIT.\n           ADD INPUT-DIGITS(DIGIT-NO) TO DIGIT-SUM.\n", "target": "import java.math.BigInteger;\n\nclass DigitalRoot\n{\n  public static int[] calcDigitalRoot(String number, int base)\n  {\n    BigInteger bi = new BigInteger(number, base);\n    int additivePersistence = 0;\n    if (bi.signum() < 0)\n      bi = bi.negate();\n    BigInteger biBase = BigInteger.valueOf(base);\n    while (bi.compareTo(biBase) >= 0)\n    {\n      number = bi.toString(base);\n      bi = BigInteger.ZERO;\n      for (int i = 0; i < number.length(); i++)\n        bi = bi.add(new BigInteger(number.substring(i, i + 1), base));\n      additivePersistence++;\n    }\n    return new int[] { additivePersistence, bi.intValue() };\n  }\n\n  public static void main(String[] args)\n  {\n    for (String arg : args)\n    {\n      int[] results = calcDigitalRoot(arg, 10);\n      System.out.println(arg + \" has additive persistence \" + results[0] + \" and digital root of \" + results[1]);\n    }\n  }\n}\n"}
{"id": 49045, "name": "Digital root", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DIGITAL-ROOT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 INPUT-NUMBER     PIC 9(16).\n          03 INPUT-DIGITS     REDEFINES INPUT-NUMBER,\n                              PIC 9 OCCURS 16 TIMES.\n          03 DIGIT-SUM        PIC 999.\n          03 DIGIT-NO         PIC 99.\n          03 PERSISTENCE      PIC 9.\n\n       01 OUTPUT-FORMAT.\n          03 O-NUMBER         PIC Z(15)9.\n          03 FILLER           PIC X(16) VALUE ': PERSISTENCE = '.\n          03 O-PERSISTENCE    PIC Z9.\n          03 FILLER           PIC X(9) VALUE ', ROOT = '.\n          03 O-ROOT           PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 627615 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 39390 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 393900588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           STOP RUN.\n\n       FIND-DIGITAL-ROOT.\n           MOVE ZERO TO PERSISTENCE.\n           MOVE INPUT-NUMBER TO O-NUMBER.\n           PERFORM SUMMATION UNTIL INPUT-NUMBER IS LESS THAN 10.\n           MOVE INPUT-NUMBER TO O-ROOT.\n           MOVE PERSISTENCE TO O-PERSISTENCE.\n           DISPLAY OUTPUT-FORMAT.\n\n       SUMMATION.\n           MOVE ZERO TO DIGIT-SUM.\n           ADD 1 TO PERSISTENCE.\n           PERFORM ADD-DIGIT VARYING DIGIT-NO FROM 1 BY 1\n               UNTIL DIGIT-NO IS GREATER THAN 16.\n           MOVE DIGIT-SUM TO INPUT-NUMBER.\n\n       ADD-DIGIT.\n           ADD INPUT-DIGITS(DIGIT-NO) TO DIGIT-SUM.\n", "target": "import java.math.BigInteger;\n\nclass DigitalRoot\n{\n  public static int[] calcDigitalRoot(String number, int base)\n  {\n    BigInteger bi = new BigInteger(number, base);\n    int additivePersistence = 0;\n    if (bi.signum() < 0)\n      bi = bi.negate();\n    BigInteger biBase = BigInteger.valueOf(base);\n    while (bi.compareTo(biBase) >= 0)\n    {\n      number = bi.toString(base);\n      bi = BigInteger.ZERO;\n      for (int i = 0; i < number.length(); i++)\n        bi = bi.add(new BigInteger(number.substring(i, i + 1), base));\n      additivePersistence++;\n    }\n    return new int[] { additivePersistence, bi.intValue() };\n  }\n\n  public static void main(String[] args)\n  {\n    for (String arg : args)\n    {\n      int[] results = calcDigitalRoot(arg, 10);\n      System.out.println(arg + \" has additive persistence \" + results[0] + \" and digital root of \" + results[1]);\n    }\n  }\n}\n"}
{"id": 49046, "name": "Digital root", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DIGITAL-ROOT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 INPUT-NUMBER     PIC 9(16).\n          03 INPUT-DIGITS     REDEFINES INPUT-NUMBER,\n                              PIC 9 OCCURS 16 TIMES.\n          03 DIGIT-SUM        PIC 999.\n          03 DIGIT-NO         PIC 99.\n          03 PERSISTENCE      PIC 9.\n\n       01 OUTPUT-FORMAT.\n          03 O-NUMBER         PIC Z(15)9.\n          03 FILLER           PIC X(16) VALUE ': PERSISTENCE = '.\n          03 O-PERSISTENCE    PIC Z9.\n          03 FILLER           PIC X(9) VALUE ', ROOT = '.\n          03 O-ROOT           PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 627615 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 39390 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 393900588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           STOP RUN.\n\n       FIND-DIGITAL-ROOT.\n           MOVE ZERO TO PERSISTENCE.\n           MOVE INPUT-NUMBER TO O-NUMBER.\n           PERFORM SUMMATION UNTIL INPUT-NUMBER IS LESS THAN 10.\n           MOVE INPUT-NUMBER TO O-ROOT.\n           MOVE PERSISTENCE TO O-PERSISTENCE.\n           DISPLAY OUTPUT-FORMAT.\n\n       SUMMATION.\n           MOVE ZERO TO DIGIT-SUM.\n           ADD 1 TO PERSISTENCE.\n           PERFORM ADD-DIGIT VARYING DIGIT-NO FROM 1 BY 1\n               UNTIL DIGIT-NO IS GREATER THAN 16.\n           MOVE DIGIT-SUM TO INPUT-NUMBER.\n\n       ADD-DIGIT.\n           ADD INPUT-DIGITS(DIGIT-NO) TO DIGIT-SUM.\n", "target": "def digital_root (n):\n    ap = 0\n    n = abs(int(n))\n    while n >= 10:\n        n = sum(int(digit) for digit in str(n))\n        ap += 1\n    return ap, n\n\nif __name__ == '__main__':\n    for n in [627615, 39390, 588225, 393900588225, 55]:\n        persistance, root = digital_root(n)\n        print(\"%12i has additive persistance %2i and digital root %i.\" \n              % (n, persistance, root))\n"}
{"id": 49047, "name": "Digital root", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DIGITAL-ROOT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 INPUT-NUMBER     PIC 9(16).\n          03 INPUT-DIGITS     REDEFINES INPUT-NUMBER,\n                              PIC 9 OCCURS 16 TIMES.\n          03 DIGIT-SUM        PIC 999.\n          03 DIGIT-NO         PIC 99.\n          03 PERSISTENCE      PIC 9.\n\n       01 OUTPUT-FORMAT.\n          03 O-NUMBER         PIC Z(15)9.\n          03 FILLER           PIC X(16) VALUE ': PERSISTENCE = '.\n          03 O-PERSISTENCE    PIC Z9.\n          03 FILLER           PIC X(9) VALUE ', ROOT = '.\n          03 O-ROOT           PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 627615 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 39390 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 393900588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           STOP RUN.\n\n       FIND-DIGITAL-ROOT.\n           MOVE ZERO TO PERSISTENCE.\n           MOVE INPUT-NUMBER TO O-NUMBER.\n           PERFORM SUMMATION UNTIL INPUT-NUMBER IS LESS THAN 10.\n           MOVE INPUT-NUMBER TO O-ROOT.\n           MOVE PERSISTENCE TO O-PERSISTENCE.\n           DISPLAY OUTPUT-FORMAT.\n\n       SUMMATION.\n           MOVE ZERO TO DIGIT-SUM.\n           ADD 1 TO PERSISTENCE.\n           PERFORM ADD-DIGIT VARYING DIGIT-NO FROM 1 BY 1\n               UNTIL DIGIT-NO IS GREATER THAN 16.\n           MOVE DIGIT-SUM TO INPUT-NUMBER.\n\n       ADD-DIGIT.\n           ADD INPUT-DIGITS(DIGIT-NO) TO DIGIT-SUM.\n", "target": "def digital_root (n):\n    ap = 0\n    n = abs(int(n))\n    while n >= 10:\n        n = sum(int(digit) for digit in str(n))\n        ap += 1\n    return ap, n\n\nif __name__ == '__main__':\n    for n in [627615, 39390, 588225, 393900588225, 55]:\n        persistance, root = digital_root(n)\n        print(\"%12i has additive persistance %2i and digital root %i.\" \n              % (n, persistance, root))\n"}
{"id": 49390, "name": "Loops_Continue", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. loop-continue.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i PIC 99.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               DISPLAY i WITH NO ADVANCING\n\n               IF FUNCTION MOD(i, 5) = 0\n                   DISPLAY SPACE\n                   EXIT PERFORM CYCLE\n               END-IF\n\n               DISPLAY \", \" WITH NO ADVANCING\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        for (int i = 1; i <= 10; i++) {\n            Console.Write(i);\n\n            if (i % 5 == 0) {\n                Console.WriteLine();\n                continue;\n            }\n\n            Console.Write(\", \");\n        }\n    }\n}\n"}
{"id": 49392, "name": "Loops_Continue", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. loop-continue.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i PIC 99.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               DISPLAY i WITH NO ADVANCING\n\n               IF FUNCTION MOD(i, 5) = 0\n                   DISPLAY SPACE\n                   EXIT PERFORM CYCLE\n               END-IF\n\n               DISPLAY \", \" WITH NO ADVANCING\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "for(int i = 1;i <= 10; i++){\n   System.out.print(i);\n   if(i % 5 == 0){\n      System.out.println();\n      continue;\n   }\n   System.out.print(\", \");\n}\n"}
{"id": 49393, "name": "Loops_Continue", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. loop-continue.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i PIC 99.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               DISPLAY i WITH NO ADVANCING\n\n               IF FUNCTION MOD(i, 5) = 0\n                   DISPLAY SPACE\n                   EXIT PERFORM CYCLE\n               END-IF\n\n               DISPLAY \", \" WITH NO ADVANCING\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "for i in range(1, 11):\n    if i % 5 == 0:\n        print(i)\n        continue\n    print(i, end=', ')\n"}
{"id": 50135, "name": "Sieve of Eratosthenes", "source": "Translate COBOL to C#: \n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Sieve-Of-Eratosthenes.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  Max-Number       USAGE UNSIGNED-INT.\n       01  Max-Prime        USAGE UNSIGNED-INT.\n\n       01  Num-Group.\n           03  Num-Table PIC X VALUE \"P\"\n                   OCCURS 1 TO 10000000 TIMES DEPENDING ON Max-Number\n                   INDEXED BY Num-Index.\n               88  Is-Prime VALUE \"P\" FALSE \"N\".\n               \n       01  Current-Prime    USAGE UNSIGNED-INT.\n\n       01  I                USAGE UNSIGNED-INT.\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Enter the limit: \" WITH NO ADVANCING\n           ACCEPT Max-Number\n           DIVIDE Max-Number BY 2 GIVING Max-Prime\n\n*          \n           SET Is-Prime (1) TO FALSE\n           PERFORM UNTIL Max-Prime < Current-Prime\n*              \n               ADD 1 TO Current-Prime\n               PERFORM VARYING Num-Index FROM Current-Prime BY 1\n                   UNTIL Is-Prime (Num-Index)\n               END-PERFORM\n               MOVE Num-Index TO Current-Prime\n\n*              \n*              \n               COMPUTE Num-Index = Current-Prime ** 2\n               PERFORM UNTIL Max-Number < Num-Index\n                   SET Is-Prime (Num-Index) TO FALSE\n                   SET Num-Index UP BY Current-Prime\n               END-PERFORM\n           END-PERFORM\n\n*          \n           PERFORM VARYING Num-Index FROM 1 BY 1\n                   UNTIL Max-Number < Num-Index\n               IF Is-Prime (Num-Index)\n                   DISPLAY Num-Index\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace SieveOfEratosthenes\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int maxprime = int.Parse(args[0]);\n            var primelist = GetAllPrimesLessThan(maxprime);\n            foreach (int prime in primelist)\n            {\n                Console.WriteLine(prime);\n            }\n            Console.WriteLine(\"Count = \" + primelist.Count);\n            Console.ReadLine();\n        }\n\n        private static List<int> GetAllPrimesLessThan(int maxPrime)\n        {\n            var primes = new List<int>();\n            var maxSquareRoot = (int)Math.Sqrt(maxPrime);\n            var eliminated = new BitArray(maxPrime + 1);\n\n            for (int i = 2; i <= maxPrime; ++i)\n            {\n                if (!eliminated[i])\n                {\n                    primes.Add(i);\n                    if (i <= maxSquareRoot)\n                    {\n                        for (int j = i * i; j <= maxPrime; j += i)\n                        {\n                            eliminated[j] = true;\n                        }\n                    }\n                }\n            }\n            return primes;\n        }\n    }\n}\n"}
{"id": 50137, "name": "Sieve of Eratosthenes", "source": "Translate COBOL to Java: \n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Sieve-Of-Eratosthenes.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  Max-Number       USAGE UNSIGNED-INT.\n       01  Max-Prime        USAGE UNSIGNED-INT.\n\n       01  Num-Group.\n           03  Num-Table PIC X VALUE \"P\"\n                   OCCURS 1 TO 10000000 TIMES DEPENDING ON Max-Number\n                   INDEXED BY Num-Index.\n               88  Is-Prime VALUE \"P\" FALSE \"N\".\n               \n       01  Current-Prime    USAGE UNSIGNED-INT.\n\n       01  I                USAGE UNSIGNED-INT.\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Enter the limit: \" WITH NO ADVANCING\n           ACCEPT Max-Number\n           DIVIDE Max-Number BY 2 GIVING Max-Prime\n\n*          \n           SET Is-Prime (1) TO FALSE\n           PERFORM UNTIL Max-Prime < Current-Prime\n*              \n               ADD 1 TO Current-Prime\n               PERFORM VARYING Num-Index FROM Current-Prime BY 1\n                   UNTIL Is-Prime (Num-Index)\n               END-PERFORM\n               MOVE Num-Index TO Current-Prime\n\n*              \n*              \n               COMPUTE Num-Index = Current-Prime ** 2\n               PERFORM UNTIL Max-Number < Num-Index\n                   SET Is-Prime (Num-Index) TO FALSE\n                   SET Num-Index UP BY Current-Prime\n               END-PERFORM\n           END-PERFORM\n\n*          \n           PERFORM VARYING Num-Index FROM 1 BY 1\n                   UNTIL Max-Number < Num-Index\n               IF Is-Prime (Num-Index)\n                   DISPLAY Num-Index\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "import java.util.LinkedList;\n\npublic class Sieve{\n       public static LinkedList<Integer> sieve(int n){\n               if(n < 2) return new LinkedList<Integer>();\n               LinkedList<Integer> primes = new LinkedList<Integer>();\n               LinkedList<Integer> nums = new LinkedList<Integer>();\n\n               for(int i = 2;i <= n;i++){ \n                       nums.add(i);\n               }\n\n               while(nums.size() > 0){\n                       int nextPrime = nums.remove();\n                       for(int i = nextPrime * nextPrime;i <= n;i += nextPrime){\n                               nums.removeFirstOccurrence(i);\n                       }\n                       primes.add(nextPrime);\n               }\n               return primes;\n       }\n}\n"}
{"id": 50138, "name": "Sieve of Eratosthenes", "source": "Translate COBOL to Python: \n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Sieve-Of-Eratosthenes.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  Max-Number       USAGE UNSIGNED-INT.\n       01  Max-Prime        USAGE UNSIGNED-INT.\n\n       01  Num-Group.\n           03  Num-Table PIC X VALUE \"P\"\n                   OCCURS 1 TO 10000000 TIMES DEPENDING ON Max-Number\n                   INDEXED BY Num-Index.\n               88  Is-Prime VALUE \"P\" FALSE \"N\".\n               \n       01  Current-Prime    USAGE UNSIGNED-INT.\n\n       01  I                USAGE UNSIGNED-INT.\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Enter the limit: \" WITH NO ADVANCING\n           ACCEPT Max-Number\n           DIVIDE Max-Number BY 2 GIVING Max-Prime\n\n*          \n           SET Is-Prime (1) TO FALSE\n           PERFORM UNTIL Max-Prime < Current-Prime\n*              \n               ADD 1 TO Current-Prime\n               PERFORM VARYING Num-Index FROM Current-Prime BY 1\n                   UNTIL Is-Prime (Num-Index)\n               END-PERFORM\n               MOVE Num-Index TO Current-Prime\n\n*              \n*              \n               COMPUTE Num-Index = Current-Prime ** 2\n               PERFORM UNTIL Max-Number < Num-Index\n                   SET Is-Prime (Num-Index) TO FALSE\n                   SET Num-Index UP BY Current-Prime\n               END-PERFORM\n           END-PERFORM\n\n*          \n           PERFORM VARYING Num-Index FROM 1 BY 1\n                   UNTIL Max-Number < Num-Index\n               IF Is-Prime (Num-Index)\n                   DISPLAY Num-Index\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "from __future__ import print_function\n\ni = 2\n\ndef setup():\n    size(1000, 1000)\n    \n    global maxx, maxy, max_num, sieve\n    maxx = width\n    maxy = height\n    max_num = width * height\n    sieve = [False] * (max_num + 1)\n\n    sieve[1] = False\n    plot(0, False)\n    plot(1, False)\n    for i in range(2, max_num + 1):\n        sieve[i] = True\n        plot(i, True)\n\n\ndef draw():\n    global i\n    if not sieve[i]:\n        while (i * i < max_num and not sieve[i]):\n            i += 1\n\n    if sieve[i]:\n        print(\"{} \".format(i), end = '')\n        for j in range(i * i, max_num + 1, i):\n            if sieve[j]:\n                sieve[j] = False\n                plot(j, False)\n\n    if i * i < max_num:\n        i += 1\n    else:\n        noLoop()\n        println(\"finished\")\n\n\ndef plot(pos, active):\n    set(pos % maxx, pos / maxx, color(0) if active else color(255))\n"}
{"id": 51032, "name": "Split a character string based on change of character", "source": "Translate COBOL to C#:        identification division.\n       program-id. split-ch.\n       data division.\n       1 split-str pic x(30) value space.\n       88 str-1 value \"gHHH5YY++///\\\".\n       88 str-2 value \"gHHH5  ))YY++,,,///\\\".\n       1 binary.\n        2 ptr pic 9(4) value 1.\n        2 str-start pic 9(4) value 1.\n        2 delim-len pic 9(4) value 1.\n        2 split-str-len pic 9(4) value 0.\n        2 trash-9 pic 9(4) value 0.\n       1 delim-char pic x value space.\n       1 delim-str pic x(6) value space.\n       1 trash-x pic x.\n       procedure division.\n           display \"Requested string\"\n           set str-1 to true\n           perform split-init-and-go\n           display space\n           display \"With spaces and commas\"\n           set str-2 to true\n           perform split-init-and-go\n           stop run\n           .\n\n       split-init-and-go.\n           move 1 to ptr\n           move 0 to split-str-len\n           perform split\n           .\n\n       split.\n           perform get-split-str-len\n           display split-str (1:split-str-len)\n           perform until ptr > split-str-len\n               move ptr to str-start\n               move split-str (ptr:1) to delim-char\n               unstring split-str (1:split-str-len)\n                   delimited all delim-char\n                   into trash-x delimiter delim-str\n                   pointer ptr\n               end-unstring\n               subtract str-start from ptr giving delim-len\n               move split-str (str-start:delim-len)\n                   to delim-str (1:delim-len)\n               display delim-str (1:delim-len) with no advancing\n               if ptr <= split-str-len\n                   display \", \" with no advancing\n               end-if\n           end-perform\n           display space\n           .\n\n       get-split-str-len.\n           inspect function reverse (split-str) tallying\n               trash-9 for leading space\n               split-str-len for characters after space\n           .\n\n       end program split-ch.\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    string s = @\"gHHH5YY++\n    Console.WriteLine(s.RunLengthSplit().Delimit(\", \"));\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> RunLengthSplit(this string source) {\n        using (var enumerator = source.GetEnumerator()) {\n            if (!enumerator.MoveNext()) yield break;\n            char previous = enumerator.Current;\n            int count = 1;\n            while (enumerator.MoveNext()) {\n                if (previous == enumerator.Current) {\n                    count++;\n                } else {\n                    yield return new string(Enumerable.Repeat(previous, count).ToArray());\n                    previous = enumerator.Current;\n                    count = 1;\n                }\n            }\n            yield return new string(Enumerable.Repeat(previous, count).ToArray());\n        }\n    }\n\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = \"\") => string.Join(separator ?? \"\", source);\n}\n"}
{"id": 51033, "name": "Split a character string based on change of character", "source": "Translate COBOL to C#:        identification division.\n       program-id. split-ch.\n       data division.\n       1 split-str pic x(30) value space.\n       88 str-1 value \"gHHH5YY++///\\\".\n       88 str-2 value \"gHHH5  ))YY++,,,///\\\".\n       1 binary.\n        2 ptr pic 9(4) value 1.\n        2 str-start pic 9(4) value 1.\n        2 delim-len pic 9(4) value 1.\n        2 split-str-len pic 9(4) value 0.\n        2 trash-9 pic 9(4) value 0.\n       1 delim-char pic x value space.\n       1 delim-str pic x(6) value space.\n       1 trash-x pic x.\n       procedure division.\n           display \"Requested string\"\n           set str-1 to true\n           perform split-init-and-go\n           display space\n           display \"With spaces and commas\"\n           set str-2 to true\n           perform split-init-and-go\n           stop run\n           .\n\n       split-init-and-go.\n           move 1 to ptr\n           move 0 to split-str-len\n           perform split\n           .\n\n       split.\n           perform get-split-str-len\n           display split-str (1:split-str-len)\n           perform until ptr > split-str-len\n               move ptr to str-start\n               move split-str (ptr:1) to delim-char\n               unstring split-str (1:split-str-len)\n                   delimited all delim-char\n                   into trash-x delimiter delim-str\n                   pointer ptr\n               end-unstring\n               subtract str-start from ptr giving delim-len\n               move split-str (str-start:delim-len)\n                   to delim-str (1:delim-len)\n               display delim-str (1:delim-len) with no advancing\n               if ptr <= split-str-len\n                   display \", \" with no advancing\n               end-if\n           end-perform\n           display space\n           .\n\n       get-split-str-len.\n           inspect function reverse (split-str) tallying\n               trash-9 for leading space\n               split-str-len for characters after space\n           .\n\n       end program split-ch.\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    string s = @\"gHHH5YY++\n    Console.WriteLine(s.RunLengthSplit().Delimit(\", \"));\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> RunLengthSplit(this string source) {\n        using (var enumerator = source.GetEnumerator()) {\n            if (!enumerator.MoveNext()) yield break;\n            char previous = enumerator.Current;\n            int count = 1;\n            while (enumerator.MoveNext()) {\n                if (previous == enumerator.Current) {\n                    count++;\n                } else {\n                    yield return new string(Enumerable.Repeat(previous, count).ToArray());\n                    previous = enumerator.Current;\n                    count = 1;\n                }\n            }\n            yield return new string(Enumerable.Repeat(previous, count).ToArray());\n        }\n    }\n\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = \"\") => string.Join(separator ?? \"\", source);\n}\n"}
{"id": 51036, "name": "Split a character string based on change of character", "source": "Translate COBOL to Java:        identification division.\n       program-id. split-ch.\n       data division.\n       1 split-str pic x(30) value space.\n       88 str-1 value \"gHHH5YY++///\\\".\n       88 str-2 value \"gHHH5  ))YY++,,,///\\\".\n       1 binary.\n        2 ptr pic 9(4) value 1.\n        2 str-start pic 9(4) value 1.\n        2 delim-len pic 9(4) value 1.\n        2 split-str-len pic 9(4) value 0.\n        2 trash-9 pic 9(4) value 0.\n       1 delim-char pic x value space.\n       1 delim-str pic x(6) value space.\n       1 trash-x pic x.\n       procedure division.\n           display \"Requested string\"\n           set str-1 to true\n           perform split-init-and-go\n           display space\n           display \"With spaces and commas\"\n           set str-2 to true\n           perform split-init-and-go\n           stop run\n           .\n\n       split-init-and-go.\n           move 1 to ptr\n           move 0 to split-str-len\n           perform split\n           .\n\n       split.\n           perform get-split-str-len\n           display split-str (1:split-str-len)\n           perform until ptr > split-str-len\n               move ptr to str-start\n               move split-str (ptr:1) to delim-char\n               unstring split-str (1:split-str-len)\n                   delimited all delim-char\n                   into trash-x delimiter delim-str\n                   pointer ptr\n               end-unstring\n               subtract str-start from ptr giving delim-len\n               move split-str (str-start:delim-len)\n                   to delim-str (1:delim-len)\n               display delim-str (1:delim-len) with no advancing\n               if ptr <= split-str-len\n                   display \", \" with no advancing\n               end-if\n           end-perform\n           display space\n           .\n\n       get-split-str-len.\n           inspect function reverse (split-str) tallying\n               trash-9 for leading space\n               split-str-len for characters after space\n           .\n\n       end program split-ch.\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SplitStringByCharacterChange {\n    \n    public static void main(String... args){\n        for (String string : args){\n            \n            List<String> resultStrings = splitStringByCharacter(string);\n            String output = formatList(resultStrings);\n            System.out.println(output);\n        }\n    }\n    \n    \n    public static List<String> splitStringByCharacter(String string){\n        \n        List<String> resultStrings = new ArrayList<>();\n        StringBuilder currentString = new StringBuilder();\n        \n        for (int pointer = 0; pointer < string.length(); pointer++){\n            \n            currentString.append(string.charAt(pointer));\n            \n            if (pointer == string.length() - 1 \n                    || currentString.charAt(0) != string.charAt(pointer + 1)) {\n                resultStrings.add(currentString.toString());\n                currentString = new StringBuilder();\n            }\n        }\n        \n        return resultStrings;\n    }\n    \n    \n    public static String formatList(List<String> list){\n        \n        StringBuilder output = new StringBuilder();\n        \n        for (int pointer = 0; pointer < list.size(); pointer++){\n            output.append(list.get(pointer));\n            \n            if (pointer != list.size() - 1){\n                output.append(\", \");\n            }\n        }\n        \n        return output.toString();\n    }\n}\n"}
{"id": 51037, "name": "Split a character string based on change of character", "source": "Translate COBOL to Java:        identification division.\n       program-id. split-ch.\n       data division.\n       1 split-str pic x(30) value space.\n       88 str-1 value \"gHHH5YY++///\\\".\n       88 str-2 value \"gHHH5  ))YY++,,,///\\\".\n       1 binary.\n        2 ptr pic 9(4) value 1.\n        2 str-start pic 9(4) value 1.\n        2 delim-len pic 9(4) value 1.\n        2 split-str-len pic 9(4) value 0.\n        2 trash-9 pic 9(4) value 0.\n       1 delim-char pic x value space.\n       1 delim-str pic x(6) value space.\n       1 trash-x pic x.\n       procedure division.\n           display \"Requested string\"\n           set str-1 to true\n           perform split-init-and-go\n           display space\n           display \"With spaces and commas\"\n           set str-2 to true\n           perform split-init-and-go\n           stop run\n           .\n\n       split-init-and-go.\n           move 1 to ptr\n           move 0 to split-str-len\n           perform split\n           .\n\n       split.\n           perform get-split-str-len\n           display split-str (1:split-str-len)\n           perform until ptr > split-str-len\n               move ptr to str-start\n               move split-str (ptr:1) to delim-char\n               unstring split-str (1:split-str-len)\n                   delimited all delim-char\n                   into trash-x delimiter delim-str\n                   pointer ptr\n               end-unstring\n               subtract str-start from ptr giving delim-len\n               move split-str (str-start:delim-len)\n                   to delim-str (1:delim-len)\n               display delim-str (1:delim-len) with no advancing\n               if ptr <= split-str-len\n                   display \", \" with no advancing\n               end-if\n           end-perform\n           display space\n           .\n\n       get-split-str-len.\n           inspect function reverse (split-str) tallying\n               trash-9 for leading space\n               split-str-len for characters after space\n           .\n\n       end program split-ch.\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SplitStringByCharacterChange {\n    \n    public static void main(String... args){\n        for (String string : args){\n            \n            List<String> resultStrings = splitStringByCharacter(string);\n            String output = formatList(resultStrings);\n            System.out.println(output);\n        }\n    }\n    \n    \n    public static List<String> splitStringByCharacter(String string){\n        \n        List<String> resultStrings = new ArrayList<>();\n        StringBuilder currentString = new StringBuilder();\n        \n        for (int pointer = 0; pointer < string.length(); pointer++){\n            \n            currentString.append(string.charAt(pointer));\n            \n            if (pointer == string.length() - 1 \n                    || currentString.charAt(0) != string.charAt(pointer + 1)) {\n                resultStrings.add(currentString.toString());\n                currentString = new StringBuilder();\n            }\n        }\n        \n        return resultStrings;\n    }\n    \n    \n    public static String formatList(List<String> list){\n        \n        StringBuilder output = new StringBuilder();\n        \n        for (int pointer = 0; pointer < list.size(); pointer++){\n            output.append(list.get(pointer));\n            \n            if (pointer != list.size() - 1){\n                output.append(\", \");\n            }\n        }\n        \n        return output.toString();\n    }\n}\n"}
{"id": 51038, "name": "Split a character string based on change of character", "source": "Translate COBOL to Python:        identification division.\n       program-id. split-ch.\n       data division.\n       1 split-str pic x(30) value space.\n       88 str-1 value \"gHHH5YY++///\\\".\n       88 str-2 value \"gHHH5  ))YY++,,,///\\\".\n       1 binary.\n        2 ptr pic 9(4) value 1.\n        2 str-start pic 9(4) value 1.\n        2 delim-len pic 9(4) value 1.\n        2 split-str-len pic 9(4) value 0.\n        2 trash-9 pic 9(4) value 0.\n       1 delim-char pic x value space.\n       1 delim-str pic x(6) value space.\n       1 trash-x pic x.\n       procedure division.\n           display \"Requested string\"\n           set str-1 to true\n           perform split-init-and-go\n           display space\n           display \"With spaces and commas\"\n           set str-2 to true\n           perform split-init-and-go\n           stop run\n           .\n\n       split-init-and-go.\n           move 1 to ptr\n           move 0 to split-str-len\n           perform split\n           .\n\n       split.\n           perform get-split-str-len\n           display split-str (1:split-str-len)\n           perform until ptr > split-str-len\n               move ptr to str-start\n               move split-str (ptr:1) to delim-char\n               unstring split-str (1:split-str-len)\n                   delimited all delim-char\n                   into trash-x delimiter delim-str\n                   pointer ptr\n               end-unstring\n               subtract str-start from ptr giving delim-len\n               move split-str (str-start:delim-len)\n                   to delim-str (1:delim-len)\n               display delim-str (1:delim-len) with no advancing\n               if ptr <= split-str-len\n                   display \", \" with no advancing\n               end-if\n           end-perform\n           display space\n           .\n\n       get-split-str-len.\n           inspect function reverse (split-str) tallying\n               trash-9 for leading space\n               split-str-len for characters after space\n           .\n\n       end program split-ch.\n", "target": "from itertools import groupby\n\ndef splitter(text):\n    return ', '.join(''.join(group) for key, group in groupby(text))\n\nif __name__ == '__main__':\n    txt = 'gHHH5YY++///\\\\'      \n    print(f'Input: {txt}\\nSplit: {splitter(txt)}')\n"}
{"id": 51039, "name": "Split a character string based on change of character", "source": "Translate COBOL to Python:        identification division.\n       program-id. split-ch.\n       data division.\n       1 split-str pic x(30) value space.\n       88 str-1 value \"gHHH5YY++///\\\".\n       88 str-2 value \"gHHH5  ))YY++,,,///\\\".\n       1 binary.\n        2 ptr pic 9(4) value 1.\n        2 str-start pic 9(4) value 1.\n        2 delim-len pic 9(4) value 1.\n        2 split-str-len pic 9(4) value 0.\n        2 trash-9 pic 9(4) value 0.\n       1 delim-char pic x value space.\n       1 delim-str pic x(6) value space.\n       1 trash-x pic x.\n       procedure division.\n           display \"Requested string\"\n           set str-1 to true\n           perform split-init-and-go\n           display space\n           display \"With spaces and commas\"\n           set str-2 to true\n           perform split-init-and-go\n           stop run\n           .\n\n       split-init-and-go.\n           move 1 to ptr\n           move 0 to split-str-len\n           perform split\n           .\n\n       split.\n           perform get-split-str-len\n           display split-str (1:split-str-len)\n           perform until ptr > split-str-len\n               move ptr to str-start\n               move split-str (ptr:1) to delim-char\n               unstring split-str (1:split-str-len)\n                   delimited all delim-char\n                   into trash-x delimiter delim-str\n                   pointer ptr\n               end-unstring\n               subtract str-start from ptr giving delim-len\n               move split-str (str-start:delim-len)\n                   to delim-str (1:delim-len)\n               display delim-str (1:delim-len) with no advancing\n               if ptr <= split-str-len\n                   display \", \" with no advancing\n               end-if\n           end-perform\n           display space\n           .\n\n       get-split-str-len.\n           inspect function reverse (split-str) tallying\n               trash-9 for leading space\n               split-str-len for characters after space\n           .\n\n       end program split-ch.\n", "target": "from itertools import groupby\n\ndef splitter(text):\n    return ', '.join(''.join(group) for key, group in groupby(text))\n\nif __name__ == '__main__':\n    txt = 'gHHH5YY++///\\\\'      \n    print(f'Input: {txt}\\nSplit: {splitter(txt)}')\n"}
{"id": 51985, "name": "Sorting algorithms_Merge sort", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.                      MERGESORT.\n       AUTHOR.                          DAVE STRATFORD.\n       DATE-WRITTEN.                    APRIL 2010.\n       INSTALLATION.                    HEXAGON SYSTEMS LIMITED.\n      ******************************************************************\n      *                            MERGE SORT                          *\n      *  The Merge sort uses a completely different paradigm, one of   *\n      * divide and conquer, to many of the other sorts. The data set   *\n      * is split into smaller sub sets upon which are sorted and then  *\n      * merged together to form the final sorted data set.             *\n      *  This version uses the recursive method. Split the data set in *\n      * half and perform a merge sort on each half. This in turn splits*\n      * each half again and again until each set is just one or 2 items*\n      * long. A set of one item is already sorted so is ignored, a set *\n      * of two is compared and swapped as necessary. The smaller data  *\n      * sets are then repeatedly merged together to eventually form the*\n      * full, sorted, set.                                             *\n      *  Since cobol cannot do recursion this module only simulates it *\n      * so is not as fast as a normal recursive version would be.      *\n      *  Scales very well to larger data sets, its relative complexity *\n      * means it is not suited to sorting smaller data sets: use an    *\n      * Insertion sort instead as the Merge sort is a stable sort.     *\n      ******************************************************************\n\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SOURCE-COMPUTER.                 ICL VME.\n       OBJECT-COMPUTER.                 ICL VME.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT FA-INPUT-FILE  ASSIGN FL01.\n           SELECT FB-OUTPUT-FILE ASSIGN FL02.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  FA-INPUT-FILE.\n       01  FA-INPUT-REC.\n         03  FA-DATA                    PIC 9(6).\n\n       FD  FB-OUTPUT-FILE.\n       01  FB-OUTPUT-REC                PIC 9(6).\n\n       WORKING-STORAGE SECTION.\n       01  WA-IDENTITY.\n         03  WA-PROGNAME                PIC X(10) VALUE \"MERGESORT\".\n         03  WA-VERSION                 PIC X(6) VALUE \"000001\".\n\n       01  WB-TABLE.\n         03  WB-ENTRY                   PIC 9(8) COMP SYNC OCCURS 100000\n                                                 INDEXED BY WB-IX-1\n                                                            WB-IX-2.\n\n       01  WC-VARS.\n         03  WC-SIZE                    PIC S9(8) COMP SYNC.\n         03  WC-TEMP                    PIC S9(8) COMP SYNC.\n         03  WC-START                   PIC S9(8) COMP SYNC.\n         03  WC-MIDDLE                  PIC S9(8) COMP SYNC.\n         03  WC-END                     PIC S9(8) COMP SYNC.\n\n       01  WD-FIRST-HALF.\n         03  WD-FH-MAX                  PIC S9(8) COMP SYNC.\n         03  WD-ENTRY                   PIC 9(8) COMP SYNC OCCURS 50000\n                                                 INDEXED BY WD-IX.\n\n       01  WF-CONDITION-FLAGS.\n         03  WF-EOF-FLAG                PIC X.\n           88  END-OF-FILE              VALUE \"Y\".\n         03  WF-EMPTY-FILE-FLAG         PIC X.\n           88  EMPTY-FILE               VALUE \"Y\".\n\n       01  WS-STACK.\n      * This stack is big enough to sort a list of 1million items.\n         03  WS-STACK-ENTRY OCCURS 20 INDEXED BY WS-STACK-TOP.\n           05  WS-START                 PIC S9(8) COMP SYNC.\n           05  WS-MIDDLE                PIC S9(8) COMP SYNC.\n           05  WS-END                   PIC S9(8) COMP SYNC.\n           05  WS-FS-FLAG               PIC X.\n             88  FIRST-HALF             VALUE \"F\".\n             88  SECOND-HALF            VALUE \"S\".\n             88  WS-ALL                 VALUE \"A\".\n           05  WS-IO-FLAG               PIC X.\n             88  WS-IN                  VALUE \"I\".\n             88  WS-OUT                 VALUE \"O\".\n\n       PROCEDURE DIVISION.\n       A-MAIN SECTION.\n       A-000.\n           PERFORM B-INITIALISE.\n\n           IF NOT EMPTY-FILE\n              PERFORM C-PROCESS.\n\n           PERFORM D-FINISH.\n\n       A-999.\n           STOP RUN.\n\n       B-INITIALISE SECTION.\n       B-000.\n           DISPLAY \"*** \" WA-PROGNAME \" VERSION \"\n                          WA-VERSION \" STARTING ***\".\n\n           MOVE ALL \"N\" TO WF-CONDITION-FLAGS.\n           OPEN INPUT FA-INPUT-FILE.\n           SET WB-IX-1 TO 0.\n\n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG\n                                                 WF-EMPTY-FILE-FLAG.\n\n           PERFORM BA-READ-INPUT UNTIL END-OF-FILE.\n\n           CLOSE FA-INPUT-FILE.\n\n           SET WC-SIZE TO WB-IX-1.\n\n       B-999.\n           EXIT.\n\n       BA-READ-INPUT SECTION.\n       BA-000.\n           SET WB-IX-1 UP BY 1.\n           MOVE FA-DATA TO WB-ENTRY(WB-IX-1).\n\n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG.\n\n       BA-999.\n           EXIT.\n\n       C-PROCESS SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           MOVE 1           TO WS-START(1).\n           MOVE WC-SIZE     TO WS-END(1).\n           MOVE \"F\"         TO WS-FS-FLAG(1).\n           MOVE \"I\"         TO WS-IO-FLAG(1).\n           SET WS-STACK-TOP TO 2.\n\n           PERFORM E-MERGE-SORT UNTIL WS-OUT(1).\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       D-FINISH SECTION.\n       D-000.\n           OPEN OUTPUT FB-OUTPUT-FILE.\n           SET WB-IX-1 TO 1.\n\n           PERFORM DA-WRITE-OUTPUT UNTIL WB-IX-1 > WC-SIZE.\n\n           CLOSE FB-OUTPUT-FILE.\n\n           DISPLAY \"*** \" WA-PROGNAME \" FINISHED ***\".\n\n       D-999.\n           EXIT.\n\n       DA-WRITE-OUTPUT SECTION.\n       DA-000.\n           WRITE FB-OUTPUT-REC FROM WB-ENTRY(WB-IX-1).\n           SET WB-IX-1 UP BY 1.\n\n       DA-999.\n           EXIT.\n\n      ******************************************************************\n       E-MERGE-SORT SECTION.\n      *=====================                                           *\n      * This section controls the simulated recursion.                 *\n      ******************************************************************\n       E-000.\n           IF WS-OUT(WS-STACK-TOP - 1)\n              GO TO E-010. \n\n           MOVE WS-START(WS-STACK-TOP - 1) TO WC-START.\n           MOVE WS-END(WS-STACK-TOP - 1)   TO WC-END.\n\n      * First check size of part we are dealing with.\n           IF WC-END - WC-START = 0\n      * Only 1 number in range, so simply set for output, and move on\n              MOVE \"O\" TO WS-IO-FLAG(WS-STACK-TOP - 1)\n              GO TO E-010.\n\n           IF WC-END - WC-START = 1\n      * 2 numbers, so compare and swap as necessary. Set for output\n              MOVE \"O\" TO WS-IO-FLAG(WS-STACK-TOP - 1)\n              IF WB-ENTRY(WC-START) > WB-ENTRY(WC-END)\n                 MOVE WB-ENTRY(WC-START) TO WC-TEMP\n                 MOVE WB-ENTRY(WC-END) TO WB-ENTRY(WC-START)\n                 MOVE WC-TEMP TO WB-ENTRY(WC-END)\n                 GO TO E-010\n              ELSE\n                 GO TO E-010.\n\n      * More than 2, so split and carry on down\n           COMPUTE WC-MIDDLE = ( WC-START + WC-END ) / 2.\n\n           MOVE WC-START  TO WS-START(WS-STACK-TOP).\n           MOVE WC-MIDDLE TO WS-END(WS-STACK-TOP).\n           MOVE \"F\"       TO WS-FS-FLAG(WS-STACK-TOP).\n           MOVE \"I\"       TO WS-IO-FLAG(WS-STACK-TOP).\n           SET WS-STACK-TOP UP BY 1.\n\n           GO TO E-999.\n\n       E-010.\n           SET WS-STACK-TOP DOWN BY 1.\n\n           IF SECOND-HALF(WS-STACK-TOP)\n              GO TO E-020.\n\n           MOVE WS-START(WS-STACK-TOP - 1) TO WC-START.\n           MOVE WS-END(WS-STACK-TOP - 1)   TO WC-END.\n           COMPUTE WC-MIDDLE = ( WC-START + WC-END ) / 2 + 1.\n\n           MOVE WC-MIDDLE TO WS-START(WS-STACK-TOP).\n           MOVE WC-END    TO WS-END(WS-STACK-TOP).\n           MOVE \"S\"       TO WS-FS-FLAG(WS-STACK-TOP).\n           MOVE \"I\"       TO WS-IO-FLAG(WS-STACK-TOP).\n           SET WS-STACK-TOP UP BY 1.\n\n           GO TO E-999.\n\n       E-020.\n           MOVE WS-START(WS-STACK-TOP - 1) TO WC-START.\n           MOVE WS-END(WS-STACK-TOP - 1)   TO WC-END.\n           COMPUTE WC-MIDDLE = ( WC-START + WC-END ) / 2.\n           PERFORM H-PROCESS-MERGE.\n           MOVE \"O\" TO WS-IO-FLAG(WS-STACK-TOP - 1).\n\n       E-999.\n           EXIT.\n\n      ******************************************************************\n       H-PROCESS-MERGE SECTION.\n      *========================                                        *\n      * This section identifies which data is to be merged, and then   *\n      * merges the two data streams into a single larger data stream.  *\n      ******************************************************************\n       H-000.\n           INITIALISE WD-FIRST-HALF.\n           COMPUTE WD-FH-MAX = WC-MIDDLE - WC-START + 1.\n           SET WD-IX                        TO 1.\n\n           PERFORM HA-COPY-OUT VARYING WB-IX-1 FROM WC-START BY 1\n                               UNTIL WB-IX-1 > WC-MIDDLE.\n\n           SET WB-IX-1 TO WC-START.\n           SET WB-IX-2 TO WC-MIDDLE.\n           SET WB-IX-2 UP BY 1.\n           SET WD-IX   TO 1.\n          \n           PERFORM HB-MERGE UNTIL WD-IX > WD-FH-MAX OR WB-IX-2 > WC-END.\n\n           PERFORM HC-COPY-BACK UNTIL WD-IX > WD-FH-MAX.\n\n       H-999.\n           EXIT.\n\n       HA-COPY-OUT SECTION.\n       HA-000.\n           MOVE WB-ENTRY(WB-IX-1) TO WD-ENTRY(WD-IX).\n           SET WD-IX UP BY 1.\n\n       HA-999.\n           EXIT.\n\n       HB-MERGE SECTION.\n       HB-000.\n           IF WB-ENTRY(WB-IX-2) < WD-ENTRY(WD-IX)\n              MOVE WB-ENTRY(WB-IX-2) TO WB-ENTRY(WB-IX-1)\n              SET WB-IX-2            UP BY 1\n           ELSE\n              MOVE WD-ENTRY(WD-IX) TO WB-ENTRY(WB-IX-1)\n              SET WD-IX            UP BY 1.\n\n           SET WB-IX-1 UP BY 1.\n\n       HB-999.\n           EXIT.\n\n       HC-COPY-BACK SECTION.\n       HC-000.\n           MOVE WD-ENTRY(WD-IX) TO WB-ENTRY(WB-IX-1).\n           SET WD-IX            UP BY 1.\n           SET WB-IX-1          UP BY 1.\n\n       HC-999.\n           EXIT.\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Merge{\n    public static <E extends Comparable<? super E>> List<E> mergeSort(List<E> m){\n        if(m.size() <= 1) return m;\n\n        int middle = m.size() / 2;\n        List<E> left = m.subList(0, middle);\n        List<E> right = m.subList(middle, m.size());\n\n        right = mergeSort(right);\n        left = mergeSort(left);\n        List<E> result = merge(left, right);\n\n        return result;\n    }\n\n    public static <E extends Comparable<? super E>> List<E> merge(List<E> left, List<E> right){\n        List<E> result = new ArrayList<E>();\n        Iterator<E> it1 = left.iterator();\n        Iterator<E> it2 = right.iterator();\n\n\tE x = it1.next();\n\tE y = it2.next();\n        while (true){\n            \n            if(x.compareTo(y) <= 0){\n\t\tresult.add(x);\n\t\tif(it1.hasNext()){\n\t\t    x = it1.next();\n\t\t}else{\n\t\t    result.add(y);\n\t\t    while(it2.hasNext()){\n\t\t\tresult.add(it2.next());\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }else{\n\t\tresult.add(y);\n\t\tif(it2.hasNext()){\n\t\t    y = it2.next();\n\t\t}else{\n\t\t    result.add(x);\n\t\t    while (it1.hasNext()){\n\t\t\tresult.add(it1.next());\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n        }\n        return result;\n    }\n}\n"}
{"id": 51986, "name": "Sorting algorithms_Merge sort", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.                      MERGESORT.\n       AUTHOR.                          DAVE STRATFORD.\n       DATE-WRITTEN.                    APRIL 2010.\n       INSTALLATION.                    HEXAGON SYSTEMS LIMITED.\n      ******************************************************************\n      *                            MERGE SORT                          *\n      *  The Merge sort uses a completely different paradigm, one of   *\n      * divide and conquer, to many of the other sorts. The data set   *\n      * is split into smaller sub sets upon which are sorted and then  *\n      * merged together to form the final sorted data set.             *\n      *  This version uses the recursive method. Split the data set in *\n      * half and perform a merge sort on each half. This in turn splits*\n      * each half again and again until each set is just one or 2 items*\n      * long. A set of one item is already sorted so is ignored, a set *\n      * of two is compared and swapped as necessary. The smaller data  *\n      * sets are then repeatedly merged together to eventually form the*\n      * full, sorted, set.                                             *\n      *  Since cobol cannot do recursion this module only simulates it *\n      * so is not as fast as a normal recursive version would be.      *\n      *  Scales very well to larger data sets, its relative complexity *\n      * means it is not suited to sorting smaller data sets: use an    *\n      * Insertion sort instead as the Merge sort is a stable sort.     *\n      ******************************************************************\n\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SOURCE-COMPUTER.                 ICL VME.\n       OBJECT-COMPUTER.                 ICL VME.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT FA-INPUT-FILE  ASSIGN FL01.\n           SELECT FB-OUTPUT-FILE ASSIGN FL02.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  FA-INPUT-FILE.\n       01  FA-INPUT-REC.\n         03  FA-DATA                    PIC 9(6).\n\n       FD  FB-OUTPUT-FILE.\n       01  FB-OUTPUT-REC                PIC 9(6).\n\n       WORKING-STORAGE SECTION.\n       01  WA-IDENTITY.\n         03  WA-PROGNAME                PIC X(10) VALUE \"MERGESORT\".\n         03  WA-VERSION                 PIC X(6) VALUE \"000001\".\n\n       01  WB-TABLE.\n         03  WB-ENTRY                   PIC 9(8) COMP SYNC OCCURS 100000\n                                                 INDEXED BY WB-IX-1\n                                                            WB-IX-2.\n\n       01  WC-VARS.\n         03  WC-SIZE                    PIC S9(8) COMP SYNC.\n         03  WC-TEMP                    PIC S9(8) COMP SYNC.\n         03  WC-START                   PIC S9(8) COMP SYNC.\n         03  WC-MIDDLE                  PIC S9(8) COMP SYNC.\n         03  WC-END                     PIC S9(8) COMP SYNC.\n\n       01  WD-FIRST-HALF.\n         03  WD-FH-MAX                  PIC S9(8) COMP SYNC.\n         03  WD-ENTRY                   PIC 9(8) COMP SYNC OCCURS 50000\n                                                 INDEXED BY WD-IX.\n\n       01  WF-CONDITION-FLAGS.\n         03  WF-EOF-FLAG                PIC X.\n           88  END-OF-FILE              VALUE \"Y\".\n         03  WF-EMPTY-FILE-FLAG         PIC X.\n           88  EMPTY-FILE               VALUE \"Y\".\n\n       01  WS-STACK.\n      * This stack is big enough to sort a list of 1million items.\n         03  WS-STACK-ENTRY OCCURS 20 INDEXED BY WS-STACK-TOP.\n           05  WS-START                 PIC S9(8) COMP SYNC.\n           05  WS-MIDDLE                PIC S9(8) COMP SYNC.\n           05  WS-END                   PIC S9(8) COMP SYNC.\n           05  WS-FS-FLAG               PIC X.\n             88  FIRST-HALF             VALUE \"F\".\n             88  SECOND-HALF            VALUE \"S\".\n             88  WS-ALL                 VALUE \"A\".\n           05  WS-IO-FLAG               PIC X.\n             88  WS-IN                  VALUE \"I\".\n             88  WS-OUT                 VALUE \"O\".\n\n       PROCEDURE DIVISION.\n       A-MAIN SECTION.\n       A-000.\n           PERFORM B-INITIALISE.\n\n           IF NOT EMPTY-FILE\n              PERFORM C-PROCESS.\n\n           PERFORM D-FINISH.\n\n       A-999.\n           STOP RUN.\n\n       B-INITIALISE SECTION.\n       B-000.\n           DISPLAY \"*** \" WA-PROGNAME \" VERSION \"\n                          WA-VERSION \" STARTING ***\".\n\n           MOVE ALL \"N\" TO WF-CONDITION-FLAGS.\n           OPEN INPUT FA-INPUT-FILE.\n           SET WB-IX-1 TO 0.\n\n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG\n                                                 WF-EMPTY-FILE-FLAG.\n\n           PERFORM BA-READ-INPUT UNTIL END-OF-FILE.\n\n           CLOSE FA-INPUT-FILE.\n\n           SET WC-SIZE TO WB-IX-1.\n\n       B-999.\n           EXIT.\n\n       BA-READ-INPUT SECTION.\n       BA-000.\n           SET WB-IX-1 UP BY 1.\n           MOVE FA-DATA TO WB-ENTRY(WB-IX-1).\n\n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG.\n\n       BA-999.\n           EXIT.\n\n       C-PROCESS SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           MOVE 1           TO WS-START(1).\n           MOVE WC-SIZE     TO WS-END(1).\n           MOVE \"F\"         TO WS-FS-FLAG(1).\n           MOVE \"I\"         TO WS-IO-FLAG(1).\n           SET WS-STACK-TOP TO 2.\n\n           PERFORM E-MERGE-SORT UNTIL WS-OUT(1).\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       D-FINISH SECTION.\n       D-000.\n           OPEN OUTPUT FB-OUTPUT-FILE.\n           SET WB-IX-1 TO 1.\n\n           PERFORM DA-WRITE-OUTPUT UNTIL WB-IX-1 > WC-SIZE.\n\n           CLOSE FB-OUTPUT-FILE.\n\n           DISPLAY \"*** \" WA-PROGNAME \" FINISHED ***\".\n\n       D-999.\n           EXIT.\n\n       DA-WRITE-OUTPUT SECTION.\n       DA-000.\n           WRITE FB-OUTPUT-REC FROM WB-ENTRY(WB-IX-1).\n           SET WB-IX-1 UP BY 1.\n\n       DA-999.\n           EXIT.\n\n      ******************************************************************\n       E-MERGE-SORT SECTION.\n      *=====================                                           *\n      * This section controls the simulated recursion.                 *\n      ******************************************************************\n       E-000.\n           IF WS-OUT(WS-STACK-TOP - 1)\n              GO TO E-010. \n\n           MOVE WS-START(WS-STACK-TOP - 1) TO WC-START.\n           MOVE WS-END(WS-STACK-TOP - 1)   TO WC-END.\n\n      * First check size of part we are dealing with.\n           IF WC-END - WC-START = 0\n      * Only 1 number in range, so simply set for output, and move on\n              MOVE \"O\" TO WS-IO-FLAG(WS-STACK-TOP - 1)\n              GO TO E-010.\n\n           IF WC-END - WC-START = 1\n      * 2 numbers, so compare and swap as necessary. Set for output\n              MOVE \"O\" TO WS-IO-FLAG(WS-STACK-TOP - 1)\n              IF WB-ENTRY(WC-START) > WB-ENTRY(WC-END)\n                 MOVE WB-ENTRY(WC-START) TO WC-TEMP\n                 MOVE WB-ENTRY(WC-END) TO WB-ENTRY(WC-START)\n                 MOVE WC-TEMP TO WB-ENTRY(WC-END)\n                 GO TO E-010\n              ELSE\n                 GO TO E-010.\n\n      * More than 2, so split and carry on down\n           COMPUTE WC-MIDDLE = ( WC-START + WC-END ) / 2.\n\n           MOVE WC-START  TO WS-START(WS-STACK-TOP).\n           MOVE WC-MIDDLE TO WS-END(WS-STACK-TOP).\n           MOVE \"F\"       TO WS-FS-FLAG(WS-STACK-TOP).\n           MOVE \"I\"       TO WS-IO-FLAG(WS-STACK-TOP).\n           SET WS-STACK-TOP UP BY 1.\n\n           GO TO E-999.\n\n       E-010.\n           SET WS-STACK-TOP DOWN BY 1.\n\n           IF SECOND-HALF(WS-STACK-TOP)\n              GO TO E-020.\n\n           MOVE WS-START(WS-STACK-TOP - 1) TO WC-START.\n           MOVE WS-END(WS-STACK-TOP - 1)   TO WC-END.\n           COMPUTE WC-MIDDLE = ( WC-START + WC-END ) / 2 + 1.\n\n           MOVE WC-MIDDLE TO WS-START(WS-STACK-TOP).\n           MOVE WC-END    TO WS-END(WS-STACK-TOP).\n           MOVE \"S\"       TO WS-FS-FLAG(WS-STACK-TOP).\n           MOVE \"I\"       TO WS-IO-FLAG(WS-STACK-TOP).\n           SET WS-STACK-TOP UP BY 1.\n\n           GO TO E-999.\n\n       E-020.\n           MOVE WS-START(WS-STACK-TOP - 1) TO WC-START.\n           MOVE WS-END(WS-STACK-TOP - 1)   TO WC-END.\n           COMPUTE WC-MIDDLE = ( WC-START + WC-END ) / 2.\n           PERFORM H-PROCESS-MERGE.\n           MOVE \"O\" TO WS-IO-FLAG(WS-STACK-TOP - 1).\n\n       E-999.\n           EXIT.\n\n      ******************************************************************\n       H-PROCESS-MERGE SECTION.\n      *========================                                        *\n      * This section identifies which data is to be merged, and then   *\n      * merges the two data streams into a single larger data stream.  *\n      ******************************************************************\n       H-000.\n           INITIALISE WD-FIRST-HALF.\n           COMPUTE WD-FH-MAX = WC-MIDDLE - WC-START + 1.\n           SET WD-IX                        TO 1.\n\n           PERFORM HA-COPY-OUT VARYING WB-IX-1 FROM WC-START BY 1\n                               UNTIL WB-IX-1 > WC-MIDDLE.\n\n           SET WB-IX-1 TO WC-START.\n           SET WB-IX-2 TO WC-MIDDLE.\n           SET WB-IX-2 UP BY 1.\n           SET WD-IX   TO 1.\n          \n           PERFORM HB-MERGE UNTIL WD-IX > WD-FH-MAX OR WB-IX-2 > WC-END.\n\n           PERFORM HC-COPY-BACK UNTIL WD-IX > WD-FH-MAX.\n\n       H-999.\n           EXIT.\n\n       HA-COPY-OUT SECTION.\n       HA-000.\n           MOVE WB-ENTRY(WB-IX-1) TO WD-ENTRY(WD-IX).\n           SET WD-IX UP BY 1.\n\n       HA-999.\n           EXIT.\n\n       HB-MERGE SECTION.\n       HB-000.\n           IF WB-ENTRY(WB-IX-2) < WD-ENTRY(WD-IX)\n              MOVE WB-ENTRY(WB-IX-2) TO WB-ENTRY(WB-IX-1)\n              SET WB-IX-2            UP BY 1\n           ELSE\n              MOVE WD-ENTRY(WD-IX) TO WB-ENTRY(WB-IX-1)\n              SET WD-IX            UP BY 1.\n\n           SET WB-IX-1 UP BY 1.\n\n       HB-999.\n           EXIT.\n\n       HC-COPY-BACK SECTION.\n       HC-000.\n           MOVE WD-ENTRY(WD-IX) TO WB-ENTRY(WB-IX-1).\n           SET WD-IX            UP BY 1.\n           SET WB-IX-1          UP BY 1.\n\n       HC-999.\n           EXIT.\n", "target": "fun mergesort(m):\n    if m.lenght <= 1: return m\n    let middle = floor m.lenght / 2\n    let left = merge(m[:middle])\n    let right = merge(m[middle-1:]);\n\nfun merge(left, right):\n    let result = []\n    while not (left.isempty or right.isempty):\n        if left[1] <= right[1]:\n            result.push! left.shift!()\n        else:\n            result.push! right.shift!()\n    result.push! left.push! right\n\nlet arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]\nprint mergesort arr\n"}
{"id": 52671, "name": "Word frequency", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. WordFrequency.\n       AUTHOR.  Bill Gunshannon.\n       DATE-WRITTEN.  30 Jan 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Given a text file and an integer n, print the n most\n      **   common words in the file (and the number of their\n      **   occurrences) in decreasing frequency.\n      **\n      **   A file named Parameter.txt provides this information.\n      **   Format is:\n      **   12345678901234567890123456789012345678901234567890\n      **   |------------------|----|\n      **     ^^^^^^^^^^^^^^^^  ^^^^\n      **          |              |\n      **     Source Text File   Number of words with count\n      **       20 Characters      5 digits with leading zeroes\n      **\n      **\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Parameter-File ASSIGN TO \"Parameter.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Input-File ASSIGN TO Source-Text\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Word-File ASSIGN TO \"Word.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Output-File ASSIGN TO \"Output.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Print-File ASSIGN TO \"Printer.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Sort-File     ASSIGN TO DISK.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Parameter-File\n           DATA RECORD IS Parameter-Record.\n       01  Parameter-Record.\n           05 Source-Text               PIC X(20).\n           05 How-Many                  PIC 99999.\n\n       FD  Input-File\n           DATA RECORD IS Input-Record.\n       01  Input-Record.\n           05 Input-Line                PIC X(80).\n\n       FD  Word-File\n           DATA RECORD IS Word-Record.\n       01  Word-Record.\n           05 Input-Word               PIC X(20).\n\n       FD  Output-File\n           DATA RECORD IS Output-Rec.\n       01  Output-Rec.\n           05  Output-Rec-Word         PIC X(20).\n           05  Output-Rec-Word-Cnt     PIC 9(5).\n\n       FD  Print-File\n           DATA RECORD IS Print-Rec.\n       01  Print-Rec.\n           05  Print-Rec-Word          PIC X(20).\n           05  Print-Rec-Word-Cnt      PIC 9(5).\n       \n       SD  Sort-File.\n       01  Sort-Rec.\n           05  Sort-Word               PIC X(20).\n           05  Sort-Word-Cnt           PIC 9(5).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                    PIC X     VALUE 'F'.\n       01 InLine                 PIC X(80).\n       01 Word1                  PIC X(20).\n       01 Current-Word           PIC X(20).\n       01 Current-Word-Cnt       PIC 9(5).\n       01 Pos                    PIC 99\n                 VALUE 1.\n       01 Cnt                    PIC 99.\n       01 Report-Rank.\n          05  IRank              PIC 99999\n                 VALUE 1.\n          05 Rank                PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n      **\n      **  Read the Parameters\n      **\n         OPEN INPUT Parameter-File.\n         READ Parameter-File.\n         CLOSE Parameter-File.\n\n      **\n      **  Open Files for first stage\n      **\n         OPEN INPUT  Input-File.\n         OPEN OUTPUT  Word-File.\n\n      **\n      **  Pare\\se the Source Text into a file of invidual words\n      **\n         PERFORM UNTIL Eof = 'T'\n            READ Input-File \n               AT END MOVE 'T' TO Eof\n            END-READ\n\n         PERFORM Parse-a-Words\n\n         MOVE SPACES TO Input-Record\n         MOVE 1 TO Pos\n         END-PERFORM.\n     \n      **\n      **  Cleanup from the first stage\n      **\n         CLOSE Input-File Word-File\n\n      **\n      **  Sort the individual words in alphabetical order\n      **\n         SORT Sort-File\n              ON ASCENDING KEY Sort-Word\n              USING Word-File\n              GIVING Word-File.\n\n      **\n      **  Count each time a word is used\n      **\n         PERFORM Collect-Totals.\n\n      **\n      **  Sort data by number of usages per word\n      **\n         SORT Sort-File\n              ON DESCENDING KEY Sort-Word-Cnt\n              USING Output-File\n              GIVING Print-File.\n\n      **\n      **  Show the work done\n      **\n         OPEN INPUT Print-File.\n            DISPLAY \" Rank  Word               Frequency\"\n         PERFORM How-Many TIMES\n            READ Print-File\n            MOVE IRank TO Rank\n            DISPLAY Rank \"  \" Print-Rec\n            ADD 1 TO IRank\n         END-PERFORM.\n\n      **\n      **  Cleanup\n      **\n         CLOSE Print-File.\n         CALL \"C$DELETE\" USING \"Word.txt\" ,0\n         CALL \"C$DELETE\" USING \"Output.txt\" ,0\n\n         STOP RUN.\n         \n\n        Parse-a-Words.\n          INSPECT Input-Record CONVERTING '-.,\"();:/[]{}!?|' TO SPACE \n          PERFORM UNTIL Pos > FUNCTION STORED-CHAR-LENGTH(Input-Record) \n\n\n          UNSTRING Input-Record DELIMITED BY SPACE INTO Word1 \n                    WITH POINTER Pos TALLYING IN Cnt \n          MOVE FUNCTION TRIM(FUNCTION LOWER-CASE(Word1)) TO Word-Record\n          \n          IF Word-Record NOT EQUAL SPACES AND Word-Record IS ALPHABETIC\n             THEN WRITE Word-Record\n          END-IF\n\n          END-PERFORM.\n\n       Collect-Totals.\n          MOVE 'F' to Eof\n          OPEN INPUT Word-File\n          OPEN OUTPUT Output-File\n             READ Word-File\n             MOVE Input-Word TO Current-Word\n             MOVE 1 to Current-Word-Cnt\n          PERFORM UNTIL Eof = 'T'\n             READ Word-File\n                AT END MOVE 'T' TO Eof\n             END-READ\n\n             IF FUNCTION TRIM(Word-Record) \n                    EQUAL \n                           FUNCTION TRIM(Current-Word)\n                THEN\n                     ADD 1 to Current-Word-Cnt\n                ELSE\n                     MOVE Current-Word TO Output-Rec-Word\n                     MOVE Current-Word-Cnt TO Output-Rec-Word-Cnt\n                     WRITE Output-Rec\n                     MOVE 1 to Current-Word-Cnt\n                     MOVE Word-Record TO Current-Word\n                     MOVE SPACES TO Input-Record\n            END-IF \n           \n          END-PERFORM.\n          CLOSE Word-File Output-File.\n       END-PROGRAM.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace WordCount {\n    class Program {\n        static void Main(string[] args) {\n            var text = File.ReadAllText(\"135-0.txt\").ToLower();\n\n            var match = Regex.Match(text, \"\\\\w+\");\n            Dictionary<string, int> freq = new Dictionary<string, int>();\n            while (match.Success) {\n                string word = match.Value;\n                if (freq.ContainsKey(word)) {\n                    freq[word]++;\n                } else {\n                    freq.Add(word, 1);\n                }\n\n                match = match.NextMatch();\n            }\n\n            Console.WriteLine(\"Rank  Word  Frequency\");\n            Console.WriteLine(\"====  ====  =========\");\n            int rank = 1;\n            foreach (var elem in freq.OrderByDescending(a => a.Value).Take(10)) {\n                Console.WriteLine(\"{0,2}    {1,-4}    {2,5}\", rank++, elem.Key, elem.Value);\n            }\n        }\n    }\n}\n"}
{"id": 52672, "name": "Word frequency", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. WordFrequency.\n       AUTHOR.  Bill Gunshannon.\n       DATE-WRITTEN.  30 Jan 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Given a text file and an integer n, print the n most\n      **   common words in the file (and the number of their\n      **   occurrences) in decreasing frequency.\n      **\n      **   A file named Parameter.txt provides this information.\n      **   Format is:\n      **   12345678901234567890123456789012345678901234567890\n      **   |------------------|----|\n      **     ^^^^^^^^^^^^^^^^  ^^^^\n      **          |              |\n      **     Source Text File   Number of words with count\n      **       20 Characters      5 digits with leading zeroes\n      **\n      **\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Parameter-File ASSIGN TO \"Parameter.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Input-File ASSIGN TO Source-Text\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Word-File ASSIGN TO \"Word.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Output-File ASSIGN TO \"Output.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Print-File ASSIGN TO \"Printer.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Sort-File     ASSIGN TO DISK.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Parameter-File\n           DATA RECORD IS Parameter-Record.\n       01  Parameter-Record.\n           05 Source-Text               PIC X(20).\n           05 How-Many                  PIC 99999.\n\n       FD  Input-File\n           DATA RECORD IS Input-Record.\n       01  Input-Record.\n           05 Input-Line                PIC X(80).\n\n       FD  Word-File\n           DATA RECORD IS Word-Record.\n       01  Word-Record.\n           05 Input-Word               PIC X(20).\n\n       FD  Output-File\n           DATA RECORD IS Output-Rec.\n       01  Output-Rec.\n           05  Output-Rec-Word         PIC X(20).\n           05  Output-Rec-Word-Cnt     PIC 9(5).\n\n       FD  Print-File\n           DATA RECORD IS Print-Rec.\n       01  Print-Rec.\n           05  Print-Rec-Word          PIC X(20).\n           05  Print-Rec-Word-Cnt      PIC 9(5).\n       \n       SD  Sort-File.\n       01  Sort-Rec.\n           05  Sort-Word               PIC X(20).\n           05  Sort-Word-Cnt           PIC 9(5).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                    PIC X     VALUE 'F'.\n       01 InLine                 PIC X(80).\n       01 Word1                  PIC X(20).\n       01 Current-Word           PIC X(20).\n       01 Current-Word-Cnt       PIC 9(5).\n       01 Pos                    PIC 99\n                 VALUE 1.\n       01 Cnt                    PIC 99.\n       01 Report-Rank.\n          05  IRank              PIC 99999\n                 VALUE 1.\n          05 Rank                PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n      **\n      **  Read the Parameters\n      **\n         OPEN INPUT Parameter-File.\n         READ Parameter-File.\n         CLOSE Parameter-File.\n\n      **\n      **  Open Files for first stage\n      **\n         OPEN INPUT  Input-File.\n         OPEN OUTPUT  Word-File.\n\n      **\n      **  Pare\\se the Source Text into a file of invidual words\n      **\n         PERFORM UNTIL Eof = 'T'\n            READ Input-File \n               AT END MOVE 'T' TO Eof\n            END-READ\n\n         PERFORM Parse-a-Words\n\n         MOVE SPACES TO Input-Record\n         MOVE 1 TO Pos\n         END-PERFORM.\n     \n      **\n      **  Cleanup from the first stage\n      **\n         CLOSE Input-File Word-File\n\n      **\n      **  Sort the individual words in alphabetical order\n      **\n         SORT Sort-File\n              ON ASCENDING KEY Sort-Word\n              USING Word-File\n              GIVING Word-File.\n\n      **\n      **  Count each time a word is used\n      **\n         PERFORM Collect-Totals.\n\n      **\n      **  Sort data by number of usages per word\n      **\n         SORT Sort-File\n              ON DESCENDING KEY Sort-Word-Cnt\n              USING Output-File\n              GIVING Print-File.\n\n      **\n      **  Show the work done\n      **\n         OPEN INPUT Print-File.\n            DISPLAY \" Rank  Word               Frequency\"\n         PERFORM How-Many TIMES\n            READ Print-File\n            MOVE IRank TO Rank\n            DISPLAY Rank \"  \" Print-Rec\n            ADD 1 TO IRank\n         END-PERFORM.\n\n      **\n      **  Cleanup\n      **\n         CLOSE Print-File.\n         CALL \"C$DELETE\" USING \"Word.txt\" ,0\n         CALL \"C$DELETE\" USING \"Output.txt\" ,0\n\n         STOP RUN.\n         \n\n        Parse-a-Words.\n          INSPECT Input-Record CONVERTING '-.,\"();:/[]{}!?|' TO SPACE \n          PERFORM UNTIL Pos > FUNCTION STORED-CHAR-LENGTH(Input-Record) \n\n\n          UNSTRING Input-Record DELIMITED BY SPACE INTO Word1 \n                    WITH POINTER Pos TALLYING IN Cnt \n          MOVE FUNCTION TRIM(FUNCTION LOWER-CASE(Word1)) TO Word-Record\n          \n          IF Word-Record NOT EQUAL SPACES AND Word-Record IS ALPHABETIC\n             THEN WRITE Word-Record\n          END-IF\n\n          END-PERFORM.\n\n       Collect-Totals.\n          MOVE 'F' to Eof\n          OPEN INPUT Word-File\n          OPEN OUTPUT Output-File\n             READ Word-File\n             MOVE Input-Word TO Current-Word\n             MOVE 1 to Current-Word-Cnt\n          PERFORM UNTIL Eof = 'T'\n             READ Word-File\n                AT END MOVE 'T' TO Eof\n             END-READ\n\n             IF FUNCTION TRIM(Word-Record) \n                    EQUAL \n                           FUNCTION TRIM(Current-Word)\n                THEN\n                     ADD 1 to Current-Word-Cnt\n                ELSE\n                     MOVE Current-Word TO Output-Rec-Word\n                     MOVE Current-Word-Cnt TO Output-Rec-Word-Cnt\n                     WRITE Output-Rec\n                     MOVE 1 to Current-Word-Cnt\n                     MOVE Word-Record TO Current-Word\n                     MOVE SPACES TO Input-Record\n            END-IF \n           \n          END-PERFORM.\n          CLOSE Word-File Output-File.\n       END-PROGRAM.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace WordCount {\n    class Program {\n        static void Main(string[] args) {\n            var text = File.ReadAllText(\"135-0.txt\").ToLower();\n\n            var match = Regex.Match(text, \"\\\\w+\");\n            Dictionary<string, int> freq = new Dictionary<string, int>();\n            while (match.Success) {\n                string word = match.Value;\n                if (freq.ContainsKey(word)) {\n                    freq[word]++;\n                } else {\n                    freq.Add(word, 1);\n                }\n\n                match = match.NextMatch();\n            }\n\n            Console.WriteLine(\"Rank  Word  Frequency\");\n            Console.WriteLine(\"====  ====  =========\");\n            int rank = 1;\n            foreach (var elem in freq.OrderByDescending(a => a.Value).Take(10)) {\n                Console.WriteLine(\"{0,2}    {1,-4}    {2,5}\", rank++, elem.Key, elem.Value);\n            }\n        }\n    }\n}\n"}
{"id": 52675, "name": "Word frequency", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. WordFrequency.\n       AUTHOR.  Bill Gunshannon.\n       DATE-WRITTEN.  30 Jan 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Given a text file and an integer n, print the n most\n      **   common words in the file (and the number of their\n      **   occurrences) in decreasing frequency.\n      **\n      **   A file named Parameter.txt provides this information.\n      **   Format is:\n      **   12345678901234567890123456789012345678901234567890\n      **   |------------------|----|\n      **     ^^^^^^^^^^^^^^^^  ^^^^\n      **          |              |\n      **     Source Text File   Number of words with count\n      **       20 Characters      5 digits with leading zeroes\n      **\n      **\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Parameter-File ASSIGN TO \"Parameter.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Input-File ASSIGN TO Source-Text\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Word-File ASSIGN TO \"Word.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Output-File ASSIGN TO \"Output.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Print-File ASSIGN TO \"Printer.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Sort-File     ASSIGN TO DISK.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Parameter-File\n           DATA RECORD IS Parameter-Record.\n       01  Parameter-Record.\n           05 Source-Text               PIC X(20).\n           05 How-Many                  PIC 99999.\n\n       FD  Input-File\n           DATA RECORD IS Input-Record.\n       01  Input-Record.\n           05 Input-Line                PIC X(80).\n\n       FD  Word-File\n           DATA RECORD IS Word-Record.\n       01  Word-Record.\n           05 Input-Word               PIC X(20).\n\n       FD  Output-File\n           DATA RECORD IS Output-Rec.\n       01  Output-Rec.\n           05  Output-Rec-Word         PIC X(20).\n           05  Output-Rec-Word-Cnt     PIC 9(5).\n\n       FD  Print-File\n           DATA RECORD IS Print-Rec.\n       01  Print-Rec.\n           05  Print-Rec-Word          PIC X(20).\n           05  Print-Rec-Word-Cnt      PIC 9(5).\n       \n       SD  Sort-File.\n       01  Sort-Rec.\n           05  Sort-Word               PIC X(20).\n           05  Sort-Word-Cnt           PIC 9(5).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                    PIC X     VALUE 'F'.\n       01 InLine                 PIC X(80).\n       01 Word1                  PIC X(20).\n       01 Current-Word           PIC X(20).\n       01 Current-Word-Cnt       PIC 9(5).\n       01 Pos                    PIC 99\n                 VALUE 1.\n       01 Cnt                    PIC 99.\n       01 Report-Rank.\n          05  IRank              PIC 99999\n                 VALUE 1.\n          05 Rank                PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n      **\n      **  Read the Parameters\n      **\n         OPEN INPUT Parameter-File.\n         READ Parameter-File.\n         CLOSE Parameter-File.\n\n      **\n      **  Open Files for first stage\n      **\n         OPEN INPUT  Input-File.\n         OPEN OUTPUT  Word-File.\n\n      **\n      **  Pare\\se the Source Text into a file of invidual words\n      **\n         PERFORM UNTIL Eof = 'T'\n            READ Input-File \n               AT END MOVE 'T' TO Eof\n            END-READ\n\n         PERFORM Parse-a-Words\n\n         MOVE SPACES TO Input-Record\n         MOVE 1 TO Pos\n         END-PERFORM.\n     \n      **\n      **  Cleanup from the first stage\n      **\n         CLOSE Input-File Word-File\n\n      **\n      **  Sort the individual words in alphabetical order\n      **\n         SORT Sort-File\n              ON ASCENDING KEY Sort-Word\n              USING Word-File\n              GIVING Word-File.\n\n      **\n      **  Count each time a word is used\n      **\n         PERFORM Collect-Totals.\n\n      **\n      **  Sort data by number of usages per word\n      **\n         SORT Sort-File\n              ON DESCENDING KEY Sort-Word-Cnt\n              USING Output-File\n              GIVING Print-File.\n\n      **\n      **  Show the work done\n      **\n         OPEN INPUT Print-File.\n            DISPLAY \" Rank  Word               Frequency\"\n         PERFORM How-Many TIMES\n            READ Print-File\n            MOVE IRank TO Rank\n            DISPLAY Rank \"  \" Print-Rec\n            ADD 1 TO IRank\n         END-PERFORM.\n\n      **\n      **  Cleanup\n      **\n         CLOSE Print-File.\n         CALL \"C$DELETE\" USING \"Word.txt\" ,0\n         CALL \"C$DELETE\" USING \"Output.txt\" ,0\n\n         STOP RUN.\n         \n\n        Parse-a-Words.\n          INSPECT Input-Record CONVERTING '-.,\"();:/[]{}!?|' TO SPACE \n          PERFORM UNTIL Pos > FUNCTION STORED-CHAR-LENGTH(Input-Record) \n\n\n          UNSTRING Input-Record DELIMITED BY SPACE INTO Word1 \n                    WITH POINTER Pos TALLYING IN Cnt \n          MOVE FUNCTION TRIM(FUNCTION LOWER-CASE(Word1)) TO Word-Record\n          \n          IF Word-Record NOT EQUAL SPACES AND Word-Record IS ALPHABETIC\n             THEN WRITE Word-Record\n          END-IF\n\n          END-PERFORM.\n\n       Collect-Totals.\n          MOVE 'F' to Eof\n          OPEN INPUT Word-File\n          OPEN OUTPUT Output-File\n             READ Word-File\n             MOVE Input-Word TO Current-Word\n             MOVE 1 to Current-Word-Cnt\n          PERFORM UNTIL Eof = 'T'\n             READ Word-File\n                AT END MOVE 'T' TO Eof\n             END-READ\n\n             IF FUNCTION TRIM(Word-Record) \n                    EQUAL \n                           FUNCTION TRIM(Current-Word)\n                THEN\n                     ADD 1 to Current-Word-Cnt\n                ELSE\n                     MOVE Current-Word TO Output-Rec-Word\n                     MOVE Current-Word-Cnt TO Output-Rec-Word-Cnt\n                     WRITE Output-Rec\n                     MOVE 1 to Current-Word-Cnt\n                     MOVE Word-Record TO Current-Word\n                     MOVE SPACES TO Input-Record\n            END-IF \n           \n          END-PERFORM.\n          CLOSE Word-File Output-File.\n       END-PROGRAM.\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class WordCount {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"135-0.txt\");\n        byte[] bytes = Files.readAllBytes(path);\n        String text = new String(bytes);\n        text = text.toLowerCase();\n\n        Pattern r = Pattern.compile(\"\\\\p{javaLowerCase}+\");\n        Matcher matcher = r.matcher(text);\n        Map<String, Integer> freq = new HashMap<>();\n        while (matcher.find()) {\n            String word = matcher.group();\n            Integer current = freq.getOrDefault(word, 0);\n            freq.put(word, current + 1);\n        }\n\n        List<Map.Entry<String, Integer>> entries = freq.entrySet()\n            .stream()\n            .sorted((i1, i2) -> Integer.compare(i2.getValue(), i1.getValue()))\n            .limit(10)\n            .collect(Collectors.toList());\n\n        System.out.println(\"Rank  Word  Frequency\");\n        System.out.println(\"====  ====  =========\");\n        int rank = 1;\n        for (Map.Entry<String, Integer> entry : entries) {\n            String word = entry.getKey();\n            Integer count = entry.getValue();\n            System.out.printf(\"%2d   \u00a0%-4s    %5d\\n\", rank++, word, count);\n        }\n    }\n}\n"}
{"id": 52676, "name": "Word frequency", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. WordFrequency.\n       AUTHOR.  Bill Gunshannon.\n       DATE-WRITTEN.  30 Jan 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Given a text file and an integer n, print the n most\n      **   common words in the file (and the number of their\n      **   occurrences) in decreasing frequency.\n      **\n      **   A file named Parameter.txt provides this information.\n      **   Format is:\n      **   12345678901234567890123456789012345678901234567890\n      **   |------------------|----|\n      **     ^^^^^^^^^^^^^^^^  ^^^^\n      **          |              |\n      **     Source Text File   Number of words with count\n      **       20 Characters      5 digits with leading zeroes\n      **\n      **\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Parameter-File ASSIGN TO \"Parameter.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Input-File ASSIGN TO Source-Text\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Word-File ASSIGN TO \"Word.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Output-File ASSIGN TO \"Output.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Print-File ASSIGN TO \"Printer.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Sort-File     ASSIGN TO DISK.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Parameter-File\n           DATA RECORD IS Parameter-Record.\n       01  Parameter-Record.\n           05 Source-Text               PIC X(20).\n           05 How-Many                  PIC 99999.\n\n       FD  Input-File\n           DATA RECORD IS Input-Record.\n       01  Input-Record.\n           05 Input-Line                PIC X(80).\n\n       FD  Word-File\n           DATA RECORD IS Word-Record.\n       01  Word-Record.\n           05 Input-Word               PIC X(20).\n\n       FD  Output-File\n           DATA RECORD IS Output-Rec.\n       01  Output-Rec.\n           05  Output-Rec-Word         PIC X(20).\n           05  Output-Rec-Word-Cnt     PIC 9(5).\n\n       FD  Print-File\n           DATA RECORD IS Print-Rec.\n       01  Print-Rec.\n           05  Print-Rec-Word          PIC X(20).\n           05  Print-Rec-Word-Cnt      PIC 9(5).\n       \n       SD  Sort-File.\n       01  Sort-Rec.\n           05  Sort-Word               PIC X(20).\n           05  Sort-Word-Cnt           PIC 9(5).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                    PIC X     VALUE 'F'.\n       01 InLine                 PIC X(80).\n       01 Word1                  PIC X(20).\n       01 Current-Word           PIC X(20).\n       01 Current-Word-Cnt       PIC 9(5).\n       01 Pos                    PIC 99\n                 VALUE 1.\n       01 Cnt                    PIC 99.\n       01 Report-Rank.\n          05  IRank              PIC 99999\n                 VALUE 1.\n          05 Rank                PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n      **\n      **  Read the Parameters\n      **\n         OPEN INPUT Parameter-File.\n         READ Parameter-File.\n         CLOSE Parameter-File.\n\n      **\n      **  Open Files for first stage\n      **\n         OPEN INPUT  Input-File.\n         OPEN OUTPUT  Word-File.\n\n      **\n      **  Pare\\se the Source Text into a file of invidual words\n      **\n         PERFORM UNTIL Eof = 'T'\n            READ Input-File \n               AT END MOVE 'T' TO Eof\n            END-READ\n\n         PERFORM Parse-a-Words\n\n         MOVE SPACES TO Input-Record\n         MOVE 1 TO Pos\n         END-PERFORM.\n     \n      **\n      **  Cleanup from the first stage\n      **\n         CLOSE Input-File Word-File\n\n      **\n      **  Sort the individual words in alphabetical order\n      **\n         SORT Sort-File\n              ON ASCENDING KEY Sort-Word\n              USING Word-File\n              GIVING Word-File.\n\n      **\n      **  Count each time a word is used\n      **\n         PERFORM Collect-Totals.\n\n      **\n      **  Sort data by number of usages per word\n      **\n         SORT Sort-File\n              ON DESCENDING KEY Sort-Word-Cnt\n              USING Output-File\n              GIVING Print-File.\n\n      **\n      **  Show the work done\n      **\n         OPEN INPUT Print-File.\n            DISPLAY \" Rank  Word               Frequency\"\n         PERFORM How-Many TIMES\n            READ Print-File\n            MOVE IRank TO Rank\n            DISPLAY Rank \"  \" Print-Rec\n            ADD 1 TO IRank\n         END-PERFORM.\n\n      **\n      **  Cleanup\n      **\n         CLOSE Print-File.\n         CALL \"C$DELETE\" USING \"Word.txt\" ,0\n         CALL \"C$DELETE\" USING \"Output.txt\" ,0\n\n         STOP RUN.\n         \n\n        Parse-a-Words.\n          INSPECT Input-Record CONVERTING '-.,\"();:/[]{}!?|' TO SPACE \n          PERFORM UNTIL Pos > FUNCTION STORED-CHAR-LENGTH(Input-Record) \n\n\n          UNSTRING Input-Record DELIMITED BY SPACE INTO Word1 \n                    WITH POINTER Pos TALLYING IN Cnt \n          MOVE FUNCTION TRIM(FUNCTION LOWER-CASE(Word1)) TO Word-Record\n          \n          IF Word-Record NOT EQUAL SPACES AND Word-Record IS ALPHABETIC\n             THEN WRITE Word-Record\n          END-IF\n\n          END-PERFORM.\n\n       Collect-Totals.\n          MOVE 'F' to Eof\n          OPEN INPUT Word-File\n          OPEN OUTPUT Output-File\n             READ Word-File\n             MOVE Input-Word TO Current-Word\n             MOVE 1 to Current-Word-Cnt\n          PERFORM UNTIL Eof = 'T'\n             READ Word-File\n                AT END MOVE 'T' TO Eof\n             END-READ\n\n             IF FUNCTION TRIM(Word-Record) \n                    EQUAL \n                           FUNCTION TRIM(Current-Word)\n                THEN\n                     ADD 1 to Current-Word-Cnt\n                ELSE\n                     MOVE Current-Word TO Output-Rec-Word\n                     MOVE Current-Word-Cnt TO Output-Rec-Word-Cnt\n                     WRITE Output-Rec\n                     MOVE 1 to Current-Word-Cnt\n                     MOVE Word-Record TO Current-Word\n                     MOVE SPACES TO Input-Record\n            END-IF \n           \n          END-PERFORM.\n          CLOSE Word-File Output-File.\n       END-PROGRAM.\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class WordCount {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"135-0.txt\");\n        byte[] bytes = Files.readAllBytes(path);\n        String text = new String(bytes);\n        text = text.toLowerCase();\n\n        Pattern r = Pattern.compile(\"\\\\p{javaLowerCase}+\");\n        Matcher matcher = r.matcher(text);\n        Map<String, Integer> freq = new HashMap<>();\n        while (matcher.find()) {\n            String word = matcher.group();\n            Integer current = freq.getOrDefault(word, 0);\n            freq.put(word, current + 1);\n        }\n\n        List<Map.Entry<String, Integer>> entries = freq.entrySet()\n            .stream()\n            .sorted((i1, i2) -> Integer.compare(i2.getValue(), i1.getValue()))\n            .limit(10)\n            .collect(Collectors.toList());\n\n        System.out.println(\"Rank  Word  Frequency\");\n        System.out.println(\"====  ====  =========\");\n        int rank = 1;\n        for (Map.Entry<String, Integer> entry : entries) {\n            String word = entry.getKey();\n            Integer count = entry.getValue();\n            System.out.printf(\"%2d   \u00a0%-4s    %5d\\n\", rank++, word, count);\n        }\n    }\n}\n"}
{"id": 52677, "name": "Word frequency", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. WordFrequency.\n       AUTHOR.  Bill Gunshannon.\n       DATE-WRITTEN.  30 Jan 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Given a text file and an integer n, print the n most\n      **   common words in the file (and the number of their\n      **   occurrences) in decreasing frequency.\n      **\n      **   A file named Parameter.txt provides this information.\n      **   Format is:\n      **   12345678901234567890123456789012345678901234567890\n      **   |------------------|----|\n      **     ^^^^^^^^^^^^^^^^  ^^^^\n      **          |              |\n      **     Source Text File   Number of words with count\n      **       20 Characters      5 digits with leading zeroes\n      **\n      **\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Parameter-File ASSIGN TO \"Parameter.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Input-File ASSIGN TO Source-Text\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Word-File ASSIGN TO \"Word.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Output-File ASSIGN TO \"Output.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Print-File ASSIGN TO \"Printer.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Sort-File     ASSIGN TO DISK.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Parameter-File\n           DATA RECORD IS Parameter-Record.\n       01  Parameter-Record.\n           05 Source-Text               PIC X(20).\n           05 How-Many                  PIC 99999.\n\n       FD  Input-File\n           DATA RECORD IS Input-Record.\n       01  Input-Record.\n           05 Input-Line                PIC X(80).\n\n       FD  Word-File\n           DATA RECORD IS Word-Record.\n       01  Word-Record.\n           05 Input-Word               PIC X(20).\n\n       FD  Output-File\n           DATA RECORD IS Output-Rec.\n       01  Output-Rec.\n           05  Output-Rec-Word         PIC X(20).\n           05  Output-Rec-Word-Cnt     PIC 9(5).\n\n       FD  Print-File\n           DATA RECORD IS Print-Rec.\n       01  Print-Rec.\n           05  Print-Rec-Word          PIC X(20).\n           05  Print-Rec-Word-Cnt      PIC 9(5).\n       \n       SD  Sort-File.\n       01  Sort-Rec.\n           05  Sort-Word               PIC X(20).\n           05  Sort-Word-Cnt           PIC 9(5).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                    PIC X     VALUE 'F'.\n       01 InLine                 PIC X(80).\n       01 Word1                  PIC X(20).\n       01 Current-Word           PIC X(20).\n       01 Current-Word-Cnt       PIC 9(5).\n       01 Pos                    PIC 99\n                 VALUE 1.\n       01 Cnt                    PIC 99.\n       01 Report-Rank.\n          05  IRank              PIC 99999\n                 VALUE 1.\n          05 Rank                PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n      **\n      **  Read the Parameters\n      **\n         OPEN INPUT Parameter-File.\n         READ Parameter-File.\n         CLOSE Parameter-File.\n\n      **\n      **  Open Files for first stage\n      **\n         OPEN INPUT  Input-File.\n         OPEN OUTPUT  Word-File.\n\n      **\n      **  Pare\\se the Source Text into a file of invidual words\n      **\n         PERFORM UNTIL Eof = 'T'\n            READ Input-File \n               AT END MOVE 'T' TO Eof\n            END-READ\n\n         PERFORM Parse-a-Words\n\n         MOVE SPACES TO Input-Record\n         MOVE 1 TO Pos\n         END-PERFORM.\n     \n      **\n      **  Cleanup from the first stage\n      **\n         CLOSE Input-File Word-File\n\n      **\n      **  Sort the individual words in alphabetical order\n      **\n         SORT Sort-File\n              ON ASCENDING KEY Sort-Word\n              USING Word-File\n              GIVING Word-File.\n\n      **\n      **  Count each time a word is used\n      **\n         PERFORM Collect-Totals.\n\n      **\n      **  Sort data by number of usages per word\n      **\n         SORT Sort-File\n              ON DESCENDING KEY Sort-Word-Cnt\n              USING Output-File\n              GIVING Print-File.\n\n      **\n      **  Show the work done\n      **\n         OPEN INPUT Print-File.\n            DISPLAY \" Rank  Word               Frequency\"\n         PERFORM How-Many TIMES\n            READ Print-File\n            MOVE IRank TO Rank\n            DISPLAY Rank \"  \" Print-Rec\n            ADD 1 TO IRank\n         END-PERFORM.\n\n      **\n      **  Cleanup\n      **\n         CLOSE Print-File.\n         CALL \"C$DELETE\" USING \"Word.txt\" ,0\n         CALL \"C$DELETE\" USING \"Output.txt\" ,0\n\n         STOP RUN.\n         \n\n        Parse-a-Words.\n          INSPECT Input-Record CONVERTING '-.,\"();:/[]{}!?|' TO SPACE \n          PERFORM UNTIL Pos > FUNCTION STORED-CHAR-LENGTH(Input-Record) \n\n\n          UNSTRING Input-Record DELIMITED BY SPACE INTO Word1 \n                    WITH POINTER Pos TALLYING IN Cnt \n          MOVE FUNCTION TRIM(FUNCTION LOWER-CASE(Word1)) TO Word-Record\n          \n          IF Word-Record NOT EQUAL SPACES AND Word-Record IS ALPHABETIC\n             THEN WRITE Word-Record\n          END-IF\n\n          END-PERFORM.\n\n       Collect-Totals.\n          MOVE 'F' to Eof\n          OPEN INPUT Word-File\n          OPEN OUTPUT Output-File\n             READ Word-File\n             MOVE Input-Word TO Current-Word\n             MOVE 1 to Current-Word-Cnt\n          PERFORM UNTIL Eof = 'T'\n             READ Word-File\n                AT END MOVE 'T' TO Eof\n             END-READ\n\n             IF FUNCTION TRIM(Word-Record) \n                    EQUAL \n                           FUNCTION TRIM(Current-Word)\n                THEN\n                     ADD 1 to Current-Word-Cnt\n                ELSE\n                     MOVE Current-Word TO Output-Rec-Word\n                     MOVE Current-Word-Cnt TO Output-Rec-Word-Cnt\n                     WRITE Output-Rec\n                     MOVE 1 to Current-Word-Cnt\n                     MOVE Word-Record TO Current-Word\n                     MOVE SPACES TO Input-Record\n            END-IF \n           \n          END-PERFORM.\n          CLOSE Word-File Output-File.\n       END-PROGRAM.\n", "target": "import collections\nimport re\nimport string\nimport sys\n\ndef main():\n  counter = collections.Counter(re.findall(r\"\\w+\",open(sys.argv[1]).read().lower()))\n  print counter.most_common(int(sys.argv[2]))\n\nif __name__ == \"__main__\":\n  main()\n"}
{"id": 52678, "name": "Word frequency", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. WordFrequency.\n       AUTHOR.  Bill Gunshannon.\n       DATE-WRITTEN.  30 Jan 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Given a text file and an integer n, print the n most\n      **   common words in the file (and the number of their\n      **   occurrences) in decreasing frequency.\n      **\n      **   A file named Parameter.txt provides this information.\n      **   Format is:\n      **   12345678901234567890123456789012345678901234567890\n      **   |------------------|----|\n      **     ^^^^^^^^^^^^^^^^  ^^^^\n      **          |              |\n      **     Source Text File   Number of words with count\n      **       20 Characters      5 digits with leading zeroes\n      **\n      **\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Parameter-File ASSIGN TO \"Parameter.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Input-File ASSIGN TO Source-Text\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Word-File ASSIGN TO \"Word.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Output-File ASSIGN TO \"Output.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Print-File ASSIGN TO \"Printer.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Sort-File     ASSIGN TO DISK.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Parameter-File\n           DATA RECORD IS Parameter-Record.\n       01  Parameter-Record.\n           05 Source-Text               PIC X(20).\n           05 How-Many                  PIC 99999.\n\n       FD  Input-File\n           DATA RECORD IS Input-Record.\n       01  Input-Record.\n           05 Input-Line                PIC X(80).\n\n       FD  Word-File\n           DATA RECORD IS Word-Record.\n       01  Word-Record.\n           05 Input-Word               PIC X(20).\n\n       FD  Output-File\n           DATA RECORD IS Output-Rec.\n       01  Output-Rec.\n           05  Output-Rec-Word         PIC X(20).\n           05  Output-Rec-Word-Cnt     PIC 9(5).\n\n       FD  Print-File\n           DATA RECORD IS Print-Rec.\n       01  Print-Rec.\n           05  Print-Rec-Word          PIC X(20).\n           05  Print-Rec-Word-Cnt      PIC 9(5).\n       \n       SD  Sort-File.\n       01  Sort-Rec.\n           05  Sort-Word               PIC X(20).\n           05  Sort-Word-Cnt           PIC 9(5).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                    PIC X     VALUE 'F'.\n       01 InLine                 PIC X(80).\n       01 Word1                  PIC X(20).\n       01 Current-Word           PIC X(20).\n       01 Current-Word-Cnt       PIC 9(5).\n       01 Pos                    PIC 99\n                 VALUE 1.\n       01 Cnt                    PIC 99.\n       01 Report-Rank.\n          05  IRank              PIC 99999\n                 VALUE 1.\n          05 Rank                PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n      **\n      **  Read the Parameters\n      **\n         OPEN INPUT Parameter-File.\n         READ Parameter-File.\n         CLOSE Parameter-File.\n\n      **\n      **  Open Files for first stage\n      **\n         OPEN INPUT  Input-File.\n         OPEN OUTPUT  Word-File.\n\n      **\n      **  Pare\\se the Source Text into a file of invidual words\n      **\n         PERFORM UNTIL Eof = 'T'\n            READ Input-File \n               AT END MOVE 'T' TO Eof\n            END-READ\n\n         PERFORM Parse-a-Words\n\n         MOVE SPACES TO Input-Record\n         MOVE 1 TO Pos\n         END-PERFORM.\n     \n      **\n      **  Cleanup from the first stage\n      **\n         CLOSE Input-File Word-File\n\n      **\n      **  Sort the individual words in alphabetical order\n      **\n         SORT Sort-File\n              ON ASCENDING KEY Sort-Word\n              USING Word-File\n              GIVING Word-File.\n\n      **\n      **  Count each time a word is used\n      **\n         PERFORM Collect-Totals.\n\n      **\n      **  Sort data by number of usages per word\n      **\n         SORT Sort-File\n              ON DESCENDING KEY Sort-Word-Cnt\n              USING Output-File\n              GIVING Print-File.\n\n      **\n      **  Show the work done\n      **\n         OPEN INPUT Print-File.\n            DISPLAY \" Rank  Word               Frequency\"\n         PERFORM How-Many TIMES\n            READ Print-File\n            MOVE IRank TO Rank\n            DISPLAY Rank \"  \" Print-Rec\n            ADD 1 TO IRank\n         END-PERFORM.\n\n      **\n      **  Cleanup\n      **\n         CLOSE Print-File.\n         CALL \"C$DELETE\" USING \"Word.txt\" ,0\n         CALL \"C$DELETE\" USING \"Output.txt\" ,0\n\n         STOP RUN.\n         \n\n        Parse-a-Words.\n          INSPECT Input-Record CONVERTING '-.,\"();:/[]{}!?|' TO SPACE \n          PERFORM UNTIL Pos > FUNCTION STORED-CHAR-LENGTH(Input-Record) \n\n\n          UNSTRING Input-Record DELIMITED BY SPACE INTO Word1 \n                    WITH POINTER Pos TALLYING IN Cnt \n          MOVE FUNCTION TRIM(FUNCTION LOWER-CASE(Word1)) TO Word-Record\n          \n          IF Word-Record NOT EQUAL SPACES AND Word-Record IS ALPHABETIC\n             THEN WRITE Word-Record\n          END-IF\n\n          END-PERFORM.\n\n       Collect-Totals.\n          MOVE 'F' to Eof\n          OPEN INPUT Word-File\n          OPEN OUTPUT Output-File\n             READ Word-File\n             MOVE Input-Word TO Current-Word\n             MOVE 1 to Current-Word-Cnt\n          PERFORM UNTIL Eof = 'T'\n             READ Word-File\n                AT END MOVE 'T' TO Eof\n             END-READ\n\n             IF FUNCTION TRIM(Word-Record) \n                    EQUAL \n                           FUNCTION TRIM(Current-Word)\n                THEN\n                     ADD 1 to Current-Word-Cnt\n                ELSE\n                     MOVE Current-Word TO Output-Rec-Word\n                     MOVE Current-Word-Cnt TO Output-Rec-Word-Cnt\n                     WRITE Output-Rec\n                     MOVE 1 to Current-Word-Cnt\n                     MOVE Word-Record TO Current-Word\n                     MOVE SPACES TO Input-Record\n            END-IF \n           \n          END-PERFORM.\n          CLOSE Word-File Output-File.\n       END-PROGRAM.\n", "target": "import collections\nimport re\nimport string\nimport sys\n\ndef main():\n  counter = collections.Counter(re.findall(r\"\\w+\",open(sys.argv[1]).read().lower()))\n  print counter.most_common(int(sys.argv[2]))\n\nif __name__ == \"__main__\":\n  main()\n"}
{"id": 53472, "name": "Pick random element", "source": "Translate COBOL to C#:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. random-element.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  nums-area                           VALUE \"123456789\".\n    03  nums                            PIC 9 OCCURS 9 TIMES.\n    \n01  random-idx                          PIC 9 COMP.\n    \nPROCEDURE DIVISION.\n    COMPUTE random-idx = FUNCTION RANDOM(FUNCTION CURRENT-DATE (9:7)) * 9 + 1\n    DISPLAY nums (random-idx)\n    .\nEND PROGRAM random-element.\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass RandomElementPicker {\n  static void Main() {\n    var list = new List<int>(new[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n    var rng = new Random();\n    var randomElement = list[rng.Next(list.Count)];\n    Console.WriteLine(\"I picked element {0}\", randomElement);\n  }\n}\n"}
{"id": 53474, "name": "Pick random element", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. random-element.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  nums-area                           VALUE \"123456789\".\n    03  nums                            PIC 9 OCCURS 9 TIMES.\n    \n01  random-idx                          PIC 9 COMP.\n    \nPROCEDURE DIVISION.\n    COMPUTE random-idx = FUNCTION RANDOM(FUNCTION CURRENT-DATE (9:7)) * 9 + 1\n    DISPLAY nums (random-idx)\n    .\nEND PROGRAM random-element.\n", "target": "import java.util.Random;\n...\nint[] array = {1,2,3};\nreturn array[new Random().nextInt(array.length)]; \n"}
{"id": 53475, "name": "Pick random element", "source": "Translate COBOL to Python:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. random-element.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  nums-area                           VALUE \"123456789\".\n    03  nums                            PIC 9 OCCURS 9 TIMES.\n    \n01  random-idx                          PIC 9 COMP.\n    \nPROCEDURE DIVISION.\n    COMPUTE random-idx = FUNCTION RANDOM(FUNCTION CURRENT-DATE (9:7)) * 9 + 1\n    DISPLAY nums (random-idx)\n    .\nEND PROGRAM random-element.\n", "target": ">>> import random\n>>> random.choice(['foo', 'bar', 'baz'])\n'baz'\n"}
{"id": 54005, "name": "Greatest element of a list", "source": "Translate COBOL to C#: DISPLAY FUNCTION MAX(nums (ALL))\n", "target": "int[] values = new int[] {1,2,3,4,5,6,7,8,9,10};\n\nint max = values.Max();\n"}
{"id": 54007, "name": "Greatest element of a list", "source": "Translate COBOL to Java: DISPLAY FUNCTION MAX(nums (ALL))\n", "target": "public static float max(float[] values) throws NoSuchElementException {\n    if (values.length == 0)\n        throw new NoSuchElementException();\n    float themax = values[0];\n    for (int idx = 1; idx < values.length; ++idx) {\n        if (values[idx] > themax)\n            themax = values[idx];\n    }\n    return themax;\n}\n"}
{"id": 54671, "name": "Binary digits", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. SAMPLE.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n         01 binary_number   pic X(21).\n         01 str             pic X(21).\n         01 binary_digit    pic X.\n         01 digit           pic 9.\n         01 n               pic 9(7).\n         01 nstr            pic X(7).\n\n       PROCEDURE DIVISION.\n         accept nstr\n         move nstr to n\n         perform until n equal 0\n           divide n by 2 giving n remainder digit\n           move digit to binary_digit\n           string binary_digit  DELIMITED BY SIZE\n                  binary_number DELIMITED BY SPACE\n                  into str\n           move str to binary_number\n         end-perform.\n         display binary_number\n         stop run.\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        foreach (var number in new[] { 5, 50, 9000 })\n        {\n            Console.WriteLine(Convert.ToString(number, 2));\n        }\n    }\n}\n"}
{"id": 54673, "name": "Binary digits", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. SAMPLE.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n         01 binary_number   pic X(21).\n         01 str             pic X(21).\n         01 binary_digit    pic X.\n         01 digit           pic 9.\n         01 n               pic 9(7).\n         01 nstr            pic X(7).\n\n       PROCEDURE DIVISION.\n         accept nstr\n         move nstr to n\n         perform until n equal 0\n           divide n by 2 giving n remainder digit\n           move digit to binary_digit\n           string binary_digit  DELIMITED BY SIZE\n                  binary_number DELIMITED BY SPACE\n                  into str\n           move str to binary_number\n         end-perform.\n         display binary_number\n         stop run.\n", "target": "module BinaryDigits\n    {\n    @Inject Console console;\n    void run()\n        {\n        Int[] tests = [0, 1, 5, 50, 9000];\n\n        Int longestInt = tests.map(n -> n.estimateStringLength()).reduce(0, (max, len) -> max.maxOf(len));\n        Int longestBin = tests.map(n -> (64-n.leadingZeroCount).maxOf(1)).reduce(0, (max, len) -> max.maxOf(len));\n\n        function String(Int) num = n ->\n            {\n            Int indent = longestInt - n.estimateStringLength();\n            return $\"{' ' * indent}{n}\";\n            };\n\n        function String(Int) bin = n ->\n            {\n            Int index  = n.leadingZeroCount.minOf(63);\n            Int indent = index - (64 - longestBin);\n            val bits   = n.toBitArray()[index ..< 64];\n            return $\"{' ' * indent}{bits.toString().substring(2)}\";\n            };\n\n        for (Int test : tests)\n            {\n            console.print($\"The decimal value {num(test)} should produce an output of {bin(test)}\");\n            }\n        }\n    }\n"}
{"id": 54674, "name": "Binary digits", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. SAMPLE.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n         01 binary_number   pic X(21).\n         01 str             pic X(21).\n         01 binary_digit    pic X.\n         01 digit           pic 9.\n         01 n               pic 9(7).\n         01 nstr            pic X(7).\n\n       PROCEDURE DIVISION.\n         accept nstr\n         move nstr to n\n         perform until n equal 0\n           divide n by 2 giving n remainder digit\n           move digit to binary_digit\n           string binary_digit  DELIMITED BY SIZE\n                  binary_number DELIMITED BY SPACE\n                  into str\n           move str to binary_number\n         end-perform.\n         display binary_number\n         stop run.\n", "target": ">>> for i in range(16): print('{0:b}'.format(i))\n\n0\n1\n10\n11\n100\n101\n110\n111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n"}
{"id": 55292, "name": "Create an HTML table", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Table.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  1 January 2022.\n      ************************************************************\n      ** Program Abstract:\n      **   Data values are hardcoded in this example but they\n      **     could come from anywhere.  Computed, read from a\n      **     file, input from the keyboard.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Table-File ASSIGN TO \"index.html\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Table-File\n           DATA RECORD IS Table-Record.\n       01  Table-Record.\n           05 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Table-Data.\n           05  Line3.\n               10  Line3-Value1  PIC S9(4)  VALUE  1234.\n               10  Line3-Value2  PIC S9(4)  VALUE  23.\n               10  Line3-Value3  PIC S9(4)  VALUE  -123.\n           05  Line4.\n               10  Line4-Value1  PIC S9(4)  VALUE  123.\n               10  Line4-Value2  PIC S9(4)  VALUE  12.\n               10  Line4-Value3  PIC S9(4)  VALUE  -1234.\n           05  Line5.\n               10  Line5-Value1  PIC S9(4)  VALUE  567.\n               10  Line5-Value2  PIC S9(4)  VALUE  6789.\n               10  Line5-Value3  PIC S9(4)  VALUE  3.\n\n       \n       01  Table-HTML.\n           05  Line1  PIC X(16)  VALUE\n               \"<table border=1>\".\n           05  Line2  PIC X(40)  VALUE\n               \"<th></th><th>X</th><th>Y</th><th>Z</th>\".\n           05  Line3.\n               10  Line3-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>1</th><td>\".\n               10  Line3-Value1   PIC -ZZZ9.\n               10  Line3-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value2   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value3   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line4.\n               10  Line4-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>2</th><td>\".\n               10  Line4-Value1   PIC -ZZZ9.\n               10  Line4-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value2   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value3   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line5.\n               10  Line5-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>3</th><td>\".\n               10  Line5-Value1   PIC -ZZZ9.\n               10  Line5-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value2   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value3   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line6  PIC X(8)  VALUE\n               \"</table>\".\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT Table-File.\n           MOVE CORRESPONDING Table-Data TO Table-HTML.\n           PERFORM Write-Table.\n           CLOSE Table-File.\n           STOP RUN.\n       \n       \n       Write-Table.\n           WRITE Table-Record FROM Line1 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line2 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line3 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line4 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line5 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line6 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n          \n       \n       END-PROGRAM.\n", "target": "using System;\nusing System.Text;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\tRandom rnd = new Random();\n\t\t\t\n\t\t\ts.AppendLine(\"<table>\");\n\t\t\ts.AppendLine(\"<thead align = \\\"right\\\">\");\n\t\t\ts.Append(\"<tr><th></th>\");\n\t\t\tfor(int i=0; i<3; i++)\n\t\t\t\ts.Append(\"<td>\" + \"XYZ\"[i] + \"</td>\");\n\t\t\ts.AppendLine(\"</tr>\");\n\t\t\ts.AppendLine(\"</thead>\");\n\t\t\ts.AppendLine(\"<tbody align = \\\"right\\\">\");\n\t\t\tfor( int i=0; i<3; i++ )\n\t\t\t{\n\t\t\t\ts.Append(\"<tr><td>\"+i+\"</td>\");\n\t\t\t\tfor( int j=0; j<3; j++ )\n\t\t\t\t\ts.Append(\"<td>\"+rnd.Next(10000)+\"</td>\");\t\t\t\t\n\t\t\t\ts.AppendLine(\"</tr>\");\n\t\t\t}\n\t\t\ts.AppendLine(\"</tbody>\");\n\t\t\ts.AppendLine(\"</table>\");\n\t\t\t\n\t\t\tConsole.WriteLine( s );\n\t\t}\n\t}\n}\n"}
{"id": 55293, "name": "Create an HTML table", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Table.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  1 January 2022.\n      ************************************************************\n      ** Program Abstract:\n      **   Data values are hardcoded in this example but they\n      **     could come from anywhere.  Computed, read from a\n      **     file, input from the keyboard.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Table-File ASSIGN TO \"index.html\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Table-File\n           DATA RECORD IS Table-Record.\n       01  Table-Record.\n           05 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Table-Data.\n           05  Line3.\n               10  Line3-Value1  PIC S9(4)  VALUE  1234.\n               10  Line3-Value2  PIC S9(4)  VALUE  23.\n               10  Line3-Value3  PIC S9(4)  VALUE  -123.\n           05  Line4.\n               10  Line4-Value1  PIC S9(4)  VALUE  123.\n               10  Line4-Value2  PIC S9(4)  VALUE  12.\n               10  Line4-Value3  PIC S9(4)  VALUE  -1234.\n           05  Line5.\n               10  Line5-Value1  PIC S9(4)  VALUE  567.\n               10  Line5-Value2  PIC S9(4)  VALUE  6789.\n               10  Line5-Value3  PIC S9(4)  VALUE  3.\n\n       \n       01  Table-HTML.\n           05  Line1  PIC X(16)  VALUE\n               \"<table border=1>\".\n           05  Line2  PIC X(40)  VALUE\n               \"<th></th><th>X</th><th>Y</th><th>Z</th>\".\n           05  Line3.\n               10  Line3-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>1</th><td>\".\n               10  Line3-Value1   PIC -ZZZ9.\n               10  Line3-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value2   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value3   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line4.\n               10  Line4-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>2</th><td>\".\n               10  Line4-Value1   PIC -ZZZ9.\n               10  Line4-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value2   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value3   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line5.\n               10  Line5-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>3</th><td>\".\n               10  Line5-Value1   PIC -ZZZ9.\n               10  Line5-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value2   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value3   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line6  PIC X(8)  VALUE\n               \"</table>\".\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT Table-File.\n           MOVE CORRESPONDING Table-Data TO Table-HTML.\n           PERFORM Write-Table.\n           CLOSE Table-File.\n           STOP RUN.\n       \n       \n       Write-Table.\n           WRITE Table-Record FROM Line1 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line2 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line3 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line4 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line5 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line6 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n          \n       \n       END-PROGRAM.\n", "target": "using System;\nusing System.Text;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\tRandom rnd = new Random();\n\t\t\t\n\t\t\ts.AppendLine(\"<table>\");\n\t\t\ts.AppendLine(\"<thead align = \\\"right\\\">\");\n\t\t\ts.Append(\"<tr><th></th>\");\n\t\t\tfor(int i=0; i<3; i++)\n\t\t\t\ts.Append(\"<td>\" + \"XYZ\"[i] + \"</td>\");\n\t\t\ts.AppendLine(\"</tr>\");\n\t\t\ts.AppendLine(\"</thead>\");\n\t\t\ts.AppendLine(\"<tbody align = \\\"right\\\">\");\n\t\t\tfor( int i=0; i<3; i++ )\n\t\t\t{\n\t\t\t\ts.Append(\"<tr><td>\"+i+\"</td>\");\n\t\t\t\tfor( int j=0; j<3; j++ )\n\t\t\t\t\ts.Append(\"<td>\"+rnd.Next(10000)+\"</td>\");\t\t\t\t\n\t\t\t\ts.AppendLine(\"</tr>\");\n\t\t\t}\n\t\t\ts.AppendLine(\"</tbody>\");\n\t\t\ts.AppendLine(\"</table>\");\n\t\t\t\n\t\t\tConsole.WriteLine( s );\n\t\t}\n\t}\n}\n"}
{"id": 55296, "name": "Create an HTML table", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Table.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  1 January 2022.\n      ************************************************************\n      ** Program Abstract:\n      **   Data values are hardcoded in this example but they\n      **     could come from anywhere.  Computed, read from a\n      **     file, input from the keyboard.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Table-File ASSIGN TO \"index.html\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Table-File\n           DATA RECORD IS Table-Record.\n       01  Table-Record.\n           05 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Table-Data.\n           05  Line3.\n               10  Line3-Value1  PIC S9(4)  VALUE  1234.\n               10  Line3-Value2  PIC S9(4)  VALUE  23.\n               10  Line3-Value3  PIC S9(4)  VALUE  -123.\n           05  Line4.\n               10  Line4-Value1  PIC S9(4)  VALUE  123.\n               10  Line4-Value2  PIC S9(4)  VALUE  12.\n               10  Line4-Value3  PIC S9(4)  VALUE  -1234.\n           05  Line5.\n               10  Line5-Value1  PIC S9(4)  VALUE  567.\n               10  Line5-Value2  PIC S9(4)  VALUE  6789.\n               10  Line5-Value3  PIC S9(4)  VALUE  3.\n\n       \n       01  Table-HTML.\n           05  Line1  PIC X(16)  VALUE\n               \"<table border=1>\".\n           05  Line2  PIC X(40)  VALUE\n               \"<th></th><th>X</th><th>Y</th><th>Z</th>\".\n           05  Line3.\n               10  Line3-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>1</th><td>\".\n               10  Line3-Value1   PIC -ZZZ9.\n               10  Line3-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value2   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value3   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line4.\n               10  Line4-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>2</th><td>\".\n               10  Line4-Value1   PIC -ZZZ9.\n               10  Line4-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value2   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value3   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line5.\n               10  Line5-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>3</th><td>\".\n               10  Line5-Value1   PIC -ZZZ9.\n               10  Line5-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value2   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value3   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line6  PIC X(8)  VALUE\n               \"</table>\".\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT Table-File.\n           MOVE CORRESPONDING Table-Data TO Table-HTML.\n           PERFORM Write-Table.\n           CLOSE Table-File.\n           STOP RUN.\n       \n       \n       Write-Table.\n           WRITE Table-Record FROM Line1 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line2 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line3 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line4 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line5 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line6 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n          \n       \n       END-PROGRAM.\n", "target": "public class HTML {\n\n\tpublic static String array2HTML(Object[][] array){\n\t\tStringBuilder html = new StringBuilder(\n\t\t\t\t\"<table>\");\n\t\tfor(Object elem:array[0]){\n\t\t\thtml.append(\"<th>\" + elem.toString() + \"</th>\");\n\t\t}\n\t\tfor(int i = 1; i < array.length; i++){\n\t\t\tObject[] row = array[i];\n\t\t\thtml.append(\"<tr>\");\n\t\t\tfor(Object elem:row){\n\t\t\t\thtml.append(\"<td>\" + elem.toString() + \"</td>\");\n\t\t\t}\n\t\t\thtml.append(\"</tr>\");\n\t\t}\n\t\thtml.append(\"</table>\");\n\t\treturn html.toString();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tObject[][] ints = {{\"\",\"X\",\"Y\",\"Z\"},{1,1,2,3},{2,4,5,6},{3,7,8,9},{4,10,11,12}};\n\t\tSystem.out.println(array2HTML(ints));\n\t}\n}\n"}
{"id": 55297, "name": "Create an HTML table", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Table.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  1 January 2022.\n      ************************************************************\n      ** Program Abstract:\n      **   Data values are hardcoded in this example but they\n      **     could come from anywhere.  Computed, read from a\n      **     file, input from the keyboard.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Table-File ASSIGN TO \"index.html\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Table-File\n           DATA RECORD IS Table-Record.\n       01  Table-Record.\n           05 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Table-Data.\n           05  Line3.\n               10  Line3-Value1  PIC S9(4)  VALUE  1234.\n               10  Line3-Value2  PIC S9(4)  VALUE  23.\n               10  Line3-Value3  PIC S9(4)  VALUE  -123.\n           05  Line4.\n               10  Line4-Value1  PIC S9(4)  VALUE  123.\n               10  Line4-Value2  PIC S9(4)  VALUE  12.\n               10  Line4-Value3  PIC S9(4)  VALUE  -1234.\n           05  Line5.\n               10  Line5-Value1  PIC S9(4)  VALUE  567.\n               10  Line5-Value2  PIC S9(4)  VALUE  6789.\n               10  Line5-Value3  PIC S9(4)  VALUE  3.\n\n       \n       01  Table-HTML.\n           05  Line1  PIC X(16)  VALUE\n               \"<table border=1>\".\n           05  Line2  PIC X(40)  VALUE\n               \"<th></th><th>X</th><th>Y</th><th>Z</th>\".\n           05  Line3.\n               10  Line3-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>1</th><td>\".\n               10  Line3-Value1   PIC -ZZZ9.\n               10  Line3-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value2   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value3   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line4.\n               10  Line4-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>2</th><td>\".\n               10  Line4-Value1   PIC -ZZZ9.\n               10  Line4-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value2   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value3   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line5.\n               10  Line5-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>3</th><td>\".\n               10  Line5-Value1   PIC -ZZZ9.\n               10  Line5-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value2   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value3   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line6  PIC X(8)  VALUE\n               \"</table>\".\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT Table-File.\n           MOVE CORRESPONDING Table-Data TO Table-HTML.\n           PERFORM Write-Table.\n           CLOSE Table-File.\n           STOP RUN.\n       \n       \n       Write-Table.\n           WRITE Table-Record FROM Line1 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line2 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line3 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line4 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line5 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line6 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n          \n       \n       END-PROGRAM.\n", "target": "public class HTML {\n\n\tpublic static String array2HTML(Object[][] array){\n\t\tStringBuilder html = new StringBuilder(\n\t\t\t\t\"<table>\");\n\t\tfor(Object elem:array[0]){\n\t\t\thtml.append(\"<th>\" + elem.toString() + \"</th>\");\n\t\t}\n\t\tfor(int i = 1; i < array.length; i++){\n\t\t\tObject[] row = array[i];\n\t\t\thtml.append(\"<tr>\");\n\t\t\tfor(Object elem:row){\n\t\t\t\thtml.append(\"<td>\" + elem.toString() + \"</td>\");\n\t\t\t}\n\t\t\thtml.append(\"</tr>\");\n\t\t}\n\t\thtml.append(\"</table>\");\n\t\treturn html.toString();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tObject[][] ints = {{\"\",\"X\",\"Y\",\"Z\"},{1,1,2,3},{2,4,5,6},{3,7,8,9},{4,10,11,12}};\n\t\tSystem.out.println(array2HTML(ints));\n\t}\n}\n"}
{"id": 55298, "name": "Create an HTML table", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Table.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  1 January 2022.\n      ************************************************************\n      ** Program Abstract:\n      **   Data values are hardcoded in this example but they\n      **     could come from anywhere.  Computed, read from a\n      **     file, input from the keyboard.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Table-File ASSIGN TO \"index.html\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Table-File\n           DATA RECORD IS Table-Record.\n       01  Table-Record.\n           05 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Table-Data.\n           05  Line3.\n               10  Line3-Value1  PIC S9(4)  VALUE  1234.\n               10  Line3-Value2  PIC S9(4)  VALUE  23.\n               10  Line3-Value3  PIC S9(4)  VALUE  -123.\n           05  Line4.\n               10  Line4-Value1  PIC S9(4)  VALUE  123.\n               10  Line4-Value2  PIC S9(4)  VALUE  12.\n               10  Line4-Value3  PIC S9(4)  VALUE  -1234.\n           05  Line5.\n               10  Line5-Value1  PIC S9(4)  VALUE  567.\n               10  Line5-Value2  PIC S9(4)  VALUE  6789.\n               10  Line5-Value3  PIC S9(4)  VALUE  3.\n\n       \n       01  Table-HTML.\n           05  Line1  PIC X(16)  VALUE\n               \"<table border=1>\".\n           05  Line2  PIC X(40)  VALUE\n               \"<th></th><th>X</th><th>Y</th><th>Z</th>\".\n           05  Line3.\n               10  Line3-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>1</th><td>\".\n               10  Line3-Value1   PIC -ZZZ9.\n               10  Line3-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value2   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value3   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line4.\n               10  Line4-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>2</th><td>\".\n               10  Line4-Value1   PIC -ZZZ9.\n               10  Line4-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value2   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value3   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line5.\n               10  Line5-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>3</th><td>\".\n               10  Line5-Value1   PIC -ZZZ9.\n               10  Line5-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value2   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value3   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line6  PIC X(8)  VALUE\n               \"</table>\".\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT Table-File.\n           MOVE CORRESPONDING Table-Data TO Table-HTML.\n           PERFORM Write-Table.\n           CLOSE Table-File.\n           STOP RUN.\n       \n       \n       Write-Table.\n           WRITE Table-Record FROM Line1 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line2 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line3 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line4 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line5 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line6 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n          \n       \n       END-PROGRAM.\n", "target": "import random\n\ndef rand9999():\n    return random.randint(1000, 9999)\n\ndef tag(attr='', **kwargs):\n    for tag, txt in kwargs.items():\n        return '<{tag}{attr}>{txt}</{tag}>'.format(**locals())\n\nif __name__ == '__main__':\n    header = tag(tr=''.join(tag(th=txt) for txt in ',X,Y,Z'.split(','))) + '\\n'\n    rows = '\\n'.join(tag(tr=tag(' style=\"font-weight: bold;\"', td=i)\n                                    + ''.join(tag(td=rand9999())\n                                              for j in range(3)))\n                     for i in range(1, 6))\n    table = tag(table='\\n' + header + rows + '\\n')\n    print(table)\n"}
{"id": 55299, "name": "Create an HTML table", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Table.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  1 January 2022.\n      ************************************************************\n      ** Program Abstract:\n      **   Data values are hardcoded in this example but they\n      **     could come from anywhere.  Computed, read from a\n      **     file, input from the keyboard.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Table-File ASSIGN TO \"index.html\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Table-File\n           DATA RECORD IS Table-Record.\n       01  Table-Record.\n           05 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Table-Data.\n           05  Line3.\n               10  Line3-Value1  PIC S9(4)  VALUE  1234.\n               10  Line3-Value2  PIC S9(4)  VALUE  23.\n               10  Line3-Value3  PIC S9(4)  VALUE  -123.\n           05  Line4.\n               10  Line4-Value1  PIC S9(4)  VALUE  123.\n               10  Line4-Value2  PIC S9(4)  VALUE  12.\n               10  Line4-Value3  PIC S9(4)  VALUE  -1234.\n           05  Line5.\n               10  Line5-Value1  PIC S9(4)  VALUE  567.\n               10  Line5-Value2  PIC S9(4)  VALUE  6789.\n               10  Line5-Value3  PIC S9(4)  VALUE  3.\n\n       \n       01  Table-HTML.\n           05  Line1  PIC X(16)  VALUE\n               \"<table border=1>\".\n           05  Line2  PIC X(40)  VALUE\n               \"<th></th><th>X</th><th>Y</th><th>Z</th>\".\n           05  Line3.\n               10  Line3-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>1</th><td>\".\n               10  Line3-Value1   PIC -ZZZ9.\n               10  Line3-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value2   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value3   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line4.\n               10  Line4-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>2</th><td>\".\n               10  Line4-Value1   PIC -ZZZ9.\n               10  Line4-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value2   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value3   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line5.\n               10  Line5-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>3</th><td>\".\n               10  Line5-Value1   PIC -ZZZ9.\n               10  Line5-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value2   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value3   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line6  PIC X(8)  VALUE\n               \"</table>\".\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT Table-File.\n           MOVE CORRESPONDING Table-Data TO Table-HTML.\n           PERFORM Write-Table.\n           CLOSE Table-File.\n           STOP RUN.\n       \n       \n       Write-Table.\n           WRITE Table-Record FROM Line1 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line2 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line3 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line4 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line5 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line6 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n          \n       \n       END-PROGRAM.\n", "target": "import random\n\ndef rand9999():\n    return random.randint(1000, 9999)\n\ndef tag(attr='', **kwargs):\n    for tag, txt in kwargs.items():\n        return '<{tag}{attr}>{txt}</{tag}>'.format(**locals())\n\nif __name__ == '__main__':\n    header = tag(tr=''.join(tag(th=txt) for txt in ',X,Y,Z'.split(','))) + '\\n'\n    rows = '\\n'.join(tag(tr=tag(' style=\"font-weight: bold;\"', td=i)\n                                    + ''.join(tag(td=rand9999())\n                                              for j in range(3)))\n                     for i in range(1, 6))\n    table = tag(table='\\n' + header + rows + '\\n')\n    print(table)\n"}
{"id": 55944, "name": "Conditional structures", "source": "Translate COBOL to C#: if condition-1\n    imperative-statement-1\nelse\n    imperative-statement-2\nend-if\n\nif condition-1\n    if condition-a\n        imperative-statement-1a\n    else\n        imperative-statement-1\n    end-if\nelse\n    if condition-a\n        imperative-statement-2a\n    else\n        imperative-statement-2\n    end-if\nend-if\n", "target": "if (condition)\n{\n   \n}\n\nif (condition)\n{\n  \n}\nelse if (condition2)\n{\n  \n}\nelse\n{\n  \n}\n"}
{"id": 55946, "name": "Conditional structures", "source": "Translate COBOL to Java: if condition-1\n    imperative-statement-1\nelse\n    imperative-statement-2\nend-if\n\nif condition-1\n    if condition-a\n        imperative-statement-1a\n    else\n        imperative-statement-1\n    end-if\nelse\n    if condition-a\n        imperative-statement-2a\n    else\n        imperative-statement-2\n    end-if\nend-if\n", "target": "if (s == 'Hello World') {\n    foo();\n} else if (s == 'Bye World') {\n    bar();\n} else {\n    deusEx();\n}\n"}
{"id": 55947, "name": "Conditional structures", "source": "Translate COBOL to Python: if condition-1\n    imperative-statement-1\nelse\n    imperative-statement-2\nend-if\n\nif condition-1\n    if condition-a\n        imperative-statement-1a\n    else\n        imperative-statement-1\n    end-if\nelse\n    if condition-a\n        imperative-statement-2a\n    else\n        imperative-statement-2\n    end-if\nend-if\n", "target": "if x == 0:\n    foo()\nelif x == 1:\n    bar()\nelif x == 2:\n    baz()\nelse:\n    qux()\n\nmatch x:\n    0 => foo()\n    1 => bar()\n    2 => baz()\n    _ => qux()\n\n(a) ? b : c\n"}
{"id": 56155, "name": "Align columns", "source": "Translate COBOL to C#:        identification division.\n       program-id. AlignColumns.\n\n       data division.\n       working-storage section.\n      \n       78 MAX-LINES value 6.\n       78 MAX-LINE-SIZE value 66.\n       78 MAX-COLUMNS value 12.\n       78 MAX-COLUMN-SIZE value 16.\n      \n       01 w-idx                   pic is 9(2).\n       01 w-idy                   pic is 9(2).\n       01 w-pos                   pic is 9(3).\n      \n       01 w-lines.\n          05 w-line               pic is x(MAX-LINE-SIZE) occurs MAX-LINES.\n       01 w-column-sizes.\n          05 w-column-size        pic is 99 occurs MAX-COLUMNS value zeros.\n       01 w-matrix.\n          05 filler               occurs MAX-LINES.\n             10 filler            occurs MAX-COLUMNS.\n                15 w-content      pic is x(MAX-COLUMN-SIZE).\n      \n       01 w-line-out              pic is x(120).\n      \n       01 w-alignment             pic is x(1).\n          88 alignment-left       value is \"L\".\n          88 alignment-center     value is \"C\".\n          88 alignment-right      value is \"R\".\n\n       procedure division.\n       main.\n           move \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\" to w-line(1)\n           move \"are$delineated$by$a$single$'dollar'$character,$write$a$program\" to w-line(2)\n           move \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\" to w-line(3)\n           move \"column$are$separated$by$at$least$one$space.\" to w-line(4)\n           move \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\" to w-line(5)\n           move \"justified,$right$justified,$or$center$justified$within$its$column.\" to w-line(6)\n           perform calculate-size-columns\n           set alignment-left to true\n           perform show-content\n           set alignment-center to true\n           perform show-content\n           set alignment-right to true\n           perform show-content\n           goback\n           .\n       calculate-size-columns.\n           perform\n              varying             w-idx from 1 by 1\n                 until            w-idx > MAX-LINES\n              unstring w-line(w-idx) delimited by \"$\" into w-content(w-idx, 1), w-content(w-idx, 2), \n                  w-content(w-idx, 3), w-content(w-idx, 4), w-content(w-idx, 5), w-content(w-idx, 6), \n                  w-content(w-idx, 7), w-content(w-idx, 8), w-content(w-idx, 9), w-content(w-idx, 10), \n                  w-content(w-idx, 11), w-content(w-idx, 12),\n              perform\n                 varying          w-idy from 1 by 1\n                    until         w-idy > MAX-COLUMNS\n                 if function stored-char-length(w-content(w-idx, w-idy)) > w-column-size(w-idy)\n                    move function stored-char-length(w-content(w-idx, w-idy)) to w-column-size(w-idy)\n                 end-if\n              end-perform\n           end-perform\n           .\n       show-content.\n           move all \"-\" to w-line-out\n           display w-line-out\n           perform\n              varying             w-idx from 1 by 1\n                 until            w-idx > MAX-LINES\n              move spaces to w-line-out\n              move 1 to w-pos\n              perform\n                 varying          w-idy from 1 by 1\n                    until         w-idy > MAX-COLUMNS\n                 call \"C$JUSTIFY\" using w-content(w-idx, w-idy)(1:w-column-size(w-idy)), w-alignment\n                 move w-content(w-idx, w-idy) to w-line-out(w-pos:w-column-size(w-idy))\n                 compute w-pos = w-pos + w-column-size(w-idy) + 1\n              end-perform\n              display w-line-out\n           end-perform\n           .\n", "target": "using System;\nclass ColumnAlignerProgram\n{\n    delegate string Justification(string s, int width);\n\n    static string[] AlignColumns(string[] lines, Justification justification)\n    {\n        const char Separator = '$';\n        \n        string[][] table = new string[lines.Length][];\n        int columns = 0;\n        for (int i = 0; i < lines.Length; i++)\n        {\n            string[] row = lines[i].TrimEnd(Separator).Split(Separator);\n            if (columns < row.Length) columns = row.Length;\n            table[i] = row;\n        }\n        \n        string[][] formattedTable = new string[table.Length][];\n        for (int i = 0; i < formattedTable.Length; i++)\n        {\n            formattedTable[i] = new string[columns];\n        }\n        for (int j = 0; j < columns; j++)\n        {\n            \n            int columnWidth = 0;\n            for (int i = 0; i < table.Length; i++)\n            {\n                if (j < table[i].Length && columnWidth < table[i][j].Length)\n                    columnWidth = table[i][j].Length;\n            }\n            \n            for (int i = 0; i < formattedTable.Length; i++)\n            {\n                if (j < table[i].Length)\n                    formattedTable[i][j] = justification(table[i][j], columnWidth);\n                else \n                    formattedTable[i][j] = new String(' ', columnWidth);\n            }\n        }\n        \n        string[] result = new string[formattedTable.Length];\n        for (int i = 0; i < result.Length; i++)\n        {\n            result[i] = String.Join(\" \", formattedTable[i]);\n        }\n        return result;\n    }\n\n    static string JustifyLeft(string s, int width) { return s.PadRight(width); }\n    static string JustifyRight(string s, int width) { return s.PadLeft(width); }\n    static string JustifyCenter(string s, int width) \n    { \n        return s.PadLeft((width + s.Length) / 2).PadRight(width); \n    }\n\n    static void Main()\n    {\n        string[] input = {    \n            \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n            \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n            \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n            \"column$are$separated$by$at$least$one$space.\",\n            \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n            \"justified,$right$justified,$or$center$justified$within$its$column.\",\n        };\n\n        foreach (string line in AlignColumns(input, JustifyCenter))\n        {\n            Console.WriteLine(line);\n        }\n    }\n}\n"}
{"id": 56156, "name": "Align columns", "source": "Translate COBOL to Java:        identification division.\n       program-id. AlignColumns.\n\n       data division.\n       working-storage section.\n      \n       78 MAX-LINES value 6.\n       78 MAX-LINE-SIZE value 66.\n       78 MAX-COLUMNS value 12.\n       78 MAX-COLUMN-SIZE value 16.\n      \n       01 w-idx                   pic is 9(2).\n       01 w-idy                   pic is 9(2).\n       01 w-pos                   pic is 9(3).\n      \n       01 w-lines.\n          05 w-line               pic is x(MAX-LINE-SIZE) occurs MAX-LINES.\n       01 w-column-sizes.\n          05 w-column-size        pic is 99 occurs MAX-COLUMNS value zeros.\n       01 w-matrix.\n          05 filler               occurs MAX-LINES.\n             10 filler            occurs MAX-COLUMNS.\n                15 w-content      pic is x(MAX-COLUMN-SIZE).\n      \n       01 w-line-out              pic is x(120).\n      \n       01 w-alignment             pic is x(1).\n          88 alignment-left       value is \"L\".\n          88 alignment-center     value is \"C\".\n          88 alignment-right      value is \"R\".\n\n       procedure division.\n       main.\n           move \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\" to w-line(1)\n           move \"are$delineated$by$a$single$'dollar'$character,$write$a$program\" to w-line(2)\n           move \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\" to w-line(3)\n           move \"column$are$separated$by$at$least$one$space.\" to w-line(4)\n           move \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\" to w-line(5)\n           move \"justified,$right$justified,$or$center$justified$within$its$column.\" to w-line(6)\n           perform calculate-size-columns\n           set alignment-left to true\n           perform show-content\n           set alignment-center to true\n           perform show-content\n           set alignment-right to true\n           perform show-content\n           goback\n           .\n       calculate-size-columns.\n           perform\n              varying             w-idx from 1 by 1\n                 until            w-idx > MAX-LINES\n              unstring w-line(w-idx) delimited by \"$\" into w-content(w-idx, 1), w-content(w-idx, 2), \n                  w-content(w-idx, 3), w-content(w-idx, 4), w-content(w-idx, 5), w-content(w-idx, 6), \n                  w-content(w-idx, 7), w-content(w-idx, 8), w-content(w-idx, 9), w-content(w-idx, 10), \n                  w-content(w-idx, 11), w-content(w-idx, 12),\n              perform\n                 varying          w-idy from 1 by 1\n                    until         w-idy > MAX-COLUMNS\n                 if function stored-char-length(w-content(w-idx, w-idy)) > w-column-size(w-idy)\n                    move function stored-char-length(w-content(w-idx, w-idy)) to w-column-size(w-idy)\n                 end-if\n              end-perform\n           end-perform\n           .\n       show-content.\n           move all \"-\" to w-line-out\n           display w-line-out\n           perform\n              varying             w-idx from 1 by 1\n                 until            w-idx > MAX-LINES\n              move spaces to w-line-out\n              move 1 to w-pos\n              perform\n                 varying          w-idy from 1 by 1\n                    until         w-idy > MAX-COLUMNS\n                 call \"C$JUSTIFY\" using w-content(w-idx, w-idy)(1:w-column-size(w-idy)), w-alignment\n                 move w-content(w-idx, w-idy) to w-line-out(w-pos:w-column-size(w-idy))\n                 compute w-pos = w-pos + w-column-size(w-idy) + 1\n              end-perform\n              display w-line-out\n           end-perform\n           .\n", "target": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\n\n\npublic class ColumnAligner {\n    private List<String[]> words = new ArrayList<>();\n    private int columns = 0;\n    private List<Integer> columnWidths = new ArrayList<>();\n\n    \n    public ColumnAligner(String s) {\n        String[] lines = s.split(\"\\\\n\");\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    \n    public ColumnAligner(List<String> lines) {\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    private void processInputLine(String line) {\n        String[] lineWords = line.split(\"\\\\$\");\n        words.add(lineWords);\n        columns = Math.max(columns, lineWords.length);\n        for (int i = 0; i < lineWords.length; i++) {\n            String word = lineWords[i];\n            if (i >= columnWidths.size()) {\n                columnWidths.add(word.length());\n            } else {\n                columnWidths.set(i, Math.max(columnWidths.get(i), word.length()));\n            }\n        }\n    }\n\n    interface AlignFunction {\n        String align(String s, int length);\n    }\n\n    \n    public String alignLeft() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.rightPad(s, length);\n            }\n        });\n    }\n\n    \n    public String alignRight() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.leftPad(s, length);\n            }\n        });\n    }\n\n    \n    public String alignCenter() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.center(s, length);\n            }\n        });\n    }\n\n    private String align(AlignFunction a) {\n        StringBuilder result = new StringBuilder();\n        for (String[] lineWords : words) {\n            for (int i = 0; i < lineWords.length; i++) {\n                String word = lineWords[i];\n                if (i == 0) {\n                    result.append(\"|\");\n                }\n                result.append(a.align(word, columnWidths.get(i)) + \"|\");\n            }\n            result.append(\"\\n\");\n        }\n        return result.toString();\n    }\n\n    public static void main(String args[]) throws IOException {\n        if (args.length < 1) {\n            System.out.println(\"Usage: ColumnAligner file [left|right|center]\");\n            return;\n        }\n        String filePath = args[0];\n        String alignment = \"left\";\n        if (args.length >= 2) {\n            alignment = args[1];\n        }\n        ColumnAligner ca = new ColumnAligner(Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8));\n        switch (alignment) {\n        case \"left\":\n            System.out.print(ca.alignLeft());\n            break;\n        case \"right\":\n            System.out.print(ca.alignRight());\n            break;\n        case \"center\":\n            System.out.print(ca.alignCenter());\n            break;\n        default:\n            System.err.println(String.format(\"Error! Unknown alignment: '%s'\", alignment));\n            break;\n        }\n    }\n}\n"}
{"id": 56157, "name": "Align columns", "source": "Translate COBOL to Python:        identification division.\n       program-id. AlignColumns.\n\n       data division.\n       working-storage section.\n      \n       78 MAX-LINES value 6.\n       78 MAX-LINE-SIZE value 66.\n       78 MAX-COLUMNS value 12.\n       78 MAX-COLUMN-SIZE value 16.\n      \n       01 w-idx                   pic is 9(2).\n       01 w-idy                   pic is 9(2).\n       01 w-pos                   pic is 9(3).\n      \n       01 w-lines.\n          05 w-line               pic is x(MAX-LINE-SIZE) occurs MAX-LINES.\n       01 w-column-sizes.\n          05 w-column-size        pic is 99 occurs MAX-COLUMNS value zeros.\n       01 w-matrix.\n          05 filler               occurs MAX-LINES.\n             10 filler            occurs MAX-COLUMNS.\n                15 w-content      pic is x(MAX-COLUMN-SIZE).\n      \n       01 w-line-out              pic is x(120).\n      \n       01 w-alignment             pic is x(1).\n          88 alignment-left       value is \"L\".\n          88 alignment-center     value is \"C\".\n          88 alignment-right      value is \"R\".\n\n       procedure division.\n       main.\n           move \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\" to w-line(1)\n           move \"are$delineated$by$a$single$'dollar'$character,$write$a$program\" to w-line(2)\n           move \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\" to w-line(3)\n           move \"column$are$separated$by$at$least$one$space.\" to w-line(4)\n           move \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\" to w-line(5)\n           move \"justified,$right$justified,$or$center$justified$within$its$column.\" to w-line(6)\n           perform calculate-size-columns\n           set alignment-left to true\n           perform show-content\n           set alignment-center to true\n           perform show-content\n           set alignment-right to true\n           perform show-content\n           goback\n           .\n       calculate-size-columns.\n           perform\n              varying             w-idx from 1 by 1\n                 until            w-idx > MAX-LINES\n              unstring w-line(w-idx) delimited by \"$\" into w-content(w-idx, 1), w-content(w-idx, 2), \n                  w-content(w-idx, 3), w-content(w-idx, 4), w-content(w-idx, 5), w-content(w-idx, 6), \n                  w-content(w-idx, 7), w-content(w-idx, 8), w-content(w-idx, 9), w-content(w-idx, 10), \n                  w-content(w-idx, 11), w-content(w-idx, 12),\n              perform\n                 varying          w-idy from 1 by 1\n                    until         w-idy > MAX-COLUMNS\n                 if function stored-char-length(w-content(w-idx, w-idy)) > w-column-size(w-idy)\n                    move function stored-char-length(w-content(w-idx, w-idy)) to w-column-size(w-idy)\n                 end-if\n              end-perform\n           end-perform\n           .\n       show-content.\n           move all \"-\" to w-line-out\n           display w-line-out\n           perform\n              varying             w-idx from 1 by 1\n                 until            w-idx > MAX-LINES\n              move spaces to w-line-out\n              move 1 to w-pos\n              perform\n                 varying          w-idy from 1 by 1\n                    until         w-idy > MAX-COLUMNS\n                 call \"C$JUSTIFY\" using w-content(w-idx, w-idy)(1:w-column-size(w-idy)), w-alignment\n                 move w-content(w-idx, w-idy) to w-line-out(w-pos:w-column-size(w-idy))\n                 compute w-pos = w-pos + w-column-size(w-idy) + 1\n              end-perform\n              display w-line-out\n           end-perform\n           .\n", "target": "from itertools import zip_longest\n\ntxt = \n \nparts = [line.rstrip(\"$\").split(\"$\") for line in txt.splitlines()]\nwidths = [max(len(word) for word in col) \n          for col in zip_longest(*parts, fillvalue='')]\n \nfor justify in \"<_Left ^_Center >_Right\".split():\n    j, jtext = justify.split('_')\n    print(f\"{jtext} column-aligned output:\\n\")\n    for line in parts:\n        print(' '.join(f\"{wrd:{j}{wdth}}\" for wdth, wrd in zip(widths, line)))\n    print(\"- \" * 52)\n"}
{"id": 57029, "name": "Real constants and functions", "source": "Translate COBOL to C#: E          \nPI         \nSQRT(n)    \nLOG(n)     \nLOG10(n)   \nEXP(n)     \nABS(n)     \nINTEGER(n) \n\nADD 1 TO N\nMOVE INTEGER(N) TO Result\n\nCOMPUTE Result = N ** 2\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {        \n        Console.WriteLine(Math.E); \n        Console.WriteLine(Math.PI); \n        Console.WriteLine(Math.Sqrt(10)); \n        Console.WriteLine(Math.Log(10)); \n        Console.WriteLine(Math.Log10(10)); \n        Console.WriteLine(Math.Exp(10)); \n        Console.WriteLine(Math.Abs(10)); \n        Console.WriteLine(Math.Floor(10.0)); \n        Console.WriteLine(Math.Ceiling(10.0)); \n        Console.WriteLine(Math.Pow(2, 5)); \n    }\n}\n"}
{"id": 57031, "name": "Real constants and functions", "source": "Translate COBOL to Java: E          \nPI         \nSQRT(n)    \nLOG(n)     \nLOG10(n)   \nEXP(n)     \nABS(n)     \nINTEGER(n) \n\nADD 1 TO N\nMOVE INTEGER(N) TO Result\n\nCOMPUTE Result = N ** 2\n", "target": "Math.E; \nMath.PI; \nMath.sqrt(x); \nMath.log(x); \nMath.exp(x); \nMath.abs(x); \nMath.floor(x); \nMath.ceil(x); \nMath.pow(x,y); \n"}
{"id": 57032, "name": "Real constants and functions", "source": "Translate COBOL to Python: E          \nPI         \nSQRT(n)    \nLOG(n)     \nLOG10(n)   \nEXP(n)     \nABS(n)     \nINTEGER(n) \n\nADD 1 TO N\nMOVE INTEGER(N) TO Result\n\nCOMPUTE Result = N ** 2\n", "target": "import math\n\nmath.e          \nmath.pi         \nmath.sqrt(x)    \nmath.log(x)     \nmath.log10(x)   \nmath.exp(x)     \nabs(x)          \nmath.floor(x)   \nmath.ceil(x)    \nx ** y          \npow(x, y[, n])  \n\n\n\n"}
{"id": 57513, "name": "System time", "source": "Translate COBOL to C#:        WORKING-STORAGE SECTION.\n       01  WS-CURRENT-DATE-FIELDS.\n           05  WS-CURRENT-DATE.\n               10  WS-CURRENT-YEAR    PIC  9(4).\n               10  WS-CURRENT-MONTH   PIC  9(2).\n               10  WS-CURRENT-DAY     PIC  9(2).\n           05  WS-CURRENT-TIME.\n               10  WS-CURRENT-HOUR    PIC  9(2).\n               10  WS-CURRENT-MINUTE  PIC  9(2).\n               10  WS-CURRENT-SECOND  PIC  9(2).\n               10  WS-CURRENT-MS      PIC  9(2).\n           05  WS-DIFF-FROM-GMT       PIC S9(4).\n \n       PROCEDURE DIVISION.\n           MOVE FUNCTION CURRENT-DATE TO WS-CURRENT-DATE-FIELDS.\n", "target": "Console.WriteLine(DateTime.Now);\n"}
{"id": 57515, "name": "System time", "source": "Translate COBOL to Java:        WORKING-STORAGE SECTION.\n       01  WS-CURRENT-DATE-FIELDS.\n           05  WS-CURRENT-DATE.\n               10  WS-CURRENT-YEAR    PIC  9(4).\n               10  WS-CURRENT-MONTH   PIC  9(2).\n               10  WS-CURRENT-DAY     PIC  9(2).\n           05  WS-CURRENT-TIME.\n               10  WS-CURRENT-HOUR    PIC  9(2).\n               10  WS-CURRENT-MINUTE  PIC  9(2).\n               10  WS-CURRENT-SECOND  PIC  9(2).\n               10  WS-CURRENT-MS      PIC  9(2).\n           05  WS-DIFF-FROM-GMT       PIC S9(4).\n \n       PROCEDURE DIVISION.\n           MOVE FUNCTION CURRENT-DATE TO WS-CURRENT-DATE-FIELDS.\n", "target": "public class SystemTime{\n    public static void main(String[] args){\n        System.out.format(\"%tc%n\", System.currentTimeMillis());\n    }\n}\n"}
{"id": 57516, "name": "System time", "source": "Translate COBOL to Python:        WORKING-STORAGE SECTION.\n       01  WS-CURRENT-DATE-FIELDS.\n           05  WS-CURRENT-DATE.\n               10  WS-CURRENT-YEAR    PIC  9(4).\n               10  WS-CURRENT-MONTH   PIC  9(2).\n               10  WS-CURRENT-DAY     PIC  9(2).\n           05  WS-CURRENT-TIME.\n               10  WS-CURRENT-HOUR    PIC  9(2).\n               10  WS-CURRENT-MINUTE  PIC  9(2).\n               10  WS-CURRENT-SECOND  PIC  9(2).\n               10  WS-CURRENT-MS      PIC  9(2).\n           05  WS-DIFF-FROM-GMT       PIC S9(4).\n \n       PROCEDURE DIVISION.\n           MOVE FUNCTION CURRENT-DATE TO WS-CURRENT-DATE-FIELDS.\n", "target": "import time\nprint time.ctime()\n"}
{"id": 58862, "name": "Box the compass", "source": "Translate COBOL to C#:        identification division.\n       program-id. box-compass.\n       data division.\n       working-storage section.\n       01 point                pic 99.\n       01 degrees              usage float-short.\n       01 degrees-rounded      pic 999v99.\n       01 show-degrees         pic zz9.99.\n       01 box                  pic z9.\n       01 fudge                pic 9.\n       01 compass              pic x(4).\n       01 compass-point        pic x(18).\n       01 shortform            pic x.\n       01 short-names.\n          05 short-name        pic x(4) occurs 33 times.\n       01 overlay.\n          05 value \"N   \" & \"NbE \" & \"N-NE\" & \"NEbN\" & \"NE  \" &\n                   \"NEbE\" & \"E-NE\" & \"EbN \" & \"E   \" & \"EbS \" &\n                   \"E-SE\" & \"SEbE\" & \"SE  \" & \"SEbS\" & \"S-SE\" &\n                   \"SbE \" & \"S   \" & \"SbW \" & \"S-SW\" & \"SWbS\" &\n                   \"SW  \" & \"SWbW\" & \"W-SW\" & \"WbS \" & \"W   \" &\n                   \"WbN \" & \"W-NW\" & \"NWbW\" & \"NW  \" & \"NWbN\" &\n                   \"N-NW\" & \"NbW \" & \"N   \".\n\n       procedure division.\n       display \"Index Compass point      Degree\"\n\n       move overlay to short-names.\n       perform varying point from 0 by 1 until point > 32\n           compute box = function mod(point 32) + 1\n           compute degrees = point * 11.25\n           compute fudge = function mod(point 3)\n           evaluate fudge\n              when equal 1\n                  add 5.62 to degrees\n              when equal 2\n                  subtract 5.62 from degrees\n           end-evaluate\n\n           compute degrees-rounded rounded = degrees\n           move degrees-rounded to show-degrees\n           inspect show-degrees replacing trailing '00' by '0 '\n           inspect show-degrees replacing trailing '50' by '5 '\n\n           move short-name(point + 1) to compass\n           move spaces to compass-point\n           display space box space space space with no advancing\n           perform varying tally from 1 by 1 until tally > 4\n               move compass(tally:1) to shortform\n               move function concatenate(function trim(compass-point),\n                    function substitute(shortform,\n                        \"N\", \"North\",\n                        \"E\", \"East\",\n                        \"S\", \"South\",\n                        \"W\", \"West\",\n                        \"b\", \" byZ\",\n                        \"-\", \"-\"))\n                 to compass-point\n           end-perform\n           move function substitute(compass-point, \"Z\", \" \")\n             to compass-point\n           move function lower-case(compass-point) to compass-point\n           move function upper-case(compass-point(1:1))\n             to compass-point(1:1)\n           display compass-point space show-degrees\n       end-perform\n       goback.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace BoxTheCompass\n{\n    class Compass\n    {\n        string[] cp = new string[] {\"North\", \"North by east\", \"North-northeast\", \"Northeast by north\", \"Northeast\",\"Northeast by east\", \n\t    \"East-northeast\", \"East by north\", \"East\", \"East by south\", \"East-southeast\", \"Southeast by east\", \"Southeast\", \n            \"Southeast by south\", \"South-southeast\", \"South by east\", \"South\", \"South by west\", \"South-southwest\", \"Southwest by south\", \n            \"Southwest\", \"Southwest by west\", \"West-southwest\", \"West by south\", \"West\", \"West by north\", \"West-northwest\", \n            \"Northwest by west\", \"Northwest\", \"Northwest by north\", \"North-northwest\", \"North by west\", \"North\"};\n\n        public void compassHeading(float a)\n        {\n            int h = Convert.ToInt32(Math.Floor(a / 11.25f + .5f)) % 32;\n            Console.WriteLine( \"{0,2}: {1,-22}\u00a0: {2,6:N}\",h + 1, cp[h], a );\n        }\n    };\n    class Program\n    {\n        static void Main(string[] args)\n       {\n            Compass c = new Compass();\n            float[] degs = new float[] {0.0f, 16.87f, 16.88f, 33.75f, 50.62f, 50.63f, 67.5f, 84.37f, 84.38f, 101.25f, \n                118.12f, 118.13f, 135.0f, 151.87f, 151.88f, 168.75f, 185.62f, 185.63f, 202.5f, 219.37f, 219.38f, 236.25f, \n                253.12f, 253.13f, 270.0f, 286.87f, 286.88f, 303.75f, 320.62f, 320.63f, 337.5f, 354.37f, 354.38f};\n\n            foreach (float d in degs)\n                c.compassHeading(d);\n\n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 58863, "name": "Box the compass", "source": "Translate COBOL to C#:        identification division.\n       program-id. box-compass.\n       data division.\n       working-storage section.\n       01 point                pic 99.\n       01 degrees              usage float-short.\n       01 degrees-rounded      pic 999v99.\n       01 show-degrees         pic zz9.99.\n       01 box                  pic z9.\n       01 fudge                pic 9.\n       01 compass              pic x(4).\n       01 compass-point        pic x(18).\n       01 shortform            pic x.\n       01 short-names.\n          05 short-name        pic x(4) occurs 33 times.\n       01 overlay.\n          05 value \"N   \" & \"NbE \" & \"N-NE\" & \"NEbN\" & \"NE  \" &\n                   \"NEbE\" & \"E-NE\" & \"EbN \" & \"E   \" & \"EbS \" &\n                   \"E-SE\" & \"SEbE\" & \"SE  \" & \"SEbS\" & \"S-SE\" &\n                   \"SbE \" & \"S   \" & \"SbW \" & \"S-SW\" & \"SWbS\" &\n                   \"SW  \" & \"SWbW\" & \"W-SW\" & \"WbS \" & \"W   \" &\n                   \"WbN \" & \"W-NW\" & \"NWbW\" & \"NW  \" & \"NWbN\" &\n                   \"N-NW\" & \"NbW \" & \"N   \".\n\n       procedure division.\n       display \"Index Compass point      Degree\"\n\n       move overlay to short-names.\n       perform varying point from 0 by 1 until point > 32\n           compute box = function mod(point 32) + 1\n           compute degrees = point * 11.25\n           compute fudge = function mod(point 3)\n           evaluate fudge\n              when equal 1\n                  add 5.62 to degrees\n              when equal 2\n                  subtract 5.62 from degrees\n           end-evaluate\n\n           compute degrees-rounded rounded = degrees\n           move degrees-rounded to show-degrees\n           inspect show-degrees replacing trailing '00' by '0 '\n           inspect show-degrees replacing trailing '50' by '5 '\n\n           move short-name(point + 1) to compass\n           move spaces to compass-point\n           display space box space space space with no advancing\n           perform varying tally from 1 by 1 until tally > 4\n               move compass(tally:1) to shortform\n               move function concatenate(function trim(compass-point),\n                    function substitute(shortform,\n                        \"N\", \"North\",\n                        \"E\", \"East\",\n                        \"S\", \"South\",\n                        \"W\", \"West\",\n                        \"b\", \" byZ\",\n                        \"-\", \"-\"))\n                 to compass-point\n           end-perform\n           move function substitute(compass-point, \"Z\", \" \")\n             to compass-point\n           move function lower-case(compass-point) to compass-point\n           move function upper-case(compass-point(1:1))\n             to compass-point(1:1)\n           display compass-point space show-degrees\n       end-perform\n       goback.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace BoxTheCompass\n{\n    class Compass\n    {\n        string[] cp = new string[] {\"North\", \"North by east\", \"North-northeast\", \"Northeast by north\", \"Northeast\",\"Northeast by east\", \n\t    \"East-northeast\", \"East by north\", \"East\", \"East by south\", \"East-southeast\", \"Southeast by east\", \"Southeast\", \n            \"Southeast by south\", \"South-southeast\", \"South by east\", \"South\", \"South by west\", \"South-southwest\", \"Southwest by south\", \n            \"Southwest\", \"Southwest by west\", \"West-southwest\", \"West by south\", \"West\", \"West by north\", \"West-northwest\", \n            \"Northwest by west\", \"Northwest\", \"Northwest by north\", \"North-northwest\", \"North by west\", \"North\"};\n\n        public void compassHeading(float a)\n        {\n            int h = Convert.ToInt32(Math.Floor(a / 11.25f + .5f)) % 32;\n            Console.WriteLine( \"{0,2}: {1,-22}\u00a0: {2,6:N}\",h + 1, cp[h], a );\n        }\n    };\n    class Program\n    {\n        static void Main(string[] args)\n       {\n            Compass c = new Compass();\n            float[] degs = new float[] {0.0f, 16.87f, 16.88f, 33.75f, 50.62f, 50.63f, 67.5f, 84.37f, 84.38f, 101.25f, \n                118.12f, 118.13f, 135.0f, 151.87f, 151.88f, 168.75f, 185.62f, 185.63f, 202.5f, 219.37f, 219.38f, 236.25f, \n                253.12f, 253.13f, 270.0f, 286.87f, 286.88f, 303.75f, 320.62f, 320.63f, 337.5f, 354.37f, 354.38f};\n\n            foreach (float d in degs)\n                c.compassHeading(d);\n\n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 58866, "name": "Box the compass", "source": "Translate COBOL to Java:        identification division.\n       program-id. box-compass.\n       data division.\n       working-storage section.\n       01 point                pic 99.\n       01 degrees              usage float-short.\n       01 degrees-rounded      pic 999v99.\n       01 show-degrees         pic zz9.99.\n       01 box                  pic z9.\n       01 fudge                pic 9.\n       01 compass              pic x(4).\n       01 compass-point        pic x(18).\n       01 shortform            pic x.\n       01 short-names.\n          05 short-name        pic x(4) occurs 33 times.\n       01 overlay.\n          05 value \"N   \" & \"NbE \" & \"N-NE\" & \"NEbN\" & \"NE  \" &\n                   \"NEbE\" & \"E-NE\" & \"EbN \" & \"E   \" & \"EbS \" &\n                   \"E-SE\" & \"SEbE\" & \"SE  \" & \"SEbS\" & \"S-SE\" &\n                   \"SbE \" & \"S   \" & \"SbW \" & \"S-SW\" & \"SWbS\" &\n                   \"SW  \" & \"SWbW\" & \"W-SW\" & \"WbS \" & \"W   \" &\n                   \"WbN \" & \"W-NW\" & \"NWbW\" & \"NW  \" & \"NWbN\" &\n                   \"N-NW\" & \"NbW \" & \"N   \".\n\n       procedure division.\n       display \"Index Compass point      Degree\"\n\n       move overlay to short-names.\n       perform varying point from 0 by 1 until point > 32\n           compute box = function mod(point 32) + 1\n           compute degrees = point * 11.25\n           compute fudge = function mod(point 3)\n           evaluate fudge\n              when equal 1\n                  add 5.62 to degrees\n              when equal 2\n                  subtract 5.62 from degrees\n           end-evaluate\n\n           compute degrees-rounded rounded = degrees\n           move degrees-rounded to show-degrees\n           inspect show-degrees replacing trailing '00' by '0 '\n           inspect show-degrees replacing trailing '50' by '5 '\n\n           move short-name(point + 1) to compass\n           move spaces to compass-point\n           display space box space space space with no advancing\n           perform varying tally from 1 by 1 until tally > 4\n               move compass(tally:1) to shortform\n               move function concatenate(function trim(compass-point),\n                    function substitute(shortform,\n                        \"N\", \"North\",\n                        \"E\", \"East\",\n                        \"S\", \"South\",\n                        \"W\", \"West\",\n                        \"b\", \" byZ\",\n                        \"-\", \"-\"))\n                 to compass-point\n           end-perform\n           move function substitute(compass-point, \"Z\", \" \")\n             to compass-point\n           move function lower-case(compass-point) to compass-point\n           move function upper-case(compass-point(1:1))\n             to compass-point(1:1)\n           display compass-point space show-degrees\n       end-perform\n       goback.\n", "target": "public class BoxingTheCompass{\n    private static String[] points = new String[32];\n \n    public static void main(String[] args){\n        buildPoints();\n \n        double heading = 0;\n \n        for(int i = 0; i<= 32;i++){\n            heading = i * 11.25;\n            switch(i % 3){\n                case 1:\n                    heading += 5.62;\n                    break;\n                case 2:\n                    heading -= 5.62;\n                    break;\n                default:\n            }\n \n            System.out.printf(\"%s\\t%18s\\t%s\u00b0\\n\",(i % 32) + 1, initialUpper(getPoint(heading)), heading);\n        }\n    }\n \n    private static void buildPoints(){\n        String[] cardinal = {\"north\", \"east\", \"south\", \"west\"};\n        String[] pointDesc = {\"1\", \"1 by 2\", \"1-C\", \"C by 1\", \"C\", \"C by 2\", \"2-C\", \"2 by 1\"};\n \n        String str1, str2, strC;\n \n        for(int i = 0;i <= 3;i++){\n            str1 = cardinal[i];\n            str2 = cardinal[(i + 1) % 4];\n            strC = (str1.equals(\"north\") || str1.equals(\"south\")) ? (str1 + str2): (str2 + str1);\n            for(int j = 0;j <= 7;j++){\n                points[i * 8 + j] = pointDesc[j].replace(\"1\", str1).replace(\"2\", str2).replace(\"C\", strC);\n            }\n        }\n    }\n \n    private static String initialUpper(String s){\n        return s.substring(0, 1).toUpperCase() + s.substring(1);\n    }\n \n    private static String getPoint(double degrees){\n        double testD = (degrees / 11.25) + 0.5;\n        return points[(int)Math.floor(testD % 32)];\n    }\n}\n"}
{"id": 58867, "name": "Box the compass", "source": "Translate COBOL to Java:        identification division.\n       program-id. box-compass.\n       data division.\n       working-storage section.\n       01 point                pic 99.\n       01 degrees              usage float-short.\n       01 degrees-rounded      pic 999v99.\n       01 show-degrees         pic zz9.99.\n       01 box                  pic z9.\n       01 fudge                pic 9.\n       01 compass              pic x(4).\n       01 compass-point        pic x(18).\n       01 shortform            pic x.\n       01 short-names.\n          05 short-name        pic x(4) occurs 33 times.\n       01 overlay.\n          05 value \"N   \" & \"NbE \" & \"N-NE\" & \"NEbN\" & \"NE  \" &\n                   \"NEbE\" & \"E-NE\" & \"EbN \" & \"E   \" & \"EbS \" &\n                   \"E-SE\" & \"SEbE\" & \"SE  \" & \"SEbS\" & \"S-SE\" &\n                   \"SbE \" & \"S   \" & \"SbW \" & \"S-SW\" & \"SWbS\" &\n                   \"SW  \" & \"SWbW\" & \"W-SW\" & \"WbS \" & \"W   \" &\n                   \"WbN \" & \"W-NW\" & \"NWbW\" & \"NW  \" & \"NWbN\" &\n                   \"N-NW\" & \"NbW \" & \"N   \".\n\n       procedure division.\n       display \"Index Compass point      Degree\"\n\n       move overlay to short-names.\n       perform varying point from 0 by 1 until point > 32\n           compute box = function mod(point 32) + 1\n           compute degrees = point * 11.25\n           compute fudge = function mod(point 3)\n           evaluate fudge\n              when equal 1\n                  add 5.62 to degrees\n              when equal 2\n                  subtract 5.62 from degrees\n           end-evaluate\n\n           compute degrees-rounded rounded = degrees\n           move degrees-rounded to show-degrees\n           inspect show-degrees replacing trailing '00' by '0 '\n           inspect show-degrees replacing trailing '50' by '5 '\n\n           move short-name(point + 1) to compass\n           move spaces to compass-point\n           display space box space space space with no advancing\n           perform varying tally from 1 by 1 until tally > 4\n               move compass(tally:1) to shortform\n               move function concatenate(function trim(compass-point),\n                    function substitute(shortform,\n                        \"N\", \"North\",\n                        \"E\", \"East\",\n                        \"S\", \"South\",\n                        \"W\", \"West\",\n                        \"b\", \" byZ\",\n                        \"-\", \"-\"))\n                 to compass-point\n           end-perform\n           move function substitute(compass-point, \"Z\", \" \")\n             to compass-point\n           move function lower-case(compass-point) to compass-point\n           move function upper-case(compass-point(1:1))\n             to compass-point(1:1)\n           display compass-point space show-degrees\n       end-perform\n       goback.\n", "target": "public class BoxingTheCompass{\n    private static String[] points = new String[32];\n \n    public static void main(String[] args){\n        buildPoints();\n \n        double heading = 0;\n \n        for(int i = 0; i<= 32;i++){\n            heading = i * 11.25;\n            switch(i % 3){\n                case 1:\n                    heading += 5.62;\n                    break;\n                case 2:\n                    heading -= 5.62;\n                    break;\n                default:\n            }\n \n            System.out.printf(\"%s\\t%18s\\t%s\u00b0\\n\",(i % 32) + 1, initialUpper(getPoint(heading)), heading);\n        }\n    }\n \n    private static void buildPoints(){\n        String[] cardinal = {\"north\", \"east\", \"south\", \"west\"};\n        String[] pointDesc = {\"1\", \"1 by 2\", \"1-C\", \"C by 1\", \"C\", \"C by 2\", \"2-C\", \"2 by 1\"};\n \n        String str1, str2, strC;\n \n        for(int i = 0;i <= 3;i++){\n            str1 = cardinal[i];\n            str2 = cardinal[(i + 1) % 4];\n            strC = (str1.equals(\"north\") || str1.equals(\"south\")) ? (str1 + str2): (str2 + str1);\n            for(int j = 0;j <= 7;j++){\n                points[i * 8 + j] = pointDesc[j].replace(\"1\", str1).replace(\"2\", str2).replace(\"C\", strC);\n            }\n        }\n    }\n \n    private static String initialUpper(String s){\n        return s.substring(0, 1).toUpperCase() + s.substring(1);\n    }\n \n    private static String getPoint(double degrees){\n        double testD = (degrees / 11.25) + 0.5;\n        return points[(int)Math.floor(testD % 32)];\n    }\n}\n"}
{"id": 58868, "name": "Box the compass", "source": "Translate COBOL to Python:        identification division.\n       program-id. box-compass.\n       data division.\n       working-storage section.\n       01 point                pic 99.\n       01 degrees              usage float-short.\n       01 degrees-rounded      pic 999v99.\n       01 show-degrees         pic zz9.99.\n       01 box                  pic z9.\n       01 fudge                pic 9.\n       01 compass              pic x(4).\n       01 compass-point        pic x(18).\n       01 shortform            pic x.\n       01 short-names.\n          05 short-name        pic x(4) occurs 33 times.\n       01 overlay.\n          05 value \"N   \" & \"NbE \" & \"N-NE\" & \"NEbN\" & \"NE  \" &\n                   \"NEbE\" & \"E-NE\" & \"EbN \" & \"E   \" & \"EbS \" &\n                   \"E-SE\" & \"SEbE\" & \"SE  \" & \"SEbS\" & \"S-SE\" &\n                   \"SbE \" & \"S   \" & \"SbW \" & \"S-SW\" & \"SWbS\" &\n                   \"SW  \" & \"SWbW\" & \"W-SW\" & \"WbS \" & \"W   \" &\n                   \"WbN \" & \"W-NW\" & \"NWbW\" & \"NW  \" & \"NWbN\" &\n                   \"N-NW\" & \"NbW \" & \"N   \".\n\n       procedure division.\n       display \"Index Compass point      Degree\"\n\n       move overlay to short-names.\n       perform varying point from 0 by 1 until point > 32\n           compute box = function mod(point 32) + 1\n           compute degrees = point * 11.25\n           compute fudge = function mod(point 3)\n           evaluate fudge\n              when equal 1\n                  add 5.62 to degrees\n              when equal 2\n                  subtract 5.62 from degrees\n           end-evaluate\n\n           compute degrees-rounded rounded = degrees\n           move degrees-rounded to show-degrees\n           inspect show-degrees replacing trailing '00' by '0 '\n           inspect show-degrees replacing trailing '50' by '5 '\n\n           move short-name(point + 1) to compass\n           move spaces to compass-point\n           display space box space space space with no advancing\n           perform varying tally from 1 by 1 until tally > 4\n               move compass(tally:1) to shortform\n               move function concatenate(function trim(compass-point),\n                    function substitute(shortform,\n                        \"N\", \"North\",\n                        \"E\", \"East\",\n                        \"S\", \"South\",\n                        \"W\", \"West\",\n                        \"b\", \" byZ\",\n                        \"-\", \"-\"))\n                 to compass-point\n           end-perform\n           move function substitute(compass-point, \"Z\", \" \")\n             to compass-point\n           move function lower-case(compass-point) to compass-point\n           move function upper-case(compass-point(1:1))\n             to compass-point(1:1)\n           display compass-point space show-degrees\n       end-perform\n       goback.\n", "target": "majors   = 'north east south west'.split()\nmajors   *= 2 \nquarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')\nquarter2 = [p.replace('NE','EN') for p in quarter1]\n\ndef degrees2compasspoint(d):\n    d = (d % 360) + 360/64\n    majorindex, minor = divmod(d, 90.)\n    majorindex = int(majorindex)\n    minorindex  = int( (minor*4) // 45 )\n    p1, p2 = majors[majorindex: majorindex+2]\n    if p1 in {'north', 'south'}:\n        q = quarter1\n    else:\n        q = quarter2\n    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()\n\nif __name__ == '__main__':\n    for i in range(33):\n        d = i * 11.25\n        m = i % 3\n        if   m == 1: d += 5.62\n        elif m == 2: d -= 5.62\n        n = i % 32 + 1\n        print( '%2i %-18s %7.2f\u00b0' % (n, degrees2compasspoint(d), d) )\n"}
{"id": 58869, "name": "Box the compass", "source": "Translate COBOL to Python:        identification division.\n       program-id. box-compass.\n       data division.\n       working-storage section.\n       01 point                pic 99.\n       01 degrees              usage float-short.\n       01 degrees-rounded      pic 999v99.\n       01 show-degrees         pic zz9.99.\n       01 box                  pic z9.\n       01 fudge                pic 9.\n       01 compass              pic x(4).\n       01 compass-point        pic x(18).\n       01 shortform            pic x.\n       01 short-names.\n          05 short-name        pic x(4) occurs 33 times.\n       01 overlay.\n          05 value \"N   \" & \"NbE \" & \"N-NE\" & \"NEbN\" & \"NE  \" &\n                   \"NEbE\" & \"E-NE\" & \"EbN \" & \"E   \" & \"EbS \" &\n                   \"E-SE\" & \"SEbE\" & \"SE  \" & \"SEbS\" & \"S-SE\" &\n                   \"SbE \" & \"S   \" & \"SbW \" & \"S-SW\" & \"SWbS\" &\n                   \"SW  \" & \"SWbW\" & \"W-SW\" & \"WbS \" & \"W   \" &\n                   \"WbN \" & \"W-NW\" & \"NWbW\" & \"NW  \" & \"NWbN\" &\n                   \"N-NW\" & \"NbW \" & \"N   \".\n\n       procedure division.\n       display \"Index Compass point      Degree\"\n\n       move overlay to short-names.\n       perform varying point from 0 by 1 until point > 32\n           compute box = function mod(point 32) + 1\n           compute degrees = point * 11.25\n           compute fudge = function mod(point 3)\n           evaluate fudge\n              when equal 1\n                  add 5.62 to degrees\n              when equal 2\n                  subtract 5.62 from degrees\n           end-evaluate\n\n           compute degrees-rounded rounded = degrees\n           move degrees-rounded to show-degrees\n           inspect show-degrees replacing trailing '00' by '0 '\n           inspect show-degrees replacing trailing '50' by '5 '\n\n           move short-name(point + 1) to compass\n           move spaces to compass-point\n           display space box space space space with no advancing\n           perform varying tally from 1 by 1 until tally > 4\n               move compass(tally:1) to shortform\n               move function concatenate(function trim(compass-point),\n                    function substitute(shortform,\n                        \"N\", \"North\",\n                        \"E\", \"East\",\n                        \"S\", \"South\",\n                        \"W\", \"West\",\n                        \"b\", \" byZ\",\n                        \"-\", \"-\"))\n                 to compass-point\n           end-perform\n           move function substitute(compass-point, \"Z\", \" \")\n             to compass-point\n           move function lower-case(compass-point) to compass-point\n           move function upper-case(compass-point(1:1))\n             to compass-point(1:1)\n           display compass-point space show-degrees\n       end-perform\n       goback.\n", "target": "majors   = 'north east south west'.split()\nmajors   *= 2 \nquarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')\nquarter2 = [p.replace('NE','EN') for p in quarter1]\n\ndef degrees2compasspoint(d):\n    d = (d % 360) + 360/64\n    majorindex, minor = divmod(d, 90.)\n    majorindex = int(majorindex)\n    minorindex  = int( (minor*4) // 45 )\n    p1, p2 = majors[majorindex: majorindex+2]\n    if p1 in {'north', 'south'}:\n        q = quarter1\n    else:\n        q = quarter2\n    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()\n\nif __name__ == '__main__':\n    for i in range(33):\n        d = i * 11.25\n        m = i % 3\n        if   m == 1: d += 5.62\n        elif m == 2: d -= 5.62\n        n = i % 32 + 1\n        print( '%2i %-18s %7.2f\u00b0' % (n, degrees2compasspoint(d), d) )\n"}
{"id": 59918, "name": "99 bottles of beer", "source": "Translate COBOL to C#: identification division.\nprogram-id. ninety-nine.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter\tpic 99.\n\t88 no-bottles-left value 0.\n\t88 one-bottle-left value 1.\n\n01\tparts-of-counter redefines counter.\n\t05\ttens\t\tpic 9.\n\t05\tdigits\t\tpic 9.\n\n01\tafter-ten-words.\n\t05\tfiller\tpic x(7) value spaces.\n\t05\tfiller\tpic x(7) value \"Twenty\".\n\t05\tfiller\tpic x(7) value \"Thirty\".\n\t05\tfiller\tpic x(7) value \"Forty\".\n\t05\tfiller\tpic x(7) value \"Fifty\".\n\t05\tfiller\tpic x(7) value \"Sixty\".\n\t05\tfiller\tpic x(7) value \"Seventy\".\n\t05\tfiller\tpic x(7) value \"Eighty\".\n\t05\tfiller\tpic x(7) value \"Ninety\".\n\t05\tfiller\tpic x(7) value spaces.\n\n01\tafter-ten-array redefines after-ten-words.\n\t05\tatens occurs 10 times pic x(7).\n\n01\tdigit-words.\n\t05\tfiller\tpic x(9) value \"One\".\n\t05\tfiller\tpic x(9) value \"Two\".\n\t05\tfiller\tpic x(9) value \"Three\".\n\t05\tfiller\tpic x(9) value \"Four\".\n\t05\tfiller\tpic x(9) value \"Five\".\n\t05\tfiller\tpic x(9) value \"Six\".\n\t05\tfiller\tpic x(9) value \"Seven\".\n\t05\tfiller\tpic x(9) value \"Eight\".\n\t05\tfiller\tpic x(9) value \"Nine\".\n\t05\tfiller\tpic x(9) value \"Ten\".\n\t05\tfiller\tpic x(9) value \"Eleven\".\n\t05\tfiller\tpic x(9) value \"Twelve\".\n\t05\tfiller\tpic x(9) value \"Thirteen\".\n\t05\tfiller\tpic x(9) value \"Fourteen\".\n\t05\tfiller\tpic x(9) value \"Fifteen\".\n\t05\tfiller\tpic x(9) value \"Sixteen\".\n\t05\tfiller\tpic x(9) value \"Seventeen\".\n\t05\tfiller\tpic x(9) value \"Eighteen\".\n\t05\tfiller\tpic x(9) value \"Nineteen\".\n\t05\tfiller\tpic x(9) value spaces.\n\t\n01\tdigit-array redefines digit-words.\n\t05\tadigits occurs 20 times \tpic x(9).\n\t\n01\tnumber-name pic x(15).\n\nprocedure division.\n100-main section.\n100-setup.\n\tperform varying counter from 99 by -1 until no-bottles-left\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tperform 100-show-number\n\t\tdisplay \" of beer\"\n\t\tdisplay \"Take \" with no advancing\n\t\tif one-bottle-left \n\t\t\tdisplay \"it \" with no advancing\n\t\telse\n\t\t\tdisplay \"one \" with no advancing\n\t\tend-if\n\t\tdisplay \"down and pass it round\"\n\t\tsubtract 1 from counter giving counter\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tadd 1 to counter giving counter\n\t\tdisplay space\n\tend-perform.\n\tdisplay \"No more bottles of beer on the wall\"\n\tdisplay \"No more bottles of beer\"\n\tdisplay \"Go to the store and buy some more\"\n\tdisplay \"Ninety Nine bottles of beer on the wall\"\n\tstop run.\n\t\n100-show-number.\n\tif no-bottles-left \n\t\tdisplay \"No more\" with no advancing\n\telse \n\t\tif counter < 20\n\t\t\tdisplay function trim( adigits( counter ) ) with no advancing\n\t\telse \n\t\t\tif counter < 100\n\t\t\t\tmove spaces to number-name\n\t\t\t\tstring atens( tens ) delimited by space, space delimited by size, adigits( digits ) delimited by space into number-name\n\t\t\t\tdisplay function trim( number-name) with no advancing\n\t\t\tend-if\n\t\tend-if\n\tend-if.\n\tif one-bottle-left\n\t\tdisplay \" bottle\" with no advancing\n\telse\n\t\tdisplay \" bottles\" with no advancing\n\tend-if.\n\n100-end.\nend-program.\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 99; i > -1; i--)\n        {\n            if (i == 0)\n            {\n                Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\");\n                Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n                break;\n            }\n            if (i == 1)\n            {\n                Console.WriteLine(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n                Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"{0} bottles of beer on the wall, {0} bottles of beer.\", i);\n                Console.WriteLine(\"Take one down and pass it around, {0} bottles of beer on the wall.\", i - 1);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 59919, "name": "99 bottles of beer", "source": "Translate COBOL to C#: identification division.\nprogram-id. ninety-nine.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter\tpic 99.\n\t88 no-bottles-left value 0.\n\t88 one-bottle-left value 1.\n\n01\tparts-of-counter redefines counter.\n\t05\ttens\t\tpic 9.\n\t05\tdigits\t\tpic 9.\n\n01\tafter-ten-words.\n\t05\tfiller\tpic x(7) value spaces.\n\t05\tfiller\tpic x(7) value \"Twenty\".\n\t05\tfiller\tpic x(7) value \"Thirty\".\n\t05\tfiller\tpic x(7) value \"Forty\".\n\t05\tfiller\tpic x(7) value \"Fifty\".\n\t05\tfiller\tpic x(7) value \"Sixty\".\n\t05\tfiller\tpic x(7) value \"Seventy\".\n\t05\tfiller\tpic x(7) value \"Eighty\".\n\t05\tfiller\tpic x(7) value \"Ninety\".\n\t05\tfiller\tpic x(7) value spaces.\n\n01\tafter-ten-array redefines after-ten-words.\n\t05\tatens occurs 10 times pic x(7).\n\n01\tdigit-words.\n\t05\tfiller\tpic x(9) value \"One\".\n\t05\tfiller\tpic x(9) value \"Two\".\n\t05\tfiller\tpic x(9) value \"Three\".\n\t05\tfiller\tpic x(9) value \"Four\".\n\t05\tfiller\tpic x(9) value \"Five\".\n\t05\tfiller\tpic x(9) value \"Six\".\n\t05\tfiller\tpic x(9) value \"Seven\".\n\t05\tfiller\tpic x(9) value \"Eight\".\n\t05\tfiller\tpic x(9) value \"Nine\".\n\t05\tfiller\tpic x(9) value \"Ten\".\n\t05\tfiller\tpic x(9) value \"Eleven\".\n\t05\tfiller\tpic x(9) value \"Twelve\".\n\t05\tfiller\tpic x(9) value \"Thirteen\".\n\t05\tfiller\tpic x(9) value \"Fourteen\".\n\t05\tfiller\tpic x(9) value \"Fifteen\".\n\t05\tfiller\tpic x(9) value \"Sixteen\".\n\t05\tfiller\tpic x(9) value \"Seventeen\".\n\t05\tfiller\tpic x(9) value \"Eighteen\".\n\t05\tfiller\tpic x(9) value \"Nineteen\".\n\t05\tfiller\tpic x(9) value spaces.\n\t\n01\tdigit-array redefines digit-words.\n\t05\tadigits occurs 20 times \tpic x(9).\n\t\n01\tnumber-name pic x(15).\n\nprocedure division.\n100-main section.\n100-setup.\n\tperform varying counter from 99 by -1 until no-bottles-left\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tperform 100-show-number\n\t\tdisplay \" of beer\"\n\t\tdisplay \"Take \" with no advancing\n\t\tif one-bottle-left \n\t\t\tdisplay \"it \" with no advancing\n\t\telse\n\t\t\tdisplay \"one \" with no advancing\n\t\tend-if\n\t\tdisplay \"down and pass it round\"\n\t\tsubtract 1 from counter giving counter\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tadd 1 to counter giving counter\n\t\tdisplay space\n\tend-perform.\n\tdisplay \"No more bottles of beer on the wall\"\n\tdisplay \"No more bottles of beer\"\n\tdisplay \"Go to the store and buy some more\"\n\tdisplay \"Ninety Nine bottles of beer on the wall\"\n\tstop run.\n\t\n100-show-number.\n\tif no-bottles-left \n\t\tdisplay \"No more\" with no advancing\n\telse \n\t\tif counter < 20\n\t\t\tdisplay function trim( adigits( counter ) ) with no advancing\n\t\telse \n\t\t\tif counter < 100\n\t\t\t\tmove spaces to number-name\n\t\t\t\tstring atens( tens ) delimited by space, space delimited by size, adigits( digits ) delimited by space into number-name\n\t\t\t\tdisplay function trim( number-name) with no advancing\n\t\t\tend-if\n\t\tend-if\n\tend-if.\n\tif one-bottle-left\n\t\tdisplay \" bottle\" with no advancing\n\telse\n\t\tdisplay \" bottles\" with no advancing\n\tend-if.\n\n100-end.\nend-program.\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 99; i > -1; i--)\n        {\n            if (i == 0)\n            {\n                Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\");\n                Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n                break;\n            }\n            if (i == 1)\n            {\n                Console.WriteLine(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n                Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"{0} bottles of beer on the wall, {0} bottles of beer.\", i);\n                Console.WriteLine(\"Take one down and pass it around, {0} bottles of beer on the wall.\", i - 1);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 59922, "name": "99 bottles of beer", "source": "Translate COBOL to Java: identification division.\nprogram-id. ninety-nine.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter\tpic 99.\n\t88 no-bottles-left value 0.\n\t88 one-bottle-left value 1.\n\n01\tparts-of-counter redefines counter.\n\t05\ttens\t\tpic 9.\n\t05\tdigits\t\tpic 9.\n\n01\tafter-ten-words.\n\t05\tfiller\tpic x(7) value spaces.\n\t05\tfiller\tpic x(7) value \"Twenty\".\n\t05\tfiller\tpic x(7) value \"Thirty\".\n\t05\tfiller\tpic x(7) value \"Forty\".\n\t05\tfiller\tpic x(7) value \"Fifty\".\n\t05\tfiller\tpic x(7) value \"Sixty\".\n\t05\tfiller\tpic x(7) value \"Seventy\".\n\t05\tfiller\tpic x(7) value \"Eighty\".\n\t05\tfiller\tpic x(7) value \"Ninety\".\n\t05\tfiller\tpic x(7) value spaces.\n\n01\tafter-ten-array redefines after-ten-words.\n\t05\tatens occurs 10 times pic x(7).\n\n01\tdigit-words.\n\t05\tfiller\tpic x(9) value \"One\".\n\t05\tfiller\tpic x(9) value \"Two\".\n\t05\tfiller\tpic x(9) value \"Three\".\n\t05\tfiller\tpic x(9) value \"Four\".\n\t05\tfiller\tpic x(9) value \"Five\".\n\t05\tfiller\tpic x(9) value \"Six\".\n\t05\tfiller\tpic x(9) value \"Seven\".\n\t05\tfiller\tpic x(9) value \"Eight\".\n\t05\tfiller\tpic x(9) value \"Nine\".\n\t05\tfiller\tpic x(9) value \"Ten\".\n\t05\tfiller\tpic x(9) value \"Eleven\".\n\t05\tfiller\tpic x(9) value \"Twelve\".\n\t05\tfiller\tpic x(9) value \"Thirteen\".\n\t05\tfiller\tpic x(9) value \"Fourteen\".\n\t05\tfiller\tpic x(9) value \"Fifteen\".\n\t05\tfiller\tpic x(9) value \"Sixteen\".\n\t05\tfiller\tpic x(9) value \"Seventeen\".\n\t05\tfiller\tpic x(9) value \"Eighteen\".\n\t05\tfiller\tpic x(9) value \"Nineteen\".\n\t05\tfiller\tpic x(9) value spaces.\n\t\n01\tdigit-array redefines digit-words.\n\t05\tadigits occurs 20 times \tpic x(9).\n\t\n01\tnumber-name pic x(15).\n\nprocedure division.\n100-main section.\n100-setup.\n\tperform varying counter from 99 by -1 until no-bottles-left\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tperform 100-show-number\n\t\tdisplay \" of beer\"\n\t\tdisplay \"Take \" with no advancing\n\t\tif one-bottle-left \n\t\t\tdisplay \"it \" with no advancing\n\t\telse\n\t\t\tdisplay \"one \" with no advancing\n\t\tend-if\n\t\tdisplay \"down and pass it round\"\n\t\tsubtract 1 from counter giving counter\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tadd 1 to counter giving counter\n\t\tdisplay space\n\tend-perform.\n\tdisplay \"No more bottles of beer on the wall\"\n\tdisplay \"No more bottles of beer\"\n\tdisplay \"Go to the store and buy some more\"\n\tdisplay \"Ninety Nine bottles of beer on the wall\"\n\tstop run.\n\t\n100-show-number.\n\tif no-bottles-left \n\t\tdisplay \"No more\" with no advancing\n\telse \n\t\tif counter < 20\n\t\t\tdisplay function trim( adigits( counter ) ) with no advancing\n\t\telse \n\t\t\tif counter < 100\n\t\t\t\tmove spaces to number-name\n\t\t\t\tstring atens( tens ) delimited by space, space delimited by size, adigits( digits ) delimited by space into number-name\n\t\t\t\tdisplay function trim( number-name) with no advancing\n\t\t\tend-if\n\t\tend-if\n\tend-if.\n\tif one-bottle-left\n\t\tdisplay \" bottle\" with no advancing\n\telse\n\t\tdisplay \" bottles\" with no advancing\n\tend-if.\n\n100-end.\nend-program.\n", "target": "module Bottles\n    {\n    @Inject Console console;\n    void run()\n        {\n        function String(Int) num     = i -> i==0 ? \"No\" : i.toString();\n        function String(Int) bottles = i -> i==1 ? \"bottle\" : \"bottles\";\n\n        for (Int remain : 99..1)\n            {\n            console.print($|{num(remain)} {bottles(remain)} of beer on the wall\n                           |{num(remain)} {bottles(remain)} of beer\n                           |Take one down, pass it around\n                           |{num(remain-1)} {bottles(remain-1)} of beer on the wall\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 59923, "name": "99 bottles of beer", "source": "Translate COBOL to Java: identification division.\nprogram-id. ninety-nine.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter\tpic 99.\n\t88 no-bottles-left value 0.\n\t88 one-bottle-left value 1.\n\n01\tparts-of-counter redefines counter.\n\t05\ttens\t\tpic 9.\n\t05\tdigits\t\tpic 9.\n\n01\tafter-ten-words.\n\t05\tfiller\tpic x(7) value spaces.\n\t05\tfiller\tpic x(7) value \"Twenty\".\n\t05\tfiller\tpic x(7) value \"Thirty\".\n\t05\tfiller\tpic x(7) value \"Forty\".\n\t05\tfiller\tpic x(7) value \"Fifty\".\n\t05\tfiller\tpic x(7) value \"Sixty\".\n\t05\tfiller\tpic x(7) value \"Seventy\".\n\t05\tfiller\tpic x(7) value \"Eighty\".\n\t05\tfiller\tpic x(7) value \"Ninety\".\n\t05\tfiller\tpic x(7) value spaces.\n\n01\tafter-ten-array redefines after-ten-words.\n\t05\tatens occurs 10 times pic x(7).\n\n01\tdigit-words.\n\t05\tfiller\tpic x(9) value \"One\".\n\t05\tfiller\tpic x(9) value \"Two\".\n\t05\tfiller\tpic x(9) value \"Three\".\n\t05\tfiller\tpic x(9) value \"Four\".\n\t05\tfiller\tpic x(9) value \"Five\".\n\t05\tfiller\tpic x(9) value \"Six\".\n\t05\tfiller\tpic x(9) value \"Seven\".\n\t05\tfiller\tpic x(9) value \"Eight\".\n\t05\tfiller\tpic x(9) value \"Nine\".\n\t05\tfiller\tpic x(9) value \"Ten\".\n\t05\tfiller\tpic x(9) value \"Eleven\".\n\t05\tfiller\tpic x(9) value \"Twelve\".\n\t05\tfiller\tpic x(9) value \"Thirteen\".\n\t05\tfiller\tpic x(9) value \"Fourteen\".\n\t05\tfiller\tpic x(9) value \"Fifteen\".\n\t05\tfiller\tpic x(9) value \"Sixteen\".\n\t05\tfiller\tpic x(9) value \"Seventeen\".\n\t05\tfiller\tpic x(9) value \"Eighteen\".\n\t05\tfiller\tpic x(9) value \"Nineteen\".\n\t05\tfiller\tpic x(9) value spaces.\n\t\n01\tdigit-array redefines digit-words.\n\t05\tadigits occurs 20 times \tpic x(9).\n\t\n01\tnumber-name pic x(15).\n\nprocedure division.\n100-main section.\n100-setup.\n\tperform varying counter from 99 by -1 until no-bottles-left\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tperform 100-show-number\n\t\tdisplay \" of beer\"\n\t\tdisplay \"Take \" with no advancing\n\t\tif one-bottle-left \n\t\t\tdisplay \"it \" with no advancing\n\t\telse\n\t\t\tdisplay \"one \" with no advancing\n\t\tend-if\n\t\tdisplay \"down and pass it round\"\n\t\tsubtract 1 from counter giving counter\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tadd 1 to counter giving counter\n\t\tdisplay space\n\tend-perform.\n\tdisplay \"No more bottles of beer on the wall\"\n\tdisplay \"No more bottles of beer\"\n\tdisplay \"Go to the store and buy some more\"\n\tdisplay \"Ninety Nine bottles of beer on the wall\"\n\tstop run.\n\t\n100-show-number.\n\tif no-bottles-left \n\t\tdisplay \"No more\" with no advancing\n\telse \n\t\tif counter < 20\n\t\t\tdisplay function trim( adigits( counter ) ) with no advancing\n\t\telse \n\t\t\tif counter < 100\n\t\t\t\tmove spaces to number-name\n\t\t\t\tstring atens( tens ) delimited by space, space delimited by size, adigits( digits ) delimited by space into number-name\n\t\t\t\tdisplay function trim( number-name) with no advancing\n\t\t\tend-if\n\t\tend-if\n\tend-if.\n\tif one-bottle-left\n\t\tdisplay \" bottle\" with no advancing\n\telse\n\t\tdisplay \" bottles\" with no advancing\n\tend-if.\n\n100-end.\nend-program.\n", "target": "module Bottles\n    {\n    @Inject Console console;\n    void run()\n        {\n        function String(Int) num     = i -> i==0 ? \"No\" : i.toString();\n        function String(Int) bottles = i -> i==1 ? \"bottle\" : \"bottles\";\n\n        for (Int remain : 99..1)\n            {\n            console.print($|{num(remain)} {bottles(remain)} of beer on the wall\n                           |{num(remain)} {bottles(remain)} of beer\n                           |Take one down, pass it around\n                           |{num(remain-1)} {bottles(remain-1)} of beer on the wall\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 59924, "name": "99 bottles of beer", "source": "Translate COBOL to Python: identification division.\nprogram-id. ninety-nine.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter\tpic 99.\n\t88 no-bottles-left value 0.\n\t88 one-bottle-left value 1.\n\n01\tparts-of-counter redefines counter.\n\t05\ttens\t\tpic 9.\n\t05\tdigits\t\tpic 9.\n\n01\tafter-ten-words.\n\t05\tfiller\tpic x(7) value spaces.\n\t05\tfiller\tpic x(7) value \"Twenty\".\n\t05\tfiller\tpic x(7) value \"Thirty\".\n\t05\tfiller\tpic x(7) value \"Forty\".\n\t05\tfiller\tpic x(7) value \"Fifty\".\n\t05\tfiller\tpic x(7) value \"Sixty\".\n\t05\tfiller\tpic x(7) value \"Seventy\".\n\t05\tfiller\tpic x(7) value \"Eighty\".\n\t05\tfiller\tpic x(7) value \"Ninety\".\n\t05\tfiller\tpic x(7) value spaces.\n\n01\tafter-ten-array redefines after-ten-words.\n\t05\tatens occurs 10 times pic x(7).\n\n01\tdigit-words.\n\t05\tfiller\tpic x(9) value \"One\".\n\t05\tfiller\tpic x(9) value \"Two\".\n\t05\tfiller\tpic x(9) value \"Three\".\n\t05\tfiller\tpic x(9) value \"Four\".\n\t05\tfiller\tpic x(9) value \"Five\".\n\t05\tfiller\tpic x(9) value \"Six\".\n\t05\tfiller\tpic x(9) value \"Seven\".\n\t05\tfiller\tpic x(9) value \"Eight\".\n\t05\tfiller\tpic x(9) value \"Nine\".\n\t05\tfiller\tpic x(9) value \"Ten\".\n\t05\tfiller\tpic x(9) value \"Eleven\".\n\t05\tfiller\tpic x(9) value \"Twelve\".\n\t05\tfiller\tpic x(9) value \"Thirteen\".\n\t05\tfiller\tpic x(9) value \"Fourteen\".\n\t05\tfiller\tpic x(9) value \"Fifteen\".\n\t05\tfiller\tpic x(9) value \"Sixteen\".\n\t05\tfiller\tpic x(9) value \"Seventeen\".\n\t05\tfiller\tpic x(9) value \"Eighteen\".\n\t05\tfiller\tpic x(9) value \"Nineteen\".\n\t05\tfiller\tpic x(9) value spaces.\n\t\n01\tdigit-array redefines digit-words.\n\t05\tadigits occurs 20 times \tpic x(9).\n\t\n01\tnumber-name pic x(15).\n\nprocedure division.\n100-main section.\n100-setup.\n\tperform varying counter from 99 by -1 until no-bottles-left\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tperform 100-show-number\n\t\tdisplay \" of beer\"\n\t\tdisplay \"Take \" with no advancing\n\t\tif one-bottle-left \n\t\t\tdisplay \"it \" with no advancing\n\t\telse\n\t\t\tdisplay \"one \" with no advancing\n\t\tend-if\n\t\tdisplay \"down and pass it round\"\n\t\tsubtract 1 from counter giving counter\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tadd 1 to counter giving counter\n\t\tdisplay space\n\tend-perform.\n\tdisplay \"No more bottles of beer on the wall\"\n\tdisplay \"No more bottles of beer\"\n\tdisplay \"Go to the store and buy some more\"\n\tdisplay \"Ninety Nine bottles of beer on the wall\"\n\tstop run.\n\t\n100-show-number.\n\tif no-bottles-left \n\t\tdisplay \"No more\" with no advancing\n\telse \n\t\tif counter < 20\n\t\t\tdisplay function trim( adigits( counter ) ) with no advancing\n\t\telse \n\t\t\tif counter < 100\n\t\t\t\tmove spaces to number-name\n\t\t\t\tstring atens( tens ) delimited by space, space delimited by size, adigits( digits ) delimited by space into number-name\n\t\t\t\tdisplay function trim( number-name) with no advancing\n\t\t\tend-if\n\t\tend-if\n\tend-if.\n\tif one-bottle-left\n\t\tdisplay \" bottle\" with no advancing\n\telse\n\t\tdisplay \" bottles\" with no advancing\n\tend-if.\n\n100-end.\nend-program.\n", "target": "fun bottles(n): match __args__:\n    (0) => \"No more bottles\"\n    (1) => \"1 bottle\"\n    (_) => \"$n bottles\"\n\nfor n in 99..-1..1:\n    print @format\n"}
{"id": 59925, "name": "99 bottles of beer", "source": "Translate COBOL to Python: identification division.\nprogram-id. ninety-nine.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter\tpic 99.\n\t88 no-bottles-left value 0.\n\t88 one-bottle-left value 1.\n\n01\tparts-of-counter redefines counter.\n\t05\ttens\t\tpic 9.\n\t05\tdigits\t\tpic 9.\n\n01\tafter-ten-words.\n\t05\tfiller\tpic x(7) value spaces.\n\t05\tfiller\tpic x(7) value \"Twenty\".\n\t05\tfiller\tpic x(7) value \"Thirty\".\n\t05\tfiller\tpic x(7) value \"Forty\".\n\t05\tfiller\tpic x(7) value \"Fifty\".\n\t05\tfiller\tpic x(7) value \"Sixty\".\n\t05\tfiller\tpic x(7) value \"Seventy\".\n\t05\tfiller\tpic x(7) value \"Eighty\".\n\t05\tfiller\tpic x(7) value \"Ninety\".\n\t05\tfiller\tpic x(7) value spaces.\n\n01\tafter-ten-array redefines after-ten-words.\n\t05\tatens occurs 10 times pic x(7).\n\n01\tdigit-words.\n\t05\tfiller\tpic x(9) value \"One\".\n\t05\tfiller\tpic x(9) value \"Two\".\n\t05\tfiller\tpic x(9) value \"Three\".\n\t05\tfiller\tpic x(9) value \"Four\".\n\t05\tfiller\tpic x(9) value \"Five\".\n\t05\tfiller\tpic x(9) value \"Six\".\n\t05\tfiller\tpic x(9) value \"Seven\".\n\t05\tfiller\tpic x(9) value \"Eight\".\n\t05\tfiller\tpic x(9) value \"Nine\".\n\t05\tfiller\tpic x(9) value \"Ten\".\n\t05\tfiller\tpic x(9) value \"Eleven\".\n\t05\tfiller\tpic x(9) value \"Twelve\".\n\t05\tfiller\tpic x(9) value \"Thirteen\".\n\t05\tfiller\tpic x(9) value \"Fourteen\".\n\t05\tfiller\tpic x(9) value \"Fifteen\".\n\t05\tfiller\tpic x(9) value \"Sixteen\".\n\t05\tfiller\tpic x(9) value \"Seventeen\".\n\t05\tfiller\tpic x(9) value \"Eighteen\".\n\t05\tfiller\tpic x(9) value \"Nineteen\".\n\t05\tfiller\tpic x(9) value spaces.\n\t\n01\tdigit-array redefines digit-words.\n\t05\tadigits occurs 20 times \tpic x(9).\n\t\n01\tnumber-name pic x(15).\n\nprocedure division.\n100-main section.\n100-setup.\n\tperform varying counter from 99 by -1 until no-bottles-left\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tperform 100-show-number\n\t\tdisplay \" of beer\"\n\t\tdisplay \"Take \" with no advancing\n\t\tif one-bottle-left \n\t\t\tdisplay \"it \" with no advancing\n\t\telse\n\t\t\tdisplay \"one \" with no advancing\n\t\tend-if\n\t\tdisplay \"down and pass it round\"\n\t\tsubtract 1 from counter giving counter\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tadd 1 to counter giving counter\n\t\tdisplay space\n\tend-perform.\n\tdisplay \"No more bottles of beer on the wall\"\n\tdisplay \"No more bottles of beer\"\n\tdisplay \"Go to the store and buy some more\"\n\tdisplay \"Ninety Nine bottles of beer on the wall\"\n\tstop run.\n\t\n100-show-number.\n\tif no-bottles-left \n\t\tdisplay \"No more\" with no advancing\n\telse \n\t\tif counter < 20\n\t\t\tdisplay function trim( adigits( counter ) ) with no advancing\n\t\telse \n\t\t\tif counter < 100\n\t\t\t\tmove spaces to number-name\n\t\t\t\tstring atens( tens ) delimited by space, space delimited by size, adigits( digits ) delimited by space into number-name\n\t\t\t\tdisplay function trim( number-name) with no advancing\n\t\t\tend-if\n\t\tend-if\n\tend-if.\n\tif one-bottle-left\n\t\tdisplay \" bottle\" with no advancing\n\telse\n\t\tdisplay \" bottles\" with no advancing\n\tend-if.\n\n100-end.\nend-program.\n", "target": "fun bottles(n): match __args__:\n    (0) => \"No more bottles\"\n    (1) => \"1 bottle\"\n    (_) => \"$n bottles\"\n\nfor n in 99..-1..1:\n    print @format\n"}
{"id": 60452, "name": "Strip a set of characters from a string", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Strip-Chars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Str-Size  CONSTANT 128.\n\n       LOCAL-STORAGE SECTION.\n       01  I       PIC 999.\n       01  Str-Pos PIC 999.\n\n       01  Offset  PIC 999.\n       01  New-Pos PIC 999.\n\n       01  Str-End PIC 999.\n\n       LINKAGE SECTION.\n       01  Str     PIC X(Str-Size).\n       01  Chars-To-Replace PIC X(256).\n\n       PROCEDURE DIVISION USING Str BY VALUE Chars-To-Replace.\n       Main.\n           PERFORM VARYING I FROM 1 BY 1\n                   UNTIL Chars-To-Replace (I:1) = X\"00\"\n\n               MOVE ZERO TO Offset\n\n*              \n*              \n               PERFORM VARYING Str-Pos FROM 1 BY 1\n                       UNTIL Str-Size < Str-Pos\n                   IF Str (Str-Pos:1) = Chars-To-Replace (I:1)\n                       ADD 1 TO Offset\n                   ELSE IF Offset NOT = ZERO\n                       COMPUTE New-Pos = Str-Pos - Offset\n                       MOVE Str (Str-Pos:1) TO Str (New-Pos:1)\n                   END-IF\n               END-PERFORM\n               \n*              \n*              \n               COMPUTE Str-End = Str-Size - Offset\n               MOVE SPACES TO Str (Str-End:Offset)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\n\npublic static string RemoveCharactersFromString(string testString, string removeChars)\n{\n    char[] charAry = removeChars.ToCharArray();\n    string returnString = testString;\n    foreach (char c in charAry)\n    {\n        while (returnString.IndexOf(c) > -1)\n        {\n            returnString = returnString.Remove(returnString.IndexOf(c), 1);\n        }\n    }\n    return returnString;\n}\n"}
{"id": 60454, "name": "Strip a set of characters from a string", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Strip-Chars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Str-Size  CONSTANT 128.\n\n       LOCAL-STORAGE SECTION.\n       01  I       PIC 999.\n       01  Str-Pos PIC 999.\n\n       01  Offset  PIC 999.\n       01  New-Pos PIC 999.\n\n       01  Str-End PIC 999.\n\n       LINKAGE SECTION.\n       01  Str     PIC X(Str-Size).\n       01  Chars-To-Replace PIC X(256).\n\n       PROCEDURE DIVISION USING Str BY VALUE Chars-To-Replace.\n       Main.\n           PERFORM VARYING I FROM 1 BY 1\n                   UNTIL Chars-To-Replace (I:1) = X\"00\"\n\n               MOVE ZERO TO Offset\n\n*              \n*              \n               PERFORM VARYING Str-Pos FROM 1 BY 1\n                       UNTIL Str-Size < Str-Pos\n                   IF Str (Str-Pos:1) = Chars-To-Replace (I:1)\n                       ADD 1 TO Offset\n                   ELSE IF Offset NOT = ZERO\n                       COMPUTE New-Pos = Str-Pos - Offset\n                       MOVE Str (Str-Pos:1) TO Str (New-Pos:1)\n                   END-IF\n               END-PERFORM\n               \n*              \n*              \n               COMPUTE Str-End = Str-Size - Offset\n               MOVE SPACES TO Str (Str-End:Offset)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "class StripChars {\n    public static String stripChars(String inString, String toStrip) {\n        return inString.replaceAll(\"[\" + toStrip + \"]\", \"\");\n    }\n\n    public static void main(String[] args) {\n        String sentence = \"She was a soul stripper. She took my heart!\";\n        String chars = \"aei\";\n        System.out.println(\"sentence: \" + sentence);\n        System.out.println(\"to strip: \" + chars);\n        System.out.println(\"stripped: \" + stripChars(sentence, chars));\n    }\n}\n"}
{"id": 60455, "name": "Strip a set of characters from a string", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Strip-Chars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Str-Size  CONSTANT 128.\n\n       LOCAL-STORAGE SECTION.\n       01  I       PIC 999.\n       01  Str-Pos PIC 999.\n\n       01  Offset  PIC 999.\n       01  New-Pos PIC 999.\n\n       01  Str-End PIC 999.\n\n       LINKAGE SECTION.\n       01  Str     PIC X(Str-Size).\n       01  Chars-To-Replace PIC X(256).\n\n       PROCEDURE DIVISION USING Str BY VALUE Chars-To-Replace.\n       Main.\n           PERFORM VARYING I FROM 1 BY 1\n                   UNTIL Chars-To-Replace (I:1) = X\"00\"\n\n               MOVE ZERO TO Offset\n\n*              \n*              \n               PERFORM VARYING Str-Pos FROM 1 BY 1\n                       UNTIL Str-Size < Str-Pos\n                   IF Str (Str-Pos:1) = Chars-To-Replace (I:1)\n                       ADD 1 TO Offset\n                   ELSE IF Offset NOT = ZERO\n                       COMPUTE New-Pos = Str-Pos - Offset\n                       MOVE Str (Str-Pos:1) TO Str (New-Pos:1)\n                   END-IF\n               END-PERFORM\n               \n*              \n*              \n               COMPUTE Str-End = Str-Size - Offset\n               MOVE SPACES TO Str (Str-End:Offset)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": ">>> def stripchars(s, chars):\n...     return s.translate(None, chars)\n... \n>>> stripchars(\"She was a soul stripper. She took my heart!\", \"aei\")\n'Sh ws  soul strppr. Sh took my hrt!'\n"}
{"id": 60799, "name": "Isqrt (integer square root) of X", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. I-SQRT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 QUAD-RET-VARS.\n          03 X          PIC 9(18).\n          03 Q          PIC 9(18).\n          03 Z          PIC 9(18).\n          03 T          PIC S9(18).\n          03 R          PIC 9(18).\n\n       01 TO-65-VARS.\n          03 ISQRT-N    PIC 99.\n          03 DISP-LN    PIC X(22) VALUE SPACES.\n          03 DISP-FMT   PIC Z9.\n          03 PTR        PIC 99 VALUE 1.\n\n       01 BIG-SQRT-VARS.\n          03 POW-7      PIC 9(18) VALUE 7.\n          03 POW-N      PIC 99 VALUE 1.\n          03 POW-N-OUT  PIC Z9.\n          03 POW-7-OUT  PIC Z(10).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SQRTS-TO-65.\n           PERFORM BIG-SQRTS.\n           STOP RUN.\n\n       SQRTS-TO-65.\n           PERFORM DISP-SMALL-SQRT\n           VARYING ISQRT-N FROM 0 BY 1\n           UNTIL ISQRT-N IS GREATER THAN 65.\n\n       DISP-SMALL-SQRT.\n           MOVE ISQRT-N TO X.\n           PERFORM ISQRT.\n           MOVE R TO DISP-FMT.\n           STRING DISP-FMT DELIMITED BY SIZE INTO DISP-LN \n           WITH POINTER PTR.\n           IF PTR IS GREATER THAN 22, \n               DISPLAY DISP-LN, \n               MOVE 1 TO PTR.\n\n       BIG-SQRTS.\n           PERFORM BIG-SQRT 10 TIMES.\n \n       BIG-SQRT.\n           MOVE POW-7 TO X.\n           PERFORM ISQRT.\n           MOVE POW-N TO POW-N-OUT. \n           MOVE R TO POW-7-OUT. \n           DISPLAY \"ISQRT(7^\" POW-N-OUT \") = \" POW-7-OUT.\n           ADD 2 TO POW-N.\n           MULTIPLY 49 BY POW-7.\n\n       ISQRT.\n           MOVE 1 TO Q.\n           PERFORM MUL-Q-BY-4 UNTIL Q IS GREATER THAN X.\n           MOVE X TO Z.\n           MOVE ZERO TO R.\n           PERFORM ISQRT-STEP UNTIL Q IS NOT GREATER THAN 1. \n\n       MUL-Q-BY-4.\n           MULTIPLY 4 BY Q.\n\n       ISQRT-STEP.\n           DIVIDE 4 INTO Q.\n           COMPUTE T = Z - R - Q.\n           DIVIDE 2 INTO R.\n           IF T IS NOT LESS THAN ZERO,\n               MOVE T TO Z,\n               ADD Q TO R.\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\u00a0\nclass Program {\n\u00a0\n    static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n        q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\u00a0\n    static void Main() { const int max = 73, smax = 65;\n        int power_width = ((BI.Pow(7, max).ToString().Length / 3) << 2) + 3,\n            isqrt_width = (power_width + 1) >> 1;\n        WriteLine(\"Integer square root for numbers 0 to {0}:\", smax);\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", \n            (n / 10).ToString().Replace(\"0\", \" \")); WriteLine();\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", n % 10); WriteLine();\n        WriteLine(new String('-', (smax << 1) + 1));\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", isqrt(n));\n        WriteLine(\"\\n\\nInteger square roots of odd powers of 7 from 1 to {0}:\", max);\n        string s = string.Format(\"[0,2] |[1,{0}:n0] |[2,{1}:n0]\",\n            power_width, isqrt_width).Replace(\"[\", \"{\").Replace(\"]\", \"}\");\n        WriteLine(s, \"n\", \"7 ^ n\", \"isqrt(7 ^ n)\");\n        WriteLine(new String('-', power_width + isqrt_width + 6));\n        BI p = 7; for (int n = 1; n <= max; n += 2, p *= 49)\n            WriteLine (s, n, p, isqrt(p)); }\n}\n"}
{"id": 60800, "name": "Isqrt (integer square root) of X", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. I-SQRT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 QUAD-RET-VARS.\n          03 X          PIC 9(18).\n          03 Q          PIC 9(18).\n          03 Z          PIC 9(18).\n          03 T          PIC S9(18).\n          03 R          PIC 9(18).\n\n       01 TO-65-VARS.\n          03 ISQRT-N    PIC 99.\n          03 DISP-LN    PIC X(22) VALUE SPACES.\n          03 DISP-FMT   PIC Z9.\n          03 PTR        PIC 99 VALUE 1.\n\n       01 BIG-SQRT-VARS.\n          03 POW-7      PIC 9(18) VALUE 7.\n          03 POW-N      PIC 99 VALUE 1.\n          03 POW-N-OUT  PIC Z9.\n          03 POW-7-OUT  PIC Z(10).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SQRTS-TO-65.\n           PERFORM BIG-SQRTS.\n           STOP RUN.\n\n       SQRTS-TO-65.\n           PERFORM DISP-SMALL-SQRT\n           VARYING ISQRT-N FROM 0 BY 1\n           UNTIL ISQRT-N IS GREATER THAN 65.\n\n       DISP-SMALL-SQRT.\n           MOVE ISQRT-N TO X.\n           PERFORM ISQRT.\n           MOVE R TO DISP-FMT.\n           STRING DISP-FMT DELIMITED BY SIZE INTO DISP-LN \n           WITH POINTER PTR.\n           IF PTR IS GREATER THAN 22, \n               DISPLAY DISP-LN, \n               MOVE 1 TO PTR.\n\n       BIG-SQRTS.\n           PERFORM BIG-SQRT 10 TIMES.\n \n       BIG-SQRT.\n           MOVE POW-7 TO X.\n           PERFORM ISQRT.\n           MOVE POW-N TO POW-N-OUT. \n           MOVE R TO POW-7-OUT. \n           DISPLAY \"ISQRT(7^\" POW-N-OUT \") = \" POW-7-OUT.\n           ADD 2 TO POW-N.\n           MULTIPLY 49 BY POW-7.\n\n       ISQRT.\n           MOVE 1 TO Q.\n           PERFORM MUL-Q-BY-4 UNTIL Q IS GREATER THAN X.\n           MOVE X TO Z.\n           MOVE ZERO TO R.\n           PERFORM ISQRT-STEP UNTIL Q IS NOT GREATER THAN 1. \n\n       MUL-Q-BY-4.\n           MULTIPLY 4 BY Q.\n\n       ISQRT-STEP.\n           DIVIDE 4 INTO Q.\n           COMPUTE T = Z - R - Q.\n           DIVIDE 2 INTO R.\n           IF T IS NOT LESS THAN ZERO,\n               MOVE T TO Z,\n               ADD Q TO R.\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\u00a0\nclass Program {\n\u00a0\n    static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n        q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\u00a0\n    static void Main() { const int max = 73, smax = 65;\n        int power_width = ((BI.Pow(7, max).ToString().Length / 3) << 2) + 3,\n            isqrt_width = (power_width + 1) >> 1;\n        WriteLine(\"Integer square root for numbers 0 to {0}:\", smax);\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", \n            (n / 10).ToString().Replace(\"0\", \" \")); WriteLine();\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", n % 10); WriteLine();\n        WriteLine(new String('-', (smax << 1) + 1));\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", isqrt(n));\n        WriteLine(\"\\n\\nInteger square roots of odd powers of 7 from 1 to {0}:\", max);\n        string s = string.Format(\"[0,2] |[1,{0}:n0] |[2,{1}:n0]\",\n            power_width, isqrt_width).Replace(\"[\", \"{\").Replace(\"]\", \"}\");\n        WriteLine(s, \"n\", \"7 ^ n\", \"isqrt(7 ^ n)\");\n        WriteLine(new String('-', power_width + isqrt_width + 6));\n        BI p = 7; for (int n = 1; n <= max; n += 2, p *= 49)\n            WriteLine (s, n, p, isqrt(p)); }\n}\n"}
{"id": 60803, "name": "Isqrt (integer square root) of X", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. I-SQRT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 QUAD-RET-VARS.\n          03 X          PIC 9(18).\n          03 Q          PIC 9(18).\n          03 Z          PIC 9(18).\n          03 T          PIC S9(18).\n          03 R          PIC 9(18).\n\n       01 TO-65-VARS.\n          03 ISQRT-N    PIC 99.\n          03 DISP-LN    PIC X(22) VALUE SPACES.\n          03 DISP-FMT   PIC Z9.\n          03 PTR        PIC 99 VALUE 1.\n\n       01 BIG-SQRT-VARS.\n          03 POW-7      PIC 9(18) VALUE 7.\n          03 POW-N      PIC 99 VALUE 1.\n          03 POW-N-OUT  PIC Z9.\n          03 POW-7-OUT  PIC Z(10).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SQRTS-TO-65.\n           PERFORM BIG-SQRTS.\n           STOP RUN.\n\n       SQRTS-TO-65.\n           PERFORM DISP-SMALL-SQRT\n           VARYING ISQRT-N FROM 0 BY 1\n           UNTIL ISQRT-N IS GREATER THAN 65.\n\n       DISP-SMALL-SQRT.\n           MOVE ISQRT-N TO X.\n           PERFORM ISQRT.\n           MOVE R TO DISP-FMT.\n           STRING DISP-FMT DELIMITED BY SIZE INTO DISP-LN \n           WITH POINTER PTR.\n           IF PTR IS GREATER THAN 22, \n               DISPLAY DISP-LN, \n               MOVE 1 TO PTR.\n\n       BIG-SQRTS.\n           PERFORM BIG-SQRT 10 TIMES.\n \n       BIG-SQRT.\n           MOVE POW-7 TO X.\n           PERFORM ISQRT.\n           MOVE POW-N TO POW-N-OUT. \n           MOVE R TO POW-7-OUT. \n           DISPLAY \"ISQRT(7^\" POW-N-OUT \") = \" POW-7-OUT.\n           ADD 2 TO POW-N.\n           MULTIPLY 49 BY POW-7.\n\n       ISQRT.\n           MOVE 1 TO Q.\n           PERFORM MUL-Q-BY-4 UNTIL Q IS GREATER THAN X.\n           MOVE X TO Z.\n           MOVE ZERO TO R.\n           PERFORM ISQRT-STEP UNTIL Q IS NOT GREATER THAN 1. \n\n       MUL-Q-BY-4.\n           MULTIPLY 4 BY Q.\n\n       ISQRT-STEP.\n           DIVIDE 4 INTO Q.\n           COMPUTE T = Z - R - Q.\n           DIVIDE 2 INTO R.\n           IF T IS NOT LESS THAN ZERO,\n               MOVE T TO Z,\n               ADD Q TO R.\n", "target": "import java.math.BigInteger;\n\npublic class Isqrt {\n    private static BigInteger isqrt(BigInteger x) {\n        if (x.compareTo(BigInteger.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Argument cannot be negative\");\n        }\n        var q = BigInteger.ONE;\n        while (q.compareTo(x) <= 0) {\n            q = q.shiftLeft(2);\n        }\n        var z = x;\n        var r = BigInteger.ZERO;\n        while (q.compareTo(BigInteger.ONE) > 0) {\n            q = q.shiftRight(2);\n            var t = z;\n            t = t.subtract(r);\n            t = t.subtract(q);\n            r = r.shiftRight(1);\n            if (t.compareTo(BigInteger.ZERO) >= 0) {\n                z = t;\n                r = r.add(q);\n            }\n        }\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The integer square root of integers from 0 to 65 are:\");\n        for (int i = 0; i <= 65; i++) {\n            System.out.printf(\"%s \", isqrt(BigInteger.valueOf(i)));\n        }\n        System.out.println();\n\n        System.out.println(\"The integer square roots of powers of 7 from 7^1 up to 7^73 are:\");\n        System.out.println(\"power                                    7 ^ power                                                 integer square root\");\n        System.out.println(\"----- --------------------------------------------------------------------------------- -----------------------------------------\");\n        var pow7 = BigInteger.valueOf(7);\n        var bi49 = BigInteger.valueOf(49);\n        for (int i = 1; i < 74; i += 2) {\n            System.out.printf(\"%2d\u00a0%,84d\u00a0%,41d\\n\", i, pow7, isqrt(pow7));\n            pow7 = pow7.multiply(bi49);\n        }\n    }\n}\n"}
{"id": 60804, "name": "Isqrt (integer square root) of X", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. I-SQRT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 QUAD-RET-VARS.\n          03 X          PIC 9(18).\n          03 Q          PIC 9(18).\n          03 Z          PIC 9(18).\n          03 T          PIC S9(18).\n          03 R          PIC 9(18).\n\n       01 TO-65-VARS.\n          03 ISQRT-N    PIC 99.\n          03 DISP-LN    PIC X(22) VALUE SPACES.\n          03 DISP-FMT   PIC Z9.\n          03 PTR        PIC 99 VALUE 1.\n\n       01 BIG-SQRT-VARS.\n          03 POW-7      PIC 9(18) VALUE 7.\n          03 POW-N      PIC 99 VALUE 1.\n          03 POW-N-OUT  PIC Z9.\n          03 POW-7-OUT  PIC Z(10).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SQRTS-TO-65.\n           PERFORM BIG-SQRTS.\n           STOP RUN.\n\n       SQRTS-TO-65.\n           PERFORM DISP-SMALL-SQRT\n           VARYING ISQRT-N FROM 0 BY 1\n           UNTIL ISQRT-N IS GREATER THAN 65.\n\n       DISP-SMALL-SQRT.\n           MOVE ISQRT-N TO X.\n           PERFORM ISQRT.\n           MOVE R TO DISP-FMT.\n           STRING DISP-FMT DELIMITED BY SIZE INTO DISP-LN \n           WITH POINTER PTR.\n           IF PTR IS GREATER THAN 22, \n               DISPLAY DISP-LN, \n               MOVE 1 TO PTR.\n\n       BIG-SQRTS.\n           PERFORM BIG-SQRT 10 TIMES.\n \n       BIG-SQRT.\n           MOVE POW-7 TO X.\n           PERFORM ISQRT.\n           MOVE POW-N TO POW-N-OUT. \n           MOVE R TO POW-7-OUT. \n           DISPLAY \"ISQRT(7^\" POW-N-OUT \") = \" POW-7-OUT.\n           ADD 2 TO POW-N.\n           MULTIPLY 49 BY POW-7.\n\n       ISQRT.\n           MOVE 1 TO Q.\n           PERFORM MUL-Q-BY-4 UNTIL Q IS GREATER THAN X.\n           MOVE X TO Z.\n           MOVE ZERO TO R.\n           PERFORM ISQRT-STEP UNTIL Q IS NOT GREATER THAN 1. \n\n       MUL-Q-BY-4.\n           MULTIPLY 4 BY Q.\n\n       ISQRT-STEP.\n           DIVIDE 4 INTO Q.\n           COMPUTE T = Z - R - Q.\n           DIVIDE 2 INTO R.\n           IF T IS NOT LESS THAN ZERO,\n               MOVE T TO Z,\n               ADD Q TO R.\n", "target": "import java.math.BigInteger;\n\npublic class Isqrt {\n    private static BigInteger isqrt(BigInteger x) {\n        if (x.compareTo(BigInteger.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Argument cannot be negative\");\n        }\n        var q = BigInteger.ONE;\n        while (q.compareTo(x) <= 0) {\n            q = q.shiftLeft(2);\n        }\n        var z = x;\n        var r = BigInteger.ZERO;\n        while (q.compareTo(BigInteger.ONE) > 0) {\n            q = q.shiftRight(2);\n            var t = z;\n            t = t.subtract(r);\n            t = t.subtract(q);\n            r = r.shiftRight(1);\n            if (t.compareTo(BigInteger.ZERO) >= 0) {\n                z = t;\n                r = r.add(q);\n            }\n        }\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The integer square root of integers from 0 to 65 are:\");\n        for (int i = 0; i <= 65; i++) {\n            System.out.printf(\"%s \", isqrt(BigInteger.valueOf(i)));\n        }\n        System.out.println();\n\n        System.out.println(\"The integer square roots of powers of 7 from 7^1 up to 7^73 are:\");\n        System.out.println(\"power                                    7 ^ power                                                 integer square root\");\n        System.out.println(\"----- --------------------------------------------------------------------------------- -----------------------------------------\");\n        var pow7 = BigInteger.valueOf(7);\n        var bi49 = BigInteger.valueOf(49);\n        for (int i = 1; i < 74; i += 2) {\n            System.out.printf(\"%2d\u00a0%,84d\u00a0%,41d\\n\", i, pow7, isqrt(pow7));\n            pow7 = pow7.multiply(bi49);\n        }\n    }\n}\n"}
{"id": 60805, "name": "Isqrt (integer square root) of X", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. I-SQRT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 QUAD-RET-VARS.\n          03 X          PIC 9(18).\n          03 Q          PIC 9(18).\n          03 Z          PIC 9(18).\n          03 T          PIC S9(18).\n          03 R          PIC 9(18).\n\n       01 TO-65-VARS.\n          03 ISQRT-N    PIC 99.\n          03 DISP-LN    PIC X(22) VALUE SPACES.\n          03 DISP-FMT   PIC Z9.\n          03 PTR        PIC 99 VALUE 1.\n\n       01 BIG-SQRT-VARS.\n          03 POW-7      PIC 9(18) VALUE 7.\n          03 POW-N      PIC 99 VALUE 1.\n          03 POW-N-OUT  PIC Z9.\n          03 POW-7-OUT  PIC Z(10).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SQRTS-TO-65.\n           PERFORM BIG-SQRTS.\n           STOP RUN.\n\n       SQRTS-TO-65.\n           PERFORM DISP-SMALL-SQRT\n           VARYING ISQRT-N FROM 0 BY 1\n           UNTIL ISQRT-N IS GREATER THAN 65.\n\n       DISP-SMALL-SQRT.\n           MOVE ISQRT-N TO X.\n           PERFORM ISQRT.\n           MOVE R TO DISP-FMT.\n           STRING DISP-FMT DELIMITED BY SIZE INTO DISP-LN \n           WITH POINTER PTR.\n           IF PTR IS GREATER THAN 22, \n               DISPLAY DISP-LN, \n               MOVE 1 TO PTR.\n\n       BIG-SQRTS.\n           PERFORM BIG-SQRT 10 TIMES.\n \n       BIG-SQRT.\n           MOVE POW-7 TO X.\n           PERFORM ISQRT.\n           MOVE POW-N TO POW-N-OUT. \n           MOVE R TO POW-7-OUT. \n           DISPLAY \"ISQRT(7^\" POW-N-OUT \") = \" POW-7-OUT.\n           ADD 2 TO POW-N.\n           MULTIPLY 49 BY POW-7.\n\n       ISQRT.\n           MOVE 1 TO Q.\n           PERFORM MUL-Q-BY-4 UNTIL Q IS GREATER THAN X.\n           MOVE X TO Z.\n           MOVE ZERO TO R.\n           PERFORM ISQRT-STEP UNTIL Q IS NOT GREATER THAN 1. \n\n       MUL-Q-BY-4.\n           MULTIPLY 4 BY Q.\n\n       ISQRT-STEP.\n           DIVIDE 4 INTO Q.\n           COMPUTE T = Z - R - Q.\n           DIVIDE 2 INTO R.\n           IF T IS NOT LESS THAN ZERO,\n               MOVE T TO Z,\n               ADD Q TO R.\n", "target": "def isqrt ( x ):\n    q = 1\n    while q <= x : \n        q *= 4\n    z,r = x,0\n    while q > 1 :\n        q  /= 4\n        t,r = z-r-q,r/2\n        if t >= 0 :\n            z,r = t,r+q\n    return r \n\nprint ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))\nprint '\\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))\n"}
{"id": 60806, "name": "Isqrt (integer square root) of X", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. I-SQRT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 QUAD-RET-VARS.\n          03 X          PIC 9(18).\n          03 Q          PIC 9(18).\n          03 Z          PIC 9(18).\n          03 T          PIC S9(18).\n          03 R          PIC 9(18).\n\n       01 TO-65-VARS.\n          03 ISQRT-N    PIC 99.\n          03 DISP-LN    PIC X(22) VALUE SPACES.\n          03 DISP-FMT   PIC Z9.\n          03 PTR        PIC 99 VALUE 1.\n\n       01 BIG-SQRT-VARS.\n          03 POW-7      PIC 9(18) VALUE 7.\n          03 POW-N      PIC 99 VALUE 1.\n          03 POW-N-OUT  PIC Z9.\n          03 POW-7-OUT  PIC Z(10).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SQRTS-TO-65.\n           PERFORM BIG-SQRTS.\n           STOP RUN.\n\n       SQRTS-TO-65.\n           PERFORM DISP-SMALL-SQRT\n           VARYING ISQRT-N FROM 0 BY 1\n           UNTIL ISQRT-N IS GREATER THAN 65.\n\n       DISP-SMALL-SQRT.\n           MOVE ISQRT-N TO X.\n           PERFORM ISQRT.\n           MOVE R TO DISP-FMT.\n           STRING DISP-FMT DELIMITED BY SIZE INTO DISP-LN \n           WITH POINTER PTR.\n           IF PTR IS GREATER THAN 22, \n               DISPLAY DISP-LN, \n               MOVE 1 TO PTR.\n\n       BIG-SQRTS.\n           PERFORM BIG-SQRT 10 TIMES.\n \n       BIG-SQRT.\n           MOVE POW-7 TO X.\n           PERFORM ISQRT.\n           MOVE POW-N TO POW-N-OUT. \n           MOVE R TO POW-7-OUT. \n           DISPLAY \"ISQRT(7^\" POW-N-OUT \") = \" POW-7-OUT.\n           ADD 2 TO POW-N.\n           MULTIPLY 49 BY POW-7.\n\n       ISQRT.\n           MOVE 1 TO Q.\n           PERFORM MUL-Q-BY-4 UNTIL Q IS GREATER THAN X.\n           MOVE X TO Z.\n           MOVE ZERO TO R.\n           PERFORM ISQRT-STEP UNTIL Q IS NOT GREATER THAN 1. \n\n       MUL-Q-BY-4.\n           MULTIPLY 4 BY Q.\n\n       ISQRT-STEP.\n           DIVIDE 4 INTO Q.\n           COMPUTE T = Z - R - Q.\n           DIVIDE 2 INTO R.\n           IF T IS NOT LESS THAN ZERO,\n               MOVE T TO Z,\n               ADD Q TO R.\n", "target": "def isqrt ( x ):\n    q = 1\n    while q <= x : \n        q *= 4\n    z,r = x,0\n    while q > 1 :\n        q  /= 4\n        t,r = z-r-q,r/2\n        if t >= 0 :\n            z,r = t,r+q\n    return r \n\nprint ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))\nprint '\\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))\n"}
{"id": 61413, "name": "Factorial", "source": "Translate COBOL to C#: MOVE FUNCTION FACTORIAL(num) TO result\n", "target": "using System;\n\nclass Program\n{\n    static int Factorial(int number)\n    {\n        if(number < 0) \n            throw new ArgumentOutOfRangeException(nameof(number), number, \"Must be zero or a positive number.\");\n\n        var accumulator = 1;\n        for (var factor = 1; factor <= number; factor++)\n        {\n            accumulator *= factor;\n        }\n        return accumulator;\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Factorial(10));\n    }\n}\n"}
{"id": 61415, "name": "Factorial", "source": "Translate COBOL to Java: MOVE FUNCTION FACTORIAL(num) TO result\n", "target": "module ShowFactorials\n    {\n    static <Value extends IntNumber> Value factorial(Value n)\n        {\n        assert:arg n >= Value.zero();\n        return n <= Value.one() ? n : n * factorial(n-Value.one());\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        \n        UInt128 bigNum = 34;\n        console.print($\"factorial({bigNum})={factorial(bigNum)}\");\n\n        \n        for (Int i : 10..-1)\n            {\n            console.print($\"factorial({i})={factorial(i)}\");\n            }\n        }\n    }\n"}
{"id": 61856, "name": "Menu", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Test-Prompt-Menu.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  Num-Options    USAGE UNSIGNED-INT VALUE 4.\n       01  Example-Menu.\n           03  Example-Options-Data.\n               05  FILLER PIC X(30) VALUE \"fee fie\".\n               05  FILLER PIC X(30) VALUE \"huff and puff\".\n               05  FILLER PIC X(30) VALUE \"mirror mirror\".\n               05  FILLER PIC X(30) VALUE \"tick tock\".\n\n           03  Example-Options-Values REDEFINES Example-Options-Data.\n               05  Example-Options PIC X(30) OCCURS 4 TIMES.\n\n       01  Chosen-Option PIC X(30).\n\n       PROCEDURE DIVISION.\n           CALL \"Prompt-Menu\" USING BY CONTENT Num-Options\n               BY CONTENT Example-Menu\n               BY REFERENCE Chosen-Option\n\n           DISPLAY \"You chose: \" Chosen-Option\n\n           GOBACK\n           .\n\n       END PROGRAM Test-Prompt-Menu.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Prompt-Menu.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  User-Input        USAGE UNSIGNED-INT.\n       01  Input-Flag        PIC X.\n           88  Valid-Input   VALUE \"Y\".\n\n       01  Options-Index     USAGE UNSIGNED-INT.\n       01  Index-Display     PIC Z(10).\n\n       LINKAGE SECTION.\n\n       01  Num-Options       USAGE UNSIGNED-INT.\n       01  Menu-Options.\n           03  Options-Table PIC X(30) OCCURS 0 TO 10000000 TIMES\n               DEPENDING ON Num-Options.\n\n       01  Chosen-Option     PIC X(30).\n\n       PROCEDURE DIVISION USING Num-Options Menu-Options Chosen-Option.\n       Main.\n           IF Num-Options = 0\n               MOVE SPACES TO Chosen-Option\n               GOBACK\n           END-IF\n\n           PERFORM UNTIL Valid-Input\n               PERFORM Display-Menu-Options\n\n               DISPLAY \"Choose an option: \" WITH NO ADVANCING\n               ACCEPT User-Input\n\n               PERFORM Validate-Input\n           END-PERFORM\n\n           MOVE Options-Table (User-Input) TO Chosen-Option\n\n           GOBACK\n           .\n\n       Display-Menu-Options.\n           PERFORM VARYING Options-Index FROM 1 BY 1\n                   UNTIL Num-Options < Options-Index\n               MOVE Options-Index TO Index-Display\n               DISPLAY\n                   Index-Display \". \" Options-Table (Options-Index)\n               END-DISPLAY\n           END-PERFORM\n           .\n\n       Validate-Input.\n           IF User-Input = 0 OR > Num-Options\n               DISPLAY \"Invalid input.\"\n           ELSE\n               SET Valid-Input TO TRUE\n           END-IF\n           .\n\n       END PROGRAM Prompt-Menu.\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Menu\n{\n        static void Main(string[] args)\n        {\n            List<string> menu_items = new List<string>() { \"fee fie\", \"huff and puff\", \"mirror mirror\", \"tick tock\" };\n            \n            Console.WriteLine(PrintMenu(menu_items));\n            Console.ReadLine();\n        }\n        private static string PrintMenu(List<string> items)\n        {\n            if (items.Count == 0)\n                return \"\";\n\n            string input = \"\";\n            int i = -1;\n            do\n            {\n                for (int j = 0; j < items.Count; j++)\n                    Console.WriteLine(\"{0}) {1}\", j, items[j]);\n\n                Console.WriteLine(\"What number?\");\n                input = Console.ReadLine();\n\n            } while (!int.TryParse(input, out i) || i >= items.Count || i < 0);\n            return items[i];\n        }\n}\n"}
{"id": 61858, "name": "Menu", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Test-Prompt-Menu.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  Num-Options    USAGE UNSIGNED-INT VALUE 4.\n       01  Example-Menu.\n           03  Example-Options-Data.\n               05  FILLER PIC X(30) VALUE \"fee fie\".\n               05  FILLER PIC X(30) VALUE \"huff and puff\".\n               05  FILLER PIC X(30) VALUE \"mirror mirror\".\n               05  FILLER PIC X(30) VALUE \"tick tock\".\n\n           03  Example-Options-Values REDEFINES Example-Options-Data.\n               05  Example-Options PIC X(30) OCCURS 4 TIMES.\n\n       01  Chosen-Option PIC X(30).\n\n       PROCEDURE DIVISION.\n           CALL \"Prompt-Menu\" USING BY CONTENT Num-Options\n               BY CONTENT Example-Menu\n               BY REFERENCE Chosen-Option\n\n           DISPLAY \"You chose: \" Chosen-Option\n\n           GOBACK\n           .\n\n       END PROGRAM Test-Prompt-Menu.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Prompt-Menu.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  User-Input        USAGE UNSIGNED-INT.\n       01  Input-Flag        PIC X.\n           88  Valid-Input   VALUE \"Y\".\n\n       01  Options-Index     USAGE UNSIGNED-INT.\n       01  Index-Display     PIC Z(10).\n\n       LINKAGE SECTION.\n\n       01  Num-Options       USAGE UNSIGNED-INT.\n       01  Menu-Options.\n           03  Options-Table PIC X(30) OCCURS 0 TO 10000000 TIMES\n               DEPENDING ON Num-Options.\n\n       01  Chosen-Option     PIC X(30).\n\n       PROCEDURE DIVISION USING Num-Options Menu-Options Chosen-Option.\n       Main.\n           IF Num-Options = 0\n               MOVE SPACES TO Chosen-Option\n               GOBACK\n           END-IF\n\n           PERFORM UNTIL Valid-Input\n               PERFORM Display-Menu-Options\n\n               DISPLAY \"Choose an option: \" WITH NO ADVANCING\n               ACCEPT User-Input\n\n               PERFORM Validate-Input\n           END-PERFORM\n\n           MOVE Options-Table (User-Input) TO Chosen-Option\n\n           GOBACK\n           .\n\n       Display-Menu-Options.\n           PERFORM VARYING Options-Index FROM 1 BY 1\n                   UNTIL Num-Options < Options-Index\n               MOVE Options-Index TO Index-Display\n               DISPLAY\n                   Index-Display \". \" Options-Table (Options-Index)\n               END-DISPLAY\n           END-PERFORM\n           .\n\n       Validate-Input.\n           IF User-Input = 0 OR > Num-Options\n               DISPLAY \"Invalid input.\"\n           ELSE\n               SET Valid-Input TO TRUE\n           END-IF\n           .\n\n       END PROGRAM Prompt-Menu.\n", "target": "public static String select(List<String> list, String prompt){\n    if(list.size() == 0) return \"\";\n    Scanner sc = new Scanner(System.in);\n    String ret = null;\n    do{\n        for(int i=0;i<list.size();i++){\n            System.out.println(i + \": \"+list.get(i));\n        }\n        System.out.print(prompt);\n        int index = sc.nextInt();\n        if(index >= 0 && index < list.size()){\n            ret = list.get(index);\n        }\n    }while(ret == null);\n    return ret;\n}\n"}
{"id": 61859, "name": "Menu", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Test-Prompt-Menu.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  Num-Options    USAGE UNSIGNED-INT VALUE 4.\n       01  Example-Menu.\n           03  Example-Options-Data.\n               05  FILLER PIC X(30) VALUE \"fee fie\".\n               05  FILLER PIC X(30) VALUE \"huff and puff\".\n               05  FILLER PIC X(30) VALUE \"mirror mirror\".\n               05  FILLER PIC X(30) VALUE \"tick tock\".\n\n           03  Example-Options-Values REDEFINES Example-Options-Data.\n               05  Example-Options PIC X(30) OCCURS 4 TIMES.\n\n       01  Chosen-Option PIC X(30).\n\n       PROCEDURE DIVISION.\n           CALL \"Prompt-Menu\" USING BY CONTENT Num-Options\n               BY CONTENT Example-Menu\n               BY REFERENCE Chosen-Option\n\n           DISPLAY \"You chose: \" Chosen-Option\n\n           GOBACK\n           .\n\n       END PROGRAM Test-Prompt-Menu.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Prompt-Menu.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  User-Input        USAGE UNSIGNED-INT.\n       01  Input-Flag        PIC X.\n           88  Valid-Input   VALUE \"Y\".\n\n       01  Options-Index     USAGE UNSIGNED-INT.\n       01  Index-Display     PIC Z(10).\n\n       LINKAGE SECTION.\n\n       01  Num-Options       USAGE UNSIGNED-INT.\n       01  Menu-Options.\n           03  Options-Table PIC X(30) OCCURS 0 TO 10000000 TIMES\n               DEPENDING ON Num-Options.\n\n       01  Chosen-Option     PIC X(30).\n\n       PROCEDURE DIVISION USING Num-Options Menu-Options Chosen-Option.\n       Main.\n           IF Num-Options = 0\n               MOVE SPACES TO Chosen-Option\n               GOBACK\n           END-IF\n\n           PERFORM UNTIL Valid-Input\n               PERFORM Display-Menu-Options\n\n               DISPLAY \"Choose an option: \" WITH NO ADVANCING\n               ACCEPT User-Input\n\n               PERFORM Validate-Input\n           END-PERFORM\n\n           MOVE Options-Table (User-Input) TO Chosen-Option\n\n           GOBACK\n           .\n\n       Display-Menu-Options.\n           PERFORM VARYING Options-Index FROM 1 BY 1\n                   UNTIL Num-Options < Options-Index\n               MOVE Options-Index TO Index-Display\n               DISPLAY\n                   Index-Display \". \" Options-Table (Options-Index)\n               END-DISPLAY\n           END-PERFORM\n           .\n\n       Validate-Input.\n           IF User-Input = 0 OR > Num-Options\n               DISPLAY \"Invalid input.\"\n           ELSE\n               SET Valid-Input TO TRUE\n           END-IF\n           .\n\n       END PROGRAM Prompt-Menu.\n", "target": "def _menu(items):\n    for indexitem in enumerate(items):\n        print (\"  %2i) %s\" % indexitem)\n\ndef _ok(reply, itemcount):\n    try:\n        n = int(reply)\n        return 0 <= n < itemcount\n    except:\n        return False\n    \ndef selector(items, prompt):\n    'Prompt to select an item from the items'\n    if not items: return ''\n    reply = -1\n    itemcount = len(items)\n    while not _ok(reply, itemcount):\n        _menu(items)\n        \n        reply = raw_input(prompt).strip()\n    return items[int(reply)]\n\nif __name__ == '__main__':\n    items = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']\n    item = selector(items, 'Which is from the three pigs: ')\n    print (\"You chose: \" + item)\n"}
{"id": 62770, "name": "Integer sequence", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Sequence.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n*      \n       01  I PIC 9(36).\n\n       PROCEDURE DIVISION.\n*          \n           PERFORM VARYING I FROM 1 BY 1 UNTIL I = 0\n               DISPLAY I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        BigInteger i = 1;\n        while (true)\n        {\n            Console.WriteLine(i++);\n        }\n    }\n}\n"}
{"id": 62771, "name": "Integer sequence", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Sequence.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n*      \n       01  I PIC 9(36).\n\n       PROCEDURE DIVISION.\n*          \n           PERFORM VARYING I FROM 1 BY 1 UNTIL I = 0\n               DISPLAY I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        BigInteger i = 1;\n        while (true)\n        {\n            Console.WriteLine(i++);\n        }\n    }\n}\n"}
{"id": 62774, "name": "Integer sequence", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Sequence.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n*      \n       01  I PIC 9(36).\n\n       PROCEDURE DIVISION.\n*          \n           PERFORM VARYING I FROM 1 BY 1 UNTIL I = 0\n               DISPLAY I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(long i = 1; ;i++) System.out.println(i);\n    }\n}\n"}
{"id": 62775, "name": "Integer sequence", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Sequence.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n*      \n       01  I PIC 9(36).\n\n       PROCEDURE DIVISION.\n*          \n           PERFORM VARYING I FROM 1 BY 1 UNTIL I = 0\n               DISPLAY I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(long i = 1; ;i++) System.out.println(i);\n    }\n}\n"}
{"id": 62776, "name": "Integer sequence", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Sequence.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n*      \n       01  I PIC 9(36).\n\n       PROCEDURE DIVISION.\n*          \n           PERFORM VARYING I FROM 1 BY 1 UNTIL I = 0\n               DISPLAY I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "i=1\nwhile i:\n    print(i)\n    i += 1\n"}
{"id": 62777, "name": "Integer sequence", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Sequence.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n*      \n       01  I PIC 9(36).\n\n       PROCEDURE DIVISION.\n*          \n           PERFORM VARYING I FROM 1 BY 1 UNTIL I = 0\n               DISPLAY I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "i=1\nwhile i:\n    print(i)\n    i += 1\n"}
{"id": 63061, "name": "Fibonacci sequence", "source": "Translate COBOL to C#: Program-ID. Fibonacci-Sequence.\nData Division.\nWorking-Storage Section.\n  01  FIBONACCI-PROCESSING.\n    05  FIBONACCI-NUMBER  PIC 9(36)   VALUE 0.\n    05  FIB-ONE           PIC 9(36)   VALUE 0.\n    05  FIB-TWO           PIC 9(36)   VALUE 1.\n  01  DESIRED-COUNT       PIC 9(4).\n  01  FORMATTING.\n    05  INTERM-RESULT     PIC Z(35)9.\n    05  FORMATTED-RESULT  PIC X(36).\n    05  FORMATTED-SPACE   PIC x(35).\nProcedure Division.\n  000-START-PROGRAM.\n    Display \"What place of the Fibonacci Sequence would you like (<173)? \" with no advancing.\n    Accept DESIRED-COUNT.\n    If DESIRED-COUNT is less than 1\n      Stop run.\n    If DESIRED-COUNT is less than 2\n      Move FIBONACCI-NUMBER to INTERM-RESULT\n      Move INTERM-RESULT to FORMATTED-RESULT\n      Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT\n      Display FORMATTED-RESULT\n      Stop run.\n    Subtract 1 from DESIRED-COUNT.\n    Move FIBONACCI-NUMBER to INTERM-RESULT.\n    Move INTERM-RESULT to FORMATTED-RESULT.\n    Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT.\n    Display FORMATTED-RESULT.\n    Perform 100-COMPUTE-FIBONACCI until DESIRED-COUNT = zero.\n    Stop run.\n  100-COMPUTE-FIBONACCI.\n    Compute FIBONACCI-NUMBER = FIB-ONE + FIB-TWO.\n    Move FIB-TWO to FIB-ONE.\n    Move FIBONACCI-NUMBER to FIB-TWO.\n    Subtract 1 from DESIRED-COUNT.\n    Move FIBONACCI-NUMBER to INTERM-RESULT.\n    Move INTERM-RESULT to FORMATTED-RESULT.\n    Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT.\n    Display FORMATTED-RESULT.\n", "target": "public static ulong Fib(uint n) {\n    return (n < 2)? n : Fib(n - 1) + Fib(n - 2);\n}\n"}
{"id": 63063, "name": "Fibonacci sequence", "source": "Translate COBOL to Java: Program-ID. Fibonacci-Sequence.\nData Division.\nWorking-Storage Section.\n  01  FIBONACCI-PROCESSING.\n    05  FIBONACCI-NUMBER  PIC 9(36)   VALUE 0.\n    05  FIB-ONE           PIC 9(36)   VALUE 0.\n    05  FIB-TWO           PIC 9(36)   VALUE 1.\n  01  DESIRED-COUNT       PIC 9(4).\n  01  FORMATTING.\n    05  INTERM-RESULT     PIC Z(35)9.\n    05  FORMATTED-RESULT  PIC X(36).\n    05  FORMATTED-SPACE   PIC x(35).\nProcedure Division.\n  000-START-PROGRAM.\n    Display \"What place of the Fibonacci Sequence would you like (<173)? \" with no advancing.\n    Accept DESIRED-COUNT.\n    If DESIRED-COUNT is less than 1\n      Stop run.\n    If DESIRED-COUNT is less than 2\n      Move FIBONACCI-NUMBER to INTERM-RESULT\n      Move INTERM-RESULT to FORMATTED-RESULT\n      Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT\n      Display FORMATTED-RESULT\n      Stop run.\n    Subtract 1 from DESIRED-COUNT.\n    Move FIBONACCI-NUMBER to INTERM-RESULT.\n    Move INTERM-RESULT to FORMATTED-RESULT.\n    Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT.\n    Display FORMATTED-RESULT.\n    Perform 100-COMPUTE-FIBONACCI until DESIRED-COUNT = zero.\n    Stop run.\n  100-COMPUTE-FIBONACCI.\n    Compute FIBONACCI-NUMBER = FIB-ONE + FIB-TWO.\n    Move FIB-TWO to FIB-ONE.\n    Move FIBONACCI-NUMBER to FIB-TWO.\n    Subtract 1 from DESIRED-COUNT.\n    Move FIBONACCI-NUMBER to INTERM-RESULT.\n    Move INTERM-RESULT to FORMATTED-RESULT.\n    Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT.\n    Display FORMATTED-RESULT.\n", "target": "public static long itFibN(int n)\n{\n if (n < 2)\n  return n;\n long ans = 0;\n long n1 = 0;\n long n2 = 1;\n for(n--; n > 0; n--)\n {\n  ans = n1 + n2;\n  n1 = n2;\n  n2 = ans;\n }\n return ans;\n}\n"}
{"id": 63064, "name": "Fibonacci sequence", "source": "Translate COBOL to Python: Program-ID. Fibonacci-Sequence.\nData Division.\nWorking-Storage Section.\n  01  FIBONACCI-PROCESSING.\n    05  FIBONACCI-NUMBER  PIC 9(36)   VALUE 0.\n    05  FIB-ONE           PIC 9(36)   VALUE 0.\n    05  FIB-TWO           PIC 9(36)   VALUE 1.\n  01  DESIRED-COUNT       PIC 9(4).\n  01  FORMATTING.\n    05  INTERM-RESULT     PIC Z(35)9.\n    05  FORMATTED-RESULT  PIC X(36).\n    05  FORMATTED-SPACE   PIC x(35).\nProcedure Division.\n  000-START-PROGRAM.\n    Display \"What place of the Fibonacci Sequence would you like (<173)? \" with no advancing.\n    Accept DESIRED-COUNT.\n    If DESIRED-COUNT is less than 1\n      Stop run.\n    If DESIRED-COUNT is less than 2\n      Move FIBONACCI-NUMBER to INTERM-RESULT\n      Move INTERM-RESULT to FORMATTED-RESULT\n      Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT\n      Display FORMATTED-RESULT\n      Stop run.\n    Subtract 1 from DESIRED-COUNT.\n    Move FIBONACCI-NUMBER to INTERM-RESULT.\n    Move INTERM-RESULT to FORMATTED-RESULT.\n    Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT.\n    Display FORMATTED-RESULT.\n    Perform 100-COMPUTE-FIBONACCI until DESIRED-COUNT = zero.\n    Stop run.\n  100-COMPUTE-FIBONACCI.\n    Compute FIBONACCI-NUMBER = FIB-ONE + FIB-TWO.\n    Move FIB-TWO to FIB-ONE.\n    Move FIBONACCI-NUMBER to FIB-TWO.\n    Subtract 1 from DESIRED-COUNT.\n    Move FIBONACCI-NUMBER to INTERM-RESULT.\n    Move INTERM-RESULT to FORMATTED-RESULT.\n    Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT.\n    Display FORMATTED-RESULT.\n", "target": "from math import *\n\ndef analytic_fibonacci(n):\n  sqrt_5 = sqrt(5);\n  p = (1 + sqrt_5) / 2;\n  q = 1/p;\n  return int( (p**n + q**n) / sqrt_5 + 0.5 )\n\nfor i in range(1,31):\n  print analytic_fibonacci(i),\n"}
{"id": 63341, "name": "Averages_Arithmetic mean", "source": "Translate COBOL to C#: FUNCTION MEAN(some-table (ALL))\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(new[] { 1, 2, 3 }.Average());\n    }\n}\n"}
{"id": 63343, "name": "Averages_Arithmetic mean", "source": "Translate COBOL to Java: FUNCTION MEAN(some-table (ALL))\n", "target": "public static double avg(double... arr) {\n    double sum = 0.0;\n    for (double x : arr) {\n        sum += x;\n    }\n    return sum / arr.length;\n}\n"}
{"id": 63344, "name": "Averages_Arithmetic mean", "source": "Translate COBOL to Python: FUNCTION MEAN(some-table (ALL))\n", "target": "from math import fsum\ndef average(x):\n    return fsum(x)/float(len(x)) if x else 0\nprint (average([0,0,3,1,4,1,5,9,0,0]))\nprint (average([1e20,-1e-20,3,1,4,1,5,9,-1e20,1e-20]))\n"}
{"id": 63920, "name": "Terminal control_Display an extended character", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Display-Pound.\n\n       PROCEDURE DIVISION.\n       DISPLAY \"\u00a3\"\n\n       GOBACK\n       .\n", "target": "class Program\n{\n    static void Main()\n    {\n        System.Console.WriteLine(\"\u00a3\");\n    }\n}\n"}
{"id": 63922, "name": "Terminal control_Display an extended character", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Display-Pound.\n\n       PROCEDURE DIVISION.\n       DISPLAY \"\u00a3\"\n\n       GOBACK\n       .\n", "target": "import java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\n\npublic class Main\n{\n    public static void main(String[] args) throws UnsupportedEncodingException\n    {\n        PrintStream writer = new PrintStream(System.out, true, \"UTF-8\");\n        writer.println(\"\u00a3\");\n        writer.println(\"\u672d\u5e4c\");\n    }\n}\n"}
{"id": 63923, "name": "Terminal control_Display an extended character", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Display-Pound.\n\n       PROCEDURE DIVISION.\n       DISPLAY \"\u00a3\"\n\n       GOBACK\n       .\n", "target": "print u'\\u00a3'\n"}
{"id": 64154, "name": "Julia set", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. JULIA-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-COMPLEX-CONSTANT.\n    05 C-REAL             PIC S9V999.\n    05 C-IMAGINARY        PIC S9V999.\n01  WS-ARGAND-PLANE.\n    05 X                  PIC S9(9)V999.\n    05 Y                  PIC S9(9)V999.\n01  WS-COMPLEX-VARIABLE.\n    05 Z-REAL             PIC S9(9)V999.\n    05 Z-IMAGINARY        PIC S9(9)V999.\n01  WS-TEMPORARY-RESULTS.\n    05 X-SQUARED          PIC S9(9)V999.\n    05 Y-SQUARED          PIC S9(9)V999.\n    05 X-TIMES-Y          PIC S9(9)V999.\n    05 Z-REAL-SQUARED     PIC S9(9)V999.\n01  WS-LOOP-COUNTERS.\n    05 HORIZONTAL         PIC 999.\n    05 VERTICAL           PIC 999.\n    05 ITERATIONS         PIC 99.\n77  WS-PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nINPUT-COMPLEX-CONSTANT-PARAGRAPH.\n    ACCEPT C-REAL      FROM CONSOLE.\n    ACCEPT C-IMAGINARY FROM CONSOLE.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH  VARYING VERTICAL   FROM 1 BY 10\n    UNTIL VERTICAL IS GREATER THAN 320.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING HORIZONTAL FROM 1 BY 10\n    UNTIL HORIZONTAL IS GREATER THAN 560.\n    DISPLAY '' UPON CONSOLE.\nCOMPUTATION-PARAGRAPH.\n    SUBTRACT 280   FROM HORIZONTAL GIVING X.\n    SUBTRACT 160   FROM VERTICAL   GIVING Y.\n    DIVIDE   X     BY   200        GIVING X.\n    DIVIDE   Y     BY   100        GIVING Y.\n    MOVE     '#'   TO   WS-PLOT-CHARACTER.\n    PERFORM COMPLEX-MULTIPLICATION-PARAGRAPH\n    VARYING ITERATIONS FROM   1  BY      1\n    UNTIL   ITERATIONS        IS GREATER THAN 50\n    OR      WS-PLOT-CHARACTER IS EQUAL   TO   SPACE.\n    DISPLAY WS-PLOT-CHARACTER UPON CONSOLE WITH NO ADVANCING.\nCOMPLEX-MULTIPLICATION-PARAGRAPH.\n    MULTIPLY X         BY   X         GIVING X-SQUARED.\n    MULTIPLY Y         BY   Y         GIVING Y-SQUARED.\n    SUBTRACT Y-SQUARED FROM X-SQUARED GIVING Z-REAL.\n    ADD      C-REAL    TO   Z-REAL.\n    MULTIPLY X         BY   Y         GIVING X-TIMES-Y.\n    MULTIPLY X-TIMES-Y BY   2         GIVING Z-IMAGINARY.\n    ADD C-IMAGINARY    TO   Z-IMAGINARY.\n    MULTIPLY Z-REAL    BY   Z-REAL    GIVING Z-REAL-SQUARED.\n    IF  Z-REAL-SQUARED IS   GREATER   THAN   10000 THEN\n    MOVE SPACE         TO   WS-PLOT-CHARACTER.\n    MOVE Z-REAL        TO   X.\n    MOVE Z-IMAGINARY   TO   Y.\n", "target": "using System.Drawing;\n\n\n\nusing System.Linq;\n\nnamespace RosettaJuliaSet\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 800;\n            const int h = 600;\n            const int zoom = 1;\n            const int maxiter = 255;\n            const int moveX = 0;\n            const int moveY = 0;\n            const double cX = -0.7;\n            const double cY = 0.27015;\n            double zx, zy, tmp;\n            int i;\n\n            var colors = (from c in Enumerable.Range(0, 256)\n                          select Color.FromArgb((c >> 5) * 36, (c >> 3 & 7) * 36, (c & 3) * 85)).ToArray();\n\n            var bitmap = new Bitmap(w, h);\n            for (int x = 0; x < w; x++)\n            {\n                for (int y = 0; y < h; y++)\n                {\n                    zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX;\n                    zy = 1.0 * (y - h / 2) / (0.5 * zoom * h) + moveY;\n                    i = maxiter;\n                    while (zx * zx + zy * zy < 4 && i > 1)\n                    {\n                        tmp = zx * zx - zy * zy + cX;\n                        zy = 2.0 * zx * zy + cY;\n                        zx = tmp;\n                        i -= 1;\n                    }\n                    bitmap.SetPixel(x, y, colors[i]);\n                }\n            }\n            bitmap.Save(\"julia-set.png\");\n        }\n    }\n}\n"}
{"id": 64155, "name": "Julia set", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. JULIA-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-COMPLEX-CONSTANT.\n    05 C-REAL             PIC S9V999.\n    05 C-IMAGINARY        PIC S9V999.\n01  WS-ARGAND-PLANE.\n    05 X                  PIC S9(9)V999.\n    05 Y                  PIC S9(9)V999.\n01  WS-COMPLEX-VARIABLE.\n    05 Z-REAL             PIC S9(9)V999.\n    05 Z-IMAGINARY        PIC S9(9)V999.\n01  WS-TEMPORARY-RESULTS.\n    05 X-SQUARED          PIC S9(9)V999.\n    05 Y-SQUARED          PIC S9(9)V999.\n    05 X-TIMES-Y          PIC S9(9)V999.\n    05 Z-REAL-SQUARED     PIC S9(9)V999.\n01  WS-LOOP-COUNTERS.\n    05 HORIZONTAL         PIC 999.\n    05 VERTICAL           PIC 999.\n    05 ITERATIONS         PIC 99.\n77  WS-PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nINPUT-COMPLEX-CONSTANT-PARAGRAPH.\n    ACCEPT C-REAL      FROM CONSOLE.\n    ACCEPT C-IMAGINARY FROM CONSOLE.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH  VARYING VERTICAL   FROM 1 BY 10\n    UNTIL VERTICAL IS GREATER THAN 320.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING HORIZONTAL FROM 1 BY 10\n    UNTIL HORIZONTAL IS GREATER THAN 560.\n    DISPLAY '' UPON CONSOLE.\nCOMPUTATION-PARAGRAPH.\n    SUBTRACT 280   FROM HORIZONTAL GIVING X.\n    SUBTRACT 160   FROM VERTICAL   GIVING Y.\n    DIVIDE   X     BY   200        GIVING X.\n    DIVIDE   Y     BY   100        GIVING Y.\n    MOVE     '#'   TO   WS-PLOT-CHARACTER.\n    PERFORM COMPLEX-MULTIPLICATION-PARAGRAPH\n    VARYING ITERATIONS FROM   1  BY      1\n    UNTIL   ITERATIONS        IS GREATER THAN 50\n    OR      WS-PLOT-CHARACTER IS EQUAL   TO   SPACE.\n    DISPLAY WS-PLOT-CHARACTER UPON CONSOLE WITH NO ADVANCING.\nCOMPLEX-MULTIPLICATION-PARAGRAPH.\n    MULTIPLY X         BY   X         GIVING X-SQUARED.\n    MULTIPLY Y         BY   Y         GIVING Y-SQUARED.\n    SUBTRACT Y-SQUARED FROM X-SQUARED GIVING Z-REAL.\n    ADD      C-REAL    TO   Z-REAL.\n    MULTIPLY X         BY   Y         GIVING X-TIMES-Y.\n    MULTIPLY X-TIMES-Y BY   2         GIVING Z-IMAGINARY.\n    ADD C-IMAGINARY    TO   Z-IMAGINARY.\n    MULTIPLY Z-REAL    BY   Z-REAL    GIVING Z-REAL-SQUARED.\n    IF  Z-REAL-SQUARED IS   GREATER   THAN   10000 THEN\n    MOVE SPACE         TO   WS-PLOT-CHARACTER.\n    MOVE Z-REAL        TO   X.\n    MOVE Z-IMAGINARY   TO   Y.\n", "target": "using System.Drawing;\n\n\n\nusing System.Linq;\n\nnamespace RosettaJuliaSet\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 800;\n            const int h = 600;\n            const int zoom = 1;\n            const int maxiter = 255;\n            const int moveX = 0;\n            const int moveY = 0;\n            const double cX = -0.7;\n            const double cY = 0.27015;\n            double zx, zy, tmp;\n            int i;\n\n            var colors = (from c in Enumerable.Range(0, 256)\n                          select Color.FromArgb((c >> 5) * 36, (c >> 3 & 7) * 36, (c & 3) * 85)).ToArray();\n\n            var bitmap = new Bitmap(w, h);\n            for (int x = 0; x < w; x++)\n            {\n                for (int y = 0; y < h; y++)\n                {\n                    zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX;\n                    zy = 1.0 * (y - h / 2) / (0.5 * zoom * h) + moveY;\n                    i = maxiter;\n                    while (zx * zx + zy * zy < 4 && i > 1)\n                    {\n                        tmp = zx * zx - zy * zy + cX;\n                        zy = 2.0 * zx * zy + cY;\n                        zx = tmp;\n                        i -= 1;\n                    }\n                    bitmap.SetPixel(x, y, colors[i]);\n                }\n            }\n            bitmap.Save(\"julia-set.png\");\n        }\n    }\n}\n"}
{"id": 64158, "name": "Julia set", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. JULIA-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-COMPLEX-CONSTANT.\n    05 C-REAL             PIC S9V999.\n    05 C-IMAGINARY        PIC S9V999.\n01  WS-ARGAND-PLANE.\n    05 X                  PIC S9(9)V999.\n    05 Y                  PIC S9(9)V999.\n01  WS-COMPLEX-VARIABLE.\n    05 Z-REAL             PIC S9(9)V999.\n    05 Z-IMAGINARY        PIC S9(9)V999.\n01  WS-TEMPORARY-RESULTS.\n    05 X-SQUARED          PIC S9(9)V999.\n    05 Y-SQUARED          PIC S9(9)V999.\n    05 X-TIMES-Y          PIC S9(9)V999.\n    05 Z-REAL-SQUARED     PIC S9(9)V999.\n01  WS-LOOP-COUNTERS.\n    05 HORIZONTAL         PIC 999.\n    05 VERTICAL           PIC 999.\n    05 ITERATIONS         PIC 99.\n77  WS-PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nINPUT-COMPLEX-CONSTANT-PARAGRAPH.\n    ACCEPT C-REAL      FROM CONSOLE.\n    ACCEPT C-IMAGINARY FROM CONSOLE.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH  VARYING VERTICAL   FROM 1 BY 10\n    UNTIL VERTICAL IS GREATER THAN 320.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING HORIZONTAL FROM 1 BY 10\n    UNTIL HORIZONTAL IS GREATER THAN 560.\n    DISPLAY '' UPON CONSOLE.\nCOMPUTATION-PARAGRAPH.\n    SUBTRACT 280   FROM HORIZONTAL GIVING X.\n    SUBTRACT 160   FROM VERTICAL   GIVING Y.\n    DIVIDE   X     BY   200        GIVING X.\n    DIVIDE   Y     BY   100        GIVING Y.\n    MOVE     '#'   TO   WS-PLOT-CHARACTER.\n    PERFORM COMPLEX-MULTIPLICATION-PARAGRAPH\n    VARYING ITERATIONS FROM   1  BY      1\n    UNTIL   ITERATIONS        IS GREATER THAN 50\n    OR      WS-PLOT-CHARACTER IS EQUAL   TO   SPACE.\n    DISPLAY WS-PLOT-CHARACTER UPON CONSOLE WITH NO ADVANCING.\nCOMPLEX-MULTIPLICATION-PARAGRAPH.\n    MULTIPLY X         BY   X         GIVING X-SQUARED.\n    MULTIPLY Y         BY   Y         GIVING Y-SQUARED.\n    SUBTRACT Y-SQUARED FROM X-SQUARED GIVING Z-REAL.\n    ADD      C-REAL    TO   Z-REAL.\n    MULTIPLY X         BY   Y         GIVING X-TIMES-Y.\n    MULTIPLY X-TIMES-Y BY   2         GIVING Z-IMAGINARY.\n    ADD C-IMAGINARY    TO   Z-IMAGINARY.\n    MULTIPLY Z-REAL    BY   Z-REAL    GIVING Z-REAL-SQUARED.\n    IF  Z-REAL-SQUARED IS   GREATER   THAN   10000 THEN\n    MOVE SPACE         TO   WS-PLOT-CHARACTER.\n    MOVE Z-REAL        TO   X.\n    MOVE Z-IMAGINARY   TO   Y.\n", "target": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class JuliaSet extends JPanel {\n    private static final int MAX_ITERATIONS = 300;\n    private static final double ZOOM = 1;\n    private static final double CX = -0.7;\n    private static final double CY = 0.27015;\n    private static final double MOVE_X = 0;\n    private static final double MOVE_Y = 0;\n\n    public JuliaSet() {\n        setPreferredSize(new Dimension(800, 600));\n        setBackground(Color.white);\n    }\n\n    void drawJuliaSet(Graphics2D g) {\n        int w = getWidth();\n        int h = getHeight();\n        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n\n        for (int x = 0; x < w; x++) {\n            for (int y = 0; y < h; y++) {\n                double zx = 1.5 * (x - w / 2) / (0.5 * ZOOM * w) + MOVE_X;\n                double zy = (y - h / 2) / (0.5 * ZOOM * h) + MOVE_Y;\n                float i = MAX_ITERATIONS;\n                while (zx * zx + zy * zy < 4 && i > 0) {\n                    double tmp = zx * zx - zy * zy + CX;\n                    zy = 2.0 * zx * zy + CY;\n                    zx = tmp;\n                    i--;\n                }\n                int c = Color.HSBtoRGB((MAX_ITERATIONS / i) % 1, 1, i > 0 ? 1 : 0);\n                image.setRGB(x, y, c);\n            }\n        }\n        g.drawImage(image, 0, 0, null);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        drawJuliaSet(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Julia Set\");\n            f.setResizable(false);\n            f.add(new JuliaSet(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 64159, "name": "Julia set", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. JULIA-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-COMPLEX-CONSTANT.\n    05 C-REAL             PIC S9V999.\n    05 C-IMAGINARY        PIC S9V999.\n01  WS-ARGAND-PLANE.\n    05 X                  PIC S9(9)V999.\n    05 Y                  PIC S9(9)V999.\n01  WS-COMPLEX-VARIABLE.\n    05 Z-REAL             PIC S9(9)V999.\n    05 Z-IMAGINARY        PIC S9(9)V999.\n01  WS-TEMPORARY-RESULTS.\n    05 X-SQUARED          PIC S9(9)V999.\n    05 Y-SQUARED          PIC S9(9)V999.\n    05 X-TIMES-Y          PIC S9(9)V999.\n    05 Z-REAL-SQUARED     PIC S9(9)V999.\n01  WS-LOOP-COUNTERS.\n    05 HORIZONTAL         PIC 999.\n    05 VERTICAL           PIC 999.\n    05 ITERATIONS         PIC 99.\n77  WS-PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nINPUT-COMPLEX-CONSTANT-PARAGRAPH.\n    ACCEPT C-REAL      FROM CONSOLE.\n    ACCEPT C-IMAGINARY FROM CONSOLE.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH  VARYING VERTICAL   FROM 1 BY 10\n    UNTIL VERTICAL IS GREATER THAN 320.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING HORIZONTAL FROM 1 BY 10\n    UNTIL HORIZONTAL IS GREATER THAN 560.\n    DISPLAY '' UPON CONSOLE.\nCOMPUTATION-PARAGRAPH.\n    SUBTRACT 280   FROM HORIZONTAL GIVING X.\n    SUBTRACT 160   FROM VERTICAL   GIVING Y.\n    DIVIDE   X     BY   200        GIVING X.\n    DIVIDE   Y     BY   100        GIVING Y.\n    MOVE     '#'   TO   WS-PLOT-CHARACTER.\n    PERFORM COMPLEX-MULTIPLICATION-PARAGRAPH\n    VARYING ITERATIONS FROM   1  BY      1\n    UNTIL   ITERATIONS        IS GREATER THAN 50\n    OR      WS-PLOT-CHARACTER IS EQUAL   TO   SPACE.\n    DISPLAY WS-PLOT-CHARACTER UPON CONSOLE WITH NO ADVANCING.\nCOMPLEX-MULTIPLICATION-PARAGRAPH.\n    MULTIPLY X         BY   X         GIVING X-SQUARED.\n    MULTIPLY Y         BY   Y         GIVING Y-SQUARED.\n    SUBTRACT Y-SQUARED FROM X-SQUARED GIVING Z-REAL.\n    ADD      C-REAL    TO   Z-REAL.\n    MULTIPLY X         BY   Y         GIVING X-TIMES-Y.\n    MULTIPLY X-TIMES-Y BY   2         GIVING Z-IMAGINARY.\n    ADD C-IMAGINARY    TO   Z-IMAGINARY.\n    MULTIPLY Z-REAL    BY   Z-REAL    GIVING Z-REAL-SQUARED.\n    IF  Z-REAL-SQUARED IS   GREATER   THAN   10000 THEN\n    MOVE SPACE         TO   WS-PLOT-CHARACTER.\n    MOVE Z-REAL        TO   X.\n    MOVE Z-IMAGINARY   TO   Y.\n", "target": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class JuliaSet extends JPanel {\n    private static final int MAX_ITERATIONS = 300;\n    private static final double ZOOM = 1;\n    private static final double CX = -0.7;\n    private static final double CY = 0.27015;\n    private static final double MOVE_X = 0;\n    private static final double MOVE_Y = 0;\n\n    public JuliaSet() {\n        setPreferredSize(new Dimension(800, 600));\n        setBackground(Color.white);\n    }\n\n    void drawJuliaSet(Graphics2D g) {\n        int w = getWidth();\n        int h = getHeight();\n        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n\n        for (int x = 0; x < w; x++) {\n            for (int y = 0; y < h; y++) {\n                double zx = 1.5 * (x - w / 2) / (0.5 * ZOOM * w) + MOVE_X;\n                double zy = (y - h / 2) / (0.5 * ZOOM * h) + MOVE_Y;\n                float i = MAX_ITERATIONS;\n                while (zx * zx + zy * zy < 4 && i > 0) {\n                    double tmp = zx * zx - zy * zy + CX;\n                    zy = 2.0 * zx * zy + CY;\n                    zx = tmp;\n                    i--;\n                }\n                int c = Color.HSBtoRGB((MAX_ITERATIONS / i) % 1, 1, i > 0 ? 1 : 0);\n                image.setRGB(x, y, c);\n            }\n        }\n        g.drawImage(image, 0, 0, null);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        drawJuliaSet(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Julia Set\");\n            f.setResizable(false);\n            f.add(new JuliaSet(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 64160, "name": "Julia set", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. JULIA-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-COMPLEX-CONSTANT.\n    05 C-REAL             PIC S9V999.\n    05 C-IMAGINARY        PIC S9V999.\n01  WS-ARGAND-PLANE.\n    05 X                  PIC S9(9)V999.\n    05 Y                  PIC S9(9)V999.\n01  WS-COMPLEX-VARIABLE.\n    05 Z-REAL             PIC S9(9)V999.\n    05 Z-IMAGINARY        PIC S9(9)V999.\n01  WS-TEMPORARY-RESULTS.\n    05 X-SQUARED          PIC S9(9)V999.\n    05 Y-SQUARED          PIC S9(9)V999.\n    05 X-TIMES-Y          PIC S9(9)V999.\n    05 Z-REAL-SQUARED     PIC S9(9)V999.\n01  WS-LOOP-COUNTERS.\n    05 HORIZONTAL         PIC 999.\n    05 VERTICAL           PIC 999.\n    05 ITERATIONS         PIC 99.\n77  WS-PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nINPUT-COMPLEX-CONSTANT-PARAGRAPH.\n    ACCEPT C-REAL      FROM CONSOLE.\n    ACCEPT C-IMAGINARY FROM CONSOLE.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH  VARYING VERTICAL   FROM 1 BY 10\n    UNTIL VERTICAL IS GREATER THAN 320.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING HORIZONTAL FROM 1 BY 10\n    UNTIL HORIZONTAL IS GREATER THAN 560.\n    DISPLAY '' UPON CONSOLE.\nCOMPUTATION-PARAGRAPH.\n    SUBTRACT 280   FROM HORIZONTAL GIVING X.\n    SUBTRACT 160   FROM VERTICAL   GIVING Y.\n    DIVIDE   X     BY   200        GIVING X.\n    DIVIDE   Y     BY   100        GIVING Y.\n    MOVE     '#'   TO   WS-PLOT-CHARACTER.\n    PERFORM COMPLEX-MULTIPLICATION-PARAGRAPH\n    VARYING ITERATIONS FROM   1  BY      1\n    UNTIL   ITERATIONS        IS GREATER THAN 50\n    OR      WS-PLOT-CHARACTER IS EQUAL   TO   SPACE.\n    DISPLAY WS-PLOT-CHARACTER UPON CONSOLE WITH NO ADVANCING.\nCOMPLEX-MULTIPLICATION-PARAGRAPH.\n    MULTIPLY X         BY   X         GIVING X-SQUARED.\n    MULTIPLY Y         BY   Y         GIVING Y-SQUARED.\n    SUBTRACT Y-SQUARED FROM X-SQUARED GIVING Z-REAL.\n    ADD      C-REAL    TO   Z-REAL.\n    MULTIPLY X         BY   Y         GIVING X-TIMES-Y.\n    MULTIPLY X-TIMES-Y BY   2         GIVING Z-IMAGINARY.\n    ADD C-IMAGINARY    TO   Z-IMAGINARY.\n    MULTIPLY Z-REAL    BY   Z-REAL    GIVING Z-REAL-SQUARED.\n    IF  Z-REAL-SQUARED IS   GREATER   THAN   10000 THEN\n    MOVE SPACE         TO   WS-PLOT-CHARACTER.\n    MOVE Z-REAL        TO   X.\n    MOVE Z-IMAGINARY   TO   Y.\n", "target": "from __future__ import division\n\ncX = -0.7\ncY = 0.27015\nmaxIter = 300\n\ndef setup():\n    size(640, 480)\n\ndef draw():\n    for x in range(width):\n        for y in range(height):\n            zx = 1.5 * (x - width / 2) / (0.5 * width)\n            zy = (y - height / 2) / (0.5 * height)\n            i = maxIter\n            while zx * zx + zy * zy < 4 and i > 0:\n                tmp = zx * zx - zy * zy + cX\n                zy = 2.0 * zx * zy + cY\n                zx = tmp\n                i -= 1\n            colorMode(HSB)\n            c = color(i / maxIter * 255, 255, 255 if i > 1 else 0)\n            set(x, y, c)\n"}
{"id": 64161, "name": "Julia set", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. JULIA-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-COMPLEX-CONSTANT.\n    05 C-REAL             PIC S9V999.\n    05 C-IMAGINARY        PIC S9V999.\n01  WS-ARGAND-PLANE.\n    05 X                  PIC S9(9)V999.\n    05 Y                  PIC S9(9)V999.\n01  WS-COMPLEX-VARIABLE.\n    05 Z-REAL             PIC S9(9)V999.\n    05 Z-IMAGINARY        PIC S9(9)V999.\n01  WS-TEMPORARY-RESULTS.\n    05 X-SQUARED          PIC S9(9)V999.\n    05 Y-SQUARED          PIC S9(9)V999.\n    05 X-TIMES-Y          PIC S9(9)V999.\n    05 Z-REAL-SQUARED     PIC S9(9)V999.\n01  WS-LOOP-COUNTERS.\n    05 HORIZONTAL         PIC 999.\n    05 VERTICAL           PIC 999.\n    05 ITERATIONS         PIC 99.\n77  WS-PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nINPUT-COMPLEX-CONSTANT-PARAGRAPH.\n    ACCEPT C-REAL      FROM CONSOLE.\n    ACCEPT C-IMAGINARY FROM CONSOLE.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH  VARYING VERTICAL   FROM 1 BY 10\n    UNTIL VERTICAL IS GREATER THAN 320.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING HORIZONTAL FROM 1 BY 10\n    UNTIL HORIZONTAL IS GREATER THAN 560.\n    DISPLAY '' UPON CONSOLE.\nCOMPUTATION-PARAGRAPH.\n    SUBTRACT 280   FROM HORIZONTAL GIVING X.\n    SUBTRACT 160   FROM VERTICAL   GIVING Y.\n    DIVIDE   X     BY   200        GIVING X.\n    DIVIDE   Y     BY   100        GIVING Y.\n    MOVE     '#'   TO   WS-PLOT-CHARACTER.\n    PERFORM COMPLEX-MULTIPLICATION-PARAGRAPH\n    VARYING ITERATIONS FROM   1  BY      1\n    UNTIL   ITERATIONS        IS GREATER THAN 50\n    OR      WS-PLOT-CHARACTER IS EQUAL   TO   SPACE.\n    DISPLAY WS-PLOT-CHARACTER UPON CONSOLE WITH NO ADVANCING.\nCOMPLEX-MULTIPLICATION-PARAGRAPH.\n    MULTIPLY X         BY   X         GIVING X-SQUARED.\n    MULTIPLY Y         BY   Y         GIVING Y-SQUARED.\n    SUBTRACT Y-SQUARED FROM X-SQUARED GIVING Z-REAL.\n    ADD      C-REAL    TO   Z-REAL.\n    MULTIPLY X         BY   Y         GIVING X-TIMES-Y.\n    MULTIPLY X-TIMES-Y BY   2         GIVING Z-IMAGINARY.\n    ADD C-IMAGINARY    TO   Z-IMAGINARY.\n    MULTIPLY Z-REAL    BY   Z-REAL    GIVING Z-REAL-SQUARED.\n    IF  Z-REAL-SQUARED IS   GREATER   THAN   10000 THEN\n    MOVE SPACE         TO   WS-PLOT-CHARACTER.\n    MOVE Z-REAL        TO   X.\n    MOVE Z-IMAGINARY   TO   Y.\n", "target": "from __future__ import division\n\ncX = -0.7\ncY = 0.27015\nmaxIter = 300\n\ndef setup():\n    size(640, 480)\n\ndef draw():\n    for x in range(width):\n        for y in range(height):\n            zx = 1.5 * (x - width / 2) / (0.5 * width)\n            zy = (y - height / 2) / (0.5 * height)\n            i = maxIter\n            while zx * zx + zy * zy < 4 and i > 0:\n                tmp = zx * zx - zy * zy + cX\n                zy = 2.0 * zx * zy + cY\n                zx = tmp\n                i -= 1\n            colorMode(HSB)\n            c = color(i / maxIter * 255, 255, 255 if i > 1 else 0)\n            set(x, y, c)\n"}
{"id": 64596, "name": "Calculating the value of e", "source": "Translate COBOL to C#:        >>SOURCE FORMAT IS FIXED\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n           01 EPSILON USAGE COMPUTATIONAL-2 VALUE 1.0E-15.\n           01 FACT USAGE BINARY-DOUBLE UNSIGNED VALUE 1.\n           01 N USAGE BINARY-INT UNSIGNED.\n           01 E USAGE COMPUTATIONAL-2 VALUE 2.0.\n           01 E0 USAGE COMPUTATIONAL-2 value 0.0.\n           01 RESULT-MESSAGE.\n              03 FILLER PIC X(4) VALUE 'e = '.\n              03 RESULT-VALUE PIC 9.9(18) USAGE DISPLAY.\n       PROCEDURE DIVISION.\n       MAIN SECTION.\n           PERFORM\n              VARYING N FROM 2 BY 1\n              UNTIL FUNCTION ABS(E - E0) < EPSILON\n              MOVE E TO E0\n              COMPUTE FACT = FACT * N\n              COMPUTE E = E + 1.0 / FACT\n           END-PERFORM.\n           MOVE E TO RESULT-VALUE.\n           DISPLAY RESULT-MESSAGE.\n           STOP RUN.\n", "target": "using System;\n\nnamespace CalculateE {\n    class Program {\n        public const double EPSILON = 1.0e-15;\n\n        static void Main(string[] args) {\n            ulong fact = 1;\n            double e = 2.0;\n            double e0;\n            uint n = 2;\n            do {\n                e0 = e;\n                fact *= n++;\n                e += 1.0 / fact;\n            } while (Math.Abs(e - e0) >= EPSILON);\n            Console.WriteLine(\"e = {0:F15}\", e);\n        }\n    }\n}\n"}
{"id": 64597, "name": "Calculating the value of e", "source": "Translate COBOL to C#:        >>SOURCE FORMAT IS FIXED\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n           01 EPSILON USAGE COMPUTATIONAL-2 VALUE 1.0E-15.\n           01 FACT USAGE BINARY-DOUBLE UNSIGNED VALUE 1.\n           01 N USAGE BINARY-INT UNSIGNED.\n           01 E USAGE COMPUTATIONAL-2 VALUE 2.0.\n           01 E0 USAGE COMPUTATIONAL-2 value 0.0.\n           01 RESULT-MESSAGE.\n              03 FILLER PIC X(4) VALUE 'e = '.\n              03 RESULT-VALUE PIC 9.9(18) USAGE DISPLAY.\n       PROCEDURE DIVISION.\n       MAIN SECTION.\n           PERFORM\n              VARYING N FROM 2 BY 1\n              UNTIL FUNCTION ABS(E - E0) < EPSILON\n              MOVE E TO E0\n              COMPUTE FACT = FACT * N\n              COMPUTE E = E + 1.0 / FACT\n           END-PERFORM.\n           MOVE E TO RESULT-VALUE.\n           DISPLAY RESULT-MESSAGE.\n           STOP RUN.\n", "target": "using System;\n\nnamespace CalculateE {\n    class Program {\n        public const double EPSILON = 1.0e-15;\n\n        static void Main(string[] args) {\n            ulong fact = 1;\n            double e = 2.0;\n            double e0;\n            uint n = 2;\n            do {\n                e0 = e;\n                fact *= n++;\n                e += 1.0 / fact;\n            } while (Math.Abs(e - e0) >= EPSILON);\n            Console.WriteLine(\"e = {0:F15}\", e);\n        }\n    }\n}\n"}
{"id": 64600, "name": "Calculating the value of e", "source": "Translate COBOL to Java:        >>SOURCE FORMAT IS FIXED\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n           01 EPSILON USAGE COMPUTATIONAL-2 VALUE 1.0E-15.\n           01 FACT USAGE BINARY-DOUBLE UNSIGNED VALUE 1.\n           01 N USAGE BINARY-INT UNSIGNED.\n           01 E USAGE COMPUTATIONAL-2 VALUE 2.0.\n           01 E0 USAGE COMPUTATIONAL-2 value 0.0.\n           01 RESULT-MESSAGE.\n              03 FILLER PIC X(4) VALUE 'e = '.\n              03 RESULT-VALUE PIC 9.9(18) USAGE DISPLAY.\n       PROCEDURE DIVISION.\n       MAIN SECTION.\n           PERFORM\n              VARYING N FROM 2 BY 1\n              UNTIL FUNCTION ABS(E - E0) < EPSILON\n              MOVE E TO E0\n              COMPUTE FACT = FACT * N\n              COMPUTE E = E + 1.0 / FACT\n           END-PERFORM.\n           MOVE E TO RESULT-VALUE.\n           DISPLAY RESULT-MESSAGE.\n           STOP RUN.\n", "target": "public class CalculateE {\n    public static final double EPSILON = 1.0e-15;\n\n    public static void main(String[] args) {\n        long fact = 1;\n        double e = 2.0;\n        int n = 2;\n        double e0;\n        do {\n            e0 = e;\n            fact *= n++;\n            e += 1.0 / fact;\n        } while (Math.abs(e - e0) >= EPSILON);\n        System.out.printf(\"e =\u00a0%.15f\\n\", e);\n    }\n}\n"}
{"id": 64601, "name": "Calculating the value of e", "source": "Translate COBOL to Java:        >>SOURCE FORMAT IS FIXED\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n           01 EPSILON USAGE COMPUTATIONAL-2 VALUE 1.0E-15.\n           01 FACT USAGE BINARY-DOUBLE UNSIGNED VALUE 1.\n           01 N USAGE BINARY-INT UNSIGNED.\n           01 E USAGE COMPUTATIONAL-2 VALUE 2.0.\n           01 E0 USAGE COMPUTATIONAL-2 value 0.0.\n           01 RESULT-MESSAGE.\n              03 FILLER PIC X(4) VALUE 'e = '.\n              03 RESULT-VALUE PIC 9.9(18) USAGE DISPLAY.\n       PROCEDURE DIVISION.\n       MAIN SECTION.\n           PERFORM\n              VARYING N FROM 2 BY 1\n              UNTIL FUNCTION ABS(E - E0) < EPSILON\n              MOVE E TO E0\n              COMPUTE FACT = FACT * N\n              COMPUTE E = E + 1.0 / FACT\n           END-PERFORM.\n           MOVE E TO RESULT-VALUE.\n           DISPLAY RESULT-MESSAGE.\n           STOP RUN.\n", "target": "public class CalculateE {\n    public static final double EPSILON = 1.0e-15;\n\n    public static void main(String[] args) {\n        long fact = 1;\n        double e = 2.0;\n        int n = 2;\n        double e0;\n        do {\n            e0 = e;\n            fact *= n++;\n            e += 1.0 / fact;\n        } while (Math.abs(e - e0) >= EPSILON);\n        System.out.printf(\"e =\u00a0%.15f\\n\", e);\n    }\n}\n"}
{"id": 64602, "name": "Calculating the value of e", "source": "Translate COBOL to Python:        >>SOURCE FORMAT IS FIXED\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n           01 EPSILON USAGE COMPUTATIONAL-2 VALUE 1.0E-15.\n           01 FACT USAGE BINARY-DOUBLE UNSIGNED VALUE 1.\n           01 N USAGE BINARY-INT UNSIGNED.\n           01 E USAGE COMPUTATIONAL-2 VALUE 2.0.\n           01 E0 USAGE COMPUTATIONAL-2 value 0.0.\n           01 RESULT-MESSAGE.\n              03 FILLER PIC X(4) VALUE 'e = '.\n              03 RESULT-VALUE PIC 9.9(18) USAGE DISPLAY.\n       PROCEDURE DIVISION.\n       MAIN SECTION.\n           PERFORM\n              VARYING N FROM 2 BY 1\n              UNTIL FUNCTION ABS(E - E0) < EPSILON\n              MOVE E TO E0\n              COMPUTE FACT = FACT * N\n              COMPUTE E = E + 1.0 / FACT\n           END-PERFORM.\n           MOVE E TO RESULT-VALUE.\n           DISPLAY RESULT-MESSAGE.\n           STOP RUN.\n", "target": "import math\n\ne0 = 0\ne = 2\nn = 0\nfact = 1\nwhile(e-e0 > 1e-15):\n\te0 = e\n\tn += 1\n\tfact *= 2*n*(2*n+1)\n\te += (2.*n+2)/fact\n\nprint \"Computed e = \"+str(e)\nprint \"Real e = \"+str(math.e)\nprint \"Error = \"+str(math.e-e)\nprint \"Number of iterations = \"+str(n)\n"}
{"id": 64603, "name": "Calculating the value of e", "source": "Translate COBOL to Python:        >>SOURCE FORMAT IS FIXED\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n           01 EPSILON USAGE COMPUTATIONAL-2 VALUE 1.0E-15.\n           01 FACT USAGE BINARY-DOUBLE UNSIGNED VALUE 1.\n           01 N USAGE BINARY-INT UNSIGNED.\n           01 E USAGE COMPUTATIONAL-2 VALUE 2.0.\n           01 E0 USAGE COMPUTATIONAL-2 value 0.0.\n           01 RESULT-MESSAGE.\n              03 FILLER PIC X(4) VALUE 'e = '.\n              03 RESULT-VALUE PIC 9.9(18) USAGE DISPLAY.\n       PROCEDURE DIVISION.\n       MAIN SECTION.\n           PERFORM\n              VARYING N FROM 2 BY 1\n              UNTIL FUNCTION ABS(E - E0) < EPSILON\n              MOVE E TO E0\n              COMPUTE FACT = FACT * N\n              COMPUTE E = E + 1.0 / FACT\n           END-PERFORM.\n           MOVE E TO RESULT-VALUE.\n           DISPLAY RESULT-MESSAGE.\n           STOP RUN.\n", "target": "import math\n\ne0 = 0\ne = 2\nn = 0\nfact = 1\nwhile(e-e0 > 1e-15):\n\te0 = e\n\tn += 1\n\tfact *= 2*n*(2*n+1)\n\te += (2.*n+2)/fact\n\nprint \"Computed e = \"+str(e)\nprint \"Real e = \"+str(math.e)\nprint \"Error = \"+str(math.e-e)\nprint \"Number of iterations = \"+str(n)\n"}
{"id": 65263, "name": "Inheritance_Single", "source": "Translate COBOL to C#:        CLASS-ID. Animal.\n           \n       END CLASS Animal.\n       \n       CLASS-ID. Dog INHERITS Animal.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Animal.\n\n           \n       END CLASS Dog.\n       \n       CLASS-ID. Cat INHERITS Animal. \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Animal. \n\n           \n       END CLASS Cat.\n           \n       CLASS-ID. Lab INHERITS Dog.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Dog.\n\n           \n       END CLASS Lab.\n       \n       CLASS-ID. Collie INHERITS Dog.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Dog.\n\n           \n       END CLASS Collie.\n", "target": "class Animal\n{ \n   \n  \n}\n\nclass Dog : Animal\n{ \n   \n  \n}\n\nclass Lab : Dog\n{ \n   \n  \n}\n\nclass Collie : Dog\n{ \n  \n  \n}\n\nclass Cat : Animal\n{ \n  \n  \n}\n"}
{"id": 65265, "name": "Inheritance_Single", "source": "Translate COBOL to Java:        CLASS-ID. Animal.\n           \n       END CLASS Animal.\n       \n       CLASS-ID. Dog INHERITS Animal.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Animal.\n\n           \n       END CLASS Dog.\n       \n       CLASS-ID. Cat INHERITS Animal. \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Animal. \n\n           \n       END CLASS Cat.\n           \n       CLASS-ID. Lab INHERITS Dog.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Dog.\n\n           \n       END CLASS Lab.\n       \n       CLASS-ID. Collie INHERITS Dog.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Dog.\n\n           \n       END CLASS Collie.\n", "target": "public class Animal{\n   \n}\n"}
{"id": 65266, "name": "Inheritance_Single", "source": "Translate COBOL to Python:        CLASS-ID. Animal.\n           \n       END CLASS Animal.\n       \n       CLASS-ID. Dog INHERITS Animal.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Animal.\n\n           \n       END CLASS Dog.\n       \n       CLASS-ID. Cat INHERITS Animal. \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Animal. \n\n           \n       END CLASS Cat.\n           \n       CLASS-ID. Lab INHERITS Dog.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Dog.\n\n           \n       END CLASS Lab.\n       \n       CLASS-ID. Collie INHERITS Dog.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Dog.\n\n           \n       END CLASS Collie.\n", "target": "class Animal:\n  pass \n\nclass Dog(Animal):\n  pass \n\nclass Cat(Animal):\n  pass \n\nclass Lab(Dog):\n  pass \n\nclass Collie(Dog):\n  pass \n"}
{"id": 66110, "name": "N'th", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. NTH-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-NUMBER.\n    05 N               PIC 9(8).\n    05 LAST-TWO-DIGITS PIC 99.\n    05 LAST-DIGIT      PIC 9.\n    05 N-TO-OUTPUT     PIC Z(7)9.\n    05 SUFFIX          PIC AA.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 0 BY 1 UNTIL N IS GREATER THAN 25.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 250 BY 1 UNTIL N IS GREATER THAN 265.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 1000 BY 1 UNTIL N IS GREATER THAN 1025.\n    STOP RUN.\nNTH-PARAGRAPH.\n    MOVE 'TH' TO SUFFIX.\n    MOVE N (7:2) TO LAST-TWO-DIGITS.\n    IF LAST-TWO-DIGITS IS LESS THAN 4,\n    OR LAST-TWO-DIGITS IS GREATER THAN 20,\n    THEN PERFORM DECISION-PARAGRAPH.\n    MOVE N TO N-TO-OUTPUT.\n    DISPLAY N-TO-OUTPUT WITH NO ADVANCING.\n    DISPLAY SUFFIX WITH NO ADVANCING.\n    DISPLAY SPACE WITH NO ADVANCING.\nDECISION-PARAGRAPH.\n    MOVE N (8:1) TO LAST-DIGIT.\n    IF LAST-DIGIT IS EQUAL TO 1 THEN MOVE 'ST' TO SUFFIX.\n    IF LAST-DIGIT IS EQUAL TO 2 THEN MOVE 'ND' TO SUFFIX.\n    IF LAST-DIGIT IS EQUAL TO 3 THEN MOVE 'RD' TO SUFFIX.\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    private static string Ordinalize(int i)\n    {\n        i = Math.Abs(i);\n\n        if (new[] {11, 12, 13}.Contains(i%100))\n            return i + \"th\";\n\n        switch (i%10)\n        {\n            case 1:\n                return i + \"st\";\n            case 2:\n                return i + \"nd\";\n            case 3:\n                return i + \"rd\";\n            default:\n                return i + \"th\";\n        }\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(0, 26).Select(Ordinalize)));\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(250, 16).Select(Ordinalize)));\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(1000, 26).Select(Ordinalize)));\n    }\n}\n"}
{"id": 66112, "name": "N'th", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. NTH-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-NUMBER.\n    05 N               PIC 9(8).\n    05 LAST-TWO-DIGITS PIC 99.\n    05 LAST-DIGIT      PIC 9.\n    05 N-TO-OUTPUT     PIC Z(7)9.\n    05 SUFFIX          PIC AA.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 0 BY 1 UNTIL N IS GREATER THAN 25.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 250 BY 1 UNTIL N IS GREATER THAN 265.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 1000 BY 1 UNTIL N IS GREATER THAN 1025.\n    STOP RUN.\nNTH-PARAGRAPH.\n    MOVE 'TH' TO SUFFIX.\n    MOVE N (7:2) TO LAST-TWO-DIGITS.\n    IF LAST-TWO-DIGITS IS LESS THAN 4,\n    OR LAST-TWO-DIGITS IS GREATER THAN 20,\n    THEN PERFORM DECISION-PARAGRAPH.\n    MOVE N TO N-TO-OUTPUT.\n    DISPLAY N-TO-OUTPUT WITH NO ADVANCING.\n    DISPLAY SUFFIX WITH NO ADVANCING.\n    DISPLAY SPACE WITH NO ADVANCING.\nDECISION-PARAGRAPH.\n    MOVE N (8:1) TO LAST-DIGIT.\n    IF LAST-DIGIT IS EQUAL TO 1 THEN MOVE 'ST' TO SUFFIX.\n    IF LAST-DIGIT IS EQUAL TO 2 THEN MOVE 'ND' TO SUFFIX.\n    IF LAST-DIGIT IS EQUAL TO 3 THEN MOVE 'RD' TO SUFFIX.\n", "target": "public class Nth {\n\tpublic static String ordinalAbbrev(int n){\n\t\tString ans = \"th\"; \n\t\tif(n % 100 / 10 == 1) return ans; \n\t\tswitch(n % 10){\n\t\t\tcase 1: ans = \"st\"; break;\n\t\t\tcase 2: ans = \"nd\"; break;\n\t\t\tcase 3: ans = \"rd\"; break;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 25;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 250; i <= 265;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 1000; i <= 1025;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t}\n}\n"}
{"id": 66113, "name": "N'th", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. NTH-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-NUMBER.\n    05 N               PIC 9(8).\n    05 LAST-TWO-DIGITS PIC 99.\n    05 LAST-DIGIT      PIC 9.\n    05 N-TO-OUTPUT     PIC Z(7)9.\n    05 SUFFIX          PIC AA.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 0 BY 1 UNTIL N IS GREATER THAN 25.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 250 BY 1 UNTIL N IS GREATER THAN 265.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 1000 BY 1 UNTIL N IS GREATER THAN 1025.\n    STOP RUN.\nNTH-PARAGRAPH.\n    MOVE 'TH' TO SUFFIX.\n    MOVE N (7:2) TO LAST-TWO-DIGITS.\n    IF LAST-TWO-DIGITS IS LESS THAN 4,\n    OR LAST-TWO-DIGITS IS GREATER THAN 20,\n    THEN PERFORM DECISION-PARAGRAPH.\n    MOVE N TO N-TO-OUTPUT.\n    DISPLAY N-TO-OUTPUT WITH NO ADVANCING.\n    DISPLAY SUFFIX WITH NO ADVANCING.\n    DISPLAY SPACE WITH NO ADVANCING.\nDECISION-PARAGRAPH.\n    MOVE N (8:1) TO LAST-DIGIT.\n    IF LAST-DIGIT IS EQUAL TO 1 THEN MOVE 'ST' TO SUFFIX.\n    IF LAST-DIGIT IS EQUAL TO 2 THEN MOVE 'ND' TO SUFFIX.\n    IF LAST-DIGIT IS EQUAL TO 3 THEN MOVE 'RD' TO SUFFIX.\n", "target": "_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    return \"%i'%s\" % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th')\n\nif __name__ == '__main__':\n    for j in range(0,1001, 250):\n        print(' '.join(nth(i) for i in list(range(j, j+25))))\n"}
{"id": 66567, "name": "Levenshtein distance", "source": "Translate COBOL to C#:        identification division.\n       program-id. Levenshtein.\n \n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n \n       data division.\n       working-storage section.\n       77  string-a               pic x(255).\n       77  string-b               pic x(255).\n       77  length-a               pic 9(3).\n       77  length-b               pic 9(3).\n       77  distance               pic z(3).\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).\n       01  tab.\n           05 filler              occurs 256.\n              10 filler           occurs 256.\n                 15 costs         pic 9(3).\n\n       procedure division.\n       main.\n           move \"kitten\" to string-a\n           move \"sitting\" to string-b\n           perform levenshtein-dist\n\n           move \"rosettacode\" to string-a\n           move \"raisethysword\" to string-b\n           perform levenshtein-dist\n           stop run\n           .\n       levenshtein-dist.\n           move length(trim(string-a)) to length-a\n           move length(trim(string-b)) to length-b\n\n           initialize tab\n           \n           perform varying i from 0 by 1 until i > length-a\n              move i to costs(i + 1, 1)\n           end-perform\n\n           perform varying j from 0 by 1 until j > length-b\n              move j to costs(1, j + 1)\n           end-perform\n           \n           perform with test after varying i from 2 by 1 until i > length-a\n              perform with test after varying j from 2 by 1 until j > length-b\n                 if string-a(i - 1:1) = string-b(j - 1:1)\n                    move costs(i - 1, j - 1) to costs(i, j)\n                 else\n                    move min(min(costs(i - 1, j) + 1,     \n                                 costs(i, j - 1) + 1),    \n                             costs(i - 1, j - 1) + 1)     \n                       to costs(i, j)\n                 end-if\n              end-perform\n           end-perform\n           move costs(length-a + 1, length-b + 1) to distance\n           display trim(string-a) \" -> \" trim(string-b) \" = \" trim(distance)\n           .\n", "target": "using System;\n\nnamespace LevenshteinDistance\n{\n    class Program\n    {\n        static int LevenshteinDistance(string s, string t)\n        {\n            int n = s.Length;\n            int m = t.Length;\n            int[,] d = new int[n + 1, m + 1];\n\t\t\n\t    if (n == 0)\n\t    {\n\t\treturn m;\n\t    }\n\t\n\t    if (m == 0)\n\t    {\n\t\treturn n;\n\t    }\n\n            for (int i = 0; i <= n; i++)\n                d[i, 0] = i;\n            for (int j = 0; j <= m; j++)\n                d[0, j] = j;\n\t\t\t\n            for (int j = 1; j <= m; j++)\n                for (int i = 1; i <= n; i++)\n                    if (s[i - 1] == t[j - 1])\n                        d[i, j] = d[i - 1, j - 1];  \n                    else\n                        d[i, j] = Math.Min(Math.Min(\n                            d[i - 1, j] + 1,    \n                            d[i, j - 1] + 1),   \n                            d[i - 1, j - 1] + 1 \n                            );\n            return d[n, m];\n        }\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 2)\n                Console.WriteLine(\"{0} -> {1} = {2}\",\n                    args[0], args[1], LevenshteinDistance(args[0], args[1]));\n            else\n                Console.WriteLine(\"Usage:-\\n\\nLevenshteinDistance <string1> <string2>\");\n        }\n    }\n}\n"}
{"id": 66568, "name": "Levenshtein distance", "source": "Translate COBOL to C#:        identification division.\n       program-id. Levenshtein.\n \n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n \n       data division.\n       working-storage section.\n       77  string-a               pic x(255).\n       77  string-b               pic x(255).\n       77  length-a               pic 9(3).\n       77  length-b               pic 9(3).\n       77  distance               pic z(3).\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).\n       01  tab.\n           05 filler              occurs 256.\n              10 filler           occurs 256.\n                 15 costs         pic 9(3).\n\n       procedure division.\n       main.\n           move \"kitten\" to string-a\n           move \"sitting\" to string-b\n           perform levenshtein-dist\n\n           move \"rosettacode\" to string-a\n           move \"raisethysword\" to string-b\n           perform levenshtein-dist\n           stop run\n           .\n       levenshtein-dist.\n           move length(trim(string-a)) to length-a\n           move length(trim(string-b)) to length-b\n\n           initialize tab\n           \n           perform varying i from 0 by 1 until i > length-a\n              move i to costs(i + 1, 1)\n           end-perform\n\n           perform varying j from 0 by 1 until j > length-b\n              move j to costs(1, j + 1)\n           end-perform\n           \n           perform with test after varying i from 2 by 1 until i > length-a\n              perform with test after varying j from 2 by 1 until j > length-b\n                 if string-a(i - 1:1) = string-b(j - 1:1)\n                    move costs(i - 1, j - 1) to costs(i, j)\n                 else\n                    move min(min(costs(i - 1, j) + 1,     \n                                 costs(i, j - 1) + 1),    \n                             costs(i - 1, j - 1) + 1)     \n                       to costs(i, j)\n                 end-if\n              end-perform\n           end-perform\n           move costs(length-a + 1, length-b + 1) to distance\n           display trim(string-a) \" -> \" trim(string-b) \" = \" trim(distance)\n           .\n", "target": "using System;\n\nnamespace LevenshteinDistance\n{\n    class Program\n    {\n        static int LevenshteinDistance(string s, string t)\n        {\n            int n = s.Length;\n            int m = t.Length;\n            int[,] d = new int[n + 1, m + 1];\n\t\t\n\t    if (n == 0)\n\t    {\n\t\treturn m;\n\t    }\n\t\n\t    if (m == 0)\n\t    {\n\t\treturn n;\n\t    }\n\n            for (int i = 0; i <= n; i++)\n                d[i, 0] = i;\n            for (int j = 0; j <= m; j++)\n                d[0, j] = j;\n\t\t\t\n            for (int j = 1; j <= m; j++)\n                for (int i = 1; i <= n; i++)\n                    if (s[i - 1] == t[j - 1])\n                        d[i, j] = d[i - 1, j - 1];  \n                    else\n                        d[i, j] = Math.Min(Math.Min(\n                            d[i - 1, j] + 1,    \n                            d[i, j - 1] + 1),   \n                            d[i - 1, j - 1] + 1 \n                            );\n            return d[n, m];\n        }\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 2)\n                Console.WriteLine(\"{0} -> {1} = {2}\",\n                    args[0], args[1], LevenshteinDistance(args[0], args[1]));\n            else\n                Console.WriteLine(\"Usage:-\\n\\nLevenshteinDistance <string1> <string2>\");\n        }\n    }\n}\n"}
{"id": 66571, "name": "Levenshtein distance", "source": "Translate COBOL to Java:        identification division.\n       program-id. Levenshtein.\n \n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n \n       data division.\n       working-storage section.\n       77  string-a               pic x(255).\n       77  string-b               pic x(255).\n       77  length-a               pic 9(3).\n       77  length-b               pic 9(3).\n       77  distance               pic z(3).\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).\n       01  tab.\n           05 filler              occurs 256.\n              10 filler           occurs 256.\n                 15 costs         pic 9(3).\n\n       procedure division.\n       main.\n           move \"kitten\" to string-a\n           move \"sitting\" to string-b\n           perform levenshtein-dist\n\n           move \"rosettacode\" to string-a\n           move \"raisethysword\" to string-b\n           perform levenshtein-dist\n           stop run\n           .\n       levenshtein-dist.\n           move length(trim(string-a)) to length-a\n           move length(trim(string-b)) to length-b\n\n           initialize tab\n           \n           perform varying i from 0 by 1 until i > length-a\n              move i to costs(i + 1, 1)\n           end-perform\n\n           perform varying j from 0 by 1 until j > length-b\n              move j to costs(1, j + 1)\n           end-perform\n           \n           perform with test after varying i from 2 by 1 until i > length-a\n              perform with test after varying j from 2 by 1 until j > length-b\n                 if string-a(i - 1:1) = string-b(j - 1:1)\n                    move costs(i - 1, j - 1) to costs(i, j)\n                 else\n                    move min(min(costs(i - 1, j) + 1,     \n                                 costs(i, j - 1) + 1),    \n                             costs(i - 1, j - 1) + 1)     \n                       to costs(i, j)\n                 end-if\n              end-perform\n           end-perform\n           move costs(length-a + 1, length-b + 1) to distance\n           display trim(string-a) \" -> \" trim(string-b) \" = \" trim(distance)\n           .\n", "target": "public class Levenshtein {\n\n    public static int distance(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int [] costs = new int [b.length() + 1];\n        for (int j = 0; j < costs.length; j++)\n            costs[j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            \n            costs[0] = i;\n            int nw = i - 1;\n            for (int j = 1; j <= b.length(); j++) {\n                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);\n                nw = costs[j];\n                costs[j] = cj;\n            }\n        }\n        return costs[b.length()];\n    }\n\n    public static void main(String [] args) {\n        String [] data = { \"kitten\", \"sitting\", \"saturday\", \"sunday\", \"rosettacode\", \"raisethysword\" };\n        for (int i = 0; i < data.length; i += 2)\n            System.out.println(\"distance(\" + data[i] + \", \" + data[i+1] + \") = \" + distance(data[i], data[i+1]));\n    }\n}\n"}
{"id": 66572, "name": "Levenshtein distance", "source": "Translate COBOL to Java:        identification division.\n       program-id. Levenshtein.\n \n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n \n       data division.\n       working-storage section.\n       77  string-a               pic x(255).\n       77  string-b               pic x(255).\n       77  length-a               pic 9(3).\n       77  length-b               pic 9(3).\n       77  distance               pic z(3).\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).\n       01  tab.\n           05 filler              occurs 256.\n              10 filler           occurs 256.\n                 15 costs         pic 9(3).\n\n       procedure division.\n       main.\n           move \"kitten\" to string-a\n           move \"sitting\" to string-b\n           perform levenshtein-dist\n\n           move \"rosettacode\" to string-a\n           move \"raisethysword\" to string-b\n           perform levenshtein-dist\n           stop run\n           .\n       levenshtein-dist.\n           move length(trim(string-a)) to length-a\n           move length(trim(string-b)) to length-b\n\n           initialize tab\n           \n           perform varying i from 0 by 1 until i > length-a\n              move i to costs(i + 1, 1)\n           end-perform\n\n           perform varying j from 0 by 1 until j > length-b\n              move j to costs(1, j + 1)\n           end-perform\n           \n           perform with test after varying i from 2 by 1 until i > length-a\n              perform with test after varying j from 2 by 1 until j > length-b\n                 if string-a(i - 1:1) = string-b(j - 1:1)\n                    move costs(i - 1, j - 1) to costs(i, j)\n                 else\n                    move min(min(costs(i - 1, j) + 1,     \n                                 costs(i, j - 1) + 1),    \n                             costs(i - 1, j - 1) + 1)     \n                       to costs(i, j)\n                 end-if\n              end-perform\n           end-perform\n           move costs(length-a + 1, length-b + 1) to distance\n           display trim(string-a) \" -> \" trim(string-b) \" = \" trim(distance)\n           .\n", "target": "public class Levenshtein {\n\n    public static int distance(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int [] costs = new int [b.length() + 1];\n        for (int j = 0; j < costs.length; j++)\n            costs[j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            \n            costs[0] = i;\n            int nw = i - 1;\n            for (int j = 1; j <= b.length(); j++) {\n                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);\n                nw = costs[j];\n                costs[j] = cj;\n            }\n        }\n        return costs[b.length()];\n    }\n\n    public static void main(String [] args) {\n        String [] data = { \"kitten\", \"sitting\", \"saturday\", \"sunday\", \"rosettacode\", \"raisethysword\" };\n        for (int i = 0; i < data.length; i += 2)\n            System.out.println(\"distance(\" + data[i] + \", \" + data[i+1] + \") = \" + distance(data[i], data[i+1]));\n    }\n}\n"}
{"id": 66573, "name": "Levenshtein distance", "source": "Translate COBOL to Python:        identification division.\n       program-id. Levenshtein.\n \n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n \n       data division.\n       working-storage section.\n       77  string-a               pic x(255).\n       77  string-b               pic x(255).\n       77  length-a               pic 9(3).\n       77  length-b               pic 9(3).\n       77  distance               pic z(3).\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).\n       01  tab.\n           05 filler              occurs 256.\n              10 filler           occurs 256.\n                 15 costs         pic 9(3).\n\n       procedure division.\n       main.\n           move \"kitten\" to string-a\n           move \"sitting\" to string-b\n           perform levenshtein-dist\n\n           move \"rosettacode\" to string-a\n           move \"raisethysword\" to string-b\n           perform levenshtein-dist\n           stop run\n           .\n       levenshtein-dist.\n           move length(trim(string-a)) to length-a\n           move length(trim(string-b)) to length-b\n\n           initialize tab\n           \n           perform varying i from 0 by 1 until i > length-a\n              move i to costs(i + 1, 1)\n           end-perform\n\n           perform varying j from 0 by 1 until j > length-b\n              move j to costs(1, j + 1)\n           end-perform\n           \n           perform with test after varying i from 2 by 1 until i > length-a\n              perform with test after varying j from 2 by 1 until j > length-b\n                 if string-a(i - 1:1) = string-b(j - 1:1)\n                    move costs(i - 1, j - 1) to costs(i, j)\n                 else\n                    move min(min(costs(i - 1, j) + 1,     \n                                 costs(i, j - 1) + 1),    \n                             costs(i - 1, j - 1) + 1)     \n                       to costs(i, j)\n                 end-if\n              end-perform\n           end-perform\n           move costs(length-a + 1, length-b + 1) to distance\n           display trim(string-a) \" -> \" trim(string-b) \" = \" trim(distance)\n           .\n", "target": "def setup():\n    println(distance(\"kitten\", \"sitting\"))\n\ndef distance(a, b):\n    costs = []\n    for j in range(len(b) + 1):\n        costs.append(j)\n    for i in range(1, len(a) + 1):\n        costs[0] = i\n        nw = i - 1\n        for j in range(1, len(b) + 1):\n            cj = min(1 + min(costs[j], costs[j - 1]),\n                     nw if a[i - 1] == b[j - 1] else nw + 1)\n            nw = costs[j]\n            costs[j] = cj\n\n    return costs[len(b)]\n"}
{"id": 66574, "name": "Levenshtein distance", "source": "Translate COBOL to Python:        identification division.\n       program-id. Levenshtein.\n \n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n \n       data division.\n       working-storage section.\n       77  string-a               pic x(255).\n       77  string-b               pic x(255).\n       77  length-a               pic 9(3).\n       77  length-b               pic 9(3).\n       77  distance               pic z(3).\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).\n       01  tab.\n           05 filler              occurs 256.\n              10 filler           occurs 256.\n                 15 costs         pic 9(3).\n\n       procedure division.\n       main.\n           move \"kitten\" to string-a\n           move \"sitting\" to string-b\n           perform levenshtein-dist\n\n           move \"rosettacode\" to string-a\n           move \"raisethysword\" to string-b\n           perform levenshtein-dist\n           stop run\n           .\n       levenshtein-dist.\n           move length(trim(string-a)) to length-a\n           move length(trim(string-b)) to length-b\n\n           initialize tab\n           \n           perform varying i from 0 by 1 until i > length-a\n              move i to costs(i + 1, 1)\n           end-perform\n\n           perform varying j from 0 by 1 until j > length-b\n              move j to costs(1, j + 1)\n           end-perform\n           \n           perform with test after varying i from 2 by 1 until i > length-a\n              perform with test after varying j from 2 by 1 until j > length-b\n                 if string-a(i - 1:1) = string-b(j - 1:1)\n                    move costs(i - 1, j - 1) to costs(i, j)\n                 else\n                    move min(min(costs(i - 1, j) + 1,     \n                                 costs(i, j - 1) + 1),    \n                             costs(i - 1, j - 1) + 1)     \n                       to costs(i, j)\n                 end-if\n              end-perform\n           end-perform\n           move costs(length-a + 1, length-b + 1) to distance\n           display trim(string-a) \" -> \" trim(string-b) \" = \" trim(distance)\n           .\n", "target": "def setup():\n    println(distance(\"kitten\", \"sitting\"))\n\ndef distance(a, b):\n    costs = []\n    for j in range(len(b) + 1):\n        costs.append(j)\n    for i in range(1, len(a) + 1):\n        costs[0] = i\n        nw = i - 1\n        for j in range(1, len(b) + 1):\n            cj = min(1 + min(costs[j], costs[j - 1]),\n                     nw if a[i - 1] == b[j - 1] else nw + 1)\n            nw = costs[j]\n            costs[j] = cj\n\n    return costs[len(b)]\n"}
{"id": 67021, "name": "15 puzzle game", "source": "Translate COBOL to C#:          >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. fifteen.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n\n01  r pic 9.\n01  r-empty pic 9.\n01  r-to pic 9.\n01  r-from pic 9.\n\n01  c pic 9.\n01  c-empty pic 9.\n01  c-to pic 9.\n01  c-from pic 9.\n\n01  display-table.\n    03  display-row occurs 4.\n        05  display-cell occurs 4 pic 99.\n\n01  tile-number pic 99.\n01  tile-flags pic x(16).\n\n01  display-move value spaces.\n    03  tile-id pic 99.\n\n01  row-separator pic x(21) value all '.'.\n01  column-separator pic x(3) value ' . '.\n\n01  inversions pic 99.\n01  current-tile pic 99.\n\n01  winning-display pic x(32) value\n        '01020304'\n    &   '05060708'\n    &   '09101112'\n    &   '13141500'.\n\nprocedure division.\nstart-fifteen.\n    display 'start fifteen puzzle'\n    display '    enter a two-digit tile number and press <enter> to move'\n    display '    press <enter> only to exit'\n\n    \n    perform initialize-table with test after until inversions = 0\n    perform show-table\n    accept display-move\n    perform until display-move = spaces\n        perform move-tile\n        perform show-table\n        move spaces to display-move\n        accept display-move\n    end-perform\n    stop run\n    .\ninitialize-table.\n    compute tile-number = random(seconds-past-midnight) \n    move spaces to tile-flags\n    move 0 to current-tile inversions\n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        perform with test after\n        until tile-flags(tile-number + 1:1) = space\n            compute tile-number = random() * 100\n            compute tile-number = mod(tile-number, 16)\n        end-perform\n        move 'x' to tile-flags(tile-number + 1:1)\n        if tile-number > 0 and < current-tile\n            add 1 to inversions\n        end-if\n        move tile-number to display-cell(r,c) current-tile\n    end-perform\n    compute inversions = mod(inversions,2)\n    .\nshow-table.\n    if display-table = winning-display\n        display 'winning'\n    end-if\n    display space row-separator\n    perform varying r from 1 by 1 until r > 4\n        perform varying c from 1 by 1 until c > 4\n            display column-separator with no advancing\n            if display-cell(r,c) = 00\n                display '  ' with no advancing\n                move r to r-empty\n                move c to c-empty\n            else\n                display display-cell(r,c) with no advancing\n            end-if\n        end-perform\n        display column-separator\n    end-perform\n    display space row-separator\n    .\nmove-tile.\n    if not (tile-id numeric and tile-id >= 01 and <= 15)\n        display 'invalid tile number'\n        exit paragraph\n    end-if\n\n    \n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        if display-cell(r,c) = tile-id\n            exit perform\n        end-if\n    end-perform\n\n    \n    evaluate true\n    when r = r-empty\n        if c-empty < c\n            \n            perform varying c-to from c-empty by 1 until c-to > c\n                compute c-from = c-to + 1\n                move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n            end-perform\n        else\n           \n           perform varying c-to from c-empty by -1 until c-to < c\n               compute c-from = c-to - 1\n               move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n           end-perform\n       end-if\n       move 00 to display-cell(r,c)\n    when c = c-empty\n        if r-empty < r\n            \n            perform varying r-to from r-empty by 1 until r-to > r\n                compute r-from = r-to + 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        else\n            \n            perform varying r-to from r-empty by -1 until r-to < r\n                compute r-from = r-to - 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        end-if\n        move 00 to display-cell(r,c)\n    when other\n         display 'invalid move'\n    end-evaluate\n    .\nend program fifteen.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Windows.Forms;\n\npublic class FifteenPuzzle\n{\n    const int GridSize = 4; \n    const int BlockCount = 16;\n\n    static readonly Random R = new Random();\n\n    private List<Button> Puzzles = new List<Button>();\n    private int Moves = 0;\n    private DateTime Start;\n\n    public class Puzzle\n    {\n        private int mOrderedNumer;\n\n        public int CurrentNumber;\n\n        public int X;\n        public int Y;\n\n        public int InvX\n        {\n            get { return (GridSize - 1) - X; }\n        }\n        public int InvY\n        {\n            get { return (GridSize - 1) - Y; }\n        }\n\n        public Puzzle(int OrderedNumer)\n        {\n            mOrderedNumer = OrderedNumer;\n\n            CurrentNumber = OrderedNumer;\n\n            X = OrderedNumer % GridSize;\n            Y = OrderedNumer / GridSize;\n        }\n        public Puzzle(int OrderedNumer, int CurrentNumber)\n            : this(OrderedNumer)\n        {\n            this.CurrentNumber = CurrentNumber;\n        }\n\n        public bool IsEmptyPuzzle\n        {\n            get { return CurrentNumber >= (BlockCount - 1); }\n        }\n        public bool IsTruePlace\n        {\n            get { return (CurrentNumber == mOrderedNumer); }\n        }\n        public bool NearestWith(Puzzle OtherPz)\n        {\n            int dx = (X - OtherPz.X);\n            int dy = (Y - OtherPz.Y);\n\n            if ((dx == 0) && (dy <= 1) && (dy >= -1)) return true;\n            if ((dy == 0) && (dx <= 1) && (dx >= -1)) return true;\n\n            return false;\n        }\n\n        public override string ToString()\n        {\n            return (CurrentNumber + 1).ToString();\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        FifteenPuzzle Game = new FifteenPuzzle();\n        Application.Run(Game.CreateForm());\n    }\n\n    private Form CreateForm()\n    {\n        int ButtonSize = 50;\n        int ButtonMargin = 3;\n        int FormEdge = 9;\n\n        Font ButtonFont = new Font(\"Arial\", 15.75F, FontStyle.Regular);\n\n        Button StartButton = new Button();\n        StartButton.Location = new Point(FormEdge, (GridSize * (ButtonMargin + ButtonSize)) + FormEdge);\n        StartButton.Size = new Size(86, 23);\n        StartButton.Font = new Font(\"Arial\", 9.75F, FontStyle.Regular);\n        StartButton.Text = \"New Game\";\n        StartButton.UseVisualStyleBackColor = true;\n        StartButton.TabStop = false;\n\n        StartButton.Click += new EventHandler(NewGame);\n\n        int FormWidth = (GridSize * ButtonSize) + ((GridSize - 1) * ButtonMargin) + (FormEdge * 2);\n        int FormHeigth = FormWidth + StartButton.Height;\n\n        Form Form = new Form();\n        Form.Text = \"Fifteen\";\n        Form.ClientSize = new Size(FormWidth, FormHeigth);\n        Form.FormBorderStyle = FormBorderStyle.FixedSingle;\n        Form.MaximizeBox = false;\n        Form.SuspendLayout();\n\n        for (int i = 0; i < BlockCount; i++)\n        {\n            Button Bt = new Button();\n            Puzzle Pz = new Puzzle(i);\n\n            int PosX = FormEdge + (Pz.X) * (ButtonSize + ButtonMargin);\n            int PosY = FormEdge + (Pz.Y) * (ButtonSize + ButtonMargin);\n            Bt.Location = new Point(PosX, PosY);\n\n            Bt.Size = new Size(ButtonSize, ButtonSize);\n            Bt.Font = ButtonFont;\n\n            Bt.Text = Pz.ToString();\n            Bt.Tag = Pz;\n            Bt.UseVisualStyleBackColor = true;\n            Bt.TabStop = false;\n\n            Bt.Enabled = false;\n            if (Pz.IsEmptyPuzzle) Bt.Visible = false;\n\n            Bt.Click += new EventHandler(MovePuzzle);\n\n            Puzzles.Add(Bt);\n            Form.Controls.Add(Bt);\n        }\n\n        Form.Controls.Add(StartButton);\n        Form.ResumeLayout();\n\n        return Form;\n    }\n\n    private void NewGame(object Sender, EventArgs E)\n    {\n        do\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Button Bt1 = Puzzles[R.Next(i, Puzzles.Count)];\n                Button Bt2 = Puzzles[i];\n                Swap(Bt1, Bt2);\n            }\n        }\n        while (!IsSolvable());\n\n        for (int i = 0; i < Puzzles.Count; i++)\n        {\n            Puzzles[i].Enabled = true;\n        }\n\n        Moves = 0;\n        Start = DateTime.Now;\n    }\n\n    private void MovePuzzle(object Sender, EventArgs E)\n    {\n        Button Bt1 = (Button)Sender;\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n\n        Button Bt2 = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        if (Pz1.NearestWith(Pz2))\n        {\n            Swap(Bt1, Bt2);\n            Moves++;\n        }\n\n        CheckWin();\n    }\n\n    private void CheckWin()\n    {\n        Button WrongPuzzle = Puzzles.Find(Bt => !((Puzzle)Bt.Tag).IsTruePlace);\n        bool UWin = (WrongPuzzle == null);\n\n        if (UWin)\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Puzzles[i].Enabled = false;\n            }\n\n            TimeSpan Elapsed = DateTime.Now - Start;\n            Elapsed = TimeSpan.FromSeconds(Math.Round(Elapsed.TotalSeconds, 0));\n            MessageBox.Show(String.Format(\"Solved in {0} moves. Time: {1}\", Moves, Elapsed));\n        }\n    }\n\n    private void Swap(Button Bt1, Button Bt2)\n    {\n        if (Bt1 == Bt2) return;\n\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        int g = Pz1.CurrentNumber;\n        Pz1.CurrentNumber = Pz2.CurrentNumber;\n        Pz2.CurrentNumber = g;\n\n        Bt1.Visible = true;\n        Bt1.Text = Pz1.ToString();\n        if (Pz1.IsEmptyPuzzle) Bt1.Visible = false;\n\n        Bt2.Visible = true;\n        Bt2.Text = Pz2.ToString();\n        if (Pz2.IsEmptyPuzzle) Bt2.Visible = false;\n    }\n\n    private bool IsSolvable()\n    {\n        \n        \n\n        int InvCount = 0;\n        for (int i = 0; i < Puzzles.Count - 1; i++)\n        {\n            for (int j = i + 1; j < Puzzles.Count; j++)\n            {\n                Puzzle Pz1 = (Puzzle)Puzzles[i].Tag;\n                if (Pz1.IsEmptyPuzzle) continue;\n\n                Puzzle Pz2 = (Puzzle)Puzzles[j].Tag;\n                if (Pz2.IsEmptyPuzzle) continue;\n\n                if (Pz1.CurrentNumber > Pz2.CurrentNumber) InvCount++;\n            }\n        }\n\n        Button EmptyBt = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle EmptyPz = (Puzzle)EmptyBt.Tag;\n\n        bool Result = false;\n        if ((EmptyPz.InvY + 1) % 2 == 0) \n        {\n            \n            if (InvCount % 2 != 0) Result = true;\n        }\n        else \n        {\n            \n            if (InvCount % 2 == 0) Result = true;\n        }\n        return Result;\n    }\n}\n"}
{"id": 67022, "name": "15 puzzle game", "source": "Translate COBOL to C#:          >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. fifteen.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n\n01  r pic 9.\n01  r-empty pic 9.\n01  r-to pic 9.\n01  r-from pic 9.\n\n01  c pic 9.\n01  c-empty pic 9.\n01  c-to pic 9.\n01  c-from pic 9.\n\n01  display-table.\n    03  display-row occurs 4.\n        05  display-cell occurs 4 pic 99.\n\n01  tile-number pic 99.\n01  tile-flags pic x(16).\n\n01  display-move value spaces.\n    03  tile-id pic 99.\n\n01  row-separator pic x(21) value all '.'.\n01  column-separator pic x(3) value ' . '.\n\n01  inversions pic 99.\n01  current-tile pic 99.\n\n01  winning-display pic x(32) value\n        '01020304'\n    &   '05060708'\n    &   '09101112'\n    &   '13141500'.\n\nprocedure division.\nstart-fifteen.\n    display 'start fifteen puzzle'\n    display '    enter a two-digit tile number and press <enter> to move'\n    display '    press <enter> only to exit'\n\n    \n    perform initialize-table with test after until inversions = 0\n    perform show-table\n    accept display-move\n    perform until display-move = spaces\n        perform move-tile\n        perform show-table\n        move spaces to display-move\n        accept display-move\n    end-perform\n    stop run\n    .\ninitialize-table.\n    compute tile-number = random(seconds-past-midnight) \n    move spaces to tile-flags\n    move 0 to current-tile inversions\n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        perform with test after\n        until tile-flags(tile-number + 1:1) = space\n            compute tile-number = random() * 100\n            compute tile-number = mod(tile-number, 16)\n        end-perform\n        move 'x' to tile-flags(tile-number + 1:1)\n        if tile-number > 0 and < current-tile\n            add 1 to inversions\n        end-if\n        move tile-number to display-cell(r,c) current-tile\n    end-perform\n    compute inversions = mod(inversions,2)\n    .\nshow-table.\n    if display-table = winning-display\n        display 'winning'\n    end-if\n    display space row-separator\n    perform varying r from 1 by 1 until r > 4\n        perform varying c from 1 by 1 until c > 4\n            display column-separator with no advancing\n            if display-cell(r,c) = 00\n                display '  ' with no advancing\n                move r to r-empty\n                move c to c-empty\n            else\n                display display-cell(r,c) with no advancing\n            end-if\n        end-perform\n        display column-separator\n    end-perform\n    display space row-separator\n    .\nmove-tile.\n    if not (tile-id numeric and tile-id >= 01 and <= 15)\n        display 'invalid tile number'\n        exit paragraph\n    end-if\n\n    \n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        if display-cell(r,c) = tile-id\n            exit perform\n        end-if\n    end-perform\n\n    \n    evaluate true\n    when r = r-empty\n        if c-empty < c\n            \n            perform varying c-to from c-empty by 1 until c-to > c\n                compute c-from = c-to + 1\n                move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n            end-perform\n        else\n           \n           perform varying c-to from c-empty by -1 until c-to < c\n               compute c-from = c-to - 1\n               move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n           end-perform\n       end-if\n       move 00 to display-cell(r,c)\n    when c = c-empty\n        if r-empty < r\n            \n            perform varying r-to from r-empty by 1 until r-to > r\n                compute r-from = r-to + 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        else\n            \n            perform varying r-to from r-empty by -1 until r-to < r\n                compute r-from = r-to - 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        end-if\n        move 00 to display-cell(r,c)\n    when other\n         display 'invalid move'\n    end-evaluate\n    .\nend program fifteen.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Windows.Forms;\n\npublic class FifteenPuzzle\n{\n    const int GridSize = 4; \n    const int BlockCount = 16;\n\n    static readonly Random R = new Random();\n\n    private List<Button> Puzzles = new List<Button>();\n    private int Moves = 0;\n    private DateTime Start;\n\n    public class Puzzle\n    {\n        private int mOrderedNumer;\n\n        public int CurrentNumber;\n\n        public int X;\n        public int Y;\n\n        public int InvX\n        {\n            get { return (GridSize - 1) - X; }\n        }\n        public int InvY\n        {\n            get { return (GridSize - 1) - Y; }\n        }\n\n        public Puzzle(int OrderedNumer)\n        {\n            mOrderedNumer = OrderedNumer;\n\n            CurrentNumber = OrderedNumer;\n\n            X = OrderedNumer % GridSize;\n            Y = OrderedNumer / GridSize;\n        }\n        public Puzzle(int OrderedNumer, int CurrentNumber)\n            : this(OrderedNumer)\n        {\n            this.CurrentNumber = CurrentNumber;\n        }\n\n        public bool IsEmptyPuzzle\n        {\n            get { return CurrentNumber >= (BlockCount - 1); }\n        }\n        public bool IsTruePlace\n        {\n            get { return (CurrentNumber == mOrderedNumer); }\n        }\n        public bool NearestWith(Puzzle OtherPz)\n        {\n            int dx = (X - OtherPz.X);\n            int dy = (Y - OtherPz.Y);\n\n            if ((dx == 0) && (dy <= 1) && (dy >= -1)) return true;\n            if ((dy == 0) && (dx <= 1) && (dx >= -1)) return true;\n\n            return false;\n        }\n\n        public override string ToString()\n        {\n            return (CurrentNumber + 1).ToString();\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        FifteenPuzzle Game = new FifteenPuzzle();\n        Application.Run(Game.CreateForm());\n    }\n\n    private Form CreateForm()\n    {\n        int ButtonSize = 50;\n        int ButtonMargin = 3;\n        int FormEdge = 9;\n\n        Font ButtonFont = new Font(\"Arial\", 15.75F, FontStyle.Regular);\n\n        Button StartButton = new Button();\n        StartButton.Location = new Point(FormEdge, (GridSize * (ButtonMargin + ButtonSize)) + FormEdge);\n        StartButton.Size = new Size(86, 23);\n        StartButton.Font = new Font(\"Arial\", 9.75F, FontStyle.Regular);\n        StartButton.Text = \"New Game\";\n        StartButton.UseVisualStyleBackColor = true;\n        StartButton.TabStop = false;\n\n        StartButton.Click += new EventHandler(NewGame);\n\n        int FormWidth = (GridSize * ButtonSize) + ((GridSize - 1) * ButtonMargin) + (FormEdge * 2);\n        int FormHeigth = FormWidth + StartButton.Height;\n\n        Form Form = new Form();\n        Form.Text = \"Fifteen\";\n        Form.ClientSize = new Size(FormWidth, FormHeigth);\n        Form.FormBorderStyle = FormBorderStyle.FixedSingle;\n        Form.MaximizeBox = false;\n        Form.SuspendLayout();\n\n        for (int i = 0; i < BlockCount; i++)\n        {\n            Button Bt = new Button();\n            Puzzle Pz = new Puzzle(i);\n\n            int PosX = FormEdge + (Pz.X) * (ButtonSize + ButtonMargin);\n            int PosY = FormEdge + (Pz.Y) * (ButtonSize + ButtonMargin);\n            Bt.Location = new Point(PosX, PosY);\n\n            Bt.Size = new Size(ButtonSize, ButtonSize);\n            Bt.Font = ButtonFont;\n\n            Bt.Text = Pz.ToString();\n            Bt.Tag = Pz;\n            Bt.UseVisualStyleBackColor = true;\n            Bt.TabStop = false;\n\n            Bt.Enabled = false;\n            if (Pz.IsEmptyPuzzle) Bt.Visible = false;\n\n            Bt.Click += new EventHandler(MovePuzzle);\n\n            Puzzles.Add(Bt);\n            Form.Controls.Add(Bt);\n        }\n\n        Form.Controls.Add(StartButton);\n        Form.ResumeLayout();\n\n        return Form;\n    }\n\n    private void NewGame(object Sender, EventArgs E)\n    {\n        do\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Button Bt1 = Puzzles[R.Next(i, Puzzles.Count)];\n                Button Bt2 = Puzzles[i];\n                Swap(Bt1, Bt2);\n            }\n        }\n        while (!IsSolvable());\n\n        for (int i = 0; i < Puzzles.Count; i++)\n        {\n            Puzzles[i].Enabled = true;\n        }\n\n        Moves = 0;\n        Start = DateTime.Now;\n    }\n\n    private void MovePuzzle(object Sender, EventArgs E)\n    {\n        Button Bt1 = (Button)Sender;\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n\n        Button Bt2 = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        if (Pz1.NearestWith(Pz2))\n        {\n            Swap(Bt1, Bt2);\n            Moves++;\n        }\n\n        CheckWin();\n    }\n\n    private void CheckWin()\n    {\n        Button WrongPuzzle = Puzzles.Find(Bt => !((Puzzle)Bt.Tag).IsTruePlace);\n        bool UWin = (WrongPuzzle == null);\n\n        if (UWin)\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Puzzles[i].Enabled = false;\n            }\n\n            TimeSpan Elapsed = DateTime.Now - Start;\n            Elapsed = TimeSpan.FromSeconds(Math.Round(Elapsed.TotalSeconds, 0));\n            MessageBox.Show(String.Format(\"Solved in {0} moves. Time: {1}\", Moves, Elapsed));\n        }\n    }\n\n    private void Swap(Button Bt1, Button Bt2)\n    {\n        if (Bt1 == Bt2) return;\n\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        int g = Pz1.CurrentNumber;\n        Pz1.CurrentNumber = Pz2.CurrentNumber;\n        Pz2.CurrentNumber = g;\n\n        Bt1.Visible = true;\n        Bt1.Text = Pz1.ToString();\n        if (Pz1.IsEmptyPuzzle) Bt1.Visible = false;\n\n        Bt2.Visible = true;\n        Bt2.Text = Pz2.ToString();\n        if (Pz2.IsEmptyPuzzle) Bt2.Visible = false;\n    }\n\n    private bool IsSolvable()\n    {\n        \n        \n\n        int InvCount = 0;\n        for (int i = 0; i < Puzzles.Count - 1; i++)\n        {\n            for (int j = i + 1; j < Puzzles.Count; j++)\n            {\n                Puzzle Pz1 = (Puzzle)Puzzles[i].Tag;\n                if (Pz1.IsEmptyPuzzle) continue;\n\n                Puzzle Pz2 = (Puzzle)Puzzles[j].Tag;\n                if (Pz2.IsEmptyPuzzle) continue;\n\n                if (Pz1.CurrentNumber > Pz2.CurrentNumber) InvCount++;\n            }\n        }\n\n        Button EmptyBt = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle EmptyPz = (Puzzle)EmptyBt.Tag;\n\n        bool Result = false;\n        if ((EmptyPz.InvY + 1) % 2 == 0) \n        {\n            \n            if (InvCount % 2 != 0) Result = true;\n        }\n        else \n        {\n            \n            if (InvCount % 2 == 0) Result = true;\n        }\n        return Result;\n    }\n}\n"}
{"id": 67025, "name": "15 puzzle game", "source": "Translate COBOL to Java:          >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. fifteen.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n\n01  r pic 9.\n01  r-empty pic 9.\n01  r-to pic 9.\n01  r-from pic 9.\n\n01  c pic 9.\n01  c-empty pic 9.\n01  c-to pic 9.\n01  c-from pic 9.\n\n01  display-table.\n    03  display-row occurs 4.\n        05  display-cell occurs 4 pic 99.\n\n01  tile-number pic 99.\n01  tile-flags pic x(16).\n\n01  display-move value spaces.\n    03  tile-id pic 99.\n\n01  row-separator pic x(21) value all '.'.\n01  column-separator pic x(3) value ' . '.\n\n01  inversions pic 99.\n01  current-tile pic 99.\n\n01  winning-display pic x(32) value\n        '01020304'\n    &   '05060708'\n    &   '09101112'\n    &   '13141500'.\n\nprocedure division.\nstart-fifteen.\n    display 'start fifteen puzzle'\n    display '    enter a two-digit tile number and press <enter> to move'\n    display '    press <enter> only to exit'\n\n    \n    perform initialize-table with test after until inversions = 0\n    perform show-table\n    accept display-move\n    perform until display-move = spaces\n        perform move-tile\n        perform show-table\n        move spaces to display-move\n        accept display-move\n    end-perform\n    stop run\n    .\ninitialize-table.\n    compute tile-number = random(seconds-past-midnight) \n    move spaces to tile-flags\n    move 0 to current-tile inversions\n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        perform with test after\n        until tile-flags(tile-number + 1:1) = space\n            compute tile-number = random() * 100\n            compute tile-number = mod(tile-number, 16)\n        end-perform\n        move 'x' to tile-flags(tile-number + 1:1)\n        if tile-number > 0 and < current-tile\n            add 1 to inversions\n        end-if\n        move tile-number to display-cell(r,c) current-tile\n    end-perform\n    compute inversions = mod(inversions,2)\n    .\nshow-table.\n    if display-table = winning-display\n        display 'winning'\n    end-if\n    display space row-separator\n    perform varying r from 1 by 1 until r > 4\n        perform varying c from 1 by 1 until c > 4\n            display column-separator with no advancing\n            if display-cell(r,c) = 00\n                display '  ' with no advancing\n                move r to r-empty\n                move c to c-empty\n            else\n                display display-cell(r,c) with no advancing\n            end-if\n        end-perform\n        display column-separator\n    end-perform\n    display space row-separator\n    .\nmove-tile.\n    if not (tile-id numeric and tile-id >= 01 and <= 15)\n        display 'invalid tile number'\n        exit paragraph\n    end-if\n\n    \n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        if display-cell(r,c) = tile-id\n            exit perform\n        end-if\n    end-perform\n\n    \n    evaluate true\n    when r = r-empty\n        if c-empty < c\n            \n            perform varying c-to from c-empty by 1 until c-to > c\n                compute c-from = c-to + 1\n                move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n            end-perform\n        else\n           \n           perform varying c-to from c-empty by -1 until c-to < c\n               compute c-from = c-to - 1\n               move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n           end-perform\n       end-if\n       move 00 to display-cell(r,c)\n    when c = c-empty\n        if r-empty < r\n            \n            perform varying r-to from r-empty by 1 until r-to > r\n                compute r-from = r-to + 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        else\n            \n            perform varying r-to from r-empty by -1 until r-to < r\n                compute r-from = r-to - 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        end-if\n        move 00 to display-cell(r,c)\n    when other\n         display 'invalid move'\n    end-evaluate\n    .\nend program fifteen.\n", "target": "package fifteenpuzzle;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.Random;\nimport javax.swing.*;\n\nclass FifteenPuzzle extends JPanel {\n\n    private final int side = 4;\n    private final int numTiles = side * side - 1;\n\n    private final Random rand = new Random();\n    private final int[] tiles = new int[numTiles + 1];\n    private final int tileSize;\n    private int blankPos;\n    private final int margin;\n    private final int gridSize;\n    private boolean gameOver;\n\n    private FifteenPuzzle() {\n        final int dim = 640;\n\n        margin = 80;\n        tileSize = (dim - 2 * margin) / side;\n        gridSize = tileSize * side;\n\n        setPreferredSize(new Dimension(dim, dim + margin));\n        setBackground(Color.WHITE);\n        setForeground(new Color(0x6495ED)); \n        setFont(new Font(\"SansSerif\", Font.BOLD, 60));\n\n        gameOver = true;\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (gameOver) {\n                    newGame();\n\n                } else {\n\n                    int ex = e.getX() - margin;\n                    int ey = e.getY() - margin;\n\n                    if (ex < 0 || ex > gridSize || ey < 0 || ey > gridSize) {\n                        return;\n                    }\n\n                    int c1 = ex / tileSize;\n                    int r1 = ey / tileSize;\n                    int c2 = blankPos % side;\n                    int r2 = blankPos / side;\n\n                    int clickPos = r1 * side + c1;\n\n                    int dir = 0;\n                    if (c1 == c2 && Math.abs(r1 - r2) > 0) {\n                        dir = (r1 - r2) > 0 ? 4 : -4;\n                        \n                    } else if (r1 == r2 && Math.abs(c1 - c2) > 0) {\n                        dir = (c1 - c2) > 0 ? 1 : -1;\n                    }\n\n                    if (dir != 0) {\n                        do {\n                            int newBlankPos = blankPos + dir;\n                            tiles[blankPos] = tiles[newBlankPos];\n                            blankPos = newBlankPos;\n                        } while (blankPos != clickPos);\n                        tiles[blankPos] = 0;\n                    }\n                    \n                    gameOver = isSolved();\n                }\n                repaint();\n            }\n        });\n\n        newGame();\n    }\n\n    private void newGame() {\n        do {\n            reset();\n            shuffle();\n        } while (!isSolvable());\n        gameOver = false;\n    }\n\n    private void reset() {\n        for (int i = 0; i < tiles.length; i++) {\n            tiles[i] = (i + 1) % tiles.length;\n        }\n        blankPos = tiles.length - 1;\n    }\n\n    private void shuffle() {\n        \n        \n        int n = numTiles;\n        while (n > 1) {\n            int r = rand.nextInt(n--);\n            int tmp = tiles[r];\n            tiles[r] = tiles[n];\n            tiles[n] = tmp;\n        }\n    }\n\n    \n    private boolean isSolvable() {\n        int countInversions = 0;\n        for (int i = 0; i < numTiles; i++) {\n            for (int j = 0; j < i; j++) {\n                if (tiles[j] > tiles[i]) {\n                    countInversions++;\n                }\n            }\n        }\n        return countInversions % 2 == 0;\n    }\n\n    private boolean isSolved() {\n        if (tiles[tiles.length - 1] != 0) {\n            return false;\n        }\n        for (int i = numTiles - 1; i >= 0; i--) {\n            if (tiles[i] != i + 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void drawGrid(Graphics2D g) {\n        for (int i = 0; i < tiles.length; i++) {\n            int r = i / side;\n            int c = i % side;\n            int x = margin + c * tileSize;\n            int y = margin + r * tileSize;\n\n            if (tiles[i] == 0) {\n                if (gameOver) {\n                    g.setColor(Color.GREEN);\n                    drawCenteredString(g, \"\\u2713\", x, y);\n                }\n                continue;\n            }\n\n            g.setColor(getForeground());\n            g.fillRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.blue.darker());\n            g.drawRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.WHITE);\n\n            drawCenteredString(g, String.valueOf(tiles[i]), x, y);\n        }\n    }\n\n    private void drawStartMessage(Graphics2D g) {\n        if (gameOver) {\n            g.setFont(getFont().deriveFont(Font.BOLD, 18));\n            g.setColor(getForeground());\n            String s = \"click to start a new game\";\n            int x = (getWidth() - g.getFontMetrics().stringWidth(s)) / 2;\n            int y = getHeight() - margin;\n            g.drawString(s, x, y);\n        }\n    }\n\n    private void drawCenteredString(Graphics2D g, String s, int x, int y) {\n        FontMetrics fm = g.getFontMetrics();\n        int asc = fm.getAscent();\n        int des = fm.getDescent();\n\n        x = x + (tileSize - fm.stringWidth(s)) / 2;\n        y = y + (asc + (tileSize - (asc + des)) / 2);\n\n        g.drawString(s, x, y);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n        drawStartMessage(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fifteen Puzzle\");\n            f.setResizable(false);\n            f.add(new FifteenPuzzle(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 67026, "name": "15 puzzle game", "source": "Translate COBOL to Java:          >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. fifteen.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n\n01  r pic 9.\n01  r-empty pic 9.\n01  r-to pic 9.\n01  r-from pic 9.\n\n01  c pic 9.\n01  c-empty pic 9.\n01  c-to pic 9.\n01  c-from pic 9.\n\n01  display-table.\n    03  display-row occurs 4.\n        05  display-cell occurs 4 pic 99.\n\n01  tile-number pic 99.\n01  tile-flags pic x(16).\n\n01  display-move value spaces.\n    03  tile-id pic 99.\n\n01  row-separator pic x(21) value all '.'.\n01  column-separator pic x(3) value ' . '.\n\n01  inversions pic 99.\n01  current-tile pic 99.\n\n01  winning-display pic x(32) value\n        '01020304'\n    &   '05060708'\n    &   '09101112'\n    &   '13141500'.\n\nprocedure division.\nstart-fifteen.\n    display 'start fifteen puzzle'\n    display '    enter a two-digit tile number and press <enter> to move'\n    display '    press <enter> only to exit'\n\n    \n    perform initialize-table with test after until inversions = 0\n    perform show-table\n    accept display-move\n    perform until display-move = spaces\n        perform move-tile\n        perform show-table\n        move spaces to display-move\n        accept display-move\n    end-perform\n    stop run\n    .\ninitialize-table.\n    compute tile-number = random(seconds-past-midnight) \n    move spaces to tile-flags\n    move 0 to current-tile inversions\n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        perform with test after\n        until tile-flags(tile-number + 1:1) = space\n            compute tile-number = random() * 100\n            compute tile-number = mod(tile-number, 16)\n        end-perform\n        move 'x' to tile-flags(tile-number + 1:1)\n        if tile-number > 0 and < current-tile\n            add 1 to inversions\n        end-if\n        move tile-number to display-cell(r,c) current-tile\n    end-perform\n    compute inversions = mod(inversions,2)\n    .\nshow-table.\n    if display-table = winning-display\n        display 'winning'\n    end-if\n    display space row-separator\n    perform varying r from 1 by 1 until r > 4\n        perform varying c from 1 by 1 until c > 4\n            display column-separator with no advancing\n            if display-cell(r,c) = 00\n                display '  ' with no advancing\n                move r to r-empty\n                move c to c-empty\n            else\n                display display-cell(r,c) with no advancing\n            end-if\n        end-perform\n        display column-separator\n    end-perform\n    display space row-separator\n    .\nmove-tile.\n    if not (tile-id numeric and tile-id >= 01 and <= 15)\n        display 'invalid tile number'\n        exit paragraph\n    end-if\n\n    \n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        if display-cell(r,c) = tile-id\n            exit perform\n        end-if\n    end-perform\n\n    \n    evaluate true\n    when r = r-empty\n        if c-empty < c\n            \n            perform varying c-to from c-empty by 1 until c-to > c\n                compute c-from = c-to + 1\n                move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n            end-perform\n        else\n           \n           perform varying c-to from c-empty by -1 until c-to < c\n               compute c-from = c-to - 1\n               move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n           end-perform\n       end-if\n       move 00 to display-cell(r,c)\n    when c = c-empty\n        if r-empty < r\n            \n            perform varying r-to from r-empty by 1 until r-to > r\n                compute r-from = r-to + 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        else\n            \n            perform varying r-to from r-empty by -1 until r-to < r\n                compute r-from = r-to - 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        end-if\n        move 00 to display-cell(r,c)\n    when other\n         display 'invalid move'\n    end-evaluate\n    .\nend program fifteen.\n", "target": "package fifteenpuzzle;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.Random;\nimport javax.swing.*;\n\nclass FifteenPuzzle extends JPanel {\n\n    private final int side = 4;\n    private final int numTiles = side * side - 1;\n\n    private final Random rand = new Random();\n    private final int[] tiles = new int[numTiles + 1];\n    private final int tileSize;\n    private int blankPos;\n    private final int margin;\n    private final int gridSize;\n    private boolean gameOver;\n\n    private FifteenPuzzle() {\n        final int dim = 640;\n\n        margin = 80;\n        tileSize = (dim - 2 * margin) / side;\n        gridSize = tileSize * side;\n\n        setPreferredSize(new Dimension(dim, dim + margin));\n        setBackground(Color.WHITE);\n        setForeground(new Color(0x6495ED)); \n        setFont(new Font(\"SansSerif\", Font.BOLD, 60));\n\n        gameOver = true;\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (gameOver) {\n                    newGame();\n\n                } else {\n\n                    int ex = e.getX() - margin;\n                    int ey = e.getY() - margin;\n\n                    if (ex < 0 || ex > gridSize || ey < 0 || ey > gridSize) {\n                        return;\n                    }\n\n                    int c1 = ex / tileSize;\n                    int r1 = ey / tileSize;\n                    int c2 = blankPos % side;\n                    int r2 = blankPos / side;\n\n                    int clickPos = r1 * side + c1;\n\n                    int dir = 0;\n                    if (c1 == c2 && Math.abs(r1 - r2) > 0) {\n                        dir = (r1 - r2) > 0 ? 4 : -4;\n                        \n                    } else if (r1 == r2 && Math.abs(c1 - c2) > 0) {\n                        dir = (c1 - c2) > 0 ? 1 : -1;\n                    }\n\n                    if (dir != 0) {\n                        do {\n                            int newBlankPos = blankPos + dir;\n                            tiles[blankPos] = tiles[newBlankPos];\n                            blankPos = newBlankPos;\n                        } while (blankPos != clickPos);\n                        tiles[blankPos] = 0;\n                    }\n                    \n                    gameOver = isSolved();\n                }\n                repaint();\n            }\n        });\n\n        newGame();\n    }\n\n    private void newGame() {\n        do {\n            reset();\n            shuffle();\n        } while (!isSolvable());\n        gameOver = false;\n    }\n\n    private void reset() {\n        for (int i = 0; i < tiles.length; i++) {\n            tiles[i] = (i + 1) % tiles.length;\n        }\n        blankPos = tiles.length - 1;\n    }\n\n    private void shuffle() {\n        \n        \n        int n = numTiles;\n        while (n > 1) {\n            int r = rand.nextInt(n--);\n            int tmp = tiles[r];\n            tiles[r] = tiles[n];\n            tiles[n] = tmp;\n        }\n    }\n\n    \n    private boolean isSolvable() {\n        int countInversions = 0;\n        for (int i = 0; i < numTiles; i++) {\n            for (int j = 0; j < i; j++) {\n                if (tiles[j] > tiles[i]) {\n                    countInversions++;\n                }\n            }\n        }\n        return countInversions % 2 == 0;\n    }\n\n    private boolean isSolved() {\n        if (tiles[tiles.length - 1] != 0) {\n            return false;\n        }\n        for (int i = numTiles - 1; i >= 0; i--) {\n            if (tiles[i] != i + 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void drawGrid(Graphics2D g) {\n        for (int i = 0; i < tiles.length; i++) {\n            int r = i / side;\n            int c = i % side;\n            int x = margin + c * tileSize;\n            int y = margin + r * tileSize;\n\n            if (tiles[i] == 0) {\n                if (gameOver) {\n                    g.setColor(Color.GREEN);\n                    drawCenteredString(g, \"\\u2713\", x, y);\n                }\n                continue;\n            }\n\n            g.setColor(getForeground());\n            g.fillRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.blue.darker());\n            g.drawRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.WHITE);\n\n            drawCenteredString(g, String.valueOf(tiles[i]), x, y);\n        }\n    }\n\n    private void drawStartMessage(Graphics2D g) {\n        if (gameOver) {\n            g.setFont(getFont().deriveFont(Font.BOLD, 18));\n            g.setColor(getForeground());\n            String s = \"click to start a new game\";\n            int x = (getWidth() - g.getFontMetrics().stringWidth(s)) / 2;\n            int y = getHeight() - margin;\n            g.drawString(s, x, y);\n        }\n    }\n\n    private void drawCenteredString(Graphics2D g, String s, int x, int y) {\n        FontMetrics fm = g.getFontMetrics();\n        int asc = fm.getAscent();\n        int des = fm.getDescent();\n\n        x = x + (tileSize - fm.stringWidth(s)) / 2;\n        y = y + (asc + (tileSize - (asc + des)) / 2);\n\n        g.drawString(s, x, y);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n        drawStartMessage(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fifteen Puzzle\");\n            f.setResizable(false);\n            f.add(new FifteenPuzzle(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 67027, "name": "15 puzzle game", "source": "Translate COBOL to Python:          >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. fifteen.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n\n01  r pic 9.\n01  r-empty pic 9.\n01  r-to pic 9.\n01  r-from pic 9.\n\n01  c pic 9.\n01  c-empty pic 9.\n01  c-to pic 9.\n01  c-from pic 9.\n\n01  display-table.\n    03  display-row occurs 4.\n        05  display-cell occurs 4 pic 99.\n\n01  tile-number pic 99.\n01  tile-flags pic x(16).\n\n01  display-move value spaces.\n    03  tile-id pic 99.\n\n01  row-separator pic x(21) value all '.'.\n01  column-separator pic x(3) value ' . '.\n\n01  inversions pic 99.\n01  current-tile pic 99.\n\n01  winning-display pic x(32) value\n        '01020304'\n    &   '05060708'\n    &   '09101112'\n    &   '13141500'.\n\nprocedure division.\nstart-fifteen.\n    display 'start fifteen puzzle'\n    display '    enter a two-digit tile number and press <enter> to move'\n    display '    press <enter> only to exit'\n\n    \n    perform initialize-table with test after until inversions = 0\n    perform show-table\n    accept display-move\n    perform until display-move = spaces\n        perform move-tile\n        perform show-table\n        move spaces to display-move\n        accept display-move\n    end-perform\n    stop run\n    .\ninitialize-table.\n    compute tile-number = random(seconds-past-midnight) \n    move spaces to tile-flags\n    move 0 to current-tile inversions\n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        perform with test after\n        until tile-flags(tile-number + 1:1) = space\n            compute tile-number = random() * 100\n            compute tile-number = mod(tile-number, 16)\n        end-perform\n        move 'x' to tile-flags(tile-number + 1:1)\n        if tile-number > 0 and < current-tile\n            add 1 to inversions\n        end-if\n        move tile-number to display-cell(r,c) current-tile\n    end-perform\n    compute inversions = mod(inversions,2)\n    .\nshow-table.\n    if display-table = winning-display\n        display 'winning'\n    end-if\n    display space row-separator\n    perform varying r from 1 by 1 until r > 4\n        perform varying c from 1 by 1 until c > 4\n            display column-separator with no advancing\n            if display-cell(r,c) = 00\n                display '  ' with no advancing\n                move r to r-empty\n                move c to c-empty\n            else\n                display display-cell(r,c) with no advancing\n            end-if\n        end-perform\n        display column-separator\n    end-perform\n    display space row-separator\n    .\nmove-tile.\n    if not (tile-id numeric and tile-id >= 01 and <= 15)\n        display 'invalid tile number'\n        exit paragraph\n    end-if\n\n    \n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        if display-cell(r,c) = tile-id\n            exit perform\n        end-if\n    end-perform\n\n    \n    evaluate true\n    when r = r-empty\n        if c-empty < c\n            \n            perform varying c-to from c-empty by 1 until c-to > c\n                compute c-from = c-to + 1\n                move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n            end-perform\n        else\n           \n           perform varying c-to from c-empty by -1 until c-to < c\n               compute c-from = c-to - 1\n               move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n           end-perform\n       end-if\n       move 00 to display-cell(r,c)\n    when c = c-empty\n        if r-empty < r\n            \n            perform varying r-to from r-empty by 1 until r-to > r\n                compute r-from = r-to + 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        else\n            \n            perform varying r-to from r-empty by -1 until r-to < r\n                compute r-from = r-to - 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        end-if\n        move 00 to display-cell(r,c)\n    when other\n         display 'invalid move'\n    end-evaluate\n    .\nend program fifteen.\n", "target": "type Puzzle(var items: {}, var position: -1)\n\nfun mainframe(puz):\n    let d = puz.items\n    print('+-----+-----+-----+-----+')\n    print(d[1], d[2], d[3], d[4], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[5], d[6], d[7], d[8], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[9], d[10], d[11], d[12], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[13], d[14], d[15], d[16], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n\nfun format(puz, ch):\n    match ch.trim().length:\n        1 => '  $ch  '\n        2 => '  $ch '\n        0 => '     '\n\nfun change(puz, to):\n    let fro = puz.position\n    for a, b in puz.items where b == puz.format(str i):\n        to = a\n        break\n\n    swap(puz.items[fro], :[to])\n    puz.position = to;\n\nfun buildboard(puz, difficulty):\n    for i in 1..16:\n        puz.items[i] = puz.format(str i)\n\n    var tmp = a\n    for a, b in puz.items where b == '  16 ':\n        puz.items[a] = '     '\n            tmp = a\n            break\n\n    puz.position = tmp\n    let diff = match difficulty:\n        0 => 10\n        1 => 50\n        _ => 100\n\n    for i in 1..diff:\n        let lst = puz.validmoves()\n        let lst1 = []\n        for j in lst:\n            lst1.push! j.trim().int()\n        puz.change(lst1[random(1, lst1.length - 1)])\n\nfun validmoves(puz):\n    match puz.position:\n        6 | 7 | 10 | 11 =>\n            puz.items[pos - 4], :[pos - 1], :[pos + 1], :[pos + 4]\n        5 | 9 =>\n            puz.items[pos - 4], :[pos + 4], :[pos + 1]\n        8 | 12 =>\n            puz.items[pos - 4], :[pos + 4], :[pos - 1]\n        2 | 3 =>\n            puz.items[pos - 1], :[pos + 1], :[pos + 4]\n        14 | 15 =>\n            puz.items[pos - 1], :[pos + 1], :[pos - 4]\n        1 =>\n            puz.items[pos + 1], :[pos + 4]\n        4 =>\n            puz.items[pos - 1], :[pos + 4]\n        13 =>\n            puz.items[pos + 1], :[pos - 4]\n        16 =>\n            puz.items[pos - 1], :[pos - 4]\n\nfun mainframe(puz):\n    var flag = false\n    for a, b in puz.items:\n        if b == '     ':\n            pass\n        else:\n            flag = (a == b.trim().int())\n    ..\n    return flag\n\nlet game = Puzzle()\ngame.buildboard(\n    int(input('Enter the difficulty\u00a0: 0 1 2\\n2 => highest 0=> lowest\\n'))\n)\ngame.mainframe()\n\nprint 'Enter 0 to exit'\n\nloop:\n    print 'Hello user:\\nTo change the position just enter the no. near it'\n\n    var lst = game.validmoves()\n    var lst1 = []\n    for i in lst:\n        lst1.push! i.trim().int()\n        print(i.strip(), '\\t', last: '')\n\n    print()\n\n    let value = int(input())\n    if value == 0:\n        break\n    elif x not in lst1:\n        print('Wrong move')\n    else:\n        game.change(x)\n\n    game.mainframe()\n    if g.gameover():\n        print 'You WON'\n        break\n"}
{"id": 67028, "name": "15 puzzle game", "source": "Translate COBOL to Python:          >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. fifteen.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n\n01  r pic 9.\n01  r-empty pic 9.\n01  r-to pic 9.\n01  r-from pic 9.\n\n01  c pic 9.\n01  c-empty pic 9.\n01  c-to pic 9.\n01  c-from pic 9.\n\n01  display-table.\n    03  display-row occurs 4.\n        05  display-cell occurs 4 pic 99.\n\n01  tile-number pic 99.\n01  tile-flags pic x(16).\n\n01  display-move value spaces.\n    03  tile-id pic 99.\n\n01  row-separator pic x(21) value all '.'.\n01  column-separator pic x(3) value ' . '.\n\n01  inversions pic 99.\n01  current-tile pic 99.\n\n01  winning-display pic x(32) value\n        '01020304'\n    &   '05060708'\n    &   '09101112'\n    &   '13141500'.\n\nprocedure division.\nstart-fifteen.\n    display 'start fifteen puzzle'\n    display '    enter a two-digit tile number and press <enter> to move'\n    display '    press <enter> only to exit'\n\n    \n    perform initialize-table with test after until inversions = 0\n    perform show-table\n    accept display-move\n    perform until display-move = spaces\n        perform move-tile\n        perform show-table\n        move spaces to display-move\n        accept display-move\n    end-perform\n    stop run\n    .\ninitialize-table.\n    compute tile-number = random(seconds-past-midnight) \n    move spaces to tile-flags\n    move 0 to current-tile inversions\n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        perform with test after\n        until tile-flags(tile-number + 1:1) = space\n            compute tile-number = random() * 100\n            compute tile-number = mod(tile-number, 16)\n        end-perform\n        move 'x' to tile-flags(tile-number + 1:1)\n        if tile-number > 0 and < current-tile\n            add 1 to inversions\n        end-if\n        move tile-number to display-cell(r,c) current-tile\n    end-perform\n    compute inversions = mod(inversions,2)\n    .\nshow-table.\n    if display-table = winning-display\n        display 'winning'\n    end-if\n    display space row-separator\n    perform varying r from 1 by 1 until r > 4\n        perform varying c from 1 by 1 until c > 4\n            display column-separator with no advancing\n            if display-cell(r,c) = 00\n                display '  ' with no advancing\n                move r to r-empty\n                move c to c-empty\n            else\n                display display-cell(r,c) with no advancing\n            end-if\n        end-perform\n        display column-separator\n    end-perform\n    display space row-separator\n    .\nmove-tile.\n    if not (tile-id numeric and tile-id >= 01 and <= 15)\n        display 'invalid tile number'\n        exit paragraph\n    end-if\n\n    \n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        if display-cell(r,c) = tile-id\n            exit perform\n        end-if\n    end-perform\n\n    \n    evaluate true\n    when r = r-empty\n        if c-empty < c\n            \n            perform varying c-to from c-empty by 1 until c-to > c\n                compute c-from = c-to + 1\n                move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n            end-perform\n        else\n           \n           perform varying c-to from c-empty by -1 until c-to < c\n               compute c-from = c-to - 1\n               move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n           end-perform\n       end-if\n       move 00 to display-cell(r,c)\n    when c = c-empty\n        if r-empty < r\n            \n            perform varying r-to from r-empty by 1 until r-to > r\n                compute r-from = r-to + 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        else\n            \n            perform varying r-to from r-empty by -1 until r-to < r\n                compute r-from = r-to - 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        end-if\n        move 00 to display-cell(r,c)\n    when other\n         display 'invalid move'\n    end-evaluate\n    .\nend program fifteen.\n", "target": "type Puzzle(var items: {}, var position: -1)\n\nfun mainframe(puz):\n    let d = puz.items\n    print('+-----+-----+-----+-----+')\n    print(d[1], d[2], d[3], d[4], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[5], d[6], d[7], d[8], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[9], d[10], d[11], d[12], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[13], d[14], d[15], d[16], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n\nfun format(puz, ch):\n    match ch.trim().length:\n        1 => '  $ch  '\n        2 => '  $ch '\n        0 => '     '\n\nfun change(puz, to):\n    let fro = puz.position\n    for a, b in puz.items where b == puz.format(str i):\n        to = a\n        break\n\n    swap(puz.items[fro], :[to])\n    puz.position = to;\n\nfun buildboard(puz, difficulty):\n    for i in 1..16:\n        puz.items[i] = puz.format(str i)\n\n    var tmp = a\n    for a, b in puz.items where b == '  16 ':\n        puz.items[a] = '     '\n            tmp = a\n            break\n\n    puz.position = tmp\n    let diff = match difficulty:\n        0 => 10\n        1 => 50\n        _ => 100\n\n    for i in 1..diff:\n        let lst = puz.validmoves()\n        let lst1 = []\n        for j in lst:\n            lst1.push! j.trim().int()\n        puz.change(lst1[random(1, lst1.length - 1)])\n\nfun validmoves(puz):\n    match puz.position:\n        6 | 7 | 10 | 11 =>\n            puz.items[pos - 4], :[pos - 1], :[pos + 1], :[pos + 4]\n        5 | 9 =>\n            puz.items[pos - 4], :[pos + 4], :[pos + 1]\n        8 | 12 =>\n            puz.items[pos - 4], :[pos + 4], :[pos - 1]\n        2 | 3 =>\n            puz.items[pos - 1], :[pos + 1], :[pos + 4]\n        14 | 15 =>\n            puz.items[pos - 1], :[pos + 1], :[pos - 4]\n        1 =>\n            puz.items[pos + 1], :[pos + 4]\n        4 =>\n            puz.items[pos - 1], :[pos + 4]\n        13 =>\n            puz.items[pos + 1], :[pos - 4]\n        16 =>\n            puz.items[pos - 1], :[pos - 4]\n\nfun mainframe(puz):\n    var flag = false\n    for a, b in puz.items:\n        if b == '     ':\n            pass\n        else:\n            flag = (a == b.trim().int())\n    ..\n    return flag\n\nlet game = Puzzle()\ngame.buildboard(\n    int(input('Enter the difficulty\u00a0: 0 1 2\\n2 => highest 0=> lowest\\n'))\n)\ngame.mainframe()\n\nprint 'Enter 0 to exit'\n\nloop:\n    print 'Hello user:\\nTo change the position just enter the no. near it'\n\n    var lst = game.validmoves()\n    var lst1 = []\n    for i in lst:\n        lst1.push! i.trim().int()\n        print(i.strip(), '\\t', last: '')\n\n    print()\n\n    let value = int(input())\n    if value == 0:\n        break\n    elif x not in lst1:\n        print('Wrong move')\n    else:\n        game.change(x)\n\n    game.mainframe()\n    if g.gameover():\n        print 'You WON'\n        break\n"}
{"id": 67756, "name": "Array length", "source": "Translate COBOL to C#:        identification division.\n       program-id. array-length.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 str-field pic x(7) occurs 0 to 5 depending on t1.\n\n       77 t1           pic 99.\n\n       procedure division.\n       array-length-main.\n       perform initialize-table\n       perform display-table-info\n       goback.\n\n       initialize-table.\n           move 1 to t1\n           move \"apples\" to str-field(t1)\n\n           add 1 to t1\n           move \"oranges\" to str-field(t1).\n\n      \n           add 1 to t1\n           move \"bananas\" to str-field(t1).\n           subtract 1 from t1\n       .\n\n       display-table-info.\n           display \"Elements: \" t1 \", using \" length(table-one) \" bytes\"\n           display table-one\n       .\n\n       end program array-length.\n", "target": "using System;\n\nnamespace ArrayLength\n{\n  class Program\n  {\n    public static void Main()\n    {\n      var array = new String[](\"apple\", \"orange\");\n      Console.WriteLine(array.Count);\n      delete(array);\n    }\n  }\n}\n"}
{"id": 67757, "name": "Array length", "source": "Translate COBOL to C#:        identification division.\n       program-id. array-length.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 str-field pic x(7) occurs 0 to 5 depending on t1.\n\n       77 t1           pic 99.\n\n       procedure division.\n       array-length-main.\n       perform initialize-table\n       perform display-table-info\n       goback.\n\n       initialize-table.\n           move 1 to t1\n           move \"apples\" to str-field(t1)\n\n           add 1 to t1\n           move \"oranges\" to str-field(t1).\n\n      \n           add 1 to t1\n           move \"bananas\" to str-field(t1).\n           subtract 1 from t1\n       .\n\n       display-table-info.\n           display \"Elements: \" t1 \", using \" length(table-one) \" bytes\"\n           display table-one\n       .\n\n       end program array-length.\n", "target": "using System;\n\nnamespace ArrayLength\n{\n  class Program\n  {\n    public static void Main()\n    {\n      var array = new String[](\"apple\", \"orange\");\n      Console.WriteLine(array.Count);\n      delete(array);\n    }\n  }\n}\n"}
{"id": 67760, "name": "Array length", "source": "Translate COBOL to Java:        identification division.\n       program-id. array-length.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 str-field pic x(7) occurs 0 to 5 depending on t1.\n\n       77 t1           pic 99.\n\n       procedure division.\n       array-length-main.\n       perform initialize-table\n       perform display-table-info\n       goback.\n\n       initialize-table.\n           move 1 to t1\n           move \"apples\" to str-field(t1)\n\n           add 1 to t1\n           move \"oranges\" to str-field(t1).\n\n      \n           add 1 to t1\n           move \"bananas\" to str-field(t1).\n           subtract 1 from t1\n       .\n\n       display-table-info.\n           display \"Elements: \" t1 \", using \" length(table-one) \" bytes\"\n           display table-one\n       .\n\n       end program array-length.\n", "target": "String[] array  = [\"apple\", \"orange\"];\nInt      length = array.size;\n"}
{"id": 67761, "name": "Array length", "source": "Translate COBOL to Java:        identification division.\n       program-id. array-length.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 str-field pic x(7) occurs 0 to 5 depending on t1.\n\n       77 t1           pic 99.\n\n       procedure division.\n       array-length-main.\n       perform initialize-table\n       perform display-table-info\n       goback.\n\n       initialize-table.\n           move 1 to t1\n           move \"apples\" to str-field(t1)\n\n           add 1 to t1\n           move \"oranges\" to str-field(t1).\n\n      \n           add 1 to t1\n           move \"bananas\" to str-field(t1).\n           subtract 1 from t1\n       .\n\n       display-table-info.\n           display \"Elements: \" t1 \", using \" length(table-one) \" bytes\"\n           display table-one\n       .\n\n       end program array-length.\n", "target": "String[] array  = [\"apple\", \"orange\"];\nInt      length = array.size;\n"}
{"id": 67762, "name": "Array length", "source": "Translate COBOL to Python:        identification division.\n       program-id. array-length.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 str-field pic x(7) occurs 0 to 5 depending on t1.\n\n       77 t1           pic 99.\n\n       procedure division.\n       array-length-main.\n       perform initialize-table\n       perform display-table-info\n       goback.\n\n       initialize-table.\n           move 1 to t1\n           move \"apples\" to str-field(t1)\n\n           add 1 to t1\n           move \"oranges\" to str-field(t1).\n\n      \n           add 1 to t1\n           move \"bananas\" to str-field(t1).\n           subtract 1 from t1\n       .\n\n       display-table-info.\n           display \"Elements: \" t1 \", using \" length(table-one) \" bytes\"\n           display table-one\n       .\n\n       end program array-length.\n", "target": "arr = ['apple', 'orange']  \n\ndef setup():\n    println(len(arr))\n"}
{"id": 67763, "name": "Array length", "source": "Translate COBOL to Python:        identification division.\n       program-id. array-length.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 str-field pic x(7) occurs 0 to 5 depending on t1.\n\n       77 t1           pic 99.\n\n       procedure division.\n       array-length-main.\n       perform initialize-table\n       perform display-table-info\n       goback.\n\n       initialize-table.\n           move 1 to t1\n           move \"apples\" to str-field(t1)\n\n           add 1 to t1\n           move \"oranges\" to str-field(t1).\n\n      \n           add 1 to t1\n           move \"bananas\" to str-field(t1).\n           subtract 1 from t1\n       .\n\n       display-table-info.\n           display \"Elements: \" t1 \", using \" length(table-one) \" bytes\"\n           display table-one\n       .\n\n       end program array-length.\n", "target": "arr = ['apple', 'orange']  \n\ndef setup():\n    println(len(arr))\n"}
{"id": 69328, "name": "Averages_Root mean square", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. QUADRATIC-MEAN-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  QUADRATIC-MEAN-VARS.\n    05 N               PIC 99        VALUE 0.\n    05 N-SQUARED       PIC 999.\n    05 RUNNING-TOTAL   PIC 999       VALUE 0.\n    05 MEAN-OF-SQUARES PIC 99V9(16).\n    05 QUADRATIC-MEAN  PIC 9V9(15).\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM MULTIPLICATION-PARAGRAPH 10 TIMES.\n    DIVIDE  RUNNING-TOTAL BY 10 GIVING MEAN-OF-SQUARES.\n    COMPUTE QUADRATIC-MEAN = FUNCTION SQRT(MEAN-OF-SQUARES).\n    DISPLAY QUADRATIC-MEAN UPON CONSOLE.\n    STOP RUN.\nMULTIPLICATION-PARAGRAPH.\n    ADD      1         TO N.\n    MULTIPLY N         BY N GIVING N-SQUARED.\n    ADD      N-SQUARED TO RUNNING-TOTAL.\n", "target": "using System;\n\nnamespace rms\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] x = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            Console.WriteLine(rootMeanSquare(x));\n        }\n\n        private static double rootMeanSquare(int[] x)\n        {            \n            double sum = 0;\n            for (int i = 0; i < x.Length; i++)\n            {\n                sum += (x[i]*x[i]);\n            }\n            return Math.Sqrt(sum / x.Length);\n        }\n    }\n}\n"}
{"id": 69329, "name": "Averages_Root mean square", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. QUADRATIC-MEAN-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  QUADRATIC-MEAN-VARS.\n    05 N               PIC 99        VALUE 0.\n    05 N-SQUARED       PIC 999.\n    05 RUNNING-TOTAL   PIC 999       VALUE 0.\n    05 MEAN-OF-SQUARES PIC 99V9(16).\n    05 QUADRATIC-MEAN  PIC 9V9(15).\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM MULTIPLICATION-PARAGRAPH 10 TIMES.\n    DIVIDE  RUNNING-TOTAL BY 10 GIVING MEAN-OF-SQUARES.\n    COMPUTE QUADRATIC-MEAN = FUNCTION SQRT(MEAN-OF-SQUARES).\n    DISPLAY QUADRATIC-MEAN UPON CONSOLE.\n    STOP RUN.\nMULTIPLICATION-PARAGRAPH.\n    ADD      1         TO N.\n    MULTIPLY N         BY N GIVING N-SQUARED.\n    ADD      N-SQUARED TO RUNNING-TOTAL.\n", "target": "using System;\n\nnamespace rms\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] x = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            Console.WriteLine(rootMeanSquare(x));\n        }\n\n        private static double rootMeanSquare(int[] x)\n        {            \n            double sum = 0;\n            for (int i = 0; i < x.Length; i++)\n            {\n                sum += (x[i]*x[i]);\n            }\n            return Math.Sqrt(sum / x.Length);\n        }\n    }\n}\n"}
{"id": 69332, "name": "Averages_Root mean square", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. QUADRATIC-MEAN-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  QUADRATIC-MEAN-VARS.\n    05 N               PIC 99        VALUE 0.\n    05 N-SQUARED       PIC 999.\n    05 RUNNING-TOTAL   PIC 999       VALUE 0.\n    05 MEAN-OF-SQUARES PIC 99V9(16).\n    05 QUADRATIC-MEAN  PIC 9V9(15).\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM MULTIPLICATION-PARAGRAPH 10 TIMES.\n    DIVIDE  RUNNING-TOTAL BY 10 GIVING MEAN-OF-SQUARES.\n    COMPUTE QUADRATIC-MEAN = FUNCTION SQRT(MEAN-OF-SQUARES).\n    DISPLAY QUADRATIC-MEAN UPON CONSOLE.\n    STOP RUN.\nMULTIPLICATION-PARAGRAPH.\n    ADD      1         TO N.\n    MULTIPLY N         BY N GIVING N-SQUARED.\n    ADD      N-SQUARED TO RUNNING-TOTAL.\n", "target": "public class RootMeanSquare {\n\n    public static double rootMeanSquare(double... nums) {\n        double sum = 0.0;\n        for (double num : nums)\n            sum += num * num;\n        return Math.sqrt(sum / nums.length);\n    }\n\n    public static void main(String[] args) {\n        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        System.out.println(\"The RMS of the numbers from 1 to 10 is \" + rootMeanSquare(nums));\n    }\n}\n"}
{"id": 69333, "name": "Averages_Root mean square", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. QUADRATIC-MEAN-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  QUADRATIC-MEAN-VARS.\n    05 N               PIC 99        VALUE 0.\n    05 N-SQUARED       PIC 999.\n    05 RUNNING-TOTAL   PIC 999       VALUE 0.\n    05 MEAN-OF-SQUARES PIC 99V9(16).\n    05 QUADRATIC-MEAN  PIC 9V9(15).\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM MULTIPLICATION-PARAGRAPH 10 TIMES.\n    DIVIDE  RUNNING-TOTAL BY 10 GIVING MEAN-OF-SQUARES.\n    COMPUTE QUADRATIC-MEAN = FUNCTION SQRT(MEAN-OF-SQUARES).\n    DISPLAY QUADRATIC-MEAN UPON CONSOLE.\n    STOP RUN.\nMULTIPLICATION-PARAGRAPH.\n    ADD      1         TO N.\n    MULTIPLY N         BY N GIVING N-SQUARED.\n    ADD      N-SQUARED TO RUNNING-TOTAL.\n", "target": "public class RootMeanSquare {\n\n    public static double rootMeanSquare(double... nums) {\n        double sum = 0.0;\n        for (double num : nums)\n            sum += num * num;\n        return Math.sqrt(sum / nums.length);\n    }\n\n    public static void main(String[] args) {\n        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        System.out.println(\"The RMS of the numbers from 1 to 10 is \" + rootMeanSquare(nums));\n    }\n}\n"}
{"id": 69334, "name": "Averages_Root mean square", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. QUADRATIC-MEAN-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  QUADRATIC-MEAN-VARS.\n    05 N               PIC 99        VALUE 0.\n    05 N-SQUARED       PIC 999.\n    05 RUNNING-TOTAL   PIC 999       VALUE 0.\n    05 MEAN-OF-SQUARES PIC 99V9(16).\n    05 QUADRATIC-MEAN  PIC 9V9(15).\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM MULTIPLICATION-PARAGRAPH 10 TIMES.\n    DIVIDE  RUNNING-TOTAL BY 10 GIVING MEAN-OF-SQUARES.\n    COMPUTE QUADRATIC-MEAN = FUNCTION SQRT(MEAN-OF-SQUARES).\n    DISPLAY QUADRATIC-MEAN UPON CONSOLE.\n    STOP RUN.\nMULTIPLICATION-PARAGRAPH.\n    ADD      1         TO N.\n    MULTIPLY N         BY N GIVING N-SQUARED.\n    ADD      N-SQUARED TO RUNNING-TOTAL.\n", "target": "sqrt(mean(x\u00b2))\n"}
{"id": 69335, "name": "Averages_Root mean square", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. QUADRATIC-MEAN-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  QUADRATIC-MEAN-VARS.\n    05 N               PIC 99        VALUE 0.\n    05 N-SQUARED       PIC 999.\n    05 RUNNING-TOTAL   PIC 999       VALUE 0.\n    05 MEAN-OF-SQUARES PIC 99V9(16).\n    05 QUADRATIC-MEAN  PIC 9V9(15).\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM MULTIPLICATION-PARAGRAPH 10 TIMES.\n    DIVIDE  RUNNING-TOTAL BY 10 GIVING MEAN-OF-SQUARES.\n    COMPUTE QUADRATIC-MEAN = FUNCTION SQRT(MEAN-OF-SQUARES).\n    DISPLAY QUADRATIC-MEAN UPON CONSOLE.\n    STOP RUN.\nMULTIPLICATION-PARAGRAPH.\n    ADD      1         TO N.\n    MULTIPLY N         BY N GIVING N-SQUARED.\n    ADD      N-SQUARED TO RUNNING-TOTAL.\n", "target": "sqrt(mean(x\u00b2))\n"}
{"id": 70075, "name": "Terminal control_Coloured text", "source": "Translate COBOL to C#: \n       IDENTIFICATION  DIVISION.\n       PROGRAM-ID. coloured-text.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  example-str VALUE \"COBOL\".\n\n       01  fore-colour PIC 9.\n       01  back-colour PIC 9.\n\n       01  line-num    PIC 99 VALUE 1.\n       01  col-num     PIC 99 VALUE 1.\n\n       01  pause       PIC X.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"With HIGHLIGHT:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour HIGHLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With LOWLIGHT: (has no effect on many terminals)\"\n               AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour LOWLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With BLINK:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour BLINK\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"Press enter to continue.\"\n               AT LINE line-num, COLUMN 1\n           ACCEPT pause AT LINE line-num, COLUMN 40\n\n           GOBACK\n           .\n", "target": "static void Main(string[] args)\n{\n    Console.ForegroundColor = ConsoleColor.Red;\n    Console.BackgroundColor = ConsoleColor.Yellow;\n    Console.WriteLine(\"Red on Yellow\");\n    Console.ForegroundColor = ConsoleColor.White;\n    Console.BackgroundColor = ConsoleColor.Black;\n    Console.WriteLine(\"White on black\");\n    Console.ResetColor();\n    Console.WriteLine(\"Back to normal\");\n    Console.ReadKey();\n}\n"}
{"id": 70076, "name": "Terminal control_Coloured text", "source": "Translate COBOL to C#: \n       IDENTIFICATION  DIVISION.\n       PROGRAM-ID. coloured-text.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  example-str VALUE \"COBOL\".\n\n       01  fore-colour PIC 9.\n       01  back-colour PIC 9.\n\n       01  line-num    PIC 99 VALUE 1.\n       01  col-num     PIC 99 VALUE 1.\n\n       01  pause       PIC X.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"With HIGHLIGHT:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour HIGHLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With LOWLIGHT: (has no effect on many terminals)\"\n               AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour LOWLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With BLINK:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour BLINK\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"Press enter to continue.\"\n               AT LINE line-num, COLUMN 1\n           ACCEPT pause AT LINE line-num, COLUMN 40\n\n           GOBACK\n           .\n", "target": "static void Main(string[] args)\n{\n    Console.ForegroundColor = ConsoleColor.Red;\n    Console.BackgroundColor = ConsoleColor.Yellow;\n    Console.WriteLine(\"Red on Yellow\");\n    Console.ForegroundColor = ConsoleColor.White;\n    Console.BackgroundColor = ConsoleColor.Black;\n    Console.WriteLine(\"White on black\");\n    Console.ResetColor();\n    Console.WriteLine(\"Back to normal\");\n    Console.ReadKey();\n}\n"}
{"id": 70077, "name": "Terminal control_Coloured text", "source": "Translate COBOL to Python: \n       IDENTIFICATION  DIVISION.\n       PROGRAM-ID. coloured-text.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  example-str VALUE \"COBOL\".\n\n       01  fore-colour PIC 9.\n       01  back-colour PIC 9.\n\n       01  line-num    PIC 99 VALUE 1.\n       01  col-num     PIC 99 VALUE 1.\n\n       01  pause       PIC X.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"With HIGHLIGHT:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour HIGHLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With LOWLIGHT: (has no effect on many terminals)\"\n               AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour LOWLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With BLINK:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour BLINK\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"Press enter to continue.\"\n               AT LINE line-num, COLUMN 1\n           ACCEPT pause AT LINE line-num, COLUMN 40\n\n           GOBACK\n           .\n", "target": "from colorama import init, Fore, Back, Style\ninit(autoreset=True)\n\nprint Fore.RED + \"FATAL ERROR! Cannot write to /boot/vmlinuz-3.2.0-33-generic\"\nprint Back.BLUE + Fore.YELLOW + \"What a cute console!\"\nprint \"This is an %simportant%s word\" % (Style.BRIGHT, Style.NORMAL)\nprint Fore.YELLOW  + \"Rosetta Code!\"\nprint Fore.CYAN    + \"Rosetta Code!\"\nprint Fore.GREEN   + \"Rosetta Code!\"\nprint Fore.MAGENTA + \"Rosetta Code!\"\nprint Back.YELLOW + Fore.BLUE + Style.BRIGHT + \" \" * 40 + \" == Good Bye!\"\n"}
{"id": 70078, "name": "Terminal control_Coloured text", "source": "Translate COBOL to Python: \n       IDENTIFICATION  DIVISION.\n       PROGRAM-ID. coloured-text.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  example-str VALUE \"COBOL\".\n\n       01  fore-colour PIC 9.\n       01  back-colour PIC 9.\n\n       01  line-num    PIC 99 VALUE 1.\n       01  col-num     PIC 99 VALUE 1.\n\n       01  pause       PIC X.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"With HIGHLIGHT:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour HIGHLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With LOWLIGHT: (has no effect on many terminals)\"\n               AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour LOWLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With BLINK:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour BLINK\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"Press enter to continue.\"\n               AT LINE line-num, COLUMN 1\n           ACCEPT pause AT LINE line-num, COLUMN 40\n\n           GOBACK\n           .\n", "target": "from colorama import init, Fore, Back, Style\ninit(autoreset=True)\n\nprint Fore.RED + \"FATAL ERROR! Cannot write to /boot/vmlinuz-3.2.0-33-generic\"\nprint Back.BLUE + Fore.YELLOW + \"What a cute console!\"\nprint \"This is an %simportant%s word\" % (Style.BRIGHT, Style.NORMAL)\nprint Fore.YELLOW  + \"Rosetta Code!\"\nprint Fore.CYAN    + \"Rosetta Code!\"\nprint Fore.GREEN   + \"Rosetta Code!\"\nprint Fore.MAGENTA + \"Rosetta Code!\"\nprint Back.YELLOW + Fore.BLUE + Style.BRIGHT + \" \" * 40 + \" == Good Bye!\"\n"}
{"id": 70312, "name": "Loops_Foreach", "source": "Translate COBOL to C#: 01  things occurs 3.\n...\nset content of things to (\"Apple\", \"Banana\", \"Coconut\")\nperform varying thing as string through things\n    display thing\nend-perform\n", "target": "string[] things = {\"Apple\", \"Banana\", \"Coconut\"};\n\nforeach (string thing in things)\n{\n    Console.WriteLine(thing);\n}\n"}
{"id": 70314, "name": "Loops_Foreach", "source": "Translate COBOL to Java: 01  things occurs 3.\n...\nset content of things to (\"Apple\", \"Banana\", \"Coconut\")\nperform varying thing as string through things\n    display thing\nend-perform\n", "target": "module LoopForEach\n    {\n    @Inject Console console;\n    void run()\n        {\n        val vals = [10, 20, 30, 40];\n        console.print(\"Array of values:\");\n        Loop: for (val val : vals)\n            {\n            console.print($\"  value #{Loop.count + 1}: {val}\");\n            }\n\n        Map<String, Int> pairs = [\"x\"=42, \"y\"=69];\n        console.print(\"\\nKeys and values:\");\n        for ((String key, Int val) : pairs)\n            {\n            console.print($\"  {key}={val}\");\n            }\n        console.print(\"\\nJust the keys:\");\n        Loop: for (String key : pairs)\n            {\n            console.print($\"  key #{Loop.count + 1}: {key}\");\n            }\n\n        console.print(\"\\nValues from a range:\");\n        for (Int n : 1..5)\n            {\n            console.print($\"  {n}\");\n            }\n        }\n    }\n"}
{"id": 70315, "name": "Loops_Foreach", "source": "Translate COBOL to Python: 01  things occurs 3.\n...\nset content of things to (\"Apple\", \"Banana\", \"Coconut\")\nperform varying thing as string through things\n    display thing\nend-perform\n", "target": "for i in collection:\n   print i\n"}
{"id": 72522, "name": "Five weekends", "source": "Translate COBOL to C#:        program-id. five-we.\n       data division.\n       working-storage section.\n       1 wk binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 friday pic 9(4) value 5.\n        2 mo-sub pic 9(4).\n        2 months-with-5 pic 9(4) value 0.\n        2 years-no-5 pic 9(4) value 0.\n        2 5-we-flag pic 9(4) value 0.\n         88 5-we-true value 1 when false 0.\n       1 31-day-mos pic 9(14) value 01030507081012.\n       1 31-day-table redefines 31-day-mos.\n        2 mo-no occurs 7 pic 99.\n       1 cal-date.\n        2 yr pic 9(4).\n        2 mo pic 9(2).\n        2 da pic 9(2) value 1.\n       procedure division.\n           perform varying yr from 1900 by 1\n           until yr > 2100\n               set 5-we-true to false\n               perform varying mo-sub from 1 by 1\n               until mo-sub > 7\n                   move mo-no (mo-sub) to mo\n                   compute int-date = function\n                       integer-of-date (function numval (cal-date))\n                   compute dow = function mod\n                       ((int-date - 1) 7) + 1\n                   if dow = friday\n                       perform output-date\n                       add 1 to months-with-5\n                       set 5-we-true to true\n                   end-if\n               end-perform\n               if not 5-we-true\n                   add 1 to years-no-5\n               end-if\n           end-perform\n           perform output-counts\n           stop run\n           .\n\n       output-counts.\n           display \"Months with 5 weekends: \" months-with-5\n           display \"Years without 5 weekends: \" years-no-5\n           .\n\n       output-date.\n           display yr \"-\" mo\n           .\n       end program five-we.\n", "target": "using System;\n\nnamespace _5_Weekends\n{\n    class Program\n    {\n        const int FIRST_YEAR = 1900;\n        const int LAST_YEAR = 2100;\n        static int[] _31_MONTHS = { 1, 3, 5, 7, 8, 10, 12 }; \n\n        static void Main(string[] args)\n        {\n            int totalNum = 0;\n            int totalNo5Weekends = 0;\n\n            for (int year = FIRST_YEAR; year <= LAST_YEAR; year++)\n            {\n                bool has5Weekends = false;\n\n                foreach (int month in _31_MONTHS)\n                {\n                    DateTime firstDay = new DateTime(year, month, 1);\n                    if (firstDay.DayOfWeek == DayOfWeek.Friday)\n                    {\n                        totalNum++;\n                        has5Weekends = true;\n                        Console.WriteLine(firstDay.ToString(\"yyyy - MMMM\"));\n                    }\n                }\n\n                if (!has5Weekends) totalNo5Weekends++;\n            }\n            Console.WriteLine(\"Total 5-weekend months between {0} and {1}: {2}\", FIRST_YEAR, LAST_YEAR, totalNum);\n            Console.WriteLine(\"Total number of years with no 5-weekend months {0}\", totalNo5Weekends);\n        }\n    }\n}\n"}
{"id": 72524, "name": "Five weekends", "source": "Translate COBOL to Java:        program-id. five-we.\n       data division.\n       working-storage section.\n       1 wk binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 friday pic 9(4) value 5.\n        2 mo-sub pic 9(4).\n        2 months-with-5 pic 9(4) value 0.\n        2 years-no-5 pic 9(4) value 0.\n        2 5-we-flag pic 9(4) value 0.\n         88 5-we-true value 1 when false 0.\n       1 31-day-mos pic 9(14) value 01030507081012.\n       1 31-day-table redefines 31-day-mos.\n        2 mo-no occurs 7 pic 99.\n       1 cal-date.\n        2 yr pic 9(4).\n        2 mo pic 9(2).\n        2 da pic 9(2) value 1.\n       procedure division.\n           perform varying yr from 1900 by 1\n           until yr > 2100\n               set 5-we-true to false\n               perform varying mo-sub from 1 by 1\n               until mo-sub > 7\n                   move mo-no (mo-sub) to mo\n                   compute int-date = function\n                       integer-of-date (function numval (cal-date))\n                   compute dow = function mod\n                       ((int-date - 1) 7) + 1\n                   if dow = friday\n                       perform output-date\n                       add 1 to months-with-5\n                       set 5-we-true to true\n                   end-if\n               end-perform\n               if not 5-we-true\n                   add 1 to years-no-5\n               end-if\n           end-perform\n           perform output-counts\n           stop run\n           .\n\n       output-counts.\n           display \"Months with 5 weekends: \" months-with-5\n           display \"Years without 5 weekends: \" years-no-5\n           .\n\n       output-date.\n           display yr \"-\" mo\n           .\n       end program five-we.\n", "target": "import java.util.Calendar;\nimport java.util.GregorianCalendar;\n\npublic class FiveFSS {\n    private static boolean[] years = new boolean[201];\n    private static int[] month31 = {Calendar.JANUARY, Calendar.MARCH, Calendar.MAY,\n        Calendar.JULY, Calendar.AUGUST, Calendar.OCTOBER, Calendar.DECEMBER};\n\n    public static void main(String[] args) {\n        StringBuilder months = new StringBuilder();\n        int numMonths = 0;\n        for (int year = 1900; year <= 2100; year++) {\n            for (int month : month31) {\n                Calendar date = new GregorianCalendar(year, month, 1);\n                if (date.get(Calendar.DAY_OF_WEEK) == Calendar.FRIDAY) {\n                    years[year - 1900] = true;\n                    numMonths++;\n                    \n                    months.append((date.get(Calendar.MONTH) + 1) + \"-\" + year +\"\\n\");\n                }\n            }\n        }\n        System.out.println(\"There are \"+numMonths+\" months with five weekends from 1900 through 2100:\");\n        System.out.println(months);\n        System.out.println(\"Years with no five-weekend months:\");\n        for (int year = 1900; year <= 2100; year++) {\n            if(!years[year - 1900]){\n                System.out.println(year);\n            }\n        }\n    }\n}\n"}
{"id": 72525, "name": "Five weekends", "source": "Translate COBOL to Python:        program-id. five-we.\n       data division.\n       working-storage section.\n       1 wk binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 friday pic 9(4) value 5.\n        2 mo-sub pic 9(4).\n        2 months-with-5 pic 9(4) value 0.\n        2 years-no-5 pic 9(4) value 0.\n        2 5-we-flag pic 9(4) value 0.\n         88 5-we-true value 1 when false 0.\n       1 31-day-mos pic 9(14) value 01030507081012.\n       1 31-day-table redefines 31-day-mos.\n        2 mo-no occurs 7 pic 99.\n       1 cal-date.\n        2 yr pic 9(4).\n        2 mo pic 9(2).\n        2 da pic 9(2) value 1.\n       procedure division.\n           perform varying yr from 1900 by 1\n           until yr > 2100\n               set 5-we-true to false\n               perform varying mo-sub from 1 by 1\n               until mo-sub > 7\n                   move mo-no (mo-sub) to mo\n                   compute int-date = function\n                       integer-of-date (function numval (cal-date))\n                   compute dow = function mod\n                       ((int-date - 1) 7) + 1\n                   if dow = friday\n                       perform output-date\n                       add 1 to months-with-5\n                       set 5-we-true to true\n                   end-if\n               end-perform\n               if not 5-we-true\n                   add 1 to years-no-5\n               end-if\n           end-perform\n           perform output-counts\n           stop run\n           .\n\n       output-counts.\n           display \"Months with 5 weekends: \" months-with-5\n           display \"Years without 5 weekends: \" years-no-5\n           .\n\n       output-date.\n           display yr \"-\" mo\n           .\n       end program five-we.\n", "target": "from datetime import (date,\n                      timedelta)\n\nDAY = timedelta(days=1)\nSTART, STOP = date(1900, 1, 1), date(2101, 1, 1)\nWEEKEND = {6, 5, 4}  \nFMT = '%Y %m(%B)'\n\n\ndef five_weekends_per_month(start: date = START,\n                            stop: date = STOP) -> list[date]:\n    \n    current_date = start\n    last_month = weekend_days = 0\n    five_weekends = []\n    while current_date < stop:\n        if current_date.month != last_month:\n            if weekend_days >= 15:\n                five_weekends.append(current_date - DAY)\n            weekend_days = 0\n            last_month = current_date.month\n        if current_date.weekday() in WEEKEND:\n            weekend_days += 1\n        current_date += DAY\n    return five_weekends\n\n\ndates = five_weekends_per_month()\nindent = '  '\nprint(f\"There are {len(dates)} months of which the first and last five are:\")\nprint(indent + ('\\n' + indent).join(d.strftime(FMT) for d in dates[:5]))\nprint(indent + '...')\nprint(indent + ('\\n' + indent).join(d.strftime(FMT) for d in dates[-5:]))\n\nyears_without_five_weekends_months = (STOP.year - START.year\n                                      - len({d.year for d in dates}))\nprint(f\"\\nThere are {years_without_five_weekends_months} years in the \"\n      f\"range that do not have months with five weekends\")\n"}
{"id": 74437, "name": "Array concatenation", "source": "Translate COBOL to C#:        identification division.\n       program-id. array-concat.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 int-field pic 999 occurs 0 to 5 depending on t1.\n       01 table-two.\n          05 int-field pic 9(4) occurs 0 to 10 depending on t2.\n\n       77 t1           pic 99.\n       77 t2           pic 99.\n\n       77 show         pic z(4).\n\n       procedure division.\n       array-concat-main.\n       perform initialize-tables\n       perform concatenate-tables\n       perform display-result\n       goback.\n\n       initialize-tables.\n           move 4 to t1\n           perform varying tally from 1 by 1 until tally > t1\n               compute int-field of table-one(tally) = tally * 3\n           end-perform\n\n           move 3 to t2\n           perform varying tally from 1 by 1 until tally > t2\n               compute int-field of table-two(tally) = tally * 6\n           end-perform\n       .\n\n       concatenate-tables.\n           perform varying tally from 1 by 1 until tally > t1\n               add 1 to t2\n               move int-field of table-one(tally)\n                 to int-field of table-two(t2)\n           end-perform\n       .\n\n       display-result.\n           perform varying tally from 1 by 1 until tally = t2\n               move int-field of table-two(tally) to show\n               display trim(show) \", \" with no advancing\n           end-perform\n           move int-field of table-two(tally) to show\n           display trim(show)\n       .\n\n       end program array-concat.\n", "target": "using System;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] a = { 1, 2, 3 };\n            int[] b = { 4, 5, 6 };\n\n            int[] c = new int[a.Length + b.Length];\n            a.CopyTo(c, 0);\n            b.CopyTo(c, a.Length);\n\n            foreach(int n in c)\n            {\n                Console.WriteLine(n.ToString());\n            }\n        }\n    }\n}\n"}
{"id": 74439, "name": "Array concatenation", "source": "Translate COBOL to Java:        identification division.\n       program-id. array-concat.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 int-field pic 999 occurs 0 to 5 depending on t1.\n       01 table-two.\n          05 int-field pic 9(4) occurs 0 to 10 depending on t2.\n\n       77 t1           pic 99.\n       77 t2           pic 99.\n\n       77 show         pic z(4).\n\n       procedure division.\n       array-concat-main.\n       perform initialize-tables\n       perform concatenate-tables\n       perform display-result\n       goback.\n\n       initialize-tables.\n           move 4 to t1\n           perform varying tally from 1 by 1 until tally > t1\n               compute int-field of table-one(tally) = tally * 3\n           end-perform\n\n           move 3 to t2\n           perform varying tally from 1 by 1 until tally > t2\n               compute int-field of table-two(tally) = tally * 6\n           end-perform\n       .\n\n       concatenate-tables.\n           perform varying tally from 1 by 1 until tally > t1\n               add 1 to t2\n               move int-field of table-one(tally)\n                 to int-field of table-two(t2)\n           end-perform\n       .\n\n       display-result.\n           perform varying tally from 1 by 1 until tally = t2\n               move int-field of table-two(tally) to show\n               display trim(show) \", \" with no advancing\n           end-perform\n           move int-field of table-two(tally) to show\n           display trim(show)\n       .\n\n       end program array-concat.\n", "target": "String[] fruits = [\"apples\", \"oranges\"];\nString[] grains = [\"wheat\", \"corn\"];\nString[] all    = fruits + grains;\n"}
{"id": 74440, "name": "Array concatenation", "source": "Translate COBOL to Python:        identification division.\n       program-id. array-concat.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 int-field pic 999 occurs 0 to 5 depending on t1.\n       01 table-two.\n          05 int-field pic 9(4) occurs 0 to 10 depending on t2.\n\n       77 t1           pic 99.\n       77 t2           pic 99.\n\n       77 show         pic z(4).\n\n       procedure division.\n       array-concat-main.\n       perform initialize-tables\n       perform concatenate-tables\n       perform display-result\n       goback.\n\n       initialize-tables.\n           move 4 to t1\n           perform varying tally from 1 by 1 until tally > t1\n               compute int-field of table-one(tally) = tally * 3\n           end-perform\n\n           move 3 to t2\n           perform varying tally from 1 by 1 until tally > t2\n               compute int-field of table-two(tally) = tally * 6\n           end-perform\n       .\n\n       concatenate-tables.\n           perform varying tally from 1 by 1 until tally > t1\n               add 1 to t2\n               move int-field of table-one(tally)\n                 to int-field of table-two(t2)\n           end-perform\n       .\n\n       display-result.\n           perform varying tally from 1 by 1 until tally = t2\n               move int-field of table-two(tally) to show\n               display trim(show) \", \" with no advancing\n           end-perform\n           move int-field of table-two(tally) to show\n           display trim(show)\n       .\n\n       end program array-concat.\n", "target": "arr1 = [1, 2, 3]\narr2 = [4, 5, 6]\narr3 = [7, 8, 9]\narr4 = arr1 + arr2\nassert arr4 == [1, 2, 3, 4, 5, 6]\narr4.extend(arr3)\nassert arr4 == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"}
{"id": 75500, "name": "Write language name in 3D ASCII", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. cobol-3d.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  cobol-area.\n           03  cobol-text-data PIC X(1030) VALUE \"________/\\\\\\\\\\\\\\\\\\____\n      -        \"____/\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\________\n      -        \"/\\\\\\_____________         _____/\\\\\\////////_______/\\\\\\//\n      -        \"/\\\\\\_____\\/\\\\\\/////////\\\\\\______/\\\\\\///\\\\\\_____\\/\\\\\\____\n      -        \"_________         ___/\\\\\\/______________/\\\\\\/__\\///\\\\\\__\n      -        \"_\\/\\\\\\_______\\/\\\\\\____/\\\\\\/__\\///\\\\\\___\\/\\\\\\____________\n      -        \"_         __/\\\\\\_______________/\\\\\\______\\//\\\\\\__\\/\\\\\\\\\\\n      -        \"\\\\\\\\\\\\\\\\\\____/\\\\\\______\\//\\\\\\__\\/\\\\\\_____________       \n      -      \"  _\\/\\\\\\______________\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\/////////\\\\\\\n      -        \"__\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\_____________         _\\//\\\\\\_\n      -        \"____________\\//\\\\\\______/\\\\\\___\\/\\\\\\_______\\/\\\\\\__\\//\\\\\\\n      -        \"______/\\\\\\___\\/\\\\\\_____________         __\\///\\\\\\_______\n      -        \"_____\\///\\\\\\__/\\\\\\_____\\/\\\\\\_______\\/\\\\\\___\\///\\\\\\__/\\\\\\\n      -        \"_____\\/\\\\\\_____________         ____\\////\\\\\\\\\\\\\\\\\\_____\\\n      -        \"///\\\\\\\\\\/______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\///\\\\\\\\\\/______\\/\\\n      -        \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\_         _______\\/////////________\\/////_\n      -        \"_______\\/////////////__________\\/////________\\//////////\n      -        \"/////__\" \n               .\n           03  cobol-text-table REDEFINES cobol-text-data.\n               05  cobol-text  PIC X(103) OCCURS 10 TIMES.\n\n       01  i                   PIC 99.\n       01  j                   PIC 9(4).\n\n       PROCEDURE DIVISION.\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               MOVE 1 TO j\n               PERFORM UNTIL 103 < j\n                   \n                   \n                   IF cobol-text (i) (j:4) = \"\\\\\\/\"\n                       DISPLAY cobol-text (i) (j:3) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7, HIGHLIGHT\n                           \n                       ADD 3 TO j\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n\n                       ADD 1 TO j\n                           \n                       EXIT PERFORM CYCLE\n                   END-IF\n                       \n                   \n                   \n                   IF cobol-text (i) (j:1) = \"/\" \n                          OR cobol-text (i) (FUNCTION SUM(j, 1):1) = \"/\"\n                          OR cobol-text (i) (FUNCTION SUM(j, 1):2)\n                              = \"\\/\"\n                       DISPLAY cobol-text (i) (j:1)  AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n                   \n                   ELSE\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7 , HIGHLIGHT\n                   END-IF\n\n                   ADD 1 TO j\n               END-PERFORM\n           END-PERFORM\n\n           \n           \n           \n           DISPLAY \"Press enter to stop appreciating COBOL in 3D.\"\n               AT LINE 11 COL 1\n           ACCEPT i AT LINE 11 COL 46\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Text;\n\nnamespace Language_name_in_3D_ascii\n{\n    public class F5\n    {\n        char[] z = { ' ', ' ', '_', '/', };\n        long[,] f ={\n            {87381,87381,87381,87381,87381,87381,87381,},\n            {349525,375733,742837,742837,375733,349525,349525,},\n            {742741,768853,742837,742837,768853,349525,349525,},\n            {349525,375733,742741,742741,375733,349525,349525,},\n            {349621,375733,742837,742837,375733,349525,349525,},\n            {349525,375637,768949,742741,375733,349525,349525,},\n            {351157,374101,768949,374101,374101,349525,349525,},\n            {349525,375733,742837,742837,375733,349621,351157,},\n            {742741,768853,742837,742837,742837,349525,349525,},\n            {181,85,181,181,181,85,85,},\n            {1461,1365,1461,1461,1461,1461,2901,},\n            {742741,744277,767317,744277,742837,349525,349525,},\n            {181,181,181,181,181,85,85,},\n            {1431655765,3149249365L,3042661813L,3042661813L,3042661813L,1431655765,1431655765,},\n            {349525,768853,742837,742837,742837,349525,349525,},\n            {349525,375637,742837,742837,375637,349525,349525,},\n            {349525,768853,742837,742837,768853,742741,742741,},\n            {349525,375733,742837,742837,375733,349621,349621,},\n            {349525,744373,767317,742741,742741,349525,349525,},\n            {349525,375733,767317,351157,768853,349525,349525,},\n            {374101,768949,374101,374101,351157,349525,349525,},\n            {349525,742837,742837,742837,375733,349525,349525,},\n            {5592405,11883957,11883957,5987157,5616981,5592405,5592405,},\n            {366503875925L,778827027893L,778827027893L,392374737749L,368114513237L,366503875925L,366503875925L,},\n            {349525,742837,375637,742837,742837,349525,349525,},\n            {349525,742837,742837,742837,375733,349621,375637,},\n            {349525,768949,351061,374101,768949,349525,349525,},\n            {375637,742837,768949,742837,742837,349525,349525,},\n            {768853,742837,768853,742837,768853,349525,349525,},\n            {375733,742741,742741,742741,375733,349525,349525,},\n            {192213,185709,185709,185709,192213,87381,87381,},\n            {1817525,1791317,1817429,1791317,1817525,1398101,1398101,},\n            {768949,742741,768853,742741,742741,349525,349525,},\n            {375733,742741,744373,742837,375733,349525,349525,},\n            {742837,742837,768949,742837,742837,349525,349525,},\n            {48053,23381,23381,23381,48053,21845,21845,},\n            {349621,349621,349621,742837,375637,349525,349525,},\n            {742837,744277,767317,744277,742837,349525,349525,},\n            {742741,742741,742741,742741,768949,349525,349525,},\n            {11883957,12278709,11908533,11883957,11883957,5592405,5592405,},\n            {11883957,12277173,11908533,11885493,11883957,5592405,5592405,},\n            {375637,742837,742837,742837,375637,349525,349525,},\n            {768853,742837,768853,742741,742741,349525,349525,},\n            {6010197,11885397,11909973,11885397,6010293,5592405,5592405,},\n            {768853,742837,768853,742837,742837,349525,349525,},\n            {375733,742741,375637,349621,768853,349525,349525,},\n            {12303285,5616981,5616981,5616981,5616981,5592405,5592405,},\n            {742837,742837,742837,742837,375637,349525,349525,},\n            {11883957,11883957,11883957,5987157,5616981,5592405,5592405,},\n            {3042268597L,3042268597L,3042661813L,1532713813,1437971797,1431655765,1431655765,},\n            {11883957,5987157,5616981,5987157,11883957,5592405,5592405,},\n            {11883957,5987157,5616981,5616981,5616981,5592405,5592405,},\n            {12303285,5593941,5616981,5985621,12303285,5592405,5592405,}\n            };\n\n        private F5(string s)\n        {\n            StringBuilder[] o = new StringBuilder[7];\n            for (int i = 0; i < 7; i++) o[i] = new StringBuilder();\n            for (int i = 0, l = s.Length; i < l; i++)\n            {\n                int c = s[i];\n                if (65 <= c && c <= 90) c -= 39;\n                else if (97 <= c && c <= 122) c -= 97;\n                else c = -1;\n                long[] d = new long[7];\n                Buffer.BlockCopy(f, (++c * sizeof(long) * 7), d, 0, 7 * sizeof(long));\n                for (int j = 0; j < 7; j++)\n                {\n                    StringBuilder b = new StringBuilder();\n                    long v = d[j];\n                    while (v > 0)\n                    {\n                        b.Append(z[(int)(v & 3)]);\n                        v >>= 2;\n                    }\n                    char[] charArray = b.ToString().ToCharArray();\n                    Array.Reverse(charArray);\n                    o[j].Append(new string(charArray));\n                }\n            }\n            for (int i = 0; i < 7; i++)\n            {\n                for (int j = 0; j < 7 - i; j++)\n                    System.Console.Write(' ');\n                System.Console.WriteLine(o[i]);\n            }\n        }\n\n        public static void Main(string[] args)\n        {\n            new F5(args.Length > 0 ? args[0] : \"C sharp\");\n        }\n    }\n}\n"}
{"id": 75501, "name": "Write language name in 3D ASCII", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. cobol-3d.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  cobol-area.\n           03  cobol-text-data PIC X(1030) VALUE \"________/\\\\\\\\\\\\\\\\\\____\n      -        \"____/\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\________\n      -        \"/\\\\\\_____________         _____/\\\\\\////////_______/\\\\\\//\n      -        \"/\\\\\\_____\\/\\\\\\/////////\\\\\\______/\\\\\\///\\\\\\_____\\/\\\\\\____\n      -        \"_________         ___/\\\\\\/______________/\\\\\\/__\\///\\\\\\__\n      -        \"_\\/\\\\\\_______\\/\\\\\\____/\\\\\\/__\\///\\\\\\___\\/\\\\\\____________\n      -        \"_         __/\\\\\\_______________/\\\\\\______\\//\\\\\\__\\/\\\\\\\\\\\n      -        \"\\\\\\\\\\\\\\\\\\____/\\\\\\______\\//\\\\\\__\\/\\\\\\_____________       \n      -      \"  _\\/\\\\\\______________\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\/////////\\\\\\\n      -        \"__\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\_____________         _\\//\\\\\\_\n      -        \"____________\\//\\\\\\______/\\\\\\___\\/\\\\\\_______\\/\\\\\\__\\//\\\\\\\n      -        \"______/\\\\\\___\\/\\\\\\_____________         __\\///\\\\\\_______\n      -        \"_____\\///\\\\\\__/\\\\\\_____\\/\\\\\\_______\\/\\\\\\___\\///\\\\\\__/\\\\\\\n      -        \"_____\\/\\\\\\_____________         ____\\////\\\\\\\\\\\\\\\\\\_____\\\n      -        \"///\\\\\\\\\\/______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\///\\\\\\\\\\/______\\/\\\n      -        \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\_         _______\\/////////________\\/////_\n      -        \"_______\\/////////////__________\\/////________\\//////////\n      -        \"/////__\" \n               .\n           03  cobol-text-table REDEFINES cobol-text-data.\n               05  cobol-text  PIC X(103) OCCURS 10 TIMES.\n\n       01  i                   PIC 99.\n       01  j                   PIC 9(4).\n\n       PROCEDURE DIVISION.\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               MOVE 1 TO j\n               PERFORM UNTIL 103 < j\n                   \n                   \n                   IF cobol-text (i) (j:4) = \"\\\\\\/\"\n                       DISPLAY cobol-text (i) (j:3) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7, HIGHLIGHT\n                           \n                       ADD 3 TO j\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n\n                       ADD 1 TO j\n                           \n                       EXIT PERFORM CYCLE\n                   END-IF\n                       \n                   \n                   \n                   IF cobol-text (i) (j:1) = \"/\" \n                          OR cobol-text (i) (FUNCTION SUM(j, 1):1) = \"/\"\n                          OR cobol-text (i) (FUNCTION SUM(j, 1):2)\n                              = \"\\/\"\n                       DISPLAY cobol-text (i) (j:1)  AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n                   \n                   ELSE\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7 , HIGHLIGHT\n                   END-IF\n\n                   ADD 1 TO j\n               END-PERFORM\n           END-PERFORM\n\n           \n           \n           \n           DISPLAY \"Press enter to stop appreciating COBOL in 3D.\"\n               AT LINE 11 COL 1\n           ACCEPT i AT LINE 11 COL 46\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Text;\n\nnamespace Language_name_in_3D_ascii\n{\n    public class F5\n    {\n        char[] z = { ' ', ' ', '_', '/', };\n        long[,] f ={\n            {87381,87381,87381,87381,87381,87381,87381,},\n            {349525,375733,742837,742837,375733,349525,349525,},\n            {742741,768853,742837,742837,768853,349525,349525,},\n            {349525,375733,742741,742741,375733,349525,349525,},\n            {349621,375733,742837,742837,375733,349525,349525,},\n            {349525,375637,768949,742741,375733,349525,349525,},\n            {351157,374101,768949,374101,374101,349525,349525,},\n            {349525,375733,742837,742837,375733,349621,351157,},\n            {742741,768853,742837,742837,742837,349525,349525,},\n            {181,85,181,181,181,85,85,},\n            {1461,1365,1461,1461,1461,1461,2901,},\n            {742741,744277,767317,744277,742837,349525,349525,},\n            {181,181,181,181,181,85,85,},\n            {1431655765,3149249365L,3042661813L,3042661813L,3042661813L,1431655765,1431655765,},\n            {349525,768853,742837,742837,742837,349525,349525,},\n            {349525,375637,742837,742837,375637,349525,349525,},\n            {349525,768853,742837,742837,768853,742741,742741,},\n            {349525,375733,742837,742837,375733,349621,349621,},\n            {349525,744373,767317,742741,742741,349525,349525,},\n            {349525,375733,767317,351157,768853,349525,349525,},\n            {374101,768949,374101,374101,351157,349525,349525,},\n            {349525,742837,742837,742837,375733,349525,349525,},\n            {5592405,11883957,11883957,5987157,5616981,5592405,5592405,},\n            {366503875925L,778827027893L,778827027893L,392374737749L,368114513237L,366503875925L,366503875925L,},\n            {349525,742837,375637,742837,742837,349525,349525,},\n            {349525,742837,742837,742837,375733,349621,375637,},\n            {349525,768949,351061,374101,768949,349525,349525,},\n            {375637,742837,768949,742837,742837,349525,349525,},\n            {768853,742837,768853,742837,768853,349525,349525,},\n            {375733,742741,742741,742741,375733,349525,349525,},\n            {192213,185709,185709,185709,192213,87381,87381,},\n            {1817525,1791317,1817429,1791317,1817525,1398101,1398101,},\n            {768949,742741,768853,742741,742741,349525,349525,},\n            {375733,742741,744373,742837,375733,349525,349525,},\n            {742837,742837,768949,742837,742837,349525,349525,},\n            {48053,23381,23381,23381,48053,21845,21845,},\n            {349621,349621,349621,742837,375637,349525,349525,},\n            {742837,744277,767317,744277,742837,349525,349525,},\n            {742741,742741,742741,742741,768949,349525,349525,},\n            {11883957,12278709,11908533,11883957,11883957,5592405,5592405,},\n            {11883957,12277173,11908533,11885493,11883957,5592405,5592405,},\n            {375637,742837,742837,742837,375637,349525,349525,},\n            {768853,742837,768853,742741,742741,349525,349525,},\n            {6010197,11885397,11909973,11885397,6010293,5592405,5592405,},\n            {768853,742837,768853,742837,742837,349525,349525,},\n            {375733,742741,375637,349621,768853,349525,349525,},\n            {12303285,5616981,5616981,5616981,5616981,5592405,5592405,},\n            {742837,742837,742837,742837,375637,349525,349525,},\n            {11883957,11883957,11883957,5987157,5616981,5592405,5592405,},\n            {3042268597L,3042268597L,3042661813L,1532713813,1437971797,1431655765,1431655765,},\n            {11883957,5987157,5616981,5987157,11883957,5592405,5592405,},\n            {11883957,5987157,5616981,5616981,5616981,5592405,5592405,},\n            {12303285,5593941,5616981,5985621,12303285,5592405,5592405,}\n            };\n\n        private F5(string s)\n        {\n            StringBuilder[] o = new StringBuilder[7];\n            for (int i = 0; i < 7; i++) o[i] = new StringBuilder();\n            for (int i = 0, l = s.Length; i < l; i++)\n            {\n                int c = s[i];\n                if (65 <= c && c <= 90) c -= 39;\n                else if (97 <= c && c <= 122) c -= 97;\n                else c = -1;\n                long[] d = new long[7];\n                Buffer.BlockCopy(f, (++c * sizeof(long) * 7), d, 0, 7 * sizeof(long));\n                for (int j = 0; j < 7; j++)\n                {\n                    StringBuilder b = new StringBuilder();\n                    long v = d[j];\n                    while (v > 0)\n                    {\n                        b.Append(z[(int)(v & 3)]);\n                        v >>= 2;\n                    }\n                    char[] charArray = b.ToString().ToCharArray();\n                    Array.Reverse(charArray);\n                    o[j].Append(new string(charArray));\n                }\n            }\n            for (int i = 0; i < 7; i++)\n            {\n                for (int j = 0; j < 7 - i; j++)\n                    System.Console.Write(' ');\n                System.Console.WriteLine(o[i]);\n            }\n        }\n\n        public static void Main(string[] args)\n        {\n            new F5(args.Length > 0 ? args[0] : \"C sharp\");\n        }\n    }\n}\n"}
{"id": 75504, "name": "Write language name in 3D ASCII", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. cobol-3d.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  cobol-area.\n           03  cobol-text-data PIC X(1030) VALUE \"________/\\\\\\\\\\\\\\\\\\____\n      -        \"____/\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\________\n      -        \"/\\\\\\_____________         _____/\\\\\\////////_______/\\\\\\//\n      -        \"/\\\\\\_____\\/\\\\\\/////////\\\\\\______/\\\\\\///\\\\\\_____\\/\\\\\\____\n      -        \"_________         ___/\\\\\\/______________/\\\\\\/__\\///\\\\\\__\n      -        \"_\\/\\\\\\_______\\/\\\\\\____/\\\\\\/__\\///\\\\\\___\\/\\\\\\____________\n      -        \"_         __/\\\\\\_______________/\\\\\\______\\//\\\\\\__\\/\\\\\\\\\\\n      -        \"\\\\\\\\\\\\\\\\\\____/\\\\\\______\\//\\\\\\__\\/\\\\\\_____________       \n      -      \"  _\\/\\\\\\______________\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\/////////\\\\\\\n      -        \"__\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\_____________         _\\//\\\\\\_\n      -        \"____________\\//\\\\\\______/\\\\\\___\\/\\\\\\_______\\/\\\\\\__\\//\\\\\\\n      -        \"______/\\\\\\___\\/\\\\\\_____________         __\\///\\\\\\_______\n      -        \"_____\\///\\\\\\__/\\\\\\_____\\/\\\\\\_______\\/\\\\\\___\\///\\\\\\__/\\\\\\\n      -        \"_____\\/\\\\\\_____________         ____\\////\\\\\\\\\\\\\\\\\\_____\\\n      -        \"///\\\\\\\\\\/______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\///\\\\\\\\\\/______\\/\\\n      -        \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\_         _______\\/////////________\\/////_\n      -        \"_______\\/////////////__________\\/////________\\//////////\n      -        \"/////__\" \n               .\n           03  cobol-text-table REDEFINES cobol-text-data.\n               05  cobol-text  PIC X(103) OCCURS 10 TIMES.\n\n       01  i                   PIC 99.\n       01  j                   PIC 9(4).\n\n       PROCEDURE DIVISION.\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               MOVE 1 TO j\n               PERFORM UNTIL 103 < j\n                   \n                   \n                   IF cobol-text (i) (j:4) = \"\\\\\\/\"\n                       DISPLAY cobol-text (i) (j:3) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7, HIGHLIGHT\n                           \n                       ADD 3 TO j\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n\n                       ADD 1 TO j\n                           \n                       EXIT PERFORM CYCLE\n                   END-IF\n                       \n                   \n                   \n                   IF cobol-text (i) (j:1) = \"/\" \n                          OR cobol-text (i) (FUNCTION SUM(j, 1):1) = \"/\"\n                          OR cobol-text (i) (FUNCTION SUM(j, 1):2)\n                              = \"\\/\"\n                       DISPLAY cobol-text (i) (j:1)  AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n                   \n                   ELSE\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7 , HIGHLIGHT\n                   END-IF\n\n                   ADD 1 TO j\n               END-PERFORM\n           END-PERFORM\n\n           \n           \n           \n           DISPLAY \"Press enter to stop appreciating COBOL in 3D.\"\n               AT LINE 11 COL 1\n           ACCEPT i AT LINE 11 COL 46\n\n           GOBACK\n           .\n", "target": "public class F5{\n    char[]z={' ',' ','_','/',};\n    long[][]f={\n        {87381,87381,87381,87381,87381,87381,87381,},\n        {349525,375733,742837,742837,375733,349525,349525,},\n        {742741,768853,742837,742837,768853,349525,349525,},\n        {349525,375733,742741,742741,375733,349525,349525,},\n        {349621,375733,742837,742837,375733,349525,349525,},\n        {349525,375637,768949,742741,375733,349525,349525,},\n        {351157,374101,768949,374101,374101,349525,349525,},\n        {349525,375733,742837,742837,375733,349621,351157,},\n        {742741,768853,742837,742837,742837,349525,349525,},\n        {181,85,181,181,181,85,85,},\n        {1461,1365,1461,1461,1461,1461,2901,},\n        {742741,744277,767317,744277,742837,349525,349525,},\n        {181,181,181,181,181,85,85,},\n        {1431655765,3149249365L,3042661813L,3042661813L,3042661813L,1431655765,1431655765,},\n        {349525,768853,742837,742837,742837,349525,349525,},\n        {349525,375637,742837,742837,375637,349525,349525,},\n        {349525,768853,742837,742837,768853,742741,742741,},\n        {349525,375733,742837,742837,375733,349621,349621,},\n        {349525,744373,767317,742741,742741,349525,349525,},\n        {349525,375733,767317,351157,768853,349525,349525,},\n        {374101,768949,374101,374101,351157,349525,349525,},\n        {349525,742837,742837,742837,375733,349525,349525,},\n        {5592405,11883957,11883957,5987157,5616981,5592405,5592405,},\n        {366503875925L,778827027893L,778827027893L,392374737749L,368114513237L,366503875925L,366503875925L,},\n        {349525,742837,375637,742837,742837,349525,349525,},\n        {349525,742837,742837,742837,375733,349621,375637,},\n        {349525,768949,351061,374101,768949,349525,349525,},\n        {375637,742837,768949,742837,742837,349525,349525,},\n        {768853,742837,768853,742837,768853,349525,349525,},\n        {375733,742741,742741,742741,375733,349525,349525,},\n        {192213,185709,185709,185709,192213,87381,87381,},\n        {1817525,1791317,1817429,1791317,1817525,1398101,1398101,},\n        {768949,742741,768853,742741,742741,349525,349525,},\n        {375733,742741,744373,742837,375733,349525,349525,},\n        {742837,742837,768949,742837,742837,349525,349525,},\n        {48053,23381,23381,23381,48053,21845,21845,},\n        {349621,349621,349621,742837,375637,349525,349525,},\n        {742837,744277,767317,744277,742837,349525,349525,},\n        {742741,742741,742741,742741,768949,349525,349525,},\n        {11883957,12278709,11908533,11883957,11883957,5592405,5592405,},\n        {11883957,12277173,11908533,11885493,11883957,5592405,5592405,},\n        {375637,742837,742837,742837,375637,349525,349525,},\n        {768853,742837,768853,742741,742741,349525,349525,},\n        {6010197,11885397,11909973,11885397,6010293,5592405,5592405,},\n        {768853,742837,768853,742837,742837,349525,349525,},\n        {375733,742741,375637,349621,768853,349525,349525,},\n        {12303285,5616981,5616981,5616981,5616981,5592405,5592405,},\n        {742837,742837,742837,742837,375637,349525,349525,},\n        {11883957,11883957,11883957,5987157,5616981,5592405,5592405,},\n        {3042268597L,3042268597L,3042661813L,1532713813,1437971797,1431655765,1431655765,},\n        {11883957,5987157,5616981,5987157,11883957,5592405,5592405,},\n        {11883957,5987157,5616981,5616981,5616981,5592405,5592405,},\n        {12303285,5593941,5616981,5985621,12303285,5592405,5592405,},};\n    public static void main(String[]a){\n        new F5(a.length>0?a[0]:\"Java\");}\n    private F5(String s){\n        StringBuilder[]o=new StringBuilder[7];\n        for(int i=0;i<7;i++)o[i]=new StringBuilder();\n        for(int i=0,l=s.length();i<l;i++){\n            int c=s.charAt(i);\n            if(65<=c&&c<=90)c-=39;\n            else if(97<=c&&c<=122)c-=97;\n            else c=-1;\n            long[]d=f[++c];\n            for(int j=0;j<7;j++){\n                StringBuilder b=new StringBuilder();\n                long v=d[j];\n                while(v>0){\n                    b.append(z[(int)(v&3)]);\n                    v>>=2;}\n                o[j].append(b.reverse().toString());}}\n        for(int i=0;i<7;i++){\n            for(int j=0;j<7-i;j++)\n                System.out.print(' ');\n            System.out.println(o[i]);}}}\n"}
{"id": 75505, "name": "Write language name in 3D ASCII", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. cobol-3d.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  cobol-area.\n           03  cobol-text-data PIC X(1030) VALUE \"________/\\\\\\\\\\\\\\\\\\____\n      -        \"____/\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\________\n      -        \"/\\\\\\_____________         _____/\\\\\\////////_______/\\\\\\//\n      -        \"/\\\\\\_____\\/\\\\\\/////////\\\\\\______/\\\\\\///\\\\\\_____\\/\\\\\\____\n      -        \"_________         ___/\\\\\\/______________/\\\\\\/__\\///\\\\\\__\n      -        \"_\\/\\\\\\_______\\/\\\\\\____/\\\\\\/__\\///\\\\\\___\\/\\\\\\____________\n      -        \"_         __/\\\\\\_______________/\\\\\\______\\//\\\\\\__\\/\\\\\\\\\\\n      -        \"\\\\\\\\\\\\\\\\\\____/\\\\\\______\\//\\\\\\__\\/\\\\\\_____________       \n      -      \"  _\\/\\\\\\______________\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\/////////\\\\\\\n      -        \"__\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\_____________         _\\//\\\\\\_\n      -        \"____________\\//\\\\\\______/\\\\\\___\\/\\\\\\_______\\/\\\\\\__\\//\\\\\\\n      -        \"______/\\\\\\___\\/\\\\\\_____________         __\\///\\\\\\_______\n      -        \"_____\\///\\\\\\__/\\\\\\_____\\/\\\\\\_______\\/\\\\\\___\\///\\\\\\__/\\\\\\\n      -        \"_____\\/\\\\\\_____________         ____\\////\\\\\\\\\\\\\\\\\\_____\\\n      -        \"///\\\\\\\\\\/______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\///\\\\\\\\\\/______\\/\\\n      -        \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\_         _______\\/////////________\\/////_\n      -        \"_______\\/////////////__________\\/////________\\//////////\n      -        \"/////__\" \n               .\n           03  cobol-text-table REDEFINES cobol-text-data.\n               05  cobol-text  PIC X(103) OCCURS 10 TIMES.\n\n       01  i                   PIC 99.\n       01  j                   PIC 9(4).\n\n       PROCEDURE DIVISION.\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               MOVE 1 TO j\n               PERFORM UNTIL 103 < j\n                   \n                   \n                   IF cobol-text (i) (j:4) = \"\\\\\\/\"\n                       DISPLAY cobol-text (i) (j:3) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7, HIGHLIGHT\n                           \n                       ADD 3 TO j\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n\n                       ADD 1 TO j\n                           \n                       EXIT PERFORM CYCLE\n                   END-IF\n                       \n                   \n                   \n                   IF cobol-text (i) (j:1) = \"/\" \n                          OR cobol-text (i) (FUNCTION SUM(j, 1):1) = \"/\"\n                          OR cobol-text (i) (FUNCTION SUM(j, 1):2)\n                              = \"\\/\"\n                       DISPLAY cobol-text (i) (j:1)  AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n                   \n                   ELSE\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7 , HIGHLIGHT\n                   END-IF\n\n                   ADD 1 TO j\n               END-PERFORM\n           END-PERFORM\n\n           \n           \n           \n           DISPLAY \"Press enter to stop appreciating COBOL in 3D.\"\n               AT LINE 11 COL 1\n           ACCEPT i AT LINE 11 COL 46\n\n           GOBACK\n           .\n", "target": "public class F5{\n    char[]z={' ',' ','_','/',};\n    long[][]f={\n        {87381,87381,87381,87381,87381,87381,87381,},\n        {349525,375733,742837,742837,375733,349525,349525,},\n        {742741,768853,742837,742837,768853,349525,349525,},\n        {349525,375733,742741,742741,375733,349525,349525,},\n        {349621,375733,742837,742837,375733,349525,349525,},\n        {349525,375637,768949,742741,375733,349525,349525,},\n        {351157,374101,768949,374101,374101,349525,349525,},\n        {349525,375733,742837,742837,375733,349621,351157,},\n        {742741,768853,742837,742837,742837,349525,349525,},\n        {181,85,181,181,181,85,85,},\n        {1461,1365,1461,1461,1461,1461,2901,},\n        {742741,744277,767317,744277,742837,349525,349525,},\n        {181,181,181,181,181,85,85,},\n        {1431655765,3149249365L,3042661813L,3042661813L,3042661813L,1431655765,1431655765,},\n        {349525,768853,742837,742837,742837,349525,349525,},\n        {349525,375637,742837,742837,375637,349525,349525,},\n        {349525,768853,742837,742837,768853,742741,742741,},\n        {349525,375733,742837,742837,375733,349621,349621,},\n        {349525,744373,767317,742741,742741,349525,349525,},\n        {349525,375733,767317,351157,768853,349525,349525,},\n        {374101,768949,374101,374101,351157,349525,349525,},\n        {349525,742837,742837,742837,375733,349525,349525,},\n        {5592405,11883957,11883957,5987157,5616981,5592405,5592405,},\n        {366503875925L,778827027893L,778827027893L,392374737749L,368114513237L,366503875925L,366503875925L,},\n        {349525,742837,375637,742837,742837,349525,349525,},\n        {349525,742837,742837,742837,375733,349621,375637,},\n        {349525,768949,351061,374101,768949,349525,349525,},\n        {375637,742837,768949,742837,742837,349525,349525,},\n        {768853,742837,768853,742837,768853,349525,349525,},\n        {375733,742741,742741,742741,375733,349525,349525,},\n        {192213,185709,185709,185709,192213,87381,87381,},\n        {1817525,1791317,1817429,1791317,1817525,1398101,1398101,},\n        {768949,742741,768853,742741,742741,349525,349525,},\n        {375733,742741,744373,742837,375733,349525,349525,},\n        {742837,742837,768949,742837,742837,349525,349525,},\n        {48053,23381,23381,23381,48053,21845,21845,},\n        {349621,349621,349621,742837,375637,349525,349525,},\n        {742837,744277,767317,744277,742837,349525,349525,},\n        {742741,742741,742741,742741,768949,349525,349525,},\n        {11883957,12278709,11908533,11883957,11883957,5592405,5592405,},\n        {11883957,12277173,11908533,11885493,11883957,5592405,5592405,},\n        {375637,742837,742837,742837,375637,349525,349525,},\n        {768853,742837,768853,742741,742741,349525,349525,},\n        {6010197,11885397,11909973,11885397,6010293,5592405,5592405,},\n        {768853,742837,768853,742837,742837,349525,349525,},\n        {375733,742741,375637,349621,768853,349525,349525,},\n        {12303285,5616981,5616981,5616981,5616981,5592405,5592405,},\n        {742837,742837,742837,742837,375637,349525,349525,},\n        {11883957,11883957,11883957,5987157,5616981,5592405,5592405,},\n        {3042268597L,3042268597L,3042661813L,1532713813,1437971797,1431655765,1431655765,},\n        {11883957,5987157,5616981,5987157,11883957,5592405,5592405,},\n        {11883957,5987157,5616981,5616981,5616981,5592405,5592405,},\n        {12303285,5593941,5616981,5985621,12303285,5592405,5592405,},};\n    public static void main(String[]a){\n        new F5(a.length>0?a[0]:\"Java\");}\n    private F5(String s){\n        StringBuilder[]o=new StringBuilder[7];\n        for(int i=0;i<7;i++)o[i]=new StringBuilder();\n        for(int i=0,l=s.length();i<l;i++){\n            int c=s.charAt(i);\n            if(65<=c&&c<=90)c-=39;\n            else if(97<=c&&c<=122)c-=97;\n            else c=-1;\n            long[]d=f[++c];\n            for(int j=0;j<7;j++){\n                StringBuilder b=new StringBuilder();\n                long v=d[j];\n                while(v>0){\n                    b.append(z[(int)(v&3)]);\n                    v>>=2;}\n                o[j].append(b.reverse().toString());}}\n        for(int i=0;i<7;i++){\n            for(int j=0;j<7-i;j++)\n                System.out.print(' ');\n            System.out.println(o[i]);}}}\n"}
{"id": 75506, "name": "Write language name in 3D ASCII", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. cobol-3d.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  cobol-area.\n           03  cobol-text-data PIC X(1030) VALUE \"________/\\\\\\\\\\\\\\\\\\____\n      -        \"____/\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\________\n      -        \"/\\\\\\_____________         _____/\\\\\\////////_______/\\\\\\//\n      -        \"/\\\\\\_____\\/\\\\\\/////////\\\\\\______/\\\\\\///\\\\\\_____\\/\\\\\\____\n      -        \"_________         ___/\\\\\\/______________/\\\\\\/__\\///\\\\\\__\n      -        \"_\\/\\\\\\_______\\/\\\\\\____/\\\\\\/__\\///\\\\\\___\\/\\\\\\____________\n      -        \"_         __/\\\\\\_______________/\\\\\\______\\//\\\\\\__\\/\\\\\\\\\\\n      -        \"\\\\\\\\\\\\\\\\\\____/\\\\\\______\\//\\\\\\__\\/\\\\\\_____________       \n      -      \"  _\\/\\\\\\______________\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\/////////\\\\\\\n      -        \"__\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\_____________         _\\//\\\\\\_\n      -        \"____________\\//\\\\\\______/\\\\\\___\\/\\\\\\_______\\/\\\\\\__\\//\\\\\\\n      -        \"______/\\\\\\___\\/\\\\\\_____________         __\\///\\\\\\_______\n      -        \"_____\\///\\\\\\__/\\\\\\_____\\/\\\\\\_______\\/\\\\\\___\\///\\\\\\__/\\\\\\\n      -        \"_____\\/\\\\\\_____________         ____\\////\\\\\\\\\\\\\\\\\\_____\\\n      -        \"///\\\\\\\\\\/______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\///\\\\\\\\\\/______\\/\\\n      -        \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\_         _______\\/////////________\\/////_\n      -        \"_______\\/////////////__________\\/////________\\//////////\n      -        \"/////__\" \n               .\n           03  cobol-text-table REDEFINES cobol-text-data.\n               05  cobol-text  PIC X(103) OCCURS 10 TIMES.\n\n       01  i                   PIC 99.\n       01  j                   PIC 9(4).\n\n       PROCEDURE DIVISION.\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               MOVE 1 TO j\n               PERFORM UNTIL 103 < j\n                   \n                   \n                   IF cobol-text (i) (j:4) = \"\\\\\\/\"\n                       DISPLAY cobol-text (i) (j:3) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7, HIGHLIGHT\n                           \n                       ADD 3 TO j\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n\n                       ADD 1 TO j\n                           \n                       EXIT PERFORM CYCLE\n                   END-IF\n                       \n                   \n                   \n                   IF cobol-text (i) (j:1) = \"/\" \n                          OR cobol-text (i) (FUNCTION SUM(j, 1):1) = \"/\"\n                          OR cobol-text (i) (FUNCTION SUM(j, 1):2)\n                              = \"\\/\"\n                       DISPLAY cobol-text (i) (j:1)  AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n                   \n                   ELSE\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7 , HIGHLIGHT\n                   END-IF\n\n                   ADD 1 TO j\n               END-PERFORM\n           END-PERFORM\n\n           \n           \n           \n           DISPLAY \"Press enter to stop appreciating COBOL in 3D.\"\n               AT LINE 11 COL 1\n           ACCEPT i AT LINE 11 COL 46\n\n           GOBACK\n           .\n", "target": "py = '''\\\n \n \n \n \n \n\nlines = py.replace('\n        .replace('X', '   ').replace('\\n', ' Y') \\\n        .replace('< ', '<>').split('Y')\n\nfor i, l in enumerate(lines): \n    print('  ' * (len(lines) - i) + l)\n"}
{"id": 75507, "name": "Write language name in 3D ASCII", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. cobol-3d.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  cobol-area.\n           03  cobol-text-data PIC X(1030) VALUE \"________/\\\\\\\\\\\\\\\\\\____\n      -        \"____/\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\________\n      -        \"/\\\\\\_____________         _____/\\\\\\////////_______/\\\\\\//\n      -        \"/\\\\\\_____\\/\\\\\\/////////\\\\\\______/\\\\\\///\\\\\\_____\\/\\\\\\____\n      -        \"_________         ___/\\\\\\/______________/\\\\\\/__\\///\\\\\\__\n      -        \"_\\/\\\\\\_______\\/\\\\\\____/\\\\\\/__\\///\\\\\\___\\/\\\\\\____________\n      -        \"_         __/\\\\\\_______________/\\\\\\______\\//\\\\\\__\\/\\\\\\\\\\\n      -        \"\\\\\\\\\\\\\\\\\\____/\\\\\\______\\//\\\\\\__\\/\\\\\\_____________       \n      -      \"  _\\/\\\\\\______________\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\/////////\\\\\\\n      -        \"__\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\_____________         _\\//\\\\\\_\n      -        \"____________\\//\\\\\\______/\\\\\\___\\/\\\\\\_______\\/\\\\\\__\\//\\\\\\\n      -        \"______/\\\\\\___\\/\\\\\\_____________         __\\///\\\\\\_______\n      -        \"_____\\///\\\\\\__/\\\\\\_____\\/\\\\\\_______\\/\\\\\\___\\///\\\\\\__/\\\\\\\n      -        \"_____\\/\\\\\\_____________         ____\\////\\\\\\\\\\\\\\\\\\_____\\\n      -        \"///\\\\\\\\\\/______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\///\\\\\\\\\\/______\\/\\\n      -        \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\_         _______\\/////////________\\/////_\n      -        \"_______\\/////////////__________\\/////________\\//////////\n      -        \"/////__\" \n               .\n           03  cobol-text-table REDEFINES cobol-text-data.\n               05  cobol-text  PIC X(103) OCCURS 10 TIMES.\n\n       01  i                   PIC 99.\n       01  j                   PIC 9(4).\n\n       PROCEDURE DIVISION.\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               MOVE 1 TO j\n               PERFORM UNTIL 103 < j\n                   \n                   \n                   IF cobol-text (i) (j:4) = \"\\\\\\/\"\n                       DISPLAY cobol-text (i) (j:3) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7, HIGHLIGHT\n                           \n                       ADD 3 TO j\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n\n                       ADD 1 TO j\n                           \n                       EXIT PERFORM CYCLE\n                   END-IF\n                       \n                   \n                   \n                   IF cobol-text (i) (j:1) = \"/\" \n                          OR cobol-text (i) (FUNCTION SUM(j, 1):1) = \"/\"\n                          OR cobol-text (i) (FUNCTION SUM(j, 1):2)\n                              = \"\\/\"\n                       DISPLAY cobol-text (i) (j:1)  AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n                   \n                   ELSE\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7 , HIGHLIGHT\n                   END-IF\n\n                   ADD 1 TO j\n               END-PERFORM\n           END-PERFORM\n\n           \n           \n           \n           DISPLAY \"Press enter to stop appreciating COBOL in 3D.\"\n               AT LINE 11 COL 1\n           ACCEPT i AT LINE 11 COL 46\n\n           GOBACK\n           .\n", "target": "py = '''\\\n \n \n \n \n \n\nlines = py.replace('\n        .replace('X', '   ').replace('\\n', ' Y') \\\n        .replace('< ', '<>').split('Y')\n\nfor i, l in enumerate(lines): \n    print('  ' * (len(lines) - i) + l)\n"}
{"id": 76003, "name": "Sorting algorithms_Bubble sort", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.                      BUBBLESORT.\n       AUTHOR.                          DAVE STRATFORD.\n       DATE-WRITTEN.                    MARCH 2010.\n       INSTALLATION.                    HEXAGON SYSTEMS LIMITED.\n \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SOURCE-COMPUTER.                 ICL VME.\n       OBJECT-COMPUTER.                 ICL VME.\n \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT FA-INPUT-FILE  ASSIGN FL01.\n           SELECT FB-OUTPUT-FILE ASSIGN FL02.\n \n       DATA DIVISION.\n       FILE SECTION.\n \n       FD  FA-INPUT-FILE.\n       01  FA-INPUT-REC.\n         03  FA-DATA                    PIC S9(6).\n \n       FD  FB-OUTPUT-FILE.\n       01  FB-OUTPUT-REC                PIC S9(6).\n \n       WORKING-STORAGE SECTION.\n       01  WA-IDENTITY.\n         03  WA-PROGNAME                PIC X(10) VALUE \"BUBBLESORT\".\n         03  WA-VERSION                 PIC X(6) VALUE \"000001\".\n \n       01  WB-TABLE.\n         03  WB-ENTRY                   PIC 9(8) COMP SYNC OCCURS 100000\n                                                  INDEXED BY WB-IX-1.\n \n       01  WC-VARS.\n         03  WC-SIZE                    PIC S9(8) COMP SYNC.\n         03  WC-TEMP                    PIC S9(8) COMP SYNC.\n         03  WC-END                     PIC S9(8) COMP SYNC.\n         03  WC-LAST-CHANGE             PIC S9(8) COMP SYNC.\n \n       01  WF-CONDITION-FLAGS.\n         03  WF-EOF-FLAG                PIC X.\n           88  END-OF-FILE              VALUE \"Y\".\n         03  WF-EMPTY-FILE-FLAG         PIC X.\n           88  EMPTY-FILE               VALUE \"Y\".\n \n       PROCEDURE DIVISION.\n       A-MAIN SECTION.\n       A-000.\n           PERFORM B-INITIALISE.\n           IF NOT EMPTY-FILE\n              PERFORM C-SORT.\n           PERFORM D-FINISH.\n \n       A-999.\n           STOP RUN.\n \n       B-INITIALISE SECTION.\n       B-000.\n           DISPLAY \"*** \" WA-PROGNAME \" VERSION \"\n                          WA-VERSION \" STARTING ***\".\n \n           MOVE ALL \"N\" TO WF-CONDITION-FLAGS.\n           OPEN INPUT FA-INPUT-FILE.\n           SET WB-IX-1 TO 0.\n \n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG\n                                                 WF-EMPTY-FILE-FLAG.\n \n           PERFORM BA-READ-INPUT UNTIL END-OF-FILE.\n \n           CLOSE FA-INPUT-FILE.\n \n           SET WC-SIZE TO WB-IX-1.\n \n       B-999.\n           EXIT.\n \n       BA-READ-INPUT SECTION.\n       BA-000.\n           SET WB-IX-1 UP BY 1.\n           MOVE FA-DATA TO WB-ENTRY(WB-IX-1).\n \n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG.\n \n       BA-999.\n           EXIT.\n \n       C-SORT SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n \n           MOVE WC-SIZE TO WC-END.\n           PERFORM E-BUBBLE UNTIL WC-END = 1.\n \n           DISPLAY \"SORT FINISHED\".\n \n       C-999.\n           EXIT.\n \n       D-FINISH SECTION.\n       D-000.\n           OPEN OUTPUT FB-OUTPUT-FILE.\n           SET WB-IX-1 TO 1.\n \n           PERFORM DA-WRITE-OUTPUT UNTIL WB-IX-1 > WC-SIZE.\n \n           CLOSE FB-OUTPUT-FILE.\n \n           DISPLAY \"*** \" WA-PROGNAME \" FINISHED ***\".\n \n       D-999.\n           EXIT.\n \n       DA-WRITE-OUTPUT SECTION.\n       DA-000.\n           WRITE FB-OUTPUT-REC FROM WB-ENTRY(WB-IX-1).\n           SET WB-IX-1 UP BY 1.\n \n       DA-999.\n           EXIT.\n \n       E-BUBBLE SECTION.\n       E-000.\n           MOVE 1 TO WC-LAST-CHANGE.\n \n           PERFORM F-PASS VARYING WB-IX-1 FROM 1 BY 1\n                          UNTIL WB-IX-1 = WC-END.\n \n           MOVE WC-LAST-CHANGE TO WC-END.\n \n       E-999.\n           EXIT.\n \n       F-PASS SECTION.\n       F-000.\n           IF WB-ENTRY(WB-IX-1) > WB-ENTRY(WB-IX-1 + 1)\n              SET  WC-LAST-CHANGE        TO WB-IX-1\n              MOVE WB-ENTRY(WB-IX-1)     TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1 + 1) TO WB-ENTRY(WB-IX-1)\n              MOVE WC-TEMP               TO WB-ENTRY(WB-IX-1 + 1).\n \n       F-999.\n           EXIT.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.BubbleSort\n{\n    public static class BubbleSortMethods\n    {\n        \n        \n        \n        public static void BubbleSort<T>(this List<T> list) where T : IComparable\n        {\n            bool madeChanges;\n            int itemCount = list.Count;\n            do\n            {\n                madeChanges = false;\n                itemCount--;\n                for (int i = 0; i < itemCount; i++)\n                {\n                    if (list[i].CompareTo(list[i + 1]) > 0)\n                    {\n                        T temp = list[i + 1];\n                        list[i + 1] = list[i];\n                        list[i] = temp;\n                        madeChanges = true;\n                    }\n                }\n            } while (madeChanges);\n        }\n    }\n\n    \n    \n    class Program\n    {\n        static void Main()\n        {\n            List<int> testList = new List<int> { 3, 7, 3, 2, 1, -4, 10, 12, 4 };\n            testList.BubbleSort();\n            foreach (var t in testList) Console.Write(t + \" \");\n        }\n    }\n}\n"}
{"id": 76005, "name": "Sorting algorithms_Bubble sort", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.                      BUBBLESORT.\n       AUTHOR.                          DAVE STRATFORD.\n       DATE-WRITTEN.                    MARCH 2010.\n       INSTALLATION.                    HEXAGON SYSTEMS LIMITED.\n \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SOURCE-COMPUTER.                 ICL VME.\n       OBJECT-COMPUTER.                 ICL VME.\n \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT FA-INPUT-FILE  ASSIGN FL01.\n           SELECT FB-OUTPUT-FILE ASSIGN FL02.\n \n       DATA DIVISION.\n       FILE SECTION.\n \n       FD  FA-INPUT-FILE.\n       01  FA-INPUT-REC.\n         03  FA-DATA                    PIC S9(6).\n \n       FD  FB-OUTPUT-FILE.\n       01  FB-OUTPUT-REC                PIC S9(6).\n \n       WORKING-STORAGE SECTION.\n       01  WA-IDENTITY.\n         03  WA-PROGNAME                PIC X(10) VALUE \"BUBBLESORT\".\n         03  WA-VERSION                 PIC X(6) VALUE \"000001\".\n \n       01  WB-TABLE.\n         03  WB-ENTRY                   PIC 9(8) COMP SYNC OCCURS 100000\n                                                  INDEXED BY WB-IX-1.\n \n       01  WC-VARS.\n         03  WC-SIZE                    PIC S9(8) COMP SYNC.\n         03  WC-TEMP                    PIC S9(8) COMP SYNC.\n         03  WC-END                     PIC S9(8) COMP SYNC.\n         03  WC-LAST-CHANGE             PIC S9(8) COMP SYNC.\n \n       01  WF-CONDITION-FLAGS.\n         03  WF-EOF-FLAG                PIC X.\n           88  END-OF-FILE              VALUE \"Y\".\n         03  WF-EMPTY-FILE-FLAG         PIC X.\n           88  EMPTY-FILE               VALUE \"Y\".\n \n       PROCEDURE DIVISION.\n       A-MAIN SECTION.\n       A-000.\n           PERFORM B-INITIALISE.\n           IF NOT EMPTY-FILE\n              PERFORM C-SORT.\n           PERFORM D-FINISH.\n \n       A-999.\n           STOP RUN.\n \n       B-INITIALISE SECTION.\n       B-000.\n           DISPLAY \"*** \" WA-PROGNAME \" VERSION \"\n                          WA-VERSION \" STARTING ***\".\n \n           MOVE ALL \"N\" TO WF-CONDITION-FLAGS.\n           OPEN INPUT FA-INPUT-FILE.\n           SET WB-IX-1 TO 0.\n \n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG\n                                                 WF-EMPTY-FILE-FLAG.\n \n           PERFORM BA-READ-INPUT UNTIL END-OF-FILE.\n \n           CLOSE FA-INPUT-FILE.\n \n           SET WC-SIZE TO WB-IX-1.\n \n       B-999.\n           EXIT.\n \n       BA-READ-INPUT SECTION.\n       BA-000.\n           SET WB-IX-1 UP BY 1.\n           MOVE FA-DATA TO WB-ENTRY(WB-IX-1).\n \n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG.\n \n       BA-999.\n           EXIT.\n \n       C-SORT SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n \n           MOVE WC-SIZE TO WC-END.\n           PERFORM E-BUBBLE UNTIL WC-END = 1.\n \n           DISPLAY \"SORT FINISHED\".\n \n       C-999.\n           EXIT.\n \n       D-FINISH SECTION.\n       D-000.\n           OPEN OUTPUT FB-OUTPUT-FILE.\n           SET WB-IX-1 TO 1.\n \n           PERFORM DA-WRITE-OUTPUT UNTIL WB-IX-1 > WC-SIZE.\n \n           CLOSE FB-OUTPUT-FILE.\n \n           DISPLAY \"*** \" WA-PROGNAME \" FINISHED ***\".\n \n       D-999.\n           EXIT.\n \n       DA-WRITE-OUTPUT SECTION.\n       DA-000.\n           WRITE FB-OUTPUT-REC FROM WB-ENTRY(WB-IX-1).\n           SET WB-IX-1 UP BY 1.\n \n       DA-999.\n           EXIT.\n \n       E-BUBBLE SECTION.\n       E-000.\n           MOVE 1 TO WC-LAST-CHANGE.\n \n           PERFORM F-PASS VARYING WB-IX-1 FROM 1 BY 1\n                          UNTIL WB-IX-1 = WC-END.\n \n           MOVE WC-LAST-CHANGE TO WC-END.\n \n       E-999.\n           EXIT.\n \n       F-PASS SECTION.\n       F-000.\n           IF WB-ENTRY(WB-IX-1) > WB-ENTRY(WB-IX-1 + 1)\n              SET  WC-LAST-CHANGE        TO WB-IX-1\n              MOVE WB-ENTRY(WB-IX-1)     TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1 + 1) TO WB-ENTRY(WB-IX-1)\n              MOVE WC-TEMP               TO WB-ENTRY(WB-IX-1 + 1).\n \n       F-999.\n           EXIT.\n", "target": "public static <E extends Comparable<? super E>> void bubbleSort(E[] comparable) {\n    boolean changed = false;\n    do {\n        changed = false;\n        for (int a = 0; a < comparable.length - 1; a++) {\n            if (comparable[a].compareTo(comparable[a + 1]) > 0) {\n                E tmp = comparable[a];\n                comparable[a] = comparable[a + 1];\n                comparable[a + 1] = tmp;\n                changed = true;\n            }\n        }\n    } while (changed);\n}\n"}
{"id": 76006, "name": "Sorting algorithms_Bubble sort", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.                      BUBBLESORT.\n       AUTHOR.                          DAVE STRATFORD.\n       DATE-WRITTEN.                    MARCH 2010.\n       INSTALLATION.                    HEXAGON SYSTEMS LIMITED.\n \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SOURCE-COMPUTER.                 ICL VME.\n       OBJECT-COMPUTER.                 ICL VME.\n \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT FA-INPUT-FILE  ASSIGN FL01.\n           SELECT FB-OUTPUT-FILE ASSIGN FL02.\n \n       DATA DIVISION.\n       FILE SECTION.\n \n       FD  FA-INPUT-FILE.\n       01  FA-INPUT-REC.\n         03  FA-DATA                    PIC S9(6).\n \n       FD  FB-OUTPUT-FILE.\n       01  FB-OUTPUT-REC                PIC S9(6).\n \n       WORKING-STORAGE SECTION.\n       01  WA-IDENTITY.\n         03  WA-PROGNAME                PIC X(10) VALUE \"BUBBLESORT\".\n         03  WA-VERSION                 PIC X(6) VALUE \"000001\".\n \n       01  WB-TABLE.\n         03  WB-ENTRY                   PIC 9(8) COMP SYNC OCCURS 100000\n                                                  INDEXED BY WB-IX-1.\n \n       01  WC-VARS.\n         03  WC-SIZE                    PIC S9(8) COMP SYNC.\n         03  WC-TEMP                    PIC S9(8) COMP SYNC.\n         03  WC-END                     PIC S9(8) COMP SYNC.\n         03  WC-LAST-CHANGE             PIC S9(8) COMP SYNC.\n \n       01  WF-CONDITION-FLAGS.\n         03  WF-EOF-FLAG                PIC X.\n           88  END-OF-FILE              VALUE \"Y\".\n         03  WF-EMPTY-FILE-FLAG         PIC X.\n           88  EMPTY-FILE               VALUE \"Y\".\n \n       PROCEDURE DIVISION.\n       A-MAIN SECTION.\n       A-000.\n           PERFORM B-INITIALISE.\n           IF NOT EMPTY-FILE\n              PERFORM C-SORT.\n           PERFORM D-FINISH.\n \n       A-999.\n           STOP RUN.\n \n       B-INITIALISE SECTION.\n       B-000.\n           DISPLAY \"*** \" WA-PROGNAME \" VERSION \"\n                          WA-VERSION \" STARTING ***\".\n \n           MOVE ALL \"N\" TO WF-CONDITION-FLAGS.\n           OPEN INPUT FA-INPUT-FILE.\n           SET WB-IX-1 TO 0.\n \n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG\n                                                 WF-EMPTY-FILE-FLAG.\n \n           PERFORM BA-READ-INPUT UNTIL END-OF-FILE.\n \n           CLOSE FA-INPUT-FILE.\n \n           SET WC-SIZE TO WB-IX-1.\n \n       B-999.\n           EXIT.\n \n       BA-READ-INPUT SECTION.\n       BA-000.\n           SET WB-IX-1 UP BY 1.\n           MOVE FA-DATA TO WB-ENTRY(WB-IX-1).\n \n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG.\n \n       BA-999.\n           EXIT.\n \n       C-SORT SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n \n           MOVE WC-SIZE TO WC-END.\n           PERFORM E-BUBBLE UNTIL WC-END = 1.\n \n           DISPLAY \"SORT FINISHED\".\n \n       C-999.\n           EXIT.\n \n       D-FINISH SECTION.\n       D-000.\n           OPEN OUTPUT FB-OUTPUT-FILE.\n           SET WB-IX-1 TO 1.\n \n           PERFORM DA-WRITE-OUTPUT UNTIL WB-IX-1 > WC-SIZE.\n \n           CLOSE FB-OUTPUT-FILE.\n \n           DISPLAY \"*** \" WA-PROGNAME \" FINISHED ***\".\n \n       D-999.\n           EXIT.\n \n       DA-WRITE-OUTPUT SECTION.\n       DA-000.\n           WRITE FB-OUTPUT-REC FROM WB-ENTRY(WB-IX-1).\n           SET WB-IX-1 UP BY 1.\n \n       DA-999.\n           EXIT.\n \n       E-BUBBLE SECTION.\n       E-000.\n           MOVE 1 TO WC-LAST-CHANGE.\n \n           PERFORM F-PASS VARYING WB-IX-1 FROM 1 BY 1\n                          UNTIL WB-IX-1 = WC-END.\n \n           MOVE WC-LAST-CHANGE TO WC-END.\n \n       E-999.\n           EXIT.\n \n       F-PASS SECTION.\n       F-000.\n           IF WB-ENTRY(WB-IX-1) > WB-ENTRY(WB-IX-1 + 1)\n              SET  WC-LAST-CHANGE        TO WB-IX-1\n              MOVE WB-ENTRY(WB-IX-1)     TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1 + 1) TO WB-ENTRY(WB-IX-1)\n              MOVE WC-TEMP               TO WB-ENTRY(WB-IX-1 + 1).\n \n       F-999.\n           EXIT.\n", "target": "def bubble_sort(seq):\n    \n    changed = True\n    while changed:\n        changed = False\n        for i in range(len(seq) - 1):\n            if seq[i] > seq[i+1]:\n                seq[i], seq[i+1] = seq[i+1], seq[i]\n                changed = True\n    return seq\n\nif __name__ == \"__main__\":\n   \n\n   from random import shuffle\n\n   testset = [_ for _ in range(100)]\n   testcase = testset.copy() \n   shuffle(testcase)\n   assert testcase != testset  \n   bubble_sort(testcase)\n   assert testcase == testset  \n"}
{"id": 77125, "name": "Greatest common divisor", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. GCD.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 A        PIC 9(10)   VALUE ZEROES.\n       01 B        PIC 9(10)   VALUE ZEROES.\n       01 TEMP     PIC 9(10)   VALUE ZEROES.\n\n       PROCEDURE DIVISION.\n       Begin.\n           DISPLAY \"Enter first number, max 10 digits.\"\n           ACCEPT A\n           DISPLAY \"Enter second number, max 10 digits.\"\n           ACCEPT B\n           IF A < B\n             MOVE B TO TEMP\n             MOVE A TO B\n             MOVE TEMP TO B\n           END-IF\n\n           PERFORM UNTIL B = 0\n             MOVE A TO TEMP\n             MOVE B TO A\n             DIVIDE TEMP BY B GIVING TEMP REMAINDER B\n           END-PERFORM\n           DISPLAY \"The gcd is \" A\n           STOP RUN.\n", "target": "static void Main()\n{\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 1, gcd(1, 1));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 10, gcd(1, 10));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 10, 100, gcd(10, 100));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 5, 50, gcd(5, 50));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 8, 24, gcd(8, 24));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 17, gcd(36, 17));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 18, gcd(36, 18));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 19, gcd(36, 19));\n\tfor (int x = 1; x < 36; x++)\n\t{\n\t\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, x, gcd(36, x));\n\t}\n\tConsole.Read();\n}\n \n\n\n\nstatic int gcd(int a, int b)\n{\n    while (b != 0) b = a % (a = b);\n    return a;\n}\n"}
{"id": 77127, "name": "Greatest common divisor", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. GCD.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 A        PIC 9(10)   VALUE ZEROES.\n       01 B        PIC 9(10)   VALUE ZEROES.\n       01 TEMP     PIC 9(10)   VALUE ZEROES.\n\n       PROCEDURE DIVISION.\n       Begin.\n           DISPLAY \"Enter first number, max 10 digits.\"\n           ACCEPT A\n           DISPLAY \"Enter second number, max 10 digits.\"\n           ACCEPT B\n           IF A < B\n             MOVE B TO TEMP\n             MOVE A TO B\n             MOVE TEMP TO B\n           END-IF\n\n           PERFORM UNTIL B = 0\n             MOVE A TO TEMP\n             MOVE B TO A\n             DIVIDE TEMP BY B GIVING TEMP REMAINDER B\n           END-PERFORM\n           DISPLAY \"The gcd is \" A\n           STOP RUN.\n", "target": "public static long gcd(long a, long b){\n   long factor= Math.min(a, b);\n   for(long loop= factor;loop > 1;loop--){\n      if(a % loop == 0 && b % loop == 0){\n         return loop;\n      }\n   }\n   return 1;\n}\n"}
{"id": 77128, "name": "Greatest common divisor", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. GCD.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 A        PIC 9(10)   VALUE ZEROES.\n       01 B        PIC 9(10)   VALUE ZEROES.\n       01 TEMP     PIC 9(10)   VALUE ZEROES.\n\n       PROCEDURE DIVISION.\n       Begin.\n           DISPLAY \"Enter first number, max 10 digits.\"\n           ACCEPT A\n           DISPLAY \"Enter second number, max 10 digits.\"\n           ACCEPT B\n           IF A < B\n             MOVE B TO TEMP\n             MOVE A TO B\n             MOVE TEMP TO B\n           END-IF\n\n           PERFORM UNTIL B = 0\n             MOVE A TO TEMP\n             MOVE B TO A\n             DIVIDE TEMP BY B GIVING TEMP REMAINDER B\n           END-PERFORM\n           DISPLAY \"The gcd is \" A\n           STOP RUN.\n", "target": "from fractions import gcd\n"}
{"id": 77403, "name": "Luhn test of credit card numbers", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  LUHNTEST.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       data division.\n       WORKING-STORAGE SECTION.\n       01  inp-card.\n         03  inp-card-ch      pic x(01) occurs 20 times.\n       01  ws-result          pic 9(01).\n         88  pass-luhn-test             value 0.\n\n       PROCEDURE DIVISION.\n           move \"49927398716\"       to inp-card\n           perform test-card\n           move \"49927398717\"       to inp-card\n           perform test-card\n           move \"1234567812345678\"  to inp-card\n           perform test-card\n           move \"1234567812345670\"  to inp-card\n           perform test-card\n           stop run\n           .\n       test-card.\n           call \"LUHN\" using inp-card, ws-result\n           if pass-luhn-test\n             display \"input=\" inp-card \"pass\"\n           else\n             display \"input=\" inp-card \"fail\"\n           .\n\n       END PROGRAM LUHNTEST.\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  LUHN.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  maxlen           pic 9(02) comp value 16.\n       01  inplen           pic 9(02) comp value 0.\n       01  i                pic 9(02) comp value 0.\n       01  j                pic 9(02) comp value 0.\n       01  l                pic 9(02) comp value 0.\n       01  dw               pic 9(02) comp value 0.\n       01  ws-total         pic 9(03) comp value 0.\n       01  ws-prod          pic 99.\n       01  filler redefines ws-prod.\n         03  ws-prod-tens   pic 9.\n         03  ws-prod-units  pic 9.\n       01  ws-card.\n         03  filler           occurs 16 times depending on maxlen.\n           05  ws-card-ch     pic x(01).\n           05  ws-card-digit redefines ws-card-ch  pic 9(01).\n       LINKAGE SECTION.\n       01  inp-card.\n         03  inp-card-ch      pic x(01) occurs 20 times.\n       01  ws-result          pic 9(01).\n         88  pass-luhn-test             value 0.\n\n       PROCEDURE DIVISION using inp-card, ws-result.\n           perform varying i from 1 by +1\n           until i > maxlen\n           or    inp-card-ch (i) = space\n           end-perform\n           compute l = i - 1\n           compute inplen = l\n           perform varying j from 1 by +1\n           until j > inplen\n             if l < 1\n               move \"0\"             to ws-card-ch (j)\n             else\n               move inp-card-ch (l) to ws-card-ch (j)\n               compute l = l - 1\n             end-if\n           end-perform\n           move 0 to ws-total\n           perform varying i from 1 by +1\n           until i > inplen\n             compute dw = 2 - (i - 2 * function integer (i / 2))\n             compute ws-prod = ws-card-digit (i) * dw\n             compute ws-total = ws-total\n                              + ws-prod-tens\n                              + ws-prod-units\n           end-perform\n           compute ws-result = ws-total - 10 * function integer (ws-total / 10)\n           goback\n           .\n       END PROGRAM LUHN.\n", "target": "    public static class Luhn\n    {\n        public static bool LuhnCheck(this string cardNumber)\n        {\n            return LuhnCheck(cardNumber.Select(c => c - '0').ToArray());\n        }\n\n        private static bool LuhnCheck(this int[] digits)\n        {\n            return GetCheckValue(digits) == 0;\n        }\n\n        private static int GetCheckValue(int[] digits)\n        {\n            return digits.Select((d, i) => i % 2 == digits.Length % 2 ? ((2 * d) % 10) + d / 5 : d).Sum() % 10;\n        }\n    }\n\n    public static class TestProgram\n    {\n        public static void Main()\n        {\n            long[] testNumbers = {49927398716, 49927398717, 1234567812345678, 1234567812345670};\n            foreach (var testNumber in testNumbers)\n                Console.WriteLine(\"{0} is {1}valid\", testNumber, testNumber.ToString().LuhnCheck() ? \"\" : \"not \");\n        }\n    }\n"}
{"id": 77405, "name": "Luhn test of credit card numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  LUHNTEST.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       data division.\n       WORKING-STORAGE SECTION.\n       01  inp-card.\n         03  inp-card-ch      pic x(01) occurs 20 times.\n       01  ws-result          pic 9(01).\n         88  pass-luhn-test             value 0.\n\n       PROCEDURE DIVISION.\n           move \"49927398716\"       to inp-card\n           perform test-card\n           move \"49927398717\"       to inp-card\n           perform test-card\n           move \"1234567812345678\"  to inp-card\n           perform test-card\n           move \"1234567812345670\"  to inp-card\n           perform test-card\n           stop run\n           .\n       test-card.\n           call \"LUHN\" using inp-card, ws-result\n           if pass-luhn-test\n             display \"input=\" inp-card \"pass\"\n           else\n             display \"input=\" inp-card \"fail\"\n           .\n\n       END PROGRAM LUHNTEST.\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  LUHN.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  maxlen           pic 9(02) comp value 16.\n       01  inplen           pic 9(02) comp value 0.\n       01  i                pic 9(02) comp value 0.\n       01  j                pic 9(02) comp value 0.\n       01  l                pic 9(02) comp value 0.\n       01  dw               pic 9(02) comp value 0.\n       01  ws-total         pic 9(03) comp value 0.\n       01  ws-prod          pic 99.\n       01  filler redefines ws-prod.\n         03  ws-prod-tens   pic 9.\n         03  ws-prod-units  pic 9.\n       01  ws-card.\n         03  filler           occurs 16 times depending on maxlen.\n           05  ws-card-ch     pic x(01).\n           05  ws-card-digit redefines ws-card-ch  pic 9(01).\n       LINKAGE SECTION.\n       01  inp-card.\n         03  inp-card-ch      pic x(01) occurs 20 times.\n       01  ws-result          pic 9(01).\n         88  pass-luhn-test             value 0.\n\n       PROCEDURE DIVISION using inp-card, ws-result.\n           perform varying i from 1 by +1\n           until i > maxlen\n           or    inp-card-ch (i) = space\n           end-perform\n           compute l = i - 1\n           compute inplen = l\n           perform varying j from 1 by +1\n           until j > inplen\n             if l < 1\n               move \"0\"             to ws-card-ch (j)\n             else\n               move inp-card-ch (l) to ws-card-ch (j)\n               compute l = l - 1\n             end-if\n           end-perform\n           move 0 to ws-total\n           perform varying i from 1 by +1\n           until i > inplen\n             compute dw = 2 - (i - 2 * function integer (i / 2))\n             compute ws-prod = ws-card-digit (i) * dw\n             compute ws-total = ws-total\n                              + ws-prod-tens\n                              + ws-prod-units\n           end-perform\n           compute ws-result = ws-total - 10 * function integer (ws-total / 10)\n           goback\n           .\n       END PROGRAM LUHN.\n", "target": "public class Luhn {\n    public static void main(String[] args) {\n        System.out.println(luhnTest(\"49927398716\"));\n        System.out.println(luhnTest(\"49927398717\"));\n        System.out.println(luhnTest(\"1234567812345678\"));\n        System.out.println(luhnTest(\"1234567812345670\"));\n    }\n    \n    public static boolean luhnTest(String number){\n        int s1 = 0, s2 = 0;\n        String reverse = new StringBuffer(number).reverse().toString();\n        for(int i = 0 ;i < reverse.length();i++){\n            int digit = Character.digit(reverse.charAt(i), 10);\n            if(i % 2 == 0){\n                s1 += digit;\n            }else{\n                s2 += 2 * digit;\n                if(digit >= 5){\n                    s2 -= 9;\n                }\n            }\n        }\n        return (s1 + s2) % 10 == 0;\n    }\n}\n"}
{"id": 77406, "name": "Luhn test of credit card numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  LUHNTEST.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       data division.\n       WORKING-STORAGE SECTION.\n       01  inp-card.\n         03  inp-card-ch      pic x(01) occurs 20 times.\n       01  ws-result          pic 9(01).\n         88  pass-luhn-test             value 0.\n\n       PROCEDURE DIVISION.\n           move \"49927398716\"       to inp-card\n           perform test-card\n           move \"49927398717\"       to inp-card\n           perform test-card\n           move \"1234567812345678\"  to inp-card\n           perform test-card\n           move \"1234567812345670\"  to inp-card\n           perform test-card\n           stop run\n           .\n       test-card.\n           call \"LUHN\" using inp-card, ws-result\n           if pass-luhn-test\n             display \"input=\" inp-card \"pass\"\n           else\n             display \"input=\" inp-card \"fail\"\n           .\n\n       END PROGRAM LUHNTEST.\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  LUHN.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  maxlen           pic 9(02) comp value 16.\n       01  inplen           pic 9(02) comp value 0.\n       01  i                pic 9(02) comp value 0.\n       01  j                pic 9(02) comp value 0.\n       01  l                pic 9(02) comp value 0.\n       01  dw               pic 9(02) comp value 0.\n       01  ws-total         pic 9(03) comp value 0.\n       01  ws-prod          pic 99.\n       01  filler redefines ws-prod.\n         03  ws-prod-tens   pic 9.\n         03  ws-prod-units  pic 9.\n       01  ws-card.\n         03  filler           occurs 16 times depending on maxlen.\n           05  ws-card-ch     pic x(01).\n           05  ws-card-digit redefines ws-card-ch  pic 9(01).\n       LINKAGE SECTION.\n       01  inp-card.\n         03  inp-card-ch      pic x(01) occurs 20 times.\n       01  ws-result          pic 9(01).\n         88  pass-luhn-test             value 0.\n\n       PROCEDURE DIVISION using inp-card, ws-result.\n           perform varying i from 1 by +1\n           until i > maxlen\n           or    inp-card-ch (i) = space\n           end-perform\n           compute l = i - 1\n           compute inplen = l\n           perform varying j from 1 by +1\n           until j > inplen\n             if l < 1\n               move \"0\"             to ws-card-ch (j)\n             else\n               move inp-card-ch (l) to ws-card-ch (j)\n               compute l = l - 1\n             end-if\n           end-perform\n           move 0 to ws-total\n           perform varying i from 1 by +1\n           until i > inplen\n             compute dw = 2 - (i - 2 * function integer (i / 2))\n             compute ws-prod = ws-card-digit (i) * dw\n             compute ws-total = ws-total\n                              + ws-prod-tens\n                              + ws-prod-units\n           end-perform\n           compute ws-result = ws-total - 10 * function integer (ws-total / 10)\n           goback\n           .\n       END PROGRAM LUHN.\n", "target": ">>> def luhn(n):\n\tr = [int(ch) for ch in str(n)][::-1]\n\treturn (sum(r[0::2]) + sum(sum(divmod(d*2,10)) for d in r[1::2])) % 10 == 0\n\n>>> for n in (49927398716, 49927398717, 1234567812345678, 1234567812345670):\n\tprint(n, luhn(n))\n"}
{"id": 77684, "name": "Sorting algorithms_Quicksort", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. quicksort RECURSIVE.\n       \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                   PIC S9(8).\n       \n       01  pivot                  PIC S9(8).\n       \n       01  left-most-idx          PIC 9(5).\n       01  right-most-idx         PIC 9(5).\n       \n       01  left-idx               PIC 9(5).\n       01  right-idx              PIC 9(5).\n       \n       LINKAGE SECTION.\n       78  Arr-Length             VALUE 50.\n       \n       01  arr-area.\n           03  arr                PIC S9(8) OCCURS Arr-Length TIMES.\n           \n       01  left-val               PIC 9(5).\n       01  right-val              PIC 9(5).  \n       \n       PROCEDURE DIVISION USING REFERENCE arr-area, OPTIONAL left-val,\n               OPTIONAL right-val.\n           IF left-val IS OMITTED OR right-val IS OMITTED\n               MOVE 1 TO left-most-idx, left-idx\n               MOVE Arr-Length TO right-most-idx, right-idx\n           ELSE\n               MOVE left-val TO left-most-idx, left-idx\n               MOVE right-val TO right-most-idx, right-idx\n           END-IF\n           \n           IF right-most-idx - left-most-idx < 1\n               GOBACK\n           END-IF\n       \n           COMPUTE pivot = arr ((left-most-idx + right-most-idx) / 2)\n       \n           PERFORM UNTIL left-idx > right-idx\n               PERFORM VARYING left-idx FROM left-idx BY 1\n                   UNTIL arr (left-idx) >= pivot\n               END-PERFORM\n               \n               PERFORM VARYING right-idx FROM right-idx BY -1\n                   UNTIL arr (right-idx) <= pivot\n               END-PERFORM\n               \n               IF left-idx <= right-idx\n                   MOVE arr (left-idx) TO temp\n                   MOVE arr (right-idx) TO arr (left-idx)\n                   MOVE temp TO arr (right-idx)\n                   \n                   ADD 1 TO left-idx\n                   SUBTRACT 1 FROM right-idx\n               END-IF\n           END-PERFORM\n       \n           CALL \"quicksort\" USING REFERENCE arr-area,\n               CONTENT left-most-idx, right-idx\n           CALL \"quicksort\" USING REFERENCE arr-area, CONTENT left-idx,\n               right-most-idx\n               \n           GOBACK\n           .\n", "target": "\n\n\n\n\n#define Tripartite\n\nnamespace RosettaCode {\n  using System;\n  using System.Diagnostics;\n\n  public class QuickSort<T> where T : IComparable {\n    #region Constants\n    public const UInt32 INSERTION_LIMIT_DEFAULT = 12;\n    private const Int32 SAMPLES_MAX = 19;\n    #endregion\n\n    #region Properties\n    public UInt32 InsertionLimit { get; }\n    private T[] Samples { get; }\n    private Int32 Left { get; set; }\n    private Int32 Right { get; set; }\n    private Int32 LeftMedian { get; set; }\n    private Int32 RightMedian { get; set; }\n    #endregion\n\n    #region Constructors\n    public QuickSort(UInt32 insertionLimit = INSERTION_LIMIT_DEFAULT) {\n      this.InsertionLimit = insertionLimit;\n      this.Samples = new T[SAMPLES_MAX];\n    }\n    #endregion\n\n    #region Sort Methods\n    public void Sort(T[] entries) {\n      Sort(entries, 0, entries.Length - 1);\n    }\n\n    public void Sort(T[] entries, Int32 first, Int32 last) {\n      var length = last + 1 - first;\n      while (length > 1) {\n        if (length < InsertionLimit) {\n          InsertionSort<T>.Sort(entries, first, last);\n          return;\n        }\n\n        Left = first;\n        Right = last;\n        var median = pivot(entries);\n        partition(median, entries);\n        \n\n        var leftLength = Right + 1 - first;\n        var rightLength = last + 1 - Left;\n\n        \n        \n        \n        \n        if (leftLength < rightLength) {\n          Sort(entries, first, Right);\n          first = Left;\n          length = rightLength;\n        }\n        else {\n          Sort(entries, Left, last);\n          last = Right;\n          length = leftLength;\n        }\n      }\n    }\n\n    \n    private static Int32 sampleSize(Int32 length, Int32 max = SAMPLES_MAX) {\n      var logLen = (Int32)Math.Log10(length);\n      var samples = Math.Min(2 * logLen + 1, max);\n      return Math.Min(samples, length);\n    }\n\n    \n    \n    private T pivot(T[] entries) {\n      var length = Right + 1 - Left;\n      var samples = sampleSize(length);\n      \n      for (var sample = 0; sample < samples; sample++) {\n        \n        var index = (Int64)length * sample / samples + Left;\n        Samples[sample] = entries[index];\n      }\n\n      InsertionSort<T>.Sort(Samples, 0, samples - 1);\n      return Samples[samples / 2];\n    }\n\n    private void partition(T median, T[] entries) {\n      var first = Left;\n      var last = Right;\n#if Tripartite\n      LeftMedian = first;\n      RightMedian = last;\n#endif\n      while (true) {\n        \n        \n        \n        while (median.CompareTo(entries[Left]) > 0) Left++;\n        while (median.CompareTo(entries[Right]) < 0) Right--;\n\n        \n        if (Right <= Left) break;\n\n        Swap(entries, Left, Right);\n        swapOut(median, entries);\n        Left++;\n        Right--;\n        \n      }\n\n      if (Left == Right) {\n        Left++;\n        Right--;\n      }\n      \n      swapIn(entries, first, last);\n\n      \n      \n    }\n    #endregion\n\n    #region Swap Methods\n    [Conditional(\"Tripartite\")]\n    private void swapOut(T median, T[] entries) {\n      if (median.CompareTo(entries[Left]) == 0) Swap(entries, LeftMedian++, Left);\n      if (median.CompareTo(entries[Right]) == 0) Swap(entries, Right, RightMedian--);\n    }\n\n    [Conditional(\"Tripartite\")]\n    private void swapIn(T[] entries, Int32 first, Int32 last) {\n      \n      while (first < LeftMedian) Swap(entries, first++, Right--);\n      while (RightMedian < last) Swap(entries, Left++, last--);\n    }\n\n    \n    public void Swap(T[] entries, Int32 left, Int32 right) {\n      Swap(ref entries[left], ref entries[right]);\n    }\n\n    \n    public static void Swap(ref T e1, ref T e2) {\n      var e = e1;\n      e1 = e2;\n      e2 = e;\n    }\n    #endregion\n  }\n\n  #region Insertion Sort\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var next = first + 1; next <= last; next++)\n        insert(entries, first, next);\n    }\n\n    \n    private static void insert(T[] entries, Int32 first, Int32 next) {\n      var entry = entries[next];\n      while (next > first && entries[next - 1].CompareTo(entry) > 0)\n        entries[next] = entries[--next];\n      entries[next] = entry;\n    }\n  }\n  #endregion\n}\n"}
{"id": 77686, "name": "Sorting algorithms_Quicksort", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. quicksort RECURSIVE.\n       \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                   PIC S9(8).\n       \n       01  pivot                  PIC S9(8).\n       \n       01  left-most-idx          PIC 9(5).\n       01  right-most-idx         PIC 9(5).\n       \n       01  left-idx               PIC 9(5).\n       01  right-idx              PIC 9(5).\n       \n       LINKAGE SECTION.\n       78  Arr-Length             VALUE 50.\n       \n       01  arr-area.\n           03  arr                PIC S9(8) OCCURS Arr-Length TIMES.\n           \n       01  left-val               PIC 9(5).\n       01  right-val              PIC 9(5).  \n       \n       PROCEDURE DIVISION USING REFERENCE arr-area, OPTIONAL left-val,\n               OPTIONAL right-val.\n           IF left-val IS OMITTED OR right-val IS OMITTED\n               MOVE 1 TO left-most-idx, left-idx\n               MOVE Arr-Length TO right-most-idx, right-idx\n           ELSE\n               MOVE left-val TO left-most-idx, left-idx\n               MOVE right-val TO right-most-idx, right-idx\n           END-IF\n           \n           IF right-most-idx - left-most-idx < 1\n               GOBACK\n           END-IF\n       \n           COMPUTE pivot = arr ((left-most-idx + right-most-idx) / 2)\n       \n           PERFORM UNTIL left-idx > right-idx\n               PERFORM VARYING left-idx FROM left-idx BY 1\n                   UNTIL arr (left-idx) >= pivot\n               END-PERFORM\n               \n               PERFORM VARYING right-idx FROM right-idx BY -1\n                   UNTIL arr (right-idx) <= pivot\n               END-PERFORM\n               \n               IF left-idx <= right-idx\n                   MOVE arr (left-idx) TO temp\n                   MOVE arr (right-idx) TO arr (left-idx)\n                   MOVE temp TO arr (right-idx)\n                   \n                   ADD 1 TO left-idx\n                   SUBTRACT 1 FROM right-idx\n               END-IF\n           END-PERFORM\n       \n           CALL \"quicksort\" USING REFERENCE arr-area,\n               CONTENT left-most-idx, right-idx\n           CALL \"quicksort\" USING REFERENCE arr-area, CONTENT left-idx,\n               right-most-idx\n               \n           GOBACK\n           .\n", "target": "public static <E extends Comparable<? super E>> List<E> quickSort(List<E> arr) {\n    if (arr.isEmpty())\n        return arr;\n    else {\n        E pivot = arr.get(0);\n\n        List<E> less = new LinkedList<E>();\n        List<E> pivotList = new LinkedList<E>();\n        List<E> more = new LinkedList<E>();\n\n        \n        for (E i: arr) {\n            if (i.compareTo(pivot) < 0)\n                less.add(i);\n            else if (i.compareTo(pivot) > 0)\n                more.add(i);\n            else\n                pivotList.add(i);\n        }\n\n        \n        less = quickSort(less);\n        more = quickSort(more);\n\n        \n        less.addAll(pivotList);\n        less.addAll(more);\n        return less;\n    }\n}\n"}
{"id": 77687, "name": "Sorting algorithms_Quicksort", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. quicksort RECURSIVE.\n       \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                   PIC S9(8).\n       \n       01  pivot                  PIC S9(8).\n       \n       01  left-most-idx          PIC 9(5).\n       01  right-most-idx         PIC 9(5).\n       \n       01  left-idx               PIC 9(5).\n       01  right-idx              PIC 9(5).\n       \n       LINKAGE SECTION.\n       78  Arr-Length             VALUE 50.\n       \n       01  arr-area.\n           03  arr                PIC S9(8) OCCURS Arr-Length TIMES.\n           \n       01  left-val               PIC 9(5).\n       01  right-val              PIC 9(5).  \n       \n       PROCEDURE DIVISION USING REFERENCE arr-area, OPTIONAL left-val,\n               OPTIONAL right-val.\n           IF left-val IS OMITTED OR right-val IS OMITTED\n               MOVE 1 TO left-most-idx, left-idx\n               MOVE Arr-Length TO right-most-idx, right-idx\n           ELSE\n               MOVE left-val TO left-most-idx, left-idx\n               MOVE right-val TO right-most-idx, right-idx\n           END-IF\n           \n           IF right-most-idx - left-most-idx < 1\n               GOBACK\n           END-IF\n       \n           COMPUTE pivot = arr ((left-most-idx + right-most-idx) / 2)\n       \n           PERFORM UNTIL left-idx > right-idx\n               PERFORM VARYING left-idx FROM left-idx BY 1\n                   UNTIL arr (left-idx) >= pivot\n               END-PERFORM\n               \n               PERFORM VARYING right-idx FROM right-idx BY -1\n                   UNTIL arr (right-idx) <= pivot\n               END-PERFORM\n               \n               IF left-idx <= right-idx\n                   MOVE arr (left-idx) TO temp\n                   MOVE arr (right-idx) TO arr (left-idx)\n                   MOVE temp TO arr (right-idx)\n                   \n                   ADD 1 TO left-idx\n                   SUBTRACT 1 FROM right-idx\n               END-IF\n           END-PERFORM\n       \n           CALL \"quicksort\" USING REFERENCE arr-area,\n               CONTENT left-most-idx, right-idx\n           CALL \"quicksort\" USING REFERENCE arr-area, CONTENT left-idx,\n               right-most-idx\n               \n           GOBACK\n           .\n", "target": "def quickSort(arr):\n    less = []\n    pivotList = []\n    more = []\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        for i in arr:\n            if i < pivot:\n                less.append(i)\n            elif i > pivot:\n                more.append(i)\n            else:\n                pivotList.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + pivotList + more\n\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\na = quickSort(a)\n"}
{"id": 77906, "name": "Date manipulation", "source": "Translate COBOL to C#:        identification division.\n       program-id. date-manipulation.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 given-date.\n          05 filler            value z\"March 7 2009 7:30pm EST\".\n       01 date-spec.\n          05 filler            value z\"%B %d %Y %I:%M%p %Z\".\n\n       01 time-struct.\n          05 tm-sec            usage binary-long.\n          05 tm-min            usage binary-long.\n          05 tm-hour           usage binary-long.\n          05 tm-mday           usage binary-long.\n          05 tm-mon            usage binary-long.\n          05 tm-year           usage binary-long.\n          05 tm-wday           usage binary-long.\n          05 tm-yday           usage binary-long.\n          05 tm-isdst          usage binary-long.\n          05 tm-gmtoff         usage binary-c-long.\n          05 tm-zone           usage pointer.\n       01 scan-index           usage pointer.\n\n       01 time-t               usage binary-c-long.\n       01 time-tm              usage pointer.\n\n       01 reform-buffer        pic x(64).\n       01 reform-length        usage binary-long.\n\n       01 current-locale       usage pointer.\n\n       01 iso-spec             constant as \"YYYY-MM-DDThh:mm:ss+hh:mm\".\n       01 iso-date             constant as \"2009-03-07T19:30:00-05:00\".\n       01 date-integer         pic 9(9).\n       01 time-integer         pic 9(9).\n       \n       procedure division.\n      \n       call \"strptime\" using\n           by reference given-date\n           by reference date-spec\n           by reference time-struct\n           returning scan-index\n           on exception\n               display \"error calling strptime\" upon syserr\n       end-call\n       display \"Given: \" given-date\n\n       if scan-index not equal null then\n           \n           call \"mktime\" using time-struct returning time-t\n           add 43200 to time-t\n           perform form-datetime\n\n           \n           set environment \"TZ\" to \"PST8PDT\"\n           call \"tzset\" returning omitted\n           perform form-datetime\n\n           \n           set environment \"TZ\" to \"GMT\"\n           call \"tzset\" returning omitted\n           perform form-datetime\n\n\n           \n           set environment \"TZ\" to \"Japan\"\n           call \"tzset\" returning omitted\n           call \"setlocale\" using by value 6 by content z\"en_HK.utf8\"\n               returning current-locale\n               on exception\n                   display \"error with setlocale\" upon syserr\n           end-call\n           move z\"%c\" to date-spec\n           perform form-datetime\n       else\n           display \"date parse error\" upon syserr\n       end-if\n\n      \n       display \"Given: \" iso-date\n       move integer-of-formatted-date(iso-spec, iso-date)\n         to date-integer\n\n       move seconds-from-formatted-time(iso-spec, iso-date)\n         to time-integer\n\n       add 43200 to time-integer\n       if time-integer greater than 86400 then\n           subtract 86400 from time-integer\n           add 1 to date-integer\n       end-if\n       display \"       \" substitute(formatted-datetime(iso-spec\n                   date-integer, time-integer, -300), \"T\", \"/\")\n\n       goback.\n\n       form-datetime.\n       call \"localtime\" using time-t returning time-tm\n       call \"strftime\" using\n           by reference reform-buffer\n           by value length(reform-buffer)\n           by reference date-spec\n           by value time-tm\n           returning reform-length\n           on exception\n               display \"error calling strftime\" upon syserr\n       end-call\n       if reform-length > 0 and <= length(reform-buffer) then\n           display \"       \" reform-buffer(1 : reform-length)\n       else\n           display \"date format error\" upon syserr\n       end-if\n       .\n       end program date-manipulation.\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        CultureInfo ci=CultureInfo.CreateSpecificCulture(\"en-US\");\n        string dateString = \"March 7 2009 7:30pm EST\";\n        string format = \"MMMM d yyyy h:mmtt z\";\n        DateTime myDateTime = DateTime.ParseExact(dateString.Replace(\"EST\",\"+6\"),format,ci) ;\n        DateTime newDateTime = myDateTime.AddHours(12).AddDays(1) ;\n        Console.WriteLine(newDateTime.ToString(format).Replace(\"-5\",\"EST\")); \n\n        Console.ReadLine();\n    }\n}\n"}
{"id": 77908, "name": "Date manipulation", "source": "Translate COBOL to Java:        identification division.\n       program-id. date-manipulation.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 given-date.\n          05 filler            value z\"March 7 2009 7:30pm EST\".\n       01 date-spec.\n          05 filler            value z\"%B %d %Y %I:%M%p %Z\".\n\n       01 time-struct.\n          05 tm-sec            usage binary-long.\n          05 tm-min            usage binary-long.\n          05 tm-hour           usage binary-long.\n          05 tm-mday           usage binary-long.\n          05 tm-mon            usage binary-long.\n          05 tm-year           usage binary-long.\n          05 tm-wday           usage binary-long.\n          05 tm-yday           usage binary-long.\n          05 tm-isdst          usage binary-long.\n          05 tm-gmtoff         usage binary-c-long.\n          05 tm-zone           usage pointer.\n       01 scan-index           usage pointer.\n\n       01 time-t               usage binary-c-long.\n       01 time-tm              usage pointer.\n\n       01 reform-buffer        pic x(64).\n       01 reform-length        usage binary-long.\n\n       01 current-locale       usage pointer.\n\n       01 iso-spec             constant as \"YYYY-MM-DDThh:mm:ss+hh:mm\".\n       01 iso-date             constant as \"2009-03-07T19:30:00-05:00\".\n       01 date-integer         pic 9(9).\n       01 time-integer         pic 9(9).\n       \n       procedure division.\n      \n       call \"strptime\" using\n           by reference given-date\n           by reference date-spec\n           by reference time-struct\n           returning scan-index\n           on exception\n               display \"error calling strptime\" upon syserr\n       end-call\n       display \"Given: \" given-date\n\n       if scan-index not equal null then\n           \n           call \"mktime\" using time-struct returning time-t\n           add 43200 to time-t\n           perform form-datetime\n\n           \n           set environment \"TZ\" to \"PST8PDT\"\n           call \"tzset\" returning omitted\n           perform form-datetime\n\n           \n           set environment \"TZ\" to \"GMT\"\n           call \"tzset\" returning omitted\n           perform form-datetime\n\n\n           \n           set environment \"TZ\" to \"Japan\"\n           call \"tzset\" returning omitted\n           call \"setlocale\" using by value 6 by content z\"en_HK.utf8\"\n               returning current-locale\n               on exception\n                   display \"error with setlocale\" upon syserr\n           end-call\n           move z\"%c\" to date-spec\n           perform form-datetime\n       else\n           display \"date parse error\" upon syserr\n       end-if\n\n      \n       display \"Given: \" iso-date\n       move integer-of-formatted-date(iso-spec, iso-date)\n         to date-integer\n\n       move seconds-from-formatted-time(iso-spec, iso-date)\n         to time-integer\n\n       add 43200 to time-integer\n       if time-integer greater than 86400 then\n           subtract 86400 from time-integer\n           add 1 to date-integer\n       end-if\n       display \"       \" substitute(formatted-datetime(iso-spec\n                   date-integer, time-integer, -300), \"T\", \"/\")\n\n       goback.\n\n       form-datetime.\n       call \"localtime\" using time-t returning time-tm\n       call \"strftime\" using\n           by reference reform-buffer\n           by value length(reform-buffer)\n           by reference date-spec\n           by value time-tm\n           returning reform-length\n           on exception\n               display \"error calling strftime\" upon syserr\n       end-call\n       if reform-length > 0 and <= length(reform-buffer) then\n           display \"       \" reform-buffer(1 : reform-length)\n       else\n           display \"date format error\" upon syserr\n       end-if\n       .\n       end program date-manipulation.\n", "target": "import java.time.*;\nimport java.time.format.*;\n\nclass Main {  \n  public static void main(String args[]) { \n    String dateStr = \"March 7 2009 7:30pm EST\";\n\n    DateTimeFormatter df = new DateTimeFormatterBuilder()\n\t\t\t\t.parseCaseInsensitive()\n\t\t\t\t.appendPattern(\"MMMM d yyyy h:mma zzz\")\n\t\t\t\t.toFormatter();\n\t\t\n    ZonedDateTime after12Hours = ZonedDateTime.parse(dateStr, df).plusHours(12);\n  \n    System.out.println(\"Date: \" + dateStr);\n    System.out.println(\"+12h: \" + after12Hours.format(df));\n\n    ZonedDateTime after12HoursInCentralEuropeTime = after12Hours.withZoneSameInstant(ZoneId.of(\"CET\"));\n    System.out.println(\"+12h (in Central Europe): \" + after12HoursInCentralEuropeTime.format(df));\n  }\n}\n"}
{"id": 77909, "name": "Date manipulation", "source": "Translate COBOL to Python:        identification division.\n       program-id. date-manipulation.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 given-date.\n          05 filler            value z\"March 7 2009 7:30pm EST\".\n       01 date-spec.\n          05 filler            value z\"%B %d %Y %I:%M%p %Z\".\n\n       01 time-struct.\n          05 tm-sec            usage binary-long.\n          05 tm-min            usage binary-long.\n          05 tm-hour           usage binary-long.\n          05 tm-mday           usage binary-long.\n          05 tm-mon            usage binary-long.\n          05 tm-year           usage binary-long.\n          05 tm-wday           usage binary-long.\n          05 tm-yday           usage binary-long.\n          05 tm-isdst          usage binary-long.\n          05 tm-gmtoff         usage binary-c-long.\n          05 tm-zone           usage pointer.\n       01 scan-index           usage pointer.\n\n       01 time-t               usage binary-c-long.\n       01 time-tm              usage pointer.\n\n       01 reform-buffer        pic x(64).\n       01 reform-length        usage binary-long.\n\n       01 current-locale       usage pointer.\n\n       01 iso-spec             constant as \"YYYY-MM-DDThh:mm:ss+hh:mm\".\n       01 iso-date             constant as \"2009-03-07T19:30:00-05:00\".\n       01 date-integer         pic 9(9).\n       01 time-integer         pic 9(9).\n       \n       procedure division.\n      \n       call \"strptime\" using\n           by reference given-date\n           by reference date-spec\n           by reference time-struct\n           returning scan-index\n           on exception\n               display \"error calling strptime\" upon syserr\n       end-call\n       display \"Given: \" given-date\n\n       if scan-index not equal null then\n           \n           call \"mktime\" using time-struct returning time-t\n           add 43200 to time-t\n           perform form-datetime\n\n           \n           set environment \"TZ\" to \"PST8PDT\"\n           call \"tzset\" returning omitted\n           perform form-datetime\n\n           \n           set environment \"TZ\" to \"GMT\"\n           call \"tzset\" returning omitted\n           perform form-datetime\n\n\n           \n           set environment \"TZ\" to \"Japan\"\n           call \"tzset\" returning omitted\n           call \"setlocale\" using by value 6 by content z\"en_HK.utf8\"\n               returning current-locale\n               on exception\n                   display \"error with setlocale\" upon syserr\n           end-call\n           move z\"%c\" to date-spec\n           perform form-datetime\n       else\n           display \"date parse error\" upon syserr\n       end-if\n\n      \n       display \"Given: \" iso-date\n       move integer-of-formatted-date(iso-spec, iso-date)\n         to date-integer\n\n       move seconds-from-formatted-time(iso-spec, iso-date)\n         to time-integer\n\n       add 43200 to time-integer\n       if time-integer greater than 86400 then\n           subtract 86400 from time-integer\n           add 1 to date-integer\n       end-if\n       display \"       \" substitute(formatted-datetime(iso-spec\n                   date-integer, time-integer, -300), \"T\", \"/\")\n\n       goback.\n\n       form-datetime.\n       call \"localtime\" using time-t returning time-tm\n       call \"strftime\" using\n           by reference reform-buffer\n           by value length(reform-buffer)\n           by reference date-spec\n           by value time-tm\n           returning reform-length\n           on exception\n               display \"error calling strftime\" upon syserr\n       end-call\n       if reform-length > 0 and <= length(reform-buffer) then\n           display \"       \" reform-buffer(1 : reform-length)\n       else\n           display \"date format error\" upon syserr\n       end-if\n       .\n       end program date-manipulation.\n", "target": "import datetime\n\ndef mt():\n\tdatime1=\"March 7 2009 7:30pm EST\"\n\tformatting = \"%B %d %Y %I:%M%p \"\n\tdatime2 = datime1[:-3]  \n\ttdelta = datetime.timedelta(hours=12)\t\t\n\ts3 = datetime.datetime.strptime(datime2, formatting)\n\tdatime2 = s3+tdelta\n\tprint datime2.strftime(\"%B %d %Y %I:%M%p %Z\") + datime1[-3:]\n\nmt()\n"}
{"id": 78188, "name": "Rot-13", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. rot-13.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       78  STR-LENGTH   VALUE 100.\n \n       78  normal-lower VALUE \"abcdefghijklmnopqrstuvwxyz\".\n       78  rot13-lower  VALUE \"nopqrstuvwxyzabcdefghijklm\".\n\n       78  normal-upper VALUE \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n       78  rot13-upper  VALUE \"NOPQRSTUVWXYZABCDEFGHIJKLM\".\n\n       LINKAGE SECTION.\n       01  in-str       PIC X(STR-LENGTH).\n       01  out-str      PIC X(STR-LENGTH).\n\n       PROCEDURE DIVISION USING VALUE in-str, REFERENCE out-str.\n           MOVE in-str TO out-str\n\n           INSPECT out-str CONVERTING normal-lower TO rot13-lower\n           INSPECT out-str CONVERTING normal-upper TO rot13-upper\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nclass Program\n{\n    static char Rot13(char c)\n    {\n        if ('a' <= c && c <= 'm' || 'A' <= c && c <= 'M')\n        {\n            return (char)(c + 13);\n        }\n        if ('n' <= c && c <= 'z' || 'N' <= c && c <= 'Z')\n        {\n            return (char)(c - 13);\n        }\n        return c;\n    }\n\n    static string Rot13(string s)\n    {\n        return new string(s.Select(Rot13).ToArray());\n    }\n\n\n    static void Main(string[] args)\n    {\n        foreach (var file in args.Where(file => File.Exists(file)))\n        {\n            Console.WriteLine(Rot13(File.ReadAllText(file)));\n        }\n        if (!args.Any())\n        {\n            Console.WriteLine(Rot13(Console.In.ReadToEnd()));\n        }\n    }\n}\n"}
{"id": 78190, "name": "Rot-13", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. rot-13.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       78  STR-LENGTH   VALUE 100.\n \n       78  normal-lower VALUE \"abcdefghijklmnopqrstuvwxyz\".\n       78  rot13-lower  VALUE \"nopqrstuvwxyzabcdefghijklm\".\n\n       78  normal-upper VALUE \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n       78  rot13-upper  VALUE \"NOPQRSTUVWXYZABCDEFGHIJKLM\".\n\n       LINKAGE SECTION.\n       01  in-str       PIC X(STR-LENGTH).\n       01  out-str      PIC X(STR-LENGTH).\n\n       PROCEDURE DIVISION USING VALUE in-str, REFERENCE out-str.\n           MOVE in-str TO out-str\n\n           INSPECT out-str CONVERTING normal-lower TO rot13-lower\n           INSPECT out-str CONVERTING normal-upper TO rot13-upper\n\n           GOBACK\n           .\n", "target": "import java.io.*;\n\npublic class Rot13 {\n\n    public static void main(String[] args) throws IOException {\n        if (args.length >= 1) {\n            for (String file : args) {\n                try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {\n                    rot13(in, System.out);\n                }\n            }\n        } else {\n            rot13(System.in, System.out);\n        }\n    }\n\n    private static void rot13(InputStream in, OutputStream out) throws IOException {\n        int ch;\n        while ((ch = in.read()) != -1) {\n            out.write(rot13((char) ch));\n        }\n    }\n\n    private static char rot13(char ch) {\n        if (ch >= 'A' && ch <= 'Z') {\n            return (char) (((ch - 'A') + 13) % 26 + 'A');\n        }\n        if (ch >= 'a' && ch <= 'z') {\n            return (char) (((ch - 'a') + 13) % 26 + 'a');\n        }\n        return ch;\n    }\n}\n"}
{"id": 78191, "name": "Rot-13", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. rot-13.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       78  STR-LENGTH   VALUE 100.\n \n       78  normal-lower VALUE \"abcdefghijklmnopqrstuvwxyz\".\n       78  rot13-lower  VALUE \"nopqrstuvwxyzabcdefghijklm\".\n\n       78  normal-upper VALUE \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n       78  rot13-upper  VALUE \"NOPQRSTUVWXYZABCDEFGHIJKLM\".\n\n       LINKAGE SECTION.\n       01  in-str       PIC X(STR-LENGTH).\n       01  out-str      PIC X(STR-LENGTH).\n\n       PROCEDURE DIVISION USING VALUE in-str, REFERENCE out-str.\n           MOVE in-str TO out-str\n\n           INSPECT out-str CONVERTING normal-lower TO rot13-lower\n           INSPECT out-str CONVERTING normal-upper TO rot13-upper\n\n           GOBACK\n           .\n", "target": ">>> u'foo'.encode('rot13')\n'sbb'\n>>> 'sbb'.decode('rot13')\nu'foo'\n"}
{"id": 78698, "name": "Write float arrays to a text file", "source": "Translate COBOL to C#:        identification division.\n       program-id. wr-float.\n       environment division.\n       input-output section.\n       file-control.\n           select report-file assign \"float.txt\"\n               organization sequential.\n       data division.\n       file section.\n       fd report-file\n           report is floats.\n       working-storage section.\n       1 i binary pic 9(4).\n       1 x-values comp-2.\n        2 value 1.0.\n        2 value 2.0.\n        2 value 3.0.\n        2 value 1.0e11.\n       1 redefines x-values comp-2.\n        2 x occurs 4.\n       1 comp-2.\n        2 y occurs 4.\n       report section.\n       rd floats.\n       1 float-line type de.\n        2 line plus 1.\n         3 column 1 pic -9.99e+99 source x(i).\n         2 column 12 pic -9.9999e+99 source y(i).\n       procedure division.\n       begin.\n           open output report-file\n           initiate floats\n           perform varying i from 1 by 1\n           until i > 4\n               compute y(i) = function sqrt (x(i))\n               generate float-line\n           end-perform\n           terminate floats\n           close report-file\n           stop run\n           .\n       end program wr-float.\n", "target": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var x = new double[] { 1, 2, 3, 1e11 };\n        var y = new double[] { 1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791 };\n\n        int xprecision = 3;\n        int yprecision = 5;\n\n        string formatString = \"{0:G\" + xprecision + \"}\\t{1:G\" + yprecision + \"}\";\n\n        using (var outf = new StreamWriter(\"FloatArrayColumns.txt\"))\n            for (int i = 0; i < x.Length; i++)\n                outf.WriteLine(formatString, x[i], y[i]);\n    }\n}\n"}
{"id": 78699, "name": "Write float arrays to a text file", "source": "Translate COBOL to C#:        identification division.\n       program-id. wr-float.\n       environment division.\n       input-output section.\n       file-control.\n           select report-file assign \"float.txt\"\n               organization sequential.\n       data division.\n       file section.\n       fd report-file\n           report is floats.\n       working-storage section.\n       1 i binary pic 9(4).\n       1 x-values comp-2.\n        2 value 1.0.\n        2 value 2.0.\n        2 value 3.0.\n        2 value 1.0e11.\n       1 redefines x-values comp-2.\n        2 x occurs 4.\n       1 comp-2.\n        2 y occurs 4.\n       report section.\n       rd floats.\n       1 float-line type de.\n        2 line plus 1.\n         3 column 1 pic -9.99e+99 source x(i).\n         2 column 12 pic -9.9999e+99 source y(i).\n       procedure division.\n       begin.\n           open output report-file\n           initiate floats\n           perform varying i from 1 by 1\n           until i > 4\n               compute y(i) = function sqrt (x(i))\n               generate float-line\n           end-perform\n           terminate floats\n           close report-file\n           stop run\n           .\n       end program wr-float.\n", "target": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var x = new double[] { 1, 2, 3, 1e11 };\n        var y = new double[] { 1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791 };\n\n        int xprecision = 3;\n        int yprecision = 5;\n\n        string formatString = \"{0:G\" + xprecision + \"}\\t{1:G\" + yprecision + \"}\";\n\n        using (var outf = new StreamWriter(\"FloatArrayColumns.txt\"))\n            for (int i = 0; i < x.Length; i++)\n                outf.WriteLine(formatString, x[i], y[i]);\n    }\n}\n"}
{"id": 78702, "name": "Write float arrays to a text file", "source": "Translate COBOL to Java:        identification division.\n       program-id. wr-float.\n       environment division.\n       input-output section.\n       file-control.\n           select report-file assign \"float.txt\"\n               organization sequential.\n       data division.\n       file section.\n       fd report-file\n           report is floats.\n       working-storage section.\n       1 i binary pic 9(4).\n       1 x-values comp-2.\n        2 value 1.0.\n        2 value 2.0.\n        2 value 3.0.\n        2 value 1.0e11.\n       1 redefines x-values comp-2.\n        2 x occurs 4.\n       1 comp-2.\n        2 y occurs 4.\n       report section.\n       rd floats.\n       1 float-line type de.\n        2 line plus 1.\n         3 column 1 pic -9.99e+99 source x(i).\n         2 column 12 pic -9.9999e+99 source y(i).\n       procedure division.\n       begin.\n           open output report-file\n           initiate floats\n           perform varying i from 1 by 1\n           until i > 4\n               compute y(i) = function sqrt (x(i))\n               generate float-line\n           end-perform\n           terminate floats\n           close report-file\n           stop run\n           .\n       end program wr-float.\n", "target": "import java.io.*;\n\npublic class FloatArray {\n    public static void writeDat(String filename, double[] x, double[] y,\n                                int xprecision, int yprecision)\n        throws IOException {\n        assert x.length == y.length;\n        PrintWriter out = new PrintWriter(filename);\n        for (int i = 0; i < x.length; i++)\n            out.printf(\"%.\"+xprecision+\"g\\t%.\"+yprecision+\"g\\n\", x[i], y[i]);\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        double[] x = {1, 2, 3, 1e11};\n        double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++)\n            y[i] = Math.sqrt(x[i]);\n        \n        try {\n            writeDat(\"sqrt.dat\", x, y, 3, 5);\n        } catch (IOException e) {\n            System.err.println(\"writeDat: exception: \"+e);\n        }\n\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(\"sqrt.dat\"));\n            String line;\n            while ((line = br.readLine()) != null)\n                System.out.println(line);\n        } catch (IOException e) { }\n    }\n}\n"}
{"id": 78703, "name": "Write float arrays to a text file", "source": "Translate COBOL to Java:        identification division.\n       program-id. wr-float.\n       environment division.\n       input-output section.\n       file-control.\n           select report-file assign \"float.txt\"\n               organization sequential.\n       data division.\n       file section.\n       fd report-file\n           report is floats.\n       working-storage section.\n       1 i binary pic 9(4).\n       1 x-values comp-2.\n        2 value 1.0.\n        2 value 2.0.\n        2 value 3.0.\n        2 value 1.0e11.\n       1 redefines x-values comp-2.\n        2 x occurs 4.\n       1 comp-2.\n        2 y occurs 4.\n       report section.\n       rd floats.\n       1 float-line type de.\n        2 line plus 1.\n         3 column 1 pic -9.99e+99 source x(i).\n         2 column 12 pic -9.9999e+99 source y(i).\n       procedure division.\n       begin.\n           open output report-file\n           initiate floats\n           perform varying i from 1 by 1\n           until i > 4\n               compute y(i) = function sqrt (x(i))\n               generate float-line\n           end-perform\n           terminate floats\n           close report-file\n           stop run\n           .\n       end program wr-float.\n", "target": "import java.io.*;\n\npublic class FloatArray {\n    public static void writeDat(String filename, double[] x, double[] y,\n                                int xprecision, int yprecision)\n        throws IOException {\n        assert x.length == y.length;\n        PrintWriter out = new PrintWriter(filename);\n        for (int i = 0; i < x.length; i++)\n            out.printf(\"%.\"+xprecision+\"g\\t%.\"+yprecision+\"g\\n\", x[i], y[i]);\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        double[] x = {1, 2, 3, 1e11};\n        double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++)\n            y[i] = Math.sqrt(x[i]);\n        \n        try {\n            writeDat(\"sqrt.dat\", x, y, 3, 5);\n        } catch (IOException e) {\n            System.err.println(\"writeDat: exception: \"+e);\n        }\n\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(\"sqrt.dat\"));\n            String line;\n            while ((line = br.readLine()) != null)\n                System.out.println(line);\n        } catch (IOException e) { }\n    }\n}\n"}
{"id": 78704, "name": "Write float arrays to a text file", "source": "Translate COBOL to Python:        identification division.\n       program-id. wr-float.\n       environment division.\n       input-output section.\n       file-control.\n           select report-file assign \"float.txt\"\n               organization sequential.\n       data division.\n       file section.\n       fd report-file\n           report is floats.\n       working-storage section.\n       1 i binary pic 9(4).\n       1 x-values comp-2.\n        2 value 1.0.\n        2 value 2.0.\n        2 value 3.0.\n        2 value 1.0e11.\n       1 redefines x-values comp-2.\n        2 x occurs 4.\n       1 comp-2.\n        2 y occurs 4.\n       report section.\n       rd floats.\n       1 float-line type de.\n        2 line plus 1.\n         3 column 1 pic -9.99e+99 source x(i).\n         2 column 12 pic -9.9999e+99 source y(i).\n       procedure division.\n       begin.\n           open output report-file\n           initiate floats\n           perform varying i from 1 by 1\n           until i > 4\n               compute y(i) = function sqrt (x(i))\n               generate float-line\n           end-perform\n           terminate floats\n           close report-file\n           stop run\n           .\n       end program wr-float.\n", "target": "import itertools\ndef writedat(filename, x, y, xprecision=3, yprecision=5):\n    with open(filename,'w') as f:\n        for a, b in itertools.izip(x, y):\n            print >> f, \"%.*g\\t%.*g\" % (xprecision, a, yprecision, b)\n"}
{"id": 78705, "name": "Write float arrays to a text file", "source": "Translate COBOL to Python:        identification division.\n       program-id. wr-float.\n       environment division.\n       input-output section.\n       file-control.\n           select report-file assign \"float.txt\"\n               organization sequential.\n       data division.\n       file section.\n       fd report-file\n           report is floats.\n       working-storage section.\n       1 i binary pic 9(4).\n       1 x-values comp-2.\n        2 value 1.0.\n        2 value 2.0.\n        2 value 3.0.\n        2 value 1.0e11.\n       1 redefines x-values comp-2.\n        2 x occurs 4.\n       1 comp-2.\n        2 y occurs 4.\n       report section.\n       rd floats.\n       1 float-line type de.\n        2 line plus 1.\n         3 column 1 pic -9.99e+99 source x(i).\n         2 column 12 pic -9.9999e+99 source y(i).\n       procedure division.\n       begin.\n           open output report-file\n           initiate floats\n           perform varying i from 1 by 1\n           until i > 4\n               compute y(i) = function sqrt (x(i))\n               generate float-line\n           end-perform\n           terminate floats\n           close report-file\n           stop run\n           .\n       end program wr-float.\n", "target": "import itertools\ndef writedat(filename, x, y, xprecision=3, yprecision=5):\n    with open(filename,'w') as f:\n        for a, b in itertools.izip(x, y):\n            print >> f, \"%.*g\\t%.*g\" % (xprecision, a, yprecision, b)\n"}
{"id": 79477, "name": "Sum multiples of 3 and 5", "source": "Translate COBOL to C#: Identification division.\nProgram-id. three-five-sum.\n\nData division.\nWorking-storage section.\n01 ws-the-limit  pic 9(18) value 1000.\n01 ws-the-number pic 9(18).\n01 ws-the-sum    pic 9(18).\n01 ws-sum-out    pic z(18).\n\nProcedure division.\nMain-program.\n    Perform Do-sum\n        varying ws-the-number from 1 by 1 \n        until ws-the-number = ws-the-limit.\n    Move ws-the-sum to ws-sum-out.\n    Display \"Sum = \" ws-sum-out.\n    End-run.\n\nDo-sum.\n    If function mod(ws-the-number, 3) = zero\n       or function mod(ws-the-number, 5) = zero\n       then add ws-the-number to ws-the-sum.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            List<BigInteger> candidates = new List<BigInteger>(new BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });\n            candidates.Add(BigInteger.Parse(\"100000000000000000000\"));\n\n            foreach (BigInteger candidate in candidates)\n            {\n                BigInteger c = candidate - 1;\n                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);\n                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);\n                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);\n\n                Console.WriteLine(\"The sum of numbers divisible by 3 or 5 between 1 and {0} is {1}\", c, answer3 + answer5 - answer15);\n            }\n\n            Console.ReadKey(true);\n        }\n\n        private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)\n        {\n            BigInteger largest = candidate;\n            while (largest % n > 0)\n                largest--;\n            BigInteger totalCount = (largest / n);\n            BigInteger pairCount = totalCount / 2;\n            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);\n            BigInteger pairSum = largest + n;\n            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);\n        }\n\n    }\n}\n"}
{"id": 79478, "name": "Sum multiples of 3 and 5", "source": "Translate COBOL to C#: Identification division.\nProgram-id. three-five-sum.\n\nData division.\nWorking-storage section.\n01 ws-the-limit  pic 9(18) value 1000.\n01 ws-the-number pic 9(18).\n01 ws-the-sum    pic 9(18).\n01 ws-sum-out    pic z(18).\n\nProcedure division.\nMain-program.\n    Perform Do-sum\n        varying ws-the-number from 1 by 1 \n        until ws-the-number = ws-the-limit.\n    Move ws-the-sum to ws-sum-out.\n    Display \"Sum = \" ws-sum-out.\n    End-run.\n\nDo-sum.\n    If function mod(ws-the-number, 3) = zero\n       or function mod(ws-the-number, 5) = zero\n       then add ws-the-number to ws-the-sum.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            List<BigInteger> candidates = new List<BigInteger>(new BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });\n            candidates.Add(BigInteger.Parse(\"100000000000000000000\"));\n\n            foreach (BigInteger candidate in candidates)\n            {\n                BigInteger c = candidate - 1;\n                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);\n                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);\n                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);\n\n                Console.WriteLine(\"The sum of numbers divisible by 3 or 5 between 1 and {0} is {1}\", c, answer3 + answer5 - answer15);\n            }\n\n            Console.ReadKey(true);\n        }\n\n        private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)\n        {\n            BigInteger largest = candidate;\n            while (largest % n > 0)\n                largest--;\n            BigInteger totalCount = (largest / n);\n            BigInteger pairCount = totalCount / 2;\n            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);\n            BigInteger pairSum = largest + n;\n            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);\n        }\n\n    }\n}\n"}
{"id": 79481, "name": "Sum multiples of 3 and 5", "source": "Translate COBOL to Java: Identification division.\nProgram-id. three-five-sum.\n\nData division.\nWorking-storage section.\n01 ws-the-limit  pic 9(18) value 1000.\n01 ws-the-number pic 9(18).\n01 ws-the-sum    pic 9(18).\n01 ws-sum-out    pic z(18).\n\nProcedure division.\nMain-program.\n    Perform Do-sum\n        varying ws-the-number from 1 by 1 \n        until ws-the-number = ws-the-limit.\n    Move ws-the-sum to ws-sum-out.\n    Display \"Sum = \" ws-sum-out.\n    End-run.\n\nDo-sum.\n    If function mod(ws-the-number, 3) = zero\n       or function mod(ws-the-number, 5) = zero\n       then add ws-the-number to ws-the-sum.\n", "target": "class SumMultiples {\n\tpublic static long getSum(long n) {\n\t\tlong sum = 0;\n\t\tfor (int i = 3; i < n; i++) {\n\t\t\tif (i % 3 == 0 || i % 5 == 0) sum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getSum(1000));\n\t}\n}\n"}
{"id": 79482, "name": "Sum multiples of 3 and 5", "source": "Translate COBOL to Java: Identification division.\nProgram-id. three-five-sum.\n\nData division.\nWorking-storage section.\n01 ws-the-limit  pic 9(18) value 1000.\n01 ws-the-number pic 9(18).\n01 ws-the-sum    pic 9(18).\n01 ws-sum-out    pic z(18).\n\nProcedure division.\nMain-program.\n    Perform Do-sum\n        varying ws-the-number from 1 by 1 \n        until ws-the-number = ws-the-limit.\n    Move ws-the-sum to ws-sum-out.\n    Display \"Sum = \" ws-sum-out.\n    End-run.\n\nDo-sum.\n    If function mod(ws-the-number, 3) = zero\n       or function mod(ws-the-number, 5) = zero\n       then add ws-the-number to ws-the-sum.\n", "target": "class SumMultiples {\n\tpublic static long getSum(long n) {\n\t\tlong sum = 0;\n\t\tfor (int i = 3; i < n; i++) {\n\t\t\tif (i % 3 == 0 || i % 5 == 0) sum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getSum(1000));\n\t}\n}\n"}
{"id": 79483, "name": "Sum multiples of 3 and 5", "source": "Translate COBOL to Python: Identification division.\nProgram-id. three-five-sum.\n\nData division.\nWorking-storage section.\n01 ws-the-limit  pic 9(18) value 1000.\n01 ws-the-number pic 9(18).\n01 ws-the-sum    pic 9(18).\n01 ws-sum-out    pic z(18).\n\nProcedure division.\nMain-program.\n    Perform Do-sum\n        varying ws-the-number from 1 by 1 \n        until ws-the-number = ws-the-limit.\n    Move ws-the-sum to ws-sum-out.\n    Display \"Sum = \" ws-sum-out.\n    End-run.\n\nDo-sum.\n    If function mod(ws-the-number, 3) = zero\n       or function mod(ws-the-number, 5) = zero\n       then add ws-the-number to ws-the-sum.\n", "target": "def sum35a(n):\n    'Direct count'\n    \n    return sum(x for x in range(n) if x%3==0 or x%5==0)\n\ndef sum35b(n): \n    \"Count all the 3's; all the 5's; minus double-counted 3*5's\"\n    \n    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))\n    \ndef sum35c(n):\n    'Sum the arithmetic progressions: sum3 + sum5 - sum15'\n    consts = (3, 5, 15)\n    \n    divs = [(n-1) // c for c in consts]\n    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]\n    return sums[0] + sums[1] - sums[2]\n\n\nfor n in range(1001):\n    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)\n    assert sa == sb == sc  \n\nprint('For n = %7i -> %i\\n' % (n, sc))\n\n\nfor p in range(7):\n    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))\n\n\np = 20\nprint('\\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))\n"}
{"id": 79484, "name": "Sum multiples of 3 and 5", "source": "Translate COBOL to Python: Identification division.\nProgram-id. three-five-sum.\n\nData division.\nWorking-storage section.\n01 ws-the-limit  pic 9(18) value 1000.\n01 ws-the-number pic 9(18).\n01 ws-the-sum    pic 9(18).\n01 ws-sum-out    pic z(18).\n\nProcedure division.\nMain-program.\n    Perform Do-sum\n        varying ws-the-number from 1 by 1 \n        until ws-the-number = ws-the-limit.\n    Move ws-the-sum to ws-sum-out.\n    Display \"Sum = \" ws-sum-out.\n    End-run.\n\nDo-sum.\n    If function mod(ws-the-number, 3) = zero\n       or function mod(ws-the-number, 5) = zero\n       then add ws-the-number to ws-the-sum.\n", "target": "def sum35a(n):\n    'Direct count'\n    \n    return sum(x for x in range(n) if x%3==0 or x%5==0)\n\ndef sum35b(n): \n    \"Count all the 3's; all the 5's; minus double-counted 3*5's\"\n    \n    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))\n    \ndef sum35c(n):\n    'Sum the arithmetic progressions: sum3 + sum5 - sum15'\n    consts = (3, 5, 15)\n    \n    divs = [(n-1) // c for c in consts]\n    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]\n    return sums[0] + sums[1] - sums[2]\n\n\nfor n in range(1001):\n    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)\n    assert sa == sb == sc  \n\nprint('For n = %7i -> %i\\n' % (n, sc))\n\n\nfor p in range(7):\n    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))\n\n\np = 20\nprint('\\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))\n"}
{"id": 80121, "name": "Logical operations", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. print-logic.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  result                  PIC 1 USAGE BIT.\n\n       LINKAGE SECTION.\n       01  a                       PIC 1 USAGE BIT.\n       01  b                       PIC 1 USAGE BIT.\n\n       PROCEDURE DIVISION USING a, b.\n           COMPUTE result = a B-AND b\n           DISPLAY \"a and b is \" result\n\n           COMPUTE result = a B-OR b\n           DISPLAY \"a or b is \" result\n\n           COMPUTE result = B-NOT a\n           DISPLAY \"Not a is \" result\n\n           COMPUTE result = a B-XOR b\n           DISPLAY \"a exclusive-or b is \" result\n\n           GOBACK\n           .\n", "target": "using System;\n\nnamespace LogicalOperations\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool a = true, b = false;\n            Console.WriteLine(\"a and b is {0}\", a && b);\n            Console.WriteLine(\"a or b is {0}\", a || b);\n            Console.WriteLine(\"Not a is {0}\", !a);\n            Console.WriteLine(\"a exclusive-or b is {0}\", a ^ b);\n        }\n    }\n}\n"}
{"id": 80123, "name": "Logical operations", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. print-logic.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  result                  PIC 1 USAGE BIT.\n\n       LINKAGE SECTION.\n       01  a                       PIC 1 USAGE BIT.\n       01  b                       PIC 1 USAGE BIT.\n\n       PROCEDURE DIVISION USING a, b.\n           COMPUTE result = a B-AND b\n           DISPLAY \"a and b is \" result\n\n           COMPUTE result = a B-OR b\n           DISPLAY \"a or b is \" result\n\n           COMPUTE result = B-NOT a\n           DISPLAY \"Not a is \" result\n\n           COMPUTE result = a B-XOR b\n           DISPLAY \"a exclusive-or b is \" result\n\n           GOBACK\n           .\n", "target": "boolean a = true;\nboolean b = false;\nSystem.Debug('a AND b: ' + (a && b));\nSystem.Debug('a OR b: ' + (a || b));\nSystem.Debug('NOT a: ' + (!a));\nSystem.Debug('a XOR b: ' + (a ^ b));\n"}
{"id": 80124, "name": "Logical operations", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. print-logic.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  result                  PIC 1 USAGE BIT.\n\n       LINKAGE SECTION.\n       01  a                       PIC 1 USAGE BIT.\n       01  b                       PIC 1 USAGE BIT.\n\n       PROCEDURE DIVISION USING a, b.\n           COMPUTE result = a B-AND b\n           DISPLAY \"a and b is \" result\n\n           COMPUTE result = a B-OR b\n           DISPLAY \"a or b is \" result\n\n           COMPUTE result = B-NOT a\n           DISPLAY \"Not a is \" result\n\n           COMPUTE result = a B-XOR b\n           DISPLAY \"a exclusive-or b is \" result\n\n           GOBACK\n           .\n", "target": "def logic(a, b):\n    print('a and b:', a and b)\n    print('a or b:', a or b)\n    print('not a:', not a)\n"}
{"id": 80713, "name": "Abstract type", "source": "Translate COBOL to C#:        INTERFACE-ID. Shape.\n       \n       PROCEDURE DIVISION.\n       \n       METHOD-ID. perimeter.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  ret USAGE FLOAT-LONG.\n       PROCEDURE DIVISION RETURNING ret.\n       END METHOD perimeter.\n       \n       METHOD-ID. shape-area.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  ret USAGE FLOAT-LONG.\n       PROCEDURE DIVISION RETURNING ret.\n       END METHOD shape-area.\n       \n       END INTERFACE Shape.\n       \n\n       CLASS-ID. Rectangle. \n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           INTERFACE Shape.\n       \n       OBJECT IMPLEMENTS Shape.\n           DATA DIVISION.\n           WORKING-STORAGE SECTION.\n           01  width  USAGE FLOAT-LONG PROPERTY.\n           01  height USAGE FLOAT-LONG PROPERTY.\n           \n           PROCEDURE DIVISION.\n           \n           METHOD-ID. perimeter.\n           DATA DIVISION.\n           LINKAGE SECTION.\n           01  ret USAGE FLOAT-LONG.\n           PROCEDURE DIVISION RETURNING ret.\n               COMPUTE ret = width * 2.0 + height * 2.0\n               GOBACK\n               .\n           END METHOD perimeter.\n       \n           METHOD-ID. shape-area.\n           DATA DIVISION.\n           LINKAGE SECTION.\n           01  ret USAGE FLOAT-LONG.\n           PROCEDURE DIVISION RETURNING ret.\n               COMPUTE ret = width * height\n               GOBACK\n               .\n           END METHOD shape-area.\n       END OBJECT.\n       \n       END CLASS Rectangle.\n", "target": "abstract class Class1\n{\n   public abstract void method1();\n\n   public int method2()\n   {\n      return 0;\n   }\n}\n"}
{"id": 80715, "name": "Abstract type", "source": "Translate COBOL to Java:        INTERFACE-ID. Shape.\n       \n       PROCEDURE DIVISION.\n       \n       METHOD-ID. perimeter.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  ret USAGE FLOAT-LONG.\n       PROCEDURE DIVISION RETURNING ret.\n       END METHOD perimeter.\n       \n       METHOD-ID. shape-area.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  ret USAGE FLOAT-LONG.\n       PROCEDURE DIVISION RETURNING ret.\n       END METHOD shape-area.\n       \n       END INTERFACE Shape.\n       \n\n       CLASS-ID. Rectangle. \n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           INTERFACE Shape.\n       \n       OBJECT IMPLEMENTS Shape.\n           DATA DIVISION.\n           WORKING-STORAGE SECTION.\n           01  width  USAGE FLOAT-LONG PROPERTY.\n           01  height USAGE FLOAT-LONG PROPERTY.\n           \n           PROCEDURE DIVISION.\n           \n           METHOD-ID. perimeter.\n           DATA DIVISION.\n           LINKAGE SECTION.\n           01  ret USAGE FLOAT-LONG.\n           PROCEDURE DIVISION RETURNING ret.\n               COMPUTE ret = width * 2.0 + height * 2.0\n               GOBACK\n               .\n           END METHOD perimeter.\n       \n           METHOD-ID. shape-area.\n           DATA DIVISION.\n           LINKAGE SECTION.\n           01  ret USAGE FLOAT-LONG.\n           PROCEDURE DIVISION RETURNING ret.\n               COMPUTE ret = width * height\n               GOBACK\n               .\n           END METHOD shape-area.\n       END OBJECT.\n       \n       END CLASS Rectangle.\n", "target": "public abstract class Abs {\n    public abstract int method1(double value);\n    protected abstract int method2(String name);\n    int add(int a, int b) {\n        return a + b;\n    }\n}\n"}
{"id": 80716, "name": "Abstract type", "source": "Translate COBOL to Python:        INTERFACE-ID. Shape.\n       \n       PROCEDURE DIVISION.\n       \n       METHOD-ID. perimeter.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  ret USAGE FLOAT-LONG.\n       PROCEDURE DIVISION RETURNING ret.\n       END METHOD perimeter.\n       \n       METHOD-ID. shape-area.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  ret USAGE FLOAT-LONG.\n       PROCEDURE DIVISION RETURNING ret.\n       END METHOD shape-area.\n       \n       END INTERFACE Shape.\n       \n\n       CLASS-ID. Rectangle. \n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           INTERFACE Shape.\n       \n       OBJECT IMPLEMENTS Shape.\n           DATA DIVISION.\n           WORKING-STORAGE SECTION.\n           01  width  USAGE FLOAT-LONG PROPERTY.\n           01  height USAGE FLOAT-LONG PROPERTY.\n           \n           PROCEDURE DIVISION.\n           \n           METHOD-ID. perimeter.\n           DATA DIVISION.\n           LINKAGE SECTION.\n           01  ret USAGE FLOAT-LONG.\n           PROCEDURE DIVISION RETURNING ret.\n               COMPUTE ret = width * 2.0 + height * 2.0\n               GOBACK\n               .\n           END METHOD perimeter.\n       \n           METHOD-ID. shape-area.\n           DATA DIVISION.\n           LINKAGE SECTION.\n           01  ret USAGE FLOAT-LONG.\n           PROCEDURE DIVISION RETURNING ret.\n               COMPUTE ret = width * height\n               GOBACK\n               .\n           END METHOD shape-area.\n       END OBJECT.\n       \n       END CLASS Rectangle.\n", "target": "class BaseQueue(object):\n    \n    def __init__(self):\n        self.contents = list()\n        raise NotImplementedError\n    def Enqueue(self, item):\n        raise NotImplementedError\n    def Dequeue(self):\n        raise NotImplementedError\n    def Print_Contents(self):\n        for i in self.contents:\n            print i,\n"}
{"id": 80964, "name": "Conway's Game of Life", "source": "Translate COBOL to C#: identification division.\nprogram-id. game-of-life-program.\ndata division.\nworking-storage section.\n01  grid.\n    05 cell-table.\n        10 row occurs 5 times.\n            15 cell pic x value space occurs 5 times.\n    05 next-gen-cell-table.\n        10 next-gen-row occurs 5 times.\n            15 next-gen-cell pic x occurs 5 times.\n01  counters.\n    05 generation pic 9.\n    05 current-row pic 9.\n    05 current-cell pic 9.\n    05 living-neighbours pic 9.\n    05 neighbour-row pic 9.\n    05 neighbour-cell pic 9.\n    05 check-row pic s9.\n    05 check-cell pic s9.\nprocedure division.\ncontrol-paragraph.\n    perform blinker-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\n    perform show-grid-paragraph through life-paragraph\n    varying generation from 0 by 1\n    until generation is greater than 2.\n    stop run.\nblinker-paragraph.\n    move '#' to cell(3,current-cell).\nshow-grid-paragraph.\n    display 'GENERATION ' generation ':'.\n    display '   +---+'.\n    perform show-row-paragraph varying current-row from 2 by 1\n    until current-row is greater than 4.\n    display '   +---+'.\n    display ''.\nlife-paragraph.\n    perform update-row-paragraph varying current-row from 2 by 1\n    until current-row is greater than 4.\n    move next-gen-cell-table to cell-table.\nshow-row-paragraph.\n    display '   |' with no advancing.\n    perform show-cell-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\n    display '|'.\nshow-cell-paragraph.\n    display cell(current-row,current-cell) with no advancing.\nupdate-row-paragraph.\n    perform update-cell-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\nupdate-cell-paragraph.\n    move 0 to living-neighbours.\n    perform check-row-paragraph varying check-row from -1 by 1\n    until check-row is greater than 1.\n    evaluate living-neighbours,\n        when 2 move cell(current-row,current-cell) to next-gen-cell(current-row,current-cell),\n        when 3 move '#' to next-gen-cell(current-row,current-cell),\n        when other move space to next-gen-cell(current-row,current-cell),\n    end-evaluate.\ncheck-row-paragraph.\n    add check-row to current-row giving neighbour-row.\n    perform check-cell-paragraph varying check-cell from -1 by 1\n    until check-cell is greater than 1.\ncheck-cell-paragraph.\n    add check-cell to current-cell giving neighbour-cell.\n    if cell(neighbour-row,neighbour-cell) is equal to '#',\n    and check-cell is not equal to zero or check-row is not equal to zero,\n    then add 1 to living-neighbours.\n", "target": "using System;\nusing System.Text;\nusing System.Threading;\n \nnamespace ConwaysGameOfLife\n{\n    \n    class Program\n    {\n        \n        private const int DELAY = 50;\n \n        \n        private const ConsoleColor DEAD_COLOR = ConsoleColor.White;\n        private const ConsoleColor LIVE_COLOR = ConsoleColor.Black;\n \n        \n        private const ConsoleColor EXTRA_COLOR = ConsoleColor.Gray;\n \n        private const char EMPTY_BLOCK_CHAR = ' ';\n        private const char FULL_BLOCK_CHAR = '\\u2588';\n \n        \n        private static bool[,] board;\n \n        \n        private static int width = 32;\n        private static int height = 32;\n \n        \n        private static bool loopEdges = true;\n \n \n        static void Main(string[] args)\n        {\n            \n            initializeDemoBoard();\n \n            initializeConsole();\n \n            \n            while (!Console.KeyAvailable || Console.ReadKey(true).Key != ConsoleKey.Escape) {\n                Program.drawBoard();\n                Program.updateBoard();\n \n                \n                Thread.Sleep(DELAY);\n            }\n        }\n \n        \n        private static void initializeConsole()\n        {\n            Console.BackgroundColor = EXTRA_COLOR;\n            Console.Clear();\n \n            Console.CursorVisible = false;\n \n            \n            \n            int width = Math.Max(Program.width, 8) * 2 + 1;\n            int height = Math.Max(Program.height, 8) + 1;\n            Console.SetWindowSize(width, height);\n            Console.SetBufferSize(width, height);\n \n            Console.BackgroundColor = DEAD_COLOR;\n            Console.ForegroundColor = LIVE_COLOR;\n        }\n \n        \n        private static void initializeRandomBoard()\n        {\n            var random = new Random();\n \n            Program.board = new bool[Program.width, Program.height];\n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    \n                    Program.board[x, y] = random.Next(2) == 0;\n                }\n            }\n        }\n \n        \n        private static void initializeDemoBoard()\n        {\n            Program.width = 3;\n            Program.height = 3;\n \n            Program.loopEdges = false;\n \n            Program.board = new bool[3, 3];\n            Program.board[1, 0] = true;\n            Program.board[1, 1] = true;\n            Program.board[1, 2] = true;\n        }\n \n        \n        private static void drawBoard()\n        {\n            \n            var builder = new StringBuilder();\n \n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    char c = Program.board[x, y] ? FULL_BLOCK_CHAR : EMPTY_BLOCK_CHAR;\n \n                    \n                    builder.Append(c);\n                    builder.Append(c);\n                }\n                builder.Append('\\n');\n            }\n \n            \n            Console.SetCursorPosition(0, 0);\n            Console.Write (builder.ToString());\n        }\n \n        \n        private static void updateBoard()\n        {\n            \n            bool[,] newBoard = new bool[Program.width, Program.height];\n \n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    var n = countLiveNeighbors(x, y);\n                    var c = Program.board[x, y];\n \n                    \n                    \n                    newBoard[x, y] = c && (n == 2 || n == 3) || !c && n == 3;\n                }\n            }\n \n            \n            Program.board = newBoard;\n        }\n \n        \n        private static int countLiveNeighbors(int x, int y)\n        {\n            \n            int value = 0;\n \n            \n            for (var j = -1; j <= 1; j++) {\n                \n                if (!Program.loopEdges && y + j < 0 || y + j >= Program.height) {\n                    continue;\n                }\n \n                \n                int k = (y + j + Program.height) % Program.height;\n \n                for (var i = -1; i <= 1; i++) {\n                    \n                    if (!Program.loopEdges && x + i < 0 || x + i >= Program.width) {\n                        continue;\n                    }\n \n                    \n                    int h = (x + i + Program.width) % Program.width;\n \n                    \n                    value += Program.board[h, k] ? 1 : 0;\n                }\n            }\n \n            \n            return value - (Program.board[x, y] ? 1 : 0);\n        }\n    }\n}\n"}
{"id": 80966, "name": "Conway's Game of Life", "source": "Translate COBOL to Java: identification division.\nprogram-id. game-of-life-program.\ndata division.\nworking-storage section.\n01  grid.\n    05 cell-table.\n        10 row occurs 5 times.\n            15 cell pic x value space occurs 5 times.\n    05 next-gen-cell-table.\n        10 next-gen-row occurs 5 times.\n            15 next-gen-cell pic x occurs 5 times.\n01  counters.\n    05 generation pic 9.\n    05 current-row pic 9.\n    05 current-cell pic 9.\n    05 living-neighbours pic 9.\n    05 neighbour-row pic 9.\n    05 neighbour-cell pic 9.\n    05 check-row pic s9.\n    05 check-cell pic s9.\nprocedure division.\ncontrol-paragraph.\n    perform blinker-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\n    perform show-grid-paragraph through life-paragraph\n    varying generation from 0 by 1\n    until generation is greater than 2.\n    stop run.\nblinker-paragraph.\n    move '#' to cell(3,current-cell).\nshow-grid-paragraph.\n    display 'GENERATION ' generation ':'.\n    display '   +---+'.\n    perform show-row-paragraph varying current-row from 2 by 1\n    until current-row is greater than 4.\n    display '   +---+'.\n    display ''.\nlife-paragraph.\n    perform update-row-paragraph varying current-row from 2 by 1\n    until current-row is greater than 4.\n    move next-gen-cell-table to cell-table.\nshow-row-paragraph.\n    display '   |' with no advancing.\n    perform show-cell-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\n    display '|'.\nshow-cell-paragraph.\n    display cell(current-row,current-cell) with no advancing.\nupdate-row-paragraph.\n    perform update-cell-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\nupdate-cell-paragraph.\n    move 0 to living-neighbours.\n    perform check-row-paragraph varying check-row from -1 by 1\n    until check-row is greater than 1.\n    evaluate living-neighbours,\n        when 2 move cell(current-row,current-cell) to next-gen-cell(current-row,current-cell),\n        when 3 move '#' to next-gen-cell(current-row,current-cell),\n        when other move space to next-gen-cell(current-row,current-cell),\n    end-evaluate.\ncheck-row-paragraph.\n    add check-row to current-row giving neighbour-row.\n    perform check-cell-paragraph varying check-cell from -1 by 1\n    until check-cell is greater than 1.\ncheck-cell-paragraph.\n    add check-cell to current-cell giving neighbour-cell.\n    if cell(neighbour-row,neighbour-cell) is equal to '#',\n    and check-cell is not equal to zero or check-row is not equal to zero,\n    then add 1 to living-neighbours.\n", "target": "public class GameOfLife{\n\tpublic static void main(String[] args){\n\t\tString[] dish= {\n\t\t\t\t\"_#_\",\n\t\t\t\t\"_#_\",\n\t\t\t\t\"_#_\",};\n\t\tint gens= 3;\n\t\tfor(int i= 0;i < gens;i++){\n\t\t\tSystem.out.println(\"Generation \" + i + \":\");\n\t\t\tprint(dish);\n\t\t\tdish= life(dish);\n\t\t}\n\t}\n\n\tpublic static String[] life(String[] dish){\n\t\tString[] newGen= new String[dish.length];\n\t\tfor(int row= 0;row < dish.length;row++){\n\t\t\tnewGen[row]= \"\";\n\t\t\tfor(int i= 0;i < dish[row].length();i++){\n\t\t\t\tString above= \"\";\n\t\t\t\tString same= \"\";\n\t\t\t\tString below= \"\";\n\t\t\t\tif(i == 0){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i,\n\t\t\t\t\t\t\t\t\ti + 2);\n\t\t\t\t\tsame= dish[row].substring(i + 1, i + 2);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i, i + 2);\n\t\t\t\t}else if(i == dish[row].length() - 1){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i - 1,\n\t\t\t\t\t\t\t\t\ti + 1);\n\t\t\t\t\tsame= dish[row].substring(i - 1, i);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i - 1, i + 1);\n\t\t\t\t}else{\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i - 1,\n\t\t\t\t\t\t\t\t\ti + 2);\n\t\t\t\t\tsame= dish[row].substring(i - 1, i)\n\t\t\t\t\t\t\t\t\t+ dish[row].substring(i + 1, i + 2);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i - 1, i + 2);\n\t\t\t\t}\n\t\t\t\tint neighbors= getNeighbors(above, same, below);\n\t\t\t\tif(neighbors < 2 || neighbors > 3){\n\t\t\t\t\tnewGen[row]+= \"_\";\n\t\t\t\t}else if(neighbors == 3){\n\t\t\t\t\tnewGen[row]+= \"#\";\n\t\t\t\t}else{\n\t\t\t\t\tnewGen[row]+= dish[row].charAt(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn newGen;\n\t}\n\n\tpublic static int getNeighbors(String above, String same, String below){\n\t\tint ans= 0;\n\t\tif(above != null){\n\t\t\tfor(char x: above.toCharArray()){\n\t\t\t\tif(x == '#') ans++;\n\t\t\t}\n\t\t}\n\t\tfor(char x: same.toCharArray()){\n\t\t\tif(x == '#') ans++;\n\t\t}\n\t\tif(below != null){\n\t\t\tfor(char x: below.toCharArray()){\n\t\t\t\tif(x == '#') ans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static void print(String[] dish){\n\t\tfor(String s: dish){\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}\n"}
{"id": 80967, "name": "Conway's Game of Life", "source": "Translate COBOL to Python: identification division.\nprogram-id. game-of-life-program.\ndata division.\nworking-storage section.\n01  grid.\n    05 cell-table.\n        10 row occurs 5 times.\n            15 cell pic x value space occurs 5 times.\n    05 next-gen-cell-table.\n        10 next-gen-row occurs 5 times.\n            15 next-gen-cell pic x occurs 5 times.\n01  counters.\n    05 generation pic 9.\n    05 current-row pic 9.\n    05 current-cell pic 9.\n    05 living-neighbours pic 9.\n    05 neighbour-row pic 9.\n    05 neighbour-cell pic 9.\n    05 check-row pic s9.\n    05 check-cell pic s9.\nprocedure division.\ncontrol-paragraph.\n    perform blinker-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\n    perform show-grid-paragraph through life-paragraph\n    varying generation from 0 by 1\n    until generation is greater than 2.\n    stop run.\nblinker-paragraph.\n    move '#' to cell(3,current-cell).\nshow-grid-paragraph.\n    display 'GENERATION ' generation ':'.\n    display '   +---+'.\n    perform show-row-paragraph varying current-row from 2 by 1\n    until current-row is greater than 4.\n    display '   +---+'.\n    display ''.\nlife-paragraph.\n    perform update-row-paragraph varying current-row from 2 by 1\n    until current-row is greater than 4.\n    move next-gen-cell-table to cell-table.\nshow-row-paragraph.\n    display '   |' with no advancing.\n    perform show-cell-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\n    display '|'.\nshow-cell-paragraph.\n    display cell(current-row,current-cell) with no advancing.\nupdate-row-paragraph.\n    perform update-cell-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\nupdate-cell-paragraph.\n    move 0 to living-neighbours.\n    perform check-row-paragraph varying check-row from -1 by 1\n    until check-row is greater than 1.\n    evaluate living-neighbours,\n        when 2 move cell(current-row,current-cell) to next-gen-cell(current-row,current-cell),\n        when 3 move '#' to next-gen-cell(current-row,current-cell),\n        when other move space to next-gen-cell(current-row,current-cell),\n    end-evaluate.\ncheck-row-paragraph.\n    add check-row to current-row giving neighbour-row.\n    perform check-cell-paragraph varying check-cell from -1 by 1\n    until check-cell is greater than 1.\ncheck-cell-paragraph.\n    add check-cell to current-cell giving neighbour-cell.\n    if cell(neighbour-row,neighbour-cell) is equal to '#',\n    and check-cell is not equal to zero or check-row is not equal to zero,\n    then add 1 to living-neighbours.\n", "target": "cell_size = 10\nsample = 10 \nplay = False   \nlast_cell = 0\n\ndef setup():\n    global grid, next_grid, rows, cols\n    size(800, 500)\n\n    rows = height / cell_size\n    cols = width / cell_size\n    grid = empty_grid()\n    next_grid = empty_grid()\n    randomize_grid()\n\n    println(\"Press 'space' to start/stop\")\n    println(\"'e' to clear all cells\")\n    println(\"'b' demonstrate 'blinker'\")\n    println(\"'g' demonstrate glider\")\n    println(\"'r' to randomize grid\")\n    println(\"'+' and '-' to change speed\")\n\ndef draw():\n    background(0)\n    for i in range(cols):\n        x = i * cell_size\n        for j in range(rows):\n            y = j * cell_size\n            current_state = grid[i][j]\n            fill(255)\n            noStroke()\n            if current_state:\n                rect(x, y, cell_size, cell_size)\n            if play:\n                ngbs_alive = calc_ngbs_alive(i, j)\n                result = rule(current_state, ngbs_alive)\n                next_grid[i][j] = result\n                \n    if play and frameCount % sample == 0 and not mousePressed:\n        step()\n\ndef rule(current, ngbs):\n    \n    if ngbs < 2 or ngbs > 3:\n        return 0  \n    elif ngbs == 3:\n        return 1  \n    else:\n        return current  \n\ndef calc_ngbs_alive(i, j):\n    NEIGHBOURS = ((-1, 00), (01, 00),  \n                  (-1, -1), (00, -1),\n                  (01, -1), (-1, 01),\n                  (00, 01), (01, 01))\n    alive = 0\n    for iv, jv in NEIGHBOURS:\n        alive += grid[(i + iv) % cols][(j + jv) % rows]\n    return alive\n\ndef empty_grid():\n    grid = []\n    for _ in range(cols):\n        grid.append([0] * rows)\n    return grid\n\ndef randomize_grid():\n    from random import choice\n    for i in range(cols):\n        for j in range(rows):\n            grid[i][j] = choice((0, 1))\n\ndef step():\n    global grid, next_grid\n    grid = next_grid\n    next_grid = empty_grid()\n\ndef keyReleased():\n    global grid, play, sample\n    if key == \"e\":\n        grid = empty_grid()\n    if key == \"r\":\n        randomize_grid()\n    if key == \"g\":\n         grid[10][10:13] = [0, 1, 0]       \n         grid[11][10:13] = [0, 0, 1]       \n         grid[12][10:13] = [1, 1, 1]       \n    if key == \"b\":\n         grid[10][10:13] = [0, 1, 0]       \n         grid[11][10:13] = [0, 1, 0]       \n         grid[12][10:13] = [0, 1, 0]               \n    if key == \" \":\n        play = not play \n    if  str(key) in '+=':\n        sample = max(sample - 1, 1);\n    if key == '-':\n        sample += 1\n\ndef mousePressed():\n    paint()\n    \ndef mouseDragged():\n    paint()\n\ndef paint():\n    global last_cell\n    i, j = mouseX // cell_size, mouseY // cell_size\n    p = j * cols + i\n    if p != last_cell:\n        last_cell = p\n        grid[i][j] = (1, 0)[grid[i][j]]\n"}
{"id": 83640, "name": "Show the (decimal) value of a number of 1s appended with a 3, then squared", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ONES-THREE-SQUARED.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 N                  PIC 9.\n          03 ONES-3             PIC 9(9).\n          03 SQUARE             PIC 9(15).\n       01 FMT.\n          03 FMT-ONES-3         PIC Z(7)9.\n          03 FILLER             PIC X(5) VALUE \"^2 = \".\n          03 FMT-SQUARE         PIC Z(14)9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM N-ONES-3 VARYING N FROM 0 BY 1 UNTIL N IS EQUAL TO 8.\n           STOP RUN.\n\n       N-ONES-3.\n           MOVE ZERO TO ONES-3.\n           PERFORM ADD-ONE N TIMES.\n           MULTIPLY 10 BY ONES-3.\n           ADD 3 TO ONES-3.\n           MULTIPLY ONES-3 BY ONES-3 GIVING SQUARE.\n           MOVE ONES-3 TO FMT-ONES-3.\n           MOVE SQUARE TO FMT-SQUARE.\n           DISPLAY FMT.\n\n       ADD-ONE.\n           MULTIPLY 10 BY ONES-3.\n           ADD 1 TO ONES-3.\n", "target": "using System; using BI = System.Numerics.BigInteger;\nclass Program { static void Main(string[] args) {\n    for (BI x = 3; BI.Log10(x) < 22; x = (x - 2) * 10 + 3)\n      Console.WriteLine(\"{1,43} {0,-20}\", x, x * x); } }\n"}
{"id": 83641, "name": "Show the (decimal) value of a number of 1s appended with a 3, then squared", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ONES-THREE-SQUARED.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 N                  PIC 9.\n          03 ONES-3             PIC 9(9).\n          03 SQUARE             PIC 9(15).\n       01 FMT.\n          03 FMT-ONES-3         PIC Z(7)9.\n          03 FILLER             PIC X(5) VALUE \"^2 = \".\n          03 FMT-SQUARE         PIC Z(14)9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM N-ONES-3 VARYING N FROM 0 BY 1 UNTIL N IS EQUAL TO 8.\n           STOP RUN.\n\n       N-ONES-3.\n           MOVE ZERO TO ONES-3.\n           PERFORM ADD-ONE N TIMES.\n           MULTIPLY 10 BY ONES-3.\n           ADD 3 TO ONES-3.\n           MULTIPLY ONES-3 BY ONES-3 GIVING SQUARE.\n           MOVE ONES-3 TO FMT-ONES-3.\n           MOVE SQUARE TO FMT-SQUARE.\n           DISPLAY FMT.\n\n       ADD-ONE.\n           MULTIPLY 10 BY ONES-3.\n           ADD 1 TO ONES-3.\n", "target": "using System; using BI = System.Numerics.BigInteger;\nclass Program { static void Main(string[] args) {\n    for (BI x = 3; BI.Log10(x) < 22; x = (x - 2) * 10 + 3)\n      Console.WriteLine(\"{1,43} {0,-20}\", x, x * x); } }\n"}
{"id": 83642, "name": "Show the (decimal) value of a number of 1s appended with a 3, then squared", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ONES-THREE-SQUARED.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 N                  PIC 9.\n          03 ONES-3             PIC 9(9).\n          03 SQUARE             PIC 9(15).\n       01 FMT.\n          03 FMT-ONES-3         PIC Z(7)9.\n          03 FILLER             PIC X(5) VALUE \"^2 = \".\n          03 FMT-SQUARE         PIC Z(14)9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM N-ONES-3 VARYING N FROM 0 BY 1 UNTIL N IS EQUAL TO 8.\n           STOP RUN.\n\n       N-ONES-3.\n           MOVE ZERO TO ONES-3.\n           PERFORM ADD-ONE N TIMES.\n           MULTIPLY 10 BY ONES-3.\n           ADD 3 TO ONES-3.\n           MULTIPLY ONES-3 BY ONES-3 GIVING SQUARE.\n           MOVE ONES-3 TO FMT-ONES-3.\n           MOVE SQUARE TO FMT-SQUARE.\n           DISPLAY FMT.\n\n       ADD-ONE.\n           MULTIPLY 10 BY ONES-3.\n           ADD 1 TO ONES-3.\n", "target": "[print(\"( \" + \"1\"*i + \"3 ) ^ 2 = \" + str(int(\"1\"*i + \"3\")**2)) for i in range(0,8)]\n"}
{"id": 83643, "name": "Show the (decimal) value of a number of 1s appended with a 3, then squared", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ONES-THREE-SQUARED.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 N                  PIC 9.\n          03 ONES-3             PIC 9(9).\n          03 SQUARE             PIC 9(15).\n       01 FMT.\n          03 FMT-ONES-3         PIC Z(7)9.\n          03 FILLER             PIC X(5) VALUE \"^2 = \".\n          03 FMT-SQUARE         PIC Z(14)9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM N-ONES-3 VARYING N FROM 0 BY 1 UNTIL N IS EQUAL TO 8.\n           STOP RUN.\n\n       N-ONES-3.\n           MOVE ZERO TO ONES-3.\n           PERFORM ADD-ONE N TIMES.\n           MULTIPLY 10 BY ONES-3.\n           ADD 3 TO ONES-3.\n           MULTIPLY ONES-3 BY ONES-3 GIVING SQUARE.\n           MOVE ONES-3 TO FMT-ONES-3.\n           MOVE SQUARE TO FMT-SQUARE.\n           DISPLAY FMT.\n\n       ADD-ONE.\n           MULTIPLY 10 BY ONES-3.\n           ADD 1 TO ONES-3.\n", "target": "[print(\"( \" + \"1\"*i + \"3 ) ^ 2 = \" + str(int(\"1\"*i + \"3\")**2)) for i in range(0,8)]\n"}
{"id": 83878, "name": "Loops_N plus one half", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Loop-N-And-Half.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  I    PIC 99.\n       01  List PIC X(45).\n\n       PROCEDURE DIVISION.\n           PERFORM FOREVER\n               \n               \n               STRING FUNCTION TRIM(List) \" \"  I  INTO List\n\n               IF I = 10\n                   EXIT PERFORM\n               END-IF\n               \n               STRING FUNCTION TRIM(List) \",\" INTO List\n\n               ADD 1 TO I\n           END-PERFORM\n\n           DISPLAY List\n\n           GOBACK\n           .\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 1; ; i++)\n        {\n            Console.Write(i);\n            if (i == 10) break;\n            Console.Write(\", \");\n        }\n        Console.WriteLine();\n    }\n}\n"}
{"id": 83880, "name": "Loops_N plus one half", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Loop-N-And-Half.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  I    PIC 99.\n       01  List PIC X(45).\n\n       PROCEDURE DIVISION.\n           PERFORM FOREVER\n               \n               \n               STRING FUNCTION TRIM(List) \" \"  I  INTO List\n\n               IF I = 10\n                   EXIT PERFORM\n               END-IF\n               \n               STRING FUNCTION TRIM(List) \",\" INTO List\n\n               ADD 1 TO I\n           END-PERFORM\n\n           DISPLAY List\n\n           GOBACK\n           .\n", "target": "var out = System.out\nfor(i in 1..10) {\n  if(i > 1) out.print(\", \")\n  out.print(i)\n}\n"}
{"id": 83881, "name": "Loops_N plus one half", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Loop-N-And-Half.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  I    PIC 99.\n       01  List PIC X(45).\n\n       PROCEDURE DIVISION.\n           PERFORM FOREVER\n               \n               \n               STRING FUNCTION TRIM(List) \" \"  I  INTO List\n\n               IF I = 10\n                   EXIT PERFORM\n               END-IF\n               \n               STRING FUNCTION TRIM(List) \",\" INTO List\n\n               ADD 1 TO I\n           END-PERFORM\n\n           DISPLAY List\n\n           GOBACK\n           .\n", "target": "print ( ', '.join(str(i+1) for i in range(10)) )\n"}
{"id": 84260, "name": "Euler's sum of powers conjecture", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       FILE SECTION.\n       WORKING-STORAGE SECTION.\n       1   TABLE-LENGTH CONSTANT 250.\n       1   SEARCHING-FLAG     PIC 9.\n        88  FINISHED-SEARCHING VALUE IS 1\n                               WHEN SET TO FALSE IS 0.\n       1  CALC.\n        3  A               PIC 999 USAGE COMPUTATIONAL-5.\n        3  B               PIC 999 USAGE COMPUTATIONAL-5.\n        3  C               PIC 999 USAGE COMPUTATIONAL-5.\n        3  D               PIC 999 USAGE COMPUTATIONAL-5.\n        3  ABCD            PIC 9(18) USAGE COMPUTATIONAL-5.\n        3  FIFTH-ROOT-OFFS PIC 999 USAGE COMPUTATIONAL-5.\n        3  POWER-COUNTER   PIC 999 USAGE COMPUTATIONAL-5.\n        88 POWER-MAX       VALUE TABLE-LENGTH.\n       \n       1   PRETTY.\n        3  A               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  B               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  C               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  D               PIC ZZ9.\n        3  FILLER          VALUE \"^5 = \".\n        3  FIFTH-ROOT-OFFS PIC ZZ9.\n        3  FILLER          VALUE \"^5.\".\n\n       1   FIFTH-POWER-TABLE   OCCURS TABLE-LENGTH TIMES\n                               ASCENDING KEY IS FIFTH-POWER\n                               INDEXED BY POWER-INDEX.\n        3  FIFTH-POWER PIC 9(18) USAGE COMPUTATIONAL-5.\n\n\n       PROCEDURE DIVISION.\n       MAIN-PARAGRAPH.\n           SET FINISHED-SEARCHING TO FALSE.\n           PERFORM POWERS-OF-FIVE-TABLE-INIT.\n           PERFORM VARYING\n               A IN CALC\n               FROM 1 BY 1 UNTIL A IN CALC = TABLE-LENGTH\n\n               AFTER B IN CALC\n               FROM 1 BY 1 UNTIL B IN CALC = A IN CALC\n\n               AFTER C IN CALC\n               FROM 1 BY 1 UNTIL C IN CALC = B IN CALC\n\n               AFTER D IN CALC\n               FROM 1 BY 1 UNTIL D IN CALC = C IN CALC\n\n               IF FINISHED-SEARCHING\n                   STOP RUN\n               END-IF\n\n               PERFORM POWER-COMPUTATIONS\n\n           END-PERFORM.\n\n       POWER-COMPUTATIONS.\n\n           MOVE ZERO TO ABCD IN CALC.\n\n           ADD FIFTH-POWER(A IN CALC)\n               FIFTH-POWER(B IN CALC)\n               FIFTH-POWER(C IN CALC)\n               FIFTH-POWER(D IN CALC)\n                   TO ABCD IN CALC.\n\n           SET POWER-INDEX TO 1.\n\n           SEARCH ALL FIFTH-POWER-TABLE\n               WHEN FIFTH-POWER(POWER-INDEX) = ABCD IN CALC\n                      MOVE POWER-INDEX TO FIFTH-ROOT-OFFS IN CALC\n                      MOVE CORRESPONDING CALC TO PRETTY\n                      DISPLAY PRETTY END-DISPLAY\n                      SET FINISHED-SEARCHING TO TRUE\n           END-SEARCH\n\n           EXIT PARAGRAPH.\n\n       POWERS-OF-FIVE-TABLE-INIT.\n           PERFORM VARYING POWER-COUNTER FROM 1 BY 1 UNTIL POWER-MAX\n               COMPUTE FIFTH-POWER(POWER-COUNTER) = \n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER \n               END-COMPUTE\n           END-PERFORM.\n           EXIT PARAGRAPH.\n\n       END PROGRAM EULER.\n", "target": "using System;\n\nnamespace EulerSumOfPowers {\n    class Program {\n        const int MAX_NUMBER = 250;\n\n        static void Main(string[] args) {\n            bool found = false;\n            long[] fifth = new long[MAX_NUMBER];\n\n            for (int i = 1; i <= MAX_NUMBER; i++) {\n                long i2 = i * i;\n                fifth[i - 1] = i2 * i2 * i;\n            }\n\n            for (int a = 0; a < MAX_NUMBER && !found; a++) {\n                for (int b = a; b < MAX_NUMBER && !found; b++) {\n                    for (int c = b; c < MAX_NUMBER && !found; c++) {\n                        for (int d = c; d < MAX_NUMBER && !found; d++) {\n                            long sum = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                            int e = Array.BinarySearch(fifth, sum);\n                            found = e >= 0;\n                            if (found) {\n                                Console.WriteLine(\"{0}^5 + {1}^5 + {2}^5 + {3}^5 = {4}^5\", a + 1, b + 1, c + 1, d + 1, e + 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 84261, "name": "Euler's sum of powers conjecture", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       FILE SECTION.\n       WORKING-STORAGE SECTION.\n       1   TABLE-LENGTH CONSTANT 250.\n       1   SEARCHING-FLAG     PIC 9.\n        88  FINISHED-SEARCHING VALUE IS 1\n                               WHEN SET TO FALSE IS 0.\n       1  CALC.\n        3  A               PIC 999 USAGE COMPUTATIONAL-5.\n        3  B               PIC 999 USAGE COMPUTATIONAL-5.\n        3  C               PIC 999 USAGE COMPUTATIONAL-5.\n        3  D               PIC 999 USAGE COMPUTATIONAL-5.\n        3  ABCD            PIC 9(18) USAGE COMPUTATIONAL-5.\n        3  FIFTH-ROOT-OFFS PIC 999 USAGE COMPUTATIONAL-5.\n        3  POWER-COUNTER   PIC 999 USAGE COMPUTATIONAL-5.\n        88 POWER-MAX       VALUE TABLE-LENGTH.\n       \n       1   PRETTY.\n        3  A               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  B               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  C               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  D               PIC ZZ9.\n        3  FILLER          VALUE \"^5 = \".\n        3  FIFTH-ROOT-OFFS PIC ZZ9.\n        3  FILLER          VALUE \"^5.\".\n\n       1   FIFTH-POWER-TABLE   OCCURS TABLE-LENGTH TIMES\n                               ASCENDING KEY IS FIFTH-POWER\n                               INDEXED BY POWER-INDEX.\n        3  FIFTH-POWER PIC 9(18) USAGE COMPUTATIONAL-5.\n\n\n       PROCEDURE DIVISION.\n       MAIN-PARAGRAPH.\n           SET FINISHED-SEARCHING TO FALSE.\n           PERFORM POWERS-OF-FIVE-TABLE-INIT.\n           PERFORM VARYING\n               A IN CALC\n               FROM 1 BY 1 UNTIL A IN CALC = TABLE-LENGTH\n\n               AFTER B IN CALC\n               FROM 1 BY 1 UNTIL B IN CALC = A IN CALC\n\n               AFTER C IN CALC\n               FROM 1 BY 1 UNTIL C IN CALC = B IN CALC\n\n               AFTER D IN CALC\n               FROM 1 BY 1 UNTIL D IN CALC = C IN CALC\n\n               IF FINISHED-SEARCHING\n                   STOP RUN\n               END-IF\n\n               PERFORM POWER-COMPUTATIONS\n\n           END-PERFORM.\n\n       POWER-COMPUTATIONS.\n\n           MOVE ZERO TO ABCD IN CALC.\n\n           ADD FIFTH-POWER(A IN CALC)\n               FIFTH-POWER(B IN CALC)\n               FIFTH-POWER(C IN CALC)\n               FIFTH-POWER(D IN CALC)\n                   TO ABCD IN CALC.\n\n           SET POWER-INDEX TO 1.\n\n           SEARCH ALL FIFTH-POWER-TABLE\n               WHEN FIFTH-POWER(POWER-INDEX) = ABCD IN CALC\n                      MOVE POWER-INDEX TO FIFTH-ROOT-OFFS IN CALC\n                      MOVE CORRESPONDING CALC TO PRETTY\n                      DISPLAY PRETTY END-DISPLAY\n                      SET FINISHED-SEARCHING TO TRUE\n           END-SEARCH\n\n           EXIT PARAGRAPH.\n\n       POWERS-OF-FIVE-TABLE-INIT.\n           PERFORM VARYING POWER-COUNTER FROM 1 BY 1 UNTIL POWER-MAX\n               COMPUTE FIFTH-POWER(POWER-COUNTER) = \n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER \n               END-COMPUTE\n           END-PERFORM.\n           EXIT PARAGRAPH.\n\n       END PROGRAM EULER.\n", "target": "using System;\n\nnamespace EulerSumOfPowers {\n    class Program {\n        const int MAX_NUMBER = 250;\n\n        static void Main(string[] args) {\n            bool found = false;\n            long[] fifth = new long[MAX_NUMBER];\n\n            for (int i = 1; i <= MAX_NUMBER; i++) {\n                long i2 = i * i;\n                fifth[i - 1] = i2 * i2 * i;\n            }\n\n            for (int a = 0; a < MAX_NUMBER && !found; a++) {\n                for (int b = a; b < MAX_NUMBER && !found; b++) {\n                    for (int c = b; c < MAX_NUMBER && !found; c++) {\n                        for (int d = c; d < MAX_NUMBER && !found; d++) {\n                            long sum = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                            int e = Array.BinarySearch(fifth, sum);\n                            found = e >= 0;\n                            if (found) {\n                                Console.WriteLine(\"{0}^5 + {1}^5 + {2}^5 + {3}^5 = {4}^5\", a + 1, b + 1, c + 1, d + 1, e + 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 84264, "name": "Euler's sum of powers conjecture", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       FILE SECTION.\n       WORKING-STORAGE SECTION.\n       1   TABLE-LENGTH CONSTANT 250.\n       1   SEARCHING-FLAG     PIC 9.\n        88  FINISHED-SEARCHING VALUE IS 1\n                               WHEN SET TO FALSE IS 0.\n       1  CALC.\n        3  A               PIC 999 USAGE COMPUTATIONAL-5.\n        3  B               PIC 999 USAGE COMPUTATIONAL-5.\n        3  C               PIC 999 USAGE COMPUTATIONAL-5.\n        3  D               PIC 999 USAGE COMPUTATIONAL-5.\n        3  ABCD            PIC 9(18) USAGE COMPUTATIONAL-5.\n        3  FIFTH-ROOT-OFFS PIC 999 USAGE COMPUTATIONAL-5.\n        3  POWER-COUNTER   PIC 999 USAGE COMPUTATIONAL-5.\n        88 POWER-MAX       VALUE TABLE-LENGTH.\n       \n       1   PRETTY.\n        3  A               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  B               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  C               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  D               PIC ZZ9.\n        3  FILLER          VALUE \"^5 = \".\n        3  FIFTH-ROOT-OFFS PIC ZZ9.\n        3  FILLER          VALUE \"^5.\".\n\n       1   FIFTH-POWER-TABLE   OCCURS TABLE-LENGTH TIMES\n                               ASCENDING KEY IS FIFTH-POWER\n                               INDEXED BY POWER-INDEX.\n        3  FIFTH-POWER PIC 9(18) USAGE COMPUTATIONAL-5.\n\n\n       PROCEDURE DIVISION.\n       MAIN-PARAGRAPH.\n           SET FINISHED-SEARCHING TO FALSE.\n           PERFORM POWERS-OF-FIVE-TABLE-INIT.\n           PERFORM VARYING\n               A IN CALC\n               FROM 1 BY 1 UNTIL A IN CALC = TABLE-LENGTH\n\n               AFTER B IN CALC\n               FROM 1 BY 1 UNTIL B IN CALC = A IN CALC\n\n               AFTER C IN CALC\n               FROM 1 BY 1 UNTIL C IN CALC = B IN CALC\n\n               AFTER D IN CALC\n               FROM 1 BY 1 UNTIL D IN CALC = C IN CALC\n\n               IF FINISHED-SEARCHING\n                   STOP RUN\n               END-IF\n\n               PERFORM POWER-COMPUTATIONS\n\n           END-PERFORM.\n\n       POWER-COMPUTATIONS.\n\n           MOVE ZERO TO ABCD IN CALC.\n\n           ADD FIFTH-POWER(A IN CALC)\n               FIFTH-POWER(B IN CALC)\n               FIFTH-POWER(C IN CALC)\n               FIFTH-POWER(D IN CALC)\n                   TO ABCD IN CALC.\n\n           SET POWER-INDEX TO 1.\n\n           SEARCH ALL FIFTH-POWER-TABLE\n               WHEN FIFTH-POWER(POWER-INDEX) = ABCD IN CALC\n                      MOVE POWER-INDEX TO FIFTH-ROOT-OFFS IN CALC\n                      MOVE CORRESPONDING CALC TO PRETTY\n                      DISPLAY PRETTY END-DISPLAY\n                      SET FINISHED-SEARCHING TO TRUE\n           END-SEARCH\n\n           EXIT PARAGRAPH.\n\n       POWERS-OF-FIVE-TABLE-INIT.\n           PERFORM VARYING POWER-COUNTER FROM 1 BY 1 UNTIL POWER-MAX\n               COMPUTE FIFTH-POWER(POWER-COUNTER) = \n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER \n               END-COMPUTE\n           END-PERFORM.\n           EXIT PARAGRAPH.\n\n       END PROGRAM EULER.\n", "target": "public class eulerSopConjecture\n{\n\n    static final int    MAX_NUMBER = 250;\n\n    public static void main( String[] args )\n    {\n        boolean found = false;\n        long[]  fifth = new long[ MAX_NUMBER ];\n\n        for( int i = 1; i <= MAX_NUMBER; i ++ )\n        {\n            long i2 =  i * i;\n            fifth[ i - 1 ] = i2 * i2 * i;\n        } \n\n        for( int a = 0; a < MAX_NUMBER && ! found ; a ++ )\n        {\n            for( int b = a; b < MAX_NUMBER && ! found ; b ++ )\n            {\n                for( int c = b; c < MAX_NUMBER && ! found ; c ++ )\n                {\n                    for( int d = c; d < MAX_NUMBER && ! found ; d ++ )\n                    {\n                        long sum  = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                        int  e = java.util.Arrays.binarySearch( fifth, sum );\n                        found  = ( e >= 0 );\n                        if( found )\n                        {\n                            \n                            System.out.print( (a+1) + \"^5 + \"\n                                            + (b+1) + \"^5 + \"\n                                            + (c+1) + \"^5 + \"\n                                            + (d+1) + \"^5 = \"\n                                            + (e+1) + \"^5\"\n                                            );\n                        } \n                    } \n                } \n            } \n        } \n    } \n\n} \n"}
{"id": 84265, "name": "Euler's sum of powers conjecture", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       FILE SECTION.\n       WORKING-STORAGE SECTION.\n       1   TABLE-LENGTH CONSTANT 250.\n       1   SEARCHING-FLAG     PIC 9.\n        88  FINISHED-SEARCHING VALUE IS 1\n                               WHEN SET TO FALSE IS 0.\n       1  CALC.\n        3  A               PIC 999 USAGE COMPUTATIONAL-5.\n        3  B               PIC 999 USAGE COMPUTATIONAL-5.\n        3  C               PIC 999 USAGE COMPUTATIONAL-5.\n        3  D               PIC 999 USAGE COMPUTATIONAL-5.\n        3  ABCD            PIC 9(18) USAGE COMPUTATIONAL-5.\n        3  FIFTH-ROOT-OFFS PIC 999 USAGE COMPUTATIONAL-5.\n        3  POWER-COUNTER   PIC 999 USAGE COMPUTATIONAL-5.\n        88 POWER-MAX       VALUE TABLE-LENGTH.\n       \n       1   PRETTY.\n        3  A               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  B               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  C               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  D               PIC ZZ9.\n        3  FILLER          VALUE \"^5 = \".\n        3  FIFTH-ROOT-OFFS PIC ZZ9.\n        3  FILLER          VALUE \"^5.\".\n\n       1   FIFTH-POWER-TABLE   OCCURS TABLE-LENGTH TIMES\n                               ASCENDING KEY IS FIFTH-POWER\n                               INDEXED BY POWER-INDEX.\n        3  FIFTH-POWER PIC 9(18) USAGE COMPUTATIONAL-5.\n\n\n       PROCEDURE DIVISION.\n       MAIN-PARAGRAPH.\n           SET FINISHED-SEARCHING TO FALSE.\n           PERFORM POWERS-OF-FIVE-TABLE-INIT.\n           PERFORM VARYING\n               A IN CALC\n               FROM 1 BY 1 UNTIL A IN CALC = TABLE-LENGTH\n\n               AFTER B IN CALC\n               FROM 1 BY 1 UNTIL B IN CALC = A IN CALC\n\n               AFTER C IN CALC\n               FROM 1 BY 1 UNTIL C IN CALC = B IN CALC\n\n               AFTER D IN CALC\n               FROM 1 BY 1 UNTIL D IN CALC = C IN CALC\n\n               IF FINISHED-SEARCHING\n                   STOP RUN\n               END-IF\n\n               PERFORM POWER-COMPUTATIONS\n\n           END-PERFORM.\n\n       POWER-COMPUTATIONS.\n\n           MOVE ZERO TO ABCD IN CALC.\n\n           ADD FIFTH-POWER(A IN CALC)\n               FIFTH-POWER(B IN CALC)\n               FIFTH-POWER(C IN CALC)\n               FIFTH-POWER(D IN CALC)\n                   TO ABCD IN CALC.\n\n           SET POWER-INDEX TO 1.\n\n           SEARCH ALL FIFTH-POWER-TABLE\n               WHEN FIFTH-POWER(POWER-INDEX) = ABCD IN CALC\n                      MOVE POWER-INDEX TO FIFTH-ROOT-OFFS IN CALC\n                      MOVE CORRESPONDING CALC TO PRETTY\n                      DISPLAY PRETTY END-DISPLAY\n                      SET FINISHED-SEARCHING TO TRUE\n           END-SEARCH\n\n           EXIT PARAGRAPH.\n\n       POWERS-OF-FIVE-TABLE-INIT.\n           PERFORM VARYING POWER-COUNTER FROM 1 BY 1 UNTIL POWER-MAX\n               COMPUTE FIFTH-POWER(POWER-COUNTER) = \n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER \n               END-COMPUTE\n           END-PERFORM.\n           EXIT PARAGRAPH.\n\n       END PROGRAM EULER.\n", "target": "public class eulerSopConjecture\n{\n\n    static final int    MAX_NUMBER = 250;\n\n    public static void main( String[] args )\n    {\n        boolean found = false;\n        long[]  fifth = new long[ MAX_NUMBER ];\n\n        for( int i = 1; i <= MAX_NUMBER; i ++ )\n        {\n            long i2 =  i * i;\n            fifth[ i - 1 ] = i2 * i2 * i;\n        } \n\n        for( int a = 0; a < MAX_NUMBER && ! found ; a ++ )\n        {\n            for( int b = a; b < MAX_NUMBER && ! found ; b ++ )\n            {\n                for( int c = b; c < MAX_NUMBER && ! found ; c ++ )\n                {\n                    for( int d = c; d < MAX_NUMBER && ! found ; d ++ )\n                    {\n                        long sum  = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                        int  e = java.util.Arrays.binarySearch( fifth, sum );\n                        found  = ( e >= 0 );\n                        if( found )\n                        {\n                            \n                            System.out.print( (a+1) + \"^5 + \"\n                                            + (b+1) + \"^5 + \"\n                                            + (c+1) + \"^5 + \"\n                                            + (d+1) + \"^5 = \"\n                                            + (e+1) + \"^5\"\n                                            );\n                        } \n                    } \n                } \n            } \n        } \n    } \n\n} \n"}
{"id": 84266, "name": "Euler's sum of powers conjecture", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       FILE SECTION.\n       WORKING-STORAGE SECTION.\n       1   TABLE-LENGTH CONSTANT 250.\n       1   SEARCHING-FLAG     PIC 9.\n        88  FINISHED-SEARCHING VALUE IS 1\n                               WHEN SET TO FALSE IS 0.\n       1  CALC.\n        3  A               PIC 999 USAGE COMPUTATIONAL-5.\n        3  B               PIC 999 USAGE COMPUTATIONAL-5.\n        3  C               PIC 999 USAGE COMPUTATIONAL-5.\n        3  D               PIC 999 USAGE COMPUTATIONAL-5.\n        3  ABCD            PIC 9(18) USAGE COMPUTATIONAL-5.\n        3  FIFTH-ROOT-OFFS PIC 999 USAGE COMPUTATIONAL-5.\n        3  POWER-COUNTER   PIC 999 USAGE COMPUTATIONAL-5.\n        88 POWER-MAX       VALUE TABLE-LENGTH.\n       \n       1   PRETTY.\n        3  A               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  B               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  C               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  D               PIC ZZ9.\n        3  FILLER          VALUE \"^5 = \".\n        3  FIFTH-ROOT-OFFS PIC ZZ9.\n        3  FILLER          VALUE \"^5.\".\n\n       1   FIFTH-POWER-TABLE   OCCURS TABLE-LENGTH TIMES\n                               ASCENDING KEY IS FIFTH-POWER\n                               INDEXED BY POWER-INDEX.\n        3  FIFTH-POWER PIC 9(18) USAGE COMPUTATIONAL-5.\n\n\n       PROCEDURE DIVISION.\n       MAIN-PARAGRAPH.\n           SET FINISHED-SEARCHING TO FALSE.\n           PERFORM POWERS-OF-FIVE-TABLE-INIT.\n           PERFORM VARYING\n               A IN CALC\n               FROM 1 BY 1 UNTIL A IN CALC = TABLE-LENGTH\n\n               AFTER B IN CALC\n               FROM 1 BY 1 UNTIL B IN CALC = A IN CALC\n\n               AFTER C IN CALC\n               FROM 1 BY 1 UNTIL C IN CALC = B IN CALC\n\n               AFTER D IN CALC\n               FROM 1 BY 1 UNTIL D IN CALC = C IN CALC\n\n               IF FINISHED-SEARCHING\n                   STOP RUN\n               END-IF\n\n               PERFORM POWER-COMPUTATIONS\n\n           END-PERFORM.\n\n       POWER-COMPUTATIONS.\n\n           MOVE ZERO TO ABCD IN CALC.\n\n           ADD FIFTH-POWER(A IN CALC)\n               FIFTH-POWER(B IN CALC)\n               FIFTH-POWER(C IN CALC)\n               FIFTH-POWER(D IN CALC)\n                   TO ABCD IN CALC.\n\n           SET POWER-INDEX TO 1.\n\n           SEARCH ALL FIFTH-POWER-TABLE\n               WHEN FIFTH-POWER(POWER-INDEX) = ABCD IN CALC\n                      MOVE POWER-INDEX TO FIFTH-ROOT-OFFS IN CALC\n                      MOVE CORRESPONDING CALC TO PRETTY\n                      DISPLAY PRETTY END-DISPLAY\n                      SET FINISHED-SEARCHING TO TRUE\n           END-SEARCH\n\n           EXIT PARAGRAPH.\n\n       POWERS-OF-FIVE-TABLE-INIT.\n           PERFORM VARYING POWER-COUNTER FROM 1 BY 1 UNTIL POWER-MAX\n               COMPUTE FIFTH-POWER(POWER-COUNTER) = \n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER \n               END-COMPUTE\n           END-PERFORM.\n           EXIT PARAGRAPH.\n\n       END PROGRAM EULER.\n", "target": "def eulers_sum_of_powers():\n    max_n = 250\n    pow_5 = [n**5 for n in range(max_n)]\n    pow5_to_n = {n**5: n for n in range(max_n)}\n    for x0 in range(1, max_n):\n        for x1 in range(1, x0):\n            for x2 in range(1, x1):\n                for x3 in range(1, x2):\n                    pow_5_sum = sum(pow_5[i] for i in (x0, x1, x2, x3))\n                    if pow_5_sum in pow5_to_n:\n                        y = pow5_to_n[pow_5_sum]\n                        return (x0, x1, x2, x3, y)\n\nprint(\"%i**5 + %i**5 + %i**5 + %i**5 == %i**5\" % eulers_sum_of_powers())\n"}
{"id": 84267, "name": "Euler's sum of powers conjecture", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       FILE SECTION.\n       WORKING-STORAGE SECTION.\n       1   TABLE-LENGTH CONSTANT 250.\n       1   SEARCHING-FLAG     PIC 9.\n        88  FINISHED-SEARCHING VALUE IS 1\n                               WHEN SET TO FALSE IS 0.\n       1  CALC.\n        3  A               PIC 999 USAGE COMPUTATIONAL-5.\n        3  B               PIC 999 USAGE COMPUTATIONAL-5.\n        3  C               PIC 999 USAGE COMPUTATIONAL-5.\n        3  D               PIC 999 USAGE COMPUTATIONAL-5.\n        3  ABCD            PIC 9(18) USAGE COMPUTATIONAL-5.\n        3  FIFTH-ROOT-OFFS PIC 999 USAGE COMPUTATIONAL-5.\n        3  POWER-COUNTER   PIC 999 USAGE COMPUTATIONAL-5.\n        88 POWER-MAX       VALUE TABLE-LENGTH.\n       \n       1   PRETTY.\n        3  A               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  B               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  C               PIC ZZ9.\n        3  FILLER          VALUE \"^5 + \".\n        3  D               PIC ZZ9.\n        3  FILLER          VALUE \"^5 = \".\n        3  FIFTH-ROOT-OFFS PIC ZZ9.\n        3  FILLER          VALUE \"^5.\".\n\n       1   FIFTH-POWER-TABLE   OCCURS TABLE-LENGTH TIMES\n                               ASCENDING KEY IS FIFTH-POWER\n                               INDEXED BY POWER-INDEX.\n        3  FIFTH-POWER PIC 9(18) USAGE COMPUTATIONAL-5.\n\n\n       PROCEDURE DIVISION.\n       MAIN-PARAGRAPH.\n           SET FINISHED-SEARCHING TO FALSE.\n           PERFORM POWERS-OF-FIVE-TABLE-INIT.\n           PERFORM VARYING\n               A IN CALC\n               FROM 1 BY 1 UNTIL A IN CALC = TABLE-LENGTH\n\n               AFTER B IN CALC\n               FROM 1 BY 1 UNTIL B IN CALC = A IN CALC\n\n               AFTER C IN CALC\n               FROM 1 BY 1 UNTIL C IN CALC = B IN CALC\n\n               AFTER D IN CALC\n               FROM 1 BY 1 UNTIL D IN CALC = C IN CALC\n\n               IF FINISHED-SEARCHING\n                   STOP RUN\n               END-IF\n\n               PERFORM POWER-COMPUTATIONS\n\n           END-PERFORM.\n\n       POWER-COMPUTATIONS.\n\n           MOVE ZERO TO ABCD IN CALC.\n\n           ADD FIFTH-POWER(A IN CALC)\n               FIFTH-POWER(B IN CALC)\n               FIFTH-POWER(C IN CALC)\n               FIFTH-POWER(D IN CALC)\n                   TO ABCD IN CALC.\n\n           SET POWER-INDEX TO 1.\n\n           SEARCH ALL FIFTH-POWER-TABLE\n               WHEN FIFTH-POWER(POWER-INDEX) = ABCD IN CALC\n                      MOVE POWER-INDEX TO FIFTH-ROOT-OFFS IN CALC\n                      MOVE CORRESPONDING CALC TO PRETTY\n                      DISPLAY PRETTY END-DISPLAY\n                      SET FINISHED-SEARCHING TO TRUE\n           END-SEARCH\n\n           EXIT PARAGRAPH.\n\n       POWERS-OF-FIVE-TABLE-INIT.\n           PERFORM VARYING POWER-COUNTER FROM 1 BY 1 UNTIL POWER-MAX\n               COMPUTE FIFTH-POWER(POWER-COUNTER) = \n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER *\n                   POWER-COUNTER \n               END-COMPUTE\n           END-PERFORM.\n           EXIT PARAGRAPH.\n\n       END PROGRAM EULER.\n", "target": "def eulers_sum_of_powers():\n    max_n = 250\n    pow_5 = [n**5 for n in range(max_n)]\n    pow5_to_n = {n**5: n for n in range(max_n)}\n    for x0 in range(1, max_n):\n        for x1 in range(1, x0):\n            for x2 in range(1, x1):\n                for x3 in range(1, x2):\n                    pow_5_sum = sum(pow_5[i] for i in (x0, x1, x2, x3))\n                    if pow_5_sum in pow5_to_n:\n                        y = pow5_to_n[pow_5_sum]\n                        return (x0, x1, x2, x3, y)\n\nprint(\"%i**5 + %i**5 + %i**5 + %i**5 == %i**5\" % eulers_sum_of_powers())\n"}
{"id": 85005, "name": "Primality by trial division", "source": "Translate COBOL to C#:        Identification Division.\n       Program-Id. Primality-By-Subdiv.\n\n       Data Division.\n       Working-Storage Section.\n       78  True-Val  Value 0.\n       78  False-Val Value 1.\n\n       Local-Storage Section.\n       01  lim Pic 9(10).\n       01  i   Pic 9(10).\n\n       Linkage Section.\n       01  num    Pic 9(10).\n       01  result Pic 9.\n\n       Procedure Division Using num result.\n       Main.\n           If num <= 1\n               Move False-Val To result\n               Goback\n           Else If num = 2\n               Move True-Val To result\n               Goback\n           End-If\n\n           Compute lim = Function Sqrt(num) + 1\n           Perform Varying i From 3 By 1 Until lim < i\n               If Function Mod(num, i) = 0\n                   Move False-Val To result\n                   Goback\n               End-If\n           End-Perform\n\n           Move True-Val To Result\n\n           Goback\n           .\n", "target": "static bool isPrime(int n)\n        {\n            if (n <= 1) return false;\n            for (int i = 2; i * i <= n; i++)            \n                if (n % i == 0) return false;            \n            return true;\n        }\n"}
{"id": 85007, "name": "Primality by trial division", "source": "Translate COBOL to Java:        Identification Division.\n       Program-Id. Primality-By-Subdiv.\n\n       Data Division.\n       Working-Storage Section.\n       78  True-Val  Value 0.\n       78  False-Val Value 1.\n\n       Local-Storage Section.\n       01  lim Pic 9(10).\n       01  i   Pic 9(10).\n\n       Linkage Section.\n       01  num    Pic 9(10).\n       01  result Pic 9.\n\n       Procedure Division Using num result.\n       Main.\n           If num <= 1\n               Move False-Val To result\n               Goback\n           Else If num = 2\n               Move True-Val To result\n               Goback\n           End-If\n\n           Compute lim = Function Sqrt(num) + 1\n           Perform Varying i From 3 By 1 Until lim < i\n               If Function Mod(num, i) = 0\n                   Move False-Val To result\n                   Goback\n               End-If\n           End-Perform\n\n           Move True-Val To Result\n\n           Goback\n           .\n", "target": "public static boolean prime(long a){\n   if(a == 2){\n      return true;\n   }else if(a <= 1 || a % 2 == 0){\n      return false;\n   }\n   long max = (long)Math.sqrt(a);\n   for(long n= 3; n <= max; n+= 2){\n      if(a % n == 0){ return false; }\n   }\n   return true;\n}\n"}
{"id": 85008, "name": "Primality by trial division", "source": "Translate COBOL to Python:        Identification Division.\n       Program-Id. Primality-By-Subdiv.\n\n       Data Division.\n       Working-Storage Section.\n       78  True-Val  Value 0.\n       78  False-Val Value 1.\n\n       Local-Storage Section.\n       01  lim Pic 9(10).\n       01  i   Pic 9(10).\n\n       Linkage Section.\n       01  num    Pic 9(10).\n       01  result Pic 9.\n\n       Procedure Division Using num result.\n       Main.\n           If num <= 1\n               Move False-Val To result\n               Goback\n           Else If num = 2\n               Move True-Val To result\n               Goback\n           End-If\n\n           Compute lim = Function Sqrt(num) + 1\n           Perform Varying i From 3 By 1 Until lim < i\n               If Function Mod(num, i) = 0\n                   Move False-Val To result\n                   Goback\n               End-If\n           End-Perform\n\n           Move True-Val To Result\n\n           Goback\n           .\n", "target": "def prime(a):\n    return not (a < 2 or any(a % x == 0 for x in xrange(2, int(a**0.5) + 1)))\n"}
{"id": 85264, "name": "MD5", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. MD5.\n       AUTHOR.  Bill Gunshannon\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   Use the md5sum utility and pass the HASH back using\n      **     a temp file.  Not elegant, but it works.\n      ************************************************************\n       \n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Tmp-MD5 ASSIGN TO \"/tmp/MD5\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n\n\n       DATA DIVISION.\n\n       FILE SECTION.\n       \n       FD  Tmp-MD5\n           DATA RECORD IS MD5-Rec.\n       01  MD5-Rec       PIC X(32).\n\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       01 Str1.\n          05  Pre-cmd   PIC X(8)\n              VALUE 'echo -n '.\n          05  Str1-complete.\n              10  Str1-Part1  PIC X(26)\n                  VALUE  'The quick brown fox jumps'.\n              10  Str1-Part2  PIC X(19)\n                  VALUE  ' over the lazy dog'.\n          05  Post-cmd    PIC X(20)\n              VALUE  ' | md5sum > /tmp/MD5'.\n       01  Str1-MD5          PIC X(32).\n       \n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n\n           DISPLAY Str1-complete.\n           PERFORM Get-MD5.\n           DISPLAY Str1-MD5.\n\n           STOP RUN.\n\n       Get-MD5.\n       \n           CALL \"SYSTEM\" USING Str1.\n           OPEN INPUT Tmp-MD5.\n           READ Tmp-MD5 INTO Str1-MD5.\n           CLOSE Tmp-MD5.\n           CALL \"CBL_DELETE_FILE\" USING '/tmp/MD5'.\n", "target": "using System.Text;\nusing System.Security.Cryptography;\n\nbyte[] data = Encoding.ASCII.GetBytes(\"The quick brown fox jumped over the lazy dog's back\");\nbyte[] hash = MD5.Create().ComputeHash(data);\nConsole.WriteLine(BitConverter.ToString(hash).Replace(\"-\", \"\").ToLower());\n"}
{"id": 85266, "name": "MD5", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. MD5.\n       AUTHOR.  Bill Gunshannon\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   Use the md5sum utility and pass the HASH back using\n      **     a temp file.  Not elegant, but it works.\n      ************************************************************\n       \n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Tmp-MD5 ASSIGN TO \"/tmp/MD5\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n\n\n       DATA DIVISION.\n\n       FILE SECTION.\n       \n       FD  Tmp-MD5\n           DATA RECORD IS MD5-Rec.\n       01  MD5-Rec       PIC X(32).\n\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       01 Str1.\n          05  Pre-cmd   PIC X(8)\n              VALUE 'echo -n '.\n          05  Str1-complete.\n              10  Str1-Part1  PIC X(26)\n                  VALUE  'The quick brown fox jumps'.\n              10  Str1-Part2  PIC X(19)\n                  VALUE  ' over the lazy dog'.\n          05  Post-cmd    PIC X(20)\n              VALUE  ' | md5sum > /tmp/MD5'.\n       01  Str1-MD5          PIC X(32).\n       \n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n\n           DISPLAY Str1-complete.\n           PERFORM Get-MD5.\n           DISPLAY Str1-MD5.\n\n           STOP RUN.\n\n       Get-MD5.\n       \n           CALL \"SYSTEM\" USING Str1.\n           OPEN INPUT Tmp-MD5.\n           READ Tmp-MD5 INTO Str1-MD5.\n           CLOSE Tmp-MD5.\n           CALL \"CBL_DELETE_FILE\" USING '/tmp/MD5'.\n", "target": "import java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class Digester {\n\n    public static void main(String[] args) {\n        System.out.println(hexDigest(\"Rosetta code\", \"MD5\"));\n    }\n\n    static String hexDigest(String str, String digestName) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(digestName);\n            byte[] digest = md.digest(str.getBytes(StandardCharsets.UTF_8));\n            char[] hex = new char[digest.length * 2];\n            for (int i = 0; i < digest.length; i++) {\n                hex[2 * i] = \"0123456789abcdef\".charAt((digest[i] & 0xf0) >> 4);\n                hex[2 * i + 1] = \"0123456789abcdef\".charAt(digest[i] & 0x0f);\n            }\n            return new String(hex);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n}\n"}
{"id": 85267, "name": "MD5", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. MD5.\n       AUTHOR.  Bill Gunshannon\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   Use the md5sum utility and pass the HASH back using\n      **     a temp file.  Not elegant, but it works.\n      ************************************************************\n       \n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Tmp-MD5 ASSIGN TO \"/tmp/MD5\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n\n\n       DATA DIVISION.\n\n       FILE SECTION.\n       \n       FD  Tmp-MD5\n           DATA RECORD IS MD5-Rec.\n       01  MD5-Rec       PIC X(32).\n\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       01 Str1.\n          05  Pre-cmd   PIC X(8)\n              VALUE 'echo -n '.\n          05  Str1-complete.\n              10  Str1-Part1  PIC X(26)\n                  VALUE  'The quick brown fox jumps'.\n              10  Str1-Part2  PIC X(19)\n                  VALUE  ' over the lazy dog'.\n          05  Post-cmd    PIC X(20)\n              VALUE  ' | md5sum > /tmp/MD5'.\n       01  Str1-MD5          PIC X(32).\n       \n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n\n           DISPLAY Str1-complete.\n           PERFORM Get-MD5.\n           DISPLAY Str1-MD5.\n\n           STOP RUN.\n\n       Get-MD5.\n       \n           CALL \"SYSTEM\" USING Str1.\n           OPEN INPUT Tmp-MD5.\n           READ Tmp-MD5 INTO Str1-MD5.\n           CLOSE Tmp-MD5.\n           CALL \"CBL_DELETE_FILE\" USING '/tmp/MD5'.\n", "target": ">>> import hashlib\n>>> \n>>> tests = (\n  (b\"\", 'd41d8cd98f00b204e9800998ecf8427e'),\n  (b\"a\", '0cc175b9c0f1b6a831c399e269772661'),\n  (b\"abc\", '900150983cd24fb0d6963f7d28e17f72'),\n  (b\"message digest\", 'f96b697d7cb7938d525a2f31aaf161d0'),\n  (b\"abcdefghijklmnopqrstuvwxyz\", 'c3fcd3d76192e4007dfb496cca67e13b'),\n  (b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", 'd174ab98d277d9f5a5611c2c9f419d9f'),\n  (b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", '57edf4a22be3c955ac49da2e2107b67a') )\n>>> for text, golden in tests: assert hashlib.md5(text).hexdigest() == golden\n\n>>>\n"}
{"id": 85923, "name": "Binary search", "source": "Translate COBOL to C#:         >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. binary-search.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  nums-area                           VALUE \"01040612184356\".\n    03  nums                            PIC 9(2)\n                                        OCCURS 7 TIMES\n                                        ASCENDING KEY nums\n                                        INDEXED BY nums-idx.\nPROCEDURE DIVISION.\n    SEARCH ALL nums\n        WHEN nums (nums-idx) = 4\n            DISPLAY \"Found 4 at index \" nums-idx\n    END-SEARCH\n    .\nEND PROGRAM binary-search.\n", "target": "namespace Search {\n  using System;\n\n  public static partial class Extensions {\n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForGLB<T>(this T[] entries, T value)\n      where T : IComparable {\n      return entries.RecursiveBinarySearchForGLB(value, 0, entries.Length - 1);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForGLB<T>(this T[] entries, T value, int left, int right)\n      where T : IComparable {\n      if (left <= right) {\n        var middle = left + (right - left) / 2;\n        return entries[middle].CompareTo(value) < 0 ?\n          entries.RecursiveBinarySearchForGLB(value, middle + 1, right) :\n          entries.RecursiveBinarySearchForGLB(value, left, middle - 1);\n      }\n\n      \n      \n      return right;\n    }\n\n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForLUB<T>(this T[] entries, T value)\n      where T : IComparable {\n      return entries.RecursiveBinarySearchForLUB(value, 0, entries.Length - 1);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForLUB<T>(this T[] entries, T value, int left, int right)\n      where T : IComparable {\n      if (left <= right) {\n        var middle = left + (right - left) / 2;\n        return entries[middle].CompareTo(value) <= 0 ?\n          entries.RecursiveBinarySearchForLUB(value, middle + 1, right) :\n          entries.RecursiveBinarySearchForLUB(value, left, middle - 1);\n      }\n\n      \n      \n      return left;\n    }\n  }\n}\n"}
{"id": 85925, "name": "Binary search", "source": "Translate COBOL to Java:         >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. binary-search.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  nums-area                           VALUE \"01040612184356\".\n    03  nums                            PIC 9(2)\n                                        OCCURS 7 TIMES\n                                        ASCENDING KEY nums\n                                        INDEXED BY nums-idx.\nPROCEDURE DIVISION.\n    SEARCH ALL nums\n        WHEN nums (nums-idx) = 4\n            DISPLAY \"Found 4 at index \" nums-idx\n    END-SEARCH\n    .\nEND PROGRAM binary-search.\n", "target": "public class BinarySearchIterative {\n\n    public static int binarySearch(int[] nums, int check) {\n        int hi = nums.length - 1;\n        int lo = 0;\n        while (hi >= lo) {\n            int guess = (lo + hi) >>> 1;  \n            if (nums[guess] > check) {\n                hi = guess - 1;\n            } else if (nums[guess] < check) {\n                lo = guess + 1;\n            } else {\n                return guess;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] haystack = {1, 5, 6, 7, 8, 11};\n        int needle = 5;\n        int index = binarySearch(haystack, needle);\n        if (index == -1) {\n            System.out.println(needle + \" is not in the array\");\n        } else {\n            System.out.println(needle + \" is at index \" + index);\n        }\n    }\n}\n"}
{"id": 85926, "name": "Binary search", "source": "Translate COBOL to Python:         >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. binary-search.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  nums-area                           VALUE \"01040612184356\".\n    03  nums                            PIC 9(2)\n                                        OCCURS 7 TIMES\n                                        ASCENDING KEY nums\n                                        INDEXED BY nums-idx.\nPROCEDURE DIVISION.\n    SEARCH ALL nums\n        WHEN nums (nums-idx) = 4\n            DISPLAY \"Found 4 at index \" nums-idx\n    END-SEARCH\n    .\nEND PROGRAM binary-search.\n", "target": "def binary_search(l, value):\n    low = 0\n    high = len(l)-1\n    while low <= high: \n        mid = (low+high)//2\n        if l[mid] > value: high = mid-1\n        elif l[mid] < value: low = mid+1\n        else: return mid\n    return -1\n"}
{"id": 86095, "name": "Documentation", "source": "Translate COBOL to C#:       \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n       REPLACE ==FIELDSIZE== BY ==80==\n               ==AREASIZE==  BY ==32768==\n               ==FILESIZE==  BY ==65536==.\n\nid     identification division.\n       program-id. cobweb-gtk.\n\n       ...\n\ndone   goback.\n       end program cobweb-gtk.\n      \n", "target": "\n\n\npublic static class XMLSystem\n{\n    static XMLSystem()\n    {\n        \n    }\n\n    \n    \n    \n    \n    \n    public static XmlDocument GetXML(string name) \n    {\n        return null;\n    }\n}\n"}
{"id": 86096, "name": "Documentation", "source": "Translate COBOL to Java:       \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n       REPLACE ==FIELDSIZE== BY ==80==\n               ==AREASIZE==  BY ==32768==\n               ==FILESIZE==  BY ==65536==.\n\nid     identification division.\n       program-id. cobweb-gtk.\n\n       ...\n\ndone   goback.\n       end program cobweb-gtk.\n      \n", "target": "\npublic class Doc{\n   \n   private String field;\n\n   \n   public int method(long num) throws BadException{\n      \n   }\n}\n"}
{"id": 86097, "name": "Documentation", "source": "Translate COBOL to Python:       \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n       REPLACE ==FIELDSIZE== BY ==80==\n               ==AREASIZE==  BY ==32768==\n               ==FILESIZE==  BY ==65536==.\n\nid     identification division.\n       program-id. cobweb-gtk.\n\n       ...\n\ndone   goback.\n       end program cobweb-gtk.\n      \n", "target": "class Doc(object):\n   \n   def method(self, num):\n      \n      pass\n"}
{"id": 87730, "name": "String length", "source": "Translate COBOL to Java: FUNCTION BYTE-LENGTH(str)\n", "target": "String s = \"Hello, world!\"; \nint byteCountUTF16 = s.getBytes(\"UTF-16\").length; \nint byteCountUTF16LE = s.getBytes(\"UTF-16LE\").length; \nint byteCountUTF8  = s.getBytes(\"UTF-8\").length; \n"}
{"id": 88574, "name": "Sorting algorithms_Insertion sort", "source": "Translate COBOL to C#:        C-PROCESS SECTION.\n           PERFORM E-INSERTION VARYING WB-IX-1 FROM 1 BY 1\n                               UNTIL WB-IX-1 > WC-SIZE.\n\n...\n\n       E-INSERTION SECTION.\n       E-000.\n           MOVE WB-ENTRY(WB-IX-1) TO WC-TEMP.\n           SET WB-IX-2 TO WB-IX-1.\n\n           PERFORM F-PASS UNTIL WB-IX-2 NOT > 1 OR\n                                WC-TEMP NOT < WB-ENTRY(WB-IX-2 - 1).\n\n           IF WB-IX-1 NOT = WB-IX-2\n              MOVE WC-TEMP TO WB-ENTRY(WB-IX-2).\n\n       E-999.\n           EXIT.\n\n       F-PASS SECTION.\n       F-000.\n           MOVE WB-ENTRY(WB-IX-2 - 1) TO WB-ENTRY(WB-IX-2).\n           SET WB-IX-2                DOWN BY 1.\n\n       F-999.\n           EXIT.\n", "target": "namespace Sort {\n  using System;\n\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries) {\n      Sort(entries, 0, entries.Length - 1);\n    }\n\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var i = first + 1; i <= last; i++) {\n        var entry = entries[i];\n        var j = i;\n\n        while (j > first && entries[j - 1].CompareTo(entry) > 0)\n          entries[j] = entries[--j];\n\n        entries[j] = entry;\n      }\n    }\n  }\n}\n"}
{"id": 88576, "name": "Sorting algorithms_Insertion sort", "source": "Translate COBOL to Java:        C-PROCESS SECTION.\n           PERFORM E-INSERTION VARYING WB-IX-1 FROM 1 BY 1\n                               UNTIL WB-IX-1 > WC-SIZE.\n\n...\n\n       E-INSERTION SECTION.\n       E-000.\n           MOVE WB-ENTRY(WB-IX-1) TO WC-TEMP.\n           SET WB-IX-2 TO WB-IX-1.\n\n           PERFORM F-PASS UNTIL WB-IX-2 NOT > 1 OR\n                                WC-TEMP NOT < WB-ENTRY(WB-IX-2 - 1).\n\n           IF WB-IX-1 NOT = WB-IX-2\n              MOVE WC-TEMP TO WB-ENTRY(WB-IX-2).\n\n       E-999.\n           EXIT.\n\n       F-PASS SECTION.\n       F-000.\n           MOVE WB-ENTRY(WB-IX-2 - 1) TO WB-ENTRY(WB-IX-2).\n           SET WB-IX-2                DOWN BY 1.\n\n       F-999.\n           EXIT.\n", "target": "public static void insertSort(int[] A){\n  for(int i = 1; i < A.length; i++){\n    int value = A[i];\n    int j = i - 1;\n    while(j >= 0 && A[j] > value){\n      A[j + 1] = A[j];\n      j = j - 1;\n    }\n    A[j + 1] = value;\n  }\n}\n"}
{"id": 88577, "name": "Sorting algorithms_Insertion sort", "source": "Translate COBOL to Python:        C-PROCESS SECTION.\n           PERFORM E-INSERTION VARYING WB-IX-1 FROM 1 BY 1\n                               UNTIL WB-IX-1 > WC-SIZE.\n\n...\n\n       E-INSERTION SECTION.\n       E-000.\n           MOVE WB-ENTRY(WB-IX-1) TO WC-TEMP.\n           SET WB-IX-2 TO WB-IX-1.\n\n           PERFORM F-PASS UNTIL WB-IX-2 NOT > 1 OR\n                                WC-TEMP NOT < WB-ENTRY(WB-IX-2 - 1).\n\n           IF WB-IX-1 NOT = WB-IX-2\n              MOVE WC-TEMP TO WB-ENTRY(WB-IX-2).\n\n       E-999.\n           EXIT.\n\n       F-PASS SECTION.\n       F-000.\n           MOVE WB-ENTRY(WB-IX-2 - 1) TO WB-ENTRY(WB-IX-2).\n           SET WB-IX-2                DOWN BY 1.\n\n       F-999.\n           EXIT.\n", "target": "def insertion_sort(L):\n    for i in xrange(1, len(L)):\n        j = i-1 \n        key = L[i]\n        while j >= 0 and L[j] > key:\n           L[j+1] = L[j]\n           j -= 1\n        L[j+1] = key\n"}
{"id": 88995, "name": "Angle difference between two bearings", "source": "Translate COBOL to C#:       ******************************************************************\n      * COBOL solution to Angle difference challange\n      * The program was run on OpenCobolIDE\n      * I chose to read the input data from a .txt file that I\n      *    created on my PC rather than to hard code it into the\n      *    program or enter it as the program was executing.\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ANGLE-DIFFERENCE.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n           SELECT IN-FILE ASSIGN TO 'C:\\Both\\Rosetta\\Angle_diff.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n       FD IN-FILE.\n       01 IN-RECORD.\n           05  ALPHA-BEARING-1          PIC X(20).\n           05  FILLER                   PIC X.\n           05  ALPHA-BEARING-2          PIC X(20).\n\n       WORKING-STORAGE SECTION.\n       01  SWITCHES.\n           05 EOF-SWITCH                PIC X VALUE 'N'.\n\n       01 COUNTERS.\n           05 REC-CTR                   PIC 9(3) VALUE 0.\n\n       01  WS-ALPHA-BEARING.\n           05  WS-AB-SIGN               PIC X.\n               88  WS-AB-NEGATIVE       VALUE \"-\".\n           05  WS-AB-INTEGER-PART       PIC X(6).\n           05  WS-AB-DEC-POINT          PIC X.\n           05  WS-AB-DECIMAL-PART       PIC X(12).\n\n       01  WS-BEARING-1                 PIC S9(6)V9(12).\n       01  WS-BEARING-2                 PIC S9(6)V9(12).\n\n       01  WS-BEARING                   PIC S9(6)V9(12).\n       01  FILLER REDEFINES WS-BEARING.\n           05  WSB-INTEGER-PART         PIC X(6).\n           05  WSB-DECIMAL-PART         PIC X9(12).\n\n       77  WS-RESULT                    PIC S9(6)V9(12).\n       77  WS-RESULT-POS                PIC 9(6)V9(12).\n       77  WS-INTEGER-PART              PIC 9(6).\n       77  WS-DECIMAL-PART              PIC V9(12).\n       77  WS-RESULT-OUT                PIC ------9.9999.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           PERFORM 100-INITIALIZE.\n           PERFORM 200-PROCESS-RECORD\n               UNTIL EOF-SWITCH = 'Y'.\n           PERFORM 300-TERMINATE.\n           STOP RUN.\n\n       100-INITIALIZE.\n           OPEN INPUT IN-FILE.\n           PERFORM 150-READ-RECORD.\n\n       150-READ-RECORD.\n           READ IN-FILE\n               AT END\n                   MOVE 'Y' TO EOF-SWITCH\n               NOT AT END\n                   COMPUTE REC-CTR = REC-CTR + 1\n               END-READ.\n\n       200-PROCESS-RECORD.\n           MOVE ALPHA-BEARING-1 TO WS-ALPHA-BEARING.\n           PERFORM 250-CONVERT-DATA.\n           MOVE WS-BEARING TO WS-BEARING-1.\n\n           MOVE ALPHA-BEARING-2 TO WS-ALPHA-BEARING.\n           PERFORM 250-CONVERT-DATA.\n           MOVE WS-BEARING TO WS-BEARING-2.\n\n           COMPUTE WS-RESULT = WS-BEARING-2 - WS-BEARING-1.\n           MOVE WS-RESULT TO WS-RESULT-POS.\n           MOVE WS-RESULT-POS TO WS-INTEGER-PART.\n           COMPUTE WS-DECIMAL-PART = WS-RESULT-POS - WS-INTEGER-PART.\n           COMPUTE WS-INTEGER-PART = FUNCTION MOD(WS-INTEGER-PART 360).\n           IF WS-RESULT > 0\n               COMPUTE WS-RESULT = WS-INTEGER-PART + WS-DECIMAL-PART\n           ELSE\n               COMPUTE WS-RESULT =\n                   (WS-INTEGER-PART + WS-DECIMAL-PART) * -1\n           END-IF.\n\n           IF WS-RESULT < -180\n               COMPUTE WS-RESULT = WS-RESULT + 360.\n           IF WS-RESULT > 180\n               COMPUTE WS-RESULT = WS-RESULT - 360.\n           COMPUTE WS-RESULT-OUT ROUNDED = WS-RESULT.\n\n           DISPLAY REC-CTR ' ' WS-RESULT-OUT.\n\n           PERFORM 150-READ-RECORD.\n\n       250-CONVERT-DATA.\n           MOVE WS-AB-INTEGER-PART      TO WSB-INTEGER-PART.\n           MOVE WS-AB-DECIMAL-PART      TO WSB-DECIMAL-PART.\n           IF WS-AB-NEGATIVE\n               SUBTRACT WS-BEARING      FROM ZERO\n                 GIVING                 WS-BEARING\n           END-IF.\n\n       300-TERMINATE.\n           DISPLAY 'RECORDS PROCESSED: ' REC-CTR.\n           CLOSE IN-FILE.\n\n      ******************************************************************\n      *    INPUT FILE ('Angle_diff.txt' stored on my PC at:\n      *            'C:\\Both\\Rosetta\\Angle_diff.txt'\n      ******************************************************************\n      *     +000020.000000000000 +000045.000000000000\n      *     -000045.000000000000 +000045.000000000000\n      *     -000085.000000000000 +000090.000000000000\n      *     -000095.000000000000 +000090.000000000000\n      *     -000045.000000000000 +000125.000000000000\n      *     -000045.000000000000 +000145.000000000000\n      *     +000029.480300000000 -000088.638100000000\n      *     -000078.325100000000 -000159.036000000000\n      *     -070099.742338109380 +029840.674378767230\n      *     -165313.666629735700 +033693.989451745600\n      *     +001174.838051059846 -154146.664901247570\n      *     +060175.773067955460 +042213.071923543730\n      ******************************************************************\n      *    OUTPUT:\n      ******************************************************************\n      *     001      25.0000\n      *     002      90.0000\n      *     003     175.0000\n      *     004    -175.0000\n      *     005     170.0000\n      *     006    -170.0000\n      *     007    -118.1184\n      *     008     -80.7109\n      *     009    -139.5833\n      *     010     -72.3439\n      *     011    -161.5030\n      *     012      37.2989\n      ******************************************************************\n", "target": "using System;\n\nnamespace Angle_difference_between_two_bearings\n{\n\tclass Program\n\t{\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\"Hello World!\");\n\t\t\tConsole.WriteLine();\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing( 20M,45));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,45M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-85M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-95M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,125M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,145M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 29.4803M,-88.6381M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-78.3251M, -159.036M));\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing(-70099.74233810938M,   29840.67437876723M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-165313.6666297357M,   33693.9894517456M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 1174.8380510598456M, -154146.66490124757M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 60175.77306795546M,   42213.07192354373M));\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t}\n\t\t\n\t\tstatic decimal Delta_Bearing(decimal b1, decimal b2)\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tdecimal d = 0;\n\t\t\t\n\t\t\t\n\t\t\tif(b1<0)\n\t\t\t\tb1 += 360;\n\t\t\tif(b2<0)\n\t\t\t\tb2 += 360;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\td = (b2 - b1)%360;\n\t\t\t\n\t\t\tif(d>180)\n\t\t\t\td -= 360;\n\t\t\telse if(d<-180)\n\t\t\t\td += 360;\n\t\t\t\n\t\t\treturn d;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}\n"}
{"id": 88996, "name": "Angle difference between two bearings", "source": "Translate COBOL to C#:       ******************************************************************\n      * COBOL solution to Angle difference challange\n      * The program was run on OpenCobolIDE\n      * I chose to read the input data from a .txt file that I\n      *    created on my PC rather than to hard code it into the\n      *    program or enter it as the program was executing.\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ANGLE-DIFFERENCE.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n           SELECT IN-FILE ASSIGN TO 'C:\\Both\\Rosetta\\Angle_diff.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n       FD IN-FILE.\n       01 IN-RECORD.\n           05  ALPHA-BEARING-1          PIC X(20).\n           05  FILLER                   PIC X.\n           05  ALPHA-BEARING-2          PIC X(20).\n\n       WORKING-STORAGE SECTION.\n       01  SWITCHES.\n           05 EOF-SWITCH                PIC X VALUE 'N'.\n\n       01 COUNTERS.\n           05 REC-CTR                   PIC 9(3) VALUE 0.\n\n       01  WS-ALPHA-BEARING.\n           05  WS-AB-SIGN               PIC X.\n               88  WS-AB-NEGATIVE       VALUE \"-\".\n           05  WS-AB-INTEGER-PART       PIC X(6).\n           05  WS-AB-DEC-POINT          PIC X.\n           05  WS-AB-DECIMAL-PART       PIC X(12).\n\n       01  WS-BEARING-1                 PIC S9(6)V9(12).\n       01  WS-BEARING-2                 PIC S9(6)V9(12).\n\n       01  WS-BEARING                   PIC S9(6)V9(12).\n       01  FILLER REDEFINES WS-BEARING.\n           05  WSB-INTEGER-PART         PIC X(6).\n           05  WSB-DECIMAL-PART         PIC X9(12).\n\n       77  WS-RESULT                    PIC S9(6)V9(12).\n       77  WS-RESULT-POS                PIC 9(6)V9(12).\n       77  WS-INTEGER-PART              PIC 9(6).\n       77  WS-DECIMAL-PART              PIC V9(12).\n       77  WS-RESULT-OUT                PIC ------9.9999.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           PERFORM 100-INITIALIZE.\n           PERFORM 200-PROCESS-RECORD\n               UNTIL EOF-SWITCH = 'Y'.\n           PERFORM 300-TERMINATE.\n           STOP RUN.\n\n       100-INITIALIZE.\n           OPEN INPUT IN-FILE.\n           PERFORM 150-READ-RECORD.\n\n       150-READ-RECORD.\n           READ IN-FILE\n               AT END\n                   MOVE 'Y' TO EOF-SWITCH\n               NOT AT END\n                   COMPUTE REC-CTR = REC-CTR + 1\n               END-READ.\n\n       200-PROCESS-RECORD.\n           MOVE ALPHA-BEARING-1 TO WS-ALPHA-BEARING.\n           PERFORM 250-CONVERT-DATA.\n           MOVE WS-BEARING TO WS-BEARING-1.\n\n           MOVE ALPHA-BEARING-2 TO WS-ALPHA-BEARING.\n           PERFORM 250-CONVERT-DATA.\n           MOVE WS-BEARING TO WS-BEARING-2.\n\n           COMPUTE WS-RESULT = WS-BEARING-2 - WS-BEARING-1.\n           MOVE WS-RESULT TO WS-RESULT-POS.\n           MOVE WS-RESULT-POS TO WS-INTEGER-PART.\n           COMPUTE WS-DECIMAL-PART = WS-RESULT-POS - WS-INTEGER-PART.\n           COMPUTE WS-INTEGER-PART = FUNCTION MOD(WS-INTEGER-PART 360).\n           IF WS-RESULT > 0\n               COMPUTE WS-RESULT = WS-INTEGER-PART + WS-DECIMAL-PART\n           ELSE\n               COMPUTE WS-RESULT =\n                   (WS-INTEGER-PART + WS-DECIMAL-PART) * -1\n           END-IF.\n\n           IF WS-RESULT < -180\n               COMPUTE WS-RESULT = WS-RESULT + 360.\n           IF WS-RESULT > 180\n               COMPUTE WS-RESULT = WS-RESULT - 360.\n           COMPUTE WS-RESULT-OUT ROUNDED = WS-RESULT.\n\n           DISPLAY REC-CTR ' ' WS-RESULT-OUT.\n\n           PERFORM 150-READ-RECORD.\n\n       250-CONVERT-DATA.\n           MOVE WS-AB-INTEGER-PART      TO WSB-INTEGER-PART.\n           MOVE WS-AB-DECIMAL-PART      TO WSB-DECIMAL-PART.\n           IF WS-AB-NEGATIVE\n               SUBTRACT WS-BEARING      FROM ZERO\n                 GIVING                 WS-BEARING\n           END-IF.\n\n       300-TERMINATE.\n           DISPLAY 'RECORDS PROCESSED: ' REC-CTR.\n           CLOSE IN-FILE.\n\n      ******************************************************************\n      *    INPUT FILE ('Angle_diff.txt' stored on my PC at:\n      *            'C:\\Both\\Rosetta\\Angle_diff.txt'\n      ******************************************************************\n      *     +000020.000000000000 +000045.000000000000\n      *     -000045.000000000000 +000045.000000000000\n      *     -000085.000000000000 +000090.000000000000\n      *     -000095.000000000000 +000090.000000000000\n      *     -000045.000000000000 +000125.000000000000\n      *     -000045.000000000000 +000145.000000000000\n      *     +000029.480300000000 -000088.638100000000\n      *     -000078.325100000000 -000159.036000000000\n      *     -070099.742338109380 +029840.674378767230\n      *     -165313.666629735700 +033693.989451745600\n      *     +001174.838051059846 -154146.664901247570\n      *     +060175.773067955460 +042213.071923543730\n      ******************************************************************\n      *    OUTPUT:\n      ******************************************************************\n      *     001      25.0000\n      *     002      90.0000\n      *     003     175.0000\n      *     004    -175.0000\n      *     005     170.0000\n      *     006    -170.0000\n      *     007    -118.1184\n      *     008     -80.7109\n      *     009    -139.5833\n      *     010     -72.3439\n      *     011    -161.5030\n      *     012      37.2989\n      ******************************************************************\n", "target": "using System;\n\nnamespace Angle_difference_between_two_bearings\n{\n\tclass Program\n\t{\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\"Hello World!\");\n\t\t\tConsole.WriteLine();\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing( 20M,45));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,45M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-85M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-95M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,125M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,145M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 29.4803M,-88.6381M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-78.3251M, -159.036M));\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing(-70099.74233810938M,   29840.67437876723M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-165313.6666297357M,   33693.9894517456M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 1174.8380510598456M, -154146.66490124757M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 60175.77306795546M,   42213.07192354373M));\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t}\n\t\t\n\t\tstatic decimal Delta_Bearing(decimal b1, decimal b2)\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tdecimal d = 0;\n\t\t\t\n\t\t\t\n\t\t\tif(b1<0)\n\t\t\t\tb1 += 360;\n\t\t\tif(b2<0)\n\t\t\t\tb2 += 360;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\td = (b2 - b1)%360;\n\t\t\t\n\t\t\tif(d>180)\n\t\t\t\td -= 360;\n\t\t\telse if(d<-180)\n\t\t\t\td += 360;\n\t\t\t\n\t\t\treturn d;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}\n"}
{"id": 88999, "name": "Angle difference between two bearings", "source": "Translate COBOL to Java:       ******************************************************************\n      * COBOL solution to Angle difference challange\n      * The program was run on OpenCobolIDE\n      * I chose to read the input data from a .txt file that I\n      *    created on my PC rather than to hard code it into the\n      *    program or enter it as the program was executing.\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ANGLE-DIFFERENCE.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n           SELECT IN-FILE ASSIGN TO 'C:\\Both\\Rosetta\\Angle_diff.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n       FD IN-FILE.\n       01 IN-RECORD.\n           05  ALPHA-BEARING-1          PIC X(20).\n           05  FILLER                   PIC X.\n           05  ALPHA-BEARING-2          PIC X(20).\n\n       WORKING-STORAGE SECTION.\n       01  SWITCHES.\n           05 EOF-SWITCH                PIC X VALUE 'N'.\n\n       01 COUNTERS.\n           05 REC-CTR                   PIC 9(3) VALUE 0.\n\n       01  WS-ALPHA-BEARING.\n           05  WS-AB-SIGN               PIC X.\n               88  WS-AB-NEGATIVE       VALUE \"-\".\n           05  WS-AB-INTEGER-PART       PIC X(6).\n           05  WS-AB-DEC-POINT          PIC X.\n           05  WS-AB-DECIMAL-PART       PIC X(12).\n\n       01  WS-BEARING-1                 PIC S9(6)V9(12).\n       01  WS-BEARING-2                 PIC S9(6)V9(12).\n\n       01  WS-BEARING                   PIC S9(6)V9(12).\n       01  FILLER REDEFINES WS-BEARING.\n           05  WSB-INTEGER-PART         PIC X(6).\n           05  WSB-DECIMAL-PART         PIC X9(12).\n\n       77  WS-RESULT                    PIC S9(6)V9(12).\n       77  WS-RESULT-POS                PIC 9(6)V9(12).\n       77  WS-INTEGER-PART              PIC 9(6).\n       77  WS-DECIMAL-PART              PIC V9(12).\n       77  WS-RESULT-OUT                PIC ------9.9999.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           PERFORM 100-INITIALIZE.\n           PERFORM 200-PROCESS-RECORD\n               UNTIL EOF-SWITCH = 'Y'.\n           PERFORM 300-TERMINATE.\n           STOP RUN.\n\n       100-INITIALIZE.\n           OPEN INPUT IN-FILE.\n           PERFORM 150-READ-RECORD.\n\n       150-READ-RECORD.\n           READ IN-FILE\n               AT END\n                   MOVE 'Y' TO EOF-SWITCH\n               NOT AT END\n                   COMPUTE REC-CTR = REC-CTR + 1\n               END-READ.\n\n       200-PROCESS-RECORD.\n           MOVE ALPHA-BEARING-1 TO WS-ALPHA-BEARING.\n           PERFORM 250-CONVERT-DATA.\n           MOVE WS-BEARING TO WS-BEARING-1.\n\n           MOVE ALPHA-BEARING-2 TO WS-ALPHA-BEARING.\n           PERFORM 250-CONVERT-DATA.\n           MOVE WS-BEARING TO WS-BEARING-2.\n\n           COMPUTE WS-RESULT = WS-BEARING-2 - WS-BEARING-1.\n           MOVE WS-RESULT TO WS-RESULT-POS.\n           MOVE WS-RESULT-POS TO WS-INTEGER-PART.\n           COMPUTE WS-DECIMAL-PART = WS-RESULT-POS - WS-INTEGER-PART.\n           COMPUTE WS-INTEGER-PART = FUNCTION MOD(WS-INTEGER-PART 360).\n           IF WS-RESULT > 0\n               COMPUTE WS-RESULT = WS-INTEGER-PART + WS-DECIMAL-PART\n           ELSE\n               COMPUTE WS-RESULT =\n                   (WS-INTEGER-PART + WS-DECIMAL-PART) * -1\n           END-IF.\n\n           IF WS-RESULT < -180\n               COMPUTE WS-RESULT = WS-RESULT + 360.\n           IF WS-RESULT > 180\n               COMPUTE WS-RESULT = WS-RESULT - 360.\n           COMPUTE WS-RESULT-OUT ROUNDED = WS-RESULT.\n\n           DISPLAY REC-CTR ' ' WS-RESULT-OUT.\n\n           PERFORM 150-READ-RECORD.\n\n       250-CONVERT-DATA.\n           MOVE WS-AB-INTEGER-PART      TO WSB-INTEGER-PART.\n           MOVE WS-AB-DECIMAL-PART      TO WSB-DECIMAL-PART.\n           IF WS-AB-NEGATIVE\n               SUBTRACT WS-BEARING      FROM ZERO\n                 GIVING                 WS-BEARING\n           END-IF.\n\n       300-TERMINATE.\n           DISPLAY 'RECORDS PROCESSED: ' REC-CTR.\n           CLOSE IN-FILE.\n\n      ******************************************************************\n      *    INPUT FILE ('Angle_diff.txt' stored on my PC at:\n      *            'C:\\Both\\Rosetta\\Angle_diff.txt'\n      ******************************************************************\n      *     +000020.000000000000 +000045.000000000000\n      *     -000045.000000000000 +000045.000000000000\n      *     -000085.000000000000 +000090.000000000000\n      *     -000095.000000000000 +000090.000000000000\n      *     -000045.000000000000 +000125.000000000000\n      *     -000045.000000000000 +000145.000000000000\n      *     +000029.480300000000 -000088.638100000000\n      *     -000078.325100000000 -000159.036000000000\n      *     -070099.742338109380 +029840.674378767230\n      *     -165313.666629735700 +033693.989451745600\n      *     +001174.838051059846 -154146.664901247570\n      *     +060175.773067955460 +042213.071923543730\n      ******************************************************************\n      *    OUTPUT:\n      ******************************************************************\n      *     001      25.0000\n      *     002      90.0000\n      *     003     175.0000\n      *     004    -175.0000\n      *     005     170.0000\n      *     006    -170.0000\n      *     007    -118.1184\n      *     008     -80.7109\n      *     009    -139.5833\n      *     010     -72.3439\n      *     011    -161.5030\n      *     012      37.2989\n      ******************************************************************\n", "target": "public class AngleDifference {\n\n    public static double getDifference(double b1, double b2) {\n        double r = (b2 - b1) % 360.0;\n        if (r < -180.0)\n            r += 360.0;\n        if (r >= 180.0)\n            r -= 360.0;\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Input in -180 to +180 range\");\n        System.out.println(getDifference(20.0, 45.0));\n        System.out.println(getDifference(-45.0, 45.0));\n        System.out.println(getDifference(-85.0, 90.0));\n        System.out.println(getDifference(-95.0, 90.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(29.4803, -88.6381));\n        System.out.println(getDifference(-78.3251, -159.036));\n\n        System.out.println(\"Input in wider range\");\n        System.out.println(getDifference(-70099.74233810938, 29840.67437876723));\n        System.out.println(getDifference(-165313.6666297357, 33693.9894517456));\n        System.out.println(getDifference(1174.8380510598456, -154146.66490124757));\n        System.out.println(getDifference(60175.77306795546, 42213.07192354373));\n    }\n}\n"}
{"id": 89000, "name": "Angle difference between two bearings", "source": "Translate COBOL to Java:       ******************************************************************\n      * COBOL solution to Angle difference challange\n      * The program was run on OpenCobolIDE\n      * I chose to read the input data from a .txt file that I\n      *    created on my PC rather than to hard code it into the\n      *    program or enter it as the program was executing.\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ANGLE-DIFFERENCE.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n           SELECT IN-FILE ASSIGN TO 'C:\\Both\\Rosetta\\Angle_diff.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n       FD IN-FILE.\n       01 IN-RECORD.\n           05  ALPHA-BEARING-1          PIC X(20).\n           05  FILLER                   PIC X.\n           05  ALPHA-BEARING-2          PIC X(20).\n\n       WORKING-STORAGE SECTION.\n       01  SWITCHES.\n           05 EOF-SWITCH                PIC X VALUE 'N'.\n\n       01 COUNTERS.\n           05 REC-CTR                   PIC 9(3) VALUE 0.\n\n       01  WS-ALPHA-BEARING.\n           05  WS-AB-SIGN               PIC X.\n               88  WS-AB-NEGATIVE       VALUE \"-\".\n           05  WS-AB-INTEGER-PART       PIC X(6).\n           05  WS-AB-DEC-POINT          PIC X.\n           05  WS-AB-DECIMAL-PART       PIC X(12).\n\n       01  WS-BEARING-1                 PIC S9(6)V9(12).\n       01  WS-BEARING-2                 PIC S9(6)V9(12).\n\n       01  WS-BEARING                   PIC S9(6)V9(12).\n       01  FILLER REDEFINES WS-BEARING.\n           05  WSB-INTEGER-PART         PIC X(6).\n           05  WSB-DECIMAL-PART         PIC X9(12).\n\n       77  WS-RESULT                    PIC S9(6)V9(12).\n       77  WS-RESULT-POS                PIC 9(6)V9(12).\n       77  WS-INTEGER-PART              PIC 9(6).\n       77  WS-DECIMAL-PART              PIC V9(12).\n       77  WS-RESULT-OUT                PIC ------9.9999.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           PERFORM 100-INITIALIZE.\n           PERFORM 200-PROCESS-RECORD\n               UNTIL EOF-SWITCH = 'Y'.\n           PERFORM 300-TERMINATE.\n           STOP RUN.\n\n       100-INITIALIZE.\n           OPEN INPUT IN-FILE.\n           PERFORM 150-READ-RECORD.\n\n       150-READ-RECORD.\n           READ IN-FILE\n               AT END\n                   MOVE 'Y' TO EOF-SWITCH\n               NOT AT END\n                   COMPUTE REC-CTR = REC-CTR + 1\n               END-READ.\n\n       200-PROCESS-RECORD.\n           MOVE ALPHA-BEARING-1 TO WS-ALPHA-BEARING.\n           PERFORM 250-CONVERT-DATA.\n           MOVE WS-BEARING TO WS-BEARING-1.\n\n           MOVE ALPHA-BEARING-2 TO WS-ALPHA-BEARING.\n           PERFORM 250-CONVERT-DATA.\n           MOVE WS-BEARING TO WS-BEARING-2.\n\n           COMPUTE WS-RESULT = WS-BEARING-2 - WS-BEARING-1.\n           MOVE WS-RESULT TO WS-RESULT-POS.\n           MOVE WS-RESULT-POS TO WS-INTEGER-PART.\n           COMPUTE WS-DECIMAL-PART = WS-RESULT-POS - WS-INTEGER-PART.\n           COMPUTE WS-INTEGER-PART = FUNCTION MOD(WS-INTEGER-PART 360).\n           IF WS-RESULT > 0\n               COMPUTE WS-RESULT = WS-INTEGER-PART + WS-DECIMAL-PART\n           ELSE\n               COMPUTE WS-RESULT =\n                   (WS-INTEGER-PART + WS-DECIMAL-PART) * -1\n           END-IF.\n\n           IF WS-RESULT < -180\n               COMPUTE WS-RESULT = WS-RESULT + 360.\n           IF WS-RESULT > 180\n               COMPUTE WS-RESULT = WS-RESULT - 360.\n           COMPUTE WS-RESULT-OUT ROUNDED = WS-RESULT.\n\n           DISPLAY REC-CTR ' ' WS-RESULT-OUT.\n\n           PERFORM 150-READ-RECORD.\n\n       250-CONVERT-DATA.\n           MOVE WS-AB-INTEGER-PART      TO WSB-INTEGER-PART.\n           MOVE WS-AB-DECIMAL-PART      TO WSB-DECIMAL-PART.\n           IF WS-AB-NEGATIVE\n               SUBTRACT WS-BEARING      FROM ZERO\n                 GIVING                 WS-BEARING\n           END-IF.\n\n       300-TERMINATE.\n           DISPLAY 'RECORDS PROCESSED: ' REC-CTR.\n           CLOSE IN-FILE.\n\n      ******************************************************************\n      *    INPUT FILE ('Angle_diff.txt' stored on my PC at:\n      *            'C:\\Both\\Rosetta\\Angle_diff.txt'\n      ******************************************************************\n      *     +000020.000000000000 +000045.000000000000\n      *     -000045.000000000000 +000045.000000000000\n      *     -000085.000000000000 +000090.000000000000\n      *     -000095.000000000000 +000090.000000000000\n      *     -000045.000000000000 +000125.000000000000\n      *     -000045.000000000000 +000145.000000000000\n      *     +000029.480300000000 -000088.638100000000\n      *     -000078.325100000000 -000159.036000000000\n      *     -070099.742338109380 +029840.674378767230\n      *     -165313.666629735700 +033693.989451745600\n      *     +001174.838051059846 -154146.664901247570\n      *     +060175.773067955460 +042213.071923543730\n      ******************************************************************\n      *    OUTPUT:\n      ******************************************************************\n      *     001      25.0000\n      *     002      90.0000\n      *     003     175.0000\n      *     004    -175.0000\n      *     005     170.0000\n      *     006    -170.0000\n      *     007    -118.1184\n      *     008     -80.7109\n      *     009    -139.5833\n      *     010     -72.3439\n      *     011    -161.5030\n      *     012      37.2989\n      ******************************************************************\n", "target": "public class AngleDifference {\n\n    public static double getDifference(double b1, double b2) {\n        double r = (b2 - b1) % 360.0;\n        if (r < -180.0)\n            r += 360.0;\n        if (r >= 180.0)\n            r -= 360.0;\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Input in -180 to +180 range\");\n        System.out.println(getDifference(20.0, 45.0));\n        System.out.println(getDifference(-45.0, 45.0));\n        System.out.println(getDifference(-85.0, 90.0));\n        System.out.println(getDifference(-95.0, 90.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(29.4803, -88.6381));\n        System.out.println(getDifference(-78.3251, -159.036));\n\n        System.out.println(\"Input in wider range\");\n        System.out.println(getDifference(-70099.74233810938, 29840.67437876723));\n        System.out.println(getDifference(-165313.6666297357, 33693.9894517456));\n        System.out.println(getDifference(1174.8380510598456, -154146.66490124757));\n        System.out.println(getDifference(60175.77306795546, 42213.07192354373));\n    }\n}\n"}
{"id": 89001, "name": "Angle difference between two bearings", "source": "Translate COBOL to Python:       ******************************************************************\n      * COBOL solution to Angle difference challange\n      * The program was run on OpenCobolIDE\n      * I chose to read the input data from a .txt file that I\n      *    created on my PC rather than to hard code it into the\n      *    program or enter it as the program was executing.\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ANGLE-DIFFERENCE.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n           SELECT IN-FILE ASSIGN TO 'C:\\Both\\Rosetta\\Angle_diff.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n       FD IN-FILE.\n       01 IN-RECORD.\n           05  ALPHA-BEARING-1          PIC X(20).\n           05  FILLER                   PIC X.\n           05  ALPHA-BEARING-2          PIC X(20).\n\n       WORKING-STORAGE SECTION.\n       01  SWITCHES.\n           05 EOF-SWITCH                PIC X VALUE 'N'.\n\n       01 COUNTERS.\n           05 REC-CTR                   PIC 9(3) VALUE 0.\n\n       01  WS-ALPHA-BEARING.\n           05  WS-AB-SIGN               PIC X.\n               88  WS-AB-NEGATIVE       VALUE \"-\".\n           05  WS-AB-INTEGER-PART       PIC X(6).\n           05  WS-AB-DEC-POINT          PIC X.\n           05  WS-AB-DECIMAL-PART       PIC X(12).\n\n       01  WS-BEARING-1                 PIC S9(6)V9(12).\n       01  WS-BEARING-2                 PIC S9(6)V9(12).\n\n       01  WS-BEARING                   PIC S9(6)V9(12).\n       01  FILLER REDEFINES WS-BEARING.\n           05  WSB-INTEGER-PART         PIC X(6).\n           05  WSB-DECIMAL-PART         PIC X9(12).\n\n       77  WS-RESULT                    PIC S9(6)V9(12).\n       77  WS-RESULT-POS                PIC 9(6)V9(12).\n       77  WS-INTEGER-PART              PIC 9(6).\n       77  WS-DECIMAL-PART              PIC V9(12).\n       77  WS-RESULT-OUT                PIC ------9.9999.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           PERFORM 100-INITIALIZE.\n           PERFORM 200-PROCESS-RECORD\n               UNTIL EOF-SWITCH = 'Y'.\n           PERFORM 300-TERMINATE.\n           STOP RUN.\n\n       100-INITIALIZE.\n           OPEN INPUT IN-FILE.\n           PERFORM 150-READ-RECORD.\n\n       150-READ-RECORD.\n           READ IN-FILE\n               AT END\n                   MOVE 'Y' TO EOF-SWITCH\n               NOT AT END\n                   COMPUTE REC-CTR = REC-CTR + 1\n               END-READ.\n\n       200-PROCESS-RECORD.\n           MOVE ALPHA-BEARING-1 TO WS-ALPHA-BEARING.\n           PERFORM 250-CONVERT-DATA.\n           MOVE WS-BEARING TO WS-BEARING-1.\n\n           MOVE ALPHA-BEARING-2 TO WS-ALPHA-BEARING.\n           PERFORM 250-CONVERT-DATA.\n           MOVE WS-BEARING TO WS-BEARING-2.\n\n           COMPUTE WS-RESULT = WS-BEARING-2 - WS-BEARING-1.\n           MOVE WS-RESULT TO WS-RESULT-POS.\n           MOVE WS-RESULT-POS TO WS-INTEGER-PART.\n           COMPUTE WS-DECIMAL-PART = WS-RESULT-POS - WS-INTEGER-PART.\n           COMPUTE WS-INTEGER-PART = FUNCTION MOD(WS-INTEGER-PART 360).\n           IF WS-RESULT > 0\n               COMPUTE WS-RESULT = WS-INTEGER-PART + WS-DECIMAL-PART\n           ELSE\n               COMPUTE WS-RESULT =\n                   (WS-INTEGER-PART + WS-DECIMAL-PART) * -1\n           END-IF.\n\n           IF WS-RESULT < -180\n               COMPUTE WS-RESULT = WS-RESULT + 360.\n           IF WS-RESULT > 180\n               COMPUTE WS-RESULT = WS-RESULT - 360.\n           COMPUTE WS-RESULT-OUT ROUNDED = WS-RESULT.\n\n           DISPLAY REC-CTR ' ' WS-RESULT-OUT.\n\n           PERFORM 150-READ-RECORD.\n\n       250-CONVERT-DATA.\n           MOVE WS-AB-INTEGER-PART      TO WSB-INTEGER-PART.\n           MOVE WS-AB-DECIMAL-PART      TO WSB-DECIMAL-PART.\n           IF WS-AB-NEGATIVE\n               SUBTRACT WS-BEARING      FROM ZERO\n                 GIVING                 WS-BEARING\n           END-IF.\n\n       300-TERMINATE.\n           DISPLAY 'RECORDS PROCESSED: ' REC-CTR.\n           CLOSE IN-FILE.\n\n      ******************************************************************\n      *    INPUT FILE ('Angle_diff.txt' stored on my PC at:\n      *            'C:\\Both\\Rosetta\\Angle_diff.txt'\n      ******************************************************************\n      *     +000020.000000000000 +000045.000000000000\n      *     -000045.000000000000 +000045.000000000000\n      *     -000085.000000000000 +000090.000000000000\n      *     -000095.000000000000 +000090.000000000000\n      *     -000045.000000000000 +000125.000000000000\n      *     -000045.000000000000 +000145.000000000000\n      *     +000029.480300000000 -000088.638100000000\n      *     -000078.325100000000 -000159.036000000000\n      *     -070099.742338109380 +029840.674378767230\n      *     -165313.666629735700 +033693.989451745600\n      *     +001174.838051059846 -154146.664901247570\n      *     +060175.773067955460 +042213.071923543730\n      ******************************************************************\n      *    OUTPUT:\n      ******************************************************************\n      *     001      25.0000\n      *     002      90.0000\n      *     003     175.0000\n      *     004    -175.0000\n      *     005     170.0000\n      *     006    -170.0000\n      *     007    -118.1184\n      *     008     -80.7109\n      *     009    -139.5833\n      *     010     -72.3439\n      *     011    -161.5030\n      *     012      37.2989\n      ******************************************************************\n", "target": "from __future__ import print_function\n \ndef getDifference(b1, b2):\n\tr = (b2 - b1) % 360.0\n\t\n\t\n\tif r >= 180.0:\n\t\tr -= 360.0\n\treturn r\n \nif __name__ == \"__main__\":\n\tprint (\"Input in -180 to +180 range\")\n\tprint (getDifference(20.0, 45.0))\n\tprint (getDifference(-45.0, 45.0))\n\tprint (getDifference(-85.0, 90.0))\n\tprint (getDifference(-95.0, 90.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(29.4803, -88.6381))\n\tprint (getDifference(-78.3251, -159.036))\n \n\tprint (\"Input in wider range\")\n\tprint (getDifference(-70099.74233810938, 29840.67437876723))\n\tprint (getDifference(-165313.6666297357, 33693.9894517456))\n\tprint (getDifference(1174.8380510598456, -154146.66490124757))\n\tprint (getDifference(60175.77306795546, 42213.07192354373))\n"}
{"id": 89002, "name": "Angle difference between two bearings", "source": "Translate COBOL to Python:       ******************************************************************\n      * COBOL solution to Angle difference challange\n      * The program was run on OpenCobolIDE\n      * I chose to read the input data from a .txt file that I\n      *    created on my PC rather than to hard code it into the\n      *    program or enter it as the program was executing.\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ANGLE-DIFFERENCE.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n           SELECT IN-FILE ASSIGN TO 'C:\\Both\\Rosetta\\Angle_diff.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n       FD IN-FILE.\n       01 IN-RECORD.\n           05  ALPHA-BEARING-1          PIC X(20).\n           05  FILLER                   PIC X.\n           05  ALPHA-BEARING-2          PIC X(20).\n\n       WORKING-STORAGE SECTION.\n       01  SWITCHES.\n           05 EOF-SWITCH                PIC X VALUE 'N'.\n\n       01 COUNTERS.\n           05 REC-CTR                   PIC 9(3) VALUE 0.\n\n       01  WS-ALPHA-BEARING.\n           05  WS-AB-SIGN               PIC X.\n               88  WS-AB-NEGATIVE       VALUE \"-\".\n           05  WS-AB-INTEGER-PART       PIC X(6).\n           05  WS-AB-DEC-POINT          PIC X.\n           05  WS-AB-DECIMAL-PART       PIC X(12).\n\n       01  WS-BEARING-1                 PIC S9(6)V9(12).\n       01  WS-BEARING-2                 PIC S9(6)V9(12).\n\n       01  WS-BEARING                   PIC S9(6)V9(12).\n       01  FILLER REDEFINES WS-BEARING.\n           05  WSB-INTEGER-PART         PIC X(6).\n           05  WSB-DECIMAL-PART         PIC X9(12).\n\n       77  WS-RESULT                    PIC S9(6)V9(12).\n       77  WS-RESULT-POS                PIC 9(6)V9(12).\n       77  WS-INTEGER-PART              PIC 9(6).\n       77  WS-DECIMAL-PART              PIC V9(12).\n       77  WS-RESULT-OUT                PIC ------9.9999.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           PERFORM 100-INITIALIZE.\n           PERFORM 200-PROCESS-RECORD\n               UNTIL EOF-SWITCH = 'Y'.\n           PERFORM 300-TERMINATE.\n           STOP RUN.\n\n       100-INITIALIZE.\n           OPEN INPUT IN-FILE.\n           PERFORM 150-READ-RECORD.\n\n       150-READ-RECORD.\n           READ IN-FILE\n               AT END\n                   MOVE 'Y' TO EOF-SWITCH\n               NOT AT END\n                   COMPUTE REC-CTR = REC-CTR + 1\n               END-READ.\n\n       200-PROCESS-RECORD.\n           MOVE ALPHA-BEARING-1 TO WS-ALPHA-BEARING.\n           PERFORM 250-CONVERT-DATA.\n           MOVE WS-BEARING TO WS-BEARING-1.\n\n           MOVE ALPHA-BEARING-2 TO WS-ALPHA-BEARING.\n           PERFORM 250-CONVERT-DATA.\n           MOVE WS-BEARING TO WS-BEARING-2.\n\n           COMPUTE WS-RESULT = WS-BEARING-2 - WS-BEARING-1.\n           MOVE WS-RESULT TO WS-RESULT-POS.\n           MOVE WS-RESULT-POS TO WS-INTEGER-PART.\n           COMPUTE WS-DECIMAL-PART = WS-RESULT-POS - WS-INTEGER-PART.\n           COMPUTE WS-INTEGER-PART = FUNCTION MOD(WS-INTEGER-PART 360).\n           IF WS-RESULT > 0\n               COMPUTE WS-RESULT = WS-INTEGER-PART + WS-DECIMAL-PART\n           ELSE\n               COMPUTE WS-RESULT =\n                   (WS-INTEGER-PART + WS-DECIMAL-PART) * -1\n           END-IF.\n\n           IF WS-RESULT < -180\n               COMPUTE WS-RESULT = WS-RESULT + 360.\n           IF WS-RESULT > 180\n               COMPUTE WS-RESULT = WS-RESULT - 360.\n           COMPUTE WS-RESULT-OUT ROUNDED = WS-RESULT.\n\n           DISPLAY REC-CTR ' ' WS-RESULT-OUT.\n\n           PERFORM 150-READ-RECORD.\n\n       250-CONVERT-DATA.\n           MOVE WS-AB-INTEGER-PART      TO WSB-INTEGER-PART.\n           MOVE WS-AB-DECIMAL-PART      TO WSB-DECIMAL-PART.\n           IF WS-AB-NEGATIVE\n               SUBTRACT WS-BEARING      FROM ZERO\n                 GIVING                 WS-BEARING\n           END-IF.\n\n       300-TERMINATE.\n           DISPLAY 'RECORDS PROCESSED: ' REC-CTR.\n           CLOSE IN-FILE.\n\n      ******************************************************************\n      *    INPUT FILE ('Angle_diff.txt' stored on my PC at:\n      *            'C:\\Both\\Rosetta\\Angle_diff.txt'\n      ******************************************************************\n      *     +000020.000000000000 +000045.000000000000\n      *     -000045.000000000000 +000045.000000000000\n      *     -000085.000000000000 +000090.000000000000\n      *     -000095.000000000000 +000090.000000000000\n      *     -000045.000000000000 +000125.000000000000\n      *     -000045.000000000000 +000145.000000000000\n      *     +000029.480300000000 -000088.638100000000\n      *     -000078.325100000000 -000159.036000000000\n      *     -070099.742338109380 +029840.674378767230\n      *     -165313.666629735700 +033693.989451745600\n      *     +001174.838051059846 -154146.664901247570\n      *     +060175.773067955460 +042213.071923543730\n      ******************************************************************\n      *    OUTPUT:\n      ******************************************************************\n      *     001      25.0000\n      *     002      90.0000\n      *     003     175.0000\n      *     004    -175.0000\n      *     005     170.0000\n      *     006    -170.0000\n      *     007    -118.1184\n      *     008     -80.7109\n      *     009    -139.5833\n      *     010     -72.3439\n      *     011    -161.5030\n      *     012      37.2989\n      ******************************************************************\n", "target": "from __future__ import print_function\n \ndef getDifference(b1, b2):\n\tr = (b2 - b1) % 360.0\n\t\n\t\n\tif r >= 180.0:\n\t\tr -= 360.0\n\treturn r\n \nif __name__ == \"__main__\":\n\tprint (\"Input in -180 to +180 range\")\n\tprint (getDifference(20.0, 45.0))\n\tprint (getDifference(-45.0, 45.0))\n\tprint (getDifference(-85.0, 90.0))\n\tprint (getDifference(-95.0, 90.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(29.4803, -88.6381))\n\tprint (getDifference(-78.3251, -159.036))\n \n\tprint (\"Input in wider range\")\n\tprint (getDifference(-70099.74233810938, 29840.67437876723))\n\tprint (getDifference(-165313.6666297357, 33693.9894517456))\n\tprint (getDifference(1174.8380510598456, -154146.66490124757))\n\tprint (getDifference(60175.77306795546, 42213.07192354373))\n"}
{"id": 90073, "name": "Reverse a string", "source": "Translate COBOL to C#: FUNCTION REVERSE('QWERTY')\n", "target": "using System;\n\nnamespace System\n{\n\textension String\n\t{\n\t\tpublic void Reverse()\n\t\t{\n\t\t\tint i = 0;\n\t\t\tint j = mLength - 1;\n\t\t\twhile (i < j)\n\t\t\t{\n\t\t\t\tSwap!(Ptr[i++], Ptr[j--]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nnamespace StringReverse\n{\n\tclass Program\n\t{\n\t\tstatic void Main()\n\t\t{\n\t\t\tString s = scope .(\"abcdef\");\n\t\t\ts.Reverse();\n\t\t\tConsole.WriteLine(s);\n\t\t}\n\t}\n}\n"}
{"id": 90822, "name": "Command-line arguments", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. accept-all-args.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  args                   PIC X(50).\n       \n       PROCEDURE DIVISION.\n       main-line.\n           ACCEPT args FROM COMMAND-LINE\n           DISPLAY args\n           \n           GOBACK\n           .\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            for (int i = 0; i < args.Length; i++)\n                Console.WriteLine(String.Format(\"Argument {0} is '{1}'\", i, args[i]));\n        }\n    }\n}\n"}
{"id": 90823, "name": "Command-line arguments", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. accept-all-args.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  args                   PIC X(50).\n       \n       PROCEDURE DIVISION.\n       main-line.\n           ACCEPT args FROM COMMAND-LINE\n           DISPLAY args\n           \n           GOBACK\n           .\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            for (int i = 0; i < args.Length; i++)\n                Console.WriteLine(String.Format(\"Argument {0} is '{1}'\", i, args[i]));\n        }\n    }\n}\n"}
{"id": 90826, "name": "Command-line arguments", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. accept-all-args.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  args                   PIC X(50).\n       \n       PROCEDURE DIVISION.\n       main-line.\n           ACCEPT args FROM COMMAND-LINE\n           DISPLAY args\n           \n           GOBACK\n           .\n", "target": "public class Arguments {\n  public static void main(String[] args) {\n     System.out.println(\"There are \" + args.length + \" arguments given.\");\n     for(int i = 0; i < args.length; i++) \n        System.out.println(\"The argument #\" + (i+1) + \" is \" + args[i] + \" and is at index \" + i);\n  }\n}\n"}
{"id": 90827, "name": "Command-line arguments", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. accept-all-args.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  args                   PIC X(50).\n       \n       PROCEDURE DIVISION.\n       main-line.\n           ACCEPT args FROM COMMAND-LINE\n           DISPLAY args\n           \n           GOBACK\n           .\n", "target": "public class Arguments {\n  public static void main(String[] args) {\n     System.out.println(\"There are \" + args.length + \" arguments given.\");\n     for(int i = 0; i < args.length; i++) \n        System.out.println(\"The argument #\" + (i+1) + \" is \" + args[i] + \" and is at index \" + i);\n  }\n}\n"}
{"id": 90828, "name": "Command-line arguments", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. accept-all-args.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  args                   PIC X(50).\n       \n       PROCEDURE DIVISION.\n       main-line.\n           ACCEPT args FROM COMMAND-LINE\n           DISPLAY args\n           \n           GOBACK\n           .\n", "target": "import sys\nprogram_name = sys.argv[0]\narguments = sys.argv[1:]\ncount = len(arguments)\n"}
{"id": 90829, "name": "Command-line arguments", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. accept-all-args.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  args                   PIC X(50).\n       \n       PROCEDURE DIVISION.\n       main-line.\n           ACCEPT args FROM COMMAND-LINE\n           DISPLAY args\n           \n           GOBACK\n           .\n", "target": "import sys\nprogram_name = sys.argv[0]\narguments = sys.argv[1:]\ncount = len(arguments)\n"}
{"id": 91358, "name": "Tokenize a string", "source": "Translate COBOL to C#:       identification division.\n       program-id. tokenize.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 period constant as \".\".\n       01 cmma   constant as \",\".\n\n       01 start-with.\n          05 value \"Hello,How,Are,You,Today\".\n\n       01 items.\n          05 item pic x(6) occurs 5 times.\n\n       procedure division.\n       tokenize-main.\n       unstring start-with delimited by cmma\n           into item(1) item(2) item(3) item(4) item(5)\n\n       display trim(item(1)) period trim(item(2)) period\n               trim(item(3)) period trim(item(4)) period\n               trim(item(5))\n\n       goback.\n       end program tokenize.\n", "target": "string str = \"Hello,How,Are,You,Today\"; \n\n\nstring[] strings = str.Split(',');\nConsole.WriteLine(String.Join(\".\", strings));\n"}
{"id": 91360, "name": "Tokenize a string", "source": "Translate COBOL to Java:       identification division.\n       program-id. tokenize.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 period constant as \".\".\n       01 cmma   constant as \",\".\n\n       01 start-with.\n          05 value \"Hello,How,Are,You,Today\".\n\n       01 items.\n          05 item pic x(6) occurs 5 times.\n\n       procedure division.\n       tokenize-main.\n       unstring start-with delimited by cmma\n           into item(1) item(2) item(3) item(4) item(5)\n\n       display trim(item(1)) period trim(item(2)) period\n               trim(item(3)) period trim(item(4)) period\n               trim(item(5))\n\n       goback.\n       end program tokenize.\n", "target": "String toTokenize = \"Hello,How,Are,You,Today\";\nSystem.out.println(String.join(\".\", toTokenize.split(\",\")));\n"}
{"id": 91361, "name": "Tokenize a string", "source": "Translate COBOL to Python:       identification division.\n       program-id. tokenize.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 period constant as \".\".\n       01 cmma   constant as \",\".\n\n       01 start-with.\n          05 value \"Hello,How,Are,You,Today\".\n\n       01 items.\n          05 item pic x(6) occurs 5 times.\n\n       procedure division.\n       tokenize-main.\n       unstring start-with delimited by cmma\n           into item(1) item(2) item(3) item(4) item(5)\n\n       display trim(item(1)) period trim(item(2)) period\n               trim(item(3)) period trim(item(4)) period\n               trim(item(5))\n\n       goback.\n       end program tokenize.\n", "target": "let text = 'Hello,How,Are,You,Today'\nlet tokens = text.split(||,||)\nprint tokens.join(with: '.')\n"}
{"id": 91555, "name": "Holidays related to Easter", "source": "Translate COBOL to C#:        identification division.\n       program-id. Easter.\n \n       environment division.\n       configuration section.\n       repository.\n           function date-of-integer intrinsic\n           function integer-of-date intrinsic\n           function mod intrinsic.\n \n       data division.\n       working-storage section.\n       77  days                   pic 9(2).\n       77  a                      pic 9(2).  \n       77  b                      pic 9(2).  \n       77  c                      pic 9(2).  \n       77  d                      pic 9(2).  \n       77  e                      pic 9(2).  \n       77  f                      pic 9(2).  \n       77  g                      pic 9(2).  \n       77  h                      pic 9(2).  \n       77  i                      pic 9(2).  \n       77  k                      pic 9(2).  \n       77  l                      pic 9(2).  \n       77  m                      pic 9(2).  \n       77  week-day               pic 9(1).\n       77  numerator              pic 9(4).\n       77  integer-date           pic 9(18).\n       \n       01  month-tab              value \"JanFebMarAprMayJunJulAugSepOctNovDec\".\n           05 month-abreviated    pic x(3) occurs 12.\n           \n       01  week-day-tab           value \"SunMonTueWedThuFriSat\".\n           05 week-day-abreviated pic x(3) occurs 7.\n       \n       01  easter-date            pic 9(8).\n       01  filler redefines easter-date.\n           05 easter-year         pic 9(4).\n           05 easter-month        pic 9(2).\n           05 easter-day          pic 9(2).\n\n       01  holiday-date           pic 9(8).\n       01  filler redefines holiday-date.\n           05 holiday-year        pic 9(4).\n           05 holiday-month       pic 9(2).\n           05 holiday-day         pic 9(2).\n\n       01  edt-date.\n           05 edt-week-day        pic x(3).\n           05 filler              pic x value space.\n           05 edt-day             pic z(2).\n           05 filler              pic x value space.\n           05 edt-month           pic x(3).\n\n       procedure division.\n       main.\n           display \"Christian holidays, related to Easter, for each centennial from 1700 to 2100 CE:\"\n           perform varying easter-year from 1700 by 100 until easter-year > 2100\n              perform output-holydays\n           end-perform\n           display \" \"\n\n           display \"Christian holidays, related to Easter, for years from 2010 to 2020 CE:\"\n           perform varying easter-year from 2010 by 1 until easter-year > 2020\n              perform output-holydays\n           end-perform\n           display \" \"\n\n           stop run\n           .\n       output-holydays.\n           display easter-year \" \" no advancing\n           perform calculate-easter\n\n           move 0 to days\n           perform add-days\n           display \" Easter: \" edt-date no advancing\n\n           move 39 to days\n           perform add-days\n           display \" Ascension: \" edt-date no advancing\n\n           move 49 to days\n           perform add-days\n           display \" Pentecost: \" edt-date no advancing\n\n           move 56 to days\n           perform add-days\n           display \" Trinity: \" edt-date no advancing\n\n           move 60 to days\n           perform add-days\n           display \" Corpus: \" edt-date \n           .\n       calculate-easter.\n           compute a = mod(easter-year, 19)\n           compute b = easter-year / 100\n           compute c = mod(easter-year, 100)\n           compute d = b / 4\n           compute e = mod(b, 4)\n           compute f = (b + 8) / 25\n           compute g = (b - f + 1) / 3\n           compute h = mod((19 * a + b - d - g + 15), 30)\n           compute i = c / 4\n           compute k = mod(c, 4)\n           compute l = mod((32 + 2 * e + 2 * i - h - k), 7)\n           compute m = (a + 11 * h + 22 * l) / 451\n           compute numerator = h + l - 7 * m + 114\n           compute easter-month = numerator / 31\n           compute easter-day = mod(numerator, 31) + 1\n           .\n       add-days.\n           if days = 0\n              move easter-date to holiday-date\n              move 1 to week-day\n           else\n              compute holiday-date = date-of-integer(integer-of-date(easter-date) + days)\n              compute week-day = mod(integer-of-date(easter-date) + days, 7) + 1\n           end-if\n           move week-day-abreviated(week-day) to edt-week-day\n           move month-abreviated(holiday-month) to edt-month\n           move holiday-day to edt-day\n           .\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\n\ninternal class Program\n{\n    private static readonly OrderedDictionary _holidayOffsets = new OrderedDictionary\n                                                                    {\n                                                                        {\"Easter\", 0},\n                                                                        {\"Ascension\", 39},\n                                                                        {\"Pentecost\", 49},\n                                                                        {\"Trinity\", 56},\n                                                                        {\"Corpus\", 60},\n                                                                    };\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:\");\n        for (int year = 400; year <= 2100; year += 100)\n            OutputHolidays(year);\n\n        Console.WriteLine();\n        Console.WriteLine(\"Christian holidays, related to Easter, for years from 2010 to 2020 CE:\");\n        for (int year = 2010; year <= 2020; year += 1)\n            OutputHolidays(year);\n    }\n\n    static void OutputHolidays(int year)\n    {\n        var easter = CalculateEaster(year);\n        var holidays = from kp in _holidayOffsets.OfType<DictionaryEntry>()\n                       let holiday = easter.AddDays(Convert.ToInt32(kp.Value))\n                       select kp.Key + \": \" + string.Format(\"{0,2:ddd} {0,2:%d} {0:MMM}\", holiday);\n        Console.WriteLine(\"{0,4} {1}\", year, string.Join(\", \", holidays.ToArray()));\n    }\n\n    static DateTime CalculateEaster(int year)\n    {\n        var a = year % 19;\n        var b = year / 100;\n        var c = year %100;\n        var d = b / 4;\n        var e = b % 4;\n        var f = (b + 8) / 25;\n        var g = (b - f + 1) / 3;\n        var h = (19 * a + b - d - g + 15) % 30;\n        var i = c / 4;\n        var k = c % 4;\n        var l = (32 + 2 * e + 2 * i - h - k) % 7;\n        var m = (a + 11 * h + 22 * l) / 451;\n        var numerator = h + l - 7 * m + 114;\n        var month = numerator / 31;\n        var day = (numerator % 31) + 1;\n        return new DateTime(year, month, day);\n    }\n}\n"}
{"id": 91556, "name": "Holidays related to Easter", "source": "Translate COBOL to Java:        identification division.\n       program-id. Easter.\n \n       environment division.\n       configuration section.\n       repository.\n           function date-of-integer intrinsic\n           function integer-of-date intrinsic\n           function mod intrinsic.\n \n       data division.\n       working-storage section.\n       77  days                   pic 9(2).\n       77  a                      pic 9(2).  \n       77  b                      pic 9(2).  \n       77  c                      pic 9(2).  \n       77  d                      pic 9(2).  \n       77  e                      pic 9(2).  \n       77  f                      pic 9(2).  \n       77  g                      pic 9(2).  \n       77  h                      pic 9(2).  \n       77  i                      pic 9(2).  \n       77  k                      pic 9(2).  \n       77  l                      pic 9(2).  \n       77  m                      pic 9(2).  \n       77  week-day               pic 9(1).\n       77  numerator              pic 9(4).\n       77  integer-date           pic 9(18).\n       \n       01  month-tab              value \"JanFebMarAprMayJunJulAugSepOctNovDec\".\n           05 month-abreviated    pic x(3) occurs 12.\n           \n       01  week-day-tab           value \"SunMonTueWedThuFriSat\".\n           05 week-day-abreviated pic x(3) occurs 7.\n       \n       01  easter-date            pic 9(8).\n       01  filler redefines easter-date.\n           05 easter-year         pic 9(4).\n           05 easter-month        pic 9(2).\n           05 easter-day          pic 9(2).\n\n       01  holiday-date           pic 9(8).\n       01  filler redefines holiday-date.\n           05 holiday-year        pic 9(4).\n           05 holiday-month       pic 9(2).\n           05 holiday-day         pic 9(2).\n\n       01  edt-date.\n           05 edt-week-day        pic x(3).\n           05 filler              pic x value space.\n           05 edt-day             pic z(2).\n           05 filler              pic x value space.\n           05 edt-month           pic x(3).\n\n       procedure division.\n       main.\n           display \"Christian holidays, related to Easter, for each centennial from 1700 to 2100 CE:\"\n           perform varying easter-year from 1700 by 100 until easter-year > 2100\n              perform output-holydays\n           end-perform\n           display \" \"\n\n           display \"Christian holidays, related to Easter, for years from 2010 to 2020 CE:\"\n           perform varying easter-year from 2010 by 1 until easter-year > 2020\n              perform output-holydays\n           end-perform\n           display \" \"\n\n           stop run\n           .\n       output-holydays.\n           display easter-year \" \" no advancing\n           perform calculate-easter\n\n           move 0 to days\n           perform add-days\n           display \" Easter: \" edt-date no advancing\n\n           move 39 to days\n           perform add-days\n           display \" Ascension: \" edt-date no advancing\n\n           move 49 to days\n           perform add-days\n           display \" Pentecost: \" edt-date no advancing\n\n           move 56 to days\n           perform add-days\n           display \" Trinity: \" edt-date no advancing\n\n           move 60 to days\n           perform add-days\n           display \" Corpus: \" edt-date \n           .\n       calculate-easter.\n           compute a = mod(easter-year, 19)\n           compute b = easter-year / 100\n           compute c = mod(easter-year, 100)\n           compute d = b / 4\n           compute e = mod(b, 4)\n           compute f = (b + 8) / 25\n           compute g = (b - f + 1) / 3\n           compute h = mod((19 * a + b - d - g + 15), 30)\n           compute i = c / 4\n           compute k = mod(c, 4)\n           compute l = mod((32 + 2 * e + 2 * i - h - k), 7)\n           compute m = (a + 11 * h + 22 * l) / 451\n           compute numerator = h + l - 7 * m + 114\n           compute easter-month = numerator / 31\n           compute easter-day = mod(numerator, 31) + 1\n           .\n       add-days.\n           if days = 0\n              move easter-date to holiday-date\n              move 1 to week-day\n           else\n              compute holiday-date = date-of-integer(integer-of-date(easter-date) + days)\n              compute week-day = mod(integer-of-date(easter-date) + days, 7) + 1\n           end-if\n           move week-day-abreviated(week-day) to edt-week-day\n           move month-abreviated(holiday-month) to edt-month\n           move holiday-day to edt-day\n           .\n", "target": "import java.text.DateFormatSymbols;\nimport java.util.*;\n\npublic class EasterRelatedHolidays {\n\n    final static Map<String, Integer> holidayOffsets;\n\n    static {\n        holidayOffsets = new LinkedHashMap<>();\n        holidayOffsets.put(\"Easter\", 0);\n        holidayOffsets.put(\"Ascension\", 39);\n        holidayOffsets.put(\"Pentecost\", 10);\n        holidayOffsets.put(\"Trinity\", 7);\n        holidayOffsets.put(\"Corpus\", 4);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Christian holidays, related to Easter,\"\n                + \" for each centennial from 400 to 2100 CE:\");\n\n        for (int y = 400; y <= 2100; y += 100)\n            printEasterRelatedHolidays(y);\n\n        System.out.println(\"\\nChristian holidays, related to Easter,\"\n                + \" for years from 2010 to 2020 CE:\");\n        for (int y = 2010; y < 2021; y++)\n            printEasterRelatedHolidays(y);\n    }\n\n    static void printEasterRelatedHolidays(int year) {\n        final int a = year % 19;\n        final int b = year / 100;\n        final int c = year % 100;\n        final int d = b / 4;\n        final int e = b % 4;\n        final int f = (b + 8) / 25;\n        final int g = (b - f + 1) / 3;\n        final int h = (19 * a + b - d - g + 15) % 30;\n        final int i = c / 4;\n        final int k = c % 4;\n        final int l = (32 + 2 * e + 2 * i - h - k) % 7;\n        final int m = (a + 11 * h + 22 * l) / 451;\n        final int n = h + l - 7 * m + 114;\n        final int month = n / 31 - 1;\n        final int day = (n % 31) + 1;\n\n        Calendar date = new GregorianCalendar(year, month, day);\n        String[] months = new DateFormatSymbols(Locale.US).getShortMonths();\n\n        System.out.printf(\"%4d \", year);\n        for (String hd : holidayOffsets.keySet()) {\n            date.add(Calendar.DATE, holidayOffsets.get(hd));\n            System.out.printf(\"%s: %2d %s  \", hd,\n                    date.get(Calendar.DAY_OF_MONTH),\n                    months[date.get(Calendar.MONTH)]);\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 91557, "name": "Holidays related to Easter", "source": "Translate COBOL to Python:        identification division.\n       program-id. Easter.\n \n       environment division.\n       configuration section.\n       repository.\n           function date-of-integer intrinsic\n           function integer-of-date intrinsic\n           function mod intrinsic.\n \n       data division.\n       working-storage section.\n       77  days                   pic 9(2).\n       77  a                      pic 9(2).  \n       77  b                      pic 9(2).  \n       77  c                      pic 9(2).  \n       77  d                      pic 9(2).  \n       77  e                      pic 9(2).  \n       77  f                      pic 9(2).  \n       77  g                      pic 9(2).  \n       77  h                      pic 9(2).  \n       77  i                      pic 9(2).  \n       77  k                      pic 9(2).  \n       77  l                      pic 9(2).  \n       77  m                      pic 9(2).  \n       77  week-day               pic 9(1).\n       77  numerator              pic 9(4).\n       77  integer-date           pic 9(18).\n       \n       01  month-tab              value \"JanFebMarAprMayJunJulAugSepOctNovDec\".\n           05 month-abreviated    pic x(3) occurs 12.\n           \n       01  week-day-tab           value \"SunMonTueWedThuFriSat\".\n           05 week-day-abreviated pic x(3) occurs 7.\n       \n       01  easter-date            pic 9(8).\n       01  filler redefines easter-date.\n           05 easter-year         pic 9(4).\n           05 easter-month        pic 9(2).\n           05 easter-day          pic 9(2).\n\n       01  holiday-date           pic 9(8).\n       01  filler redefines holiday-date.\n           05 holiday-year        pic 9(4).\n           05 holiday-month       pic 9(2).\n           05 holiday-day         pic 9(2).\n\n       01  edt-date.\n           05 edt-week-day        pic x(3).\n           05 filler              pic x value space.\n           05 edt-day             pic z(2).\n           05 filler              pic x value space.\n           05 edt-month           pic x(3).\n\n       procedure division.\n       main.\n           display \"Christian holidays, related to Easter, for each centennial from 1700 to 2100 CE:\"\n           perform varying easter-year from 1700 by 100 until easter-year > 2100\n              perform output-holydays\n           end-perform\n           display \" \"\n\n           display \"Christian holidays, related to Easter, for years from 2010 to 2020 CE:\"\n           perform varying easter-year from 2010 by 1 until easter-year > 2020\n              perform output-holydays\n           end-perform\n           display \" \"\n\n           stop run\n           .\n       output-holydays.\n           display easter-year \" \" no advancing\n           perform calculate-easter\n\n           move 0 to days\n           perform add-days\n           display \" Easter: \" edt-date no advancing\n\n           move 39 to days\n           perform add-days\n           display \" Ascension: \" edt-date no advancing\n\n           move 49 to days\n           perform add-days\n           display \" Pentecost: \" edt-date no advancing\n\n           move 56 to days\n           perform add-days\n           display \" Trinity: \" edt-date no advancing\n\n           move 60 to days\n           perform add-days\n           display \" Corpus: \" edt-date \n           .\n       calculate-easter.\n           compute a = mod(easter-year, 19)\n           compute b = easter-year / 100\n           compute c = mod(easter-year, 100)\n           compute d = b / 4\n           compute e = mod(b, 4)\n           compute f = (b + 8) / 25\n           compute g = (b - f + 1) / 3\n           compute h = mod((19 * a + b - d - g + 15), 30)\n           compute i = c / 4\n           compute k = mod(c, 4)\n           compute l = mod((32 + 2 * e + 2 * i - h - k), 7)\n           compute m = (a + 11 * h + 22 * l) / 451\n           compute numerator = h + l - 7 * m + 114\n           compute easter-month = numerator / 31\n           compute easter-day = mod(numerator, 31) + 1\n           .\n       add-days.\n           if days = 0\n              move easter-date to holiday-date\n              move 1 to week-day\n           else\n              compute holiday-date = date-of-integer(integer-of-date(easter-date) + days)\n              compute week-day = mod(integer-of-date(easter-date) + days, 7) + 1\n           end-if\n           move week-day-abreviated(week-day) to edt-week-day\n           move month-abreviated(holiday-month) to edt-month\n           move holiday-day to edt-day\n           .\n", "target": "from dateutil.easter import *\nimport datetime, calendar\n\nclass Holiday(object):\n    def __init__(self, date, offset=0):\n        self.holiday = date + datetime.timedelta(days=offset)\n\n    def __str__(self):\n        dayofweek = calendar.day_name[self.holiday.weekday()][0:3]\n        month = calendar.month_name[self.holiday.month][0:3]\n        return '{0} {1:2d} {2}'.format(dayofweek, self.holiday.day, month)\n\ndef get_holiday_values(year):\n    holidays = {'year': year}\n    easterDate = easter(year)\n    holidays['easter'] = Holiday(easterDate) \n    holidays['ascension'] = Holiday(easterDate, 39)\n    holidays['pentecost'] = Holiday(easterDate, 49)\n    holidays['trinity'] = Holiday(easterDate, 56)\n    holidays['corpus'] = Holiday(easterDate, 60)\n    return holidays\n    \ndef print_holidays(holidays):\n    print '{year:4d} Easter: {easter}, Ascension: {ascension}, Pentecost: {pentecost}, Trinity: {trinity}, Corpus: {corpus}'.format(**holidays)\n    \nif __name__ == \"__main__\":\n    print \"Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:\"\n    for year in range(400, 2200, 100):\n        print_holidays(get_holiday_values(year))\n\n    print ''\n    print \"Christian holidays, related to Easter, for years from 2010 to 2020 CE:\"\n    for year in range(2010, 2021):\n        print_holidays(get_holiday_values(year))\n"}
{"id": 91787, "name": "Stack", "source": "Translate COBOL to C#:        01  stack.\n         05  head USAGE IS POINTER VALUE NULL.\n", "target": "\nSystem.Collections.Stack stack = new System.Collections.Stack();\nstack.Push( obj );\nbool isEmpty = stack.Count == 0;\nobject top = stack.Peek(); \ntop = stack.Pop();\n\n\nSystem.Collections.Generic.Stack<Foo> stack = new System.Collections.Generic.Stack<Foo>();\nstack.Push(new Foo());\nbool isEmpty = stack.Count == 0;\nFoo top = stack.Peek(); \ntop = stack.Pop();\n"}
{"id": 91788, "name": "Stack", "source": "Translate COBOL to Java:        01  stack.\n         05  head USAGE IS POINTER VALUE NULL.\n", "target": "import java.util.Stack;\n\npublic class StackTest {\n    public static void main( final String[] args ) {\n        final Stack<String> stack = new Stack<String>();\n\n        System.out.println( \"New stack empty? \" + stack.empty() );\n\n        stack.push( \"There can be only one\" );\n        System.out.println( \"Pushed stack empty? \" + stack.empty() );\n        System.out.println( \"Popped single entry: \" + stack.pop() );\n\n        stack.push( \"First\" );\n        stack.push( \"Second\" );\n        System.out.println( \"Popped entry should be second: \" + stack.pop() );\n\n        \n        stack.pop();\n        stack.pop();\n    }\n}\n"}
{"id": 91789, "name": "Stack", "source": "Translate COBOL to Python:        01  stack.\n         05  head USAGE IS POINTER VALUE NULL.\n", "target": "from collections import deque\nstack = deque()\nstack.append(value) \nvalue = stack.pop()\nnot stack \n"}
{"id": 92030, "name": "CRC-32", "source": "Translate COBOL to C#:       \n       identification division.\n       program-id. rosetta-crc32.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 crc32-initial        usage binary-c-long.\n       01 crc32-result         usage binary-c-long unsigned.\n       01 crc32-input.\n          05 value \"The quick brown fox jumps over the lazy dog\".\n       01 crc32-hex            usage pointer.\n\n       procedure division.\n       crc32-main.\n\n      \n       call \"crc32\" using\n           by value crc32-initial\n           by reference crc32-input\n           by value length(crc32-input)\n           returning crc32-result\n           on exception\n               display \"error: no crc32 zlib linkage\" upon syserr\n       end-call\n       call \"printf\" using \"checksum: %lx\" & x\"0a\" by value crc32-result\n\n      \n       set crc32-hex up by crc32-result\n       display 'crc32 of \"' crc32-input '\" is ' crc32-hex\n\n       goback.\n       end program rosetta-crc32.\n", "target": "    \n    \n    \n    public class Crc32\n    {\n        #region Constants\n        \n        \n        \n        private const UInt32 s_generator = 0xEDB88320;\n        #endregion\n\n        #region Constructors\n        \n        \n        \n        public Crc32()\n        {\n            \n            m_checksumTable = Enumerable.Range(0, 256).Select(i =>\n            {\n                var tableEntry = (uint)i;\n                for (var j = 0; j < 8; ++j)\n                {\n                    tableEntry = ((tableEntry & 1) != 0)\n                        ? (s_generator ^ (tableEntry >> 1)) \n                        : (tableEntry >> 1);\n                }\n                return tableEntry;\n            }).ToArray();\n        }\n        #endregion\n\n        #region Methods\n        \n        \n        \n        \n        \n        public UInt32 Get<T>(IEnumerable<T> byteStream)\n        {\n            try\n            {\n                \n                return ~byteStream.Aggregate(0xFFFFFFFF, (checksumRegister, currentByte) => \n                          (m_checksumTable[(checksumRegister & 0xFF) ^ Convert.ToByte(currentByte)] ^ (checksumRegister >> 8)));\n            }\n            catch (FormatException e)\n            {\n                throw new CrcException(\"Could not read the stream out as bytes.\", e);\n            }\n            catch (InvalidCastException e)\n            {\n                throw new CrcException(\"Could not read the stream out as bytes.\", e);\n            }\n            catch (OverflowException e)\n            {\n                throw new CrcException(\"Could not read the stream out as bytes.\", e);\n            }\n        }\n        #endregion\n\n        #region Fields\n        \n        \n        \n        private readonly UInt32[] m_checksumTable;\n\n        #endregion\n    }\n"}
{"id": 92032, "name": "CRC-32", "source": "Translate COBOL to Java:       \n       identification division.\n       program-id. rosetta-crc32.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 crc32-initial        usage binary-c-long.\n       01 crc32-result         usage binary-c-long unsigned.\n       01 crc32-input.\n          05 value \"The quick brown fox jumps over the lazy dog\".\n       01 crc32-hex            usage pointer.\n\n       procedure division.\n       crc32-main.\n\n      \n       call \"crc32\" using\n           by value crc32-initial\n           by reference crc32-input\n           by value length(crc32-input)\n           returning crc32-result\n           on exception\n               display \"error: no crc32 zlib linkage\" upon syserr\n       end-call\n       call \"printf\" using \"checksum: %lx\" & x\"0a\" by value crc32-result\n\n      \n       set crc32-hex up by crc32-result\n       display 'crc32 of \"' crc32-input '\" is ' crc32-hex\n\n       goback.\n       end program rosetta-crc32.\n", "target": "import java.util.zip.* ;\n\npublic class CRCMaker {\n   public static void main( String[ ] args ) {\n      String toBeEncoded = new String( \"The quick brown fox jumps over the lazy dog\" ) ;\n      CRC32 myCRC = new CRC32( ) ;\n      myCRC.update( toBeEncoded.getBytes( ) ) ;\n      System.out.println( \"The CRC-32 value is\u00a0: \" + Long.toHexString( myCRC.getValue( ) ) + \"\u00a0!\" ) ;\n   }\n}\n"}
{"id": 92033, "name": "CRC-32", "source": "Translate COBOL to Python:       \n       identification division.\n       program-id. rosetta-crc32.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 crc32-initial        usage binary-c-long.\n       01 crc32-result         usage binary-c-long unsigned.\n       01 crc32-input.\n          05 value \"The quick brown fox jumps over the lazy dog\".\n       01 crc32-hex            usage pointer.\n\n       procedure division.\n       crc32-main.\n\n      \n       call \"crc32\" using\n           by value crc32-initial\n           by reference crc32-input\n           by value length(crc32-input)\n           returning crc32-result\n           on exception\n               display \"error: no crc32 zlib linkage\" upon syserr\n       end-call\n       call \"printf\" using \"checksum: %lx\" & x\"0a\" by value crc32-result\n\n      \n       set crc32-hex up by crc32-result\n       display 'crc32 of \"' crc32-input '\" is ' crc32-hex\n\n       goback.\n       end program rosetta-crc32.\n", "target": ">>> s = 'The quick brown fox jumps over the lazy dog'\n>>> import zlib\n>>> hex(zlib.crc32(s))\n'0x414fa339'\n\n>>> import binascii\n>>> hex(binascii.crc32(s))\n'0x414fa339'\n"}
{"id": 92844, "name": "Loops_Nested", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Nested-Loop.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       78  Table-Size VALUE 10.\n       01  Table-Area.\n           03  Table-Row OCCURS Table-Size TIMES\n                   INDEXED BY Row-Index.\n               05  Table-Element PIC 99 OCCURS Table-Size TIMES\n                   INDEXED BY Col-Index.\n\n       01  Current-Time PIC 9(8).\n       PROCEDURE DIVISION.\n*          \n           ACCEPT Current-Time FROM TIME\n           MOVE FUNCTION RANDOM(Current-Time) TO Current-Time\n\n*          \n*          \n*          \n           PERFORM VARYING Row-Index FROM 1 BY 1\n                       UNTIL Table-Size < Row-Index\n                   AFTER Col-Index FROM 1 BY 1\n                       UNTIL Table-Size < Col-Index\n               COMPUTE Table-Element (Row-Index, Col-Index) =\n                   FUNCTION MOD((FUNCTION RANDOM * 1000), 20) + 1\n           END-PERFORM\n\n*          \n*          \n           PERFORM VARYING Row-Index FROM 1 BY 1\n                   UNTIL Table-Size < Row-Index\n               PERFORM VARYING Col-Index FROM 1 BY 1\n                       UNTIL Table-Size < Col-Index\n                   IF Table-Element (Row-Index, Col-Index) = 20\n                       EXIT PERFORM\n                   ELSE\n                       DISPLAY Table-Element (Row-Index, Col-Index)\n                   END-IF\n               END-PERFORM\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        int[,] a = new int[10, 10];\n        Random r = new Random();\n\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                a[i, j] = r.Next(0, 21) + 1;\n            }\n        }\n        \n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                Console.Write(\" {0}\", a[i, j]);\n                if (a[i, j] == 20) {\n                    goto Done;\n                }\n            }\n            Console.WriteLine();\n        }\n    Done:\n        Console.WriteLine();\n    }\n}\n"}
{"id": 92846, "name": "Loops_Nested", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Nested-Loop.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       78  Table-Size VALUE 10.\n       01  Table-Area.\n           03  Table-Row OCCURS Table-Size TIMES\n                   INDEXED BY Row-Index.\n               05  Table-Element PIC 99 OCCURS Table-Size TIMES\n                   INDEXED BY Col-Index.\n\n       01  Current-Time PIC 9(8).\n       PROCEDURE DIVISION.\n*          \n           ACCEPT Current-Time FROM TIME\n           MOVE FUNCTION RANDOM(Current-Time) TO Current-Time\n\n*          \n*          \n*          \n           PERFORM VARYING Row-Index FROM 1 BY 1\n                       UNTIL Table-Size < Row-Index\n                   AFTER Col-Index FROM 1 BY 1\n                       UNTIL Table-Size < Col-Index\n               COMPUTE Table-Element (Row-Index, Col-Index) =\n                   FUNCTION MOD((FUNCTION RANDOM * 1000), 20) + 1\n           END-PERFORM\n\n*          \n*          \n           PERFORM VARYING Row-Index FROM 1 BY 1\n                   UNTIL Table-Size < Row-Index\n               PERFORM VARYING Col-Index FROM 1 BY 1\n                       UNTIL Table-Size < Col-Index\n                   IF Table-Element (Row-Index, Col-Index) = 20\n                       EXIT PERFORM\n                   ELSE\n                       DISPLAY Table-Element (Row-Index, Col-Index)\n                   END-IF\n               END-PERFORM\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "import java.util.Random;\n\npublic class NestedLoopTest {\n    public static final Random gen = new Random();\n    public static void main(String[] args) {\n        int[][] a = new int[10][10];\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[i].length; j++)\n                a[i][j] = gen.nextInt(20) + 1;\n\n        Outer:for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < a[i].length; j++) {\n                System.out.print(\" \" + a[i][j]);\n                if (a[i][j] == 20)\n                    break Outer; \n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 92847, "name": "Loops_Nested", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Nested-Loop.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       78  Table-Size VALUE 10.\n       01  Table-Area.\n           03  Table-Row OCCURS Table-Size TIMES\n                   INDEXED BY Row-Index.\n               05  Table-Element PIC 99 OCCURS Table-Size TIMES\n                   INDEXED BY Col-Index.\n\n       01  Current-Time PIC 9(8).\n       PROCEDURE DIVISION.\n*          \n           ACCEPT Current-Time FROM TIME\n           MOVE FUNCTION RANDOM(Current-Time) TO Current-Time\n\n*          \n*          \n*          \n           PERFORM VARYING Row-Index FROM 1 BY 1\n                       UNTIL Table-Size < Row-Index\n                   AFTER Col-Index FROM 1 BY 1\n                       UNTIL Table-Size < Col-Index\n               COMPUTE Table-Element (Row-Index, Col-Index) =\n                   FUNCTION MOD((FUNCTION RANDOM * 1000), 20) + 1\n           END-PERFORM\n\n*          \n*          \n           PERFORM VARYING Row-Index FROM 1 BY 1\n                   UNTIL Table-Size < Row-Index\n               PERFORM VARYING Col-Index FROM 1 BY 1\n                       UNTIL Table-Size < Col-Index\n                   IF Table-Element (Row-Index, Col-Index) = 20\n                       EXIT PERFORM\n                   ELSE\n                       DISPLAY Table-Element (Row-Index, Col-Index)\n                   END-IF\n               END-PERFORM\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "from random import randint\n\ndef do_scan(mat):\n    for row in mat:\n        for item in row:\n            print item,\n            if item == 20:\n                print\n                return\n        print\n    print\n\nmat = [[randint(1, 20) for x in xrange(10)] for y in xrange(10)]\ndo_scan(mat)\n"}
{"id": 93113, "name": "File input_output", "source": "Translate COBOL to C#:        identification division.\n       program-id. copyfile.\n       environment division.\n       input-output section.\n       file-control.\n           select input-file assign to \"input.txt\"\n               organization sequential\n           .\n           select output-file assign to \"output.txt\"\n               organization sequential\n           .\n       data division.\n       file section.\n       fd input-file.\n       1 input-record pic x(80).\n       fd output-file.\n       1 output-record pic x(80).\n       working-storage section.\n       1 end-of-file-flag pic 9 value 0.\n         88 eof value 1.\n       1 text-line pic x(80).\n       procedure division.\n       begin.\n           open input input-file\n               output output-file\n           perform read-input\n           perform until eof\n               write output-record from text-line\n               perform read-input\n           end-perform\n           close input-file output-file\n           stop run\n           .\n       read-input.\n           read input-file into text-line\n           at end\n               set eof to true\n           end-read\n           .\n       end program copyfile.\n", "target": "using System;\nusing System.IO;\n\nnamespace FileIO\n{\n  class Program\n  {\n    static void Main()\n    {\n      String s = scope .();\n      File.ReadAllText(\"input.txt\", s);\n      File.WriteAllText(\"output.txt\", s);\n    }\n  }\n}\n"}
{"id": 93115, "name": "File input_output", "source": "Translate COBOL to Java:        identification division.\n       program-id. copyfile.\n       environment division.\n       input-output section.\n       file-control.\n           select input-file assign to \"input.txt\"\n               organization sequential\n           .\n           select output-file assign to \"output.txt\"\n               organization sequential\n           .\n       data division.\n       file section.\n       fd input-file.\n       1 input-record pic x(80).\n       fd output-file.\n       1 output-record pic x(80).\n       working-storage section.\n       1 end-of-file-flag pic 9 value 0.\n         88 eof value 1.\n       1 text-line pic x(80).\n       procedure division.\n       begin.\n           open input input-file\n               output output-file\n           perform read-input\n           perform until eof\n               write output-record from text-line\n               perform read-input\n           end-perform\n           close input-file output-file\n           stop run\n           .\n       read-input.\n           read input-file into text-line\n           at end\n               set eof to true\n           end-read\n           .\n       end program copyfile.\n", "target": "import java.io.*;\n\npublic class FileIODemo {\n  public static void main(String[] args) {\n    try {\n      FileInputStream in = new FileInputStream(\"input.txt\");\n      FileOutputStream out = new FileOutputStream(\"ouput.txt\");\n      int c;\n      while ((c = in.read()) != -1) {\n        out.write(c);\n      }\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e){\n      e.printStackTrace();\n    }\n  }\n}\n"}
{"id": 93116, "name": "File input_output", "source": "Translate COBOL to Python:        identification division.\n       program-id. copyfile.\n       environment division.\n       input-output section.\n       file-control.\n           select input-file assign to \"input.txt\"\n               organization sequential\n           .\n           select output-file assign to \"output.txt\"\n               organization sequential\n           .\n       data division.\n       file section.\n       fd input-file.\n       1 input-record pic x(80).\n       fd output-file.\n       1 output-record pic x(80).\n       working-storage section.\n       1 end-of-file-flag pic 9 value 0.\n         88 eof value 1.\n       1 text-line pic x(80).\n       procedure division.\n       begin.\n           open input input-file\n               output output-file\n           perform read-input\n           perform until eof\n               write output-record from text-line\n               perform read-input\n           end-perform\n           close input-file output-file\n           stop run\n           .\n       read-input.\n           read input-file into text-line\n           at end\n               set eof to true\n           end-read\n           .\n       end program copyfile.\n", "target": "import shutil\nshutil.copyfile('input.txt', 'output.txt')\n"}
{"id": 93326, "name": "Sorting algorithms_Heapsort", "source": "Translate COBOL to C#:         >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. heapsort.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n01  filler.\n    03  a pic 99.\n    03  a-start pic 99.\n    03  a-end pic 99.\n    03  a-parent pic 99.\n    03  a-child pic 99.\n    03  a-sibling pic 99.\n    03  a-lim pic 99 value 10.\n    03  array-swap pic 99.\n    03  array occurs 10 pic 99.\nprocedure division.\nstart-heapsort.\n\n    \n    compute a = random(seconds-past-midnight)\n    perform varying a from 1 by 1 until a > a-lim\n        compute array(a) = random() * 100\n    end-perform\n\n    perform display-array\n    display  space 'initial array'\n\n    \n    move a-lim to a-end\n    compute a-start = (a-lim + 1) / 2\n    perform sift-down varying a-start from a-start by -1 until a-start = 0\n\n    perform display-array\n    display space 'heapified'\n\n    \n    move 1 to a-start\n    move a-lim to a-end\n    perform until a-end = a-start\n        move array(a-end) to array-swap\n        move array(a-start) to array(a-end)\n        move array-swap to array(a-start)\n        subtract 1 from a-end\n        perform sift-down\n    end-perform\n\n    perform display-array\n    display space 'sorted'\n\n    stop run\n    .\nsift-down.\n    move a-start to a-parent\n    perform until a-parent * 2 > a-end\n        compute a-child = a-parent * 2 \n        compute a-sibling = a-child + 1\n        if a-sibling <= a-end and array(a-child) < array(a-sibling)\n            \n            move a-sibling to a-child\n        end-if\n        if a-child <= a-end and array(a-parent) < array(a-child)\n           \n           move array(a-child) to array-swap\n           move array(a-parent) to array(a-child)\n           move array-swap to array(a-parent)\n        end-if\n        \n        move a-child to a-parent\n    end-perform\n    .\ndisplay-array.\n    perform varying a from 1 by 1 until a > a-lim\n        display space array(a) with no advancing\n    end-perform\n    .\nend program heapsort.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\npublic class HeapSortClass\n{\n    public static void HeapSort<T>(T[] array)\n    {\n        HeapSort<T>(array, 0, array.Length, Comparer<T>.Default);\n    }\n\n    public static void HeapSort<T>(T[] array, int offset, int length, IComparer<T> comparer)\n    {\n        HeapSort<T>(array, offset, length, comparer.Compare);\n    }\n\n    public static void HeapSort<T>(T[] array, int offset, int length, Comparison<T> comparison)\n    {\n        \n        for (int i = 0; i < length; i++)\n        {\n            int index = i;\n            T item = array[offset + i]; \n\n            \n            while (index > 0 &&\n                comparison(array[offset + (index - 1) / 2], item) < 0)\n            {\n                int top = (index - 1) / 2;\n                array[offset + index] = array[offset + top];\n                index = top;\n            }\n            array[offset + index] = item;\n        }\n\n        for (int i = length - 1; i > 0; i--)\n        {\n            \n            T last = array[offset + i];\n            array[offset + i] = array[offset];\n\n            int index = 0;\n            \n            while (index * 2 + 1 < i)\n            {\n                int left = index * 2 + 1, right = left + 1;\n\n                if (right < i && comparison(array[offset + left], array[offset + right]) < 0)\n                {\n                    if (comparison(last, array[offset + right]) > 0) break;\n\n                    array[offset + index] = array[offset + right];\n                    index = right;\n                }\n                else\n                {\n                    if (comparison(last, array[offset + left]) > 0) break;\n\n                    array[offset + index] = array[offset + left];\n                    index = left;\n                }\n            }\n            array[offset + index] = last;\n        }\n    }\n\n    static void Main()\n    {\n        \n        byte[] r = {5, 4, 1, 2};\n        HeapSort(r);\n\n        string[] s = { \"-\", \"D\", \"a\", \"33\" };\n        HeapSort(s, 0, s.Length, StringComparer.CurrentCultureIgnoreCase);\n    }\n}\n"}
{"id": 93328, "name": "Sorting algorithms_Heapsort", "source": "Translate COBOL to Java:         >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. heapsort.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n01  filler.\n    03  a pic 99.\n    03  a-start pic 99.\n    03  a-end pic 99.\n    03  a-parent pic 99.\n    03  a-child pic 99.\n    03  a-sibling pic 99.\n    03  a-lim pic 99 value 10.\n    03  array-swap pic 99.\n    03  array occurs 10 pic 99.\nprocedure division.\nstart-heapsort.\n\n    \n    compute a = random(seconds-past-midnight)\n    perform varying a from 1 by 1 until a > a-lim\n        compute array(a) = random() * 100\n    end-perform\n\n    perform display-array\n    display  space 'initial array'\n\n    \n    move a-lim to a-end\n    compute a-start = (a-lim + 1) / 2\n    perform sift-down varying a-start from a-start by -1 until a-start = 0\n\n    perform display-array\n    display space 'heapified'\n\n    \n    move 1 to a-start\n    move a-lim to a-end\n    perform until a-end = a-start\n        move array(a-end) to array-swap\n        move array(a-start) to array(a-end)\n        move array-swap to array(a-start)\n        subtract 1 from a-end\n        perform sift-down\n    end-perform\n\n    perform display-array\n    display space 'sorted'\n\n    stop run\n    .\nsift-down.\n    move a-start to a-parent\n    perform until a-parent * 2 > a-end\n        compute a-child = a-parent * 2 \n        compute a-sibling = a-child + 1\n        if a-sibling <= a-end and array(a-child) < array(a-sibling)\n            \n            move a-sibling to a-child\n        end-if\n        if a-child <= a-end and array(a-parent) < array(a-child)\n           \n           move array(a-child) to array-swap\n           move array(a-parent) to array(a-child)\n           move array-swap to array(a-parent)\n        end-if\n        \n        move a-child to a-parent\n    end-perform\n    .\ndisplay-array.\n    perform varying a from 1 by 1 until a > a-lim\n        display space array(a) with no advancing\n    end-perform\n    .\nend program heapsort.\n", "target": "public static void heapSort(int[] a){\n\tint count = a.length;\n\n\t\n\theapify(a, count);\n\n\tint end = count - 1;\n\twhile(end > 0){\n\t\t\n\t\t\n\t\tint tmp = a[end];\n\t\ta[end] = a[0];\n\t\ta[0] = tmp;\n\t\t\n\t\tsiftDown(a, 0, end - 1);\n\t\t\n\t\t\n\t\tend--;\n\t}\n}\n\npublic static void heapify(int[] a, int count){\n\t\n\tint start = (count - 2) / 2; \n\n\twhile(start >= 0){\n\t\t\n\t\t\n\t\t\n\t\tsiftDown(a, start, count - 1);\n\t\tstart--;\n\t}\n\t\n}\n\npublic static void siftDown(int[] a, int start, int end){\n\t\n\tint root = start;\n\n\twhile((root * 2 + 1) <= end){      \n\t\tint child = root * 2 + 1;           \n\t\t\n\t\tif(child + 1 <= end && a[child] < a[child + 1])\n\t\t\tchild = child + 1;           \n\t\tif(a[root] < a[child]){     \n\t\t\tint tmp = a[root];\n\t\t\ta[root] = a[child];\n\t\t\ta[child] = tmp;\n\t\t\troot = child;                \n\t\t}else\n\t\t\treturn;\n\t}\n}\n"}
{"id": 93329, "name": "Sorting algorithms_Heapsort", "source": "Translate COBOL to Python:         >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. heapsort.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n01  filler.\n    03  a pic 99.\n    03  a-start pic 99.\n    03  a-end pic 99.\n    03  a-parent pic 99.\n    03  a-child pic 99.\n    03  a-sibling pic 99.\n    03  a-lim pic 99 value 10.\n    03  array-swap pic 99.\n    03  array occurs 10 pic 99.\nprocedure division.\nstart-heapsort.\n\n    \n    compute a = random(seconds-past-midnight)\n    perform varying a from 1 by 1 until a > a-lim\n        compute array(a) = random() * 100\n    end-perform\n\n    perform display-array\n    display  space 'initial array'\n\n    \n    move a-lim to a-end\n    compute a-start = (a-lim + 1) / 2\n    perform sift-down varying a-start from a-start by -1 until a-start = 0\n\n    perform display-array\n    display space 'heapified'\n\n    \n    move 1 to a-start\n    move a-lim to a-end\n    perform until a-end = a-start\n        move array(a-end) to array-swap\n        move array(a-start) to array(a-end)\n        move array-swap to array(a-start)\n        subtract 1 from a-end\n        perform sift-down\n    end-perform\n\n    perform display-array\n    display space 'sorted'\n\n    stop run\n    .\nsift-down.\n    move a-start to a-parent\n    perform until a-parent * 2 > a-end\n        compute a-child = a-parent * 2 \n        compute a-sibling = a-child + 1\n        if a-sibling <= a-end and array(a-child) < array(a-sibling)\n            \n            move a-sibling to a-child\n        end-if\n        if a-child <= a-end and array(a-parent) < array(a-child)\n           \n           move array(a-child) to array-swap\n           move array(a-parent) to array(a-child)\n           move array-swap to array(a-parent)\n        end-if\n        \n        move a-child to a-parent\n    end-perform\n    .\ndisplay-array.\n    perform varying a from 1 by 1 until a > a-lim\n        display space array(a) with no advancing\n    end-perform\n    .\nend program heapsort.\n", "target": "def heapsort(lst):\n  \n\n  \n  for start in range((len(lst)-2)/2, -1, -1):\n    siftdown(lst, start, len(lst)-1)\n\n  for end in range(len(lst)-1, 0, -1):\n    lst[end], lst[0] = lst[0], lst[end]\n    siftdown(lst, 0, end - 1)\n  return lst\n\ndef siftdown(lst, start, end):\n  root = start\n  while True:\n    child = root * 2 + 1\n    if child > end: break\n    if child + 1 <= end and lst[child] < lst[child + 1]:\n      child += 1\n    if lst[root] < lst[child]:\n      lst[root], lst[child] = lst[child], lst[root]\n      root = child\n    else:\n      break\n"}
{"id": 94068, "name": "Sum and product of an array", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. array-sum-and-product.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Array-Size              VALUE 10.\n       01  array-area              VALUE \"01020304050607080910\".\n           03  array               PIC 99 OCCURS Array-Size TIMES.\n\n       01  array-sum               PIC 9(8).\n       01  array-product           PIC 9(10) VALUE 1.\n\n       01  i                       PIC 99.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL Array-Size < i\n               ADD array (i) TO array-sum\n               MULTIPLY array (i) BY array-product\n           END-PERFORM\n\n           DISPLAY \"Sum:     \" array-sum\n           DISPLAY \"Product: \" array-product\n\n           GOBACK\n           .\n", "target": "int sum = 0, prod = 1;\nint[] arg = { 1, 2, 3, 4, 5 };\nforeach (int value in arg) {\n  sum += value;\n  prod *= value;\n}\n"}
{"id": 94070, "name": "Sum and product of an array", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. array-sum-and-product.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Array-Size              VALUE 10.\n       01  array-area              VALUE \"01020304050607080910\".\n           03  array               PIC 99 OCCURS Array-Size TIMES.\n\n       01  array-sum               PIC 9(8).\n       01  array-product           PIC 9(10) VALUE 1.\n\n       01  i                       PIC 99.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL Array-Size < i\n               ADD array (i) TO array-sum\n               MULTIPLY array (i) BY array-product\n           END-PERFORM\n\n           DISPLAY \"Sum:     \" array-sum\n           DISPLAY \"Product: \" array-product\n\n           GOBACK\n           .\n", "target": "public class SumProd\n{\n public static void main(final String[] args)\n {\n  int sum = 0;\n  int prod = 1;\n  int[] arg = {1,2,3,4,5};\n  for (int i : arg)\n  {\n   sum += i;\n   prod *= i;\n  }\n }\n}\n"}
{"id": 94071, "name": "Sum and product of an array", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. array-sum-and-product.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Array-Size              VALUE 10.\n       01  array-area              VALUE \"01020304050607080910\".\n           03  array               PIC 99 OCCURS Array-Size TIMES.\n\n       01  array-sum               PIC 9(8).\n       01  array-product           PIC 9(10) VALUE 1.\n\n       01  i                       PIC 99.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL Array-Size < i\n               ADD array (i) TO array-sum\n               MULTIPLY array (i) BY array-product\n           END-PERFORM\n\n           DISPLAY \"Sum:     \" array-sum\n           DISPLAY \"Product: \" array-product\n\n           GOBACK\n           .\n", "target": "numbers = [1, 2, 3]\ntotal = sum(numbers)\n\nproduct = 1\nfor i in numbers:\n    product *= i\n"}
{"id": 94572, "name": "100 doors", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. 100Doors.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 Current-n      PIC 9(3).\n       01 StepSize       PIC 9(3).\n       01 DoorTable.\n          02 Doors       PIC 9(1)   OCCURS 100 TIMES.\n             88 ClosedDoor          VALUE ZERO.\n       01 Idx            PIC 9(3).\n\n       PROCEDURE DIVISION.\n       Begin.\n           INITIALIZE DoorTable\n           PERFORM VARYING StepSize FROM 1 BY 1 UNTIL StepSize > 100\n             PERFORM VARYING Current-n FROM StepSize BY StepSize\n                     UNTIL Current-n > 100\n               SUBTRACT Doors (Current-n) FROM 1 GIVING Doors (Current-n)\n             END-PERFORM\n           END-PERFORM\n\n           PERFORM VARYING Idx FROM 1 BY 1\n                   UNTIL Idx > 100\n             IF ClosedDoor (Idx)\n               DISPLAY Idx \" is closed.\"\n             ELSE\n               DISPLAY Idx \" is open.\"\n             END-IF\n           END-PERFORM\n\n           STOP RUN\n           .\n", "target": "namespace ConsoleApplication1\n{\n    using System;\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool[] doors = new bool[100];\n\n            \n            for (int d = 0; d < 100; d++) doors[d] = false;\n\n            \n            for (int p = 0; p < 100; p++)\n            {\n                \n                for (int d = 0; d < 100; d++)\n                {\n                    if ((d + 1) % (p + 1) == 0)\n                    {\n                        doors[d] = !doors[d];\n                    }\n                }\n            }\n\n            \n            Console.WriteLine(\"Passes Completed!!!  Here are the results: \\r\\n\");\n            for (int d = 0; d < 100; d++)\n            {\n                if (doors[d])\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Open\", d + 1));\n                }\n                else\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Closed\", d + 1));\n                }\n            }\n            Console.ReadKey(true);\n        }\n    }\n}\n"}
{"id": 94573, "name": "100 doors", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. 100Doors.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 Current-n      PIC 9(3).\n       01 StepSize       PIC 9(3).\n       01 DoorTable.\n          02 Doors       PIC 9(1)   OCCURS 100 TIMES.\n             88 ClosedDoor          VALUE ZERO.\n       01 Idx            PIC 9(3).\n\n       PROCEDURE DIVISION.\n       Begin.\n           INITIALIZE DoorTable\n           PERFORM VARYING StepSize FROM 1 BY 1 UNTIL StepSize > 100\n             PERFORM VARYING Current-n FROM StepSize BY StepSize\n                     UNTIL Current-n > 100\n               SUBTRACT Doors (Current-n) FROM 1 GIVING Doors (Current-n)\n             END-PERFORM\n           END-PERFORM\n\n           PERFORM VARYING Idx FROM 1 BY 1\n                   UNTIL Idx > 100\n             IF ClosedDoor (Idx)\n               DISPLAY Idx \" is closed.\"\n             ELSE\n               DISPLAY Idx \" is open.\"\n             END-IF\n           END-PERFORM\n\n           STOP RUN\n           .\n", "target": "namespace ConsoleApplication1\n{\n    using System;\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool[] doors = new bool[100];\n\n            \n            for (int d = 0; d < 100; d++) doors[d] = false;\n\n            \n            for (int p = 0; p < 100; p++)\n            {\n                \n                for (int d = 0; d < 100; d++)\n                {\n                    if ((d + 1) % (p + 1) == 0)\n                    {\n                        doors[d] = !doors[d];\n                    }\n                }\n            }\n\n            \n            Console.WriteLine(\"Passes Completed!!!  Here are the results: \\r\\n\");\n            for (int d = 0; d < 100; d++)\n            {\n                if (doors[d])\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Open\", d + 1));\n                }\n                else\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Closed\", d + 1));\n                }\n            }\n            Console.ReadKey(true);\n        }\n    }\n}\n"}
{"id": 94576, "name": "100 doors", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. 100Doors.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 Current-n      PIC 9(3).\n       01 StepSize       PIC 9(3).\n       01 DoorTable.\n          02 Doors       PIC 9(1)   OCCURS 100 TIMES.\n             88 ClosedDoor          VALUE ZERO.\n       01 Idx            PIC 9(3).\n\n       PROCEDURE DIVISION.\n       Begin.\n           INITIALIZE DoorTable\n           PERFORM VARYING StepSize FROM 1 BY 1 UNTIL StepSize > 100\n             PERFORM VARYING Current-n FROM StepSize BY StepSize\n                     UNTIL Current-n > 100\n               SUBTRACT Doors (Current-n) FROM 1 GIVING Doors (Current-n)\n             END-PERFORM\n           END-PERFORM\n\n           PERFORM VARYING Idx FROM 1 BY 1\n                   UNTIL Idx > 100\n             IF ClosedDoor (Idx)\n               DISPLAY Idx \" is closed.\"\n             ELSE\n               DISPLAY Idx \" is open.\"\n             END-IF\n           END-PERFORM\n\n           STOP RUN\n           .\n", "target": "module OneHundredDoors\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Boolean[] doors = new Boolean[100];\n        for (Int pass : 0 ..< 100)\n            {\n            for (Int door = pass; door < 100; door += 1+pass)\n                {\n                doors[door] = !doors[door];\n                }\n            }\n\n        console.print($\"open doors: {doors.mapIndexed((d, i) -> d\u00a0? i+1\u00a0: 0).filter(i -> i > 0)}\");\n        }\n    }\n"}
{"id": 94577, "name": "100 doors", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. 100Doors.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 Current-n      PIC 9(3).\n       01 StepSize       PIC 9(3).\n       01 DoorTable.\n          02 Doors       PIC 9(1)   OCCURS 100 TIMES.\n             88 ClosedDoor          VALUE ZERO.\n       01 Idx            PIC 9(3).\n\n       PROCEDURE DIVISION.\n       Begin.\n           INITIALIZE DoorTable\n           PERFORM VARYING StepSize FROM 1 BY 1 UNTIL StepSize > 100\n             PERFORM VARYING Current-n FROM StepSize BY StepSize\n                     UNTIL Current-n > 100\n               SUBTRACT Doors (Current-n) FROM 1 GIVING Doors (Current-n)\n             END-PERFORM\n           END-PERFORM\n\n           PERFORM VARYING Idx FROM 1 BY 1\n                   UNTIL Idx > 100\n             IF ClosedDoor (Idx)\n               DISPLAY Idx \" is closed.\"\n             ELSE\n               DISPLAY Idx \" is open.\"\n             END-IF\n           END-PERFORM\n\n           STOP RUN\n           .\n", "target": "module OneHundredDoors\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Boolean[] doors = new Boolean[100];\n        for (Int pass : 0 ..< 100)\n            {\n            for (Int door = pass; door < 100; door += 1+pass)\n                {\n                doors[door] = !doors[door];\n                }\n            }\n\n        console.print($\"open doors: {doors.mapIndexed((d, i) -> d\u00a0? i+1\u00a0: 0).filter(i -> i > 0)}\");\n        }\n    }\n"}
{"id": 94578, "name": "100 doors", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. 100Doors.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 Current-n      PIC 9(3).\n       01 StepSize       PIC 9(3).\n       01 DoorTable.\n          02 Doors       PIC 9(1)   OCCURS 100 TIMES.\n             88 ClosedDoor          VALUE ZERO.\n       01 Idx            PIC 9(3).\n\n       PROCEDURE DIVISION.\n       Begin.\n           INITIALIZE DoorTable\n           PERFORM VARYING StepSize FROM 1 BY 1 UNTIL StepSize > 100\n             PERFORM VARYING Current-n FROM StepSize BY StepSize\n                     UNTIL Current-n > 100\n               SUBTRACT Doors (Current-n) FROM 1 GIVING Doors (Current-n)\n             END-PERFORM\n           END-PERFORM\n\n           PERFORM VARYING Idx FROM 1 BY 1\n                   UNTIL Idx > 100\n             IF ClosedDoor (Idx)\n               DISPLAY Idx \" is closed.\"\n             ELSE\n               DISPLAY Idx \" is open.\"\n             END-IF\n           END-PERFORM\n\n           STOP RUN\n           .\n", "target": "var doors = falses(100)\n\nfor a in 1..100: for b in a..a..100:\n    doors[b] = not doors[b]\n\nfor a in 1..100:\n    print \"Door $a is ${(doors[a])\u00a0? 'open.': 'closed.'}\"\n"}
{"id": 94579, "name": "100 doors", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. 100Doors.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 Current-n      PIC 9(3).\n       01 StepSize       PIC 9(3).\n       01 DoorTable.\n          02 Doors       PIC 9(1)   OCCURS 100 TIMES.\n             88 ClosedDoor          VALUE ZERO.\n       01 Idx            PIC 9(3).\n\n       PROCEDURE DIVISION.\n       Begin.\n           INITIALIZE DoorTable\n           PERFORM VARYING StepSize FROM 1 BY 1 UNTIL StepSize > 100\n             PERFORM VARYING Current-n FROM StepSize BY StepSize\n                     UNTIL Current-n > 100\n               SUBTRACT Doors (Current-n) FROM 1 GIVING Doors (Current-n)\n             END-PERFORM\n           END-PERFORM\n\n           PERFORM VARYING Idx FROM 1 BY 1\n                   UNTIL Idx > 100\n             IF ClosedDoor (Idx)\n               DISPLAY Idx \" is closed.\"\n             ELSE\n               DISPLAY Idx \" is open.\"\n             END-IF\n           END-PERFORM\n\n           STOP RUN\n           .\n", "target": "var doors = falses(100)\n\nfor a in 1..100: for b in a..a..100:\n    doors[b] = not doors[b]\n\nfor a in 1..100:\n    print \"Door $a is ${(doors[a])\u00a0? 'open.': 'closed.'}\"\n"}
{"id": 95047, "name": "Anti-primes", "source": "Translate COBOL to C#:       ******************************************************************\n      * COBOL solution to Anti-primes challange\n      * The program was run on OpenCobolIDE\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ANGLE-PRIMES.\n\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       77  ANTI-PRIMES-CTR              PIC 9(3) VALUE 0.\n       77  FACTORS-CTR                  PIC 9(3) VALUE 0.\n       77  WS-INTEGER                   PIC 9(5) VALUE 1.\n       77  WS-MAX                       PIC 9(5) VALUE 0.\n       77  WS-I                         PIc 9(5) VALUE 0.\n       77  WS-LIMIT                     PIC 9(5) VALUE 1.\n       77  WS-REMAINDER                 PIC 9(5).\n\n       01  OUT-HDR         PIC X(23)    VALUE 'SEQ ANTI-PRIME FACTORS'.\n       01  OUT-LINE.\n           05 OUT-SEQ      PIC 9(3).\n           05 FILLER       PIC X(3)     VALUE SPACES.\n           05 OUT-ANTI     PIC ZZZZ9.\n           05 FILLER       PIC X(4)     VALUE SPACES.\n           05 OUT-FACTORS  PIC ZZZZ9.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           DISPLAY OUT-HDR.\n           PERFORM 100-GET-ANTI-PRIMES\n               VARYING WS-INTEGER FROM 1 By 1\n               UNTIL ANTI-PRIMES-CTR >= 20.\n           STOP RUN.\n\n       100-GET-ANTI-PRIMES.\n           SET FACTORS-CTR TO 0.\n           COMPUTE WS-LIMIT = 1 + WS-INTEGER ** .5.\n           PERFORM 200-COUNT-FACTORS\n               VARYING WS-I FROM 1 BY 1\n               UNTIL WS-I >= WS-LIMIT.\n           IF FACTORS-CTR > WS-MAX\n               ADD 1 TO ANTI-PRIMES-CTR\n               COMPUTE WS-MAX = FACTORS-CTR\n               MOVE ANTI-PRIMES-CTR TO OUT-SEQ\n               MOVE WS-INTEGER TO OUT-ANTI\n               MOVE FACTORS-CTR TO OUT-FACTORS\n               DISPLAY OUT-LINE\n           END-IF.\n\n       200-COUNT-FACTORS.\n           COMPUTE WS-REMAINDER =\n               FUNCTION MOD(WS-INTEGER WS-I).\n           IF WS-REMAINDER = ZERO\n               ADD 1 TO FACTORS-CTR\n               IF WS-INTEGER NOT = WS-I ** 2\n                   ADD 1 TO FACTORS-CTR\n               END-IF\n           END-IF.\n\n      ******************************************************************\n      *    OUTPUT:\n      ******************************************************************\n      *     SEQ ANTI-PRIME FACTORS\n      *     001       1        1\n      *     002       2        2\n      *     003       4        3\n      *     004       6        4\n      *     005      12        6\n      *     006      24        8\n      *     007      36        9\n      *     008      48       10\n      *     009      60       12\n      *     010     120       16\n      *     011     180       18\n      *     012     240       20\n      *     013     360       24\n      *     014     720       30\n      *     015     840       32\n      *     016    1260       36\n      *     017    1680       40\n      *     018    2520       48\n      *     019    5040       60\n      *     020    7560       64\n      ******************************************************************\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\t\t\t\t\t\npublic static class Program\n{\n    public static void Main() =>\n        Console.WriteLine(string.Join(\" \", FindAntiPrimes().Take(20)));\n\t\n    static IEnumerable<int> FindAntiPrimes() {\n        int max = 0;\n        for (int i = 1; ; i++) {\n            int divisors = CountDivisors(i);\n            if (divisors > max) {\n                max = divisors;\n                yield return i;\n            }\n        }\n\t\n        int CountDivisors(int n) => Enumerable.Range(1, n / 2).Count(i => n % i == 0) + 1;\n    }\n}\n"}
{"id": 95048, "name": "Anti-primes", "source": "Translate COBOL to C#:       ******************************************************************\n      * COBOL solution to Anti-primes challange\n      * The program was run on OpenCobolIDE\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ANGLE-PRIMES.\n\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       77  ANTI-PRIMES-CTR              PIC 9(3) VALUE 0.\n       77  FACTORS-CTR                  PIC 9(3) VALUE 0.\n       77  WS-INTEGER                   PIC 9(5) VALUE 1.\n       77  WS-MAX                       PIC 9(5) VALUE 0.\n       77  WS-I                         PIc 9(5) VALUE 0.\n       77  WS-LIMIT                     PIC 9(5) VALUE 1.\n       77  WS-REMAINDER                 PIC 9(5).\n\n       01  OUT-HDR         PIC X(23)    VALUE 'SEQ ANTI-PRIME FACTORS'.\n       01  OUT-LINE.\n           05 OUT-SEQ      PIC 9(3).\n           05 FILLER       PIC X(3)     VALUE SPACES.\n           05 OUT-ANTI     PIC ZZZZ9.\n           05 FILLER       PIC X(4)     VALUE SPACES.\n           05 OUT-FACTORS  PIC ZZZZ9.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           DISPLAY OUT-HDR.\n           PERFORM 100-GET-ANTI-PRIMES\n               VARYING WS-INTEGER FROM 1 By 1\n               UNTIL ANTI-PRIMES-CTR >= 20.\n           STOP RUN.\n\n       100-GET-ANTI-PRIMES.\n           SET FACTORS-CTR TO 0.\n           COMPUTE WS-LIMIT = 1 + WS-INTEGER ** .5.\n           PERFORM 200-COUNT-FACTORS\n               VARYING WS-I FROM 1 BY 1\n               UNTIL WS-I >= WS-LIMIT.\n           IF FACTORS-CTR > WS-MAX\n               ADD 1 TO ANTI-PRIMES-CTR\n               COMPUTE WS-MAX = FACTORS-CTR\n               MOVE ANTI-PRIMES-CTR TO OUT-SEQ\n               MOVE WS-INTEGER TO OUT-ANTI\n               MOVE FACTORS-CTR TO OUT-FACTORS\n               DISPLAY OUT-LINE\n           END-IF.\n\n       200-COUNT-FACTORS.\n           COMPUTE WS-REMAINDER =\n               FUNCTION MOD(WS-INTEGER WS-I).\n           IF WS-REMAINDER = ZERO\n               ADD 1 TO FACTORS-CTR\n               IF WS-INTEGER NOT = WS-I ** 2\n                   ADD 1 TO FACTORS-CTR\n               END-IF\n           END-IF.\n\n      ******************************************************************\n      *    OUTPUT:\n      ******************************************************************\n      *     SEQ ANTI-PRIME FACTORS\n      *     001       1        1\n      *     002       2        2\n      *     003       4        3\n      *     004       6        4\n      *     005      12        6\n      *     006      24        8\n      *     007      36        9\n      *     008      48       10\n      *     009      60       12\n      *     010     120       16\n      *     011     180       18\n      *     012     240       20\n      *     013     360       24\n      *     014     720       30\n      *     015     840       32\n      *     016    1260       36\n      *     017    1680       40\n      *     018    2520       48\n      *     019    5040       60\n      *     020    7560       64\n      ******************************************************************\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\t\t\t\t\t\npublic static class Program\n{\n    public static void Main() =>\n        Console.WriteLine(string.Join(\" \", FindAntiPrimes().Take(20)));\n\t\n    static IEnumerable<int> FindAntiPrimes() {\n        int max = 0;\n        for (int i = 1; ; i++) {\n            int divisors = CountDivisors(i);\n            if (divisors > max) {\n                max = divisors;\n                yield return i;\n            }\n        }\n\t\n        int CountDivisors(int n) => Enumerable.Range(1, n / 2).Count(i => n % i == 0) + 1;\n    }\n}\n"}
{"id": 95051, "name": "Anti-primes", "source": "Translate COBOL to Java:       ******************************************************************\n      * COBOL solution to Anti-primes challange\n      * The program was run on OpenCobolIDE\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ANGLE-PRIMES.\n\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       77  ANTI-PRIMES-CTR              PIC 9(3) VALUE 0.\n       77  FACTORS-CTR                  PIC 9(3) VALUE 0.\n       77  WS-INTEGER                   PIC 9(5) VALUE 1.\n       77  WS-MAX                       PIC 9(5) VALUE 0.\n       77  WS-I                         PIc 9(5) VALUE 0.\n       77  WS-LIMIT                     PIC 9(5) VALUE 1.\n       77  WS-REMAINDER                 PIC 9(5).\n\n       01  OUT-HDR         PIC X(23)    VALUE 'SEQ ANTI-PRIME FACTORS'.\n       01  OUT-LINE.\n           05 OUT-SEQ      PIC 9(3).\n           05 FILLER       PIC X(3)     VALUE SPACES.\n           05 OUT-ANTI     PIC ZZZZ9.\n           05 FILLER       PIC X(4)     VALUE SPACES.\n           05 OUT-FACTORS  PIC ZZZZ9.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           DISPLAY OUT-HDR.\n           PERFORM 100-GET-ANTI-PRIMES\n               VARYING WS-INTEGER FROM 1 By 1\n               UNTIL ANTI-PRIMES-CTR >= 20.\n           STOP RUN.\n\n       100-GET-ANTI-PRIMES.\n           SET FACTORS-CTR TO 0.\n           COMPUTE WS-LIMIT = 1 + WS-INTEGER ** .5.\n           PERFORM 200-COUNT-FACTORS\n               VARYING WS-I FROM 1 BY 1\n               UNTIL WS-I >= WS-LIMIT.\n           IF FACTORS-CTR > WS-MAX\n               ADD 1 TO ANTI-PRIMES-CTR\n               COMPUTE WS-MAX = FACTORS-CTR\n               MOVE ANTI-PRIMES-CTR TO OUT-SEQ\n               MOVE WS-INTEGER TO OUT-ANTI\n               MOVE FACTORS-CTR TO OUT-FACTORS\n               DISPLAY OUT-LINE\n           END-IF.\n\n       200-COUNT-FACTORS.\n           COMPUTE WS-REMAINDER =\n               FUNCTION MOD(WS-INTEGER WS-I).\n           IF WS-REMAINDER = ZERO\n               ADD 1 TO FACTORS-CTR\n               IF WS-INTEGER NOT = WS-I ** 2\n                   ADD 1 TO FACTORS-CTR\n               END-IF\n           END-IF.\n\n      ******************************************************************\n      *    OUTPUT:\n      ******************************************************************\n      *     SEQ ANTI-PRIME FACTORS\n      *     001       1        1\n      *     002       2        2\n      *     003       4        3\n      *     004       6        4\n      *     005      12        6\n      *     006      24        8\n      *     007      36        9\n      *     008      48       10\n      *     009      60       12\n      *     010     120       16\n      *     011     180       18\n      *     012     240       20\n      *     013     360       24\n      *     014     720       30\n      *     015     840       32\n      *     016    1260       36\n      *     017    1680       40\n      *     018    2520       48\n      *     019    5040       60\n      *     020    7560       64\n      ******************************************************************\n", "target": "public class Antiprime {\n\n    static int countDivisors(int n) {\n        if (n < 2) return 1;\n        int count = 2; \n        for (int i = 2; i <= n/2; ++i) {\n            if (n%i == 0) ++count;\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        int maxDiv = 0, count = 0;\n        System.out.println(\"The first 20 anti-primes are:\");\n        for (int n = 1; count < 20; ++n) {\n            int d = countDivisors(n);\n            if (d > maxDiv) {\n                System.out.printf(\"%d \", n);\n                maxDiv = d;\n                count++;\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 95052, "name": "Anti-primes", "source": "Translate COBOL to Java:       ******************************************************************\n      * COBOL solution to Anti-primes challange\n      * The program was run on OpenCobolIDE\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ANGLE-PRIMES.\n\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       77  ANTI-PRIMES-CTR              PIC 9(3) VALUE 0.\n       77  FACTORS-CTR                  PIC 9(3) VALUE 0.\n       77  WS-INTEGER                   PIC 9(5) VALUE 1.\n       77  WS-MAX                       PIC 9(5) VALUE 0.\n       77  WS-I                         PIc 9(5) VALUE 0.\n       77  WS-LIMIT                     PIC 9(5) VALUE 1.\n       77  WS-REMAINDER                 PIC 9(5).\n\n       01  OUT-HDR         PIC X(23)    VALUE 'SEQ ANTI-PRIME FACTORS'.\n       01  OUT-LINE.\n           05 OUT-SEQ      PIC 9(3).\n           05 FILLER       PIC X(3)     VALUE SPACES.\n           05 OUT-ANTI     PIC ZZZZ9.\n           05 FILLER       PIC X(4)     VALUE SPACES.\n           05 OUT-FACTORS  PIC ZZZZ9.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           DISPLAY OUT-HDR.\n           PERFORM 100-GET-ANTI-PRIMES\n               VARYING WS-INTEGER FROM 1 By 1\n               UNTIL ANTI-PRIMES-CTR >= 20.\n           STOP RUN.\n\n       100-GET-ANTI-PRIMES.\n           SET FACTORS-CTR TO 0.\n           COMPUTE WS-LIMIT = 1 + WS-INTEGER ** .5.\n           PERFORM 200-COUNT-FACTORS\n               VARYING WS-I FROM 1 BY 1\n               UNTIL WS-I >= WS-LIMIT.\n           IF FACTORS-CTR > WS-MAX\n               ADD 1 TO ANTI-PRIMES-CTR\n               COMPUTE WS-MAX = FACTORS-CTR\n               MOVE ANTI-PRIMES-CTR TO OUT-SEQ\n               MOVE WS-INTEGER TO OUT-ANTI\n               MOVE FACTORS-CTR TO OUT-FACTORS\n               DISPLAY OUT-LINE\n           END-IF.\n\n       200-COUNT-FACTORS.\n           COMPUTE WS-REMAINDER =\n               FUNCTION MOD(WS-INTEGER WS-I).\n           IF WS-REMAINDER = ZERO\n               ADD 1 TO FACTORS-CTR\n               IF WS-INTEGER NOT = WS-I ** 2\n                   ADD 1 TO FACTORS-CTR\n               END-IF\n           END-IF.\n\n      ******************************************************************\n      *    OUTPUT:\n      ******************************************************************\n      *     SEQ ANTI-PRIME FACTORS\n      *     001       1        1\n      *     002       2        2\n      *     003       4        3\n      *     004       6        4\n      *     005      12        6\n      *     006      24        8\n      *     007      36        9\n      *     008      48       10\n      *     009      60       12\n      *     010     120       16\n      *     011     180       18\n      *     012     240       20\n      *     013     360       24\n      *     014     720       30\n      *     015     840       32\n      *     016    1260       36\n      *     017    1680       40\n      *     018    2520       48\n      *     019    5040       60\n      *     020    7560       64\n      ******************************************************************\n", "target": "public class Antiprime {\n\n    static int countDivisors(int n) {\n        if (n < 2) return 1;\n        int count = 2; \n        for (int i = 2; i <= n/2; ++i) {\n            if (n%i == 0) ++count;\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        int maxDiv = 0, count = 0;\n        System.out.println(\"The first 20 anti-primes are:\");\n        for (int n = 1; count < 20; ++n) {\n            int d = countDivisors(n);\n            if (d > maxDiv) {\n                System.out.printf(\"%d \", n);\n                maxDiv = d;\n                count++;\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 95053, "name": "Anti-primes", "source": "Translate COBOL to Python:       ******************************************************************\n      * COBOL solution to Anti-primes challange\n      * The program was run on OpenCobolIDE\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ANGLE-PRIMES.\n\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       77  ANTI-PRIMES-CTR              PIC 9(3) VALUE 0.\n       77  FACTORS-CTR                  PIC 9(3) VALUE 0.\n       77  WS-INTEGER                   PIC 9(5) VALUE 1.\n       77  WS-MAX                       PIC 9(5) VALUE 0.\n       77  WS-I                         PIc 9(5) VALUE 0.\n       77  WS-LIMIT                     PIC 9(5) VALUE 1.\n       77  WS-REMAINDER                 PIC 9(5).\n\n       01  OUT-HDR         PIC X(23)    VALUE 'SEQ ANTI-PRIME FACTORS'.\n       01  OUT-LINE.\n           05 OUT-SEQ      PIC 9(3).\n           05 FILLER       PIC X(3)     VALUE SPACES.\n           05 OUT-ANTI     PIC ZZZZ9.\n           05 FILLER       PIC X(4)     VALUE SPACES.\n           05 OUT-FACTORS  PIC ZZZZ9.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           DISPLAY OUT-HDR.\n           PERFORM 100-GET-ANTI-PRIMES\n               VARYING WS-INTEGER FROM 1 By 1\n               UNTIL ANTI-PRIMES-CTR >= 20.\n           STOP RUN.\n\n       100-GET-ANTI-PRIMES.\n           SET FACTORS-CTR TO 0.\n           COMPUTE WS-LIMIT = 1 + WS-INTEGER ** .5.\n           PERFORM 200-COUNT-FACTORS\n               VARYING WS-I FROM 1 BY 1\n               UNTIL WS-I >= WS-LIMIT.\n           IF FACTORS-CTR > WS-MAX\n               ADD 1 TO ANTI-PRIMES-CTR\n               COMPUTE WS-MAX = FACTORS-CTR\n               MOVE ANTI-PRIMES-CTR TO OUT-SEQ\n               MOVE WS-INTEGER TO OUT-ANTI\n               MOVE FACTORS-CTR TO OUT-FACTORS\n               DISPLAY OUT-LINE\n           END-IF.\n\n       200-COUNT-FACTORS.\n           COMPUTE WS-REMAINDER =\n               FUNCTION MOD(WS-INTEGER WS-I).\n           IF WS-REMAINDER = ZERO\n               ADD 1 TO FACTORS-CTR\n               IF WS-INTEGER NOT = WS-I ** 2\n                   ADD 1 TO FACTORS-CTR\n               END-IF\n           END-IF.\n\n      ******************************************************************\n      *    OUTPUT:\n      ******************************************************************\n      *     SEQ ANTI-PRIME FACTORS\n      *     001       1        1\n      *     002       2        2\n      *     003       4        3\n      *     004       6        4\n      *     005      12        6\n      *     006      24        8\n      *     007      36        9\n      *     008      48       10\n      *     009      60       12\n      *     010     120       16\n      *     011     180       18\n      *     012     240       20\n      *     013     360       24\n      *     014     720       30\n      *     015     840       32\n      *     016    1260       36\n      *     017    1680       40\n      *     018    2520       48\n      *     019    5040       60\n      *     020    7560       64\n      ******************************************************************\n", "target": "from itertools import chain, count, cycle, islice, accumulate\n \ndef factors(n):\n    def prime_powers(n):\n        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):\n            if c*c > n: break\n            if n%c: continue\n            d,p = (), c\n            while not n%c:\n                n,p,d = n//c, p*c, d+(p,)\n            yield d\n        if n > 1: yield n,\n \n    r = [1]\n    for e in prime_powers(n):\n        r += [a*b for a in r for b in e]\n    return r\n    \ndef antiprimes():\n    mx = 0\n    yield 1\n    for c in count(2,2):\n        if c >= 58: break\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln\n    for c in count(60,30):\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln  \n\nif __name__ == '__main__':\n    print(*islice(antiprimes(), 40)))\n"}
{"id": 95054, "name": "Anti-primes", "source": "Translate COBOL to Python:       ******************************************************************\n      * COBOL solution to Anti-primes challange\n      * The program was run on OpenCobolIDE\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ANGLE-PRIMES.\n\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       77  ANTI-PRIMES-CTR              PIC 9(3) VALUE 0.\n       77  FACTORS-CTR                  PIC 9(3) VALUE 0.\n       77  WS-INTEGER                   PIC 9(5) VALUE 1.\n       77  WS-MAX                       PIC 9(5) VALUE 0.\n       77  WS-I                         PIc 9(5) VALUE 0.\n       77  WS-LIMIT                     PIC 9(5) VALUE 1.\n       77  WS-REMAINDER                 PIC 9(5).\n\n       01  OUT-HDR         PIC X(23)    VALUE 'SEQ ANTI-PRIME FACTORS'.\n       01  OUT-LINE.\n           05 OUT-SEQ      PIC 9(3).\n           05 FILLER       PIC X(3)     VALUE SPACES.\n           05 OUT-ANTI     PIC ZZZZ9.\n           05 FILLER       PIC X(4)     VALUE SPACES.\n           05 OUT-FACTORS  PIC ZZZZ9.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           DISPLAY OUT-HDR.\n           PERFORM 100-GET-ANTI-PRIMES\n               VARYING WS-INTEGER FROM 1 By 1\n               UNTIL ANTI-PRIMES-CTR >= 20.\n           STOP RUN.\n\n       100-GET-ANTI-PRIMES.\n           SET FACTORS-CTR TO 0.\n           COMPUTE WS-LIMIT = 1 + WS-INTEGER ** .5.\n           PERFORM 200-COUNT-FACTORS\n               VARYING WS-I FROM 1 BY 1\n               UNTIL WS-I >= WS-LIMIT.\n           IF FACTORS-CTR > WS-MAX\n               ADD 1 TO ANTI-PRIMES-CTR\n               COMPUTE WS-MAX = FACTORS-CTR\n               MOVE ANTI-PRIMES-CTR TO OUT-SEQ\n               MOVE WS-INTEGER TO OUT-ANTI\n               MOVE FACTORS-CTR TO OUT-FACTORS\n               DISPLAY OUT-LINE\n           END-IF.\n\n       200-COUNT-FACTORS.\n           COMPUTE WS-REMAINDER =\n               FUNCTION MOD(WS-INTEGER WS-I).\n           IF WS-REMAINDER = ZERO\n               ADD 1 TO FACTORS-CTR\n               IF WS-INTEGER NOT = WS-I ** 2\n                   ADD 1 TO FACTORS-CTR\n               END-IF\n           END-IF.\n\n      ******************************************************************\n      *    OUTPUT:\n      ******************************************************************\n      *     SEQ ANTI-PRIME FACTORS\n      *     001       1        1\n      *     002       2        2\n      *     003       4        3\n      *     004       6        4\n      *     005      12        6\n      *     006      24        8\n      *     007      36        9\n      *     008      48       10\n      *     009      60       12\n      *     010     120       16\n      *     011     180       18\n      *     012     240       20\n      *     013     360       24\n      *     014     720       30\n      *     015     840       32\n      *     016    1260       36\n      *     017    1680       40\n      *     018    2520       48\n      *     019    5040       60\n      *     020    7560       64\n      ******************************************************************\n", "target": "from itertools import chain, count, cycle, islice, accumulate\n \ndef factors(n):\n    def prime_powers(n):\n        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):\n            if c*c > n: break\n            if n%c: continue\n            d,p = (), c\n            while not n%c:\n                n,p,d = n//c, p*c, d+(p,)\n            yield d\n        if n > 1: yield n,\n \n    r = [1]\n    for e in prime_powers(n):\n        r += [a*b for a in r for b in e]\n    return r\n    \ndef antiprimes():\n    mx = 0\n    yield 1\n    for c in count(2,2):\n        if c >= 58: break\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln\n    for c in count(60,30):\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln  \n\nif __name__ == '__main__':\n    print(*islice(antiprimes(), 40)))\n"}
{"id": 95695, "name": "Knuth shuffle", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. knuth-shuffle.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  i                       PIC 9(8).\n       01  j                       PIC 9(8).\n\n       01  temp                    PIC 9(8).\n\n       LINKAGE SECTION.\n       78  Table-Len               VALUE 10.\n       01  ttable-area.\n           03  ttable              PIC 9(8) OCCURS Table-Len TIMES.\n\n       PROCEDURE DIVISION USING ttable-area.\n           MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (11:6)) TO i\n\n           PERFORM VARYING i FROM Table-Len BY -1 UNTIL i = 0\n               COMPUTE j =\n                   FUNCTION MOD(FUNCTION RANDOM * 10000, Table-Len) + 1\n\n               MOVE ttable (i) TO temp\n               MOVE ttable (j) TO ttable (i)\n               MOVE temp TO ttable (j)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "public static void KnuthShuffle<T>(T[] array)\n{\n    System.Random random = new System.Random();\n    for (int i = 0; i < array.Length; i++)\n    {\n        int j = random.Next(i, array.Length); \n        T temp = array[i]; array[i] = array[j]; array[j] = temp;\n    }\n}\n"}
{"id": 95697, "name": "Knuth shuffle", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. knuth-shuffle.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  i                       PIC 9(8).\n       01  j                       PIC 9(8).\n\n       01  temp                    PIC 9(8).\n\n       LINKAGE SECTION.\n       78  Table-Len               VALUE 10.\n       01  ttable-area.\n           03  ttable              PIC 9(8) OCCURS Table-Len TIMES.\n\n       PROCEDURE DIVISION USING ttable-area.\n           MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (11:6)) TO i\n\n           PERFORM VARYING i FROM Table-Len BY -1 UNTIL i = 0\n               COMPUTE j =\n                   FUNCTION MOD(FUNCTION RANDOM * 10000, Table-Len) + 1\n\n               MOVE ttable (i) TO temp\n               MOVE ttable (j) TO ttable (i)\n               MOVE temp TO ttable (j)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "import java.util.Random;\n\npublic static final Random gen = new Random();\n\n\npublic static void shuffle (int[] array) {\n    int n = array.length;\n    while (n > 1) {\n        int k = gen.nextInt(n--); \n        int temp = array[n];\n        array[n] = array[k];\n        array[k] = temp;\n    }\n}\n\npublic static void shuffle (Object[] array) {\n    int n = array.length;\n    while (n > 1) {\n        int k = gen.nextInt(n--); \n        Object temp = array[n];\n        array[n] = array[k];\n        array[k] = temp;\n    }\n}\n"}
{"id": 95698, "name": "Knuth shuffle", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. knuth-shuffle.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  i                       PIC 9(8).\n       01  j                       PIC 9(8).\n\n       01  temp                    PIC 9(8).\n\n       LINKAGE SECTION.\n       78  Table-Len               VALUE 10.\n       01  ttable-area.\n           03  ttable              PIC 9(8) OCCURS Table-Len TIMES.\n\n       PROCEDURE DIVISION USING ttable-area.\n           MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (11:6)) TO i\n\n           PERFORM VARYING i FROM Table-Len BY -1 UNTIL i = 0\n               COMPUTE j =\n                   FUNCTION MOD(FUNCTION RANDOM * 10000, Table-Len) + 1\n\n               MOVE ttable (i) TO temp\n               MOVE ttable (j) TO ttable (i)\n               MOVE temp TO ttable (j)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "from random import randrange\n\ndef knuth_shuffle(x):\n    for i in range(len(x)-1, 0, -1):\n        j = randrange(i + 1)\n        x[i], x[j] = x[j], x[i]\n\nx = list(range(10))\nknuth_shuffle(x)\nprint(\"shuffled:\", x)\n"}
{"id": 96449, "name": "Map range", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. demo-map-range.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i                       USAGE FLOAT-LONG.\n\n       01  mapped-num              USAGE FLOAT-LONG.\n\n       01  a-begin                 USAGE FLOAT-LONG VALUE 0.\n       01  a-end                   USAGE FLOAT-LONG VALUE 10.\n\n       01  b-begin                 USAGE FLOAT-LONG VALUE -1.\n       01  b-end                   USAGE FLOAT-LONG VALUE 0.\n\n       01  i-display               PIC --9.9.\n       01  mapped-display          PIC --9.9.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 0 BY 1 UNTIL i > 10\n               CALL \"map-range\" USING CONTENT a-begin, a-end, b-begin,\n                   b-end, i, REFERENCE mapped-num\n               COMPUTE i-display ROUNDED = i\n               COMPUTE mapped-display ROUNDED = mapped-num\n               DISPLAY FUNCTION TRIM(i-display) \" maps to \"\n                   FUNCTION TRIM(mapped-display)\n           END-PERFORM\n           .\n       END PROGRAM demo-map-range.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. map-range.\n\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  a-begin                 USAGE FLOAT-LONG.\n       01  a-end                   USAGE FLOAT-LONG.\n\n       01  b-begin                 USAGE FLOAT-LONG.\n       01  b-end                   USAGE FLOAT-LONG.\n\n       01  val-to-map              USAGE FLOAT-LONG.\n\n       01  ret                     USAGE FLOAT-LONG.\n\n       PROCEDURE DIVISION USING a-begin, a-end, b-begin, b-end,\n               val-to-map, ret.\n           COMPUTE ret = \n               b-begin + ((val-to-map - a-begin) * (b-end - b-begin)\n                   / (a-end - a-begin))\n           .\n       END PROGRAM map-range.\n", "target": "using System;\nusing System.Linq;\n\npublic class MapRange\n{\n    public static void Main() {\n        foreach (int i in Enumerable.Range(0, 11))\n            Console.WriteLine($\"{i} maps to {Map(0, 10, -1, 0, i)}\");\n    }\n    \n    static double Map(double a1, double a2, double b1, double b2, double s) => b1 + (s - a1) * (b2 - b1) / (a2 - a1);\n}\n"}
{"id": 96450, "name": "Map range", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. demo-map-range.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i                       USAGE FLOAT-LONG.\n\n       01  mapped-num              USAGE FLOAT-LONG.\n\n       01  a-begin                 USAGE FLOAT-LONG VALUE 0.\n       01  a-end                   USAGE FLOAT-LONG VALUE 10.\n\n       01  b-begin                 USAGE FLOAT-LONG VALUE -1.\n       01  b-end                   USAGE FLOAT-LONG VALUE 0.\n\n       01  i-display               PIC --9.9.\n       01  mapped-display          PIC --9.9.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 0 BY 1 UNTIL i > 10\n               CALL \"map-range\" USING CONTENT a-begin, a-end, b-begin,\n                   b-end, i, REFERENCE mapped-num\n               COMPUTE i-display ROUNDED = i\n               COMPUTE mapped-display ROUNDED = mapped-num\n               DISPLAY FUNCTION TRIM(i-display) \" maps to \"\n                   FUNCTION TRIM(mapped-display)\n           END-PERFORM\n           .\n       END PROGRAM demo-map-range.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. map-range.\n\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  a-begin                 USAGE FLOAT-LONG.\n       01  a-end                   USAGE FLOAT-LONG.\n\n       01  b-begin                 USAGE FLOAT-LONG.\n       01  b-end                   USAGE FLOAT-LONG.\n\n       01  val-to-map              USAGE FLOAT-LONG.\n\n       01  ret                     USAGE FLOAT-LONG.\n\n       PROCEDURE DIVISION USING a-begin, a-end, b-begin, b-end,\n               val-to-map, ret.\n           COMPUTE ret = \n               b-begin + ((val-to-map - a-begin) * (b-end - b-begin)\n                   / (a-end - a-begin))\n           .\n       END PROGRAM map-range.\n", "target": "using System;\nusing System.Linq;\n\npublic class MapRange\n{\n    public static void Main() {\n        foreach (int i in Enumerable.Range(0, 11))\n            Console.WriteLine($\"{i} maps to {Map(0, 10, -1, 0, i)}\");\n    }\n    \n    static double Map(double a1, double a2, double b1, double b2, double s) => b1 + (s - a1) * (b2 - b1) / (a2 - a1);\n}\n"}
{"id": 96453, "name": "Map range", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. demo-map-range.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i                       USAGE FLOAT-LONG.\n\n       01  mapped-num              USAGE FLOAT-LONG.\n\n       01  a-begin                 USAGE FLOAT-LONG VALUE 0.\n       01  a-end                   USAGE FLOAT-LONG VALUE 10.\n\n       01  b-begin                 USAGE FLOAT-LONG VALUE -1.\n       01  b-end                   USAGE FLOAT-LONG VALUE 0.\n\n       01  i-display               PIC --9.9.\n       01  mapped-display          PIC --9.9.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 0 BY 1 UNTIL i > 10\n               CALL \"map-range\" USING CONTENT a-begin, a-end, b-begin,\n                   b-end, i, REFERENCE mapped-num\n               COMPUTE i-display ROUNDED = i\n               COMPUTE mapped-display ROUNDED = mapped-num\n               DISPLAY FUNCTION TRIM(i-display) \" maps to \"\n                   FUNCTION TRIM(mapped-display)\n           END-PERFORM\n           .\n       END PROGRAM demo-map-range.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. map-range.\n\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  a-begin                 USAGE FLOAT-LONG.\n       01  a-end                   USAGE FLOAT-LONG.\n\n       01  b-begin                 USAGE FLOAT-LONG.\n       01  b-end                   USAGE FLOAT-LONG.\n\n       01  val-to-map              USAGE FLOAT-LONG.\n\n       01  ret                     USAGE FLOAT-LONG.\n\n       PROCEDURE DIVISION USING a-begin, a-end, b-begin, b-end,\n               val-to-map, ret.\n           COMPUTE ret = \n               b-begin + ((val-to-map - a-begin) * (b-end - b-begin)\n                   / (a-end - a-begin))\n           .\n       END PROGRAM map-range.\n", "target": "public class Range {\n\tpublic static void main(String[] args){\n\t\tfor(float s = 0;s <= 10; s++){\n\t\t\tSystem.out.println(s + \" in [0, 10] maps to \"+ \n\t\t\t\t\tmapRange(0, 10, -1, 0, s)+\" in [-1, 0].\");\n\t\t}\n\t}\n\t\n\tpublic static double mapRange(double a1, double a2, double b1, double b2, double s){\n\t\treturn b1 + ((s - a1)*(b2 - b1))/(a2 - a1);\n\t}\n}\n"}
{"id": 96454, "name": "Map range", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. demo-map-range.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i                       USAGE FLOAT-LONG.\n\n       01  mapped-num              USAGE FLOAT-LONG.\n\n       01  a-begin                 USAGE FLOAT-LONG VALUE 0.\n       01  a-end                   USAGE FLOAT-LONG VALUE 10.\n\n       01  b-begin                 USAGE FLOAT-LONG VALUE -1.\n       01  b-end                   USAGE FLOAT-LONG VALUE 0.\n\n       01  i-display               PIC --9.9.\n       01  mapped-display          PIC --9.9.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 0 BY 1 UNTIL i > 10\n               CALL \"map-range\" USING CONTENT a-begin, a-end, b-begin,\n                   b-end, i, REFERENCE mapped-num\n               COMPUTE i-display ROUNDED = i\n               COMPUTE mapped-display ROUNDED = mapped-num\n               DISPLAY FUNCTION TRIM(i-display) \" maps to \"\n                   FUNCTION TRIM(mapped-display)\n           END-PERFORM\n           .\n       END PROGRAM demo-map-range.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. map-range.\n\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  a-begin                 USAGE FLOAT-LONG.\n       01  a-end                   USAGE FLOAT-LONG.\n\n       01  b-begin                 USAGE FLOAT-LONG.\n       01  b-end                   USAGE FLOAT-LONG.\n\n       01  val-to-map              USAGE FLOAT-LONG.\n\n       01  ret                     USAGE FLOAT-LONG.\n\n       PROCEDURE DIVISION USING a-begin, a-end, b-begin, b-end,\n               val-to-map, ret.\n           COMPUTE ret = \n               b-begin + ((val-to-map - a-begin) * (b-end - b-begin)\n                   / (a-end - a-begin))\n           .\n       END PROGRAM map-range.\n", "target": "public class Range {\n\tpublic static void main(String[] args){\n\t\tfor(float s = 0;s <= 10; s++){\n\t\t\tSystem.out.println(s + \" in [0, 10] maps to \"+ \n\t\t\t\t\tmapRange(0, 10, -1, 0, s)+\" in [-1, 0].\");\n\t\t}\n\t}\n\t\n\tpublic static double mapRange(double a1, double a2, double b1, double b2, double s){\n\t\treturn b1 + ((s - a1)*(b2 - b1))/(a2 - a1);\n\t}\n}\n"}
{"id": 96455, "name": "Map range", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. demo-map-range.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i                       USAGE FLOAT-LONG.\n\n       01  mapped-num              USAGE FLOAT-LONG.\n\n       01  a-begin                 USAGE FLOAT-LONG VALUE 0.\n       01  a-end                   USAGE FLOAT-LONG VALUE 10.\n\n       01  b-begin                 USAGE FLOAT-LONG VALUE -1.\n       01  b-end                   USAGE FLOAT-LONG VALUE 0.\n\n       01  i-display               PIC --9.9.\n       01  mapped-display          PIC --9.9.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 0 BY 1 UNTIL i > 10\n               CALL \"map-range\" USING CONTENT a-begin, a-end, b-begin,\n                   b-end, i, REFERENCE mapped-num\n               COMPUTE i-display ROUNDED = i\n               COMPUTE mapped-display ROUNDED = mapped-num\n               DISPLAY FUNCTION TRIM(i-display) \" maps to \"\n                   FUNCTION TRIM(mapped-display)\n           END-PERFORM\n           .\n       END PROGRAM demo-map-range.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. map-range.\n\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  a-begin                 USAGE FLOAT-LONG.\n       01  a-end                   USAGE FLOAT-LONG.\n\n       01  b-begin                 USAGE FLOAT-LONG.\n       01  b-end                   USAGE FLOAT-LONG.\n\n       01  val-to-map              USAGE FLOAT-LONG.\n\n       01  ret                     USAGE FLOAT-LONG.\n\n       PROCEDURE DIVISION USING a-begin, a-end, b-begin, b-end,\n               val-to-map, ret.\n           COMPUTE ret = \n               b-begin + ((val-to-map - a-begin) * (b-end - b-begin)\n                   / (a-end - a-begin))\n           .\n       END PROGRAM map-range.\n", "target": ">>> def maprange( a, b, s):\n\t(a1, a2), (b1, b2) = a, b\n\treturn  b1 + ((s - a1) * (b2 - b1) / (a2 - a1))\n\n>>> for s in range(11):\n\tprint(\"%2g maps to %g\" % (s, maprange( (0, 10), (-1, 0), s)))\n\n\t\n 0 maps to -1\n 1 maps to -0.9\n 2 maps to -0.8\n 3 maps to -0.7\n 4 maps to -0.6\n 5 maps to -0.5\n 6 maps to -0.4\n 7 maps to -0.3\n 8 maps to -0.2\n 9 maps to -0.1\n10 maps to 0\n"}
{"id": 96456, "name": "Map range", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. demo-map-range.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i                       USAGE FLOAT-LONG.\n\n       01  mapped-num              USAGE FLOAT-LONG.\n\n       01  a-begin                 USAGE FLOAT-LONG VALUE 0.\n       01  a-end                   USAGE FLOAT-LONG VALUE 10.\n\n       01  b-begin                 USAGE FLOAT-LONG VALUE -1.\n       01  b-end                   USAGE FLOAT-LONG VALUE 0.\n\n       01  i-display               PIC --9.9.\n       01  mapped-display          PIC --9.9.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 0 BY 1 UNTIL i > 10\n               CALL \"map-range\" USING CONTENT a-begin, a-end, b-begin,\n                   b-end, i, REFERENCE mapped-num\n               COMPUTE i-display ROUNDED = i\n               COMPUTE mapped-display ROUNDED = mapped-num\n               DISPLAY FUNCTION TRIM(i-display) \" maps to \"\n                   FUNCTION TRIM(mapped-display)\n           END-PERFORM\n           .\n       END PROGRAM demo-map-range.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. map-range.\n\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  a-begin                 USAGE FLOAT-LONG.\n       01  a-end                   USAGE FLOAT-LONG.\n\n       01  b-begin                 USAGE FLOAT-LONG.\n       01  b-end                   USAGE FLOAT-LONG.\n\n       01  val-to-map              USAGE FLOAT-LONG.\n\n       01  ret                     USAGE FLOAT-LONG.\n\n       PROCEDURE DIVISION USING a-begin, a-end, b-begin, b-end,\n               val-to-map, ret.\n           COMPUTE ret = \n               b-begin + ((val-to-map - a-begin) * (b-end - b-begin)\n                   / (a-end - a-begin))\n           .\n       END PROGRAM map-range.\n", "target": ">>> def maprange( a, b, s):\n\t(a1, a2), (b1, b2) = a, b\n\treturn  b1 + ((s - a1) * (b2 - b1) / (a2 - a1))\n\n>>> for s in range(11):\n\tprint(\"%2g maps to %g\" % (s, maprange( (0, 10), (-1, 0), s)))\n\n\t\n 0 maps to -1\n 1 maps to -0.9\n 2 maps to -0.8\n 3 maps to -0.7\n 4 maps to -0.6\n 5 maps to -0.5\n 6 maps to -0.4\n 7 maps to -0.3\n 8 maps to -0.2\n 9 maps to -0.1\n10 maps to 0\n"}
{"id": 96985, "name": "HTTP", "source": "Translate COBOL to C#: COBOL  >>SOURCE FORMAT IS FIXED\n       identification division.\n       program-id. curl-rosetta.\n\n       environment division.\n       configuration section.\n       repository.\n           function read-url\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n\n       copy \"gccurlsym.cpy\".\n\n       01 web-page             pic x(16777216).\n       01 curl-status          usage binary-long.\n\n       01 cli                  pic x(7) external.\n          88 helping           values \"-h\", \"-help\", \"help\", spaces.\n          88 displaying        value \"display\".            \n          88 summarizing       value \"summary\". \n\n      \n       procedure division.\n       accept cli from command-line\n       if helping then\n           display \"./curl-rosetta [help|display|summary]\"\n           goback\n       end-if\n\n      \n      \n      \n      \n      \n      \n\n       move read-url(\"http://www.rosettacode.org\", web-page)\n         to curl-status\n\n       perform check\n       perform show\n\n       goback.\n      \n\n      \n      \n       check.\n       if curl-status not equal zero then\n           display\n               curl-status \" \"\n               CURLEMSG(curl-status) upon syserr\n       end-if\n       .\n\n      \n       show.\n       if summarizing then\n           display \"Length: \" stored-char-length(web-page)\n       end-if\n       if displaying then\n           display trim(web-page trailing) with no advancing\n       end-if\n       .\n\n       REPLACE ALSO ==:EXCEPTION-HANDLERS:== BY\n       ==\n      \n       soft-exception.\n         display space upon syserr\n         display \"--Exception Report-- \" upon syserr\n         display \"Time of exception:   \" current-date upon syserr\n         display \"Module:              \" module-id upon syserr\n         display \"Module-path:         \" module-path upon syserr\n         display \"Module-source:       \" module-source upon syserr\n         display \"Exception-file:      \" exception-file upon syserr\n         display \"Exception-status:    \" exception-status upon syserr\n         display \"Exception-location:  \" exception-location upon syserr\n         display \"Exception-statement: \" exception-statement upon syserr\n       .\n\n       hard-exception.\n           perform soft-exception\n           stop run returning 127 \n       .\n       ==.\n\n       end program curl-rosetta.\n      \n\n      \n      \n      \n      \n      \n      \n       identification division.\n       function-id. read-url.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n\n       copy \"gccurlsym.cpy\".\n\n       replace also ==:CALL-EXCEPTION:== by\n       ==\n           on exception\n               perform hard-exception\n       ==.\n\n       01 curl-handle          usage pointer.\n       01 callback-handle      usage procedure-pointer.\n       01 memory-block.\n          05 memory-address    usage pointer sync.\n          05 memory-size       usage binary-long sync.\n          05 running-total     usage binary-long sync.\n       01 curl-result          usage binary-long.\n\n       01 cli                  pic x(7) external.\n          88 helping           values \"-h\", \"-help\", \"help\", spaces.\n          88 displaying        value \"display\".            \n          88 summarizing       value \"summary\". \n\n       linkage section.\n       01 url                  pic x any length.\n       01 buffer               pic x any length.\n       01 curl-status          usage binary-long.\n\n      \n       procedure division using url buffer returning curl-status.\n       if displaying or summarizing then \n           display \"Read: \" url upon syserr\n       end-if\n\n      \n       call \"curl_global_init\" using by value CURL_GLOBAL_ALL\n           on exception\n               display\n                   \"need libcurl, link with -lcurl\" upon syserr\n               stop run returning 1\n       end-call\n\n      \n       call \"curl_easy_init\" returning curl-handle\n           :CALL-EXCEPTION:\n       end-call\n       if curl-handle equal NULL then\n           display \"no curl handle\" upon syserr\n           stop run returning 1\n       end-if\n\n      \n       call \"curl_easy_setopt\" using\n           by value curl-handle\n           by value CURLOPT_URL\n           by reference concatenate(trim(url trailing), x\"00\")\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       call \"curl_easy_setopt\" using\n           by value curl-handle\n           by value CURLOPT_FOLLOWLOCATION\n           by value 1\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       set callback-handle to address of entry \"curl-write-callback\"\n       call \"curl_easy_setopt\" using\n           by value curl-handle\n           by value CURLOPT_WRITEFUNCTION\n           by value callback-handle\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       set memory-address to address of buffer\n       move length(buffer) to memory-size\n       move 1 to running-total\n\n       call \"curl_easy_setopt\" using\n           by value curl-handle\n           by value CURLOPT_WRITEDATA\n           by value address of memory-block\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       call \"curl_easy_setopt\" using\n           by value curl-handle\n           by value CURLOPT_USERAGENT\n           by reference concatenate(\"libcurl-agent/1.0\", x\"00\")\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       call \"curl_easy_perform\" using\n           by value curl-handle\n           returning curl-result\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       move curl-result to curl-status\n\n      \n       call \"curl_easy_cleanup\" using\n           by value curl-handle\n           returning omitted\n           :CALL-EXCEPTION:\n       end-call\n\n       goback.\n\n       :EXCEPTION-HANDLERS:\n\n       end function read-url.\n      \n\n      \n      \n       identification division.\n       program-id. curl-write-callback.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 real-size            usage binary-long.\n\n      \n       01 memory-block         based.\n          05 memory-address    usage pointer sync.\n          05 memory-size       usage binary-long sync.\n          05 running-total     usage binary-long sync.\n\n       01 content-buffer       pic x(65536) based.\n       01 web-space            pic x(16777216) based.\n       01 left-over            usage binary-long.\n\n       linkage section.\n       01 contents             usage pointer.\n       01 element-size         usage binary-long.\n       01 element-count        usage binary-long.\n       01 memory-structure     usage pointer.\n\n      \n       procedure division\n           using\n              by value contents\n              by value element-size\n              by value element-count\n              by value memory-structure\n          returning real-size.\n\n       set address of memory-block to memory-structure\n       compute real-size = element-size * element-count end-compute\n\n      \n       compute\n           left-over = memory-size - running-total\n       end-compute\n       if left-over > 0 and < real-size then\n           move left-over to real-size\n       end-if\n\n      \n       if (left-over > 0) and (real-size > 1) then\n           set address of content-buffer to contents\n           set address of web-space to memory-address\n\n           move content-buffer(1:real-size)\n             to web-space(running-total:real-size)\n\n           add real-size to running-total\n       else\n           display \"curl buffer sizing problem\" upon syserr\n       end-if\n\n       goback.\n       end program curl-write-callback.\n", "target": "using System;\nusing System.Text;\nusing System.Net;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        WebClient wc = new WebClient();\n        string content = wc.DownloadString(\"http:\n        Console.WriteLine(content);\n    }\n}\n"}
{"id": 96987, "name": "HTTP", "source": "Translate COBOL to Java: COBOL  >>SOURCE FORMAT IS FIXED\n       identification division.\n       program-id. curl-rosetta.\n\n       environment division.\n       configuration section.\n       repository.\n           function read-url\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n\n       copy \"gccurlsym.cpy\".\n\n       01 web-page             pic x(16777216).\n       01 curl-status          usage binary-long.\n\n       01 cli                  pic x(7) external.\n          88 helping           values \"-h\", \"-help\", \"help\", spaces.\n          88 displaying        value \"display\".            \n          88 summarizing       value \"summary\". \n\n      \n       procedure division.\n       accept cli from command-line\n       if helping then\n           display \"./curl-rosetta [help|display|summary]\"\n           goback\n       end-if\n\n      \n      \n      \n      \n      \n      \n\n       move read-url(\"http://www.rosettacode.org\", web-page)\n         to curl-status\n\n       perform check\n       perform show\n\n       goback.\n      \n\n      \n      \n       check.\n       if curl-status not equal zero then\n           display\n               curl-status \" \"\n               CURLEMSG(curl-status) upon syserr\n       end-if\n       .\n\n      \n       show.\n       if summarizing then\n           display \"Length: \" stored-char-length(web-page)\n       end-if\n       if displaying then\n           display trim(web-page trailing) with no advancing\n       end-if\n       .\n\n       REPLACE ALSO ==:EXCEPTION-HANDLERS:== BY\n       ==\n      \n       soft-exception.\n         display space upon syserr\n         display \"--Exception Report-- \" upon syserr\n         display \"Time of exception:   \" current-date upon syserr\n         display \"Module:              \" module-id upon syserr\n         display \"Module-path:         \" module-path upon syserr\n         display \"Module-source:       \" module-source upon syserr\n         display \"Exception-file:      \" exception-file upon syserr\n         display \"Exception-status:    \" exception-status upon syserr\n         display \"Exception-location:  \" exception-location upon syserr\n         display \"Exception-statement: \" exception-statement upon syserr\n       .\n\n       hard-exception.\n           perform soft-exception\n           stop run returning 127 \n       .\n       ==.\n\n       end program curl-rosetta.\n      \n\n      \n      \n      \n      \n      \n      \n       identification division.\n       function-id. read-url.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n\n       copy \"gccurlsym.cpy\".\n\n       replace also ==:CALL-EXCEPTION:== by\n       ==\n           on exception\n               perform hard-exception\n       ==.\n\n       01 curl-handle          usage pointer.\n       01 callback-handle      usage procedure-pointer.\n       01 memory-block.\n          05 memory-address    usage pointer sync.\n          05 memory-size       usage binary-long sync.\n          05 running-total     usage binary-long sync.\n       01 curl-result          usage binary-long.\n\n       01 cli                  pic x(7) external.\n          88 helping           values \"-h\", \"-help\", \"help\", spaces.\n          88 displaying        value \"display\".            \n          88 summarizing       value \"summary\". \n\n       linkage section.\n       01 url                  pic x any length.\n       01 buffer               pic x any length.\n       01 curl-status          usage binary-long.\n\n      \n       procedure division using url buffer returning curl-status.\n       if displaying or summarizing then \n           display \"Read: \" url upon syserr\n       end-if\n\n      \n       call \"curl_global_init\" using by value CURL_GLOBAL_ALL\n           on exception\n               display\n                   \"need libcurl, link with -lcurl\" upon syserr\n               stop run returning 1\n       end-call\n\n      \n       call \"curl_easy_init\" returning curl-handle\n           :CALL-EXCEPTION:\n       end-call\n       if curl-handle equal NULL then\n           display \"no curl handle\" upon syserr\n           stop run returning 1\n       end-if\n\n      \n       call \"curl_easy_setopt\" using\n           by value curl-handle\n           by value CURLOPT_URL\n           by reference concatenate(trim(url trailing), x\"00\")\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       call \"curl_easy_setopt\" using\n           by value curl-handle\n           by value CURLOPT_FOLLOWLOCATION\n           by value 1\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       set callback-handle to address of entry \"curl-write-callback\"\n       call \"curl_easy_setopt\" using\n           by value curl-handle\n           by value CURLOPT_WRITEFUNCTION\n           by value callback-handle\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       set memory-address to address of buffer\n       move length(buffer) to memory-size\n       move 1 to running-total\n\n       call \"curl_easy_setopt\" using\n           by value curl-handle\n           by value CURLOPT_WRITEDATA\n           by value address of memory-block\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       call \"curl_easy_setopt\" using\n           by value curl-handle\n           by value CURLOPT_USERAGENT\n           by reference concatenate(\"libcurl-agent/1.0\", x\"00\")\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       call \"curl_easy_perform\" using\n           by value curl-handle\n           returning curl-result\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       move curl-result to curl-status\n\n      \n       call \"curl_easy_cleanup\" using\n           by value curl-handle\n           returning omitted\n           :CALL-EXCEPTION:\n       end-call\n\n       goback.\n\n       :EXCEPTION-HANDLERS:\n\n       end function read-url.\n      \n\n      \n      \n       identification division.\n       program-id. curl-write-callback.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 real-size            usage binary-long.\n\n      \n       01 memory-block         based.\n          05 memory-address    usage pointer sync.\n          05 memory-size       usage binary-long sync.\n          05 running-total     usage binary-long sync.\n\n       01 content-buffer       pic x(65536) based.\n       01 web-space            pic x(16777216) based.\n       01 left-over            usage binary-long.\n\n       linkage section.\n       01 contents             usage pointer.\n       01 element-size         usage binary-long.\n       01 element-count        usage binary-long.\n       01 memory-structure     usage pointer.\n\n      \n       procedure division\n           using\n              by value contents\n              by value element-size\n              by value element-count\n              by value memory-structure\n          returning real-size.\n\n       set address of memory-block to memory-structure\n       compute real-size = element-size * element-count end-compute\n\n      \n       compute\n           left-over = memory-size - running-total\n       end-compute\n       if left-over > 0 and < real-size then\n           move left-over to real-size\n       end-if\n\n      \n       if (left-over > 0) and (real-size > 1) then\n           set address of content-buffer to contents\n           set address of web-space to memory-address\n\n           move content-buffer(1:real-size)\n             to web-space(running-total:real-size)\n\n           add real-size to running-total\n       else\n           display \"curl buffer sizing problem\" upon syserr\n       end-if\n\n       goback.\n       end program curl-write-callback.\n", "target": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.Charset;\n\npublic class Main {\n    public static void main(String[] args) {\n        var request = HttpRequest.newBuilder(URI.create(\"https:\n                .GET()\n                .build();\n\n        HttpClient.newHttpClient()\n                .sendAsync(request, HttpResponse.BodyHandlers.ofString(Charset.defaultCharset()))\n                .thenApply(HttpResponse::body)\n                .thenAccept(System.out::println)\n                .join();\n    }\n}\n"}
{"id": 96988, "name": "HTTP", "source": "Translate COBOL to Python: COBOL  >>SOURCE FORMAT IS FIXED\n       identification division.\n       program-id. curl-rosetta.\n\n       environment division.\n       configuration section.\n       repository.\n           function read-url\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n\n       copy \"gccurlsym.cpy\".\n\n       01 web-page             pic x(16777216).\n       01 curl-status          usage binary-long.\n\n       01 cli                  pic x(7) external.\n          88 helping           values \"-h\", \"-help\", \"help\", spaces.\n          88 displaying        value \"display\".            \n          88 summarizing       value \"summary\". \n\n      \n       procedure division.\n       accept cli from command-line\n       if helping then\n           display \"./curl-rosetta [help|display|summary]\"\n           goback\n       end-if\n\n      \n      \n      \n      \n      \n      \n\n       move read-url(\"http://www.rosettacode.org\", web-page)\n         to curl-status\n\n       perform check\n       perform show\n\n       goback.\n      \n\n      \n      \n       check.\n       if curl-status not equal zero then\n           display\n               curl-status \" \"\n               CURLEMSG(curl-status) upon syserr\n       end-if\n       .\n\n      \n       show.\n       if summarizing then\n           display \"Length: \" stored-char-length(web-page)\n       end-if\n       if displaying then\n           display trim(web-page trailing) with no advancing\n       end-if\n       .\n\n       REPLACE ALSO ==:EXCEPTION-HANDLERS:== BY\n       ==\n      \n       soft-exception.\n         display space upon syserr\n         display \"--Exception Report-- \" upon syserr\n         display \"Time of exception:   \" current-date upon syserr\n         display \"Module:              \" module-id upon syserr\n         display \"Module-path:         \" module-path upon syserr\n         display \"Module-source:       \" module-source upon syserr\n         display \"Exception-file:      \" exception-file upon syserr\n         display \"Exception-status:    \" exception-status upon syserr\n         display \"Exception-location:  \" exception-location upon syserr\n         display \"Exception-statement: \" exception-statement upon syserr\n       .\n\n       hard-exception.\n           perform soft-exception\n           stop run returning 127 \n       .\n       ==.\n\n       end program curl-rosetta.\n      \n\n      \n      \n      \n      \n      \n      \n       identification division.\n       function-id. read-url.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n\n       copy \"gccurlsym.cpy\".\n\n       replace also ==:CALL-EXCEPTION:== by\n       ==\n           on exception\n               perform hard-exception\n       ==.\n\n       01 curl-handle          usage pointer.\n       01 callback-handle      usage procedure-pointer.\n       01 memory-block.\n          05 memory-address    usage pointer sync.\n          05 memory-size       usage binary-long sync.\n          05 running-total     usage binary-long sync.\n       01 curl-result          usage binary-long.\n\n       01 cli                  pic x(7) external.\n          88 helping           values \"-h\", \"-help\", \"help\", spaces.\n          88 displaying        value \"display\".            \n          88 summarizing       value \"summary\". \n\n       linkage section.\n       01 url                  pic x any length.\n       01 buffer               pic x any length.\n       01 curl-status          usage binary-long.\n\n      \n       procedure division using url buffer returning curl-status.\n       if displaying or summarizing then \n           display \"Read: \" url upon syserr\n       end-if\n\n      \n       call \"curl_global_init\" using by value CURL_GLOBAL_ALL\n           on exception\n               display\n                   \"need libcurl, link with -lcurl\" upon syserr\n               stop run returning 1\n       end-call\n\n      \n       call \"curl_easy_init\" returning curl-handle\n           :CALL-EXCEPTION:\n       end-call\n       if curl-handle equal NULL then\n           display \"no curl handle\" upon syserr\n           stop run returning 1\n       end-if\n\n      \n       call \"curl_easy_setopt\" using\n           by value curl-handle\n           by value CURLOPT_URL\n           by reference concatenate(trim(url trailing), x\"00\")\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       call \"curl_easy_setopt\" using\n           by value curl-handle\n           by value CURLOPT_FOLLOWLOCATION\n           by value 1\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       set callback-handle to address of entry \"curl-write-callback\"\n       call \"curl_easy_setopt\" using\n           by value curl-handle\n           by value CURLOPT_WRITEFUNCTION\n           by value callback-handle\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       set memory-address to address of buffer\n       move length(buffer) to memory-size\n       move 1 to running-total\n\n       call \"curl_easy_setopt\" using\n           by value curl-handle\n           by value CURLOPT_WRITEDATA\n           by value address of memory-block\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       call \"curl_easy_setopt\" using\n           by value curl-handle\n           by value CURLOPT_USERAGENT\n           by reference concatenate(\"libcurl-agent/1.0\", x\"00\")\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       call \"curl_easy_perform\" using\n           by value curl-handle\n           returning curl-result\n           :CALL-EXCEPTION:\n       end-call\n\n      \n       move curl-result to curl-status\n\n      \n       call \"curl_easy_cleanup\" using\n           by value curl-handle\n           returning omitted\n           :CALL-EXCEPTION:\n       end-call\n\n       goback.\n\n       :EXCEPTION-HANDLERS:\n\n       end function read-url.\n      \n\n      \n      \n       identification division.\n       program-id. curl-write-callback.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 real-size            usage binary-long.\n\n      \n       01 memory-block         based.\n          05 memory-address    usage pointer sync.\n          05 memory-size       usage binary-long sync.\n          05 running-total     usage binary-long sync.\n\n       01 content-buffer       pic x(65536) based.\n       01 web-space            pic x(16777216) based.\n       01 left-over            usage binary-long.\n\n       linkage section.\n       01 contents             usage pointer.\n       01 element-size         usage binary-long.\n       01 element-count        usage binary-long.\n       01 memory-structure     usage pointer.\n\n      \n       procedure division\n           using\n              by value contents\n              by value element-size\n              by value element-count\n              by value memory-structure\n          returning real-size.\n\n       set address of memory-block to memory-structure\n       compute real-size = element-size * element-count end-compute\n\n      \n       compute\n           left-over = memory-size - running-total\n       end-compute\n       if left-over > 0 and < real-size then\n           move left-over to real-size\n       end-if\n\n      \n       if (left-over > 0) and (real-size > 1) then\n           set address of content-buffer to contents\n           set address of web-space to memory-address\n\n           move content-buffer(1:real-size)\n             to web-space(running-total:real-size)\n\n           add real-size to running-total\n       else\n           display \"curl buffer sizing problem\" upon syserr\n       end-if\n\n       goback.\n       end program curl-write-callback.\n", "target": "import urllib.request\nprint(urllib.request.urlopen(\"http://rosettacode.org\").read())\n"}
{"id": 99215, "name": "Sleep", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Sleep-In-Seconds.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Seconds-To-Sleep       USAGE COMP-2.\n\n       PROCEDURE DIVISION.\n           ACCEPT Seconds-To-Sleep\n\n           DISPLAY \"Sleeping...\"\n\n           CALL \"C$SLEEP\" USING BY CONTENT Seconds-To-Sleep\n\n           DISPLAY \"Awake!\"\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Threading;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int sleep = Convert.ToInt32(Console.ReadLine());\n        Console.WriteLine(\"Sleeping...\");\n        Thread.Sleep(sleep); \n        Console.WriteLine(\"Awake!\");\n    }\n}\n"}
{"id": 99217, "name": "Sleep", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Sleep-In-Seconds.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Seconds-To-Sleep       USAGE COMP-2.\n\n       PROCEDURE DIVISION.\n           ACCEPT Seconds-To-Sleep\n\n           DISPLAY \"Sleeping...\"\n\n           CALL \"C$SLEEP\" USING BY CONTENT Seconds-To-Sleep\n\n           DISPLAY \"Awake!\"\n\n           GOBACK\n           .\n", "target": "import java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Sleep {\n    public static void main(final String[] args) throws InterruptedException {\n        try {\n            int ms = new Scanner(System.in).nextInt(); \n            System.out.println(\"Sleeping...\");\n            Thread.sleep(ms);\n            System.out.println(\"Awake!\");\n        } catch (InputMismatchException inputMismatchException) {\n            System.err.println(\"Exception: \" + inputMismatchException);\n        }\n    }\n}\n"}
{"id": 99218, "name": "Sleep", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Sleep-In-Seconds.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Seconds-To-Sleep       USAGE COMP-2.\n\n       PROCEDURE DIVISION.\n           ACCEPT Seconds-To-Sleep\n\n           DISPLAY \"Sleeping...\"\n\n           CALL \"C$SLEEP\" USING BY CONTENT Seconds-To-Sleep\n\n           DISPLAY \"Awake!\"\n\n           GOBACK\n           .\n", "target": "import time\n\nseconds = float(raw_input())\nprint \"Sleeping...\"\ntime.sleep(seconds) \nprint \"Awake!\"\n"}
{"id": 99870, "name": "Generate lower case ASCII alphabet", "source": "Translate COBOL to C#: identification division.\nprogram-id. lower-case-alphabet-program.\ndata division.\nworking-storage section.\n01  ascii-lower-case.\n    05 lower-case-alphabet pic a(26).\n    05 character-code      pic 999.\n    05 loop-counter        pic 99.\nprocedure division.\ncontrol-paragraph.\n    perform add-next-letter-paragraph varying loop-counter from 1 by 1\n    until loop-counter is greater than 26.\n    display lower-case-alphabet upon console.\n    stop run.\nadd-next-letter-paragraph.\n    add 97 to loop-counter giving character-code.\n    move function char(character-code) to lower-case-alphabet(loop-counter:1).\n", "target": "using System;\nusing System.Linq;\n\ninternal class Program\n{\n    private static void Main()\n    {\n        Console.WriteLine(String.Concat(Enumerable.Range('a', 26).Select(c => (char)c)));\n    }\n}\n"}
{"id": 99872, "name": "Generate lower case ASCII alphabet", "source": "Translate COBOL to Java: identification division.\nprogram-id. lower-case-alphabet-program.\ndata division.\nworking-storage section.\n01  ascii-lower-case.\n    05 lower-case-alphabet pic a(26).\n    05 character-code      pic 999.\n    05 loop-counter        pic 99.\nprocedure division.\ncontrol-paragraph.\n    perform add-next-letter-paragraph varying loop-counter from 1 by 1\n    until loop-counter is greater than 26.\n    display lower-case-alphabet upon console.\n    stop run.\nadd-next-letter-paragraph.\n    add 97 to loop-counter giving character-code.\n    move function char(character-code) to lower-case-alphabet(loop-counter:1).\n", "target": "public class LowerAscii {\n\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(26);\n        for (char ch = 'a'; ch <= 'z'; ch++)\n            sb.append(ch);\n        System.out.printf(\"lower ascii: %s, length: %s\", sb, sb.length());\n    }\n}\n"}
{"id": 99873, "name": "Generate lower case ASCII alphabet", "source": "Translate COBOL to Python: identification division.\nprogram-id. lower-case-alphabet-program.\ndata division.\nworking-storage section.\n01  ascii-lower-case.\n    05 lower-case-alphabet pic a(26).\n    05 character-code      pic 999.\n    05 loop-counter        pic 99.\nprocedure division.\ncontrol-paragraph.\n    perform add-next-letter-paragraph varying loop-counter from 1 by 1\n    until loop-counter is greater than 26.\n    display lower-case-alphabet upon console.\n    stop run.\nadd-next-letter-paragraph.\n    add 97 to loop-counter giving character-code.\n    move function char(character-code) to lower-case-alphabet(loop-counter:1).\n", "target": "\nfrom string import ascii_lowercase\n\n\nlower = [chr(i) for i in range(ord('a'), ord('z') + 1)]\n"}
{"id": 100354, "name": "Compare a list of strings", "source": "Translate COBOL to C#:        identification division.\n       program-id. CompareLists.\n\n       data division.\n       working-storage section.\n       78  MAX-ITEMS              value 3.\n       77  i                      pic 9(2).\n       01  the-list.\n           05 list-items occurs MAX-ITEMS.\n              10 list-item        pic x(3).\n       01  results.\n           05 filler              pic 9(1).\n              88 equal-strings    value 1 when set to false is 0.\n           05 filler              pic 9(1).\n              88 ordered-strings  value 1 when set to false is 0.\n\n       procedure division.\n       main.\n           move \"AA BB CC\" to the-list\n           perform check-list\n           move \"AA AA AA\" to the-list\n           perform check-list\n           move \"AA CC BB\" to the-list\n           perform check-list\n           move \"AA ACBBB CC\" to the-list\n           perform check-list\n           move \"AA\" to the-list\n           perform check-list\n           stop run\n           .\n       check-list.\n           display \"list:\"\n           set equal-strings to true\n           set ordered-strings to true\n           perform varying i from 1 by 1 until i > MAX-ITEMS\n              if list-item(i) <> spaces\n                 display function trim(list-item(i)), \" \" no advancing\n                 if i < MAX-ITEMS and list-item(i + 1) <> spaces\n                    if list-item(i + 1) <> list-item(i)\n                       set equal-strings to false            \n                    end-if\n                    if list-item(i + 1) <= list-item(i) \n                       set ordered-strings to false            \n                    end-if\n                 end-if\n              end-if\n           end-perform\n           display \" \"\n           if equal-strings\n              display \"... is lexically equal\"\n           else\n              display \"... is not lexically equal\"\n           end-if\n           if ordered-strings\n              display \"... is in strict ascending order\"\n           else\n              display \"... is not in strict ascending order\"\n           end-if\n           display \" \"\n           .\n", "target": "public static (bool lexicallyEqual, bool strictlyAscending) CompareAListOfStrings(List<string> strings) =>\n    strings.Count < 2 ? (true, true) :\n    (\n        strings.Distinct().Count() < 2,\n        Enumerable.Range(1, strings.Count - 1).All(i => string.Compare(strings[i-1], strings[i]) < 0)\n    );\n"}
{"id": 100355, "name": "Compare a list of strings", "source": "Translate COBOL to C#:        identification division.\n       program-id. CompareLists.\n\n       data division.\n       working-storage section.\n       78  MAX-ITEMS              value 3.\n       77  i                      pic 9(2).\n       01  the-list.\n           05 list-items occurs MAX-ITEMS.\n              10 list-item        pic x(3).\n       01  results.\n           05 filler              pic 9(1).\n              88 equal-strings    value 1 when set to false is 0.\n           05 filler              pic 9(1).\n              88 ordered-strings  value 1 when set to false is 0.\n\n       procedure division.\n       main.\n           move \"AA BB CC\" to the-list\n           perform check-list\n           move \"AA AA AA\" to the-list\n           perform check-list\n           move \"AA CC BB\" to the-list\n           perform check-list\n           move \"AA ACBBB CC\" to the-list\n           perform check-list\n           move \"AA\" to the-list\n           perform check-list\n           stop run\n           .\n       check-list.\n           display \"list:\"\n           set equal-strings to true\n           set ordered-strings to true\n           perform varying i from 1 by 1 until i > MAX-ITEMS\n              if list-item(i) <> spaces\n                 display function trim(list-item(i)), \" \" no advancing\n                 if i < MAX-ITEMS and list-item(i + 1) <> spaces\n                    if list-item(i + 1) <> list-item(i)\n                       set equal-strings to false            \n                    end-if\n                    if list-item(i + 1) <= list-item(i) \n                       set ordered-strings to false            \n                    end-if\n                 end-if\n              end-if\n           end-perform\n           display \" \"\n           if equal-strings\n              display \"... is lexically equal\"\n           else\n              display \"... is not lexically equal\"\n           end-if\n           if ordered-strings\n              display \"... is in strict ascending order\"\n           else\n              display \"... is not in strict ascending order\"\n           end-if\n           display \" \"\n           .\n", "target": "public static (bool lexicallyEqual, bool strictlyAscending) CompareAListOfStrings(List<string> strings) =>\n    strings.Count < 2 ? (true, true) :\n    (\n        strings.Distinct().Count() < 2,\n        Enumerable.Range(1, strings.Count - 1).All(i => string.Compare(strings[i-1], strings[i]) < 0)\n    );\n"}
{"id": 100358, "name": "Compare a list of strings", "source": "Translate COBOL to Java:        identification division.\n       program-id. CompareLists.\n\n       data division.\n       working-storage section.\n       78  MAX-ITEMS              value 3.\n       77  i                      pic 9(2).\n       01  the-list.\n           05 list-items occurs MAX-ITEMS.\n              10 list-item        pic x(3).\n       01  results.\n           05 filler              pic 9(1).\n              88 equal-strings    value 1 when set to false is 0.\n           05 filler              pic 9(1).\n              88 ordered-strings  value 1 when set to false is 0.\n\n       procedure division.\n       main.\n           move \"AA BB CC\" to the-list\n           perform check-list\n           move \"AA AA AA\" to the-list\n           perform check-list\n           move \"AA CC BB\" to the-list\n           perform check-list\n           move \"AA ACBBB CC\" to the-list\n           perform check-list\n           move \"AA\" to the-list\n           perform check-list\n           stop run\n           .\n       check-list.\n           display \"list:\"\n           set equal-strings to true\n           set ordered-strings to true\n           perform varying i from 1 by 1 until i > MAX-ITEMS\n              if list-item(i) <> spaces\n                 display function trim(list-item(i)), \" \" no advancing\n                 if i < MAX-ITEMS and list-item(i + 1) <> spaces\n                    if list-item(i + 1) <> list-item(i)\n                       set equal-strings to false            \n                    end-if\n                    if list-item(i + 1) <= list-item(i) \n                       set ordered-strings to false            \n                    end-if\n                 end-if\n              end-if\n           end-perform\n           display \" \"\n           if equal-strings\n              display \"... is lexically equal\"\n           else\n              display \"... is not lexically equal\"\n           end-if\n           if ordered-strings\n              display \"... is in strict ascending order\"\n           else\n              display \"... is not in strict ascending order\"\n           end-if\n           display \" \"\n           .\n", "target": "import java.util.Arrays;\n\npublic class CompareListOfStrings {\n\n    public static void main(String[] args) {\n        String[][] arr = {{\"AA\", \"AA\", \"AA\", \"AA\"}, {\"AA\", \"ACB\", \"BB\", \"CC\"}};\n        for (String[] a : arr) {\n            System.out.println(Arrays.toString(a));\n            System.out.println(Arrays.stream(a).distinct().count() < 2);\n            System.out.println(Arrays.equals(Arrays.stream(a).distinct().sorted().toArray(), a));\n        }\n    }\n}\n"}
{"id": 100359, "name": "Compare a list of strings", "source": "Translate COBOL to Java:        identification division.\n       program-id. CompareLists.\n\n       data division.\n       working-storage section.\n       78  MAX-ITEMS              value 3.\n       77  i                      pic 9(2).\n       01  the-list.\n           05 list-items occurs MAX-ITEMS.\n              10 list-item        pic x(3).\n       01  results.\n           05 filler              pic 9(1).\n              88 equal-strings    value 1 when set to false is 0.\n           05 filler              pic 9(1).\n              88 ordered-strings  value 1 when set to false is 0.\n\n       procedure division.\n       main.\n           move \"AA BB CC\" to the-list\n           perform check-list\n           move \"AA AA AA\" to the-list\n           perform check-list\n           move \"AA CC BB\" to the-list\n           perform check-list\n           move \"AA ACBBB CC\" to the-list\n           perform check-list\n           move \"AA\" to the-list\n           perform check-list\n           stop run\n           .\n       check-list.\n           display \"list:\"\n           set equal-strings to true\n           set ordered-strings to true\n           perform varying i from 1 by 1 until i > MAX-ITEMS\n              if list-item(i) <> spaces\n                 display function trim(list-item(i)), \" \" no advancing\n                 if i < MAX-ITEMS and list-item(i + 1) <> spaces\n                    if list-item(i + 1) <> list-item(i)\n                       set equal-strings to false            \n                    end-if\n                    if list-item(i + 1) <= list-item(i) \n                       set ordered-strings to false            \n                    end-if\n                 end-if\n              end-if\n           end-perform\n           display \" \"\n           if equal-strings\n              display \"... is lexically equal\"\n           else\n              display \"... is not lexically equal\"\n           end-if\n           if ordered-strings\n              display \"... is in strict ascending order\"\n           else\n              display \"... is not in strict ascending order\"\n           end-if\n           display \" \"\n           .\n", "target": "import java.util.Arrays;\n\npublic class CompareListOfStrings {\n\n    public static void main(String[] args) {\n        String[][] arr = {{\"AA\", \"AA\", \"AA\", \"AA\"}, {\"AA\", \"ACB\", \"BB\", \"CC\"}};\n        for (String[] a : arr) {\n            System.out.println(Arrays.toString(a));\n            System.out.println(Arrays.stream(a).distinct().count() < 2);\n            System.out.println(Arrays.equals(Arrays.stream(a).distinct().sorted().toArray(), a));\n        }\n    }\n}\n"}
{"id": 100360, "name": "Compare a list of strings", "source": "Translate COBOL to Python:        identification division.\n       program-id. CompareLists.\n\n       data division.\n       working-storage section.\n       78  MAX-ITEMS              value 3.\n       77  i                      pic 9(2).\n       01  the-list.\n           05 list-items occurs MAX-ITEMS.\n              10 list-item        pic x(3).\n       01  results.\n           05 filler              pic 9(1).\n              88 equal-strings    value 1 when set to false is 0.\n           05 filler              pic 9(1).\n              88 ordered-strings  value 1 when set to false is 0.\n\n       procedure division.\n       main.\n           move \"AA BB CC\" to the-list\n           perform check-list\n           move \"AA AA AA\" to the-list\n           perform check-list\n           move \"AA CC BB\" to the-list\n           perform check-list\n           move \"AA ACBBB CC\" to the-list\n           perform check-list\n           move \"AA\" to the-list\n           perform check-list\n           stop run\n           .\n       check-list.\n           display \"list:\"\n           set equal-strings to true\n           set ordered-strings to true\n           perform varying i from 1 by 1 until i > MAX-ITEMS\n              if list-item(i) <> spaces\n                 display function trim(list-item(i)), \" \" no advancing\n                 if i < MAX-ITEMS and list-item(i + 1) <> spaces\n                    if list-item(i + 1) <> list-item(i)\n                       set equal-strings to false            \n                    end-if\n                    if list-item(i + 1) <= list-item(i) \n                       set ordered-strings to false            \n                    end-if\n                 end-if\n              end-if\n           end-perform\n           display \" \"\n           if equal-strings\n              display \"... is lexically equal\"\n           else\n              display \"... is not lexically equal\"\n           end-if\n           if ordered-strings\n              display \"... is in strict ascending order\"\n           else\n              display \"... is not in strict ascending order\"\n           end-if\n           display \" \"\n           .\n", "target": "all(a == nexta for a, nexta in zip(strings, strings[1:])) \nall(a < nexta for a, nexta in zip(strings, strings[1:])) \n\nlen(set(strings)) == 1  \nsorted(strings, reverse=True) == strings  \n"}
{"id": 100361, "name": "Compare a list of strings", "source": "Translate COBOL to Python:        identification division.\n       program-id. CompareLists.\n\n       data division.\n       working-storage section.\n       78  MAX-ITEMS              value 3.\n       77  i                      pic 9(2).\n       01  the-list.\n           05 list-items occurs MAX-ITEMS.\n              10 list-item        pic x(3).\n       01  results.\n           05 filler              pic 9(1).\n              88 equal-strings    value 1 when set to false is 0.\n           05 filler              pic 9(1).\n              88 ordered-strings  value 1 when set to false is 0.\n\n       procedure division.\n       main.\n           move \"AA BB CC\" to the-list\n           perform check-list\n           move \"AA AA AA\" to the-list\n           perform check-list\n           move \"AA CC BB\" to the-list\n           perform check-list\n           move \"AA ACBBB CC\" to the-list\n           perform check-list\n           move \"AA\" to the-list\n           perform check-list\n           stop run\n           .\n       check-list.\n           display \"list:\"\n           set equal-strings to true\n           set ordered-strings to true\n           perform varying i from 1 by 1 until i > MAX-ITEMS\n              if list-item(i) <> spaces\n                 display function trim(list-item(i)), \" \" no advancing\n                 if i < MAX-ITEMS and list-item(i + 1) <> spaces\n                    if list-item(i + 1) <> list-item(i)\n                       set equal-strings to false            \n                    end-if\n                    if list-item(i + 1) <= list-item(i) \n                       set ordered-strings to false            \n                    end-if\n                 end-if\n              end-if\n           end-perform\n           display \" \"\n           if equal-strings\n              display \"... is lexically equal\"\n           else\n              display \"... is not lexically equal\"\n           end-if\n           if ordered-strings\n              display \"... is in strict ascending order\"\n           else\n              display \"... is not in strict ascending order\"\n           end-if\n           display \" \"\n           .\n", "target": "all(a == nexta for a, nexta in zip(strings, strings[1:])) \nall(a < nexta for a, nexta in zip(strings, strings[1:])) \n\nlen(set(strings)) == 1  \nsorted(strings, reverse=True) == strings  \n"}
{"id": 100830, "name": "Roman numerals_Decode", "source": "Translate COBOL to C#:       IDENTIFICATION DIVISION.\n      PROGRAM-ID.  UNROMAN.\n      DATA DIVISION.\n      WORKING-STORAGE SECTION.\n      01  filler.\n        03  i              pic 9(02) comp.\n        03  j              pic 9(02) comp.\n        03  k              pic 9(02) comp.\n        03  l              pic 9(02) comp.\n      01  inp-roman.\n        03  inp-rom-ch     pic x(01) occurs 20 times.\n      01  inp-roman-digits.\n        03  inp-rom-digit  pic 9(01) occurs 20 times.\n      01  ws-search-idx        pic 9(02) comp.\n      01  ws-tbl-table-def.\n        03  filler pic x(05) value '1000M'.\n        03  filler pic x(05) value '0500D'.\n        03  filler pic x(05) value '0100C'.\n        03  filler pic x(05) value '0050L'.\n        03  filler pic x(05) value '0010X'.\n        03  filler pic x(05) value '0005V'.\n        03  filler pic x(05) value '0001I'.\n      01  filler redefines ws-tbl-table-def.\n        03  ws-tbl-roman      occurs 07 times indexed by rx.\n          05  ws-tbl-rom-val  pic 9(04).\n          05  ws-tbl-rom-ch   pic x(01).\n      01  ws-number           pic s9(05) value 0.\n      01  ws-number-pic       pic zzzz9-.\n\n      PROCEDURE DIVISION.\n          accept inp-roman \n          perform\n          until inp-roman = ' '\n            move zeroes to inp-roman-digits\n            perform\n            varying i from 1 by +1 until inp-rom-ch (i) = ' '\n              set rx to 1\n              search ws-tbl-roman\n                at end\n                  move 0 to inp-rom-digit (i)\n                when ws-tbl-rom-ch (rx) = inp-rom-ch (i)\n                  set inp-rom-digit (i) to rx\n              end-search\n            end-perform\n            compute l = i - 1\n            move 0 to ws-number\n            perform\n            varying i from 1 by +1\n            until i > l or inp-rom-digit (i) = 0\n              compute j = inp-rom-digit (i)\n              compute k = inp-rom-digit (i + 1)\n              if ws-tbl-rom-val (k)\n              >  ws-tbl-rom-val (j)\n                compute ws-number\n                =      ws-number\n                -      ws-tbl-rom-val (j)\n              else\n                compute ws-number\n                =      ws-number\n                +      ws-tbl-rom-val (j)\n              end-if\n            end-perform\n            move ws-number to ws-number-pic\n            display '----------'\n            display 'roman=' inp-roman \n            display 'arabic=' ws-number-pic\n            if i < l or ws-number = 0                             \n              display 'invalid/incomplete roman numeral at pos 'i \n                      ' found ' inp-rom-ch (i)                    \n            end-if                                 \n            accept inp-roman\n          end-perform\n          stop run\n          .\n      END PROGRAM UNROMAN.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Roman\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            \n            Console.WriteLine(\"{0}: {1}\", \"MCMXC\", Decode(\"MCMXC\"));\n            Console.WriteLine(\"{0}: {1}\", \"MMVIII\", Decode(\"MMVIII\"));\n            Console.WriteLine(\"{0}: {1}\", \"MDCLXVI\", Decode(\"MDCLXVI\"));\n        }\n\n        \n        private static readonly Dictionary<char, int> RomanDictionary = new Dictionary<char, int>\n                                                                            {\n                                                                                {'I', 1},\n                                                                                {'V', 5},\n                                                                                {'X', 10},\n                                                                                {'L', 50},\n                                                                                {'C', 100},\n                                                                                {'D', 500},\n                                                                                {'M', 1000}\n                                                                            };\n\n        private static int Decode(string roman)\n        {\n            \n            roman = roman.ToUpper();\n\n            \n            int total = 0, minus = 0;\n\n            for (int i = 0; i < roman.Length; i++) \n            {\n                \n                int thisNumeral = RomanDictionary[roman[i]] - minus;\n\n                \n                if (i >= roman.Length - 1 ||\n                    thisNumeral + minus >= RomanDictionary[roman[i + 1]])\n                {\n                    total += thisNumeral;\n                    minus = 0;\n                }\n                else\n                {\n                    minus = thisNumeral;\n                }\n            }\n\n            return total; \n        }\n    }\n}\n"}
{"id": 100831, "name": "Roman numerals_Decode", "source": "Translate COBOL to C#:       IDENTIFICATION DIVISION.\n      PROGRAM-ID.  UNROMAN.\n      DATA DIVISION.\n      WORKING-STORAGE SECTION.\n      01  filler.\n        03  i              pic 9(02) comp.\n        03  j              pic 9(02) comp.\n        03  k              pic 9(02) comp.\n        03  l              pic 9(02) comp.\n      01  inp-roman.\n        03  inp-rom-ch     pic x(01) occurs 20 times.\n      01  inp-roman-digits.\n        03  inp-rom-digit  pic 9(01) occurs 20 times.\n      01  ws-search-idx        pic 9(02) comp.\n      01  ws-tbl-table-def.\n        03  filler pic x(05) value '1000M'.\n        03  filler pic x(05) value '0500D'.\n        03  filler pic x(05) value '0100C'.\n        03  filler pic x(05) value '0050L'.\n        03  filler pic x(05) value '0010X'.\n        03  filler pic x(05) value '0005V'.\n        03  filler pic x(05) value '0001I'.\n      01  filler redefines ws-tbl-table-def.\n        03  ws-tbl-roman      occurs 07 times indexed by rx.\n          05  ws-tbl-rom-val  pic 9(04).\n          05  ws-tbl-rom-ch   pic x(01).\n      01  ws-number           pic s9(05) value 0.\n      01  ws-number-pic       pic zzzz9-.\n\n      PROCEDURE DIVISION.\n          accept inp-roman \n          perform\n          until inp-roman = ' '\n            move zeroes to inp-roman-digits\n            perform\n            varying i from 1 by +1 until inp-rom-ch (i) = ' '\n              set rx to 1\n              search ws-tbl-roman\n                at end\n                  move 0 to inp-rom-digit (i)\n                when ws-tbl-rom-ch (rx) = inp-rom-ch (i)\n                  set inp-rom-digit (i) to rx\n              end-search\n            end-perform\n            compute l = i - 1\n            move 0 to ws-number\n            perform\n            varying i from 1 by +1\n            until i > l or inp-rom-digit (i) = 0\n              compute j = inp-rom-digit (i)\n              compute k = inp-rom-digit (i + 1)\n              if ws-tbl-rom-val (k)\n              >  ws-tbl-rom-val (j)\n                compute ws-number\n                =      ws-number\n                -      ws-tbl-rom-val (j)\n              else\n                compute ws-number\n                =      ws-number\n                +      ws-tbl-rom-val (j)\n              end-if\n            end-perform\n            move ws-number to ws-number-pic\n            display '----------'\n            display 'roman=' inp-roman \n            display 'arabic=' ws-number-pic\n            if i < l or ws-number = 0                             \n              display 'invalid/incomplete roman numeral at pos 'i \n                      ' found ' inp-rom-ch (i)                    \n            end-if                                 \n            accept inp-roman\n          end-perform\n          stop run\n          .\n      END PROGRAM UNROMAN.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Roman\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            \n            Console.WriteLine(\"{0}: {1}\", \"MCMXC\", Decode(\"MCMXC\"));\n            Console.WriteLine(\"{0}: {1}\", \"MMVIII\", Decode(\"MMVIII\"));\n            Console.WriteLine(\"{0}: {1}\", \"MDCLXVI\", Decode(\"MDCLXVI\"));\n        }\n\n        \n        private static readonly Dictionary<char, int> RomanDictionary = new Dictionary<char, int>\n                                                                            {\n                                                                                {'I', 1},\n                                                                                {'V', 5},\n                                                                                {'X', 10},\n                                                                                {'L', 50},\n                                                                                {'C', 100},\n                                                                                {'D', 500},\n                                                                                {'M', 1000}\n                                                                            };\n\n        private static int Decode(string roman)\n        {\n            \n            roman = roman.ToUpper();\n\n            \n            int total = 0, minus = 0;\n\n            for (int i = 0; i < roman.Length; i++) \n            {\n                \n                int thisNumeral = RomanDictionary[roman[i]] - minus;\n\n                \n                if (i >= roman.Length - 1 ||\n                    thisNumeral + minus >= RomanDictionary[roman[i + 1]])\n                {\n                    total += thisNumeral;\n                    minus = 0;\n                }\n                else\n                {\n                    minus = thisNumeral;\n                }\n            }\n\n            return total; \n        }\n    }\n}\n"}
{"id": 100834, "name": "Roman numerals_Decode", "source": "Translate COBOL to Java:       IDENTIFICATION DIVISION.\n      PROGRAM-ID.  UNROMAN.\n      DATA DIVISION.\n      WORKING-STORAGE SECTION.\n      01  filler.\n        03  i              pic 9(02) comp.\n        03  j              pic 9(02) comp.\n        03  k              pic 9(02) comp.\n        03  l              pic 9(02) comp.\n      01  inp-roman.\n        03  inp-rom-ch     pic x(01) occurs 20 times.\n      01  inp-roman-digits.\n        03  inp-rom-digit  pic 9(01) occurs 20 times.\n      01  ws-search-idx        pic 9(02) comp.\n      01  ws-tbl-table-def.\n        03  filler pic x(05) value '1000M'.\n        03  filler pic x(05) value '0500D'.\n        03  filler pic x(05) value '0100C'.\n        03  filler pic x(05) value '0050L'.\n        03  filler pic x(05) value '0010X'.\n        03  filler pic x(05) value '0005V'.\n        03  filler pic x(05) value '0001I'.\n      01  filler redefines ws-tbl-table-def.\n        03  ws-tbl-roman      occurs 07 times indexed by rx.\n          05  ws-tbl-rom-val  pic 9(04).\n          05  ws-tbl-rom-ch   pic x(01).\n      01  ws-number           pic s9(05) value 0.\n      01  ws-number-pic       pic zzzz9-.\n\n      PROCEDURE DIVISION.\n          accept inp-roman \n          perform\n          until inp-roman = ' '\n            move zeroes to inp-roman-digits\n            perform\n            varying i from 1 by +1 until inp-rom-ch (i) = ' '\n              set rx to 1\n              search ws-tbl-roman\n                at end\n                  move 0 to inp-rom-digit (i)\n                when ws-tbl-rom-ch (rx) = inp-rom-ch (i)\n                  set inp-rom-digit (i) to rx\n              end-search\n            end-perform\n            compute l = i - 1\n            move 0 to ws-number\n            perform\n            varying i from 1 by +1\n            until i > l or inp-rom-digit (i) = 0\n              compute j = inp-rom-digit (i)\n              compute k = inp-rom-digit (i + 1)\n              if ws-tbl-rom-val (k)\n              >  ws-tbl-rom-val (j)\n                compute ws-number\n                =      ws-number\n                -      ws-tbl-rom-val (j)\n              else\n                compute ws-number\n                =      ws-number\n                +      ws-tbl-rom-val (j)\n              end-if\n            end-perform\n            move ws-number to ws-number-pic\n            display '----------'\n            display 'roman=' inp-roman \n            display 'arabic=' ws-number-pic\n            if i < l or ws-number = 0                             \n              display 'invalid/incomplete roman numeral at pos 'i \n                      ' found ' inp-rom-ch (i)                    \n            end-if                                 \n            accept inp-roman\n          end-perform\n          stop run\n          .\n      END PROGRAM UNROMAN.\n", "target": "\ngrammar ParseRN ;\n\noptions {\n\tlanguage = Java;\n}\n@members {\nint rnValue;\nint ONE;\n}\n\nparseRN:\t({rnValue = 0;} rn NEWLINE {System.out.println($rn.text + \" = \" + rnValue);})*\n\t;\n\t\nrn\t:\t(Thousand {rnValue += 1000;})* hundreds? tens? units?;\n\nhundreds:\t{ONE = 0;} (h9 | h5) {if (ONE > 3) System.out.println (\"Too many hundreds\");};\nh9\t:\tHundred {ONE += 1;} (FiveHund {rnValue += 400;}| Thousand {rnValue += 900;}|{rnValue += 100;} (Hundred {rnValue += 100; ONE += 1;})*);\nh5\t:\tFiveHund {rnValue += 500;} (Hundred {rnValue += 100; ONE += 1;})*;\n\ntens\t:\t{ONE = 0;} (t9 | t5) {if (ONE > 3) System.out.println (\"Too many tens\");};\nt9\t:\tTen {ONE += 1;} (Fifty {rnValue += 40;}| Hundred {rnValue += 90;}|{rnValue += 10;} (Ten {rnValue += 10; ONE += 1;})*);\nt5\t:\tFifty {rnValue += 50;} (Ten {rnValue += 10; ONE += 1;})*;\n\t\nunits\t:\t{ONE = 0;} (u9 | u5) {if (ONE > 3) System.out.println (\"Too many ones\");};\nu9\t:\tOne {ONE += 1;} (Five {rnValue += 4;}| Ten {rnValue += 9;}|{rnValue += 1;} (One {rnValue += 1; ONE += 1;})*);\nu5\t:\tFive {rnValue += 5;} (One {rnValue += 1; ONE += 1;})*;\n\t\nOne\t:\t'I';\nFive\t:\t'V';\nTen\t:\t'X';\nFifty\t:\t'L';\nHundred:\t'C';\nFiveHund:\t'D';\nThousand:\t'M' ;\nNEWLINE:\t'\\r'? '\\n' ;\n"}
{"id": 100835, "name": "Roman numerals_Decode", "source": "Translate COBOL to Java:       IDENTIFICATION DIVISION.\n      PROGRAM-ID.  UNROMAN.\n      DATA DIVISION.\n      WORKING-STORAGE SECTION.\n      01  filler.\n        03  i              pic 9(02) comp.\n        03  j              pic 9(02) comp.\n        03  k              pic 9(02) comp.\n        03  l              pic 9(02) comp.\n      01  inp-roman.\n        03  inp-rom-ch     pic x(01) occurs 20 times.\n      01  inp-roman-digits.\n        03  inp-rom-digit  pic 9(01) occurs 20 times.\n      01  ws-search-idx        pic 9(02) comp.\n      01  ws-tbl-table-def.\n        03  filler pic x(05) value '1000M'.\n        03  filler pic x(05) value '0500D'.\n        03  filler pic x(05) value '0100C'.\n        03  filler pic x(05) value '0050L'.\n        03  filler pic x(05) value '0010X'.\n        03  filler pic x(05) value '0005V'.\n        03  filler pic x(05) value '0001I'.\n      01  filler redefines ws-tbl-table-def.\n        03  ws-tbl-roman      occurs 07 times indexed by rx.\n          05  ws-tbl-rom-val  pic 9(04).\n          05  ws-tbl-rom-ch   pic x(01).\n      01  ws-number           pic s9(05) value 0.\n      01  ws-number-pic       pic zzzz9-.\n\n      PROCEDURE DIVISION.\n          accept inp-roman \n          perform\n          until inp-roman = ' '\n            move zeroes to inp-roman-digits\n            perform\n            varying i from 1 by +1 until inp-rom-ch (i) = ' '\n              set rx to 1\n              search ws-tbl-roman\n                at end\n                  move 0 to inp-rom-digit (i)\n                when ws-tbl-rom-ch (rx) = inp-rom-ch (i)\n                  set inp-rom-digit (i) to rx\n              end-search\n            end-perform\n            compute l = i - 1\n            move 0 to ws-number\n            perform\n            varying i from 1 by +1\n            until i > l or inp-rom-digit (i) = 0\n              compute j = inp-rom-digit (i)\n              compute k = inp-rom-digit (i + 1)\n              if ws-tbl-rom-val (k)\n              >  ws-tbl-rom-val (j)\n                compute ws-number\n                =      ws-number\n                -      ws-tbl-rom-val (j)\n              else\n                compute ws-number\n                =      ws-number\n                +      ws-tbl-rom-val (j)\n              end-if\n            end-perform\n            move ws-number to ws-number-pic\n            display '----------'\n            display 'roman=' inp-roman \n            display 'arabic=' ws-number-pic\n            if i < l or ws-number = 0                             \n              display 'invalid/incomplete roman numeral at pos 'i \n                      ' found ' inp-rom-ch (i)                    \n            end-if                                 \n            accept inp-roman\n          end-perform\n          stop run\n          .\n      END PROGRAM UNROMAN.\n", "target": "\ngrammar ParseRN ;\n\noptions {\n\tlanguage = Java;\n}\n@members {\nint rnValue;\nint ONE;\n}\n\nparseRN:\t({rnValue = 0;} rn NEWLINE {System.out.println($rn.text + \" = \" + rnValue);})*\n\t;\n\t\nrn\t:\t(Thousand {rnValue += 1000;})* hundreds? tens? units?;\n\nhundreds:\t{ONE = 0;} (h9 | h5) {if (ONE > 3) System.out.println (\"Too many hundreds\");};\nh9\t:\tHundred {ONE += 1;} (FiveHund {rnValue += 400;}| Thousand {rnValue += 900;}|{rnValue += 100;} (Hundred {rnValue += 100; ONE += 1;})*);\nh5\t:\tFiveHund {rnValue += 500;} (Hundred {rnValue += 100; ONE += 1;})*;\n\ntens\t:\t{ONE = 0;} (t9 | t5) {if (ONE > 3) System.out.println (\"Too many tens\");};\nt9\t:\tTen {ONE += 1;} (Fifty {rnValue += 40;}| Hundred {rnValue += 90;}|{rnValue += 10;} (Ten {rnValue += 10; ONE += 1;})*);\nt5\t:\tFifty {rnValue += 50;} (Ten {rnValue += 10; ONE += 1;})*;\n\t\nunits\t:\t{ONE = 0;} (u9 | u5) {if (ONE > 3) System.out.println (\"Too many ones\");};\nu9\t:\tOne {ONE += 1;} (Five {rnValue += 4;}| Ten {rnValue += 9;}|{rnValue += 1;} (One {rnValue += 1; ONE += 1;})*);\nu5\t:\tFive {rnValue += 5;} (One {rnValue += 1; ONE += 1;})*;\n\t\nOne\t:\t'I';\nFive\t:\t'V';\nTen\t:\t'X';\nFifty\t:\t'L';\nHundred:\t'C';\nFiveHund:\t'D';\nThousand:\t'M' ;\nNEWLINE:\t'\\r'? '\\n' ;\n"}
{"id": 100836, "name": "Roman numerals_Decode", "source": "Translate COBOL to Python:       IDENTIFICATION DIVISION.\n      PROGRAM-ID.  UNROMAN.\n      DATA DIVISION.\n      WORKING-STORAGE SECTION.\n      01  filler.\n        03  i              pic 9(02) comp.\n        03  j              pic 9(02) comp.\n        03  k              pic 9(02) comp.\n        03  l              pic 9(02) comp.\n      01  inp-roman.\n        03  inp-rom-ch     pic x(01) occurs 20 times.\n      01  inp-roman-digits.\n        03  inp-rom-digit  pic 9(01) occurs 20 times.\n      01  ws-search-idx        pic 9(02) comp.\n      01  ws-tbl-table-def.\n        03  filler pic x(05) value '1000M'.\n        03  filler pic x(05) value '0500D'.\n        03  filler pic x(05) value '0100C'.\n        03  filler pic x(05) value '0050L'.\n        03  filler pic x(05) value '0010X'.\n        03  filler pic x(05) value '0005V'.\n        03  filler pic x(05) value '0001I'.\n      01  filler redefines ws-tbl-table-def.\n        03  ws-tbl-roman      occurs 07 times indexed by rx.\n          05  ws-tbl-rom-val  pic 9(04).\n          05  ws-tbl-rom-ch   pic x(01).\n      01  ws-number           pic s9(05) value 0.\n      01  ws-number-pic       pic zzzz9-.\n\n      PROCEDURE DIVISION.\n          accept inp-roman \n          perform\n          until inp-roman = ' '\n            move zeroes to inp-roman-digits\n            perform\n            varying i from 1 by +1 until inp-rom-ch (i) = ' '\n              set rx to 1\n              search ws-tbl-roman\n                at end\n                  move 0 to inp-rom-digit (i)\n                when ws-tbl-rom-ch (rx) = inp-rom-ch (i)\n                  set inp-rom-digit (i) to rx\n              end-search\n            end-perform\n            compute l = i - 1\n            move 0 to ws-number\n            perform\n            varying i from 1 by +1\n            until i > l or inp-rom-digit (i) = 0\n              compute j = inp-rom-digit (i)\n              compute k = inp-rom-digit (i + 1)\n              if ws-tbl-rom-val (k)\n              >  ws-tbl-rom-val (j)\n                compute ws-number\n                =      ws-number\n                -      ws-tbl-rom-val (j)\n              else\n                compute ws-number\n                =      ws-number\n                +      ws-tbl-rom-val (j)\n              end-if\n            end-perform\n            move ws-number to ws-number-pic\n            display '----------'\n            display 'roman=' inp-roman \n            display 'arabic=' ws-number-pic\n            if i < l or ws-number = 0                             \n              display 'invalid/incomplete roman numeral at pos 'i \n                      ' found ' inp-rom-ch (i)                    \n            end-if                                 \n            accept inp-roman\n          end-perform\n          stop run\n          .\n      END PROGRAM UNROMAN.\n", "target": "_rdecode = dict(zip('MDCLXVI', (1000, 500, 100, 50, 10, 5, 1)))\n\ndef decode( roman ):\n    result = 0\n    for r, r1 in zip(roman, roman[1:]):\n        rd, rd1 = _rdecode[r], _rdecode[r1]\n        result += -rd if rd < rd1 else rd\n    return result + _rdecode[roman[-1]]\n\nif __name__ == '__main__':\n    for r in 'MCMXC MMVIII MDCLXVI'.split():\n        print( r, decode(r) )\n"}
{"id": 100837, "name": "Roman numerals_Decode", "source": "Translate COBOL to Python:       IDENTIFICATION DIVISION.\n      PROGRAM-ID.  UNROMAN.\n      DATA DIVISION.\n      WORKING-STORAGE SECTION.\n      01  filler.\n        03  i              pic 9(02) comp.\n        03  j              pic 9(02) comp.\n        03  k              pic 9(02) comp.\n        03  l              pic 9(02) comp.\n      01  inp-roman.\n        03  inp-rom-ch     pic x(01) occurs 20 times.\n      01  inp-roman-digits.\n        03  inp-rom-digit  pic 9(01) occurs 20 times.\n      01  ws-search-idx        pic 9(02) comp.\n      01  ws-tbl-table-def.\n        03  filler pic x(05) value '1000M'.\n        03  filler pic x(05) value '0500D'.\n        03  filler pic x(05) value '0100C'.\n        03  filler pic x(05) value '0050L'.\n        03  filler pic x(05) value '0010X'.\n        03  filler pic x(05) value '0005V'.\n        03  filler pic x(05) value '0001I'.\n      01  filler redefines ws-tbl-table-def.\n        03  ws-tbl-roman      occurs 07 times indexed by rx.\n          05  ws-tbl-rom-val  pic 9(04).\n          05  ws-tbl-rom-ch   pic x(01).\n      01  ws-number           pic s9(05) value 0.\n      01  ws-number-pic       pic zzzz9-.\n\n      PROCEDURE DIVISION.\n          accept inp-roman \n          perform\n          until inp-roman = ' '\n            move zeroes to inp-roman-digits\n            perform\n            varying i from 1 by +1 until inp-rom-ch (i) = ' '\n              set rx to 1\n              search ws-tbl-roman\n                at end\n                  move 0 to inp-rom-digit (i)\n                when ws-tbl-rom-ch (rx) = inp-rom-ch (i)\n                  set inp-rom-digit (i) to rx\n              end-search\n            end-perform\n            compute l = i - 1\n            move 0 to ws-number\n            perform\n            varying i from 1 by +1\n            until i > l or inp-rom-digit (i) = 0\n              compute j = inp-rom-digit (i)\n              compute k = inp-rom-digit (i + 1)\n              if ws-tbl-rom-val (k)\n              >  ws-tbl-rom-val (j)\n                compute ws-number\n                =      ws-number\n                -      ws-tbl-rom-val (j)\n              else\n                compute ws-number\n                =      ws-number\n                +      ws-tbl-rom-val (j)\n              end-if\n            end-perform\n            move ws-number to ws-number-pic\n            display '----------'\n            display 'roman=' inp-roman \n            display 'arabic=' ws-number-pic\n            if i < l or ws-number = 0                             \n              display 'invalid/incomplete roman numeral at pos 'i \n                      ' found ' inp-rom-ch (i)                    \n            end-if                                 \n            accept inp-roman\n          end-perform\n          stop run\n          .\n      END PROGRAM UNROMAN.\n", "target": "_rdecode = dict(zip('MDCLXVI', (1000, 500, 100, 50, 10, 5, 1)))\n\ndef decode( roman ):\n    result = 0\n    for r, r1 in zip(roman, roman[1:]):\n        rd, rd1 = _rdecode[r], _rdecode[r1]\n        result += -rd if rd < rd1 else rd\n    return result + _rdecode[roman[-1]]\n\nif __name__ == '__main__':\n    for r in 'MCMXC MMVIII MDCLXVI'.split():\n        print( r, decode(r) )\n"}
{"id": 101157, "name": "Euler method", "source": "Translate COBOL to C#:        DELEGATE-ID func.\n       PROCEDURE DIVISION USING VALUE t AS FLOAT-LONG\n           RETURNING ret AS FLOAT-LONG.\n       END DELEGATE.     \n     \n       CLASS-ID. MainClass.\n       \n       78  T0                     VALUE 100.0.\n       78  TR                     VALUE 20.0.\n       78  k                      VALUE 0.07.\n       \n       01  delta-t                INITIALIZE ONLY STATIC\n                                  FLOAT-LONG OCCURS 3 VALUES 2.0, 5.0, 10.0.\n       \n       78  n                      VALUE 100.\n       \n       METHOD-ID NewtonCooling STATIC.\n       PROCEDURE DIVISION USING VALUE t AS FLOAT-LONG\n               RETURNING ret AS FLOAT-LONG.\n           COMPUTE ret = - k * (t - TR)\n       END METHOD.\n       \n       METHOD-ID Main STATIC.\n           DECLARE f AS TYPE func\n           SET f TO METHOD self::NewtonCooling\n           \n           DECLARE delta-t-len AS BINARY-LONG\n           MOVE delta-t::Length TO delta-t-len\n           PERFORM VARYING i AS BINARY-LONG FROM 1 BY 1\n                   UNTIL i > delta-t-len\n               DECLARE elt AS FLOAT-LONG = delta-t (i)\n               INVOKE TYPE Console::WriteLine(\"delta-t = {0:F4}\", elt)\n               INVOKE self::Euler(f, T0, n, elt)\n           END-PERFORM\n       END METHOD.\n       \n       METHOD-ID Euler STATIC.\n       PROCEDURE DIVISION USING VALUE f AS TYPE func, y AS FLOAT-LONG,\n               n AS BINARY-LONG, h AS FLOAT-LONG.\n           PERFORM VARYING x AS BINARY-LONG FROM 0 BY h UNTIL x >= n\n               INVOKE TYPE Console::WriteLine(\"x = {0:F4}, y = {1:F4}\", x, y)\n               COMPUTE y = y + h * RUN f(y)\n           END-PERFORM\n       END METHOD.\n       END CLASS.\n", "target": "using System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tconst float T0 = 100f;\n\t\tconst float TR = 20f;\n\t\tconst float k = 0.07f;\n\t\treadonly static float[] delta_t = {2.0f,5.0f,10.0f};\n\t\tconst int n = 100;\n\t\t\n\t\tpublic delegate float func(float t);\n\t\tstatic float NewtonCooling(float t)\n\t\t{\n\t\t\treturn -k * (t-TR);\t\t\t\n\t\t}\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfunc f = new func(NewtonCooling); \n\t\t\tfor(int i=0; i<delta_t.Length; i++)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"delta_t = \" + delta_t[i]);\n\t\t\t\tEuler(f,T0,n,delta_t[i]);\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tpublic static void Euler(func f, float y, int n, float h)\n\t\t{\n\t\t\tfor(float x=0; x<=n; x+=h)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"\\t\" + x + \"\\t\" + y);\n\t\t\t\ty += h * f(y);\t\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 101159, "name": "Euler method", "source": "Translate COBOL to Java:        DELEGATE-ID func.\n       PROCEDURE DIVISION USING VALUE t AS FLOAT-LONG\n           RETURNING ret AS FLOAT-LONG.\n       END DELEGATE.     \n     \n       CLASS-ID. MainClass.\n       \n       78  T0                     VALUE 100.0.\n       78  TR                     VALUE 20.0.\n       78  k                      VALUE 0.07.\n       \n       01  delta-t                INITIALIZE ONLY STATIC\n                                  FLOAT-LONG OCCURS 3 VALUES 2.0, 5.0, 10.0.\n       \n       78  n                      VALUE 100.\n       \n       METHOD-ID NewtonCooling STATIC.\n       PROCEDURE DIVISION USING VALUE t AS FLOAT-LONG\n               RETURNING ret AS FLOAT-LONG.\n           COMPUTE ret = - k * (t - TR)\n       END METHOD.\n       \n       METHOD-ID Main STATIC.\n           DECLARE f AS TYPE func\n           SET f TO METHOD self::NewtonCooling\n           \n           DECLARE delta-t-len AS BINARY-LONG\n           MOVE delta-t::Length TO delta-t-len\n           PERFORM VARYING i AS BINARY-LONG FROM 1 BY 1\n                   UNTIL i > delta-t-len\n               DECLARE elt AS FLOAT-LONG = delta-t (i)\n               INVOKE TYPE Console::WriteLine(\"delta-t = {0:F4}\", elt)\n               INVOKE self::Euler(f, T0, n, elt)\n           END-PERFORM\n       END METHOD.\n       \n       METHOD-ID Euler STATIC.\n       PROCEDURE DIVISION USING VALUE f AS TYPE func, y AS FLOAT-LONG,\n               n AS BINARY-LONG, h AS FLOAT-LONG.\n           PERFORM VARYING x AS BINARY-LONG FROM 0 BY h UNTIL x >= n\n               INVOKE TYPE Console::WriteLine(\"x = {0:F4}, y = {1:F4}\", x, y)\n               COMPUTE y = y + h * RUN f(y)\n           END-PERFORM\n       END METHOD.\n       END CLASS.\n", "target": "public class Euler {\n  private static void euler (Callable f, double y0, int a, int b, int h) {\n    int t = a;\n    double y = y0;\n    while (t < b) {\n      System.out.println (\"\" + t + \" \" + y);\n      t += h;\n      y += h * f.compute (t, y);\n    }\n    System.out.println (\"DONE\");\n  }\n\n  public static void main (String[] args) {\n    Callable cooling = new Cooling ();\n    int[] steps = {2, 5, 10};\n    for (int stepSize : steps) {\n      System.out.println (\"Step size: \" + stepSize);\n      euler (cooling, 100.0, 0, 100, stepSize);\n    }\n  }\n}\n\n\ninterface Callable {\n  public double compute (int time, double t);\n}\n\n\nclass Cooling implements Callable {\n  public double compute (int time, double t) {\n    return -0.07 * (t - 20);\n  }\n}\n"}
{"id": 101160, "name": "Euler method", "source": "Translate COBOL to Python:        DELEGATE-ID func.\n       PROCEDURE DIVISION USING VALUE t AS FLOAT-LONG\n           RETURNING ret AS FLOAT-LONG.\n       END DELEGATE.     \n     \n       CLASS-ID. MainClass.\n       \n       78  T0                     VALUE 100.0.\n       78  TR                     VALUE 20.0.\n       78  k                      VALUE 0.07.\n       \n       01  delta-t                INITIALIZE ONLY STATIC\n                                  FLOAT-LONG OCCURS 3 VALUES 2.0, 5.0, 10.0.\n       \n       78  n                      VALUE 100.\n       \n       METHOD-ID NewtonCooling STATIC.\n       PROCEDURE DIVISION USING VALUE t AS FLOAT-LONG\n               RETURNING ret AS FLOAT-LONG.\n           COMPUTE ret = - k * (t - TR)\n       END METHOD.\n       \n       METHOD-ID Main STATIC.\n           DECLARE f AS TYPE func\n           SET f TO METHOD self::NewtonCooling\n           \n           DECLARE delta-t-len AS BINARY-LONG\n           MOVE delta-t::Length TO delta-t-len\n           PERFORM VARYING i AS BINARY-LONG FROM 1 BY 1\n                   UNTIL i > delta-t-len\n               DECLARE elt AS FLOAT-LONG = delta-t (i)\n               INVOKE TYPE Console::WriteLine(\"delta-t = {0:F4}\", elt)\n               INVOKE self::Euler(f, T0, n, elt)\n           END-PERFORM\n       END METHOD.\n       \n       METHOD-ID Euler STATIC.\n       PROCEDURE DIVISION USING VALUE f AS TYPE func, y AS FLOAT-LONG,\n               n AS BINARY-LONG, h AS FLOAT-LONG.\n           PERFORM VARYING x AS BINARY-LONG FROM 0 BY h UNTIL x >= n\n               INVOKE TYPE Console::WriteLine(\"x = {0:F4}, y = {1:F4}\", x, y)\n               COMPUTE y = y + h * RUN f(y)\n           END-PERFORM\n       END METHOD.\n       END CLASS.\n", "target": "def euler(f,y0,a,b,h):\n\tt,y = a,y0\n\twhile t <= b:\n\t\tprint \"%6.3f %6.3f\" % (t,y)\n\t\tt += h\n\t\ty += h * f(t,y)\n\ndef newtoncooling(time, temp):\n\treturn -0.07 * (temp - 20)\n\neuler(newtoncooling,100,0,100,10)\n"}
{"id": 102362, "name": "Dragon curve", "source": "Translate COBOL to C#:          >>SOURCE FORMAT FREE\n\nidentification division.\nprogram-id. dragon.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n01  segment-length pic 9 value 2.\n01  mark pic x value '.'.\n01  segment-count pic 9999 value 513.\n\n01  segment pic 9999.\n01  point pic 9999 value 1.\n01  point-max pic 9999.\n01  point-lim pic 9999 value 8192.\n01  dragon-curve.\n    03  filler occurs 8192.\n        05  ydragon pic s9999.\n        05  xdragon pic s9999.\n\n01  x pic s9999 value 1.\n01  y pic S9999 value 1.\n\n01  xdelta pic s9 value 1. \n01  ydelta pic s9 value 0.\n\n01  x-max pic s9999 value -9999.\n01  x-min pic s9999 value 9999.\n01  y-max pic s9999 value -9999.\n01  y-min pic s9999 value 9999.\n\n01  n pic 9999.\n01  r pic 9.\n\n01  xupper pic s9999.\n01  yupper pic s9999.\n\n01  window-line-number pic 99.\n01  window-width pic 99 value 64.\n01  window-height pic 99 value 22.\n01  window.\n    03  window-line occurs 22.\n        05  window-point occurs 64 pic x.\n\n01  direction pic x.\n\nprocedure division.\nstart-dragon.\n\n    if segment-count * segment-length > point-lim\n        \n        compute segment-count = point-lim / segment-length\n    end-if\n\n    perform varying segment from 1 by 1\n    until segment > segment-count\n\n        \n        \n        \n        \n\n        \n        divide 2 into segment giving n remainder r\n        perform until r <> 0\n            divide 2 into n giving n remainder r\n        end-perform\n        divide 2 into n giving n remainder r\n\n        \n        evaluate r also xdelta also ydelta\n        when 0 also 1 also 0  \n        when 1 also -1 also 0 \n            \n            move 0 to xdelta\n            move 1 to ydelta\n        when 1 also 1 also 0  \n        when 0 also -1 also 0 \n            \n            move 0 to xdelta\n            move -1 to ydelta\n        when 0 also 0 also 1  \n        when 1 also 0 also -1 \n            \n            move 0 to ydelta\n            move -1 to xdelta\n        when 1 also 0 also 1  \n        when 0 also 0 also -1 \n            \n            move 0 to ydelta\n            move 1 to xdelta\n        end-evaluate\n\n        \n        perform segment-length times\n            add xdelta to x\n            add ydelta to y\n\n            move x to xdragon(point)\n            move y to ydragon(point)\n\n            add 1 to point\n        end-perform\n\n        \n        compute x-max = max(x, x-max)\n        compute x-min = min(x, x-min)\n        compute y-max = max(y, y-max)\n        compute y-min = min(y, y-min)\n        move point to point-max\n\n    end-perform\n\n    \n    \n    \n    \n    \n\n    move 1 to yupper xupper\n\n    perform with test after\n    until direction <> 'h' and 'j' and 'k' and 'l'\n\n        \n        \n        \n\n        \n        evaluate true\n        when direction = 'h' \n        and xupper > x-min + window-width\n           subtract 1 from xupper\n        when direction = 'j' \n        and yupper < y-max - window-height\n           add 1 to yupper\n        when direction = 'k' \n        and yupper > y-min + window-height\n           subtract 1 from yupper\n        when direction = 'l' \n        and xupper < x-max - window-width\n            add 1 to xupper\n        end-evaluate\n\n        \n        move spaces to window\n        perform varying point from 1 by 1\n        until point > point-max\n            if ydragon(point) >= yupper and < yupper + window-height\n            and xdragon(point) >= xupper and < xupper + window-width\n                \n                compute y = ydragon(point) - yupper + 1\n                compute x =  xdragon(point) - xupper + 1\n                move mark to window-point(y, x)\n            end-if\n         end-perform\n\n         \n         perform varying window-line-number from 1 by 1\n         until window-line-number > window-height\n             display window-line(window-line-number)\n         end-perform\n\n         \n         display 'hjkl?' with no advancing\n         accept direction\n    end-perform\n\n    stop run\n    .\nend program dragon.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Windows.Forms;\n\npublic class DragonCurve : Form\n{\n    private List<int> turns;\n    private double startingAngle, side;\n\n    public DragonCurve(int iter)\n    {\n        Size = new Size(800, 600);\n        StartPosition = FormStartPosition.CenterScreen;\n        DoubleBuffered = true;\n        BackColor = Color.White;\n\n        startingAngle = -iter * (Math.PI / 4);\n        side = 400 / Math.Pow(2, iter / 2.0);\n\n        turns = getSequence(iter);\n    }\n\n    private List<int> getSequence(int iter)\n    {\n        var turnSequence = new List<int>();\n        for (int i = 0; i < iter; i++)\n        {\n            var copy = new List<int>(turnSequence);\n            copy.Reverse();\n            turnSequence.Add(1);\n            foreach (int turn in copy)\n            {\n                turnSequence.Add(-turn);\n            }\n        }\n        return turnSequence;\n    }\n\n    protected override void OnPaint(PaintEventArgs e)\n    {\n        base.OnPaint(e);\n        e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;\n\n        double angle = startingAngle;\n        int x1 = 230, y1 = 350;\n        int x2 = x1 + (int)(Math.Cos(angle) * side);\n        int y2 = y1 + (int)(Math.Sin(angle) * side);\n        e.Graphics.DrawLine(Pens.Black, x1, y1, x2, y2);\n        x1 = x2;\n        y1 = y2;\n        foreach (int turn in turns)\n        {\n            angle += turn * (Math.PI / 2);\n            x2 = x1 + (int)(Math.Cos(angle) * side);\n            y2 = y1 + (int)(Math.Sin(angle) * side);\n            e.Graphics.DrawLine(Pens.Black, x1, y1, x2, y2);\n            x1 = x2;\n            y1 = y2;\n        }\n    }\n\n    [STAThread]\n    static void Main()\n    {\n        Application.Run(new DragonCurve(14));\n    }\n}\n"}
{"id": 102364, "name": "Dragon curve", "source": "Translate COBOL to Java:          >>SOURCE FORMAT FREE\n\nidentification division.\nprogram-id. dragon.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n01  segment-length pic 9 value 2.\n01  mark pic x value '.'.\n01  segment-count pic 9999 value 513.\n\n01  segment pic 9999.\n01  point pic 9999 value 1.\n01  point-max pic 9999.\n01  point-lim pic 9999 value 8192.\n01  dragon-curve.\n    03  filler occurs 8192.\n        05  ydragon pic s9999.\n        05  xdragon pic s9999.\n\n01  x pic s9999 value 1.\n01  y pic S9999 value 1.\n\n01  xdelta pic s9 value 1. \n01  ydelta pic s9 value 0.\n\n01  x-max pic s9999 value -9999.\n01  x-min pic s9999 value 9999.\n01  y-max pic s9999 value -9999.\n01  y-min pic s9999 value 9999.\n\n01  n pic 9999.\n01  r pic 9.\n\n01  xupper pic s9999.\n01  yupper pic s9999.\n\n01  window-line-number pic 99.\n01  window-width pic 99 value 64.\n01  window-height pic 99 value 22.\n01  window.\n    03  window-line occurs 22.\n        05  window-point occurs 64 pic x.\n\n01  direction pic x.\n\nprocedure division.\nstart-dragon.\n\n    if segment-count * segment-length > point-lim\n        \n        compute segment-count = point-lim / segment-length\n    end-if\n\n    perform varying segment from 1 by 1\n    until segment > segment-count\n\n        \n        \n        \n        \n\n        \n        divide 2 into segment giving n remainder r\n        perform until r <> 0\n            divide 2 into n giving n remainder r\n        end-perform\n        divide 2 into n giving n remainder r\n\n        \n        evaluate r also xdelta also ydelta\n        when 0 also 1 also 0  \n        when 1 also -1 also 0 \n            \n            move 0 to xdelta\n            move 1 to ydelta\n        when 1 also 1 also 0  \n        when 0 also -1 also 0 \n            \n            move 0 to xdelta\n            move -1 to ydelta\n        when 0 also 0 also 1  \n        when 1 also 0 also -1 \n            \n            move 0 to ydelta\n            move -1 to xdelta\n        when 1 also 0 also 1  \n        when 0 also 0 also -1 \n            \n            move 0 to ydelta\n            move 1 to xdelta\n        end-evaluate\n\n        \n        perform segment-length times\n            add xdelta to x\n            add ydelta to y\n\n            move x to xdragon(point)\n            move y to ydragon(point)\n\n            add 1 to point\n        end-perform\n\n        \n        compute x-max = max(x, x-max)\n        compute x-min = min(x, x-min)\n        compute y-max = max(y, y-max)\n        compute y-min = min(y, y-min)\n        move point to point-max\n\n    end-perform\n\n    \n    \n    \n    \n    \n\n    move 1 to yupper xupper\n\n    perform with test after\n    until direction <> 'h' and 'j' and 'k' and 'l'\n\n        \n        \n        \n\n        \n        evaluate true\n        when direction = 'h' \n        and xupper > x-min + window-width\n           subtract 1 from xupper\n        when direction = 'j' \n        and yupper < y-max - window-height\n           add 1 to yupper\n        when direction = 'k' \n        and yupper > y-min + window-height\n           subtract 1 from yupper\n        when direction = 'l' \n        and xupper < x-max - window-width\n            add 1 to xupper\n        end-evaluate\n\n        \n        move spaces to window\n        perform varying point from 1 by 1\n        until point > point-max\n            if ydragon(point) >= yupper and < yupper + window-height\n            and xdragon(point) >= xupper and < xupper + window-width\n                \n                compute y = ydragon(point) - yupper + 1\n                compute x =  xdragon(point) - xupper + 1\n                move mark to window-point(y, x)\n            end-if\n         end-perform\n\n         \n         perform varying window-line-number from 1 by 1\n         until window-line-number > window-height\n             display window-line(window-line-number)\n         end-perform\n\n         \n         display 'hjkl?' with no advancing\n         accept direction\n    end-perform\n\n    stop run\n    .\nend program dragon.\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.*;\nimport javax.swing.JFrame;\n\npublic class DragonCurve extends JFrame {\n\n    private List<Integer> turns;\n    private double startingAngle, side;\n\n    public DragonCurve(int iter) {\n        super(\"Dragon Curve\");\n        setBounds(100, 100, 800, 600);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        turns = getSequence(iter);\n        startingAngle = -iter * (Math.PI / 4);\n        side = 400 / Math.pow(2, iter / 2.);\n    }\n\n    public List<Integer> getSequence(int iterations) {\n        List<Integer> turnSequence = new ArrayList<Integer>();\n        for (int i = 0; i < iterations; i++) {\n            List<Integer> copy = new ArrayList<Integer>(turnSequence);\n            Collections.reverse(copy);\n            turnSequence.add(1);\n            for (Integer turn : copy) {\n                turnSequence.add(-turn);\n            }\n        }\n        return turnSequence;\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.setColor(Color.BLACK);\n        double angle = startingAngle;\n        int x1 = 230, y1 = 350;\n        int x2 = x1 + (int) (Math.cos(angle) * side);\n        int y2 = y1 + (int) (Math.sin(angle) * side);\n        g.drawLine(x1, y1, x2, y2);\n        x1 = x2;\n        y1 = y2;\n        for (Integer turn : turns) {\n            angle += turn * (Math.PI / 2);\n            x2 = x1 + (int) (Math.cos(angle) * side);\n            y2 = y1 + (int) (Math.sin(angle) * side);\n            g.drawLine(x1, y1, x2, y2);\n            x1 = x2;\n            y1 = y2;\n        }\n    }\n\n    public static void main(String[] args) {\n        new DragonCurve(14).setVisible(true);\n    }\n}\n"}
{"id": 102365, "name": "Dragon curve", "source": "Translate COBOL to Python:          >>SOURCE FORMAT FREE\n\nidentification division.\nprogram-id. dragon.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n01  segment-length pic 9 value 2.\n01  mark pic x value '.'.\n01  segment-count pic 9999 value 513.\n\n01  segment pic 9999.\n01  point pic 9999 value 1.\n01  point-max pic 9999.\n01  point-lim pic 9999 value 8192.\n01  dragon-curve.\n    03  filler occurs 8192.\n        05  ydragon pic s9999.\n        05  xdragon pic s9999.\n\n01  x pic s9999 value 1.\n01  y pic S9999 value 1.\n\n01  xdelta pic s9 value 1. \n01  ydelta pic s9 value 0.\n\n01  x-max pic s9999 value -9999.\n01  x-min pic s9999 value 9999.\n01  y-max pic s9999 value -9999.\n01  y-min pic s9999 value 9999.\n\n01  n pic 9999.\n01  r pic 9.\n\n01  xupper pic s9999.\n01  yupper pic s9999.\n\n01  window-line-number pic 99.\n01  window-width pic 99 value 64.\n01  window-height pic 99 value 22.\n01  window.\n    03  window-line occurs 22.\n        05  window-point occurs 64 pic x.\n\n01  direction pic x.\n\nprocedure division.\nstart-dragon.\n\n    if segment-count * segment-length > point-lim\n        \n        compute segment-count = point-lim / segment-length\n    end-if\n\n    perform varying segment from 1 by 1\n    until segment > segment-count\n\n        \n        \n        \n        \n\n        \n        divide 2 into segment giving n remainder r\n        perform until r <> 0\n            divide 2 into n giving n remainder r\n        end-perform\n        divide 2 into n giving n remainder r\n\n        \n        evaluate r also xdelta also ydelta\n        when 0 also 1 also 0  \n        when 1 also -1 also 0 \n            \n            move 0 to xdelta\n            move 1 to ydelta\n        when 1 also 1 also 0  \n        when 0 also -1 also 0 \n            \n            move 0 to xdelta\n            move -1 to ydelta\n        when 0 also 0 also 1  \n        when 1 also 0 also -1 \n            \n            move 0 to ydelta\n            move -1 to xdelta\n        when 1 also 0 also 1  \n        when 0 also 0 also -1 \n            \n            move 0 to ydelta\n            move 1 to xdelta\n        end-evaluate\n\n        \n        perform segment-length times\n            add xdelta to x\n            add ydelta to y\n\n            move x to xdragon(point)\n            move y to ydragon(point)\n\n            add 1 to point\n        end-perform\n\n        \n        compute x-max = max(x, x-max)\n        compute x-min = min(x, x-min)\n        compute y-max = max(y, y-max)\n        compute y-min = min(y, y-min)\n        move point to point-max\n\n    end-perform\n\n    \n    \n    \n    \n    \n\n    move 1 to yupper xupper\n\n    perform with test after\n    until direction <> 'h' and 'j' and 'k' and 'l'\n\n        \n        \n        \n\n        \n        evaluate true\n        when direction = 'h' \n        and xupper > x-min + window-width\n           subtract 1 from xupper\n        when direction = 'j' \n        and yupper < y-max - window-height\n           add 1 to yupper\n        when direction = 'k' \n        and yupper > y-min + window-height\n           subtract 1 from yupper\n        when direction = 'l' \n        and xupper < x-max - window-width\n            add 1 to xupper\n        end-evaluate\n\n        \n        move spaces to window\n        perform varying point from 1 by 1\n        until point > point-max\n            if ydragon(point) >= yupper and < yupper + window-height\n            and xdragon(point) >= xupper and < xupper + window-width\n                \n                compute y = ydragon(point) - yupper + 1\n                compute x =  xdragon(point) - xupper + 1\n                move mark to window-point(y, x)\n            end-if\n         end-perform\n\n         \n         perform varying window-line-number from 1 by 1\n         until window-line-number > window-height\n             display window-line(window-line-number)\n         end-perform\n\n         \n         display 'hjkl?' with no advancing\n         accept direction\n    end-perform\n\n    stop run\n    .\nend program dragon.\n", "target": "l = 3\nints = 13\n\ndef setup():\n  size(700, 600)\n  background(0, 0, 255)\n  translate(150, 100)\n  stroke(255)\n  turn_left(l, ints)\n  turn_right(l, ints)\n\ndef turn_right(l, ints):\n    if ints == 0:\n        line(0, 0, 0, -l)\n        translate(0, -l)\n    else:\n        turn_left(l, ints - 1)\n        rotate(radians(90))\n        turn_right(l, ints - 1)\n  \ndef turn_left(l, ints):\n    if ints == 0:\n        line(0, 0, 0, -l)\n        translate(0, -l)\n    else:\n        turn_left(l, ints - 1)\n        rotate(radians(-90))\n        turn_right(l, ints - 1)\n"}
{"id": 102591, "name": "Input loop", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. input-loop.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT in-stream ASSIGN TO KEYBOARD \n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS in-stream-status.\n               \n       DATA DIVISION.\n       FILE SECTION.\n       FD  in-stream.\n       01  stream-line                 PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       01  in-stream-status            PIC 99.\n           88  end-of-stream           VALUE 10.\n       \n       PROCEDURE DIVISION.\n           OPEN INPUT in-stream\n           \n           PERFORM UNTIL EXIT\n               READ in-stream\n                   AT END\n                       EXIT PERFORM\n               END-READ\n               DISPLAY stream-line\n           END-PERFORM\n           \n           CLOSE in-stream\n           .\n       END PROGRAM input-loop.\n", "target": "using System;\nusing System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        \n\n        using (var b = new StreamReader(\"file.txt\"))\n        {\n            string line;\n            while ((line = b.ReadLine()) != null)\n                Console.WriteLine(line);\n        }\n    }\n}\n"}
{"id": 102593, "name": "Input loop", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. input-loop.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT in-stream ASSIGN TO KEYBOARD \n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS in-stream-status.\n               \n       DATA DIVISION.\n       FILE SECTION.\n       FD  in-stream.\n       01  stream-line                 PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       01  in-stream-status            PIC 99.\n           88  end-of-stream           VALUE 10.\n       \n       PROCEDURE DIVISION.\n           OPEN INPUT in-stream\n           \n           PERFORM UNTIL EXIT\n               READ in-stream\n                   AT END\n                       EXIT PERFORM\n               END-READ\n               DISPLAY stream-line\n           END-PERFORM\n           \n           CLOSE in-stream\n           .\n       END PROGRAM input-loop.\n", "target": "import java.io.InputStream;\nimport java.util.Scanner;\n\npublic class InputLoop {\n    public static void main(String args[]) {\n        \n        InputStream source = System.in;\n\n        \n\n        Scanner in = new Scanner(source);\n        while(in.hasNext()){\n            String input = in.next(); \n\n            \n            System.out.println(input);\n        }\n    }\n}\n"}
{"id": 102594, "name": "Input loop", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. input-loop.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT in-stream ASSIGN TO KEYBOARD \n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS in-stream-status.\n               \n       DATA DIVISION.\n       FILE SECTION.\n       FD  in-stream.\n       01  stream-line                 PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       01  in-stream-status            PIC 99.\n           88  end-of-stream           VALUE 10.\n       \n       PROCEDURE DIVISION.\n           OPEN INPUT in-stream\n           \n           PERFORM UNTIL EXIT\n               READ in-stream\n                   AT END\n                       EXIT PERFORM\n               END-READ\n               DISPLAY stream-line\n           END-PERFORM\n           \n           CLOSE in-stream\n           .\n       END PROGRAM input-loop.\n", "target": "while(True):\n      x = input(\"What is your age? \")\n      print(x)\n"}
{"id": 102859, "name": "Mandelbrot set", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. MANDELBROT-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  COMPLEX-ARITHMETIC.\n    05 X               PIC S9V9(9).\n    05 Y               PIC S9V9(9).\n    05 X-A             PIC S9V9(6).\n    05 X-B             PIC S9V9(6).\n    05 Y-A             PIC S9V9(6).\n    05 X-A-SQUARED     PIC S9V9(6).\n    05 Y-A-SQUARED     PIC S9V9(6).\n    05 SUM-OF-SQUARES  PIC S9V9(6).\n    05 ROOT            PIC S9V9(6).\n01  LOOP-COUNTERS.\n    05 I               PIC 99.\n    05 J               PIC 99.\n    05 K               PIC 999.\n77  PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH\n    VARYING I FROM 1 BY 1 UNTIL I IS GREATER THAN 24.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM INNER-LOOP-PARAGRAPH\n    VARYING J FROM 1 BY 1 UNTIL J IS GREATER THAN 64.\n    DISPLAY ''.\nINNER-LOOP-PARAGRAPH.\n    MOVE SPACE TO PLOT-CHARACTER.\n    MOVE ZERO  TO X-A.\n    MOVE ZERO  TO Y-A.\n    MULTIPLY J   BY   0.0390625   GIVING X.\n    SUBTRACT 1.5 FROM X.\n    MULTIPLY I   BY   0.083333333 GIVING Y.\n    SUBTRACT 1 FROM Y.\n    PERFORM ITERATION-PARAGRAPH VARYING K FROM 1 BY 1\n    UNTIL K IS GREATER THAN 100 OR PLOT-CHARACTER IS EQUAL TO '#'.\n    DISPLAY PLOT-CHARACTER WITH NO ADVANCING.\nITERATION-PARAGRAPH.\n    MULTIPLY X-A BY X-A GIVING X-A-SQUARED.\n    MULTIPLY Y-A BY Y-A GIVING Y-A-SQUARED.\n    SUBTRACT Y-A-SQUARED FROM X-A-SQUARED GIVING X-B.\n    ADD      X   TO X-B.\n    MULTIPLY X-A BY Y-A GIVING Y-A.\n    MULTIPLY Y-A BY 2   GIVING Y-A.\n    SUBTRACT Y   FROM Y-A.\n    MOVE     X-B TO   X-A.\n    ADD X-A-SQUARED TO Y-A-SQUARED GIVING SUM-OF-SQUARES.\n    MOVE FUNCTION SQRT (SUM-OF-SQUARES) TO ROOT.\n    IF ROOT IS GREATER THAN 2 THEN MOVE '#' TO PLOT-CHARACTER.\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Imaging;\nusing System.Threading;\nusing System.Windows.Forms;\n\n\n\n\npublic class MandelbrotSetForm : Form\n{\n    const double MaxValueExtent = 2.0;\n    Thread thread;\n\n    static double CalcMandelbrotSetColor(ComplexNumber c)\n    {\n        \n        const int MaxIterations = 1000;\n        const double MaxNorm = MaxValueExtent * MaxValueExtent;\n\n        int iteration = 0;\n        ComplexNumber z = new ComplexNumber();\n        do\n        {\n            z = z * z + c;\n            iteration++;\n        } while (z.Norm() < MaxNorm && iteration < MaxIterations);\n        if (iteration < MaxIterations)\n            return (double)iteration / MaxIterations;\n        else\n            return 0; \n    }\n\n    static void GenerateBitmap(Bitmap bitmap)\n    {\n        double scale = 2 * MaxValueExtent / Math.Min(bitmap.Width, bitmap.Height);\n        for (int i = 0; i < bitmap.Height; i++)\n        {\n            double y = (bitmap.Height / 2 - i) * scale;\n            for (int j = 0; j < bitmap.Width; j++)\n            {\n                double x = (j - bitmap.Width / 2) * scale;\n                double color = CalcMandelbrotSetColor(new ComplexNumber(x, y));\n                bitmap.SetPixel(j, i, GetColor(color));\n            }\n        }\n    }\n\n    static Color GetColor(double value)\n    {\n        const double MaxColor = 256;\n        const double ContrastValue = 0.2;\n        return Color.FromArgb(0, 0,\n            (int)(MaxColor * Math.Pow(value, ContrastValue)));\n    }\n    \n    public MandelbrotSetForm()\n    {\n        \n        this.Text = \"Mandelbrot Set Drawing\";\n        this.BackColor = System.Drawing.Color.Black;\n        this.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Stretch;\n        this.MaximizeBox = false;\n        this.StartPosition = FormStartPosition.CenterScreen;\n        this.FormBorderStyle = FormBorderStyle.FixedDialog;\n        this.ClientSize = new Size(640, 640);\n        this.Load += new System.EventHandler(this.MainForm_Load);\n    }\n\n    void MainForm_Load(object sender, EventArgs e)\n    {\n        thread = new Thread(thread_Proc);\n        thread.IsBackground = true;\n        thread.Start(this.ClientSize);\n    }\n\n    void thread_Proc(object args)\n    {\n        \n        Size size = (Size)args;\n        int width = 16;\n        while (width * 2 < size.Width)\n        {\n            int height = width * size.Height / size.Width;\n            Bitmap bitmap = new Bitmap(width, height, PixelFormat.Format24bppRgb);\n            GenerateBitmap(bitmap);\n            this.BeginInvoke(new SetNewBitmapDelegate(SetNewBitmap), bitmap);\n            width *= 2;\n            Thread.Sleep(200);\n        }\n        \n        Bitmap finalBitmap = new Bitmap(size.Width, size.Height, PixelFormat.Format24bppRgb);\n        GenerateBitmap(finalBitmap);\n        this.BeginInvoke(new SetNewBitmapDelegate(SetNewBitmap), finalBitmap);\n    }\n\n    void SetNewBitmap(Bitmap image)\n    {\n        if (this.BackgroundImage != null)\n            this.BackgroundImage.Dispose();\n        this.BackgroundImage = image;\n    }\n\n    delegate void SetNewBitmapDelegate(Bitmap image);\n\n    static void Main()\n    {\n        Application.Run(new MandelbrotSetForm());\n    }\n}\n\nstruct ComplexNumber\n{\n    public double Re;\n    public double Im;\n\n    public ComplexNumber(double re, double im)\n    {\n        this.Re = re;\n        this.Im = im;\n    }\n\n    public static ComplexNumber operator +(ComplexNumber x, ComplexNumber y)\n    {\n        return new ComplexNumber(x.Re + y.Re, x.Im + y.Im);\n    }\n\n    public static ComplexNumber operator *(ComplexNumber x, ComplexNumber y)\n    {\n        return new ComplexNumber(x.Re * y.Re - x.Im * y.Im,\n            x.Re * y.Im + x.Im * y.Re);\n    }\n\n    public double Norm()\n    {\n        return Re * Re + Im * Im;\n    }\n}\n"}
{"id": 102861, "name": "Mandelbrot set", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. MANDELBROT-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  COMPLEX-ARITHMETIC.\n    05 X               PIC S9V9(9).\n    05 Y               PIC S9V9(9).\n    05 X-A             PIC S9V9(6).\n    05 X-B             PIC S9V9(6).\n    05 Y-A             PIC S9V9(6).\n    05 X-A-SQUARED     PIC S9V9(6).\n    05 Y-A-SQUARED     PIC S9V9(6).\n    05 SUM-OF-SQUARES  PIC S9V9(6).\n    05 ROOT            PIC S9V9(6).\n01  LOOP-COUNTERS.\n    05 I               PIC 99.\n    05 J               PIC 99.\n    05 K               PIC 999.\n77  PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH\n    VARYING I FROM 1 BY 1 UNTIL I IS GREATER THAN 24.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM INNER-LOOP-PARAGRAPH\n    VARYING J FROM 1 BY 1 UNTIL J IS GREATER THAN 64.\n    DISPLAY ''.\nINNER-LOOP-PARAGRAPH.\n    MOVE SPACE TO PLOT-CHARACTER.\n    MOVE ZERO  TO X-A.\n    MOVE ZERO  TO Y-A.\n    MULTIPLY J   BY   0.0390625   GIVING X.\n    SUBTRACT 1.5 FROM X.\n    MULTIPLY I   BY   0.083333333 GIVING Y.\n    SUBTRACT 1 FROM Y.\n    PERFORM ITERATION-PARAGRAPH VARYING K FROM 1 BY 1\n    UNTIL K IS GREATER THAN 100 OR PLOT-CHARACTER IS EQUAL TO '#'.\n    DISPLAY PLOT-CHARACTER WITH NO ADVANCING.\nITERATION-PARAGRAPH.\n    MULTIPLY X-A BY X-A GIVING X-A-SQUARED.\n    MULTIPLY Y-A BY Y-A GIVING Y-A-SQUARED.\n    SUBTRACT Y-A-SQUARED FROM X-A-SQUARED GIVING X-B.\n    ADD      X   TO X-B.\n    MULTIPLY X-A BY Y-A GIVING Y-A.\n    MULTIPLY Y-A BY 2   GIVING Y-A.\n    SUBTRACT Y   FROM Y-A.\n    MOVE     X-B TO   X-A.\n    ADD X-A-SQUARED TO Y-A-SQUARED GIVING SUM-OF-SQUARES.\n    MOVE FUNCTION SQRT (SUM-OF-SQUARES) TO ROOT.\n    IF ROOT IS GREATER THAN 2 THEN MOVE '#' TO PLOT-CHARACTER.\n", "target": "import java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport javax.swing.JFrame;\n\npublic class Mandelbrot extends JFrame {\n\n    private final int MAX_ITER = 570;\n    private final double ZOOM = 150;\n    private BufferedImage I;\n    private double zx, zy, cX, cY, tmp;\n\n    public Mandelbrot() {\n        super(\"Mandelbrot Set\");\n        setBounds(100, 100, 800, 600);\n        setResizable(false);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        I = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);\n        for (int y = 0; y < getHeight(); y++) {\n            for (int x = 0; x < getWidth(); x++) {\n                zx = zy = 0;\n                cX = (x - 400) / ZOOM;\n                cY = (y - 300) / ZOOM;\n                int iter = MAX_ITER;\n                while (zx * zx + zy * zy < 4 && iter > 0) {\n                    tmp = zx * zx - zy * zy + cX;\n                    zy = 2.0 * zx * zy + cY;\n                    zx = tmp;\n                    iter--;\n                }\n                I.setRGB(x, y, iter | (iter << 8));\n            }\n        }\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.drawImage(I, 0, 0, this);\n    }\n\n    public static void main(String[] args) {\n        new Mandelbrot().setVisible(true);\n    }\n}\n"}
{"id": 102862, "name": "Mandelbrot set", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. MANDELBROT-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  COMPLEX-ARITHMETIC.\n    05 X               PIC S9V9(9).\n    05 Y               PIC S9V9(9).\n    05 X-A             PIC S9V9(6).\n    05 X-B             PIC S9V9(6).\n    05 Y-A             PIC S9V9(6).\n    05 X-A-SQUARED     PIC S9V9(6).\n    05 Y-A-SQUARED     PIC S9V9(6).\n    05 SUM-OF-SQUARES  PIC S9V9(6).\n    05 ROOT            PIC S9V9(6).\n01  LOOP-COUNTERS.\n    05 I               PIC 99.\n    05 J               PIC 99.\n    05 K               PIC 999.\n77  PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH\n    VARYING I FROM 1 BY 1 UNTIL I IS GREATER THAN 24.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM INNER-LOOP-PARAGRAPH\n    VARYING J FROM 1 BY 1 UNTIL J IS GREATER THAN 64.\n    DISPLAY ''.\nINNER-LOOP-PARAGRAPH.\n    MOVE SPACE TO PLOT-CHARACTER.\n    MOVE ZERO  TO X-A.\n    MOVE ZERO  TO Y-A.\n    MULTIPLY J   BY   0.0390625   GIVING X.\n    SUBTRACT 1.5 FROM X.\n    MULTIPLY I   BY   0.083333333 GIVING Y.\n    SUBTRACT 1 FROM Y.\n    PERFORM ITERATION-PARAGRAPH VARYING K FROM 1 BY 1\n    UNTIL K IS GREATER THAN 100 OR PLOT-CHARACTER IS EQUAL TO '#'.\n    DISPLAY PLOT-CHARACTER WITH NO ADVANCING.\nITERATION-PARAGRAPH.\n    MULTIPLY X-A BY X-A GIVING X-A-SQUARED.\n    MULTIPLY Y-A BY Y-A GIVING Y-A-SQUARED.\n    SUBTRACT Y-A-SQUARED FROM X-A-SQUARED GIVING X-B.\n    ADD      X   TO X-B.\n    MULTIPLY X-A BY Y-A GIVING Y-A.\n    MULTIPLY Y-A BY 2   GIVING Y-A.\n    SUBTRACT Y   FROM Y-A.\n    MOVE     X-B TO   X-A.\n    ADD X-A-SQUARED TO Y-A-SQUARED GIVING SUM-OF-SQUARES.\n    MOVE FUNCTION SQRT (SUM-OF-SQUARES) TO ROOT.\n    IF ROOT IS GREATER THAN 2 THEN MOVE '#' TO PLOT-CHARACTER.\n", "target": "i = di = dj = 0\nfn1, fn2, fn3 = random(20), random(20), random(20)\nf = 10\n    \ndef setup():\n    global zmx1, zmx2, zmy1, zmy2\n    size(500, 500)\n    zmx1 = int(width / 4)\n    zmx2 = 2\n    zmy1 = int(height / 4)\n    zmy2 = 2\n\n\ndef draw():\n    global i\n\n    if i <= width:\n        i += 1\n    x = float(i + di) / zmx1 - zmx2\n    for j in range(height + 1):\n        y = zmy2 - float(j + dj) / zmy1\n        zr = zi = zr2 = zi2 = 0\n        cr, ci = x, y\n        n = 1\n        while n < 200 and (zr2 + zi2) < 4:\n            zi2 = zi * zi\n            zr2 = zr * zr\n            zi = 2 * zi * zr + ci\n            zr = zr2 - zi2 + cr\n            n += 1\n\n        re = (n * fn1) % 255\n        gr = (n * fn2) % 255\n        bl = (n * fn3) % 255\n        stroke(re, gr, bl)\n        point(i, j)\n\n\ndef mousePressed():\n    global zmx1, zmx2, zmy1, zmy2, di, dj\n    global i, j\n    background(200)\n    xt, yt = mouseX, mouseY\n    di = di + xt - width / 2.\n    dj = dj + yt - height / 2.\n    zmx1 = zmx1 * f\n    zmx2 = zmx2 * (1. / f)\n    zmy1 = zmy1 * f\n    zmy2 = zmy2 * (1. / f)\n    di, dj = di * f, dj * f\n    i = j = 0\n"}
{"id": 103136, "name": "Anagrams", "source": "Translate COBOL to C#:       \n      \n      \n      \n      \n      \n      \n       identification division.\n       program-id. anagrams.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select words-in\n           assign to wordfile\n           organization is line sequential\n           status is words-status\n           .\n\n       REPLACE ==:LETTERS:== BY ==42==.\n\n       data division.\n       file section.\n       fd words-in record is varying from 1 to :LETTERS: characters\n                             depending on word-length.\n       01 word-record.\n          05 word-data         pic x occurs 0 to :LETTERS: times\n                                     depending on word-length.\n\n       working-storage section.\n       >>IF ALLWORDS DEFINED\n       01 wordfile     constant as \"/usr/local/share/dict/all.words\".\n       01 max-words    constant as 4802100.\n\n       >>ELSE-IF MOSTWORDS DEFINED\n       01 wordfile     constant as \"/usr/local/share/dict/linux.words\".\n       01 max-words    constant as 628000.\n\n       >>ELSE-IF MOREWORDS DEFINED\n       01 wordfile     constant as \"/usr/share/dict/words\".\n       01 max-words    constant as 100000.\n\n       >>ELSE\n       01 wordfile     constant as \"unixdict.txt\".\n       01 max-words    constant as 26000.\n       >>END-IF\n\n      \n       >>IF ALLWORDS DEFINED\n       01 max-letters          constant as 26.\n       >>ELSE\n       01 max-letters          constant as :LETTERS:.\n       >>END-IF\n\n       01 word-length          pic 99 comp-5.\n       01 words-status         pic xx.\n          88 ok-status         values '00' thru '09'.\n          88 eof-status        value '10'.\n\n      \n       01 letter-index         usage index.\n       01 letter-table.\n          05 letters           occurs 1 to max-letters times\n                               depending on word-length\n                               ascending key letter\n                               indexed by letter-index.\n             10 letter         pic x.\n\n      \n       01 sorted-index         usage index.\n       01 word-table.\n          05 word-list         occurs 0 to max-words times\n                               depending on word-tally\n                               ascending key sorted-word\n                               indexed by sorted-index.\n             10 match-count    pic 999 comp-5.\n             10 this-word      pic x(max-letters).\n             10 sorted-word    pic x(max-letters).\n       01 sorted-display       pic x(10).\n\n       01 interest-table.\n          05 interest-list     pic 9(8) comp-5\n                               occurs 0 to max-words times\n                               depending on interest-tally.\n\n       01 outer                pic 9(8) comp-5.\n       01 inner                pic 9(8) comp-5.\n       01 starter              pic 9(8) comp-5.\n       01 ender                pic 9(8) comp-5.\n       01 word-tally           pic 9(8) comp-5.\n       01 interest-tally       pic 9(8) comp-5.\n       01 tally-display        pic zz,zzz,zz9.\n\n       01 most-matches         pic 99 comp-5.\n       01 matches              pic 99 comp-5.\n       01 match-display        pic z9.\n\n      \n       01 time-stamp.\n          05 filler            pic x(11).\n          05 timer-hours       pic 99.\n          05 filler            pic x.\n          05 timer-minutes     pic 99.\n          05 filler            pic x.\n          05 timer-seconds     pic 99.\n          05 filler            pic x.\n          05 timer-subsec      pic v9(6).\n       01 timer-elapsed        pic 9(6)v9(6).\n       01 timer-value          pic 9(6)v9(6).\n       01 timer-display        pic zzz,zz9.9(6).\n\n      \n       procedure division.\n       main-routine.\n\n       >>IF ALLWORDS DEFINED\n           display \"** Words limited to \" max-letters \" letters **\"\n       >>END-IF\n\n       perform show-time\n\n       perform load-words\n       perform find-most\n       perform display-result\n\n       perform show-time\n       goback\n       .\n\n      \n       load-words.\n       open input words-in\n       if not ok-status then\n           display \"error opening \" wordfile upon syserr\n           move 1 to return-code\n           goback\n       end-if\n\n       perform until exit\n           read words-in\n           if eof-status then exit perform end-if\n           if not ok-status then\n               display wordfile \" read error: \" words-status upon syserr\n           end-if\n\n           if word-length equal zero then exit perform cycle end-if\n\n       >>IF ALLWORDS DEFINED\n           move min(word-length, max-letters) to word-length\n       >>END-IF\n\n           add 1 to word-tally\n           move word-record to this-word(word-tally) letter-table\n           sort letters ascending key letter\n           move letter-table to sorted-word(word-tally)\n       end-perform\n\n       move word-tally to tally-display\n       display trim(tally-display) \" words\" with no advancing\n\n       close words-in\n       if not ok-status then\n           display \"error closing \" wordfile upon syserr\n           move 1 to return-code\n       end-if\n\n      \n       sort word-list ascending key sorted-word\n       .\n\n      \n       find-most.\n       perform varying outer from 1 by 1 until outer > word-tally\n           move 1 to matches\n           add 1 to outer giving starter\n           perform varying inner from starter by 1\n                   until sorted-word(inner) not equal sorted-word(outer)\n               add 1 to matches\n           end-perform\n           if matches > most-matches then\n               move matches to most-matches\n               initialize interest-table all to value\n               move 0 to interest-tally\n           end-if\n           move matches to match-count(outer)\n           if matches = most-matches then\n               add 1 to interest-tally\n               move outer to interest-list(interest-tally)\n           end-if\n       end-perform\n       .\n\n      \n       display-result.\n       move interest-tally to tally-display\n       move most-matches to match-display\n       display \", most anagrams: \" trim(match-display)\n               \", with \" trim(tally-display) \" set\" with no advancing\n       if interest-tally not equal 1 then\n           display \"s\" with no advancing\n       end-if\n       display \" of interest\"\n\n       perform varying outer from 1 by 1 until outer > interest-tally\n           move sorted-word(interest-list(outer)) to sorted-display\n           display sorted-display\n                   \" [\" trim(this-word(interest-list(outer)))\n              with no advancing\n           add 1 to interest-list(outer) giving starter\n           add most-matches to interest-list(outer) giving ender\n           perform varying inner from starter by 1\n               until inner = ender\n                   display \", \" trim(this-word(inner))\n                      with no advancing\n           end-perform\n           display \"]\"\n       end-perform\n       .\n\n      \n       show-time.\n       move formatted-current-date(\"YYYY-MM-DDThh:mm:ss.ssssss\")\n         to time-stamp\n       compute timer-value = timer-hours * 3600 + timer-minutes * 60\n                             + timer-seconds + timer-subsec\n       if timer-elapsed = 0 then\n           display time-stamp\n           move timer-value to timer-elapsed\n       else\n           if timer-value < timer-elapsed then\n               add 86400 to timer-value\n           end-if\n           subtract timer-elapsed from timer-value\n           move timer-value to timer-display\n           display time-stamp \", \" trim(timer-display) \" seconds\"\n       end-if\n       .\n\n       end program anagrams.\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Text.RegularExpressions;\n\nnamespace Anagram\n{\n    class Program\n    {\n        const string DICO_URL = \"http:\n\n        static void Main( string[] args )\n        {\n            WebRequest request = WebRequest.Create(DICO_URL);\n            string[] words;\n            using (StreamReader sr = new StreamReader(request.GetResponse().GetResponseStream(), true)) {\n                words = Regex.Split(sr.ReadToEnd(), @\"\\r?\\n\");\n            }\n            var groups = from string w in words\n                         group w by string.Concat(w.OrderBy(x => x)) into c\n                         group c by c.Count() into d\n                         orderby d.Key descending\n                         select d;\n            foreach (var c in groups.First()) {\n                Console.WriteLine(string.Join(\" \", c));\n            }\n        }\n    }\n}\n"}
{"id": 103138, "name": "Anagrams", "source": "Translate COBOL to Java:       \n      \n      \n      \n      \n      \n      \n       identification division.\n       program-id. anagrams.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select words-in\n           assign to wordfile\n           organization is line sequential\n           status is words-status\n           .\n\n       REPLACE ==:LETTERS:== BY ==42==.\n\n       data division.\n       file section.\n       fd words-in record is varying from 1 to :LETTERS: characters\n                             depending on word-length.\n       01 word-record.\n          05 word-data         pic x occurs 0 to :LETTERS: times\n                                     depending on word-length.\n\n       working-storage section.\n       >>IF ALLWORDS DEFINED\n       01 wordfile     constant as \"/usr/local/share/dict/all.words\".\n       01 max-words    constant as 4802100.\n\n       >>ELSE-IF MOSTWORDS DEFINED\n       01 wordfile     constant as \"/usr/local/share/dict/linux.words\".\n       01 max-words    constant as 628000.\n\n       >>ELSE-IF MOREWORDS DEFINED\n       01 wordfile     constant as \"/usr/share/dict/words\".\n       01 max-words    constant as 100000.\n\n       >>ELSE\n       01 wordfile     constant as \"unixdict.txt\".\n       01 max-words    constant as 26000.\n       >>END-IF\n\n      \n       >>IF ALLWORDS DEFINED\n       01 max-letters          constant as 26.\n       >>ELSE\n       01 max-letters          constant as :LETTERS:.\n       >>END-IF\n\n       01 word-length          pic 99 comp-5.\n       01 words-status         pic xx.\n          88 ok-status         values '00' thru '09'.\n          88 eof-status        value '10'.\n\n      \n       01 letter-index         usage index.\n       01 letter-table.\n          05 letters           occurs 1 to max-letters times\n                               depending on word-length\n                               ascending key letter\n                               indexed by letter-index.\n             10 letter         pic x.\n\n      \n       01 sorted-index         usage index.\n       01 word-table.\n          05 word-list         occurs 0 to max-words times\n                               depending on word-tally\n                               ascending key sorted-word\n                               indexed by sorted-index.\n             10 match-count    pic 999 comp-5.\n             10 this-word      pic x(max-letters).\n             10 sorted-word    pic x(max-letters).\n       01 sorted-display       pic x(10).\n\n       01 interest-table.\n          05 interest-list     pic 9(8) comp-5\n                               occurs 0 to max-words times\n                               depending on interest-tally.\n\n       01 outer                pic 9(8) comp-5.\n       01 inner                pic 9(8) comp-5.\n       01 starter              pic 9(8) comp-5.\n       01 ender                pic 9(8) comp-5.\n       01 word-tally           pic 9(8) comp-5.\n       01 interest-tally       pic 9(8) comp-5.\n       01 tally-display        pic zz,zzz,zz9.\n\n       01 most-matches         pic 99 comp-5.\n       01 matches              pic 99 comp-5.\n       01 match-display        pic z9.\n\n      \n       01 time-stamp.\n          05 filler            pic x(11).\n          05 timer-hours       pic 99.\n          05 filler            pic x.\n          05 timer-minutes     pic 99.\n          05 filler            pic x.\n          05 timer-seconds     pic 99.\n          05 filler            pic x.\n          05 timer-subsec      pic v9(6).\n       01 timer-elapsed        pic 9(6)v9(6).\n       01 timer-value          pic 9(6)v9(6).\n       01 timer-display        pic zzz,zz9.9(6).\n\n      \n       procedure division.\n       main-routine.\n\n       >>IF ALLWORDS DEFINED\n           display \"** Words limited to \" max-letters \" letters **\"\n       >>END-IF\n\n       perform show-time\n\n       perform load-words\n       perform find-most\n       perform display-result\n\n       perform show-time\n       goback\n       .\n\n      \n       load-words.\n       open input words-in\n       if not ok-status then\n           display \"error opening \" wordfile upon syserr\n           move 1 to return-code\n           goback\n       end-if\n\n       perform until exit\n           read words-in\n           if eof-status then exit perform end-if\n           if not ok-status then\n               display wordfile \" read error: \" words-status upon syserr\n           end-if\n\n           if word-length equal zero then exit perform cycle end-if\n\n       >>IF ALLWORDS DEFINED\n           move min(word-length, max-letters) to word-length\n       >>END-IF\n\n           add 1 to word-tally\n           move word-record to this-word(word-tally) letter-table\n           sort letters ascending key letter\n           move letter-table to sorted-word(word-tally)\n       end-perform\n\n       move word-tally to tally-display\n       display trim(tally-display) \" words\" with no advancing\n\n       close words-in\n       if not ok-status then\n           display \"error closing \" wordfile upon syserr\n           move 1 to return-code\n       end-if\n\n      \n       sort word-list ascending key sorted-word\n       .\n\n      \n       find-most.\n       perform varying outer from 1 by 1 until outer > word-tally\n           move 1 to matches\n           add 1 to outer giving starter\n           perform varying inner from starter by 1\n                   until sorted-word(inner) not equal sorted-word(outer)\n               add 1 to matches\n           end-perform\n           if matches > most-matches then\n               move matches to most-matches\n               initialize interest-table all to value\n               move 0 to interest-tally\n           end-if\n           move matches to match-count(outer)\n           if matches = most-matches then\n               add 1 to interest-tally\n               move outer to interest-list(interest-tally)\n           end-if\n       end-perform\n       .\n\n      \n       display-result.\n       move interest-tally to tally-display\n       move most-matches to match-display\n       display \", most anagrams: \" trim(match-display)\n               \", with \" trim(tally-display) \" set\" with no advancing\n       if interest-tally not equal 1 then\n           display \"s\" with no advancing\n       end-if\n       display \" of interest\"\n\n       perform varying outer from 1 by 1 until outer > interest-tally\n           move sorted-word(interest-list(outer)) to sorted-display\n           display sorted-display\n                   \" [\" trim(this-word(interest-list(outer)))\n              with no advancing\n           add 1 to interest-list(outer) giving starter\n           add most-matches to interest-list(outer) giving ender\n           perform varying inner from starter by 1\n               until inner = ender\n                   display \", \" trim(this-word(inner))\n                      with no advancing\n           end-perform\n           display \"]\"\n       end-perform\n       .\n\n      \n       show-time.\n       move formatted-current-date(\"YYYY-MM-DDThh:mm:ss.ssssss\")\n         to time-stamp\n       compute timer-value = timer-hours * 3600 + timer-minutes * 60\n                             + timer-seconds + timer-subsec\n       if timer-elapsed = 0 then\n           display time-stamp\n           move timer-value to timer-elapsed\n       else\n           if timer-value < timer-elapsed then\n               add 86400 to timer-value\n           end-if\n           subtract timer-elapsed from timer-value\n           move timer-value to timer-display\n           display time-stamp \", \" trim(timer-display) \" seconds\"\n       end-if\n       .\n\n       end program anagrams.\n", "target": "import java.net.*;\nimport java.io.*;\nimport java.util.*;\n \npublic class WordsOfEqChars {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http:\n        InputStreamReader isr = new InputStreamReader(url.openStream());\n        BufferedReader reader = new BufferedReader(isr);\n\n        Map<String, Collection<String>> anagrams = new HashMap<String, Collection<String>>();\n        String word;\n        int count = 0;\n        while ((word = reader.readLine()) != null) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            String key = new String(chars);\n            if (!anagrams.containsKey(key))\n                anagrams.put(key, new ArrayList<String>());\n            anagrams.get(key).add(word);\n            count = Math.max(count, anagrams.get(key).size());\n        }\n\n        reader.close();\n\n        for (Collection<String> ana : anagrams.values())\n            if (ana.size() >= count)\n                System.out.println(ana);\n    }   \n}\n"}
{"id": 103139, "name": "Anagrams", "source": "Translate COBOL to Python:       \n      \n      \n      \n      \n      \n      \n       identification division.\n       program-id. anagrams.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select words-in\n           assign to wordfile\n           organization is line sequential\n           status is words-status\n           .\n\n       REPLACE ==:LETTERS:== BY ==42==.\n\n       data division.\n       file section.\n       fd words-in record is varying from 1 to :LETTERS: characters\n                             depending on word-length.\n       01 word-record.\n          05 word-data         pic x occurs 0 to :LETTERS: times\n                                     depending on word-length.\n\n       working-storage section.\n       >>IF ALLWORDS DEFINED\n       01 wordfile     constant as \"/usr/local/share/dict/all.words\".\n       01 max-words    constant as 4802100.\n\n       >>ELSE-IF MOSTWORDS DEFINED\n       01 wordfile     constant as \"/usr/local/share/dict/linux.words\".\n       01 max-words    constant as 628000.\n\n       >>ELSE-IF MOREWORDS DEFINED\n       01 wordfile     constant as \"/usr/share/dict/words\".\n       01 max-words    constant as 100000.\n\n       >>ELSE\n       01 wordfile     constant as \"unixdict.txt\".\n       01 max-words    constant as 26000.\n       >>END-IF\n\n      \n       >>IF ALLWORDS DEFINED\n       01 max-letters          constant as 26.\n       >>ELSE\n       01 max-letters          constant as :LETTERS:.\n       >>END-IF\n\n       01 word-length          pic 99 comp-5.\n       01 words-status         pic xx.\n          88 ok-status         values '00' thru '09'.\n          88 eof-status        value '10'.\n\n      \n       01 letter-index         usage index.\n       01 letter-table.\n          05 letters           occurs 1 to max-letters times\n                               depending on word-length\n                               ascending key letter\n                               indexed by letter-index.\n             10 letter         pic x.\n\n      \n       01 sorted-index         usage index.\n       01 word-table.\n          05 word-list         occurs 0 to max-words times\n                               depending on word-tally\n                               ascending key sorted-word\n                               indexed by sorted-index.\n             10 match-count    pic 999 comp-5.\n             10 this-word      pic x(max-letters).\n             10 sorted-word    pic x(max-letters).\n       01 sorted-display       pic x(10).\n\n       01 interest-table.\n          05 interest-list     pic 9(8) comp-5\n                               occurs 0 to max-words times\n                               depending on interest-tally.\n\n       01 outer                pic 9(8) comp-5.\n       01 inner                pic 9(8) comp-5.\n       01 starter              pic 9(8) comp-5.\n       01 ender                pic 9(8) comp-5.\n       01 word-tally           pic 9(8) comp-5.\n       01 interest-tally       pic 9(8) comp-5.\n       01 tally-display        pic zz,zzz,zz9.\n\n       01 most-matches         pic 99 comp-5.\n       01 matches              pic 99 comp-5.\n       01 match-display        pic z9.\n\n      \n       01 time-stamp.\n          05 filler            pic x(11).\n          05 timer-hours       pic 99.\n          05 filler            pic x.\n          05 timer-minutes     pic 99.\n          05 filler            pic x.\n          05 timer-seconds     pic 99.\n          05 filler            pic x.\n          05 timer-subsec      pic v9(6).\n       01 timer-elapsed        pic 9(6)v9(6).\n       01 timer-value          pic 9(6)v9(6).\n       01 timer-display        pic zzz,zz9.9(6).\n\n      \n       procedure division.\n       main-routine.\n\n       >>IF ALLWORDS DEFINED\n           display \"** Words limited to \" max-letters \" letters **\"\n       >>END-IF\n\n       perform show-time\n\n       perform load-words\n       perform find-most\n       perform display-result\n\n       perform show-time\n       goback\n       .\n\n      \n       load-words.\n       open input words-in\n       if not ok-status then\n           display \"error opening \" wordfile upon syserr\n           move 1 to return-code\n           goback\n       end-if\n\n       perform until exit\n           read words-in\n           if eof-status then exit perform end-if\n           if not ok-status then\n               display wordfile \" read error: \" words-status upon syserr\n           end-if\n\n           if word-length equal zero then exit perform cycle end-if\n\n       >>IF ALLWORDS DEFINED\n           move min(word-length, max-letters) to word-length\n       >>END-IF\n\n           add 1 to word-tally\n           move word-record to this-word(word-tally) letter-table\n           sort letters ascending key letter\n           move letter-table to sorted-word(word-tally)\n       end-perform\n\n       move word-tally to tally-display\n       display trim(tally-display) \" words\" with no advancing\n\n       close words-in\n       if not ok-status then\n           display \"error closing \" wordfile upon syserr\n           move 1 to return-code\n       end-if\n\n      \n       sort word-list ascending key sorted-word\n       .\n\n      \n       find-most.\n       perform varying outer from 1 by 1 until outer > word-tally\n           move 1 to matches\n           add 1 to outer giving starter\n           perform varying inner from starter by 1\n                   until sorted-word(inner) not equal sorted-word(outer)\n               add 1 to matches\n           end-perform\n           if matches > most-matches then\n               move matches to most-matches\n               initialize interest-table all to value\n               move 0 to interest-tally\n           end-if\n           move matches to match-count(outer)\n           if matches = most-matches then\n               add 1 to interest-tally\n               move outer to interest-list(interest-tally)\n           end-if\n       end-perform\n       .\n\n      \n       display-result.\n       move interest-tally to tally-display\n       move most-matches to match-display\n       display \", most anagrams: \" trim(match-display)\n               \", with \" trim(tally-display) \" set\" with no advancing\n       if interest-tally not equal 1 then\n           display \"s\" with no advancing\n       end-if\n       display \" of interest\"\n\n       perform varying outer from 1 by 1 until outer > interest-tally\n           move sorted-word(interest-list(outer)) to sorted-display\n           display sorted-display\n                   \" [\" trim(this-word(interest-list(outer)))\n              with no advancing\n           add 1 to interest-list(outer) giving starter\n           add most-matches to interest-list(outer) giving ender\n           perform varying inner from starter by 1\n               until inner = ender\n                   display \", \" trim(this-word(inner))\n                      with no advancing\n           end-perform\n           display \"]\"\n       end-perform\n       .\n\n      \n       show-time.\n       move formatted-current-date(\"YYYY-MM-DDThh:mm:ss.ssssss\")\n         to time-stamp\n       compute timer-value = timer-hours * 3600 + timer-minutes * 60\n                             + timer-seconds + timer-subsec\n       if timer-elapsed = 0 then\n           display time-stamp\n           move timer-value to timer-elapsed\n       else\n           if timer-value < timer-elapsed then\n               add 86400 to timer-value\n           end-if\n           subtract timer-elapsed from timer-value\n           move timer-value to timer-display\n           display time-stamp \", \" trim(timer-display) \" seconds\"\n       end-if\n       .\n\n       end program anagrams.\n", "target": ">>> import urllib.request\n>>> from collections import defaultdict\n>>> words = urllib.request.urlopen('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt').read().split()\n>>> anagram = defaultdict(list) \n>>> for word in words:\n\tanagram[tuple(sorted(word))].append( word )\n\n\t\n>>> count = max(len(ana) for ana in anagram.values())\n>>> for ana in anagram.values():\n\tif len(ana) >= count:\n\t\tprint ([x.decode() for x in ana])\n"}
{"id": 103690, "name": "Letter frequency", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Letter-Frequency.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  12 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   A rather simplistic program to do the kind of thing\n      **   that COBOL does really well.                \n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Text-File ASSIGN TO \"File.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Text-File\n           DATA RECORD IS Record-Name.\n       01  Record-Name           PIC X(80).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n\n       01  Letter-cnt.\n           05  A-cnt            PIC 9(5)    VALUE 0.\n           05  B-cnt            PIC 9(5)    VALUE 0.\n           05  C-cnt            PIC 9(5)    VALUE 0.\n           05  D-cnt            PIC 9(5)    VALUE 0.\n           05  E-cnt            PIC 9(5)    VALUE 0.\n           05  F-cnt            PIC 9(5)    VALUE 0.\n           05  G-cnt            PIC 9(5)    VALUE 0.\n           05  H-cnt            PIC 9(5)    VALUE 0.\n           05  I-cnt            PIC 9(5)    VALUE 0.\n           05  J-cnt            PIC 9(5)    VALUE 0.\n           05  K-cnt            PIC 9(5)    VALUE 0.\n           05  L-cnt            PIC 9(5)    VALUE 0.\n           05  M-cnt            PIC 9(5)    VALUE 0.\n           05  N-cnt            PIC 9(5)    VALUE 0.\n           05  O-cnt            PIC 9(5)    VALUE 0.\n           05  P-cnt            PIC 9(5)    VALUE 0.\n           05  Q-cnt            PIC 9(5)    VALUE 0.\n           05  R-cnt            PIC 9(5)    VALUE 0.\n           05  S-cnt            PIC 9(5)    VALUE 0.\n           05  T-cnt            PIC 9(5)    VALUE 0.\n           05  U-cnt            PIC 9(5)    VALUE 0.\n           05  V-cnt            PIC 9(5)    VALUE 0.\n           05  W-cnt            PIC 9(5)    VALUE 0.\n           05  X-cnt            PIC 9(5)    VALUE 0.\n           05  Y-cnt            PIC 9(5)    VALUE 0.\n           05  Z-cnt            PIC 9(5)    VALUE 0.\n       \n       01  Letter-disp.\n           05  A-cnt            PIC ZZZZ9.\n           05  B-cnt            PIC ZZZZ9.\n           05  C-cnt            PIC ZZZZ9.\n           05  D-cnt            PIC ZZZZ9.\n           05  E-cnt            PIC ZZZZ9.\n           05  F-cnt            PIC ZZZZ9.\n           05  G-cnt            PIC ZZZZ9.\n           05  H-cnt            PIC ZZZZ9.\n           05  I-cnt            PIC ZZZZ9.\n           05  J-cnt            PIC ZZZZ9.\n           05  K-cnt            PIC ZZZZ9.\n           05  L-cnt            PIC ZZZZ9.\n           05  M-cnt            PIC ZZZZ9.\n           05  N-cnt            PIC ZZZZ9.\n           05  O-cnt            PIC ZZZZ9.\n           05  P-cnt            PIC ZZZZ9.\n           05  Q-cnt            PIC ZZZZ9.\n           05  R-cnt            PIC ZZZZ9.\n           05  S-cnt            PIC ZZZZ9.\n           05  T-cnt            PIC ZZZZ9.\n           05  U-cnt            PIC ZZZZ9.\n           05  V-cnt            PIC ZZZZ9.\n           05  W-cnt            PIC ZZZZ9.\n           05  X-cnt            PIC ZZZZ9.\n           05  Y-cnt            PIC ZZZZ9.\n           05  Z-cnt            PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  Text-File\n           PERFORM UNTIL Eof = 'T'\n              READ  Text-File\n                    AT END MOVE 'T' to Eof\n              END-READ\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING A-cnt OF Letter-cnt  FOR ALL 'A'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING B-cnt OF Letter-cnt  FOR ALL 'B'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING C-cnt OF Letter-cnt  FOR ALL 'C'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING D-cnt OF Letter-cnt  FOR ALL 'D'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING E-cnt OF Letter-cnt  FOR ALL 'E'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING F-cnt OF Letter-cnt  FOR ALL 'F'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING G-cnt OF Letter-cnt  FOR ALL 'G'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING H-cnt OF Letter-cnt  FOR ALL 'H'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING I-cnt OF Letter-cnt  FOR ALL 'I'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING J-cnt OF Letter-cnt  FOR ALL 'J'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING K-cnt OF Letter-cnt  FOR ALL 'K'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING L-cnt OF Letter-cnt  FOR ALL 'L'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING M-cnt OF Letter-cnt  FOR ALL 'M'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING N-cnt OF Letter-cnt  FOR ALL 'N'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING O-cnt OF Letter-cnt  FOR ALL 'O'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING P-cnt OF Letter-cnt  FOR ALL 'P'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING Q-cnt OF Letter-cnt  FOR ALL 'Q'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING R-cnt OF Letter-cnt  FOR ALL 'R'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING S-cnt OF Letter-cnt  FOR ALL 'S'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING T-cnt OF Letter-cnt  FOR ALL 'T'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING U-cnt OF Letter-cnt  FOR ALL 'U'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING V-cnt OF Letter-cnt  FOR ALL 'V'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING W-cnt OF Letter-cnt  FOR ALL 'W'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING X-cnt OF Letter-cnt  FOR ALL 'X'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING Y-cnt OF Letter-cnt  FOR ALL 'Y'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING Z-cnt OF Letter-cnt  FOR ALL 'Z'\n           END-PERFORM.\n           CLOSE Text-File.\n           MOVE CORRESPONDING Letter-cnt To Letter-disp.\n           DISPLAY 'Letter Frequency Distribution'.\n           DISPLAY '-----------------------------'.\n           DISPLAY 'A\u00a0: ' A-cnt OF Letter-disp '          '\n                   'N\u00a0: ' N-cnt OF Letter-disp.\n           DISPLAY 'B\u00a0: ' B-cnt OF Letter-disp '          '\n                   'O\u00a0: ' O-cnt OF Letter-disp.\n           DISPLAY 'C\u00a0: ' C-cnt OF Letter-disp '          '\n                   'P\u00a0: ' P-cnt OF Letter-disp.\n           DISPLAY 'D\u00a0: ' D-cnt OF Letter-disp '          '\n                   'Q\u00a0: ' Q-cnt OF Letter-disp.\n           DISPLAY 'E\u00a0: ' E-cnt OF Letter-disp '          '\n                   'R\u00a0: ' R-cnt OF Letter-disp.\n           DISPLAY 'F\u00a0: ' F-cnt OF Letter-disp '          '\n                   'S\u00a0: ' S-cnt OF Letter-disp.\n           DISPLAY 'G\u00a0: ' G-cnt OF Letter-disp '          '\n                   'T\u00a0: ' T-cnt OF Letter-disp.\n           DISPLAY 'H\u00a0: ' H-cnt OF Letter-disp '          '\n                   'U\u00a0: ' U-cnt OF Letter-disp.\n           DISPLAY 'I\u00a0: ' I-cnt OF Letter-disp '          '\n                   'V\u00a0: ' V-cnt OF Letter-disp.\n           DISPLAY 'J\u00a0: ' J-cnt OF Letter-disp '          '\n                   'W\u00a0: ' W-cnt OF Letter-disp.\n           DISPLAY 'K\u00a0: ' K-cnt OF Letter-disp '          '\n                   'X\u00a0: ' X-cnt OF Letter-disp.\n           DISPLAY 'L\u00a0: ' L-cnt OF Letter-disp '          '\n                   'Y\u00a0: ' Y-cnt OF Letter-disp.\n           DISPLAY 'M\u00a0: ' M-cnt OF Letter-disp '          '\n                   'Z\u00a0: ' Z-cnt OF Letter-disp.\n           STOP RUN.\n       \n       \n       END-PROGRAM.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nclass Program\n{\n    static SortedDictionary<TItem, int> GetFrequencies<TItem>(IEnumerable<TItem> items)\n    {\n        var dictionary = new SortedDictionary<TItem, int>();\n        foreach (var item in items)\n        {\n            if (dictionary.ContainsKey(item))\n            {\n                dictionary[item]++;\n            }\n            else\n            {\n                dictionary[item] = 1;\n            }\n        }\n        return dictionary;\n    }\n\n    static void Main(string[] arguments)\n    {\n        var file = arguments.FirstOrDefault();\n        if (File.Exists(file))\n        {\n            var text = File.ReadAllText(file);\n            foreach (var entry in GetFrequencies(text))\n            {\n                Console.WriteLine(\"{0}: {1}\", entry.Key, entry.Value);\n            }\n        }\n    }\n}\n"}
{"id": 103692, "name": "Letter frequency", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Letter-Frequency.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  12 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   A rather simplistic program to do the kind of thing\n      **   that COBOL does really well.                \n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Text-File ASSIGN TO \"File.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Text-File\n           DATA RECORD IS Record-Name.\n       01  Record-Name           PIC X(80).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n\n       01  Letter-cnt.\n           05  A-cnt            PIC 9(5)    VALUE 0.\n           05  B-cnt            PIC 9(5)    VALUE 0.\n           05  C-cnt            PIC 9(5)    VALUE 0.\n           05  D-cnt            PIC 9(5)    VALUE 0.\n           05  E-cnt            PIC 9(5)    VALUE 0.\n           05  F-cnt            PIC 9(5)    VALUE 0.\n           05  G-cnt            PIC 9(5)    VALUE 0.\n           05  H-cnt            PIC 9(5)    VALUE 0.\n           05  I-cnt            PIC 9(5)    VALUE 0.\n           05  J-cnt            PIC 9(5)    VALUE 0.\n           05  K-cnt            PIC 9(5)    VALUE 0.\n           05  L-cnt            PIC 9(5)    VALUE 0.\n           05  M-cnt            PIC 9(5)    VALUE 0.\n           05  N-cnt            PIC 9(5)    VALUE 0.\n           05  O-cnt            PIC 9(5)    VALUE 0.\n           05  P-cnt            PIC 9(5)    VALUE 0.\n           05  Q-cnt            PIC 9(5)    VALUE 0.\n           05  R-cnt            PIC 9(5)    VALUE 0.\n           05  S-cnt            PIC 9(5)    VALUE 0.\n           05  T-cnt            PIC 9(5)    VALUE 0.\n           05  U-cnt            PIC 9(5)    VALUE 0.\n           05  V-cnt            PIC 9(5)    VALUE 0.\n           05  W-cnt            PIC 9(5)    VALUE 0.\n           05  X-cnt            PIC 9(5)    VALUE 0.\n           05  Y-cnt            PIC 9(5)    VALUE 0.\n           05  Z-cnt            PIC 9(5)    VALUE 0.\n       \n       01  Letter-disp.\n           05  A-cnt            PIC ZZZZ9.\n           05  B-cnt            PIC ZZZZ9.\n           05  C-cnt            PIC ZZZZ9.\n           05  D-cnt            PIC ZZZZ9.\n           05  E-cnt            PIC ZZZZ9.\n           05  F-cnt            PIC ZZZZ9.\n           05  G-cnt            PIC ZZZZ9.\n           05  H-cnt            PIC ZZZZ9.\n           05  I-cnt            PIC ZZZZ9.\n           05  J-cnt            PIC ZZZZ9.\n           05  K-cnt            PIC ZZZZ9.\n           05  L-cnt            PIC ZZZZ9.\n           05  M-cnt            PIC ZZZZ9.\n           05  N-cnt            PIC ZZZZ9.\n           05  O-cnt            PIC ZZZZ9.\n           05  P-cnt            PIC ZZZZ9.\n           05  Q-cnt            PIC ZZZZ9.\n           05  R-cnt            PIC ZZZZ9.\n           05  S-cnt            PIC ZZZZ9.\n           05  T-cnt            PIC ZZZZ9.\n           05  U-cnt            PIC ZZZZ9.\n           05  V-cnt            PIC ZZZZ9.\n           05  W-cnt            PIC ZZZZ9.\n           05  X-cnt            PIC ZZZZ9.\n           05  Y-cnt            PIC ZZZZ9.\n           05  Z-cnt            PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  Text-File\n           PERFORM UNTIL Eof = 'T'\n              READ  Text-File\n                    AT END MOVE 'T' to Eof\n              END-READ\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING A-cnt OF Letter-cnt  FOR ALL 'A'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING B-cnt OF Letter-cnt  FOR ALL 'B'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING C-cnt OF Letter-cnt  FOR ALL 'C'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING D-cnt OF Letter-cnt  FOR ALL 'D'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING E-cnt OF Letter-cnt  FOR ALL 'E'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING F-cnt OF Letter-cnt  FOR ALL 'F'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING G-cnt OF Letter-cnt  FOR ALL 'G'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING H-cnt OF Letter-cnt  FOR ALL 'H'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING I-cnt OF Letter-cnt  FOR ALL 'I'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING J-cnt OF Letter-cnt  FOR ALL 'J'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING K-cnt OF Letter-cnt  FOR ALL 'K'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING L-cnt OF Letter-cnt  FOR ALL 'L'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING M-cnt OF Letter-cnt  FOR ALL 'M'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING N-cnt OF Letter-cnt  FOR ALL 'N'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING O-cnt OF Letter-cnt  FOR ALL 'O'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING P-cnt OF Letter-cnt  FOR ALL 'P'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING Q-cnt OF Letter-cnt  FOR ALL 'Q'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING R-cnt OF Letter-cnt  FOR ALL 'R'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING S-cnt OF Letter-cnt  FOR ALL 'S'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING T-cnt OF Letter-cnt  FOR ALL 'T'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING U-cnt OF Letter-cnt  FOR ALL 'U'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING V-cnt OF Letter-cnt  FOR ALL 'V'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING W-cnt OF Letter-cnt  FOR ALL 'W'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING X-cnt OF Letter-cnt  FOR ALL 'X'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING Y-cnt OF Letter-cnt  FOR ALL 'Y'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING Z-cnt OF Letter-cnt  FOR ALL 'Z'\n           END-PERFORM.\n           CLOSE Text-File.\n           MOVE CORRESPONDING Letter-cnt To Letter-disp.\n           DISPLAY 'Letter Frequency Distribution'.\n           DISPLAY '-----------------------------'.\n           DISPLAY 'A\u00a0: ' A-cnt OF Letter-disp '          '\n                   'N\u00a0: ' N-cnt OF Letter-disp.\n           DISPLAY 'B\u00a0: ' B-cnt OF Letter-disp '          '\n                   'O\u00a0: ' O-cnt OF Letter-disp.\n           DISPLAY 'C\u00a0: ' C-cnt OF Letter-disp '          '\n                   'P\u00a0: ' P-cnt OF Letter-disp.\n           DISPLAY 'D\u00a0: ' D-cnt OF Letter-disp '          '\n                   'Q\u00a0: ' Q-cnt OF Letter-disp.\n           DISPLAY 'E\u00a0: ' E-cnt OF Letter-disp '          '\n                   'R\u00a0: ' R-cnt OF Letter-disp.\n           DISPLAY 'F\u00a0: ' F-cnt OF Letter-disp '          '\n                   'S\u00a0: ' S-cnt OF Letter-disp.\n           DISPLAY 'G\u00a0: ' G-cnt OF Letter-disp '          '\n                   'T\u00a0: ' T-cnt OF Letter-disp.\n           DISPLAY 'H\u00a0: ' H-cnt OF Letter-disp '          '\n                   'U\u00a0: ' U-cnt OF Letter-disp.\n           DISPLAY 'I\u00a0: ' I-cnt OF Letter-disp '          '\n                   'V\u00a0: ' V-cnt OF Letter-disp.\n           DISPLAY 'J\u00a0: ' J-cnt OF Letter-disp '          '\n                   'W\u00a0: ' W-cnt OF Letter-disp.\n           DISPLAY 'K\u00a0: ' K-cnt OF Letter-disp '          '\n                   'X\u00a0: ' X-cnt OF Letter-disp.\n           DISPLAY 'L\u00a0: ' L-cnt OF Letter-disp '          '\n                   'Y\u00a0: ' Y-cnt OF Letter-disp.\n           DISPLAY 'M\u00a0: ' M-cnt OF Letter-disp '          '\n                   'Z\u00a0: ' Z-cnt OF Letter-disp.\n           STOP RUN.\n       \n       \n       END-PROGRAM.\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\n\npublic class LetterFreq {\n\tpublic static int[] countLetters(String filename) throws IOException{\n\t\tint[] freqs = new int[26];\n\t\tBufferedReader in = new BufferedReader(new FileReader(filename));\n\t\tString line;\n\t\twhile((line = in.readLine()) != null){\n\t\t\tline = line.toUpperCase();\n\t\t\tfor(char ch:line.toCharArray()){\n\t\t\t\tif(Character.isLetter(ch)){\n\t\t\t\t\tfreqs[ch - 'A']++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tin.close();\n\t\treturn freqs;\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tSystem.out.println(Arrays.toString(countLetters(\"filename.txt\")));\n\t}\n}\n"}
{"id": 103693, "name": "Letter frequency", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Letter-Frequency.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  12 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   A rather simplistic program to do the kind of thing\n      **   that COBOL does really well.                \n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Text-File ASSIGN TO \"File.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Text-File\n           DATA RECORD IS Record-Name.\n       01  Record-Name           PIC X(80).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n\n       01  Letter-cnt.\n           05  A-cnt            PIC 9(5)    VALUE 0.\n           05  B-cnt            PIC 9(5)    VALUE 0.\n           05  C-cnt            PIC 9(5)    VALUE 0.\n           05  D-cnt            PIC 9(5)    VALUE 0.\n           05  E-cnt            PIC 9(5)    VALUE 0.\n           05  F-cnt            PIC 9(5)    VALUE 0.\n           05  G-cnt            PIC 9(5)    VALUE 0.\n           05  H-cnt            PIC 9(5)    VALUE 0.\n           05  I-cnt            PIC 9(5)    VALUE 0.\n           05  J-cnt            PIC 9(5)    VALUE 0.\n           05  K-cnt            PIC 9(5)    VALUE 0.\n           05  L-cnt            PIC 9(5)    VALUE 0.\n           05  M-cnt            PIC 9(5)    VALUE 0.\n           05  N-cnt            PIC 9(5)    VALUE 0.\n           05  O-cnt            PIC 9(5)    VALUE 0.\n           05  P-cnt            PIC 9(5)    VALUE 0.\n           05  Q-cnt            PIC 9(5)    VALUE 0.\n           05  R-cnt            PIC 9(5)    VALUE 0.\n           05  S-cnt            PIC 9(5)    VALUE 0.\n           05  T-cnt            PIC 9(5)    VALUE 0.\n           05  U-cnt            PIC 9(5)    VALUE 0.\n           05  V-cnt            PIC 9(5)    VALUE 0.\n           05  W-cnt            PIC 9(5)    VALUE 0.\n           05  X-cnt            PIC 9(5)    VALUE 0.\n           05  Y-cnt            PIC 9(5)    VALUE 0.\n           05  Z-cnt            PIC 9(5)    VALUE 0.\n       \n       01  Letter-disp.\n           05  A-cnt            PIC ZZZZ9.\n           05  B-cnt            PIC ZZZZ9.\n           05  C-cnt            PIC ZZZZ9.\n           05  D-cnt            PIC ZZZZ9.\n           05  E-cnt            PIC ZZZZ9.\n           05  F-cnt            PIC ZZZZ9.\n           05  G-cnt            PIC ZZZZ9.\n           05  H-cnt            PIC ZZZZ9.\n           05  I-cnt            PIC ZZZZ9.\n           05  J-cnt            PIC ZZZZ9.\n           05  K-cnt            PIC ZZZZ9.\n           05  L-cnt            PIC ZZZZ9.\n           05  M-cnt            PIC ZZZZ9.\n           05  N-cnt            PIC ZZZZ9.\n           05  O-cnt            PIC ZZZZ9.\n           05  P-cnt            PIC ZZZZ9.\n           05  Q-cnt            PIC ZZZZ9.\n           05  R-cnt            PIC ZZZZ9.\n           05  S-cnt            PIC ZZZZ9.\n           05  T-cnt            PIC ZZZZ9.\n           05  U-cnt            PIC ZZZZ9.\n           05  V-cnt            PIC ZZZZ9.\n           05  W-cnt            PIC ZZZZ9.\n           05  X-cnt            PIC ZZZZ9.\n           05  Y-cnt            PIC ZZZZ9.\n           05  Z-cnt            PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  Text-File\n           PERFORM UNTIL Eof = 'T'\n              READ  Text-File\n                    AT END MOVE 'T' to Eof\n              END-READ\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING A-cnt OF Letter-cnt  FOR ALL 'A'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING B-cnt OF Letter-cnt  FOR ALL 'B'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING C-cnt OF Letter-cnt  FOR ALL 'C'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING D-cnt OF Letter-cnt  FOR ALL 'D'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING E-cnt OF Letter-cnt  FOR ALL 'E'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING F-cnt OF Letter-cnt  FOR ALL 'F'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING G-cnt OF Letter-cnt  FOR ALL 'G'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING H-cnt OF Letter-cnt  FOR ALL 'H'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING I-cnt OF Letter-cnt  FOR ALL 'I'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING J-cnt OF Letter-cnt  FOR ALL 'J'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING K-cnt OF Letter-cnt  FOR ALL 'K'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING L-cnt OF Letter-cnt  FOR ALL 'L'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING M-cnt OF Letter-cnt  FOR ALL 'M'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING N-cnt OF Letter-cnt  FOR ALL 'N'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING O-cnt OF Letter-cnt  FOR ALL 'O'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING P-cnt OF Letter-cnt  FOR ALL 'P'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING Q-cnt OF Letter-cnt  FOR ALL 'Q'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING R-cnt OF Letter-cnt  FOR ALL 'R'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING S-cnt OF Letter-cnt  FOR ALL 'S'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING T-cnt OF Letter-cnt  FOR ALL 'T'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING U-cnt OF Letter-cnt  FOR ALL 'U'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING V-cnt OF Letter-cnt  FOR ALL 'V'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING W-cnt OF Letter-cnt  FOR ALL 'W'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING X-cnt OF Letter-cnt  FOR ALL 'X'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING Y-cnt OF Letter-cnt  FOR ALL 'Y'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING Z-cnt OF Letter-cnt  FOR ALL 'Z'\n           END-PERFORM.\n           CLOSE Text-File.\n           MOVE CORRESPONDING Letter-cnt To Letter-disp.\n           DISPLAY 'Letter Frequency Distribution'.\n           DISPLAY '-----------------------------'.\n           DISPLAY 'A\u00a0: ' A-cnt OF Letter-disp '          '\n                   'N\u00a0: ' N-cnt OF Letter-disp.\n           DISPLAY 'B\u00a0: ' B-cnt OF Letter-disp '          '\n                   'O\u00a0: ' O-cnt OF Letter-disp.\n           DISPLAY 'C\u00a0: ' C-cnt OF Letter-disp '          '\n                   'P\u00a0: ' P-cnt OF Letter-disp.\n           DISPLAY 'D\u00a0: ' D-cnt OF Letter-disp '          '\n                   'Q\u00a0: ' Q-cnt OF Letter-disp.\n           DISPLAY 'E\u00a0: ' E-cnt OF Letter-disp '          '\n                   'R\u00a0: ' R-cnt OF Letter-disp.\n           DISPLAY 'F\u00a0: ' F-cnt OF Letter-disp '          '\n                   'S\u00a0: ' S-cnt OF Letter-disp.\n           DISPLAY 'G\u00a0: ' G-cnt OF Letter-disp '          '\n                   'T\u00a0: ' T-cnt OF Letter-disp.\n           DISPLAY 'H\u00a0: ' H-cnt OF Letter-disp '          '\n                   'U\u00a0: ' U-cnt OF Letter-disp.\n           DISPLAY 'I\u00a0: ' I-cnt OF Letter-disp '          '\n                   'V\u00a0: ' V-cnt OF Letter-disp.\n           DISPLAY 'J\u00a0: ' J-cnt OF Letter-disp '          '\n                   'W\u00a0: ' W-cnt OF Letter-disp.\n           DISPLAY 'K\u00a0: ' K-cnt OF Letter-disp '          '\n                   'X\u00a0: ' X-cnt OF Letter-disp.\n           DISPLAY 'L\u00a0: ' L-cnt OF Letter-disp '          '\n                   'Y\u00a0: ' Y-cnt OF Letter-disp.\n           DISPLAY 'M\u00a0: ' M-cnt OF Letter-disp '          '\n                   'Z\u00a0: ' Z-cnt OF Letter-disp.\n           STOP RUN.\n       \n       \n       END-PROGRAM.\n", "target": "import collections, sys\n\ndef filecharcount(openfile):\n    return sorted(collections.Counter(c for l in openfile for c in l).items())\n\nf = open(sys.argv[1])\nprint(filecharcount(f))\n"}
{"id": 104088, "name": "Hello world_Graphical", "source": "Translate COBOL to C#:        CLASS-ID ProgramClass.\n       METHOD-ID Main STATIC.\n       PROCEDURE DIVISION.\n           INVOKE TYPE Application::EnableVisualStyles() \n           INVOKE TYPE MessageBox::Show(\"Goodbye, World!\")\n       END METHOD.\n       END CLASS.\n", "target": "using System;\nusing System.Windows.Forms;\n\nclass Program {\n    static void Main(string[] args) {\n        Application.EnableVisualStyles(); \n        MessageBox.Show(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 104090, "name": "Hello world_Graphical", "source": "Translate COBOL to Java:        CLASS-ID ProgramClass.\n       METHOD-ID Main STATIC.\n       PROCEDURE DIVISION.\n           INVOKE TYPE Application::EnableVisualStyles() \n           INVOKE TYPE MessageBox::Show(\"Goodbye, World!\")\n       END METHOD.\n       END CLASS.\n", "target": "import javax.swing.*;\nimport java.awt.*;\n\npublic class OutputSwing {\n\n    public static void main(String[] args) {\n\n        SwingUtilities.invokeLater(new Runnable(){\n            public void run() {\n                JOptionPane.showMessageDialog (null, \"Goodbye, World!\"); \n                JFrame frame = new JFrame(\"Goodbye, World!\");            \n                JTextArea text = new JTextArea(\"Goodbye, World!\");       \n                JButton button = new JButton(\"Goodbye, World!\");         \n\n                frame.setLayout(new FlowLayout());\n                frame.add(button);\n                frame.add(text);\n                frame.pack();\n                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n                frame.setVisible(true);\n            }\n        });\n    }\n}\n"}
{"id": 104091, "name": "Hello world_Graphical", "source": "Translate COBOL to Python:        CLASS-ID ProgramClass.\n       METHOD-ID Main STATIC.\n       PROCEDURE DIVISION.\n           INVOKE TYPE Application::EnableVisualStyles() \n           INVOKE TYPE MessageBox::Show(\"Goodbye, World!\")\n       END METHOD.\n       END CLASS.\n", "target": "import bpy\n\n\nbpy.data.objects['Cube'].select_set(True)\n\n\nbpy.ops.object.delete(True)\n  \n\nbpy.data.curves.new(type=\"FONT\", name=\"Font Curve\").body = \"Hello World\"\nfont_obj = bpy.data.objects.new(name=\"Font Object\", object_data=bpy.data.curves[\"Font Curve\"])\nbpy.context.scene.collection.objects.link(font_obj)\n        \n\nbpy.context.scene.camera.location = (2.5,0.3,10)\n\n\nbpy.context.scene.camera.rotation_euler = (0,0,0)\n\n\narea = next(area for area in bpy.context.screen.areas if area.type == 'VIEW_3D')\narea.spaces[0].region_3d.view_perspective = 'CAMERA'\n"}
{"id": 104373, "name": "Search a list", "source": "Translate COBOL to C#: \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Search-List.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  haystack-area.\n           78  Haystack-Size VALUE 10.\n           03  haystack-data.\n               05  FILLER     PIC X(7) VALUE \"Zig\".\n               05  FILLER     PIC X(7) VALUE \"Zag\".\n               05  FILLER     PIC X(7) VALUE \"Wally\".\n               05  FILLER     PIC X(7) VALUE \"Ronald\".\n               05  FILLER     PIC X(7) VALUE \"Bush\".\n               05  FILLER     PIC X(7) VALUE \"Krusty\".\n               05  FILLER     PIC X(7) VALUE \"Charlie\".\n               05  FILLER     PIC X(7) VALUE \"Bush\".\n               05  FILLER     PIC X(7) VALUE \"Boz\".\n               05  FILLER     PIC X(7) VALUE \"Zag\".\n\n           03  haystack-table REDEFINES haystack-data.\n               05  haystack   PIC X(7) OCCURS Haystack-Size TIMES\n                   INDEXED BY haystack-index.\n\n       01  needle             PIC X(7).\n\n       PROCEDURE DIVISION.\n       main.\n           MOVE \"Bush\" TO needle\n           PERFORM find-needle\n\n           MOVE \"Goofy\" TO needle\n           PERFORM find-needle\n\n*          \n           MOVE \"Bush\" TO needle\n           PERFORM find-last-of-needle\n           \n           GOBACK\n           .\n\n       find-needle.\n           SEARCH haystack\n               AT END\n                   DISPLAY needle \" not found.\"\n\n               WHEN haystack (haystack-index) = needle\n                   DISPLAY \"Found \" needle \" at \" haystack-index \".\"\n           END-SEARCH\n           .\n\n       find-last-of-needle.\n           PERFORM VARYING haystack-index FROM Haystack-Size BY -1\n               UNTIL haystack-index = 0\n               OR haystack (haystack-index) = needle\n           END-PERFORM\n\n           IF haystack-index = 0\n               DISPLAY needle \" not found.\"\n           ELSE\n               DISPLAY \"Found last of \" needle \" at \" haystack-index \".\"\n           END-IF\n           .\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Program {\n    static void Main(string[] args) {\n        List<string> haystack = new List<string>() { \"Zig\", \"Zag\", \"Wally\", \"Ronald\", \"Bush\", \"Krusty\", \"Charlie\", \"Bush\", \"Bozo\" };\n\n        foreach (string needle in new string[] { \"Washington\", \"Bush\" }) {\n            int index = haystack.IndexOf(needle);\n            \n            if (index < 0) Console.WriteLine(\"{0} is not in haystack\",needle);                \n            else Console.WriteLine(\"{0} {1}\",index,needle);\n        }\n    }\n}\n"}
{"id": 104375, "name": "Search a list", "source": "Translate COBOL to Java: \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Search-List.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  haystack-area.\n           78  Haystack-Size VALUE 10.\n           03  haystack-data.\n               05  FILLER     PIC X(7) VALUE \"Zig\".\n               05  FILLER     PIC X(7) VALUE \"Zag\".\n               05  FILLER     PIC X(7) VALUE \"Wally\".\n               05  FILLER     PIC X(7) VALUE \"Ronald\".\n               05  FILLER     PIC X(7) VALUE \"Bush\".\n               05  FILLER     PIC X(7) VALUE \"Krusty\".\n               05  FILLER     PIC X(7) VALUE \"Charlie\".\n               05  FILLER     PIC X(7) VALUE \"Bush\".\n               05  FILLER     PIC X(7) VALUE \"Boz\".\n               05  FILLER     PIC X(7) VALUE \"Zag\".\n\n           03  haystack-table REDEFINES haystack-data.\n               05  haystack   PIC X(7) OCCURS Haystack-Size TIMES\n                   INDEXED BY haystack-index.\n\n       01  needle             PIC X(7).\n\n       PROCEDURE DIVISION.\n       main.\n           MOVE \"Bush\" TO needle\n           PERFORM find-needle\n\n           MOVE \"Goofy\" TO needle\n           PERFORM find-needle\n\n*          \n           MOVE \"Bush\" TO needle\n           PERFORM find-last-of-needle\n           \n           GOBACK\n           .\n\n       find-needle.\n           SEARCH haystack\n               AT END\n                   DISPLAY needle \" not found.\"\n\n               WHEN haystack (haystack-index) = needle\n                   DISPLAY \"Found \" needle \" at \" haystack-index \".\"\n           END-SEARCH\n           .\n\n       find-last-of-needle.\n           PERFORM VARYING haystack-index FROM Haystack-Size BY -1\n               UNTIL haystack-index = 0\n               OR haystack (haystack-index) = needle\n           END-PERFORM\n\n           IF haystack-index = 0\n               DISPLAY needle \" not found.\"\n           ELSE\n               DISPLAY \"Found last of \" needle \" at \" haystack-index \".\"\n           END-IF\n           .\n", "target": "import java.util.List;\nimport java.util.Arrays;\n\nList<String> haystack = Arrays.asList(\"Zig\",\"Zag\",\"Wally\",\"Ronald\",\"Bush\",\"Krusty\",\"Charlie\",\"Bush\",\"Bozo\");\n\nfor (String needle : new String[]{\"Washington\",\"Bush\"}) {\n    int index = haystack.indexOf(needle);\n    if (index < 0)\n        System.out.println(needle + \" is not in haystack\");\n    else\n        System.out.println(index + \" \" + needle);\n}\n"}
{"id": 104376, "name": "Search a list", "source": "Translate COBOL to Python: \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Search-List.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  haystack-area.\n           78  Haystack-Size VALUE 10.\n           03  haystack-data.\n               05  FILLER     PIC X(7) VALUE \"Zig\".\n               05  FILLER     PIC X(7) VALUE \"Zag\".\n               05  FILLER     PIC X(7) VALUE \"Wally\".\n               05  FILLER     PIC X(7) VALUE \"Ronald\".\n               05  FILLER     PIC X(7) VALUE \"Bush\".\n               05  FILLER     PIC X(7) VALUE \"Krusty\".\n               05  FILLER     PIC X(7) VALUE \"Charlie\".\n               05  FILLER     PIC X(7) VALUE \"Bush\".\n               05  FILLER     PIC X(7) VALUE \"Boz\".\n               05  FILLER     PIC X(7) VALUE \"Zag\".\n\n           03  haystack-table REDEFINES haystack-data.\n               05  haystack   PIC X(7) OCCURS Haystack-Size TIMES\n                   INDEXED BY haystack-index.\n\n       01  needle             PIC X(7).\n\n       PROCEDURE DIVISION.\n       main.\n           MOVE \"Bush\" TO needle\n           PERFORM find-needle\n\n           MOVE \"Goofy\" TO needle\n           PERFORM find-needle\n\n*          \n           MOVE \"Bush\" TO needle\n           PERFORM find-last-of-needle\n           \n           GOBACK\n           .\n\n       find-needle.\n           SEARCH haystack\n               AT END\n                   DISPLAY needle \" not found.\"\n\n               WHEN haystack (haystack-index) = needle\n                   DISPLAY \"Found \" needle \" at \" haystack-index \".\"\n           END-SEARCH\n           .\n\n       find-last-of-needle.\n           PERFORM VARYING haystack-index FROM Haystack-Size BY -1\n               UNTIL haystack-index = 0\n               OR haystack (haystack-index) = needle\n           END-PERFORM\n\n           IF haystack-index = 0\n               DISPLAY needle \" not found.\"\n           ELSE\n               DISPLAY \"Found last of \" needle \" at \" haystack-index \".\"\n           END-IF\n           .\n", "target": "haystack=[\"Zig\",\"Zag\",\"Wally\",\"Ronald\",\"Bush\",\"Krusty\",\"Charlie\",\"Bush\",\"Bozo\"]\n\nfor needle in (\"Washington\",\"Bush\"):\n  try:\n    print haystack.index(needle), needle\n  except ValueError, value_error:\n    print needle,\"is not in haystack\"\n"}
{"id": 104652, "name": "Terminal control_Cursor positioning", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. cursor-positioning.\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Hello\" AT LINE 6, COL 3\n\n           GOBACK\n           .\n", "target": "static void Main(string[] args)\n{\n    Console.SetCursorPosition(3, 6);\n    Console.Write(\"Hello\");\n}\n"}
{"id": 104653, "name": "Terminal control_Cursor positioning", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. cursor-positioning.\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Hello\" AT LINE 6, COL 3\n\n           GOBACK\n           .\n", "target": "print(\"\\033[6;3HHello\")\n"}
{"id": 105571, "name": "Variables", "source": "Translate COBOL to C#: MOVE 5 TO x\nMOVE FUNCTION SOME-FUNC(x) TO y\nMOVE \"foo\" TO z\nMOVE \"values 1234\" TO group-item\nSET some-index TO 5\n", "target": "int j;\n"}
{"id": 105573, "name": "Variables", "source": "Translate COBOL to Java: MOVE 5 TO x\nMOVE FUNCTION SOME-FUNC(x) TO y\nMOVE \"foo\" TO z\nMOVE \"values 1234\" TO group-item\nSET some-index TO 5\n", "target": "int a;\ndouble b;\nAClassNameHere c;\n"}
{"id": 105574, "name": "Variables", "source": "Translate COBOL to Python: MOVE 5 TO x\nMOVE FUNCTION SOME-FUNC(x) TO y\nMOVE \"foo\" TO z\nMOVE \"values 1234\" TO group-item\nSET some-index TO 5\n", "target": "\nexample1 = 3\nexample2 = 3.0\nexample3 = True\nexample4 = \"hello\"\n\n\nexample1 = \"goodbye\"\n"}
{"id": 105784, "name": "Sort three variables", "source": "Translate COBOL to C#:        program-id. 3var.\n       data division.\n       working-storage section.\n       1 n binary pic 9(4).\n       1 num pic -(7)9.\n       1 a1 pic x(32) value \"lions, tigers, and\".\n       1 a2 pic x(32) value \"bears, oh my!\".\n       1 a3 pic x(32) value \"(from the \"\"Wizard of OZ\"\")\".\n       1 n1 pic x(8) value \"77444\".\n       1 n2 pic x(8) value \"-12\".\n       1 n3 pic x(8) value \"0\".\n       1 alpha-table.\n        2 alpha-entry occurs 3 pic x(32).\n       1 numeric-table.\n        2 numeric-entry occurs 3 pic s9(8).\n       1 filler value \"x = y = z = \".\n        2 lead-in occurs 3 pic x(4).\n       procedure division.\n       begin.\n           move a1 to alpha-entry (1)\n           move a2 to alpha-entry (2)\n           move a3 to alpha-entry (3)\n           sort alpha-entry ascending alpha-entry\n           perform varying n from 1 by 1\n           until n > 3\n               display lead-in (n) alpha-entry (n)\n           end-perform\n\n           display space\n\n           compute numeric-entry (1) = function numval (n1)\n           compute numeric-entry (2) = function numval (n2)\n           compute numeric-entry (3) = function numval (n3)\n           sort numeric-entry ascending numeric-entry\n           perform varying n from 1 by 1\n           until n > 3\n               move numeric-entry (n) to num\n               display lead-in (n) num\n           end-perform\n\n           stop run\n           .\n       end program 3var.\n", "target": "using System;\npublic class Program\n{\n    public static void Main()\n    {\n        (int x, int y, int z) = (77444, -12, 0);\n\n        \n        if (x > y) (x, y) = (y, x);\n        if (x > z) (x, z) = (z, x);\n        if (y > z) (y, z) = (z, y);\n        Console.WriteLine((x, y, z));\n\n        var (a, b, c) = (\n            \"lions, tigers, and\",\n            \"bears, oh my!\",\n            \"(from the 'Wizard of OZ')\");\n        \n        \n        Sort(ref a, ref b, ref c);\n        Console.WriteLine((a, b, c));\n    }\n    \n    public static void Sort<T>(ref T a, ref T b, ref T c)\n        where T : IComparable<T>\n    {\n        if (a.CompareTo(b) > 0) (a, b) = (b, a);\n        if (a.CompareTo(c) > 0) (a, c) = (c, a);\n        if (b.CompareTo(c) > 0) (b, c) = (c, b);\n    }\n}\n"}
{"id": 105786, "name": "Sort three variables", "source": "Translate COBOL to Java:        program-id. 3var.\n       data division.\n       working-storage section.\n       1 n binary pic 9(4).\n       1 num pic -(7)9.\n       1 a1 pic x(32) value \"lions, tigers, and\".\n       1 a2 pic x(32) value \"bears, oh my!\".\n       1 a3 pic x(32) value \"(from the \"\"Wizard of OZ\"\")\".\n       1 n1 pic x(8) value \"77444\".\n       1 n2 pic x(8) value \"-12\".\n       1 n3 pic x(8) value \"0\".\n       1 alpha-table.\n        2 alpha-entry occurs 3 pic x(32).\n       1 numeric-table.\n        2 numeric-entry occurs 3 pic s9(8).\n       1 filler value \"x = y = z = \".\n        2 lead-in occurs 3 pic x(4).\n       procedure division.\n       begin.\n           move a1 to alpha-entry (1)\n           move a2 to alpha-entry (2)\n           move a3 to alpha-entry (3)\n           sort alpha-entry ascending alpha-entry\n           perform varying n from 1 by 1\n           until n > 3\n               display lead-in (n) alpha-entry (n)\n           end-perform\n\n           display space\n\n           compute numeric-entry (1) = function numval (n1)\n           compute numeric-entry (2) = function numval (n2)\n           compute numeric-entry (3) = function numval (n3)\n           sort numeric-entry ascending numeric-entry\n           perform varying n from 1 by 1\n           until n > 3\n               move numeric-entry (n) to num\n               display lead-in (n) num\n           end-perform\n\n           stop run\n           .\n       end program 3var.\n", "target": "import java.util.Comparator;\nimport java.util.stream.Stream;\n\nclass Box {\n    public int weightKg;\n\n    Box(final int weightKg) {\n        this.weightKg = weightKg;\n    }\n}\n\npublic class Sort3Vars {\n    public static void main(String... args) {\n        int iA = 21;\n        int iB = 11;\n        int iC = 82;\n        int[] sortedInt = Stream.of(iA, iB, iC).sorted().mapToInt(Integer::intValue).toArray();\n        iA = sortedInt[0];\n        iB = sortedInt[1];\n        iC = sortedInt[2];\n        System.out.printf(\"Sorted values: %d %d %d%n\", iA, iB, iC);\n\n        String sA = \"s21\";\n        String sB = \"s11\";\n        String sC = \"s82\";\n        Object[] sortedStr = Stream.of(sA, sB, sC).sorted().toArray();\n        sA = (String) sortedStr[0];\n        sB = (String) sortedStr[1];\n        sC = (String) sortedStr[2];\n        System.out.printf(\"Sorted values: %s %s %s%n\", sA, sB, sC);\n\n        Box bA = new Box(200);\n        Box bB = new Box(12);\n        Box bC = new Box(143);\n        \n        Object[] sortedBox = Stream.of(bA, bB, bC).sorted(Comparator.comparingInt(a -> a.weightKg)).toArray();\n        bA = (Box) sortedBox[0];\n        bB = (Box) sortedBox[1];\n        bC = (Box) sortedBox[2];\n        System.out.printf(\"Sorted Boxes: %dKg %dKg %dKg%n\", bA.weightKg, bB.weightKg, bC.weightKg);\n    }\n}\n"}
{"id": 105787, "name": "Sort three variables", "source": "Translate COBOL to Python:        program-id. 3var.\n       data division.\n       working-storage section.\n       1 n binary pic 9(4).\n       1 num pic -(7)9.\n       1 a1 pic x(32) value \"lions, tigers, and\".\n       1 a2 pic x(32) value \"bears, oh my!\".\n       1 a3 pic x(32) value \"(from the \"\"Wizard of OZ\"\")\".\n       1 n1 pic x(8) value \"77444\".\n       1 n2 pic x(8) value \"-12\".\n       1 n3 pic x(8) value \"0\".\n       1 alpha-table.\n        2 alpha-entry occurs 3 pic x(32).\n       1 numeric-table.\n        2 numeric-entry occurs 3 pic s9(8).\n       1 filler value \"x = y = z = \".\n        2 lead-in occurs 3 pic x(4).\n       procedure division.\n       begin.\n           move a1 to alpha-entry (1)\n           move a2 to alpha-entry (2)\n           move a3 to alpha-entry (3)\n           sort alpha-entry ascending alpha-entry\n           perform varying n from 1 by 1\n           until n > 3\n               display lead-in (n) alpha-entry (n)\n           end-perform\n\n           display space\n\n           compute numeric-entry (1) = function numval (n1)\n           compute numeric-entry (2) = function numval (n2)\n           compute numeric-entry (3) = function numval (n3)\n           sort numeric-entry ascending numeric-entry\n           perform varying n from 1 by 1\n           until n > 3\n               move numeric-entry (n) to num\n               display lead-in (n) num\n           end-perform\n\n           stop run\n           .\n       end program 3var.\n", "target": "\na= raw_input(\"Enter values one by one ..\\n1.\").strip()\nb=raw_input(\"2.\").strip()\nc=raw_input(\"3.\").strip()\nif a>b :\n   a,b = b,a \nif a>c:\n   a,c = c,a \nif b>c:\n   b,c = c,b \nprint(str(a)+\" \"+str(b)+\" \"+str(c))\n"}
{"id": 106796, "name": "Last Friday of each month", "source": "Translate COBOL to C#:        program-id. last-fri.\n       data division.\n       working-storage section.\n       1 wk-date.\n        2 yr pic 9999.\n        2 mo pic 99 value 1.\n        2 da pic 99 value 1.\n       1 rd-date redefines wk-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 friday pic 9(4) value 5.\n       procedure division.\n           display \"Enter a calendar year (1601 thru 9999): \"\n               with no advancing\n           accept yr\n           if yr >= 1601 and <= 9999\n               continue\n           else\n               display \"Invalid year\"\n               stop run\n           end-if\n           perform 12 times\n               move 1 to da\n               add 1 to mo\n               if mo > 12              \n                   move 12 to mo\n                   move 31 to da\n               end-if\n               compute int-date = function\n                   integer-of-date (rd-date)\n               if mo =12 and da = 31   \n                   continue\n               else\n                   subtract 1 from int-date\n               end-if\n               compute rd-date = function\n                   date-of-integer (int-date)\n               compute dow = function mod\n                   ((int-date - 1) 7) + 1\n               compute dow = function mod ((dow - friday) 7)\n               subtract dow from da\n               display yr \"-\" mo \"-\" da\n               add 1 to mo\n           end-perform\n           stop run\n           .\n       end program last-fri.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\n\nnamespace RosettaCode.LastFridaysOfYear\n{\n    internal static class Program\n    {\n        private static IEnumerable<DateTime> LastFridaysOfYear(int year)\n        {\n            for (var month = 1; month <= 12; month++)\n            {\n                var date = new DateTime(year, month, 1).AddMonths(1).AddDays(-1);\n                while (date.DayOfWeek != DayOfWeek.Friday)\n                {\n                    date = date.AddDays(-1);\n                }\n                yield return date;\n            }\n        }\n\n        private static void Main(string[] arguments)\n        {\n            int year;\n            var argument = arguments.FirstOrDefault();\n            if (string.IsNullOrEmpty(argument) || !int.TryParse(argument, out year))\n            {\n                year = DateTime.Today.Year;\n            }\n\n            foreach (var date in LastFridaysOfYear(year))\n            {\n                Console.WriteLine(date.ToString(\"d\", CultureInfo.InvariantCulture));\n            }\n        }\n    }\n}\n"}
{"id": 106797, "name": "Last Friday of each month", "source": "Translate COBOL to C#:        program-id. last-fri.\n       data division.\n       working-storage section.\n       1 wk-date.\n        2 yr pic 9999.\n        2 mo pic 99 value 1.\n        2 da pic 99 value 1.\n       1 rd-date redefines wk-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 friday pic 9(4) value 5.\n       procedure division.\n           display \"Enter a calendar year (1601 thru 9999): \"\n               with no advancing\n           accept yr\n           if yr >= 1601 and <= 9999\n               continue\n           else\n               display \"Invalid year\"\n               stop run\n           end-if\n           perform 12 times\n               move 1 to da\n               add 1 to mo\n               if mo > 12              \n                   move 12 to mo\n                   move 31 to da\n               end-if\n               compute int-date = function\n                   integer-of-date (rd-date)\n               if mo =12 and da = 31   \n                   continue\n               else\n                   subtract 1 from int-date\n               end-if\n               compute rd-date = function\n                   date-of-integer (int-date)\n               compute dow = function mod\n                   ((int-date - 1) 7) + 1\n               compute dow = function mod ((dow - friday) 7)\n               subtract dow from da\n               display yr \"-\" mo \"-\" da\n               add 1 to mo\n           end-perform\n           stop run\n           .\n       end program last-fri.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\n\nnamespace RosettaCode.LastFridaysOfYear\n{\n    internal static class Program\n    {\n        private static IEnumerable<DateTime> LastFridaysOfYear(int year)\n        {\n            for (var month = 1; month <= 12; month++)\n            {\n                var date = new DateTime(year, month, 1).AddMonths(1).AddDays(-1);\n                while (date.DayOfWeek != DayOfWeek.Friday)\n                {\n                    date = date.AddDays(-1);\n                }\n                yield return date;\n            }\n        }\n\n        private static void Main(string[] arguments)\n        {\n            int year;\n            var argument = arguments.FirstOrDefault();\n            if (string.IsNullOrEmpty(argument) || !int.TryParse(argument, out year))\n            {\n                year = DateTime.Today.Year;\n            }\n\n            foreach (var date in LastFridaysOfYear(year))\n            {\n                Console.WriteLine(date.ToString(\"d\", CultureInfo.InvariantCulture));\n            }\n        }\n    }\n}\n"}
{"id": 106800, "name": "Last Friday of each month", "source": "Translate COBOL to Java:        program-id. last-fri.\n       data division.\n       working-storage section.\n       1 wk-date.\n        2 yr pic 9999.\n        2 mo pic 99 value 1.\n        2 da pic 99 value 1.\n       1 rd-date redefines wk-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 friday pic 9(4) value 5.\n       procedure division.\n           display \"Enter a calendar year (1601 thru 9999): \"\n               with no advancing\n           accept yr\n           if yr >= 1601 and <= 9999\n               continue\n           else\n               display \"Invalid year\"\n               stop run\n           end-if\n           perform 12 times\n               move 1 to da\n               add 1 to mo\n               if mo > 12              \n                   move 12 to mo\n                   move 31 to da\n               end-if\n               compute int-date = function\n                   integer-of-date (rd-date)\n               if mo =12 and da = 31   \n                   continue\n               else\n                   subtract 1 from int-date\n               end-if\n               compute rd-date = function\n                   date-of-integer (int-date)\n               compute dow = function mod\n                   ((int-date - 1) 7) + 1\n               compute dow = function mod ((dow - friday) 7)\n               subtract dow from da\n               display yr \"-\" mo \"-\" da\n               add 1 to mo\n           end-perform\n           stop run\n           .\n       end program last-fri.\n", "target": "import java.text.*;\nimport java.util.*;\n\npublic class LastFridays {\n\n    public static void main(String[] args) throws Exception {\n        int year = Integer.parseInt(args[0]);\n        GregorianCalendar c = new GregorianCalendar(year, 0, 1);\n\n        for (String mon : new DateFormatSymbols(Locale.US).getShortMonths()) {\n            if (!mon.isEmpty()) {\n                int totalDaysOfMonth = c.getActualMaximum(Calendar.DAY_OF_MONTH);\n                c.set(Calendar.DAY_OF_MONTH, totalDaysOfMonth);\n\n                int daysToRollBack = (c.get(Calendar.DAY_OF_WEEK) + 1) % 7;\n\n                int day = totalDaysOfMonth - daysToRollBack;\n                c.set(Calendar.DAY_OF_MONTH, day);\n\n                System.out.printf(\"%d %s %d\\n\", year, mon, day);\n\n                c.set(year, c.get(Calendar.MONTH) + 1, 1);\n            }\n        }\n    }\n}\n"}
{"id": 106801, "name": "Last Friday of each month", "source": "Translate COBOL to Java:        program-id. last-fri.\n       data division.\n       working-storage section.\n       1 wk-date.\n        2 yr pic 9999.\n        2 mo pic 99 value 1.\n        2 da pic 99 value 1.\n       1 rd-date redefines wk-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 friday pic 9(4) value 5.\n       procedure division.\n           display \"Enter a calendar year (1601 thru 9999): \"\n               with no advancing\n           accept yr\n           if yr >= 1601 and <= 9999\n               continue\n           else\n               display \"Invalid year\"\n               stop run\n           end-if\n           perform 12 times\n               move 1 to da\n               add 1 to mo\n               if mo > 12              \n                   move 12 to mo\n                   move 31 to da\n               end-if\n               compute int-date = function\n                   integer-of-date (rd-date)\n               if mo =12 and da = 31   \n                   continue\n               else\n                   subtract 1 from int-date\n               end-if\n               compute rd-date = function\n                   date-of-integer (int-date)\n               compute dow = function mod\n                   ((int-date - 1) 7) + 1\n               compute dow = function mod ((dow - friday) 7)\n               subtract dow from da\n               display yr \"-\" mo \"-\" da\n               add 1 to mo\n           end-perform\n           stop run\n           .\n       end program last-fri.\n", "target": "import java.text.*;\nimport java.util.*;\n\npublic class LastFridays {\n\n    public static void main(String[] args) throws Exception {\n        int year = Integer.parseInt(args[0]);\n        GregorianCalendar c = new GregorianCalendar(year, 0, 1);\n\n        for (String mon : new DateFormatSymbols(Locale.US).getShortMonths()) {\n            if (!mon.isEmpty()) {\n                int totalDaysOfMonth = c.getActualMaximum(Calendar.DAY_OF_MONTH);\n                c.set(Calendar.DAY_OF_MONTH, totalDaysOfMonth);\n\n                int daysToRollBack = (c.get(Calendar.DAY_OF_WEEK) + 1) % 7;\n\n                int day = totalDaysOfMonth - daysToRollBack;\n                c.set(Calendar.DAY_OF_MONTH, day);\n\n                System.out.printf(\"%d %s %d\\n\", year, mon, day);\n\n                c.set(year, c.get(Calendar.MONTH) + 1, 1);\n            }\n        }\n    }\n}\n"}
{"id": 106802, "name": "Last Friday of each month", "source": "Translate COBOL to Python:        program-id. last-fri.\n       data division.\n       working-storage section.\n       1 wk-date.\n        2 yr pic 9999.\n        2 mo pic 99 value 1.\n        2 da pic 99 value 1.\n       1 rd-date redefines wk-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 friday pic 9(4) value 5.\n       procedure division.\n           display \"Enter a calendar year (1601 thru 9999): \"\n               with no advancing\n           accept yr\n           if yr >= 1601 and <= 9999\n               continue\n           else\n               display \"Invalid year\"\n               stop run\n           end-if\n           perform 12 times\n               move 1 to da\n               add 1 to mo\n               if mo > 12              \n                   move 12 to mo\n                   move 31 to da\n               end-if\n               compute int-date = function\n                   integer-of-date (rd-date)\n               if mo =12 and da = 31   \n                   continue\n               else\n                   subtract 1 from int-date\n               end-if\n               compute rd-date = function\n                   date-of-integer (int-date)\n               compute dow = function mod\n                   ((int-date - 1) 7) + 1\n               compute dow = function mod ((dow - friday) 7)\n               subtract dow from da\n               display yr \"-\" mo \"-\" da\n               add 1 to mo\n           end-perform\n           stop run\n           .\n       end program last-fri.\n", "target": "import calendar\n\ndef last_fridays(year):\n    for month in range(1, 13):\n        last_friday = max(week[calendar.FRIDAY]\n            for week in calendar.monthcalendar(year, month))\n        print('{:4d}-{:02d}-{:02d}'.format(year, month, last_friday))\n"}
{"id": 106803, "name": "Last Friday of each month", "source": "Translate COBOL to Python:        program-id. last-fri.\n       data division.\n       working-storage section.\n       1 wk-date.\n        2 yr pic 9999.\n        2 mo pic 99 value 1.\n        2 da pic 99 value 1.\n       1 rd-date redefines wk-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 friday pic 9(4) value 5.\n       procedure division.\n           display \"Enter a calendar year (1601 thru 9999): \"\n               with no advancing\n           accept yr\n           if yr >= 1601 and <= 9999\n               continue\n           else\n               display \"Invalid year\"\n               stop run\n           end-if\n           perform 12 times\n               move 1 to da\n               add 1 to mo\n               if mo > 12              \n                   move 12 to mo\n                   move 31 to da\n               end-if\n               compute int-date = function\n                   integer-of-date (rd-date)\n               if mo =12 and da = 31   \n                   continue\n               else\n                   subtract 1 from int-date\n               end-if\n               compute rd-date = function\n                   date-of-integer (int-date)\n               compute dow = function mod\n                   ((int-date - 1) 7) + 1\n               compute dow = function mod ((dow - friday) 7)\n               subtract dow from da\n               display yr \"-\" mo \"-\" da\n               add 1 to mo\n           end-perform\n           stop run\n           .\n       end program last-fri.\n", "target": "import calendar\n\ndef last_fridays(year):\n    for month in range(1, 13):\n        last_friday = max(week[calendar.FRIDAY]\n            for week in calendar.monthcalendar(year, month))\n        print('{:4d}-{:02d}-{:02d}'.format(year, month, last_friday))\n"}
{"id": 107138, "name": "Date format", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Date-Format.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  Days-Area.\n           03  Days-Data.\n               05  FILLER PIC X(9) VALUE \"Monday\".\n               05  FILLER PIC X(9) VALUE \"Tuesday\".\n               05  FILLER PIC X(9) VALUE \"Wednesday\".\n               05  FILLER PIC X(9) VALUE \"Thursday\".\n               05  FILLER PIC X(9) VALUE \"Friday\".\n               05  FILLER PIC X(9) VALUE \"Saturday\".\n               05  FILLER PIC X(9) VALUE \"Sunday\".\n\n           03  Days-Values REDEFINES Days-Data.\n               05  Days-Table PIC X(9) OCCURS 7 TIMES.\n\n       01  Months-Area.\n           03  Months-Data.\n               05  FILLER PIC X(9) VALUE \"January\".\n               05  FILLER PIC X(9) VALUE \"February\".\n               05  FILLER PIC X(9) VALUE \"March\".\n               05  FILLER PIC X(9) VALUE \"April\".\n               05  FILLER PIC X(9) VALUE \"May\".\n               05  FILLER PIC X(9) VALUE \"June\".\n               05  FILLER PIC X(9) VALUE \"July\".\n               05  FILLER PIC X(9) VALUE \"August\".\n               05  FILLER PIC X(9) VALUE \"September\".\n               05  FILLER PIC X(9) VALUE \"October\".\n               05  FILLER PIC X(9) VALUE \"November\".\n               05  FILLER PIC X(9) VALUE \"December\".\n              \n           03  Months-Values REDEFINES Months-Data.\n               05  Months-Table PIC X(9) OCCURS 12 TIMES.\n\n       01  Current-Date-Str.\n           03  Current-Year     PIC X(4).\n           03  Current-Month    PIC X(2).\n           03  Current-Day      PIC X(2).\n\n       01  Current-Day-Of-Week  PIC 9.\n\n       PROCEDURE DIVISION.\n           MOVE FUNCTION CURRENT-DATE (1:8) TO Current-Date-Str\n           \n           DISPLAY Current-Year \"-\" Current-Month \"-\" Current-Day\n\n           ACCEPT Current-Day-Of-Week FROM DAY-OF-WEEK\n           DISPLAY\n               FUNCTION TRIM(\n                   Days-Table (FUNCTION NUMVAL(Current-Day-Of-Week)))\n               \", \"\n               FUNCTION TRIM(\n                   Months-Table (FUNCTION NUMVAL(Current-Month)))\n               \" \"\n               Current-Day\n               \", \"\n               Current-Year\n           END-DISPLAY\n\n           GOBACK\n           .\n", "target": "using System;\n\nnamespace RosettaCode.DateFormat\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            DateTime today = DateTime.Now.Date;\n            Console.WriteLine(today.ToString(\"yyyy-MM-dd\"));\n            Console.WriteLine(today.ToString(\"dddd, MMMMM d, yyyy\"));\n        }\n    }\n}\n"}
{"id": 107140, "name": "Date format", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Date-Format.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  Days-Area.\n           03  Days-Data.\n               05  FILLER PIC X(9) VALUE \"Monday\".\n               05  FILLER PIC X(9) VALUE \"Tuesday\".\n               05  FILLER PIC X(9) VALUE \"Wednesday\".\n               05  FILLER PIC X(9) VALUE \"Thursday\".\n               05  FILLER PIC X(9) VALUE \"Friday\".\n               05  FILLER PIC X(9) VALUE \"Saturday\".\n               05  FILLER PIC X(9) VALUE \"Sunday\".\n\n           03  Days-Values REDEFINES Days-Data.\n               05  Days-Table PIC X(9) OCCURS 7 TIMES.\n\n       01  Months-Area.\n           03  Months-Data.\n               05  FILLER PIC X(9) VALUE \"January\".\n               05  FILLER PIC X(9) VALUE \"February\".\n               05  FILLER PIC X(9) VALUE \"March\".\n               05  FILLER PIC X(9) VALUE \"April\".\n               05  FILLER PIC X(9) VALUE \"May\".\n               05  FILLER PIC X(9) VALUE \"June\".\n               05  FILLER PIC X(9) VALUE \"July\".\n               05  FILLER PIC X(9) VALUE \"August\".\n               05  FILLER PIC X(9) VALUE \"September\".\n               05  FILLER PIC X(9) VALUE \"October\".\n               05  FILLER PIC X(9) VALUE \"November\".\n               05  FILLER PIC X(9) VALUE \"December\".\n              \n           03  Months-Values REDEFINES Months-Data.\n               05  Months-Table PIC X(9) OCCURS 12 TIMES.\n\n       01  Current-Date-Str.\n           03  Current-Year     PIC X(4).\n           03  Current-Month    PIC X(2).\n           03  Current-Day      PIC X(2).\n\n       01  Current-Day-Of-Week  PIC 9.\n\n       PROCEDURE DIVISION.\n           MOVE FUNCTION CURRENT-DATE (1:8) TO Current-Date-Str\n           \n           DISPLAY Current-Year \"-\" Current-Month \"-\" Current-Day\n\n           ACCEPT Current-Day-Of-Week FROM DAY-OF-WEEK\n           DISPLAY\n               FUNCTION TRIM(\n                   Days-Table (FUNCTION NUMVAL(Current-Day-Of-Week)))\n               \", \"\n               FUNCTION TRIM(\n                   Months-Table (FUNCTION NUMVAL(Current-Month)))\n               \" \"\n               Current-Day\n               \", \"\n               Current-Year\n           END-DISPLAY\n\n           GOBACK\n           .\n", "target": "Datetime dtNow = datetime.now();\nString strDt1 = dtNow.format('yyyy-MM-dd');\nString strDt2 = dtNow.format('EEEE, MMMM dd, yyyy');\nsystem.debug(strDt1); \nsystem.debug(strDt2); \n"}
{"id": 107141, "name": "Date format", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Date-Format.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  Days-Area.\n           03  Days-Data.\n               05  FILLER PIC X(9) VALUE \"Monday\".\n               05  FILLER PIC X(9) VALUE \"Tuesday\".\n               05  FILLER PIC X(9) VALUE \"Wednesday\".\n               05  FILLER PIC X(9) VALUE \"Thursday\".\n               05  FILLER PIC X(9) VALUE \"Friday\".\n               05  FILLER PIC X(9) VALUE \"Saturday\".\n               05  FILLER PIC X(9) VALUE \"Sunday\".\n\n           03  Days-Values REDEFINES Days-Data.\n               05  Days-Table PIC X(9) OCCURS 7 TIMES.\n\n       01  Months-Area.\n           03  Months-Data.\n               05  FILLER PIC X(9) VALUE \"January\".\n               05  FILLER PIC X(9) VALUE \"February\".\n               05  FILLER PIC X(9) VALUE \"March\".\n               05  FILLER PIC X(9) VALUE \"April\".\n               05  FILLER PIC X(9) VALUE \"May\".\n               05  FILLER PIC X(9) VALUE \"June\".\n               05  FILLER PIC X(9) VALUE \"July\".\n               05  FILLER PIC X(9) VALUE \"August\".\n               05  FILLER PIC X(9) VALUE \"September\".\n               05  FILLER PIC X(9) VALUE \"October\".\n               05  FILLER PIC X(9) VALUE \"November\".\n               05  FILLER PIC X(9) VALUE \"December\".\n              \n           03  Months-Values REDEFINES Months-Data.\n               05  Months-Table PIC X(9) OCCURS 12 TIMES.\n\n       01  Current-Date-Str.\n           03  Current-Year     PIC X(4).\n           03  Current-Month    PIC X(2).\n           03  Current-Day      PIC X(2).\n\n       01  Current-Day-Of-Week  PIC 9.\n\n       PROCEDURE DIVISION.\n           MOVE FUNCTION CURRENT-DATE (1:8) TO Current-Date-Str\n           \n           DISPLAY Current-Year \"-\" Current-Month \"-\" Current-Day\n\n           ACCEPT Current-Day-Of-Week FROM DAY-OF-WEEK\n           DISPLAY\n               FUNCTION TRIM(\n                   Days-Table (FUNCTION NUMVAL(Current-Day-Of-Week)))\n               \", \"\n               FUNCTION TRIM(\n                   Months-Table (FUNCTION NUMVAL(Current-Month)))\n               \" \"\n               Current-Day\n               \", \"\n               Current-Year\n           END-DISPLAY\n\n           GOBACK\n           .\n", "target": "import datetime\ntoday = datetime.date.today()\n\ntoday.isoformat()\n\ntoday.strftime(\"%A, %B %d, %Y\")\n\n\n\"The date is {0:%A, %B %d, %Y}\".format(d)\n\n\"The date is {date:%A, %B %d, %Y}\".format(date=d)\n\nf\"The date is {d:%A, %B %d, %Y}\"\n"}
{"id": 107969, "name": "Loops_For with a specified step", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Display-Odd-Nums.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  I PIC 99.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING I FROM 1 BY 2 UNTIL 10 < I\n               DISPLAY I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\n \nclass Program {\n    static void Main(string[] args) {    \n        for (int i = 2; i <= 8; i+= 2) {        \n            Console.Write(\"{0}, \", i);\n        }\n\n        Console.WriteLine(\"who do we appreciate?\");\n    }\n}\n"}
{"id": 107971, "name": "Loops_For with a specified step", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Display-Odd-Nums.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  I PIC 99.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING I FROM 1 BY 2 UNTIL 10 < I\n               DISPLAY I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "for(int i = 2; i <= 8;i += 2){\n   System.out.print(i + \", \");\n}\nSystem.out.println(\"who do we appreciate?\");\n"}
{"id": 107972, "name": "Loops_For with a specified step", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Display-Odd-Nums.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  I PIC 99.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING I FROM 1 BY 2 UNTIL 10 < I\n               DISPLAY I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "for i in xrange(2, 9, 2):\n    print \"%d,\" % i,\nprint \"who do we appreciate?\"\n"}
{"id": 108879, "name": "Loops_Break", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Random-Nums.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Num  PIC Z9.\n\n       PROCEDURE DIVISION.\n       Main.\n           PERFORM FOREVER\n               PERFORM Generate-And-Display-Num\n\n               IF Num = 10\n                   EXIT PERFORM\n               ELSE\n                   PERFORM Generate-And-Display-Num\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n\n       Generate-And-Display-Num.\n           COMPUTE Num =  FUNCTION REM(FUNCTION RANDOM * 100, 20)\n           DISPLAY Num\n           .\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        Random random = new Random();\n        while (true)\n        {\n            int a = random.Next(20);\n            Console.WriteLine(a);\n            if (a == 10)\n                break;\n            int b = random.Next(20)\n            Console.WriteLine(b);\n        }\n           \n        Console.ReadLine();\n    }       \n}\n"}
{"id": 108881, "name": "Loops_Break", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Random-Nums.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Num  PIC Z9.\n\n       PROCEDURE DIVISION.\n       Main.\n           PERFORM FOREVER\n               PERFORM Generate-And-Display-Num\n\n               IF Num = 10\n                   EXIT PERFORM\n               ELSE\n                   PERFORM Generate-And-Display-Num\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n\n       Generate-And-Display-Num.\n           COMPUTE Num =  FUNCTION REM(FUNCTION RANDOM * 100, 20)\n           DISPLAY Num\n           .\n", "target": "import java.util.Random;\n\nRandom rand = new Random();\nwhile(true){\n    int a = rand.nextInt(20);\n    System.out.println(a);\n    if(a == 10) break;\n    int b = rand.nextInt(20);\n    System.out.println(b);\n}\n"}
{"id": 108882, "name": "Loops_Break", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Random-Nums.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Num  PIC Z9.\n\n       PROCEDURE DIVISION.\n       Main.\n           PERFORM FOREVER\n               PERFORM Generate-And-Display-Num\n\n               IF Num = 10\n                   EXIT PERFORM\n               ELSE\n                   PERFORM Generate-And-Display-Num\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n\n       Generate-And-Display-Num.\n           COMPUTE Num =  FUNCTION REM(FUNCTION RANDOM * 100, 20)\n           DISPLAY Num\n           .\n", "target": "from random import randrange\n\nwhile True:\n    a = randrange(20)\n    print(a)\n    if a == 10:\n        break\n    b = randrange(20)\n    print(b)\n"}
{"id": 109558, "name": "Factors of an integer", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. FACTORS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  CALCULATING.\n           03  NUM  USAGE BINARY-LONG VALUE ZERO.\n           03  LIM  USAGE BINARY-LONG VALUE ZERO.\n           03  CNT  USAGE BINARY-LONG VALUE ZERO.\n           03  DIV  USAGE BINARY-LONG VALUE ZERO.\n           03  REM  USAGE BINARY-LONG VALUE ZERO.\n           03  ZRS  USAGE BINARY-SHORT VALUE ZERO.\n\n       01  DISPLAYING.\n           03  DIS  PIC 9(10) USAGE DISPLAY.\n\n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"Factors of? \" WITH NO ADVANCING\n           ACCEPT NUM\n           DIVIDE NUM BY 2 GIVING LIM.\n\n           PERFORM VARYING CNT FROM 1 BY 1 UNTIL CNT > LIM\n               DIVIDE NUM BY CNT GIVING DIV REMAINDER REM\n               IF REM = 0\n                   MOVE CNT TO DIS\n                   PERFORM SHODIS\n               END-IF\n           END-PERFORM.\n\n           MOVE NUM TO DIS.\n           PERFORM SHODIS.\n           STOP RUN.\n\n       SHODIS.\n           MOVE ZERO TO ZRS.\n           INSPECT DIS TALLYING ZRS FOR LEADING ZERO.\n           DISPLAY DIS(ZRS + 1:)\n           EXIT PARAGRAPH.\n\n       END PROGRAM FACTORS.\n", "target": "static void Main (string[] args) {\n    do {\n        Console.WriteLine (\"Number:\");\n        Int64 p = 0;\n        do {\n            try {\n                p = Convert.ToInt64 (Console.ReadLine ());\n                break;\n            } catch (Exception) { }\n\n        } while (true);\n\n        Console.WriteLine (\"For 1 through \" + ((int) Math.Sqrt (p)).ToString () + \"\");\n        for (int x = 1; x <= (int) Math.Sqrt (p); x++) {\n            if (p % x == 0)\n                Console.WriteLine (\"Found: \" + x.ToString () + \". \" + p.ToString () + \" / \" + x.ToString () + \" = \" + (p / x).ToString ());\n        }\n\n        Console.WriteLine (\"Done.\");\n    } while (true);\n}\n"}
{"id": 109560, "name": "Factors of an integer", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. FACTORS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  CALCULATING.\n           03  NUM  USAGE BINARY-LONG VALUE ZERO.\n           03  LIM  USAGE BINARY-LONG VALUE ZERO.\n           03  CNT  USAGE BINARY-LONG VALUE ZERO.\n           03  DIV  USAGE BINARY-LONG VALUE ZERO.\n           03  REM  USAGE BINARY-LONG VALUE ZERO.\n           03  ZRS  USAGE BINARY-SHORT VALUE ZERO.\n\n       01  DISPLAYING.\n           03  DIS  PIC 9(10) USAGE DISPLAY.\n\n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"Factors of? \" WITH NO ADVANCING\n           ACCEPT NUM\n           DIVIDE NUM BY 2 GIVING LIM.\n\n           PERFORM VARYING CNT FROM 1 BY 1 UNTIL CNT > LIM\n               DIVIDE NUM BY CNT GIVING DIV REMAINDER REM\n               IF REM = 0\n                   MOVE CNT TO DIS\n                   PERFORM SHODIS\n               END-IF\n           END-PERFORM.\n\n           MOVE NUM TO DIS.\n           PERFORM SHODIS.\n           STOP RUN.\n\n       SHODIS.\n           MOVE ZERO TO ZRS.\n           INSPECT DIS TALLYING ZRS FOR LEADING ZERO.\n           DISPLAY DIS(ZRS + 1:)\n           EXIT PARAGRAPH.\n\n       END PROGRAM FACTORS.\n", "target": "public static TreeSet<Long> factors(long n)\n{\n TreeSet<Long> factors = new TreeSet<Long>();\n factors.add(n);\n factors.add(1L);\n for(long test = n - 1; test >= Math.sqrt(n); test--)\n  if(n % test == 0)\n  {\n   factors.add(test);\n   factors.add(n / test);\n  }\n return factors;\n}\n"}
{"id": 109561, "name": "Factors of an integer", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. FACTORS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  CALCULATING.\n           03  NUM  USAGE BINARY-LONG VALUE ZERO.\n           03  LIM  USAGE BINARY-LONG VALUE ZERO.\n           03  CNT  USAGE BINARY-LONG VALUE ZERO.\n           03  DIV  USAGE BINARY-LONG VALUE ZERO.\n           03  REM  USAGE BINARY-LONG VALUE ZERO.\n           03  ZRS  USAGE BINARY-SHORT VALUE ZERO.\n\n       01  DISPLAYING.\n           03  DIS  PIC 9(10) USAGE DISPLAY.\n\n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"Factors of? \" WITH NO ADVANCING\n           ACCEPT NUM\n           DIVIDE NUM BY 2 GIVING LIM.\n\n           PERFORM VARYING CNT FROM 1 BY 1 UNTIL CNT > LIM\n               DIVIDE NUM BY CNT GIVING DIV REMAINDER REM\n               IF REM = 0\n                   MOVE CNT TO DIS\n                   PERFORM SHODIS\n               END-IF\n           END-PERFORM.\n\n           MOVE NUM TO DIS.\n           PERFORM SHODIS.\n           STOP RUN.\n\n       SHODIS.\n           MOVE ZERO TO ZRS.\n           INSPECT DIS TALLYING ZRS FOR LEADING ZERO.\n           DISPLAY DIS(ZRS + 1:)\n           EXIT PARAGRAPH.\n\n       END PROGRAM FACTORS.\n", "target": ">>> def factors(n):\n      return [i for i in range(1, n + 1) if not n%i]\n"}
{"id": 110271, "name": "Anagrams_Deranged anagrams", "source": "Translate COBOL to C#:       ******************************************************************\n      * COBOL solution to Anagrams Deranged challange\n      * The program was run on OpenCobolIDE\n      * Input data is stored in file 'Anagrams.txt' on my PC\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. DERANGED.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT IN-FILE ASSIGN TO 'C:\\Both\\Rosetta\\Anagrams.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD IN-FILE.\n       01 IN-RECORD                PIC X(22).\n\n       WORKING-STORAGE SECTION.\n       01  SWITCHES.\n           05 WS-EOF               PIC X       VALUE 'N'.\n           05 WS-FND               PIC X       VALUE 'N'.\n           05 WS-EXIT              PIC X       VALUE 'N'.\n\n       01 COUNTERS.\n           05 WS-TOT-RECS          PIC 9(5)    COMP-3  VALUE 0.\n           05 WS-SEL-RECS          PIC 9(5)    COMP-3  VALUE 0.\n           05 WT-REC-NBR           PIC 9(5)    COMP-3  VALUE 0.\n\n      * Extra byte to guarentee a space at end - needed in sort logic.\n       01 WS-WORD-TEMP             PIC X(23).\n       01 FILLER REDEFINES WS-WORD-TEMP.\n           05   WS-LETTER  OCCURS 23 TIMES PIC X.\n       77  WS-LETTER-HLD           PIC X.\n\n       77  WS-WORD-IN              PIC X(22).\n       77  WS-WORD-KEY             PIC X(22).\n\n       01 WS-WORD-TABLE.\n           05 WT-RECORD OCCURS 0 to 24000 TIMES\n                   DEPENDING ON WT-REC-NBR\n                   DESCENDING KEY IS WT-WORD-LEN\n                   INDEXED BY WT-IDX.\n               10 WT-WORD-KEY         PIC X(22).\n               10 WT-WORD-LEN         PIC 9(2).\n               10 WT-ANAGRAM-CNT      PIC 9(5) COMP-3.\n               10 WT-ANAGRAMS OCCURS 6 TIMES.\n                   15 WT-ANAGRAM      PIC X(22).\n\n       01 WS-WORD-TEMP1             PIC X(22).\n       01 FILLER REDEFINES WS-WORD-TEMP1.\n           05   WS-LETTER1  OCCURS 22 TIMES PIC X.\n\n       01 WS-WORD-TEMP2             PIC X(22).\n       01 FILLER REDEFINES WS-WORD-TEMP2.\n           05   WS-LETTER2  OCCURS 22 TIMES PIC X.\n\n       77  WS-I                    PIC 99999  COMP-3.\n       77  WS-J                    PIC 99999  COMP-3.\n       77  WS-K                    PIC 99999  COMP-3.\n       77  WS-L                    PIC 99999  COMP-3.\n       77  WS-BEG                  PIC 99999  COMP-3.\n       77  WS-MAX                  PIC 99999  COMP-3.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           PERFORM 100-INITIALIZE.\n           PERFORM 200-PROCESS-RECORD\n               UNTIL WS-EOF = 'Y'.\n           SORT WT-RECORD ON DESCENDING KEY WT-WORD-LEN.\n           PERFORM 500-FIND-DERANGED.\n           PERFORM 900-TERMINATE.\n           STOP RUN.\n\n       100-INITIALIZE.\n           OPEN INPUT IN-FILE.\n           PERFORM 150-READ-RECORD.\n\n       150-READ-RECORD.\n           READ IN-FILE INTO WS-WORD-IN\n               AT END\n                   MOVE 'Y' TO WS-EOF\n               NOT AT END\n                   COMPUTE WS-TOT-RECS = WS-TOT-RECS + 1\n           END-READ.\n\n       200-PROCESS-RECORD.\n           IF WS-WORD-IN IS ALPHABETIC\n               COMPUTE WS-SEL-RECS = WS-SEL-RECS + 1\n               MOVE WS-WORD-IN TO WS-WORD-TEMP\n               PERFORM 300-SORT-WORD\n               MOVE WS-WORD-TEMP TO WS-WORD-KEY\n               PERFORM 400-ADD-TO-TABLE\n           END-IF.\n\n           PERFORM 150-READ-RECORD.\n\n      * bubble sort:\n       300-SORT-WORD.\n           PERFORM VARYING WS-MAX FROM 1 BY 1\n               UNTIL WS-LETTER(WS-MAX) = SPACE\n           END-PERFORM.\n\n           PERFORM VARYING WS-I FROM 1 BY 1 UNTIL WS-I = WS-MAX\n               PERFORM VARYING WS-J FROM WS-I BY 1\n                 UNTIL WS-J > WS-MAX - 1\n                   IF WS-LETTER(WS-J) < WS-LETTER(WS-I) THEN\n                       MOVE WS-LETTER(WS-I)  TO WS-LETTER-HLD\n                       MOVE WS-LETTER(WS-J)  TO WS-LETTER(WS-I)\n                       MOVE WS-LETTER-HLD    TO WS-LETTER(WS-J)\n                   END-IF\n               END-PERFORM\n           END-PERFORM.\n\n       400-ADD-TO-TABLE.\n           SET WT-IDX TO 1.\n           SEARCH WT-RECORD\n               AT END\n                   PERFORM 420-ADD-RECORD\n               WHEN WT-WORD-KEY(WT-IDX) = WS-WORD-KEY\n                   PERFORM 440-UPDATE-RECORD\n           END-SEARCH.\n\n       420-ADD-RECORD.\n           ADD 1 To WT-REC-NBR.\n           MOVE WS-WORD-KEY TO WT-WORD-KEY(WT-REC-NBR).\n           COMPUTE WT-WORD-LEN(WT-REC-NBR) = WS-MAX - 1.\n           MOVE 1 TO WT-ANAGRAM-CNT(WT-REC-NBR).\n           MOVE WS-WORD-IN TO\n               WT-ANAGRAM(WT-REC-NBR, WT-ANAGRAM-CNT(WT-REC-NBR)).\n\n       440-UPDATE-RECORD.\n           ADD 1 TO WT-ANAGRAM-CNT(WT-IDX).\n           MOVE WS-WORD-IN TO\n               WT-ANAGRAM(WT-IDX, WT-ANAGRAM-CNT(WT-IDX)).\n\n       500-FIND-DERANGED.\n           PERFORM VARYING WS-I FROM 1 BY 1\n             UNTIL WS-I > WT-REC-NBR OR WS-FND = 'Y'\n               PERFORM VARYING WS-J FROM 1 BY 1\n                 UNTIL WS-J > WT-ANAGRAM-CNT(WS-I) - 1 OR WS-FND = 'Y'\n                   COMPUTE WS-BEG = WS-J + 1\n                   PERFORM VARYING WS-K FROM WS-BEG BY 1\n                     UNTIL WS-K > WT-ANAGRAM-CNT(WS-I) OR WS-FND = 'Y'\n                       MOVE WT-ANAGRAM(WS-I, WS-J) TO WS-WORD-TEMP1\n                       MOVE WT-ANAGRAM(WS-I, WS-K) To WS-WORD-TEMP2\n                       PERFORM 650-CHECK-DERANGED\n                   END-PERFORM\n               END-PERFORM\n           END-PERFORM.\n\n           650-CHECK-DERANGED.\n               MOVE 'N' TO WS-EXIT.\n               PERFORM VARYING WS-L FROM 1 BY 1\n                   UNTIL WS-L > WT-WORD-LEN(WS-I) OR WS-EXIT = 'Y'\n                       IF WS-LETTER1(WS-L) = WS-LETTER2(WS-L)\n                           MOVE 'Y' TO WS-EXIT\n               END-PERFORM.\n               IF WS-EXIT = 'N'\n                   DISPLAY WS-WORD-TEMP1(1:WT-WORD-LEN(WS-I))\n                   ' '\n                   WS-WORD-TEMP2\n                   MOVE 'Y' TO WS-FND\n               END-IF.\n\n       900-TERMINATE.\n           DISPLAY 'RECORDS READ: ' WS-TOT-RECS.\n           DISPLAY 'RECORDS SELECTED ' WS-SEL-RECS.\n           DISPLAY 'RECORD KEYS: ' WT-REC-NBR.\n           CLOSE IN-FILE.\n\n      \n\n      \n      \n      \n      \n\n      \n      \n", "target": "public static void Main()\n{\n    var lookupTable = File.ReadLines(\"unixdict.txt\").ToLookup(line => AnagramKey(line));\n    var query = from a in lookupTable\n        orderby a.Key.Length descending\n        let deranged = FindDeranged(a)\n        where deranged != null\n        select deranged[0] + \" \" + deranged[1];\n    Console.WriteLine(query.FirstOrDefault());\n}\n\t\nstatic string AnagramKey(string word) => new string(word.OrderBy(c => c).ToArray());\n\t\nstatic string[] FindDeranged(IEnumerable<string> anagrams) => (\n    from first in anagrams\n    from second in anagrams\n    where !second.Equals(first)\n        && Enumerable.Range(0, first.Length).All(i => first[i] != second[i])\n    select new [] { first, second })\n    .FirstOrDefault();\n"}
{"id": 110272, "name": "Anagrams_Deranged anagrams", "source": "Translate COBOL to C#:       ******************************************************************\n      * COBOL solution to Anagrams Deranged challange\n      * The program was run on OpenCobolIDE\n      * Input data is stored in file 'Anagrams.txt' on my PC\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. DERANGED.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT IN-FILE ASSIGN TO 'C:\\Both\\Rosetta\\Anagrams.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD IN-FILE.\n       01 IN-RECORD                PIC X(22).\n\n       WORKING-STORAGE SECTION.\n       01  SWITCHES.\n           05 WS-EOF               PIC X       VALUE 'N'.\n           05 WS-FND               PIC X       VALUE 'N'.\n           05 WS-EXIT              PIC X       VALUE 'N'.\n\n       01 COUNTERS.\n           05 WS-TOT-RECS          PIC 9(5)    COMP-3  VALUE 0.\n           05 WS-SEL-RECS          PIC 9(5)    COMP-3  VALUE 0.\n           05 WT-REC-NBR           PIC 9(5)    COMP-3  VALUE 0.\n\n      * Extra byte to guarentee a space at end - needed in sort logic.\n       01 WS-WORD-TEMP             PIC X(23).\n       01 FILLER REDEFINES WS-WORD-TEMP.\n           05   WS-LETTER  OCCURS 23 TIMES PIC X.\n       77  WS-LETTER-HLD           PIC X.\n\n       77  WS-WORD-IN              PIC X(22).\n       77  WS-WORD-KEY             PIC X(22).\n\n       01 WS-WORD-TABLE.\n           05 WT-RECORD OCCURS 0 to 24000 TIMES\n                   DEPENDING ON WT-REC-NBR\n                   DESCENDING KEY IS WT-WORD-LEN\n                   INDEXED BY WT-IDX.\n               10 WT-WORD-KEY         PIC X(22).\n               10 WT-WORD-LEN         PIC 9(2).\n               10 WT-ANAGRAM-CNT      PIC 9(5) COMP-3.\n               10 WT-ANAGRAMS OCCURS 6 TIMES.\n                   15 WT-ANAGRAM      PIC X(22).\n\n       01 WS-WORD-TEMP1             PIC X(22).\n       01 FILLER REDEFINES WS-WORD-TEMP1.\n           05   WS-LETTER1  OCCURS 22 TIMES PIC X.\n\n       01 WS-WORD-TEMP2             PIC X(22).\n       01 FILLER REDEFINES WS-WORD-TEMP2.\n           05   WS-LETTER2  OCCURS 22 TIMES PIC X.\n\n       77  WS-I                    PIC 99999  COMP-3.\n       77  WS-J                    PIC 99999  COMP-3.\n       77  WS-K                    PIC 99999  COMP-3.\n       77  WS-L                    PIC 99999  COMP-3.\n       77  WS-BEG                  PIC 99999  COMP-3.\n       77  WS-MAX                  PIC 99999  COMP-3.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           PERFORM 100-INITIALIZE.\n           PERFORM 200-PROCESS-RECORD\n               UNTIL WS-EOF = 'Y'.\n           SORT WT-RECORD ON DESCENDING KEY WT-WORD-LEN.\n           PERFORM 500-FIND-DERANGED.\n           PERFORM 900-TERMINATE.\n           STOP RUN.\n\n       100-INITIALIZE.\n           OPEN INPUT IN-FILE.\n           PERFORM 150-READ-RECORD.\n\n       150-READ-RECORD.\n           READ IN-FILE INTO WS-WORD-IN\n               AT END\n                   MOVE 'Y' TO WS-EOF\n               NOT AT END\n                   COMPUTE WS-TOT-RECS = WS-TOT-RECS + 1\n           END-READ.\n\n       200-PROCESS-RECORD.\n           IF WS-WORD-IN IS ALPHABETIC\n               COMPUTE WS-SEL-RECS = WS-SEL-RECS + 1\n               MOVE WS-WORD-IN TO WS-WORD-TEMP\n               PERFORM 300-SORT-WORD\n               MOVE WS-WORD-TEMP TO WS-WORD-KEY\n               PERFORM 400-ADD-TO-TABLE\n           END-IF.\n\n           PERFORM 150-READ-RECORD.\n\n      * bubble sort:\n       300-SORT-WORD.\n           PERFORM VARYING WS-MAX FROM 1 BY 1\n               UNTIL WS-LETTER(WS-MAX) = SPACE\n           END-PERFORM.\n\n           PERFORM VARYING WS-I FROM 1 BY 1 UNTIL WS-I = WS-MAX\n               PERFORM VARYING WS-J FROM WS-I BY 1\n                 UNTIL WS-J > WS-MAX - 1\n                   IF WS-LETTER(WS-J) < WS-LETTER(WS-I) THEN\n                       MOVE WS-LETTER(WS-I)  TO WS-LETTER-HLD\n                       MOVE WS-LETTER(WS-J)  TO WS-LETTER(WS-I)\n                       MOVE WS-LETTER-HLD    TO WS-LETTER(WS-J)\n                   END-IF\n               END-PERFORM\n           END-PERFORM.\n\n       400-ADD-TO-TABLE.\n           SET WT-IDX TO 1.\n           SEARCH WT-RECORD\n               AT END\n                   PERFORM 420-ADD-RECORD\n               WHEN WT-WORD-KEY(WT-IDX) = WS-WORD-KEY\n                   PERFORM 440-UPDATE-RECORD\n           END-SEARCH.\n\n       420-ADD-RECORD.\n           ADD 1 To WT-REC-NBR.\n           MOVE WS-WORD-KEY TO WT-WORD-KEY(WT-REC-NBR).\n           COMPUTE WT-WORD-LEN(WT-REC-NBR) = WS-MAX - 1.\n           MOVE 1 TO WT-ANAGRAM-CNT(WT-REC-NBR).\n           MOVE WS-WORD-IN TO\n               WT-ANAGRAM(WT-REC-NBR, WT-ANAGRAM-CNT(WT-REC-NBR)).\n\n       440-UPDATE-RECORD.\n           ADD 1 TO WT-ANAGRAM-CNT(WT-IDX).\n           MOVE WS-WORD-IN TO\n               WT-ANAGRAM(WT-IDX, WT-ANAGRAM-CNT(WT-IDX)).\n\n       500-FIND-DERANGED.\n           PERFORM VARYING WS-I FROM 1 BY 1\n             UNTIL WS-I > WT-REC-NBR OR WS-FND = 'Y'\n               PERFORM VARYING WS-J FROM 1 BY 1\n                 UNTIL WS-J > WT-ANAGRAM-CNT(WS-I) - 1 OR WS-FND = 'Y'\n                   COMPUTE WS-BEG = WS-J + 1\n                   PERFORM VARYING WS-K FROM WS-BEG BY 1\n                     UNTIL WS-K > WT-ANAGRAM-CNT(WS-I) OR WS-FND = 'Y'\n                       MOVE WT-ANAGRAM(WS-I, WS-J) TO WS-WORD-TEMP1\n                       MOVE WT-ANAGRAM(WS-I, WS-K) To WS-WORD-TEMP2\n                       PERFORM 650-CHECK-DERANGED\n                   END-PERFORM\n               END-PERFORM\n           END-PERFORM.\n\n           650-CHECK-DERANGED.\n               MOVE 'N' TO WS-EXIT.\n               PERFORM VARYING WS-L FROM 1 BY 1\n                   UNTIL WS-L > WT-WORD-LEN(WS-I) OR WS-EXIT = 'Y'\n                       IF WS-LETTER1(WS-L) = WS-LETTER2(WS-L)\n                           MOVE 'Y' TO WS-EXIT\n               END-PERFORM.\n               IF WS-EXIT = 'N'\n                   DISPLAY WS-WORD-TEMP1(1:WT-WORD-LEN(WS-I))\n                   ' '\n                   WS-WORD-TEMP2\n                   MOVE 'Y' TO WS-FND\n               END-IF.\n\n       900-TERMINATE.\n           DISPLAY 'RECORDS READ: ' WS-TOT-RECS.\n           DISPLAY 'RECORDS SELECTED ' WS-SEL-RECS.\n           DISPLAY 'RECORD KEYS: ' WT-REC-NBR.\n           CLOSE IN-FILE.\n\n      \n\n      \n      \n      \n      \n\n      \n      \n", "target": "public static void Main()\n{\n    var lookupTable = File.ReadLines(\"unixdict.txt\").ToLookup(line => AnagramKey(line));\n    var query = from a in lookupTable\n        orderby a.Key.Length descending\n        let deranged = FindDeranged(a)\n        where deranged != null\n        select deranged[0] + \" \" + deranged[1];\n    Console.WriteLine(query.FirstOrDefault());\n}\n\t\nstatic string AnagramKey(string word) => new string(word.OrderBy(c => c).ToArray());\n\t\nstatic string[] FindDeranged(IEnumerable<string> anagrams) => (\n    from first in anagrams\n    from second in anagrams\n    where !second.Equals(first)\n        && Enumerable.Range(0, first.Length).All(i => first[i] != second[i])\n    select new [] { first, second })\n    .FirstOrDefault();\n"}
{"id": 110275, "name": "Anagrams_Deranged anagrams", "source": "Translate COBOL to Java:       ******************************************************************\n      * COBOL solution to Anagrams Deranged challange\n      * The program was run on OpenCobolIDE\n      * Input data is stored in file 'Anagrams.txt' on my PC\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. DERANGED.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT IN-FILE ASSIGN TO 'C:\\Both\\Rosetta\\Anagrams.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD IN-FILE.\n       01 IN-RECORD                PIC X(22).\n\n       WORKING-STORAGE SECTION.\n       01  SWITCHES.\n           05 WS-EOF               PIC X       VALUE 'N'.\n           05 WS-FND               PIC X       VALUE 'N'.\n           05 WS-EXIT              PIC X       VALUE 'N'.\n\n       01 COUNTERS.\n           05 WS-TOT-RECS          PIC 9(5)    COMP-3  VALUE 0.\n           05 WS-SEL-RECS          PIC 9(5)    COMP-3  VALUE 0.\n           05 WT-REC-NBR           PIC 9(5)    COMP-3  VALUE 0.\n\n      * Extra byte to guarentee a space at end - needed in sort logic.\n       01 WS-WORD-TEMP             PIC X(23).\n       01 FILLER REDEFINES WS-WORD-TEMP.\n           05   WS-LETTER  OCCURS 23 TIMES PIC X.\n       77  WS-LETTER-HLD           PIC X.\n\n       77  WS-WORD-IN              PIC X(22).\n       77  WS-WORD-KEY             PIC X(22).\n\n       01 WS-WORD-TABLE.\n           05 WT-RECORD OCCURS 0 to 24000 TIMES\n                   DEPENDING ON WT-REC-NBR\n                   DESCENDING KEY IS WT-WORD-LEN\n                   INDEXED BY WT-IDX.\n               10 WT-WORD-KEY         PIC X(22).\n               10 WT-WORD-LEN         PIC 9(2).\n               10 WT-ANAGRAM-CNT      PIC 9(5) COMP-3.\n               10 WT-ANAGRAMS OCCURS 6 TIMES.\n                   15 WT-ANAGRAM      PIC X(22).\n\n       01 WS-WORD-TEMP1             PIC X(22).\n       01 FILLER REDEFINES WS-WORD-TEMP1.\n           05   WS-LETTER1  OCCURS 22 TIMES PIC X.\n\n       01 WS-WORD-TEMP2             PIC X(22).\n       01 FILLER REDEFINES WS-WORD-TEMP2.\n           05   WS-LETTER2  OCCURS 22 TIMES PIC X.\n\n       77  WS-I                    PIC 99999  COMP-3.\n       77  WS-J                    PIC 99999  COMP-3.\n       77  WS-K                    PIC 99999  COMP-3.\n       77  WS-L                    PIC 99999  COMP-3.\n       77  WS-BEG                  PIC 99999  COMP-3.\n       77  WS-MAX                  PIC 99999  COMP-3.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           PERFORM 100-INITIALIZE.\n           PERFORM 200-PROCESS-RECORD\n               UNTIL WS-EOF = 'Y'.\n           SORT WT-RECORD ON DESCENDING KEY WT-WORD-LEN.\n           PERFORM 500-FIND-DERANGED.\n           PERFORM 900-TERMINATE.\n           STOP RUN.\n\n       100-INITIALIZE.\n           OPEN INPUT IN-FILE.\n           PERFORM 150-READ-RECORD.\n\n       150-READ-RECORD.\n           READ IN-FILE INTO WS-WORD-IN\n               AT END\n                   MOVE 'Y' TO WS-EOF\n               NOT AT END\n                   COMPUTE WS-TOT-RECS = WS-TOT-RECS + 1\n           END-READ.\n\n       200-PROCESS-RECORD.\n           IF WS-WORD-IN IS ALPHABETIC\n               COMPUTE WS-SEL-RECS = WS-SEL-RECS + 1\n               MOVE WS-WORD-IN TO WS-WORD-TEMP\n               PERFORM 300-SORT-WORD\n               MOVE WS-WORD-TEMP TO WS-WORD-KEY\n               PERFORM 400-ADD-TO-TABLE\n           END-IF.\n\n           PERFORM 150-READ-RECORD.\n\n      * bubble sort:\n       300-SORT-WORD.\n           PERFORM VARYING WS-MAX FROM 1 BY 1\n               UNTIL WS-LETTER(WS-MAX) = SPACE\n           END-PERFORM.\n\n           PERFORM VARYING WS-I FROM 1 BY 1 UNTIL WS-I = WS-MAX\n               PERFORM VARYING WS-J FROM WS-I BY 1\n                 UNTIL WS-J > WS-MAX - 1\n                   IF WS-LETTER(WS-J) < WS-LETTER(WS-I) THEN\n                       MOVE WS-LETTER(WS-I)  TO WS-LETTER-HLD\n                       MOVE WS-LETTER(WS-J)  TO WS-LETTER(WS-I)\n                       MOVE WS-LETTER-HLD    TO WS-LETTER(WS-J)\n                   END-IF\n               END-PERFORM\n           END-PERFORM.\n\n       400-ADD-TO-TABLE.\n           SET WT-IDX TO 1.\n           SEARCH WT-RECORD\n               AT END\n                   PERFORM 420-ADD-RECORD\n               WHEN WT-WORD-KEY(WT-IDX) = WS-WORD-KEY\n                   PERFORM 440-UPDATE-RECORD\n           END-SEARCH.\n\n       420-ADD-RECORD.\n           ADD 1 To WT-REC-NBR.\n           MOVE WS-WORD-KEY TO WT-WORD-KEY(WT-REC-NBR).\n           COMPUTE WT-WORD-LEN(WT-REC-NBR) = WS-MAX - 1.\n           MOVE 1 TO WT-ANAGRAM-CNT(WT-REC-NBR).\n           MOVE WS-WORD-IN TO\n               WT-ANAGRAM(WT-REC-NBR, WT-ANAGRAM-CNT(WT-REC-NBR)).\n\n       440-UPDATE-RECORD.\n           ADD 1 TO WT-ANAGRAM-CNT(WT-IDX).\n           MOVE WS-WORD-IN TO\n               WT-ANAGRAM(WT-IDX, WT-ANAGRAM-CNT(WT-IDX)).\n\n       500-FIND-DERANGED.\n           PERFORM VARYING WS-I FROM 1 BY 1\n             UNTIL WS-I > WT-REC-NBR OR WS-FND = 'Y'\n               PERFORM VARYING WS-J FROM 1 BY 1\n                 UNTIL WS-J > WT-ANAGRAM-CNT(WS-I) - 1 OR WS-FND = 'Y'\n                   COMPUTE WS-BEG = WS-J + 1\n                   PERFORM VARYING WS-K FROM WS-BEG BY 1\n                     UNTIL WS-K > WT-ANAGRAM-CNT(WS-I) OR WS-FND = 'Y'\n                       MOVE WT-ANAGRAM(WS-I, WS-J) TO WS-WORD-TEMP1\n                       MOVE WT-ANAGRAM(WS-I, WS-K) To WS-WORD-TEMP2\n                       PERFORM 650-CHECK-DERANGED\n                   END-PERFORM\n               END-PERFORM\n           END-PERFORM.\n\n           650-CHECK-DERANGED.\n               MOVE 'N' TO WS-EXIT.\n               PERFORM VARYING WS-L FROM 1 BY 1\n                   UNTIL WS-L > WT-WORD-LEN(WS-I) OR WS-EXIT = 'Y'\n                       IF WS-LETTER1(WS-L) = WS-LETTER2(WS-L)\n                           MOVE 'Y' TO WS-EXIT\n               END-PERFORM.\n               IF WS-EXIT = 'N'\n                   DISPLAY WS-WORD-TEMP1(1:WT-WORD-LEN(WS-I))\n                   ' '\n                   WS-WORD-TEMP2\n                   MOVE 'Y' TO WS-FND\n               END-IF.\n\n       900-TERMINATE.\n           DISPLAY 'RECORDS READ: ' WS-TOT-RECS.\n           DISPLAY 'RECORDS SELECTED ' WS-SEL-RECS.\n           DISPLAY 'RECORD KEYS: ' WT-REC-NBR.\n           CLOSE IN-FILE.\n\n      \n\n      \n      \n      \n      \n\n      \n      \n", "target": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n \npublic class DerangedAnagrams {\n \n    public static void main(String[] args) throws IOException {\n        List<String> words = Files.readAllLines(new File(\"unixdict.txt\").toPath());\n        printLongestDerangedAnagram(words);\n    }\n \n    private static void printLongestDerangedAnagram(List<String> words) {\n        words.sort(Comparator.comparingInt(String::length).reversed().thenComparing(String::toString));\n\n        Map<String, ArrayList<String>> map = new HashMap<>();\n        for (String word : words) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            String key = String.valueOf(chars);\n\n            List<String> anagrams = map.computeIfAbsent(key, k -> new ArrayList<>());\n            for (String anagram : anagrams) {\n                if (isDeranged(word, anagram)) {\n                    System.out.printf(\"%s %s%n\", anagram, word);\n                    return;\n                }\n            }\n            anagrams.add(word);\n        }\n        System.out.println(\"no result\");\n    }\n\n    private static boolean isDeranged(String word1, String word2) {\n        for (int i = 0; i < word1.length(); i++) {\n            if (word1.charAt(i) == word2.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"id": 110276, "name": "Anagrams_Deranged anagrams", "source": "Translate COBOL to Java:       ******************************************************************\n      * COBOL solution to Anagrams Deranged challange\n      * The program was run on OpenCobolIDE\n      * Input data is stored in file 'Anagrams.txt' on my PC\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. DERANGED.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT IN-FILE ASSIGN TO 'C:\\Both\\Rosetta\\Anagrams.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD IN-FILE.\n       01 IN-RECORD                PIC X(22).\n\n       WORKING-STORAGE SECTION.\n       01  SWITCHES.\n           05 WS-EOF               PIC X       VALUE 'N'.\n           05 WS-FND               PIC X       VALUE 'N'.\n           05 WS-EXIT              PIC X       VALUE 'N'.\n\n       01 COUNTERS.\n           05 WS-TOT-RECS          PIC 9(5)    COMP-3  VALUE 0.\n           05 WS-SEL-RECS          PIC 9(5)    COMP-3  VALUE 0.\n           05 WT-REC-NBR           PIC 9(5)    COMP-3  VALUE 0.\n\n      * Extra byte to guarentee a space at end - needed in sort logic.\n       01 WS-WORD-TEMP             PIC X(23).\n       01 FILLER REDEFINES WS-WORD-TEMP.\n           05   WS-LETTER  OCCURS 23 TIMES PIC X.\n       77  WS-LETTER-HLD           PIC X.\n\n       77  WS-WORD-IN              PIC X(22).\n       77  WS-WORD-KEY             PIC X(22).\n\n       01 WS-WORD-TABLE.\n           05 WT-RECORD OCCURS 0 to 24000 TIMES\n                   DEPENDING ON WT-REC-NBR\n                   DESCENDING KEY IS WT-WORD-LEN\n                   INDEXED BY WT-IDX.\n               10 WT-WORD-KEY         PIC X(22).\n               10 WT-WORD-LEN         PIC 9(2).\n               10 WT-ANAGRAM-CNT      PIC 9(5) COMP-3.\n               10 WT-ANAGRAMS OCCURS 6 TIMES.\n                   15 WT-ANAGRAM      PIC X(22).\n\n       01 WS-WORD-TEMP1             PIC X(22).\n       01 FILLER REDEFINES WS-WORD-TEMP1.\n           05   WS-LETTER1  OCCURS 22 TIMES PIC X.\n\n       01 WS-WORD-TEMP2             PIC X(22).\n       01 FILLER REDEFINES WS-WORD-TEMP2.\n           05   WS-LETTER2  OCCURS 22 TIMES PIC X.\n\n       77  WS-I                    PIC 99999  COMP-3.\n       77  WS-J                    PIC 99999  COMP-3.\n       77  WS-K                    PIC 99999  COMP-3.\n       77  WS-L                    PIC 99999  COMP-3.\n       77  WS-BEG                  PIC 99999  COMP-3.\n       77  WS-MAX                  PIC 99999  COMP-3.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           PERFORM 100-INITIALIZE.\n           PERFORM 200-PROCESS-RECORD\n               UNTIL WS-EOF = 'Y'.\n           SORT WT-RECORD ON DESCENDING KEY WT-WORD-LEN.\n           PERFORM 500-FIND-DERANGED.\n           PERFORM 900-TERMINATE.\n           STOP RUN.\n\n       100-INITIALIZE.\n           OPEN INPUT IN-FILE.\n           PERFORM 150-READ-RECORD.\n\n       150-READ-RECORD.\n           READ IN-FILE INTO WS-WORD-IN\n               AT END\n                   MOVE 'Y' TO WS-EOF\n               NOT AT END\n                   COMPUTE WS-TOT-RECS = WS-TOT-RECS + 1\n           END-READ.\n\n       200-PROCESS-RECORD.\n           IF WS-WORD-IN IS ALPHABETIC\n               COMPUTE WS-SEL-RECS = WS-SEL-RECS + 1\n               MOVE WS-WORD-IN TO WS-WORD-TEMP\n               PERFORM 300-SORT-WORD\n               MOVE WS-WORD-TEMP TO WS-WORD-KEY\n               PERFORM 400-ADD-TO-TABLE\n           END-IF.\n\n           PERFORM 150-READ-RECORD.\n\n      * bubble sort:\n       300-SORT-WORD.\n           PERFORM VARYING WS-MAX FROM 1 BY 1\n               UNTIL WS-LETTER(WS-MAX) = SPACE\n           END-PERFORM.\n\n           PERFORM VARYING WS-I FROM 1 BY 1 UNTIL WS-I = WS-MAX\n               PERFORM VARYING WS-J FROM WS-I BY 1\n                 UNTIL WS-J > WS-MAX - 1\n                   IF WS-LETTER(WS-J) < WS-LETTER(WS-I) THEN\n                       MOVE WS-LETTER(WS-I)  TO WS-LETTER-HLD\n                       MOVE WS-LETTER(WS-J)  TO WS-LETTER(WS-I)\n                       MOVE WS-LETTER-HLD    TO WS-LETTER(WS-J)\n                   END-IF\n               END-PERFORM\n           END-PERFORM.\n\n       400-ADD-TO-TABLE.\n           SET WT-IDX TO 1.\n           SEARCH WT-RECORD\n               AT END\n                   PERFORM 420-ADD-RECORD\n               WHEN WT-WORD-KEY(WT-IDX) = WS-WORD-KEY\n                   PERFORM 440-UPDATE-RECORD\n           END-SEARCH.\n\n       420-ADD-RECORD.\n           ADD 1 To WT-REC-NBR.\n           MOVE WS-WORD-KEY TO WT-WORD-KEY(WT-REC-NBR).\n           COMPUTE WT-WORD-LEN(WT-REC-NBR) = WS-MAX - 1.\n           MOVE 1 TO WT-ANAGRAM-CNT(WT-REC-NBR).\n           MOVE WS-WORD-IN TO\n               WT-ANAGRAM(WT-REC-NBR, WT-ANAGRAM-CNT(WT-REC-NBR)).\n\n       440-UPDATE-RECORD.\n           ADD 1 TO WT-ANAGRAM-CNT(WT-IDX).\n           MOVE WS-WORD-IN TO\n               WT-ANAGRAM(WT-IDX, WT-ANAGRAM-CNT(WT-IDX)).\n\n       500-FIND-DERANGED.\n           PERFORM VARYING WS-I FROM 1 BY 1\n             UNTIL WS-I > WT-REC-NBR OR WS-FND = 'Y'\n               PERFORM VARYING WS-J FROM 1 BY 1\n                 UNTIL WS-J > WT-ANAGRAM-CNT(WS-I) - 1 OR WS-FND = 'Y'\n                   COMPUTE WS-BEG = WS-J + 1\n                   PERFORM VARYING WS-K FROM WS-BEG BY 1\n                     UNTIL WS-K > WT-ANAGRAM-CNT(WS-I) OR WS-FND = 'Y'\n                       MOVE WT-ANAGRAM(WS-I, WS-J) TO WS-WORD-TEMP1\n                       MOVE WT-ANAGRAM(WS-I, WS-K) To WS-WORD-TEMP2\n                       PERFORM 650-CHECK-DERANGED\n                   END-PERFORM\n               END-PERFORM\n           END-PERFORM.\n\n           650-CHECK-DERANGED.\n               MOVE 'N' TO WS-EXIT.\n               PERFORM VARYING WS-L FROM 1 BY 1\n                   UNTIL WS-L > WT-WORD-LEN(WS-I) OR WS-EXIT = 'Y'\n                       IF WS-LETTER1(WS-L) = WS-LETTER2(WS-L)\n                           MOVE 'Y' TO WS-EXIT\n               END-PERFORM.\n               IF WS-EXIT = 'N'\n                   DISPLAY WS-WORD-TEMP1(1:WT-WORD-LEN(WS-I))\n                   ' '\n                   WS-WORD-TEMP2\n                   MOVE 'Y' TO WS-FND\n               END-IF.\n\n       900-TERMINATE.\n           DISPLAY 'RECORDS READ: ' WS-TOT-RECS.\n           DISPLAY 'RECORDS SELECTED ' WS-SEL-RECS.\n           DISPLAY 'RECORD KEYS: ' WT-REC-NBR.\n           CLOSE IN-FILE.\n\n      \n\n      \n      \n      \n      \n\n      \n      \n", "target": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n \npublic class DerangedAnagrams {\n \n    public static void main(String[] args) throws IOException {\n        List<String> words = Files.readAllLines(new File(\"unixdict.txt\").toPath());\n        printLongestDerangedAnagram(words);\n    }\n \n    private static void printLongestDerangedAnagram(List<String> words) {\n        words.sort(Comparator.comparingInt(String::length).reversed().thenComparing(String::toString));\n\n        Map<String, ArrayList<String>> map = new HashMap<>();\n        for (String word : words) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            String key = String.valueOf(chars);\n\n            List<String> anagrams = map.computeIfAbsent(key, k -> new ArrayList<>());\n            for (String anagram : anagrams) {\n                if (isDeranged(word, anagram)) {\n                    System.out.printf(\"%s %s%n\", anagram, word);\n                    return;\n                }\n            }\n            anagrams.add(word);\n        }\n        System.out.println(\"no result\");\n    }\n\n    private static boolean isDeranged(String word1, String word2) {\n        for (int i = 0; i < word1.length(); i++) {\n            if (word1.charAt(i) == word2.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"id": 110277, "name": "Anagrams_Deranged anagrams", "source": "Translate COBOL to Python:       ******************************************************************\n      * COBOL solution to Anagrams Deranged challange\n      * The program was run on OpenCobolIDE\n      * Input data is stored in file 'Anagrams.txt' on my PC\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. DERANGED.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT IN-FILE ASSIGN TO 'C:\\Both\\Rosetta\\Anagrams.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD IN-FILE.\n       01 IN-RECORD                PIC X(22).\n\n       WORKING-STORAGE SECTION.\n       01  SWITCHES.\n           05 WS-EOF               PIC X       VALUE 'N'.\n           05 WS-FND               PIC X       VALUE 'N'.\n           05 WS-EXIT              PIC X       VALUE 'N'.\n\n       01 COUNTERS.\n           05 WS-TOT-RECS          PIC 9(5)    COMP-3  VALUE 0.\n           05 WS-SEL-RECS          PIC 9(5)    COMP-3  VALUE 0.\n           05 WT-REC-NBR           PIC 9(5)    COMP-3  VALUE 0.\n\n      * Extra byte to guarentee a space at end - needed in sort logic.\n       01 WS-WORD-TEMP             PIC X(23).\n       01 FILLER REDEFINES WS-WORD-TEMP.\n           05   WS-LETTER  OCCURS 23 TIMES PIC X.\n       77  WS-LETTER-HLD           PIC X.\n\n       77  WS-WORD-IN              PIC X(22).\n       77  WS-WORD-KEY             PIC X(22).\n\n       01 WS-WORD-TABLE.\n           05 WT-RECORD OCCURS 0 to 24000 TIMES\n                   DEPENDING ON WT-REC-NBR\n                   DESCENDING KEY IS WT-WORD-LEN\n                   INDEXED BY WT-IDX.\n               10 WT-WORD-KEY         PIC X(22).\n               10 WT-WORD-LEN         PIC 9(2).\n               10 WT-ANAGRAM-CNT      PIC 9(5) COMP-3.\n               10 WT-ANAGRAMS OCCURS 6 TIMES.\n                   15 WT-ANAGRAM      PIC X(22).\n\n       01 WS-WORD-TEMP1             PIC X(22).\n       01 FILLER REDEFINES WS-WORD-TEMP1.\n           05   WS-LETTER1  OCCURS 22 TIMES PIC X.\n\n       01 WS-WORD-TEMP2             PIC X(22).\n       01 FILLER REDEFINES WS-WORD-TEMP2.\n           05   WS-LETTER2  OCCURS 22 TIMES PIC X.\n\n       77  WS-I                    PIC 99999  COMP-3.\n       77  WS-J                    PIC 99999  COMP-3.\n       77  WS-K                    PIC 99999  COMP-3.\n       77  WS-L                    PIC 99999  COMP-3.\n       77  WS-BEG                  PIC 99999  COMP-3.\n       77  WS-MAX                  PIC 99999  COMP-3.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           PERFORM 100-INITIALIZE.\n           PERFORM 200-PROCESS-RECORD\n               UNTIL WS-EOF = 'Y'.\n           SORT WT-RECORD ON DESCENDING KEY WT-WORD-LEN.\n           PERFORM 500-FIND-DERANGED.\n           PERFORM 900-TERMINATE.\n           STOP RUN.\n\n       100-INITIALIZE.\n           OPEN INPUT IN-FILE.\n           PERFORM 150-READ-RECORD.\n\n       150-READ-RECORD.\n           READ IN-FILE INTO WS-WORD-IN\n               AT END\n                   MOVE 'Y' TO WS-EOF\n               NOT AT END\n                   COMPUTE WS-TOT-RECS = WS-TOT-RECS + 1\n           END-READ.\n\n       200-PROCESS-RECORD.\n           IF WS-WORD-IN IS ALPHABETIC\n               COMPUTE WS-SEL-RECS = WS-SEL-RECS + 1\n               MOVE WS-WORD-IN TO WS-WORD-TEMP\n               PERFORM 300-SORT-WORD\n               MOVE WS-WORD-TEMP TO WS-WORD-KEY\n               PERFORM 400-ADD-TO-TABLE\n           END-IF.\n\n           PERFORM 150-READ-RECORD.\n\n      * bubble sort:\n       300-SORT-WORD.\n           PERFORM VARYING WS-MAX FROM 1 BY 1\n               UNTIL WS-LETTER(WS-MAX) = SPACE\n           END-PERFORM.\n\n           PERFORM VARYING WS-I FROM 1 BY 1 UNTIL WS-I = WS-MAX\n               PERFORM VARYING WS-J FROM WS-I BY 1\n                 UNTIL WS-J > WS-MAX - 1\n                   IF WS-LETTER(WS-J) < WS-LETTER(WS-I) THEN\n                       MOVE WS-LETTER(WS-I)  TO WS-LETTER-HLD\n                       MOVE WS-LETTER(WS-J)  TO WS-LETTER(WS-I)\n                       MOVE WS-LETTER-HLD    TO WS-LETTER(WS-J)\n                   END-IF\n               END-PERFORM\n           END-PERFORM.\n\n       400-ADD-TO-TABLE.\n           SET WT-IDX TO 1.\n           SEARCH WT-RECORD\n               AT END\n                   PERFORM 420-ADD-RECORD\n               WHEN WT-WORD-KEY(WT-IDX) = WS-WORD-KEY\n                   PERFORM 440-UPDATE-RECORD\n           END-SEARCH.\n\n       420-ADD-RECORD.\n           ADD 1 To WT-REC-NBR.\n           MOVE WS-WORD-KEY TO WT-WORD-KEY(WT-REC-NBR).\n           COMPUTE WT-WORD-LEN(WT-REC-NBR) = WS-MAX - 1.\n           MOVE 1 TO WT-ANAGRAM-CNT(WT-REC-NBR).\n           MOVE WS-WORD-IN TO\n               WT-ANAGRAM(WT-REC-NBR, WT-ANAGRAM-CNT(WT-REC-NBR)).\n\n       440-UPDATE-RECORD.\n           ADD 1 TO WT-ANAGRAM-CNT(WT-IDX).\n           MOVE WS-WORD-IN TO\n               WT-ANAGRAM(WT-IDX, WT-ANAGRAM-CNT(WT-IDX)).\n\n       500-FIND-DERANGED.\n           PERFORM VARYING WS-I FROM 1 BY 1\n             UNTIL WS-I > WT-REC-NBR OR WS-FND = 'Y'\n               PERFORM VARYING WS-J FROM 1 BY 1\n                 UNTIL WS-J > WT-ANAGRAM-CNT(WS-I) - 1 OR WS-FND = 'Y'\n                   COMPUTE WS-BEG = WS-J + 1\n                   PERFORM VARYING WS-K FROM WS-BEG BY 1\n                     UNTIL WS-K > WT-ANAGRAM-CNT(WS-I) OR WS-FND = 'Y'\n                       MOVE WT-ANAGRAM(WS-I, WS-J) TO WS-WORD-TEMP1\n                       MOVE WT-ANAGRAM(WS-I, WS-K) To WS-WORD-TEMP2\n                       PERFORM 650-CHECK-DERANGED\n                   END-PERFORM\n               END-PERFORM\n           END-PERFORM.\n\n           650-CHECK-DERANGED.\n               MOVE 'N' TO WS-EXIT.\n               PERFORM VARYING WS-L FROM 1 BY 1\n                   UNTIL WS-L > WT-WORD-LEN(WS-I) OR WS-EXIT = 'Y'\n                       IF WS-LETTER1(WS-L) = WS-LETTER2(WS-L)\n                           MOVE 'Y' TO WS-EXIT\n               END-PERFORM.\n               IF WS-EXIT = 'N'\n                   DISPLAY WS-WORD-TEMP1(1:WT-WORD-LEN(WS-I))\n                   ' '\n                   WS-WORD-TEMP2\n                   MOVE 'Y' TO WS-FND\n               END-IF.\n\n       900-TERMINATE.\n           DISPLAY 'RECORDS READ: ' WS-TOT-RECS.\n           DISPLAY 'RECORDS SELECTED ' WS-SEL-RECS.\n           DISPLAY 'RECORD KEYS: ' WT-REC-NBR.\n           CLOSE IN-FILE.\n\n      \n\n      \n      \n      \n      \n\n      \n      \n", "target": "import urllib.request\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef getwords(url='http://www.puzzlers.org/pub/wordlists/unixdict.txt'):\n    return list(set(urllib.request.urlopen(url).read().decode().split()))\n\ndef find_anagrams(words):\n    anagram = defaultdict(list) \n    for word in words:\n        anagram[tuple(sorted(word))].append( word )\n    return dict((key, words) for key, words in anagram.items()\n                if len(words) > 1)\n\ndef is_deranged(words):\n    'returns pairs of words that have no character in the same position'\n    return [ (word1, word2)\n             for word1,word2 in combinations(words, 2)\n             if all(ch1 != ch2 for ch1, ch2 in zip(word1, word2)) ]\n\ndef largest_deranged_ana(anagrams):\n    ordered_anagrams = sorted(anagrams.items(),\n                              key=lambda x:(-len(x[0]), x[0]))\n    for _, words in ordered_anagrams:\n        deranged_pairs = is_deranged(words)\n        if deranged_pairs:\n            return deranged_pairs\n    return []\n\nif __name__ == '__main__':\n    words = getwords('http://www.puzzlers.org/pub/wordlists/unixdict.txt')\n    print(\"Word count:\", len(words))\n\n    anagrams = find_anagrams(words)\n    print(\"Anagram count:\", len(anagrams),\"\\n\")\n\n    print(\"Longest anagrams with no characters in the same position:\")\n    print('  ' + '\\n  '.join(', '.join(pairs)\n                             for pairs in largest_deranged_ana(anagrams)))\n"}
{"id": 110278, "name": "Anagrams_Deranged anagrams", "source": "Translate COBOL to Python:       ******************************************************************\n      * COBOL solution to Anagrams Deranged challange\n      * The program was run on OpenCobolIDE\n      * Input data is stored in file 'Anagrams.txt' on my PC\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. DERANGED.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT IN-FILE ASSIGN TO 'C:\\Both\\Rosetta\\Anagrams.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD IN-FILE.\n       01 IN-RECORD                PIC X(22).\n\n       WORKING-STORAGE SECTION.\n       01  SWITCHES.\n           05 WS-EOF               PIC X       VALUE 'N'.\n           05 WS-FND               PIC X       VALUE 'N'.\n           05 WS-EXIT              PIC X       VALUE 'N'.\n\n       01 COUNTERS.\n           05 WS-TOT-RECS          PIC 9(5)    COMP-3  VALUE 0.\n           05 WS-SEL-RECS          PIC 9(5)    COMP-3  VALUE 0.\n           05 WT-REC-NBR           PIC 9(5)    COMP-3  VALUE 0.\n\n      * Extra byte to guarentee a space at end - needed in sort logic.\n       01 WS-WORD-TEMP             PIC X(23).\n       01 FILLER REDEFINES WS-WORD-TEMP.\n           05   WS-LETTER  OCCURS 23 TIMES PIC X.\n       77  WS-LETTER-HLD           PIC X.\n\n       77  WS-WORD-IN              PIC X(22).\n       77  WS-WORD-KEY             PIC X(22).\n\n       01 WS-WORD-TABLE.\n           05 WT-RECORD OCCURS 0 to 24000 TIMES\n                   DEPENDING ON WT-REC-NBR\n                   DESCENDING KEY IS WT-WORD-LEN\n                   INDEXED BY WT-IDX.\n               10 WT-WORD-KEY         PIC X(22).\n               10 WT-WORD-LEN         PIC 9(2).\n               10 WT-ANAGRAM-CNT      PIC 9(5) COMP-3.\n               10 WT-ANAGRAMS OCCURS 6 TIMES.\n                   15 WT-ANAGRAM      PIC X(22).\n\n       01 WS-WORD-TEMP1             PIC X(22).\n       01 FILLER REDEFINES WS-WORD-TEMP1.\n           05   WS-LETTER1  OCCURS 22 TIMES PIC X.\n\n       01 WS-WORD-TEMP2             PIC X(22).\n       01 FILLER REDEFINES WS-WORD-TEMP2.\n           05   WS-LETTER2  OCCURS 22 TIMES PIC X.\n\n       77  WS-I                    PIC 99999  COMP-3.\n       77  WS-J                    PIC 99999  COMP-3.\n       77  WS-K                    PIC 99999  COMP-3.\n       77  WS-L                    PIC 99999  COMP-3.\n       77  WS-BEG                  PIC 99999  COMP-3.\n       77  WS-MAX                  PIC 99999  COMP-3.\n\n       PROCEDURE DIVISION.\n       000-MAIN.\n           PERFORM 100-INITIALIZE.\n           PERFORM 200-PROCESS-RECORD\n               UNTIL WS-EOF = 'Y'.\n           SORT WT-RECORD ON DESCENDING KEY WT-WORD-LEN.\n           PERFORM 500-FIND-DERANGED.\n           PERFORM 900-TERMINATE.\n           STOP RUN.\n\n       100-INITIALIZE.\n           OPEN INPUT IN-FILE.\n           PERFORM 150-READ-RECORD.\n\n       150-READ-RECORD.\n           READ IN-FILE INTO WS-WORD-IN\n               AT END\n                   MOVE 'Y' TO WS-EOF\n               NOT AT END\n                   COMPUTE WS-TOT-RECS = WS-TOT-RECS + 1\n           END-READ.\n\n       200-PROCESS-RECORD.\n           IF WS-WORD-IN IS ALPHABETIC\n               COMPUTE WS-SEL-RECS = WS-SEL-RECS + 1\n               MOVE WS-WORD-IN TO WS-WORD-TEMP\n               PERFORM 300-SORT-WORD\n               MOVE WS-WORD-TEMP TO WS-WORD-KEY\n               PERFORM 400-ADD-TO-TABLE\n           END-IF.\n\n           PERFORM 150-READ-RECORD.\n\n      * bubble sort:\n       300-SORT-WORD.\n           PERFORM VARYING WS-MAX FROM 1 BY 1\n               UNTIL WS-LETTER(WS-MAX) = SPACE\n           END-PERFORM.\n\n           PERFORM VARYING WS-I FROM 1 BY 1 UNTIL WS-I = WS-MAX\n               PERFORM VARYING WS-J FROM WS-I BY 1\n                 UNTIL WS-J > WS-MAX - 1\n                   IF WS-LETTER(WS-J) < WS-LETTER(WS-I) THEN\n                       MOVE WS-LETTER(WS-I)  TO WS-LETTER-HLD\n                       MOVE WS-LETTER(WS-J)  TO WS-LETTER(WS-I)\n                       MOVE WS-LETTER-HLD    TO WS-LETTER(WS-J)\n                   END-IF\n               END-PERFORM\n           END-PERFORM.\n\n       400-ADD-TO-TABLE.\n           SET WT-IDX TO 1.\n           SEARCH WT-RECORD\n               AT END\n                   PERFORM 420-ADD-RECORD\n               WHEN WT-WORD-KEY(WT-IDX) = WS-WORD-KEY\n                   PERFORM 440-UPDATE-RECORD\n           END-SEARCH.\n\n       420-ADD-RECORD.\n           ADD 1 To WT-REC-NBR.\n           MOVE WS-WORD-KEY TO WT-WORD-KEY(WT-REC-NBR).\n           COMPUTE WT-WORD-LEN(WT-REC-NBR) = WS-MAX - 1.\n           MOVE 1 TO WT-ANAGRAM-CNT(WT-REC-NBR).\n           MOVE WS-WORD-IN TO\n               WT-ANAGRAM(WT-REC-NBR, WT-ANAGRAM-CNT(WT-REC-NBR)).\n\n       440-UPDATE-RECORD.\n           ADD 1 TO WT-ANAGRAM-CNT(WT-IDX).\n           MOVE WS-WORD-IN TO\n               WT-ANAGRAM(WT-IDX, WT-ANAGRAM-CNT(WT-IDX)).\n\n       500-FIND-DERANGED.\n           PERFORM VARYING WS-I FROM 1 BY 1\n             UNTIL WS-I > WT-REC-NBR OR WS-FND = 'Y'\n               PERFORM VARYING WS-J FROM 1 BY 1\n                 UNTIL WS-J > WT-ANAGRAM-CNT(WS-I) - 1 OR WS-FND = 'Y'\n                   COMPUTE WS-BEG = WS-J + 1\n                   PERFORM VARYING WS-K FROM WS-BEG BY 1\n                     UNTIL WS-K > WT-ANAGRAM-CNT(WS-I) OR WS-FND = 'Y'\n                       MOVE WT-ANAGRAM(WS-I, WS-J) TO WS-WORD-TEMP1\n                       MOVE WT-ANAGRAM(WS-I, WS-K) To WS-WORD-TEMP2\n                       PERFORM 650-CHECK-DERANGED\n                   END-PERFORM\n               END-PERFORM\n           END-PERFORM.\n\n           650-CHECK-DERANGED.\n               MOVE 'N' TO WS-EXIT.\n               PERFORM VARYING WS-L FROM 1 BY 1\n                   UNTIL WS-L > WT-WORD-LEN(WS-I) OR WS-EXIT = 'Y'\n                       IF WS-LETTER1(WS-L) = WS-LETTER2(WS-L)\n                           MOVE 'Y' TO WS-EXIT\n               END-PERFORM.\n               IF WS-EXIT = 'N'\n                   DISPLAY WS-WORD-TEMP1(1:WT-WORD-LEN(WS-I))\n                   ' '\n                   WS-WORD-TEMP2\n                   MOVE 'Y' TO WS-FND\n               END-IF.\n\n       900-TERMINATE.\n           DISPLAY 'RECORDS READ: ' WS-TOT-RECS.\n           DISPLAY 'RECORDS SELECTED ' WS-SEL-RECS.\n           DISPLAY 'RECORD KEYS: ' WT-REC-NBR.\n           CLOSE IN-FILE.\n\n      \n\n      \n      \n      \n      \n\n      \n      \n", "target": "import urllib.request\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef getwords(url='http://www.puzzlers.org/pub/wordlists/unixdict.txt'):\n    return list(set(urllib.request.urlopen(url).read().decode().split()))\n\ndef find_anagrams(words):\n    anagram = defaultdict(list) \n    for word in words:\n        anagram[tuple(sorted(word))].append( word )\n    return dict((key, words) for key, words in anagram.items()\n                if len(words) > 1)\n\ndef is_deranged(words):\n    'returns pairs of words that have no character in the same position'\n    return [ (word1, word2)\n             for word1,word2 in combinations(words, 2)\n             if all(ch1 != ch2 for ch1, ch2 in zip(word1, word2)) ]\n\ndef largest_deranged_ana(anagrams):\n    ordered_anagrams = sorted(anagrams.items(),\n                              key=lambda x:(-len(x[0]), x[0]))\n    for _, words in ordered_anagrams:\n        deranged_pairs = is_deranged(words)\n        if deranged_pairs:\n            return deranged_pairs\n    return []\n\nif __name__ == '__main__':\n    words = getwords('http://www.puzzlers.org/pub/wordlists/unixdict.txt')\n    print(\"Word count:\", len(words))\n\n    anagrams = find_anagrams(words)\n    print(\"Anagram count:\", len(anagrams),\"\\n\")\n\n    print(\"Longest anagrams with no characters in the same position:\")\n    print('  ' + '\\n  '.join(', '.join(pairs)\n                             for pairs in largest_deranged_ana(anagrams)))\n"}
{"id": 110696, "name": "Gapful numbers", "source": "Translate COBOL to C#:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. GAPFUL.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 COMPUTATION.\n            02 N            PIC 9(10).\n            02 N-DIGITS     REDEFINES N.\n               03 ND        PIC 9 OCCURS 10 TIMES.\n            02 DIV-CHECK    PIC 9(10)V9(2).\n            02 DIV-PARTS    REDEFINES DIV-CHECK.\n               03 DIV-INT   PIC 9(10).\n               03 DIV-FRAC  PIC 9(2).\n            02 GAP-AMOUNT   PIC 99.\n            02 GAP-DSOR     PIC 99.\n            02 FIRST-DIGIT  PIC 99.\n        01 OUTPUT-FORMAT.\n            02 N-OUT        PIC Z(10).\n            \n        PROCEDURE DIVISION.\n        BEGIN.\n            DISPLAY \"First 30 gapful numbers >= 100:\".\n            MOVE 100 TO N. MOVE 30 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            \n            DISPLAY \" \".\n            DISPLAY \"First 15 gapful numbers >= 1000000:\".\n            MOVE 1000000 TO N. MOVE 15 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            \n            DISPLAY \" \".\n            DISPLAY \"First 10 gapful numbers >= 1000000000:\".\n            MOVE 1000000000 TO N. MOVE 10 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            STOP RUN.\n        \n        CHECK-GAPFUL-NUMBER.\n            SET FIRST-DIGIT TO 1.\n            INSPECT N TALLYING FIRST-DIGIT FOR LEADING '0'.\n            COMPUTE GAP-DSOR = ND(FIRST-DIGIT) * 10 + ND(10).\n            DIVIDE N BY GAP-DSOR GIVING DIV-CHECK.\n            IF DIV-FRAC IS EQUAL TO 0\n                MOVE N TO N-OUT\n                DISPLAY N-OUT\n                SUBTRACT 1 FROM GAP-AMOUNT.\n            ADD 1 TO N.\n            IF GAP-AMOUNT IS GREATER THAN 0 \n                GO TO CHECK-GAPFUL-NUMBER.\n", "target": "using System;\n\nnamespace GapfulNumbers\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"The first 30 gapful numbers are: \");\n            \n            FindGap(100, 30);\n\n            Console.WriteLine(\"The first 15 gapful numbers > 1,000,000 are: \");\n            FindGap(1000000, 15);\n\n            Console.WriteLine(\"The first 10 gapful numbers > 1,000,000,000 are: \");\n            FindGap(1000000000, 10);\n\n            Console.Read();\n        }\n\n        public static int firstNum(int n)\n        {\n            \n            while (n >= 10)\n            {\n                n /= 10;\n            }\n            return (n);\n        }\n\n        public static int lastNum(int n)\n        {\n            \n            return (n % 10);\n        }\n\n        static void FindGap(int n, int gaps)\n        {\n            int count = 0;\n            while (count < gaps)\n            {\n\n                \n                string concat = firstNum(n).ToString() + lastNum(n).ToString();\n                \n                int i = Convert.ToInt32(concat);\n\n                \n                if (n % i == 0)\n                {\n                    Console.Write(n + \" \");\n                    count++;\n                    n++;\n                }\n                else\n                {\n                    n++;\n                    continue;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 110697, "name": "Gapful numbers", "source": "Translate COBOL to C#:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. GAPFUL.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 COMPUTATION.\n            02 N            PIC 9(10).\n            02 N-DIGITS     REDEFINES N.\n               03 ND        PIC 9 OCCURS 10 TIMES.\n            02 DIV-CHECK    PIC 9(10)V9(2).\n            02 DIV-PARTS    REDEFINES DIV-CHECK.\n               03 DIV-INT   PIC 9(10).\n               03 DIV-FRAC  PIC 9(2).\n            02 GAP-AMOUNT   PIC 99.\n            02 GAP-DSOR     PIC 99.\n            02 FIRST-DIGIT  PIC 99.\n        01 OUTPUT-FORMAT.\n            02 N-OUT        PIC Z(10).\n            \n        PROCEDURE DIVISION.\n        BEGIN.\n            DISPLAY \"First 30 gapful numbers >= 100:\".\n            MOVE 100 TO N. MOVE 30 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            \n            DISPLAY \" \".\n            DISPLAY \"First 15 gapful numbers >= 1000000:\".\n            MOVE 1000000 TO N. MOVE 15 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            \n            DISPLAY \" \".\n            DISPLAY \"First 10 gapful numbers >= 1000000000:\".\n            MOVE 1000000000 TO N. MOVE 10 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            STOP RUN.\n        \n        CHECK-GAPFUL-NUMBER.\n            SET FIRST-DIGIT TO 1.\n            INSPECT N TALLYING FIRST-DIGIT FOR LEADING '0'.\n            COMPUTE GAP-DSOR = ND(FIRST-DIGIT) * 10 + ND(10).\n            DIVIDE N BY GAP-DSOR GIVING DIV-CHECK.\n            IF DIV-FRAC IS EQUAL TO 0\n                MOVE N TO N-OUT\n                DISPLAY N-OUT\n                SUBTRACT 1 FROM GAP-AMOUNT.\n            ADD 1 TO N.\n            IF GAP-AMOUNT IS GREATER THAN 0 \n                GO TO CHECK-GAPFUL-NUMBER.\n", "target": "using System;\n\nnamespace GapfulNumbers\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"The first 30 gapful numbers are: \");\n            \n            FindGap(100, 30);\n\n            Console.WriteLine(\"The first 15 gapful numbers > 1,000,000 are: \");\n            FindGap(1000000, 15);\n\n            Console.WriteLine(\"The first 10 gapful numbers > 1,000,000,000 are: \");\n            FindGap(1000000000, 10);\n\n            Console.Read();\n        }\n\n        public static int firstNum(int n)\n        {\n            \n            while (n >= 10)\n            {\n                n /= 10;\n            }\n            return (n);\n        }\n\n        public static int lastNum(int n)\n        {\n            \n            return (n % 10);\n        }\n\n        static void FindGap(int n, int gaps)\n        {\n            int count = 0;\n            while (count < gaps)\n            {\n\n                \n                string concat = firstNum(n).ToString() + lastNum(n).ToString();\n                \n                int i = Convert.ToInt32(concat);\n\n                \n                if (n % i == 0)\n                {\n                    Console.Write(n + \" \");\n                    count++;\n                    n++;\n                }\n                else\n                {\n                    n++;\n                    continue;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 110700, "name": "Gapful numbers", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. GAPFUL.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 COMPUTATION.\n            02 N            PIC 9(10).\n            02 N-DIGITS     REDEFINES N.\n               03 ND        PIC 9 OCCURS 10 TIMES.\n            02 DIV-CHECK    PIC 9(10)V9(2).\n            02 DIV-PARTS    REDEFINES DIV-CHECK.\n               03 DIV-INT   PIC 9(10).\n               03 DIV-FRAC  PIC 9(2).\n            02 GAP-AMOUNT   PIC 99.\n            02 GAP-DSOR     PIC 99.\n            02 FIRST-DIGIT  PIC 99.\n        01 OUTPUT-FORMAT.\n            02 N-OUT        PIC Z(10).\n            \n        PROCEDURE DIVISION.\n        BEGIN.\n            DISPLAY \"First 30 gapful numbers >= 100:\".\n            MOVE 100 TO N. MOVE 30 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            \n            DISPLAY \" \".\n            DISPLAY \"First 15 gapful numbers >= 1000000:\".\n            MOVE 1000000 TO N. MOVE 15 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            \n            DISPLAY \" \".\n            DISPLAY \"First 10 gapful numbers >= 1000000000:\".\n            MOVE 1000000000 TO N. MOVE 10 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            STOP RUN.\n        \n        CHECK-GAPFUL-NUMBER.\n            SET FIRST-DIGIT TO 1.\n            INSPECT N TALLYING FIRST-DIGIT FOR LEADING '0'.\n            COMPUTE GAP-DSOR = ND(FIRST-DIGIT) * 10 + ND(10).\n            DIVIDE N BY GAP-DSOR GIVING DIV-CHECK.\n            IF DIV-FRAC IS EQUAL TO 0\n                MOVE N TO N-OUT\n                DISPLAY N-OUT\n                SUBTRACT 1 FROM GAP-AMOUNT.\n            ADD 1 TO N.\n            IF GAP-AMOUNT IS GREATER THAN 0 \n                GO TO CHECK-GAPFUL-NUMBER.\n", "target": "import java.util.List;\n\npublic class GapfulNumbers {\n    private static String commatize(long n) {\n        StringBuilder sb = new StringBuilder(Long.toString(n));\n        int le = sb.length();\n        for (int i = le - 3; i >= 1; i -= 3) {\n            sb.insert(i, ',');\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        List<Long> starts = List.of((long) 1e2, (long) 1e6, (long) 1e7, (long) 1e9, (long) 7123);\n        List<Integer> counts = List.of(30, 15, 15, 10, 25);\n        for (int i = 0; i < starts.size(); ++i) {\n            int count = 0;\n            Long j = starts.get(i);\n            long pow = 100;\n            while (j >= pow * 10) {\n                pow *= 10;\n            }\n            System.out.printf(\"First %d gapful numbers starting at %s:\\n\", counts.get(i), commatize(starts.get(i)));\n            while (count < counts.get(i)) {\n                long fl = (j / pow) * 10 + (j % 10);\n                if (j % fl == 0) {\n                    System.out.printf(\"%d \", j);\n                    count++;\n                }\n                j++;\n                if (j >= 10 * pow) {\n                    pow *= 10;\n                }\n            }\n            System.out.println('\\n');\n        }\n    }\n}\n"}
{"id": 110701, "name": "Gapful numbers", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. GAPFUL.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 COMPUTATION.\n            02 N            PIC 9(10).\n            02 N-DIGITS     REDEFINES N.\n               03 ND        PIC 9 OCCURS 10 TIMES.\n            02 DIV-CHECK    PIC 9(10)V9(2).\n            02 DIV-PARTS    REDEFINES DIV-CHECK.\n               03 DIV-INT   PIC 9(10).\n               03 DIV-FRAC  PIC 9(2).\n            02 GAP-AMOUNT   PIC 99.\n            02 GAP-DSOR     PIC 99.\n            02 FIRST-DIGIT  PIC 99.\n        01 OUTPUT-FORMAT.\n            02 N-OUT        PIC Z(10).\n            \n        PROCEDURE DIVISION.\n        BEGIN.\n            DISPLAY \"First 30 gapful numbers >= 100:\".\n            MOVE 100 TO N. MOVE 30 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            \n            DISPLAY \" \".\n            DISPLAY \"First 15 gapful numbers >= 1000000:\".\n            MOVE 1000000 TO N. MOVE 15 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            \n            DISPLAY \" \".\n            DISPLAY \"First 10 gapful numbers >= 1000000000:\".\n            MOVE 1000000000 TO N. MOVE 10 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            STOP RUN.\n        \n        CHECK-GAPFUL-NUMBER.\n            SET FIRST-DIGIT TO 1.\n            INSPECT N TALLYING FIRST-DIGIT FOR LEADING '0'.\n            COMPUTE GAP-DSOR = ND(FIRST-DIGIT) * 10 + ND(10).\n            DIVIDE N BY GAP-DSOR GIVING DIV-CHECK.\n            IF DIV-FRAC IS EQUAL TO 0\n                MOVE N TO N-OUT\n                DISPLAY N-OUT\n                SUBTRACT 1 FROM GAP-AMOUNT.\n            ADD 1 TO N.\n            IF GAP-AMOUNT IS GREATER THAN 0 \n                GO TO CHECK-GAPFUL-NUMBER.\n", "target": "import java.util.List;\n\npublic class GapfulNumbers {\n    private static String commatize(long n) {\n        StringBuilder sb = new StringBuilder(Long.toString(n));\n        int le = sb.length();\n        for (int i = le - 3; i >= 1; i -= 3) {\n            sb.insert(i, ',');\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        List<Long> starts = List.of((long) 1e2, (long) 1e6, (long) 1e7, (long) 1e9, (long) 7123);\n        List<Integer> counts = List.of(30, 15, 15, 10, 25);\n        for (int i = 0; i < starts.size(); ++i) {\n            int count = 0;\n            Long j = starts.get(i);\n            long pow = 100;\n            while (j >= pow * 10) {\n                pow *= 10;\n            }\n            System.out.printf(\"First %d gapful numbers starting at %s:\\n\", counts.get(i), commatize(starts.get(i)));\n            while (count < counts.get(i)) {\n                long fl = (j / pow) * 10 + (j % 10);\n                if (j % fl == 0) {\n                    System.out.printf(\"%d \", j);\n                    count++;\n                }\n                j++;\n                if (j >= 10 * pow) {\n                    pow *= 10;\n                }\n            }\n            System.out.println('\\n');\n        }\n    }\n}\n"}
{"id": 110702, "name": "Gapful numbers", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. GAPFUL.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 COMPUTATION.\n            02 N            PIC 9(10).\n            02 N-DIGITS     REDEFINES N.\n               03 ND        PIC 9 OCCURS 10 TIMES.\n            02 DIV-CHECK    PIC 9(10)V9(2).\n            02 DIV-PARTS    REDEFINES DIV-CHECK.\n               03 DIV-INT   PIC 9(10).\n               03 DIV-FRAC  PIC 9(2).\n            02 GAP-AMOUNT   PIC 99.\n            02 GAP-DSOR     PIC 99.\n            02 FIRST-DIGIT  PIC 99.\n        01 OUTPUT-FORMAT.\n            02 N-OUT        PIC Z(10).\n            \n        PROCEDURE DIVISION.\n        BEGIN.\n            DISPLAY \"First 30 gapful numbers >= 100:\".\n            MOVE 100 TO N. MOVE 30 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            \n            DISPLAY \" \".\n            DISPLAY \"First 15 gapful numbers >= 1000000:\".\n            MOVE 1000000 TO N. MOVE 15 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            \n            DISPLAY \" \".\n            DISPLAY \"First 10 gapful numbers >= 1000000000:\".\n            MOVE 1000000000 TO N. MOVE 10 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            STOP RUN.\n        \n        CHECK-GAPFUL-NUMBER.\n            SET FIRST-DIGIT TO 1.\n            INSPECT N TALLYING FIRST-DIGIT FOR LEADING '0'.\n            COMPUTE GAP-DSOR = ND(FIRST-DIGIT) * 10 + ND(10).\n            DIVIDE N BY GAP-DSOR GIVING DIV-CHECK.\n            IF DIV-FRAC IS EQUAL TO 0\n                MOVE N TO N-OUT\n                DISPLAY N-OUT\n                SUBTRACT 1 FROM GAP-AMOUNT.\n            ADD 1 TO N.\n            IF GAP-AMOUNT IS GREATER THAN 0 \n                GO TO CHECK-GAPFUL-NUMBER.\n", "target": "from itertools import islice, count\nfor start, n in [(100, 30), (1_000_000, 15), (1_000_000_000, 10)]:\n    print(f\"\\nFirst {n} gapful numbers from {start:_}\")\n    print(list(islice(( x for x in count(start) \n                        if (x % (int(str(x)[0]) * 10 + (x % 10)) == 0) )\n                      , n)))\n"}
{"id": 110703, "name": "Gapful numbers", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. GAPFUL.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 COMPUTATION.\n            02 N            PIC 9(10).\n            02 N-DIGITS     REDEFINES N.\n               03 ND        PIC 9 OCCURS 10 TIMES.\n            02 DIV-CHECK    PIC 9(10)V9(2).\n            02 DIV-PARTS    REDEFINES DIV-CHECK.\n               03 DIV-INT   PIC 9(10).\n               03 DIV-FRAC  PIC 9(2).\n            02 GAP-AMOUNT   PIC 99.\n            02 GAP-DSOR     PIC 99.\n            02 FIRST-DIGIT  PIC 99.\n        01 OUTPUT-FORMAT.\n            02 N-OUT        PIC Z(10).\n            \n        PROCEDURE DIVISION.\n        BEGIN.\n            DISPLAY \"First 30 gapful numbers >= 100:\".\n            MOVE 100 TO N. MOVE 30 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            \n            DISPLAY \" \".\n            DISPLAY \"First 15 gapful numbers >= 1000000:\".\n            MOVE 1000000 TO N. MOVE 15 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            \n            DISPLAY \" \".\n            DISPLAY \"First 10 gapful numbers >= 1000000000:\".\n            MOVE 1000000000 TO N. MOVE 10 TO GAP-AMOUNT.\n            PERFORM CHECK-GAPFUL-NUMBER.\n            STOP RUN.\n        \n        CHECK-GAPFUL-NUMBER.\n            SET FIRST-DIGIT TO 1.\n            INSPECT N TALLYING FIRST-DIGIT FOR LEADING '0'.\n            COMPUTE GAP-DSOR = ND(FIRST-DIGIT) * 10 + ND(10).\n            DIVIDE N BY GAP-DSOR GIVING DIV-CHECK.\n            IF DIV-FRAC IS EQUAL TO 0\n                MOVE N TO N-OUT\n                DISPLAY N-OUT\n                SUBTRACT 1 FROM GAP-AMOUNT.\n            ADD 1 TO N.\n            IF GAP-AMOUNT IS GREATER THAN 0 \n                GO TO CHECK-GAPFUL-NUMBER.\n", "target": "from itertools import islice, count\nfor start, n in [(100, 30), (1_000_000, 15), (1_000_000_000, 10)]:\n    print(f\"\\nFirst {n} gapful numbers from {start:_}\")\n    print(list(islice(( x for x in count(start) \n                        if (x % (int(str(x)[0]) * 10 + (x % 10)) == 0) )\n                      , n)))\n"}
{"id": 111135, "name": "Take notes on the command line", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. NOTES.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT OPTIONAL notes ASSIGN TO \"NOTES.TXT\"\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS note-status.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  notes.\n       01  note-record       PIC X(256).\n\n       LOCAL-STORAGE SECTION.\n       01  note-status       PIC 99.\n           88  notes-ok      VALUE 0 THRU 9.\n\n       01  date-now.\n           03  current-year  PIC 9(4).\n           03  current-month PIC 99.\n           03  current-day   PIC 99.\n\n       01  time-now.\n           03  current-hour  PIC 99.\n           03  current-min   PIC 99.\n           03  current-sec   PIC 99.\n\n       01  args              PIC X(256).\n\n       PROCEDURE DIVISION.\n       DECLARATIVES.\n       note-error SECTION.\n           USE AFTER STANDARD ERROR PROCEDURE ON notes.\n\n           DISPLAY \"Error using NOTES.TXT. Error code: \" note-status\n           .\n       END DECLARATIVES.\n\n       main.\n           ACCEPT args FROM COMMAND-LINE\n\n*          \n           IF args = SPACES\n               OPEN INPUT notes\n\n               PERFORM FOREVER\n*                  \n*                  \n                   READ notes \n                       AT END\n                           EXIT PERFORM\n\n                       NOT AT END\n                           DISPLAY FUNCTION TRIM(note-record)\n                   END-READ\n               END-PERFORM\n           ELSE\n               OPEN EXTEND notes\n\n*              \n               ACCEPT date-now FROM DATE YYYYMMDD\n               ACCEPT time-now FROM TIME\n               STRING current-year \"-\" current-month \"-\" current-day\n                   \" \" current-hour \":\" current-min \":\" current-sec\n                   INTO note-record\n               WRITE note-record\n               \n*              \n               STRING X\"09\", args INTO note-record\n               WRITE note-record\n           END-IF\n\n           CLOSE notes\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.IO;\nusing System.Text;\n\nnamespace RosettaCode\n{\n  internal class Program\n  {\n    private const string FileName = \"NOTES.TXT\";\n\n    private static void Main(string[] args)\n    {\n      if (args.Length==0)\n      {\n        string txt = File.ReadAllText(FileName);\n        Console.WriteLine(txt);\n      }\n      else\n      {\n        var sb = new StringBuilder();\n        sb.Append(DateTime.Now).Append(\"\\n\\t\");\n        foreach (string s in args)\n          sb.Append(s).Append(\" \");\n        sb.Append(\"\\n\");\n\n        if (File.Exists(FileName))\n          File.AppendAllText(FileName, sb.ToString());\n        else\n          File.WriteAllText(FileName, sb.ToString());\n      }\n    }\n  }\n}\n"}
{"id": 111137, "name": "Take notes on the command line", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. NOTES.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT OPTIONAL notes ASSIGN TO \"NOTES.TXT\"\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS note-status.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  notes.\n       01  note-record       PIC X(256).\n\n       LOCAL-STORAGE SECTION.\n       01  note-status       PIC 99.\n           88  notes-ok      VALUE 0 THRU 9.\n\n       01  date-now.\n           03  current-year  PIC 9(4).\n           03  current-month PIC 99.\n           03  current-day   PIC 99.\n\n       01  time-now.\n           03  current-hour  PIC 99.\n           03  current-min   PIC 99.\n           03  current-sec   PIC 99.\n\n       01  args              PIC X(256).\n\n       PROCEDURE DIVISION.\n       DECLARATIVES.\n       note-error SECTION.\n           USE AFTER STANDARD ERROR PROCEDURE ON notes.\n\n           DISPLAY \"Error using NOTES.TXT. Error code: \" note-status\n           .\n       END DECLARATIVES.\n\n       main.\n           ACCEPT args FROM COMMAND-LINE\n\n*          \n           IF args = SPACES\n               OPEN INPUT notes\n\n               PERFORM FOREVER\n*                  \n*                  \n                   READ notes \n                       AT END\n                           EXIT PERFORM\n\n                       NOT AT END\n                           DISPLAY FUNCTION TRIM(note-record)\n                   END-READ\n               END-PERFORM\n           ELSE\n               OPEN EXTEND notes\n\n*              \n               ACCEPT date-now FROM DATE YYYYMMDD\n               ACCEPT time-now FROM TIME\n               STRING current-year \"-\" current-month \"-\" current-day\n                   \" \" current-hour \":\" current-min \":\" current-sec\n                   INTO note-record\n               WRITE note-record\n               \n*              \n               STRING X\"09\", args INTO note-record\n               WRITE note-record\n           END-IF\n\n           CLOSE notes\n\n           GOBACK\n           .\n", "target": "import java.io.*;\nimport java.nio.channels.*;\nimport java.util.Date;\n\npublic class TakeNotes {\n    public static void main(String[] args) throws IOException {\n        if (args.length > 0) {\n            PrintStream ps = new PrintStream(new FileOutputStream(\"notes.txt\", true));\n            ps.println(new Date());\n            ps.print(\"\\t\" + args[0]);\n            for (int i = 1; i < args.length; i++)\n                ps.print(\" \" + args[i]);\n            ps.println();\n            ps.close();\n        } else {\n            FileChannel fc = new FileInputStream(\"notes.txt\").getChannel();\n            fc.transferTo(0, fc.size(), Channels.newChannel(System.out));\n            fc.close();\n        }\n    }\n}\n"}
{"id": 111138, "name": "Take notes on the command line", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. NOTES.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT OPTIONAL notes ASSIGN TO \"NOTES.TXT\"\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS note-status.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  notes.\n       01  note-record       PIC X(256).\n\n       LOCAL-STORAGE SECTION.\n       01  note-status       PIC 99.\n           88  notes-ok      VALUE 0 THRU 9.\n\n       01  date-now.\n           03  current-year  PIC 9(4).\n           03  current-month PIC 99.\n           03  current-day   PIC 99.\n\n       01  time-now.\n           03  current-hour  PIC 99.\n           03  current-min   PIC 99.\n           03  current-sec   PIC 99.\n\n       01  args              PIC X(256).\n\n       PROCEDURE DIVISION.\n       DECLARATIVES.\n       note-error SECTION.\n           USE AFTER STANDARD ERROR PROCEDURE ON notes.\n\n           DISPLAY \"Error using NOTES.TXT. Error code: \" note-status\n           .\n       END DECLARATIVES.\n\n       main.\n           ACCEPT args FROM COMMAND-LINE\n\n*          \n           IF args = SPACES\n               OPEN INPUT notes\n\n               PERFORM FOREVER\n*                  \n*                  \n                   READ notes \n                       AT END\n                           EXIT PERFORM\n\n                       NOT AT END\n                           DISPLAY FUNCTION TRIM(note-record)\n                   END-READ\n               END-PERFORM\n           ELSE\n               OPEN EXTEND notes\n\n*              \n               ACCEPT date-now FROM DATE YYYYMMDD\n               ACCEPT time-now FROM TIME\n               STRING current-year \"-\" current-month \"-\" current-day\n                   \" \" current-hour \":\" current-min \":\" current-sec\n                   INTO note-record\n               WRITE note-record\n               \n*              \n               STRING X\"09\", args INTO note-record\n               WRITE note-record\n           END-IF\n\n           CLOSE notes\n\n           GOBACK\n           .\n", "target": "import sys, datetime, shutil\n\nif len(sys.argv) == 1:\n    try:\n        with open(\"notes.txt\", \"r\") as f:\n            shutil.copyfileobj(f, sys.stdout)\n    except IOError:\n        pass\nelse:\n    with open(\"notes.txt\", \"a\") as f:\n        f.write(datetime.datetime.now().isoformat() + \"\\n\")\n        f.write(\"\\t%s\\n\" % ' '.join(sys.argv[1:]))\n"}
{"id": 112135, "name": "Memory allocation", "source": "Translate COBOL to C#:        PROGRAM-ID. memory-allocation.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  based-data              PIC X(20) VALUE \"Hello, World!\"\n                                   BASED.\n\n       PROCEDURE DIVISION.\n           \n           ALLOCATE based-data INITIALIZED\n           DISPLAY based-data\n           FREE based-data\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Runtime.InteropServices;\n\npublic unsafe class Program\n{\n    public static unsafe void HeapMemory()\n    {\n        const int HEAP_ZERO_MEMORY = 0x00000008;\n        const int size = 1000;\n        int ph = GetProcessHeap();\n        void* pointer = HeapAlloc(ph, HEAP_ZERO_MEMORY, size);\n        if (pointer == null)\n            throw new OutOfMemoryException();\n        Console.WriteLine(HeapSize(ph, 0, pointer));\n        HeapFree(ph, 0, pointer);\n    }\n\n    public static unsafe void StackMemory()\n    {\n        byte* buffer = stackalloc byte[1000];\n        \n    }\n    public static void Main(string[] args)\n    {\n        HeapMemory();\n        StackMemory();\n    }\n    [DllImport(\"kernel32\")]\n    static extern void* HeapAlloc(int hHeap, int flags, int size);\n    [DllImport(\"kernel32\")]\n    static extern bool HeapFree(int hHeap, int flags, void* block);\n    [DllImport(\"kernel32\")]\n    static extern int GetProcessHeap();\n    [DllImport(\"kernel32\")]\n    static extern int HeapSize(int hHeap, int flags, void* block);\n\n}\n"}
{"id": 112137, "name": "Memory allocation", "source": "Translate COBOL to Java:        PROGRAM-ID. memory-allocation.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  based-data              PIC X(20) VALUE \"Hello, World!\"\n                                   BASED.\n\n       PROCEDURE DIVISION.\n           \n           ALLOCATE based-data INITIALIZED\n           DISPLAY based-data\n           FREE based-data\n\n           GOBACK\n           .\n", "target": "\n\nObject foo = new Object(); \nint[] fooArray = new int[size]; \nint x = 0; \n"}
{"id": 112138, "name": "Memory allocation", "source": "Translate COBOL to Python:        PROGRAM-ID. memory-allocation.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  based-data              PIC X(20) VALUE \"Hello, World!\"\n                                   BASED.\n\n       PROCEDURE DIVISION.\n           \n           ALLOCATE based-data INITIALIZED\n           DISPLAY based-data\n           FREE based-data\n\n           GOBACK\n           .\n", "target": ">>> from array import array\n>>> argslist = [('l', []), ('c', 'hello world'), ('u', u'hello \\u2641'),\n\t('l', [1, 2, 3, 4, 5]), ('d', [1.0, 2.0, 3.14])]\n>>> for typecode, initializer in argslist:\n\ta = array(typecode, initializer)\n\tprint a\n\tdel a\n\n\t\narray('l')\narray('c', 'hello world')\narray('u', u'hello \\u2641')\narray('l', [1, 2, 3, 4, 5])\narray('d', [1.0, 2.0, 3.1400000000000001])\n>>>\n"}
{"id": 112600, "name": "Hostname", "source": "Translate COBOL to C#:        identification division.\n       program-id. hostname.\n\n       data division.\n       working-storage section.\n       01 hostname pic x(256).\n       01 nullpos  pic 999 value 1.\n\n       procedure division.\n       call \"gethostname\" using hostname by value length of hostname\n       string hostname delimited by low-value into hostname\n           with pointer nullpos\n       display \"Host: \" hostname(1 : nullpos - 1)\n       goback.\n       end program hostname.\n", "target": "System.Net.Dns.GetHostName();\n"}
{"id": 112601, "name": "Hostname", "source": "Translate COBOL to Java:        identification division.\n       program-id. hostname.\n\n       data division.\n       working-storage section.\n       01 hostname pic x(256).\n       01 nullpos  pic 999 value 1.\n\n       procedure division.\n       call \"gethostname\" using hostname by value length of hostname\n       string hostname delimited by low-value into hostname\n           with pointer nullpos\n       display \"Host: \" hostname(1 : nullpos - 1)\n       goback.\n       end program hostname.\n", "target": "import java.net.*;\nclass DiscoverHostName {\n public static void main(final String[] args) {\n  try {\n   System.out.println(InetAddress.getLocalHost().getHostName());\n  } catch (UnknownHostException e) { \n  }\n }\n}\n"}
{"id": 112602, "name": "Hostname", "source": "Translate COBOL to Python:        identification division.\n       program-id. hostname.\n\n       data division.\n       working-storage section.\n       01 hostname pic x(256).\n       01 nullpos  pic 999 value 1.\n\n       procedure division.\n       call \"gethostname\" using hostname by value length of hostname\n       string hostname delimited by low-value into hostname\n           with pointer nullpos\n       display \"Host: \" hostname(1 : nullpos - 1)\n       goback.\n       end program hostname.\n", "target": "import socket\nhost = socket.gethostname()\n"}
{"id": 112835, "name": "Guess the number", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Guess-The-Number.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Random-Num PIC 99.\n       01  Guess      PIC 99.\n\n       PROCEDURE DIVISION.\n           COMPUTE Random-Num = 1 + (FUNCTION RANDOM * 10)\n           DISPLAY \"Guess a number between 1 and 10:\"\n\n           PERFORM FOREVER\n               ACCEPT Guess\n\n               IF Guess = Random-Num\n                   DISPLAY \"Well guessed!\"\n                   EXIT PERFORM\n               ELSE\n                   DISPLAY \"That isn't it. Try again.\"\n               END-IF\n           END-PERFORM\n           \n           GOBACK\n           .\n", "target": "using System;\n\nclass GuessTheNumberGame\n{\n    static void Main()\n    {\n        int randomNumber = new Random().Next(1, 11);\n        \n        Console.WriteLine(\"I'm thinking of a number between 1 and 10. Can you guess it?\");\n        while(true)\n        {\n            Console.Write(\"Guess: \");\n            if (int.Parse(Console.ReadLine()) == randomNumber)\n                break;\n            Console.WriteLine(\"That's not it. Guess again.\");\n        }\n        Console.WriteLine(\"Congrats!! You guessed right!\");\n    }\n};\n"}
{"id": 112837, "name": "Guess the number", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Guess-The-Number.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Random-Num PIC 99.\n       01  Guess      PIC 99.\n\n       PROCEDURE DIVISION.\n           COMPUTE Random-Num = 1 + (FUNCTION RANDOM * 10)\n           DISPLAY \"Guess a number between 1 and 10:\"\n\n           PERFORM FOREVER\n               ACCEPT Guess\n\n               IF Guess = Random-Num\n                   DISPLAY \"Well guessed!\"\n                   EXIT PERFORM\n               ELSE\n                   DISPLAY \"That isn't it. Try again.\"\n               END-IF\n           END-PERFORM\n           \n           GOBACK\n           .\n", "target": "public class Guessing {\n    public static void main(String[] args) throws NumberFormatException{\n        int n = (int)(Math.random() * 10 + 1);\n        System.out.print(\"Guess the number between 1 and 10: \");\n        while(Integer.parseInt(System.console().readLine()) != n){\n            System.out.print(\"Wrong! Guess again: \");\n        }\n        System.out.println(\"Well guessed!\");\n    }\n}\n"}
{"id": 112838, "name": "Guess the number", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Guess-The-Number.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Random-Num PIC 99.\n       01  Guess      PIC 99.\n\n       PROCEDURE DIVISION.\n           COMPUTE Random-Num = 1 + (FUNCTION RANDOM * 10)\n           DISPLAY \"Guess a number between 1 and 10:\"\n\n           PERFORM FOREVER\n               ACCEPT Guess\n\n               IF Guess = Random-Num\n                   DISPLAY \"Well guessed!\"\n                   EXIT PERFORM\n               ELSE\n                   DISPLAY \"That isn't it. Try again.\"\n               END-IF\n           END-PERFORM\n           \n           GOBACK\n           .\n", "target": "import random\nt,g=random.randint(1,10),0\ng=int(input(\"Guess a number that's between 1 and 10: \"))\nwhile t!=g:g=int(input(\"Guess again! \"))\nprint(\"That's right!\")\n"}
{"id": 113479, "name": "Parsing_RPN calculator algorithm", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. RPN.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  \n       DATE-WRITTEN.  9 Feb 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Create a stack-based evaluator for an expression in  \n      **   reverse Polish notation (RPN)   that also shows the\n      **   changes in the stack as each individual token is\n      **   processed as a table.\n      ************************************************************\n       \n       DATA DIVISION.\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01  LineIn               PIC X(25).\n       01  IP                   PIC 99\n                  VALUE 1.\n       01  CInNum               PIC XXXX.\n\n       01  Stack                PIC S999999V9999999\n               OCCURS  50 times.\n       01  SP                   PIC 99\n                  VALUE 1.\n       01  Operator             PIC X.\n       01  Value1               PIC S999999V9999999.\n       01  Value2               PIC S999999V9999999.\n       01  Result               PIC S999999V9999999.\n       01  Idx                  PIC 99.\n       01  FormatNum            PIC ZZZZZZ9.9999999.\n       01  Zip                  PIC X.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n            DISPLAY \"Enter the RPN Equation: \" \n                     WITH NO ADVANCING.\n            ACCEPT LineIn.\n\n            PERFORM UNTIL IP GREATER THAN \n                          FUNCTION STORED-CHAR-LENGTH(LineIn)\n\n\n            UNSTRING LineIn DELIMITED BY SPACE INTO CInNum \n                    WITH POINTER IP\n\n            MOVE CInNum TO Operator\n\n            PERFORM Do-Operation\n\n            PERFORM Show-Stack\n\n            END-PERFORM.\n\n            DISPLAY \"End Result: \" FormatNum\n\n           STOP RUN.\n       \n       Do-Operation.\n\n          EVALUATE Operator\n          WHEN \"+\"\n                        PERFORM Pop\n                        Compute Result = Value2 + Value1\n                        PERFORM Push\n\n          WHEN \"-\"\n                        PERFORM Pop\n                        Compute Result = Value2 - Value1\n                        PERFORM Push\n\n          WHEN \"*\"\n                        PERFORM Pop\n                        Compute Result = Value2 * Value1\n                        PERFORM Push\n\n          WHEN \"/\"\n                        PERFORM Pop\n                        Compute Result = Value2 / Value1\n                        PERFORM Push\n\n          WHEN \"^\"\n                        PERFORM Pop\n                        Compute Result = Value2 ** Value1\n                        PERFORM Push\n\n          WHEN NUMERIC\n                       MOVE Operator TO Result\n                       PERFORM Push\n          END-EVALUATE.\n\n\n       Show-Stack.\n\n              DISPLAY \"STACK: \" WITH NO ADVANCING.\n              MOVE 1 TO Idx.\n              PERFORM UNTIL (Idx = SP)\n                      MOVE Stack(Idx) TO FormatNum\n                      IF Stack(Idx) IS NEGATIVE\n                         THEN\n                              DISPLAY \"    -\" FUNCTION TRIM(FormatNum)\n                                             WITH NO ADVANCING\n                         ELSE\n                              DISPLAY FormatNum WITH NO ADVANCING\n                     END-IF\n                      ADD 1 to Idx\n              END-PERFORM.\n                      DISPLAY \" \".\n\n       Push.\n\n             MOVE Result TO Stack(SP)\n             ADD 1 TO SP.\n\n       Pop.\n\n            SUBTRACT 1 FROM SP\n            MOVE Stack(SP) TO Value1\n            SUBTRACT 1 FROM SP\n            MOVE Stack(SP) TO Value2.\n\n\n       END-PROGRAM.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Globalization;\nusing System.Threading;\n\nnamespace RPNEvaluator\n{\n    class RPNEvaluator\n    {\n        static void Main(string[] args)\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n\n            string rpn = \"3 4 2 * 1 5 - 2 3 ^ ^ / +\";\n            Console.WriteLine(\"{0}\\n\", rpn);\n\n            decimal result = CalculateRPN(rpn);\n            Console.WriteLine(\"\\nResult is {0}\", result);\n        }\n\n        static decimal CalculateRPN(string rpn)\n        {\n            string[] rpnTokens = rpn.Split(' ');\n            Stack<decimal> stack = new Stack<decimal>();\n            decimal number = decimal.Zero;\n\n            foreach (string token in rpnTokens)\n            {\n                if (decimal.TryParse(token, out number))\n                {\n                    stack.Push(number);\n                }\n                else\n                {\n                    switch (token)\n                    {\n                        case \"^\":\n                        case \"pow\":\n                            {\n                                number = stack.Pop();\n                                stack.Push((decimal)Math.Pow((double)stack.Pop(), (double)number));\n                                break;\n                            }\n                        case \"ln\":\n                            {\n                                stack.Push((decimal)Math.Log((double)stack.Pop(), Math.E));\n                                break;\n                            }\n                        case \"sqrt\":\n                            {\n                                stack.Push((decimal)Math.Sqrt((double)stack.Pop()));\n                                break;\n                            }\n                        case \"*\":\n                            {\n                                stack.Push(stack.Pop() * stack.Pop());\n                                break;\n                            }\n                        case \"/\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() / number);\n                                break;\n                            }\n                        case \"+\":\n                            {\n                                stack.Push(stack.Pop() + stack.Pop());\n                                break;\n                            }\n                        case \"-\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() - number);\n                                break;\n                            }\n                        default:\n                            Console.WriteLine(\"Error in CalculateRPN(string) Method!\");\n                            break;\n                    }\n                }\n                PrintState(stack);\n            }\n\n            return stack.Pop();\n        }\n\n        static void PrintState(Stack<decimal> stack)\n        {\n            decimal[] arr = stack.ToArray();\n\n            for (int i = arr.Length - 1; i >= 0; i--)\n            {\n                Console.Write(\"{0,-8:F3}\", arr[i]);\n            }\n            \n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 113480, "name": "Parsing_RPN calculator algorithm", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. RPN.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  \n       DATE-WRITTEN.  9 Feb 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Create a stack-based evaluator for an expression in  \n      **   reverse Polish notation (RPN)   that also shows the\n      **   changes in the stack as each individual token is\n      **   processed as a table.\n      ************************************************************\n       \n       DATA DIVISION.\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01  LineIn               PIC X(25).\n       01  IP                   PIC 99\n                  VALUE 1.\n       01  CInNum               PIC XXXX.\n\n       01  Stack                PIC S999999V9999999\n               OCCURS  50 times.\n       01  SP                   PIC 99\n                  VALUE 1.\n       01  Operator             PIC X.\n       01  Value1               PIC S999999V9999999.\n       01  Value2               PIC S999999V9999999.\n       01  Result               PIC S999999V9999999.\n       01  Idx                  PIC 99.\n       01  FormatNum            PIC ZZZZZZ9.9999999.\n       01  Zip                  PIC X.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n            DISPLAY \"Enter the RPN Equation: \" \n                     WITH NO ADVANCING.\n            ACCEPT LineIn.\n\n            PERFORM UNTIL IP GREATER THAN \n                          FUNCTION STORED-CHAR-LENGTH(LineIn)\n\n\n            UNSTRING LineIn DELIMITED BY SPACE INTO CInNum \n                    WITH POINTER IP\n\n            MOVE CInNum TO Operator\n\n            PERFORM Do-Operation\n\n            PERFORM Show-Stack\n\n            END-PERFORM.\n\n            DISPLAY \"End Result: \" FormatNum\n\n           STOP RUN.\n       \n       Do-Operation.\n\n          EVALUATE Operator\n          WHEN \"+\"\n                        PERFORM Pop\n                        Compute Result = Value2 + Value1\n                        PERFORM Push\n\n          WHEN \"-\"\n                        PERFORM Pop\n                        Compute Result = Value2 - Value1\n                        PERFORM Push\n\n          WHEN \"*\"\n                        PERFORM Pop\n                        Compute Result = Value2 * Value1\n                        PERFORM Push\n\n          WHEN \"/\"\n                        PERFORM Pop\n                        Compute Result = Value2 / Value1\n                        PERFORM Push\n\n          WHEN \"^\"\n                        PERFORM Pop\n                        Compute Result = Value2 ** Value1\n                        PERFORM Push\n\n          WHEN NUMERIC\n                       MOVE Operator TO Result\n                       PERFORM Push\n          END-EVALUATE.\n\n\n       Show-Stack.\n\n              DISPLAY \"STACK: \" WITH NO ADVANCING.\n              MOVE 1 TO Idx.\n              PERFORM UNTIL (Idx = SP)\n                      MOVE Stack(Idx) TO FormatNum\n                      IF Stack(Idx) IS NEGATIVE\n                         THEN\n                              DISPLAY \"    -\" FUNCTION TRIM(FormatNum)\n                                             WITH NO ADVANCING\n                         ELSE\n                              DISPLAY FormatNum WITH NO ADVANCING\n                     END-IF\n                      ADD 1 to Idx\n              END-PERFORM.\n                      DISPLAY \" \".\n\n       Push.\n\n             MOVE Result TO Stack(SP)\n             ADD 1 TO SP.\n\n       Pop.\n\n            SUBTRACT 1 FROM SP\n            MOVE Stack(SP) TO Value1\n            SUBTRACT 1 FROM SP\n            MOVE Stack(SP) TO Value2.\n\n\n       END-PROGRAM.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Globalization;\nusing System.Threading;\n\nnamespace RPNEvaluator\n{\n    class RPNEvaluator\n    {\n        static void Main(string[] args)\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n\n            string rpn = \"3 4 2 * 1 5 - 2 3 ^ ^ / +\";\n            Console.WriteLine(\"{0}\\n\", rpn);\n\n            decimal result = CalculateRPN(rpn);\n            Console.WriteLine(\"\\nResult is {0}\", result);\n        }\n\n        static decimal CalculateRPN(string rpn)\n        {\n            string[] rpnTokens = rpn.Split(' ');\n            Stack<decimal> stack = new Stack<decimal>();\n            decimal number = decimal.Zero;\n\n            foreach (string token in rpnTokens)\n            {\n                if (decimal.TryParse(token, out number))\n                {\n                    stack.Push(number);\n                }\n                else\n                {\n                    switch (token)\n                    {\n                        case \"^\":\n                        case \"pow\":\n                            {\n                                number = stack.Pop();\n                                stack.Push((decimal)Math.Pow((double)stack.Pop(), (double)number));\n                                break;\n                            }\n                        case \"ln\":\n                            {\n                                stack.Push((decimal)Math.Log((double)stack.Pop(), Math.E));\n                                break;\n                            }\n                        case \"sqrt\":\n                            {\n                                stack.Push((decimal)Math.Sqrt((double)stack.Pop()));\n                                break;\n                            }\n                        case \"*\":\n                            {\n                                stack.Push(stack.Pop() * stack.Pop());\n                                break;\n                            }\n                        case \"/\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() / number);\n                                break;\n                            }\n                        case \"+\":\n                            {\n                                stack.Push(stack.Pop() + stack.Pop());\n                                break;\n                            }\n                        case \"-\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() - number);\n                                break;\n                            }\n                        default:\n                            Console.WriteLine(\"Error in CalculateRPN(string) Method!\");\n                            break;\n                    }\n                }\n                PrintState(stack);\n            }\n\n            return stack.Pop();\n        }\n\n        static void PrintState(Stack<decimal> stack)\n        {\n            decimal[] arr = stack.ToArray();\n\n            for (int i = arr.Length - 1; i >= 0; i--)\n            {\n                Console.Write(\"{0,-8:F3}\", arr[i]);\n            }\n            \n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 113483, "name": "Parsing_RPN calculator algorithm", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. RPN.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  \n       DATE-WRITTEN.  9 Feb 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Create a stack-based evaluator for an expression in  \n      **   reverse Polish notation (RPN)   that also shows the\n      **   changes in the stack as each individual token is\n      **   processed as a table.\n      ************************************************************\n       \n       DATA DIVISION.\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01  LineIn               PIC X(25).\n       01  IP                   PIC 99\n                  VALUE 1.\n       01  CInNum               PIC XXXX.\n\n       01  Stack                PIC S999999V9999999\n               OCCURS  50 times.\n       01  SP                   PIC 99\n                  VALUE 1.\n       01  Operator             PIC X.\n       01  Value1               PIC S999999V9999999.\n       01  Value2               PIC S999999V9999999.\n       01  Result               PIC S999999V9999999.\n       01  Idx                  PIC 99.\n       01  FormatNum            PIC ZZZZZZ9.9999999.\n       01  Zip                  PIC X.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n            DISPLAY \"Enter the RPN Equation: \" \n                     WITH NO ADVANCING.\n            ACCEPT LineIn.\n\n            PERFORM UNTIL IP GREATER THAN \n                          FUNCTION STORED-CHAR-LENGTH(LineIn)\n\n\n            UNSTRING LineIn DELIMITED BY SPACE INTO CInNum \n                    WITH POINTER IP\n\n            MOVE CInNum TO Operator\n\n            PERFORM Do-Operation\n\n            PERFORM Show-Stack\n\n            END-PERFORM.\n\n            DISPLAY \"End Result: \" FormatNum\n\n           STOP RUN.\n       \n       Do-Operation.\n\n          EVALUATE Operator\n          WHEN \"+\"\n                        PERFORM Pop\n                        Compute Result = Value2 + Value1\n                        PERFORM Push\n\n          WHEN \"-\"\n                        PERFORM Pop\n                        Compute Result = Value2 - Value1\n                        PERFORM Push\n\n          WHEN \"*\"\n                        PERFORM Pop\n                        Compute Result = Value2 * Value1\n                        PERFORM Push\n\n          WHEN \"/\"\n                        PERFORM Pop\n                        Compute Result = Value2 / Value1\n                        PERFORM Push\n\n          WHEN \"^\"\n                        PERFORM Pop\n                        Compute Result = Value2 ** Value1\n                        PERFORM Push\n\n          WHEN NUMERIC\n                       MOVE Operator TO Result\n                       PERFORM Push\n          END-EVALUATE.\n\n\n       Show-Stack.\n\n              DISPLAY \"STACK: \" WITH NO ADVANCING.\n              MOVE 1 TO Idx.\n              PERFORM UNTIL (Idx = SP)\n                      MOVE Stack(Idx) TO FormatNum\n                      IF Stack(Idx) IS NEGATIVE\n                         THEN\n                              DISPLAY \"    -\" FUNCTION TRIM(FormatNum)\n                                             WITH NO ADVANCING\n                         ELSE\n                              DISPLAY FormatNum WITH NO ADVANCING\n                     END-IF\n                      ADD 1 to Idx\n              END-PERFORM.\n                      DISPLAY \" \".\n\n       Push.\n\n             MOVE Result TO Stack(SP)\n             ADD 1 TO SP.\n\n       Pop.\n\n            SUBTRACT 1 FROM SP\n            MOVE Stack(SP) TO Value1\n            SUBTRACT 1 FROM SP\n            MOVE Stack(SP) TO Value2.\n\n\n       END-PROGRAM.\n", "target": "grammar rpnC ;\n\n\n\n\n\n@members {\nStack<Double> s = new Stack<Double>();\n}\nrpn\t:\t(WS* (num|op) (WS | WS* NEWLINE {System.out.println(s.pop());}))*;\nnum\t:\t'-'? Digit+ ('.' Digit+)? {s.push(Double.parseDouble($num.text));};\nDigit\t:\t'0'..'9';\nop\t:\t'-' {double x = s.pop(); s.push(s.pop() - x);}\n\t|\t'/' {double x = s.pop(); s.push(s.pop() / x);}\n\t|\t'*' {s.push(s.pop() * s.pop());}\n\t|\t'^' {double x = s.pop(); s.push(Math.pow(s.pop(), x));}\n\t|\t'+' {s.push(s.pop() + s.pop());};\nWS\t:\t(' ' | '\\t'){skip()};\nNEWLINE\t:\t'\\r'? '\\n';\n"}
{"id": 113484, "name": "Parsing_RPN calculator algorithm", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. RPN.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  \n       DATE-WRITTEN.  9 Feb 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Create a stack-based evaluator for an expression in  \n      **   reverse Polish notation (RPN)   that also shows the\n      **   changes in the stack as each individual token is\n      **   processed as a table.\n      ************************************************************\n       \n       DATA DIVISION.\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01  LineIn               PIC X(25).\n       01  IP                   PIC 99\n                  VALUE 1.\n       01  CInNum               PIC XXXX.\n\n       01  Stack                PIC S999999V9999999\n               OCCURS  50 times.\n       01  SP                   PIC 99\n                  VALUE 1.\n       01  Operator             PIC X.\n       01  Value1               PIC S999999V9999999.\n       01  Value2               PIC S999999V9999999.\n       01  Result               PIC S999999V9999999.\n       01  Idx                  PIC 99.\n       01  FormatNum            PIC ZZZZZZ9.9999999.\n       01  Zip                  PIC X.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n            DISPLAY \"Enter the RPN Equation: \" \n                     WITH NO ADVANCING.\n            ACCEPT LineIn.\n\n            PERFORM UNTIL IP GREATER THAN \n                          FUNCTION STORED-CHAR-LENGTH(LineIn)\n\n\n            UNSTRING LineIn DELIMITED BY SPACE INTO CInNum \n                    WITH POINTER IP\n\n            MOVE CInNum TO Operator\n\n            PERFORM Do-Operation\n\n            PERFORM Show-Stack\n\n            END-PERFORM.\n\n            DISPLAY \"End Result: \" FormatNum\n\n           STOP RUN.\n       \n       Do-Operation.\n\n          EVALUATE Operator\n          WHEN \"+\"\n                        PERFORM Pop\n                        Compute Result = Value2 + Value1\n                        PERFORM Push\n\n          WHEN \"-\"\n                        PERFORM Pop\n                        Compute Result = Value2 - Value1\n                        PERFORM Push\n\n          WHEN \"*\"\n                        PERFORM Pop\n                        Compute Result = Value2 * Value1\n                        PERFORM Push\n\n          WHEN \"/\"\n                        PERFORM Pop\n                        Compute Result = Value2 / Value1\n                        PERFORM Push\n\n          WHEN \"^\"\n                        PERFORM Pop\n                        Compute Result = Value2 ** Value1\n                        PERFORM Push\n\n          WHEN NUMERIC\n                       MOVE Operator TO Result\n                       PERFORM Push\n          END-EVALUATE.\n\n\n       Show-Stack.\n\n              DISPLAY \"STACK: \" WITH NO ADVANCING.\n              MOVE 1 TO Idx.\n              PERFORM UNTIL (Idx = SP)\n                      MOVE Stack(Idx) TO FormatNum\n                      IF Stack(Idx) IS NEGATIVE\n                         THEN\n                              DISPLAY \"    -\" FUNCTION TRIM(FormatNum)\n                                             WITH NO ADVANCING\n                         ELSE\n                              DISPLAY FormatNum WITH NO ADVANCING\n                     END-IF\n                      ADD 1 to Idx\n              END-PERFORM.\n                      DISPLAY \" \".\n\n       Push.\n\n             MOVE Result TO Stack(SP)\n             ADD 1 TO SP.\n\n       Pop.\n\n            SUBTRACT 1 FROM SP\n            MOVE Stack(SP) TO Value1\n            SUBTRACT 1 FROM SP\n            MOVE Stack(SP) TO Value2.\n\n\n       END-PROGRAM.\n", "target": "grammar rpnC ;\n\n\n\n\n\n@members {\nStack<Double> s = new Stack<Double>();\n}\nrpn\t:\t(WS* (num|op) (WS | WS* NEWLINE {System.out.println(s.pop());}))*;\nnum\t:\t'-'? Digit+ ('.' Digit+)? {s.push(Double.parseDouble($num.text));};\nDigit\t:\t'0'..'9';\nop\t:\t'-' {double x = s.pop(); s.push(s.pop() - x);}\n\t|\t'/' {double x = s.pop(); s.push(s.pop() / x);}\n\t|\t'*' {s.push(s.pop() * s.pop());}\n\t|\t'^' {double x = s.pop(); s.push(Math.pow(s.pop(), x));}\n\t|\t'+' {s.push(s.pop() + s.pop());};\nWS\t:\t(' ' | '\\t'){skip()};\nNEWLINE\t:\t'\\r'? '\\n';\n"}
{"id": 113485, "name": "Parsing_RPN calculator algorithm", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. RPN.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  \n       DATE-WRITTEN.  9 Feb 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Create a stack-based evaluator for an expression in  \n      **   reverse Polish notation (RPN)   that also shows the\n      **   changes in the stack as each individual token is\n      **   processed as a table.\n      ************************************************************\n       \n       DATA DIVISION.\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01  LineIn               PIC X(25).\n       01  IP                   PIC 99\n                  VALUE 1.\n       01  CInNum               PIC XXXX.\n\n       01  Stack                PIC S999999V9999999\n               OCCURS  50 times.\n       01  SP                   PIC 99\n                  VALUE 1.\n       01  Operator             PIC X.\n       01  Value1               PIC S999999V9999999.\n       01  Value2               PIC S999999V9999999.\n       01  Result               PIC S999999V9999999.\n       01  Idx                  PIC 99.\n       01  FormatNum            PIC ZZZZZZ9.9999999.\n       01  Zip                  PIC X.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n            DISPLAY \"Enter the RPN Equation: \" \n                     WITH NO ADVANCING.\n            ACCEPT LineIn.\n\n            PERFORM UNTIL IP GREATER THAN \n                          FUNCTION STORED-CHAR-LENGTH(LineIn)\n\n\n            UNSTRING LineIn DELIMITED BY SPACE INTO CInNum \n                    WITH POINTER IP\n\n            MOVE CInNum TO Operator\n\n            PERFORM Do-Operation\n\n            PERFORM Show-Stack\n\n            END-PERFORM.\n\n            DISPLAY \"End Result: \" FormatNum\n\n           STOP RUN.\n       \n       Do-Operation.\n\n          EVALUATE Operator\n          WHEN \"+\"\n                        PERFORM Pop\n                        Compute Result = Value2 + Value1\n                        PERFORM Push\n\n          WHEN \"-\"\n                        PERFORM Pop\n                        Compute Result = Value2 - Value1\n                        PERFORM Push\n\n          WHEN \"*\"\n                        PERFORM Pop\n                        Compute Result = Value2 * Value1\n                        PERFORM Push\n\n          WHEN \"/\"\n                        PERFORM Pop\n                        Compute Result = Value2 / Value1\n                        PERFORM Push\n\n          WHEN \"^\"\n                        PERFORM Pop\n                        Compute Result = Value2 ** Value1\n                        PERFORM Push\n\n          WHEN NUMERIC\n                       MOVE Operator TO Result\n                       PERFORM Push\n          END-EVALUATE.\n\n\n       Show-Stack.\n\n              DISPLAY \"STACK: \" WITH NO ADVANCING.\n              MOVE 1 TO Idx.\n              PERFORM UNTIL (Idx = SP)\n                      MOVE Stack(Idx) TO FormatNum\n                      IF Stack(Idx) IS NEGATIVE\n                         THEN\n                              DISPLAY \"    -\" FUNCTION TRIM(FormatNum)\n                                             WITH NO ADVANCING\n                         ELSE\n                              DISPLAY FormatNum WITH NO ADVANCING\n                     END-IF\n                      ADD 1 to Idx\n              END-PERFORM.\n                      DISPLAY \" \".\n\n       Push.\n\n             MOVE Result TO Stack(SP)\n             ADD 1 TO SP.\n\n       Pop.\n\n            SUBTRACT 1 FROM SP\n            MOVE Stack(SP) TO Value1\n            SUBTRACT 1 FROM SP\n            MOVE Stack(SP) TO Value2.\n\n\n       END-PROGRAM.\n", "target": "def op_pow(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a ** b )\ndef op_mul(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a * b )\ndef op_div(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a / b )\ndef op_add(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a + b )\ndef op_sub(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a - b )\ndef op_num(stack, num):\n    stack.append( num )\n    \nops = {\n '^': op_pow,\n '*': op_mul,\n '/': op_div,\n '+': op_add,\n '-': op_sub,\n }\n\ndef get_input(inp = None):\n    'Inputs an expression and returns list of tokens'\n    \n    if inp is None:\n        inp = input('expression: ')\n    tokens = inp.strip().split()\n    return tokens\n\ndef rpn_calc(tokens):\n    stack = []\n    table = ['TOKEN,ACTION,STACK'.split(',')]\n    for token in tokens:\n        if token in ops:\n            action = 'Apply op to top of stack'\n            ops[token](stack)\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n        else:\n            action = 'Push num onto top of stack'\n            op_num(stack, eval(token))\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n    return table\n\nif __name__ == '__main__':\n    rpn = '3 4 2 * 1 5 - 2 3 ^ ^ / +'\n    print( 'For RPN expression: %r\\n' % rpn )\n    rp = rpn_calc(get_input(rpn))\n    maxcolwidths = [max(len(y) for y in x) for x in zip(*rp)]\n    row = rp[0]\n    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n    for row in rp[1:]:\n        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n\n    print('\\n The final output value is: %r' % rp[-1][2])\n"}
{"id": 113486, "name": "Parsing_RPN calculator algorithm", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. RPN.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  \n       DATE-WRITTEN.  9 Feb 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Create a stack-based evaluator for an expression in  \n      **   reverse Polish notation (RPN)   that also shows the\n      **   changes in the stack as each individual token is\n      **   processed as a table.\n      ************************************************************\n       \n       DATA DIVISION.\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01  LineIn               PIC X(25).\n       01  IP                   PIC 99\n                  VALUE 1.\n       01  CInNum               PIC XXXX.\n\n       01  Stack                PIC S999999V9999999\n               OCCURS  50 times.\n       01  SP                   PIC 99\n                  VALUE 1.\n       01  Operator             PIC X.\n       01  Value1               PIC S999999V9999999.\n       01  Value2               PIC S999999V9999999.\n       01  Result               PIC S999999V9999999.\n       01  Idx                  PIC 99.\n       01  FormatNum            PIC ZZZZZZ9.9999999.\n       01  Zip                  PIC X.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n            DISPLAY \"Enter the RPN Equation: \" \n                     WITH NO ADVANCING.\n            ACCEPT LineIn.\n\n            PERFORM UNTIL IP GREATER THAN \n                          FUNCTION STORED-CHAR-LENGTH(LineIn)\n\n\n            UNSTRING LineIn DELIMITED BY SPACE INTO CInNum \n                    WITH POINTER IP\n\n            MOVE CInNum TO Operator\n\n            PERFORM Do-Operation\n\n            PERFORM Show-Stack\n\n            END-PERFORM.\n\n            DISPLAY \"End Result: \" FormatNum\n\n           STOP RUN.\n       \n       Do-Operation.\n\n          EVALUATE Operator\n          WHEN \"+\"\n                        PERFORM Pop\n                        Compute Result = Value2 + Value1\n                        PERFORM Push\n\n          WHEN \"-\"\n                        PERFORM Pop\n                        Compute Result = Value2 - Value1\n                        PERFORM Push\n\n          WHEN \"*\"\n                        PERFORM Pop\n                        Compute Result = Value2 * Value1\n                        PERFORM Push\n\n          WHEN \"/\"\n                        PERFORM Pop\n                        Compute Result = Value2 / Value1\n                        PERFORM Push\n\n          WHEN \"^\"\n                        PERFORM Pop\n                        Compute Result = Value2 ** Value1\n                        PERFORM Push\n\n          WHEN NUMERIC\n                       MOVE Operator TO Result\n                       PERFORM Push\n          END-EVALUATE.\n\n\n       Show-Stack.\n\n              DISPLAY \"STACK: \" WITH NO ADVANCING.\n              MOVE 1 TO Idx.\n              PERFORM UNTIL (Idx = SP)\n                      MOVE Stack(Idx) TO FormatNum\n                      IF Stack(Idx) IS NEGATIVE\n                         THEN\n                              DISPLAY \"    -\" FUNCTION TRIM(FormatNum)\n                                             WITH NO ADVANCING\n                         ELSE\n                              DISPLAY FormatNum WITH NO ADVANCING\n                     END-IF\n                      ADD 1 to Idx\n              END-PERFORM.\n                      DISPLAY \" \".\n\n       Push.\n\n             MOVE Result TO Stack(SP)\n             ADD 1 TO SP.\n\n       Pop.\n\n            SUBTRACT 1 FROM SP\n            MOVE Stack(SP) TO Value1\n            SUBTRACT 1 FROM SP\n            MOVE Stack(SP) TO Value2.\n\n\n       END-PROGRAM.\n", "target": "def op_pow(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a ** b )\ndef op_mul(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a * b )\ndef op_div(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a / b )\ndef op_add(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a + b )\ndef op_sub(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a - b )\ndef op_num(stack, num):\n    stack.append( num )\n    \nops = {\n '^': op_pow,\n '*': op_mul,\n '/': op_div,\n '+': op_add,\n '-': op_sub,\n }\n\ndef get_input(inp = None):\n    'Inputs an expression and returns list of tokens'\n    \n    if inp is None:\n        inp = input('expression: ')\n    tokens = inp.strip().split()\n    return tokens\n\ndef rpn_calc(tokens):\n    stack = []\n    table = ['TOKEN,ACTION,STACK'.split(',')]\n    for token in tokens:\n        if token in ops:\n            action = 'Apply op to top of stack'\n            ops[token](stack)\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n        else:\n            action = 'Push num onto top of stack'\n            op_num(stack, eval(token))\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n    return table\n\nif __name__ == '__main__':\n    rpn = '3 4 2 * 1 5 - 2 3 ^ ^ / +'\n    print( 'For RPN expression: %r\\n' % rpn )\n    rp = rpn_calc(get_input(rpn))\n    maxcolwidths = [max(len(y) for y in x) for x in zip(*rp)]\n    row = rp[0]\n    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n    for row in rp[1:]:\n        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n\n    print('\\n The final output value is: %r' % rp[-1][2])\n"}
{"id": 113814, "name": "Run-length encoding", "source": "Translate COBOL to C#:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. run-length-encoding.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION encode\n    FUNCTION decode\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  input-str                           PIC A(100).\n01  encoded                             PIC X(200).\n01  decoded                             PIC X(200).\n\nPROCEDURE DIVISION.\n    ACCEPT input-str\n    MOVE encode(FUNCTION TRIM(input-str)) TO encoded\n    DISPLAY \"Encoded: \" FUNCTION TRIM(encoded)\n    DISPLAY \"Decoded: \" FUNCTION TRIM(decode(encoded))\n    .\nEND PROGRAM run-length-encoding.\n\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. encode.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  str-len                             PIC 9(3) COMP.\n\n01  i                                   PIC 9(3) COMP.\n\n01  current-char                        PIC A.\n\n01  num-chars                           PIC 9(3) COMP.\n01  num-chars-disp                      PIC Z(3).\n\n01  encoded-pos                         PIC 9(3) COMP VALUE 1.\n\nLINKAGE SECTION.\n01  str                                 PIC X ANY LENGTH.\n\n01  encoded                             PIC X(200).\n\nPROCEDURE DIVISION USING str RETURNING encoded.\n    MOVE FUNCTION LENGTH(str) TO str-len\n    MOVE str (1:1) TO current-char\n    MOVE 1 TO num-chars\n    PERFORM VARYING i FROM 2 BY 1 UNTIL i > str-len\n        IF str (i:1) <> current-char\n            CALL \"add-num-chars\" USING encoded, encoded-pos,\n                CONTENT current-char, num-chars\n                \n            MOVE str (i:1) TO current-char\n            MOVE 1 TO num-chars\n        ELSE\n            ADD 1 TO num-chars\n        END-IF\n    END-PERFORM\n\n    CALL \"add-num-chars\" USING encoded, encoded-pos, CONTENT current-char,\n        num-chars\n    .\nEND FUNCTION encode.\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. add-num-chars.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  num-chars-disp                      PIC Z(3).\n\nLINKAGE SECTION.\n01  str                                 PIC X(200).\n\n01  current-pos                         PIC 9(3) COMP.\n\n01  char-to-encode                      PIC X.\n\n01  num-chars                           PIC 9(3) COMP.\n\nPROCEDURE DIVISION USING str, current-pos, char-to-encode, num-chars.\n    MOVE num-chars TO num-chars-disp\n    MOVE FUNCTION TRIM(num-chars-disp) TO str (current-pos:3)\n    ADD FUNCTION LENGTH(FUNCTION TRIM(num-chars-disp)) TO current-pos\n    MOVE char-to-encode TO str (current-pos:1)\n    ADD 1 TO current-pos\n    .\nEND PROGRAM add-num-chars.\n\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. decode.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  encoded-pos                         PIC 9(3) COMP VALUE 1.\n01  decoded-pos                         PIC 9(3) COMP VALUE 1.\n\n01  num-of-char                         PIC 9(3) COMP VALUE 0.\n\nLINKAGE SECTION.\n01  encoded                             PIC X(200).\n\n01  decoded                             PIC X(100).\n\nPROCEDURE DIVISION USING encoded RETURNING decoded.\n    PERFORM VARYING encoded-pos FROM 1 BY 1\n            UNTIL encoded (encoded-pos:2) = SPACES OR encoded-pos > 200\n        IF encoded (encoded-pos:1) IS NUMERIC\n            COMPUTE num-of-char = num-of-char * 10\n                + FUNCTION NUMVAL(encoded (encoded-pos:1))\n        ELSE\n            PERFORM UNTIL num-of-char = 0\n                MOVE encoded (encoded-pos:1) TO decoded (decoded-pos:1)\n                ADD 1 TO decoded-pos\n                SUBTRACT 1 FROM num-of-char\n            END-PERFORM\n        END-IF\n    END-PERFORM\n    .\nEND FUNCTION decode.\n", "target": "using System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nusing static System.Linq.Enumerable;\n\nnamespace RunLengthEncoding\n{\n    static class Program\n    {\n          public static string Encode(string input) => input.Length ==0 ? \"\" : input.Skip(1)\n            .Aggregate((t:input[0].ToString(),o:Empty<string>()),\n               (a,c)=>a.t[0]==c ? (a.t+c,a.o) : (c.ToString(),a.o.Append(a.t)),\n               a=>a.o.Append(a.t).Select(p => (key: p.Length, chr: p[0])))\n            .Select(p=> $\"{p.key}{p.chr}\")\n            .StringConcat();\n\n        public static string Decode(string input) => input\n            .Aggregate((t: \"\", o: Empty<string>()), (a, c) => !char.IsDigit(c) ? (\"\", a.o.Append(a.t+c)) : (a.t + c,a.o)).o \n            .Select(p => new string(p.Last(), int.Parse(string.Concat(p.Where(char.IsDigit)))))\n            .StringConcat();\n\n        private static string StringConcat(this IEnumerable<string> seq) => string.Concat(seq);\n        \n        public static void Main(string[] args)\n        {\n            const string  raw = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n            const string encoded = \"12W1B12W3B24W1B14W\";\n\n            WriteLine($\"raw = {raw}\");\n            WriteLine($\"encoded = {encoded}\");\n            WriteLine($\"Encode(raw) = encoded = {Encode(raw)}\");\n            WriteLine($\"Decode(encode) = {Decode(encoded)}\");\n            WriteLine($\"Decode(Encode(raw)) = {Decode(Encode(raw)) == raw}\");\n            ReadLine();\n        }\n    }\n}\n"}
{"id": 113816, "name": "Run-length encoding", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. run-length-encoding.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION encode\n    FUNCTION decode\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  input-str                           PIC A(100).\n01  encoded                             PIC X(200).\n01  decoded                             PIC X(200).\n\nPROCEDURE DIVISION.\n    ACCEPT input-str\n    MOVE encode(FUNCTION TRIM(input-str)) TO encoded\n    DISPLAY \"Encoded: \" FUNCTION TRIM(encoded)\n    DISPLAY \"Decoded: \" FUNCTION TRIM(decode(encoded))\n    .\nEND PROGRAM run-length-encoding.\n\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. encode.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  str-len                             PIC 9(3) COMP.\n\n01  i                                   PIC 9(3) COMP.\n\n01  current-char                        PIC A.\n\n01  num-chars                           PIC 9(3) COMP.\n01  num-chars-disp                      PIC Z(3).\n\n01  encoded-pos                         PIC 9(3) COMP VALUE 1.\n\nLINKAGE SECTION.\n01  str                                 PIC X ANY LENGTH.\n\n01  encoded                             PIC X(200).\n\nPROCEDURE DIVISION USING str RETURNING encoded.\n    MOVE FUNCTION LENGTH(str) TO str-len\n    MOVE str (1:1) TO current-char\n    MOVE 1 TO num-chars\n    PERFORM VARYING i FROM 2 BY 1 UNTIL i > str-len\n        IF str (i:1) <> current-char\n            CALL \"add-num-chars\" USING encoded, encoded-pos,\n                CONTENT current-char, num-chars\n                \n            MOVE str (i:1) TO current-char\n            MOVE 1 TO num-chars\n        ELSE\n            ADD 1 TO num-chars\n        END-IF\n    END-PERFORM\n\n    CALL \"add-num-chars\" USING encoded, encoded-pos, CONTENT current-char,\n        num-chars\n    .\nEND FUNCTION encode.\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. add-num-chars.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  num-chars-disp                      PIC Z(3).\n\nLINKAGE SECTION.\n01  str                                 PIC X(200).\n\n01  current-pos                         PIC 9(3) COMP.\n\n01  char-to-encode                      PIC X.\n\n01  num-chars                           PIC 9(3) COMP.\n\nPROCEDURE DIVISION USING str, current-pos, char-to-encode, num-chars.\n    MOVE num-chars TO num-chars-disp\n    MOVE FUNCTION TRIM(num-chars-disp) TO str (current-pos:3)\n    ADD FUNCTION LENGTH(FUNCTION TRIM(num-chars-disp)) TO current-pos\n    MOVE char-to-encode TO str (current-pos:1)\n    ADD 1 TO current-pos\n    .\nEND PROGRAM add-num-chars.\n\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. decode.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  encoded-pos                         PIC 9(3) COMP VALUE 1.\n01  decoded-pos                         PIC 9(3) COMP VALUE 1.\n\n01  num-of-char                         PIC 9(3) COMP VALUE 0.\n\nLINKAGE SECTION.\n01  encoded                             PIC X(200).\n\n01  decoded                             PIC X(100).\n\nPROCEDURE DIVISION USING encoded RETURNING decoded.\n    PERFORM VARYING encoded-pos FROM 1 BY 1\n            UNTIL encoded (encoded-pos:2) = SPACES OR encoded-pos > 200\n        IF encoded (encoded-pos:1) IS NUMERIC\n            COMPUTE num-of-char = num-of-char * 10\n                + FUNCTION NUMVAL(encoded (encoded-pos:1))\n        ELSE\n            PERFORM UNTIL num-of-char = 0\n                MOVE encoded (encoded-pos:1) TO decoded (decoded-pos:1)\n                ADD 1 TO decoded-pos\n                SUBTRACT 1 FROM num-of-char\n            END-PERFORM\n        END-IF\n    END-PERFORM\n    .\nEND FUNCTION decode.\n", "target": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\npublic class RunLengthEncoding {\n\n    public static String encode(String source) {\n        StringBuffer dest = new StringBuffer();\n        for (int i = 0; i < source.length(); i++) {\n            int runLength = 1;\n            while (i+1 < source.length() && source.charAt(i) == source.charAt(i+1)) {\n                runLength++;\n                i++;\n            }\n            dest.append(runLength);\n            dest.append(source.charAt(i));\n        }\n        return dest.toString();\n    }\n\n    public static String decode(String source) {\n        StringBuffer dest = new StringBuffer();\n        Pattern pattern = Pattern.compile(\"[0-9]+|[a-zA-Z]\");\n        Matcher matcher = pattern.matcher(source);\n        while (matcher.find()) {\n            int number = Integer.parseInt(matcher.group());\n            matcher.find();\n            while (number-- != 0) {\n                dest.append(matcher.group());\n            }\n        }\n        return dest.toString();\n    }\n\n    public static void main(String[] args) {\n        String example = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n        System.out.println(encode(example));\n        System.out.println(decode(\"1W1B1W1B1W1B1W1B1W1B1W1B1W1B\"));\n    }\n}\n"}
{"id": 113817, "name": "Run-length encoding", "source": "Translate COBOL to Python:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. run-length-encoding.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION encode\n    FUNCTION decode\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  input-str                           PIC A(100).\n01  encoded                             PIC X(200).\n01  decoded                             PIC X(200).\n\nPROCEDURE DIVISION.\n    ACCEPT input-str\n    MOVE encode(FUNCTION TRIM(input-str)) TO encoded\n    DISPLAY \"Encoded: \" FUNCTION TRIM(encoded)\n    DISPLAY \"Decoded: \" FUNCTION TRIM(decode(encoded))\n    .\nEND PROGRAM run-length-encoding.\n\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. encode.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  str-len                             PIC 9(3) COMP.\n\n01  i                                   PIC 9(3) COMP.\n\n01  current-char                        PIC A.\n\n01  num-chars                           PIC 9(3) COMP.\n01  num-chars-disp                      PIC Z(3).\n\n01  encoded-pos                         PIC 9(3) COMP VALUE 1.\n\nLINKAGE SECTION.\n01  str                                 PIC X ANY LENGTH.\n\n01  encoded                             PIC X(200).\n\nPROCEDURE DIVISION USING str RETURNING encoded.\n    MOVE FUNCTION LENGTH(str) TO str-len\n    MOVE str (1:1) TO current-char\n    MOVE 1 TO num-chars\n    PERFORM VARYING i FROM 2 BY 1 UNTIL i > str-len\n        IF str (i:1) <> current-char\n            CALL \"add-num-chars\" USING encoded, encoded-pos,\n                CONTENT current-char, num-chars\n                \n            MOVE str (i:1) TO current-char\n            MOVE 1 TO num-chars\n        ELSE\n            ADD 1 TO num-chars\n        END-IF\n    END-PERFORM\n\n    CALL \"add-num-chars\" USING encoded, encoded-pos, CONTENT current-char,\n        num-chars\n    .\nEND FUNCTION encode.\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. add-num-chars.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  num-chars-disp                      PIC Z(3).\n\nLINKAGE SECTION.\n01  str                                 PIC X(200).\n\n01  current-pos                         PIC 9(3) COMP.\n\n01  char-to-encode                      PIC X.\n\n01  num-chars                           PIC 9(3) COMP.\n\nPROCEDURE DIVISION USING str, current-pos, char-to-encode, num-chars.\n    MOVE num-chars TO num-chars-disp\n    MOVE FUNCTION TRIM(num-chars-disp) TO str (current-pos:3)\n    ADD FUNCTION LENGTH(FUNCTION TRIM(num-chars-disp)) TO current-pos\n    MOVE char-to-encode TO str (current-pos:1)\n    ADD 1 TO current-pos\n    .\nEND PROGRAM add-num-chars.\n\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. decode.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  encoded-pos                         PIC 9(3) COMP VALUE 1.\n01  decoded-pos                         PIC 9(3) COMP VALUE 1.\n\n01  num-of-char                         PIC 9(3) COMP VALUE 0.\n\nLINKAGE SECTION.\n01  encoded                             PIC X(200).\n\n01  decoded                             PIC X(100).\n\nPROCEDURE DIVISION USING encoded RETURNING decoded.\n    PERFORM VARYING encoded-pos FROM 1 BY 1\n            UNTIL encoded (encoded-pos:2) = SPACES OR encoded-pos > 200\n        IF encoded (encoded-pos:1) IS NUMERIC\n            COMPUTE num-of-char = num-of-char * 10\n                + FUNCTION NUMVAL(encoded (encoded-pos:1))\n        ELSE\n            PERFORM UNTIL num-of-char = 0\n                MOVE encoded (encoded-pos:1) TO decoded (decoded-pos:1)\n                ADD 1 TO decoded-pos\n                SUBTRACT 1 FROM num-of-char\n            END-PERFORM\n        END-IF\n    END-PERFORM\n    .\nEND FUNCTION decode.\n", "target": "def encode(input_string):\n    count = 1\n    prev = None\n    lst = []\n    for character in input_string:\n        if character != prev:\n            if prev:\n                entry = (prev, count)\n                lst.append(entry)\n            count = 1\n            prev = character\n        else:\n            count += 1\n    else:\n        try:\n            entry = (character, count)\n            lst.append(entry)\n            return (lst, 0)\n        except Exception as e:\n            print(\"Exception encountered {e}\".format(e=e)) \n            return (e, 1)\n \ndef decode(lst):\n    q = []\n    for character, count in lst:\n        q.append(character * count)\n    return ''.join(q)\n \n\nvalue = encode(\"aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa\")\nif value[1] == 0:\n    print(\"Encoded value is {}\".format(value[0]))\n    decode(value[0])\n"}
{"id": 114571, "name": "A+B", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. A-Plus-B.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A       PIC S9(5).\n       01  B       PIC S9(5).\n\n       01  A-B-Sum PIC S9(5).\n\n       PROCEDURE DIVISION.\n           ACCEPT A\n           ACCEPT B\n\n           ADD A TO B GIVING A-B-Sum\n\n           DISPLAY A-B-Sum\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(Console.ReadLine().Split().Select(int.Parse).Sum());\n    }\n}\n"}
{"id": 114572, "name": "A+B", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. A-Plus-B.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A       PIC S9(5).\n       01  B       PIC S9(5).\n\n       01  A-B-Sum PIC S9(5).\n\n       PROCEDURE DIVISION.\n           ACCEPT A\n           ACCEPT B\n\n           ADD A TO B GIVING A-B-Sum\n\n           DISPLAY A-B-Sum\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(Console.ReadLine().Split().Select(int.Parse).Sum());\n    }\n}\n"}
{"id": 114575, "name": "A+B", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. A-Plus-B.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A       PIC S9(5).\n       01  B       PIC S9(5).\n\n       01  A-B-Sum PIC S9(5).\n\n       PROCEDURE DIVISION.\n           ACCEPT A\n           ACCEPT B\n\n           ADD A TO B GIVING A-B-Sum\n\n           DISPLAY A-B-Sum\n\n           GOBACK\n           .\n", "target": "import java.util.Scanner;\n\npublic class Sum2 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in); \n        System.out.println(in.nextInt() + in.nextInt()); \n    }\n}\n"}
{"id": 114576, "name": "A+B", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. A-Plus-B.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A       PIC S9(5).\n       01  B       PIC S9(5).\n\n       01  A-B-Sum PIC S9(5).\n\n       PROCEDURE DIVISION.\n           ACCEPT A\n           ACCEPT B\n\n           ADD A TO B GIVING A-B-Sum\n\n           DISPLAY A-B-Sum\n\n           GOBACK\n           .\n", "target": "import java.util.Scanner;\n\npublic class Sum2 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in); \n        System.out.println(in.nextInt() + in.nextInt()); \n    }\n}\n"}
{"id": 114577, "name": "A+B", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. A-Plus-B.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A       PIC S9(5).\n       01  B       PIC S9(5).\n\n       01  A-B-Sum PIC S9(5).\n\n       PROCEDURE DIVISION.\n           ACCEPT A\n           ACCEPT B\n\n           ADD A TO B GIVING A-B-Sum\n\n           DISPLAY A-B-Sum\n\n           GOBACK\n           .\n", "target": "try: raw_input\nexcept: raw_input = input\n\nprint(sum(map(int, raw_input().split())))\n"}
{"id": 114578, "name": "A+B", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. A-Plus-B.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A       PIC S9(5).\n       01  B       PIC S9(5).\n\n       01  A-B-Sum PIC S9(5).\n\n       PROCEDURE DIVISION.\n           ACCEPT A\n           ACCEPT B\n\n           ADD A TO B GIVING A-B-Sum\n\n           DISPLAY A-B-Sum\n\n           GOBACK\n           .\n", "target": "try: raw_input\nexcept: raw_input = input\n\nprint(sum(map(int, raw_input().split())))\n"}
{"id": 114945, "name": "Leap year", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. leap-year.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  examples VALUE \"19001994199619972000\".\n           03  year PIC 9(4) OCCURS 5 TIMES\n               INDEXED BY year-index.\n\n       01  remainders.\n           03 400-rem   PIC 9(4).\n           03 100-rem   PIC 9(4).\n           03 4-rem     PIC 9(4).\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING year-index FROM 1 BY 1 UNTIL 5 < year-index\n               MOVE FUNCTION MOD(year (year-index), 400) TO 400-rem\n               MOVE FUNCTION MOD(year (year-index), 100) TO 100-rem\n               MOVE FUNCTION MOD(year (year-index), 4) TO 4-rem\n\n               IF 400-rem = 0 OR ((100-rem NOT = 0) AND 4-rem = 0)\n                   DISPLAY year (year-index) \" is a leap year.\"\n               ELSE\n                   DISPLAY year (year-index) \" is not a leap year.\"\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        foreach (var year in new[] { 1900, 1994, 1996, DateTime.Now.Year })\n        {\n            Console.WriteLine(\"{0} is {1}a leap year.\",\n                              year,\n                              DateTime.IsLeapYear(year) ? string.Empty : \"not \");\n        }\n    }\n}\n"}
{"id": 114947, "name": "Leap year", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. leap-year.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  examples VALUE \"19001994199619972000\".\n           03  year PIC 9(4) OCCURS 5 TIMES\n               INDEXED BY year-index.\n\n       01  remainders.\n           03 400-rem   PIC 9(4).\n           03 100-rem   PIC 9(4).\n           03 4-rem     PIC 9(4).\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING year-index FROM 1 BY 1 UNTIL 5 < year-index\n               MOVE FUNCTION MOD(year (year-index), 400) TO 400-rem\n               MOVE FUNCTION MOD(year (year-index), 100) TO 100-rem\n               MOVE FUNCTION MOD(year (year-index), 4) TO 4-rem\n\n               IF 400-rem = 0 OR ((100-rem NOT = 0) AND 4-rem = 0)\n                   DISPLAY year (year-index) \" is a leap year.\"\n               ELSE\n                   DISPLAY year (year-index) \" is not a leap year.\"\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "import java.util.GregorianCalendar;\nimport java.text.MessageFormat;\n\npublic class Leapyear{\n        public static void main(String[] argv){\n                int[] yrs = {1800,1900,1994,1998,1999,2000,2001,2004,2100};\n                GregorianCalendar cal = new GregorianCalendar();\n                for(int year : yrs){\n                        System.err.println(MessageFormat.format(\"The year {0,number,#} is leaper: {1} / {2}.\",\n                                                                 year, cal.isLeapYear(year), isLeapYear(year)));\n                }\n\n        }\n        public static boolean isLeapYear(int year){\n                return (year % 100 == 0) ? (year % 400 == 0) : (year % 4 == 0);\n        }\n}\n"}
{"id": 114948, "name": "Leap year", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. leap-year.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  examples VALUE \"19001994199619972000\".\n           03  year PIC 9(4) OCCURS 5 TIMES\n               INDEXED BY year-index.\n\n       01  remainders.\n           03 400-rem   PIC 9(4).\n           03 100-rem   PIC 9(4).\n           03 4-rem     PIC 9(4).\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING year-index FROM 1 BY 1 UNTIL 5 < year-index\n               MOVE FUNCTION MOD(year (year-index), 400) TO 400-rem\n               MOVE FUNCTION MOD(year (year-index), 100) TO 100-rem\n               MOVE FUNCTION MOD(year (year-index), 4) TO 4-rem\n\n               IF 400-rem = 0 OR ((100-rem NOT = 0) AND 4-rem = 0)\n                   DISPLAY year (year-index) \" is a leap year.\"\n               ELSE\n                   DISPLAY year (year-index) \" is not a leap year.\"\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "import calendar\ncalendar.isleap(year)\n"}
{"id": 115208, "name": "Program name", "source": "Translate COBOL to C#:        identification division.\n       program-id. sample.\n\n       data division.\n       working-storage section.\n       01 progname pic x(16).\n\n       procedure division.\n       sample-main.\n\n       display 0 upon argument-number\n       accept progname from argument-value\n       display \"argument-value zero\u00a0:\" progname \":\"\n\n       display \"function module-id \u00a0:\" function module-id \":\"\n\n       goback.\n       end program sample.\n", "target": "using System;\nnamespace ProgramName\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tConsole.Write(Environment.CommandLine);\n\t\t}\n\t}\n}\n"}
{"id": 115210, "name": "Program name", "source": "Translate COBOL to Java:        identification division.\n       program-id. sample.\n\n       data division.\n       working-storage section.\n       01 progname pic x(16).\n\n       procedure division.\n       sample-main.\n\n       display 0 upon argument-number\n       accept progname from argument-value\n       display \"argument-value zero\u00a0:\" progname \":\"\n\n       display \"function module-id \u00a0:\" function module-id \":\"\n\n       goback.\n       end program sample.\n", "target": "public class ScriptName {\n\tpublic static void main(String[] args) {\n\t\tString program = System.getProperty(\"sun.java.command\").split(\" \")[0];\n\t\tSystem.out.println(\"Program: \" + program);\n\t}\n}\n"}
{"id": 115211, "name": "Program name", "source": "Translate COBOL to Python:        identification division.\n       program-id. sample.\n\n       data division.\n       working-storage section.\n       01 progname pic x(16).\n\n       procedure division.\n       sample-main.\n\n       display 0 upon argument-number\n       accept progname from argument-value\n       display \"argument-value zero\u00a0:\" progname \":\"\n\n       display \"function module-id \u00a0:\" function module-id \":\"\n\n       goback.\n       end program sample.\n", "target": "\n\nimport sys\n\ndef main():\n    program = sys.argv[0]\n    print(\"Program: %s\" % program)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 115354, "name": "Terminal control_Ringing the terminal bell", "source": "Translate COBOL to C#: DISPLAY SPACE WITH BELL\n", "target": "\nSystem.Console.Write(\"\\a\"); \nSystem.Threading.Thread.Sleep(1000); \nSystem.Console.Beep(); \nSystem.Threading.Thread.Sleep(1000);\n\n\nSystem.Console.Beep(440, 2000); \n"}
{"id": 115355, "name": "Terminal control_Ringing the terminal bell", "source": "Translate COBOL to Java: DISPLAY SPACE WITH BELL\n", "target": "public class Bell{\n    public static void main(String[] args){\n        java.awt.Toolkit.getDefaultToolkit().beep();\n\n        \n\n        System.out.println((char)7);\n    }\n}\n"}
{"id": 116274, "name": "Four bit adder", "source": "Translate COBOL to C#:        program-id. test-add.\n       environment division.\n       configuration section.\n       special-names.\n           class bin is \"0\" \"1\".\n       data division.\n       working-storage section.\n       1 parms.\n        2 a-in pic 9999.\n        2 b-in pic 9999.\n        2 r-out pic 9999.\n        2 c-out pic 9.\n       procedure division.\n           display \"Enter 'A' value (4-bits binary): \"\n               with no advancing\n           accept a-in\n           if a-in (1:) not bin\n               display \"A is not binary\"\n               stop run\n           end-if\n           display \"Enter 'B' value (4-bits binary): \"\n               with no advancing\n           accept b-in\n           if b-in (1:) not bin\n               display \"B is not binary\"\n               stop run\n           end-if\n           call \"add-4b\" using parms\n           display \"Carry \" c-out \" result \" r-out\n           stop run\n           .\n       end program test-add.\n\n       program-id. add-4b.\n       data division.\n       working-storage section.\n       1 wk binary.\n        2 i pic 9(4).\n        2 occurs 5.\n         3 a-reg pic 9.\n         3 b-reg pic 9.\n         3 c-reg pic 9.\n         3 r-reg pic 9.\n        2 a pic 9.\n        2 b pic 9.\n        2 c pic 9.\n        2 a-not pic 9.\n        2 b-not pic 9.\n        2 c-not pic 9.\n        2 ha-1s pic 9.\n        2 ha-1c pic 9.\n        2 ha-1s-not pic 9.\n        2 ha-1c-not pic 9.\n        2 ha-2s pic 9.\n        2 ha-2c pic 9.\n        2 fa-s pic 9.\n        2 fa-c pic 9.\n       linkage section.\n       1 parms.\n        2 a-in pic 9999.\n        2 b-in pic 9999.\n        2 r-out pic 9999.\n        2 c-out pic 9.\n       procedure division using parms.\n           initialize wk\n           perform varying i from 1 by 1\n           until i > 4\n               move a-in (5 - i:1) to a-reg (i)\n               move b-in (5 - i:1) to b-reg (i)\n           end-perform\n           perform simulate-adder varying i from 1 by 1\n               until i > 4\n           move c-reg (5) to c-out\n           perform varying i from 1 by 1\n           until i > 4\n               move r-reg (i) to r-out (5 - i:1)\n           end-perform\n           exit program\n           .\n\n       simulate-adder section.\n           move a-reg (i) to a\n           move b-reg (i) to b\n           move c-reg (i) to c\n           add a -1 giving a-not\n           add b -1 giving b-not\n           add c -1 giving c-not\n\n           compute ha-1s = function max (\n               function min ( a b-not )\n               function min ( b a-not ) )\n           compute ha-1c = function min ( a b )\n           add ha-1s -1 giving ha-1s-not\n           add ha-1c -1 giving ha-1c-not\n\n           compute ha-2s = function max (\n               function min ( c ha-1s-not )\n               function min ( ha-1s c-not ) )\n           compute ha-2c = function min ( c ha-1c )\n\n           compute fa-s = ha-2s\n           compute fa-c = function max ( ha-1c ha-2c )\n\n           move fa-s to r-reg (i)\n           move fa-c to c-reg (i + 1)\n           .\n       end program add-4b.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCodeTasks.FourBitAdder\n{\n\tpublic struct BitAdderOutput\n\t{\n\t\tpublic bool S { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn \"S\" + ( S ? \"1\" : \"0\" ) + \"C\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct Nibble\n\t{\n\t\tpublic bool _1 { get; set; }\n\t\tpublic bool _2 { get; set; }\n\t\tpublic bool _3 { get; set; }\n\t\tpublic bool _4 { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn ( _4 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _3 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _2 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _1 ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct FourBitAdderOutput\n\t{\n\t\tpublic Nibble N { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn N.ToString ( ) + \"c\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\n\tpublic static class LogicGates\n\t{\n\t\t\n\t\tpublic static bool Not ( bool A ) { return !A; }\n\t\tpublic static bool And ( bool A, bool B ) { return A && B; }\n\t\tpublic static bool Or ( bool A, bool B ) { return A || B; }\n\n\t\t\n\t\tpublic static bool Xor ( bool A, bool B ) {\treturn Or ( And ( A, Not ( B ) ), ( And ( Not ( A ), B ) ) ); }\n\t}\n\n\tpublic static class ConstructiveBlocks\n\t{\n\t\tpublic static BitAdderOutput HalfAdder ( bool A, bool B )\n\t\t{\n\t\t\treturn new BitAdderOutput ( ) { S = LogicGates.Xor ( A, B ), C = LogicGates.And ( A, B ) };\n\t\t}\n\n\t\tpublic static BitAdderOutput FullAdder ( bool A, bool B, bool CI )\n\t\t{\n\t\t\tBitAdderOutput HA1 = HalfAdder ( CI, A );\n\t\t\tBitAdderOutput HA2 = HalfAdder ( HA1.S, B );\n\n\t\t\treturn new BitAdderOutput ( ) { S = HA2.S, C = LogicGates.Or ( HA1.C, HA2.C ) };\n\t\t}\n\n\t\tpublic static FourBitAdderOutput FourBitAdder ( Nibble A, Nibble B, bool CI )\n\t\t{\n\n\t\t\tBitAdderOutput FA1 = FullAdder ( A._1, B._1, CI );\n\t\t\tBitAdderOutput FA2 = FullAdder ( A._2, B._2, FA1.C );\n\t\t\tBitAdderOutput FA3 = FullAdder ( A._3, B._3, FA2.C );\n\t\t\tBitAdderOutput FA4 = FullAdder ( A._4, B._4, FA3.C );\n\n\t\t\treturn new FourBitAdderOutput ( ) { N = new Nibble ( ) { _1 = FA1.S, _2 = FA2.S, _3 = FA3.S, _4 = FA4.S }, C = FA4.C };\n\t\t}\n\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Four Bit Adder\" );\n\n\t\t\tfor ( int i = 0; i < 256; i++ )\n\t\t\t{\n\t\t\t\tNibble A = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tNibble B = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tif ( (i & 1) == 1)\n\t\t\t\t{\n\t\t\t\t\tA._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 2 ) == 2 )\n\t\t\t\t{\n\t\t\t\t\tA._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 4 ) == 4 )\n\t\t\t\t{\n\t\t\t\t\tA._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 8 ) == 8 )\n\t\t\t\t{\n\t\t\t\t\tA._4 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 16 ) == 16 )\n\t\t\t\t{\n\t\t\t\t\tB._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 32 ) == 32)\n\t\t\t\t{\n\t\t\t\t\tB._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 64 ) == 64 )\n\t\t\t\t{\n\t\t\t\t\tB._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 128 ) == 128 )\n\t\t\t\t{\n\t\t\t\t\tB._4 = true;\n\t\t\t\t}\n\n\t\t\t\tConsole.WriteLine ( \"{0} + {1} = {2}\", A.ToString ( ), B.ToString ( ), FourBitAdder( A, B, false ).ToString ( ) );\n\n\t\t\t}\n\n\t\t\tConsole.WriteLine ( );\n\t\t}\n\n\t}\n}\n"}
{"id": 116275, "name": "Four bit adder", "source": "Translate COBOL to C#:        program-id. test-add.\n       environment division.\n       configuration section.\n       special-names.\n           class bin is \"0\" \"1\".\n       data division.\n       working-storage section.\n       1 parms.\n        2 a-in pic 9999.\n        2 b-in pic 9999.\n        2 r-out pic 9999.\n        2 c-out pic 9.\n       procedure division.\n           display \"Enter 'A' value (4-bits binary): \"\n               with no advancing\n           accept a-in\n           if a-in (1:) not bin\n               display \"A is not binary\"\n               stop run\n           end-if\n           display \"Enter 'B' value (4-bits binary): \"\n               with no advancing\n           accept b-in\n           if b-in (1:) not bin\n               display \"B is not binary\"\n               stop run\n           end-if\n           call \"add-4b\" using parms\n           display \"Carry \" c-out \" result \" r-out\n           stop run\n           .\n       end program test-add.\n\n       program-id. add-4b.\n       data division.\n       working-storage section.\n       1 wk binary.\n        2 i pic 9(4).\n        2 occurs 5.\n         3 a-reg pic 9.\n         3 b-reg pic 9.\n         3 c-reg pic 9.\n         3 r-reg pic 9.\n        2 a pic 9.\n        2 b pic 9.\n        2 c pic 9.\n        2 a-not pic 9.\n        2 b-not pic 9.\n        2 c-not pic 9.\n        2 ha-1s pic 9.\n        2 ha-1c pic 9.\n        2 ha-1s-not pic 9.\n        2 ha-1c-not pic 9.\n        2 ha-2s pic 9.\n        2 ha-2c pic 9.\n        2 fa-s pic 9.\n        2 fa-c pic 9.\n       linkage section.\n       1 parms.\n        2 a-in pic 9999.\n        2 b-in pic 9999.\n        2 r-out pic 9999.\n        2 c-out pic 9.\n       procedure division using parms.\n           initialize wk\n           perform varying i from 1 by 1\n           until i > 4\n               move a-in (5 - i:1) to a-reg (i)\n               move b-in (5 - i:1) to b-reg (i)\n           end-perform\n           perform simulate-adder varying i from 1 by 1\n               until i > 4\n           move c-reg (5) to c-out\n           perform varying i from 1 by 1\n           until i > 4\n               move r-reg (i) to r-out (5 - i:1)\n           end-perform\n           exit program\n           .\n\n       simulate-adder section.\n           move a-reg (i) to a\n           move b-reg (i) to b\n           move c-reg (i) to c\n           add a -1 giving a-not\n           add b -1 giving b-not\n           add c -1 giving c-not\n\n           compute ha-1s = function max (\n               function min ( a b-not )\n               function min ( b a-not ) )\n           compute ha-1c = function min ( a b )\n           add ha-1s -1 giving ha-1s-not\n           add ha-1c -1 giving ha-1c-not\n\n           compute ha-2s = function max (\n               function min ( c ha-1s-not )\n               function min ( ha-1s c-not ) )\n           compute ha-2c = function min ( c ha-1c )\n\n           compute fa-s = ha-2s\n           compute fa-c = function max ( ha-1c ha-2c )\n\n           move fa-s to r-reg (i)\n           move fa-c to c-reg (i + 1)\n           .\n       end program add-4b.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCodeTasks.FourBitAdder\n{\n\tpublic struct BitAdderOutput\n\t{\n\t\tpublic bool S { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn \"S\" + ( S ? \"1\" : \"0\" ) + \"C\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct Nibble\n\t{\n\t\tpublic bool _1 { get; set; }\n\t\tpublic bool _2 { get; set; }\n\t\tpublic bool _3 { get; set; }\n\t\tpublic bool _4 { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn ( _4 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _3 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _2 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _1 ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct FourBitAdderOutput\n\t{\n\t\tpublic Nibble N { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn N.ToString ( ) + \"c\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\n\tpublic static class LogicGates\n\t{\n\t\t\n\t\tpublic static bool Not ( bool A ) { return !A; }\n\t\tpublic static bool And ( bool A, bool B ) { return A && B; }\n\t\tpublic static bool Or ( bool A, bool B ) { return A || B; }\n\n\t\t\n\t\tpublic static bool Xor ( bool A, bool B ) {\treturn Or ( And ( A, Not ( B ) ), ( And ( Not ( A ), B ) ) ); }\n\t}\n\n\tpublic static class ConstructiveBlocks\n\t{\n\t\tpublic static BitAdderOutput HalfAdder ( bool A, bool B )\n\t\t{\n\t\t\treturn new BitAdderOutput ( ) { S = LogicGates.Xor ( A, B ), C = LogicGates.And ( A, B ) };\n\t\t}\n\n\t\tpublic static BitAdderOutput FullAdder ( bool A, bool B, bool CI )\n\t\t{\n\t\t\tBitAdderOutput HA1 = HalfAdder ( CI, A );\n\t\t\tBitAdderOutput HA2 = HalfAdder ( HA1.S, B );\n\n\t\t\treturn new BitAdderOutput ( ) { S = HA2.S, C = LogicGates.Or ( HA1.C, HA2.C ) };\n\t\t}\n\n\t\tpublic static FourBitAdderOutput FourBitAdder ( Nibble A, Nibble B, bool CI )\n\t\t{\n\n\t\t\tBitAdderOutput FA1 = FullAdder ( A._1, B._1, CI );\n\t\t\tBitAdderOutput FA2 = FullAdder ( A._2, B._2, FA1.C );\n\t\t\tBitAdderOutput FA3 = FullAdder ( A._3, B._3, FA2.C );\n\t\t\tBitAdderOutput FA4 = FullAdder ( A._4, B._4, FA3.C );\n\n\t\t\treturn new FourBitAdderOutput ( ) { N = new Nibble ( ) { _1 = FA1.S, _2 = FA2.S, _3 = FA3.S, _4 = FA4.S }, C = FA4.C };\n\t\t}\n\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Four Bit Adder\" );\n\n\t\t\tfor ( int i = 0; i < 256; i++ )\n\t\t\t{\n\t\t\t\tNibble A = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tNibble B = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tif ( (i & 1) == 1)\n\t\t\t\t{\n\t\t\t\t\tA._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 2 ) == 2 )\n\t\t\t\t{\n\t\t\t\t\tA._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 4 ) == 4 )\n\t\t\t\t{\n\t\t\t\t\tA._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 8 ) == 8 )\n\t\t\t\t{\n\t\t\t\t\tA._4 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 16 ) == 16 )\n\t\t\t\t{\n\t\t\t\t\tB._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 32 ) == 32)\n\t\t\t\t{\n\t\t\t\t\tB._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 64 ) == 64 )\n\t\t\t\t{\n\t\t\t\t\tB._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 128 ) == 128 )\n\t\t\t\t{\n\t\t\t\t\tB._4 = true;\n\t\t\t\t}\n\n\t\t\t\tConsole.WriteLine ( \"{0} + {1} = {2}\", A.ToString ( ), B.ToString ( ), FourBitAdder( A, B, false ).ToString ( ) );\n\n\t\t\t}\n\n\t\t\tConsole.WriteLine ( );\n\t\t}\n\n\t}\n}\n"}
{"id": 116276, "name": "Four bit adder", "source": "Translate COBOL to Java:        program-id. test-add.\n       environment division.\n       configuration section.\n       special-names.\n           class bin is \"0\" \"1\".\n       data division.\n       working-storage section.\n       1 parms.\n        2 a-in pic 9999.\n        2 b-in pic 9999.\n        2 r-out pic 9999.\n        2 c-out pic 9.\n       procedure division.\n           display \"Enter 'A' value (4-bits binary): \"\n               with no advancing\n           accept a-in\n           if a-in (1:) not bin\n               display \"A is not binary\"\n               stop run\n           end-if\n           display \"Enter 'B' value (4-bits binary): \"\n               with no advancing\n           accept b-in\n           if b-in (1:) not bin\n               display \"B is not binary\"\n               stop run\n           end-if\n           call \"add-4b\" using parms\n           display \"Carry \" c-out \" result \" r-out\n           stop run\n           .\n       end program test-add.\n\n       program-id. add-4b.\n       data division.\n       working-storage section.\n       1 wk binary.\n        2 i pic 9(4).\n        2 occurs 5.\n         3 a-reg pic 9.\n         3 b-reg pic 9.\n         3 c-reg pic 9.\n         3 r-reg pic 9.\n        2 a pic 9.\n        2 b pic 9.\n        2 c pic 9.\n        2 a-not pic 9.\n        2 b-not pic 9.\n        2 c-not pic 9.\n        2 ha-1s pic 9.\n        2 ha-1c pic 9.\n        2 ha-1s-not pic 9.\n        2 ha-1c-not pic 9.\n        2 ha-2s pic 9.\n        2 ha-2c pic 9.\n        2 fa-s pic 9.\n        2 fa-c pic 9.\n       linkage section.\n       1 parms.\n        2 a-in pic 9999.\n        2 b-in pic 9999.\n        2 r-out pic 9999.\n        2 c-out pic 9.\n       procedure division using parms.\n           initialize wk\n           perform varying i from 1 by 1\n           until i > 4\n               move a-in (5 - i:1) to a-reg (i)\n               move b-in (5 - i:1) to b-reg (i)\n           end-perform\n           perform simulate-adder varying i from 1 by 1\n               until i > 4\n           move c-reg (5) to c-out\n           perform varying i from 1 by 1\n           until i > 4\n               move r-reg (i) to r-out (5 - i:1)\n           end-perform\n           exit program\n           .\n\n       simulate-adder section.\n           move a-reg (i) to a\n           move b-reg (i) to b\n           move c-reg (i) to c\n           add a -1 giving a-not\n           add b -1 giving b-not\n           add c -1 giving c-not\n\n           compute ha-1s = function max (\n               function min ( a b-not )\n               function min ( b a-not ) )\n           compute ha-1c = function min ( a b )\n           add ha-1s -1 giving ha-1s-not\n           add ha-1c -1 giving ha-1c-not\n\n           compute ha-2s = function max (\n               function min ( c ha-1s-not )\n               function min ( ha-1s c-not ) )\n           compute ha-2c = function min ( c ha-1c )\n\n           compute fa-s = ha-2s\n           compute fa-c = function max ( ha-1c ha-2c )\n\n           move fa-s to r-reg (i)\n           move fa-c to c-reg (i + 1)\n           .\n       end program add-4b.\n", "target": "public class GateLogic\n{\n  \n  public interface OneInputGate\n  {  boolean eval(boolean input);  }\n  \n  public interface TwoInputGate\n  {  boolean eval(boolean input1, boolean input2);  }\n  \n  public interface MultiGate\n  {  boolean[] eval(boolean... inputs);  }\n  \n  \n  public static OneInputGate NOT = new OneInputGate() {\n    public boolean eval(boolean input)\n    {  return !input;  }\n  };\n  \n  \n  public static TwoInputGate AND = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 && input2;  }\n  };\n  \n  \n  public static TwoInputGate OR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 || input2;  }\n  };\n  \n  \n  public static TwoInputGate XOR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {\n      return OR.eval(\n               AND.eval(input1, NOT.eval(input2)),\n               AND.eval(NOT.eval(input1), input2)\n             );\n    }\n  };\n  \n  \n  public static MultiGate HALF_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 2)\n        throw new IllegalArgumentException();\n      return new boolean[] {\n        XOR.eval(inputs[0], inputs[1]),  \n        AND.eval(inputs[0], inputs[1])   \n      };\n    }\n  };\n  \n  \n  public static MultiGate FULL_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 3)\n        throw new IllegalArgumentException();\n      \n      \n      boolean[] haOutputs1 = HALF_ADDER.eval(inputs[0], inputs[1]);\n      boolean[] haOutputs2 = HALF_ADDER.eval(haOutputs1[0], inputs[2]);\n      return new boolean[] {\n        haOutputs2[0],                         \n        OR.eval(haOutputs1[1], haOutputs2[1])  \n      };\n    }\n  };\n  \n  public static MultiGate buildAdder(final int numBits)\n  {\n    return new MultiGate() {\n      public boolean[] eval(boolean... inputs)\n      {\n        \n        if (inputs.length != (numBits << 1))\n          throw new IllegalArgumentException();\n        boolean[] outputs = new boolean[numBits + 1];\n        boolean[] faInputs = new boolean[3];\n        boolean[] faOutputs = null;\n        for (int i = 0; i < numBits; i++)\n        {\n          faInputs[0] = (faOutputs == null) ? false : faOutputs[1];  \n          faInputs[1] = inputs[i];                                   \n          faInputs[2] = inputs[numBits + i];                         \n          faOutputs = FULL_ADDER.eval(faInputs);\n          outputs[i] = faOutputs[0];                                 \n        }\n        if (faOutputs != null)\n          outputs[numBits] = faOutputs[1];                           \n        return outputs;\n      }\n    };\n  }\n  \n  public static void main(String[] args)\n  {\n    int numBits = Integer.parseInt(args[0]);\n    int firstNum = Integer.parseInt(args[1]);\n    int secondNum = Integer.parseInt(args[2]);\n    int maxNum = 1 << numBits;\n    if ((firstNum < 0) || (firstNum >= maxNum))\n    {\n      System.out.println(\"First number is out of range\");\n      return;\n    }\n    if ((secondNum < 0) || (secondNum >= maxNum))\n    {\n      System.out.println(\"Second number is out of range\");\n      return;\n    }\n    \n    MultiGate multiBitAdder = buildAdder(numBits);\n    \n    boolean[] inputs = new boolean[numBits << 1];\n    String firstNumDisplay = \"\";\n    String secondNumDisplay = \"\";\n    for (int i = 0; i < numBits; i++)\n    {\n      boolean firstBit = ((firstNum >>> i) & 1) == 1;\n      boolean secondBit = ((secondNum >>> i) & 1) == 1;\n      inputs[i] = firstBit;\n      inputs[numBits + i] = secondBit;\n      firstNumDisplay = (firstBit ? \"1\" : \"0\") + firstNumDisplay;\n      secondNumDisplay = (secondBit ? \"1\" : \"0\") + secondNumDisplay;\n    }\n    \n    boolean[] outputs = multiBitAdder.eval(inputs);\n    int outputNum = 0;\n    String outputNumDisplay = \"\";\n    String outputCarryDisplay = null;\n    for (int i = numBits; i >= 0; i--)\n    {\n      outputNum = (outputNum << 1) | (outputs[i] ? 1 : 0);\n      if (i == numBits)\n        outputCarryDisplay = outputs[i] ? \"1\" : \"0\";\n      else\n        outputNumDisplay += (outputs[i] ? \"1\" : \"0\");\n    }\n    System.out.println(\"numBits=\" + numBits);\n    System.out.println(\"A=\" + firstNumDisplay + \" (\" + firstNum + \"), B=\" + secondNumDisplay + \" (\" + secondNum + \"), S=\" + outputCarryDisplay + \" \" + outputNumDisplay + \" (\" + outputNum + \")\");\n    return;\n  }\n  \n}\n"}
{"id": 116277, "name": "Four bit adder", "source": "Translate COBOL to Java:        program-id. test-add.\n       environment division.\n       configuration section.\n       special-names.\n           class bin is \"0\" \"1\".\n       data division.\n       working-storage section.\n       1 parms.\n        2 a-in pic 9999.\n        2 b-in pic 9999.\n        2 r-out pic 9999.\n        2 c-out pic 9.\n       procedure division.\n           display \"Enter 'A' value (4-bits binary): \"\n               with no advancing\n           accept a-in\n           if a-in (1:) not bin\n               display \"A is not binary\"\n               stop run\n           end-if\n           display \"Enter 'B' value (4-bits binary): \"\n               with no advancing\n           accept b-in\n           if b-in (1:) not bin\n               display \"B is not binary\"\n               stop run\n           end-if\n           call \"add-4b\" using parms\n           display \"Carry \" c-out \" result \" r-out\n           stop run\n           .\n       end program test-add.\n\n       program-id. add-4b.\n       data division.\n       working-storage section.\n       1 wk binary.\n        2 i pic 9(4).\n        2 occurs 5.\n         3 a-reg pic 9.\n         3 b-reg pic 9.\n         3 c-reg pic 9.\n         3 r-reg pic 9.\n        2 a pic 9.\n        2 b pic 9.\n        2 c pic 9.\n        2 a-not pic 9.\n        2 b-not pic 9.\n        2 c-not pic 9.\n        2 ha-1s pic 9.\n        2 ha-1c pic 9.\n        2 ha-1s-not pic 9.\n        2 ha-1c-not pic 9.\n        2 ha-2s pic 9.\n        2 ha-2c pic 9.\n        2 fa-s pic 9.\n        2 fa-c pic 9.\n       linkage section.\n       1 parms.\n        2 a-in pic 9999.\n        2 b-in pic 9999.\n        2 r-out pic 9999.\n        2 c-out pic 9.\n       procedure division using parms.\n           initialize wk\n           perform varying i from 1 by 1\n           until i > 4\n               move a-in (5 - i:1) to a-reg (i)\n               move b-in (5 - i:1) to b-reg (i)\n           end-perform\n           perform simulate-adder varying i from 1 by 1\n               until i > 4\n           move c-reg (5) to c-out\n           perform varying i from 1 by 1\n           until i > 4\n               move r-reg (i) to r-out (5 - i:1)\n           end-perform\n           exit program\n           .\n\n       simulate-adder section.\n           move a-reg (i) to a\n           move b-reg (i) to b\n           move c-reg (i) to c\n           add a -1 giving a-not\n           add b -1 giving b-not\n           add c -1 giving c-not\n\n           compute ha-1s = function max (\n               function min ( a b-not )\n               function min ( b a-not ) )\n           compute ha-1c = function min ( a b )\n           add ha-1s -1 giving ha-1s-not\n           add ha-1c -1 giving ha-1c-not\n\n           compute ha-2s = function max (\n               function min ( c ha-1s-not )\n               function min ( ha-1s c-not ) )\n           compute ha-2c = function min ( c ha-1c )\n\n           compute fa-s = ha-2s\n           compute fa-c = function max ( ha-1c ha-2c )\n\n           move fa-s to r-reg (i)\n           move fa-c to c-reg (i + 1)\n           .\n       end program add-4b.\n", "target": "public class GateLogic\n{\n  \n  public interface OneInputGate\n  {  boolean eval(boolean input);  }\n  \n  public interface TwoInputGate\n  {  boolean eval(boolean input1, boolean input2);  }\n  \n  public interface MultiGate\n  {  boolean[] eval(boolean... inputs);  }\n  \n  \n  public static OneInputGate NOT = new OneInputGate() {\n    public boolean eval(boolean input)\n    {  return !input;  }\n  };\n  \n  \n  public static TwoInputGate AND = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 && input2;  }\n  };\n  \n  \n  public static TwoInputGate OR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 || input2;  }\n  };\n  \n  \n  public static TwoInputGate XOR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {\n      return OR.eval(\n               AND.eval(input1, NOT.eval(input2)),\n               AND.eval(NOT.eval(input1), input2)\n             );\n    }\n  };\n  \n  \n  public static MultiGate HALF_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 2)\n        throw new IllegalArgumentException();\n      return new boolean[] {\n        XOR.eval(inputs[0], inputs[1]),  \n        AND.eval(inputs[0], inputs[1])   \n      };\n    }\n  };\n  \n  \n  public static MultiGate FULL_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 3)\n        throw new IllegalArgumentException();\n      \n      \n      boolean[] haOutputs1 = HALF_ADDER.eval(inputs[0], inputs[1]);\n      boolean[] haOutputs2 = HALF_ADDER.eval(haOutputs1[0], inputs[2]);\n      return new boolean[] {\n        haOutputs2[0],                         \n        OR.eval(haOutputs1[1], haOutputs2[1])  \n      };\n    }\n  };\n  \n  public static MultiGate buildAdder(final int numBits)\n  {\n    return new MultiGate() {\n      public boolean[] eval(boolean... inputs)\n      {\n        \n        if (inputs.length != (numBits << 1))\n          throw new IllegalArgumentException();\n        boolean[] outputs = new boolean[numBits + 1];\n        boolean[] faInputs = new boolean[3];\n        boolean[] faOutputs = null;\n        for (int i = 0; i < numBits; i++)\n        {\n          faInputs[0] = (faOutputs == null) ? false : faOutputs[1];  \n          faInputs[1] = inputs[i];                                   \n          faInputs[2] = inputs[numBits + i];                         \n          faOutputs = FULL_ADDER.eval(faInputs);\n          outputs[i] = faOutputs[0];                                 \n        }\n        if (faOutputs != null)\n          outputs[numBits] = faOutputs[1];                           \n        return outputs;\n      }\n    };\n  }\n  \n  public static void main(String[] args)\n  {\n    int numBits = Integer.parseInt(args[0]);\n    int firstNum = Integer.parseInt(args[1]);\n    int secondNum = Integer.parseInt(args[2]);\n    int maxNum = 1 << numBits;\n    if ((firstNum < 0) || (firstNum >= maxNum))\n    {\n      System.out.println(\"First number is out of range\");\n      return;\n    }\n    if ((secondNum < 0) || (secondNum >= maxNum))\n    {\n      System.out.println(\"Second number is out of range\");\n      return;\n    }\n    \n    MultiGate multiBitAdder = buildAdder(numBits);\n    \n    boolean[] inputs = new boolean[numBits << 1];\n    String firstNumDisplay = \"\";\n    String secondNumDisplay = \"\";\n    for (int i = 0; i < numBits; i++)\n    {\n      boolean firstBit = ((firstNum >>> i) & 1) == 1;\n      boolean secondBit = ((secondNum >>> i) & 1) == 1;\n      inputs[i] = firstBit;\n      inputs[numBits + i] = secondBit;\n      firstNumDisplay = (firstBit ? \"1\" : \"0\") + firstNumDisplay;\n      secondNumDisplay = (secondBit ? \"1\" : \"0\") + secondNumDisplay;\n    }\n    \n    boolean[] outputs = multiBitAdder.eval(inputs);\n    int outputNum = 0;\n    String outputNumDisplay = \"\";\n    String outputCarryDisplay = null;\n    for (int i = numBits; i >= 0; i--)\n    {\n      outputNum = (outputNum << 1) | (outputs[i] ? 1 : 0);\n      if (i == numBits)\n        outputCarryDisplay = outputs[i] ? \"1\" : \"0\";\n      else\n        outputNumDisplay += (outputs[i] ? \"1\" : \"0\");\n    }\n    System.out.println(\"numBits=\" + numBits);\n    System.out.println(\"A=\" + firstNumDisplay + \" (\" + firstNum + \"), B=\" + secondNumDisplay + \" (\" + secondNum + \"), S=\" + outputCarryDisplay + \" \" + outputNumDisplay + \" (\" + outputNum + \")\");\n    return;\n  }\n  \n}\n"}
{"id": 116278, "name": "Four bit adder", "source": "Translate COBOL to Python:        program-id. test-add.\n       environment division.\n       configuration section.\n       special-names.\n           class bin is \"0\" \"1\".\n       data division.\n       working-storage section.\n       1 parms.\n        2 a-in pic 9999.\n        2 b-in pic 9999.\n        2 r-out pic 9999.\n        2 c-out pic 9.\n       procedure division.\n           display \"Enter 'A' value (4-bits binary): \"\n               with no advancing\n           accept a-in\n           if a-in (1:) not bin\n               display \"A is not binary\"\n               stop run\n           end-if\n           display \"Enter 'B' value (4-bits binary): \"\n               with no advancing\n           accept b-in\n           if b-in (1:) not bin\n               display \"B is not binary\"\n               stop run\n           end-if\n           call \"add-4b\" using parms\n           display \"Carry \" c-out \" result \" r-out\n           stop run\n           .\n       end program test-add.\n\n       program-id. add-4b.\n       data division.\n       working-storage section.\n       1 wk binary.\n        2 i pic 9(4).\n        2 occurs 5.\n         3 a-reg pic 9.\n         3 b-reg pic 9.\n         3 c-reg pic 9.\n         3 r-reg pic 9.\n        2 a pic 9.\n        2 b pic 9.\n        2 c pic 9.\n        2 a-not pic 9.\n        2 b-not pic 9.\n        2 c-not pic 9.\n        2 ha-1s pic 9.\n        2 ha-1c pic 9.\n        2 ha-1s-not pic 9.\n        2 ha-1c-not pic 9.\n        2 ha-2s pic 9.\n        2 ha-2c pic 9.\n        2 fa-s pic 9.\n        2 fa-c pic 9.\n       linkage section.\n       1 parms.\n        2 a-in pic 9999.\n        2 b-in pic 9999.\n        2 r-out pic 9999.\n        2 c-out pic 9.\n       procedure division using parms.\n           initialize wk\n           perform varying i from 1 by 1\n           until i > 4\n               move a-in (5 - i:1) to a-reg (i)\n               move b-in (5 - i:1) to b-reg (i)\n           end-perform\n           perform simulate-adder varying i from 1 by 1\n               until i > 4\n           move c-reg (5) to c-out\n           perform varying i from 1 by 1\n           until i > 4\n               move r-reg (i) to r-out (5 - i:1)\n           end-perform\n           exit program\n           .\n\n       simulate-adder section.\n           move a-reg (i) to a\n           move b-reg (i) to b\n           move c-reg (i) to c\n           add a -1 giving a-not\n           add b -1 giving b-not\n           add c -1 giving c-not\n\n           compute ha-1s = function max (\n               function min ( a b-not )\n               function min ( b a-not ) )\n           compute ha-1c = function min ( a b )\n           add ha-1s -1 giving ha-1s-not\n           add ha-1c -1 giving ha-1c-not\n\n           compute ha-2s = function max (\n               function min ( c ha-1s-not )\n               function min ( ha-1s c-not ) )\n           compute ha-2c = function min ( c ha-1c )\n\n           compute fa-s = ha-2s\n           compute fa-c = function max ( ha-1c ha-2c )\n\n           move fa-s to r-reg (i)\n           move fa-c to c-reg (i + 1)\n           .\n       end program add-4b.\n", "target": "\n\nfrom myhdl import *\n\n\n\n@block\ndef NOTgate( a,  q ):   \n   \n   @always_comb   \n   def NOTgateLogic():\n      q.next = not a\n\n   return NOTgateLogic   \n\n\n@block\ndef ANDgate( a, b,  q ):\n   \n   @always_comb \n   def ANDgateLogic():\n      q.next = a and b\n\n   return ANDgateLogic\n\n\n@block\ndef ORgate( a, b,  q ):\n      \n   @always_comb  \n   def ORgateLogic():\n      q.next = a or b\n\n   return ORgateLogic\n\n\n\n\n@block\ndef XORgate( a, b,  q ):\n      \n   \n   nota, notb, annotb, bnnota = [Signal(bool(0)) for i in range(4)]\n   \n   inv0 = NOTgate( a,  nota )\n   inv1 = NOTgate( b,  notb )\n   and2a = ANDgate( a, notb,  annotb )\n   and2b = ANDgate( b, nota,  bnnota )\n   or2a = ORgate( annotb, bnnota,  q )\n\n   return inv0, inv1, and2a, and2b, or2a\n\n\n@block\ndef HalfAdder( in_a, in_b,  summ, carry ):\n    \n   and2a =  ANDgate(in_a, in_b,  carry)\n   xor2a =  XORgate(in_a, in_b,  summ)\n\n   return and2a, xor2a\n\n\n@block\ndef FullAdder( fa_c0, fa_a, fa_b,  fa_s, fa_c1 ):\n   \n\n   ha1_s, ha1_c1, ha2_c1 = [Signal(bool(0)) for i in range(3)]\n\n   HalfAdder01 = HalfAdder( fa_c0, fa_a,  ha1_s, ha1_c1 )\n   HalfAdder02 = HalfAdder( ha1_s, fa_b,  fa_s,  ha2_c1 )\n   or2a = ORgate(ha1_c1, ha2_c1,  fa_c1)\n\n   return HalfAdder01, HalfAdder02, or2a\n\n\n@block\ndef Adder4b( ina, inb,  cOut, sum4):\n    \n\n   cl = [Signal(bool()) for i in range(0,4)]  \n   sl = [Signal(bool()) for i in range(4)]  \n\n   HalfAdder0 = HalfAdder(        ina(0), inb(0),  sl[0], cl[1] )\n   FullAdder1 = FullAdder( cl[1], ina(1), inb(1),  sl[1], cl[2] ) \n   FullAdder2 = FullAdder( cl[2], ina(2), inb(2),  sl[2], cl[3] ) \n   FullAdder3 = FullAdder( cl[3], ina(3), inb(3),  sl[3], cOut ) \n\n   sc = ConcatSignal(*reversed(sl))  \n\n   @always_comb\n   def list2intbv():\n      sum4.next = sc  \n\n   return HalfAdder0, FullAdder1, FullAdder2, FullAdder3, list2intbv\n\n\n\nt_co, t_s, t_a, t_b, dbug =  [Signal(bool(0)) for i in range(5)]\nina4, inb4, sum4 =  [Signal(intbv(0)[4:])  for i in range(3)]\n\nfrom random import randrange \n\n@block\ndef Test_Adder4b():\n   \n   dut = Adder4b( ina4, inb4,  t_co, sum4 )\n\n   @instance\n   def check():\n      print( \"\\n      b   a   |  c1    s   \\n     -------------------\" )\n      for i in range(15):\n         ina4.next, inb4.next = randrange(2**4), randrange(2**4)\n         yield delay(5)\n         print( \"     %2d  %2d   |  %2d   %2d     \" \\\n                % (ina4,inb4, t_co,sum4) )\n         assert t_co * 16 + sum4 == ina4 + inb4  \n      print()\n\n   return dut, check\n\n\n\n\ndef main():\n   simInst = Test_Adder4b()\n   simInst.name = \"mySimInst\"\n   simInst.config_sim(trace=True)  \n   simInst.run_sim(duration=None)\n\n   inst = Adder4b( ina4, inb4,  t_co, sum4 )  \n   inst.convert(hdl='VHDL')  \n   inst.convert(hdl='Verilog')  \n\n    \nif __name__ == '__main__':\n   main()\n"}
{"id": 116279, "name": "Four bit adder", "source": "Translate COBOL to Python:        program-id. test-add.\n       environment division.\n       configuration section.\n       special-names.\n           class bin is \"0\" \"1\".\n       data division.\n       working-storage section.\n       1 parms.\n        2 a-in pic 9999.\n        2 b-in pic 9999.\n        2 r-out pic 9999.\n        2 c-out pic 9.\n       procedure division.\n           display \"Enter 'A' value (4-bits binary): \"\n               with no advancing\n           accept a-in\n           if a-in (1:) not bin\n               display \"A is not binary\"\n               stop run\n           end-if\n           display \"Enter 'B' value (4-bits binary): \"\n               with no advancing\n           accept b-in\n           if b-in (1:) not bin\n               display \"B is not binary\"\n               stop run\n           end-if\n           call \"add-4b\" using parms\n           display \"Carry \" c-out \" result \" r-out\n           stop run\n           .\n       end program test-add.\n\n       program-id. add-4b.\n       data division.\n       working-storage section.\n       1 wk binary.\n        2 i pic 9(4).\n        2 occurs 5.\n         3 a-reg pic 9.\n         3 b-reg pic 9.\n         3 c-reg pic 9.\n         3 r-reg pic 9.\n        2 a pic 9.\n        2 b pic 9.\n        2 c pic 9.\n        2 a-not pic 9.\n        2 b-not pic 9.\n        2 c-not pic 9.\n        2 ha-1s pic 9.\n        2 ha-1c pic 9.\n        2 ha-1s-not pic 9.\n        2 ha-1c-not pic 9.\n        2 ha-2s pic 9.\n        2 ha-2c pic 9.\n        2 fa-s pic 9.\n        2 fa-c pic 9.\n       linkage section.\n       1 parms.\n        2 a-in pic 9999.\n        2 b-in pic 9999.\n        2 r-out pic 9999.\n        2 c-out pic 9.\n       procedure division using parms.\n           initialize wk\n           perform varying i from 1 by 1\n           until i > 4\n               move a-in (5 - i:1) to a-reg (i)\n               move b-in (5 - i:1) to b-reg (i)\n           end-perform\n           perform simulate-adder varying i from 1 by 1\n               until i > 4\n           move c-reg (5) to c-out\n           perform varying i from 1 by 1\n           until i > 4\n               move r-reg (i) to r-out (5 - i:1)\n           end-perform\n           exit program\n           .\n\n       simulate-adder section.\n           move a-reg (i) to a\n           move b-reg (i) to b\n           move c-reg (i) to c\n           add a -1 giving a-not\n           add b -1 giving b-not\n           add c -1 giving c-not\n\n           compute ha-1s = function max (\n               function min ( a b-not )\n               function min ( b a-not ) )\n           compute ha-1c = function min ( a b )\n           add ha-1s -1 giving ha-1s-not\n           add ha-1c -1 giving ha-1c-not\n\n           compute ha-2s = function max (\n               function min ( c ha-1s-not )\n               function min ( ha-1s c-not ) )\n           compute ha-2c = function min ( c ha-1c )\n\n           compute fa-s = ha-2s\n           compute fa-c = function max ( ha-1c ha-2c )\n\n           move fa-s to r-reg (i)\n           move fa-c to c-reg (i + 1)\n           .\n       end program add-4b.\n", "target": "\n\nfrom myhdl import *\n\n\n\n@block\ndef NOTgate( a,  q ):   \n   \n   @always_comb   \n   def NOTgateLogic():\n      q.next = not a\n\n   return NOTgateLogic   \n\n\n@block\ndef ANDgate( a, b,  q ):\n   \n   @always_comb \n   def ANDgateLogic():\n      q.next = a and b\n\n   return ANDgateLogic\n\n\n@block\ndef ORgate( a, b,  q ):\n      \n   @always_comb  \n   def ORgateLogic():\n      q.next = a or b\n\n   return ORgateLogic\n\n\n\n\n@block\ndef XORgate( a, b,  q ):\n      \n   \n   nota, notb, annotb, bnnota = [Signal(bool(0)) for i in range(4)]\n   \n   inv0 = NOTgate( a,  nota )\n   inv1 = NOTgate( b,  notb )\n   and2a = ANDgate( a, notb,  annotb )\n   and2b = ANDgate( b, nota,  bnnota )\n   or2a = ORgate( annotb, bnnota,  q )\n\n   return inv0, inv1, and2a, and2b, or2a\n\n\n@block\ndef HalfAdder( in_a, in_b,  summ, carry ):\n    \n   and2a =  ANDgate(in_a, in_b,  carry)\n   xor2a =  XORgate(in_a, in_b,  summ)\n\n   return and2a, xor2a\n\n\n@block\ndef FullAdder( fa_c0, fa_a, fa_b,  fa_s, fa_c1 ):\n   \n\n   ha1_s, ha1_c1, ha2_c1 = [Signal(bool(0)) for i in range(3)]\n\n   HalfAdder01 = HalfAdder( fa_c0, fa_a,  ha1_s, ha1_c1 )\n   HalfAdder02 = HalfAdder( ha1_s, fa_b,  fa_s,  ha2_c1 )\n   or2a = ORgate(ha1_c1, ha2_c1,  fa_c1)\n\n   return HalfAdder01, HalfAdder02, or2a\n\n\n@block\ndef Adder4b( ina, inb,  cOut, sum4):\n    \n\n   cl = [Signal(bool()) for i in range(0,4)]  \n   sl = [Signal(bool()) for i in range(4)]  \n\n   HalfAdder0 = HalfAdder(        ina(0), inb(0),  sl[0], cl[1] )\n   FullAdder1 = FullAdder( cl[1], ina(1), inb(1),  sl[1], cl[2] ) \n   FullAdder2 = FullAdder( cl[2], ina(2), inb(2),  sl[2], cl[3] ) \n   FullAdder3 = FullAdder( cl[3], ina(3), inb(3),  sl[3], cOut ) \n\n   sc = ConcatSignal(*reversed(sl))  \n\n   @always_comb\n   def list2intbv():\n      sum4.next = sc  \n\n   return HalfAdder0, FullAdder1, FullAdder2, FullAdder3, list2intbv\n\n\n\nt_co, t_s, t_a, t_b, dbug =  [Signal(bool(0)) for i in range(5)]\nina4, inb4, sum4 =  [Signal(intbv(0)[4:])  for i in range(3)]\n\nfrom random import randrange \n\n@block\ndef Test_Adder4b():\n   \n   dut = Adder4b( ina4, inb4,  t_co, sum4 )\n\n   @instance\n   def check():\n      print( \"\\n      b   a   |  c1    s   \\n     -------------------\" )\n      for i in range(15):\n         ina4.next, inb4.next = randrange(2**4), randrange(2**4)\n         yield delay(5)\n         print( \"     %2d  %2d   |  %2d   %2d     \" \\\n                % (ina4,inb4, t_co,sum4) )\n         assert t_co * 16 + sum4 == ina4 + inb4  \n      print()\n\n   return dut, check\n\n\n\n\ndef main():\n   simInst = Test_Adder4b()\n   simInst.name = \"mySimInst\"\n   simInst.config_sim(trace=True)  \n   simInst.run_sim(duration=None)\n\n   inst = Adder4b( ina4, inb4,  t_co, sum4 )  \n   inst.convert(hdl='VHDL')  \n   inst.convert(hdl='Verilog')  \n\n    \nif __name__ == '__main__':\n   main()\n"}
{"id": 118186, "name": "Apply a callback to an array", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Map.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Table-Size CONSTANT 30.\n\n       LOCAL-STORAGE SECTION.\n       01  I USAGE UNSIGNED-INT.\n\n       LINKAGE SECTION.\n       01  Table-Param.\n           03  Table-Values USAGE COMP-2 OCCURS Table-Size TIMES.\n\n       01  Func-Id PIC X(30).\n\n       PROCEDURE DIVISION USING Table-Param Func-Id.\n           PERFORM VARYING I FROM 1 BY 1 UNTIL Table-Size < I\n               CALL Func-Id USING BY REFERENCE Table-Values (I)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "int[] intArray = { 1, 2, 3, 4, 5 };\n\nint[] squares1 = intArray.Select(x => x * x).ToArray();\n\n\nint[] squares2 = (from x in intArray\n                  select x * x).ToArray();\n\n\nforeach (var i in intArray)\n    Console.WriteLine(i * i);\n"}
{"id": 118188, "name": "Apply a callback to an array", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Map.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Table-Size CONSTANT 30.\n\n       LOCAL-STORAGE SECTION.\n       01  I USAGE UNSIGNED-INT.\n\n       LINKAGE SECTION.\n       01  Table-Param.\n           03  Table-Values USAGE COMP-2 OCCURS Table-Size TIMES.\n\n       01  Func-Id PIC X(30).\n\n       PROCEDURE DIVISION USING Table-Param Func-Id.\n           PERFORM VARYING I FROM 1 BY 1 UNTIL Table-Size < I\n               CALL Func-Id USING BY REFERENCE Table-Values (I)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "public class ArrayCallback7 {\n\n    interface IntConsumer {\n        void run(int x);\n    }\n\n    interface IntToInt {\n        int run(int x);\n    }\n\n    static void forEach(int[] arr, IntConsumer consumer) {\n        for (int i : arr) {\n            consumer.run(i);\n        }\n    }\n\n    static void update(int[] arr, IntToInt mapper) {\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = mapper.run(arr[i]);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n        forEach(numbers, new IntConsumer() {\n            public void run(int x) {\n                System.out.println(x);\n            }\n        });\n\n        update(numbers, new IntToInt() {\n            @Override\n            public int run(int x) {\n                return x * x;\n            }\n        });\n\n        forEach(numbers, new IntConsumer() {\n            public void run(int x) {\n                System.out.println(x);\n            }\n        });\n    }\n}\n"}
{"id": 118189, "name": "Apply a callback to an array", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Map.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Table-Size CONSTANT 30.\n\n       LOCAL-STORAGE SECTION.\n       01  I USAGE UNSIGNED-INT.\n\n       LINKAGE SECTION.\n       01  Table-Param.\n           03  Table-Values USAGE COMP-2 OCCURS Table-Size TIMES.\n\n       01  Func-Id PIC X(30).\n\n       PROCEDURE DIVISION USING Table-Param Func-Id.\n           PERFORM VARYING I FROM 1 BY 1 UNTIL Table-Size < I\n               CALL Func-Id USING BY REFERENCE Table-Values (I)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "def square(n):\n    return n * n\n  \nnumbers = [1, 3, 5, 7]\n\nsquares1 = [square(n) for n in numbers]     \n\nsquares2a = map(square, numbers)            \n\nsquares2b = map(lambda x: x*x, numbers)     \n\nsquares3 = [n * n for n in numbers]         \n                                            \n\nisquares1 = (n * n for n in numbers)        \n\nimport itertools\nisquares2 = itertools.imap(square, numbers) \n"}
{"id": 118900, "name": "Convert seconds to compound duration", "source": "Translate COBOL to C#:        identification division.\n       program-id. fmt-dura.\n       data division.\n       working-storage section.\n       1 input-seconds pic 9(8).\n       1 formatted-duration pic x(30) global.\n       1 fractions.\n        2 weeks pic z(3)9.\n        2 days pic z(3)9.\n        2 hours pic z(3)9.\n        2 minutes pic z(3)9.\n        2 seconds pic z(3)9.\n       1 .\n        2 weeks-str pic x(4) value \"wk\".\n        2 days-str pic x(4) value \"d\".\n        2 hours-str pic x(4) value \"hr\".\n        2 minutes-str pic x(4) value \"min\".\n        2 seconds-str pic x(4) value \"sec\".\n       1 work binary global.\n        2 str-pos pic 9(4).\n        2 chars-transferred pic 9(4).\n       procedure division.\n       begin.\n           display \"Enter duration (seconds): \" no advancing\n           accept input-seconds\n           divide input-seconds by 60 giving input-seconds\n               remainder seconds\n           divide input-seconds by 60 giving input-seconds\n               remainder minutes\n           divide input-seconds by 24 giving input-seconds\n               remainder hours\n           divide input-seconds by 7 giving weeks\n               remainder days\n           move 1 to str-pos\n           call \"fmt\" using weeks weeks-str\n           call \"fmt\" using days days-str\n           call \"fmt\" using hours hours-str\n           call \"fmt\" using minutes minutes-str\n           call \"fmt\" using seconds seconds-str\n           display formatted-duration\n           stop run\n           .\n\n       identification division.\n       program-id. fmt.\n       data division.\n       working-storage section.\n       77 nothing pic x.\n       linkage section.\n       1 formatted-value pic x(4).\n       1 duration-size pic x(4).\n       procedure division using formatted-value duration-size.\n       begin.\n           if function numval (formatted-value) not = 0\n               perform insert-comma-space\n               unstring formatted-value delimited all space\n                   into nothing formatted-duration (str-pos:)\n                   count chars-transferred\n               add chars-transferred to str-pos\n               string space delimited size\n                   duration-size delimited space\n                   into formatted-duration pointer str-pos\n           end-if\n           exit program\n           .\n\n       insert-comma-space.\n           if str-pos > 1\n               move \", \" to formatted-duration (str-pos:)\n               add 2 to str-pos\n           end-if\n           .\n       end program fmt.\n       end program fmt-dura.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ConvertSecondsToCompoundDuration\n{\n  class Program\n  {\n    static void Main( string[] args )\n    {\n      foreach ( string arg in args )\n      {\n        int duration ;\n        bool isValid = int.TryParse( arg , out duration ) ;\n\n        if ( !isValid     ) { Console.Error.WriteLine( \"ERROR: Not an integer: {0}\"           , arg ) ; }\n        if ( duration < 0 ) { Console.Error.WriteLine( \"ERROR: duration must be non-negative\" , arg ) ; }\n        \n        Console.WriteLine();\n        Console.WriteLine( \"{0:#,##0} seconds ==> {1}\" , duration , FormatAsDuration(duration) ) ;\n        \n      }\n    }\n    \n    private static string FormatAsDuration( int duration )\n    {\n      if ( duration < 0 ) throw new ArgumentOutOfRangeException(\"duration\") ;\n      return string.Join( \", \" , GetDurationParts(duration)  ) ;\n    }\n    \n    private static IEnumerable<string> GetDurationParts( int duration )\n    {\n      var parts = new[]\n      {\n        new { Name=\"wk\" , Length = 7*24*60*60*1 , } ,\n        new { Name=\"d\"  , Length =   24*60*60*1 , } ,\n        new { Name=\"h\"  , Length =      60*60*1 , } ,\n        new { Name=\"m\"  , Length =         60*1 , } ,\n        new { Name=\"s\"  , Length =            1 , } ,\n      } ;\n      \n      foreach ( var part in parts )\n      {\n        int n = Math.DivRem( duration , part.Length , out duration ) ;\n        if ( n > 0 ) yield return string.Format( \"{0} {1}\" , n , part.Name ) ;\n      }\n      \n    }\n    \n  }\n  \n}\n"}
{"id": 118901, "name": "Convert seconds to compound duration", "source": "Translate COBOL to C#:        identification division.\n       program-id. fmt-dura.\n       data division.\n       working-storage section.\n       1 input-seconds pic 9(8).\n       1 formatted-duration pic x(30) global.\n       1 fractions.\n        2 weeks pic z(3)9.\n        2 days pic z(3)9.\n        2 hours pic z(3)9.\n        2 minutes pic z(3)9.\n        2 seconds pic z(3)9.\n       1 .\n        2 weeks-str pic x(4) value \"wk\".\n        2 days-str pic x(4) value \"d\".\n        2 hours-str pic x(4) value \"hr\".\n        2 minutes-str pic x(4) value \"min\".\n        2 seconds-str pic x(4) value \"sec\".\n       1 work binary global.\n        2 str-pos pic 9(4).\n        2 chars-transferred pic 9(4).\n       procedure division.\n       begin.\n           display \"Enter duration (seconds): \" no advancing\n           accept input-seconds\n           divide input-seconds by 60 giving input-seconds\n               remainder seconds\n           divide input-seconds by 60 giving input-seconds\n               remainder minutes\n           divide input-seconds by 24 giving input-seconds\n               remainder hours\n           divide input-seconds by 7 giving weeks\n               remainder days\n           move 1 to str-pos\n           call \"fmt\" using weeks weeks-str\n           call \"fmt\" using days days-str\n           call \"fmt\" using hours hours-str\n           call \"fmt\" using minutes minutes-str\n           call \"fmt\" using seconds seconds-str\n           display formatted-duration\n           stop run\n           .\n\n       identification division.\n       program-id. fmt.\n       data division.\n       working-storage section.\n       77 nothing pic x.\n       linkage section.\n       1 formatted-value pic x(4).\n       1 duration-size pic x(4).\n       procedure division using formatted-value duration-size.\n       begin.\n           if function numval (formatted-value) not = 0\n               perform insert-comma-space\n               unstring formatted-value delimited all space\n                   into nothing formatted-duration (str-pos:)\n                   count chars-transferred\n               add chars-transferred to str-pos\n               string space delimited size\n                   duration-size delimited space\n                   into formatted-duration pointer str-pos\n           end-if\n           exit program\n           .\n\n       insert-comma-space.\n           if str-pos > 1\n               move \", \" to formatted-duration (str-pos:)\n               add 2 to str-pos\n           end-if\n           .\n       end program fmt.\n       end program fmt-dura.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ConvertSecondsToCompoundDuration\n{\n  class Program\n  {\n    static void Main( string[] args )\n    {\n      foreach ( string arg in args )\n      {\n        int duration ;\n        bool isValid = int.TryParse( arg , out duration ) ;\n\n        if ( !isValid     ) { Console.Error.WriteLine( \"ERROR: Not an integer: {0}\"           , arg ) ; }\n        if ( duration < 0 ) { Console.Error.WriteLine( \"ERROR: duration must be non-negative\" , arg ) ; }\n        \n        Console.WriteLine();\n        Console.WriteLine( \"{0:#,##0} seconds ==> {1}\" , duration , FormatAsDuration(duration) ) ;\n        \n      }\n    }\n    \n    private static string FormatAsDuration( int duration )\n    {\n      if ( duration < 0 ) throw new ArgumentOutOfRangeException(\"duration\") ;\n      return string.Join( \", \" , GetDurationParts(duration)  ) ;\n    }\n    \n    private static IEnumerable<string> GetDurationParts( int duration )\n    {\n      var parts = new[]\n      {\n        new { Name=\"wk\" , Length = 7*24*60*60*1 , } ,\n        new { Name=\"d\"  , Length =   24*60*60*1 , } ,\n        new { Name=\"h\"  , Length =      60*60*1 , } ,\n        new { Name=\"m\"  , Length =         60*1 , } ,\n        new { Name=\"s\"  , Length =            1 , } ,\n      } ;\n      \n      foreach ( var part in parts )\n      {\n        int n = Math.DivRem( duration , part.Length , out duration ) ;\n        if ( n > 0 ) yield return string.Format( \"{0} {1}\" , n , part.Name ) ;\n      }\n      \n    }\n    \n  }\n  \n}\n"}
{"id": 118904, "name": "Convert seconds to compound duration", "source": "Translate COBOL to Java:        identification division.\n       program-id. fmt-dura.\n       data division.\n       working-storage section.\n       1 input-seconds pic 9(8).\n       1 formatted-duration pic x(30) global.\n       1 fractions.\n        2 weeks pic z(3)9.\n        2 days pic z(3)9.\n        2 hours pic z(3)9.\n        2 minutes pic z(3)9.\n        2 seconds pic z(3)9.\n       1 .\n        2 weeks-str pic x(4) value \"wk\".\n        2 days-str pic x(4) value \"d\".\n        2 hours-str pic x(4) value \"hr\".\n        2 minutes-str pic x(4) value \"min\".\n        2 seconds-str pic x(4) value \"sec\".\n       1 work binary global.\n        2 str-pos pic 9(4).\n        2 chars-transferred pic 9(4).\n       procedure division.\n       begin.\n           display \"Enter duration (seconds): \" no advancing\n           accept input-seconds\n           divide input-seconds by 60 giving input-seconds\n               remainder seconds\n           divide input-seconds by 60 giving input-seconds\n               remainder minutes\n           divide input-seconds by 24 giving input-seconds\n               remainder hours\n           divide input-seconds by 7 giving weeks\n               remainder days\n           move 1 to str-pos\n           call \"fmt\" using weeks weeks-str\n           call \"fmt\" using days days-str\n           call \"fmt\" using hours hours-str\n           call \"fmt\" using minutes minutes-str\n           call \"fmt\" using seconds seconds-str\n           display formatted-duration\n           stop run\n           .\n\n       identification division.\n       program-id. fmt.\n       data division.\n       working-storage section.\n       77 nothing pic x.\n       linkage section.\n       1 formatted-value pic x(4).\n       1 duration-size pic x(4).\n       procedure division using formatted-value duration-size.\n       begin.\n           if function numval (formatted-value) not = 0\n               perform insert-comma-space\n               unstring formatted-value delimited all space\n                   into nothing formatted-duration (str-pos:)\n                   count chars-transferred\n               add chars-transferred to str-pos\n               string space delimited size\n                   duration-size delimited space\n                   into formatted-duration pointer str-pos\n           end-if\n           exit program\n           .\n\n       insert-comma-space.\n           if str-pos > 1\n               move \", \" to formatted-duration (str-pos:)\n               add 2 to str-pos\n           end-if\n           .\n       end program fmt.\n       end program fmt-dura.\n", "target": "public class CompoundDuration {\n\n    public static void main(String[] args) {\n        compound(7259);\n        compound(86400);\n        compound(6000_000);\n    }\n\n    private static void compound(long seconds) {\n        StringBuilder sb = new StringBuilder();\n\n        seconds = addUnit(sb, seconds, 604800, \" wk, \");\n        seconds = addUnit(sb, seconds, 86400, \" d, \");\n        seconds = addUnit(sb, seconds, 3600, \" hr, \");\n        seconds = addUnit(sb, seconds, 60, \" min, \");\n        addUnit(sb, seconds, 1, \" sec, \");\n\n        sb.setLength(sb.length() > 2 ? sb.length() - 2 : 0);\n\n        System.out.println(sb);\n    }\n\n    private static long addUnit(StringBuilder sb, long sec, long unit, String s) {\n        long n;\n        if ((n = sec / unit) > 0) {\n            sb.append(n).append(s);\n            sec %= (n * unit);\n        }\n        return sec;\n    }\n}\n"}
{"id": 118905, "name": "Convert seconds to compound duration", "source": "Translate COBOL to Java:        identification division.\n       program-id. fmt-dura.\n       data division.\n       working-storage section.\n       1 input-seconds pic 9(8).\n       1 formatted-duration pic x(30) global.\n       1 fractions.\n        2 weeks pic z(3)9.\n        2 days pic z(3)9.\n        2 hours pic z(3)9.\n        2 minutes pic z(3)9.\n        2 seconds pic z(3)9.\n       1 .\n        2 weeks-str pic x(4) value \"wk\".\n        2 days-str pic x(4) value \"d\".\n        2 hours-str pic x(4) value \"hr\".\n        2 minutes-str pic x(4) value \"min\".\n        2 seconds-str pic x(4) value \"sec\".\n       1 work binary global.\n        2 str-pos pic 9(4).\n        2 chars-transferred pic 9(4).\n       procedure division.\n       begin.\n           display \"Enter duration (seconds): \" no advancing\n           accept input-seconds\n           divide input-seconds by 60 giving input-seconds\n               remainder seconds\n           divide input-seconds by 60 giving input-seconds\n               remainder minutes\n           divide input-seconds by 24 giving input-seconds\n               remainder hours\n           divide input-seconds by 7 giving weeks\n               remainder days\n           move 1 to str-pos\n           call \"fmt\" using weeks weeks-str\n           call \"fmt\" using days days-str\n           call \"fmt\" using hours hours-str\n           call \"fmt\" using minutes minutes-str\n           call \"fmt\" using seconds seconds-str\n           display formatted-duration\n           stop run\n           .\n\n       identification division.\n       program-id. fmt.\n       data division.\n       working-storage section.\n       77 nothing pic x.\n       linkage section.\n       1 formatted-value pic x(4).\n       1 duration-size pic x(4).\n       procedure division using formatted-value duration-size.\n       begin.\n           if function numval (formatted-value) not = 0\n               perform insert-comma-space\n               unstring formatted-value delimited all space\n                   into nothing formatted-duration (str-pos:)\n                   count chars-transferred\n               add chars-transferred to str-pos\n               string space delimited size\n                   duration-size delimited space\n                   into formatted-duration pointer str-pos\n           end-if\n           exit program\n           .\n\n       insert-comma-space.\n           if str-pos > 1\n               move \", \" to formatted-duration (str-pos:)\n               add 2 to str-pos\n           end-if\n           .\n       end program fmt.\n       end program fmt-dura.\n", "target": "public class CompoundDuration {\n\n    public static void main(String[] args) {\n        compound(7259);\n        compound(86400);\n        compound(6000_000);\n    }\n\n    private static void compound(long seconds) {\n        StringBuilder sb = new StringBuilder();\n\n        seconds = addUnit(sb, seconds, 604800, \" wk, \");\n        seconds = addUnit(sb, seconds, 86400, \" d, \");\n        seconds = addUnit(sb, seconds, 3600, \" hr, \");\n        seconds = addUnit(sb, seconds, 60, \" min, \");\n        addUnit(sb, seconds, 1, \" sec, \");\n\n        sb.setLength(sb.length() > 2 ? sb.length() - 2 : 0);\n\n        System.out.println(sb);\n    }\n\n    private static long addUnit(StringBuilder sb, long sec, long unit, String s) {\n        long n;\n        if ((n = sec / unit) > 0) {\n            sb.append(n).append(s);\n            sec %= (n * unit);\n        }\n        return sec;\n    }\n}\n"}
{"id": 118906, "name": "Convert seconds to compound duration", "source": "Translate COBOL to Python:        identification division.\n       program-id. fmt-dura.\n       data division.\n       working-storage section.\n       1 input-seconds pic 9(8).\n       1 formatted-duration pic x(30) global.\n       1 fractions.\n        2 weeks pic z(3)9.\n        2 days pic z(3)9.\n        2 hours pic z(3)9.\n        2 minutes pic z(3)9.\n        2 seconds pic z(3)9.\n       1 .\n        2 weeks-str pic x(4) value \"wk\".\n        2 days-str pic x(4) value \"d\".\n        2 hours-str pic x(4) value \"hr\".\n        2 minutes-str pic x(4) value \"min\".\n        2 seconds-str pic x(4) value \"sec\".\n       1 work binary global.\n        2 str-pos pic 9(4).\n        2 chars-transferred pic 9(4).\n       procedure division.\n       begin.\n           display \"Enter duration (seconds): \" no advancing\n           accept input-seconds\n           divide input-seconds by 60 giving input-seconds\n               remainder seconds\n           divide input-seconds by 60 giving input-seconds\n               remainder minutes\n           divide input-seconds by 24 giving input-seconds\n               remainder hours\n           divide input-seconds by 7 giving weeks\n               remainder days\n           move 1 to str-pos\n           call \"fmt\" using weeks weeks-str\n           call \"fmt\" using days days-str\n           call \"fmt\" using hours hours-str\n           call \"fmt\" using minutes minutes-str\n           call \"fmt\" using seconds seconds-str\n           display formatted-duration\n           stop run\n           .\n\n       identification division.\n       program-id. fmt.\n       data division.\n       working-storage section.\n       77 nothing pic x.\n       linkage section.\n       1 formatted-value pic x(4).\n       1 duration-size pic x(4).\n       procedure division using formatted-value duration-size.\n       begin.\n           if function numval (formatted-value) not = 0\n               perform insert-comma-space\n               unstring formatted-value delimited all space\n                   into nothing formatted-duration (str-pos:)\n                   count chars-transferred\n               add chars-transferred to str-pos\n               string space delimited size\n                   duration-size delimited space\n                   into formatted-duration pointer str-pos\n           end-if\n           exit program\n           .\n\n       insert-comma-space.\n           if str-pos > 1\n               move \", \" to formatted-duration (str-pos:)\n               add 2 to str-pos\n           end-if\n           .\n       end program fmt.\n       end program fmt-dura.\n", "target": ">>> def duration(seconds):\n\tt= []\n\tfor dm in (60, 60, 24, 7):\n\t\tseconds, m = divmod(seconds, dm)\n\t\tt.append(m)\n\tt.append(seconds)\n\treturn ', '.join('%d %s' % (num, unit)\n\t\t\t for num, unit in zip(t[::-1], 'wk d hr min sec'.split())\n\t\t\t if num)\n\n>>> for seconds in [7259, 86400, 6000000]:\n\tprint(\"%7d sec = %s\" % (seconds, duration(seconds)))\n\n\t\n   7259 sec = 2 hr, 59 sec\n  86400 sec = 1 d\n6000000 sec = 9 wk, 6 d, 10 hr, 40 min\n>>>\n"}
{"id": 118907, "name": "Convert seconds to compound duration", "source": "Translate COBOL to Python:        identification division.\n       program-id. fmt-dura.\n       data division.\n       working-storage section.\n       1 input-seconds pic 9(8).\n       1 formatted-duration pic x(30) global.\n       1 fractions.\n        2 weeks pic z(3)9.\n        2 days pic z(3)9.\n        2 hours pic z(3)9.\n        2 minutes pic z(3)9.\n        2 seconds pic z(3)9.\n       1 .\n        2 weeks-str pic x(4) value \"wk\".\n        2 days-str pic x(4) value \"d\".\n        2 hours-str pic x(4) value \"hr\".\n        2 minutes-str pic x(4) value \"min\".\n        2 seconds-str pic x(4) value \"sec\".\n       1 work binary global.\n        2 str-pos pic 9(4).\n        2 chars-transferred pic 9(4).\n       procedure division.\n       begin.\n           display \"Enter duration (seconds): \" no advancing\n           accept input-seconds\n           divide input-seconds by 60 giving input-seconds\n               remainder seconds\n           divide input-seconds by 60 giving input-seconds\n               remainder minutes\n           divide input-seconds by 24 giving input-seconds\n               remainder hours\n           divide input-seconds by 7 giving weeks\n               remainder days\n           move 1 to str-pos\n           call \"fmt\" using weeks weeks-str\n           call \"fmt\" using days days-str\n           call \"fmt\" using hours hours-str\n           call \"fmt\" using minutes minutes-str\n           call \"fmt\" using seconds seconds-str\n           display formatted-duration\n           stop run\n           .\n\n       identification division.\n       program-id. fmt.\n       data division.\n       working-storage section.\n       77 nothing pic x.\n       linkage section.\n       1 formatted-value pic x(4).\n       1 duration-size pic x(4).\n       procedure division using formatted-value duration-size.\n       begin.\n           if function numval (formatted-value) not = 0\n               perform insert-comma-space\n               unstring formatted-value delimited all space\n                   into nothing formatted-duration (str-pos:)\n                   count chars-transferred\n               add chars-transferred to str-pos\n               string space delimited size\n                   duration-size delimited space\n                   into formatted-duration pointer str-pos\n           end-if\n           exit program\n           .\n\n       insert-comma-space.\n           if str-pos > 1\n               move \", \" to formatted-duration (str-pos:)\n               add 2 to str-pos\n           end-if\n           .\n       end program fmt.\n       end program fmt-dura.\n", "target": ">>> def duration(seconds):\n\tt= []\n\tfor dm in (60, 60, 24, 7):\n\t\tseconds, m = divmod(seconds, dm)\n\t\tt.append(m)\n\tt.append(seconds)\n\treturn ', '.join('%d %s' % (num, unit)\n\t\t\t for num, unit in zip(t[::-1], 'wk d hr min sec'.split())\n\t\t\t if num)\n\n>>> for seconds in [7259, 86400, 6000000]:\n\tprint(\"%7d sec = %s\" % (seconds, duration(seconds)))\n\n\t\n   7259 sec = 2 hr, 59 sec\n  86400 sec = 1 d\n6000000 sec = 9 wk, 6 d, 10 hr, 40 min\n>>>\n"}
{"id": 119148, "name": "Execute a system command", "source": "Translate COBOL to C#: CALL \"SYSTEM\" USING BY CONTENT \"ls\"\n", "target": "using System.Diagnostics;\n\nnamespace Execute\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Process.Start(\"cmd.exe\", \"/c dir\");\n        }\n    }\n}\n"}
{"id": 119149, "name": "Execute a system command", "source": "Translate COBOL to Java: CALL \"SYSTEM\" USING BY CONTENT \"ls\"\n", "target": "import java.util.Scanner;\nimport java.io.*;\n\npublic class Program {\n    public static void main(String[] args) {    \t\n    \ttry {\n    \t\tProcess p = Runtime.getRuntime().exec(\"cmd /C dir\");\n    \t\tScanner sc = new Scanner(p.getInputStream());    \t\t\n    \t\twhile (sc.hasNext()) System.out.println(sc.nextLine());\n    \t}\n    \tcatch (IOException e) {\n    \t\tSystem.out.println(e.getMessage());\n    \t}\n    }\n}\n"}
{"id": 119150, "name": "Execute a system command", "source": "Translate COBOL to Python: CALL \"SYSTEM\" USING BY CONTENT \"ls\"\n", "target": "import os\nexit_code = os.system('ls')       \noutput    = os.popen('ls').read() \n"}
{"id": 119409, "name": "Loops_Do-while", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. loop-do-while.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i PIC 99 VALUE 0.\n\n       PROCEDURE DIVISION.\n           PERFORM WITH TEST AFTER UNTIL FUNCTION MOD(i, 6) = 0\n               ADD 1 TO i\n               DISPLAY i\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "int a = 0;\n\ndo\n{\n    a += 1;\n    Console.WriteLine(a);\n} while (a % 6 != 0);\n"}
{"id": 119411, "name": "Loops_Do-while", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. loop-do-while.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i PIC 99 VALUE 0.\n\n       PROCEDURE DIVISION.\n           PERFORM WITH TEST AFTER UNTIL FUNCTION MOD(i, 6) = 0\n               ADD 1 TO i\n               DISPLAY i\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "int val = 0;\ndo{\n   val++;\n   System.out.println(val);\n}while(val % 6 != 0);\n"}
{"id": 119412, "name": "Loops_Do-while", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. loop-do-while.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i PIC 99 VALUE 0.\n\n       PROCEDURE DIVISION.\n           PERFORM WITH TEST AFTER UNTIL FUNCTION MOD(i, 6) = 0\n               ADD 1 TO i\n               DISPLAY i\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "val = 0\nwhile True:\n   val +=1\n   print val\n   if val % 6 == 0: break\n"}
{"id": 119963, "name": "Text processing_2", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. text-processing-2.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT readings ASSIGN Input-File-Path\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS file-status.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  readings.\n       01  reading-record.\n           03  date-stamp          PIC X(10).\n           03  FILLER              PIC X.\n           03  input-data          PIC X(300).\n\n       LOCAL-STORAGE SECTION.\n       78  Input-File-Path         VALUE \"readings.txt\".\n       78  Num-Data-Points         VALUE 48.\n\n       01  file-status             PIC XX.\n\n       01  current-line            PIC 9(5).\n\n       01  num-date-stamps-read    PIC 9(5).\n       01  read-date-stamps-area.\n           03  read-date-stamps    PIC X(10) OCCURS 1 TO 10000 TIMES\n                                   DEPENDING ON num-date-stamps-read\n                                   INDEXED BY date-stamp-idx.\n\n       01  offset                  PIC 999.\n       01  data-len                PIC 999.\n       01  data-flag               PIC X.\n           88  data-not-found      VALUE \"N\".\n\n       01  data-field              PIC X(25).\n\n       01  i                       PIC 99.\n\n       01  num-good-readings       PIC 9(5).\n\n       01  reading-flag            PIC X.\n           88 bad-reading          VALUE \"B\".\n\n       01  delim                   PIC X.\n\n       PROCEDURE DIVISION.\n       DECLARATIVES.\n       readings-error SECTION.\n           USE AFTER ERROR ON readings\n\n           DISPLAY \"An error occurred while using \" Input-File-Path\n           DISPLAY \"Error code \" file-status\n           DISPLAY \"The program will terminate.\"\n\n           CLOSE readings\n           GOBACK\n           .\n       END DECLARATIVES.\n\n       main-line.\n           OPEN INPUT readings\n\n           \n           PERFORM FOREVER\n               READ readings\n                   AT END\n                       EXIT PERFORM\n               END-READ\n\n               ADD 1 TO current-line\n\n               IF reading-record = SPACES\n                   DISPLAY \"Line \" current-line \" is blank.\"\n                   EXIT PERFORM CYCLE\n               END-IF\n\n               PERFORM check-duplicate-date-stamp\n\n               \n               \n               INITIALIZE offset, reading-flag, data-flag\n               PERFORM VARYING i FROM 1 BY 1 UNTIL Num-Data-Points < i\n                   PERFORM get-next-field\n                   IF data-not-found\n                       DISPLAY \"Line \" current-line \" has missing \"\n                           \"fields.\"\n                       SET bad-reading TO TRUE\n                       EXIT PERFORM\n                   END-IF\n\n                   \n                   IF FUNCTION MOD(i, 2) = 0 AND NOT bad-reading\n                       IF FUNCTION NUMVAL(data-field) <= 0\n                           SET bad-reading TO TRUE\n                       END-IF\n                   END-IF\n\n                   ADD data-len TO offset\n               END-PERFORM\n\n               IF NOT bad-reading\n                   ADD 1 TO num-good-readings\n               END-IF\n           END-PERFORM\n\n           CLOSE readings\n\n           \n           DISPLAY SPACE\n           DISPLAY current-line \" lines read.\"\n           DISPLAY num-good-readings \" have good readings for all \"\n               \"instruments.\"\n\n           GOBACK\n           .\n       check-duplicate-date-stamp.\n           SEARCH read-date-stamps\n               AT END\n                   ADD 1 TO num-date-stamps-read\n                   MOVE date-stamp\n                       TO read-date-stamps (num-date-stamps-read)\n\n               WHEN read-date-stamps (date-stamp-idx) = date-stamp\n                   DISPLAY \"Date \" date-stamp \" is duplicated at \"\n                       \"line \" current-line \".\"\n           END-SEARCH\n           .\n       get-next-field.\n           INSPECT input-data (offset:) TALLYING offset\n               FOR LEADING X\"09\"\n\n           \n           MOVE X\"09\" TO delim\n           PERFORM find-num-chars-before-delim\n\n           \n           IF FUNCTION SUM(data-len, offset) > 300\n               \n               \n               MOVE SPACE TO delim\n               PERFORM find-num-chars-before-delim\n\n               IF FUNCTION SUM(data-len, offset) > 300\n                   SET data-not-found TO TRUE\n                   EXIT PARAGRAPH\n               END-IF\n           END-IF\n\n           IF data-len = 0\n               SET data-not-found TO TRUE\n               EXIT PARAGRAPH\n           END-IF\n\n           MOVE input-data (offset:data-len) TO data-field\n           .\n       find-num-chars-before-delim.\n           INITIALIZE data-len\n           INSPECT input-data (offset:) TALLYING data-len\n               FOR CHARACTERS BEFORE delim\n           .\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing System.IO;\n\nnamespace TextProc2\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Regex multiWhite = new Regex(@\"\\s+\");\n            Regex dateEx = new Regex(@\"^\\d{4}-\\d{2}-\\d{2}$\");\n            Regex valEx = new Regex(@\"^\\d+\\.{1}\\d{3}$\");\n            Regex flagEx = new Regex(@\"^[1-9]{1}$\");\n            \n            int missformcount = 0, totalcount = 0;\n            Dictionary<int, string> dates = new Dictionary<int, string>();\n\n            using (StreamReader sr = new StreamReader(\"readings.txt\"))\n            {\n                string line = sr.ReadLine();\n                while (line != null)\n                {\n                    line = multiWhite.Replace(line, @\" \");                    \n                    string[] splitLine = line.Split(' ');\n                    if (splitLine.Length != 49)\n                        missformcount++;\n                    if (!dateEx.IsMatch(splitLine[0]))                        \n                        missformcount++;                    \n                    else\n                        dates.Add(totalcount + 1, dateEx.Match(splitLine[0]).ToString());\n                    int err = 0;                    \n                    for (int i = 1; i < splitLine.Length; i++)\n                    {\n                        if (i%2 != 0)\n                        {\n                            if (!valEx.IsMatch(splitLine[i]))                          \n                                err++;\n                        }\n                        else\n                        {\n                            if (!flagEx.IsMatch(splitLine[i]))\n                                err++;                                                        \n                        }                        \n                    }\n                    if (err != 0) missformcount++;\n                    line = sr.ReadLine();\n                    totalcount++;                    \n                }\n            }\n\n            int goodEntries = totalcount - missformcount;\n            Dictionary<string,List<int>> dateReverse = new Dictionary<string,List<int>>();\n\n            foreach (KeyValuePair<int, string> kvp in dates)\n            {\n                if (!dateReverse.ContainsKey(kvp.Value))\n                    dateReverse[kvp.Value] = new List<int>();\n                dateReverse[kvp.Value].Add(kvp.Key);\n            }\n\n            Console.WriteLine(goodEntries + \" valid Records out of \" + totalcount);\n\n            foreach (KeyValuePair<string, List<int>> kvp in dateReverse)\n            {\n                if (kvp.Value.Count > 1)\n                    Console.WriteLine(\"{0} is duplicated at Lines\u00a0: {1}\", kvp.Key, string.Join(\",\", kvp.Value));                    \n            }\n        }\n    }\n}\n"}
{"id": 119965, "name": "Text processing_2", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. text-processing-2.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT readings ASSIGN Input-File-Path\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS file-status.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  readings.\n       01  reading-record.\n           03  date-stamp          PIC X(10).\n           03  FILLER              PIC X.\n           03  input-data          PIC X(300).\n\n       LOCAL-STORAGE SECTION.\n       78  Input-File-Path         VALUE \"readings.txt\".\n       78  Num-Data-Points         VALUE 48.\n\n       01  file-status             PIC XX.\n\n       01  current-line            PIC 9(5).\n\n       01  num-date-stamps-read    PIC 9(5).\n       01  read-date-stamps-area.\n           03  read-date-stamps    PIC X(10) OCCURS 1 TO 10000 TIMES\n                                   DEPENDING ON num-date-stamps-read\n                                   INDEXED BY date-stamp-idx.\n\n       01  offset                  PIC 999.\n       01  data-len                PIC 999.\n       01  data-flag               PIC X.\n           88  data-not-found      VALUE \"N\".\n\n       01  data-field              PIC X(25).\n\n       01  i                       PIC 99.\n\n       01  num-good-readings       PIC 9(5).\n\n       01  reading-flag            PIC X.\n           88 bad-reading          VALUE \"B\".\n\n       01  delim                   PIC X.\n\n       PROCEDURE DIVISION.\n       DECLARATIVES.\n       readings-error SECTION.\n           USE AFTER ERROR ON readings\n\n           DISPLAY \"An error occurred while using \" Input-File-Path\n           DISPLAY \"Error code \" file-status\n           DISPLAY \"The program will terminate.\"\n\n           CLOSE readings\n           GOBACK\n           .\n       END DECLARATIVES.\n\n       main-line.\n           OPEN INPUT readings\n\n           \n           PERFORM FOREVER\n               READ readings\n                   AT END\n                       EXIT PERFORM\n               END-READ\n\n               ADD 1 TO current-line\n\n               IF reading-record = SPACES\n                   DISPLAY \"Line \" current-line \" is blank.\"\n                   EXIT PERFORM CYCLE\n               END-IF\n\n               PERFORM check-duplicate-date-stamp\n\n               \n               \n               INITIALIZE offset, reading-flag, data-flag\n               PERFORM VARYING i FROM 1 BY 1 UNTIL Num-Data-Points < i\n                   PERFORM get-next-field\n                   IF data-not-found\n                       DISPLAY \"Line \" current-line \" has missing \"\n                           \"fields.\"\n                       SET bad-reading TO TRUE\n                       EXIT PERFORM\n                   END-IF\n\n                   \n                   IF FUNCTION MOD(i, 2) = 0 AND NOT bad-reading\n                       IF FUNCTION NUMVAL(data-field) <= 0\n                           SET bad-reading TO TRUE\n                       END-IF\n                   END-IF\n\n                   ADD data-len TO offset\n               END-PERFORM\n\n               IF NOT bad-reading\n                   ADD 1 TO num-good-readings\n               END-IF\n           END-PERFORM\n\n           CLOSE readings\n\n           \n           DISPLAY SPACE\n           DISPLAY current-line \" lines read.\"\n           DISPLAY num-good-readings \" have good readings for all \"\n               \"instruments.\"\n\n           GOBACK\n           .\n       check-duplicate-date-stamp.\n           SEARCH read-date-stamps\n               AT END\n                   ADD 1 TO num-date-stamps-read\n                   MOVE date-stamp\n                       TO read-date-stamps (num-date-stamps-read)\n\n               WHEN read-date-stamps (date-stamp-idx) = date-stamp\n                   DISPLAY \"Date \" date-stamp \" is duplicated at \"\n                       \"line \" current-line \".\"\n           END-SEARCH\n           .\n       get-next-field.\n           INSPECT input-data (offset:) TALLYING offset\n               FOR LEADING X\"09\"\n\n           \n           MOVE X\"09\" TO delim\n           PERFORM find-num-chars-before-delim\n\n           \n           IF FUNCTION SUM(data-len, offset) > 300\n               \n               \n               MOVE SPACE TO delim\n               PERFORM find-num-chars-before-delim\n\n               IF FUNCTION SUM(data-len, offset) > 300\n                   SET data-not-found TO TRUE\n                   EXIT PARAGRAPH\n               END-IF\n           END-IF\n\n           IF data-len = 0\n               SET data-not-found TO TRUE\n               EXIT PARAGRAPH\n           END-IF\n\n           MOVE input-data (offset:data-len) TO data-field\n           .\n       find-num-chars-before-delim.\n           INITIALIZE data-len\n           INSPECT input-data (offset:) TALLYING data-len\n               FOR CHARACTERS BEFORE delim\n           .\n", "target": "import java.util.*;\nimport java.util.regex.*;\nimport java.io.*;\n\npublic class DataMunging2 {\n\n    public static final Pattern e = Pattern.compile(\"\\\\s+\");\n\n    public static void main(String[] args) {\n        try {\n            BufferedReader infile = new BufferedReader(new FileReader(args[0]));\n            List<String> duplicates = new ArrayList<String>();\n            Set<String> datestamps = new HashSet<String>(); \n\n            String eingabe;\n            int all_ok = 0;\n            while ((eingabe = infile.readLine()) != null) { \n                String[] fields = e.split(eingabe); \n                if (fields.length != 49) \n                    System.out.println(\"Format not ok!\");\n                if (datestamps.add(fields[0])) { \n                    int howoften = (fields.length - 1) / 2 ; \n                                                             \n                    for (int n = 1; Integer.parseInt(fields[2*n]) >= 1; n++) {\n                        if (n == howoften) {\n                            all_ok++ ;\n                            break ;\n                        }\n                    }\n                } else {\n                    duplicates.add(fields[0]); \n                }\n            }\n            infile.close();\n            System.out.println(\"The following \" + duplicates.size() + \" datestamps were duplicated:\");\n            for (String x : duplicates)\n                System.out.println(x);\n            System.out.println(all_ok + \" records were complete and ok!\");\n        } catch (IOException e) {\n            System.err.println(\"Can't open file \" + args[0]);\n            System.exit(1);\n        }\n    }\n}\n"}
{"id": 119966, "name": "Text processing_2", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. text-processing-2.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT readings ASSIGN Input-File-Path\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS file-status.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  readings.\n       01  reading-record.\n           03  date-stamp          PIC X(10).\n           03  FILLER              PIC X.\n           03  input-data          PIC X(300).\n\n       LOCAL-STORAGE SECTION.\n       78  Input-File-Path         VALUE \"readings.txt\".\n       78  Num-Data-Points         VALUE 48.\n\n       01  file-status             PIC XX.\n\n       01  current-line            PIC 9(5).\n\n       01  num-date-stamps-read    PIC 9(5).\n       01  read-date-stamps-area.\n           03  read-date-stamps    PIC X(10) OCCURS 1 TO 10000 TIMES\n                                   DEPENDING ON num-date-stamps-read\n                                   INDEXED BY date-stamp-idx.\n\n       01  offset                  PIC 999.\n       01  data-len                PIC 999.\n       01  data-flag               PIC X.\n           88  data-not-found      VALUE \"N\".\n\n       01  data-field              PIC X(25).\n\n       01  i                       PIC 99.\n\n       01  num-good-readings       PIC 9(5).\n\n       01  reading-flag            PIC X.\n           88 bad-reading          VALUE \"B\".\n\n       01  delim                   PIC X.\n\n       PROCEDURE DIVISION.\n       DECLARATIVES.\n       readings-error SECTION.\n           USE AFTER ERROR ON readings\n\n           DISPLAY \"An error occurred while using \" Input-File-Path\n           DISPLAY \"Error code \" file-status\n           DISPLAY \"The program will terminate.\"\n\n           CLOSE readings\n           GOBACK\n           .\n       END DECLARATIVES.\n\n       main-line.\n           OPEN INPUT readings\n\n           \n           PERFORM FOREVER\n               READ readings\n                   AT END\n                       EXIT PERFORM\n               END-READ\n\n               ADD 1 TO current-line\n\n               IF reading-record = SPACES\n                   DISPLAY \"Line \" current-line \" is blank.\"\n                   EXIT PERFORM CYCLE\n               END-IF\n\n               PERFORM check-duplicate-date-stamp\n\n               \n               \n               INITIALIZE offset, reading-flag, data-flag\n               PERFORM VARYING i FROM 1 BY 1 UNTIL Num-Data-Points < i\n                   PERFORM get-next-field\n                   IF data-not-found\n                       DISPLAY \"Line \" current-line \" has missing \"\n                           \"fields.\"\n                       SET bad-reading TO TRUE\n                       EXIT PERFORM\n                   END-IF\n\n                   \n                   IF FUNCTION MOD(i, 2) = 0 AND NOT bad-reading\n                       IF FUNCTION NUMVAL(data-field) <= 0\n                           SET bad-reading TO TRUE\n                       END-IF\n                   END-IF\n\n                   ADD data-len TO offset\n               END-PERFORM\n\n               IF NOT bad-reading\n                   ADD 1 TO num-good-readings\n               END-IF\n           END-PERFORM\n\n           CLOSE readings\n\n           \n           DISPLAY SPACE\n           DISPLAY current-line \" lines read.\"\n           DISPLAY num-good-readings \" have good readings for all \"\n               \"instruments.\"\n\n           GOBACK\n           .\n       check-duplicate-date-stamp.\n           SEARCH read-date-stamps\n               AT END\n                   ADD 1 TO num-date-stamps-read\n                   MOVE date-stamp\n                       TO read-date-stamps (num-date-stamps-read)\n\n               WHEN read-date-stamps (date-stamp-idx) = date-stamp\n                   DISPLAY \"Date \" date-stamp \" is duplicated at \"\n                       \"line \" current-line \".\"\n           END-SEARCH\n           .\n       get-next-field.\n           INSPECT input-data (offset:) TALLYING offset\n               FOR LEADING X\"09\"\n\n           \n           MOVE X\"09\" TO delim\n           PERFORM find-num-chars-before-delim\n\n           \n           IF FUNCTION SUM(data-len, offset) > 300\n               \n               \n               MOVE SPACE TO delim\n               PERFORM find-num-chars-before-delim\n\n               IF FUNCTION SUM(data-len, offset) > 300\n                   SET data-not-found TO TRUE\n                   EXIT PARAGRAPH\n               END-IF\n           END-IF\n\n           IF data-len = 0\n               SET data-not-found TO TRUE\n               EXIT PARAGRAPH\n           END-IF\n\n           MOVE input-data (offset:data-len) TO data-field\n           .\n       find-num-chars-before-delim.\n           INITIALIZE data-len\n           INSPECT input-data (offset:) TALLYING data-len\n               FOR CHARACTERS BEFORE delim\n           .\n", "target": "import re\nimport zipfile\nimport StringIO\n\ndef munge2(readings):\n\n   datePat = re.compile(r'\\d{4}-\\d{2}-\\d{2}')\n   valuPat = re.compile(r'[-+]?\\d+\\.\\d+')\n   statPat = re.compile(r'-?\\d+')\n   allOk, totalLines = 0, 0\n   datestamps = set([])\n   for line in readings:\n      totalLines += 1\n      fields = line.split('\\t')\n      date = fields[0]\n      pairs = [(fields[i],fields[i+1]) for i in range(1,len(fields),2)]\n\n      lineFormatOk = datePat.match(date) and \\\n         all( valuPat.match(p[0]) for p in pairs ) and \\\n         all( statPat.match(p[1]) for p in pairs )\n      if not lineFormatOk:\n         print 'Bad formatting', line\n         continue\n\t\t\n      if len(pairs)!=24 or any( int(p[1]) < 1 for p in pairs ):\n         print 'Missing values', line\n         continue\n\n      if date in datestamps:\n         print 'Duplicate datestamp', line\n         continue\n      datestamps.add(date)\n      allOk += 1\n\n   print 'Lines with all readings: ', allOk\n   print 'Total records: ', totalLines\n\n\n\nreadings = open('readings.txt','r')\nmunge2(readings)\n"}
{"id": 120387, "name": "Floyd's triangle", "source": "Translate COBOL to C#:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. FLOYD-TRIANGLE.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 VARIABLES        COMP.\n           02 NUM-LINES     PIC 99.\n           02 CUR-LINE      PIC 99.\n           02 CUR-COL       PIC 99.\n           02 CUR-NUM       PIC 999.\n           02 ZERO-SKIP     PIC 9.\n           02 LINE-PTR      PIC 99.\n           02 MAX-NUM       PIC 999.\n        \n        01 OUTPUT-FORMAT.\n           02 OUT-LINE      PIC X(72).\n           02 ONE-DIGIT     PIC B9.\n           02 TWO-DIGITS    PIC BZ9.\n           02 THREE-DIGITS  PIC BZZ9.\n           02 MAX-COL-NUM   PIC 999.\n        \n        PROCEDURE DIVISION.\n        BEGIN.\n            MOVE 5 TO NUM-LINES. PERFORM FLOYD.\n            DISPLAY ' '.\n            MOVE 14 TO NUM-LINES. PERFORM FLOYD.\n            STOP RUN.\n            \n        FLOYD.\n            MOVE 1 TO CUR-NUM.\n            COMPUTE MAX-NUM = NUM-LINES * (NUM-LINES + 1) / 2.\n            PERFORM FLOYD-LINE \n                VARYING CUR-LINE FROM 1 BY 1\n                UNTIL CUR-LINE IS GREATER THAN NUM-LINES.\n            \n        FLOYD-LINE.\n            MOVE ' ' TO OUT-LINE.\n            MOVE 1 TO LINE-PTR.\n            PERFORM FLOYD-NUM\n                VARYING CUR-COL FROM 1 BY 1\n                UNTIL CUR-COL IS GREATER THAN CUR-LINE.\n            DISPLAY OUT-LINE.\n\n        FLOYD-NUM.\n            COMPUTE MAX-COL-NUM = MAX-NUM - NUM-LINES + CUR-COL.\n            MOVE 0 TO ZERO-SKIP.\n            INSPECT MAX-COL-NUM TALLYING ZERO-SKIP FOR LEADING '0'.\n            IF ZERO-SKIP IS EQUAL TO ZERO\n                PERFORM FLOYD-THREE-DIGITS\n            ELSE IF ZERO-SKIP IS EQUAL TO 1\n                PERFORM FLOYD-TWO-DIGITS\n            ELSE IF ZERO-SKIP IS EQUAL TO 2\n                PERFORM FLOYD-ONE-DIGIT.\n            ADD 1 TO CUR-NUM.\n                \n        FLOYD-ONE-DIGIT.\n            MOVE CUR-NUM TO ONE-DIGIT.\n            STRING ONE-DIGIT DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n        \n        FLOYD-TWO-DIGITS.\n            MOVE CUR-NUM TO TWO-DIGITS.\n            STRING TWO-DIGITS DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n        \n        FLOYD-THREE-DIGITS.\n            MOVE CUR-NUM TO THREE-DIGITS.\n            STRING THREE-DIGITS DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n", "target": "using System;\nusing System.Text;\n\npublic class FloydsTriangle\n{\n    internal static void Main(string[] args)\n    {\n        int count;\n        if (args.Length >= 1 && int.TryParse(args[0], out count) && count > 0)\n        {\n            Console.WriteLine(MakeTriangle(count));\n        }\n        else\n        {\n            Console.WriteLine(MakeTriangle(5));\n            Console.WriteLine();\n            Console.WriteLine(MakeTriangle(14));\n        }\n    }\n\n    public static string MakeTriangle(int rows)\n    {\n        int maxValue = (rows * (rows + 1)) / 2;\n        int digit = 0;\n        StringBuilder output = new StringBuilder();\n\n        for (int row = 1; row <= rows; row++)\n        {\n            for (int column = 0; column < row; column++)\n            {\n                int colMaxDigit = (maxValue - rows) + column + 1;\n                if (column > 0)\n                {\n                    output.Append(' ');\n                }\n\n                digit++;\n                output.Append(digit.ToString().PadLeft(colMaxDigit.ToString().Length));\n            }\n\n            output.AppendLine();\n        }\n\n        return output.ToString();\n    }\n}\n"}
{"id": 120388, "name": "Floyd's triangle", "source": "Translate COBOL to C#:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. FLOYD-TRIANGLE.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 VARIABLES        COMP.\n           02 NUM-LINES     PIC 99.\n           02 CUR-LINE      PIC 99.\n           02 CUR-COL       PIC 99.\n           02 CUR-NUM       PIC 999.\n           02 ZERO-SKIP     PIC 9.\n           02 LINE-PTR      PIC 99.\n           02 MAX-NUM       PIC 999.\n        \n        01 OUTPUT-FORMAT.\n           02 OUT-LINE      PIC X(72).\n           02 ONE-DIGIT     PIC B9.\n           02 TWO-DIGITS    PIC BZ9.\n           02 THREE-DIGITS  PIC BZZ9.\n           02 MAX-COL-NUM   PIC 999.\n        \n        PROCEDURE DIVISION.\n        BEGIN.\n            MOVE 5 TO NUM-LINES. PERFORM FLOYD.\n            DISPLAY ' '.\n            MOVE 14 TO NUM-LINES. PERFORM FLOYD.\n            STOP RUN.\n            \n        FLOYD.\n            MOVE 1 TO CUR-NUM.\n            COMPUTE MAX-NUM = NUM-LINES * (NUM-LINES + 1) / 2.\n            PERFORM FLOYD-LINE \n                VARYING CUR-LINE FROM 1 BY 1\n                UNTIL CUR-LINE IS GREATER THAN NUM-LINES.\n            \n        FLOYD-LINE.\n            MOVE ' ' TO OUT-LINE.\n            MOVE 1 TO LINE-PTR.\n            PERFORM FLOYD-NUM\n                VARYING CUR-COL FROM 1 BY 1\n                UNTIL CUR-COL IS GREATER THAN CUR-LINE.\n            DISPLAY OUT-LINE.\n\n        FLOYD-NUM.\n            COMPUTE MAX-COL-NUM = MAX-NUM - NUM-LINES + CUR-COL.\n            MOVE 0 TO ZERO-SKIP.\n            INSPECT MAX-COL-NUM TALLYING ZERO-SKIP FOR LEADING '0'.\n            IF ZERO-SKIP IS EQUAL TO ZERO\n                PERFORM FLOYD-THREE-DIGITS\n            ELSE IF ZERO-SKIP IS EQUAL TO 1\n                PERFORM FLOYD-TWO-DIGITS\n            ELSE IF ZERO-SKIP IS EQUAL TO 2\n                PERFORM FLOYD-ONE-DIGIT.\n            ADD 1 TO CUR-NUM.\n                \n        FLOYD-ONE-DIGIT.\n            MOVE CUR-NUM TO ONE-DIGIT.\n            STRING ONE-DIGIT DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n        \n        FLOYD-TWO-DIGITS.\n            MOVE CUR-NUM TO TWO-DIGITS.\n            STRING TWO-DIGITS DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n        \n        FLOYD-THREE-DIGITS.\n            MOVE CUR-NUM TO THREE-DIGITS.\n            STRING THREE-DIGITS DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n", "target": "using System;\nusing System.Text;\n\npublic class FloydsTriangle\n{\n    internal static void Main(string[] args)\n    {\n        int count;\n        if (args.Length >= 1 && int.TryParse(args[0], out count) && count > 0)\n        {\n            Console.WriteLine(MakeTriangle(count));\n        }\n        else\n        {\n            Console.WriteLine(MakeTriangle(5));\n            Console.WriteLine();\n            Console.WriteLine(MakeTriangle(14));\n        }\n    }\n\n    public static string MakeTriangle(int rows)\n    {\n        int maxValue = (rows * (rows + 1)) / 2;\n        int digit = 0;\n        StringBuilder output = new StringBuilder();\n\n        for (int row = 1; row <= rows; row++)\n        {\n            for (int column = 0; column < row; column++)\n            {\n                int colMaxDigit = (maxValue - rows) + column + 1;\n                if (column > 0)\n                {\n                    output.Append(' ');\n                }\n\n                digit++;\n                output.Append(digit.ToString().PadLeft(colMaxDigit.ToString().Length));\n            }\n\n            output.AppendLine();\n        }\n\n        return output.ToString();\n    }\n}\n"}
{"id": 120391, "name": "Floyd's triangle", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. FLOYD-TRIANGLE.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 VARIABLES        COMP.\n           02 NUM-LINES     PIC 99.\n           02 CUR-LINE      PIC 99.\n           02 CUR-COL       PIC 99.\n           02 CUR-NUM       PIC 999.\n           02 ZERO-SKIP     PIC 9.\n           02 LINE-PTR      PIC 99.\n           02 MAX-NUM       PIC 999.\n        \n        01 OUTPUT-FORMAT.\n           02 OUT-LINE      PIC X(72).\n           02 ONE-DIGIT     PIC B9.\n           02 TWO-DIGITS    PIC BZ9.\n           02 THREE-DIGITS  PIC BZZ9.\n           02 MAX-COL-NUM   PIC 999.\n        \n        PROCEDURE DIVISION.\n        BEGIN.\n            MOVE 5 TO NUM-LINES. PERFORM FLOYD.\n            DISPLAY ' '.\n            MOVE 14 TO NUM-LINES. PERFORM FLOYD.\n            STOP RUN.\n            \n        FLOYD.\n            MOVE 1 TO CUR-NUM.\n            COMPUTE MAX-NUM = NUM-LINES * (NUM-LINES + 1) / 2.\n            PERFORM FLOYD-LINE \n                VARYING CUR-LINE FROM 1 BY 1\n                UNTIL CUR-LINE IS GREATER THAN NUM-LINES.\n            \n        FLOYD-LINE.\n            MOVE ' ' TO OUT-LINE.\n            MOVE 1 TO LINE-PTR.\n            PERFORM FLOYD-NUM\n                VARYING CUR-COL FROM 1 BY 1\n                UNTIL CUR-COL IS GREATER THAN CUR-LINE.\n            DISPLAY OUT-LINE.\n\n        FLOYD-NUM.\n            COMPUTE MAX-COL-NUM = MAX-NUM - NUM-LINES + CUR-COL.\n            MOVE 0 TO ZERO-SKIP.\n            INSPECT MAX-COL-NUM TALLYING ZERO-SKIP FOR LEADING '0'.\n            IF ZERO-SKIP IS EQUAL TO ZERO\n                PERFORM FLOYD-THREE-DIGITS\n            ELSE IF ZERO-SKIP IS EQUAL TO 1\n                PERFORM FLOYD-TWO-DIGITS\n            ELSE IF ZERO-SKIP IS EQUAL TO 2\n                PERFORM FLOYD-ONE-DIGIT.\n            ADD 1 TO CUR-NUM.\n                \n        FLOYD-ONE-DIGIT.\n            MOVE CUR-NUM TO ONE-DIGIT.\n            STRING ONE-DIGIT DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n        \n        FLOYD-TWO-DIGITS.\n            MOVE CUR-NUM TO TWO-DIGITS.\n            STRING TWO-DIGITS DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n        \n        FLOYD-THREE-DIGITS.\n            MOVE CUR-NUM TO THREE-DIGITS.\n            STRING THREE-DIGITS DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n", "target": "public class Floyd {\n\tpublic static void main(String[] args){\n\t\tprintTriangle(5);\n\t\tprintTriangle(14);\n\t}\n\t\n\tprivate static void printTriangle(int n){\n\t\tSystem.out.println(n + \" rows:\");\n\t\tfor(int rowNum = 1, printMe = 1, numsPrinted = 0;\n\t\t\t\trowNum <= n; printMe++){\n\t\t\tint cols = (int)Math.ceil(Math.log10(n*(n-1)/2 + numsPrinted + 2));\n\t\t\tSystem.out.printf(\"%\"+cols+\"d \", printMe);\n\t\t\tif(++numsPrinted == rowNum){\n\t\t\t\tSystem.out.println();\n\t\t\t\trowNum++;\n\t\t\t\tnumsPrinted = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 120392, "name": "Floyd's triangle", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. FLOYD-TRIANGLE.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 VARIABLES        COMP.\n           02 NUM-LINES     PIC 99.\n           02 CUR-LINE      PIC 99.\n           02 CUR-COL       PIC 99.\n           02 CUR-NUM       PIC 999.\n           02 ZERO-SKIP     PIC 9.\n           02 LINE-PTR      PIC 99.\n           02 MAX-NUM       PIC 999.\n        \n        01 OUTPUT-FORMAT.\n           02 OUT-LINE      PIC X(72).\n           02 ONE-DIGIT     PIC B9.\n           02 TWO-DIGITS    PIC BZ9.\n           02 THREE-DIGITS  PIC BZZ9.\n           02 MAX-COL-NUM   PIC 999.\n        \n        PROCEDURE DIVISION.\n        BEGIN.\n            MOVE 5 TO NUM-LINES. PERFORM FLOYD.\n            DISPLAY ' '.\n            MOVE 14 TO NUM-LINES. PERFORM FLOYD.\n            STOP RUN.\n            \n        FLOYD.\n            MOVE 1 TO CUR-NUM.\n            COMPUTE MAX-NUM = NUM-LINES * (NUM-LINES + 1) / 2.\n            PERFORM FLOYD-LINE \n                VARYING CUR-LINE FROM 1 BY 1\n                UNTIL CUR-LINE IS GREATER THAN NUM-LINES.\n            \n        FLOYD-LINE.\n            MOVE ' ' TO OUT-LINE.\n            MOVE 1 TO LINE-PTR.\n            PERFORM FLOYD-NUM\n                VARYING CUR-COL FROM 1 BY 1\n                UNTIL CUR-COL IS GREATER THAN CUR-LINE.\n            DISPLAY OUT-LINE.\n\n        FLOYD-NUM.\n            COMPUTE MAX-COL-NUM = MAX-NUM - NUM-LINES + CUR-COL.\n            MOVE 0 TO ZERO-SKIP.\n            INSPECT MAX-COL-NUM TALLYING ZERO-SKIP FOR LEADING '0'.\n            IF ZERO-SKIP IS EQUAL TO ZERO\n                PERFORM FLOYD-THREE-DIGITS\n            ELSE IF ZERO-SKIP IS EQUAL TO 1\n                PERFORM FLOYD-TWO-DIGITS\n            ELSE IF ZERO-SKIP IS EQUAL TO 2\n                PERFORM FLOYD-ONE-DIGIT.\n            ADD 1 TO CUR-NUM.\n                \n        FLOYD-ONE-DIGIT.\n            MOVE CUR-NUM TO ONE-DIGIT.\n            STRING ONE-DIGIT DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n        \n        FLOYD-TWO-DIGITS.\n            MOVE CUR-NUM TO TWO-DIGITS.\n            STRING TWO-DIGITS DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n        \n        FLOYD-THREE-DIGITS.\n            MOVE CUR-NUM TO THREE-DIGITS.\n            STRING THREE-DIGITS DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n", "target": "public class Floyd {\n\tpublic static void main(String[] args){\n\t\tprintTriangle(5);\n\t\tprintTriangle(14);\n\t}\n\t\n\tprivate static void printTriangle(int n){\n\t\tSystem.out.println(n + \" rows:\");\n\t\tfor(int rowNum = 1, printMe = 1, numsPrinted = 0;\n\t\t\t\trowNum <= n; printMe++){\n\t\t\tint cols = (int)Math.ceil(Math.log10(n*(n-1)/2 + numsPrinted + 2));\n\t\t\tSystem.out.printf(\"%\"+cols+\"d \", printMe);\n\t\t\tif(++numsPrinted == rowNum){\n\t\t\t\tSystem.out.println();\n\t\t\t\trowNum++;\n\t\t\t\tnumsPrinted = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 120393, "name": "Floyd's triangle", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. FLOYD-TRIANGLE.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 VARIABLES        COMP.\n           02 NUM-LINES     PIC 99.\n           02 CUR-LINE      PIC 99.\n           02 CUR-COL       PIC 99.\n           02 CUR-NUM       PIC 999.\n           02 ZERO-SKIP     PIC 9.\n           02 LINE-PTR      PIC 99.\n           02 MAX-NUM       PIC 999.\n        \n        01 OUTPUT-FORMAT.\n           02 OUT-LINE      PIC X(72).\n           02 ONE-DIGIT     PIC B9.\n           02 TWO-DIGITS    PIC BZ9.\n           02 THREE-DIGITS  PIC BZZ9.\n           02 MAX-COL-NUM   PIC 999.\n        \n        PROCEDURE DIVISION.\n        BEGIN.\n            MOVE 5 TO NUM-LINES. PERFORM FLOYD.\n            DISPLAY ' '.\n            MOVE 14 TO NUM-LINES. PERFORM FLOYD.\n            STOP RUN.\n            \n        FLOYD.\n            MOVE 1 TO CUR-NUM.\n            COMPUTE MAX-NUM = NUM-LINES * (NUM-LINES + 1) / 2.\n            PERFORM FLOYD-LINE \n                VARYING CUR-LINE FROM 1 BY 1\n                UNTIL CUR-LINE IS GREATER THAN NUM-LINES.\n            \n        FLOYD-LINE.\n            MOVE ' ' TO OUT-LINE.\n            MOVE 1 TO LINE-PTR.\n            PERFORM FLOYD-NUM\n                VARYING CUR-COL FROM 1 BY 1\n                UNTIL CUR-COL IS GREATER THAN CUR-LINE.\n            DISPLAY OUT-LINE.\n\n        FLOYD-NUM.\n            COMPUTE MAX-COL-NUM = MAX-NUM - NUM-LINES + CUR-COL.\n            MOVE 0 TO ZERO-SKIP.\n            INSPECT MAX-COL-NUM TALLYING ZERO-SKIP FOR LEADING '0'.\n            IF ZERO-SKIP IS EQUAL TO ZERO\n                PERFORM FLOYD-THREE-DIGITS\n            ELSE IF ZERO-SKIP IS EQUAL TO 1\n                PERFORM FLOYD-TWO-DIGITS\n            ELSE IF ZERO-SKIP IS EQUAL TO 2\n                PERFORM FLOYD-ONE-DIGIT.\n            ADD 1 TO CUR-NUM.\n                \n        FLOYD-ONE-DIGIT.\n            MOVE CUR-NUM TO ONE-DIGIT.\n            STRING ONE-DIGIT DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n        \n        FLOYD-TWO-DIGITS.\n            MOVE CUR-NUM TO TWO-DIGITS.\n            STRING TWO-DIGITS DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n        \n        FLOYD-THREE-DIGITS.\n            MOVE CUR-NUM TO THREE-DIGITS.\n            STRING THREE-DIGITS DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n", "target": ">>> def floyd(rowcount=5):\n\trows = [[1]]\n\twhile len(rows) < rowcount:\n\t\tn = rows[-1][-1] + 1\n\t\trows.append(list(range(n, n + len(rows[-1]) + 1)))\n\treturn rows\n\n>>> floyd()\n[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]\n>>> def pfloyd(rows=[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]):\n\tcolspace = [len(str(n)) for n in rows[-1]]\n\tfor row in rows:\n\t\tprint( ' '.join('%*i' % space_n for space_n in zip(colspace, row)))\n\n\t\t\n>>> pfloyd()\n1\n2 3\n4 5 6\n7 8 9 10\n>>> pfloyd(floyd(5))\n 1\n 2  3\n 4  5  6\n 7  8  9 10\n11 12 13 14 15\n>>> pfloyd(floyd(14))\n 1\n 2  3\n 4  5  6\n 7  8  9 10\n11 12 13 14 15\n16 17 18 19 20 21\n22 23 24 25 26 27 28\n29 30 31 32 33 34 35 36\n37 38 39 40 41 42 43 44  45\n46 47 48 49 50 51 52 53  54  55\n56 57 58 59 60 61 62 63  64  65  66\n67 68 69 70 71 72 73 74  75  76  77  78\n79 80 81 82 83 84 85 86  87  88  89  90  91\n92 93 94 95 96 97 98 99 100 101 102 103 104 105\n>>>\n"}
{"id": 120394, "name": "Floyd's triangle", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. FLOYD-TRIANGLE.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 VARIABLES        COMP.\n           02 NUM-LINES     PIC 99.\n           02 CUR-LINE      PIC 99.\n           02 CUR-COL       PIC 99.\n           02 CUR-NUM       PIC 999.\n           02 ZERO-SKIP     PIC 9.\n           02 LINE-PTR      PIC 99.\n           02 MAX-NUM       PIC 999.\n        \n        01 OUTPUT-FORMAT.\n           02 OUT-LINE      PIC X(72).\n           02 ONE-DIGIT     PIC B9.\n           02 TWO-DIGITS    PIC BZ9.\n           02 THREE-DIGITS  PIC BZZ9.\n           02 MAX-COL-NUM   PIC 999.\n        \n        PROCEDURE DIVISION.\n        BEGIN.\n            MOVE 5 TO NUM-LINES. PERFORM FLOYD.\n            DISPLAY ' '.\n            MOVE 14 TO NUM-LINES. PERFORM FLOYD.\n            STOP RUN.\n            \n        FLOYD.\n            MOVE 1 TO CUR-NUM.\n            COMPUTE MAX-NUM = NUM-LINES * (NUM-LINES + 1) / 2.\n            PERFORM FLOYD-LINE \n                VARYING CUR-LINE FROM 1 BY 1\n                UNTIL CUR-LINE IS GREATER THAN NUM-LINES.\n            \n        FLOYD-LINE.\n            MOVE ' ' TO OUT-LINE.\n            MOVE 1 TO LINE-PTR.\n            PERFORM FLOYD-NUM\n                VARYING CUR-COL FROM 1 BY 1\n                UNTIL CUR-COL IS GREATER THAN CUR-LINE.\n            DISPLAY OUT-LINE.\n\n        FLOYD-NUM.\n            COMPUTE MAX-COL-NUM = MAX-NUM - NUM-LINES + CUR-COL.\n            MOVE 0 TO ZERO-SKIP.\n            INSPECT MAX-COL-NUM TALLYING ZERO-SKIP FOR LEADING '0'.\n            IF ZERO-SKIP IS EQUAL TO ZERO\n                PERFORM FLOYD-THREE-DIGITS\n            ELSE IF ZERO-SKIP IS EQUAL TO 1\n                PERFORM FLOYD-TWO-DIGITS\n            ELSE IF ZERO-SKIP IS EQUAL TO 2\n                PERFORM FLOYD-ONE-DIGIT.\n            ADD 1 TO CUR-NUM.\n                \n        FLOYD-ONE-DIGIT.\n            MOVE CUR-NUM TO ONE-DIGIT.\n            STRING ONE-DIGIT DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n        \n        FLOYD-TWO-DIGITS.\n            MOVE CUR-NUM TO TWO-DIGITS.\n            STRING TWO-DIGITS DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n        \n        FLOYD-THREE-DIGITS.\n            MOVE CUR-NUM TO THREE-DIGITS.\n            STRING THREE-DIGITS DELIMITED BY SIZE INTO OUT-LINE\n                WITH POINTER LINE-PTR.\n", "target": ">>> def floyd(rowcount=5):\n\trows = [[1]]\n\twhile len(rows) < rowcount:\n\t\tn = rows[-1][-1] + 1\n\t\trows.append(list(range(n, n + len(rows[-1]) + 1)))\n\treturn rows\n\n>>> floyd()\n[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]\n>>> def pfloyd(rows=[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]):\n\tcolspace = [len(str(n)) for n in rows[-1]]\n\tfor row in rows:\n\t\tprint( ' '.join('%*i' % space_n for space_n in zip(colspace, row)))\n\n\t\t\n>>> pfloyd()\n1\n2 3\n4 5 6\n7 8 9 10\n>>> pfloyd(floyd(5))\n 1\n 2  3\n 4  5  6\n 7  8  9 10\n11 12 13 14 15\n>>> pfloyd(floyd(14))\n 1\n 2  3\n 4  5  6\n 7  8  9 10\n11 12 13 14 15\n16 17 18 19 20 21\n22 23 24 25 26 27 28\n29 30 31 32 33 34 35 36\n37 38 39 40 41 42 43 44  45\n46 47 48 49 50 51 52 53  54  55\n56 57 58 59 60 61 62 63  64  65  66\n67 68 69 70 71 72 73 74  75  76  77  78\n79 80 81 82 83 84 85 86  87  88  89  90  91\n92 93 94 95 96 97 98 99 100 101 102 103 104 105\n>>>\n"}
{"id": 121778, "name": "Harshad or Niven series", "source": "Translate COBOL to C#: identification division.\nprogram-id. harshad.\nenvironment division.\ndata division.\nworking-storage section.\n\n01  harshads.\n    03  harshad pic 9(5)    occurs 20 times indexed by niven.\n\n\n01  first-num   pic 9(5).\n01  second-num  pic 9(5).\n\n\n01  i   pic 9(5).\n\n\n01  div pic 9(5).\n01  mod pic 9(5).\n01  tot pic 9(5).\n\n\n01  harshad-div pic 9(5).\n01  harshad-mod pic 9(5).\n    88  evenly-divisible    value 0.\n01  harshad-disp    pic zzzz9.\n01  harshad-result  pic 9(5).\n\n\n01  pass        pic 9.\n    88  first-pass  value 1.\n    88  second-pass value 2.\n    \nprocedure division.\n10-main section.\n    move 1 to pass.\n    set niven to 1.\n    perform 20-calculate-harshad with test before varying first-num from 1 by 1 until niven = 21.\n    \n    move 2 to pass.\n    move first-num to second-num.\n    perform 20-calculate-harshad with test after varying first-num from second-num by 1 until harshad-result > 1000.\n    \n    perform with test after varying i from 1 by 1 until i = 20\n        move harshad(i) to harshad-disp\n        display function trim(harshad-disp) space with no advancing\n    end-perform.\n    \n    move harshad-result to harshad-disp.\n    display \"... \" function trim(harshad-disp).\n    stop run.\n    \n20-calculate-harshad.\n    move first-num to div.\n    move zero to harshad-result.\n    perform 100-calculate-sum-of-digits.\n    divide first-num by tot giving harshad-div remainder harshad-mod.\n    if evenly-divisible\n        if first-pass\n            move first-num to harshad(niven)\n            set niven up by 1\n        else\n            move first-num to harshad-result\n        end-if\n    end-if.\n    exit paragraph.\n        \n100-calculate-sum-of-digits.\n    move zero to tot.\n    perform with test after until div = 0\n        divide div by 10 giving div remainder mod\n        add mod to tot\n    end-perform.\n    \n    \n    \n    \n    exit paragraph.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Harshad\n{\n    class Program\n    {\n        public static bool IsHarshad(int n)\n        {\n            char[] inputChars = n.ToString().ToCharArray();\n            IList<byte> digits = new List<byte>();\n\n            foreach (char digit in inputChars)\n            {\n                digits.Add((byte)Char.GetNumericValue(digit));\n            }\n\n            if (n < 1)\n            {\n                return false;\n            }\n\n            int sum = 0;\n\n            foreach (byte digit in digits)\n            {\n                sum += digit;\n            }\n\n            return n % sum == 0;\n        }\n\n        static void Main(string[] args)\n        {\n            int i = 1;\n            int count = 0;\n\n            while (true)\n            {\n                if (IsHarshad(i))\n                {\n                    count++;\n\n                    if (count <= 20)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                    }\n                    else if (i > 1000)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                        break;\n                    }\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 121779, "name": "Harshad or Niven series", "source": "Translate COBOL to C#: identification division.\nprogram-id. harshad.\nenvironment division.\ndata division.\nworking-storage section.\n\n01  harshads.\n    03  harshad pic 9(5)    occurs 20 times indexed by niven.\n\n\n01  first-num   pic 9(5).\n01  second-num  pic 9(5).\n\n\n01  i   pic 9(5).\n\n\n01  div pic 9(5).\n01  mod pic 9(5).\n01  tot pic 9(5).\n\n\n01  harshad-div pic 9(5).\n01  harshad-mod pic 9(5).\n    88  evenly-divisible    value 0.\n01  harshad-disp    pic zzzz9.\n01  harshad-result  pic 9(5).\n\n\n01  pass        pic 9.\n    88  first-pass  value 1.\n    88  second-pass value 2.\n    \nprocedure division.\n10-main section.\n    move 1 to pass.\n    set niven to 1.\n    perform 20-calculate-harshad with test before varying first-num from 1 by 1 until niven = 21.\n    \n    move 2 to pass.\n    move first-num to second-num.\n    perform 20-calculate-harshad with test after varying first-num from second-num by 1 until harshad-result > 1000.\n    \n    perform with test after varying i from 1 by 1 until i = 20\n        move harshad(i) to harshad-disp\n        display function trim(harshad-disp) space with no advancing\n    end-perform.\n    \n    move harshad-result to harshad-disp.\n    display \"... \" function trim(harshad-disp).\n    stop run.\n    \n20-calculate-harshad.\n    move first-num to div.\n    move zero to harshad-result.\n    perform 100-calculate-sum-of-digits.\n    divide first-num by tot giving harshad-div remainder harshad-mod.\n    if evenly-divisible\n        if first-pass\n            move first-num to harshad(niven)\n            set niven up by 1\n        else\n            move first-num to harshad-result\n        end-if\n    end-if.\n    exit paragraph.\n        \n100-calculate-sum-of-digits.\n    move zero to tot.\n    perform with test after until div = 0\n        divide div by 10 giving div remainder mod\n        add mod to tot\n    end-perform.\n    \n    \n    \n    \n    exit paragraph.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Harshad\n{\n    class Program\n    {\n        public static bool IsHarshad(int n)\n        {\n            char[] inputChars = n.ToString().ToCharArray();\n            IList<byte> digits = new List<byte>();\n\n            foreach (char digit in inputChars)\n            {\n                digits.Add((byte)Char.GetNumericValue(digit));\n            }\n\n            if (n < 1)\n            {\n                return false;\n            }\n\n            int sum = 0;\n\n            foreach (byte digit in digits)\n            {\n                sum += digit;\n            }\n\n            return n % sum == 0;\n        }\n\n        static void Main(string[] args)\n        {\n            int i = 1;\n            int count = 0;\n\n            while (true)\n            {\n                if (IsHarshad(i))\n                {\n                    count++;\n\n                    if (count <= 20)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                    }\n                    else if (i > 1000)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                        break;\n                    }\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 121782, "name": "Harshad or Niven series", "source": "Translate COBOL to Java: identification division.\nprogram-id. harshad.\nenvironment division.\ndata division.\nworking-storage section.\n\n01  harshads.\n    03  harshad pic 9(5)    occurs 20 times indexed by niven.\n\n\n01  first-num   pic 9(5).\n01  second-num  pic 9(5).\n\n\n01  i   pic 9(5).\n\n\n01  div pic 9(5).\n01  mod pic 9(5).\n01  tot pic 9(5).\n\n\n01  harshad-div pic 9(5).\n01  harshad-mod pic 9(5).\n    88  evenly-divisible    value 0.\n01  harshad-disp    pic zzzz9.\n01  harshad-result  pic 9(5).\n\n\n01  pass        pic 9.\n    88  first-pass  value 1.\n    88  second-pass value 2.\n    \nprocedure division.\n10-main section.\n    move 1 to pass.\n    set niven to 1.\n    perform 20-calculate-harshad with test before varying first-num from 1 by 1 until niven = 21.\n    \n    move 2 to pass.\n    move first-num to second-num.\n    perform 20-calculate-harshad with test after varying first-num from second-num by 1 until harshad-result > 1000.\n    \n    perform with test after varying i from 1 by 1 until i = 20\n        move harshad(i) to harshad-disp\n        display function trim(harshad-disp) space with no advancing\n    end-perform.\n    \n    move harshad-result to harshad-disp.\n    display \"... \" function trim(harshad-disp).\n    stop run.\n    \n20-calculate-harshad.\n    move first-num to div.\n    move zero to harshad-result.\n    perform 100-calculate-sum-of-digits.\n    divide first-num by tot giving harshad-div remainder harshad-mod.\n    if evenly-divisible\n        if first-pass\n            move first-num to harshad(niven)\n            set niven up by 1\n        else\n            move first-num to harshad-result\n        end-if\n    end-if.\n    exit paragraph.\n        \n100-calculate-sum-of-digits.\n    move zero to tot.\n    perform with test after until div = 0\n        divide div by 10 giving div remainder mod\n        add mod to tot\n    end-perform.\n    \n    \n    \n    \n    exit paragraph.\n", "target": "public class Harshad{\n    private static long sumDigits(long n){\n        long sum = 0;\n        for(char digit:Long.toString(n).toCharArray()){\n            sum += Character.digit(digit, 10);\n        }\n        return sum;\n    }\n    public static void main(String[] args){\n        for(int count = 0, i = 1; count < 20;i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                count++;\n            }\n        }\n        System.out.println();\n        for(int i = 1001; ; i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                break;\n            }\n        }\n    }\n}\n"}
{"id": 121783, "name": "Harshad or Niven series", "source": "Translate COBOL to Java: identification division.\nprogram-id. harshad.\nenvironment division.\ndata division.\nworking-storage section.\n\n01  harshads.\n    03  harshad pic 9(5)    occurs 20 times indexed by niven.\n\n\n01  first-num   pic 9(5).\n01  second-num  pic 9(5).\n\n\n01  i   pic 9(5).\n\n\n01  div pic 9(5).\n01  mod pic 9(5).\n01  tot pic 9(5).\n\n\n01  harshad-div pic 9(5).\n01  harshad-mod pic 9(5).\n    88  evenly-divisible    value 0.\n01  harshad-disp    pic zzzz9.\n01  harshad-result  pic 9(5).\n\n\n01  pass        pic 9.\n    88  first-pass  value 1.\n    88  second-pass value 2.\n    \nprocedure division.\n10-main section.\n    move 1 to pass.\n    set niven to 1.\n    perform 20-calculate-harshad with test before varying first-num from 1 by 1 until niven = 21.\n    \n    move 2 to pass.\n    move first-num to second-num.\n    perform 20-calculate-harshad with test after varying first-num from second-num by 1 until harshad-result > 1000.\n    \n    perform with test after varying i from 1 by 1 until i = 20\n        move harshad(i) to harshad-disp\n        display function trim(harshad-disp) space with no advancing\n    end-perform.\n    \n    move harshad-result to harshad-disp.\n    display \"... \" function trim(harshad-disp).\n    stop run.\n    \n20-calculate-harshad.\n    move first-num to div.\n    move zero to harshad-result.\n    perform 100-calculate-sum-of-digits.\n    divide first-num by tot giving harshad-div remainder harshad-mod.\n    if evenly-divisible\n        if first-pass\n            move first-num to harshad(niven)\n            set niven up by 1\n        else\n            move first-num to harshad-result\n        end-if\n    end-if.\n    exit paragraph.\n        \n100-calculate-sum-of-digits.\n    move zero to tot.\n    perform with test after until div = 0\n        divide div by 10 giving div remainder mod\n        add mod to tot\n    end-perform.\n    \n    \n    \n    \n    exit paragraph.\n", "target": "public class Harshad{\n    private static long sumDigits(long n){\n        long sum = 0;\n        for(char digit:Long.toString(n).toCharArray()){\n            sum += Character.digit(digit, 10);\n        }\n        return sum;\n    }\n    public static void main(String[] args){\n        for(int count = 0, i = 1; count < 20;i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                count++;\n            }\n        }\n        System.out.println();\n        for(int i = 1001; ; i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                break;\n            }\n        }\n    }\n}\n"}
{"id": 121784, "name": "Harshad or Niven series", "source": "Translate COBOL to Python: identification division.\nprogram-id. harshad.\nenvironment division.\ndata division.\nworking-storage section.\n\n01  harshads.\n    03  harshad pic 9(5)    occurs 20 times indexed by niven.\n\n\n01  first-num   pic 9(5).\n01  second-num  pic 9(5).\n\n\n01  i   pic 9(5).\n\n\n01  div pic 9(5).\n01  mod pic 9(5).\n01  tot pic 9(5).\n\n\n01  harshad-div pic 9(5).\n01  harshad-mod pic 9(5).\n    88  evenly-divisible    value 0.\n01  harshad-disp    pic zzzz9.\n01  harshad-result  pic 9(5).\n\n\n01  pass        pic 9.\n    88  first-pass  value 1.\n    88  second-pass value 2.\n    \nprocedure division.\n10-main section.\n    move 1 to pass.\n    set niven to 1.\n    perform 20-calculate-harshad with test before varying first-num from 1 by 1 until niven = 21.\n    \n    move 2 to pass.\n    move first-num to second-num.\n    perform 20-calculate-harshad with test after varying first-num from second-num by 1 until harshad-result > 1000.\n    \n    perform with test after varying i from 1 by 1 until i = 20\n        move harshad(i) to harshad-disp\n        display function trim(harshad-disp) space with no advancing\n    end-perform.\n    \n    move harshad-result to harshad-disp.\n    display \"... \" function trim(harshad-disp).\n    stop run.\n    \n20-calculate-harshad.\n    move first-num to div.\n    move zero to harshad-result.\n    perform 100-calculate-sum-of-digits.\n    divide first-num by tot giving harshad-div remainder harshad-mod.\n    if evenly-divisible\n        if first-pass\n            move first-num to harshad(niven)\n            set niven up by 1\n        else\n            move first-num to harshad-result\n        end-if\n    end-if.\n    exit paragraph.\n        \n100-calculate-sum-of-digits.\n    move zero to tot.\n    perform with test after until div = 0\n        divide div by 10 giving div remainder mod\n        add mod to tot\n    end-perform.\n    \n    \n    \n    \n    exit paragraph.\n", "target": ">>> import itertools\n>>> def harshad():\n\tfor n in itertools.count(1):\n\t\tif n % sum(int(ch) for ch in str(n)) == 0:\n\t\t\tyield n\n\n\t\t\n>>> list(itertools.islice(harshad(), 0, 20))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42]\n>>> for n in harshad():\n\tif n > 1000:\n\t\tprint(n)\n\t\tbreak\n\n\t\n1002\n>>>\n"}
{"id": 121785, "name": "Harshad or Niven series", "source": "Translate COBOL to Python: identification division.\nprogram-id. harshad.\nenvironment division.\ndata division.\nworking-storage section.\n\n01  harshads.\n    03  harshad pic 9(5)    occurs 20 times indexed by niven.\n\n\n01  first-num   pic 9(5).\n01  second-num  pic 9(5).\n\n\n01  i   pic 9(5).\n\n\n01  div pic 9(5).\n01  mod pic 9(5).\n01  tot pic 9(5).\n\n\n01  harshad-div pic 9(5).\n01  harshad-mod pic 9(5).\n    88  evenly-divisible    value 0.\n01  harshad-disp    pic zzzz9.\n01  harshad-result  pic 9(5).\n\n\n01  pass        pic 9.\n    88  first-pass  value 1.\n    88  second-pass value 2.\n    \nprocedure division.\n10-main section.\n    move 1 to pass.\n    set niven to 1.\n    perform 20-calculate-harshad with test before varying first-num from 1 by 1 until niven = 21.\n    \n    move 2 to pass.\n    move first-num to second-num.\n    perform 20-calculate-harshad with test after varying first-num from second-num by 1 until harshad-result > 1000.\n    \n    perform with test after varying i from 1 by 1 until i = 20\n        move harshad(i) to harshad-disp\n        display function trim(harshad-disp) space with no advancing\n    end-perform.\n    \n    move harshad-result to harshad-disp.\n    display \"... \" function trim(harshad-disp).\n    stop run.\n    \n20-calculate-harshad.\n    move first-num to div.\n    move zero to harshad-result.\n    perform 100-calculate-sum-of-digits.\n    divide first-num by tot giving harshad-div remainder harshad-mod.\n    if evenly-divisible\n        if first-pass\n            move first-num to harshad(niven)\n            set niven up by 1\n        else\n            move first-num to harshad-result\n        end-if\n    end-if.\n    exit paragraph.\n        \n100-calculate-sum-of-digits.\n    move zero to tot.\n    perform with test after until div = 0\n        divide div by 10 giving div remainder mod\n        add mod to tot\n    end-perform.\n    \n    \n    \n    \n    exit paragraph.\n", "target": ">>> import itertools\n>>> def harshad():\n\tfor n in itertools.count(1):\n\t\tif n % sum(int(ch) for ch in str(n)) == 0:\n\t\t\tyield n\n\n\t\t\n>>> list(itertools.islice(harshad(), 0, 20))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42]\n>>> for n in harshad():\n\tif n > 1000:\n\t\tprint(n)\n\t\tbreak\n\n\t\n1002\n>>>\n"}
{"id": 122403, "name": "Even or odd", "source": "Translate COBOL to C#:        IF FUNCTION REM(Num, 2) = 0\n           DISPLAY Num \" is even.\"\n       ELSE\n           DISPLAY Num \" is odd.\"\n       END-IF\n", "target": "namespace RosettaCode\n{\n    using System;\n\n    public static class EvenOrOdd\n    {\n        public static bool IsEvenBitwise(this int number)\n        {\n            return (number & 1) == 0;\n        }\n\n        public static bool IsOddBitwise(this int number)\n        {\n            return (number & 1) != 0;\n        }\n\n        public static bool IsEvenRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder == 0;\n        }\n\n        public static bool IsOddRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder != 0;\n        }\n\n        public static bool IsEvenModulo(this int number)\n        {\n            return (number % 2) == 0;\n        }\n\n        public static bool IsOddModulo(this int number)\n        {\n            return (number % 2) != 0;\n        }\n    }\n    public class Program\n    {\n        public static void Main()\n        {\n            int num = 26;               \n            if (num.IsEvenBitwise())    \n            {\n                Console.Write(\"Even\");\n            }\n            else\n            {\n                Console.Write(\"Odd\");\n            }\n            \n            if (num.IsOddBitwise())    \n            {\n                Console.Write(\"Odd\");\n            }\n            else\n            {\n                Console.Write(\"Even\");\n            }\n            \n        }\n    }\n}\n"}
{"id": 122404, "name": "Even or odd", "source": "Translate COBOL to C#:        IF FUNCTION REM(Num, 2) = 0\n           DISPLAY Num \" is even.\"\n       ELSE\n           DISPLAY Num \" is odd.\"\n       END-IF\n", "target": "namespace RosettaCode\n{\n    using System;\n\n    public static class EvenOrOdd\n    {\n        public static bool IsEvenBitwise(this int number)\n        {\n            return (number & 1) == 0;\n        }\n\n        public static bool IsOddBitwise(this int number)\n        {\n            return (number & 1) != 0;\n        }\n\n        public static bool IsEvenRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder == 0;\n        }\n\n        public static bool IsOddRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder != 0;\n        }\n\n        public static bool IsEvenModulo(this int number)\n        {\n            return (number % 2) == 0;\n        }\n\n        public static bool IsOddModulo(this int number)\n        {\n            return (number % 2) != 0;\n        }\n    }\n    public class Program\n    {\n        public static void Main()\n        {\n            int num = 26;               \n            if (num.IsEvenBitwise())    \n            {\n                Console.Write(\"Even\");\n            }\n            else\n            {\n                Console.Write(\"Odd\");\n            }\n            \n            if (num.IsOddBitwise())    \n            {\n                Console.Write(\"Odd\");\n            }\n            else\n            {\n                Console.Write(\"Even\");\n            }\n            \n        }\n    }\n}\n"}
{"id": 122407, "name": "Even or odd", "source": "Translate COBOL to Java:        IF FUNCTION REM(Num, 2) = 0\n           DISPLAY Num \" is even.\"\n       ELSE\n           DISPLAY Num \" is odd.\"\n       END-IF\n", "target": "public static boolean isEven(int i){\n    return (i & 1) == 0;\n}\n"}
{"id": 122408, "name": "Even or odd", "source": "Translate COBOL to Java:        IF FUNCTION REM(Num, 2) = 0\n           DISPLAY Num \" is even.\"\n       ELSE\n           DISPLAY Num \" is odd.\"\n       END-IF\n", "target": "public static boolean isEven(int i){\n    return (i & 1) == 0;\n}\n"}
{"id": 122409, "name": "Even or odd", "source": "Translate COBOL to Python:        IF FUNCTION REM(Num, 2) = 0\n           DISPLAY Num \" is even.\"\n       ELSE\n           DISPLAY Num \" is odd.\"\n       END-IF\n", "target": ">>> def is_odd(i): return bool(i & 1)\n\n>>> def is_even(i): return not is_odd(i)\n\n>>> [(j, is_odd(j)) for j in range(10)]\n[(0, False), (1, True), (2, False), (3, True), (4, False), (5, True), (6, False), (7, True), (8, False), (9, True)]\n>>> [(j, is_even(j)) for j in range(10)]\n[(0, True), (1, False), (2, True), (3, False), (4, True), (5, False), (6, True), (7, False), (8, True), (9, False)]\n>>>\n"}
{"id": 122410, "name": "Even or odd", "source": "Translate COBOL to Python:        IF FUNCTION REM(Num, 2) = 0\n           DISPLAY Num \" is even.\"\n       ELSE\n           DISPLAY Num \" is odd.\"\n       END-IF\n", "target": ">>> def is_odd(i): return bool(i & 1)\n\n>>> def is_even(i): return not is_odd(i)\n\n>>> [(j, is_odd(j)) for j in range(10)]\n[(0, False), (1, True), (2, False), (3, True), (4, False), (5, True), (6, False), (7, True), (8, False), (9, True)]\n>>> [(j, is_even(j)) for j in range(10)]\n[(0, True), (1, False), (2, True), (3, False), (4, True), (5, False), (6, True), (7, False), (8, True), (9, False)]\n>>>\n"}
{"id": 122714, "name": "Quickselect algorithm", "source": "Translate COBOL to C#:        CLASS-ID MainProgram.\n       \n       METHOD-ID Partition STATIC USING T.\n       CONSTRAINTS.\n           CONSTRAIN T IMPLEMENTS type IComparable.\n           \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  pivot-val              T.\n       \n       PROCEDURE DIVISION USING VALUE arr AS T OCCURS ANY,\n               left-idx AS BINARY-LONG, right-idx AS BINARY-LONG,\n               pivot-idx AS BINARY-LONG\n               RETURNING ret AS BINARY-LONG.\n           MOVE arr (pivot-idx) TO pivot-val\n           INVOKE self::Swap(arr, pivot-idx, right-idx)\n           DECLARE store-idx AS BINARY-LONG = left-idx\n           PERFORM VARYING i AS BINARY-LONG FROM left-idx BY 1\n                   UNTIL i > right-idx\n               IF arr (i) < pivot-val\n                   INVOKE self::Swap(arr, i, store-idx)\n                   ADD 1 TO store-idx\n               END-IF\n           END-PERFORM\n           INVOKE self::Swap(arr, right-idx, store-idx)\n           \n           MOVE store-idx TO ret\n       END METHOD.\n       \n       METHOD-ID Quickselect STATIC USING T.\n       CONSTRAINTS.\n           CONSTRAIN T IMPLEMENTS type IComparable.\n           \n       PROCEDURE DIVISION USING VALUE arr AS T OCCURS ANY,\n               left-idx AS BINARY-LONG, right-idx AS BINARY-LONG,\n               n AS BINARY-LONG\n               RETURNING ret AS T.\n           IF left-idx = right-idx\n               MOVE arr (left-idx) TO ret\n               GOBACK\n           END-IF\n       \n           DECLARE rand AS TYPE Random = NEW Random()\n           DECLARE pivot-idx AS BINARY-LONG = rand::Next(left-idx, right-idx)\n           DECLARE pivot-new-idx AS BINARY-LONG\n               = self::Partition(arr, left-idx, right-idx, pivot-idx)\n           DECLARE pivot-dist AS BINARY-LONG = pivot-new-idx - left-idx + 1\n           \n           EVALUATE TRUE\n               WHEN pivot-dist = n\n                   MOVE arr (pivot-new-idx) TO ret                   \n                      \n               WHEN n < pivot-dist\n                   INVOKE self::Quickselect(arr, left-idx, pivot-new-idx - 1, n)\n                       RETURNING ret\n                     \n               WHEN OTHER\n                   INVOKE self::Quickselect(arr, pivot-new-idx + 1, right-idx,\n                       n - pivot-dist) RETURNING ret\n           END-EVALUATE\n       END METHOD.\n       \n       METHOD-ID Swap STATIC USING T.\n       CONSTRAINTS.\n           CONSTRAIN T IMPLEMENTS type IComparable.\n           \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                   T.\n           \n       PROCEDURE DIVISION USING arr AS T OCCURS ANY,\n               VALUE idx-1 AS BINARY-LONG, idx-2 AS BINARY-LONG.\n           IF idx-1 <> idx-2\n               MOVE arr (idx-1) TO temp\n               MOVE arr (idx-2) TO arr (idx-1)\n               MOVE temp TO arr (idx-2)\n           END-IF\n       END METHOD.\n       \n       METHOD-ID Main STATIC.\n       PROCEDURE DIVISION.\n           DECLARE input-array AS BINARY-LONG OCCURS ANY\n               = TABLE OF BINARY-LONG(9, 8, 7, 6, 5, 0, 1, 2, 3, 4)\n           DISPLAY \"Loop quick select 10 times.\"\n           PERFORM VARYING i AS BINARY-LONG FROM 1 BY 1 UNTIL i > 10\n               DISPLAY self::Quickselect(input-array, 1, input-array::Length, i)\n                   NO ADVANCING\n               \n               IF i < 10\n                   DISPLAY \", \" NO ADVANCING\n               END-IF\n           END-PERFORM\n           DISPLAY SPACE\n       END METHOD.\n       END CLASS.\n", "target": "\n\n\n\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace QuickSelect\n{\n    internal static class Program\n    {\n        #region Static Members\n\n        private static void Main()\n        {\n            var inputArray = new[] {9, 8, 7, 6, 5, 0, 1, 2, 3, 4};\n            \n            Console.WriteLine( \"Loop quick select 10 times.\" );\n            for( var i = 0 ; i < 10 ; i++ )\n            {\n                Console.Write( inputArray.NthSmallestElement( i ) );\n                if( i < 9 )\n                    Console.Write( \", \" );\n            }\n            Console.WriteLine();\n\n            \n            \n            Console.WriteLine( \"Just sort 10 elements.\" );\n            Console.WriteLine( string.Join( \", \", inputArray.TakeSmallest( 10 ).OrderBy( v => v ).Select( v => v.ToString() ).ToArray() ) );\n            \n            Console.WriteLine( \"Get 4 smallest and sort them.\" );\n            Console.WriteLine( string.Join( \", \", inputArray.TakeSmallest( 4 ).OrderBy( v => v ).Select( v => v.ToString() ).ToArray() ) );\n            Console.WriteLine( \"< Press any key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n\n    internal static class ArrayExtension\n    {\n        #region Static Members\n\n        \n        \n        \n        \n        \n        \n        \n        public static IEnumerable<T> TakeSmallest<T>( this T[] array, int count ) where T : IComparable<T>\n        {\n            if( count < 0 )\n                throw new ArgumentOutOfRangeException( \"count\", \"Count is smaller than 0.\" );\n            if( count == 0 )\n                return new T[0];\n            if( array.Length <= count )\n                return array;\n\n            return QuickSelectSmallest( array, count - 1 ).Take( count );\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        public static T NthSmallestElement<T>( this T[] array, int n ) where T : IComparable<T>\n        {\n            if( n < 0 || n > array.Length - 1 )\n                throw new ArgumentOutOfRangeException( \"n\", n, string.Format( \"n should be between 0 and {0} it was {1}.\", array.Length - 1, n ) );\n            if( array.Length == 0 )\n                throw new ArgumentException( \"Array is empty.\", \"array\" );\n            if( array.Length == 1 )\n                return array[ 0 ];\n\n            return QuickSelectSmallest( array, n )[ n ];\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        private static T[] QuickSelectSmallest<T>( T[] input, int n ) where T : IComparable<T>\n        {\n            \n            \n            var partiallySortedArray = (T[]) input.Clone();\n           \n            \n            var startIndex = 0;\n            var endIndex = input.Length - 1;\n            \n            \n            \n            var pivotIndex = n;\n\n            \n            var r = new Random();\n            while( endIndex > startIndex )\n            {\n                pivotIndex = QuickSelectPartition( partiallySortedArray, startIndex, endIndex, pivotIndex );\n                if( pivotIndex == n )\n                    \n                    break;\n                if( pivotIndex > n )\n                    \n                    endIndex = pivotIndex - 1;\n                else                    \n                    \n                    startIndex = pivotIndex + 1;\n\n                \n                \n                pivotIndex = r.Next( startIndex,  endIndex );\n            }\n            return partiallySortedArray;\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        private static int QuickSelectPartition<T>( this T[] array, int startIndex, int endIndex, int pivotIndex ) where T : IComparable<T>\n        {\n            var pivotValue = array[ pivotIndex ];\n            \n            array.Swap( pivotIndex, endIndex );\n            for( var i = startIndex ; i < endIndex ; i++ )\n            {\n                if( array[ i ].CompareTo( pivotValue ) > 0 )\n                    continue;\n\n                \n                array.Swap( i, startIndex );\n                \n                startIndex++;\n            }\n            \n            array.Swap( endIndex, startIndex );\n            return startIndex;\n        }\n\n        private static void Swap<T>( this T[] array, int index1, int index2 )\n        {\n            if( index1 == index2 )\n                return;\n\n            var temp = array[ index1 ];\n            array[ index1 ] = array[ index2 ];\n            array[ index2 ] = temp;\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 122716, "name": "Quickselect algorithm", "source": "Translate COBOL to Java:        CLASS-ID MainProgram.\n       \n       METHOD-ID Partition STATIC USING T.\n       CONSTRAINTS.\n           CONSTRAIN T IMPLEMENTS type IComparable.\n           \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  pivot-val              T.\n       \n       PROCEDURE DIVISION USING VALUE arr AS T OCCURS ANY,\n               left-idx AS BINARY-LONG, right-idx AS BINARY-LONG,\n               pivot-idx AS BINARY-LONG\n               RETURNING ret AS BINARY-LONG.\n           MOVE arr (pivot-idx) TO pivot-val\n           INVOKE self::Swap(arr, pivot-idx, right-idx)\n           DECLARE store-idx AS BINARY-LONG = left-idx\n           PERFORM VARYING i AS BINARY-LONG FROM left-idx BY 1\n                   UNTIL i > right-idx\n               IF arr (i) < pivot-val\n                   INVOKE self::Swap(arr, i, store-idx)\n                   ADD 1 TO store-idx\n               END-IF\n           END-PERFORM\n           INVOKE self::Swap(arr, right-idx, store-idx)\n           \n           MOVE store-idx TO ret\n       END METHOD.\n       \n       METHOD-ID Quickselect STATIC USING T.\n       CONSTRAINTS.\n           CONSTRAIN T IMPLEMENTS type IComparable.\n           \n       PROCEDURE DIVISION USING VALUE arr AS T OCCURS ANY,\n               left-idx AS BINARY-LONG, right-idx AS BINARY-LONG,\n               n AS BINARY-LONG\n               RETURNING ret AS T.\n           IF left-idx = right-idx\n               MOVE arr (left-idx) TO ret\n               GOBACK\n           END-IF\n       \n           DECLARE rand AS TYPE Random = NEW Random()\n           DECLARE pivot-idx AS BINARY-LONG = rand::Next(left-idx, right-idx)\n           DECLARE pivot-new-idx AS BINARY-LONG\n               = self::Partition(arr, left-idx, right-idx, pivot-idx)\n           DECLARE pivot-dist AS BINARY-LONG = pivot-new-idx - left-idx + 1\n           \n           EVALUATE TRUE\n               WHEN pivot-dist = n\n                   MOVE arr (pivot-new-idx) TO ret                   \n                      \n               WHEN n < pivot-dist\n                   INVOKE self::Quickselect(arr, left-idx, pivot-new-idx - 1, n)\n                       RETURNING ret\n                     \n               WHEN OTHER\n                   INVOKE self::Quickselect(arr, pivot-new-idx + 1, right-idx,\n                       n - pivot-dist) RETURNING ret\n           END-EVALUATE\n       END METHOD.\n       \n       METHOD-ID Swap STATIC USING T.\n       CONSTRAINTS.\n           CONSTRAIN T IMPLEMENTS type IComparable.\n           \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                   T.\n           \n       PROCEDURE DIVISION USING arr AS T OCCURS ANY,\n               VALUE idx-1 AS BINARY-LONG, idx-2 AS BINARY-LONG.\n           IF idx-1 <> idx-2\n               MOVE arr (idx-1) TO temp\n               MOVE arr (idx-2) TO arr (idx-1)\n               MOVE temp TO arr (idx-2)\n           END-IF\n       END METHOD.\n       \n       METHOD-ID Main STATIC.\n       PROCEDURE DIVISION.\n           DECLARE input-array AS BINARY-LONG OCCURS ANY\n               = TABLE OF BINARY-LONG(9, 8, 7, 6, 5, 0, 1, 2, 3, 4)\n           DISPLAY \"Loop quick select 10 times.\"\n           PERFORM VARYING i AS BINARY-LONG FROM 1 BY 1 UNTIL i > 10\n               DISPLAY self::Quickselect(input-array, 1, input-array::Length, i)\n                   NO ADVANCING\n               \n               IF i < 10\n                   DISPLAY \", \" NO ADVANCING\n               END-IF\n           END-PERFORM\n           DISPLAY SPACE\n       END METHOD.\n       END CLASS.\n", "target": "import java.util.Random;\n\npublic class QuickSelect {\n\n\tprivate static <E extends Comparable<? super E>> int partition(E[] arr, int left, int right, int pivot) {\n\t\tE pivotVal = arr[pivot];\n\t\tswap(arr, pivot, right);\n\t\tint storeIndex = left;\n\t\tfor (int i = left; i < right; i++) {\n\t\t\tif (arr[i].compareTo(pivotVal) < 0) {\n\t\t\t\tswap(arr, i, storeIndex);\n\t\t\t\tstoreIndex++;\n\t\t\t}\n\t\t}\n\t\tswap(arr, right, storeIndex);\n\t\treturn storeIndex;\n\t}\n\t\n\tprivate static <E extends Comparable<? super E>> E select(E[] arr, int n) {\n\t\tint left = 0;\n\t\tint right = arr.length - 1;\n\t\tRandom rand = new Random();\n\t\twhile (right >= left) {\n\t\t\tint pivotIndex = partition(arr, left, right, rand.nextInt(right - left + 1) + left);\n\t\t\tif (pivotIndex == n) {\n\t\t\t\treturn arr[pivotIndex];\n\t\t\t} else if (pivotIndex < n) {\n\t\t\t\tleft = pivotIndex + 1;\n\t\t\t} else {\n\t\t\t\tright = pivotIndex - 1;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tprivate static void swap(Object[] arr, int i1, int i2) {\n\t\tif (i1 != i2) {\n\t\t\tObject temp = arr[i1];\n\t\t\tarr[i1] = arr[i2];\n\t\t\tarr[i2] = temp;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tInteger[] input = {9, 8, 7, 6, 5, 0, 1, 2, 3, 4};\n\t\t\tSystem.out.print(select(input, i));\n\t\t\tif (i < 9) System.out.print(\", \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}\n"}
{"id": 122717, "name": "Quickselect algorithm", "source": "Translate COBOL to Python:        CLASS-ID MainProgram.\n       \n       METHOD-ID Partition STATIC USING T.\n       CONSTRAINTS.\n           CONSTRAIN T IMPLEMENTS type IComparable.\n           \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  pivot-val              T.\n       \n       PROCEDURE DIVISION USING VALUE arr AS T OCCURS ANY,\n               left-idx AS BINARY-LONG, right-idx AS BINARY-LONG,\n               pivot-idx AS BINARY-LONG\n               RETURNING ret AS BINARY-LONG.\n           MOVE arr (pivot-idx) TO pivot-val\n           INVOKE self::Swap(arr, pivot-idx, right-idx)\n           DECLARE store-idx AS BINARY-LONG = left-idx\n           PERFORM VARYING i AS BINARY-LONG FROM left-idx BY 1\n                   UNTIL i > right-idx\n               IF arr (i) < pivot-val\n                   INVOKE self::Swap(arr, i, store-idx)\n                   ADD 1 TO store-idx\n               END-IF\n           END-PERFORM\n           INVOKE self::Swap(arr, right-idx, store-idx)\n           \n           MOVE store-idx TO ret\n       END METHOD.\n       \n       METHOD-ID Quickselect STATIC USING T.\n       CONSTRAINTS.\n           CONSTRAIN T IMPLEMENTS type IComparable.\n           \n       PROCEDURE DIVISION USING VALUE arr AS T OCCURS ANY,\n               left-idx AS BINARY-LONG, right-idx AS BINARY-LONG,\n               n AS BINARY-LONG\n               RETURNING ret AS T.\n           IF left-idx = right-idx\n               MOVE arr (left-idx) TO ret\n               GOBACK\n           END-IF\n       \n           DECLARE rand AS TYPE Random = NEW Random()\n           DECLARE pivot-idx AS BINARY-LONG = rand::Next(left-idx, right-idx)\n           DECLARE pivot-new-idx AS BINARY-LONG\n               = self::Partition(arr, left-idx, right-idx, pivot-idx)\n           DECLARE pivot-dist AS BINARY-LONG = pivot-new-idx - left-idx + 1\n           \n           EVALUATE TRUE\n               WHEN pivot-dist = n\n                   MOVE arr (pivot-new-idx) TO ret                   \n                      \n               WHEN n < pivot-dist\n                   INVOKE self::Quickselect(arr, left-idx, pivot-new-idx - 1, n)\n                       RETURNING ret\n                     \n               WHEN OTHER\n                   INVOKE self::Quickselect(arr, pivot-new-idx + 1, right-idx,\n                       n - pivot-dist) RETURNING ret\n           END-EVALUATE\n       END METHOD.\n       \n       METHOD-ID Swap STATIC USING T.\n       CONSTRAINTS.\n           CONSTRAIN T IMPLEMENTS type IComparable.\n           \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                   T.\n           \n       PROCEDURE DIVISION USING arr AS T OCCURS ANY,\n               VALUE idx-1 AS BINARY-LONG, idx-2 AS BINARY-LONG.\n           IF idx-1 <> idx-2\n               MOVE arr (idx-1) TO temp\n               MOVE arr (idx-2) TO arr (idx-1)\n               MOVE temp TO arr (idx-2)\n           END-IF\n       END METHOD.\n       \n       METHOD-ID Main STATIC.\n       PROCEDURE DIVISION.\n           DECLARE input-array AS BINARY-LONG OCCURS ANY\n               = TABLE OF BINARY-LONG(9, 8, 7, 6, 5, 0, 1, 2, 3, 4)\n           DISPLAY \"Loop quick select 10 times.\"\n           PERFORM VARYING i AS BINARY-LONG FROM 1 BY 1 UNTIL i > 10\n               DISPLAY self::Quickselect(input-array, 1, input-array::Length, i)\n                   NO ADVANCING\n               \n               IF i < 10\n                   DISPLAY \", \" NO ADVANCING\n               END-IF\n           END-PERFORM\n           DISPLAY SPACE\n       END METHOD.\n       END CLASS.\n", "target": "import random\n\ndef partition(vector, left, right, pivotIndex):\n    pivotValue = vector[pivotIndex]\n    vector[pivotIndex], vector[right] = vector[right], vector[pivotIndex]  \n    storeIndex = left\n    for i in range(left, right):\n        if vector[i] < pivotValue:\n            vector[storeIndex], vector[i] = vector[i], vector[storeIndex]\n            storeIndex += 1\n    vector[right], vector[storeIndex] = vector[storeIndex], vector[right]  \n    return storeIndex\n\ndef _select(vector, left, right, k):\n    \"Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1] inclusive.\"\n    while True:\n        pivotIndex = random.randint(left, right)     \n        pivotNewIndex = partition(vector, left, right, pivotIndex)\n        pivotDist = pivotNewIndex - left\n        if pivotDist == k:\n            return vector[pivotNewIndex]\n        elif k < pivotDist:\n            right = pivotNewIndex - 1\n        else:\n            k -= pivotDist + 1\n            left = pivotNewIndex + 1\n\ndef select(vector, k, left=None, right=None):\n    \n    if left is None:\n        left = 0\n    lv1 = len(vector) - 1\n    if right is None:\n        right = lv1\n    assert vector and k >= 0, \"Either null vector or k < 0 \"\n    assert 0 <= left <= lv1, \"left is out of range\"\n    assert left <= right <= lv1, \"right is out of range\"\n    return _select(vector, left, right, k)\n\nif __name__ == '__main__':\n    v = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]\n    print([select(v, i) for i in range(10)])\n"}
{"id": 123566, "name": "Sort an integer array", "source": "Translate COBOL to C#:        PROGRAM-ID. sort-ints.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  array-area             VALUE \"54321\".\n           03  array              PIC 9 OCCURS 5 TIMES.\n       01  i                      PIC 9.\n       \n       PROCEDURE DIVISION.\n       main-line.\n           PERFORM display-array\n           SORT array ASCENDING array\n           PERFORM display-array\n       \n           GOBACK\n           .\n       display-array.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL 5 < i\n               DISPLAY array (i) \" \" NO ADVANCING\n           END-PERFORM\n           DISPLAY SPACE\n           .\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n    static void Main() {\n        int[] unsorted = { 6, 2, 7, 8, 3, 1, 10, 5, 4, 9 };\n        Array.Sort(unsorted);\n    }\n}\n"}
{"id": 123568, "name": "Sort an integer array", "source": "Translate COBOL to Java:        PROGRAM-ID. sort-ints.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  array-area             VALUE \"54321\".\n           03  array              PIC 9 OCCURS 5 TIMES.\n       01  i                      PIC 9.\n       \n       PROCEDURE DIVISION.\n       main-line.\n           PERFORM display-array\n           SORT array ASCENDING array\n           PERFORM display-array\n       \n           GOBACK\n           .\n       display-array.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL 5 < i\n               DISPLAY array (i) \" \" NO ADVANCING\n           END-PERFORM\n           DISPLAY SPACE\n           .\n", "target": "import java.util.Arrays;\n\npublic class Example {\n    public static void main(String[] args)\n    {\n        int[] nums = {2,4,3,1,2};\n        Arrays.sort(nums);\n    }\n}\n"}
{"id": 123569, "name": "Sort an integer array", "source": "Translate COBOL to Python:        PROGRAM-ID. sort-ints.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  array-area             VALUE \"54321\".\n           03  array              PIC 9 OCCURS 5 TIMES.\n       01  i                      PIC 9.\n       \n       PROCEDURE DIVISION.\n       main-line.\n           PERFORM display-array\n           SORT array ASCENDING array\n           PERFORM display-array\n       \n           GOBACK\n           .\n       display-array.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL 5 < i\n               DISPLAY array (i) \" \" NO ADVANCING\n           END-PERFORM\n           DISPLAY SPACE\n           .\n", "target": "nums = [2,4,3,1,2]\nnums.sort()\n"}
{"id": 125142, "name": "Happy numbers", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. HAPPY.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE        PIC 9(4).\n          03 SQSUM-IN         PIC 9(4).\n          03 FILLER           REDEFINES SQSUM-IN. \n             05 DIGITS        PIC 9 OCCURS 4 TIMES.\n          03 SQUARE           PIC 9(4).\n          03 SUM-OF-SQUARES   PIC 9(4).\n          03 N                PIC 9.\n          03 TORTOISE         PIC 9(4).\n          03 HARE             PIC 9(4).\n             88 HAPPY         VALUE 1.\n          03 SEEN             PIC 9 VALUE ZERO.\n          03 OUT-FMT          PIC ZZZ9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM DISPLAY-IF-HAPPY VARYING CANDIDATE FROM 1 BY 1\n           UNTIL SEEN IS EQUAL TO 8.\n           STOP RUN.\n\n       DISPLAY-IF-HAPPY.\n           PERFORM CHECK-HAPPY.\n           IF HAPPY, \n               MOVE CANDIDATE TO OUT-FMT, \n               DISPLAY OUT-FMT,\n               ADD 1 TO SEEN.\n \n       CHECK-HAPPY.\n           MOVE CANDIDATE TO TORTOISE, SQSUM-IN.\n           PERFORM CALC-SUM-OF-SQUARES.\n           MOVE SUM-OF-SQUARES TO HARE.\n           PERFORM CHECK-HAPPY-STEP UNTIL TORTOISE IS EQUAL TO HARE.\n    \n       CHECK-HAPPY-STEP.\n           MOVE TORTOISE TO SQSUM-IN.\n           PERFORM CALC-SUM-OF-SQUARES.\n           MOVE SUM-OF-SQUARES TO TORTOISE.\n           MOVE HARE TO SQSUM-IN.\n           PERFORM CALC-SUM-OF-SQUARES.\n           MOVE SUM-OF-SQUARES TO SQSUM-IN.\n           PERFORM CALC-SUM-OF-SQUARES.\n           MOVE SUM-OF-SQUARES TO HARE.\n \n       CALC-SUM-OF-SQUARES.\n           MOVE ZERO TO SUM-OF-SQUARES.\n           PERFORM ADD-DIGIT-SQUARE VARYING N FROM 1 BY 1\n           UNTIL N IS GREATER THAN 4.\n \n       ADD-DIGIT-SQUARE.\n           MULTIPLY DIGITS(N) BY DIGITS(N) GIVING SQUARE.\n           ADD SQUARE TO SUM-OF-SQUARES.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace HappyNums\n{\n    class Program\n    {\n        public static bool ishappy(int n)\n        {\n            List<int> cache = new List<int>();\n            int sum = 0;\n            while (n != 1)\n            {\n                if (cache.Contains(n))\n                {\n                    return false;\n                }\n                cache.Add(n);\n                while (n != 0)\n                {\n                    int digit = n % 10;\n                    sum += digit * digit;\n                    n /= 10;\n                }\n                n = sum;\n                sum = 0;\n            }\n           return true;            \n        }\n\n        static void Main(string[] args)\n        {\n            int num = 1;\n            List<int> happynums = new List<int>();\n\n            while (happynums.Count < 8)\n            {\n                if (ishappy(num))\n                {\n                    happynums.Add(num);\n                }\n                num++;\n            }\n            Console.WriteLine(\"First 8 happy numbers\u00a0: \" + string.Join(\",\", happynums));\n        }\n    }\n}\n"}
{"id": 125144, "name": "Happy numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. HAPPY.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE        PIC 9(4).\n          03 SQSUM-IN         PIC 9(4).\n          03 FILLER           REDEFINES SQSUM-IN. \n             05 DIGITS        PIC 9 OCCURS 4 TIMES.\n          03 SQUARE           PIC 9(4).\n          03 SUM-OF-SQUARES   PIC 9(4).\n          03 N                PIC 9.\n          03 TORTOISE         PIC 9(4).\n          03 HARE             PIC 9(4).\n             88 HAPPY         VALUE 1.\n          03 SEEN             PIC 9 VALUE ZERO.\n          03 OUT-FMT          PIC ZZZ9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM DISPLAY-IF-HAPPY VARYING CANDIDATE FROM 1 BY 1\n           UNTIL SEEN IS EQUAL TO 8.\n           STOP RUN.\n\n       DISPLAY-IF-HAPPY.\n           PERFORM CHECK-HAPPY.\n           IF HAPPY, \n               MOVE CANDIDATE TO OUT-FMT, \n               DISPLAY OUT-FMT,\n               ADD 1 TO SEEN.\n \n       CHECK-HAPPY.\n           MOVE CANDIDATE TO TORTOISE, SQSUM-IN.\n           PERFORM CALC-SUM-OF-SQUARES.\n           MOVE SUM-OF-SQUARES TO HARE.\n           PERFORM CHECK-HAPPY-STEP UNTIL TORTOISE IS EQUAL TO HARE.\n    \n       CHECK-HAPPY-STEP.\n           MOVE TORTOISE TO SQSUM-IN.\n           PERFORM CALC-SUM-OF-SQUARES.\n           MOVE SUM-OF-SQUARES TO TORTOISE.\n           MOVE HARE TO SQSUM-IN.\n           PERFORM CALC-SUM-OF-SQUARES.\n           MOVE SUM-OF-SQUARES TO SQSUM-IN.\n           PERFORM CALC-SUM-OF-SQUARES.\n           MOVE SUM-OF-SQUARES TO HARE.\n \n       CALC-SUM-OF-SQUARES.\n           MOVE ZERO TO SUM-OF-SQUARES.\n           PERFORM ADD-DIGIT-SQUARE VARYING N FROM 1 BY 1\n           UNTIL N IS GREATER THAN 4.\n \n       ADD-DIGIT-SQUARE.\n           MULTIPLY DIGITS(N) BY DIGITS(N) GIVING SQUARE.\n           ADD SQUARE TO SUM-OF-SQUARES.\n", "target": "import java.util.HashSet;\npublic class Happy{\n   public static boolean happy(long number){\n       long m = 0;\n       int digit = 0;\n       HashSet<Long> cycle = new HashSet<Long>();\n       while(number != 1 && cycle.add(number)){\n           m = 0;\n           while(number > 0){\n               digit = (int)(number % 10);\n               m += digit*digit;\n               number /= 10;\n           }\n           number = m;\n       }\n       return number == 1;\n   }\n\n   public static void main(String[] args){\n       for(long num = 1,count = 0;count<8;num++){\n           if(happy(num)){\n               System.out.println(num);\n               count++;\n           }\n       }\n   }\n}\n"}
{"id": 125145, "name": "Happy numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. HAPPY.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE        PIC 9(4).\n          03 SQSUM-IN         PIC 9(4).\n          03 FILLER           REDEFINES SQSUM-IN. \n             05 DIGITS        PIC 9 OCCURS 4 TIMES.\n          03 SQUARE           PIC 9(4).\n          03 SUM-OF-SQUARES   PIC 9(4).\n          03 N                PIC 9.\n          03 TORTOISE         PIC 9(4).\n          03 HARE             PIC 9(4).\n             88 HAPPY         VALUE 1.\n          03 SEEN             PIC 9 VALUE ZERO.\n          03 OUT-FMT          PIC ZZZ9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM DISPLAY-IF-HAPPY VARYING CANDIDATE FROM 1 BY 1\n           UNTIL SEEN IS EQUAL TO 8.\n           STOP RUN.\n\n       DISPLAY-IF-HAPPY.\n           PERFORM CHECK-HAPPY.\n           IF HAPPY, \n               MOVE CANDIDATE TO OUT-FMT, \n               DISPLAY OUT-FMT,\n               ADD 1 TO SEEN.\n \n       CHECK-HAPPY.\n           MOVE CANDIDATE TO TORTOISE, SQSUM-IN.\n           PERFORM CALC-SUM-OF-SQUARES.\n           MOVE SUM-OF-SQUARES TO HARE.\n           PERFORM CHECK-HAPPY-STEP UNTIL TORTOISE IS EQUAL TO HARE.\n    \n       CHECK-HAPPY-STEP.\n           MOVE TORTOISE TO SQSUM-IN.\n           PERFORM CALC-SUM-OF-SQUARES.\n           MOVE SUM-OF-SQUARES TO TORTOISE.\n           MOVE HARE TO SQSUM-IN.\n           PERFORM CALC-SUM-OF-SQUARES.\n           MOVE SUM-OF-SQUARES TO SQSUM-IN.\n           PERFORM CALC-SUM-OF-SQUARES.\n           MOVE SUM-OF-SQUARES TO HARE.\n \n       CALC-SUM-OF-SQUARES.\n           MOVE ZERO TO SUM-OF-SQUARES.\n           PERFORM ADD-DIGIT-SQUARE VARYING N FROM 1 BY 1\n           UNTIL N IS GREATER THAN 4.\n \n       ADD-DIGIT-SQUARE.\n           MULTIPLY DIGITS(N) BY DIGITS(N) GIVING SQUARE.\n           ADD SQUARE TO SUM-OF-SQUARES.\n", "target": ">>> def happy(n):\n    past = set()\t\t\t\n    while n != 1:\n        n = sum(int(i)**2 for i in str(n))\n        if n in past:\n            return False\n        past.add(n)\n    return True\n\n>>> [x for x in xrange(500) if happy(x)][:8]\n[1, 7, 10, 13, 19, 23, 28, 31]\n"}
{"id": 125396, "name": "Random numbers", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. RANDOM.\n       AUTHOR.  Bill Gunshannon\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  14 January 2022.\n      ************************************************************\n      ** Program Abstract:\n      **   Able to get the Mean to be really close to 1.0 but\n      **     couldn't get the Standard Deviation any closer than\n      **     .3 to .4.\n      ************************************************************\n       \n       DATA DIVISION.\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Sample-Size          PIC 9(5)         VALUE 1000.\n       01  Total                PIC 9(10)V9(5)  VALUE 0.0.\n       01  Arith-Mean           PIC 999V999  VALUE 0.0.\n       01  Std-Dev              PIC 999V999  VALUE 0.0.\n       01  Seed                 PIC 999V999.\n       01  TI                   PIC 9(8).\n\n       01  Idx                  PIC 99999     VALUE 0.\n       01  Intermediate         PIC 9(10)V9(5)  VALUE 0.0.\n       01  Rnd-Work.\n           05  Rnd-Tbl \n                   OCCURS 1 TO 99999 TIMES DEPENDING ON Sample-Size.\n               10  Rnd              PIC 9V9999999  VALUE 0.0.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           ACCEPT TI FROM TIME.\n           MOVE FUNCTION RANDOM(TI) TO Seed.\n           PERFORM WITH TEST AFTER VARYING Idx \n                   FROM 1 BY 1 \n                   UNTIL Idx = Sample-Size\n              COMPUTE Intermediate = \n                           (FUNCTION RANDOM() * 2.01) \n              MOVE Intermediate TO Rnd(Idx)\n           END-PERFORM.\n           PERFORM WITH TEST AFTER VARYING Idx \n                   FROM 1 BY 1 \n                   UNTIL Idx = Sample-Size \n              COMPUTE Total = Total + Rnd(Idx)\n           END-PERFORM.\n\n\n           COMPUTE Arith-Mean = Total / Sample-Size.\n           DISPLAY \"Mean: \" Arith-Mean.\n\n\n           PERFORM WITH TEST AFTER VARYING Idx\n                   FROM 1 BY 1\n                   UNTIL Idx = Sample-Size\n              COMPUTE Intermediate = \n                      Intermediate + (Rnd(Idx) - Arith-Mean) ** 2\n           END-PERFORM.\n              COMPUTE Std-Dev = Intermediate / Sample-Size.\n\n\n           DISPLAY \"Std-Dev: \" Std-Dev.\n\n           STOP RUN.\n       \n       END PROGRAM RANDOM.\n", "target": "private static double randomNormal()\n{\n\treturn Math.Cos(2 * Math.PI * tRand.NextDouble()) * Math.Sqrt(-2 * Math.Log(tRand.NextDouble()));\n}\n"}
{"id": 125398, "name": "Random numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. RANDOM.\n       AUTHOR.  Bill Gunshannon\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  14 January 2022.\n      ************************************************************\n      ** Program Abstract:\n      **   Able to get the Mean to be really close to 1.0 but\n      **     couldn't get the Standard Deviation any closer than\n      **     .3 to .4.\n      ************************************************************\n       \n       DATA DIVISION.\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Sample-Size          PIC 9(5)         VALUE 1000.\n       01  Total                PIC 9(10)V9(5)  VALUE 0.0.\n       01  Arith-Mean           PIC 999V999  VALUE 0.0.\n       01  Std-Dev              PIC 999V999  VALUE 0.0.\n       01  Seed                 PIC 999V999.\n       01  TI                   PIC 9(8).\n\n       01  Idx                  PIC 99999     VALUE 0.\n       01  Intermediate         PIC 9(10)V9(5)  VALUE 0.0.\n       01  Rnd-Work.\n           05  Rnd-Tbl \n                   OCCURS 1 TO 99999 TIMES DEPENDING ON Sample-Size.\n               10  Rnd              PIC 9V9999999  VALUE 0.0.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           ACCEPT TI FROM TIME.\n           MOVE FUNCTION RANDOM(TI) TO Seed.\n           PERFORM WITH TEST AFTER VARYING Idx \n                   FROM 1 BY 1 \n                   UNTIL Idx = Sample-Size\n              COMPUTE Intermediate = \n                           (FUNCTION RANDOM() * 2.01) \n              MOVE Intermediate TO Rnd(Idx)\n           END-PERFORM.\n           PERFORM WITH TEST AFTER VARYING Idx \n                   FROM 1 BY 1 \n                   UNTIL Idx = Sample-Size \n              COMPUTE Total = Total + Rnd(Idx)\n           END-PERFORM.\n\n\n           COMPUTE Arith-Mean = Total / Sample-Size.\n           DISPLAY \"Mean: \" Arith-Mean.\n\n\n           PERFORM WITH TEST AFTER VARYING Idx\n                   FROM 1 BY 1\n                   UNTIL Idx = Sample-Size\n              COMPUTE Intermediate = \n                      Intermediate + (Rnd(Idx) - Arith-Mean) ** 2\n           END-PERFORM.\n              COMPUTE Std-Dev = Intermediate / Sample-Size.\n\n\n           DISPLAY \"Std-Dev: \" Std-Dev.\n\n           STOP RUN.\n       \n       END PROGRAM RANDOM.\n", "target": "double[] list = new double[1000];\ndouble mean = 1.0, std = 0.5;\nRandom rng = new Random();\nfor(int i = 0;i<list.length;i++) {\n  list[i] = mean + std * rng.nextGaussian();\n}\n"}
{"id": 125399, "name": "Random numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. RANDOM.\n       AUTHOR.  Bill Gunshannon\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  14 January 2022.\n      ************************************************************\n      ** Program Abstract:\n      **   Able to get the Mean to be really close to 1.0 but\n      **     couldn't get the Standard Deviation any closer than\n      **     .3 to .4.\n      ************************************************************\n       \n       DATA DIVISION.\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Sample-Size          PIC 9(5)         VALUE 1000.\n       01  Total                PIC 9(10)V9(5)  VALUE 0.0.\n       01  Arith-Mean           PIC 999V999  VALUE 0.0.\n       01  Std-Dev              PIC 999V999  VALUE 0.0.\n       01  Seed                 PIC 999V999.\n       01  TI                   PIC 9(8).\n\n       01  Idx                  PIC 99999     VALUE 0.\n       01  Intermediate         PIC 9(10)V9(5)  VALUE 0.0.\n       01  Rnd-Work.\n           05  Rnd-Tbl \n                   OCCURS 1 TO 99999 TIMES DEPENDING ON Sample-Size.\n               10  Rnd              PIC 9V9999999  VALUE 0.0.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           ACCEPT TI FROM TIME.\n           MOVE FUNCTION RANDOM(TI) TO Seed.\n           PERFORM WITH TEST AFTER VARYING Idx \n                   FROM 1 BY 1 \n                   UNTIL Idx = Sample-Size\n              COMPUTE Intermediate = \n                           (FUNCTION RANDOM() * 2.01) \n              MOVE Intermediate TO Rnd(Idx)\n           END-PERFORM.\n           PERFORM WITH TEST AFTER VARYING Idx \n                   FROM 1 BY 1 \n                   UNTIL Idx = Sample-Size \n              COMPUTE Total = Total + Rnd(Idx)\n           END-PERFORM.\n\n\n           COMPUTE Arith-Mean = Total / Sample-Size.\n           DISPLAY \"Mean: \" Arith-Mean.\n\n\n           PERFORM WITH TEST AFTER VARYING Idx\n                   FROM 1 BY 1\n                   UNTIL Idx = Sample-Size\n              COMPUTE Intermediate = \n                      Intermediate + (Rnd(Idx) - Arith-Mean) ** 2\n           END-PERFORM.\n              COMPUTE Std-Dev = Intermediate / Sample-Size.\n\n\n           DISPLAY \"Std-Dev: \" Std-Dev.\n\n           STOP RUN.\n       \n       END PROGRAM RANDOM.\n", "target": ">>> import random\n>>> values = [random.gauss(1, .5) for i in range(1000)]\n>>>\n"}
{"id": 126935, "name": "Classes", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       CLASS-ID. my-class INHERITS base.\n       \n       \n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS base.\n     \n           \n           \n           \n           \n     \n           OBJECT.\n               \n               DATA DIVISION.\n               WORKING-STORAGE SECTION.\n               01  instance-variable PIC 9(8).\n       \n               \n               \n               01  a-property        PIC 9(8) PROPERTY.\n               \n               PROCEDURE DIVISION.\n       \n               METHOD-ID. some-method.\n               PROCEDURE DIVISION.\n                   \n               END METHOD some-method.\n           END OBJECT.\n       END CLASS my-class.\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. example-class-use.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           \n           \n           CLASS my-class\n           PROPERTY a-property. \n                  \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       \n       01  instance USAGE OBJECT REFERENCE my-class.\n       \n       PROCEDURE DIVISION.\n       \n           \n           INVOKE my-class \"new\" RETURNING instance\n           \n           \n           INVOKE instance \"some-method\"\n\n           \n           MOVE 5 TO a-property OF instance\n           DISPLAY a-property OF instance\n       \n           GOBACK\n           .\n           \n       END PROGRAM example-class-use.\n", "target": "public class MyClass\n{\n    public MyClass()\n    {\n    }\n    public void SomeMethod()\n    {\n    }\n    private int _variable;\n    public int Variable\n    {\n        get { return _variable; }\n        set { _variable = value; }\n    }\n    public static void Main()\n    {\n        \n        MyClass instance = new MyClass();\n        \n        instance.SomeMethod();\n        \n        instance.Variable = 99;\n        \n        System.Console.WriteLine( \"Variable=\" + instance.Variable.ToString() );\n    }\n}\n"}
{"id": 126937, "name": "Classes", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       CLASS-ID. my-class INHERITS base.\n       \n       \n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS base.\n     \n           \n           \n           \n           \n     \n           OBJECT.\n               \n               DATA DIVISION.\n               WORKING-STORAGE SECTION.\n               01  instance-variable PIC 9(8).\n       \n               \n               \n               01  a-property        PIC 9(8) PROPERTY.\n               \n               PROCEDURE DIVISION.\n       \n               METHOD-ID. some-method.\n               PROCEDURE DIVISION.\n                   \n               END METHOD some-method.\n           END OBJECT.\n       END CLASS my-class.\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. example-class-use.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           \n           \n           CLASS my-class\n           PROPERTY a-property. \n                  \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       \n       01  instance USAGE OBJECT REFERENCE my-class.\n       \n       PROCEDURE DIVISION.\n       \n           \n           INVOKE my-class \"new\" RETURNING instance\n           \n           \n           INVOKE instance \"some-method\"\n\n           \n           MOVE 5 TO a-property OF instance\n           DISPLAY a-property OF instance\n       \n           GOBACK\n           .\n           \n       END PROGRAM example-class-use.\n", "target": "public class MyClass{\n\n  \n  private int variable;  \n\n  \n  public MyClass(){\n    \n  }\n\n  \n  public void someMethod(){\n   this.variable = 1;\n  }\n}\n"}
{"id": 126938, "name": "Classes", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       CLASS-ID. my-class INHERITS base.\n       \n       \n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS base.\n     \n           \n           \n           \n           \n     \n           OBJECT.\n               \n               DATA DIVISION.\n               WORKING-STORAGE SECTION.\n               01  instance-variable PIC 9(8).\n       \n               \n               \n               01  a-property        PIC 9(8) PROPERTY.\n               \n               PROCEDURE DIVISION.\n       \n               METHOD-ID. some-method.\n               PROCEDURE DIVISION.\n                   \n               END METHOD some-method.\n           END OBJECT.\n       END CLASS my-class.\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. example-class-use.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           \n           \n           CLASS my-class\n           PROPERTY a-property. \n                  \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       \n       01  instance USAGE OBJECT REFERENCE my-class.\n       \n       PROCEDURE DIVISION.\n       \n           \n           INVOKE my-class \"new\" RETURNING instance\n           \n           \n           INVOKE instance \"some-method\"\n\n           \n           MOVE 5 TO a-property OF instance\n           DISPLAY a-property OF instance\n       \n           GOBACK\n           .\n           \n       END PROGRAM example-class-use.\n", "target": "class MyClass:\n    name2 = 2 \n\n    def __init__(self):\n        \n        self.name1 = 0 \n  \n    def someMethod(self):\n        \n        self.name1 = 1\n        MyClass.name2 = 3\n  \n  \nmyclass = MyClass() \n\nclass MyOtherClass:\n    count = 0  \n    def __init__(self, name, gender=\"Male\", age=None):\n        \n        MyOtherClass.count += 1\n        self.name = name\n        self.gender = gender\n        if age is not None:\n            self.age = age\n    def __del__(self):\n        MyOtherClass.count -= 1\n\nperson1 = MyOtherClass(\"John\")\nprint person1.name, person1.gender  \nprint person1.age                   \nperson2 = MyOtherClass(\"Jane\", \"Female\", 23)\nprint person2.name, person2.gender, person2.age  \n"}
{"id": 127162, "name": "Long multiplication", "source": "Translate COBOL to C#:        identification division.\n       program-id. long-mul.\n       data division.\n       replace ==ij-lim== by ==7== ==ir-lim== by ==14==.\n       working-storage section.\n       1 input-string pic x(26) value \"18,446,744,073,709,551,616\".\n       1 a-table.\n        2 a pic 999 occurs ij-lim.\n       1 b-table.\n        2 b pic 999 occurs ij-lim.\n       1 ir-table value all \"0\".\n        2 occurs ij-lim.\n         3 ir pic 999 occurs ir-lim.\n       1 s-table value all \"0\".\n        2 s pic 999 occurs ir-lim.\n       1 display.\n        2 temp-result pic 9(6) value 0.\n        2 carry pic 999 value 0.\n        2 remain pic 999 value 0.\n       1 binary.\n        2 i pic 9(4) value 0.\n        2 j pic 9(4) value 0.\n        2 k pic 9(4) value 0.\n       procedure division.\n       begin.\n           move 1 to j\n           perform varying i from 1 by 1 until i > ij-lim\n               unstring input-string delimited \",\"\n                   into a (i) with pointer j\n           end-perform\n           move a-table to b-table\n           perform intermediate-calc\n           perform sum-ir\n           perform display-result\n       stop run\n       .\n\n       intermediate-calc.\n           perform varying i from ij-lim by -1 until i < 1\n               move 0 to carry\n               perform varying j from ij-lim by -1 until j < 1\n                   compute temp-result = a (i) * b (j) + carry\n                   divide temp-result by 1000 giving carry\n                       remainder remain\n                   compute k = i + j\n                   move remain to ir (i k)\n               end-perform\n               subtract 1 from k\n               move carry to ir (i k)\n           end-perform\n           .\n\n       sum-ir.\n           move 0 to carry\n           perform varying k from ir-lim by -1 until k < 1\n               move carry to temp-result\n               perform varying i from ij-lim by -1 until i < 1\n                   compute temp-result = temp-result + ir (i k)\n               end-perform\n               divide temp-result by 1000 giving carry\n                   remainder remain\n               move remain to s (k)\n           end-perform\n           .\n\n       display-result.\n           display \"   \" input-string\n           display \" * \" input-string\n           display \" = \" with no advancing\n           perform varying k from 1 by 1\n           until k > ir-lim or s (k) not = 0\n           end-perform\n           if s (k) < 100\n               move 1 to i\n               inspect s (k) tallying i for leading \"0\"\n               display s (k) (i:) \",\" with no advancing\n               add 1 to k\n           end-if\n           perform varying k from k by 1 until k > ir-lim\n               display s (k) with no advancing\n               if k < ir-lim\n                   display \",\" with no advancing\n               end-if\n           end-perform\n           display space\n           .\n\n       end program long-mul.\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\nclass Program {\n\n  static decimal mx = 1E28M, hm = 1E14M, a;\n\n  \n  struct bi { public decimal hi, lo; }\n\n  \n  static bi set4sq(decimal a) { bi r; r.hi = Math.Floor(a / hm); r.lo = a % hm; return r; }\n\n  \n  static string toStr(bi a, bool comma = false) {\n    string r = a.hi == 0 ? string.Format(\"{0:0}\", a.lo) :\n                           string.Format(\"{0:0}{1:\" + new string('0', 28) + \"}\", a.hi, a.lo);\n    if (!comma) return r;  string rc = \"\";\n    for (int i = r.Length - 3; i > 0; i -= 3) rc = \",\" + r.Substring(i, 3) + rc;\n    return r.Substring(0, ((r.Length + 2) % 3) + 1) + rc; }\n\n  \n  static decimal Pow_dec(decimal bas, uint exp) {\n    if (exp == 0) return 1M; decimal tmp = Pow_dec(bas, exp >> 1); tmp *= tmp;\n    if ((exp & 1) == 0) return tmp; return tmp * bas; }\n\n  static void Main(string[] args) {\n    for (uint p = 64; p < 95; p += 30) {        \n      bi x = set4sq(a = Pow_dec(2M, p)), y;     \n      WriteLine(\"The square of (2^{0}):                    {1,38:n0}\", p, a); BI BS = BI.Pow((BI)a, 2);\n      y.lo = x.lo * x.lo; y.hi = x.hi * x.hi;   \n      a = x.hi * x.lo * 2M;                     \n      y.hi += Math.Floor(a / hm);               \n      y.lo += (a % hm) * hm;                    \n      while (y.lo > mx) { y.lo -= mx; y.hi++; } \n      WriteLine(\" is {0,75} (which {1} match the BigInteger computation)\\n\", toStr(y, true),\n          BS.ToString() == toStr(y) ? \"does\" : \"fails to\"); } }\n\n}\n"}
{"id": 127164, "name": "Long multiplication", "source": "Translate COBOL to Java:        identification division.\n       program-id. long-mul.\n       data division.\n       replace ==ij-lim== by ==7== ==ir-lim== by ==14==.\n       working-storage section.\n       1 input-string pic x(26) value \"18,446,744,073,709,551,616\".\n       1 a-table.\n        2 a pic 999 occurs ij-lim.\n       1 b-table.\n        2 b pic 999 occurs ij-lim.\n       1 ir-table value all \"0\".\n        2 occurs ij-lim.\n         3 ir pic 999 occurs ir-lim.\n       1 s-table value all \"0\".\n        2 s pic 999 occurs ir-lim.\n       1 display.\n        2 temp-result pic 9(6) value 0.\n        2 carry pic 999 value 0.\n        2 remain pic 999 value 0.\n       1 binary.\n        2 i pic 9(4) value 0.\n        2 j pic 9(4) value 0.\n        2 k pic 9(4) value 0.\n       procedure division.\n       begin.\n           move 1 to j\n           perform varying i from 1 by 1 until i > ij-lim\n               unstring input-string delimited \",\"\n                   into a (i) with pointer j\n           end-perform\n           move a-table to b-table\n           perform intermediate-calc\n           perform sum-ir\n           perform display-result\n       stop run\n       .\n\n       intermediate-calc.\n           perform varying i from ij-lim by -1 until i < 1\n               move 0 to carry\n               perform varying j from ij-lim by -1 until j < 1\n                   compute temp-result = a (i) * b (j) + carry\n                   divide temp-result by 1000 giving carry\n                       remainder remain\n                   compute k = i + j\n                   move remain to ir (i k)\n               end-perform\n               subtract 1 from k\n               move carry to ir (i k)\n           end-perform\n           .\n\n       sum-ir.\n           move 0 to carry\n           perform varying k from ir-lim by -1 until k < 1\n               move carry to temp-result\n               perform varying i from ij-lim by -1 until i < 1\n                   compute temp-result = temp-result + ir (i k)\n               end-perform\n               divide temp-result by 1000 giving carry\n                   remainder remain\n               move remain to s (k)\n           end-perform\n           .\n\n       display-result.\n           display \"   \" input-string\n           display \" * \" input-string\n           display \" = \" with no advancing\n           perform varying k from 1 by 1\n           until k > ir-lim or s (k) not = 0\n           end-perform\n           if s (k) < 100\n               move 1 to i\n               inspect s (k) tallying i for leading \"0\"\n               display s (k) (i:) \",\" with no advancing\n               add 1 to k\n           end-if\n           perform varying k from k by 1 until k > ir-lim\n               display s (k) with no advancing\n               if k < ir-lim\n                   display \",\" with no advancing\n               end-if\n           end-perform\n           display space\n           .\n\n       end program long-mul.\n", "target": "public class LongMult {\n\n\tprivate static byte[] stringToDigits(String num) {\n\t\tbyte[] result = new byte[num.length()];\n\t\tfor (int i = 0; i < num.length(); i++) {\n\t\t\tchar c = num.charAt(i);\n\t\t\tif (c < '0' || c > '9') {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid digit \" + c\n\t\t\t\t\t\t+ \" found at position \" + i);\n\t\t\t}\n\t\t\tresult[num.length() - 1 - i] = (byte) (c - '0');\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static String longMult(String num1, String num2) {\n\t\tbyte[] left = stringToDigits(num1);\n\t\tbyte[] right = stringToDigits(num2);\n\t\tbyte[] result = new byte[left.length + right.length];\n\t\tfor (int rightPos = 0; rightPos < right.length; rightPos++) {\n\t\t\tbyte rightDigit = right[rightPos];\n\t\t\tbyte temp = 0;\n\t\t\tfor (int leftPos = 0; leftPos < left.length; leftPos++) {\n\t\t\t\ttemp += result[leftPos + rightPos];\n\t\t\t\ttemp += rightDigit * left[leftPos];\n\t\t\t\tresult[leftPos + rightPos] = (byte) (temp % 10);\n\t\t\t\ttemp /= 10;\n\t\t\t}\n\t\t\tint destPos = rightPos + left.length;\n\t\t\twhile (temp != 0) {\n\t\t\t\ttemp += result[destPos] & 0xFFFFFFFFL;\n\t\t\t\tresult[destPos] = (byte) (temp % 10);\n\t\t\t\ttemp /= 10;\n\t\t\t\tdestPos++;\n\t\t\t}\n\t\t}\n\t\tStringBuilder stringResultBuilder = new StringBuilder(result.length);\n\t\tfor (int i = result.length - 1; i >= 0; i--) {\n\t\t\tbyte digit = result[i];\n\t\t\tif (digit != 0 || stringResultBuilder.length() > 0) {\n\t\t\t\tstringResultBuilder.append((char) (digit + '0'));\n\t\t\t}\n\t\t}\n\t\treturn stringResultBuilder.toString();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(longMult(\"18446744073709551616\",\n\t\t\t\t\"18446744073709551616\"));\n\t}\n}\n"}
{"id": 127165, "name": "Long multiplication", "source": "Translate COBOL to Python:        identification division.\n       program-id. long-mul.\n       data division.\n       replace ==ij-lim== by ==7== ==ir-lim== by ==14==.\n       working-storage section.\n       1 input-string pic x(26) value \"18,446,744,073,709,551,616\".\n       1 a-table.\n        2 a pic 999 occurs ij-lim.\n       1 b-table.\n        2 b pic 999 occurs ij-lim.\n       1 ir-table value all \"0\".\n        2 occurs ij-lim.\n         3 ir pic 999 occurs ir-lim.\n       1 s-table value all \"0\".\n        2 s pic 999 occurs ir-lim.\n       1 display.\n        2 temp-result pic 9(6) value 0.\n        2 carry pic 999 value 0.\n        2 remain pic 999 value 0.\n       1 binary.\n        2 i pic 9(4) value 0.\n        2 j pic 9(4) value 0.\n        2 k pic 9(4) value 0.\n       procedure division.\n       begin.\n           move 1 to j\n           perform varying i from 1 by 1 until i > ij-lim\n               unstring input-string delimited \",\"\n                   into a (i) with pointer j\n           end-perform\n           move a-table to b-table\n           perform intermediate-calc\n           perform sum-ir\n           perform display-result\n       stop run\n       .\n\n       intermediate-calc.\n           perform varying i from ij-lim by -1 until i < 1\n               move 0 to carry\n               perform varying j from ij-lim by -1 until j < 1\n                   compute temp-result = a (i) * b (j) + carry\n                   divide temp-result by 1000 giving carry\n                       remainder remain\n                   compute k = i + j\n                   move remain to ir (i k)\n               end-perform\n               subtract 1 from k\n               move carry to ir (i k)\n           end-perform\n           .\n\n       sum-ir.\n           move 0 to carry\n           perform varying k from ir-lim by -1 until k < 1\n               move carry to temp-result\n               perform varying i from ij-lim by -1 until i < 1\n                   compute temp-result = temp-result + ir (i k)\n               end-perform\n               divide temp-result by 1000 giving carry\n                   remainder remain\n               move remain to s (k)\n           end-perform\n           .\n\n       display-result.\n           display \"   \" input-string\n           display \" * \" input-string\n           display \" = \" with no advancing\n           perform varying k from 1 by 1\n           until k > ir-lim or s (k) not = 0\n           end-perform\n           if s (k) < 100\n               move 1 to i\n               inspect s (k) tallying i for leading \"0\"\n               display s (k) (i:) \",\" with no advancing\n               add 1 to k\n           end-if\n           perform varying k from k by 1 until k > ir-lim\n               display s (k) with no advancing\n               if k < ir-lim\n                   display \",\" with no advancing\n               end-if\n           end-perform\n           display space\n           .\n\n       end program long-mul.\n", "target": "\nprint 2**64*2**64\n"}
{"id": 127582, "name": "Detect division by zero", "source": "Translate COBOL to C#: DIVIDE foo BY bar GIVING foobar\n    ON SIZE ERROR\n        DISPLAY \"Division by zero detected!\"\nEND-DIVIDE\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            int x = 1;\n            int y = 0;\n            try {\n               int z = x / y;\n            } catch (DivideByZeroException e) {\n                Console.WriteLine(e);\n            }\n            \n        }\n    }\n}\n"}
{"id": 127583, "name": "Detect division by zero", "source": "Translate COBOL to C#: DIVIDE foo BY bar GIVING foobar\n    ON SIZE ERROR\n        DISPLAY \"Division by zero detected!\"\nEND-DIVIDE\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            int x = 1;\n            int y = 0;\n            try {\n               int z = x / y;\n            } catch (DivideByZeroException e) {\n                Console.WriteLine(e);\n            }\n            \n        }\n    }\n}\n"}
{"id": 127586, "name": "Detect division by zero", "source": "Translate COBOL to Java: DIVIDE foo BY bar GIVING foobar\n    ON SIZE ERROR\n        DISPLAY \"Division by zero detected!\"\nEND-DIVIDE\n", "target": "public static boolean infinity(double numer, double denom){\n\treturn Double.isInfinite(numer/denom);\n}\n"}
{"id": 127587, "name": "Detect division by zero", "source": "Translate COBOL to Java: DIVIDE foo BY bar GIVING foobar\n    ON SIZE ERROR\n        DISPLAY \"Division by zero detected!\"\nEND-DIVIDE\n", "target": "public static boolean infinity(double numer, double denom){\n\treturn Double.isInfinite(numer/denom);\n}\n"}
{"id": 127588, "name": "Detect division by zero", "source": "Translate COBOL to Python: DIVIDE foo BY bar GIVING foobar\n    ON SIZE ERROR\n        DISPLAY \"Division by zero detected!\"\nEND-DIVIDE\n", "target": "def div_check(x, y):\n  try:\n    x / y\n  except ZeroDivisionError:\n    return True\n  else:\n    return False\n"}
{"id": 127589, "name": "Detect division by zero", "source": "Translate COBOL to Python: DIVIDE foo BY bar GIVING foobar\n    ON SIZE ERROR\n        DISPLAY \"Division by zero detected!\"\nEND-DIVIDE\n", "target": "def div_check(x, y):\n  try:\n    x / y\n  except ZeroDivisionError:\n    return True\n  else:\n    return False\n"}
{"id": 128542, "name": "Roman numerals_Encode", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. TOROMAN.\nDATA DIVISION.\nworking-storage section.\n  01 ws-number pic 9(4) value 0.\n  01 ws-save-number pic 9(4).\n  01 ws-tbl-def.\n    03 filler pic x(7) value '1000M  '.\n    03 filler pic x(7) value '0900CM '.\n    03 filler pic x(7) value '0500D  '.\n    03 filler pic x(7) value '0400CD '.\n    03 filler pic x(7) value '0100C  '.\n    03 filler pic x(7) value '0090XC '.\n    03 filler pic x(7) value '0050L  '.\n    03 filler pic x(7) value '0040XL '.\n    03 filler pic x(7) value '0010X  '.\n    03 filler pic x(7) value '0009IX '.\n    03 filler pic x(7) value '0005V  '.\n    03 filler pic x(7) value '0004IV '.\n    03 filler pic x(7) value '0001I  '.\n  01  filler redefines ws-tbl-def.\n    03 filler occurs 13 times indexed by rx.\n      05 ws-tbl-divisor    pic 9(4).\n      05 ws-tbl-roman-ch   pic x(1) occurs 3 times indexed by cx.\n  01 ocx pic 99.\n  01 ws-roman.\n    03 ws-roman-ch         pic x(1) occurs 16 times.\nPROCEDURE DIVISION.\n  accept ws-number\n  perform\n  until ws-number = 0\n    move ws-number to ws-save-number\n    if ws-number > 0 and ws-number < 4000\n      initialize ws-roman\n      move 0 to ocx\n      perform varying rx from 1 by +1\n      until ws-number = 0\n        perform until ws-number < ws-tbl-divisor (rx)\n          perform varying cx from 1 by +1 \n  \t\t  until ws-tbl-roman-ch (rx, cx) = spaces\n            compute ocx = ocx + 1\n            move ws-tbl-roman-ch (rx, cx) to ws-roman-ch (ocx)\n          end-perform\n          compute ws-number = ws-number - ws-tbl-divisor (rx)\n        end-perform\n      end-perform\n      display 'inp=' ws-save-number ' roman=' ws-roman\n    else\n      display 'inp=' ws-save-number ' invalid'\n    end-if\n    accept ws-number\n  end-perform\n  .\n", "target": "using System;\nclass Program\n{\n    static uint[] nums = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };\n    static string[] rum = { \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" };\n\n    static string ToRoman(uint number)\n    {\n        string value = \"\";\n        for (int i = 0; i < nums.Length && number != 0; i++)\n        {\n            while (number >= nums[i])\n            {\n                number -= nums[i];\n                value += rum[i];\n            }\n        }\n        return value;\n    }\n\n    static void Main()\n    {\n        for (uint number = 1; number <= 1 << 10; number *= 2)\n        {\n            Console.WriteLine(\"{0} = {1}\", number, ToRoman(number));\n        }\n    }\n}\n"}
{"id": 128543, "name": "Roman numerals_Encode", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. TOROMAN.\nDATA DIVISION.\nworking-storage section.\n  01 ws-number pic 9(4) value 0.\n  01 ws-save-number pic 9(4).\n  01 ws-tbl-def.\n    03 filler pic x(7) value '1000M  '.\n    03 filler pic x(7) value '0900CM '.\n    03 filler pic x(7) value '0500D  '.\n    03 filler pic x(7) value '0400CD '.\n    03 filler pic x(7) value '0100C  '.\n    03 filler pic x(7) value '0090XC '.\n    03 filler pic x(7) value '0050L  '.\n    03 filler pic x(7) value '0040XL '.\n    03 filler pic x(7) value '0010X  '.\n    03 filler pic x(7) value '0009IX '.\n    03 filler pic x(7) value '0005V  '.\n    03 filler pic x(7) value '0004IV '.\n    03 filler pic x(7) value '0001I  '.\n  01  filler redefines ws-tbl-def.\n    03 filler occurs 13 times indexed by rx.\n      05 ws-tbl-divisor    pic 9(4).\n      05 ws-tbl-roman-ch   pic x(1) occurs 3 times indexed by cx.\n  01 ocx pic 99.\n  01 ws-roman.\n    03 ws-roman-ch         pic x(1) occurs 16 times.\nPROCEDURE DIVISION.\n  accept ws-number\n  perform\n  until ws-number = 0\n    move ws-number to ws-save-number\n    if ws-number > 0 and ws-number < 4000\n      initialize ws-roman\n      move 0 to ocx\n      perform varying rx from 1 by +1\n      until ws-number = 0\n        perform until ws-number < ws-tbl-divisor (rx)\n          perform varying cx from 1 by +1 \n  \t\t  until ws-tbl-roman-ch (rx, cx) = spaces\n            compute ocx = ocx + 1\n            move ws-tbl-roman-ch (rx, cx) to ws-roman-ch (ocx)\n          end-perform\n          compute ws-number = ws-number - ws-tbl-divisor (rx)\n        end-perform\n      end-perform\n      display 'inp=' ws-save-number ' roman=' ws-roman\n    else\n      display 'inp=' ws-save-number ' invalid'\n    end-if\n    accept ws-number\n  end-perform\n  .\n", "target": "using System;\nclass Program\n{\n    static uint[] nums = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };\n    static string[] rum = { \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" };\n\n    static string ToRoman(uint number)\n    {\n        string value = \"\";\n        for (int i = 0; i < nums.Length && number != 0; i++)\n        {\n            while (number >= nums[i])\n            {\n                number -= nums[i];\n                value += rum[i];\n            }\n        }\n        return value;\n    }\n\n    static void Main()\n    {\n        for (uint number = 1; number <= 1 << 10; number *= 2)\n        {\n            Console.WriteLine(\"{0} = {1}\", number, ToRoman(number));\n        }\n    }\n}\n"}
{"id": 128546, "name": "Roman numerals_Encode", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. TOROMAN.\nDATA DIVISION.\nworking-storage section.\n  01 ws-number pic 9(4) value 0.\n  01 ws-save-number pic 9(4).\n  01 ws-tbl-def.\n    03 filler pic x(7) value '1000M  '.\n    03 filler pic x(7) value '0900CM '.\n    03 filler pic x(7) value '0500D  '.\n    03 filler pic x(7) value '0400CD '.\n    03 filler pic x(7) value '0100C  '.\n    03 filler pic x(7) value '0090XC '.\n    03 filler pic x(7) value '0050L  '.\n    03 filler pic x(7) value '0040XL '.\n    03 filler pic x(7) value '0010X  '.\n    03 filler pic x(7) value '0009IX '.\n    03 filler pic x(7) value '0005V  '.\n    03 filler pic x(7) value '0004IV '.\n    03 filler pic x(7) value '0001I  '.\n  01  filler redefines ws-tbl-def.\n    03 filler occurs 13 times indexed by rx.\n      05 ws-tbl-divisor    pic 9(4).\n      05 ws-tbl-roman-ch   pic x(1) occurs 3 times indexed by cx.\n  01 ocx pic 99.\n  01 ws-roman.\n    03 ws-roman-ch         pic x(1) occurs 16 times.\nPROCEDURE DIVISION.\n  accept ws-number\n  perform\n  until ws-number = 0\n    move ws-number to ws-save-number\n    if ws-number > 0 and ws-number < 4000\n      initialize ws-roman\n      move 0 to ocx\n      perform varying rx from 1 by +1\n      until ws-number = 0\n        perform until ws-number < ws-tbl-divisor (rx)\n          perform varying cx from 1 by +1 \n  \t\t  until ws-tbl-roman-ch (rx, cx) = spaces\n            compute ocx = ocx + 1\n            move ws-tbl-roman-ch (rx, cx) to ws-roman-ch (ocx)\n          end-perform\n          compute ws-number = ws-number - ws-tbl-divisor (rx)\n        end-perform\n      end-perform\n      display 'inp=' ws-save-number ' roman=' ws-roman\n    else\n      display 'inp=' ws-save-number ' invalid'\n    end-if\n    accept ws-number\n  end-perform\n  .\n", "target": "public class RN {\n\n    enum Numeral {\n        I(1), IV(4), V(5), IX(9), X(10), XL(40), L(50), XC(90), C(100), CD(400), D(500), CM(900), M(1000);\n        int weight;\n\n        Numeral(int weight) {\n            this.weight = weight;\n        }\n    };\n\n    public static String roman(long n) {\n        \n        if( n <= 0) {\n            throw new IllegalArgumentException();\n        }\n        \n        StringBuilder buf = new StringBuilder();\n\n        final Numeral[] values = Numeral.values();\n        for (int i = values.length - 1; i >= 0; i--) {\n            while (n >= values[i].weight) {\n                buf.append(values[i]);\n                n -= values[i].weight;\n            }\n        }\n        return buf.toString();\n    }\n\n    public static void test(long n) {\n        System.out.println(n + \" = \" + roman(n));\n    }\n\n    public static void main(String[] args) {\n        test(1999);\n        test(25);\n        test(944);\n        test(0);\n    }\n\n}\n"}
{"id": 128547, "name": "Roman numerals_Encode", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. TOROMAN.\nDATA DIVISION.\nworking-storage section.\n  01 ws-number pic 9(4) value 0.\n  01 ws-save-number pic 9(4).\n  01 ws-tbl-def.\n    03 filler pic x(7) value '1000M  '.\n    03 filler pic x(7) value '0900CM '.\n    03 filler pic x(7) value '0500D  '.\n    03 filler pic x(7) value '0400CD '.\n    03 filler pic x(7) value '0100C  '.\n    03 filler pic x(7) value '0090XC '.\n    03 filler pic x(7) value '0050L  '.\n    03 filler pic x(7) value '0040XL '.\n    03 filler pic x(7) value '0010X  '.\n    03 filler pic x(7) value '0009IX '.\n    03 filler pic x(7) value '0005V  '.\n    03 filler pic x(7) value '0004IV '.\n    03 filler pic x(7) value '0001I  '.\n  01  filler redefines ws-tbl-def.\n    03 filler occurs 13 times indexed by rx.\n      05 ws-tbl-divisor    pic 9(4).\n      05 ws-tbl-roman-ch   pic x(1) occurs 3 times indexed by cx.\n  01 ocx pic 99.\n  01 ws-roman.\n    03 ws-roman-ch         pic x(1) occurs 16 times.\nPROCEDURE DIVISION.\n  accept ws-number\n  perform\n  until ws-number = 0\n    move ws-number to ws-save-number\n    if ws-number > 0 and ws-number < 4000\n      initialize ws-roman\n      move 0 to ocx\n      perform varying rx from 1 by +1\n      until ws-number = 0\n        perform until ws-number < ws-tbl-divisor (rx)\n          perform varying cx from 1 by +1 \n  \t\t  until ws-tbl-roman-ch (rx, cx) = spaces\n            compute ocx = ocx + 1\n            move ws-tbl-roman-ch (rx, cx) to ws-roman-ch (ocx)\n          end-perform\n          compute ws-number = ws-number - ws-tbl-divisor (rx)\n        end-perform\n      end-perform\n      display 'inp=' ws-save-number ' roman=' ws-roman\n    else\n      display 'inp=' ws-save-number ' invalid'\n    end-if\n    accept ws-number\n  end-perform\n  .\n", "target": "public class RN {\n\n    enum Numeral {\n        I(1), IV(4), V(5), IX(9), X(10), XL(40), L(50), XC(90), C(100), CD(400), D(500), CM(900), M(1000);\n        int weight;\n\n        Numeral(int weight) {\n            this.weight = weight;\n        }\n    };\n\n    public static String roman(long n) {\n        \n        if( n <= 0) {\n            throw new IllegalArgumentException();\n        }\n        \n        StringBuilder buf = new StringBuilder();\n\n        final Numeral[] values = Numeral.values();\n        for (int i = values.length - 1; i >= 0; i--) {\n            while (n >= values[i].weight) {\n                buf.append(values[i]);\n                n -= values[i].weight;\n            }\n        }\n        return buf.toString();\n    }\n\n    public static void test(long n) {\n        System.out.println(n + \" = \" + roman(n));\n    }\n\n    public static void main(String[] args) {\n        test(1999);\n        test(25);\n        test(944);\n        test(0);\n    }\n\n}\n"}
{"id": 128548, "name": "Roman numerals_Encode", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. TOROMAN.\nDATA DIVISION.\nworking-storage section.\n  01 ws-number pic 9(4) value 0.\n  01 ws-save-number pic 9(4).\n  01 ws-tbl-def.\n    03 filler pic x(7) value '1000M  '.\n    03 filler pic x(7) value '0900CM '.\n    03 filler pic x(7) value '0500D  '.\n    03 filler pic x(7) value '0400CD '.\n    03 filler pic x(7) value '0100C  '.\n    03 filler pic x(7) value '0090XC '.\n    03 filler pic x(7) value '0050L  '.\n    03 filler pic x(7) value '0040XL '.\n    03 filler pic x(7) value '0010X  '.\n    03 filler pic x(7) value '0009IX '.\n    03 filler pic x(7) value '0005V  '.\n    03 filler pic x(7) value '0004IV '.\n    03 filler pic x(7) value '0001I  '.\n  01  filler redefines ws-tbl-def.\n    03 filler occurs 13 times indexed by rx.\n      05 ws-tbl-divisor    pic 9(4).\n      05 ws-tbl-roman-ch   pic x(1) occurs 3 times indexed by cx.\n  01 ocx pic 99.\n  01 ws-roman.\n    03 ws-roman-ch         pic x(1) occurs 16 times.\nPROCEDURE DIVISION.\n  accept ws-number\n  perform\n  until ws-number = 0\n    move ws-number to ws-save-number\n    if ws-number > 0 and ws-number < 4000\n      initialize ws-roman\n      move 0 to ocx\n      perform varying rx from 1 by +1\n      until ws-number = 0\n        perform until ws-number < ws-tbl-divisor (rx)\n          perform varying cx from 1 by +1 \n  \t\t  until ws-tbl-roman-ch (rx, cx) = spaces\n            compute ocx = ocx + 1\n            move ws-tbl-roman-ch (rx, cx) to ws-roman-ch (ocx)\n          end-perform\n          compute ws-number = ws-number - ws-tbl-divisor (rx)\n        end-perform\n      end-perform\n      display 'inp=' ws-save-number ' roman=' ws-roman\n    else\n      display 'inp=' ws-save-number ' invalid'\n    end-if\n    accept ws-number\n  end-perform\n  .\n", "target": "import roman\nprint(roman.toRoman(2022))\n"}
{"id": 128549, "name": "Roman numerals_Encode", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. TOROMAN.\nDATA DIVISION.\nworking-storage section.\n  01 ws-number pic 9(4) value 0.\n  01 ws-save-number pic 9(4).\n  01 ws-tbl-def.\n    03 filler pic x(7) value '1000M  '.\n    03 filler pic x(7) value '0900CM '.\n    03 filler pic x(7) value '0500D  '.\n    03 filler pic x(7) value '0400CD '.\n    03 filler pic x(7) value '0100C  '.\n    03 filler pic x(7) value '0090XC '.\n    03 filler pic x(7) value '0050L  '.\n    03 filler pic x(7) value '0040XL '.\n    03 filler pic x(7) value '0010X  '.\n    03 filler pic x(7) value '0009IX '.\n    03 filler pic x(7) value '0005V  '.\n    03 filler pic x(7) value '0004IV '.\n    03 filler pic x(7) value '0001I  '.\n  01  filler redefines ws-tbl-def.\n    03 filler occurs 13 times indexed by rx.\n      05 ws-tbl-divisor    pic 9(4).\n      05 ws-tbl-roman-ch   pic x(1) occurs 3 times indexed by cx.\n  01 ocx pic 99.\n  01 ws-roman.\n    03 ws-roman-ch         pic x(1) occurs 16 times.\nPROCEDURE DIVISION.\n  accept ws-number\n  perform\n  until ws-number = 0\n    move ws-number to ws-save-number\n    if ws-number > 0 and ws-number < 4000\n      initialize ws-roman\n      move 0 to ocx\n      perform varying rx from 1 by +1\n      until ws-number = 0\n        perform until ws-number < ws-tbl-divisor (rx)\n          perform varying cx from 1 by +1 \n  \t\t  until ws-tbl-roman-ch (rx, cx) = spaces\n            compute ocx = ocx + 1\n            move ws-tbl-roman-ch (rx, cx) to ws-roman-ch (ocx)\n          end-perform\n          compute ws-number = ws-number - ws-tbl-divisor (rx)\n        end-perform\n      end-perform\n      display 'inp=' ws-save-number ' roman=' ws-roman\n    else\n      display 'inp=' ws-save-number ' invalid'\n    end-if\n    accept ws-number\n  end-perform\n  .\n", "target": "import roman\nprint(roman.toRoman(2022))\n"}
{"id": 128914, "name": "Loops_While", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Loop-While.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  I PIC 9999 VALUE 1024.\n\n       PROCEDURE DIVISION.\n           PERFORM UNTIL NOT 0 < I\n               DISPLAY I\n               DIVIDE 2 INTO I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "int i = 1024;\nwhile(i > 0){\n   System.Console.WriteLine(i);\n   i /= 2;\n}\n"}
{"id": 128916, "name": "Loops_While", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Loop-While.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  I PIC 9999 VALUE 1024.\n\n       PROCEDURE DIVISION.\n           PERFORM UNTIL NOT 0 < I\n               DISPLAY I\n               DIVIDE 2 INTO I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "int i = 1024;\nwhile(i > 0){\n   System.out.println(i);\n   i >>= 1; \n}\n"}
{"id": 128917, "name": "Loops_While", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Loop-While.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  I PIC 9999 VALUE 1024.\n\n       PROCEDURE DIVISION.\n           PERFORM UNTIL NOT 0 < I\n               DISPLAY I\n               DIVIDE 2 INTO I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "n = 1024\nwhile n > 0:\n    print n\n    n //= 2\n"}
{"id": 129397, "name": "Towers of Hanoi", "source": "Translate COBOL to C#:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. towers-of-hanoi.\n\nPROCEDURE DIVISION.\n    CALL \"move-disk\" USING 4, 1, 2, 3\n    .\nEND PROGRAM towers-of-hanoi.\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. move-disk RECURSIVE.\n\nDATA DIVISION.\nLINKAGE SECTION.\n01  n                         PIC 9 USAGE COMP.\n01  from-pole                 PIC 9 USAGE COMP.\n01  to-pole                   PIC 9 USAGE COMP.\n01  via-pole                  PIC 9 USAGE COMP.\n\nPROCEDURE DIVISION USING n, from-pole, to-pole, via-pole.\n    IF n > 0\n       SUBTRACT 1 FROM n\n       CALL \"move-disk\" USING CONTENT n, from-pole, via-pole, to-pole\n       DISPLAY \"Move disk from pole \" from-pole \" to pole \" to-pole\n       CALL \"move-disk\" USING CONTENT n, via-pole, to-pole, from-pole\n    END-IF\n    .\nEND PROGRAM move-disk.\n", "target": "public  void move(int n, int from, int to, int via) {\n   if (n == 1) {\n     System.Console.WriteLine(\"Move disk from pole \" + from + \" to pole \" + to);\n   } else {\n     move(n - 1, from, via, to);\n     move(1, from, to, via);\n     move(n - 1, via, to, from);\n   }\n }\n"}
{"id": 129399, "name": "Towers of Hanoi", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. towers-of-hanoi.\n\nPROCEDURE DIVISION.\n    CALL \"move-disk\" USING 4, 1, 2, 3\n    .\nEND PROGRAM towers-of-hanoi.\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. move-disk RECURSIVE.\n\nDATA DIVISION.\nLINKAGE SECTION.\n01  n                         PIC 9 USAGE COMP.\n01  from-pole                 PIC 9 USAGE COMP.\n01  to-pole                   PIC 9 USAGE COMP.\n01  via-pole                  PIC 9 USAGE COMP.\n\nPROCEDURE DIVISION USING n, from-pole, to-pole, via-pole.\n    IF n > 0\n       SUBTRACT 1 FROM n\n       CALL \"move-disk\" USING CONTENT n, from-pole, via-pole, to-pole\n       DISPLAY \"Move disk from pole \" from-pole \" to pole \" to-pole\n       CALL \"move-disk\" USING CONTENT n, via-pole, to-pole, from-pole\n    END-IF\n    .\nEND PROGRAM move-disk.\n", "target": "public void move(int n, int from, int to, int via) {\n  if (n == 1) {\n    System.out.println(\"Move disk from pole \" + from + \" to pole \" + to);\n  } else {\n    move(n - 1, from, via, to);\n    move(1, from, to, via);\n    move(n - 1, via, to, from);\n  }\n}\n"}
{"id": 129400, "name": "Towers of Hanoi", "source": "Translate COBOL to Python:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. towers-of-hanoi.\n\nPROCEDURE DIVISION.\n    CALL \"move-disk\" USING 4, 1, 2, 3\n    .\nEND PROGRAM towers-of-hanoi.\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. move-disk RECURSIVE.\n\nDATA DIVISION.\nLINKAGE SECTION.\n01  n                         PIC 9 USAGE COMP.\n01  from-pole                 PIC 9 USAGE COMP.\n01  to-pole                   PIC 9 USAGE COMP.\n01  via-pole                  PIC 9 USAGE COMP.\n\nPROCEDURE DIVISION USING n, from-pole, to-pole, via-pole.\n    IF n > 0\n       SUBTRACT 1 FROM n\n       CALL \"move-disk\" USING CONTENT n, from-pole, via-pole, to-pole\n       DISPLAY \"Move disk from pole \" from-pole \" to pole \" to-pole\n       CALL \"move-disk\" USING CONTENT n, via-pole, to-pole, from-pole\n    END-IF\n    .\nEND PROGRAM move-disk.\n", "target": "\n\n\n\u0ba8\u0bbf\u0bb0\u0bb2\u0bcd\u0baa\u0bbe\u0b95\u0bae\u0bcd \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd, \u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1, \u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1)\n\n  @(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd == 1 ) \u0b86\u0ba9\u0bbe\u0bb2\u0bcd\n     \u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf  \u201c\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1 \u201d + str(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1) + \u201c\u0b90 \\t  (\u201d + str(\u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1) + \u201c  \u2014> \u201d +  str(\u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1)+ \u201c) \u0b85\u0b9a\u0bcd\u0b9a\u0bbf\u0bb1\u0bcd\u0b95\u0bc1 \u0ba8\u0b95\u0bb0\u0bcd\u0ba4\u0bcd\u0ba4\u0bc1\u0b95.\u201d\n  \u0b87\u0bb2\u0bcd\u0bb2\u0bc8\n\n  @( [\"\u0b87\", \"\u0b85\",  \"\u0b86\"]  \u0b87\u0bb2\u0bcd \u0b85\u0b9a\u0bcd\u0b9a\u0bc1 ) \u0b92\u0bb5\u0bcd\u0bb5\u0bca\u0ba9\u0bcd\u0bb1\u0bbe\u0b95\n          @( (\u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1 != \u0b85\u0b9a\u0bcd\u0b9a\u0bc1)  && (\u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1  != \u0b85\u0b9a\u0bcd\u0b9a\u0bc1) ) \u0b86\u0ba9\u0bbe\u0bb2\u0bcd\n              \u0ba8\u0b9f\u0bc1 = \u0b85\u0b9a\u0bcd\u0b9a\u0bc1\n          \u0bae\u0bc1\u0b9f\u0bbf\n  \u0bae\u0bc1\u0b9f\u0bbf\n\n    \n    \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1,   \u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0ba8\u0b9f\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1)\n\n    \n    \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(1, \u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1, \u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd)\n\n    \n    \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1, \u0ba8\u0b9f\u0bc1, \u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1)\n  \u0bae\u0bc1\u0b9f\u0bbf\n\u0bae\u0bc1\u0b9f\u0bbf\n\n\u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(4,\u201d\u0b85\u201d,\u201d\u0b86\u201d,0)\n"}
{"id": 131463, "name": "Constrained random points on a circle", "source": "Translate COBOL to C#:        identification division.\n       program-id. circle.\n       environment division.\n       input-output section.\n       file-control.\n           select plot-file assign \"circle.txt\".\n       data division.\n       file section.\n       fd plot-file report plot.\n       working-storage section.\n       1 binary.\n        2 seed pic 9(18).\n        2 x pic s9(4).\n        2 y pic s9(4).\n        2 i pic 9(4).\n        2 dot-count pic 9(4) value 0.\n        2 dot-count-save pic 9(4) value 0.\n        2 temp-points.\n         3 pic s9(4) occurs 2.\n        2 xy-table.\n         3 point-pair occurs 0 to 404 depending dot-count.\n          4 x-point pic s9(4).\n          4 y-point pic s9(4).\n       1 plot-table value all \"0\".\n        2 occurs 31.\n         3 dot pic 9 occurs 31.\n       1 cur-date-time.\n        2 yyyymmdd pic 9(8).\n        2 hh pic 9(2).\n        2 mm pic 9(2).\n        2 ss pic 9(2).\n       1 plot-work.\n        2 plot-item pic xb occurs 31.\n       report section.\n       rd plot.\n       1 plot-line type de.\n        2 line plus 1.\n         3 column is 1 source is plot-work pic x(62).\n       procedure division.\n       begin.\n           perform compute-seed\n           perform find-all-valid-points\n           perform shuffle-point-pairs\n           perform select-100-dots\n           perform print-dots\n           stop run\n           .\n\n       find-all-valid-points.\n           perform varying x from -15 by 1 until x > +15\n               perform varying y from -15 by 1 until y > +15\n                   if (function sqrt (x ** 2 + y ** 2))\n                       >= 10 and <= 15\n                   then\n                       move 1 to dot (x + 16 y + 16)\n                       add 1 to dot-count\n                       compute x-point (dot-count) = x + 16\n                       compute y-point (dot-count) = y + 16\n                   end-if\n               end-perform\n           end-perform\n           display \"Total points: \" dot-count\n           .\n\n       shuffle-point-pairs.\n           move dot-count to dot-count-save\n           compute i = function random (seed) * dot-count + 1\n           perform varying dot-count from dot-count by -1\n           until dot-count < 2\n               move point-pair (i) to temp-points\n               move point-pair (dot-count) to point-pair (i)\n               move temp-points  to point-pair (dot-count)\n               compute i = function random * dot-count + 1\n           end-perform\n           move dot-count-save to dot-count\n           .\n\n       select-100-dots.\n           perform varying i from 1 by 1\n           until i > 100\n               compute x = x-point (i)\n               compute y = y-point (i)\n               move 2 to dot (x y)\n           end-perform\n           .\n\n       print-dots.\n           open output plot-file\n           initiate plot\n           perform varying y from 1 by 1 until y > 31\n               move spaces to plot-work\n               perform varying x from 1 by 1 until x > 31\n                   if dot (x y) = 2\n                       move \"o\" to plot-item (x)\n                   end-if\n               end-perform\n               generate plot-line\n           end-perform\n           terminate plot\n           close plot-file\n           .\n\n       compute-seed.\n           unstring function current-date into\n               yyyymmdd hh mm ss\n           compute seed =\n               (function integer-of-date (yyyymmdd) * 86400)\n           compute seed = seed\n                 + (hh * 3600) + (mm * 60) + ss\n           compute seed = function mod (seed 32768)\n           .\n\n       end program circle.\n", "target": "using System;\nusing System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaConstrainedRandomCircle\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var points = new Point[404];\n            int i = 0;\n            for (int y = -15; y <= 15; y++)\n                for (int x = -15; x <= 15 && i < 404; x++)\n                {\n                    var c = Math.Sqrt(x * x + y * y);\n                    if (10 <= c && c <= 15)\n                    {\n                        points[i++] = new Point(x, y);\n                    }\n                }\n\n            var bm = new Bitmap(600, 600);\n            var g = Graphics.FromImage(bm);\n            var brush = new SolidBrush(Color.Magenta);\n\n            var r = new System.Random();\n            for (int count = 0; count < 100; count++)\n            {\n                var p = points[r.Next(404)];\n                g.FillEllipse(brush, new Rectangle(290 + 19 * p.X, 290 + 19 * p.Y, 10, 10));\n            }\n            const string filename = \"Constrained Random Circle.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 131465, "name": "Constrained random points on a circle", "source": "Translate COBOL to Java:        identification division.\n       program-id. circle.\n       environment division.\n       input-output section.\n       file-control.\n           select plot-file assign \"circle.txt\".\n       data division.\n       file section.\n       fd plot-file report plot.\n       working-storage section.\n       1 binary.\n        2 seed pic 9(18).\n        2 x pic s9(4).\n        2 y pic s9(4).\n        2 i pic 9(4).\n        2 dot-count pic 9(4) value 0.\n        2 dot-count-save pic 9(4) value 0.\n        2 temp-points.\n         3 pic s9(4) occurs 2.\n        2 xy-table.\n         3 point-pair occurs 0 to 404 depending dot-count.\n          4 x-point pic s9(4).\n          4 y-point pic s9(4).\n       1 plot-table value all \"0\".\n        2 occurs 31.\n         3 dot pic 9 occurs 31.\n       1 cur-date-time.\n        2 yyyymmdd pic 9(8).\n        2 hh pic 9(2).\n        2 mm pic 9(2).\n        2 ss pic 9(2).\n       1 plot-work.\n        2 plot-item pic xb occurs 31.\n       report section.\n       rd plot.\n       1 plot-line type de.\n        2 line plus 1.\n         3 column is 1 source is plot-work pic x(62).\n       procedure division.\n       begin.\n           perform compute-seed\n           perform find-all-valid-points\n           perform shuffle-point-pairs\n           perform select-100-dots\n           perform print-dots\n           stop run\n           .\n\n       find-all-valid-points.\n           perform varying x from -15 by 1 until x > +15\n               perform varying y from -15 by 1 until y > +15\n                   if (function sqrt (x ** 2 + y ** 2))\n                       >= 10 and <= 15\n                   then\n                       move 1 to dot (x + 16 y + 16)\n                       add 1 to dot-count\n                       compute x-point (dot-count) = x + 16\n                       compute y-point (dot-count) = y + 16\n                   end-if\n               end-perform\n           end-perform\n           display \"Total points: \" dot-count\n           .\n\n       shuffle-point-pairs.\n           move dot-count to dot-count-save\n           compute i = function random (seed) * dot-count + 1\n           perform varying dot-count from dot-count by -1\n           until dot-count < 2\n               move point-pair (i) to temp-points\n               move point-pair (dot-count) to point-pair (i)\n               move temp-points  to point-pair (dot-count)\n               compute i = function random * dot-count + 1\n           end-perform\n           move dot-count-save to dot-count\n           .\n\n       select-100-dots.\n           perform varying i from 1 by 1\n           until i > 100\n               compute x = x-point (i)\n               compute y = y-point (i)\n               move 2 to dot (x y)\n           end-perform\n           .\n\n       print-dots.\n           open output plot-file\n           initiate plot\n           perform varying y from 1 by 1 until y > 31\n               move spaces to plot-work\n               perform varying x from 1 by 1 until x > 31\n                   if dot (x y) = 2\n                       move \"o\" to plot-item (x)\n                   end-if\n               end-perform\n               generate plot-line\n           end-perform\n           terminate plot\n           close plot-file\n           .\n\n       compute-seed.\n           unstring function current-date into\n               yyyymmdd hh mm ss\n           compute seed =\n               (function integer-of-date (yyyymmdd) * 86400)\n           compute seed = seed\n                 + (hh * 3600) + (mm * 60) + ss\n           compute seed = function mod (seed 32768)\n           .\n\n       end program circle.\n", "target": "import java.util.Random;\n\npublic class FuzzyCircle {\n\tstatic final Random rnd = new Random();\n\tpublic static void main(String[] args){\n\t\tchar[][] field = new char[31][31];\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[i].length; j++){\n\t\t\t\tfield[i][j] = ' ';\n\t\t\t}\n\t\t}\n\t\tint pointsInDisc = 0;\n\t\twhile(pointsInDisc < 100){\n\t\t\tint x = rnd.nextInt(31) - 15;\n\t\t\tint y = rnd.nextInt(31) - 15;\n\t\t\tdouble dist = Math.hypot(x, y);\n\t\t\tif(dist >= 10 && dist <= 15 && field[x + 15][y + 15] == ' '){\n\t\t\t\tfield[x + 15][y + 15] = 'X';\n\t\t\t\tpointsInDisc++;\n\t\t\t}\n\t\t}\n\t\tfor(char[] row:field){\n\t\t\tfor(char space:row){\n\t\t\t\tSystem.out.print(space);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 131466, "name": "Constrained random points on a circle", "source": "Translate COBOL to Python:        identification division.\n       program-id. circle.\n       environment division.\n       input-output section.\n       file-control.\n           select plot-file assign \"circle.txt\".\n       data division.\n       file section.\n       fd plot-file report plot.\n       working-storage section.\n       1 binary.\n        2 seed pic 9(18).\n        2 x pic s9(4).\n        2 y pic s9(4).\n        2 i pic 9(4).\n        2 dot-count pic 9(4) value 0.\n        2 dot-count-save pic 9(4) value 0.\n        2 temp-points.\n         3 pic s9(4) occurs 2.\n        2 xy-table.\n         3 point-pair occurs 0 to 404 depending dot-count.\n          4 x-point pic s9(4).\n          4 y-point pic s9(4).\n       1 plot-table value all \"0\".\n        2 occurs 31.\n         3 dot pic 9 occurs 31.\n       1 cur-date-time.\n        2 yyyymmdd pic 9(8).\n        2 hh pic 9(2).\n        2 mm pic 9(2).\n        2 ss pic 9(2).\n       1 plot-work.\n        2 plot-item pic xb occurs 31.\n       report section.\n       rd plot.\n       1 plot-line type de.\n        2 line plus 1.\n         3 column is 1 source is plot-work pic x(62).\n       procedure division.\n       begin.\n           perform compute-seed\n           perform find-all-valid-points\n           perform shuffle-point-pairs\n           perform select-100-dots\n           perform print-dots\n           stop run\n           .\n\n       find-all-valid-points.\n           perform varying x from -15 by 1 until x > +15\n               perform varying y from -15 by 1 until y > +15\n                   if (function sqrt (x ** 2 + y ** 2))\n                       >= 10 and <= 15\n                   then\n                       move 1 to dot (x + 16 y + 16)\n                       add 1 to dot-count\n                       compute x-point (dot-count) = x + 16\n                       compute y-point (dot-count) = y + 16\n                   end-if\n               end-perform\n           end-perform\n           display \"Total points: \" dot-count\n           .\n\n       shuffle-point-pairs.\n           move dot-count to dot-count-save\n           compute i = function random (seed) * dot-count + 1\n           perform varying dot-count from dot-count by -1\n           until dot-count < 2\n               move point-pair (i) to temp-points\n               move point-pair (dot-count) to point-pair (i)\n               move temp-points  to point-pair (dot-count)\n               compute i = function random * dot-count + 1\n           end-perform\n           move dot-count-save to dot-count\n           .\n\n       select-100-dots.\n           perform varying i from 1 by 1\n           until i > 100\n               compute x = x-point (i)\n               compute y = y-point (i)\n               move 2 to dot (x y)\n           end-perform\n           .\n\n       print-dots.\n           open output plot-file\n           initiate plot\n           perform varying y from 1 by 1 until y > 31\n               move spaces to plot-work\n               perform varying x from 1 by 1 until x > 31\n                   if dot (x y) = 2\n                       move \"o\" to plot-item (x)\n                   end-if\n               end-perform\n               generate plot-line\n           end-perform\n           terminate plot\n           close plot-file\n           .\n\n       compute-seed.\n           unstring function current-date into\n               yyyymmdd hh mm ss\n           compute seed =\n               (function integer-of-date (yyyymmdd) * 86400)\n           compute seed = seed\n                 + (hh * 3600) + (mm * 60) + ss\n           compute seed = function mod (seed 32768)\n           .\n\n       end program circle.\n", "target": ">>> from collections import defaultdict\n>>> from random import choice\n>>> world = defaultdict(int)\n>>> possiblepoints = [(x,y) for x in range(-15,16)\n\t\t  for y in range(-15,16)\n\t\t  if 10 <= abs(x+y*1j) <= 15]\n>>> for i in range(100): world[choice(possiblepoints)] += 1\n\n>>> for x in range(-15,16):\n\tprint(''.join(str(min([9, world[(x,y)]])) if world[(x,y)] else ' '\n\t\t\t  for y in range(-15,16)))\n\n\t\n                               \n             1     1           \n          1 1                  \n      11 1     1  1     1      \n     111  1     1211           \n      1   2    1 1    11       \n      1  11         21         \n     1   1            11  1    \n   1  2                1 1     \n                               \n 1  2                          \n   1 1                      1  \n   1 1                         \n   2                      11   \n  1                         1  \n                         1     \n                               \n                               \n  1                          1 \n                         1     \n                         2     \n                            1  \n     1                  1 1    \n      1                2   1   \n   1   3            11  2      \n    11   1    1      1   2     \n            1   1    2         \n        1  1                   \n         1      1     1        \n          2 2   1              \n               1\n"}
{"id": 131617, "name": "Call an object method", "source": "Translate COBOL to C#: \nINVOKE FooClass \"someMethod\" RETURNING bar        \nINVOKE foo-instance \"anotherMethod\" RETURNING bar \n\n\nMOVE FooClass::\"someMethod\" TO bar        \nMOVE foo-instance::\"anotherMethod\" TO bar \n", "target": "\nMyClass.Method(someParameter);\n \n\nmyInstance.Method(someParameter);\n"}
{"id": 131619, "name": "Call an object method", "source": "Translate COBOL to Java: \nINVOKE FooClass \"someMethod\" RETURNING bar        \nINVOKE foo-instance \"anotherMethod\" RETURNING bar \n\n\nMOVE FooClass::\"someMethod\" TO bar        \nMOVE foo-instance::\"anotherMethod\" TO bar \n", "target": "\nMyClass.method(someParameter);\n\n\nmyInstance.method(someParameter);\n"}
{"id": 131620, "name": "Call an object method", "source": "Translate COBOL to Python: \nINVOKE FooClass \"someMethod\" RETURNING bar        \nINVOKE foo-instance \"anotherMethod\" RETURNING bar \n\n\nMOVE FooClass::\"someMethod\" TO bar        \nMOVE foo-instance::\"anotherMethod\" TO bar \n", "target": "class MyClass(object):\n\t@classmethod\n\tdef myClassMethod(self, x):\n\t\tpass\n\t@staticmethod\n\tdef myStaticMethod(x):\n\t\tpass\n\tdef myMethod(self, x):\n\t\treturn 42 + x\n\nmyInstance = MyClass()\n\n\nmyInstance.myMethod(someParameter)\n\nMyClass.myMethod(myInstance, someParameter)\n\n\n\nMyClass.myClassMethod(someParameter)\nMyClass.myStaticMethod(someParameter)\n\nmyInstance.myClassMethod(someParameter)\nmyInstance.myStaticMethod(someParameter)\n"}
{"id": 132406, "name": "Population count", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  HAMMING.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 POPCOUNT-VARIABLES.\n          03 POPCOUNT-IN       PIC 9(15)V9.\n          03 FILLER            REDEFINES POPCOUNT-IN.\n             05 POPCOUNT-REST  PIC 9(15).\n             05 FILLER         PIC 9.\n                88 BIT-IS-SET  VALUE 5.\n          03 POPCOUNT-OUT      PIC 99.\n          03 FILLER            REDEFINES POPCOUNT-OUT.\n             05 FILLER         PIC 9.\n             05 FILLER         PIC 9.\n                88 EVIL        VALUES 0, 2, 4, 6, 8.\n                88 ODIOUS      VALUES 1, 3, 5, 7, 9.\n\n       01 STATE-VARIABLES.\n          03 CUR-POWER-3       PIC 9(15) VALUE 1.\n          03 CUR-EVIL-NUM      PIC 99 VALUE 0.\n          03 CUR-ODIOUS-NUM    PIC 99 VALUE 0.\n          03 LINE-INDEX        PIC 99 VALUE 1.\n\n       01 OUTPUT-FORMAT.\n          03 LINENO            PIC Z9.\n          03 FILLER            PIC X VALUE '.'.\n          03 FILLER            PIC XX VALUE SPACES.\n          03 OUT-POW3          PIC Z9.\n          03 FILLER            PIC X(4) VALUE SPACES.\n          03 OUT-EVIL          PIC Z9.\n          03 FILLER            PIC X(4) VALUE SPACES.\n          03 OUT-ODIOUS        PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           DISPLAY \"     3^   EVIL   ODD\"\n           PERFORM MAKE-LINE 30 TIMES.\n           STOP RUN.\n      \n       MAKE-LINE.\n           MOVE LINE-INDEX TO LINENO.\n           MOVE CUR-POWER-3 TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           MOVE POPCOUNT-OUT TO OUT-POW3.\n           PERFORM FIND-EVIL.\n           MOVE CUR-EVIL-NUM TO OUT-EVIL.\n           PERFORM FIND-ODIOUS.\n           MOVE CUR-ODIOUS-NUM TO OUT-ODIOUS.\n           DISPLAY OUTPUT-FORMAT.\n           MULTIPLY 3 BY CUR-POWER-3.\n           ADD 1 TO CUR-EVIL-NUM.\n           ADD 1 TO CUR-ODIOUS-NUM.\n           ADD 1 TO LINE-INDEX.\n \n       FIND-EVIL.\n           MOVE CUR-EVIL-NUM TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           IF NOT EVIL, ADD 1 TO CUR-EVIL-NUM, GO TO FIND-EVIL.\n\n       FIND-ODIOUS.\n           MOVE CUR-ODIOUS-NUM TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           IF NOT ODIOUS, ADD 1 TO CUR-ODIOUS-NUM, GO TO FIND-ODIOUS.\n       \n       FIND-POPCOUNT.\n           MOVE 0 TO POPCOUNT-OUT.\n           PERFORM PROCESS-BIT UNTIL POPCOUNT-IN IS EQUAL TO ZERO.\n\n       PROCESS-BIT.\n           DIVIDE 2 INTO POPCOUNT-IN.\n           IF BIT-IS-SET, ADD 1 TO POPCOUNT-OUT.\n           MOVE POPCOUNT-REST TO POPCOUNT-IN.\n", "target": "using System;\nusing System.Linq;\n\nnamespace PopulationCount\n{\n    class Program\n    {\n        private static int PopulationCount(long n)\n        {\n            string binaryn = Convert.ToString(n, 2);\n            return binaryn.ToCharArray().Where(t => t == '1').Count();\n        }\n\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Population Counts:\");\n            Console.Write(\"3^n\u00a0:   \");\n\n            int count = 0;\n\n            while (count < 30)\n            {\n                double n = Math.Pow(3f, (double)count);\n                int popCount = PopulationCount((long)n);\n                Console.Write(string.Format(\"{0} \", popCount));\n                count++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Evil:   \");\n\n            count = 0;\n            int i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 == 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Odious: \");\n\n            count = 0;\n            i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 != 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 132407, "name": "Population count", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  HAMMING.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 POPCOUNT-VARIABLES.\n          03 POPCOUNT-IN       PIC 9(15)V9.\n          03 FILLER            REDEFINES POPCOUNT-IN.\n             05 POPCOUNT-REST  PIC 9(15).\n             05 FILLER         PIC 9.\n                88 BIT-IS-SET  VALUE 5.\n          03 POPCOUNT-OUT      PIC 99.\n          03 FILLER            REDEFINES POPCOUNT-OUT.\n             05 FILLER         PIC 9.\n             05 FILLER         PIC 9.\n                88 EVIL        VALUES 0, 2, 4, 6, 8.\n                88 ODIOUS      VALUES 1, 3, 5, 7, 9.\n\n       01 STATE-VARIABLES.\n          03 CUR-POWER-3       PIC 9(15) VALUE 1.\n          03 CUR-EVIL-NUM      PIC 99 VALUE 0.\n          03 CUR-ODIOUS-NUM    PIC 99 VALUE 0.\n          03 LINE-INDEX        PIC 99 VALUE 1.\n\n       01 OUTPUT-FORMAT.\n          03 LINENO            PIC Z9.\n          03 FILLER            PIC X VALUE '.'.\n          03 FILLER            PIC XX VALUE SPACES.\n          03 OUT-POW3          PIC Z9.\n          03 FILLER            PIC X(4) VALUE SPACES.\n          03 OUT-EVIL          PIC Z9.\n          03 FILLER            PIC X(4) VALUE SPACES.\n          03 OUT-ODIOUS        PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           DISPLAY \"     3^   EVIL   ODD\"\n           PERFORM MAKE-LINE 30 TIMES.\n           STOP RUN.\n      \n       MAKE-LINE.\n           MOVE LINE-INDEX TO LINENO.\n           MOVE CUR-POWER-3 TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           MOVE POPCOUNT-OUT TO OUT-POW3.\n           PERFORM FIND-EVIL.\n           MOVE CUR-EVIL-NUM TO OUT-EVIL.\n           PERFORM FIND-ODIOUS.\n           MOVE CUR-ODIOUS-NUM TO OUT-ODIOUS.\n           DISPLAY OUTPUT-FORMAT.\n           MULTIPLY 3 BY CUR-POWER-3.\n           ADD 1 TO CUR-EVIL-NUM.\n           ADD 1 TO CUR-ODIOUS-NUM.\n           ADD 1 TO LINE-INDEX.\n \n       FIND-EVIL.\n           MOVE CUR-EVIL-NUM TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           IF NOT EVIL, ADD 1 TO CUR-EVIL-NUM, GO TO FIND-EVIL.\n\n       FIND-ODIOUS.\n           MOVE CUR-ODIOUS-NUM TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           IF NOT ODIOUS, ADD 1 TO CUR-ODIOUS-NUM, GO TO FIND-ODIOUS.\n       \n       FIND-POPCOUNT.\n           MOVE 0 TO POPCOUNT-OUT.\n           PERFORM PROCESS-BIT UNTIL POPCOUNT-IN IS EQUAL TO ZERO.\n\n       PROCESS-BIT.\n           DIVIDE 2 INTO POPCOUNT-IN.\n           IF BIT-IS-SET, ADD 1 TO POPCOUNT-OUT.\n           MOVE POPCOUNT-REST TO POPCOUNT-IN.\n", "target": "using System;\nusing System.Linq;\n\nnamespace PopulationCount\n{\n    class Program\n    {\n        private static int PopulationCount(long n)\n        {\n            string binaryn = Convert.ToString(n, 2);\n            return binaryn.ToCharArray().Where(t => t == '1').Count();\n        }\n\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Population Counts:\");\n            Console.Write(\"3^n\u00a0:   \");\n\n            int count = 0;\n\n            while (count < 30)\n            {\n                double n = Math.Pow(3f, (double)count);\n                int popCount = PopulationCount((long)n);\n                Console.Write(string.Format(\"{0} \", popCount));\n                count++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Evil:   \");\n\n            count = 0;\n            int i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 == 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Odious: \");\n\n            count = 0;\n            i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 != 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 132410, "name": "Population count", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  HAMMING.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 POPCOUNT-VARIABLES.\n          03 POPCOUNT-IN       PIC 9(15)V9.\n          03 FILLER            REDEFINES POPCOUNT-IN.\n             05 POPCOUNT-REST  PIC 9(15).\n             05 FILLER         PIC 9.\n                88 BIT-IS-SET  VALUE 5.\n          03 POPCOUNT-OUT      PIC 99.\n          03 FILLER            REDEFINES POPCOUNT-OUT.\n             05 FILLER         PIC 9.\n             05 FILLER         PIC 9.\n                88 EVIL        VALUES 0, 2, 4, 6, 8.\n                88 ODIOUS      VALUES 1, 3, 5, 7, 9.\n\n       01 STATE-VARIABLES.\n          03 CUR-POWER-3       PIC 9(15) VALUE 1.\n          03 CUR-EVIL-NUM      PIC 99 VALUE 0.\n          03 CUR-ODIOUS-NUM    PIC 99 VALUE 0.\n          03 LINE-INDEX        PIC 99 VALUE 1.\n\n       01 OUTPUT-FORMAT.\n          03 LINENO            PIC Z9.\n          03 FILLER            PIC X VALUE '.'.\n          03 FILLER            PIC XX VALUE SPACES.\n          03 OUT-POW3          PIC Z9.\n          03 FILLER            PIC X(4) VALUE SPACES.\n          03 OUT-EVIL          PIC Z9.\n          03 FILLER            PIC X(4) VALUE SPACES.\n          03 OUT-ODIOUS        PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           DISPLAY \"     3^   EVIL   ODD\"\n           PERFORM MAKE-LINE 30 TIMES.\n           STOP RUN.\n      \n       MAKE-LINE.\n           MOVE LINE-INDEX TO LINENO.\n           MOVE CUR-POWER-3 TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           MOVE POPCOUNT-OUT TO OUT-POW3.\n           PERFORM FIND-EVIL.\n           MOVE CUR-EVIL-NUM TO OUT-EVIL.\n           PERFORM FIND-ODIOUS.\n           MOVE CUR-ODIOUS-NUM TO OUT-ODIOUS.\n           DISPLAY OUTPUT-FORMAT.\n           MULTIPLY 3 BY CUR-POWER-3.\n           ADD 1 TO CUR-EVIL-NUM.\n           ADD 1 TO CUR-ODIOUS-NUM.\n           ADD 1 TO LINE-INDEX.\n \n       FIND-EVIL.\n           MOVE CUR-EVIL-NUM TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           IF NOT EVIL, ADD 1 TO CUR-EVIL-NUM, GO TO FIND-EVIL.\n\n       FIND-ODIOUS.\n           MOVE CUR-ODIOUS-NUM TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           IF NOT ODIOUS, ADD 1 TO CUR-ODIOUS-NUM, GO TO FIND-ODIOUS.\n       \n       FIND-POPCOUNT.\n           MOVE 0 TO POPCOUNT-OUT.\n           PERFORM PROCESS-BIT UNTIL POPCOUNT-IN IS EQUAL TO ZERO.\n\n       PROCESS-BIT.\n           DIVIDE 2 INTO POPCOUNT-IN.\n           IF BIT-IS-SET, ADD 1 TO POPCOUNT-OUT.\n           MOVE POPCOUNT-REST TO POPCOUNT-IN.\n", "target": "import java.math.BigInteger;\n\npublic class PopCount {\n    public static void main(String[] args) {\n\t{ \n\t    System.out.print(\"32-bit integer: \");\n\t    int n = 1;\n\t    for (int i = 0; i < 20; i++) {\n\t\tSystem.out.printf(\"%d \", Integer.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"64-bit integer: \");\n\t    long n = 1;\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", Long.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"big integer  \u00a0: \");\n\t    BigInteger n = BigInteger.ONE;\n\t    BigInteger three = BigInteger.valueOf(3);\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", n.bitCount());\n\t\tn = n.multiply(three);\n\t    }\n\t    System.out.println();\n\t}\n\n\tint[] od = new int[30];\n\tint ne = 0, no = 0;\n\tSystem.out.print(\"evil  \u00a0: \");\n\tfor (int n = 0; ne+no < 60; n++) {\n\t    if ((Integer.bitCount(n) & 1) == 0) {\n\t\tif (ne < 30) {\n\t\t    System.out.printf(\"%d \", n);\n\t\t    ne++;\n\t\t}\n\t    } else {\n\t\tif (no < 30) {\n\t\t    od[no++] = n;\n\t\t}\n\t    }\n\t}\n\tSystem.out.println();\n\tSystem.out.print(\"odious\u00a0: \");\n\tfor (int n : od) {\n\t    System.out.printf(\"%d \", n);\n\t}\n\tSystem.out.println();\n    }\n}\n"}
{"id": 132411, "name": "Population count", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  HAMMING.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 POPCOUNT-VARIABLES.\n          03 POPCOUNT-IN       PIC 9(15)V9.\n          03 FILLER            REDEFINES POPCOUNT-IN.\n             05 POPCOUNT-REST  PIC 9(15).\n             05 FILLER         PIC 9.\n                88 BIT-IS-SET  VALUE 5.\n          03 POPCOUNT-OUT      PIC 99.\n          03 FILLER            REDEFINES POPCOUNT-OUT.\n             05 FILLER         PIC 9.\n             05 FILLER         PIC 9.\n                88 EVIL        VALUES 0, 2, 4, 6, 8.\n                88 ODIOUS      VALUES 1, 3, 5, 7, 9.\n\n       01 STATE-VARIABLES.\n          03 CUR-POWER-3       PIC 9(15) VALUE 1.\n          03 CUR-EVIL-NUM      PIC 99 VALUE 0.\n          03 CUR-ODIOUS-NUM    PIC 99 VALUE 0.\n          03 LINE-INDEX        PIC 99 VALUE 1.\n\n       01 OUTPUT-FORMAT.\n          03 LINENO            PIC Z9.\n          03 FILLER            PIC X VALUE '.'.\n          03 FILLER            PIC XX VALUE SPACES.\n          03 OUT-POW3          PIC Z9.\n          03 FILLER            PIC X(4) VALUE SPACES.\n          03 OUT-EVIL          PIC Z9.\n          03 FILLER            PIC X(4) VALUE SPACES.\n          03 OUT-ODIOUS        PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           DISPLAY \"     3^   EVIL   ODD\"\n           PERFORM MAKE-LINE 30 TIMES.\n           STOP RUN.\n      \n       MAKE-LINE.\n           MOVE LINE-INDEX TO LINENO.\n           MOVE CUR-POWER-3 TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           MOVE POPCOUNT-OUT TO OUT-POW3.\n           PERFORM FIND-EVIL.\n           MOVE CUR-EVIL-NUM TO OUT-EVIL.\n           PERFORM FIND-ODIOUS.\n           MOVE CUR-ODIOUS-NUM TO OUT-ODIOUS.\n           DISPLAY OUTPUT-FORMAT.\n           MULTIPLY 3 BY CUR-POWER-3.\n           ADD 1 TO CUR-EVIL-NUM.\n           ADD 1 TO CUR-ODIOUS-NUM.\n           ADD 1 TO LINE-INDEX.\n \n       FIND-EVIL.\n           MOVE CUR-EVIL-NUM TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           IF NOT EVIL, ADD 1 TO CUR-EVIL-NUM, GO TO FIND-EVIL.\n\n       FIND-ODIOUS.\n           MOVE CUR-ODIOUS-NUM TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           IF NOT ODIOUS, ADD 1 TO CUR-ODIOUS-NUM, GO TO FIND-ODIOUS.\n       \n       FIND-POPCOUNT.\n           MOVE 0 TO POPCOUNT-OUT.\n           PERFORM PROCESS-BIT UNTIL POPCOUNT-IN IS EQUAL TO ZERO.\n\n       PROCESS-BIT.\n           DIVIDE 2 INTO POPCOUNT-IN.\n           IF BIT-IS-SET, ADD 1 TO POPCOUNT-OUT.\n           MOVE POPCOUNT-REST TO POPCOUNT-IN.\n", "target": "import java.math.BigInteger;\n\npublic class PopCount {\n    public static void main(String[] args) {\n\t{ \n\t    System.out.print(\"32-bit integer: \");\n\t    int n = 1;\n\t    for (int i = 0; i < 20; i++) {\n\t\tSystem.out.printf(\"%d \", Integer.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"64-bit integer: \");\n\t    long n = 1;\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", Long.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"big integer  \u00a0: \");\n\t    BigInteger n = BigInteger.ONE;\n\t    BigInteger three = BigInteger.valueOf(3);\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", n.bitCount());\n\t\tn = n.multiply(three);\n\t    }\n\t    System.out.println();\n\t}\n\n\tint[] od = new int[30];\n\tint ne = 0, no = 0;\n\tSystem.out.print(\"evil  \u00a0: \");\n\tfor (int n = 0; ne+no < 60; n++) {\n\t    if ((Integer.bitCount(n) & 1) == 0) {\n\t\tif (ne < 30) {\n\t\t    System.out.printf(\"%d \", n);\n\t\t    ne++;\n\t\t}\n\t    } else {\n\t\tif (no < 30) {\n\t\t    od[no++] = n;\n\t\t}\n\t    }\n\t}\n\tSystem.out.println();\n\tSystem.out.print(\"odious\u00a0: \");\n\tfor (int n : od) {\n\t    System.out.printf(\"%d \", n);\n\t}\n\tSystem.out.println();\n    }\n}\n"}
{"id": 132412, "name": "Population count", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  HAMMING.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 POPCOUNT-VARIABLES.\n          03 POPCOUNT-IN       PIC 9(15)V9.\n          03 FILLER            REDEFINES POPCOUNT-IN.\n             05 POPCOUNT-REST  PIC 9(15).\n             05 FILLER         PIC 9.\n                88 BIT-IS-SET  VALUE 5.\n          03 POPCOUNT-OUT      PIC 99.\n          03 FILLER            REDEFINES POPCOUNT-OUT.\n             05 FILLER         PIC 9.\n             05 FILLER         PIC 9.\n                88 EVIL        VALUES 0, 2, 4, 6, 8.\n                88 ODIOUS      VALUES 1, 3, 5, 7, 9.\n\n       01 STATE-VARIABLES.\n          03 CUR-POWER-3       PIC 9(15) VALUE 1.\n          03 CUR-EVIL-NUM      PIC 99 VALUE 0.\n          03 CUR-ODIOUS-NUM    PIC 99 VALUE 0.\n          03 LINE-INDEX        PIC 99 VALUE 1.\n\n       01 OUTPUT-FORMAT.\n          03 LINENO            PIC Z9.\n          03 FILLER            PIC X VALUE '.'.\n          03 FILLER            PIC XX VALUE SPACES.\n          03 OUT-POW3          PIC Z9.\n          03 FILLER            PIC X(4) VALUE SPACES.\n          03 OUT-EVIL          PIC Z9.\n          03 FILLER            PIC X(4) VALUE SPACES.\n          03 OUT-ODIOUS        PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           DISPLAY \"     3^   EVIL   ODD\"\n           PERFORM MAKE-LINE 30 TIMES.\n           STOP RUN.\n      \n       MAKE-LINE.\n           MOVE LINE-INDEX TO LINENO.\n           MOVE CUR-POWER-3 TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           MOVE POPCOUNT-OUT TO OUT-POW3.\n           PERFORM FIND-EVIL.\n           MOVE CUR-EVIL-NUM TO OUT-EVIL.\n           PERFORM FIND-ODIOUS.\n           MOVE CUR-ODIOUS-NUM TO OUT-ODIOUS.\n           DISPLAY OUTPUT-FORMAT.\n           MULTIPLY 3 BY CUR-POWER-3.\n           ADD 1 TO CUR-EVIL-NUM.\n           ADD 1 TO CUR-ODIOUS-NUM.\n           ADD 1 TO LINE-INDEX.\n \n       FIND-EVIL.\n           MOVE CUR-EVIL-NUM TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           IF NOT EVIL, ADD 1 TO CUR-EVIL-NUM, GO TO FIND-EVIL.\n\n       FIND-ODIOUS.\n           MOVE CUR-ODIOUS-NUM TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           IF NOT ODIOUS, ADD 1 TO CUR-ODIOUS-NUM, GO TO FIND-ODIOUS.\n       \n       FIND-POPCOUNT.\n           MOVE 0 TO POPCOUNT-OUT.\n           PERFORM PROCESS-BIT UNTIL POPCOUNT-IN IS EQUAL TO ZERO.\n\n       PROCESS-BIT.\n           DIVIDE 2 INTO POPCOUNT-IN.\n           IF BIT-IS-SET, ADD 1 TO POPCOUNT-OUT.\n           MOVE POPCOUNT-REST TO POPCOUNT-IN.\n", "target": ">>> def popcount(n): return bin(n).count(\"1\")\n... \n>>> [popcount(3**i) for i in range(30)]\n[1, 2, 2, 4, 3, 6, 6, 5, 6, 8, 9, 13, 10, 11, 14, 15, 11, 14, 14, 17, 17, 20, 19, 22, 16, 18, 24, 30, 25, 25]\n>>> evil, odious, i = [], [], 0\n>>> while len(evil) < 30 or len(odious) < 30:\n...     p = popcount(i)\n...     if p % 2: odious.append(i)\n...     else: evil.append(i)\n...     i += 1\n... \n>>> evil[:30]\n[0, 3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45, 46, 48, 51, 53, 54, 57, 58]\n>>> odious[:30]\n[1, 2, 4, 7, 8, 11, 13, 14, 16, 19, 21, 22, 25, 26, 28, 31, 32, 35, 37, 38, 41, 42, 44, 47, 49, 50, 52, 55, 56, 59]\n>>>\n"}
{"id": 132413, "name": "Population count", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  HAMMING.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 POPCOUNT-VARIABLES.\n          03 POPCOUNT-IN       PIC 9(15)V9.\n          03 FILLER            REDEFINES POPCOUNT-IN.\n             05 POPCOUNT-REST  PIC 9(15).\n             05 FILLER         PIC 9.\n                88 BIT-IS-SET  VALUE 5.\n          03 POPCOUNT-OUT      PIC 99.\n          03 FILLER            REDEFINES POPCOUNT-OUT.\n             05 FILLER         PIC 9.\n             05 FILLER         PIC 9.\n                88 EVIL        VALUES 0, 2, 4, 6, 8.\n                88 ODIOUS      VALUES 1, 3, 5, 7, 9.\n\n       01 STATE-VARIABLES.\n          03 CUR-POWER-3       PIC 9(15) VALUE 1.\n          03 CUR-EVIL-NUM      PIC 99 VALUE 0.\n          03 CUR-ODIOUS-NUM    PIC 99 VALUE 0.\n          03 LINE-INDEX        PIC 99 VALUE 1.\n\n       01 OUTPUT-FORMAT.\n          03 LINENO            PIC Z9.\n          03 FILLER            PIC X VALUE '.'.\n          03 FILLER            PIC XX VALUE SPACES.\n          03 OUT-POW3          PIC Z9.\n          03 FILLER            PIC X(4) VALUE SPACES.\n          03 OUT-EVIL          PIC Z9.\n          03 FILLER            PIC X(4) VALUE SPACES.\n          03 OUT-ODIOUS        PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           DISPLAY \"     3^   EVIL   ODD\"\n           PERFORM MAKE-LINE 30 TIMES.\n           STOP RUN.\n      \n       MAKE-LINE.\n           MOVE LINE-INDEX TO LINENO.\n           MOVE CUR-POWER-3 TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           MOVE POPCOUNT-OUT TO OUT-POW3.\n           PERFORM FIND-EVIL.\n           MOVE CUR-EVIL-NUM TO OUT-EVIL.\n           PERFORM FIND-ODIOUS.\n           MOVE CUR-ODIOUS-NUM TO OUT-ODIOUS.\n           DISPLAY OUTPUT-FORMAT.\n           MULTIPLY 3 BY CUR-POWER-3.\n           ADD 1 TO CUR-EVIL-NUM.\n           ADD 1 TO CUR-ODIOUS-NUM.\n           ADD 1 TO LINE-INDEX.\n \n       FIND-EVIL.\n           MOVE CUR-EVIL-NUM TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           IF NOT EVIL, ADD 1 TO CUR-EVIL-NUM, GO TO FIND-EVIL.\n\n       FIND-ODIOUS.\n           MOVE CUR-ODIOUS-NUM TO POPCOUNT-IN.\n           PERFORM FIND-POPCOUNT.\n           IF NOT ODIOUS, ADD 1 TO CUR-ODIOUS-NUM, GO TO FIND-ODIOUS.\n       \n       FIND-POPCOUNT.\n           MOVE 0 TO POPCOUNT-OUT.\n           PERFORM PROCESS-BIT UNTIL POPCOUNT-IN IS EQUAL TO ZERO.\n\n       PROCESS-BIT.\n           DIVIDE 2 INTO POPCOUNT-IN.\n           IF BIT-IS-SET, ADD 1 TO POPCOUNT-OUT.\n           MOVE POPCOUNT-REST TO POPCOUNT-IN.\n", "target": ">>> def popcount(n): return bin(n).count(\"1\")\n... \n>>> [popcount(3**i) for i in range(30)]\n[1, 2, 2, 4, 3, 6, 6, 5, 6, 8, 9, 13, 10, 11, 14, 15, 11, 14, 14, 17, 17, 20, 19, 22, 16, 18, 24, 30, 25, 25]\n>>> evil, odious, i = [], [], 0\n>>> while len(evil) < 30 or len(odious) < 30:\n...     p = popcount(i)\n...     if p % 2: odious.append(i)\n...     else: evil.append(i)\n...     i += 1\n... \n>>> evil[:30]\n[0, 3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45, 46, 48, 51, 53, 54, 57, 58]\n>>> odious[:30]\n[1, 2, 4, 7, 8, 11, 13, 14, 16, 19, 21, 22, 25, 26, 28, 31, 32, 35, 37, 38, 41, 42, 44, 47, 49, 50, 52, 55, 56, 59]\n>>>\n"}
{"id": 132893, "name": "Langton's ant", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. langtons-ant.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Grid-Size               VALUE 100.\n       01  grid-area.\n           03  grid-x              OCCURS Grid-Size TIMES.\n               05  grid-y          OCCURS Grid-Size TIMES.\n                   07  cell-colour PIC X VALUE \"W\".\n                       88  black   VALUE \"B\".\n                       88  white   VALUE \"W\".\n\n       01  ant-x                   PIC 999.\n       01  ant-y                   PIC 999.\n\n       01  ant-direction           PIC 9.\n           88  upward              VALUE 0.\n           88  rightward           VALUE 1.\n           88  downward            VALUE 2.\n           88  leftward            VALUE 3.\n\n       78  Pause-Time-Ns           VALUE 10000000.\n\n       01  display-y               PIC 999.\n\n       78  Black-Background        VALUE 0.\n       78  White-Background        VALUE 7.\n\n       01  i                       PIC 999.\n       01  j                       PIC 999.\n\n       01  pause                   PIC X.\n\n       PROCEDURE DIVISION.\n       main-line.\n           DIVIDE Grid-Size BY 2 GIVING ant-x, ant-y\n\n           PERFORM display-initial-grid\n           PERFORM UNTIL (ant-x = Grid-Size OR 0)\n                   OR (ant-y = Grid-Size OR 0)\n               PERFORM step-simulation\n               CALL \"CBL_OC_NANOSLEEP\" USING Pause-Time-Ns\n           END-PERFORM\n\n           DISPLAY \"Press enter to quit.\" AT LINE 1 COLUMN 1\n           ACCEPT pause\n\n           GOBACK\n           .\n       step-simulation.\n           IF black (ant-x, ant-y)\n               SET white (ant-x, ant-y) TO TRUE\n               PERFORM display-ant-cell\n               COMPUTE ant-direction =\n                   FUNCTION MOD(ant-direction + 1, 4)\n           ELSE\n               SET black (ant-x, ant-y) TO TRUE\n               PERFORM display-ant-cell\n               COMPUTE ant-direction =\n                   FUNCTION MOD(ant-direction - 1, 4)\n           END-IF\n\n           EVALUATE TRUE\n               WHEN upward\n                   ADD 1 TO ant-y\n               WHEN rightward\n                   ADD 1 TO ant-x\n               WHEN downward\n                   SUBTRACT 1 FROM ant-y\n               WHEN leftward\n                   SUBTRACT 1 FROM ant-x\n           END-EVALUATE\n           .\n       display-ant-cell.\n               SUBTRACT ant-y FROM Grid-Size GIVING display-y\n               IF black (ant-x, ant-y)\n                   DISPLAY SPACE AT LINE display-y COLUMN ant-x\n                       WITH BACKGROUND-COLOR Black-Background\n               ELSE\n                   DISPLAY SPACE AT LINE display-y COLUMN ant-x\n                      WITH BACKGROUND-COLOR White-Background\n               END-IF\n               .\n       display-initial-grid.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL i > Grid-Size\n                   AFTER j FROM 1 BY 1 UNTIL j > Grid-Size\n               DISPLAY SPACE AT LINE i COLUMN j\n                   WITH BACKGROUND-COLOR White-Background\n           END-PERFORM\n           .\n", "target": "using System;\n\nnamespace LangtonAnt\n{\n    public struct Point\n    {\n        public int X;\n        public int Y;\n\n        public Point(int x, int y)\n        {\n            X = x;\n            Y = y;\n        }\n    }\n\n    enum Direction\n    {\n        North, East, West, South\n    }\n\n    public class Langton\n    {\n        public readonly bool [,] IsBlack;\n        private Point _origin;\n        private Point _antPosition = new Point(0, 0);\n        public bool OutOfBounds { get; set;}\n\n        \n        private Direction _antDirection = Direction.East;\n\n        private readonly Direction[] _leftTurn = new[] { Direction.West, Direction.North, Direction.South, Direction.East };\n        private readonly Direction[] _rightTurn = new[] { Direction.East, Direction.South, Direction.North, Direction.West };\n        private readonly int[] _xInc = new[] { 0, 1,-1, 0};\n        private readonly int[] _yInc = new[] {-1, 0, 0, 1};\n\n        public Langton(int width, int height, Point origin)\n        {\n            _origin = origin;\n            IsBlack = new bool[width, height];\n            OutOfBounds = false;\n        }\n\n        public Langton(int width, int height) : this(width, height, new Point(width / 2, height / 2)) {}\n\n        private void MoveAnt()\n        {\n            _antPosition.X += _xInc[(int)_antDirection];\n            _antPosition.Y += _yInc[(int)_antDirection];\n        }\n\n        public Point Step()\n        {\n            if (OutOfBounds)\n            {\n                throw new InvalidOperationException(\"Trying to step after ant is out of bounds\");\n            }\n            Point ptCur = new Point(_antPosition.X + _origin.X, _antPosition.Y + _origin.Y);\n            bool leftTurn = IsBlack[ptCur.X, ptCur.Y];\n            int iDirection = (int) _antDirection;\n            _antDirection = leftTurn ? _leftTurn[iDirection] : _rightTurn[iDirection];\n            IsBlack[ptCur.X, ptCur.Y] = !IsBlack[ptCur.X, ptCur.Y];\n            MoveAnt();\n            ptCur = new Point(_antPosition.X + _origin.X, _antPosition.Y + _origin.Y);\n            OutOfBounds = \n                ptCur.X < 0 ||\n                ptCur.X >= IsBlack.GetUpperBound(0) ||\n                ptCur.Y < 0 ||\n                ptCur.Y >= IsBlack.GetUpperBound(1);\n            return _antPosition;\n        }\n    }\n    class Program\n    {\n        static void Main()\n        {\n            Langton ant = new Langton(100, 100);\n\n            while (!ant.OutOfBounds) ant.Step();\n\n            for (int iRow = 0; iRow < 100; iRow++)\n            {\n                for (int iCol = 0; iCol < 100; iCol++)\n                {\n                    Console.Write(ant.IsBlack[iCol, iRow] ? \"#\" : \" \");\n                }\n                Console.WriteLine();\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 132895, "name": "Langton's ant", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. langtons-ant.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Grid-Size               VALUE 100.\n       01  grid-area.\n           03  grid-x              OCCURS Grid-Size TIMES.\n               05  grid-y          OCCURS Grid-Size TIMES.\n                   07  cell-colour PIC X VALUE \"W\".\n                       88  black   VALUE \"B\".\n                       88  white   VALUE \"W\".\n\n       01  ant-x                   PIC 999.\n       01  ant-y                   PIC 999.\n\n       01  ant-direction           PIC 9.\n           88  upward              VALUE 0.\n           88  rightward           VALUE 1.\n           88  downward            VALUE 2.\n           88  leftward            VALUE 3.\n\n       78  Pause-Time-Ns           VALUE 10000000.\n\n       01  display-y               PIC 999.\n\n       78  Black-Background        VALUE 0.\n       78  White-Background        VALUE 7.\n\n       01  i                       PIC 999.\n       01  j                       PIC 999.\n\n       01  pause                   PIC X.\n\n       PROCEDURE DIVISION.\n       main-line.\n           DIVIDE Grid-Size BY 2 GIVING ant-x, ant-y\n\n           PERFORM display-initial-grid\n           PERFORM UNTIL (ant-x = Grid-Size OR 0)\n                   OR (ant-y = Grid-Size OR 0)\n               PERFORM step-simulation\n               CALL \"CBL_OC_NANOSLEEP\" USING Pause-Time-Ns\n           END-PERFORM\n\n           DISPLAY \"Press enter to quit.\" AT LINE 1 COLUMN 1\n           ACCEPT pause\n\n           GOBACK\n           .\n       step-simulation.\n           IF black (ant-x, ant-y)\n               SET white (ant-x, ant-y) TO TRUE\n               PERFORM display-ant-cell\n               COMPUTE ant-direction =\n                   FUNCTION MOD(ant-direction + 1, 4)\n           ELSE\n               SET black (ant-x, ant-y) TO TRUE\n               PERFORM display-ant-cell\n               COMPUTE ant-direction =\n                   FUNCTION MOD(ant-direction - 1, 4)\n           END-IF\n\n           EVALUATE TRUE\n               WHEN upward\n                   ADD 1 TO ant-y\n               WHEN rightward\n                   ADD 1 TO ant-x\n               WHEN downward\n                   SUBTRACT 1 FROM ant-y\n               WHEN leftward\n                   SUBTRACT 1 FROM ant-x\n           END-EVALUATE\n           .\n       display-ant-cell.\n               SUBTRACT ant-y FROM Grid-Size GIVING display-y\n               IF black (ant-x, ant-y)\n                   DISPLAY SPACE AT LINE display-y COLUMN ant-x\n                       WITH BACKGROUND-COLOR Black-Background\n               ELSE\n                   DISPLAY SPACE AT LINE display-y COLUMN ant-x\n                      WITH BACKGROUND-COLOR White-Background\n               END-IF\n               .\n       display-initial-grid.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL i > Grid-Size\n                   AFTER j FROM 1 BY 1 UNTIL j > Grid-Size\n               DISPLAY SPACE AT LINE i COLUMN j\n                   WITH BACKGROUND-COLOR White-Background\n           END-PERFORM\n           .\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\npublic class Langton extends JFrame{\n\tprivate JPanel planePanel;\n\tprivate static final int ZOOM = 4;\n\t\n\tpublic Langton(final boolean[][] plane){\n\t\tplanePanel = new JPanel(){\n\t\t\t@Override\n\t\t\tpublic void paint(Graphics g) {\n\t\t\t\tfor(int y = 0; y < plane.length;y++){\n\t\t\t\t\tfor(int x = 0; x < plane[0].length;x++){\n\t\t\t\t\t\tg.setColor(plane[y][x] ? Color.BLACK : Color.WHITE);\n\t\t\t\t\t\tg.fillRect(x * ZOOM, y * ZOOM, ZOOM, ZOOM);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tg.setColor(Color.GREEN);\n\t\t\t\tg.fillRect(plane[0].length / 2 * ZOOM,\n\t\t\t\t           plane.length / 2 * ZOOM, ZOOM/2, ZOOM/2);\n\t\t\t}\n\t\t};\n\t\tplanePanel.setSize(plane[0].length - 1, plane.length - 1);\n\t\tadd(planePanel);\n\t\tsetSize(ZOOM * plane[0].length, ZOOM * plane.length + 30);\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetVisible(true);\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tnew Langton(runAnt(100, 100));\n\t}\n\n\tprivate static boolean[][] runAnt(int height, int width){\n\t\tboolean[][] plane = new boolean[height][width];\n\t\tint antX = width/2, antY = height/2;\n\t\tint xChange = 0, yChange = -1; \n\t\twhile(antX < width && antY < height && antX >= 0 && antY >= 0){\n\t\t\tif(plane[antY][antX]){\n\t\t\t\t\n\t\t\t\tif(xChange == 0){ \n\t\t\t\t\txChange = yChange;\n\t\t\t\t\tyChange = 0;\n\t\t\t\t}else{ \n\t\t\t\t\tyChange = -xChange;\n\t\t\t\t\txChange = 0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\n\t\t\t\tif(xChange == 0){ \n\t\t\t\t\txChange = -yChange;\n\t\t\t\t\tyChange = 0;\n\t\t\t\t}else{ \n\t\t\t\t\tyChange = xChange;\n\t\t\t\t\txChange = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tplane[antY][antX] = !plane[antY][antX];\n\t\t\tantX += xChange;\n\t\t\tantY += yChange;\n\t\t}\n\t\treturn plane;\n\t}\n}\n"}
{"id": 132896, "name": "Langton's ant", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. langtons-ant.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Grid-Size               VALUE 100.\n       01  grid-area.\n           03  grid-x              OCCURS Grid-Size TIMES.\n               05  grid-y          OCCURS Grid-Size TIMES.\n                   07  cell-colour PIC X VALUE \"W\".\n                       88  black   VALUE \"B\".\n                       88  white   VALUE \"W\".\n\n       01  ant-x                   PIC 999.\n       01  ant-y                   PIC 999.\n\n       01  ant-direction           PIC 9.\n           88  upward              VALUE 0.\n           88  rightward           VALUE 1.\n           88  downward            VALUE 2.\n           88  leftward            VALUE 3.\n\n       78  Pause-Time-Ns           VALUE 10000000.\n\n       01  display-y               PIC 999.\n\n       78  Black-Background        VALUE 0.\n       78  White-Background        VALUE 7.\n\n       01  i                       PIC 999.\n       01  j                       PIC 999.\n\n       01  pause                   PIC X.\n\n       PROCEDURE DIVISION.\n       main-line.\n           DIVIDE Grid-Size BY 2 GIVING ant-x, ant-y\n\n           PERFORM display-initial-grid\n           PERFORM UNTIL (ant-x = Grid-Size OR 0)\n                   OR (ant-y = Grid-Size OR 0)\n               PERFORM step-simulation\n               CALL \"CBL_OC_NANOSLEEP\" USING Pause-Time-Ns\n           END-PERFORM\n\n           DISPLAY \"Press enter to quit.\" AT LINE 1 COLUMN 1\n           ACCEPT pause\n\n           GOBACK\n           .\n       step-simulation.\n           IF black (ant-x, ant-y)\n               SET white (ant-x, ant-y) TO TRUE\n               PERFORM display-ant-cell\n               COMPUTE ant-direction =\n                   FUNCTION MOD(ant-direction + 1, 4)\n           ELSE\n               SET black (ant-x, ant-y) TO TRUE\n               PERFORM display-ant-cell\n               COMPUTE ant-direction =\n                   FUNCTION MOD(ant-direction - 1, 4)\n           END-IF\n\n           EVALUATE TRUE\n               WHEN upward\n                   ADD 1 TO ant-y\n               WHEN rightward\n                   ADD 1 TO ant-x\n               WHEN downward\n                   SUBTRACT 1 FROM ant-y\n               WHEN leftward\n                   SUBTRACT 1 FROM ant-x\n           END-EVALUATE\n           .\n       display-ant-cell.\n               SUBTRACT ant-y FROM Grid-Size GIVING display-y\n               IF black (ant-x, ant-y)\n                   DISPLAY SPACE AT LINE display-y COLUMN ant-x\n                       WITH BACKGROUND-COLOR Black-Background\n               ELSE\n                   DISPLAY SPACE AT LINE display-y COLUMN ant-x\n                      WITH BACKGROUND-COLOR White-Background\n               END-IF\n               .\n       display-initial-grid.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL i > Grid-Size\n                   AFTER j FROM 1 BY 1 UNTIL j > Grid-Size\n               DISPLAY SPACE AT LINE i COLUMN j\n                   WITH BACKGROUND-COLOR White-Background\n           END-PERFORM\n           .\n", "target": "\n\n\n\n\n\nSTEP = 100\ncount = 0\n\ndef setup():\n    global x, y, direction\n\n    \n    \n    size(100, 100, P2D)\n\n    background(255)\n    x = width / 2\n    y = height / 2\n    direction = 0\n\ndef draw():\n    global count\n    for i in range(STEP):\n        count += 1\n        pix = get(x, y) != -1 \n        setBool(x, y, pix)\n\n        turn(pix)\n        move()\n\n        if (x < 0 or y < 0 or x >= width or y >= height):\n            println(\"finished\")\n            noLoop()\n            break\n\n    if count % 1000 == 0:\n        println(\"iteration {}\".format(count))\n\ndef move():\n    global x, y\n    if direction == 0:\n        y -= 1\n    elif direction == 1:\n        x -= 1\n    elif direction == 2:\n        y += 1\n    elif direction == 3:\n        x += 1\n\ndef turn(rightleft):\n    global direction\n    direction += 1 if rightleft else -1\n    if direction == -1:\n        direction = 3\n    if direction == 4:\n        direction = 0\n\ndef setBool(x, y, white):\n    set(x, y, -1 if white else 0)\n"}
{"id": 133496, "name": "Pangram checker", "source": "Translate COBOL to C#:        identification division.\n       program-id. pan-test.\n       data division.\n       working-storage section.\n       1 text-string pic x(80).\n       1 len binary pic 9(4).\n       1 trailing-spaces binary pic 9(4).\n       1 pangram-flag pic x value \"n\".\n        88 is-not-pangram value \"n\".\n        88 is-pangram value \"y\".\n       procedure division.\n       begin.\n           display \"Enter text string:\"\n           accept text-string\n           set is-not-pangram to true\n           initialize trailing-spaces len\n           inspect function reverse (text-string)\n           tallying trailing-spaces for leading space\n               len for characters after space\n           call \"pangram\" using pangram-flag len text-string\n           cancel \"pangram\"\n           if is-pangram\n               display \"is a pangram\"\n           else\n               display \"is not a pangram\"\n           end-if\n           stop run\n           .\n       end program pan-test.\n\n       identification division.\n       program-id. pangram.\n       data division.\n       1 lc-alphabet pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n       linkage section.\n       1 pangram-flag pic x.\n        88 is-not-pangram value \"n\".\n        88 is-pangram value \"y\".\n       1 len binary pic 9(4).\n       1 text-string pic x(80).\n       procedure division using pangram-flag len text-string.\n       begin.\n           inspect lc-alphabet converting\n               function lower-case (text-string (1:len))\n               to space\n           if lc-alphabet = space\n               set is-pangram to true\n           end-if\n           exit program\n           .\n       end program pangram.\n", "target": "using System;\nusing System.Linq;\n\nstatic class Program\n{\n    static bool IsPangram(this string text, string alphabet = \"abcdefghijklmnopqrstuvwxyz\")\n    {\n        return alphabet.All(text.ToLower().Contains);\n    }\n\n    static void Main(string[] arguments)\n    {\n        Console.WriteLine(arguments.Any() && arguments.First().IsPangram());\n    }\n}\n"}
{"id": 133497, "name": "Pangram checker", "source": "Translate COBOL to C#:        identification division.\n       program-id. pan-test.\n       data division.\n       working-storage section.\n       1 text-string pic x(80).\n       1 len binary pic 9(4).\n       1 trailing-spaces binary pic 9(4).\n       1 pangram-flag pic x value \"n\".\n        88 is-not-pangram value \"n\".\n        88 is-pangram value \"y\".\n       procedure division.\n       begin.\n           display \"Enter text string:\"\n           accept text-string\n           set is-not-pangram to true\n           initialize trailing-spaces len\n           inspect function reverse (text-string)\n           tallying trailing-spaces for leading space\n               len for characters after space\n           call \"pangram\" using pangram-flag len text-string\n           cancel \"pangram\"\n           if is-pangram\n               display \"is a pangram\"\n           else\n               display \"is not a pangram\"\n           end-if\n           stop run\n           .\n       end program pan-test.\n\n       identification division.\n       program-id. pangram.\n       data division.\n       1 lc-alphabet pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n       linkage section.\n       1 pangram-flag pic x.\n        88 is-not-pangram value \"n\".\n        88 is-pangram value \"y\".\n       1 len binary pic 9(4).\n       1 text-string pic x(80).\n       procedure division using pangram-flag len text-string.\n       begin.\n           inspect lc-alphabet converting\n               function lower-case (text-string (1:len))\n               to space\n           if lc-alphabet = space\n               set is-pangram to true\n           end-if\n           exit program\n           .\n       end program pangram.\n", "target": "using System;\nusing System.Linq;\n\nstatic class Program\n{\n    static bool IsPangram(this string text, string alphabet = \"abcdefghijklmnopqrstuvwxyz\")\n    {\n        return alphabet.All(text.ToLower().Contains);\n    }\n\n    static void Main(string[] arguments)\n    {\n        Console.WriteLine(arguments.Any() && arguments.First().IsPangram());\n    }\n}\n"}
{"id": 133500, "name": "Pangram checker", "source": "Translate COBOL to Java:        identification division.\n       program-id. pan-test.\n       data division.\n       working-storage section.\n       1 text-string pic x(80).\n       1 len binary pic 9(4).\n       1 trailing-spaces binary pic 9(4).\n       1 pangram-flag pic x value \"n\".\n        88 is-not-pangram value \"n\".\n        88 is-pangram value \"y\".\n       procedure division.\n       begin.\n           display \"Enter text string:\"\n           accept text-string\n           set is-not-pangram to true\n           initialize trailing-spaces len\n           inspect function reverse (text-string)\n           tallying trailing-spaces for leading space\n               len for characters after space\n           call \"pangram\" using pangram-flag len text-string\n           cancel \"pangram\"\n           if is-pangram\n               display \"is a pangram\"\n           else\n               display \"is not a pangram\"\n           end-if\n           stop run\n           .\n       end program pan-test.\n\n       identification division.\n       program-id. pangram.\n       data division.\n       1 lc-alphabet pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n       linkage section.\n       1 pangram-flag pic x.\n        88 is-not-pangram value \"n\".\n        88 is-pangram value \"y\".\n       1 len binary pic 9(4).\n       1 text-string pic x(80).\n       procedure division using pangram-flag len text-string.\n       begin.\n           inspect lc-alphabet converting\n               function lower-case (text-string (1:len))\n               to space\n           if lc-alphabet = space\n               set is-pangram to true\n           end-if\n           exit program\n           .\n       end program pangram.\n", "target": "public class Pangram {\n    public static boolean isPangram(String test){\n        for (char a = 'A'; a <= 'Z'; a++)\n            if ((test.indexOf(a) < 0) && (test.indexOf((char)(a + 32)) < 0))\n                return false;\n        return true;\n    }\n\n    public static void main(String[] args){\n        System.out.println(isPangram(\"the quick brown fox jumps over the lazy dog\"));\n        System.out.println(isPangram(\"the quick brown fox jumped over the lazy dog\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKLMNOPQSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKL.NOPQRSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABC.D.E.FGHI*J/KL-M+NO*PQ R\\nSTUVWXYZ\"));\n        System.out.println(isPangram(\"\"));\n    }\n}\n"}
{"id": 133501, "name": "Pangram checker", "source": "Translate COBOL to Java:        identification division.\n       program-id. pan-test.\n       data division.\n       working-storage section.\n       1 text-string pic x(80).\n       1 len binary pic 9(4).\n       1 trailing-spaces binary pic 9(4).\n       1 pangram-flag pic x value \"n\".\n        88 is-not-pangram value \"n\".\n        88 is-pangram value \"y\".\n       procedure division.\n       begin.\n           display \"Enter text string:\"\n           accept text-string\n           set is-not-pangram to true\n           initialize trailing-spaces len\n           inspect function reverse (text-string)\n           tallying trailing-spaces for leading space\n               len for characters after space\n           call \"pangram\" using pangram-flag len text-string\n           cancel \"pangram\"\n           if is-pangram\n               display \"is a pangram\"\n           else\n               display \"is not a pangram\"\n           end-if\n           stop run\n           .\n       end program pan-test.\n\n       identification division.\n       program-id. pangram.\n       data division.\n       1 lc-alphabet pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n       linkage section.\n       1 pangram-flag pic x.\n        88 is-not-pangram value \"n\".\n        88 is-pangram value \"y\".\n       1 len binary pic 9(4).\n       1 text-string pic x(80).\n       procedure division using pangram-flag len text-string.\n       begin.\n           inspect lc-alphabet converting\n               function lower-case (text-string (1:len))\n               to space\n           if lc-alphabet = space\n               set is-pangram to true\n           end-if\n           exit program\n           .\n       end program pangram.\n", "target": "public class Pangram {\n    public static boolean isPangram(String test){\n        for (char a = 'A'; a <= 'Z'; a++)\n            if ((test.indexOf(a) < 0) && (test.indexOf((char)(a + 32)) < 0))\n                return false;\n        return true;\n    }\n\n    public static void main(String[] args){\n        System.out.println(isPangram(\"the quick brown fox jumps over the lazy dog\"));\n        System.out.println(isPangram(\"the quick brown fox jumped over the lazy dog\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKLMNOPQSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKL.NOPQRSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABC.D.E.FGHI*J/KL-M+NO*PQ R\\nSTUVWXYZ\"));\n        System.out.println(isPangram(\"\"));\n    }\n}\n"}
{"id": 133502, "name": "Pangram checker", "source": "Translate COBOL to Python:        identification division.\n       program-id. pan-test.\n       data division.\n       working-storage section.\n       1 text-string pic x(80).\n       1 len binary pic 9(4).\n       1 trailing-spaces binary pic 9(4).\n       1 pangram-flag pic x value \"n\".\n        88 is-not-pangram value \"n\".\n        88 is-pangram value \"y\".\n       procedure division.\n       begin.\n           display \"Enter text string:\"\n           accept text-string\n           set is-not-pangram to true\n           initialize trailing-spaces len\n           inspect function reverse (text-string)\n           tallying trailing-spaces for leading space\n               len for characters after space\n           call \"pangram\" using pangram-flag len text-string\n           cancel \"pangram\"\n           if is-pangram\n               display \"is a pangram\"\n           else\n               display \"is not a pangram\"\n           end-if\n           stop run\n           .\n       end program pan-test.\n\n       identification division.\n       program-id. pangram.\n       data division.\n       1 lc-alphabet pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n       linkage section.\n       1 pangram-flag pic x.\n        88 is-not-pangram value \"n\".\n        88 is-pangram value \"y\".\n       1 len binary pic 9(4).\n       1 text-string pic x(80).\n       procedure division using pangram-flag len text-string.\n       begin.\n           inspect lc-alphabet converting\n               function lower-case (text-string (1:len))\n               to space\n           if lc-alphabet = space\n               set is-pangram to true\n           end-if\n           exit program\n           .\n       end program pangram.\n", "target": "import string, sys\nif sys.version_info[0] < 3:\n    input = raw_input\n\ndef ispangram(sentence, alphabet=string.ascii_lowercase):\n    alphaset = set(alphabet)\n    return alphaset <= set(sentence.lower())\n\nprint ( ispangram(input('Sentence: ')) )\n"}
{"id": 133503, "name": "Pangram checker", "source": "Translate COBOL to Python:        identification division.\n       program-id. pan-test.\n       data division.\n       working-storage section.\n       1 text-string pic x(80).\n       1 len binary pic 9(4).\n       1 trailing-spaces binary pic 9(4).\n       1 pangram-flag pic x value \"n\".\n        88 is-not-pangram value \"n\".\n        88 is-pangram value \"y\".\n       procedure division.\n       begin.\n           display \"Enter text string:\"\n           accept text-string\n           set is-not-pangram to true\n           initialize trailing-spaces len\n           inspect function reverse (text-string)\n           tallying trailing-spaces for leading space\n               len for characters after space\n           call \"pangram\" using pangram-flag len text-string\n           cancel \"pangram\"\n           if is-pangram\n               display \"is a pangram\"\n           else\n               display \"is not a pangram\"\n           end-if\n           stop run\n           .\n       end program pan-test.\n\n       identification division.\n       program-id. pangram.\n       data division.\n       1 lc-alphabet pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n       linkage section.\n       1 pangram-flag pic x.\n        88 is-not-pangram value \"n\".\n        88 is-pangram value \"y\".\n       1 len binary pic 9(4).\n       1 text-string pic x(80).\n       procedure division using pangram-flag len text-string.\n       begin.\n           inspect lc-alphabet converting\n               function lower-case (text-string (1:len))\n               to space\n           if lc-alphabet = space\n               set is-pangram to true\n           end-if\n           exit program\n           .\n       end program pangram.\n", "target": "import string, sys\nif sys.version_info[0] < 3:\n    input = raw_input\n\ndef ispangram(sentence, alphabet=string.ascii_lowercase):\n    alphaset = set(alphabet)\n    return alphaset <= set(sentence.lower())\n\nprint ( ispangram(input('Sentence: ')) )\n"}
{"id": 134472, "name": "Empty string", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.    EMPTYSTR.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  str                     PIC X(10).\n\n       PROCEDURE DIVISION.\n       Begin.\n\n*     *    Assign an empty string.\n           INITIALIZE str.\n\n*     *    Or\n           MOVE \" \" TO str.\n\n           IF (str = \" \")\n              DISPLAY \"String is empty\"\n           ELSE\n              DISPLAY \"String is not empty\"\n           END-IF.\n\n           STOP RUN.\n", "target": "using System;\n\nnamespace EmptyString\n{\n  class Program\n  {\n    public static void Main()\n    {\n      String s = scope .();\n      if (s.IsEmpty)\n      {\n        Console.Writeln(\"string empty\");\n      }\n      if (!s.IsEmpty)\n      {\n        Console.Writeln(\"string not empty\");\n      }\n    }\n  }\n}\n"}
{"id": 134473, "name": "Empty string", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.    EMPTYSTR.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  str                     PIC X(10).\n\n       PROCEDURE DIVISION.\n       Begin.\n\n*     *    Assign an empty string.\n           INITIALIZE str.\n\n*     *    Or\n           MOVE \" \" TO str.\n\n           IF (str = \" \")\n              DISPLAY \"String is empty\"\n           ELSE\n              DISPLAY \"String is not empty\"\n           END-IF.\n\n           STOP RUN.\n", "target": "using System;\n\nnamespace EmptyString\n{\n  class Program\n  {\n    public static void Main()\n    {\n      String s = scope .();\n      if (s.IsEmpty)\n      {\n        Console.Writeln(\"string empty\");\n      }\n      if (!s.IsEmpty)\n      {\n        Console.Writeln(\"string not empty\");\n      }\n    }\n  }\n}\n"}
{"id": 134476, "name": "Empty string", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.    EMPTYSTR.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  str                     PIC X(10).\n\n       PROCEDURE DIVISION.\n       Begin.\n\n*     *    Assign an empty string.\n           INITIALIZE str.\n\n*     *    Or\n           MOVE \" \" TO str.\n\n           IF (str = \" \")\n              DISPLAY \"String is empty\"\n           ELSE\n              DISPLAY \"String is not empty\"\n           END-IF.\n\n           STOP RUN.\n", "target": "String s = \"\";\nif(s != null && s.isEmpty()){\n   System.out.println(\"s is empty\");\n}else{\n   System.out.println(\"s is not empty\");\n}\n"}
{"id": 134477, "name": "Empty string", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.    EMPTYSTR.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  str                     PIC X(10).\n\n       PROCEDURE DIVISION.\n       Begin.\n\n*     *    Assign an empty string.\n           INITIALIZE str.\n\n*     *    Or\n           MOVE \" \" TO str.\n\n           IF (str = \" \")\n              DISPLAY \"String is empty\"\n           ELSE\n              DISPLAY \"String is not empty\"\n           END-IF.\n\n           STOP RUN.\n", "target": "String s = \"\";\nif(s != null && s.isEmpty()){\n   System.out.println(\"s is empty\");\n}else{\n   System.out.println(\"s is not empty\");\n}\n"}
{"id": 134478, "name": "Empty string", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.    EMPTYSTR.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  str                     PIC X(10).\n\n       PROCEDURE DIVISION.\n       Begin.\n\n*     *    Assign an empty string.\n           INITIALIZE str.\n\n*     *    Or\n           MOVE \" \" TO str.\n\n           IF (str = \" \")\n              DISPLAY \"String is empty\"\n           ELSE\n              DISPLAY \"String is not empty\"\n           END-IF.\n\n           STOP RUN.\n", "target": "s = ''\n\ns = str()\n\nif not s or s == '':\n   print(\"String is empty\")\n\nif len(s) == 0:\n    print(\"String is empty\")\nelse:\n    print(\"String not empty\")\n\n\n\n\n\n\ndef emptystring(s):\n   if isinstance(s, (''.__class__ , u''.__class__) ):\n      if len(s) == 0: \n         return True\n      else \n         return False\n\n   elif s is None:\n        return True\n"}
{"id": 134479, "name": "Empty string", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.    EMPTYSTR.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  str                     PIC X(10).\n\n       PROCEDURE DIVISION.\n       Begin.\n\n*     *    Assign an empty string.\n           INITIALIZE str.\n\n*     *    Or\n           MOVE \" \" TO str.\n\n           IF (str = \" \")\n              DISPLAY \"String is empty\"\n           ELSE\n              DISPLAY \"String is not empty\"\n           END-IF.\n\n           STOP RUN.\n", "target": "s = ''\n\ns = str()\n\nif not s or s == '':\n   print(\"String is empty\")\n\nif len(s) == 0:\n    print(\"String is empty\")\nelse:\n    print(\"String not empty\")\n\n\n\n\n\n\ndef emptystring(s):\n   if isinstance(s, (''.__class__ , u''.__class__) ):\n      if len(s) == 0: \n         return True\n      else \n         return False\n\n   elif s is None:\n        return True\n"}
{"id": 136008, "name": "Pernicious numbers", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. PERNICIOUS-NUMBERS.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 AMOUNT             PIC 99.\n          03 CAND               PIC 9(9).\n          03 POPCOUNT           PIC 99.\n          03 POP-N              PIC 9(9).\n          03 FILLER             REDEFINES POP-N.\n             05 FILLER          PIC 9(8).\n             05 FILLER          PIC 9.\n                88 ODD          VALUES 1, 3, 5, 7, 9.\n          03 DSOR               PIC 99.\n          03 DIV-RSLT           PIC 99V99.\n          03 FILLER             REDEFINES DIV-RSLT.\n             05 FILLER          PIC 99.\n             05 FILLER          PIC 99.\n                88 DIVISIBLE    VALUE ZERO.\n          03 PRIME-FLAG         PIC X.\n             88 PRIME           VALUE '*'.\n       \n       01 FORMAT.\n          03 SIZE-FLAG          PIC X.\n             88 SMALL           VALUE 'S'.\n             88 LARGE           VALUE 'L'.\n          03 SMALL-NUM          PIC ZZ9.\n          03 LARGE-NUM          PIC Z(9)9.\n          03 OUT-STR            PIC X(80).\n          03 OUT-PTR            PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SMALL-PERNICIOUS.\n           PERFORM LARGE-PERNICIOUS.\n           STOP RUN.\n           \n       INIT-OUTPUT-VARS.\n           MOVE ZERO TO AMOUNT.\n           MOVE 1 TO OUT-PTR.\n           MOVE SPACES TO OUT-STR.\n           \n       SMALL-PERNICIOUS.\n           PERFORM INIT-OUTPUT-VARS.\n           MOVE 'S' TO SIZE-FLAG.\n           PERFORM ADD-PERNICIOUS\n               VARYING CAND FROM 1 BY 1 UNTIL AMOUNT IS EQUAL TO 25.\n           DISPLAY OUT-STR.\n\n       LARGE-PERNICIOUS.\n           PERFORM INIT-OUTPUT-VARS.\n           MOVE 'L' TO SIZE-FLAG.\n           PERFORM ADD-PERNICIOUS\n               VARYING CAND FROM 888888877 BY 1\n               UNTIL CAND IS GREATER THAN 888888888.\n           DISPLAY OUT-STR.\n       \n       ADD-NUM.\n           ADD 1 TO AMOUNT.\n           IF SMALL,\n               MOVE CAND TO SMALL-NUM,\n               STRING SMALL-NUM DELIMITED BY SIZE INTO OUT-STR\n               WITH POINTER OUT-PTR.\n           IF LARGE,\n               MOVE CAND TO LARGE-NUM,\n               STRING LARGE-NUM DELIMITED BY SIZE INTO OUT-STR\n               WITH POINTER OUT-PTR.\n       \n       ADD-PERNICIOUS.\n           PERFORM FIND-POPCOUNT.\n           PERFORM CHECK-PRIME.\n           IF PRIME, PERFORM ADD-NUM.\n           \n       FIND-POPCOUNT.\n           MOVE ZERO TO POPCOUNT.\n           MOVE CAND TO POP-N.\n           PERFORM COUNT-BIT UNTIL POP-N IS EQUAL TO ZERO.\n        \n       COUNT-BIT.\n           IF ODD, ADD 1 TO POPCOUNT.\n           DIVIDE 2 INTO POP-N.\n       \n       CHECK-PRIME.\n           IF POPCOUNT IS LESS THAN 2,\n               MOVE SPACE TO PRIME-FLAG\n           ELSE\n               MOVE '*' TO PRIME-FLAG.\n           PERFORM CHECK-DSOR VARYING DSOR FROM 2 BY 1\n               UNTIL NOT PRIME OR DSOR IS NOT LESS THAN POPCOUNT.\n\n       CHECK-DSOR.\n           DIVIDE POPCOUNT BY DSOR GIVING DIV-RSLT.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n", "target": "using System;\nusing System.Linq;\n\nnamespace PerniciousNumbers\n{\n    class Program\n    {\n        public static int PopulationCount(long n)\n        {\n            int cnt = 0;\n            do\n            {\n                if ((n & 1) != 0) \n                {\n                    cnt++;\n                }\n            } while ((n >>= 1) > 0);\n\n            return cnt;\n        }\n\n         public static bool isPrime(int x)\n        {\n            if (x <= 2 || (x & 1) == 0)\n            {\n                return x == 2;\n            }\n\n            var limit = Math.Sqrt(x);\n            for (int i = 3; i <= limit; i += 2)\n            {\n                if (x % i == 0)\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static IEnumerable<int> Pernicious(int start, int count, int take)\n        {\n            return Enumerable.Range(start, count).Where(n => isPrime(PopulationCount(n))).Take(take);\n        }\n\n        static void Main(string[] args)\n        {\n            foreach (var n in Pernicious(0, int.MaxValue, 25))\n            {\n                Console.Write(\"{0} \", n);\n            }\n\n            Console.WriteLine();\n\n            foreach (var n in Pernicious(888888877, 11, 11))\n            {\n                Console.Write(\"{0} \", n);\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 136010, "name": "Pernicious numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. PERNICIOUS-NUMBERS.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 AMOUNT             PIC 99.\n          03 CAND               PIC 9(9).\n          03 POPCOUNT           PIC 99.\n          03 POP-N              PIC 9(9).\n          03 FILLER             REDEFINES POP-N.\n             05 FILLER          PIC 9(8).\n             05 FILLER          PIC 9.\n                88 ODD          VALUES 1, 3, 5, 7, 9.\n          03 DSOR               PIC 99.\n          03 DIV-RSLT           PIC 99V99.\n          03 FILLER             REDEFINES DIV-RSLT.\n             05 FILLER          PIC 99.\n             05 FILLER          PIC 99.\n                88 DIVISIBLE    VALUE ZERO.\n          03 PRIME-FLAG         PIC X.\n             88 PRIME           VALUE '*'.\n       \n       01 FORMAT.\n          03 SIZE-FLAG          PIC X.\n             88 SMALL           VALUE 'S'.\n             88 LARGE           VALUE 'L'.\n          03 SMALL-NUM          PIC ZZ9.\n          03 LARGE-NUM          PIC Z(9)9.\n          03 OUT-STR            PIC X(80).\n          03 OUT-PTR            PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SMALL-PERNICIOUS.\n           PERFORM LARGE-PERNICIOUS.\n           STOP RUN.\n           \n       INIT-OUTPUT-VARS.\n           MOVE ZERO TO AMOUNT.\n           MOVE 1 TO OUT-PTR.\n           MOVE SPACES TO OUT-STR.\n           \n       SMALL-PERNICIOUS.\n           PERFORM INIT-OUTPUT-VARS.\n           MOVE 'S' TO SIZE-FLAG.\n           PERFORM ADD-PERNICIOUS\n               VARYING CAND FROM 1 BY 1 UNTIL AMOUNT IS EQUAL TO 25.\n           DISPLAY OUT-STR.\n\n       LARGE-PERNICIOUS.\n           PERFORM INIT-OUTPUT-VARS.\n           MOVE 'L' TO SIZE-FLAG.\n           PERFORM ADD-PERNICIOUS\n               VARYING CAND FROM 888888877 BY 1\n               UNTIL CAND IS GREATER THAN 888888888.\n           DISPLAY OUT-STR.\n       \n       ADD-NUM.\n           ADD 1 TO AMOUNT.\n           IF SMALL,\n               MOVE CAND TO SMALL-NUM,\n               STRING SMALL-NUM DELIMITED BY SIZE INTO OUT-STR\n               WITH POINTER OUT-PTR.\n           IF LARGE,\n               MOVE CAND TO LARGE-NUM,\n               STRING LARGE-NUM DELIMITED BY SIZE INTO OUT-STR\n               WITH POINTER OUT-PTR.\n       \n       ADD-PERNICIOUS.\n           PERFORM FIND-POPCOUNT.\n           PERFORM CHECK-PRIME.\n           IF PRIME, PERFORM ADD-NUM.\n           \n       FIND-POPCOUNT.\n           MOVE ZERO TO POPCOUNT.\n           MOVE CAND TO POP-N.\n           PERFORM COUNT-BIT UNTIL POP-N IS EQUAL TO ZERO.\n        \n       COUNT-BIT.\n           IF ODD, ADD 1 TO POPCOUNT.\n           DIVIDE 2 INTO POP-N.\n       \n       CHECK-PRIME.\n           IF POPCOUNT IS LESS THAN 2,\n               MOVE SPACE TO PRIME-FLAG\n           ELSE\n               MOVE '*' TO PRIME-FLAG.\n           PERFORM CHECK-DSOR VARYING DSOR FROM 2 BY 1\n               UNTIL NOT PRIME OR DSOR IS NOT LESS THAN POPCOUNT.\n\n       CHECK-DSOR.\n           DIVIDE POPCOUNT BY DSOR GIVING DIV-RSLT.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n", "target": "public class Pernicious{\n    \n    public static boolean isPrime(int x){\n        if(x < 2) return false;\n        for(int i = 2; i < x; i++){\n            if(x % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static int popCount(long x){\n        return Long.bitCount(x);\n    }\n\n    public static void main(String[] args){\n        for(long i = 1, n = 0; n < 25; i++){\n            if(isPrime(popCount(i))){\n                System.out.print(i + \" \");\n                n++;\n            }\n        }\n        \n        System.out.println();\n        \n        for(long i = 888888877; i <= 888888888; i++){\n            if(isPrime(popCount(i))) System.out.print(i + \" \");\n        }\n    }\n}\n"}
{"id": 136011, "name": "Pernicious numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. PERNICIOUS-NUMBERS.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 AMOUNT             PIC 99.\n          03 CAND               PIC 9(9).\n          03 POPCOUNT           PIC 99.\n          03 POP-N              PIC 9(9).\n          03 FILLER             REDEFINES POP-N.\n             05 FILLER          PIC 9(8).\n             05 FILLER          PIC 9.\n                88 ODD          VALUES 1, 3, 5, 7, 9.\n          03 DSOR               PIC 99.\n          03 DIV-RSLT           PIC 99V99.\n          03 FILLER             REDEFINES DIV-RSLT.\n             05 FILLER          PIC 99.\n             05 FILLER          PIC 99.\n                88 DIVISIBLE    VALUE ZERO.\n          03 PRIME-FLAG         PIC X.\n             88 PRIME           VALUE '*'.\n       \n       01 FORMAT.\n          03 SIZE-FLAG          PIC X.\n             88 SMALL           VALUE 'S'.\n             88 LARGE           VALUE 'L'.\n          03 SMALL-NUM          PIC ZZ9.\n          03 LARGE-NUM          PIC Z(9)9.\n          03 OUT-STR            PIC X(80).\n          03 OUT-PTR            PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SMALL-PERNICIOUS.\n           PERFORM LARGE-PERNICIOUS.\n           STOP RUN.\n           \n       INIT-OUTPUT-VARS.\n           MOVE ZERO TO AMOUNT.\n           MOVE 1 TO OUT-PTR.\n           MOVE SPACES TO OUT-STR.\n           \n       SMALL-PERNICIOUS.\n           PERFORM INIT-OUTPUT-VARS.\n           MOVE 'S' TO SIZE-FLAG.\n           PERFORM ADD-PERNICIOUS\n               VARYING CAND FROM 1 BY 1 UNTIL AMOUNT IS EQUAL TO 25.\n           DISPLAY OUT-STR.\n\n       LARGE-PERNICIOUS.\n           PERFORM INIT-OUTPUT-VARS.\n           MOVE 'L' TO SIZE-FLAG.\n           PERFORM ADD-PERNICIOUS\n               VARYING CAND FROM 888888877 BY 1\n               UNTIL CAND IS GREATER THAN 888888888.\n           DISPLAY OUT-STR.\n       \n       ADD-NUM.\n           ADD 1 TO AMOUNT.\n           IF SMALL,\n               MOVE CAND TO SMALL-NUM,\n               STRING SMALL-NUM DELIMITED BY SIZE INTO OUT-STR\n               WITH POINTER OUT-PTR.\n           IF LARGE,\n               MOVE CAND TO LARGE-NUM,\n               STRING LARGE-NUM DELIMITED BY SIZE INTO OUT-STR\n               WITH POINTER OUT-PTR.\n       \n       ADD-PERNICIOUS.\n           PERFORM FIND-POPCOUNT.\n           PERFORM CHECK-PRIME.\n           IF PRIME, PERFORM ADD-NUM.\n           \n       FIND-POPCOUNT.\n           MOVE ZERO TO POPCOUNT.\n           MOVE CAND TO POP-N.\n           PERFORM COUNT-BIT UNTIL POP-N IS EQUAL TO ZERO.\n        \n       COUNT-BIT.\n           IF ODD, ADD 1 TO POPCOUNT.\n           DIVIDE 2 INTO POP-N.\n       \n       CHECK-PRIME.\n           IF POPCOUNT IS LESS THAN 2,\n               MOVE SPACE TO PRIME-FLAG\n           ELSE\n               MOVE '*' TO PRIME-FLAG.\n           PERFORM CHECK-DSOR VARYING DSOR FROM 2 BY 1\n               UNTIL NOT PRIME OR DSOR IS NOT LESS THAN POPCOUNT.\n\n       CHECK-DSOR.\n           DIVIDE POPCOUNT BY DSOR GIVING DIV-RSLT.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n", "target": ">>> def popcount(n): return bin(n).count(\"1\")\n\n>>> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61}\n>>> p, i = [], 0\n>>> while len(p) < 25:\n        if popcount(i) in primes: p.append(i)\n        i += 1\n\n        \n>>> p\n[3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22, 24, 25, 26, 28, 31, 33, 34, 35, 36]\n>>> p, i = [], 888888877\n>>> while i <= 888888888:\n        if popcount(i) in primes: p.append(i)\n        i += 1\n\n        \n>>> p\n[888888877, 888888878, 888888880, 888888883, 888888885, 888888886]\n>>>\n"}
{"id": 136231, "name": "IBAN", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. iban-main.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  iban                    PIC X(50).\n       01  iban-flag               PIC X.\n           88  is-valid            VALUE \"Y\", FALSE \"N\".\n\n       PROCEDURE DIVISION.\n       main-line.\n           MOVE \"GB82 WEST 1234 5698 7654 32\" TO iban\n           PERFORM display-validity\n\n           MOVE \"GB82 TEST 1234 5698 7654 32\" TO iban\n           PERFORM display-validity\n\n           GOBACK\n           .\n       display-validity.\n           CALL \"validate-iban\" USING CONTENT iban, REFERENCE iban-flag\n           IF is-valid\n               DISPLAY FUNCTION TRIM(iban) \" is valid.\"\n           ELSE\n               DISPLAY FUNCTION TRIM(iban) \" is not valid.\"\n           END-IF\n           .\n       END PROGRAM iban-main.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. validate-iban.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  country-lengths-area    VALUE \"AD24AE23AL28AT20AZ28BA20BE16\"\n           & \"BG22BH22BR29CH21CR21CY28CZ24DE22DK18DO28EE20ES24FI18FO18F\"\n           & \"R27GB22GE22GI23GL18GR27GT28HR21HU28IE22IL23IS26IT27KW30KZ\"\n           & \"20LB28LI21LT20LU20LV21MC27MD24ME22MK19MR27MT31MU30NL18NO1\"\n           & \"5PK24PL28PS29PT25RO24RS22SA24SE24SI19SK24SM27TN24TR26VG24\"\n           .\n           03  country-lengths     OCCURS 64 TIMES\n                                   INDEXED BY country-lengths-idx.\n               05  country-code    PIC XX.\n               05  country-len     PIC 99.\n\n       01  offset                  PIC 99.\n\n       01  i                       PIC 99.\n\n       01  len                     PIC 99.\n\n       LINKAGE SECTION.\n       01  iban                    PIC X(50).\n\n       01  valid-flag              PIC X.\n           88  is-valid            VALUE \"Y\", FALSE \"N\".\n\n       PROCEDURE DIVISION USING iban, valid-flag.\n           MOVE FUNCTION UPPER-CASE(iban) TO iban\n           CALL \"remove-spaces\" USING iban\n\n           \n           INITIALIZE len\n           INSPECT iban TALLYING len FOR CHARACTERS BEFORE SPACE\n           SET country-lengths-idx TO 1\n           SEARCH country-lengths\n               AT END\n                   SET is-valid TO FALSE\n                   GOBACK\n\n               WHEN country-code (country-lengths-idx) = iban (1:2)\n                   IF country-len (country-lengths-idx) NOT = len\n                       SET is-valid TO FALSE\n                       GOBACK\n                   END-IF\n           END-SEARCH\n\n           CALL \"create-iban-number\" USING CONTENT len, REFERENCE iban\n\n           \n           IF FUNCTION MOD(iban, 97) = 1\n               SET is-valid TO TRUE\n           ELSE\n               SET is-valid TO FALSE\n           END-IF\n           .\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. remove-spaces.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i                       PIC 99.\n       01  offset                  PIC 99.\n\n       LINKAGE SECTION.\n       01  str                     PIC X(50).\n\n       PROCEDURE DIVISION USING str.\n           INITIALIZE offset\n           PERFORM VARYING i FROM 1 BY 1 UNTIL i > 50\n               EVALUATE TRUE\n                   WHEN str (i:1) = SPACE\n                       ADD 1 TO offset\n               \n                   WHEN offset NOT = ZERO\n                       MOVE str (i:1) TO str (i - offset:1)\n               END-EVALUATE\n           END-PERFORM\n           MOVE SPACES TO str (50 - offset + 1:)\n           .\n       END PROGRAM remove-spaces.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. create-iban-number.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  first-four              PIC X(4).\n\n       01  iban-num                PIC X(50).\n       01  digit-num               PIC 99 VALUE 1.       \n\n       01  i                       PIC 99.\n\n       01  letter-num              PIC 99.\n\n       LINKAGE SECTION.\n       01  len                     PIC 99.\n\n       01  iban                    PIC X(50).\n\n       PROCEDURE DIVISION USING len, iban.\n           \n           MOVE iban (1:4) TO first-four\n           MOVE iban (5:) TO iban\n           MOVE first-four TO iban (len - 3:)\n\n           \n           INITIALIZE iban-num, digit-num ALL TO VALUE\n           PERFORM VARYING i FROM 1 BY 1\n                   UNTIL i > len OR iban (i:1) = SPACE\n               IF iban (i:1) IS NUMERIC\n                   MOVE iban (i:1) TO iban-num (digit-num:1)\n                   ADD 1 TO digit-num\n               ELSE\n                   COMPUTE letter-num =\n                       FUNCTION ORD(iban (i:1)) - FUNCTION ORD(\"A\") + 10\n                   MOVE letter-num TO iban-num (digit-num:2)\n                   ADD 2 TO digit-num\n               END-IF\n           END-PERFORM\n\n           MOVE iban-num TO iban\n           .\n           \n       END PROGRAM create-iban-number.\n\n       END PROGRAM validate-iban.\n", "target": "    public class IbanValidator : IValidateTypes\n    {\n        public ValidationResult Validate(string value)\n        {\n            \n            if (string.IsNullOrEmpty(value))\n                return ValidationResult.ValueMissing;\n\n            if (value.Length < 2)\n                return ValidationResult.ValueTooSmall;\n\n            var countryCode = value.Substring(0, 2).ToUpper();\n\n            int lengthForCountryCode;\n\n            var countryCodeKnown = Lengths.TryGetValue(countryCode, out lengthForCountryCode);\n            if (!countryCodeKnown)\n            {\n                return ValidationResult.CountryCodeNotKnown;\n            }\n\n            \n            if (value.Length < lengthForCountryCode)\n                return ValidationResult.ValueTooSmall;\n\n            if (value.Length > lengthForCountryCode)\n                return ValidationResult.ValueTooBig;\n\n            value = value.ToUpper();\n            var newIban = value.Substring(4) + value.Substring(0, 4);\n\n            newIban = Regex.Replace(newIban, @\"\\D\", match => (match.Value[0] - 55).ToString());\n\n            var remainder = BigInteger.Parse(newIban) % 97;\n\n            if (remainder != 1)\n                return ValidationResult.ValueFailsModule97Check;\n\n            return ValidationResult.IsValid;\n        }\n\n        public enum ValidationResult\n        {\n            IsValid,\n            ValueMissing,\n            ValueTooSmall,\n            ValueTooBig,\n            ValueFailsModule97Check,\n            CountryCodeNotKnown\n        }\n\n        private static readonly IDictionary<string, int> Lengths = new Dictionary<string, int>\n        {\n            {\"AL\", 28},\n            {\"AD\", 24},\n            {\"AT\", 20},\n            {\"AZ\", 28},\n            {\"BE\", 16},\n            {\"BH\", 22},\n            {\"BA\", 20},\n            {\"BR\", 29},\n            {\"BG\", 22},\n            {\"CR\", 21},\n            {\"HR\", 21},\n            {\"CY\", 28},\n            {\"CZ\", 24},\n            {\"DK\", 18},\n            {\"DO\", 28},\n            {\"EE\", 20},\n            {\"FO\", 18},\n            {\"FI\", 18},\n            {\"FR\", 27},\n            {\"GE\", 22},\n            {\"DE\", 22},\n            {\"GI\", 23},\n            {\"GR\", 27},\n            {\"GL\", 18},\n            {\"GT\", 28},\n            {\"HU\", 28},\n            {\"IS\", 26},\n            {\"IE\", 22},\n            {\"IL\", 23},\n            {\"IT\", 27},\n            {\"KZ\", 20},\n            {\"KW\", 30},\n            {\"LV\", 21},\n            {\"LB\", 28},\n            {\"LI\", 21},\n            {\"LT\", 20},\n            {\"LU\", 20},\n            {\"MK\", 19},\n            {\"MT\", 31},\n            {\"MR\", 27},\n            {\"MU\", 30},\n            {\"MC\", 27},\n            {\"MD\", 24},\n            {\"ME\", 22},\n            {\"NL\", 18},\n            {\"NO\", 15},\n            {\"PK\", 24},\n            {\"PS\", 29},\n            {\"PL\", 28},\n            {\"PT\", 25},\n            {\"RO\", 24},\n            {\"SM\", 27},\n            {\"SA\", 24},\n            {\"RS\", 22},\n            {\"SK\", 24},\n            {\"SI\", 19},\n            {\"ES\", 24},\n            {\"SE\", 24},\n            {\"CH\", 21},\n            {\"TN\", 24},\n            {\"TR\", 26},\n            {\"AE\", 23},\n            {\"GB\", 22},\n            {\"VG\", 24}\n        };\n    }\n"}
{"id": 136233, "name": "IBAN", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. iban-main.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  iban                    PIC X(50).\n       01  iban-flag               PIC X.\n           88  is-valid            VALUE \"Y\", FALSE \"N\".\n\n       PROCEDURE DIVISION.\n       main-line.\n           MOVE \"GB82 WEST 1234 5698 7654 32\" TO iban\n           PERFORM display-validity\n\n           MOVE \"GB82 TEST 1234 5698 7654 32\" TO iban\n           PERFORM display-validity\n\n           GOBACK\n           .\n       display-validity.\n           CALL \"validate-iban\" USING CONTENT iban, REFERENCE iban-flag\n           IF is-valid\n               DISPLAY FUNCTION TRIM(iban) \" is valid.\"\n           ELSE\n               DISPLAY FUNCTION TRIM(iban) \" is not valid.\"\n           END-IF\n           .\n       END PROGRAM iban-main.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. validate-iban.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  country-lengths-area    VALUE \"AD24AE23AL28AT20AZ28BA20BE16\"\n           & \"BG22BH22BR29CH21CR21CY28CZ24DE22DK18DO28EE20ES24FI18FO18F\"\n           & \"R27GB22GE22GI23GL18GR27GT28HR21HU28IE22IL23IS26IT27KW30KZ\"\n           & \"20LB28LI21LT20LU20LV21MC27MD24ME22MK19MR27MT31MU30NL18NO1\"\n           & \"5PK24PL28PS29PT25RO24RS22SA24SE24SI19SK24SM27TN24TR26VG24\"\n           .\n           03  country-lengths     OCCURS 64 TIMES\n                                   INDEXED BY country-lengths-idx.\n               05  country-code    PIC XX.\n               05  country-len     PIC 99.\n\n       01  offset                  PIC 99.\n\n       01  i                       PIC 99.\n\n       01  len                     PIC 99.\n\n       LINKAGE SECTION.\n       01  iban                    PIC X(50).\n\n       01  valid-flag              PIC X.\n           88  is-valid            VALUE \"Y\", FALSE \"N\".\n\n       PROCEDURE DIVISION USING iban, valid-flag.\n           MOVE FUNCTION UPPER-CASE(iban) TO iban\n           CALL \"remove-spaces\" USING iban\n\n           \n           INITIALIZE len\n           INSPECT iban TALLYING len FOR CHARACTERS BEFORE SPACE\n           SET country-lengths-idx TO 1\n           SEARCH country-lengths\n               AT END\n                   SET is-valid TO FALSE\n                   GOBACK\n\n               WHEN country-code (country-lengths-idx) = iban (1:2)\n                   IF country-len (country-lengths-idx) NOT = len\n                       SET is-valid TO FALSE\n                       GOBACK\n                   END-IF\n           END-SEARCH\n\n           CALL \"create-iban-number\" USING CONTENT len, REFERENCE iban\n\n           \n           IF FUNCTION MOD(iban, 97) = 1\n               SET is-valid TO TRUE\n           ELSE\n               SET is-valid TO FALSE\n           END-IF\n           .\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. remove-spaces.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i                       PIC 99.\n       01  offset                  PIC 99.\n\n       LINKAGE SECTION.\n       01  str                     PIC X(50).\n\n       PROCEDURE DIVISION USING str.\n           INITIALIZE offset\n           PERFORM VARYING i FROM 1 BY 1 UNTIL i > 50\n               EVALUATE TRUE\n                   WHEN str (i:1) = SPACE\n                       ADD 1 TO offset\n               \n                   WHEN offset NOT = ZERO\n                       MOVE str (i:1) TO str (i - offset:1)\n               END-EVALUATE\n           END-PERFORM\n           MOVE SPACES TO str (50 - offset + 1:)\n           .\n       END PROGRAM remove-spaces.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. create-iban-number.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  first-four              PIC X(4).\n\n       01  iban-num                PIC X(50).\n       01  digit-num               PIC 99 VALUE 1.       \n\n       01  i                       PIC 99.\n\n       01  letter-num              PIC 99.\n\n       LINKAGE SECTION.\n       01  len                     PIC 99.\n\n       01  iban                    PIC X(50).\n\n       PROCEDURE DIVISION USING len, iban.\n           \n           MOVE iban (1:4) TO first-four\n           MOVE iban (5:) TO iban\n           MOVE first-four TO iban (len - 3:)\n\n           \n           INITIALIZE iban-num, digit-num ALL TO VALUE\n           PERFORM VARYING i FROM 1 BY 1\n                   UNTIL i > len OR iban (i:1) = SPACE\n               IF iban (i:1) IS NUMERIC\n                   MOVE iban (i:1) TO iban-num (digit-num:1)\n                   ADD 1 TO digit-num\n               ELSE\n                   COMPUTE letter-num =\n                       FUNCTION ORD(iban (i:1)) - FUNCTION ORD(\"A\") + 10\n                   MOVE letter-num TO iban-num (digit-num:2)\n                   ADD 2 TO digit-num\n               END-IF\n           END-PERFORM\n\n           MOVE iban-num TO iban\n           .\n           \n       END PROGRAM create-iban-number.\n\n       END PROGRAM validate-iban.\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class IBAN {\n    private static final String DEFSTRS = \"\"\n            + \"AL28 AD24 AT20 AZ28 BE16 BH22 BA20 BR29 BG22 \"\n            + \"HR21 CY28 CZ24 DK18 DO28 EE20 FO18 FI18 FR27 GE22 DE22 GI23 \"\n            + \"GL18 GT28 HU28 IS26 IE22 IL23 IT27 KZ20 KW30 LV21 LB28 LI21 \"\n            + \"LT20 LU20 MK19 MT31 MR27 MU30 MC27 MD24 ME22 NL18 NO15 PK24 \"\n            + \"PS29 PL28 PT25 RO24 SM27 SA24 RS22 SK24 SI19 ES24 SE24 CH21 \"\n            + \"TN24 TR26 AE23 GB22 VG24 GR27 CR21\";\n    private static final Map<String, Integer> DEFINITIONS = new HashMap<>();\n\n    static {\n        for (String definition : DEFSTRS.split(\" \"))\n            DEFINITIONS.put(definition.substring(0, 2), Integer.parseInt(definition.substring(2)));\n    }\n\n    public static void main(String[] args) {\n        String[] ibans = {\n                \"GB82 WEST 1234 5698 7654 32\",\n                \"GB82 TEST 1234 5698 7654 32\",\n                \"GB81 WEST 1234 5698 7654 32\",\n                \"SA03 8000 0000 6080 1016 7519\",\n                \"CH93 0076 2011 6238 5295 7\",\n                \"XX00 0000\",\n                \"\",\n                \"DE\",\n                \"DE13 \u00e4\u00f6\u00fc_ 1234 1234 1234 12\"};\n        for (String iban : ibans)\n            System.out.printf(\"%s is %s.%n\", iban, validateIBAN(iban) ? \"valid\" : \"not valid\");\n    }\n\n    static boolean validateIBAN(String iban) {\n        iban = iban.replaceAll(\"\\\\s\", \"\").toUpperCase(Locale.ROOT);\n\n        int len = iban.length();\n        if (len < 4 || !iban.matches(\"[0-9A-Z]+\") || DEFINITIONS.getOrDefault(iban.substring(0, 2), 0) != len)\n            return false;\n\n        iban = iban.substring(4) + iban.substring(0, 4);\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < len; i++)\n            sb.append(Character.digit(iban.charAt(i), 36));\n\n        BigInteger bigInt = new BigInteger(sb.toString());\n\n        return bigInt.mod(BigInteger.valueOf(97)).intValue() == 1;\n    }\n}\n"}
{"id": 136234, "name": "IBAN", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. iban-main.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  iban                    PIC X(50).\n       01  iban-flag               PIC X.\n           88  is-valid            VALUE \"Y\", FALSE \"N\".\n\n       PROCEDURE DIVISION.\n       main-line.\n           MOVE \"GB82 WEST 1234 5698 7654 32\" TO iban\n           PERFORM display-validity\n\n           MOVE \"GB82 TEST 1234 5698 7654 32\" TO iban\n           PERFORM display-validity\n\n           GOBACK\n           .\n       display-validity.\n           CALL \"validate-iban\" USING CONTENT iban, REFERENCE iban-flag\n           IF is-valid\n               DISPLAY FUNCTION TRIM(iban) \" is valid.\"\n           ELSE\n               DISPLAY FUNCTION TRIM(iban) \" is not valid.\"\n           END-IF\n           .\n       END PROGRAM iban-main.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. validate-iban.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  country-lengths-area    VALUE \"AD24AE23AL28AT20AZ28BA20BE16\"\n           & \"BG22BH22BR29CH21CR21CY28CZ24DE22DK18DO28EE20ES24FI18FO18F\"\n           & \"R27GB22GE22GI23GL18GR27GT28HR21HU28IE22IL23IS26IT27KW30KZ\"\n           & \"20LB28LI21LT20LU20LV21MC27MD24ME22MK19MR27MT31MU30NL18NO1\"\n           & \"5PK24PL28PS29PT25RO24RS22SA24SE24SI19SK24SM27TN24TR26VG24\"\n           .\n           03  country-lengths     OCCURS 64 TIMES\n                                   INDEXED BY country-lengths-idx.\n               05  country-code    PIC XX.\n               05  country-len     PIC 99.\n\n       01  offset                  PIC 99.\n\n       01  i                       PIC 99.\n\n       01  len                     PIC 99.\n\n       LINKAGE SECTION.\n       01  iban                    PIC X(50).\n\n       01  valid-flag              PIC X.\n           88  is-valid            VALUE \"Y\", FALSE \"N\".\n\n       PROCEDURE DIVISION USING iban, valid-flag.\n           MOVE FUNCTION UPPER-CASE(iban) TO iban\n           CALL \"remove-spaces\" USING iban\n\n           \n           INITIALIZE len\n           INSPECT iban TALLYING len FOR CHARACTERS BEFORE SPACE\n           SET country-lengths-idx TO 1\n           SEARCH country-lengths\n               AT END\n                   SET is-valid TO FALSE\n                   GOBACK\n\n               WHEN country-code (country-lengths-idx) = iban (1:2)\n                   IF country-len (country-lengths-idx) NOT = len\n                       SET is-valid TO FALSE\n                       GOBACK\n                   END-IF\n           END-SEARCH\n\n           CALL \"create-iban-number\" USING CONTENT len, REFERENCE iban\n\n           \n           IF FUNCTION MOD(iban, 97) = 1\n               SET is-valid TO TRUE\n           ELSE\n               SET is-valid TO FALSE\n           END-IF\n           .\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. remove-spaces.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i                       PIC 99.\n       01  offset                  PIC 99.\n\n       LINKAGE SECTION.\n       01  str                     PIC X(50).\n\n       PROCEDURE DIVISION USING str.\n           INITIALIZE offset\n           PERFORM VARYING i FROM 1 BY 1 UNTIL i > 50\n               EVALUATE TRUE\n                   WHEN str (i:1) = SPACE\n                       ADD 1 TO offset\n               \n                   WHEN offset NOT = ZERO\n                       MOVE str (i:1) TO str (i - offset:1)\n               END-EVALUATE\n           END-PERFORM\n           MOVE SPACES TO str (50 - offset + 1:)\n           .\n       END PROGRAM remove-spaces.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. create-iban-number.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  first-four              PIC X(4).\n\n       01  iban-num                PIC X(50).\n       01  digit-num               PIC 99 VALUE 1.       \n\n       01  i                       PIC 99.\n\n       01  letter-num              PIC 99.\n\n       LINKAGE SECTION.\n       01  len                     PIC 99.\n\n       01  iban                    PIC X(50).\n\n       PROCEDURE DIVISION USING len, iban.\n           \n           MOVE iban (1:4) TO first-four\n           MOVE iban (5:) TO iban\n           MOVE first-four TO iban (len - 3:)\n\n           \n           INITIALIZE iban-num, digit-num ALL TO VALUE\n           PERFORM VARYING i FROM 1 BY 1\n                   UNTIL i > len OR iban (i:1) = SPACE\n               IF iban (i:1) IS NUMERIC\n                   MOVE iban (i:1) TO iban-num (digit-num:1)\n                   ADD 1 TO digit-num\n               ELSE\n                   COMPUTE letter-num =\n                       FUNCTION ORD(iban (i:1)) - FUNCTION ORD(\"A\") + 10\n                   MOVE letter-num TO iban-num (digit-num:2)\n                   ADD 2 TO digit-num\n               END-IF\n           END-PERFORM\n\n           MOVE iban-num TO iban\n           .\n           \n       END PROGRAM create-iban-number.\n\n       END PROGRAM validate-iban.\n", "target": "import re\n\n_country2length = dict(\n    AL=28, AD=24, AT=20, AZ=28, BE=16, BH=22, BA=20, BR=29,\n    BG=22, CR=21, HR=21, CY=28, CZ=24, DK=18, DO=28, EE=20,\n    FO=18, FI=18, FR=27, GE=22, DE=22, GI=23, GR=27, GL=18,\n    GT=28, HU=28, IS=26, IE=22, IL=23, IT=27, KZ=20, KW=30,\n    LV=21, LB=28, LI=21, LT=20, LU=20, MK=19, MT=31, MR=27,\n    MU=30, MC=27, MD=24, ME=22, NL=18, NO=15, PK=24, PS=29,\n    PL=28, PT=25, RO=24, SM=27, SA=24, RS=22, SK=24, SI=19,\n    ES=24, SE=24, CH=21, TN=24, TR=26, AE=23, GB=22, VG=24 )\n\ndef valid_iban(iban):\n    \n    iban = iban.replace(' ','').replace('\\t','')\n    if not re.match(r'^[\\dA-Z]+$', iban): \n        return False\n    \n    if len(iban) != _country2length[iban[:2]]:\n        return False\n    \n    iban = iban[4:] + iban[:4]\n    digits = int(''.join(str(int(ch, 36)) for ch in iban)) \n    return digits % 97 == 1\n\nif __name__ == '__main__':\n    for account in [\"GB82 WEST 1234 5698 7654 32\", \"GB82 TEST 1234 5698 7654 32\"]:\n        print('%s validation is: %s' % (account, valid_iban(account)))\n"}
{"id": 136633, "name": "Literals_String", "source": "Translate COBOL to C#: \"This is a valid string.\"\n'As is this.'\n", "target": "string path = @\"C:\\Windows\\System32\";\nstring multiline = @\"Line 1.\nLine 2.\nLine 3.\";\n"}
{"id": 136634, "name": "Literals_String", "source": "Translate COBOL to Java: \"This is a valid string.\"\n'As is this.'\n", "target": "  char a = 'a';  \n  String b = \"abc\";  \n  char doubleQuote = '\"';  \n  char singleQuote = '\\'';  \n  String singleQuotes = \"''\";  \n  String doubleQuotes = \"\\\"\\\"\";  \n"}
{"id": 136635, "name": "Literals_String", "source": "Translate COBOL to Python: \"This is a valid string.\"\n'As is this.'\n", "target": "'c' == \"c\" \n'text' == \"text\"\n' \" '\n\" ' \"\n'\\x20' == ' '\nu'unicode string'\nu'\\u05d0' \n"}
{"id": 136925, "name": "Extend your language", "source": "Translate COBOL to C#: EVALUATE EXPRESSION-1 ALSO EXPRESSION-2\n   WHEN TRUE ALSO TRUE\n      DISPLAY 'Both are true.'\n   WHEN TRUE ALSO FALSE\n      DISPLAY 'Expression 1 is true.'\n   WHEN FALSE ALSO TRUE\n      DISPLAY 'Expression 2 is true.'\n   WHEN OTHER\n      DISPLAY 'Neither is true.'\nEND-EVALUATE\n", "target": "using System;\nusing System.Reflection;\n\nnamespace Extend_your_language\n{\n\t\n\n\tclass Program\n\t{\n\t\t\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\"Hello World!\");\n\t\t\tConsole.WriteLine();\n\t\t\t\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\t\n\t\t\tfor(x=0;x<2;x++)\n\t\t\t{\n\t\t\t\tfor(y=0;y<2;y++)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tCONDITIONS( (x==0) , (y==0) ).\n\t\t\t\t\t\tIF2  (\"METHOD1\").\n\t\t\t\t\t\tELSE1(\"METHOD2\").\n\t\t\t\t\t\tELSE2(\"METHOD3\").\n\t\t\t\t\t\tELSE (\"METHOD4\");\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tpublic static void METHOD1()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 1 executed - both are true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD2()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 2 executed - first is true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD3()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 3 executed - second is true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD4()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 4 executed - both are false\");\n\t\t}\n\t\t\n\t\t\n\t\tstatic int CONDITIONS(bool condition1, bool condition2)\n\t\t{\n\t\t\tint c = 0;\n\t\t\tif(condition1 && condition2)\n\t\t\t\tc = 0;\n\t\t\telse if(condition1)\n\t\t\t\tc = 1;\n\t\t\telse if(condition2)\n\t\t\t\tc = 2;\n\t\t\telse\n\t\t\t\tc = 3;\n\t\t\t\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\t\n\tpublic static class ExtensionMethods\n\t{\n\n\t\tpublic static int IF2(this int value, string method)\n\t\t{\n\t\t\tif(value == 0)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static int ELSE1(this int value, string method)\n\t\t{\n\t\t\tif(value == 1)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static int ELSE2(this int value, string method)\n\t\t{\n\t\t\tif(value == 2)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static void ELSE(this int value, string method)\n\t\t{\n\t\t\tif(value == 3)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n"}
{"id": 136926, "name": "Extend your language", "source": "Translate COBOL to C#: EVALUATE EXPRESSION-1 ALSO EXPRESSION-2\n   WHEN TRUE ALSO TRUE\n      DISPLAY 'Both are true.'\n   WHEN TRUE ALSO FALSE\n      DISPLAY 'Expression 1 is true.'\n   WHEN FALSE ALSO TRUE\n      DISPLAY 'Expression 2 is true.'\n   WHEN OTHER\n      DISPLAY 'Neither is true.'\nEND-EVALUATE\n", "target": "using System;\nusing System.Reflection;\n\nnamespace Extend_your_language\n{\n\t\n\n\tclass Program\n\t{\n\t\t\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\"Hello World!\");\n\t\t\tConsole.WriteLine();\n\t\t\t\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\t\n\t\t\tfor(x=0;x<2;x++)\n\t\t\t{\n\t\t\t\tfor(y=0;y<2;y++)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tCONDITIONS( (x==0) , (y==0) ).\n\t\t\t\t\t\tIF2  (\"METHOD1\").\n\t\t\t\t\t\tELSE1(\"METHOD2\").\n\t\t\t\t\t\tELSE2(\"METHOD3\").\n\t\t\t\t\t\tELSE (\"METHOD4\");\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tpublic static void METHOD1()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 1 executed - both are true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD2()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 2 executed - first is true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD3()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 3 executed - second is true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD4()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 4 executed - both are false\");\n\t\t}\n\t\t\n\t\t\n\t\tstatic int CONDITIONS(bool condition1, bool condition2)\n\t\t{\n\t\t\tint c = 0;\n\t\t\tif(condition1 && condition2)\n\t\t\t\tc = 0;\n\t\t\telse if(condition1)\n\t\t\t\tc = 1;\n\t\t\telse if(condition2)\n\t\t\t\tc = 2;\n\t\t\telse\n\t\t\t\tc = 3;\n\t\t\t\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\t\n\tpublic static class ExtensionMethods\n\t{\n\n\t\tpublic static int IF2(this int value, string method)\n\t\t{\n\t\t\tif(value == 0)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static int ELSE1(this int value, string method)\n\t\t{\n\t\t\tif(value == 1)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static int ELSE2(this int value, string method)\n\t\t{\n\t\t\tif(value == 2)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static void ELSE(this int value, string method)\n\t\t{\n\t\t\tif(value == 3)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n"}
{"id": 136927, "name": "Extend your language", "source": "Translate COBOL to Java: EVALUATE EXPRESSION-1 ALSO EXPRESSION-2\n   WHEN TRUE ALSO TRUE\n      DISPLAY 'Both are true.'\n   WHEN TRUE ALSO FALSE\n      DISPLAY 'Expression 1 is true.'\n   WHEN FALSE ALSO TRUE\n      DISPLAY 'Expression 2 is true.'\n   WHEN OTHER\n      DISPLAY 'Neither is true.'\nEND-EVALUATE\n", "target": "public class If2 {\n\n    public static void if2(boolean firstCondition, boolean secondCondition,\n                           Runnable bothTrue, Runnable firstTrue, Runnable secondTrue, Runnable noneTrue) {\n        if (firstCondition)\n            if (secondCondition)\n                bothTrue.run();\n            else firstTrue.run();\n        else if (secondCondition)\n            secondTrue.run();\n        else noneTrue.run();\n    }\n}\n"}
{"id": 136928, "name": "Extend your language", "source": "Translate COBOL to Java: EVALUATE EXPRESSION-1 ALSO EXPRESSION-2\n   WHEN TRUE ALSO TRUE\n      DISPLAY 'Both are true.'\n   WHEN TRUE ALSO FALSE\n      DISPLAY 'Expression 1 is true.'\n   WHEN FALSE ALSO TRUE\n      DISPLAY 'Expression 2 is true.'\n   WHEN OTHER\n      DISPLAY 'Neither is true.'\nEND-EVALUATE\n", "target": "public class If2 {\n\n    public static void if2(boolean firstCondition, boolean secondCondition,\n                           Runnable bothTrue, Runnable firstTrue, Runnable secondTrue, Runnable noneTrue) {\n        if (firstCondition)\n            if (secondCondition)\n                bothTrue.run();\n            else firstTrue.run();\n        else if (secondCondition)\n            secondTrue.run();\n        else noneTrue.run();\n    }\n}\n"}
{"id": 136929, "name": "Extend your language", "source": "Translate COBOL to Python: EVALUATE EXPRESSION-1 ALSO EXPRESSION-2\n   WHEN TRUE ALSO TRUE\n      DISPLAY 'Both are true.'\n   WHEN TRUE ALSO FALSE\n      DISPLAY 'Expression 1 is true.'\n   WHEN FALSE ALSO TRUE\n      DISPLAY 'Expression 2 is true.'\n   WHEN OTHER\n      DISPLAY 'Neither is true.'\nEND-EVALUATE\n", "target": "a, b = 1, 0\n\nif (c1 := a == 1) and (c2 := b == 3):\n  print('a = 1 and b = 3')\nelif c1:\n  print('a = 1 and b <> 3')\nelif c2:\n  print('a <> 1 and b = 3')\nelse:\n  print('a <> 1 and b <> 3')\n"}
{"id": 136930, "name": "Extend your language", "source": "Translate COBOL to Python: EVALUATE EXPRESSION-1 ALSO EXPRESSION-2\n   WHEN TRUE ALSO TRUE\n      DISPLAY 'Both are true.'\n   WHEN TRUE ALSO FALSE\n      DISPLAY 'Expression 1 is true.'\n   WHEN FALSE ALSO TRUE\n      DISPLAY 'Expression 2 is true.'\n   WHEN OTHER\n      DISPLAY 'Neither is true.'\nEND-EVALUATE\n", "target": "a, b = 1, 0\n\nif (c1 := a == 1) and (c2 := b == 3):\n  print('a = 1 and b = 3')\nelif c1:\n  print('a = 1 and b <> 3')\nelif c2:\n  print('a <> 1 and b = 3')\nelse:\n  print('a <> 1 and b <> 3')\n"}
{"id": 138145, "name": "Check that file exists", "source": "Translate COBOL to C#:        identification division.\n       program-id. check-file-exist.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 skip                 pic 9 value 2.\n       01 file-name.\n          05 value \"/output.txt\".\n       01 dir-name.\n          05 value \"/docs/\".\n       01 unusual-name.\n          05 value \"Abdu'l-Bah\u00e1.txt\".\n\n       01 test-name            pic x(256).\n\n       01 file-handle          usage binary-long.\n       01 file-info.\n          05 file-size         pic x(8) comp-x.\n          05 file-date.\n             10 file-day       pic x comp-x.\n             10 file-month     pic x comp-x.\n             10 file-year      pic xx comp-x.\n          05 file-time.\n             10 file-hours     pic x comp-x.\n             10 file-minutes   pic x comp-x.\n             10 file-seconds   pic x comp-x.\n             10 file-hundredths  pic x comp-x. \n\n       procedure division.\n       files-main.\n\n      \n       move file-name(skip:) to test-name\n       perform check-file\n\n       move dir-name(skip:) to test-name\n       perform check-file\n\n       move unusual-name to test-name\n       perform check-file\n\n      \n       move 1 to skip\n       move file-name(skip:) to test-name\n       perform check-file\n\n       move dir-name(skip:) to test-name\n       perform check-file\n\n       goback.\n\n       check-file.\n       call \"CBL_CHECK_FILE_EXIST\" using test-name file-info\n       if return-code equal zero then\n           display test-name(1:32) \": size \" file-size \", \"\n                   file-year \"-\" file-month \"-\" file-day space\n                   file-hours \":\" file-minutes \":\" file-seconds \".\"\n                   file-hundredths\n       else\n           display \"error: CBL_CHECK_FILE_EXIST \" return-code space\n                   trim(test-name)\n       end-if\n       .\n\n       end program check-file-exist.\n", "target": "using System.IO;\n\nConsole.WriteLine(File.Exists(\"input.txt\"));\nConsole.WriteLine(File.Exists(\"/input.txt\"));\nConsole.WriteLine(Directory.Exists(\"docs\"));\nConsole.WriteLine(Directory.Exists(\"/docs\"));\n"}
{"id": 138147, "name": "Check that file exists", "source": "Translate COBOL to Java:        identification division.\n       program-id. check-file-exist.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 skip                 pic 9 value 2.\n       01 file-name.\n          05 value \"/output.txt\".\n       01 dir-name.\n          05 value \"/docs/\".\n       01 unusual-name.\n          05 value \"Abdu'l-Bah\u00e1.txt\".\n\n       01 test-name            pic x(256).\n\n       01 file-handle          usage binary-long.\n       01 file-info.\n          05 file-size         pic x(8) comp-x.\n          05 file-date.\n             10 file-day       pic x comp-x.\n             10 file-month     pic x comp-x.\n             10 file-year      pic xx comp-x.\n          05 file-time.\n             10 file-hours     pic x comp-x.\n             10 file-minutes   pic x comp-x.\n             10 file-seconds   pic x comp-x.\n             10 file-hundredths  pic x comp-x. \n\n       procedure division.\n       files-main.\n\n      \n       move file-name(skip:) to test-name\n       perform check-file\n\n       move dir-name(skip:) to test-name\n       perform check-file\n\n       move unusual-name to test-name\n       perform check-file\n\n      \n       move 1 to skip\n       move file-name(skip:) to test-name\n       perform check-file\n\n       move dir-name(skip:) to test-name\n       perform check-file\n\n       goback.\n\n       check-file.\n       call \"CBL_CHECK_FILE_EXIST\" using test-name file-info\n       if return-code equal zero then\n           display test-name(1:32) \": size \" file-size \", \"\n                   file-year \"-\" file-month \"-\" file-day space\n                   file-hours \":\" file-minutes \":\" file-seconds \".\"\n                   file-hundredths\n       else\n           display \"error: CBL_CHECK_FILE_EXIST \" return-code space\n                   trim(test-name)\n       end-if\n       .\n\n       end program check-file-exist.\n", "target": "import java.io.File;\npublic class FileExistsTest {\n   public static boolean isFileExists(String filename) {\n       boolean exists = new File(filename).exists();\n       return exists;\n   }\n   public static void test(String type, String filename) {\n       System.out.println(\"The following \" + type + \" called \" + filename + \n           (isFileExists(filename) ? \" exists.\" : \" not exists.\")\n       );\n   }\n   public static void main(String args[]) {\n        test(\"file\", \"input.txt\");\n        test(\"file\", File.separator + \"input.txt\");\n        test(\"directory\", \"docs\");\n        test(\"directory\", File.separator + \"docs\" + File.separator);\n   }\n}\n"}
{"id": 138148, "name": "Check that file exists", "source": "Translate COBOL to Python:        identification division.\n       program-id. check-file-exist.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 skip                 pic 9 value 2.\n       01 file-name.\n          05 value \"/output.txt\".\n       01 dir-name.\n          05 value \"/docs/\".\n       01 unusual-name.\n          05 value \"Abdu'l-Bah\u00e1.txt\".\n\n       01 test-name            pic x(256).\n\n       01 file-handle          usage binary-long.\n       01 file-info.\n          05 file-size         pic x(8) comp-x.\n          05 file-date.\n             10 file-day       pic x comp-x.\n             10 file-month     pic x comp-x.\n             10 file-year      pic xx comp-x.\n          05 file-time.\n             10 file-hours     pic x comp-x.\n             10 file-minutes   pic x comp-x.\n             10 file-seconds   pic x comp-x.\n             10 file-hundredths  pic x comp-x. \n\n       procedure division.\n       files-main.\n\n      \n       move file-name(skip:) to test-name\n       perform check-file\n\n       move dir-name(skip:) to test-name\n       perform check-file\n\n       move unusual-name to test-name\n       perform check-file\n\n      \n       move 1 to skip\n       move file-name(skip:) to test-name\n       perform check-file\n\n       move dir-name(skip:) to test-name\n       perform check-file\n\n       goback.\n\n       check-file.\n       call \"CBL_CHECK_FILE_EXIST\" using test-name file-info\n       if return-code equal zero then\n           display test-name(1:32) \": size \" file-size \", \"\n                   file-year \"-\" file-month \"-\" file-day space\n                   file-hours \":\" file-minutes \":\" file-seconds \".\"\n                   file-hundredths\n       else\n           display \"error: CBL_CHECK_FILE_EXIST \" return-code space\n                   trim(test-name)\n       end-if\n       .\n\n       end program check-file-exist.\n", "target": "import os\n\nos.path.isfile(\"input.txt\")\nos.path.isfile(\"/input.txt\")\nos.path.isdir(\"docs\")\nos.path.isdir(\"/docs\")\n"}
{"id": 138583, "name": "Evolutionary algorithm", "source": "Translate COBOL to C#: identification division.\nprogram-id. evolutionary-program.\ndata division.\nworking-storage section.\n01  evolving-strings.\n    05 target                pic a(28)\n        value 'METHINKS IT IS LIKE A WEASEL'.\n    05 parent                pic a(28).\n    05 offspring-table.\n        10 offspring         pic a(28)\n            occurs 50 times.\n01  fitness-calculations.\n    05 fitness               pic 99.\n    05 highest-fitness       pic 99.\n    05 fittest               pic 99.\n01  parameters.\n    05 character-set         pic a(27)\n        value 'ABCDEFGHIJKLMNOPQRSTUVWXYZ '.\n    05 size-of-generation    pic 99\n        value 50.\n    05 mutation-rate         pic 99\n        value 5.\n01  counters-and-working-variables.\n    05 character-position    pic 99.\n    05 randomization.\n        10 random-seed       pic 9(8).\n        10 random-number     pic 99.\n        10 random-letter     pic 99.\n    05 generation            pic 999.\n    05 child                 pic 99.\n    05 temporary-string      pic a(28).\nprocedure division.\ncontrol-paragraph.\n    accept random-seed from time.\n    move function random(random-seed) to random-number.\n    perform random-letter-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    move temporary-string to parent.\n    move zero to generation.\n    perform output-paragraph.\n    perform evolution-paragraph,\n    varying generation from 1 by 1\n    until parent is equal to target.\n    stop run.\nevolution-paragraph.\n    perform mutation-paragraph varying child from 1 by 1\n    until child is greater than size-of-generation.\n    move zero to highest-fitness.\n    move 1 to fittest.\n    perform check-fitness-paragraph varying child from 1 by 1\n    until child is greater than size-of-generation.\n    move offspring(fittest) to parent.\n    perform output-paragraph.\noutput-paragraph.\n    display generation ': ' parent.\nrandom-letter-paragraph.\n    move function random to random-number.\n    divide random-number by 3.80769 giving random-letter.\n    add 1 to random-letter.\n    move character-set(random-letter:1)\n    to temporary-string(character-position:1).\nmutation-paragraph.\n    move parent to temporary-string.\n    perform character-mutation-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    move temporary-string to offspring(child).\ncharacter-mutation-paragraph.\n    move function random to random-number.\n    if random-number is less than mutation-rate\n    then perform random-letter-paragraph.\ncheck-fitness-paragraph.\n    move offspring(child) to temporary-string.\n    perform fitness-paragraph.\nfitness-paragraph.\n    move zero to fitness.\n    perform character-fitness-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    if fitness is greater than highest-fitness\n    then perform fittest-paragraph.\ncharacter-fitness-paragraph.\n    if temporary-string(character-position:1) is equal to\n    target(character-position:1) then add 1 to fitness.\nfittest-paragraph.\n    move fitness to highest-fitness.\n    move child to fittest.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static Random Rng = new Random((int)DateTime.Now.Ticks);\n\n    static char NextCharacter(this Random self) {\n        const string AllowedChars = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        return AllowedChars[self.Next() % AllowedChars.Length];\n    }\n\n    static string NextString(this Random self, int length) {\n        return String.Join(\"\", Enumerable.Repeat(' ', length)\n            .Select(c => Rng.NextCharacter()));\n    }\n\n    static int Fitness(string target, string current) {\n        return target.Zip(current, (a, b) => a == b ? 1 : 0).Sum();\n    }\n\n    static string Mutate(string current, double rate) {\n        return String.Join(\"\", from c in current\n               select Rng.NextDouble() <= rate ? Rng.NextCharacter() : c);\n    }\n\n    static void Main(string[] args) {\n        const string target = \"METHINKS IT IS LIKE A WEASEL\";\n        const int C = 100;\n        const double P = 0.05;\n\n        \n        string parent = Rng.NextString(target.Length);\n\n        Console.WriteLine(\"START:       {0,20} fitness: {1}\", \n            parent, Fitness(target, parent));\n        int i = 0;\n\n        while (parent != target) {\n            \n            var candidates = Enumerable.Range(0, C + 1)\n                .Select(n => n > 0 ? Mutate(parent, P) : parent);\n\n            \n            parent = candidates.OrderByDescending(c => Fitness(target, c)).First();\n\n            ++i;\n            Console.WriteLine(\"     #{0,6} {1,20} fitness: {2}\", \n                i, parent, Fitness(target, parent));\n        }\n\n        Console.WriteLine(\"END: #{0,6} {1,20}\", i, parent);\n    }\n}\n"}
{"id": 138584, "name": "Evolutionary algorithm", "source": "Translate COBOL to C#: identification division.\nprogram-id. evolutionary-program.\ndata division.\nworking-storage section.\n01  evolving-strings.\n    05 target                pic a(28)\n        value 'METHINKS IT IS LIKE A WEASEL'.\n    05 parent                pic a(28).\n    05 offspring-table.\n        10 offspring         pic a(28)\n            occurs 50 times.\n01  fitness-calculations.\n    05 fitness               pic 99.\n    05 highest-fitness       pic 99.\n    05 fittest               pic 99.\n01  parameters.\n    05 character-set         pic a(27)\n        value 'ABCDEFGHIJKLMNOPQRSTUVWXYZ '.\n    05 size-of-generation    pic 99\n        value 50.\n    05 mutation-rate         pic 99\n        value 5.\n01  counters-and-working-variables.\n    05 character-position    pic 99.\n    05 randomization.\n        10 random-seed       pic 9(8).\n        10 random-number     pic 99.\n        10 random-letter     pic 99.\n    05 generation            pic 999.\n    05 child                 pic 99.\n    05 temporary-string      pic a(28).\nprocedure division.\ncontrol-paragraph.\n    accept random-seed from time.\n    move function random(random-seed) to random-number.\n    perform random-letter-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    move temporary-string to parent.\n    move zero to generation.\n    perform output-paragraph.\n    perform evolution-paragraph,\n    varying generation from 1 by 1\n    until parent is equal to target.\n    stop run.\nevolution-paragraph.\n    perform mutation-paragraph varying child from 1 by 1\n    until child is greater than size-of-generation.\n    move zero to highest-fitness.\n    move 1 to fittest.\n    perform check-fitness-paragraph varying child from 1 by 1\n    until child is greater than size-of-generation.\n    move offspring(fittest) to parent.\n    perform output-paragraph.\noutput-paragraph.\n    display generation ': ' parent.\nrandom-letter-paragraph.\n    move function random to random-number.\n    divide random-number by 3.80769 giving random-letter.\n    add 1 to random-letter.\n    move character-set(random-letter:1)\n    to temporary-string(character-position:1).\nmutation-paragraph.\n    move parent to temporary-string.\n    perform character-mutation-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    move temporary-string to offspring(child).\ncharacter-mutation-paragraph.\n    move function random to random-number.\n    if random-number is less than mutation-rate\n    then perform random-letter-paragraph.\ncheck-fitness-paragraph.\n    move offspring(child) to temporary-string.\n    perform fitness-paragraph.\nfitness-paragraph.\n    move zero to fitness.\n    perform character-fitness-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    if fitness is greater than highest-fitness\n    then perform fittest-paragraph.\ncharacter-fitness-paragraph.\n    if temporary-string(character-position:1) is equal to\n    target(character-position:1) then add 1 to fitness.\nfittest-paragraph.\n    move fitness to highest-fitness.\n    move child to fittest.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static Random Rng = new Random((int)DateTime.Now.Ticks);\n\n    static char NextCharacter(this Random self) {\n        const string AllowedChars = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        return AllowedChars[self.Next() % AllowedChars.Length];\n    }\n\n    static string NextString(this Random self, int length) {\n        return String.Join(\"\", Enumerable.Repeat(' ', length)\n            .Select(c => Rng.NextCharacter()));\n    }\n\n    static int Fitness(string target, string current) {\n        return target.Zip(current, (a, b) => a == b ? 1 : 0).Sum();\n    }\n\n    static string Mutate(string current, double rate) {\n        return String.Join(\"\", from c in current\n               select Rng.NextDouble() <= rate ? Rng.NextCharacter() : c);\n    }\n\n    static void Main(string[] args) {\n        const string target = \"METHINKS IT IS LIKE A WEASEL\";\n        const int C = 100;\n        const double P = 0.05;\n\n        \n        string parent = Rng.NextString(target.Length);\n\n        Console.WriteLine(\"START:       {0,20} fitness: {1}\", \n            parent, Fitness(target, parent));\n        int i = 0;\n\n        while (parent != target) {\n            \n            var candidates = Enumerable.Range(0, C + 1)\n                .Select(n => n > 0 ? Mutate(parent, P) : parent);\n\n            \n            parent = candidates.OrderByDescending(c => Fitness(target, c)).First();\n\n            ++i;\n            Console.WriteLine(\"     #{0,6} {1,20} fitness: {2}\", \n                i, parent, Fitness(target, parent));\n        }\n\n        Console.WriteLine(\"END: #{0,6} {1,20}\", i, parent);\n    }\n}\n"}
{"id": 138587, "name": "Evolutionary algorithm", "source": "Translate COBOL to Java: identification division.\nprogram-id. evolutionary-program.\ndata division.\nworking-storage section.\n01  evolving-strings.\n    05 target                pic a(28)\n        value 'METHINKS IT IS LIKE A WEASEL'.\n    05 parent                pic a(28).\n    05 offspring-table.\n        10 offspring         pic a(28)\n            occurs 50 times.\n01  fitness-calculations.\n    05 fitness               pic 99.\n    05 highest-fitness       pic 99.\n    05 fittest               pic 99.\n01  parameters.\n    05 character-set         pic a(27)\n        value 'ABCDEFGHIJKLMNOPQRSTUVWXYZ '.\n    05 size-of-generation    pic 99\n        value 50.\n    05 mutation-rate         pic 99\n        value 5.\n01  counters-and-working-variables.\n    05 character-position    pic 99.\n    05 randomization.\n        10 random-seed       pic 9(8).\n        10 random-number     pic 99.\n        10 random-letter     pic 99.\n    05 generation            pic 999.\n    05 child                 pic 99.\n    05 temporary-string      pic a(28).\nprocedure division.\ncontrol-paragraph.\n    accept random-seed from time.\n    move function random(random-seed) to random-number.\n    perform random-letter-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    move temporary-string to parent.\n    move zero to generation.\n    perform output-paragraph.\n    perform evolution-paragraph,\n    varying generation from 1 by 1\n    until parent is equal to target.\n    stop run.\nevolution-paragraph.\n    perform mutation-paragraph varying child from 1 by 1\n    until child is greater than size-of-generation.\n    move zero to highest-fitness.\n    move 1 to fittest.\n    perform check-fitness-paragraph varying child from 1 by 1\n    until child is greater than size-of-generation.\n    move offspring(fittest) to parent.\n    perform output-paragraph.\noutput-paragraph.\n    display generation ': ' parent.\nrandom-letter-paragraph.\n    move function random to random-number.\n    divide random-number by 3.80769 giving random-letter.\n    add 1 to random-letter.\n    move character-set(random-letter:1)\n    to temporary-string(character-position:1).\nmutation-paragraph.\n    move parent to temporary-string.\n    perform character-mutation-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    move temporary-string to offspring(child).\ncharacter-mutation-paragraph.\n    move function random to random-number.\n    if random-number is less than mutation-rate\n    then perform random-letter-paragraph.\ncheck-fitness-paragraph.\n    move offspring(child) to temporary-string.\n    perform fitness-paragraph.\nfitness-paragraph.\n    move zero to fitness.\n    perform character-fitness-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    if fitness is greater than highest-fitness\n    then perform fittest-paragraph.\ncharacter-fitness-paragraph.\n    if temporary-string(character-position:1) is equal to\n    target(character-position:1) then add 1 to fitness.\nfittest-paragraph.\n    move fitness to highest-fitness.\n    move child to fittest.\n", "target": "import java.util.Random;\n\npublic class EvoAlgo {\n  static final String target = \"METHINKS IT IS LIKE A WEASEL\";\n  static final char[] possibilities = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".toCharArray();\n  static int C = 100; \n  static double minMutateRate = 0.09;\n  static int perfectFitness = target.length();\n  private static String parent;\n  static Random rand = new Random();\n\n  private static int fitness(String trial){\n    int retVal = 0;\n    for(int i = 0;i < trial.length(); i++){\n      if (trial.charAt(i) == target.charAt(i)) retVal++;\n    }\n    return retVal;\n  }\n\n  private static double newMutateRate(){\n    return (((double)perfectFitness - fitness(parent)) / perfectFitness * (1 - minMutateRate));\n  }\n\n  private static String mutate(String parent, double rate){\n    String retVal = \"\";\n    for(int i = 0;i < parent.length(); i++){\n      retVal += (rand.nextDouble() <= rate) ?\n        possibilities[rand.nextInt(possibilities.length)]:\n        parent.charAt(i);\n    }\n    return retVal;\n  }\n  \n  public static void main(String[] args){\n    parent = mutate(target, 1);\n    int iter = 0;\n    while(!target.equals(parent)){\n      double rate = newMutateRate();\n      iter++;\n      if(iter % 100 == 0){\n        System.out.println(iter +\": \"+parent+ \", fitness: \"+fitness(parent)+\", rate: \"+rate);\n      }\n      String bestSpawn = null;\n      int bestFit = 0;\n      for(int i = 0; i < C; i++){\n        String spawn = mutate(parent, rate);\n        int fitness = fitness(spawn);\n        if(fitness > bestFit){\n          bestSpawn = spawn;\n          bestFit = fitness;\n        }\n      }\n      parent = bestFit > fitness(parent) ? bestSpawn : parent;\n    }\n    System.out.println(parent+\", \"+iter);\n  }\n\n}\n"}
{"id": 138588, "name": "Evolutionary algorithm", "source": "Translate COBOL to Java: identification division.\nprogram-id. evolutionary-program.\ndata division.\nworking-storage section.\n01  evolving-strings.\n    05 target                pic a(28)\n        value 'METHINKS IT IS LIKE A WEASEL'.\n    05 parent                pic a(28).\n    05 offspring-table.\n        10 offspring         pic a(28)\n            occurs 50 times.\n01  fitness-calculations.\n    05 fitness               pic 99.\n    05 highest-fitness       pic 99.\n    05 fittest               pic 99.\n01  parameters.\n    05 character-set         pic a(27)\n        value 'ABCDEFGHIJKLMNOPQRSTUVWXYZ '.\n    05 size-of-generation    pic 99\n        value 50.\n    05 mutation-rate         pic 99\n        value 5.\n01  counters-and-working-variables.\n    05 character-position    pic 99.\n    05 randomization.\n        10 random-seed       pic 9(8).\n        10 random-number     pic 99.\n        10 random-letter     pic 99.\n    05 generation            pic 999.\n    05 child                 pic 99.\n    05 temporary-string      pic a(28).\nprocedure division.\ncontrol-paragraph.\n    accept random-seed from time.\n    move function random(random-seed) to random-number.\n    perform random-letter-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    move temporary-string to parent.\n    move zero to generation.\n    perform output-paragraph.\n    perform evolution-paragraph,\n    varying generation from 1 by 1\n    until parent is equal to target.\n    stop run.\nevolution-paragraph.\n    perform mutation-paragraph varying child from 1 by 1\n    until child is greater than size-of-generation.\n    move zero to highest-fitness.\n    move 1 to fittest.\n    perform check-fitness-paragraph varying child from 1 by 1\n    until child is greater than size-of-generation.\n    move offspring(fittest) to parent.\n    perform output-paragraph.\noutput-paragraph.\n    display generation ': ' parent.\nrandom-letter-paragraph.\n    move function random to random-number.\n    divide random-number by 3.80769 giving random-letter.\n    add 1 to random-letter.\n    move character-set(random-letter:1)\n    to temporary-string(character-position:1).\nmutation-paragraph.\n    move parent to temporary-string.\n    perform character-mutation-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    move temporary-string to offspring(child).\ncharacter-mutation-paragraph.\n    move function random to random-number.\n    if random-number is less than mutation-rate\n    then perform random-letter-paragraph.\ncheck-fitness-paragraph.\n    move offspring(child) to temporary-string.\n    perform fitness-paragraph.\nfitness-paragraph.\n    move zero to fitness.\n    perform character-fitness-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    if fitness is greater than highest-fitness\n    then perform fittest-paragraph.\ncharacter-fitness-paragraph.\n    if temporary-string(character-position:1) is equal to\n    target(character-position:1) then add 1 to fitness.\nfittest-paragraph.\n    move fitness to highest-fitness.\n    move child to fittest.\n", "target": "import java.util.Random;\n\npublic class EvoAlgo {\n  static final String target = \"METHINKS IT IS LIKE A WEASEL\";\n  static final char[] possibilities = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".toCharArray();\n  static int C = 100; \n  static double minMutateRate = 0.09;\n  static int perfectFitness = target.length();\n  private static String parent;\n  static Random rand = new Random();\n\n  private static int fitness(String trial){\n    int retVal = 0;\n    for(int i = 0;i < trial.length(); i++){\n      if (trial.charAt(i) == target.charAt(i)) retVal++;\n    }\n    return retVal;\n  }\n\n  private static double newMutateRate(){\n    return (((double)perfectFitness - fitness(parent)) / perfectFitness * (1 - minMutateRate));\n  }\n\n  private static String mutate(String parent, double rate){\n    String retVal = \"\";\n    for(int i = 0;i < parent.length(); i++){\n      retVal += (rand.nextDouble() <= rate) ?\n        possibilities[rand.nextInt(possibilities.length)]:\n        parent.charAt(i);\n    }\n    return retVal;\n  }\n  \n  public static void main(String[] args){\n    parent = mutate(target, 1);\n    int iter = 0;\n    while(!target.equals(parent)){\n      double rate = newMutateRate();\n      iter++;\n      if(iter % 100 == 0){\n        System.out.println(iter +\": \"+parent+ \", fitness: \"+fitness(parent)+\", rate: \"+rate);\n      }\n      String bestSpawn = null;\n      int bestFit = 0;\n      for(int i = 0; i < C; i++){\n        String spawn = mutate(parent, rate);\n        int fitness = fitness(spawn);\n        if(fitness > bestFit){\n          bestSpawn = spawn;\n          bestFit = fitness;\n        }\n      }\n      parent = bestFit > fitness(parent) ? bestSpawn : parent;\n    }\n    System.out.println(parent+\", \"+iter);\n  }\n\n}\n"}
{"id": 138589, "name": "Evolutionary algorithm", "source": "Translate COBOL to Python: identification division.\nprogram-id. evolutionary-program.\ndata division.\nworking-storage section.\n01  evolving-strings.\n    05 target                pic a(28)\n        value 'METHINKS IT IS LIKE A WEASEL'.\n    05 parent                pic a(28).\n    05 offspring-table.\n        10 offspring         pic a(28)\n            occurs 50 times.\n01  fitness-calculations.\n    05 fitness               pic 99.\n    05 highest-fitness       pic 99.\n    05 fittest               pic 99.\n01  parameters.\n    05 character-set         pic a(27)\n        value 'ABCDEFGHIJKLMNOPQRSTUVWXYZ '.\n    05 size-of-generation    pic 99\n        value 50.\n    05 mutation-rate         pic 99\n        value 5.\n01  counters-and-working-variables.\n    05 character-position    pic 99.\n    05 randomization.\n        10 random-seed       pic 9(8).\n        10 random-number     pic 99.\n        10 random-letter     pic 99.\n    05 generation            pic 999.\n    05 child                 pic 99.\n    05 temporary-string      pic a(28).\nprocedure division.\ncontrol-paragraph.\n    accept random-seed from time.\n    move function random(random-seed) to random-number.\n    perform random-letter-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    move temporary-string to parent.\n    move zero to generation.\n    perform output-paragraph.\n    perform evolution-paragraph,\n    varying generation from 1 by 1\n    until parent is equal to target.\n    stop run.\nevolution-paragraph.\n    perform mutation-paragraph varying child from 1 by 1\n    until child is greater than size-of-generation.\n    move zero to highest-fitness.\n    move 1 to fittest.\n    perform check-fitness-paragraph varying child from 1 by 1\n    until child is greater than size-of-generation.\n    move offspring(fittest) to parent.\n    perform output-paragraph.\noutput-paragraph.\n    display generation ': ' parent.\nrandom-letter-paragraph.\n    move function random to random-number.\n    divide random-number by 3.80769 giving random-letter.\n    add 1 to random-letter.\n    move character-set(random-letter:1)\n    to temporary-string(character-position:1).\nmutation-paragraph.\n    move parent to temporary-string.\n    perform character-mutation-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    move temporary-string to offspring(child).\ncharacter-mutation-paragraph.\n    move function random to random-number.\n    if random-number is less than mutation-rate\n    then perform random-letter-paragraph.\ncheck-fitness-paragraph.\n    move offspring(child) to temporary-string.\n    perform fitness-paragraph.\nfitness-paragraph.\n    move zero to fitness.\n    perform character-fitness-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    if fitness is greater than highest-fitness\n    then perform fittest-paragraph.\ncharacter-fitness-paragraph.\n    if temporary-string(character-position:1) is equal to\n    target(character-position:1) then add 1 to fitness.\nfittest-paragraph.\n    move fitness to highest-fitness.\n    move child to fittest.\n", "target": "from string import letters\nfrom random import choice, random\n \ntarget  = list(\"METHINKS IT IS LIKE A WEASEL\")\ncharset = letters + ' '\nparent  = [choice(charset) for _ in range(len(target))]\nminmutaterate  = .09\nC = range(100)\n \nperfectfitness = float(len(target))\n    \ndef fitness(trial):\n    'Sum of matching chars by position'\n    return sum(t==h for t,h in zip(trial, target))\n \ndef mutaterate():\n    'Less mutation the closer the fit of the parent'\n    return 1-((perfectfitness - fitness(parent)) / perfectfitness * (1 - minmutaterate))\n \ndef mutate(parent, rate):\n    return [(ch if random() <= rate else choice(charset)) for ch in parent]\n \ndef que():\n    '(from the favourite saying of Manuel in Fawlty Towers)'\n    print (\"\n           (iterations, fitness(parent)*100./perfectfitness, ''.join(parent)))\n\ndef mate(a, b):\n    place = 0\n    if choice(xrange(10)) < 7:\n        place = choice(xrange(len(target)))\n    else:\n        return a, b\n    \n    return a, b, a[:place] + b[place:], b[:place] + a[place:]\n\niterations = 0\ncenter = len(C)/2\nwhile parent != target:\n    rate = mutaterate()\n    iterations += 1\n    if iterations % 100 == 0: que()\n    copies = [ mutate(parent, rate) for _ in C ]  + [parent]\n    parent1 = max(copies[:center], key=fitness)\n    parent2 = max(copies[center:], key=fitness)\n    parent = max(mate(parent1, parent2), key=fitness)\nque()\n"}
{"id": 138590, "name": "Evolutionary algorithm", "source": "Translate COBOL to Python: identification division.\nprogram-id. evolutionary-program.\ndata division.\nworking-storage section.\n01  evolving-strings.\n    05 target                pic a(28)\n        value 'METHINKS IT IS LIKE A WEASEL'.\n    05 parent                pic a(28).\n    05 offspring-table.\n        10 offspring         pic a(28)\n            occurs 50 times.\n01  fitness-calculations.\n    05 fitness               pic 99.\n    05 highest-fitness       pic 99.\n    05 fittest               pic 99.\n01  parameters.\n    05 character-set         pic a(27)\n        value 'ABCDEFGHIJKLMNOPQRSTUVWXYZ '.\n    05 size-of-generation    pic 99\n        value 50.\n    05 mutation-rate         pic 99\n        value 5.\n01  counters-and-working-variables.\n    05 character-position    pic 99.\n    05 randomization.\n        10 random-seed       pic 9(8).\n        10 random-number     pic 99.\n        10 random-letter     pic 99.\n    05 generation            pic 999.\n    05 child                 pic 99.\n    05 temporary-string      pic a(28).\nprocedure division.\ncontrol-paragraph.\n    accept random-seed from time.\n    move function random(random-seed) to random-number.\n    perform random-letter-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    move temporary-string to parent.\n    move zero to generation.\n    perform output-paragraph.\n    perform evolution-paragraph,\n    varying generation from 1 by 1\n    until parent is equal to target.\n    stop run.\nevolution-paragraph.\n    perform mutation-paragraph varying child from 1 by 1\n    until child is greater than size-of-generation.\n    move zero to highest-fitness.\n    move 1 to fittest.\n    perform check-fitness-paragraph varying child from 1 by 1\n    until child is greater than size-of-generation.\n    move offspring(fittest) to parent.\n    perform output-paragraph.\noutput-paragraph.\n    display generation ': ' parent.\nrandom-letter-paragraph.\n    move function random to random-number.\n    divide random-number by 3.80769 giving random-letter.\n    add 1 to random-letter.\n    move character-set(random-letter:1)\n    to temporary-string(character-position:1).\nmutation-paragraph.\n    move parent to temporary-string.\n    perform character-mutation-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    move temporary-string to offspring(child).\ncharacter-mutation-paragraph.\n    move function random to random-number.\n    if random-number is less than mutation-rate\n    then perform random-letter-paragraph.\ncheck-fitness-paragraph.\n    move offspring(child) to temporary-string.\n    perform fitness-paragraph.\nfitness-paragraph.\n    move zero to fitness.\n    perform character-fitness-paragraph,\n    varying character-position from 1 by 1\n    until character-position is greater than 28.\n    if fitness is greater than highest-fitness\n    then perform fittest-paragraph.\ncharacter-fitness-paragraph.\n    if temporary-string(character-position:1) is equal to\n    target(character-position:1) then add 1 to fitness.\nfittest-paragraph.\n    move fitness to highest-fitness.\n    move child to fittest.\n", "target": "from string import letters\nfrom random import choice, random\n \ntarget  = list(\"METHINKS IT IS LIKE A WEASEL\")\ncharset = letters + ' '\nparent  = [choice(charset) for _ in range(len(target))]\nminmutaterate  = .09\nC = range(100)\n \nperfectfitness = float(len(target))\n    \ndef fitness(trial):\n    'Sum of matching chars by position'\n    return sum(t==h for t,h in zip(trial, target))\n \ndef mutaterate():\n    'Less mutation the closer the fit of the parent'\n    return 1-((perfectfitness - fitness(parent)) / perfectfitness * (1 - minmutaterate))\n \ndef mutate(parent, rate):\n    return [(ch if random() <= rate else choice(charset)) for ch in parent]\n \ndef que():\n    '(from the favourite saying of Manuel in Fawlty Towers)'\n    print (\"\n           (iterations, fitness(parent)*100./perfectfitness, ''.join(parent)))\n\ndef mate(a, b):\n    place = 0\n    if choice(xrange(10)) < 7:\n        place = choice(xrange(len(target)))\n    else:\n        return a, b\n    \n    return a, b, a[:place] + b[place:], b[:place] + a[place:]\n\niterations = 0\ncenter = len(C)/2\nwhile parent != target:\n    rate = mutaterate()\n    iterations += 1\n    if iterations % 100 == 0: que()\n    copies = [ mutate(parent, rate) for _ in C ]  + [parent]\n    parent1 = max(copies[:center], key=fitness)\n    parent2 = max(copies[center:], key=fitness)\n    parent = max(mate(parent1, parent2), key=fitness)\nque()\n"}
{"id": 139131, "name": "Ordered words", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ABC-WORDS.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT DICT ASSIGN TO DISK\n           ORGANIZATION LINE SEQUENTIAL.\n           \n       DATA DIVISION.\n       FILE SECTION.\n       FD DICT \n           LABEL RECORD STANDARD\n           VALUE OF FILE-ID IS \"unixdict.txt\".\n       01 ENTRY.\n          03 WORD         PIC X(32).\n          03 LETTERS      PIC X OCCURS 32 TIMES, REDEFINES WORD.\n       \n       WORKING-STORAGE SECTION.\n       01 LEN             PIC 99.\n       01 MAXLEN          PIC 99 VALUE 0.\n       01 I               PIC 99.\n       01 OK-FLAG         PIC X.\n          88 OK           VALUE '*'.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           OPEN INPUT DICT.\n           \n       FIND-LONGEST-WORD.\n           READ DICT, AT END CLOSE DICT, GO TO PRINT-LONGEST-WORDS.\n           PERFORM CHECK-WORD.\n           GO TO FIND-LONGEST-WORD.\n           \n       PRINT-LONGEST-WORDS.\n           ALTER VALID-WORD TO PROCEED TO SHOW-WORD.\n           OPEN INPUT DICT.\n       \n       READ-WORDS.\n           READ DICT, AT END CLOSE DICT, STOP RUN.\n           PERFORM CHECK-WORD.\n           GO TO READ-WORDS.\n           \n       CHECK-WORD.\n           MOVE ZERO TO LEN.\n           INSPECT WORD TALLYING LEN \n               FOR CHARACTERS BEFORE INITIAL SPACE.\n           MOVE '*' TO OK-FLAG.\n           PERFORM CHECK-CHAR-PAIR VARYING I FROM 2 BY 1\n               UNTIL NOT OK OR I IS GREATER THAN LEN.\n           IF OK, PERFORM DO-WORD.\n       \n       CHECK-CHAR-PAIR.\n           IF LETTERS(I - 1) IS GREATER THAN LETTERS(I), \n               MOVE SPACE TO OK-FLAG.\n         \n       DO-WORD SECTION.         \n       VALID-WORD.\n           GO TO CHECK-LENGTH.\n       CHECK-LENGTH.\n           IF LEN IS GREATER THAN MAXLEN, MOVE LEN TO MAXLEN.\n           GO TO DONE.\n       SHOW-WORD.\n           IF LEN IS EQUAL TO MAXLEN, DISPLAY WORD.\n       DONE.\n           EXIT.\n", "target": "using System;\nusing System.Linq;\nusing System.Net;\n\nstatic class Program\n{\n    static void Main(string[] args)\n    {\n        WebClient client = new WebClient();\n        string text = client.DownloadString(\"http:\n        string[] words = text.Split(new char[] { '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries);\n\n        var query = from w in words\n                    where IsOrderedWord(w)\n                    group w by w.Length into ows\n                    orderby ows.Key descending\n                    select ows;\n\n        Console.WriteLine(string.Join(\", \", query.First().ToArray()));\n    }\n\n    private static bool IsOrderedWord(string w)\n    {\n        for (int i = 1; i < w.Length; i++)\n            if (w[i] < w[i - 1])\n                return false;\n\n        return true;\n    }\n}\n"}
{"id": 139133, "name": "Ordered words", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ABC-WORDS.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT DICT ASSIGN TO DISK\n           ORGANIZATION LINE SEQUENTIAL.\n           \n       DATA DIVISION.\n       FILE SECTION.\n       FD DICT \n           LABEL RECORD STANDARD\n           VALUE OF FILE-ID IS \"unixdict.txt\".\n       01 ENTRY.\n          03 WORD         PIC X(32).\n          03 LETTERS      PIC X OCCURS 32 TIMES, REDEFINES WORD.\n       \n       WORKING-STORAGE SECTION.\n       01 LEN             PIC 99.\n       01 MAXLEN          PIC 99 VALUE 0.\n       01 I               PIC 99.\n       01 OK-FLAG         PIC X.\n          88 OK           VALUE '*'.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           OPEN INPUT DICT.\n           \n       FIND-LONGEST-WORD.\n           READ DICT, AT END CLOSE DICT, GO TO PRINT-LONGEST-WORDS.\n           PERFORM CHECK-WORD.\n           GO TO FIND-LONGEST-WORD.\n           \n       PRINT-LONGEST-WORDS.\n           ALTER VALID-WORD TO PROCEED TO SHOW-WORD.\n           OPEN INPUT DICT.\n       \n       READ-WORDS.\n           READ DICT, AT END CLOSE DICT, STOP RUN.\n           PERFORM CHECK-WORD.\n           GO TO READ-WORDS.\n           \n       CHECK-WORD.\n           MOVE ZERO TO LEN.\n           INSPECT WORD TALLYING LEN \n               FOR CHARACTERS BEFORE INITIAL SPACE.\n           MOVE '*' TO OK-FLAG.\n           PERFORM CHECK-CHAR-PAIR VARYING I FROM 2 BY 1\n               UNTIL NOT OK OR I IS GREATER THAN LEN.\n           IF OK, PERFORM DO-WORD.\n       \n       CHECK-CHAR-PAIR.\n           IF LETTERS(I - 1) IS GREATER THAN LETTERS(I), \n               MOVE SPACE TO OK-FLAG.\n         \n       DO-WORD SECTION.         \n       VALID-WORD.\n           GO TO CHECK-LENGTH.\n       CHECK-LENGTH.\n           IF LEN IS GREATER THAN MAXLEN, MOVE LEN TO MAXLEN.\n           GO TO DONE.\n       SHOW-WORD.\n           IF LEN IS EQUAL TO MAXLEN, DISPLAY WORD.\n       DONE.\n           EXIT.\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Ordered {\n\n\tprivate static boolean isOrderedWord(String word){\n\t\tchar[] sortedWord = word.toCharArray();\n\t\tArrays.sort(sortedWord);\n\t\treturn word.equals(new String(sortedWord));\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tList<String> orderedWords = new LinkedList<String>();\n\t\tBufferedReader in = new BufferedReader(new FileReader(args[0]));\n\t\twhile(in.ready()){\n\t\t\tString word = in.readLine();\n\t\t\tif(isOrderedWord(word)) orderedWords.add(word);\n\t\t}\n\t\tin.close();\n\t\t\n\t\tCollections.<String>sort(orderedWords, new Comparator<String>() {\n\t\t\t@Override\n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\treturn new Integer(o2.length()).compareTo(o1.length());\n\t\t\t}\n\t\t});\n\t\t\n\t\tint maxLen = orderedWords.get(0).length();\n\t\tfor(String word: orderedWords){\n\t\t\tif(word.length() == maxLen){\n\t\t\t\tSystem.out.println(word);\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 139134, "name": "Ordered words", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ABC-WORDS.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT DICT ASSIGN TO DISK\n           ORGANIZATION LINE SEQUENTIAL.\n           \n       DATA DIVISION.\n       FILE SECTION.\n       FD DICT \n           LABEL RECORD STANDARD\n           VALUE OF FILE-ID IS \"unixdict.txt\".\n       01 ENTRY.\n          03 WORD         PIC X(32).\n          03 LETTERS      PIC X OCCURS 32 TIMES, REDEFINES WORD.\n       \n       WORKING-STORAGE SECTION.\n       01 LEN             PIC 99.\n       01 MAXLEN          PIC 99 VALUE 0.\n       01 I               PIC 99.\n       01 OK-FLAG         PIC X.\n          88 OK           VALUE '*'.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           OPEN INPUT DICT.\n           \n       FIND-LONGEST-WORD.\n           READ DICT, AT END CLOSE DICT, GO TO PRINT-LONGEST-WORDS.\n           PERFORM CHECK-WORD.\n           GO TO FIND-LONGEST-WORD.\n           \n       PRINT-LONGEST-WORDS.\n           ALTER VALID-WORD TO PROCEED TO SHOW-WORD.\n           OPEN INPUT DICT.\n       \n       READ-WORDS.\n           READ DICT, AT END CLOSE DICT, STOP RUN.\n           PERFORM CHECK-WORD.\n           GO TO READ-WORDS.\n           \n       CHECK-WORD.\n           MOVE ZERO TO LEN.\n           INSPECT WORD TALLYING LEN \n               FOR CHARACTERS BEFORE INITIAL SPACE.\n           MOVE '*' TO OK-FLAG.\n           PERFORM CHECK-CHAR-PAIR VARYING I FROM 2 BY 1\n               UNTIL NOT OK OR I IS GREATER THAN LEN.\n           IF OK, PERFORM DO-WORD.\n       \n       CHECK-CHAR-PAIR.\n           IF LETTERS(I - 1) IS GREATER THAN LETTERS(I), \n               MOVE SPACE TO OK-FLAG.\n         \n       DO-WORD SECTION.         \n       VALID-WORD.\n           GO TO CHECK-LENGTH.\n       CHECK-LENGTH.\n           IF LEN IS GREATER THAN MAXLEN, MOVE LEN TO MAXLEN.\n           GO TO DONE.\n       SHOW-WORD.\n           IF LEN IS EQUAL TO MAXLEN, DISPLAY WORD.\n       DONE.\n           EXIT.\n", "target": "import urllib.request\n\nurl = 'http://www.puzzlers.org/pub/wordlists/unixdict.txt'\nwords = urllib.request.urlopen(url).read().decode(\"utf-8\").split()\nordered = [word for word in words if word==''.join(sorted(word))]\nmaxlen = len(max(ordered, key=len))\nmaxorderedwords = [word for word in ordered if len(word) == maxlen]\nprint(' '.join(maxorderedwords))\n"}
{"id": 139371, "name": "Arrays", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. arrays.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  fixed-length-table.\n           03  fixed-table-elt      PIC X OCCURS 5 TIMES.\n\n       01  table-length             PIC 9(5) VALUE 1.\n       01  variable-length-table.\n           03  variable-table-elt   PIC X OCCURS 1 TO 5 TIMES\n               DEPENDING ON table-length.\n\n       01  initial-value-area.\n           03  initial-values.\n               05  FILLER           PIC X(10) VALUE \"One\".\n               05  FILLER           PIC X(10) VALUE \"Two\".\n               05  FILLER           PIC X(10) VALUE \"Three\".\n           03 initial-value-table REDEFINES initial-values.\n              05  initial-table-elt PIC X(10) OCCURS 3 TIMES.\n\n       01  indexed-table.\n           03  indexed-elt          PIC X OCCURS 5 TIMES\n               INDEXED BY table-index.\n\n       PROCEDURE DIVISION.\n           \n           MOVE \"12345\" TO fixed-length-table\n           \n           \n           MOVE 1 TO table-index\n           MOVE \"1\" TO indexed-elt (table-index)\n\n           \n           ADD 1 TO table-length\n           MOVE \"1\" TO variable-table-elt (2)\n\n           GOBACK\n           .\n", "target": " int[] numbers = new int[10];\n"}
{"id": 139373, "name": "Arrays", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. arrays.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  fixed-length-table.\n           03  fixed-table-elt      PIC X OCCURS 5 TIMES.\n\n       01  table-length             PIC 9(5) VALUE 1.\n       01  variable-length-table.\n           03  variable-table-elt   PIC X OCCURS 1 TO 5 TIMES\n               DEPENDING ON table-length.\n\n       01  initial-value-area.\n           03  initial-values.\n               05  FILLER           PIC X(10) VALUE \"One\".\n               05  FILLER           PIC X(10) VALUE \"Two\".\n               05  FILLER           PIC X(10) VALUE \"Three\".\n           03 initial-value-table REDEFINES initial-values.\n              05  initial-table-elt PIC X(10) OCCURS 3 TIMES.\n\n       01  indexed-table.\n           03  indexed-elt          PIC X OCCURS 5 TIMES\n               INDEXED BY table-index.\n\n       PROCEDURE DIVISION.\n           \n           MOVE \"12345\" TO fixed-length-table\n           \n           \n           MOVE 1 TO table-index\n           MOVE \"1\" TO indexed-elt (table-index)\n\n           \n           ADD 1 TO table-length\n           MOVE \"1\" TO variable-table-elt (2)\n\n           GOBACK\n           .\n", "target": "Int[] literalArray = [1,2,3];\nInt[] fixedLengthArray = new Int[10];\nInt[] variableArray = new Int[];\n\nassert literalArray.size == 3; \nInt n = literalArray[2];       \nfixedLengthArray[4] = 12345;   \n\nfixedLengthArray += 6789;  \nvariableArray    += 6789;  \n"}
{"id": 139374, "name": "Arrays", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. arrays.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  fixed-length-table.\n           03  fixed-table-elt      PIC X OCCURS 5 TIMES.\n\n       01  table-length             PIC 9(5) VALUE 1.\n       01  variable-length-table.\n           03  variable-table-elt   PIC X OCCURS 1 TO 5 TIMES\n               DEPENDING ON table-length.\n\n       01  initial-value-area.\n           03  initial-values.\n               05  FILLER           PIC X(10) VALUE \"One\".\n               05  FILLER           PIC X(10) VALUE \"Two\".\n               05  FILLER           PIC X(10) VALUE \"Three\".\n           03 initial-value-table REDEFINES initial-values.\n              05  initial-table-elt PIC X(10) OCCURS 3 TIMES.\n\n       01  indexed-table.\n           03  indexed-elt          PIC X OCCURS 5 TIMES\n               INDEXED BY table-index.\n\n       PROCEDURE DIVISION.\n           \n           MOVE \"12345\" TO fixed-length-table\n           \n           \n           MOVE 1 TO table-index\n           MOVE \"1\" TO indexed-elt (table-index)\n\n           \n           ADD 1 TO table-length\n           MOVE \"1\" TO variable-table-elt (2)\n\n           GOBACK\n           .\n", "target": "array = []\n\narray.append(1)\narray.append(3)\n\narray[0] = 2\n\nprint(array[0])\n"}
{"id": 141336, "name": "Tokenize a string with escaping", "source": "Translate COBOL to C#:        >>SOURCE FORMAT FREE\nidentification division.\nprogram-id. 'tokenizewithescaping'.\nenvironment division.\nconfiguration section.\nrepository.\n    function all intrinsic.\ndata division.\nworking-storage section.\n\n01 escape-char pic x value '^'.\n01 separator-char pic x value '|'.\n01 reference-string pic x(64) value\n   'one^|uno||three^^^^|four^^^|^cuatro|'.\n\n01 input-string pic x(64).\n01 c pic 99.\n01 escaped pic x.\n\n01 t pic 99.\n01 t-max pic 99.\n01 t-lim pic 99 value 32.\n01 token-entry occurs 32.\n   03  token-len pic 99.\n   03  token pic x(16).\n\n01 l pic 99.\n01 l-lim pic 99 value 16.\n\n01 error-found pic x.\n\nprocedure division.\nstart-tokenize-with-escaping.\n\n    move reference-string to input-string\n    perform tokenize\n\n    move 'token' to input-string\n    perform tokenize\n   \n    move '^^^^^^^^' to input-string\n    perform tokenize\n   \n    move '||||||||' to input-string\n    perform tokenize\n\n    move all 'token' to input-string\n    perform tokenize\n\n    move all 't|' to input-string\n    perform tokenize\n\n    move spaces to input-string\n    perform tokenize\n\n    display space\n\n    stop run\n    .\ntokenize.\n    display space\n    display 'string:'\n    display input-string\n\n    move 'N' to escaped error-found\n    move 1 to t-max\n    initialize token-entry(t-max)\n    move 0 to l\n\n    perform varying c from 1 by 1 until\n    c > length(input-string)\n    or input-string(c:) = spaces\n\n        evaluate escaped also input-string(c:1)\n        when 'N' also escape-char\n            move 'Y' to escaped\n        when 'N' also separator-char\n            perform increment-t-max\n            if error-found = 'Y'\n                exit paragraph\n            end-if\n        when 'N' also any\n            perform move-c\n            if error-found = 'Y'\n                exit paragraph\n            end-if\n        when 'Y' also any\n            perform move-c\n            if error-found = 'Y'\n                exit paragraph\n            end-if\n            move 'N' to escaped\n        end-evaluate\n\n    end-perform\n    if l > 0\n        move l to token-len(t-max)\n    end-if\n\n    if c = 1\n        display 'no tokens'\n    else\n        display 'tokens:'\n        perform varying t from 1 by 1 until t > t-max\n            if token-len(t) > 0\n                display t ': ' token-len(t) space token(t)\n            else\n                display t ': ' token-len(t)\n            end-if\n        end-perform\n    end-if\n    .\nincrement-t-max.\n    if t-max >= t-lim\n        display 'error: at ' c ' number of tokens exceeds ' t-lim\n        move 'Y' to error-found\n    else\n        move l to token-len(t-max)\n        add 1 to t-max\n        initialize token-entry(t-max)\n        move 0 to l\n        move 'N' to error-found\n    end-if\n    .\nmove-c.\n    if l >= l-lim\n        display 'error: at ' c ' token length exceeds ' l-lim\n        move 'Y' to error-found\n    else\n        add 1 to l\n        move input-string(c:1) to token(t-max)(l:1)\n        move 'N' to error-found\n    end-if\n    .\nend program 'tokenizewithescaping'.\n", "target": "using System;\nusing System.Text;\nusing System.Collections.Generic;\n\npublic class TokenizeAStringWithEscaping\n{\n    public static void Main() {\n        string testcase = \"one^|uno||three^^^^|four^^^|^cuatro|\";\n        foreach (var token in testcase.Tokenize(separator: '|', escape: '^')) {\n            Console.WriteLine(\": \" + token); \n        }\n    }\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> Tokenize(this string input, char separator, char escape) {\n        if (input == null) yield break;\n        var buffer = new StringBuilder();\n        bool escaping = false;\n        foreach (char c in input) {\n            if (escaping) {\n                buffer.Append(c);\n                escaping = false;\n            } else if (c == escape) {\n                escaping = true;\n            } else if (c == separator) {\n                yield return buffer.Flush();\n            } else {\n                buffer.Append(c);\n            }\n        }\n        if (buffer.Length > 0 || input[input.Length-1] == separator) yield return buffer.Flush();\n    }\n    \n    public static string Flush(this StringBuilder stringBuilder) {\n        string result = stringBuilder.ToString();\n        stringBuilder.Clear();\n        return result;\n    }\n}\n"}
{"id": 141338, "name": "Tokenize a string with escaping", "source": "Translate COBOL to Java:        >>SOURCE FORMAT FREE\nidentification division.\nprogram-id. 'tokenizewithescaping'.\nenvironment division.\nconfiguration section.\nrepository.\n    function all intrinsic.\ndata division.\nworking-storage section.\n\n01 escape-char pic x value '^'.\n01 separator-char pic x value '|'.\n01 reference-string pic x(64) value\n   'one^|uno||three^^^^|four^^^|^cuatro|'.\n\n01 input-string pic x(64).\n01 c pic 99.\n01 escaped pic x.\n\n01 t pic 99.\n01 t-max pic 99.\n01 t-lim pic 99 value 32.\n01 token-entry occurs 32.\n   03  token-len pic 99.\n   03  token pic x(16).\n\n01 l pic 99.\n01 l-lim pic 99 value 16.\n\n01 error-found pic x.\n\nprocedure division.\nstart-tokenize-with-escaping.\n\n    move reference-string to input-string\n    perform tokenize\n\n    move 'token' to input-string\n    perform tokenize\n   \n    move '^^^^^^^^' to input-string\n    perform tokenize\n   \n    move '||||||||' to input-string\n    perform tokenize\n\n    move all 'token' to input-string\n    perform tokenize\n\n    move all 't|' to input-string\n    perform tokenize\n\n    move spaces to input-string\n    perform tokenize\n\n    display space\n\n    stop run\n    .\ntokenize.\n    display space\n    display 'string:'\n    display input-string\n\n    move 'N' to escaped error-found\n    move 1 to t-max\n    initialize token-entry(t-max)\n    move 0 to l\n\n    perform varying c from 1 by 1 until\n    c > length(input-string)\n    or input-string(c:) = spaces\n\n        evaluate escaped also input-string(c:1)\n        when 'N' also escape-char\n            move 'Y' to escaped\n        when 'N' also separator-char\n            perform increment-t-max\n            if error-found = 'Y'\n                exit paragraph\n            end-if\n        when 'N' also any\n            perform move-c\n            if error-found = 'Y'\n                exit paragraph\n            end-if\n        when 'Y' also any\n            perform move-c\n            if error-found = 'Y'\n                exit paragraph\n            end-if\n            move 'N' to escaped\n        end-evaluate\n\n    end-perform\n    if l > 0\n        move l to token-len(t-max)\n    end-if\n\n    if c = 1\n        display 'no tokens'\n    else\n        display 'tokens:'\n        perform varying t from 1 by 1 until t > t-max\n            if token-len(t) > 0\n                display t ': ' token-len(t) space token(t)\n            else\n                display t ': ' token-len(t)\n            end-if\n        end-perform\n    end-if\n    .\nincrement-t-max.\n    if t-max >= t-lim\n        display 'error: at ' c ' number of tokens exceeds ' t-lim\n        move 'Y' to error-found\n    else\n        move l to token-len(t-max)\n        add 1 to t-max\n        initialize token-entry(t-max)\n        move 0 to l\n        move 'N' to error-found\n    end-if\n    .\nmove-c.\n    if l >= l-lim\n        display 'error: at ' c ' token length exceeds ' l-lim\n        move 'Y' to error-found\n    else\n        add 1 to l\n        move input-string(c:1) to token(t-max)(l:1)\n        move 'N' to error-found\n    end-if\n    .\nend program 'tokenizewithescaping'.\n", "target": "import java.util.*;\n\npublic class TokenizeStringWithEscaping {\n\n    public static void main(String[] args) {\n        String sample = \"one^|uno||three^^^^|four^^^|^cuatro|\";\n        char separator = '|';\n        char escape = '^';\n\n        System.out.println(sample);\n        try {\n            System.out.println(tokenizeString(sample, separator, escape));\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    public static List<String> tokenizeString(String s, char sep, char escape)\n            throws Exception {\n        List<String> tokens = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n\n        boolean inEscape = false;\n        for (char c : s.toCharArray()) {\n            if (inEscape) {\n                inEscape = false;\n            } else if (c == escape) {\n                inEscape = true;\n                continue;\n            } else if (c == sep) {\n                tokens.add(sb.toString());\n                sb.setLength(0);\n                continue;\n            }\n            sb.append(c);\n        }\n        if (inEscape)\n            throw new Exception(\"Invalid terminal escape\");\n\n        tokens.add(sb.toString());\n\n        return tokens;\n    }\n}\n"}
{"id": 141339, "name": "Tokenize a string with escaping", "source": "Translate COBOL to Python:        >>SOURCE FORMAT FREE\nidentification division.\nprogram-id. 'tokenizewithescaping'.\nenvironment division.\nconfiguration section.\nrepository.\n    function all intrinsic.\ndata division.\nworking-storage section.\n\n01 escape-char pic x value '^'.\n01 separator-char pic x value '|'.\n01 reference-string pic x(64) value\n   'one^|uno||three^^^^|four^^^|^cuatro|'.\n\n01 input-string pic x(64).\n01 c pic 99.\n01 escaped pic x.\n\n01 t pic 99.\n01 t-max pic 99.\n01 t-lim pic 99 value 32.\n01 token-entry occurs 32.\n   03  token-len pic 99.\n   03  token pic x(16).\n\n01 l pic 99.\n01 l-lim pic 99 value 16.\n\n01 error-found pic x.\n\nprocedure division.\nstart-tokenize-with-escaping.\n\n    move reference-string to input-string\n    perform tokenize\n\n    move 'token' to input-string\n    perform tokenize\n   \n    move '^^^^^^^^' to input-string\n    perform tokenize\n   \n    move '||||||||' to input-string\n    perform tokenize\n\n    move all 'token' to input-string\n    perform tokenize\n\n    move all 't|' to input-string\n    perform tokenize\n\n    move spaces to input-string\n    perform tokenize\n\n    display space\n\n    stop run\n    .\ntokenize.\n    display space\n    display 'string:'\n    display input-string\n\n    move 'N' to escaped error-found\n    move 1 to t-max\n    initialize token-entry(t-max)\n    move 0 to l\n\n    perform varying c from 1 by 1 until\n    c > length(input-string)\n    or input-string(c:) = spaces\n\n        evaluate escaped also input-string(c:1)\n        when 'N' also escape-char\n            move 'Y' to escaped\n        when 'N' also separator-char\n            perform increment-t-max\n            if error-found = 'Y'\n                exit paragraph\n            end-if\n        when 'N' also any\n            perform move-c\n            if error-found = 'Y'\n                exit paragraph\n            end-if\n        when 'Y' also any\n            perform move-c\n            if error-found = 'Y'\n                exit paragraph\n            end-if\n            move 'N' to escaped\n        end-evaluate\n\n    end-perform\n    if l > 0\n        move l to token-len(t-max)\n    end-if\n\n    if c = 1\n        display 'no tokens'\n    else\n        display 'tokens:'\n        perform varying t from 1 by 1 until t > t-max\n            if token-len(t) > 0\n                display t ': ' token-len(t) space token(t)\n            else\n                display t ': ' token-len(t)\n            end-if\n        end-perform\n    end-if\n    .\nincrement-t-max.\n    if t-max >= t-lim\n        display 'error: at ' c ' number of tokens exceeds ' t-lim\n        move 'Y' to error-found\n    else\n        move l to token-len(t-max)\n        add 1 to t-max\n        initialize token-entry(t-max)\n        move 0 to l\n        move 'N' to error-found\n    end-if\n    .\nmove-c.\n    if l >= l-lim\n        display 'error: at ' c ' token length exceeds ' l-lim\n        move 'Y' to error-found\n    else\n        add 1 to l\n        move input-string(c:1) to token(t-max)(l:1)\n        move 'N' to error-found\n    end-if\n    .\nend program 'tokenizewithescaping'.\n", "target": "def token_with_escape(a, escape = '^', separator = '|'):\n    \n    result = []\n    token = ''\n    state = 0\n    for c in a:\n        if state == 0:\n            if c == escape:\n                state = 1\n            elif c == separator:\n                result.append(token)\n                token = ''\n            else:\n                token += c\n        elif state == 1:\n            token += c\n            state = 0\n    result.append(token)\n    return result\n"}
{"id": 142321, "name": "String prepend", "source": "Translate COBOL to C#:        identification division.\n       program-id. prepend.\n       data division.\n       working-storage section.\n       1 str pic x(30) value \"World!\".\n       1 binary.\n        2 len pic 9(4) value 0.\n        2 scratch pic 9(4) value 0.\n       procedure division.\n       begin.\n           perform rev-sub-str\n           move function reverse (\"Hello \") to str (len + 1:)\n           perform rev-sub-str\n           display str\n           stop run\n           .\n\n       rev-sub-str.\n           move 0 to len scratch\n           inspect function reverse (str)\n           tallying scratch for leading spaces\n               len for characters after space\n           move function reverse (str (1:len)) to str\n           .\n       end program prepend.\n", "target": "using System;\n\nnamespace PrependString\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string str = \"World\";\n            str = \"Hello \" + str;\n            Console.WriteLine(str);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 142323, "name": "String prepend", "source": "Translate COBOL to Java:        identification division.\n       program-id. prepend.\n       data division.\n       working-storage section.\n       1 str pic x(30) value \"World!\".\n       1 binary.\n        2 len pic 9(4) value 0.\n        2 scratch pic 9(4) value 0.\n       procedure division.\n       begin.\n           perform rev-sub-str\n           move function reverse (\"Hello \") to str (len + 1:)\n           perform rev-sub-str\n           display str\n           stop run\n           .\n\n       rev-sub-str.\n           move 0 to len scratch\n           inspect function reverse (str)\n           tallying scratch for leading spaces\n               len for characters after space\n           move function reverse (str (1:len)) to str\n           .\n       end program prepend.\n", "target": "\npublic class Prepend {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"world\");\n        sb.insert(0, \"Hello, \");\n        System.out.println(sb);\n    }\n}\n"}
{"id": 142324, "name": "String prepend", "source": "Translate COBOL to Python:        identification division.\n       program-id. prepend.\n       data division.\n       working-storage section.\n       1 str pic x(30) value \"World!\".\n       1 binary.\n        2 len pic 9(4) value 0.\n        2 scratch pic 9(4) value 0.\n       procedure division.\n       begin.\n           perform rev-sub-str\n           move function reverse (\"Hello \") to str (len + 1:)\n           perform rev-sub-str\n           display str\n           stop run\n           .\n\n       rev-sub-str.\n           move 0 to len scratch\n           inspect function reverse (str)\n           tallying scratch for leading spaces\n               len for characters after space\n           move function reverse (str (1:len)) to str\n           .\n       end program prepend.\n", "target": "\n\n\ns = \"12345678\"\ns = \"0\" + s  \nprint(s)\n"}
{"id": 142546, "name": "Currency", "source": "Translate COBOL to C#:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. currency-example.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  Burger-Price                        CONSTANT 5.50.\n01  Milkshake-Price                     CONSTANT 2.86.\n01  num-burgers                         PIC 9(18) VALUE 4000000000000000.\n01  num-milkshakes                      PIC 9(18) VALUE 2.\n01  tax                                 PIC 9(18)V99.\n01  tax-edited                          PIC $(17)9.99.\n01  Tax-Rate                            CONSTANT 7.65.\n01  total                               PIC 9(18)V99.\n01  total-edited                        PIC $(17)9.99.\n\nPROCEDURE DIVISION.\n    COMPUTE total rounded, total-edited rounded =\n        num-burgers * Burger-Price + num-milkshakes * Milkshake-Price\n    DISPLAY \"Total before tax: \" total-edited\n\n    COMPUTE tax rounded, tax-edited rounded = total * (Tax-Rate / 100)\n    DISPLAY \"             Tax: \" tax-edited\n\n    ADD tax TO total GIVING total-edited rounded\n    DISPLAY \"  Total with tax: \" total-edited\n    .\nEND PROGRAM currency-example.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Currency\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            MenuItem hamburger = new MenuItem() { Name = \"Hamburger\", Price = 5.5M };\n            MenuItem milkshake = new MenuItem() { Name = \"Milkshake\", Price = 2.86M };\n\n            IList<CartItem> cart = new List<CartItem>();\n            cart.Add(new CartItem() { item = hamburger, quantity = 4000000000000000 });\n            cart.Add(new CartItem() { item = milkshake, quantity = 2 });\n\n            decimal total = CalculateTotal(cart);\n\n            Console.WriteLine(string.Format(\"Total before tax: {0:C}\", total));\n\n            \n            decimal tax = total * 0.0765M;\n\n            Console.WriteLine(string.Format(\"Tax: {0:C}\", tax));\n\n            total += tax;\n\n            Console.WriteLine(string.Format(\"Total with tax: {0:C}\", total));\n        }\n\n        private static decimal CalculateTotal(IList<CartItem> cart)\n        {\n            decimal total = 0M;\n\n            foreach (CartItem item in cart)\n            {\n                total += item.quantity * item.item.Price;\n            }\n\n            return total;\n        }\n\n        private struct MenuItem\n        {\n            public string Name { get; set; }\n            public decimal Price { get; set; }\n        }\n\n        private struct CartItem\n        {\n            public MenuItem item { get; set; }\n            public decimal quantity { get; set; }\n        }\n    }\n}\n"}
{"id": 142547, "name": "Currency", "source": "Translate COBOL to C#:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. currency-example.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  Burger-Price                        CONSTANT 5.50.\n01  Milkshake-Price                     CONSTANT 2.86.\n01  num-burgers                         PIC 9(18) VALUE 4000000000000000.\n01  num-milkshakes                      PIC 9(18) VALUE 2.\n01  tax                                 PIC 9(18)V99.\n01  tax-edited                          PIC $(17)9.99.\n01  Tax-Rate                            CONSTANT 7.65.\n01  total                               PIC 9(18)V99.\n01  total-edited                        PIC $(17)9.99.\n\nPROCEDURE DIVISION.\n    COMPUTE total rounded, total-edited rounded =\n        num-burgers * Burger-Price + num-milkshakes * Milkshake-Price\n    DISPLAY \"Total before tax: \" total-edited\n\n    COMPUTE tax rounded, tax-edited rounded = total * (Tax-Rate / 100)\n    DISPLAY \"             Tax: \" tax-edited\n\n    ADD tax TO total GIVING total-edited rounded\n    DISPLAY \"  Total with tax: \" total-edited\n    .\nEND PROGRAM currency-example.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Currency\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            MenuItem hamburger = new MenuItem() { Name = \"Hamburger\", Price = 5.5M };\n            MenuItem milkshake = new MenuItem() { Name = \"Milkshake\", Price = 2.86M };\n\n            IList<CartItem> cart = new List<CartItem>();\n            cart.Add(new CartItem() { item = hamburger, quantity = 4000000000000000 });\n            cart.Add(new CartItem() { item = milkshake, quantity = 2 });\n\n            decimal total = CalculateTotal(cart);\n\n            Console.WriteLine(string.Format(\"Total before tax: {0:C}\", total));\n\n            \n            decimal tax = total * 0.0765M;\n\n            Console.WriteLine(string.Format(\"Tax: {0:C}\", tax));\n\n            total += tax;\n\n            Console.WriteLine(string.Format(\"Total with tax: {0:C}\", total));\n        }\n\n        private static decimal CalculateTotal(IList<CartItem> cart)\n        {\n            decimal total = 0M;\n\n            foreach (CartItem item in cart)\n            {\n                total += item.quantity * item.item.Price;\n            }\n\n            return total;\n        }\n\n        private struct MenuItem\n        {\n            public string Name { get; set; }\n            public decimal Price { get; set; }\n        }\n\n        private struct CartItem\n        {\n            public MenuItem item { get; set; }\n            public decimal quantity { get; set; }\n        }\n    }\n}\n"}
{"id": 142548, "name": "Currency", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. currency-example.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  Burger-Price                        CONSTANT 5.50.\n01  Milkshake-Price                     CONSTANT 2.86.\n01  num-burgers                         PIC 9(18) VALUE 4000000000000000.\n01  num-milkshakes                      PIC 9(18) VALUE 2.\n01  tax                                 PIC 9(18)V99.\n01  tax-edited                          PIC $(17)9.99.\n01  Tax-Rate                            CONSTANT 7.65.\n01  total                               PIC 9(18)V99.\n01  total-edited                        PIC $(17)9.99.\n\nPROCEDURE DIVISION.\n    COMPUTE total rounded, total-edited rounded =\n        num-burgers * Burger-Price + num-milkshakes * Milkshake-Price\n    DISPLAY \"Total before tax: \" total-edited\n\n    COMPUTE tax rounded, tax-edited rounded = total * (Tax-Rate / 100)\n    DISPLAY \"             Tax: \" tax-edited\n\n    ADD tax TO total GIVING total-edited rounded\n    DISPLAY \"  Total with tax: \" total-edited\n    .\nEND PROGRAM currency-example.\n", "target": "import java.math.*;\nimport java.util.*;\n\npublic class Currency {\n    final static String taxrate = \"7.65\";\n\n    enum MenuItem {\n\n        Hamburger(\"5.50\"), Milkshake(\"2.86\");\n\n        private MenuItem(String p) {\n            price = new BigDecimal(p);\n        }\n\n        public final BigDecimal price;\n    }\n\n    public static void main(String[] args) {\n        Locale.setDefault(Locale.ENGLISH);\n\n        MathContext mc = MathContext.DECIMAL128;\n\n        Map<MenuItem, BigDecimal> order = new HashMap<>();\n        order.put(MenuItem.Hamburger, new BigDecimal(\"4000000000000000\"));\n        order.put(MenuItem.Milkshake, new BigDecimal(\"2\"));\n\n        BigDecimal subtotal = BigDecimal.ZERO;\n        for (MenuItem it : order.keySet())\n            subtotal = subtotal.add(it.price.multiply(order.get(it), mc));\n\n        BigDecimal tax = new BigDecimal(taxrate, mc);\n        tax = tax.divide(new BigDecimal(\"100\"), mc);\n        tax = subtotal.multiply(tax, mc);\n\n        System.out.printf(\"Subtotal: %20.2f%n\", subtotal);\n        System.out.printf(\"     Tax: %20.2f%n\", tax);\n        System.out.printf(\"   Total: %20.2f%n\", subtotal.add(tax));\n    }\n}\n"}
{"id": 142549, "name": "Currency", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. currency-example.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  Burger-Price                        CONSTANT 5.50.\n01  Milkshake-Price                     CONSTANT 2.86.\n01  num-burgers                         PIC 9(18) VALUE 4000000000000000.\n01  num-milkshakes                      PIC 9(18) VALUE 2.\n01  tax                                 PIC 9(18)V99.\n01  tax-edited                          PIC $(17)9.99.\n01  Tax-Rate                            CONSTANT 7.65.\n01  total                               PIC 9(18)V99.\n01  total-edited                        PIC $(17)9.99.\n\nPROCEDURE DIVISION.\n    COMPUTE total rounded, total-edited rounded =\n        num-burgers * Burger-Price + num-milkshakes * Milkshake-Price\n    DISPLAY \"Total before tax: \" total-edited\n\n    COMPUTE tax rounded, tax-edited rounded = total * (Tax-Rate / 100)\n    DISPLAY \"             Tax: \" tax-edited\n\n    ADD tax TO total GIVING total-edited rounded\n    DISPLAY \"  Total with tax: \" total-edited\n    .\nEND PROGRAM currency-example.\n", "target": "import java.math.*;\nimport java.util.*;\n\npublic class Currency {\n    final static String taxrate = \"7.65\";\n\n    enum MenuItem {\n\n        Hamburger(\"5.50\"), Milkshake(\"2.86\");\n\n        private MenuItem(String p) {\n            price = new BigDecimal(p);\n        }\n\n        public final BigDecimal price;\n    }\n\n    public static void main(String[] args) {\n        Locale.setDefault(Locale.ENGLISH);\n\n        MathContext mc = MathContext.DECIMAL128;\n\n        Map<MenuItem, BigDecimal> order = new HashMap<>();\n        order.put(MenuItem.Hamburger, new BigDecimal(\"4000000000000000\"));\n        order.put(MenuItem.Milkshake, new BigDecimal(\"2\"));\n\n        BigDecimal subtotal = BigDecimal.ZERO;\n        for (MenuItem it : order.keySet())\n            subtotal = subtotal.add(it.price.multiply(order.get(it), mc));\n\n        BigDecimal tax = new BigDecimal(taxrate, mc);\n        tax = tax.divide(new BigDecimal(\"100\"), mc);\n        tax = subtotal.multiply(tax, mc);\n\n        System.out.printf(\"Subtotal: %20.2f%n\", subtotal);\n        System.out.printf(\"     Tax: %20.2f%n\", tax);\n        System.out.printf(\"   Total: %20.2f%n\", subtotal.add(tax));\n    }\n}\n"}
{"id": 142550, "name": "Currency", "source": "Translate COBOL to Python:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. currency-example.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  Burger-Price                        CONSTANT 5.50.\n01  Milkshake-Price                     CONSTANT 2.86.\n01  num-burgers                         PIC 9(18) VALUE 4000000000000000.\n01  num-milkshakes                      PIC 9(18) VALUE 2.\n01  tax                                 PIC 9(18)V99.\n01  tax-edited                          PIC $(17)9.99.\n01  Tax-Rate                            CONSTANT 7.65.\n01  total                               PIC 9(18)V99.\n01  total-edited                        PIC $(17)9.99.\n\nPROCEDURE DIVISION.\n    COMPUTE total rounded, total-edited rounded =\n        num-burgers * Burger-Price + num-milkshakes * Milkshake-Price\n    DISPLAY \"Total before tax: \" total-edited\n\n    COMPUTE tax rounded, tax-edited rounded = total * (Tax-Rate / 100)\n    DISPLAY \"             Tax: \" tax-edited\n\n    ADD tax TO total GIVING total-edited rounded\n    DISPLAY \"  Total with tax: \" total-edited\n    .\nEND PROGRAM currency-example.\n", "target": "from decimal import Decimal as D\nfrom collections import namedtuple\n\nItem = namedtuple('Item', 'price, quant')\n\nitems = dict( hamburger=Item(D('5.50'), D('4000000000000000')),\n              milkshake=Item(D('2.86'), D('2')) )\ntax_rate = D('0.0765')\n\nfmt = \"%-10s %8s %18s %22s\"\nprint(fmt % tuple('Item Price Quantity Extension'.upper().split()))\n\ntotal_before_tax = 0\nfor item, (price, quant) in sorted(items.items()):\n    ext = price * quant\n    print(fmt % (item, price, quant, ext))\n    total_before_tax += ext\nprint(fmt % ('', '', '', '--------------------'))\nprint(fmt % ('', '', 'subtotal', total_before_tax))\n\ntax = (tax_rate * total_before_tax).quantize(D('0.00'))\nprint(fmt % ('', '', 'Tax', tax))\n\ntotal = total_before_tax + tax\nprint(fmt % ('', '', '', '--------------------'))\nprint(fmt % ('', '', 'Total', total))\n"}
{"id": 142551, "name": "Currency", "source": "Translate COBOL to Python:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. currency-example.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  Burger-Price                        CONSTANT 5.50.\n01  Milkshake-Price                     CONSTANT 2.86.\n01  num-burgers                         PIC 9(18) VALUE 4000000000000000.\n01  num-milkshakes                      PIC 9(18) VALUE 2.\n01  tax                                 PIC 9(18)V99.\n01  tax-edited                          PIC $(17)9.99.\n01  Tax-Rate                            CONSTANT 7.65.\n01  total                               PIC 9(18)V99.\n01  total-edited                        PIC $(17)9.99.\n\nPROCEDURE DIVISION.\n    COMPUTE total rounded, total-edited rounded =\n        num-burgers * Burger-Price + num-milkshakes * Milkshake-Price\n    DISPLAY \"Total before tax: \" total-edited\n\n    COMPUTE tax rounded, tax-edited rounded = total * (Tax-Rate / 100)\n    DISPLAY \"             Tax: \" tax-edited\n\n    ADD tax TO total GIVING total-edited rounded\n    DISPLAY \"  Total with tax: \" total-edited\n    .\nEND PROGRAM currency-example.\n", "target": "from decimal import Decimal as D\nfrom collections import namedtuple\n\nItem = namedtuple('Item', 'price, quant')\n\nitems = dict( hamburger=Item(D('5.50'), D('4000000000000000')),\n              milkshake=Item(D('2.86'), D('2')) )\ntax_rate = D('0.0765')\n\nfmt = \"%-10s %8s %18s %22s\"\nprint(fmt % tuple('Item Price Quantity Extension'.upper().split()))\n\ntotal_before_tax = 0\nfor item, (price, quant) in sorted(items.items()):\n    ext = price * quant\n    print(fmt % (item, price, quant, ext))\n    total_before_tax += ext\nprint(fmt % ('', '', '', '--------------------'))\nprint(fmt % ('', '', 'subtotal', total_before_tax))\n\ntax = (tax_rate * total_before_tax).quantize(D('0.00'))\nprint(fmt % ('', '', 'Tax', tax))\n\ntotal = total_before_tax + tax\nprint(fmt % ('', '', '', '--------------------'))\nprint(fmt % ('', '', 'Total', total))\n"}
{"id": 143178, "name": "Increment a numerical string", "source": "Translate COBOL to C#:        PROGRAM-ID. increment-num-str.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  str                    PIC X(5) VALUE \"12345\".\n       01  num                    REDEFINES str PIC 9(5).\n       \n       PROCEDURE DIVISION.\n           DISPLAY str\n           ADD 1 TO num\n           DISPLAY str\n\n           GOBACK\n           .\n", "target": "string s = \"12345\";\ns = (int.Parse(s) + 1).ToString();\n\n\n\n\n\n\nusing System.Numerics;\nstring bis = \"123456789012345678999999999\";\nbis = (BigInteger.Parse(bis) + 1).ToString();\n\n\n"}
{"id": 143180, "name": "Increment a numerical string", "source": "Translate COBOL to Java:        PROGRAM-ID. increment-num-str.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  str                    PIC X(5) VALUE \"12345\".\n       01  num                    REDEFINES str PIC 9(5).\n       \n       PROCEDURE DIVISION.\n           DISPLAY str\n           ADD 1 TO num\n           DISPLAY str\n\n           GOBACK\n           .\n", "target": "String s = \"12345\";\nIntLiteral lit1 = new IntLiteral(s);\nIntLiteral lit2 = 6789;\n++lit1; \n++lit2; \n"}
{"id": 143181, "name": "Increment a numerical string", "source": "Translate COBOL to Python:        PROGRAM-ID. increment-num-str.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  str                    PIC X(5) VALUE \"12345\".\n       01  num                    REDEFINES str PIC 9(5).\n       \n       PROCEDURE DIVISION.\n           DISPLAY str\n           ADD 1 TO num\n           DISPLAY str\n\n           GOBACK\n           .\n", "target": "next = str(int('123') + 1)\n"}
{"id": 144293, "name": "Terminal control_Clear the screen", "source": "Translate COBOL to C#:        PROGRAM-ID. blank-terminal.\n       \n       DATA DIVISION.\n       SCREEN SECTION.\n       01  blank-screen BLANK SCREEN.\n       \n       PROCEDURE DIVISION.\n           DISPLAY blank-screen\n\n           GOBACK\n           .\n", "target": "System.Console.Clear();\n"}
{"id": 144294, "name": "Terminal control_Clear the screen", "source": "Translate COBOL to Java:        PROGRAM-ID. blank-terminal.\n       \n       DATA DIVISION.\n       SCREEN SECTION.\n       01  blank-screen BLANK SCREEN.\n       \n       PROCEDURE DIVISION.\n           DISPLAY blank-screen\n\n           GOBACK\n           .\n", "target": "public class Clear\n{\n    public static void main (String[] args)\n    {\n        System.out.print(\"\\033[2J\");\n    }\n}\n"}
{"id": 144295, "name": "Terminal control_Clear the screen", "source": "Translate COBOL to Python:        PROGRAM-ID. blank-terminal.\n       \n       DATA DIVISION.\n       SCREEN SECTION.\n       01  blank-screen BLANK SCREEN.\n       \n       PROCEDURE DIVISION.\n           DISPLAY blank-screen\n\n           GOBACK\n           .\n", "target": "import os\nos.system(\"clear\")\n"}
{"id": 144494, "name": "Arbitrary-precision integers (included)", "source": "Translate COBOL to C#:        identification division.\n       program-id. arbitrary-precision-integers.\n       remarks. Uses opaque libgmp internals that are built into libcob.\n\n       data division.\n       working-storage section.\n       01 gmp-number.\n          05 mp-alloc          usage binary-long.\n          05 mp-size           usage binary-long.\n          05 mp-limb           usage pointer.\n       01 gmp-build.\n          05 mp-alloc          usage binary-long.\n          05 mp-size           usage binary-long.\n          05 mp-limb           usage pointer.\n\n       01 the-int              usage binary-c-long unsigned.\n       01 the-exponent         usage binary-c-long unsigned.\n       01 valid-exponent       usage binary-long value 1.\n          88 cant-use          value 0 when set to false 1.\n\n       01 number-string        usage pointer.\n       01 number-length        usage binary-long.\n\n       01 window-width         constant as 20.\n       01 limit-width          usage binary-long.       \n       01 number-buffer        pic x(window-width) based.\n       \n       procedure division.\n       arbitrary-main.\n\n      \n       perform initialize-integers.\n       display \"10 ** 19       \u00a0: \" with no advancing\n       move 10 to the-int\n       move 19 to the-exponent\n       perform raise-pow-accrete-exponent\n       perform show-all-or-portion\n       perform clean-up\n\n      \n       perform initialize-integers.\n       display \"12345 ** 9     \u00a0: \" with no advancing\n       move 12345 to the-int\n       move 9 to the-exponent\n       perform raise-pow-accrete-exponent\n       perform show-all-or-portion\n       perform clean-up\n\n      \n       perform initialize-integers.\n       display \"5 ** 4 ** 3 ** 2: \" with no advancing\n       move 3 to the-int\n       move 2 to the-exponent\n       perform raise-pow-accrete-exponent\n       move 4 to the-int\n       perform raise-pow-accrete-exponent\n       move 5 to the-int\n       perform raise-pow-accrete-exponent\n       perform show-all-or-portion\n       perform clean-up\n       goback.\n      \n\n       initialize-integers.\n       call \"__gmpz_init\" using gmp-number returning omitted\n       call \"__gmpz_init\" using gmp-build returning omitted\n       .\n\n       raise-pow-accrete-exponent.\n      \n       if cant-use then\n           display \"Error: intermediate overflow occured at \"\n                   the-exponent upon syserr\n           goback\n       end-if\n       call \"__gmpz_set_ui\" using gmp-number by value 0\n           returning omitted\n       call \"__gmpz_set_ui\" using gmp-build by value the-int\n           returning omitted\n       call \"__gmpz_pow_ui\" using gmp-number gmp-build\n           by value the-exponent\n           returning omitted\n       call \"__gmpz_set_ui\" using gmp-build by value 0\n           returning omitted\n       call \"__gmpz_get_ui\" using gmp-number returning the-exponent\n       call \"__gmpz_fits_ulong_p\" using gmp-number\n           returning valid-exponent\n       .\n\n      \n       show-all-or-portion.\n       call \"__gmpz_sizeinbase\" using gmp-number\n           by value 10\n           returning number-length\n       display \"GMP length: \" number-length \", \" with no advancing\n\n       call \"__gmpz_get_str\" using null by value 10\n           by reference gmp-number\n           returning number-string\n       call \"strlen\" using by value number-string\n           returning number-length\n       display \"strlen: \" number-length\n\n      \n       move window-width to limit-width\n       set address of number-buffer to number-string\n       if number-length <= window-width then\n           move number-length to limit-width\n           display number-buffer(1:limit-width)\n       else\n           display number-buffer with no advancing\n           subtract window-width from number-length\n           move function max(0, number-length) to number-length\n           if number-length <= window-width then\n               move number-length to limit-width\n           else\n               display \"...\" with no advancing\n           end-if\n           set address of number-buffer up by\n               function max(window-width, number-length)\n           display number-buffer(1:limit-width)\n       end-if\n       .\n\n       clean-up.\n       call \"free\" using by value number-string returning omitted\n       call \"__gmpz_clear\" using gmp-number returning omitted\n       call \"__gmpz_clear\" using gmp-build returning omitted\n       set address of number-buffer to null\n       set cant-use to false\n       .\n\n       end program arbitrary-precision-integers.\n", "target": "using System;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Numerics;\n\nstatic class Program {\n    static void Main() {\n        BigInteger n = BigInteger.Pow(5, (int)BigInteger.Pow(4, (int)BigInteger.Pow(3, 2)));\n        string result = n.ToString();\n\n        Debug.Assert(result.Length == 183231);\n        Debug.Assert(result.StartsWith(\"62060698786608744707\"));\n        Debug.Assert(result.EndsWith(\"92256259918212890625\"));\n\n        Console.WriteLine(\"n = 5^4^3^2\");\n        Console.WriteLine(\"n = {0}...{1}\", \n            result.Substring(0, 20),\n            result.Substring(result.Length - 20, 20)\n            );\n\n        Console.WriteLine(\"n digits = {0}\", result.Length);\n    }\n}\n"}
{"id": 144496, "name": "Arbitrary-precision integers (included)", "source": "Translate COBOL to Java:        identification division.\n       program-id. arbitrary-precision-integers.\n       remarks. Uses opaque libgmp internals that are built into libcob.\n\n       data division.\n       working-storage section.\n       01 gmp-number.\n          05 mp-alloc          usage binary-long.\n          05 mp-size           usage binary-long.\n          05 mp-limb           usage pointer.\n       01 gmp-build.\n          05 mp-alloc          usage binary-long.\n          05 mp-size           usage binary-long.\n          05 mp-limb           usage pointer.\n\n       01 the-int              usage binary-c-long unsigned.\n       01 the-exponent         usage binary-c-long unsigned.\n       01 valid-exponent       usage binary-long value 1.\n          88 cant-use          value 0 when set to false 1.\n\n       01 number-string        usage pointer.\n       01 number-length        usage binary-long.\n\n       01 window-width         constant as 20.\n       01 limit-width          usage binary-long.       \n       01 number-buffer        pic x(window-width) based.\n       \n       procedure division.\n       arbitrary-main.\n\n      \n       perform initialize-integers.\n       display \"10 ** 19       \u00a0: \" with no advancing\n       move 10 to the-int\n       move 19 to the-exponent\n       perform raise-pow-accrete-exponent\n       perform show-all-or-portion\n       perform clean-up\n\n      \n       perform initialize-integers.\n       display \"12345 ** 9     \u00a0: \" with no advancing\n       move 12345 to the-int\n       move 9 to the-exponent\n       perform raise-pow-accrete-exponent\n       perform show-all-or-portion\n       perform clean-up\n\n      \n       perform initialize-integers.\n       display \"5 ** 4 ** 3 ** 2: \" with no advancing\n       move 3 to the-int\n       move 2 to the-exponent\n       perform raise-pow-accrete-exponent\n       move 4 to the-int\n       perform raise-pow-accrete-exponent\n       move 5 to the-int\n       perform raise-pow-accrete-exponent\n       perform show-all-or-portion\n       perform clean-up\n       goback.\n      \n\n       initialize-integers.\n       call \"__gmpz_init\" using gmp-number returning omitted\n       call \"__gmpz_init\" using gmp-build returning omitted\n       .\n\n       raise-pow-accrete-exponent.\n      \n       if cant-use then\n           display \"Error: intermediate overflow occured at \"\n                   the-exponent upon syserr\n           goback\n       end-if\n       call \"__gmpz_set_ui\" using gmp-number by value 0\n           returning omitted\n       call \"__gmpz_set_ui\" using gmp-build by value the-int\n           returning omitted\n       call \"__gmpz_pow_ui\" using gmp-number gmp-build\n           by value the-exponent\n           returning omitted\n       call \"__gmpz_set_ui\" using gmp-build by value 0\n           returning omitted\n       call \"__gmpz_get_ui\" using gmp-number returning the-exponent\n       call \"__gmpz_fits_ulong_p\" using gmp-number\n           returning valid-exponent\n       .\n\n      \n       show-all-or-portion.\n       call \"__gmpz_sizeinbase\" using gmp-number\n           by value 10\n           returning number-length\n       display \"GMP length: \" number-length \", \" with no advancing\n\n       call \"__gmpz_get_str\" using null by value 10\n           by reference gmp-number\n           returning number-string\n       call \"strlen\" using by value number-string\n           returning number-length\n       display \"strlen: \" number-length\n\n      \n       move window-width to limit-width\n       set address of number-buffer to number-string\n       if number-length <= window-width then\n           move number-length to limit-width\n           display number-buffer(1:limit-width)\n       else\n           display number-buffer with no advancing\n           subtract window-width from number-length\n           move function max(0, number-length) to number-length\n           if number-length <= window-width then\n               move number-length to limit-width\n           else\n               display \"...\" with no advancing\n           end-if\n           set address of number-buffer up by\n               function max(window-width, number-length)\n           display number-buffer(1:limit-width)\n       end-if\n       .\n\n       clean-up.\n       call \"free\" using by value number-string returning omitted\n       call \"__gmpz_clear\" using gmp-number returning omitted\n       call \"__gmpz_clear\" using gmp-build returning omitted\n       set address of number-buffer to null\n       set cant-use to false\n       .\n\n       end program arbitrary-precision-integers.\n", "target": "import java.math.BigInteger;\n\nclass IntegerPower {\n    public static void main(String[] args) {\n        BigInteger power = BigInteger.valueOf(5).pow(BigInteger.valueOf(4).pow(BigInteger.valueOf(3).pow(2).intValueExact()).intValueExact());\n        String str = power.toString();\n        int len = str.length();\n        System.out.printf(\"5**4**3**2 = %s...%s and has %d digits%n\",\n                str.substring(0, 20), str.substring(len - 20), len);\n    }\n}\n"}
{"id": 144497, "name": "Arbitrary-precision integers (included)", "source": "Translate COBOL to Python:        identification division.\n       program-id. arbitrary-precision-integers.\n       remarks. Uses opaque libgmp internals that are built into libcob.\n\n       data division.\n       working-storage section.\n       01 gmp-number.\n          05 mp-alloc          usage binary-long.\n          05 mp-size           usage binary-long.\n          05 mp-limb           usage pointer.\n       01 gmp-build.\n          05 mp-alloc          usage binary-long.\n          05 mp-size           usage binary-long.\n          05 mp-limb           usage pointer.\n\n       01 the-int              usage binary-c-long unsigned.\n       01 the-exponent         usage binary-c-long unsigned.\n       01 valid-exponent       usage binary-long value 1.\n          88 cant-use          value 0 when set to false 1.\n\n       01 number-string        usage pointer.\n       01 number-length        usage binary-long.\n\n       01 window-width         constant as 20.\n       01 limit-width          usage binary-long.       \n       01 number-buffer        pic x(window-width) based.\n       \n       procedure division.\n       arbitrary-main.\n\n      \n       perform initialize-integers.\n       display \"10 ** 19       \u00a0: \" with no advancing\n       move 10 to the-int\n       move 19 to the-exponent\n       perform raise-pow-accrete-exponent\n       perform show-all-or-portion\n       perform clean-up\n\n      \n       perform initialize-integers.\n       display \"12345 ** 9     \u00a0: \" with no advancing\n       move 12345 to the-int\n       move 9 to the-exponent\n       perform raise-pow-accrete-exponent\n       perform show-all-or-portion\n       perform clean-up\n\n      \n       perform initialize-integers.\n       display \"5 ** 4 ** 3 ** 2: \" with no advancing\n       move 3 to the-int\n       move 2 to the-exponent\n       perform raise-pow-accrete-exponent\n       move 4 to the-int\n       perform raise-pow-accrete-exponent\n       move 5 to the-int\n       perform raise-pow-accrete-exponent\n       perform show-all-or-portion\n       perform clean-up\n       goback.\n      \n\n       initialize-integers.\n       call \"__gmpz_init\" using gmp-number returning omitted\n       call \"__gmpz_init\" using gmp-build returning omitted\n       .\n\n       raise-pow-accrete-exponent.\n      \n       if cant-use then\n           display \"Error: intermediate overflow occured at \"\n                   the-exponent upon syserr\n           goback\n       end-if\n       call \"__gmpz_set_ui\" using gmp-number by value 0\n           returning omitted\n       call \"__gmpz_set_ui\" using gmp-build by value the-int\n           returning omitted\n       call \"__gmpz_pow_ui\" using gmp-number gmp-build\n           by value the-exponent\n           returning omitted\n       call \"__gmpz_set_ui\" using gmp-build by value 0\n           returning omitted\n       call \"__gmpz_get_ui\" using gmp-number returning the-exponent\n       call \"__gmpz_fits_ulong_p\" using gmp-number\n           returning valid-exponent\n       .\n\n      \n       show-all-or-portion.\n       call \"__gmpz_sizeinbase\" using gmp-number\n           by value 10\n           returning number-length\n       display \"GMP length: \" number-length \", \" with no advancing\n\n       call \"__gmpz_get_str\" using null by value 10\n           by reference gmp-number\n           returning number-string\n       call \"strlen\" using by value number-string\n           returning number-length\n       display \"strlen: \" number-length\n\n      \n       move window-width to limit-width\n       set address of number-buffer to number-string\n       if number-length <= window-width then\n           move number-length to limit-width\n           display number-buffer(1:limit-width)\n       else\n           display number-buffer with no advancing\n           subtract window-width from number-length\n           move function max(0, number-length) to number-length\n           if number-length <= window-width then\n               move number-length to limit-width\n           else\n               display \"...\" with no advancing\n           end-if\n           set address of number-buffer up by\n               function max(window-width, number-length)\n           display number-buffer(1:limit-width)\n       end-if\n       .\n\n       clean-up.\n       call \"free\" using by value number-string returning omitted\n       call \"__gmpz_clear\" using gmp-number returning omitted\n       call \"__gmpz_clear\" using gmp-build returning omitted\n       set address of number-buffer to null\n       set cant-use to false\n       .\n\n       end program arbitrary-precision-integers.\n", "target": ">>> y = str( 5**4**3**2 )\n>>> print (\"5**4**3**2 = %s...%s and has %i digits\" % (y[:20], y[-20:], len(y)))\n5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits\n"}
{"id": 144974, "name": "Show ASCII table", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. CHARSET.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 CHARCODE PIC 9(3) VALUE 32.\nPROCEDURE DIVISION.\nMAIN-PROCEDURE.\nPERFORM UNTIL CHARCODE=128\nDISPLAY FUNCTION CONCATENATE(\n    FUNCTION CONCATENATE(\n        CHARCODE,\n        \"\u00a0: \"\n    ),\n    FUNCTION CONCATENATE(\n        FUNCTION CHAR(CHARCODE),\n        \"   \"\n    )\n)\nWITH NO ADVANCING\nADD 1 TO CHARCODE\nEND-PERFORM.\nEND PROGRAM CHARSET.\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        for (int start = 32; start + 16 * 5 < 128; start++) {\n            WriteLine(string.Concat(Range(0, 6).Select(i => $\"{start+16*i, 3}\u00a0: {Text(start+16*i), -6}\")));\n        }\n\n        string Text(int index) => index == 32 ? \"Sp\" : index == 127 ? \"Del\" : (char)index + \"\";\n    }\n}\n"}
{"id": 144975, "name": "Show ASCII table", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. CHARSET.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 CHARCODE PIC 9(3) VALUE 32.\nPROCEDURE DIVISION.\nMAIN-PROCEDURE.\nPERFORM UNTIL CHARCODE=128\nDISPLAY FUNCTION CONCATENATE(\n    FUNCTION CONCATENATE(\n        CHARCODE,\n        \"\u00a0: \"\n    ),\n    FUNCTION CONCATENATE(\n        FUNCTION CHAR(CHARCODE),\n        \"   \"\n    )\n)\nWITH NO ADVANCING\nADD 1 TO CHARCODE\nEND-PERFORM.\nEND PROGRAM CHARSET.\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        for (int start = 32; start + 16 * 5 < 128; start++) {\n            WriteLine(string.Concat(Range(0, 6).Select(i => $\"{start+16*i, 3}\u00a0: {Text(start+16*i), -6}\")));\n        }\n\n        string Text(int index) => index == 32 ? \"Sp\" : index == 127 ? \"Del\" : (char)index + \"\";\n    }\n}\n"}
{"id": 144978, "name": "Show ASCII table", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. CHARSET.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 CHARCODE PIC 9(3) VALUE 32.\nPROCEDURE DIVISION.\nMAIN-PROCEDURE.\nPERFORM UNTIL CHARCODE=128\nDISPLAY FUNCTION CONCATENATE(\n    FUNCTION CONCATENATE(\n        CHARCODE,\n        \"\u00a0: \"\n    ),\n    FUNCTION CONCATENATE(\n        FUNCTION CHAR(CHARCODE),\n        \"   \"\n    )\n)\nWITH NO ADVANCING\nADD 1 TO CHARCODE\nEND-PERFORM.\nEND PROGRAM CHARSET.\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        for (Int offset : 0..<16)\n            {\n            for (Int ascii = 32+offset; ascii < 128; ascii += 16)\n                {\n                console.print($|{ascii.toString().rightJustify(3)}/\\\n                               |{ascii.toByte().toByteArray()}: \\\n                               |{new Char(ascii).quoted().leftJustify(5)}\n                              , suppressNewline=True);\n                }\n            console.print();\n            }\n        }\n    }\n"}
{"id": 144979, "name": "Show ASCII table", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. CHARSET.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 CHARCODE PIC 9(3) VALUE 32.\nPROCEDURE DIVISION.\nMAIN-PROCEDURE.\nPERFORM UNTIL CHARCODE=128\nDISPLAY FUNCTION CONCATENATE(\n    FUNCTION CONCATENATE(\n        CHARCODE,\n        \"\u00a0: \"\n    ),\n    FUNCTION CONCATENATE(\n        FUNCTION CHAR(CHARCODE),\n        \"   \"\n    )\n)\nWITH NO ADVANCING\nADD 1 TO CHARCODE\nEND-PERFORM.\nEND PROGRAM CHARSET.\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        for (Int offset : 0..<16)\n            {\n            for (Int ascii = 32+offset; ascii < 128; ascii += 16)\n                {\n                console.print($|{ascii.toString().rightJustify(3)}/\\\n                               |{ascii.toByte().toByteArray()}: \\\n                               |{new Char(ascii).quoted().leftJustify(5)}\n                              , suppressNewline=True);\n                }\n            console.print();\n            }\n        }\n    }\n"}
{"id": 144980, "name": "Show ASCII table", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. CHARSET.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 CHARCODE PIC 9(3) VALUE 32.\nPROCEDURE DIVISION.\nMAIN-PROCEDURE.\nPERFORM UNTIL CHARCODE=128\nDISPLAY FUNCTION CONCATENATE(\n    FUNCTION CONCATENATE(\n        CHARCODE,\n        \"\u00a0: \"\n    ),\n    FUNCTION CONCATENATE(\n        FUNCTION CHAR(CHARCODE),\n        \"   \"\n    )\n)\nWITH NO ADVANCING\nADD 1 TO CHARCODE\nEND-PERFORM.\nEND PROGRAM CHARSET.\n", "target": "for i in range(16):\n    for j in range(32+i, 127+1, 16):\n        if j == 32:\n            k = 'Spc'\n        elif j == 127:\n            k = 'Del'\n        else:\n            k = chr(j)\n        print(\"%3d\u00a0: %-3s\" % (j,k), end=\"\")\n    print()\n"}
{"id": 144981, "name": "Show ASCII table", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. CHARSET.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 CHARCODE PIC 9(3) VALUE 32.\nPROCEDURE DIVISION.\nMAIN-PROCEDURE.\nPERFORM UNTIL CHARCODE=128\nDISPLAY FUNCTION CONCATENATE(\n    FUNCTION CONCATENATE(\n        CHARCODE,\n        \"\u00a0: \"\n    ),\n    FUNCTION CONCATENATE(\n        FUNCTION CHAR(CHARCODE),\n        \"   \"\n    )\n)\nWITH NO ADVANCING\nADD 1 TO CHARCODE\nEND-PERFORM.\nEND PROGRAM CHARSET.\n", "target": "for i in range(16):\n    for j in range(32+i, 127+1, 16):\n        if j == 32:\n            k = 'Spc'\n        elif j == 127:\n            k = 'Del'\n        else:\n            k = chr(j)\n        print(\"%3d\u00a0: %-3s\" % (j,k), end=\"\")\n    print()\n"}
{"id": 145307, "name": "Sorting algorithms_Gnome sort", "source": "Translate COBOL to C#:        C-SORT SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           SET WB-IX-1 TO 2.\n           MOVE 1 TO WC-NEXT-POSN.\n\n           PERFORM E-GNOME UNTIL WC-NEXT-POSN > WC-SIZE.\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       E-GNOME SECTION.\n       E-000.\n           IF WB-ENTRY(WB-IX-1 - 1) NOT > WB-ENTRY(WB-IX-1)\n              ADD 1       TO WC-NEXT-POSN\n              SET WB-IX-1 TO WC-NEXT-POSN\n           ELSE\n              MOVE WB-ENTRY(WB-IX-1 - 1) TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1)     TO WB-ENTRY(WB-IX-1 - 1)\n              MOVE WC-TEMP               TO WB-ENTRY(WB-IX-1)\n              SET WB-IX-1                DOWN BY 1\n              IF WB-IX-1 = 1\n                 ADD 1       TO WC-NEXT-POSN\n                 SET WB-IX-1 TO WC-NEXT-POSN.\n\n       E-999.\n           EXIT.\n", "target": "        public static void gnomeSort(int[] anArray)\n        {\n            int first = 1;\n            int second = 2;\n\n            while (first < anArray.Length)\n            {\n                if (anArray[first - 1] <= anArray[first])\n                {\n                    first = second;\n                    second++;\n                }\n                else\n                {\n                    int tmp = anArray[first - 1];\n                    anArray[first - 1] = anArray[first];\n                    anArray[first] = tmp;\n                    first -= 1;\n                    if (first == 0)\n                    {\n                        first = 1;\n                        second = 2;\n                    }\n                }\n                \n            }\n        }\n"}
{"id": 145309, "name": "Sorting algorithms_Gnome sort", "source": "Translate COBOL to Java:        C-SORT SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           SET WB-IX-1 TO 2.\n           MOVE 1 TO WC-NEXT-POSN.\n\n           PERFORM E-GNOME UNTIL WC-NEXT-POSN > WC-SIZE.\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       E-GNOME SECTION.\n       E-000.\n           IF WB-ENTRY(WB-IX-1 - 1) NOT > WB-ENTRY(WB-IX-1)\n              ADD 1       TO WC-NEXT-POSN\n              SET WB-IX-1 TO WC-NEXT-POSN\n           ELSE\n              MOVE WB-ENTRY(WB-IX-1 - 1) TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1)     TO WB-ENTRY(WB-IX-1 - 1)\n              MOVE WC-TEMP               TO WB-ENTRY(WB-IX-1)\n              SET WB-IX-1                DOWN BY 1\n              IF WB-IX-1 = 1\n                 ADD 1       TO WC-NEXT-POSN\n                 SET WB-IX-1 TO WC-NEXT-POSN.\n\n       E-999.\n           EXIT.\n", "target": "public static void gnomeSort(int[] a)\n{\n  int i=1;\n  int j=2;\n \n  while(i < a.length) {\n    if ( a[i-1] <= a[i] ) {\n      i = j; j++;\n    } else {\n      int tmp = a[i-1];\n      a[i-1] = a[i];\n      a[i--] = tmp;\n      i = (i==0) ? j++ : i;\n    }\n  }\n}\n"}
{"id": 145310, "name": "Sorting algorithms_Gnome sort", "source": "Translate COBOL to Python:        C-SORT SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           SET WB-IX-1 TO 2.\n           MOVE 1 TO WC-NEXT-POSN.\n\n           PERFORM E-GNOME UNTIL WC-NEXT-POSN > WC-SIZE.\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       E-GNOME SECTION.\n       E-000.\n           IF WB-ENTRY(WB-IX-1 - 1) NOT > WB-ENTRY(WB-IX-1)\n              ADD 1       TO WC-NEXT-POSN\n              SET WB-IX-1 TO WC-NEXT-POSN\n           ELSE\n              MOVE WB-ENTRY(WB-IX-1 - 1) TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1)     TO WB-ENTRY(WB-IX-1 - 1)\n              MOVE WC-TEMP               TO WB-ENTRY(WB-IX-1)\n              SET WB-IX-1                DOWN BY 1\n              IF WB-IX-1 = 1\n                 ADD 1       TO WC-NEXT-POSN\n                 SET WB-IX-1 TO WC-NEXT-POSN.\n\n       E-999.\n           EXIT.\n", "target": ">>> def gnomesort(a):\n\ti,j,size = 1,2,len(a)\n\twhile i < size:\n\t\tif a[i-1] <= a[i]:\n\t\t\ti,j = j, j+1\n\t\telse:\n\t\t\ta[i-1],a[i] = a[i],a[i-1]\n\t\t\ti -= 1\n\t\t\tif i == 0:\n\t\t\t\ti,j = j, j+1\n\treturn a\n\n>>> gnomesort([3,4,2,5,1,6])\n[1, 2, 3, 4, 5, 6]\n>>>\n"}
{"id": 146141, "name": "Balanced brackets", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. test-balanced-brackets.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  True-Val  CONSTANT 0.\n       01  False-Val CONSTANT 1.\n\n       LOCAL-STORAGE SECTION.\n       01  current-time        PIC 9(10).\n\n       01  bracket-type        PIC 9.\n           88 add-open-bracket VALUE 1.\n\n       01  bracket-string-area.\n           03  bracket-string  PIC X(10) OCCURS 10 TIMES.\n\n       01  i                   PIC 999.\n       01  j                   PIC 999.\n\n       PROCEDURE DIVISION.\n           \n           MOVE FUNCTION CURRENT-DATE (7:10) TO current-time\n           MOVE FUNCTION RANDOM(current-time) TO current-time\n\n\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               PERFORM VARYING j FROM 1 BY 1 UNTIL i < j\n                   COMPUTE bracket-type =\n                       FUNCTION REM(FUNCTION RANDOM * 1000, 2)\n\n                   IF add-open-bracket\n                       MOVE \"[\" TO bracket-string (i) (j:1)\n                   ELSE\n                       MOVE \"]\" TO bracket-string (i) (j:1)\n                   END-IF\n               END-PERFORM\n           END-PERFORM\n\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               CALL \"check-if-balanced\" USING bracket-string (i)\n               IF RETURN-CODE = True-Val\n                   DISPLAY FUNCTION TRIM(bracket-string (i))\n                       \" is balanced.\"\n               ELSE\n                   DISPLAY FUNCTION TRIM(bracket-string (i))\n                       \" is not balanced.\"\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n\n       END PROGRAM test-balanced-brackets.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. check-if-balanced.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  True-Val  CONSTANT 0.\n       01  False-Val CONSTANT 1.\n\n       LOCAL-STORAGE SECTION.\n       01  nesting-level  PIC S999.\n       01  i              PIC 999.\n\n       LINKAGE SECTION.\n       01  bracket-string PIC X(100).\n\n       PROCEDURE DIVISION USING bracket-string.\n           PERFORM VARYING i FROM 1 BY 1\n                   UNTIL (100 < i)\n                      OR (bracket-string (i:1) = SPACE)\n                      OR (nesting-level < 0)\n               IF bracket-string (i:1) = \"[\"\n                   ADD 1 TO nesting-level\n               ELSE\n                   SUBTRACT 1 FROM nesting-level\n                   IF nesting-level < 0\n                       MOVE False-Val TO RETURN-CODE \n                       GOBACK\n                   END-IF\n               END-IF\n           END-PERFORM\n           \n           IF nesting-level = 0\n               MOVE True-Val TO RETURN-CODE\n           ELSE\n               MOVE False-Val TO RETURN-CODE\n           END-IF\n           \n           GOBACK\n           . \n\n       END PROGRAM check-if-balanced.\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static bool IsBalanced(string text, char open = '[', char close = ']')\n    {\n        var level = 0;\n        foreach (var character in text)\n        {\n            if (character == close)\n            {\n                if (level == 0)\n                {\n                    return false;\n                }\n                level--;\n            }\n            if (character == open)\n            {\n                level++;\n            }\n        }\n        return level == 0;\n    }\n\n    static string RandomBrackets(int count, char open = '[', char close = ']')\n    {\n        var random = new Random();\n        return string.Join(string.Empty,\n                (new string(open, count) + new string(close, count)).OrderBy(c => random.Next()));\n    }\n\n    static void Main()\n    {\n        for (var count = 0; count < 9; count++)\n        {\n            var text = RandomBrackets(count);\n            Console.WriteLine(\"\\\"{0}\\\" is {1}balanced.\", text, IsBalanced(text) ? string.Empty : \"not \");\n        }\n    }\n}\n"}
{"id": 146142, "name": "Balanced brackets", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. test-balanced-brackets.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  True-Val  CONSTANT 0.\n       01  False-Val CONSTANT 1.\n\n       LOCAL-STORAGE SECTION.\n       01  current-time        PIC 9(10).\n\n       01  bracket-type        PIC 9.\n           88 add-open-bracket VALUE 1.\n\n       01  bracket-string-area.\n           03  bracket-string  PIC X(10) OCCURS 10 TIMES.\n\n       01  i                   PIC 999.\n       01  j                   PIC 999.\n\n       PROCEDURE DIVISION.\n           \n           MOVE FUNCTION CURRENT-DATE (7:10) TO current-time\n           MOVE FUNCTION RANDOM(current-time) TO current-time\n\n\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               PERFORM VARYING j FROM 1 BY 1 UNTIL i < j\n                   COMPUTE bracket-type =\n                       FUNCTION REM(FUNCTION RANDOM * 1000, 2)\n\n                   IF add-open-bracket\n                       MOVE \"[\" TO bracket-string (i) (j:1)\n                   ELSE\n                       MOVE \"]\" TO bracket-string (i) (j:1)\n                   END-IF\n               END-PERFORM\n           END-PERFORM\n\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               CALL \"check-if-balanced\" USING bracket-string (i)\n               IF RETURN-CODE = True-Val\n                   DISPLAY FUNCTION TRIM(bracket-string (i))\n                       \" is balanced.\"\n               ELSE\n                   DISPLAY FUNCTION TRIM(bracket-string (i))\n                       \" is not balanced.\"\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n\n       END PROGRAM test-balanced-brackets.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. check-if-balanced.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  True-Val  CONSTANT 0.\n       01  False-Val CONSTANT 1.\n\n       LOCAL-STORAGE SECTION.\n       01  nesting-level  PIC S999.\n       01  i              PIC 999.\n\n       LINKAGE SECTION.\n       01  bracket-string PIC X(100).\n\n       PROCEDURE DIVISION USING bracket-string.\n           PERFORM VARYING i FROM 1 BY 1\n                   UNTIL (100 < i)\n                      OR (bracket-string (i:1) = SPACE)\n                      OR (nesting-level < 0)\n               IF bracket-string (i:1) = \"[\"\n                   ADD 1 TO nesting-level\n               ELSE\n                   SUBTRACT 1 FROM nesting-level\n                   IF nesting-level < 0\n                       MOVE False-Val TO RETURN-CODE \n                       GOBACK\n                   END-IF\n               END-IF\n           END-PERFORM\n           \n           IF nesting-level = 0\n               MOVE True-Val TO RETURN-CODE\n           ELSE\n               MOVE False-Val TO RETURN-CODE\n           END-IF\n           \n           GOBACK\n           . \n\n       END PROGRAM check-if-balanced.\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static bool IsBalanced(string text, char open = '[', char close = ']')\n    {\n        var level = 0;\n        foreach (var character in text)\n        {\n            if (character == close)\n            {\n                if (level == 0)\n                {\n                    return false;\n                }\n                level--;\n            }\n            if (character == open)\n            {\n                level++;\n            }\n        }\n        return level == 0;\n    }\n\n    static string RandomBrackets(int count, char open = '[', char close = ']')\n    {\n        var random = new Random();\n        return string.Join(string.Empty,\n                (new string(open, count) + new string(close, count)).OrderBy(c => random.Next()));\n    }\n\n    static void Main()\n    {\n        for (var count = 0; count < 9; count++)\n        {\n            var text = RandomBrackets(count);\n            Console.WriteLine(\"\\\"{0}\\\" is {1}balanced.\", text, IsBalanced(text) ? string.Empty : \"not \");\n        }\n    }\n}\n"}
{"id": 146145, "name": "Balanced brackets", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. test-balanced-brackets.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  True-Val  CONSTANT 0.\n       01  False-Val CONSTANT 1.\n\n       LOCAL-STORAGE SECTION.\n       01  current-time        PIC 9(10).\n\n       01  bracket-type        PIC 9.\n           88 add-open-bracket VALUE 1.\n\n       01  bracket-string-area.\n           03  bracket-string  PIC X(10) OCCURS 10 TIMES.\n\n       01  i                   PIC 999.\n       01  j                   PIC 999.\n\n       PROCEDURE DIVISION.\n           \n           MOVE FUNCTION CURRENT-DATE (7:10) TO current-time\n           MOVE FUNCTION RANDOM(current-time) TO current-time\n\n\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               PERFORM VARYING j FROM 1 BY 1 UNTIL i < j\n                   COMPUTE bracket-type =\n                       FUNCTION REM(FUNCTION RANDOM * 1000, 2)\n\n                   IF add-open-bracket\n                       MOVE \"[\" TO bracket-string (i) (j:1)\n                   ELSE\n                       MOVE \"]\" TO bracket-string (i) (j:1)\n                   END-IF\n               END-PERFORM\n           END-PERFORM\n\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               CALL \"check-if-balanced\" USING bracket-string (i)\n               IF RETURN-CODE = True-Val\n                   DISPLAY FUNCTION TRIM(bracket-string (i))\n                       \" is balanced.\"\n               ELSE\n                   DISPLAY FUNCTION TRIM(bracket-string (i))\n                       \" is not balanced.\"\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n\n       END PROGRAM test-balanced-brackets.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. check-if-balanced.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  True-Val  CONSTANT 0.\n       01  False-Val CONSTANT 1.\n\n       LOCAL-STORAGE SECTION.\n       01  nesting-level  PIC S999.\n       01  i              PIC 999.\n\n       LINKAGE SECTION.\n       01  bracket-string PIC X(100).\n\n       PROCEDURE DIVISION USING bracket-string.\n           PERFORM VARYING i FROM 1 BY 1\n                   UNTIL (100 < i)\n                      OR (bracket-string (i:1) = SPACE)\n                      OR (nesting-level < 0)\n               IF bracket-string (i:1) = \"[\"\n                   ADD 1 TO nesting-level\n               ELSE\n                   SUBTRACT 1 FROM nesting-level\n                   IF nesting-level < 0\n                       MOVE False-Val TO RETURN-CODE \n                       GOBACK\n                   END-IF\n               END-IF\n           END-PERFORM\n           \n           IF nesting-level = 0\n               MOVE True-Val TO RETURN-CODE\n           ELSE\n               MOVE False-Val TO RETURN-CODE\n           END-IF\n           \n           GOBACK\n           . \n\n       END PROGRAM check-if-balanced.\n", "target": "module BalancedBrackets\n    {\n    Boolean balanced(String text)\n        {\n        Int depth = 0;\n        for (Char ch : text)\n            {\n            switch (ch, depth)\n                {\n                case ('[', _):\n                    ++depth;\n                    break;\n                case (']', 0):\n                    return False;\n                case (']', _):\n                    --depth;\n                    break;\n                }\n            }\n        return depth==0;\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        String[] tests =\n            [\n            \"[]\",\n            \"[][]\",\n            \"[]][[]\",\n            \"[[[]][]]\",\n            \"][[[[]][]]\",\n            \"[[[]][[]][]]\",\n            \"]][[]][[[[][]]\",\n            \"[[]]]][]][[][[[]\",\n            ];\n        Int longest = tests.map(s -> s.size).reduce(0, (max, len) -> max.maxOf(len));\n        for (String test : tests)\n            {\n            console.print($\"{test}{' ' * (longest-test.size)} {balanced(test)\u00a0? \"OK\"\u00a0: \"NOT OK\"}\");\n            }\n        }\n    }\n"}
{"id": 146146, "name": "Balanced brackets", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. test-balanced-brackets.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  True-Val  CONSTANT 0.\n       01  False-Val CONSTANT 1.\n\n       LOCAL-STORAGE SECTION.\n       01  current-time        PIC 9(10).\n\n       01  bracket-type        PIC 9.\n           88 add-open-bracket VALUE 1.\n\n       01  bracket-string-area.\n           03  bracket-string  PIC X(10) OCCURS 10 TIMES.\n\n       01  i                   PIC 999.\n       01  j                   PIC 999.\n\n       PROCEDURE DIVISION.\n           \n           MOVE FUNCTION CURRENT-DATE (7:10) TO current-time\n           MOVE FUNCTION RANDOM(current-time) TO current-time\n\n\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               PERFORM VARYING j FROM 1 BY 1 UNTIL i < j\n                   COMPUTE bracket-type =\n                       FUNCTION REM(FUNCTION RANDOM * 1000, 2)\n\n                   IF add-open-bracket\n                       MOVE \"[\" TO bracket-string (i) (j:1)\n                   ELSE\n                       MOVE \"]\" TO bracket-string (i) (j:1)\n                   END-IF\n               END-PERFORM\n           END-PERFORM\n\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               CALL \"check-if-balanced\" USING bracket-string (i)\n               IF RETURN-CODE = True-Val\n                   DISPLAY FUNCTION TRIM(bracket-string (i))\n                       \" is balanced.\"\n               ELSE\n                   DISPLAY FUNCTION TRIM(bracket-string (i))\n                       \" is not balanced.\"\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n\n       END PROGRAM test-balanced-brackets.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. check-if-balanced.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  True-Val  CONSTANT 0.\n       01  False-Val CONSTANT 1.\n\n       LOCAL-STORAGE SECTION.\n       01  nesting-level  PIC S999.\n       01  i              PIC 999.\n\n       LINKAGE SECTION.\n       01  bracket-string PIC X(100).\n\n       PROCEDURE DIVISION USING bracket-string.\n           PERFORM VARYING i FROM 1 BY 1\n                   UNTIL (100 < i)\n                      OR (bracket-string (i:1) = SPACE)\n                      OR (nesting-level < 0)\n               IF bracket-string (i:1) = \"[\"\n                   ADD 1 TO nesting-level\n               ELSE\n                   SUBTRACT 1 FROM nesting-level\n                   IF nesting-level < 0\n                       MOVE False-Val TO RETURN-CODE \n                       GOBACK\n                   END-IF\n               END-IF\n           END-PERFORM\n           \n           IF nesting-level = 0\n               MOVE True-Val TO RETURN-CODE\n           ELSE\n               MOVE False-Val TO RETURN-CODE\n           END-IF\n           \n           GOBACK\n           . \n\n       END PROGRAM check-if-balanced.\n", "target": "module BalancedBrackets\n    {\n    Boolean balanced(String text)\n        {\n        Int depth = 0;\n        for (Char ch : text)\n            {\n            switch (ch, depth)\n                {\n                case ('[', _):\n                    ++depth;\n                    break;\n                case (']', 0):\n                    return False;\n                case (']', _):\n                    --depth;\n                    break;\n                }\n            }\n        return depth==0;\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        String[] tests =\n            [\n            \"[]\",\n            \"[][]\",\n            \"[]][[]\",\n            \"[[[]][]]\",\n            \"][[[[]][]]\",\n            \"[[[]][[]][]]\",\n            \"]][[]][[[[][]]\",\n            \"[[]]]][]][[][[[]\",\n            ];\n        Int longest = tests.map(s -> s.size).reduce(0, (max, len) -> max.maxOf(len));\n        for (String test : tests)\n            {\n            console.print($\"{test}{' ' * (longest-test.size)} {balanced(test)\u00a0? \"OK\"\u00a0: \"NOT OK\"}\");\n            }\n        }\n    }\n"}
{"id": 146147, "name": "Balanced brackets", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. test-balanced-brackets.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  True-Val  CONSTANT 0.\n       01  False-Val CONSTANT 1.\n\n       LOCAL-STORAGE SECTION.\n       01  current-time        PIC 9(10).\n\n       01  bracket-type        PIC 9.\n           88 add-open-bracket VALUE 1.\n\n       01  bracket-string-area.\n           03  bracket-string  PIC X(10) OCCURS 10 TIMES.\n\n       01  i                   PIC 999.\n       01  j                   PIC 999.\n\n       PROCEDURE DIVISION.\n           \n           MOVE FUNCTION CURRENT-DATE (7:10) TO current-time\n           MOVE FUNCTION RANDOM(current-time) TO current-time\n\n\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               PERFORM VARYING j FROM 1 BY 1 UNTIL i < j\n                   COMPUTE bracket-type =\n                       FUNCTION REM(FUNCTION RANDOM * 1000, 2)\n\n                   IF add-open-bracket\n                       MOVE \"[\" TO bracket-string (i) (j:1)\n                   ELSE\n                       MOVE \"]\" TO bracket-string (i) (j:1)\n                   END-IF\n               END-PERFORM\n           END-PERFORM\n\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               CALL \"check-if-balanced\" USING bracket-string (i)\n               IF RETURN-CODE = True-Val\n                   DISPLAY FUNCTION TRIM(bracket-string (i))\n                       \" is balanced.\"\n               ELSE\n                   DISPLAY FUNCTION TRIM(bracket-string (i))\n                       \" is not balanced.\"\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n\n       END PROGRAM test-balanced-brackets.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. check-if-balanced.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  True-Val  CONSTANT 0.\n       01  False-Val CONSTANT 1.\n\n       LOCAL-STORAGE SECTION.\n       01  nesting-level  PIC S999.\n       01  i              PIC 999.\n\n       LINKAGE SECTION.\n       01  bracket-string PIC X(100).\n\n       PROCEDURE DIVISION USING bracket-string.\n           PERFORM VARYING i FROM 1 BY 1\n                   UNTIL (100 < i)\n                      OR (bracket-string (i:1) = SPACE)\n                      OR (nesting-level < 0)\n               IF bracket-string (i:1) = \"[\"\n                   ADD 1 TO nesting-level\n               ELSE\n                   SUBTRACT 1 FROM nesting-level\n                   IF nesting-level < 0\n                       MOVE False-Val TO RETURN-CODE \n                       GOBACK\n                   END-IF\n               END-IF\n           END-PERFORM\n           \n           IF nesting-level = 0\n               MOVE True-Val TO RETURN-CODE\n           ELSE\n               MOVE False-Val TO RETURN-CODE\n           END-IF\n           \n           GOBACK\n           . \n\n       END PROGRAM check-if-balanced.\n", "target": ">>> def gen(N):\n...     txt = ['[', ']'] * N\n...     random.shuffle( txt )\n...     return ''.join(txt)\n... \n>>> def balanced(txt):\n...     braced = 0\n...     for ch in txt:\n...         if ch == '[': braced += 1\n...         if ch == ']':\n...             braced -= 1\n...             if braced < 0: return False\n...     return braced == 0\n... \n>>> for txt in (gen(N) for N in range(10)):\n...     print (\"%-22r is%s balanced\" % (txt, '' if balanced(txt) else ' not'))\n... \n''                     is balanced\n'[]'                   is balanced\n'[][]'                 is balanced\n'][[[]]'               is not balanced\n'[]][[][]'             is not balanced\n'[][[][]]]['           is not balanced\n'][]][][[]][['         is not balanced\n'[[]]]]][]][[[['       is not balanced\n'[[[[]][]]][[][]]'     is balanced\n'][[][[]]][]]][[[[]'   is not balanced\n"}
{"id": 146148, "name": "Balanced brackets", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. test-balanced-brackets.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  True-Val  CONSTANT 0.\n       01  False-Val CONSTANT 1.\n\n       LOCAL-STORAGE SECTION.\n       01  current-time        PIC 9(10).\n\n       01  bracket-type        PIC 9.\n           88 add-open-bracket VALUE 1.\n\n       01  bracket-string-area.\n           03  bracket-string  PIC X(10) OCCURS 10 TIMES.\n\n       01  i                   PIC 999.\n       01  j                   PIC 999.\n\n       PROCEDURE DIVISION.\n           \n           MOVE FUNCTION CURRENT-DATE (7:10) TO current-time\n           MOVE FUNCTION RANDOM(current-time) TO current-time\n\n\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               PERFORM VARYING j FROM 1 BY 1 UNTIL i < j\n                   COMPUTE bracket-type =\n                       FUNCTION REM(FUNCTION RANDOM * 1000, 2)\n\n                   IF add-open-bracket\n                       MOVE \"[\" TO bracket-string (i) (j:1)\n                   ELSE\n                       MOVE \"]\" TO bracket-string (i) (j:1)\n                   END-IF\n               END-PERFORM\n           END-PERFORM\n\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               CALL \"check-if-balanced\" USING bracket-string (i)\n               IF RETURN-CODE = True-Val\n                   DISPLAY FUNCTION TRIM(bracket-string (i))\n                       \" is balanced.\"\n               ELSE\n                   DISPLAY FUNCTION TRIM(bracket-string (i))\n                       \" is not balanced.\"\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n\n       END PROGRAM test-balanced-brackets.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. check-if-balanced.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  True-Val  CONSTANT 0.\n       01  False-Val CONSTANT 1.\n\n       LOCAL-STORAGE SECTION.\n       01  nesting-level  PIC S999.\n       01  i              PIC 999.\n\n       LINKAGE SECTION.\n       01  bracket-string PIC X(100).\n\n       PROCEDURE DIVISION USING bracket-string.\n           PERFORM VARYING i FROM 1 BY 1\n                   UNTIL (100 < i)\n                      OR (bracket-string (i:1) = SPACE)\n                      OR (nesting-level < 0)\n               IF bracket-string (i:1) = \"[\"\n                   ADD 1 TO nesting-level\n               ELSE\n                   SUBTRACT 1 FROM nesting-level\n                   IF nesting-level < 0\n                       MOVE False-Val TO RETURN-CODE \n                       GOBACK\n                   END-IF\n               END-IF\n           END-PERFORM\n           \n           IF nesting-level = 0\n               MOVE True-Val TO RETURN-CODE\n           ELSE\n               MOVE False-Val TO RETURN-CODE\n           END-IF\n           \n           GOBACK\n           . \n\n       END PROGRAM check-if-balanced.\n", "target": ">>> def gen(N):\n...     txt = ['[', ']'] * N\n...     random.shuffle( txt )\n...     return ''.join(txt)\n... \n>>> def balanced(txt):\n...     braced = 0\n...     for ch in txt:\n...         if ch == '[': braced += 1\n...         if ch == ']':\n...             braced -= 1\n...             if braced < 0: return False\n...     return braced == 0\n... \n>>> for txt in (gen(N) for N in range(10)):\n...     print (\"%-22r is%s balanced\" % (txt, '' if balanced(txt) else ' not'))\n... \n''                     is balanced\n'[]'                   is balanced\n'[][]'                 is balanced\n'][[[]]'               is not balanced\n'[]][[][]'             is not balanced\n'[][[][]]]['           is not balanced\n'][]][][[]][['         is not balanced\n'[[]]]]][]][[[['       is not balanced\n'[[[[]][]]][[][]]'     is balanced\n'][[][[]]][]]][[[[]'   is not balanced\n"}
{"id": 147170, "name": "Text processing_Max licenses in use", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. max-licenses-in-use.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT license-file ASSIGN \"mlijobs.txt\"\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS file-status.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  license-file.\n       01  license-record.\n           03  FILLER                   PIC X(8).\n           03  action                   PIC X(3).\n               88  license-out          VALUE \"OUT\".\n           03  FILLER                   PIC X(3).\n           03  license-timestamp        PIC X(19).\n           03  FILLER                   PIC X(13).\n\n       WORKING-STORAGE SECTION.\n       01  file-status                  PIC XX.\n           88  file-ok                  VALUE \"00\".\n\n       01  max-licenses-out             PIC 9(6).\n       01  num-max-times                PIC 99.\n       01  max-license-times-area.\n           03  max-timestamps           PIC X(19) OCCURS 1 TO 50 TIMES\n               DEPENDING ON num-max-times.\n       01  current-licenses-out         PIC 9(6).\n       \n       01  i                            PIC 99.\n\n       PROCEDURE DIVISION.\n       DECLARATIVES.\n       license-file-error SECTION.\n           USE AFTER ERROR ON license-file.\n\n           DISPLAY \"An unexpected error has occurred. Error \"\n               file-status \". The program will close.\"\n           GOBACK\n           .\n       END DECLARATIVES.\n\n       main-line.\n           OPEN INPUT license-file\n           IF NOT file-ok\n               DISPLAY \"File could not be opened. Error \" file-status\n                   \".\"\n               GOBACK\n           END-IF\n           \n           PERFORM FOREVER\n               READ license-file\n                   AT END\n                       EXIT PERFORM\n               END-READ\n\n               IF license-out\n                   ADD 1 TO current-licenses-out\n\n                   EVALUATE TRUE\n                       WHEN current-licenses-out > max-licenses-out\n                           MOVE 1 TO num-max-times\n                           MOVE current-licenses-out TO max-licenses-out\n                           MOVE license-timestamp\n                               TO max-timestamps (num-max-times)\n\n                       WHEN current-licenses-out = max-licenses-out\n                           ADD 1 TO num-max-times\n                           MOVE license-timestamp\n                               TO max-timestamps (num-max-times)\n                   END-EVALUATE\n               ELSE\n                   SUBTRACT 1 FROM current-licenses-out\n               END-IF\n           END-PERFORM\n\n           CLOSE license-file\n\n           DISPLAY \"License count at log end: \" current-licenses-out\n           DISPLAY \"Maximum simulataneous licenses: \" max-licenses-out\n           DISPLAY \"Time(s):\"\n           PERFORM VARYING i FROM 1 BY 1 UNTIL num-max-times < i\n               DISPLAY max-timestamps (i)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\n\nnamespace TextProc3\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {            \n            string line;\n            int count = 0, maxcount = 0;\n            List<string> times = new List<string>();\n            System.IO.StreamReader file = new StreamReader(\"mlijobs.txt\");\n            while ((line = file.ReadLine()) != null)\n            {\n                string[] lineelements = line.Split(' ');                \n                switch (lineelements[1])\n                {\n                    case \"IN\":\n                        count--;\n                        break;\n                    case \"OUT\":\n                        count++;\n                        if (count > maxcount)\n                        {\n                            maxcount = count;\n                            times.Clear();\n                            times.Add(lineelements[3]);\n                        }else if(count == maxcount){\n                            times.Add(lineelements[3]);\n                        }\n                        break;\n                }                \n            }\n            file.Close();\n            Console.WriteLine(maxcount);\n            foreach (string time in times)\n            {\n                Console.WriteLine(time);\n            }\n        }\n    }\n}\n"}
{"id": 147172, "name": "Text processing_Max licenses in use", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. max-licenses-in-use.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT license-file ASSIGN \"mlijobs.txt\"\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS file-status.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  license-file.\n       01  license-record.\n           03  FILLER                   PIC X(8).\n           03  action                   PIC X(3).\n               88  license-out          VALUE \"OUT\".\n           03  FILLER                   PIC X(3).\n           03  license-timestamp        PIC X(19).\n           03  FILLER                   PIC X(13).\n\n       WORKING-STORAGE SECTION.\n       01  file-status                  PIC XX.\n           88  file-ok                  VALUE \"00\".\n\n       01  max-licenses-out             PIC 9(6).\n       01  num-max-times                PIC 99.\n       01  max-license-times-area.\n           03  max-timestamps           PIC X(19) OCCURS 1 TO 50 TIMES\n               DEPENDING ON num-max-times.\n       01  current-licenses-out         PIC 9(6).\n       \n       01  i                            PIC 99.\n\n       PROCEDURE DIVISION.\n       DECLARATIVES.\n       license-file-error SECTION.\n           USE AFTER ERROR ON license-file.\n\n           DISPLAY \"An unexpected error has occurred. Error \"\n               file-status \". The program will close.\"\n           GOBACK\n           .\n       END DECLARATIVES.\n\n       main-line.\n           OPEN INPUT license-file\n           IF NOT file-ok\n               DISPLAY \"File could not be opened. Error \" file-status\n                   \".\"\n               GOBACK\n           END-IF\n           \n           PERFORM FOREVER\n               READ license-file\n                   AT END\n                       EXIT PERFORM\n               END-READ\n\n               IF license-out\n                   ADD 1 TO current-licenses-out\n\n                   EVALUATE TRUE\n                       WHEN current-licenses-out > max-licenses-out\n                           MOVE 1 TO num-max-times\n                           MOVE current-licenses-out TO max-licenses-out\n                           MOVE license-timestamp\n                               TO max-timestamps (num-max-times)\n\n                       WHEN current-licenses-out = max-licenses-out\n                           ADD 1 TO num-max-times\n                           MOVE license-timestamp\n                               TO max-timestamps (num-max-times)\n                   END-EVALUATE\n               ELSE\n                   SUBTRACT 1 FROM current-licenses-out\n               END-IF\n           END-PERFORM\n\n           CLOSE license-file\n\n           DISPLAY \"License count at log end: \" current-licenses-out\n           DISPLAY \"Maximum simulataneous licenses: \" max-licenses-out\n           DISPLAY \"Time(s):\"\n           PERFORM VARYING i FROM 1 BY 1 UNTIL num-max-times < i\n               DISPLAY max-timestamps (i)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.LinkedList;\n\npublic class License {\n  public static void main(String[] args) throws FileNotFoundException, IOException{\n    BufferedReader in = new BufferedReader(new FileReader(args[0]));\n    int max = Integer.MIN_VALUE;\n    LinkedList<String> dates = new LinkedList<String>();\n    String line;\n    int count = 0;\n    while((line = in.readLine()) != null){\n      if(line.startsWith(\"License OUT \")) count++;\n      if(line.startsWith(\"License IN \")) count--;\n      if(count > max){\n        max = count;\n        String date = line.split(\" \")[3];\n        dates.clear();\n        dates.add(date);\n      }else if(count == max){\n        String date = line.split(\" \")[3];\n        dates.add(date);\n      }\n    }\n    System.out.println(\"Max licenses out: \"+max);\n    System.out.println(\"At time(s): \"+dates);\n  }\n}\n"}
{"id": 147173, "name": "Text processing_Max licenses in use", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. max-licenses-in-use.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT license-file ASSIGN \"mlijobs.txt\"\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS file-status.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  license-file.\n       01  license-record.\n           03  FILLER                   PIC X(8).\n           03  action                   PIC X(3).\n               88  license-out          VALUE \"OUT\".\n           03  FILLER                   PIC X(3).\n           03  license-timestamp        PIC X(19).\n           03  FILLER                   PIC X(13).\n\n       WORKING-STORAGE SECTION.\n       01  file-status                  PIC XX.\n           88  file-ok                  VALUE \"00\".\n\n       01  max-licenses-out             PIC 9(6).\n       01  num-max-times                PIC 99.\n       01  max-license-times-area.\n           03  max-timestamps           PIC X(19) OCCURS 1 TO 50 TIMES\n               DEPENDING ON num-max-times.\n       01  current-licenses-out         PIC 9(6).\n       \n       01  i                            PIC 99.\n\n       PROCEDURE DIVISION.\n       DECLARATIVES.\n       license-file-error SECTION.\n           USE AFTER ERROR ON license-file.\n\n           DISPLAY \"An unexpected error has occurred. Error \"\n               file-status \". The program will close.\"\n           GOBACK\n           .\n       END DECLARATIVES.\n\n       main-line.\n           OPEN INPUT license-file\n           IF NOT file-ok\n               DISPLAY \"File could not be opened. Error \" file-status\n                   \".\"\n               GOBACK\n           END-IF\n           \n           PERFORM FOREVER\n               READ license-file\n                   AT END\n                       EXIT PERFORM\n               END-READ\n\n               IF license-out\n                   ADD 1 TO current-licenses-out\n\n                   EVALUATE TRUE\n                       WHEN current-licenses-out > max-licenses-out\n                           MOVE 1 TO num-max-times\n                           MOVE current-licenses-out TO max-licenses-out\n                           MOVE license-timestamp\n                               TO max-timestamps (num-max-times)\n\n                       WHEN current-licenses-out = max-licenses-out\n                           ADD 1 TO num-max-times\n                           MOVE license-timestamp\n                               TO max-timestamps (num-max-times)\n                   END-EVALUATE\n               ELSE\n                   SUBTRACT 1 FROM current-licenses-out\n               END-IF\n           END-PERFORM\n\n           CLOSE license-file\n\n           DISPLAY \"License count at log end: \" current-licenses-out\n           DISPLAY \"Maximum simulataneous licenses: \" max-licenses-out\n           DISPLAY \"Time(s):\"\n           PERFORM VARYING i FROM 1 BY 1 UNTIL num-max-times < i\n               DISPLAY max-timestamps (i)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "out, max_out, max_times = 0, -1, []\nfor job in open('mlijobs.txt'):\n    out += 1 if \"OUT\" in job else -1\n    if out > max_out:\n        max_out, max_times = out, []\n    if out == max_out:\n        max_times.append(job.split()[3])\n        \nprint(\"Maximum simultaneous license use is %i at the following times:\" % max_out)\nprint('  ' + '\\n  '.join(max_times))\n"}
{"id": 147997, "name": "Sorting algorithms_Selection sort", "source": "Translate COBOL to C#:            PERFORM E-SELECTION VARYING WB-IX-1 FROM 1 BY 1\n                               UNTIL WB-IX-1 = WC-SIZE.\n\n...\n\n       E-SELECTION SECTION.\n       E-000.\n           SET WC-LOWEST   TO WB-IX-1.\n           ADD 1 WC-LOWEST GIVING WC-START\n\n           PERFORM F-PASS VARYING WB-IX-2 FROM WC-START BY 1\n                          UNTIL WB-IX-2 > WC-SIZE.\n\n           IF WB-IX-1 NOT = WC-LOWEST\n              MOVE WB-ENTRY(WC-LOWEST) TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1)   TO WB-ENTRY(WC-LOWEST)\n              MOVE WC-TEMP             TO WB-ENTRY(WB-IX-1).\n\n       E-999.\n           EXIT.\n\n       F-PASS SECTION.\n       F-000.\n           IF WB-ENTRY(WB-IX-2) < WB-ENTRY(WC-LOWEST)\n              SET WC-LOWEST TO WB-IX-2.\n\n       F-999.\n           EXIT.\n", "target": "class SelectionSort<T> where T : IComparable {\n    public T[] Sort(T[] list) {\n        int k;\n        T temp;\n\n        for (int i = 0; i < list.Length; i++) {\n            k = i;\n            for (int j=i + 1; j < list.Length; j++) {\n                if (list[j].CompareTo(list[k]) < 0) {\n                    k = j;\n                }\n            }\n            temp = list[i];\n            list[i] = list[k];\n            list[k] = temp;\n        }\n\n        return list;\n    }\n}\n"}
{"id": 147999, "name": "Sorting algorithms_Selection sort", "source": "Translate COBOL to Java:            PERFORM E-SELECTION VARYING WB-IX-1 FROM 1 BY 1\n                               UNTIL WB-IX-1 = WC-SIZE.\n\n...\n\n       E-SELECTION SECTION.\n       E-000.\n           SET WC-LOWEST   TO WB-IX-1.\n           ADD 1 WC-LOWEST GIVING WC-START\n\n           PERFORM F-PASS VARYING WB-IX-2 FROM WC-START BY 1\n                          UNTIL WB-IX-2 > WC-SIZE.\n\n           IF WB-IX-1 NOT = WC-LOWEST\n              MOVE WB-ENTRY(WC-LOWEST) TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1)   TO WB-ENTRY(WC-LOWEST)\n              MOVE WC-TEMP             TO WB-ENTRY(WB-IX-1).\n\n       E-999.\n           EXIT.\n\n       F-PASS SECTION.\n       F-000.\n           IF WB-ENTRY(WB-IX-2) < WB-ENTRY(WC-LOWEST)\n              SET WC-LOWEST TO WB-IX-2.\n\n       F-999.\n           EXIT.\n", "target": "public static void sort(int[] nums){\n\tfor(int currentPlace = 0;currentPlace<nums.length-1;currentPlace++){\n\t\tint smallest = Integer.MAX_VALUE;\n\t\tint smallestAt = currentPlace+1;\n\t\tfor(int check = currentPlace; check<nums.length;check++){\n\t\t\tif(nums[check]<smallest){\n\t\t\t\tsmallestAt = check;\n\t\t\t\tsmallest = nums[check];\n\t\t\t}\n\t\t}\n\t\tint temp = nums[currentPlace];\n\t\tnums[currentPlace] = nums[smallestAt];\n\t\tnums[smallestAt] = temp;\n\t}\n}\n"}
{"id": 148000, "name": "Sorting algorithms_Selection sort", "source": "Translate COBOL to Python:            PERFORM E-SELECTION VARYING WB-IX-1 FROM 1 BY 1\n                               UNTIL WB-IX-1 = WC-SIZE.\n\n...\n\n       E-SELECTION SECTION.\n       E-000.\n           SET WC-LOWEST   TO WB-IX-1.\n           ADD 1 WC-LOWEST GIVING WC-START\n\n           PERFORM F-PASS VARYING WB-IX-2 FROM WC-START BY 1\n                          UNTIL WB-IX-2 > WC-SIZE.\n\n           IF WB-IX-1 NOT = WC-LOWEST\n              MOVE WB-ENTRY(WC-LOWEST) TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1)   TO WB-ENTRY(WC-LOWEST)\n              MOVE WC-TEMP             TO WB-ENTRY(WB-IX-1).\n\n       E-999.\n           EXIT.\n\n       F-PASS SECTION.\n       F-000.\n           IF WB-ENTRY(WB-IX-2) < WB-ENTRY(WC-LOWEST)\n              SET WC-LOWEST TO WB-IX-2.\n\n       F-999.\n           EXIT.\n", "target": "def selection_sort(lst):\n    for i, e in enumerate(lst):\n        mn = min(range(i,len(lst)), key=lst.__getitem__)\n        lst[i], lst[mn] = lst[mn], e\n    return lst\n"}
{"id": 148254, "name": "Sorting algorithms_Comb sort", "source": "Translate COBOL to C#:        C-PROCESS SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           MOVE WC-SIZE TO WC-GAP.\n\n           PERFORM E-COMB UNTIL WC-GAP = 1 AND FINISHED.\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       E-COMB SECTION.\n       E-000.\n           IF WC-GAP > 1\n              DIVIDE WC-GAP BY 1.3 GIVING WC-GAP\n              IF WC-GAP = 9 OR 10\n                 MOVE 11 TO WC-GAP.\n\n           MOVE 1   TO WC-SUB-1.\n           MOVE \"Y\" TO WF-FINISHED.\n\n           PERFORM F-SCAN UNTIL WC-SUB-1 + WC-GAP > WC-SIZE.\n\n       E-999.\n           EXIT.\n\n       F-SCAN SECTION.\n       F-000.\n           ADD WC-SUB-1 WC-GAP GIVING WC-SUB-2.\n           IF WB-ENTRY(WC-SUB-1) > WB-ENTRY(WC-SUB-2)\n              MOVE WB-ENTRY(WC-SUB-1) TO WC-TEMP\n              MOVE WB-ENTRY(WC-SUB-2) TO WB-ENTRY(WC-SUB-1)\n              MOVE WC-TEMP            TO WB-ENTRY(WC-SUB-2)\n              MOVE \"N\"                TO WF-FINISHED.\n\n           ADD 1 TO WC-SUB-1.\n\n       F-999.\n           EXIT.\n", "target": "using System;\n\nnamespace CombSort\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] unsorted = new int[] { 3, 5, 1, 9, 7, 6, 8, 2, 4 };\n            Console.WriteLine(string.Join(\",\", combSort(unsorted)));\n        }\n        public static int[] combSort(int[] input)\n        {\n            double gap = input.Length;\n            bool swaps = true;\n            while (gap > 1 || swaps)\n            {\n                gap /= 1.247330950103979;\n                if (gap < 1) { gap = 1; }\n                int i = 0;\n                swaps = false;\n                while (i + gap < input.Length)\n                {\n                    int igap = i + (int)gap;\n                    if (input[i] > input[igap])\n                    {\n                        int swap = input[i];\n                        input[i] = input[igap];\n                        input[igap] = swap;\n                        swaps = true;\n                    }\n                    i++;\n                }\n            }\n            return input;\n        }\n    }\n}\n"}
{"id": 148256, "name": "Sorting algorithms_Comb sort", "source": "Translate COBOL to Java:        C-PROCESS SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           MOVE WC-SIZE TO WC-GAP.\n\n           PERFORM E-COMB UNTIL WC-GAP = 1 AND FINISHED.\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       E-COMB SECTION.\n       E-000.\n           IF WC-GAP > 1\n              DIVIDE WC-GAP BY 1.3 GIVING WC-GAP\n              IF WC-GAP = 9 OR 10\n                 MOVE 11 TO WC-GAP.\n\n           MOVE 1   TO WC-SUB-1.\n           MOVE \"Y\" TO WF-FINISHED.\n\n           PERFORM F-SCAN UNTIL WC-SUB-1 + WC-GAP > WC-SIZE.\n\n       E-999.\n           EXIT.\n\n       F-SCAN SECTION.\n       F-000.\n           ADD WC-SUB-1 WC-GAP GIVING WC-SUB-2.\n           IF WB-ENTRY(WC-SUB-1) > WB-ENTRY(WC-SUB-2)\n              MOVE WB-ENTRY(WC-SUB-1) TO WC-TEMP\n              MOVE WB-ENTRY(WC-SUB-2) TO WB-ENTRY(WC-SUB-1)\n              MOVE WC-TEMP            TO WB-ENTRY(WC-SUB-2)\n              MOVE \"N\"                TO WF-FINISHED.\n\n           ADD 1 TO WC-SUB-1.\n\n       F-999.\n           EXIT.\n", "target": "public static <E extends Comparable<? super E>> void sort(E[] input) {\n    int gap = input.length;\n    boolean swapped = true;\n    while (gap > 1 || swapped) {\n        if (gap > 1) {\n            gap = (int) (gap / 1.3);\n        }\n        swapped = false;\n        for (int i = 0; i + gap < input.length; i++) {\n            if (input[i].compareTo(input[i + gap]) > 0) {\n                E t = input[i];\n                input[i] = input[i + gap];\n                input[i + gap] = t;\n                swapped = true;\n            }\n        }\n    }\n}\n"}
{"id": 148257, "name": "Sorting algorithms_Comb sort", "source": "Translate COBOL to Python:        C-PROCESS SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           MOVE WC-SIZE TO WC-GAP.\n\n           PERFORM E-COMB UNTIL WC-GAP = 1 AND FINISHED.\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       E-COMB SECTION.\n       E-000.\n           IF WC-GAP > 1\n              DIVIDE WC-GAP BY 1.3 GIVING WC-GAP\n              IF WC-GAP = 9 OR 10\n                 MOVE 11 TO WC-GAP.\n\n           MOVE 1   TO WC-SUB-1.\n           MOVE \"Y\" TO WF-FINISHED.\n\n           PERFORM F-SCAN UNTIL WC-SUB-1 + WC-GAP > WC-SIZE.\n\n       E-999.\n           EXIT.\n\n       F-SCAN SECTION.\n       F-000.\n           ADD WC-SUB-1 WC-GAP GIVING WC-SUB-2.\n           IF WB-ENTRY(WC-SUB-1) > WB-ENTRY(WC-SUB-2)\n              MOVE WB-ENTRY(WC-SUB-1) TO WC-TEMP\n              MOVE WB-ENTRY(WC-SUB-2) TO WB-ENTRY(WC-SUB-1)\n              MOVE WC-TEMP            TO WB-ENTRY(WC-SUB-2)\n              MOVE \"N\"                TO WF-FINISHED.\n\n           ADD 1 TO WC-SUB-1.\n\n       F-999.\n           EXIT.\n", "target": ">>> def combsort(input):\n    gap = len(input)\n    swaps = True\n    while gap > 1 or swaps:\n        gap = max(1, int(gap / 1.25))  \n        swaps = False\n        for i in range(len(input) - gap):\n            j = i+gap\n            if input[i] > input[j]:\n                input[i], input[j] = input[j], input[i]\n                swaps = True\n\n                \n>>> y = [88, 18, 31, 44, 4, 0, 8, 81, 14, 78, 20, 76, 84, 33, 73, 75, 82, 5, 62, 70]\n>>> combsort(y)\n>>> assert y == sorted(y)\n>>> y\n[0, 4, 5, 8, 14, 18, 20, 31, 33, 44, 62, 70, 73, 75, 76, 78, 81, 82, 84, 88]\n>>>\n"}
{"id": 148465, "name": "Horizontal sundial calculations", "source": "Translate COBOL to C#: PROGRAM-ID. horizontal-sundial-calc.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  latitude                       PIC S9(3)V9(5) COMP.\n01  longitude                      PIC S9(3)V9(5) COMP.\n01  legal-meridian                 PIC S9(3)V9(5) COMP.\n\n01  lat-sine                       PIC S9(3)V9(5) COMP.\n01  diff-longitude                 PIC S9(3)V9(5) COMP. \n\n01  lat-sine-disp                  PIC -(3)9.9(5).\n01  diff-longitude-disp            PIC -(3)9.9(5).\n\n01  hour                           PIC S9 COMP.\n01  sun-hour-angle                 PIC S9(3)V9(5) COMP.\n01  dial-hour-line-angle           PIC S9(3)V9(5) COMP. \n\n01  hour-disp                      PIC 99.\n01  sun-hour-angle-disp            PIC -(3)9.9(5).\n01  dial-hour-line-angle-disp      PIC -(3)9.9(5).\n\nPROCEDURE DIVISION.\n    DISPLAY \"Enter latitude: \" NO ADVANCING\n    ACCEPT latitude\n    DISPLAY \"Enter longitude: \" NO ADVANCING\n    ACCEPT longitude\n    DISPLAY \"Enter legal meridian: \" NO ADVANCING\n    ACCEPT legal-meridian\n    DISPLAY SPACE\n    \n    COMPUTE lat-sine, lat-sine-disp ROUNDED =\n        FUNCTION SIN(latitude * 2 * FUNCTION PI / 360)\n    DISPLAY \"Sine of latitude: \" FUNCTION TRIM(lat-sine-disp)\n\n    SUBTRACT legal-meridian FROM longitude\n        GIVING diff-longitude, diff-longitude-disp\n    DISPLAY \"Diff longitude: \" FUNCTION TRIM(diff-longitude-disp)\n    DISPLAY SPACE\n\n    DISPLAY \"Time   Sun hour angle  Dial hour line angle\"\n    PERFORM VARYING hour FROM -6 BY 1 UNTIL hour > 6\n        COMPUTE sun-hour-angle ROUNDED = hour * 15 - diff-longitude\n        COMPUTE dial-hour-line-angle ROUNDED = FUNCTION ATAN(lat-sine\n            * FUNCTION TAN(sun-hour-angle * 2 * FUNCTION PI / 360))\n            * 360 / (2 * FUNCTION PI)\n\n        ADD 12 TO hour GIVING hour-disp\n        MOVE sun-hour-angle TO sun-hour-angle-disp\n        MOVE dial-hour-line-angle TO dial-hour-line-angle-disp\n        DISPLAY hour-disp \":00 \" sun-hour-angle-disp \"      \"\n            dial-hour-line-angle-disp\n    END-PERFORM\n    .\n", "target": "using System;\n\nnamespace RosettaCode\n{\n  internal sealed class Program\n  {\n    private static void Main()\n    {\n      Func<double> getDouble = () => Convert.ToDouble(Console.ReadLine());\n      double h = 0, lat, lng, lme, slat, hra, hla;\n\n      Console.Write(\"Enter latitude       => \");\n      lat = getDouble();\n      Console.Write(\"Enter longitude      => \");\n      lng = getDouble();\n      Console.Write(\"Enter legal meridian => \");\n      lme = getDouble();\n\n      slat = Math.Sin(lat*2*Math.PI/360);\n      Console.WriteLine(\"\\n    sine of latitude:   {0:0.000}\", slat);\n      Console.WriteLine(\"    diff longitude:     {0:0.000}\\n\", lng-lme);\n      Console.WriteLine(\"Hour, sun hour angle, dial hour line angle from 6am to 6pm\");\n      for (h = -6; h<6; h++)\n      {\n        hra = 15*h;\n        hra -= lng-lme;\n        hla = Math.Atan(slat*Math.Tan(hra*2*Math.PI/360))*360/(2*Math.PI);\n        Console.WriteLine(\"HR= {0,7:0.000}; HRA {1,7:0.000}; HLA= {2,7:0.000}\", h, hra, hla);\n      }\n    }\n  }\n}\n"}
{"id": 148467, "name": "Horizontal sundial calculations", "source": "Translate COBOL to Java: PROGRAM-ID. horizontal-sundial-calc.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  latitude                       PIC S9(3)V9(5) COMP.\n01  longitude                      PIC S9(3)V9(5) COMP.\n01  legal-meridian                 PIC S9(3)V9(5) COMP.\n\n01  lat-sine                       PIC S9(3)V9(5) COMP.\n01  diff-longitude                 PIC S9(3)V9(5) COMP. \n\n01  lat-sine-disp                  PIC -(3)9.9(5).\n01  diff-longitude-disp            PIC -(3)9.9(5).\n\n01  hour                           PIC S9 COMP.\n01  sun-hour-angle                 PIC S9(3)V9(5) COMP.\n01  dial-hour-line-angle           PIC S9(3)V9(5) COMP. \n\n01  hour-disp                      PIC 99.\n01  sun-hour-angle-disp            PIC -(3)9.9(5).\n01  dial-hour-line-angle-disp      PIC -(3)9.9(5).\n\nPROCEDURE DIVISION.\n    DISPLAY \"Enter latitude: \" NO ADVANCING\n    ACCEPT latitude\n    DISPLAY \"Enter longitude: \" NO ADVANCING\n    ACCEPT longitude\n    DISPLAY \"Enter legal meridian: \" NO ADVANCING\n    ACCEPT legal-meridian\n    DISPLAY SPACE\n    \n    COMPUTE lat-sine, lat-sine-disp ROUNDED =\n        FUNCTION SIN(latitude * 2 * FUNCTION PI / 360)\n    DISPLAY \"Sine of latitude: \" FUNCTION TRIM(lat-sine-disp)\n\n    SUBTRACT legal-meridian FROM longitude\n        GIVING diff-longitude, diff-longitude-disp\n    DISPLAY \"Diff longitude: \" FUNCTION TRIM(diff-longitude-disp)\n    DISPLAY SPACE\n\n    DISPLAY \"Time   Sun hour angle  Dial hour line angle\"\n    PERFORM VARYING hour FROM -6 BY 1 UNTIL hour > 6\n        COMPUTE sun-hour-angle ROUNDED = hour * 15 - diff-longitude\n        COMPUTE dial-hour-line-angle ROUNDED = FUNCTION ATAN(lat-sine\n            * FUNCTION TAN(sun-hour-angle * 2 * FUNCTION PI / 360))\n            * 360 / (2 * FUNCTION PI)\n\n        ADD 12 TO hour GIVING hour-disp\n        MOVE sun-hour-angle TO sun-hour-angle-disp\n        MOVE dial-hour-line-angle TO dial-hour-line-angle-disp\n        DISPLAY hour-disp \":00 \" sun-hour-angle-disp \"      \"\n            dial-hour-line-angle-disp\n    END-PERFORM\n    .\n", "target": "import java.util.Scanner;\n\npublic class Sundial {\n    public static void main(String[] args) {\n        double lat, slat, lng, ref;\n        Scanner sc = new Scanner(System.in);\n\n        System.out.print(\"Enter latitude: \");\n        lat = sc.nextDouble();\n        System.out.print(\"Enter longitude: \");\n        lng = sc.nextDouble();\n        System.out.print(\"Enter legal meridian: \");\n        ref = sc.nextDouble();\n        System.out.println();\n\n        slat = Math.sin(Math.toRadians(lat));\n        System.out.printf(\"sine of latitude:\u00a0%.3f\\n\", slat);\n        System.out.printf(\"diff longitude:\u00a0%.3f\\n\\n\", lng - ref);\n\n        System.out.printf(\"Hour, sun hour angle, dial hour line angle from 6am to 6pm\\n\");\n\n        for (int h = -6; h <= 6; h++) {\n            double hla, hra, hraRad;\n            hra = 15.0 * h;\n            hra = hra - lng + ref;\n            hraRad = Math.toRadians(hra);\n            hla = Math.toDegrees(Math.atan2(Math.sin(hraRad)*Math.sin(Math.toRadians(lat)), Math.cos(hraRad)));\n            System.out.printf(\"HR= %3d;  \\t  HRA=%7.3f;  \\t  HLA= %7.3f\\n\",\n                    h, hra, hla);\n        }\n    }\n}\n"}
{"id": 148468, "name": "Horizontal sundial calculations", "source": "Translate COBOL to Python: PROGRAM-ID. horizontal-sundial-calc.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  latitude                       PIC S9(3)V9(5) COMP.\n01  longitude                      PIC S9(3)V9(5) COMP.\n01  legal-meridian                 PIC S9(3)V9(5) COMP.\n\n01  lat-sine                       PIC S9(3)V9(5) COMP.\n01  diff-longitude                 PIC S9(3)V9(5) COMP. \n\n01  lat-sine-disp                  PIC -(3)9.9(5).\n01  diff-longitude-disp            PIC -(3)9.9(5).\n\n01  hour                           PIC S9 COMP.\n01  sun-hour-angle                 PIC S9(3)V9(5) COMP.\n01  dial-hour-line-angle           PIC S9(3)V9(5) COMP. \n\n01  hour-disp                      PIC 99.\n01  sun-hour-angle-disp            PIC -(3)9.9(5).\n01  dial-hour-line-angle-disp      PIC -(3)9.9(5).\n\nPROCEDURE DIVISION.\n    DISPLAY \"Enter latitude: \" NO ADVANCING\n    ACCEPT latitude\n    DISPLAY \"Enter longitude: \" NO ADVANCING\n    ACCEPT longitude\n    DISPLAY \"Enter legal meridian: \" NO ADVANCING\n    ACCEPT legal-meridian\n    DISPLAY SPACE\n    \n    COMPUTE lat-sine, lat-sine-disp ROUNDED =\n        FUNCTION SIN(latitude * 2 * FUNCTION PI / 360)\n    DISPLAY \"Sine of latitude: \" FUNCTION TRIM(lat-sine-disp)\n\n    SUBTRACT legal-meridian FROM longitude\n        GIVING diff-longitude, diff-longitude-disp\n    DISPLAY \"Diff longitude: \" FUNCTION TRIM(diff-longitude-disp)\n    DISPLAY SPACE\n\n    DISPLAY \"Time   Sun hour angle  Dial hour line angle\"\n    PERFORM VARYING hour FROM -6 BY 1 UNTIL hour > 6\n        COMPUTE sun-hour-angle ROUNDED = hour * 15 - diff-longitude\n        COMPUTE dial-hour-line-angle ROUNDED = FUNCTION ATAN(lat-sine\n            * FUNCTION TAN(sun-hour-angle * 2 * FUNCTION PI / 360))\n            * 360 / (2 * FUNCTION PI)\n\n        ADD 12 TO hour GIVING hour-disp\n        MOVE sun-hour-angle TO sun-hour-angle-disp\n        MOVE dial-hour-line-angle TO dial-hour-line-angle-disp\n        DISPLAY hour-disp \":00 \" sun-hour-angle-disp \"      \"\n            dial-hour-line-angle-disp\n    END-PERFORM\n    .\n", "target": "from __future__ import print_function\nimport math\ntry: raw_input\nexcept: raw_input = input\n\nlat = float(raw_input(\"Enter latitude       => \"))\nlng = float(raw_input(\"Enter longitude      => \"))\nref = float(raw_input(\"Enter legal meridian => \"))\nprint()\n\nslat = math.sin(math.radians(lat))\nprint(\"    sine of latitude:   %.3f\" % slat)\nprint(\"    diff longitude:     %.3f\" % (lng-ref))\nprint()\nprint(\"Hour, sun hour angle, dial hour line angle from 6am to 6pm\")\n\nfor h in range(-6, 7):\n  hra = 15 * h\n  hra -= lng - ref\n  hla = math.degrees(math.atan(slat * math.tan(math.radians(hra))))\n  print(\"HR=%3d; HRA=%7.3f; HLA=%7.3f\" % (h, hra, hla))\n"}
{"id": 148767, "name": "Attractive numbers", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ATTRACTIVE-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       77 MAXIMUM         PIC 999 VALUE 120.\n       01 SIEVE-DATA      VALUE SPACES.\n          03 MARKER       PIC X OCCURS 120 TIMES.\n             88 PRIME     VALUE SPACE.\n          03 SIEVE-MAX    PIC 999.\n          03 COMPOSITE    PIC 999.\n          03 CANDIDATE    PIC 999.\n\n       01 FACTORIZE-DATA.\n          03 FACTOR-NUM   PIC 999.\n          03 FACTORS      PIC 999.\n          03 FACTOR       PIC 999.\n          03 QUOTIENT     PIC 999V999.\n          03 FILLER       REDEFINES QUOTIENT.\n             05 FILLER    PIC 999.\n             05 DECIMAL   PIC 999.\n\n       01 OUTPUT-FORMAT.\n          03 OUT-NUM      PIC ZZZ9.\n          03 OUT-LINE     PIC X(72) VALUE SPACES.\n          03 COL-PTR      PIC 99 VALUE 1.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SIEVE.\n           PERFORM CHECK-ATTRACTIVE\n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN MAXIMUM.\n           PERFORM WRITE-LINE.\n           STOP RUN.\n\n       CHECK-ATTRACTIVE.\n           MOVE CANDIDATE TO FACTOR-NUM.\n           PERFORM FACTORIZE.\n           IF PRIME(FACTORS), PERFORM ADD-TO-OUTPUT.\n\n       ADD-TO-OUTPUT.\n           MOVE CANDIDATE TO OUT-NUM.\n           STRING OUT-NUM DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER COL-PTR.\n           IF COL-PTR IS EQUAL TO 73, PERFORM WRITE-LINE.\n\n       WRITE-LINE.\n           DISPLAY OUT-LINE.\n           MOVE SPACES TO OUT-LINE.\n           MOVE 1 TO COL-PTR.\n\n       FACTORIZE SECTION.\n       BEGIN.\n           MOVE ZERO TO FACTORS.\n           PERFORM DIVIDE-PRIME\n               VARYING FACTOR FROM 2 BY 1\n               UNTIL FACTOR IS GREATER THAN MAXIMUM.\n           GO TO DONE.\n\n       DIVIDE-PRIME.\n           IF PRIME(FACTOR),\n               DIVIDE FACTOR-NUM BY FACTOR GIVING QUOTIENT,\n               IF DECIMAL IS EQUAL TO ZERO,\n                   ADD 1 TO FACTORS,\n                   MOVE QUOTIENT TO FACTOR-NUM,\n                   GO TO DIVIDE-PRIME.\n       DONE.\n           EXIT.\n\n       SIEVE SECTION.\n       BEGIN.\n           MOVE 'X' TO MARKER(1).\n           DIVIDE MAXIMUM BY 2 GIVING SIEVE-MAX.\n           PERFORM SET-COMPOSITES THRU SET-COMPOSITES-LOOP\n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN SIEVE-MAX.\n           GO TO DONE.\n\n       SET-COMPOSITES.\n           MULTIPLY CANDIDATE BY 2 GIVING COMPOSITE.\n       SET-COMPOSITES-LOOP.\n           IF COMPOSITE IS NOT GREATER THAN MAXIMUM,\n               MOVE 'X' TO MARKER(COMPOSITE),\n               ADD CANDIDATE TO COMPOSITE,\n               GO TO SET-COMPOSITES-LOOP.\n       DONE.\n           EXIT.\n", "target": "using System;\n\nnamespace AttractiveNumbers {\n    class Program {\n        const int MAX = 120;\n\n        static bool IsPrime(int n) {\n            if (n < 2) return false;\n            if (n % 2 == 0) return n == 2;\n            if (n % 3 == 0) return n == 3;\n            int d = 5;\n            while (d * d <= n) {\n                if (n % d == 0) return false;\n                d += 2;\n                if (n % d == 0) return false;\n                d += 4;\n            }\n            return true;\n        }\n\n        static int PrimeFactorCount(int n) {\n            if (n == 1) return 0;\n            if (IsPrime(n)) return 1;\n            int count = 0;\n            int f = 2;\n            while (true) {\n                if (n % f == 0) {\n                    count++;\n                    n /= f;\n                    if (n == 1) return count;\n                    if (IsPrime(n)) f = n;\n                } else if (f >= 3) {\n                    f += 2;\n                } else {\n                    f = 3;\n                }\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"The attractive numbers up to and including {0} are:\", MAX);\n            int i = 1;\n            int count = 0;\n            while (i <= MAX) {\n                int n = PrimeFactorCount(i);\n                if (IsPrime(n)) {\n                    Console.Write(\"{0,4}\", i);\n                    if (++count % 20 == 0) Console.WriteLine();\n                }\n                ++i;\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 148768, "name": "Attractive numbers", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ATTRACTIVE-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       77 MAXIMUM         PIC 999 VALUE 120.\n       01 SIEVE-DATA      VALUE SPACES.\n          03 MARKER       PIC X OCCURS 120 TIMES.\n             88 PRIME     VALUE SPACE.\n          03 SIEVE-MAX    PIC 999.\n          03 COMPOSITE    PIC 999.\n          03 CANDIDATE    PIC 999.\n\n       01 FACTORIZE-DATA.\n          03 FACTOR-NUM   PIC 999.\n          03 FACTORS      PIC 999.\n          03 FACTOR       PIC 999.\n          03 QUOTIENT     PIC 999V999.\n          03 FILLER       REDEFINES QUOTIENT.\n             05 FILLER    PIC 999.\n             05 DECIMAL   PIC 999.\n\n       01 OUTPUT-FORMAT.\n          03 OUT-NUM      PIC ZZZ9.\n          03 OUT-LINE     PIC X(72) VALUE SPACES.\n          03 COL-PTR      PIC 99 VALUE 1.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SIEVE.\n           PERFORM CHECK-ATTRACTIVE\n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN MAXIMUM.\n           PERFORM WRITE-LINE.\n           STOP RUN.\n\n       CHECK-ATTRACTIVE.\n           MOVE CANDIDATE TO FACTOR-NUM.\n           PERFORM FACTORIZE.\n           IF PRIME(FACTORS), PERFORM ADD-TO-OUTPUT.\n\n       ADD-TO-OUTPUT.\n           MOVE CANDIDATE TO OUT-NUM.\n           STRING OUT-NUM DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER COL-PTR.\n           IF COL-PTR IS EQUAL TO 73, PERFORM WRITE-LINE.\n\n       WRITE-LINE.\n           DISPLAY OUT-LINE.\n           MOVE SPACES TO OUT-LINE.\n           MOVE 1 TO COL-PTR.\n\n       FACTORIZE SECTION.\n       BEGIN.\n           MOVE ZERO TO FACTORS.\n           PERFORM DIVIDE-PRIME\n               VARYING FACTOR FROM 2 BY 1\n               UNTIL FACTOR IS GREATER THAN MAXIMUM.\n           GO TO DONE.\n\n       DIVIDE-PRIME.\n           IF PRIME(FACTOR),\n               DIVIDE FACTOR-NUM BY FACTOR GIVING QUOTIENT,\n               IF DECIMAL IS EQUAL TO ZERO,\n                   ADD 1 TO FACTORS,\n                   MOVE QUOTIENT TO FACTOR-NUM,\n                   GO TO DIVIDE-PRIME.\n       DONE.\n           EXIT.\n\n       SIEVE SECTION.\n       BEGIN.\n           MOVE 'X' TO MARKER(1).\n           DIVIDE MAXIMUM BY 2 GIVING SIEVE-MAX.\n           PERFORM SET-COMPOSITES THRU SET-COMPOSITES-LOOP\n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN SIEVE-MAX.\n           GO TO DONE.\n\n       SET-COMPOSITES.\n           MULTIPLY CANDIDATE BY 2 GIVING COMPOSITE.\n       SET-COMPOSITES-LOOP.\n           IF COMPOSITE IS NOT GREATER THAN MAXIMUM,\n               MOVE 'X' TO MARKER(COMPOSITE),\n               ADD CANDIDATE TO COMPOSITE,\n               GO TO SET-COMPOSITES-LOOP.\n       DONE.\n           EXIT.\n", "target": "using System;\n\nnamespace AttractiveNumbers {\n    class Program {\n        const int MAX = 120;\n\n        static bool IsPrime(int n) {\n            if (n < 2) return false;\n            if (n % 2 == 0) return n == 2;\n            if (n % 3 == 0) return n == 3;\n            int d = 5;\n            while (d * d <= n) {\n                if (n % d == 0) return false;\n                d += 2;\n                if (n % d == 0) return false;\n                d += 4;\n            }\n            return true;\n        }\n\n        static int PrimeFactorCount(int n) {\n            if (n == 1) return 0;\n            if (IsPrime(n)) return 1;\n            int count = 0;\n            int f = 2;\n            while (true) {\n                if (n % f == 0) {\n                    count++;\n                    n /= f;\n                    if (n == 1) return count;\n                    if (IsPrime(n)) f = n;\n                } else if (f >= 3) {\n                    f += 2;\n                } else {\n                    f = 3;\n                }\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"The attractive numbers up to and including {0} are:\", MAX);\n            int i = 1;\n            int count = 0;\n            while (i <= MAX) {\n                int n = PrimeFactorCount(i);\n                if (IsPrime(n)) {\n                    Console.Write(\"{0,4}\", i);\n                    if (++count % 20 == 0) Console.WriteLine();\n                }\n                ++i;\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 148771, "name": "Attractive numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ATTRACTIVE-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       77 MAXIMUM         PIC 999 VALUE 120.\n       01 SIEVE-DATA      VALUE SPACES.\n          03 MARKER       PIC X OCCURS 120 TIMES.\n             88 PRIME     VALUE SPACE.\n          03 SIEVE-MAX    PIC 999.\n          03 COMPOSITE    PIC 999.\n          03 CANDIDATE    PIC 999.\n\n       01 FACTORIZE-DATA.\n          03 FACTOR-NUM   PIC 999.\n          03 FACTORS      PIC 999.\n          03 FACTOR       PIC 999.\n          03 QUOTIENT     PIC 999V999.\n          03 FILLER       REDEFINES QUOTIENT.\n             05 FILLER    PIC 999.\n             05 DECIMAL   PIC 999.\n\n       01 OUTPUT-FORMAT.\n          03 OUT-NUM      PIC ZZZ9.\n          03 OUT-LINE     PIC X(72) VALUE SPACES.\n          03 COL-PTR      PIC 99 VALUE 1.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SIEVE.\n           PERFORM CHECK-ATTRACTIVE\n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN MAXIMUM.\n           PERFORM WRITE-LINE.\n           STOP RUN.\n\n       CHECK-ATTRACTIVE.\n           MOVE CANDIDATE TO FACTOR-NUM.\n           PERFORM FACTORIZE.\n           IF PRIME(FACTORS), PERFORM ADD-TO-OUTPUT.\n\n       ADD-TO-OUTPUT.\n           MOVE CANDIDATE TO OUT-NUM.\n           STRING OUT-NUM DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER COL-PTR.\n           IF COL-PTR IS EQUAL TO 73, PERFORM WRITE-LINE.\n\n       WRITE-LINE.\n           DISPLAY OUT-LINE.\n           MOVE SPACES TO OUT-LINE.\n           MOVE 1 TO COL-PTR.\n\n       FACTORIZE SECTION.\n       BEGIN.\n           MOVE ZERO TO FACTORS.\n           PERFORM DIVIDE-PRIME\n               VARYING FACTOR FROM 2 BY 1\n               UNTIL FACTOR IS GREATER THAN MAXIMUM.\n           GO TO DONE.\n\n       DIVIDE-PRIME.\n           IF PRIME(FACTOR),\n               DIVIDE FACTOR-NUM BY FACTOR GIVING QUOTIENT,\n               IF DECIMAL IS EQUAL TO ZERO,\n                   ADD 1 TO FACTORS,\n                   MOVE QUOTIENT TO FACTOR-NUM,\n                   GO TO DIVIDE-PRIME.\n       DONE.\n           EXIT.\n\n       SIEVE SECTION.\n       BEGIN.\n           MOVE 'X' TO MARKER(1).\n           DIVIDE MAXIMUM BY 2 GIVING SIEVE-MAX.\n           PERFORM SET-COMPOSITES THRU SET-COMPOSITES-LOOP\n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN SIEVE-MAX.\n           GO TO DONE.\n\n       SET-COMPOSITES.\n           MULTIPLY CANDIDATE BY 2 GIVING COMPOSITE.\n       SET-COMPOSITES-LOOP.\n           IF COMPOSITE IS NOT GREATER THAN MAXIMUM,\n               MOVE 'X' TO MARKER(COMPOSITE),\n               ADD CANDIDATE TO COMPOSITE,\n               GO TO SET-COMPOSITES-LOOP.\n       DONE.\n           EXIT.\n", "target": "public class Attractive {\n\n    static boolean is_prime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d *d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    static int count_prime_factors(int n) {\n        if (n == 1) return 0;\n        if (is_prime(n)) return 1;\n        int count = 0, f = 2;\n        while (true) {\n            if (n % f == 0) {\n                count++;\n                n /= f;\n                if (n == 1) return count;\n                if (is_prime(n)) f = n;\n            }\n            else if (f >= 3) f += 2;\n            else f = 3;\n        }\n    }\n\n    public static void main(String[] args) {\n        final int max = 120;\n        System.out.printf(\"The attractive numbers up to and including %d are:\\n\", max);\n        for (int i = 1, count = 0; i <= max; ++i) {\n            int n = count_prime_factors(i);\n            if (is_prime(n)) {\n                System.out.printf(\"%4d\", i);\n                if (++count % 20 == 0) System.out.println();\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 148772, "name": "Attractive numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ATTRACTIVE-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       77 MAXIMUM         PIC 999 VALUE 120.\n       01 SIEVE-DATA      VALUE SPACES.\n          03 MARKER       PIC X OCCURS 120 TIMES.\n             88 PRIME     VALUE SPACE.\n          03 SIEVE-MAX    PIC 999.\n          03 COMPOSITE    PIC 999.\n          03 CANDIDATE    PIC 999.\n\n       01 FACTORIZE-DATA.\n          03 FACTOR-NUM   PIC 999.\n          03 FACTORS      PIC 999.\n          03 FACTOR       PIC 999.\n          03 QUOTIENT     PIC 999V999.\n          03 FILLER       REDEFINES QUOTIENT.\n             05 FILLER    PIC 999.\n             05 DECIMAL   PIC 999.\n\n       01 OUTPUT-FORMAT.\n          03 OUT-NUM      PIC ZZZ9.\n          03 OUT-LINE     PIC X(72) VALUE SPACES.\n          03 COL-PTR      PIC 99 VALUE 1.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SIEVE.\n           PERFORM CHECK-ATTRACTIVE\n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN MAXIMUM.\n           PERFORM WRITE-LINE.\n           STOP RUN.\n\n       CHECK-ATTRACTIVE.\n           MOVE CANDIDATE TO FACTOR-NUM.\n           PERFORM FACTORIZE.\n           IF PRIME(FACTORS), PERFORM ADD-TO-OUTPUT.\n\n       ADD-TO-OUTPUT.\n           MOVE CANDIDATE TO OUT-NUM.\n           STRING OUT-NUM DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER COL-PTR.\n           IF COL-PTR IS EQUAL TO 73, PERFORM WRITE-LINE.\n\n       WRITE-LINE.\n           DISPLAY OUT-LINE.\n           MOVE SPACES TO OUT-LINE.\n           MOVE 1 TO COL-PTR.\n\n       FACTORIZE SECTION.\n       BEGIN.\n           MOVE ZERO TO FACTORS.\n           PERFORM DIVIDE-PRIME\n               VARYING FACTOR FROM 2 BY 1\n               UNTIL FACTOR IS GREATER THAN MAXIMUM.\n           GO TO DONE.\n\n       DIVIDE-PRIME.\n           IF PRIME(FACTOR),\n               DIVIDE FACTOR-NUM BY FACTOR GIVING QUOTIENT,\n               IF DECIMAL IS EQUAL TO ZERO,\n                   ADD 1 TO FACTORS,\n                   MOVE QUOTIENT TO FACTOR-NUM,\n                   GO TO DIVIDE-PRIME.\n       DONE.\n           EXIT.\n\n       SIEVE SECTION.\n       BEGIN.\n           MOVE 'X' TO MARKER(1).\n           DIVIDE MAXIMUM BY 2 GIVING SIEVE-MAX.\n           PERFORM SET-COMPOSITES THRU SET-COMPOSITES-LOOP\n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN SIEVE-MAX.\n           GO TO DONE.\n\n       SET-COMPOSITES.\n           MULTIPLY CANDIDATE BY 2 GIVING COMPOSITE.\n       SET-COMPOSITES-LOOP.\n           IF COMPOSITE IS NOT GREATER THAN MAXIMUM,\n               MOVE 'X' TO MARKER(COMPOSITE),\n               ADD CANDIDATE TO COMPOSITE,\n               GO TO SET-COMPOSITES-LOOP.\n       DONE.\n           EXIT.\n", "target": "public class Attractive {\n\n    static boolean is_prime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d *d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    static int count_prime_factors(int n) {\n        if (n == 1) return 0;\n        if (is_prime(n)) return 1;\n        int count = 0, f = 2;\n        while (true) {\n            if (n % f == 0) {\n                count++;\n                n /= f;\n                if (n == 1) return count;\n                if (is_prime(n)) f = n;\n            }\n            else if (f >= 3) f += 2;\n            else f = 3;\n        }\n    }\n\n    public static void main(String[] args) {\n        final int max = 120;\n        System.out.printf(\"The attractive numbers up to and including %d are:\\n\", max);\n        for (int i = 1, count = 0; i <= max; ++i) {\n            int n = count_prime_factors(i);\n            if (is_prime(n)) {\n                System.out.printf(\"%4d\", i);\n                if (++count % 20 == 0) System.out.println();\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 148773, "name": "Attractive numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ATTRACTIVE-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       77 MAXIMUM         PIC 999 VALUE 120.\n       01 SIEVE-DATA      VALUE SPACES.\n          03 MARKER       PIC X OCCURS 120 TIMES.\n             88 PRIME     VALUE SPACE.\n          03 SIEVE-MAX    PIC 999.\n          03 COMPOSITE    PIC 999.\n          03 CANDIDATE    PIC 999.\n\n       01 FACTORIZE-DATA.\n          03 FACTOR-NUM   PIC 999.\n          03 FACTORS      PIC 999.\n          03 FACTOR       PIC 999.\n          03 QUOTIENT     PIC 999V999.\n          03 FILLER       REDEFINES QUOTIENT.\n             05 FILLER    PIC 999.\n             05 DECIMAL   PIC 999.\n\n       01 OUTPUT-FORMAT.\n          03 OUT-NUM      PIC ZZZ9.\n          03 OUT-LINE     PIC X(72) VALUE SPACES.\n          03 COL-PTR      PIC 99 VALUE 1.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SIEVE.\n           PERFORM CHECK-ATTRACTIVE\n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN MAXIMUM.\n           PERFORM WRITE-LINE.\n           STOP RUN.\n\n       CHECK-ATTRACTIVE.\n           MOVE CANDIDATE TO FACTOR-NUM.\n           PERFORM FACTORIZE.\n           IF PRIME(FACTORS), PERFORM ADD-TO-OUTPUT.\n\n       ADD-TO-OUTPUT.\n           MOVE CANDIDATE TO OUT-NUM.\n           STRING OUT-NUM DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER COL-PTR.\n           IF COL-PTR IS EQUAL TO 73, PERFORM WRITE-LINE.\n\n       WRITE-LINE.\n           DISPLAY OUT-LINE.\n           MOVE SPACES TO OUT-LINE.\n           MOVE 1 TO COL-PTR.\n\n       FACTORIZE SECTION.\n       BEGIN.\n           MOVE ZERO TO FACTORS.\n           PERFORM DIVIDE-PRIME\n               VARYING FACTOR FROM 2 BY 1\n               UNTIL FACTOR IS GREATER THAN MAXIMUM.\n           GO TO DONE.\n\n       DIVIDE-PRIME.\n           IF PRIME(FACTOR),\n               DIVIDE FACTOR-NUM BY FACTOR GIVING QUOTIENT,\n               IF DECIMAL IS EQUAL TO ZERO,\n                   ADD 1 TO FACTORS,\n                   MOVE QUOTIENT TO FACTOR-NUM,\n                   GO TO DIVIDE-PRIME.\n       DONE.\n           EXIT.\n\n       SIEVE SECTION.\n       BEGIN.\n           MOVE 'X' TO MARKER(1).\n           DIVIDE MAXIMUM BY 2 GIVING SIEVE-MAX.\n           PERFORM SET-COMPOSITES THRU SET-COMPOSITES-LOOP\n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN SIEVE-MAX.\n           GO TO DONE.\n\n       SET-COMPOSITES.\n           MULTIPLY CANDIDATE BY 2 GIVING COMPOSITE.\n       SET-COMPOSITES-LOOP.\n           IF COMPOSITE IS NOT GREATER THAN MAXIMUM,\n               MOVE 'X' TO MARKER(COMPOSITE),\n               ADD CANDIDATE TO COMPOSITE,\n               GO TO SET-COMPOSITES-LOOP.\n       DONE.\n           EXIT.\n", "target": "from sympy import sieve \n\ndef get_pfct(n): \n\ti = 2; factors = []\n\twhile i * i <= n:\n\t\tif n % i:\n\t\t\ti += 1\n\t\telse:\n\t\t\tn //= i\n\t\t\tfactors.append(i)\n\tif n > 1:\n\t\tfactors.append(n)\n\treturn len(factors) \n\nsieve.extend(110) \nprimes=sieve._list\n\npool=[]\n\nfor each in xrange(0,121):\n\tpool.append(get_pfct(each))\n\nfor i,each in enumerate(pool):\n\tif each in primes:\n\t\tprint i,\n"}
{"id": 148774, "name": "Attractive numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ATTRACTIVE-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       77 MAXIMUM         PIC 999 VALUE 120.\n       01 SIEVE-DATA      VALUE SPACES.\n          03 MARKER       PIC X OCCURS 120 TIMES.\n             88 PRIME     VALUE SPACE.\n          03 SIEVE-MAX    PIC 999.\n          03 COMPOSITE    PIC 999.\n          03 CANDIDATE    PIC 999.\n\n       01 FACTORIZE-DATA.\n          03 FACTOR-NUM   PIC 999.\n          03 FACTORS      PIC 999.\n          03 FACTOR       PIC 999.\n          03 QUOTIENT     PIC 999V999.\n          03 FILLER       REDEFINES QUOTIENT.\n             05 FILLER    PIC 999.\n             05 DECIMAL   PIC 999.\n\n       01 OUTPUT-FORMAT.\n          03 OUT-NUM      PIC ZZZ9.\n          03 OUT-LINE     PIC X(72) VALUE SPACES.\n          03 COL-PTR      PIC 99 VALUE 1.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SIEVE.\n           PERFORM CHECK-ATTRACTIVE\n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN MAXIMUM.\n           PERFORM WRITE-LINE.\n           STOP RUN.\n\n       CHECK-ATTRACTIVE.\n           MOVE CANDIDATE TO FACTOR-NUM.\n           PERFORM FACTORIZE.\n           IF PRIME(FACTORS), PERFORM ADD-TO-OUTPUT.\n\n       ADD-TO-OUTPUT.\n           MOVE CANDIDATE TO OUT-NUM.\n           STRING OUT-NUM DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER COL-PTR.\n           IF COL-PTR IS EQUAL TO 73, PERFORM WRITE-LINE.\n\n       WRITE-LINE.\n           DISPLAY OUT-LINE.\n           MOVE SPACES TO OUT-LINE.\n           MOVE 1 TO COL-PTR.\n\n       FACTORIZE SECTION.\n       BEGIN.\n           MOVE ZERO TO FACTORS.\n           PERFORM DIVIDE-PRIME\n               VARYING FACTOR FROM 2 BY 1\n               UNTIL FACTOR IS GREATER THAN MAXIMUM.\n           GO TO DONE.\n\n       DIVIDE-PRIME.\n           IF PRIME(FACTOR),\n               DIVIDE FACTOR-NUM BY FACTOR GIVING QUOTIENT,\n               IF DECIMAL IS EQUAL TO ZERO,\n                   ADD 1 TO FACTORS,\n                   MOVE QUOTIENT TO FACTOR-NUM,\n                   GO TO DIVIDE-PRIME.\n       DONE.\n           EXIT.\n\n       SIEVE SECTION.\n       BEGIN.\n           MOVE 'X' TO MARKER(1).\n           DIVIDE MAXIMUM BY 2 GIVING SIEVE-MAX.\n           PERFORM SET-COMPOSITES THRU SET-COMPOSITES-LOOP\n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN SIEVE-MAX.\n           GO TO DONE.\n\n       SET-COMPOSITES.\n           MULTIPLY CANDIDATE BY 2 GIVING COMPOSITE.\n       SET-COMPOSITES-LOOP.\n           IF COMPOSITE IS NOT GREATER THAN MAXIMUM,\n               MOVE 'X' TO MARKER(COMPOSITE),\n               ADD CANDIDATE TO COMPOSITE,\n               GO TO SET-COMPOSITES-LOOP.\n       DONE.\n           EXIT.\n", "target": "from sympy import sieve \n\ndef get_pfct(n): \n\ti = 2; factors = []\n\twhile i * i <= n:\n\t\tif n % i:\n\t\t\ti += 1\n\t\telse:\n\t\t\tn //= i\n\t\t\tfactors.append(i)\n\tif n > 1:\n\t\tfactors.append(n)\n\treturn len(factors) \n\nsieve.extend(110) \nprimes=sieve._list\n\npool=[]\n\nfor each in xrange(0,121):\n\tpool.append(get_pfct(each))\n\nfor i,each in enumerate(pool):\n\tif each in primes:\n\t\tprint i,\n"}
{"id": 149271, "name": "Trigonometric functions", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Trig.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Pi-Third   USAGE COMP-2.\n       01  Degree     USAGE COMP-2.\n\n       01  60-Degrees USAGE COMP-2.\n\n       01  Result     USAGE COMP-2.\n\n       PROCEDURE DIVISION.\n           COMPUTE Pi-Third = FUNCTION PI / 3\n\n           DISPLAY \"Radians:\"\n           DISPLAY \"  Sin(\u03c0 / 3)  = \" FUNCTION SIN(Pi-Third)\n           DISPLAY \"  Cos(\u03c0 / 3)  = \" FUNCTION COS(Pi-Third)\n           DISPLAY \"  Tan(\u03c0 / 3)  = \" FUNCTION TAN(Pi-Third)\n           DISPLAY \"  Asin(0.5)   = \" FUNCTION ASIN(0.5)\n           DISPLAY \"  Acos(0.5)   = \" FUNCTION ACOS(0.5)\n           DISPLAY \"  Atan(0.5)   = \" FUNCTION ATAN(0.5)\n\n           COMPUTE Degree = FUNCTION PI / 180\n           COMPUTE 60-Degrees = Degree * 60\n\n           DISPLAY \"Degrees:\"\n           DISPLAY \"  Sin(60\u00b0)  = \" FUNCTION SIN(60-Degrees)\n           DISPLAY \"  Cos(60\u00b0)  = \" FUNCTION COS(60-Degrees)\n           DISPLAY \"  Tan(60\u00b0)  = \" FUNCTION TAN(60-Degrees)\n           COMPUTE Result = FUNCTION ASIN(0.5) / 60\n           DISPLAY \"  Asin(0.5) = \" Result\n           COMPUTE Result = FUNCTION ACOS(0.5) / 60\n           DISPLAY \"  Acos(0.5) = \" Result\n           COMPUTE Result = FUNCTION ATAN(0.5) / 60\n           DISPLAY \"  Atan(0.5) = \" Result\n\n           GOBACK\n           .\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            Console.WriteLine(\"=== radians ===\");\n            Console.WriteLine(\"sin (pi/3) = {0}\", Math.Sin(Math.PI / 3));\n            Console.WriteLine(\"cos (pi/3) = {0}\", Math.Cos(Math.PI / 3));\n            Console.WriteLine(\"tan (pi/3) = {0}\", Math.Tan(Math.PI / 3));\n            Console.WriteLine(\"arcsin (1/2) = {0}\", Math.Asin(0.5));\n            Console.WriteLine(\"arccos (1/2) = {0}\", Math.Acos(0.5));\n            Console.WriteLine(\"arctan (1/2) = {0}\", Math.Atan(0.5));\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"=== degrees ===\");\n            Console.WriteLine(\"sin (60) = {0}\", Math.Sin(60 * Math.PI / 180));\n            Console.WriteLine(\"cos (60) = {0}\", Math.Cos(60 * Math.PI / 180));\n            Console.WriteLine(\"tan (60) = {0}\", Math.Tan(60 * Math.PI / 180));\n            Console.WriteLine(\"arcsin (1/2) = {0}\", Math.Asin(0.5) * 180/ Math.PI);\n            Console.WriteLine(\"arccos (1/2) = {0}\", Math.Acos(0.5) * 180 / Math.PI);\n            Console.WriteLine(\"arctan (1/2) = {0}\", Math.Atan(0.5) * 180 / Math.PI);\n\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 149273, "name": "Trigonometric functions", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Trig.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Pi-Third   USAGE COMP-2.\n       01  Degree     USAGE COMP-2.\n\n       01  60-Degrees USAGE COMP-2.\n\n       01  Result     USAGE COMP-2.\n\n       PROCEDURE DIVISION.\n           COMPUTE Pi-Third = FUNCTION PI / 3\n\n           DISPLAY \"Radians:\"\n           DISPLAY \"  Sin(\u03c0 / 3)  = \" FUNCTION SIN(Pi-Third)\n           DISPLAY \"  Cos(\u03c0 / 3)  = \" FUNCTION COS(Pi-Third)\n           DISPLAY \"  Tan(\u03c0 / 3)  = \" FUNCTION TAN(Pi-Third)\n           DISPLAY \"  Asin(0.5)   = \" FUNCTION ASIN(0.5)\n           DISPLAY \"  Acos(0.5)   = \" FUNCTION ACOS(0.5)\n           DISPLAY \"  Atan(0.5)   = \" FUNCTION ATAN(0.5)\n\n           COMPUTE Degree = FUNCTION PI / 180\n           COMPUTE 60-Degrees = Degree * 60\n\n           DISPLAY \"Degrees:\"\n           DISPLAY \"  Sin(60\u00b0)  = \" FUNCTION SIN(60-Degrees)\n           DISPLAY \"  Cos(60\u00b0)  = \" FUNCTION COS(60-Degrees)\n           DISPLAY \"  Tan(60\u00b0)  = \" FUNCTION TAN(60-Degrees)\n           COMPUTE Result = FUNCTION ASIN(0.5) / 60\n           DISPLAY \"  Asin(0.5) = \" Result\n           COMPUTE Result = FUNCTION ACOS(0.5) / 60\n           DISPLAY \"  Acos(0.5) = \" Result\n           COMPUTE Result = FUNCTION ATAN(0.5) / 60\n           DISPLAY \"  Atan(0.5) = \" Result\n\n           GOBACK\n           .\n", "target": "public class Trig {\n        public static void main(String[] args) {\n                \n                double radians = Math.PI / 4;\n                double degrees = 45.0;\n                \n                System.out.println(Math.sin(radians) + \" \" + Math.sin(Math.toRadians(degrees)));\n                \n                System.out.println(Math.cos(radians) + \" \" + Math.cos(Math.toRadians(degrees)));\n                \n                System.out.println(Math.tan(radians) + \" \" + Math.tan(Math.toRadians(degrees)));\n                \n                double arcsin = Math.asin(Math.sin(radians));\n                System.out.println(arcsin + \" \" + Math.toDegrees(arcsin));\n                \n                double arccos = Math.acos(Math.cos(radians));\n                System.out.println(arccos + \" \" + Math.toDegrees(arccos));\n                \n                double arctan = Math.atan(Math.tan(radians));\n                System.out.println(arctan + \" \" + Math.toDegrees(arctan));\n        }\n}\n"}
{"id": 149274, "name": "Trigonometric functions", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Trig.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Pi-Third   USAGE COMP-2.\n       01  Degree     USAGE COMP-2.\n\n       01  60-Degrees USAGE COMP-2.\n\n       01  Result     USAGE COMP-2.\n\n       PROCEDURE DIVISION.\n           COMPUTE Pi-Third = FUNCTION PI / 3\n\n           DISPLAY \"Radians:\"\n           DISPLAY \"  Sin(\u03c0 / 3)  = \" FUNCTION SIN(Pi-Third)\n           DISPLAY \"  Cos(\u03c0 / 3)  = \" FUNCTION COS(Pi-Third)\n           DISPLAY \"  Tan(\u03c0 / 3)  = \" FUNCTION TAN(Pi-Third)\n           DISPLAY \"  Asin(0.5)   = \" FUNCTION ASIN(0.5)\n           DISPLAY \"  Acos(0.5)   = \" FUNCTION ACOS(0.5)\n           DISPLAY \"  Atan(0.5)   = \" FUNCTION ATAN(0.5)\n\n           COMPUTE Degree = FUNCTION PI / 180\n           COMPUTE 60-Degrees = Degree * 60\n\n           DISPLAY \"Degrees:\"\n           DISPLAY \"  Sin(60\u00b0)  = \" FUNCTION SIN(60-Degrees)\n           DISPLAY \"  Cos(60\u00b0)  = \" FUNCTION COS(60-Degrees)\n           DISPLAY \"  Tan(60\u00b0)  = \" FUNCTION TAN(60-Degrees)\n           COMPUTE Result = FUNCTION ASIN(0.5) / 60\n           DISPLAY \"  Asin(0.5) = \" Result\n           COMPUTE Result = FUNCTION ACOS(0.5) / 60\n           DISPLAY \"  Acos(0.5) = \" Result\n           COMPUTE Result = FUNCTION ATAN(0.5) / 60\n           DISPLAY \"  Atan(0.5) = \" Result\n\n           GOBACK\n           .\n", "target": "Python 3.2.2 (default, Sep  4 2011, 09:51:08) [MSC v.1500 32 bit (Intel)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> from math import degrees, radians, sin, cos, tan, asin, acos, atan, pi\n>>> rad, deg = pi/4, 45.0\n>>> print(\"Sine:\", sin(rad), sin(radians(deg)))\nSine: 0.7071067811865475 0.7071067811865475\n>>> print(\"Cosine:\", cos(rad), cos(radians(deg)))\nCosine: 0.7071067811865476 0.7071067811865476\n>>> print(\"Tangent:\", tan(rad), tan(radians(deg)))\nTangent: 0.9999999999999999 0.9999999999999999\n>>> arcsine = asin(sin(rad))\n>>> print(\"Arcsine:\", arcsine, degrees(arcsine))\nArcsine: 0.7853981633974482 44.99999999999999\n>>> arccosine = acos(cos(rad))\n>>> print(\"Arccosine:\", arccosine, degrees(arccosine))\nArccosine: 0.7853981633974483 45.0\n>>> arctangent = atan(tan(rad))\n>>> print(\"Arctangent:\", arctangent, degrees(arctangent))\nArctangent: 0.7853981633974483 45.0\n>>>\n"}
{"id": 149541, "name": "Loops_For", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Display-Triangle.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Outer-Counter PIC 9.\n       01  Inner-Counter PIC 9. \n\n       PROCEDURE DIVISION.\n       PERFORM VARYING Outer-Counter FROM 1 BY 1 UNTIL 5 < Outer-Counter\n\n           PERFORM VARYING Inner-Counter FROM 1 BY 1\n                   UNTIL Outer-Counter < Inner-Counter\n               DISPLAY \"*\" NO ADVANCING\n           END-PERFORM\n\n           DISPLAY \"\" \n       END-PERFORM\n\n       GOBACK\n       .\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            for (int j = 0; j <= i; j++)\n            {\n                Console.Write(\"*\");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 149543, "name": "Loops_For", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Display-Triangle.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Outer-Counter PIC 9.\n       01  Inner-Counter PIC 9. \n\n       PROCEDURE DIVISION.\n       PERFORM VARYING Outer-Counter FROM 1 BY 1 UNTIL 5 < Outer-Counter\n\n           PERFORM VARYING Inner-Counter FROM 1 BY 1\n                   UNTIL Outer-Counter < Inner-Counter\n               DISPLAY \"*\" NO ADVANCING\n           END-PERFORM\n\n           DISPLAY \"\" \n       END-PERFORM\n\n       GOBACK\n       .\n", "target": "for (Integer i = 0; i < 5; i++) {\n    String line = '';\n\n    for (Integer j = 0; j < i; j++) {\n        line += '*';\n    }\n\n    System.debug(line);\n}\n\nList<String> lines = new List<String> {\n    '*',\n    '**',\n    '***',\n    '****',\n    '*****'\n};\n\nfor (String line : lines) {\n    System.debug(line);\n}\n"}
{"id": 149544, "name": "Loops_For", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Display-Triangle.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Outer-Counter PIC 9.\n       01  Inner-Counter PIC 9. \n\n       PROCEDURE DIVISION.\n       PERFORM VARYING Outer-Counter FROM 1 BY 1 UNTIL 5 < Outer-Counter\n\n           PERFORM VARYING Inner-Counter FROM 1 BY 1\n                   UNTIL Outer-Counter < Inner-Counter\n               DISPLAY \"*\" NO ADVANCING\n           END-PERFORM\n\n           DISPLAY \"\" \n       END-PERFORM\n\n       GOBACK\n       .\n", "target": "for i in 1..5:\n  for j in 1..i:\n    stdout.write(\"*\")\n  echo(\"\")\n"}
{"id": 149787, "name": "Loops_Downward for", "source": "Translate COBOL to C#: identification division.\nprogram-id. countdown.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter \t\tpic 99.\n\t88\tcounter-done\tvalue 0.\n01\tcounter-disp\tpic Z9.\nprocedure division.\n\tperform with test after varying counter from 10 by -1 until counter-done\n\t\tmove counter to counter-disp\n\t\tdisplay counter-disp\n\tend-perform\n\tstop run.\n", "target": "for (int i = 10; i >= 0; i--)\n{\n   Console.WriteLine(i);\n}\n"}
{"id": 149789, "name": "Loops_Downward for", "source": "Translate COBOL to Java: identification division.\nprogram-id. countdown.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter \t\tpic 99.\n\t88\tcounter-done\tvalue 0.\n01\tcounter-disp\tpic Z9.\nprocedure division.\n\tperform with test after varying counter from 10 by -1 until counter-done\n\t\tmove counter to counter-disp\n\t\tdisplay counter-disp\n\tend-perform\n\tstop run.\n", "target": "for (int i = 10; i >= 0; i--) {\n    System.out.println(i);\n}\n"}
{"id": 149790, "name": "Loops_Downward for", "source": "Translate COBOL to Python: identification division.\nprogram-id. countdown.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter \t\tpic 99.\n\t88\tcounter-done\tvalue 0.\n01\tcounter-disp\tpic Z9.\nprocedure division.\n\tperform with test after varying counter from 10 by -1 until counter-done\n\t\tmove counter to counter-disp\n\t\tdisplay counter-disp\n\tend-perform\n\tstop run.\n", "target": "for i in xrange(10, -1, -1):\n    print i\n"}
{"id": 150771, "name": "Fork", "source": "Translate COBOL to C#:        identification division.\n       program-id. forking.\n\n       data division.\n       working-storage section.\n       01 pid usage binary-long.\n\n       procedure division.\n       display \"attempting fork\"\n\n       call \"fork\" returning pid\n           on exception\n               display \"error: no fork linkage\" upon syserr\n       end-call\n\n       evaluate pid\n          when = 0\n              display \"    child sleeps\"\n              call \"C$SLEEP\" using 3\n              display \"    child task complete\"\n          when < 0\n              display \"error: fork result not ok\" upon syserr\n          when > 0\n              display \"parent waits for child...\"\n              call \"wait\" using by value 0\n              display \"parental responsibilities fulfilled\"\n       end-evaluate\n\n       goback.\n       end program forking.\n", "target": "using System;\nusing System.Threading;\n\nnamespace Fork {\n    class Program {\n        static void Fork() {\n            Console.WriteLine(\"Spawned Thread\");\n        }\n\n        static void Main(string[] args) {\n            Thread t = new Thread(new ThreadStart(Fork));\n            t.Start();\n\n            Console.WriteLine(\"Main Thread\");\n            t.Join();\n\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 150773, "name": "Fork", "source": "Translate COBOL to Java:        identification division.\n       program-id. forking.\n\n       data division.\n       working-storage section.\n       01 pid usage binary-long.\n\n       procedure division.\n       display \"attempting fork\"\n\n       call \"fork\" returning pid\n           on exception\n               display \"error: no fork linkage\" upon syserr\n       end-call\n\n       evaluate pid\n          when = 0\n              display \"    child sleeps\"\n              call \"C$SLEEP\" using 3\n              display \"    child task complete\"\n          when < 0\n              display \"error: fork result not ok\" upon syserr\n          when > 0\n              display \"parent waits for child...\"\n              call \"wait\" using by value 0\n              display \"parental responsibilities fulfilled\"\n       end-evaluate\n\n       goback.\n       end program forking.\n", "target": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RFork {\n\n  public static void main(String[] args) {\n    ProcessBuilder pb;\n    Process pp;\n    List<String> command;\n    Map<String, String> env;\n    BufferedReader ir;\n    String currentuser;\n    String line;\n    try {\n      command = Arrays.asList(\"\");\n      pb = new ProcessBuilder(command);\n      env = pb.environment();\n      currentuser = env.get(\"USER\");\n      command = Arrays.asList(\"ps\", \"-f\", \"-U\", currentuser);\n      pb.command(command);\n      pp = pb.start();\n      ir = new BufferedReader(new InputStreamReader(pp.getInputStream()));\n      line = \"Output of running \" + command.toString() + \" is:\";\n      do {\n        System.out.println(line);\n      } while ((line = ir.readLine()) != null);\n    }\n    catch (IOException iox) {\n      iox.printStackTrace();\n    }\n\n    return;\n  }\n}\n"}
{"id": 150774, "name": "Fork", "source": "Translate COBOL to Python:        identification division.\n       program-id. forking.\n\n       data division.\n       working-storage section.\n       01 pid usage binary-long.\n\n       procedure division.\n       display \"attempting fork\"\n\n       call \"fork\" returning pid\n           on exception\n               display \"error: no fork linkage\" upon syserr\n       end-call\n\n       evaluate pid\n          when = 0\n              display \"    child sleeps\"\n              call \"C$SLEEP\" using 3\n              display \"    child task complete\"\n          when < 0\n              display \"error: fork result not ok\" upon syserr\n          when > 0\n              display \"parent waits for child...\"\n              call \"wait\" using by value 0\n              display \"parental responsibilities fulfilled\"\n       end-evaluate\n\n       goback.\n       end program forking.\n", "target": "import os\n\npid = os.fork()\nif pid > 0:\n \nelse:\n \n"}
{"id": 153217, "name": "Least common multiple", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. show-lcm.\n\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION lcm\n           .\n       PROCEDURE DIVISION.\n           DISPLAY \"lcm(35, 21) = \" FUNCTION lcm(35, 21)\n           GOBACK\n           .\n       END PROGRAM show-lcm.\n\n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. lcm.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION gcd\n           .\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  m                       PIC S9(8).\n       01  n                       PIC S9(8).\n       01  ret                     PIC S9(8).\n\n       PROCEDURE DIVISION USING VALUE m, n RETURNING ret.\n           COMPUTE ret = FUNCTION ABS(m * n) / FUNCTION gcd(m, n)\n           GOBACK\n           .\n       END FUNCTION lcm.\n           \n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. gcd.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                    PIC S9(8).\n\n       01  x                       PIC S9(8).\n       01  y                       PIC S9(8).\n\n       LINKAGE SECTION.\n       01  m                       PIC S9(8).\n       01  n                       PIC S9(8).\n       01  ret                     PIC S9(8).\n\n       PROCEDURE DIVISION USING VALUE m, n RETURNING ret.\n           MOVE m to x\n           MOVE n to y\n\n           PERFORM UNTIL y = 0\n               MOVE x TO temp\n               MOVE y TO x\n               MOVE FUNCTION MOD(temp, y) TO Y\n           END-PERFORM\n\n           MOVE FUNCTION ABS(x) TO ret\n           GOBACK\n           .\n       END FUNCTION gcd.\n", "target": "Using System;\nclass Program\n{\n    static int gcd(int m, int n)\n    {\n        return n == 0 ? Math.Abs(m) : gcd(n, n % m);\n    }\n    static int lcm(int m, int n)\n    {\n        return Math.Abs(m * n) / gcd(m, n);\n    }\n    static void Main()\n    {\n        Console.WriteLine(\"lcm(12,18)=\" + lcm(12,18));\n    }\n}\n"}
{"id": 153218, "name": "Least common multiple", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. show-lcm.\n\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION lcm\n           .\n       PROCEDURE DIVISION.\n           DISPLAY \"lcm(35, 21) = \" FUNCTION lcm(35, 21)\n           GOBACK\n           .\n       END PROGRAM show-lcm.\n\n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. lcm.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION gcd\n           .\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  m                       PIC S9(8).\n       01  n                       PIC S9(8).\n       01  ret                     PIC S9(8).\n\n       PROCEDURE DIVISION USING VALUE m, n RETURNING ret.\n           COMPUTE ret = FUNCTION ABS(m * n) / FUNCTION gcd(m, n)\n           GOBACK\n           .\n       END FUNCTION lcm.\n           \n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. gcd.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                    PIC S9(8).\n\n       01  x                       PIC S9(8).\n       01  y                       PIC S9(8).\n\n       LINKAGE SECTION.\n       01  m                       PIC S9(8).\n       01  n                       PIC S9(8).\n       01  ret                     PIC S9(8).\n\n       PROCEDURE DIVISION USING VALUE m, n RETURNING ret.\n           MOVE m to x\n           MOVE n to y\n\n           PERFORM UNTIL y = 0\n               MOVE x TO temp\n               MOVE y TO x\n               MOVE FUNCTION MOD(temp, y) TO Y\n           END-PERFORM\n\n           MOVE FUNCTION ABS(x) TO ret\n           GOBACK\n           .\n       END FUNCTION gcd.\n", "target": "Using System;\nclass Program\n{\n    static int gcd(int m, int n)\n    {\n        return n == 0 ? Math.Abs(m) : gcd(n, n % m);\n    }\n    static int lcm(int m, int n)\n    {\n        return Math.Abs(m * n) / gcd(m, n);\n    }\n    static void Main()\n    {\n        Console.WriteLine(\"lcm(12,18)=\" + lcm(12,18));\n    }\n}\n"}
{"id": 153221, "name": "Least common multiple", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. show-lcm.\n\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION lcm\n           .\n       PROCEDURE DIVISION.\n           DISPLAY \"lcm(35, 21) = \" FUNCTION lcm(35, 21)\n           GOBACK\n           .\n       END PROGRAM show-lcm.\n\n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. lcm.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION gcd\n           .\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  m                       PIC S9(8).\n       01  n                       PIC S9(8).\n       01  ret                     PIC S9(8).\n\n       PROCEDURE DIVISION USING VALUE m, n RETURNING ret.\n           COMPUTE ret = FUNCTION ABS(m * n) / FUNCTION gcd(m, n)\n           GOBACK\n           .\n       END FUNCTION lcm.\n           \n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. gcd.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                    PIC S9(8).\n\n       01  x                       PIC S9(8).\n       01  y                       PIC S9(8).\n\n       LINKAGE SECTION.\n       01  m                       PIC S9(8).\n       01  n                       PIC S9(8).\n       01  ret                     PIC S9(8).\n\n       PROCEDURE DIVISION USING VALUE m, n RETURNING ret.\n           MOVE m to x\n           MOVE n to y\n\n           PERFORM UNTIL y = 0\n               MOVE x TO temp\n               MOVE y TO x\n               MOVE FUNCTION MOD(temp, y) TO Y\n           END-PERFORM\n\n           MOVE FUNCTION ABS(x) TO ret\n           GOBACK\n           .\n       END FUNCTION gcd.\n", "target": "import java.util.Scanner;\n\npublic class LCM{\n   public static void main(String[] args){\n      Scanner aScanner = new Scanner(System.in);\n   \n      \n      System.out.print(\"Enter the value of m:\");\n      int m = aScanner.nextInt();\n      System.out.print(\"Enter the value of n:\");\n      int n = aScanner.nextInt();\n      int lcm = (n == m || n == 1) ? m :(m == 1 ? n : 0);\n      \n      if (lcm == 0) {\n         int mm = m, nn = n;\n         while (mm != nn) {\n             while (mm < nn) { mm += m; }\n             while (nn < mm) { nn += n; }\n         }  \n         lcm = mm;\n      }\n      System.out.println(\"lcm(\" + m + \", \" + n + \") = \" + lcm);\n   }\n}\n"}
{"id": 153222, "name": "Least common multiple", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. show-lcm.\n\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION lcm\n           .\n       PROCEDURE DIVISION.\n           DISPLAY \"lcm(35, 21) = \" FUNCTION lcm(35, 21)\n           GOBACK\n           .\n       END PROGRAM show-lcm.\n\n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. lcm.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION gcd\n           .\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  m                       PIC S9(8).\n       01  n                       PIC S9(8).\n       01  ret                     PIC S9(8).\n\n       PROCEDURE DIVISION USING VALUE m, n RETURNING ret.\n           COMPUTE ret = FUNCTION ABS(m * n) / FUNCTION gcd(m, n)\n           GOBACK\n           .\n       END FUNCTION lcm.\n           \n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. gcd.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                    PIC S9(8).\n\n       01  x                       PIC S9(8).\n       01  y                       PIC S9(8).\n\n       LINKAGE SECTION.\n       01  m                       PIC S9(8).\n       01  n                       PIC S9(8).\n       01  ret                     PIC S9(8).\n\n       PROCEDURE DIVISION USING VALUE m, n RETURNING ret.\n           MOVE m to x\n           MOVE n to y\n\n           PERFORM UNTIL y = 0\n               MOVE x TO temp\n               MOVE y TO x\n               MOVE FUNCTION MOD(temp, y) TO Y\n           END-PERFORM\n\n           MOVE FUNCTION ABS(x) TO ret\n           GOBACK\n           .\n       END FUNCTION gcd.\n", "target": "import java.util.Scanner;\n\npublic class LCM{\n   public static void main(String[] args){\n      Scanner aScanner = new Scanner(System.in);\n   \n      \n      System.out.print(\"Enter the value of m:\");\n      int m = aScanner.nextInt();\n      System.out.print(\"Enter the value of n:\");\n      int n = aScanner.nextInt();\n      int lcm = (n == m || n == 1) ? m :(m == 1 ? n : 0);\n      \n      if (lcm == 0) {\n         int mm = m, nn = n;\n         while (mm != nn) {\n             while (mm < nn) { mm += m; }\n             while (nn < mm) { nn += n; }\n         }  \n         lcm = mm;\n      }\n      System.out.println(\"lcm(\" + m + \", \" + n + \") = \" + lcm);\n   }\n}\n"}
{"id": 153223, "name": "Least common multiple", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. show-lcm.\n\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION lcm\n           .\n       PROCEDURE DIVISION.\n           DISPLAY \"lcm(35, 21) = \" FUNCTION lcm(35, 21)\n           GOBACK\n           .\n       END PROGRAM show-lcm.\n\n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. lcm.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION gcd\n           .\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  m                       PIC S9(8).\n       01  n                       PIC S9(8).\n       01  ret                     PIC S9(8).\n\n       PROCEDURE DIVISION USING VALUE m, n RETURNING ret.\n           COMPUTE ret = FUNCTION ABS(m * n) / FUNCTION gcd(m, n)\n           GOBACK\n           .\n       END FUNCTION lcm.\n           \n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. gcd.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                    PIC S9(8).\n\n       01  x                       PIC S9(8).\n       01  y                       PIC S9(8).\n\n       LINKAGE SECTION.\n       01  m                       PIC S9(8).\n       01  n                       PIC S9(8).\n       01  ret                     PIC S9(8).\n\n       PROCEDURE DIVISION USING VALUE m, n RETURNING ret.\n           MOVE m to x\n           MOVE n to y\n\n           PERFORM UNTIL y = 0\n               MOVE x TO temp\n               MOVE y TO x\n               MOVE FUNCTION MOD(temp, y) TO Y\n           END-PERFORM\n\n           MOVE FUNCTION ABS(x) TO ret\n           GOBACK\n           .\n       END FUNCTION gcd.\n", "target": ">>> import fractions\n>>> def lcm(a,b): return abs(a * b) / fractions.gcd(a,b) if a and b else 0\n\n>>> lcm(12, 18)\n36\n>>> lcm(-6, 14)\n42\n>>> assert lcm(0, 2) == lcm(2, 0) == 0\n>>>\n"}
{"id": 153224, "name": "Least common multiple", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. show-lcm.\n\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION lcm\n           .\n       PROCEDURE DIVISION.\n           DISPLAY \"lcm(35, 21) = \" FUNCTION lcm(35, 21)\n           GOBACK\n           .\n       END PROGRAM show-lcm.\n\n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. lcm.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION gcd\n           .\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  m                       PIC S9(8).\n       01  n                       PIC S9(8).\n       01  ret                     PIC S9(8).\n\n       PROCEDURE DIVISION USING VALUE m, n RETURNING ret.\n           COMPUTE ret = FUNCTION ABS(m * n) / FUNCTION gcd(m, n)\n           GOBACK\n           .\n       END FUNCTION lcm.\n           \n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. gcd.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                    PIC S9(8).\n\n       01  x                       PIC S9(8).\n       01  y                       PIC S9(8).\n\n       LINKAGE SECTION.\n       01  m                       PIC S9(8).\n       01  n                       PIC S9(8).\n       01  ret                     PIC S9(8).\n\n       PROCEDURE DIVISION USING VALUE m, n RETURNING ret.\n           MOVE m to x\n           MOVE n to y\n\n           PERFORM UNTIL y = 0\n               MOVE x TO temp\n               MOVE y TO x\n               MOVE FUNCTION MOD(temp, y) TO Y\n           END-PERFORM\n\n           MOVE FUNCTION ABS(x) TO ret\n           GOBACK\n           .\n       END FUNCTION gcd.\n", "target": ">>> import fractions\n>>> def lcm(a,b): return abs(a * b) / fractions.gcd(a,b) if a and b else 0\n\n>>> lcm(12, 18)\n36\n>>> lcm(-6, 14)\n42\n>>> assert lcm(0, 2) == lcm(2, 0) == 0\n>>>\n"}
{"id": 153929, "name": "Literals_Integer", "source": "Translate COBOL to C#: display B#10 \", \" O#01234567 \", \" -0123456789 \", \"\n        H#0123456789ABCDEF \", \" X#0123456789ABCDEF \", \" 1;2;3;4\n", "target": "int a = 42;\nint b = 0x2a;\n"}
{"id": 153931, "name": "Literals_Integer", "source": "Translate COBOL to Java: display B#10 \", \" O#01234567 \", \" -0123456789 \", \"\n        H#0123456789ABCDEF \", \" X#0123456789ABCDEF \", \" 1;2;3;4\n", "target": "public class IntegerLiterals {\n    public static void main(String[] args) {\n        System.out.println( 727 == 0x2d7 && \n                            727 == 01327   );\n    }\n}\n"}
{"id": 153932, "name": "Literals_Integer", "source": "Translate COBOL to Python: display B#10 \", \" O#01234567 \", \" -0123456789 \", \"\n        H#0123456789ABCDEF \", \" X#0123456789ABCDEF \", \" 1;2;3;4\n", "target": ">>> \n>>> 0b1011010111 == 0o1327 == 727 == 0x2d7\nTrue\n>>>\n"}
{"id": 154396, "name": "String concatenation", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Concat.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Str  PIC X(7) VALUE \"Hello, \".\n       01  Str2 PIC X(15).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Str \u00a0: \" Str\n           STRING Str \" World!\" DELIMITED BY SIZE INTO Str2\n           DISPLAY \"Str2\u00a0: \" Str2\n\n           GOBACK\n           .\n", "target": "using System;\nnamespace StringConcatenation\n{\n  class Program {\n    static void Main() {\n        String s = scope (\"hello\");\n        Console.Write(s);\n        Console.WriteLine(\" literal\");\n        s.Append(\" literal\");\n        Console.WriteLine(s);\n    }\n  }\n}\n"}
{"id": 154398, "name": "String concatenation", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Concat.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Str  PIC X(7) VALUE \"Hello, \".\n       01  Str2 PIC X(15).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Str \u00a0: \" Str\n           STRING Str \" World!\" DELIMITED BY SIZE INTO Str2\n           DISPLAY \"Str2\u00a0: \" Str2\n\n           GOBACK\n           .\n", "target": "public class Str{\n   public static void main(String[] args){\n      String s = \"hello\";\n      System.out.println(s + \" literal\");\n      String s2 = s + \" literal\";\n      System.out.println(s2);\n   }\n}\n"}
{"id": 154399, "name": "String concatenation", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Concat.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Str  PIC X(7) VALUE \"Hello, \".\n       01  Str2 PIC X(15).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Str \u00a0: \" Str\n           STRING Str \" World!\" DELIMITED BY SIZE INTO Str2\n           DISPLAY \"Str2\u00a0: \" Str2\n\n           GOBACK\n           .\n", "target": "s1 = \"hello\"\nprint s1 + \" world\"\n\ns2 = s1 + \" world\"\nprint s2\n"}
{"id": 154908, "name": "Thue-Morse", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. THUE-MORSE.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 STRINGS.\n          03 CURRENT-STATE      PIC X(64).\n          03 TEMP               PIC X(64).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE \"0\" TO CURRENT-STATE.\n           PERFORM THUE-MORSE-STEP 8 TIMES.\n           DISPLAY CURRENT-STATE.\n           STOP RUN.\n\n       THUE-MORSE-STEP.\n           MOVE CURRENT-STATE TO TEMP.\n           INSPECT TEMP REPLACING ALL '0' BY 'X'.\n           INSPECT TEMP REPLACING ALL '1' BY '0'.\n           INSPECT TEMP REPLACING ALL 'X' BY '1'.\n           STRING CURRENT-STATE DELIMITED BY SPACE,\n                  TEMP DELIMITED BY SPACE\n                  INTO CURRENT-STATE.\n", "target": "using System;\nusing System.Text;\n\nnamespace ThueMorse\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Sequence(6);\n        }\n\n        public static void Sequence(int steps)\n        {\n            var sb1 = new StringBuilder(\"0\");\n            var sb2 = new StringBuilder(\"1\");\n            for (int i = 0; i < steps; i++)\n            {\n                var tmp = sb1.ToString();\n                sb1.Append(sb2);\n                sb2.Append(tmp);\n            }\n            Console.WriteLine(sb1);\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 154909, "name": "Thue-Morse", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. THUE-MORSE.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 STRINGS.\n          03 CURRENT-STATE      PIC X(64).\n          03 TEMP               PIC X(64).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE \"0\" TO CURRENT-STATE.\n           PERFORM THUE-MORSE-STEP 8 TIMES.\n           DISPLAY CURRENT-STATE.\n           STOP RUN.\n\n       THUE-MORSE-STEP.\n           MOVE CURRENT-STATE TO TEMP.\n           INSPECT TEMP REPLACING ALL '0' BY 'X'.\n           INSPECT TEMP REPLACING ALL '1' BY '0'.\n           INSPECT TEMP REPLACING ALL 'X' BY '1'.\n           STRING CURRENT-STATE DELIMITED BY SPACE,\n                  TEMP DELIMITED BY SPACE\n                  INTO CURRENT-STATE.\n", "target": "using System;\nusing System.Text;\n\nnamespace ThueMorse\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Sequence(6);\n        }\n\n        public static void Sequence(int steps)\n        {\n            var sb1 = new StringBuilder(\"0\");\n            var sb2 = new StringBuilder(\"1\");\n            for (int i = 0; i < steps; i++)\n            {\n                var tmp = sb1.ToString();\n                sb1.Append(sb2);\n                sb2.Append(tmp);\n            }\n            Console.WriteLine(sb1);\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 154912, "name": "Thue-Morse", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. THUE-MORSE.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 STRINGS.\n          03 CURRENT-STATE      PIC X(64).\n          03 TEMP               PIC X(64).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE \"0\" TO CURRENT-STATE.\n           PERFORM THUE-MORSE-STEP 8 TIMES.\n           DISPLAY CURRENT-STATE.\n           STOP RUN.\n\n       THUE-MORSE-STEP.\n           MOVE CURRENT-STATE TO TEMP.\n           INSPECT TEMP REPLACING ALL '0' BY 'X'.\n           INSPECT TEMP REPLACING ALL '1' BY '0'.\n           INSPECT TEMP REPLACING ALL 'X' BY '1'.\n           STRING CURRENT-STATE DELIMITED BY SPACE,\n                  TEMP DELIMITED BY SPACE\n                  INTO CURRENT-STATE.\n", "target": "public class ThueMorse {\n\n    public static void main(String[] args) {\n        sequence(6);\n    }\n\n    public static void sequence(int steps) {\n        StringBuilder sb1 = new StringBuilder(\"0\");\n        StringBuilder sb2 = new StringBuilder(\"1\");\n        for (int i = 0; i < steps; i++) {\n            String tmp = sb1.toString();\n            sb1.append(sb2);\n            sb2.append(tmp);\n        }\n        System.out.println(sb1);\n    }\n}\n"}
{"id": 154913, "name": "Thue-Morse", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. THUE-MORSE.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 STRINGS.\n          03 CURRENT-STATE      PIC X(64).\n          03 TEMP               PIC X(64).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE \"0\" TO CURRENT-STATE.\n           PERFORM THUE-MORSE-STEP 8 TIMES.\n           DISPLAY CURRENT-STATE.\n           STOP RUN.\n\n       THUE-MORSE-STEP.\n           MOVE CURRENT-STATE TO TEMP.\n           INSPECT TEMP REPLACING ALL '0' BY 'X'.\n           INSPECT TEMP REPLACING ALL '1' BY '0'.\n           INSPECT TEMP REPLACING ALL 'X' BY '1'.\n           STRING CURRENT-STATE DELIMITED BY SPACE,\n                  TEMP DELIMITED BY SPACE\n                  INTO CURRENT-STATE.\n", "target": "public class ThueMorse {\n\n    public static void main(String[] args) {\n        sequence(6);\n    }\n\n    public static void sequence(int steps) {\n        StringBuilder sb1 = new StringBuilder(\"0\");\n        StringBuilder sb2 = new StringBuilder(\"1\");\n        for (int i = 0; i < steps; i++) {\n            String tmp = sb1.toString();\n            sb1.append(sb2);\n            sb2.append(tmp);\n        }\n        System.out.println(sb1);\n    }\n}\n"}
{"id": 154914, "name": "Thue-Morse", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. THUE-MORSE.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 STRINGS.\n          03 CURRENT-STATE      PIC X(64).\n          03 TEMP               PIC X(64).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE \"0\" TO CURRENT-STATE.\n           PERFORM THUE-MORSE-STEP 8 TIMES.\n           DISPLAY CURRENT-STATE.\n           STOP RUN.\n\n       THUE-MORSE-STEP.\n           MOVE CURRENT-STATE TO TEMP.\n           INSPECT TEMP REPLACING ALL '0' BY 'X'.\n           INSPECT TEMP REPLACING ALL '1' BY '0'.\n           INSPECT TEMP REPLACING ALL 'X' BY '1'.\n           STRING CURRENT-STATE DELIMITED BY SPACE,\n                  TEMP DELIMITED BY SPACE\n                  INTO CURRENT-STATE.\n", "target": "m='0'\nprint(m)\nfor i in range(0,6):\n     m0=m\n     m=m.replace('0','a')\n     m=m.replace('1','0')\n     m=m.replace('a','1')\n     m=m0+m\n     print(m)\n"}
{"id": 154915, "name": "Thue-Morse", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. THUE-MORSE.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 STRINGS.\n          03 CURRENT-STATE      PIC X(64).\n          03 TEMP               PIC X(64).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE \"0\" TO CURRENT-STATE.\n           PERFORM THUE-MORSE-STEP 8 TIMES.\n           DISPLAY CURRENT-STATE.\n           STOP RUN.\n\n       THUE-MORSE-STEP.\n           MOVE CURRENT-STATE TO TEMP.\n           INSPECT TEMP REPLACING ALL '0' BY 'X'.\n           INSPECT TEMP REPLACING ALL '1' BY '0'.\n           INSPECT TEMP REPLACING ALL 'X' BY '1'.\n           STRING CURRENT-STATE DELIMITED BY SPACE,\n                  TEMP DELIMITED BY SPACE\n                  INTO CURRENT-STATE.\n", "target": "m='0'\nprint(m)\nfor i in range(0,6):\n     m0=m\n     m=m.replace('0','a')\n     m=m.replace('1','0')\n     m=m.replace('a','1')\n     m=m0+m\n     print(m)\n"}
{"id": 155285, "name": "Repeat a string", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. REPEAT-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n77  HAHA         PIC A(10).\nPROCEDURE DIVISION.\n    MOVE ALL 'ha' TO HAHA.\n    DISPLAY HAHA.\n    STOP RUN.\n", "target": "String s = new String('X', 5);\ns.Replace(\"X\", \"ha\");\n"}
{"id": 155287, "name": "Repeat a string", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. REPEAT-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n77  HAHA         PIC A(10).\nPROCEDURE DIVISION.\n    MOVE ALL 'ha' TO HAHA.\n    DISPLAY HAHA.\n    STOP RUN.\n", "target": "String funny = \"ha\" * 5;\nString stars = '*' * 80;\n"}
{"id": 155288, "name": "Repeat a string", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. REPEAT-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n77  HAHA         PIC A(10).\nPROCEDURE DIVISION.\n    MOVE ALL 'ha' TO HAHA.\n    DISPLAY HAHA.\n    STOP RUN.\n", "target": "def setup():\n    rep = repeat(\"ha\", 5)\n    println(rep)\n\ndef repeat(s, times):\n    return s * times\n"}
{"id": 155520, "name": "Ethiopian multiplication", "source": "Translate COBOL to C#:        \n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ethiopian-multiplication.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  l                  PICTURE 9(10) VALUE 17.\n       01  r                  PICTURE 9(10) VALUE 34.\n       01  ethiopian-multiply PICTURE 9(20).\n       01  product            PICTURE 9(20).\n       PROCEDURE DIVISION.\n         CALL \"ethiopian-multiply\" USING\n           BY CONTENT l, BY CONTENT r,\n           BY REFERENCE ethiopian-multiply\n         END-CALL\n         DISPLAY ethiopian-multiply END-DISPLAY\n         MULTIPLY l BY r GIVING product END-MULTIPLY\n         DISPLAY product END-DISPLAY\n         STOP RUN.\n       END PROGRAM ethiopian-multiplication.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ethiopian-multiply.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  evenp   PICTURE 9.\n         88 even   VALUE 1.\n         88 odd    VALUE 0.\n       LINKAGE SECTION.\n       01  l       PICTURE 9(10).\n       01  r       PICTURE 9(10).\n       01  product PICTURE 9(20) VALUE ZERO.\n       PROCEDURE DIVISION using l, r, product.\n         MOVE ZEROES TO product\n         PERFORM UNTIL l EQUAL ZERO\n           CALL \"evenp\" USING\n             BY CONTENT l,\n             BY REFERENCE evenp\n           END-CALL\n           IF odd\n             ADD r TO product GIVING product END-ADD\n           END-IF\n           CALL \"halve\" USING\n             BY CONTENT l,\n             BY REFERENCE l\n           END-CALL\n           CALL \"twice\" USING\n             BY CONTENT r,\n             BY REFERENCE r\n           END-CALL\n         END-PERFORM\n         GOBACK.\n       END PROGRAM ethiopian-multiply.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. halve.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       LINKAGE SECTION.\n       01  n   PICTURE 9(10).\n       01  m   PICTURE 9(10).\n       PROCEDURE DIVISION USING n, m.\n         DIVIDE n BY 2 GIVING m END-DIVIDE\n         GOBACK.\n       END PROGRAM halve.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. twice.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       LINKAGE SECTION.\n       01  n   PICTURE 9(10).\n       01  m   PICTURE 9(10).\n       PROCEDURE DIVISION USING n, m.\n         MULTIPLY n by 2 GIVING m END-MULTIPLY\n         GOBACK.\n       END PROGRAM twice.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. evenp.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  q   PICTURE 9(10).\n       LINKAGE SECTION.\n       01  n   PICTURE 9(10).\n       01  m   PICTURE 9(1).\n         88 even   VALUE 1.\n         88 odd    VALUE 0.\n       PROCEDURE DIVISION USING n, m.\n         DIVIDE n BY 2 GIVING q REMAINDER m END-DIVIDE\n         SUBTRACT m FROM 1 GIVING m END-SUBTRACT\n         GOBACK.\n       END PROGRAM evenp.\n", "target": "using System;\nusing System.Linq;\n\nnamespace RosettaCode.Tasks\n{\n\tpublic static class EthiopianMultiplication_Task\n\t{\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Ethiopian Multiplication\" );\n\t\t\tint A = 17, B = 34;\n\t\t\tConsole.WriteLine ( \"Recursion: {0}*{1}={2}\", A, B, EM_Recursion ( A, B ) );\n\t\t\tConsole.WriteLine ( \"Linq: {0}*{1}={2}\", A, B, EM_Linq ( A, B ) );\n\t\t\tConsole.WriteLine ( \"Loop: {0}*{1}={2}\", A, B, EM_Loop ( A, B ) );\n\t\t\tConsole.WriteLine ( );\n\t\t}\n\n\t\tpublic static int Halve ( this int p_Number )\n\t\t{\n\t\t\treturn p_Number >> 1;\n\t\t}\n\t\tpublic static int Double ( this int p_Number )\n\t\t{\n\t\t\treturn p_Number << 1;\n\t\t}\n\t\tpublic static bool IsEven ( this int p_Number )\n\t\t{\n\t\t\treturn ( p_Number % 2 ) == 0;\n\t\t}\n\n\t\tpublic static int EM_Recursion ( int p_NumberA, int p_NumberB )\n\t\t{\n\t\t\t\n\t\t\treturn p_NumberA == 1 ? p_NumberB : EM_Recursion ( p_NumberA.Halve ( ), p_NumberB.Double ( ) ) + ( p_NumberA.IsEven ( ) ? 0 : p_NumberB );\n\t\t}\n\t\tpublic static int EM_Linq ( int p_NumberA, int p_NumberB )\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\treturn Enumerable.Range ( 1, Convert.ToInt32 ( Math.Log ( p_NumberA, Math.E ) / Math.Log ( 2, Math.E ) ) + 1 )\n\t\t\t\t\n\t\t\t\t.Select ( ( item ) => Enumerable.Repeat ( new { Col1 = p_NumberA, Col2 = p_NumberB }, item )\n\t\t\t\t\t\n\t\t\t\t\t.Aggregate ( ( agg_pair, orig_pair ) => new { Col1 = agg_pair.Col1.Halve ( ), Col2 = agg_pair.Col2.Double ( ) } ) )\n\t\t\t\t\n\t\t\t\t.Where ( pair => !pair.Col1.IsEven ( ) )\n\t\t\t\t\n\t\t\t\t.Sum ( pair => pair.Col2 );\n\t\t}\n\t\tpublic static int EM_Loop ( int p_NumberA, int p_NumberB )\n\t\t{\n\t\t\tint RetVal = 0;\n\t\t\twhile ( p_NumberA >= 1 )\n\t\t\t{\n\t\t\t\tRetVal += p_NumberA.IsEven ( ) ? 0 : p_NumberB;\n\t\t\t\tp_NumberA = p_NumberA.Halve ( );\n\t\t\t\tp_NumberB = p_NumberB.Double ( );\n\t\t\t}\n\t\t\treturn RetVal;\n\t\t}\n\t}\n}\n"}
{"id": 155522, "name": "Ethiopian multiplication", "source": "Translate COBOL to Java:        \n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ethiopian-multiplication.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  l                  PICTURE 9(10) VALUE 17.\n       01  r                  PICTURE 9(10) VALUE 34.\n       01  ethiopian-multiply PICTURE 9(20).\n       01  product            PICTURE 9(20).\n       PROCEDURE DIVISION.\n         CALL \"ethiopian-multiply\" USING\n           BY CONTENT l, BY CONTENT r,\n           BY REFERENCE ethiopian-multiply\n         END-CALL\n         DISPLAY ethiopian-multiply END-DISPLAY\n         MULTIPLY l BY r GIVING product END-MULTIPLY\n         DISPLAY product END-DISPLAY\n         STOP RUN.\n       END PROGRAM ethiopian-multiplication.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ethiopian-multiply.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  evenp   PICTURE 9.\n         88 even   VALUE 1.\n         88 odd    VALUE 0.\n       LINKAGE SECTION.\n       01  l       PICTURE 9(10).\n       01  r       PICTURE 9(10).\n       01  product PICTURE 9(20) VALUE ZERO.\n       PROCEDURE DIVISION using l, r, product.\n         MOVE ZEROES TO product\n         PERFORM UNTIL l EQUAL ZERO\n           CALL \"evenp\" USING\n             BY CONTENT l,\n             BY REFERENCE evenp\n           END-CALL\n           IF odd\n             ADD r TO product GIVING product END-ADD\n           END-IF\n           CALL \"halve\" USING\n             BY CONTENT l,\n             BY REFERENCE l\n           END-CALL\n           CALL \"twice\" USING\n             BY CONTENT r,\n             BY REFERENCE r\n           END-CALL\n         END-PERFORM\n         GOBACK.\n       END PROGRAM ethiopian-multiply.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. halve.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       LINKAGE SECTION.\n       01  n   PICTURE 9(10).\n       01  m   PICTURE 9(10).\n       PROCEDURE DIVISION USING n, m.\n         DIVIDE n BY 2 GIVING m END-DIVIDE\n         GOBACK.\n       END PROGRAM halve.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. twice.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       LINKAGE SECTION.\n       01  n   PICTURE 9(10).\n       01  m   PICTURE 9(10).\n       PROCEDURE DIVISION USING n, m.\n         MULTIPLY n by 2 GIVING m END-MULTIPLY\n         GOBACK.\n       END PROGRAM twice.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. evenp.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  q   PICTURE 9(10).\n       LINKAGE SECTION.\n       01  n   PICTURE 9(10).\n       01  m   PICTURE 9(1).\n         88 even   VALUE 1.\n         88 odd    VALUE 0.\n       PROCEDURE DIVISION USING n, m.\n         DIVIDE n BY 2 GIVING q REMAINDER m END-DIVIDE\n         SUBTRACT m FROM 1 GIVING m END-SUBTRACT\n         GOBACK.\n       END PROGRAM evenp.\n", "target": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\npublic class Mult{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    int first = sc.nextInt();\n    int second = sc.nextInt();\n\n    if(first < 0){\n        first = -first;\n        second = -second;\n    }\n\n    Map<Integer, Integer> columns = new HashMap<Integer, Integer>();\n        columns.put(first, second);\n    int sum = isEven(first)? 0 : second;\n    do{\n      first = halveInt(first);\n      second = doubleInt(second);\n      columns.put(first, second);\n      if(!isEven(first)){\n          sum += second;\n      }\n    }while(first > 1);\n \n    System.out.println(sum);\n  }\n\n  public static int doubleInt(int doubleMe){\n    return doubleMe << 1; \n  }\n\n  public static int halveInt(int halveMe){\n    return halveMe >>> 1; \n  }\n\n  public static boolean isEven(int num){\n    return (num & 1) == 0;\n  }\n}\n"}
{"id": 155523, "name": "Ethiopian multiplication", "source": "Translate COBOL to Python:        \n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ethiopian-multiplication.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  l                  PICTURE 9(10) VALUE 17.\n       01  r                  PICTURE 9(10) VALUE 34.\n       01  ethiopian-multiply PICTURE 9(20).\n       01  product            PICTURE 9(20).\n       PROCEDURE DIVISION.\n         CALL \"ethiopian-multiply\" USING\n           BY CONTENT l, BY CONTENT r,\n           BY REFERENCE ethiopian-multiply\n         END-CALL\n         DISPLAY ethiopian-multiply END-DISPLAY\n         MULTIPLY l BY r GIVING product END-MULTIPLY\n         DISPLAY product END-DISPLAY\n         STOP RUN.\n       END PROGRAM ethiopian-multiplication.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ethiopian-multiply.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  evenp   PICTURE 9.\n         88 even   VALUE 1.\n         88 odd    VALUE 0.\n       LINKAGE SECTION.\n       01  l       PICTURE 9(10).\n       01  r       PICTURE 9(10).\n       01  product PICTURE 9(20) VALUE ZERO.\n       PROCEDURE DIVISION using l, r, product.\n         MOVE ZEROES TO product\n         PERFORM UNTIL l EQUAL ZERO\n           CALL \"evenp\" USING\n             BY CONTENT l,\n             BY REFERENCE evenp\n           END-CALL\n           IF odd\n             ADD r TO product GIVING product END-ADD\n           END-IF\n           CALL \"halve\" USING\n             BY CONTENT l,\n             BY REFERENCE l\n           END-CALL\n           CALL \"twice\" USING\n             BY CONTENT r,\n             BY REFERENCE r\n           END-CALL\n         END-PERFORM\n         GOBACK.\n       END PROGRAM ethiopian-multiply.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. halve.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       LINKAGE SECTION.\n       01  n   PICTURE 9(10).\n       01  m   PICTURE 9(10).\n       PROCEDURE DIVISION USING n, m.\n         DIVIDE n BY 2 GIVING m END-DIVIDE\n         GOBACK.\n       END PROGRAM halve.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. twice.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       LINKAGE SECTION.\n       01  n   PICTURE 9(10).\n       01  m   PICTURE 9(10).\n       PROCEDURE DIVISION USING n, m.\n         MULTIPLY n by 2 GIVING m END-MULTIPLY\n         GOBACK.\n       END PROGRAM twice.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. evenp.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  q   PICTURE 9(10).\n       LINKAGE SECTION.\n       01  n   PICTURE 9(10).\n       01  m   PICTURE 9(1).\n         88 even   VALUE 1.\n         88 odd    VALUE 0.\n       PROCEDURE DIVISION USING n, m.\n         DIVIDE n BY 2 GIVING q REMAINDER m END-DIVIDE\n         SUBTRACT m FROM 1 GIVING m END-SUBTRACT\n         GOBACK.\n       END PROGRAM evenp.\n", "target": "tutor = True\n\ndef halve(x):\n    return x // 2\n\ndef double(x):\n    return x * 2\n\ndef even(x):\n    return not x % 2\n\ndef ethiopian(multiplier, multiplicand):\n    if tutor:\n        print(\"Ethiopian multiplication of %i and %i\" %\n              (multiplier, multiplicand))\n    result = 0\n    while multiplier >= 1:\n        if even(multiplier):\n            if tutor:\n                print(\"%4i %6i STRUCK\" %\n                      (multiplier, multiplicand))\n        else:\n            if tutor:\n                print(\"%4i %6i KEPT\" %\n                      (multiplier, multiplicand))\n            result += multiplicand\n        multiplier   = halve(multiplier)\n        multiplicand = double(multiplicand)\n    if tutor:\n        print()\n    return result\n"}
{"id": 155755, "name": "Forest fire", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. forest-fire.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       \n       \n       \n       78  IGNITE-PROB                 VALUE 1.\n       78  NEW-TREE-PROB               VALUE 100.\n\n       78  EMPTY-PROB                  VALUE 3333.\n\n       78  AREA-SIZE                   VALUE 40.\n\n       01  sim-table.\n           03  sim-row OCCURS AREA-SIZE TIMES INDEXED BY row-index.\n               05  sim-area OCCURS AREA-SIZE TIMES\n                   INDEXED BY col-index.\n                   07  current-status  PIC 9.\n                       \n                       \n                       88  empty       VALUE 0. \n                       88  tree        VALUE 2. \n                       88  burning     VALUE 4. \n                       \n                   07  next-status     PIC 9.\n                       88  empty       VALUE 0.\n                       88  tree        VALUE 2.\n                       88  burning     VALUE 4.\n    \n       01  rand-num                    PIC 9999.\n        \n       01  next-row                    PIC 9(4).\n       01  next-col                    PIC 9(4).\n\n       01  neighbours-row              PIC 9(4).\n       01  neighbours-col              PIC 9(4).\n\n       PROCEDURE DIVISION.\n       main-line.\n           \n           MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (9:8)) TO rand-num\n\n           PERFORM initialise-table\n           PERFORM FOREVER\n               PERFORM show-simulation\n               PERFORM step-simulation\n           END-PERFORM\n\n           GOBACK\n           .\n\n       initialise-table.\n           PERFORM VARYING row-index FROM 1 BY 1\n                   UNTIL AREA-SIZE < row-index\n                   AFTER col-index FROM 1 BY 1\n                       UNTIL AREA-SIZE < col-index\n               PERFORM get-rand-num\n               IF rand-num <= EMPTY-PROB\n                   SET empty OF current-status (row-index, col-index)\n                       TO TRUE\n                   SET empty OF next-status (row-index, col-index)\n                       TO TRUE\n               ELSE\n                   SET tree OF current-status (row-index, col-index)\n                       TO TRUE\n                   SET tree OF next-status (row-index, col-index)\n                       TO TRUE\n               END-IF\n           END-PERFORM\n           .\n\n       show-simulation.\n           PERFORM VARYING row-index FROM 1 BY 1\n                   UNTIL AREA-SIZE < row-index\n                   AFTER col-index FROM 1 BY 1\n                       UNTIL AREA-SIZE < col-index\n                DISPLAY SPACE AT LINE row-index COLUMN col-index\n                    WITH BACKGROUND-COLOR\n                        current-status (row-index, col-index)\n           END-PERFORM\n           .\n\n       \n       step-simulation.\n            PERFORM VARYING row-index FROM 1 BY 1\n                   UNTIL AREA-SIZE < row-index\n                   AFTER col-index FROM 1 BY 1\n                       UNTIL AREA-SIZE < col-index\n                EVALUATE TRUE\n                    WHEN empty OF current-status (row-index, col-index)\n                        PERFORM get-rand-num\n                        IF rand-num <= NEW-TREE-PROB\n                            SET tree OF next-status\n                                 (row-index, col-index) TO TRUE\n                        END-IF\n\n                    WHEN tree OF current-status (row-index, col-index)\n                        PERFORM simulate-tree\n\n                    WHEN burning OF current-status\n                            (row-index, col-index)\n                        SET empty OF next-status (row-index, col-index)\n                            TO TRUE\n                END-EVALUATE\n            END-PERFORM\n\n            PERFORM update-statuses.\n            .\n\n       \n       \n       simulate-tree.\n           \n           COMPUTE next-row = FUNCTION MIN(row-index + 1, AREA-SIZE)\n           COMPUTE next-col = FUNCTION MIN(col-index + 1, AREA-SIZE)\n           \n           COMPUTE neighbours-row = FUNCTION MAX(row-index - 1, 1)\n           COMPUTE neighbours-col = FUNCTION MAX(col-index - 1, 1)\n\n           \n           PERFORM VARYING neighbours-row FROM neighbours-row BY 1\n                   UNTIL next-row < neighbours-row\n               \n               PERFORM VARYING neighbours-col FROM neighbours-col BY 1\n                       UNTIL next-col < neighbours-col\n                   IF neighbours-row = row-index\n                           AND neighbours-col = col-index\n                       EXIT PERFORM CYCLE\n                   END-IF\n                   \n                   IF burning OF current-status\n                           (neighbours-row, neighbours-col)\n                       SET burning OF next-status (row-index, col-index)\n                           TO TRUE\n                       EXIT PARAGRAPH\n                   END-IF\n               END-PERFORM\n\n               \n               COMPUTE neighbours-col =\n                   FUNCTION MAX(neighbours-col - 3, 1)\n           END-PERFORM\n\n           \n           \n           PERFORM get-rand-num\n           IF rand-num <= IGNITE-PROB\n               SET burning OF next-status (row-index, col-index) TO TRUE\n           END-IF\n           .\n\n       update-statuses.\n           PERFORM VARYING row-index FROM 1 BY 1\n                   UNTIL AREA-SIZE < row-index\n                   AFTER col-index FROM 1 BY 1\n                       UNTIL AREA-SIZE < col-index\n               MOVE next-status (row-index, col-index)\n                   TO current-status (row-index, col-index)\n           END-PERFORM\n           .\n\n       \n       get-rand-num.\n           COMPUTE rand-num =\n               FUNCTION MOD(FUNCTION RANDOM * 100000, 10000)\n           .\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Threading;\nusing System.Windows.Forms;\n\nnamespace ForestFire\n{\n    class Program : Form\n    {\n        private static readonly Random rand = new Random();\n        private Bitmap img;\n\n        public Program(int w, int h, int f, int p)\n        {\n            Size = new Size(w, h);\n            StartPosition = FormStartPosition.CenterScreen;\n\n            Thread t = new Thread(() => fire(f, p));\n            t.Start();\n\n            FormClosing += (object sender, FormClosingEventArgs e) => { t.Abort(); t = null; };\n        }\n\n        private void fire(int f, int p)\n        {\n            int clientWidth = ClientRectangle.Width;\n            int clientHeight = ClientRectangle.Height;\n            int cellSize = 10;\n\n            img = new Bitmap(clientWidth, clientHeight);\n            Graphics g = Graphics.FromImage(img);\n\n            CellState[,] state = InitializeForestFire(clientWidth, clientHeight);\n\n            uint generation = 0;\n\n            do\n            {\n                g.FillRectangle(Brushes.White, 0, 0, img.Width, img.Height);\n                state = StepForestFire(state, f, p);\n\n                for (int y = 0; y < clientHeight - cellSize; y += cellSize)\n                {\n                    for (int x = 0; x < clientWidth - cellSize; x += cellSize)\n                    {\n                        switch (state[y, x])\n                        {\n                            case CellState.Empty:\n                                break;\n                            case CellState.Tree:\n                                g.FillRectangle(Brushes.DarkGreen, x, y, cellSize, cellSize);\n                                break;\n                            case CellState.Burning:\n                                g.FillRectangle(Brushes.DarkRed, x, y, cellSize, cellSize);\n                                break;\n                        }\n                    }\n                }\n\n                Thread.Sleep(500);\n\n                Invoke((MethodInvoker)Refresh);\n\n            } while (generation < uint.MaxValue);\n\n            g.Dispose();\n        }\n\n        private CellState[,] InitializeForestFire(int width, int height)\n        {\n            \n            var state = new CellState[height, width];\n            state.Initialize();\n            return state;\n        }\n\n        private enum CellState : byte\n        {\n            Empty = 0,\n            Tree = 1,\n            Burning = 2\n        }\n\n        private CellState[,] StepForestFire(CellState[,] state, int f, int p)\n        {\n            \n            var newState = (CellState[,])state.Clone();\n\n            int numRows = state.GetLength(0);\n            int numCols = state.GetLength(1);\n\n            for (int r = 1; r < numRows - 1; r++)\n            {\n                for (int c = 1; c < numCols - 1; c++)\n                {\n                    \n                    switch (state[r, c])\n                    {\n                        case CellState.Empty:\n                            if (rand.Next(0, p) == 0)\n                                newState[r, c] = CellState.Tree;\n                            break;\n\n                        case CellState.Tree:\n                            if (NeighborHasState(state, r, c, CellState.Burning) || rand.Next(0, f) == 0)\n                                newState[r, c] = CellState.Burning;\n                            break;\n\n                        case CellState.Burning:\n                            newState[r, c] = CellState.Empty;\n                            break;\n                    }\n                }\n            }\n\n            return newState;\n        }\n\n        private bool NeighborHasState(CellState[,] state, int x, int y, CellState value)\n        {\n            \n            for (int r = -1; r <= 1; r++)\n            {\n                for (int c = -1; c <= 1; c++)\n                {\n                    if (r == 0 && c == 0)\n                        continue;\n\n                    if (state[x + r, y + c] == value)\n                        return true;\n                }\n            }\n\n            return false;\n        }\n\n        protected override void OnPaint(PaintEventArgs e)\n        {\n            base.OnPaint(e);\n            e.Graphics.DrawImage(img, 0, 0);\n        }\n\n        [STAThread]\n        static void Main(string[] args)\n        {\n            Application.Run(new Program(w: 500, h: 500, f: 2, p: 5));\n        }\n    }\n}\n"}
{"id": 155756, "name": "Forest fire", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. forest-fire.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       \n       \n       \n       78  IGNITE-PROB                 VALUE 1.\n       78  NEW-TREE-PROB               VALUE 100.\n\n       78  EMPTY-PROB                  VALUE 3333.\n\n       78  AREA-SIZE                   VALUE 40.\n\n       01  sim-table.\n           03  sim-row OCCURS AREA-SIZE TIMES INDEXED BY row-index.\n               05  sim-area OCCURS AREA-SIZE TIMES\n                   INDEXED BY col-index.\n                   07  current-status  PIC 9.\n                       \n                       \n                       88  empty       VALUE 0. \n                       88  tree        VALUE 2. \n                       88  burning     VALUE 4. \n                       \n                   07  next-status     PIC 9.\n                       88  empty       VALUE 0.\n                       88  tree        VALUE 2.\n                       88  burning     VALUE 4.\n    \n       01  rand-num                    PIC 9999.\n        \n       01  next-row                    PIC 9(4).\n       01  next-col                    PIC 9(4).\n\n       01  neighbours-row              PIC 9(4).\n       01  neighbours-col              PIC 9(4).\n\n       PROCEDURE DIVISION.\n       main-line.\n           \n           MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (9:8)) TO rand-num\n\n           PERFORM initialise-table\n           PERFORM FOREVER\n               PERFORM show-simulation\n               PERFORM step-simulation\n           END-PERFORM\n\n           GOBACK\n           .\n\n       initialise-table.\n           PERFORM VARYING row-index FROM 1 BY 1\n                   UNTIL AREA-SIZE < row-index\n                   AFTER col-index FROM 1 BY 1\n                       UNTIL AREA-SIZE < col-index\n               PERFORM get-rand-num\n               IF rand-num <= EMPTY-PROB\n                   SET empty OF current-status (row-index, col-index)\n                       TO TRUE\n                   SET empty OF next-status (row-index, col-index)\n                       TO TRUE\n               ELSE\n                   SET tree OF current-status (row-index, col-index)\n                       TO TRUE\n                   SET tree OF next-status (row-index, col-index)\n                       TO TRUE\n               END-IF\n           END-PERFORM\n           .\n\n       show-simulation.\n           PERFORM VARYING row-index FROM 1 BY 1\n                   UNTIL AREA-SIZE < row-index\n                   AFTER col-index FROM 1 BY 1\n                       UNTIL AREA-SIZE < col-index\n                DISPLAY SPACE AT LINE row-index COLUMN col-index\n                    WITH BACKGROUND-COLOR\n                        current-status (row-index, col-index)\n           END-PERFORM\n           .\n\n       \n       step-simulation.\n            PERFORM VARYING row-index FROM 1 BY 1\n                   UNTIL AREA-SIZE < row-index\n                   AFTER col-index FROM 1 BY 1\n                       UNTIL AREA-SIZE < col-index\n                EVALUATE TRUE\n                    WHEN empty OF current-status (row-index, col-index)\n                        PERFORM get-rand-num\n                        IF rand-num <= NEW-TREE-PROB\n                            SET tree OF next-status\n                                 (row-index, col-index) TO TRUE\n                        END-IF\n\n                    WHEN tree OF current-status (row-index, col-index)\n                        PERFORM simulate-tree\n\n                    WHEN burning OF current-status\n                            (row-index, col-index)\n                        SET empty OF next-status (row-index, col-index)\n                            TO TRUE\n                END-EVALUATE\n            END-PERFORM\n\n            PERFORM update-statuses.\n            .\n\n       \n       \n       simulate-tree.\n           \n           COMPUTE next-row = FUNCTION MIN(row-index + 1, AREA-SIZE)\n           COMPUTE next-col = FUNCTION MIN(col-index + 1, AREA-SIZE)\n           \n           COMPUTE neighbours-row = FUNCTION MAX(row-index - 1, 1)\n           COMPUTE neighbours-col = FUNCTION MAX(col-index - 1, 1)\n\n           \n           PERFORM VARYING neighbours-row FROM neighbours-row BY 1\n                   UNTIL next-row < neighbours-row\n               \n               PERFORM VARYING neighbours-col FROM neighbours-col BY 1\n                       UNTIL next-col < neighbours-col\n                   IF neighbours-row = row-index\n                           AND neighbours-col = col-index\n                       EXIT PERFORM CYCLE\n                   END-IF\n                   \n                   IF burning OF current-status\n                           (neighbours-row, neighbours-col)\n                       SET burning OF next-status (row-index, col-index)\n                           TO TRUE\n                       EXIT PARAGRAPH\n                   END-IF\n               END-PERFORM\n\n               \n               COMPUTE neighbours-col =\n                   FUNCTION MAX(neighbours-col - 3, 1)\n           END-PERFORM\n\n           \n           \n           PERFORM get-rand-num\n           IF rand-num <= IGNITE-PROB\n               SET burning OF next-status (row-index, col-index) TO TRUE\n           END-IF\n           .\n\n       update-statuses.\n           PERFORM VARYING row-index FROM 1 BY 1\n                   UNTIL AREA-SIZE < row-index\n                   AFTER col-index FROM 1 BY 1\n                       UNTIL AREA-SIZE < col-index\n               MOVE next-status (row-index, col-index)\n                   TO current-status (row-index, col-index)\n           END-PERFORM\n           .\n\n       \n       get-rand-num.\n           COMPUTE rand-num =\n               FUNCTION MOD(FUNCTION RANDOM * 100000, 10000)\n           .\n", "target": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Fire {\n\tprivate static final char BURNING = 'w'; \n\tprivate static final char TREE = 'T';\n\tprivate static final char EMPTY = '.';\n\tprivate static final double F = 0.2;\n\tprivate static final double P = 0.4;\n\tprivate static final double TREE_PROB = 0.5;\n\t\n\tprivate static List<String> process(List<String> land){\n\t\tList<String> newLand = new LinkedList<String>();\n\t\tfor(int i = 0; i < land.size(); i++){\n\t\t\tString rowAbove, thisRow = land.get(i), rowBelow;\n\t\t\tif(i == 0){\n\t\t\t\trowAbove = null;\n\t\t\t\trowBelow = land.get(i + 1);\n\t\t\t}else if(i == land.size() - 1){\n\t\t\t\trowBelow = null;\n\t\t\t\trowAbove = land.get(i - 1);\n\t\t\t}else{\n\t\t\t\trowBelow = land.get(i + 1);\n\t\t\t\trowAbove = land.get(i - 1);\n\t\t\t}\n\t\t\tnewLand.add(processRows(rowAbove, thisRow, rowBelow));\n\t\t}\n\t\treturn newLand;\n\t}\n\n\tprivate static String processRows(String rowAbove, String thisRow,\n\t\t\tString rowBelow){\n\t\tString newRow = \"\";\n\t\tfor(int i = 0; i < thisRow.length();i++){\n\t\t\tswitch(thisRow.charAt(i)){\n\t\t\tcase BURNING:\n\t\t\t\tnewRow+= EMPTY;\n\t\t\t\tbreak;\n\t\t\tcase EMPTY:\n\t\t\t\tnewRow+= Math.random() < P ? TREE : EMPTY;\n\t\t\t\tbreak;\n\t\t\tcase TREE:\n\t\t\t\tString neighbors = \"\";\n\t\t\t\tif(i == 0){\n\t\t\t\t\tneighbors+= rowAbove == null ? \"\" : rowAbove.substring(i, i + 2);\n\t\t\t\t\tneighbors+= thisRow.charAt(i + 1);\n\t\t\t\t\tneighbors+= rowBelow == null ? \"\" : rowBelow.substring(i, i + 2);\n\t\t\t\t\tif(neighbors.contains(Character.toString(BURNING))){\n\t\t\t\t\t\tnewRow+= BURNING;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else if(i == thisRow.length() - 1){\n\t\t\t\t\tneighbors+= rowAbove == null ? \"\" : rowAbove.substring(i - 1, i + 1);\n\t\t\t\t\tneighbors+= thisRow.charAt(i - 1);\n\t\t\t\t\tneighbors+= rowBelow == null ? \"\" : rowBelow.substring(i - 1, i + 1);\n\t\t\t\t\tif(neighbors.contains(Character.toString(BURNING))){\n\t\t\t\t\t\tnewRow+= BURNING;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tneighbors+= rowAbove == null ? \"\" : rowAbove.substring(i - 1, i + 2);\n\t\t\t\t\tneighbors+= thisRow.charAt(i + 1);\n\t\t\t\t\tneighbors+= thisRow.charAt(i - 1);\n\t\t\t\t\tneighbors+= rowBelow == null ? \"\" : rowBelow.substring(i - 1, i + 2);\n\t\t\t\t\tif(neighbors.contains(Character.toString(BURNING))){\n\t\t\t\t\t\tnewRow+= BURNING;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnewRow+= Math.random() < F ? BURNING : TREE;\n\t\t\t}\n\t\t}\n\t\treturn newRow;\n\t}\n\t\n\tpublic static List<String> populate(int width, int height){\n\t\tList<String> land = new LinkedList<String>();\n\t\tfor(;height > 0; height--){\n\t\t\tStringBuilder line = new StringBuilder(width);\n\t\t\tfor(int i = width; i > 0; i--){\n\t\t\t\tline.append((Math.random() < TREE_PROB) ? TREE : EMPTY);\n\t\t\t}\n\t\t\tland.add(line.toString());\n\t\t}\n\t\treturn land;\n\t}\n\t\n\t\n\tpublic static void processN(List<String> land, int n){\n\t\tfor(int i = 0;i < n; i++){\n\t\t\tland = process(land);\n\t\t}\n\t}\n\t\n\t\n\tpublic static void processNPrint(List<String> land, int n){\n\t\tfor(int i = 0;i < n; i++){\n\t\t\tland = process(land);\n\t\t\tprint(land);\n\t\t}\n\t}\n\t\n\t\n\tpublic static void print(List<String> land){\n\t\tfor(String row: land){\n\t\t\tSystem.out.println(row);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tList<String> land = Arrays.asList(\".TTT.T.T.TTTT.T\",\n\t\t\t\t\"T.T.T.TT..T.T..\",\n\t\t\t\t\"TT.TTTT...T.TT.\",\n\t\t\t\t\"TTT..TTTTT.T..T\",\n\t\t\t\t\".T.TTT....TT.TT\",\n\t\t\t\t\"...T..TTT.TT.T.\",\n\t\t\t\t\".TT.TT...TT..TT\",\n\t\t\t\t\".TT.T.T..T.T.T.\",\n\t\t\t\t\"..TTT.TT.T..T..\",\n\t\t\t\t\".T....T.....TTT\",\n\t\t\t\t\"T..TTT..T..T...\",\n\t\t\t\t\"TTT....TTTTTT.T\",\n\t\t\t\t\"......TwTTT...T\",\n\t\t\t\t\"..T....TTTTTTTT\",\n\t\t\t\t\".T.T.T....TT...\");\n\t\tprint(land);\n\t\tprocessNPrint(land, 10);\n\t\t\n\t\tSystem.out.println(\"Random land test:\");\n\t\t\n\t\tland = populate(10, 10);\n\t\tprint(land);\n\t\tprocessNPrint(land, 10);\n\t}\n}\n"}
{"id": 155757, "name": "Forest fire", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. forest-fire.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       \n       \n       \n       78  IGNITE-PROB                 VALUE 1.\n       78  NEW-TREE-PROB               VALUE 100.\n\n       78  EMPTY-PROB                  VALUE 3333.\n\n       78  AREA-SIZE                   VALUE 40.\n\n       01  sim-table.\n           03  sim-row OCCURS AREA-SIZE TIMES INDEXED BY row-index.\n               05  sim-area OCCURS AREA-SIZE TIMES\n                   INDEXED BY col-index.\n                   07  current-status  PIC 9.\n                       \n                       \n                       88  empty       VALUE 0. \n                       88  tree        VALUE 2. \n                       88  burning     VALUE 4. \n                       \n                   07  next-status     PIC 9.\n                       88  empty       VALUE 0.\n                       88  tree        VALUE 2.\n                       88  burning     VALUE 4.\n    \n       01  rand-num                    PIC 9999.\n        \n       01  next-row                    PIC 9(4).\n       01  next-col                    PIC 9(4).\n\n       01  neighbours-row              PIC 9(4).\n       01  neighbours-col              PIC 9(4).\n\n       PROCEDURE DIVISION.\n       main-line.\n           \n           MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (9:8)) TO rand-num\n\n           PERFORM initialise-table\n           PERFORM FOREVER\n               PERFORM show-simulation\n               PERFORM step-simulation\n           END-PERFORM\n\n           GOBACK\n           .\n\n       initialise-table.\n           PERFORM VARYING row-index FROM 1 BY 1\n                   UNTIL AREA-SIZE < row-index\n                   AFTER col-index FROM 1 BY 1\n                       UNTIL AREA-SIZE < col-index\n               PERFORM get-rand-num\n               IF rand-num <= EMPTY-PROB\n                   SET empty OF current-status (row-index, col-index)\n                       TO TRUE\n                   SET empty OF next-status (row-index, col-index)\n                       TO TRUE\n               ELSE\n                   SET tree OF current-status (row-index, col-index)\n                       TO TRUE\n                   SET tree OF next-status (row-index, col-index)\n                       TO TRUE\n               END-IF\n           END-PERFORM\n           .\n\n       show-simulation.\n           PERFORM VARYING row-index FROM 1 BY 1\n                   UNTIL AREA-SIZE < row-index\n                   AFTER col-index FROM 1 BY 1\n                       UNTIL AREA-SIZE < col-index\n                DISPLAY SPACE AT LINE row-index COLUMN col-index\n                    WITH BACKGROUND-COLOR\n                        current-status (row-index, col-index)\n           END-PERFORM\n           .\n\n       \n       step-simulation.\n            PERFORM VARYING row-index FROM 1 BY 1\n                   UNTIL AREA-SIZE < row-index\n                   AFTER col-index FROM 1 BY 1\n                       UNTIL AREA-SIZE < col-index\n                EVALUATE TRUE\n                    WHEN empty OF current-status (row-index, col-index)\n                        PERFORM get-rand-num\n                        IF rand-num <= NEW-TREE-PROB\n                            SET tree OF next-status\n                                 (row-index, col-index) TO TRUE\n                        END-IF\n\n                    WHEN tree OF current-status (row-index, col-index)\n                        PERFORM simulate-tree\n\n                    WHEN burning OF current-status\n                            (row-index, col-index)\n                        SET empty OF next-status (row-index, col-index)\n                            TO TRUE\n                END-EVALUATE\n            END-PERFORM\n\n            PERFORM update-statuses.\n            .\n\n       \n       \n       simulate-tree.\n           \n           COMPUTE next-row = FUNCTION MIN(row-index + 1, AREA-SIZE)\n           COMPUTE next-col = FUNCTION MIN(col-index + 1, AREA-SIZE)\n           \n           COMPUTE neighbours-row = FUNCTION MAX(row-index - 1, 1)\n           COMPUTE neighbours-col = FUNCTION MAX(col-index - 1, 1)\n\n           \n           PERFORM VARYING neighbours-row FROM neighbours-row BY 1\n                   UNTIL next-row < neighbours-row\n               \n               PERFORM VARYING neighbours-col FROM neighbours-col BY 1\n                       UNTIL next-col < neighbours-col\n                   IF neighbours-row = row-index\n                           AND neighbours-col = col-index\n                       EXIT PERFORM CYCLE\n                   END-IF\n                   \n                   IF burning OF current-status\n                           (neighbours-row, neighbours-col)\n                       SET burning OF next-status (row-index, col-index)\n                           TO TRUE\n                       EXIT PARAGRAPH\n                   END-IF\n               END-PERFORM\n\n               \n               COMPUTE neighbours-col =\n                   FUNCTION MAX(neighbours-col - 3, 1)\n           END-PERFORM\n\n           \n           \n           PERFORM get-rand-num\n           IF rand-num <= IGNITE-PROB\n               SET burning OF next-status (row-index, col-index) TO TRUE\n           END-IF\n           .\n\n       update-statuses.\n           PERFORM VARYING row-index FROM 1 BY 1\n                   UNTIL AREA-SIZE < row-index\n                   AFTER col-index FROM 1 BY 1\n                       UNTIL AREA-SIZE < col-index\n               MOVE next-status (row-index, col-index)\n                   TO current-status (row-index, col-index)\n           END-PERFORM\n           .\n\n       \n       get-rand-num.\n           COMPUTE rand-num =\n               FUNCTION MOD(FUNCTION RANDOM * 100000, 10000)\n           .\n", "target": "\n\nL = 15\n\ninitial_trees = 0.55\np = 0.01\nf = 0.001\n\ntry:\n    raw_input\nexcept:\n    raw_input = input\n    \nimport random\n\n\ntree, burning, space = 'TB.'\nhood = ((-1,-1), (-1,0), (-1,1),\n        (0,-1),          (0, 1),\n        (1,-1),  (1,0),  (1,1))\n\ndef initialise():\n    grid = {(x,y): (tree if random.random()<= initial_trees else space)\n            for x in range(L)\n            for y in range(L) }\n    return grid\n\ndef gprint(grid):\n    txt = '\\n'.join(''.join(grid[(x,y)] for x in range(L))\n                    for y in range(L))\n    print(txt)\n\ndef quickprint(grid):\n    t = b = 0\n    ll = L * L\n    for x in range(L):\n        for y in range(L):\n            if grid[(x,y)] in (tree, burning):\n                t += 1\n                if grid[(x,y)] == burning:\n                    b += 1\n    print(('Of %6i cells, %6i are trees of which %6i are currently burning.'\n          + ' (%6.3f%%, %6.3f%%)')\n          % (ll, t, b, 100. * t / ll, 100. * b / ll))\n                \n\ndef gnew(grid):\n    newgrid = {}\n    for x in range(L):\n        for y in range(L):\n            if grid[(x,y)] == burning:\n                newgrid[(x,y)] = space\n            elif grid[(x,y)] == space:\n                newgrid[(x,y)] = tree if random.random()<= p else space\n            elif grid[(x,y)] == tree:\n                newgrid[(x,y)] = (burning\n                                   if any(grid.get((x+dx,y+dy),space) == burning\n                                            for dx,dy in hood)\n                                        or random.random()<= f \n                                   else tree)\n    return newgrid\n\nif __name__ == '__main__':\n    grid = initialise()\n    iter = 0\n    while True:\n        quickprint(grid)\n        inp = raw_input('Print/Quit/<int>/<return> %6i: ' % iter).lower().strip()\n        if inp:\n            if inp[0] == 'p':\n                gprint(grid)\n            elif inp.isdigit():\n                for i in range(int(inp)):\n                    iter +=1\n                    grid = gnew(grid)\n                    quickprint(grid)\n            elif inp[0] == 'q':\n                break\n        grid = gnew(grid)\n        iter +=1\n"}
{"id": 156566, "name": "Number reversal game", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. REVERSAL.\n       AUTHOR.  Bill Gunshannon\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  11 December 2021\n      ****************************************************************\n      ** Program Abstract:\n      **   Use a Knuth Shuffle to reate our out ot sort array.\n      **   Use a procedure called \"reverse\" to pancake sort the array.\n      ****************************************************************\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       \n       01 RNUM               PIC 9.\n       01 TRIES              PIC 99    VALUE 0.\n       01 ANSWER     PIC 9(9)  VALUE 123456789.\n       01 TBL-LEN    PIC 9    VALUE 9.\n       01 TBL.\n          05  TZ PIC 9(9). \n          05  TA REDEFINES TZ \n                 PIC 9 OCCURS 9 TIMES.\n       \n       PROCEDURE DIVISION.\n       \n       MAIN-pROGRAM.\n           MOVE ANSWER TO TBL\n\n           CALL 'KNUTH-SHUFFLE'\n                 USING  BY REFERENCE TBL\n           END-CALL.\n\n           DISPLAY \"TABLE after shuffle: \" TBL.\n\n           PERFORM UNTIL TBL = ANSWER\n               ADD 1 TO TRIES\n               DISPLAY \"How many to reverse? \"\n               ACCEPT RNUM\n\n               CALL 'REVERSE' USING BY CONTENT RNUM, \n                      BY REFERENCE TBL\n               END-CALL\n\n               DISPLAY \"Try #\" TRIES \"  \" TBL\n           END-PERFORM.\n           DISPLAY \"Congratulations.  You did it!\"\n\n           STOP RUN.\n       END PROGRAM REVERSAL.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. KNUTH-SHUFFLE.\n \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  I                       PIC 9(9).\n       01  J                       PIC 9(9).\n       01  TEMP                    PIC 9(9).\n       01  tABLE-lEN               PIC 9  value 9.\n\n       LINKAGE SECTION.\n       01  TTABLE-AREA.\n           03  TTABLE              PIC 9 OCCURS 9 TIMES.\n \n       PROCEDURE DIVISION USING ttable-area.\n           MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (11:6)) TO I\n \n           PERFORM VARYING i FROM Table-Len BY -1 UNTIL i = 0\n               COMPUTE j =\n                   FUNCTION MOD(FUNCTION RANDOM * 10000, Table-Len) + 1\n \n               MOVE ttable (i) TO temp\n               MOVE ttable (j) TO ttable (i)\n               MOVE temp TO ttable (j)\n           END-PERFORM.\n\n           GOBACK.\n           END PROGRAM KNUTH-SHUFFLE.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. REVERSE.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  I                       PIC 9.\n       01  J                       PIC 9.\n       01  X                       PIC 9.\n       01  LOOP-IDX                PIC 9.\n\n\n       LINKAGE SECTION.\n       01  IDX        PIC 9.\n       01  TTABLE-AREA.\n           03  TTABLE              PIC 9 OCCURS 9 TIMES.\n\n       PROCEDURE DIVISION USING IDX, TTABLE-AREA.\n\n       DIVIDE IDX BY 2 GIVING LOOP-IDx\n\n\n       MOVE 1 TO I\n       MOVE IDX TO J\n\n       PERFORM LOOP-IDX TIMES\n           MOVE TTABLE(I) TO X\n           MOVE TTABLE(J) TO TTABLE(I)\n           MOVE X TO TTABLE(J)\n           ADD 1 TO I\n           SUBTRACT 1 FROM J\n       END-PERFORM.\n\n       GOBACK.\n       END PROGRAM REVERSE.\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var r = new Random();\n\n        var tries = 1;\n        var sorted = Enumerable.Range(1, 9).ToList();\n        var values = sorted.OrderBy(x => r.Next(-1, 1)).ToList();\n\n        while (Enumerable.SequenceEqual(sorted, values)) {\n            values = sorted.OrderBy(x => r.Next(-1, 1)).ToList();\n        }\n\n        \n\n        while (!Enumerable.SequenceEqual(sorted, values))\n        {\n            Console.Write(\"# {0}: LIST: {1} - Flip how many? \", tries, String.Join(\" \", values));\n\n            values.Reverse(0, int.Parse(Console.ReadLine()));\n            tries += 1;\n        }\n\n        Console.WriteLine(\"\\nYou took {0} attempts to put the digits in order!\", tries - 1);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 156568, "name": "Number reversal game", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. REVERSAL.\n       AUTHOR.  Bill Gunshannon\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  11 December 2021\n      ****************************************************************\n      ** Program Abstract:\n      **   Use a Knuth Shuffle to reate our out ot sort array.\n      **   Use a procedure called \"reverse\" to pancake sort the array.\n      ****************************************************************\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       \n       01 RNUM               PIC 9.\n       01 TRIES              PIC 99    VALUE 0.\n       01 ANSWER     PIC 9(9)  VALUE 123456789.\n       01 TBL-LEN    PIC 9    VALUE 9.\n       01 TBL.\n          05  TZ PIC 9(9). \n          05  TA REDEFINES TZ \n                 PIC 9 OCCURS 9 TIMES.\n       \n       PROCEDURE DIVISION.\n       \n       MAIN-pROGRAM.\n           MOVE ANSWER TO TBL\n\n           CALL 'KNUTH-SHUFFLE'\n                 USING  BY REFERENCE TBL\n           END-CALL.\n\n           DISPLAY \"TABLE after shuffle: \" TBL.\n\n           PERFORM UNTIL TBL = ANSWER\n               ADD 1 TO TRIES\n               DISPLAY \"How many to reverse? \"\n               ACCEPT RNUM\n\n               CALL 'REVERSE' USING BY CONTENT RNUM, \n                      BY REFERENCE TBL\n               END-CALL\n\n               DISPLAY \"Try #\" TRIES \"  \" TBL\n           END-PERFORM.\n           DISPLAY \"Congratulations.  You did it!\"\n\n           STOP RUN.\n       END PROGRAM REVERSAL.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. KNUTH-SHUFFLE.\n \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  I                       PIC 9(9).\n       01  J                       PIC 9(9).\n       01  TEMP                    PIC 9(9).\n       01  tABLE-lEN               PIC 9  value 9.\n\n       LINKAGE SECTION.\n       01  TTABLE-AREA.\n           03  TTABLE              PIC 9 OCCURS 9 TIMES.\n \n       PROCEDURE DIVISION USING ttable-area.\n           MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (11:6)) TO I\n \n           PERFORM VARYING i FROM Table-Len BY -1 UNTIL i = 0\n               COMPUTE j =\n                   FUNCTION MOD(FUNCTION RANDOM * 10000, Table-Len) + 1\n \n               MOVE ttable (i) TO temp\n               MOVE ttable (j) TO ttable (i)\n               MOVE temp TO ttable (j)\n           END-PERFORM.\n\n           GOBACK.\n           END PROGRAM KNUTH-SHUFFLE.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. REVERSE.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  I                       PIC 9.\n       01  J                       PIC 9.\n       01  X                       PIC 9.\n       01  LOOP-IDX                PIC 9.\n\n\n       LINKAGE SECTION.\n       01  IDX        PIC 9.\n       01  TTABLE-AREA.\n           03  TTABLE              PIC 9 OCCURS 9 TIMES.\n\n       PROCEDURE DIVISION USING IDX, TTABLE-AREA.\n\n       DIVIDE IDX BY 2 GIVING LOOP-IDx\n\n\n       MOVE 1 TO I\n       MOVE IDX TO J\n\n       PERFORM LOOP-IDX TIMES\n           MOVE TTABLE(I) TO X\n           MOVE TTABLE(J) TO TTABLE(I)\n           MOVE X TO TTABLE(J)\n           ADD 1 TO I\n           SUBTRACT 1 FROM J\n       END-PERFORM.\n\n       GOBACK.\n       END PROGRAM REVERSE.\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.Collections;\n\n\npublic class ReversalGame {\n    private List<Integer> gameList;\n\n    public ReversalGame() {\n        initialize();\n    }\n\n    public void play() throws Exception {\n        int i = 0;\n        int moveCount = 0;\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            System.out.println(gameList);\n            System.out.println(\"Please enter a index to reverse from 2 to 9. Enter 99 to quit\");\n            i = scanner.nextInt();\n            if (i == 99) {\n                break;\n            }\n            if (i < 2 || i > 9) {\n                System.out.println(\"Invalid input\");\n            } else {\n                moveCount++;\n                reverse(i);\n                if (isSorted()) {\n                    System.out.println(\"Congratulations you solved this in \" + moveCount + \" moves!\");\n                    break;\n                }\n            }\n\n        }\n        scanner.close();\n    }\n\n    private void reverse(int position) {\n        Collections.reverse(gameList.subList(0, position));\n    }\n\n    private boolean isSorted() {\n        for (int i=0; i < gameList.size() - 1; ++i) {\n            if (gameList.get(i).compareTo(gameList.get(i + 1)) > 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void initialize() {\n        this.gameList = new ArrayList<Integer>(9);\n        for (int i=1; i < 10; ++i) {\n            gameList.add(i);\n        }\n        while (isSorted()) {\n            Collections.shuffle(gameList);\n        }\n    }\n\n\n    public static void main(String[] args) {\n        try {\n            ReversalGame game = new ReversalGame();\n            game.play();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"id": 156569, "name": "Number reversal game", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. REVERSAL.\n       AUTHOR.  Bill Gunshannon\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  11 December 2021\n      ****************************************************************\n      ** Program Abstract:\n      **   Use a Knuth Shuffle to reate our out ot sort array.\n      **   Use a procedure called \"reverse\" to pancake sort the array.\n      ****************************************************************\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       \n       01 RNUM               PIC 9.\n       01 TRIES              PIC 99    VALUE 0.\n       01 ANSWER     PIC 9(9)  VALUE 123456789.\n       01 TBL-LEN    PIC 9    VALUE 9.\n       01 TBL.\n          05  TZ PIC 9(9). \n          05  TA REDEFINES TZ \n                 PIC 9 OCCURS 9 TIMES.\n       \n       PROCEDURE DIVISION.\n       \n       MAIN-pROGRAM.\n           MOVE ANSWER TO TBL\n\n           CALL 'KNUTH-SHUFFLE'\n                 USING  BY REFERENCE TBL\n           END-CALL.\n\n           DISPLAY \"TABLE after shuffle: \" TBL.\n\n           PERFORM UNTIL TBL = ANSWER\n               ADD 1 TO TRIES\n               DISPLAY \"How many to reverse? \"\n               ACCEPT RNUM\n\n               CALL 'REVERSE' USING BY CONTENT RNUM, \n                      BY REFERENCE TBL\n               END-CALL\n\n               DISPLAY \"Try #\" TRIES \"  \" TBL\n           END-PERFORM.\n           DISPLAY \"Congratulations.  You did it!\"\n\n           STOP RUN.\n       END PROGRAM REVERSAL.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. KNUTH-SHUFFLE.\n \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  I                       PIC 9(9).\n       01  J                       PIC 9(9).\n       01  TEMP                    PIC 9(9).\n       01  tABLE-lEN               PIC 9  value 9.\n\n       LINKAGE SECTION.\n       01  TTABLE-AREA.\n           03  TTABLE              PIC 9 OCCURS 9 TIMES.\n \n       PROCEDURE DIVISION USING ttable-area.\n           MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (11:6)) TO I\n \n           PERFORM VARYING i FROM Table-Len BY -1 UNTIL i = 0\n               COMPUTE j =\n                   FUNCTION MOD(FUNCTION RANDOM * 10000, Table-Len) + 1\n \n               MOVE ttable (i) TO temp\n               MOVE ttable (j) TO ttable (i)\n               MOVE temp TO ttable (j)\n           END-PERFORM.\n\n           GOBACK.\n           END PROGRAM KNUTH-SHUFFLE.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. REVERSE.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  I                       PIC 9.\n       01  J                       PIC 9.\n       01  X                       PIC 9.\n       01  LOOP-IDX                PIC 9.\n\n\n       LINKAGE SECTION.\n       01  IDX        PIC 9.\n       01  TTABLE-AREA.\n           03  TTABLE              PIC 9 OCCURS 9 TIMES.\n\n       PROCEDURE DIVISION USING IDX, TTABLE-AREA.\n\n       DIVIDE IDX BY 2 GIVING LOOP-IDx\n\n\n       MOVE 1 TO I\n       MOVE IDX TO J\n\n       PERFORM LOOP-IDX TIMES\n           MOVE TTABLE(I) TO X\n           MOVE TTABLE(J) TO TTABLE(I)\n           MOVE X TO TTABLE(J)\n           ADD 1 TO I\n           SUBTRACT 1 FROM J\n       END-PERFORM.\n\n       GOBACK.\n       END PROGRAM REVERSE.\n", "target": "print '\n\nvar data, trials = list(1..9), 0\n\nwhile data == sort data:\n    random.shuffle data\n\nwhile data != sort data:\n    trials += 1\n    flip = int input '\n    data[:flip] = reverse data[:flip]\n\nprint '\\nYou took ${trials} attempts to put digits in order!'\n"}
{"id": 156893, "name": "Van Eck sequence", "source": "Translate COBOL to C#:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. VAN-ECK.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 CALCULATION.\n            02 ECK      PIC 999 OCCURS 1000 TIMES.\n            02 I        PIC 9999.\n            02 J        PIC 9999.\n        01 OUTPUT-FORMAT.\n            02 ITEM     PIC ZZ9.\n            02 IDX      PIC ZZZ9.\n        \n        PROCEDURE DIVISION.\n        B.  PERFORM GENERATE-ECK.\n            PERFORM SHOW VARYING I FROM 1 BY 1 UNTIL I = 11.\n            PERFORM SHOW VARYING I FROM 991 BY 1 UNTIL I = 1001.\n            STOP RUN.\n        \n        SHOW.\n            MOVE I TO IDX.\n            MOVE ECK(I) TO ITEM.\n            DISPLAY 'ECK(' IDX ') = ' ITEM.\n        \n        GENERATE-ECK SECTION.\n        B.  SET ECK(1) TO 0.\n            SET I TO 1.\n            PERFORM GENERATE-TERM \n                VARYING I FROM 2 BY 1 UNTIL I = 1001.\n            \n        GENERATE-TERM SECTION.\n        B.  SUBTRACT 2 FROM I GIVING J.\n        LOOP.\n            IF J IS LESS THAN 1 GO TO TERM-IS-NEW.\n            IF ECK(J) = ECK(I - 1) GO TO TERM-IS-OLD.\n            SUBTRACT 1 FROM J.\n            GO TO LOOP.\n        \n        TERM-IS-NEW.\n            SET ECK(I) TO 0.\n            GO TO DONE.\n         \n        TERM-IS-OLD.\n            COMPUTE ECK(I) = (I - J) - 1.\n            \n        DONE. EXIT.\n", "target": "using System.Linq; class Program { static void Main() {\n    int a, b, c, d, e, f, g; int[] h = new int[g = 1000];\n    for (a = 0, b = 1, c = 2; c < g; a = b, b = c++)\n        for (d = a, e = b - d, f = h[b]; e <= b; e++)\n            if (f == h[d--]) { h[c] = e; break; }\n    void sho(int i) { System.Console.WriteLine(string.Join(\" \",\n        h.Skip(i).Take(10))); } sho(0); sho(990); } }\n"}
{"id": 156894, "name": "Van Eck sequence", "source": "Translate COBOL to C#:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. VAN-ECK.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 CALCULATION.\n            02 ECK      PIC 999 OCCURS 1000 TIMES.\n            02 I        PIC 9999.\n            02 J        PIC 9999.\n        01 OUTPUT-FORMAT.\n            02 ITEM     PIC ZZ9.\n            02 IDX      PIC ZZZ9.\n        \n        PROCEDURE DIVISION.\n        B.  PERFORM GENERATE-ECK.\n            PERFORM SHOW VARYING I FROM 1 BY 1 UNTIL I = 11.\n            PERFORM SHOW VARYING I FROM 991 BY 1 UNTIL I = 1001.\n            STOP RUN.\n        \n        SHOW.\n            MOVE I TO IDX.\n            MOVE ECK(I) TO ITEM.\n            DISPLAY 'ECK(' IDX ') = ' ITEM.\n        \n        GENERATE-ECK SECTION.\n        B.  SET ECK(1) TO 0.\n            SET I TO 1.\n            PERFORM GENERATE-TERM \n                VARYING I FROM 2 BY 1 UNTIL I = 1001.\n            \n        GENERATE-TERM SECTION.\n        B.  SUBTRACT 2 FROM I GIVING J.\n        LOOP.\n            IF J IS LESS THAN 1 GO TO TERM-IS-NEW.\n            IF ECK(J) = ECK(I - 1) GO TO TERM-IS-OLD.\n            SUBTRACT 1 FROM J.\n            GO TO LOOP.\n        \n        TERM-IS-NEW.\n            SET ECK(I) TO 0.\n            GO TO DONE.\n         \n        TERM-IS-OLD.\n            COMPUTE ECK(I) = (I - J) - 1.\n            \n        DONE. EXIT.\n", "target": "using System.Linq; class Program { static void Main() {\n    int a, b, c, d, e, f, g; int[] h = new int[g = 1000];\n    for (a = 0, b = 1, c = 2; c < g; a = b, b = c++)\n        for (d = a, e = b - d, f = h[b]; e <= b; e++)\n            if (f == h[d--]) { h[c] = e; break; }\n    void sho(int i) { System.Console.WriteLine(string.Join(\" \",\n        h.Skip(i).Take(10))); } sho(0); sho(990); } }\n"}
{"id": 156897, "name": "Van Eck sequence", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. VAN-ECK.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 CALCULATION.\n            02 ECK      PIC 999 OCCURS 1000 TIMES.\n            02 I        PIC 9999.\n            02 J        PIC 9999.\n        01 OUTPUT-FORMAT.\n            02 ITEM     PIC ZZ9.\n            02 IDX      PIC ZZZ9.\n        \n        PROCEDURE DIVISION.\n        B.  PERFORM GENERATE-ECK.\n            PERFORM SHOW VARYING I FROM 1 BY 1 UNTIL I = 11.\n            PERFORM SHOW VARYING I FROM 991 BY 1 UNTIL I = 1001.\n            STOP RUN.\n        \n        SHOW.\n            MOVE I TO IDX.\n            MOVE ECK(I) TO ITEM.\n            DISPLAY 'ECK(' IDX ') = ' ITEM.\n        \n        GENERATE-ECK SECTION.\n        B.  SET ECK(1) TO 0.\n            SET I TO 1.\n            PERFORM GENERATE-TERM \n                VARYING I FROM 2 BY 1 UNTIL I = 1001.\n            \n        GENERATE-TERM SECTION.\n        B.  SUBTRACT 2 FROM I GIVING J.\n        LOOP.\n            IF J IS LESS THAN 1 GO TO TERM-IS-NEW.\n            IF ECK(J) = ECK(I - 1) GO TO TERM-IS-OLD.\n            SUBTRACT 1 FROM J.\n            GO TO LOOP.\n        \n        TERM-IS-NEW.\n            SET ECK(I) TO 0.\n            GO TO DONE.\n         \n        TERM-IS-OLD.\n            COMPUTE ECK(I) = (I - J) - 1.\n            \n        DONE. EXIT.\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VanEckSequence {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 10 terms of Van Eck's sequence:\");\n        vanEck(1, 10);\n        System.out.println(\"\");\n        System.out.println(\"Terms 991 to 1000 of Van Eck's sequence:\");\n        vanEck(991, 1000);\n    }\n    \n    private static void vanEck(int firstIndex, int lastIndex) {\n        Map<Integer,Integer> vanEckMap = new HashMap<>();        \n        int last = 0;\n        if ( firstIndex == 1 ) {\n            System.out.printf(\"VanEck[%d] = %d%n\", 1, 0);\n        }\n        for ( int n = 2 ; n <= lastIndex ; n++ ) {\n            int vanEck = vanEckMap.containsKey(last) ? n - vanEckMap.get(last) : 0;\n            vanEckMap.put(last, n);\n            last = vanEck;\n            if ( n >= firstIndex ) {\n                System.out.printf(\"VanEck[%d] = %d%n\", n, vanEck);\n            }\n        }\n        \n    }\n\n}\n"}
{"id": 156898, "name": "Van Eck sequence", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. VAN-ECK.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 CALCULATION.\n            02 ECK      PIC 999 OCCURS 1000 TIMES.\n            02 I        PIC 9999.\n            02 J        PIC 9999.\n        01 OUTPUT-FORMAT.\n            02 ITEM     PIC ZZ9.\n            02 IDX      PIC ZZZ9.\n        \n        PROCEDURE DIVISION.\n        B.  PERFORM GENERATE-ECK.\n            PERFORM SHOW VARYING I FROM 1 BY 1 UNTIL I = 11.\n            PERFORM SHOW VARYING I FROM 991 BY 1 UNTIL I = 1001.\n            STOP RUN.\n        \n        SHOW.\n            MOVE I TO IDX.\n            MOVE ECK(I) TO ITEM.\n            DISPLAY 'ECK(' IDX ') = ' ITEM.\n        \n        GENERATE-ECK SECTION.\n        B.  SET ECK(1) TO 0.\n            SET I TO 1.\n            PERFORM GENERATE-TERM \n                VARYING I FROM 2 BY 1 UNTIL I = 1001.\n            \n        GENERATE-TERM SECTION.\n        B.  SUBTRACT 2 FROM I GIVING J.\n        LOOP.\n            IF J IS LESS THAN 1 GO TO TERM-IS-NEW.\n            IF ECK(J) = ECK(I - 1) GO TO TERM-IS-OLD.\n            SUBTRACT 1 FROM J.\n            GO TO LOOP.\n        \n        TERM-IS-NEW.\n            SET ECK(I) TO 0.\n            GO TO DONE.\n         \n        TERM-IS-OLD.\n            COMPUTE ECK(I) = (I - J) - 1.\n            \n        DONE. EXIT.\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VanEckSequence {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 10 terms of Van Eck's sequence:\");\n        vanEck(1, 10);\n        System.out.println(\"\");\n        System.out.println(\"Terms 991 to 1000 of Van Eck's sequence:\");\n        vanEck(991, 1000);\n    }\n    \n    private static void vanEck(int firstIndex, int lastIndex) {\n        Map<Integer,Integer> vanEckMap = new HashMap<>();        \n        int last = 0;\n        if ( firstIndex == 1 ) {\n            System.out.printf(\"VanEck[%d] = %d%n\", 1, 0);\n        }\n        for ( int n = 2 ; n <= lastIndex ; n++ ) {\n            int vanEck = vanEckMap.containsKey(last) ? n - vanEckMap.get(last) : 0;\n            vanEckMap.put(last, n);\n            last = vanEck;\n            if ( n >= firstIndex ) {\n                System.out.printf(\"VanEck[%d] = %d%n\", n, vanEck);\n            }\n        }\n        \n    }\n\n}\n"}
{"id": 156899, "name": "Van Eck sequence", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. VAN-ECK.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 CALCULATION.\n            02 ECK      PIC 999 OCCURS 1000 TIMES.\n            02 I        PIC 9999.\n            02 J        PIC 9999.\n        01 OUTPUT-FORMAT.\n            02 ITEM     PIC ZZ9.\n            02 IDX      PIC ZZZ9.\n        \n        PROCEDURE DIVISION.\n        B.  PERFORM GENERATE-ECK.\n            PERFORM SHOW VARYING I FROM 1 BY 1 UNTIL I = 11.\n            PERFORM SHOW VARYING I FROM 991 BY 1 UNTIL I = 1001.\n            STOP RUN.\n        \n        SHOW.\n            MOVE I TO IDX.\n            MOVE ECK(I) TO ITEM.\n            DISPLAY 'ECK(' IDX ') = ' ITEM.\n        \n        GENERATE-ECK SECTION.\n        B.  SET ECK(1) TO 0.\n            SET I TO 1.\n            PERFORM GENERATE-TERM \n                VARYING I FROM 2 BY 1 UNTIL I = 1001.\n            \n        GENERATE-TERM SECTION.\n        B.  SUBTRACT 2 FROM I GIVING J.\n        LOOP.\n            IF J IS LESS THAN 1 GO TO TERM-IS-NEW.\n            IF ECK(J) = ECK(I - 1) GO TO TERM-IS-OLD.\n            SUBTRACT 1 FROM J.\n            GO TO LOOP.\n        \n        TERM-IS-NEW.\n            SET ECK(I) TO 0.\n            GO TO DONE.\n         \n        TERM-IS-OLD.\n            COMPUTE ECK(I) = (I - J) - 1.\n            \n        DONE. EXIT.\n", "target": "def van_eck():\n    n, seen, val = 0, {}, 0\n    while True:\n        yield val\n        last = {val: n}\n        val = n - seen.get(val, n)\n        seen.update(last)\n        n += 1\n\nif __name__ == '__main__':\n    print(\"Van Eck: first 10 terms:  \", list(islice(van_eck(), 10)))\n    print(\"Van Eck: terms 991 - 1000:\", list(islice(van_eck(), 1000))[-10:])\n"}
{"id": 156900, "name": "Van Eck sequence", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. VAN-ECK.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 CALCULATION.\n            02 ECK      PIC 999 OCCURS 1000 TIMES.\n            02 I        PIC 9999.\n            02 J        PIC 9999.\n        01 OUTPUT-FORMAT.\n            02 ITEM     PIC ZZ9.\n            02 IDX      PIC ZZZ9.\n        \n        PROCEDURE DIVISION.\n        B.  PERFORM GENERATE-ECK.\n            PERFORM SHOW VARYING I FROM 1 BY 1 UNTIL I = 11.\n            PERFORM SHOW VARYING I FROM 991 BY 1 UNTIL I = 1001.\n            STOP RUN.\n        \n        SHOW.\n            MOVE I TO IDX.\n            MOVE ECK(I) TO ITEM.\n            DISPLAY 'ECK(' IDX ') = ' ITEM.\n        \n        GENERATE-ECK SECTION.\n        B.  SET ECK(1) TO 0.\n            SET I TO 1.\n            PERFORM GENERATE-TERM \n                VARYING I FROM 2 BY 1 UNTIL I = 1001.\n            \n        GENERATE-TERM SECTION.\n        B.  SUBTRACT 2 FROM I GIVING J.\n        LOOP.\n            IF J IS LESS THAN 1 GO TO TERM-IS-NEW.\n            IF ECK(J) = ECK(I - 1) GO TO TERM-IS-OLD.\n            SUBTRACT 1 FROM J.\n            GO TO LOOP.\n        \n        TERM-IS-NEW.\n            SET ECK(I) TO 0.\n            GO TO DONE.\n         \n        TERM-IS-OLD.\n            COMPUTE ECK(I) = (I - J) - 1.\n            \n        DONE. EXIT.\n", "target": "def van_eck():\n    n, seen, val = 0, {}, 0\n    while True:\n        yield val\n        last = {val: n}\n        val = n - seen.get(val, n)\n        seen.update(last)\n        n += 1\n\nif __name__ == '__main__':\n    print(\"Van Eck: first 10 terms:  \", list(islice(van_eck(), 10)))\n    print(\"Van Eck: terms 991 - 1000:\", list(islice(van_eck(), 1000))[-10:])\n"}
{"id": 158036, "name": "Phrase reversals", "source": "Translate COBOL to C#:        program-id. phra-rev.\n       data division.\n       working-storage section.\n       1 phrase pic x(28) value \"rosetta code phrase reversal\".\n       1 wk-str pic x(16).\n       1 binary.\n        2 phrase-len pic 9(4).\n        2 pos pic 9(4).\n        2 cnt pic 9(4).\n       procedure division.\n           compute phrase-len = function length (phrase)\n           display phrase\n           display function reverse (phrase)\n           perform display-words\n           move function reverse (phrase) to phrase\n           perform display-words\n           stop run\n           .\n\n       display-words.\n           move 1 to pos\n           perform until pos > phrase-len\n               unstring phrase delimited space\n               into wk-str count in cnt\n               with pointer pos\n               end-unstring\n               display function reverse (wk-str (1:cnt))\n                   with no advancing\n               if pos < phrase-len\n                   display space with no advancing\n               end-if\n           end-perform\n           display space\n           .\n       end program phra-rev.\n", "target": "using System;\nusing System.Linq;\nnamespace ConsoleApplication\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            \n            Func<string, string> reverse = s => new string(s.Reverse().ToArray());\n\n            string phrase = \"rosetta code phrase reversal\";\n            \n            Console.WriteLine(reverse(phrase));\n            \n            Console.WriteLine(string.Join(\" \", phrase.Split(' ').Select(word => reverse(word))));\n            \n            Console.WriteLine(string.Join(\" \", phrase.Split(' ').Reverse()));\n        }\n    }\n}\n"}
{"id": 158038, "name": "Phrase reversals", "source": "Translate COBOL to Java:        program-id. phra-rev.\n       data division.\n       working-storage section.\n       1 phrase pic x(28) value \"rosetta code phrase reversal\".\n       1 wk-str pic x(16).\n       1 binary.\n        2 phrase-len pic 9(4).\n        2 pos pic 9(4).\n        2 cnt pic 9(4).\n       procedure division.\n           compute phrase-len = function length (phrase)\n           display phrase\n           display function reverse (phrase)\n           perform display-words\n           move function reverse (phrase) to phrase\n           perform display-words\n           stop run\n           .\n\n       display-words.\n           move 1 to pos\n           perform until pos > phrase-len\n               unstring phrase delimited space\n               into wk-str count in cnt\n               with pointer pos\n               end-unstring\n               display function reverse (wk-str (1:cnt))\n                   with no advancing\n               if pos < phrase-len\n                   display space with no advancing\n               end-if\n           end-perform\n           display space\n           .\n       end program phra-rev.\n", "target": "import java.util.Arrays;\n\npublic class PhraseRev{\n\tprivate static String reverse(String x){\n\t\treturn new StringBuilder(x).reverse().toString();\n\t}\n\t\n\tprivate static <T> T[] reverse(T[] x){\n\t\tT[] rev = Arrays.copyOf(x, x.length);\n\t\tfor(int i = x.length - 1; i >= 0; i--){\n\t\t\trev[x.length - 1 - i] = x[i];\n\t\t}\n\t\treturn rev;\n\t}\n\t\n\tprivate static String join(String[] arr, String joinStr){\n\t\tStringBuilder joined = new StringBuilder();\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tjoined.append(arr[i]);\n\t\t\tif(i < arr.length - 1) joined.append(joinStr);\n\t\t}\n\t\treturn joined.toString();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tString str = \"rosetta code phrase reversal\";\n\t\t\n\t\tSystem.out.println(\"Straight-up reversed: \" + reverse(str));\n\t\tString[] words = str.split(\" \");\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\twords[i] = reverse(words[i]);\n\t\t}\n\t\tSystem.out.println(\"Reversed words: \" + join(words, \" \"));\n\t\tSystem.out.println(\"Reversed word order: \" + join(reverse(str.split(\" \")), \" \"));\n\t}\n}\n"}
{"id": 158039, "name": "Phrase reversals", "source": "Translate COBOL to Python:        program-id. phra-rev.\n       data division.\n       working-storage section.\n       1 phrase pic x(28) value \"rosetta code phrase reversal\".\n       1 wk-str pic x(16).\n       1 binary.\n        2 phrase-len pic 9(4).\n        2 pos pic 9(4).\n        2 cnt pic 9(4).\n       procedure division.\n           compute phrase-len = function length (phrase)\n           display phrase\n           display function reverse (phrase)\n           perform display-words\n           move function reverse (phrase) to phrase\n           perform display-words\n           stop run\n           .\n\n       display-words.\n           move 1 to pos\n           perform until pos > phrase-len\n               unstring phrase delimited space\n               into wk-str count in cnt\n               with pointer pos\n               end-unstring\n               display function reverse (wk-str (1:cnt))\n                   with no advancing\n               if pos < phrase-len\n                   display space with no advancing\n               end-if\n           end-perform\n           display space\n           .\n       end program phra-rev.\n", "target": ">>> phrase = \"rosetta code phrase reversal\"\n>>> phrase[::-1]\t\t\t\t\t  \n'lasrever esarhp edoc attesor'\n>>> ' '.join(word[::-1] for word in phrase.split())\t  \n'attesor edoc esarhp lasrever'\n>>> ' '.join(phrase.split()[::-1])\t                  \n'reversal phrase code rosetta'\n>>>\n"}
{"id": 158363, "name": "Old lady swallowed a fly", "source": "Translate COBOL to C#:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. OLD-LADY.\n\n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n\n        01  LYRICS.\n            03  THERE-WAS       PIC X(38) VALUE\n            \"There was an old lady who swallowed a \".\n            03  SHE-SWALLOWED   PIC X(18) VALUE \"She swallowed the \".\n            03  TO-CATCH        PIC X(14) VALUE \" to catch the \".\n        01  ANIMALS.\n            03  FLY.\n                05  NAME        PIC X(6) VALUE \"fly\".\n                05  VERSE       PIC X(60) VALUE\n            \"I don't know why she swallowed a fly. Perhaps she'll die.\".\n            03  SPIDER.\n                05  NAME        PIC X(6) VALUE \"spider\".\n                05  VERSE       PIC X(60) VALUE\n            \"That wiggled and jiggled and tickled inside her.\".\n            03  BIRD.\n                05  NAME        PIC X(6) VALUE \"bird\".\n                05  VERSE       PIC X(60) VALUE\n            \"How absurd, to swallow a bird.\".\n            03  CAT.\n                05  NAME        PIC X(6) VALUE \"cat\".\n                05  VERSE       PIC X(60) VALUE\n            \"Imagine that, she swallowed a cat.\".\n            03  DOG.\n                05  NAME        PIC X(6) VALUE \"dog\".\n                05  VERSE       PIC X(60) VALUE\n            \"What a hog, to swallow a dog.\".\n            03  GOAT.\n                05  NAME        PIC X(6) VALUE \"goat\".\n                05  VERSE       PIC X(60) VALUE\n            \"She just opened her throat and swallowed that goat.\".\n            03  COW.\n                05  NAME        PIC X(6) VALUE \"cow\".\n                05  VERSE       PIC X(60) VALUE\n            \"I don't know how she swallowed that cow.\".\n            03  HORSE.\n                05  NAME        PIC X(6) VALUE \"horse\".\n                05  VERSE       PIC X(60) VALUE\n            \"She's dead, of course.\".\n        01  ANIMAL-ARRAY REDEFINES ANIMALS.\n            03  ANIMAL OCCURS 8 TIMES.\n                05  NAME        PIC X(6).\n                05  VERSE       PIC X(60).\n        01  MISC.\n            03  LINE-OUT        PIC X(80).\n            03  A-IDX           PIC 9(2).\n            03  S-IDX           PIC 9(2).\n\n        PROCEDURE DIVISION.\n        MAIN SECTION.\n            PERFORM DO-ANIMAL\n                VARYING A-IDX FROM 1 BY 1 UNTIL A-IDX > 8.\n            STOP RUN.\n\n        DO-ANIMAL SECTION.\n            MOVE SPACES TO LINE-OUT.\n            STRING\n                THERE-WAS DELIMITED BY SIZE,\n                NAME OF ANIMAL(A-IDX) DELIMITED BY SPACE,\n                \",\"\n                INTO LINE-OUT\n            END-STRING.\n            DISPLAY LINE-OUT.\n            IF A-IDX > 1 THEN\n                DISPLAY VERSE OF ANIMAL(A-IDX)\n            END-IF.\n            IF A-IDX = 8 THEN\n                EXIT SECTION\n            END-IF.\n            PERFORM DO-SWALLOW \n                VARYING S-IDX FROM A-IDX BY -1 UNTIL S-IDX = 1.\n            DISPLAY VERSE OF ANIMAL(1).\n            DISPLAY SPACES.\n\n        DO-SWALLOW SECTION.\n            MOVE SPACES TO LINE-OUT.\n            STRING\n                SHE-SWALLOWED DELIMITED BY SIZE,\n                NAME OF ANIMAL(S-IDX) DELIMITED BY SPACE,\n                TO-CATCH DELIMITED BY SIZE,\n                NAME OF ANIMAL(S-IDX - 1) DELIMITED BY SPACE\n                INTO LINE-OUT\n            END-STRING.\n            DISPLAY LINE-OUT.\n", "target": "using System;\n\nnamespace OldLady\n{\n    internal class Program\n    {\n        private const string reason = \"She swallowed the {0} to catch the {1}\";\n        private static readonly string[] creatures = {\"fly\", \"spider\", \"bird\", \"cat\", \"dog\", \"goat\", \"cow\", \"horse\"};\n\n        private static readonly string[] comments =\n        {\n            \"I don't know why she swallowed that fly.\\nPerhaps she'll die\\n\",\n            \"That wiggled and jiggled and tickled inside her\",\n            \"How absurd, to swallow a bird\",\n            \"Imagine that. She swallowed a cat\",\n            \"What a hog to swallow a dog\",\n            \"She just opened her throat and swallowed that goat\",\n            \"I don't know how she swallowed that cow\",\n            \"She's dead of course\"\n        };\n\n        private static void Main()\n        {\n            int max = creatures.Length;\n            for (int i = 0; i < max; i++)\n            {\n                Console.WriteLine(\"There was an old lady who swallowed a {0}\", creatures[i]);\n                Console.WriteLine(comments[i]);\n                for (int j = i; j > 0 && i < max - 1; j--)\n                {\n                    Console.WriteLine(reason, creatures[j], creatures[j - 1]);\n                    if (j == 1)\n                    {\n                        Console.WriteLine(comments[j - 1]);\n                    }\n                }\n            }\n            Console.Read();\n        }\n    }\n}\n"}
{"id": 158365, "name": "Old lady swallowed a fly", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. OLD-LADY.\n\n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n\n        01  LYRICS.\n            03  THERE-WAS       PIC X(38) VALUE\n            \"There was an old lady who swallowed a \".\n            03  SHE-SWALLOWED   PIC X(18) VALUE \"She swallowed the \".\n            03  TO-CATCH        PIC X(14) VALUE \" to catch the \".\n        01  ANIMALS.\n            03  FLY.\n                05  NAME        PIC X(6) VALUE \"fly\".\n                05  VERSE       PIC X(60) VALUE\n            \"I don't know why she swallowed a fly. Perhaps she'll die.\".\n            03  SPIDER.\n                05  NAME        PIC X(6) VALUE \"spider\".\n                05  VERSE       PIC X(60) VALUE\n            \"That wiggled and jiggled and tickled inside her.\".\n            03  BIRD.\n                05  NAME        PIC X(6) VALUE \"bird\".\n                05  VERSE       PIC X(60) VALUE\n            \"How absurd, to swallow a bird.\".\n            03  CAT.\n                05  NAME        PIC X(6) VALUE \"cat\".\n                05  VERSE       PIC X(60) VALUE\n            \"Imagine that, she swallowed a cat.\".\n            03  DOG.\n                05  NAME        PIC X(6) VALUE \"dog\".\n                05  VERSE       PIC X(60) VALUE\n            \"What a hog, to swallow a dog.\".\n            03  GOAT.\n                05  NAME        PIC X(6) VALUE \"goat\".\n                05  VERSE       PIC X(60) VALUE\n            \"She just opened her throat and swallowed that goat.\".\n            03  COW.\n                05  NAME        PIC X(6) VALUE \"cow\".\n                05  VERSE       PIC X(60) VALUE\n            \"I don't know how she swallowed that cow.\".\n            03  HORSE.\n                05  NAME        PIC X(6) VALUE \"horse\".\n                05  VERSE       PIC X(60) VALUE\n            \"She's dead, of course.\".\n        01  ANIMAL-ARRAY REDEFINES ANIMALS.\n            03  ANIMAL OCCURS 8 TIMES.\n                05  NAME        PIC X(6).\n                05  VERSE       PIC X(60).\n        01  MISC.\n            03  LINE-OUT        PIC X(80).\n            03  A-IDX           PIC 9(2).\n            03  S-IDX           PIC 9(2).\n\n        PROCEDURE DIVISION.\n        MAIN SECTION.\n            PERFORM DO-ANIMAL\n                VARYING A-IDX FROM 1 BY 1 UNTIL A-IDX > 8.\n            STOP RUN.\n\n        DO-ANIMAL SECTION.\n            MOVE SPACES TO LINE-OUT.\n            STRING\n                THERE-WAS DELIMITED BY SIZE,\n                NAME OF ANIMAL(A-IDX) DELIMITED BY SPACE,\n                \",\"\n                INTO LINE-OUT\n            END-STRING.\n            DISPLAY LINE-OUT.\n            IF A-IDX > 1 THEN\n                DISPLAY VERSE OF ANIMAL(A-IDX)\n            END-IF.\n            IF A-IDX = 8 THEN\n                EXIT SECTION\n            END-IF.\n            PERFORM DO-SWALLOW \n                VARYING S-IDX FROM A-IDX BY -1 UNTIL S-IDX = 1.\n            DISPLAY VERSE OF ANIMAL(1).\n            DISPLAY SPACES.\n\n        DO-SWALLOW SECTION.\n            MOVE SPACES TO LINE-OUT.\n            STRING\n                SHE-SWALLOWED DELIMITED BY SIZE,\n                NAME OF ANIMAL(S-IDX) DELIMITED BY SPACE,\n                TO-CATCH DELIMITED BY SIZE,\n                NAME OF ANIMAL(S-IDX - 1) DELIMITED BY SPACE\n                INTO LINE-OUT\n            END-STRING.\n            DISPLAY LINE-OUT.\n", "target": "public class OldLadySwallowedAFly {\n\n    final static String[] data = {\n        \"_ha _c _e _p,/Quite absurd_f_p;_`cat,/Fancy that_fcat;_j`dog,/What a hog\"\n        + \"_fdog;_l`pig,/Her mouth_qso big_fpig;_d_r,/She just opened her throat_f_\"\n        + \"r;_icow,/_mhow she_ga cow;_k_o,/It_qrather wonky_f_o;_a_o_bcow,_khorse..\"\n        + \"./She's dead, of course!/\", \"_a_p_b_e \", \"/S_t \", \" to catch the \", \"fly,/Bu\"\n        + \"t _mwhy s_t fly,/Perhaps she'll die!\n        + \"t wr_nj_ntickled inside her;_aspider_b_c\", \", to_s a \", \"_sed \", \"There_qan\"\n        + \" old lady who_g\", \"_a_r_bpig,_d\", \"_acat_b_p,_\", \"_acow_b_r,_i\", \"_adog_bcat\"\n        + \",_j\", \"I don't know \", \"iggled and \", \"donkey\", \"bird\", \" was \", \"goat\", \" swal\"\n        + \"low\", \"he_gthe\"};\n\n    static boolean oldLady(String part, boolean s) {\n        for (char c : part.toCharArray()) {\n            if (s)\n                s = oldLady(data[c - '_'], false);\n            else if (c == '_')\n                s = true;\n            else\n                System.out.print(c == '/' ? '\\n' : c);\n        }\n        return s;\n    }\n\n    public static void main(String[] args) {\n        oldLady(data[0], false);\n    }\n}\n"}
{"id": 158366, "name": "Old lady swallowed a fly", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. OLD-LADY.\n\n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n\n        01  LYRICS.\n            03  THERE-WAS       PIC X(38) VALUE\n            \"There was an old lady who swallowed a \".\n            03  SHE-SWALLOWED   PIC X(18) VALUE \"She swallowed the \".\n            03  TO-CATCH        PIC X(14) VALUE \" to catch the \".\n        01  ANIMALS.\n            03  FLY.\n                05  NAME        PIC X(6) VALUE \"fly\".\n                05  VERSE       PIC X(60) VALUE\n            \"I don't know why she swallowed a fly. Perhaps she'll die.\".\n            03  SPIDER.\n                05  NAME        PIC X(6) VALUE \"spider\".\n                05  VERSE       PIC X(60) VALUE\n            \"That wiggled and jiggled and tickled inside her.\".\n            03  BIRD.\n                05  NAME        PIC X(6) VALUE \"bird\".\n                05  VERSE       PIC X(60) VALUE\n            \"How absurd, to swallow a bird.\".\n            03  CAT.\n                05  NAME        PIC X(6) VALUE \"cat\".\n                05  VERSE       PIC X(60) VALUE\n            \"Imagine that, she swallowed a cat.\".\n            03  DOG.\n                05  NAME        PIC X(6) VALUE \"dog\".\n                05  VERSE       PIC X(60) VALUE\n            \"What a hog, to swallow a dog.\".\n            03  GOAT.\n                05  NAME        PIC X(6) VALUE \"goat\".\n                05  VERSE       PIC X(60) VALUE\n            \"She just opened her throat and swallowed that goat.\".\n            03  COW.\n                05  NAME        PIC X(6) VALUE \"cow\".\n                05  VERSE       PIC X(60) VALUE\n            \"I don't know how she swallowed that cow.\".\n            03  HORSE.\n                05  NAME        PIC X(6) VALUE \"horse\".\n                05  VERSE       PIC X(60) VALUE\n            \"She's dead, of course.\".\n        01  ANIMAL-ARRAY REDEFINES ANIMALS.\n            03  ANIMAL OCCURS 8 TIMES.\n                05  NAME        PIC X(6).\n                05  VERSE       PIC X(60).\n        01  MISC.\n            03  LINE-OUT        PIC X(80).\n            03  A-IDX           PIC 9(2).\n            03  S-IDX           PIC 9(2).\n\n        PROCEDURE DIVISION.\n        MAIN SECTION.\n            PERFORM DO-ANIMAL\n                VARYING A-IDX FROM 1 BY 1 UNTIL A-IDX > 8.\n            STOP RUN.\n\n        DO-ANIMAL SECTION.\n            MOVE SPACES TO LINE-OUT.\n            STRING\n                THERE-WAS DELIMITED BY SIZE,\n                NAME OF ANIMAL(A-IDX) DELIMITED BY SPACE,\n                \",\"\n                INTO LINE-OUT\n            END-STRING.\n            DISPLAY LINE-OUT.\n            IF A-IDX > 1 THEN\n                DISPLAY VERSE OF ANIMAL(A-IDX)\n            END-IF.\n            IF A-IDX = 8 THEN\n                EXIT SECTION\n            END-IF.\n            PERFORM DO-SWALLOW \n                VARYING S-IDX FROM A-IDX BY -1 UNTIL S-IDX = 1.\n            DISPLAY VERSE OF ANIMAL(1).\n            DISPLAY SPACES.\n\n        DO-SWALLOW SECTION.\n            MOVE SPACES TO LINE-OUT.\n            STRING\n                SHE-SWALLOWED DELIMITED BY SIZE,\n                NAME OF ANIMAL(S-IDX) DELIMITED BY SPACE,\n                TO-CATCH DELIMITED BY SIZE,\n                NAME OF ANIMAL(S-IDX - 1) DELIMITED BY SPACE\n                INTO LINE-OUT\n            END-STRING.\n            DISPLAY LINE-OUT.\n", "target": "import zlib, base64\n\nb64 = b\nprint(zlib.decompress(base64.b64decode(b64)).decode(\"utf-8\", \"strict\"))\n"}
{"id": 158898, "name": "Integer overflow", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. PROCRUSTES-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-EXAMPLE.\n    05 X            PIC  999.\nPROCEDURE DIVISION.\n    MOVE     1002   TO   X.\n    DISPLAY  X      UPON CONSOLE.\n    STOP RUN.\n", "target": "using System;\n    \npublic class IntegerOverflow\n{\n    public static void Main() {\n        unchecked {\n            Console.WriteLine(\"For 32-bit signed integers:\");\n            Console.WriteLine(-(-2147483647 - 1));\n            Console.WriteLine(2000000000 + 2000000000);\n            Console.WriteLine(-2147483647 - 2147483647);\n            Console.WriteLine(46341 * 46341);\n            Console.WriteLine((-2147483647 - 1) / -1);\n            Console.WriteLine();\n            \n            Console.WriteLine(\"For 64-bit signed integers:\");\n            Console.WriteLine(-(-9223372036854775807L - 1));\n            Console.WriteLine(5000000000000000000L + 5000000000000000000L);\n            Console.WriteLine(-9223372036854775807L - 9223372036854775807L);\n            Console.WriteLine(3037000500L * 3037000500L);\n            Console.WriteLine((-9223372036854775807L - 1) / -1);\n            Console.WriteLine();\n\n            Console.WriteLine(\"For 32-bit unsigned integers:\");\n            \n            Console.WriteLine(-4294967295U);\n            Console.WriteLine(3000000000U + 3000000000U);\n            Console.WriteLine(2147483647U - 4294967295U);\n            Console.WriteLine(65537U * 65537U);\n            Console.WriteLine();\n\n            Console.WriteLine(\"For 64-bit unsigned integers:\");\n            \n            \n            Console.WriteLine(10000000000000000000UL + 10000000000000000000UL);\n            Console.WriteLine(9223372036854775807UL - 18446744073709551615UL);\n            Console.WriteLine(4294967296UL * 4294967296UL);\n            Console.WriteLine();\n        }\n        \n        int i = 2147483647;\n        Console.WriteLine(i + 1);\n        try {\n            checked { Console.WriteLine(i + 1); }\n        } catch (OverflowException) {\n            Console.WriteLine(\"Overflow!\");\n        }\n    }\n    \n}\n"}
{"id": 158900, "name": "Integer overflow", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. PROCRUSTES-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-EXAMPLE.\n    05 X            PIC  999.\nPROCEDURE DIVISION.\n    MOVE     1002   TO   X.\n    DISPLAY  X      UPON CONSOLE.\n    STOP RUN.\n", "target": "public class IntegerOverflow {\n    public static void main(String[] args) {\n        System.out.println(\"Signed 32-bit:\");\n        System.out.println(-(-2147483647 - 1));\n        System.out.println(2000000000 + 2000000000);\n        System.out.println(-2147483647 - 2147483647);\n        System.out.println(46341 * 46341);\n        System.out.println((-2147483647 - 1) / -1);\n        System.out.println(\"Signed 64-bit:\");\n        System.out.println(-(-9223372036854775807L - 1));\n        System.out.println(5000000000000000000L + 5000000000000000000L);\n        System.out.println(-9223372036854775807L - 9223372036854775807L);\n        System.out.println(3037000500L * 3037000500L);\n        System.out.println((-9223372036854775807L - 1) / -1);\n    }\n}\n"}
{"id": 158901, "name": "Integer overflow", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. PROCRUSTES-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-EXAMPLE.\n    05 X            PIC  999.\nPROCEDURE DIVISION.\n    MOVE     1002   TO   X.\n    DISPLAY  X      UPON CONSOLE.\n    STOP RUN.\n", "target": "Python 2.7.5 (default, May 15 2013, 22:43:36) [MSC v.1500 32 bit (Intel)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> for calc in .split('\\n'):\n\tans = eval(calc)\n\tprint('Expression: %r evaluates to %s of type %s'\n\t      % (calc.strip(), ans, type(ans)))\n\n\t\nExpression: '-(-2147483647-1)' evaluates to 2147483648 of type <type 'long'>\nExpression: '2000000000 + 2000000000' evaluates to 4000000000 of type <type 'long'>\nExpression: '-2147483647 - 2147483647' evaluates to -4294967294 of type <type 'long'>\nExpression: '46341 * 46341' evaluates to 2147488281 of type <type 'long'>\nExpression: '(-2147483647-1) / -1' evaluates to 2147483648 of type <type 'long'>\n>>>\n"}
{"id": 160726, "name": "Subleq", "source": "Translate COBOL to C#: identification division.\nprogram-id. subleq-program.\ndata division.\nworking-storage section.\n01  subleq-source-code.\n    05 source-string                      pic x(2000).\n01  subleq-virtual-machine.\n    05 memory-table.\n        10 memory                         pic s9999\n            occurs 500 times.\n    05 a                                  pic s9999.\n    05 b                                  pic s9999.\n    05 c                                  pic s9999.\n    05 instruction-pointer                pic s9999.\n    05 input-output-character             pic x.\n01  working-variables.\n    05 loop-counter                       pic 9999.\n    05 instruction-counter                pic 9999.\n    05 string-pointer                     pic 9999.\n    05 adjusted-index-a                   pic 9999.\n    05 adjusted-index-b                   pic 9999.\n    05 output-character-code              pic 9999.\nprocedure division.\nread-source-paragraph.\n    accept source-string from console.\n    display 'READING SUBLEQ PROGRAM... ' with no advancing.\n    move 1 to string-pointer.\n    move 0 to instruction-counter.\n    perform split-source-paragraph varying loop-counter from 1 by 1\n        until loop-counter is greater than 500\n        or string-pointer is greater than 2000.\n    display instruction-counter with no advancing.\n    display ' WORDS READ.'.\nexecute-paragraph.\n    move 1 to instruction-pointer.\n    move 0 to instruction-counter.\n    display 'BEGINNING RUN... '.\n    display ''.\n    perform execute-instruction-paragraph\n        until instruction-pointer is negative.\n    display ''.\n    display 'HALTED AFTER ' instruction-counter ' INSTRUCTIONS.'.\n    stop run.\nexecute-instruction-paragraph.\n    add 1 to instruction-counter.\n    move memory(instruction-pointer) to a.\n    add 1 to instruction-pointer.\n    move memory(instruction-pointer) to b.\n    add 1 to instruction-pointer.\n    move memory(instruction-pointer) to c.\n    add 1 to instruction-pointer.\n    if a is equal to -1 then perform input-paragraph.\n    if b is equal to -1 then perform output-paragraph.\n    if a is not equal to -1 and b is not equal to -1\n        then perform subtraction-paragraph.\nsplit-source-paragraph.\n    unstring source-string delimited by all spaces\n        into memory(loop-counter)\n        with pointer string-pointer.\n    add 1 to instruction-counter.\ninput-paragraph.\n    display '> ' with no advancing.\n    accept input-output-character from console.\n    add 1 to b giving adjusted-index-b.\n    move function ord(input-output-character)\n        to memory(adjusted-index-b).\n    subtract 1 from memory(adjusted-index-b).\noutput-paragraph.\n    add 1 to a giving adjusted-index-a.\n    add 1 to memory(adjusted-index-a) giving output-character-code.\n    move function char(output-character-code)\n        to input-output-character.\n    display input-output-character with no advancing.\nsubtraction-paragraph.\n    add 1 to c.\n    add 1 to a giving adjusted-index-a.\n    add 1 to b giving adjusted-index-b.\n    subtract memory(adjusted-index-a) from memory(adjusted-index-b).\n    if memory(adjusted-index-b) is equal to zero\n        or memory(adjusted-index-b) is negative\n        then move c to instruction-pointer.\n", "target": "using System;\n\nnamespace Subleq {\n    class Program {\n        static void Main(string[] args) {\n            int[] mem = {\n                15, 17, -1, 17, -1, -1, 16, 1, -1, 16,\n                3, -1, 15, 15, 0, 0, -1, 72, 101, 108,\n                108, 111, 44, 32, 119, 111, 114, 108, 100, 33,\n                10, 0,\n            };\n\n            int instructionPointer = 0;\n\n            do {\n                int a = mem[instructionPointer];\n                int b = mem[instructionPointer + 1];\n\n                if (a == -1) {\n                    mem[b] = Console.Read();\n                }\n                else if (b == -1) {\n                    Console.Write((char)mem[a]);\n                }\n                else {\n                    mem[b] -= mem[a];\n                    if (mem[b] < 1) {\n                        instructionPointer = mem[instructionPointer + 2];\n                        continue;\n                    }\n                }\n\n                instructionPointer += 3;\n            } while (instructionPointer >= 0);\n        }\n    }\n}\n"}
{"id": 160728, "name": "Subleq", "source": "Translate COBOL to Java: identification division.\nprogram-id. subleq-program.\ndata division.\nworking-storage section.\n01  subleq-source-code.\n    05 source-string                      pic x(2000).\n01  subleq-virtual-machine.\n    05 memory-table.\n        10 memory                         pic s9999\n            occurs 500 times.\n    05 a                                  pic s9999.\n    05 b                                  pic s9999.\n    05 c                                  pic s9999.\n    05 instruction-pointer                pic s9999.\n    05 input-output-character             pic x.\n01  working-variables.\n    05 loop-counter                       pic 9999.\n    05 instruction-counter                pic 9999.\n    05 string-pointer                     pic 9999.\n    05 adjusted-index-a                   pic 9999.\n    05 adjusted-index-b                   pic 9999.\n    05 output-character-code              pic 9999.\nprocedure division.\nread-source-paragraph.\n    accept source-string from console.\n    display 'READING SUBLEQ PROGRAM... ' with no advancing.\n    move 1 to string-pointer.\n    move 0 to instruction-counter.\n    perform split-source-paragraph varying loop-counter from 1 by 1\n        until loop-counter is greater than 500\n        or string-pointer is greater than 2000.\n    display instruction-counter with no advancing.\n    display ' WORDS READ.'.\nexecute-paragraph.\n    move 1 to instruction-pointer.\n    move 0 to instruction-counter.\n    display 'BEGINNING RUN... '.\n    display ''.\n    perform execute-instruction-paragraph\n        until instruction-pointer is negative.\n    display ''.\n    display 'HALTED AFTER ' instruction-counter ' INSTRUCTIONS.'.\n    stop run.\nexecute-instruction-paragraph.\n    add 1 to instruction-counter.\n    move memory(instruction-pointer) to a.\n    add 1 to instruction-pointer.\n    move memory(instruction-pointer) to b.\n    add 1 to instruction-pointer.\n    move memory(instruction-pointer) to c.\n    add 1 to instruction-pointer.\n    if a is equal to -1 then perform input-paragraph.\n    if b is equal to -1 then perform output-paragraph.\n    if a is not equal to -1 and b is not equal to -1\n        then perform subtraction-paragraph.\nsplit-source-paragraph.\n    unstring source-string delimited by all spaces\n        into memory(loop-counter)\n        with pointer string-pointer.\n    add 1 to instruction-counter.\ninput-paragraph.\n    display '> ' with no advancing.\n    accept input-output-character from console.\n    add 1 to b giving adjusted-index-b.\n    move function ord(input-output-character)\n        to memory(adjusted-index-b).\n    subtract 1 from memory(adjusted-index-b).\noutput-paragraph.\n    add 1 to a giving adjusted-index-a.\n    add 1 to memory(adjusted-index-a) giving output-character-code.\n    move function char(output-character-code)\n        to input-output-character.\n    display input-output-character with no advancing.\nsubtraction-paragraph.\n    add 1 to c.\n    add 1 to a giving adjusted-index-a.\n    add 1 to b giving adjusted-index-b.\n    subtract memory(adjusted-index-a) from memory(adjusted-index-b).\n    if memory(adjusted-index-b) is equal to zero\n        or memory(adjusted-index-b) is negative\n        then move c to instruction-pointer.\n", "target": "import java.util.Scanner;\n\npublic class Subleq {\n\n    public static void main(String[] args) {\n        int[] mem = {15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15, 0, 0,\n            -1, 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 10, 0};\n\n        Scanner input = new Scanner(System.in);\n        int instructionPointer = 0;\n\n        do {\n            int a = mem[instructionPointer];\n            int b = mem[instructionPointer + 1];\n\n            if (a == -1) {\n                mem[b] = input.nextInt();\n\n            } else if (b == -1) {\n                System.out.printf(\"%c\", (char) mem[a]);\n\n            } else {\n\n                mem[b] -= mem[a];\n                if (mem[b] < 1) {\n                    instructionPointer = mem[instructionPointer + 2];\n                    continue;\n                }\n            }\n\n            instructionPointer += 3;\n\n        } while (instructionPointer >= 0);\n    }\n}\n"}
{"id": 160729, "name": "Subleq", "source": "Translate COBOL to Python: identification division.\nprogram-id. subleq-program.\ndata division.\nworking-storage section.\n01  subleq-source-code.\n    05 source-string                      pic x(2000).\n01  subleq-virtual-machine.\n    05 memory-table.\n        10 memory                         pic s9999\n            occurs 500 times.\n    05 a                                  pic s9999.\n    05 b                                  pic s9999.\n    05 c                                  pic s9999.\n    05 instruction-pointer                pic s9999.\n    05 input-output-character             pic x.\n01  working-variables.\n    05 loop-counter                       pic 9999.\n    05 instruction-counter                pic 9999.\n    05 string-pointer                     pic 9999.\n    05 adjusted-index-a                   pic 9999.\n    05 adjusted-index-b                   pic 9999.\n    05 output-character-code              pic 9999.\nprocedure division.\nread-source-paragraph.\n    accept source-string from console.\n    display 'READING SUBLEQ PROGRAM... ' with no advancing.\n    move 1 to string-pointer.\n    move 0 to instruction-counter.\n    perform split-source-paragraph varying loop-counter from 1 by 1\n        until loop-counter is greater than 500\n        or string-pointer is greater than 2000.\n    display instruction-counter with no advancing.\n    display ' WORDS READ.'.\nexecute-paragraph.\n    move 1 to instruction-pointer.\n    move 0 to instruction-counter.\n    display 'BEGINNING RUN... '.\n    display ''.\n    perform execute-instruction-paragraph\n        until instruction-pointer is negative.\n    display ''.\n    display 'HALTED AFTER ' instruction-counter ' INSTRUCTIONS.'.\n    stop run.\nexecute-instruction-paragraph.\n    add 1 to instruction-counter.\n    move memory(instruction-pointer) to a.\n    add 1 to instruction-pointer.\n    move memory(instruction-pointer) to b.\n    add 1 to instruction-pointer.\n    move memory(instruction-pointer) to c.\n    add 1 to instruction-pointer.\n    if a is equal to -1 then perform input-paragraph.\n    if b is equal to -1 then perform output-paragraph.\n    if a is not equal to -1 and b is not equal to -1\n        then perform subtraction-paragraph.\nsplit-source-paragraph.\n    unstring source-string delimited by all spaces\n        into memory(loop-counter)\n        with pointer string-pointer.\n    add 1 to instruction-counter.\ninput-paragraph.\n    display '> ' with no advancing.\n    accept input-output-character from console.\n    add 1 to b giving adjusted-index-b.\n    move function ord(input-output-character)\n        to memory(adjusted-index-b).\n    subtract 1 from memory(adjusted-index-b).\noutput-paragraph.\n    add 1 to a giving adjusted-index-a.\n    add 1 to memory(adjusted-index-a) giving output-character-code.\n    move function char(output-character-code)\n        to input-output-character.\n    display input-output-character with no advancing.\nsubtraction-paragraph.\n    add 1 to c.\n    add 1 to a giving adjusted-index-a.\n    add 1 to b giving adjusted-index-b.\n    subtract memory(adjusted-index-a) from memory(adjusted-index-b).\n    if memory(adjusted-index-b) is equal to zero\n        or memory(adjusted-index-b) is negative\n        then move c to instruction-pointer.\n", "target": "import sys\n\ndef subleq(a):\n    i = 0\n    try:\n        while i >= 0:\n            if a[i] == -1:\n                a[a[i + 1]] = ord(sys.stdin.read(1))\n            elif a[i + 1] == -1:\n                print(chr(a[a[i]]), end=\"\")\n            else:\n                a[a[i + 1]] -= a[a[i]]\n                if a[a[i + 1]] <= 0:\n                    i = a[i + 2]\n                    continue\n            i += 3\n    except (ValueError, IndexError, KeyboardInterrupt):\n        print(\"abort\")\n        print(a)\n\nsubleq([15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15,\n        0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111,\n        114, 108, 100, 33, 10, 0])\n"}
{"id": 161103, "name": "Range extraction", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. extract-range-task.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  data-str                PIC X(200) VALUE \"0,  1,  2,  4,  6,\"\n           & \" 7,  8, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, \"\n           & \"24, 25, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39\".\n \n       01  result                  PIC X(200).\n \n       PROCEDURE DIVISION.\n           CALL \"extract-range\" USING CONTENT data-str, REFERENCE result\n           DISPLAY FUNCTION TRIM(result)\n \n           GOBACK\n           .\n       END PROGRAM extract-range-task.\n \n \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. extract-range.\n \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       COPY \"nums-table.cpy\".\n \n       01  difference              PIC 999.\n \n       01  rng-begin               PIC S999.\n       01  rng-end                 PIC S999.\n \n       01  num-trailing            PIC 999.\n \n       01  trailing-comma-pos      PIC 999.\n\n       LINKAGE SECTION.\n       01  nums-str                PIC X(200).\n       01  extracted-range         PIC X(200).\n \n       01  extracted-range-len     CONSTANT LENGTH extracted-range.\n\n       PROCEDURE DIVISION USING nums-str, extracted-range.\n           CALL \"split-nums\" USING CONTENT nums-str, \", \",\n               REFERENCE nums-table\n \n           \n           MOVE nums (1) TO rng-begin\n           PERFORM VARYING nums-idx FROM 2 BY 1\n                   UNTIL num-nums < nums-idx\n               SUBTRACT nums (nums-idx - 1) FROM nums (nums-idx)\n                   GIVING difference\n \n               \n               \n               IF difference > 1\n                   MOVE nums (nums-idx - 1) TO rng-end\n                   CALL \"add-next-range\" USING CONTENT rng-begin,\n                       rng-end, REFERENCE extracted-range\n                   MOVE nums (nums-idx) TO rng-begin\n               END-IF\n           END-PERFORM\n \n           \n           MOVE nums (num-nums) TO rng-end\n           CALL \"add-next-range\" USING CONTENT rng-begin,\n               rng-end, REFERENCE extracted-range\n \n           \n           CALL \"find-num-trailing-spaces\"\n               USING CONTENT extracted-range, REFERENCE num-trailing\n           COMPUTE trailing-comma-pos =\n               extracted-range-len - num-trailing\n           MOVE SPACE TO extracted-range (trailing-comma-pos:1)\n \n           GOBACK\n           .\n \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. split-nums INITIAL.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  num-len                 PIC 9.\n       01  next-num-pos            PIC 999.\n \n       LINKAGE SECTION.\n       01  str                     PIC X(200).\n       01  delim                   PIC X ANY LENGTH.\n \n       COPY \"nums-table.cpy\".\n \n       PROCEDURE DIVISION USING str, delim, nums-table.\n           INITIALIZE num-nums\n \n           PERFORM UNTIL str = SPACES\n               INITIALIZE num-len\n               INSPECT str TALLYING num-len FOR CHARACTERS BEFORE delim\n \n               ADD 1 TO num-nums\n \n               \n               \n               \n               IF num-len = 0 \n                   MOVE str TO nums (num-nums)\n                   EXIT PERFORM\n               ELSE\n                   MOVE str (1:num-len) TO nums (num-nums)\n                   ADD 3 TO num-len GIVING next-num-pos\n                   MOVE str (next-num-pos:) TO str\n               END-IF\n           END-PERFORM\n           .\n       END PROGRAM split-nums.\n \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. add-next-range INITIAL.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  num-trailing            PIC 999.\n       01  start-pos               PIC 999.\n \n       01  range-len               PIC 999.\n \n       01  begin-edited            PIC -ZZ9.\n       01  end-edited              PIC -ZZ9.\n\n       LINKAGE SECTION.\n       01  rng-begin               PIC S999.\n       01  rng-end                 PIC S999.\n \n       01  extracted-range         PIC X(200).\n\n       01  extracted-range-len     CONSTANT LENGTH extracted-range.\n \n       PROCEDURE DIVISION USING rng-begin, rng-end, extracted-range.\n           CALL \"find-num-trailing-spaces\"\n               USING CONTENT extracted-range, REFERENCE num-trailing\n           COMPUTE start-pos = extracted-range-len - num-trailing + 1\n \n           SUBTRACT rng-begin FROM rng-end GIVING range-len\n \n           MOVE rng-begin TO begin-edited\n           MOVE rng-end TO end-edited\n\n           EVALUATE TRUE\n               WHEN rng-begin = rng-end\n                   STRING FUNCTION TRIM(begin-edited), \",\"\n                       INTO extracted-range (start-pos:)\n \n               WHEN range-len = 1\n                   STRING FUNCTION TRIM(begin-edited), \",\",\n                       FUNCTION TRIM(end-edited), \",\"\n                       INTO extracted-range (start-pos:)\n \n               WHEN OTHER\n                   STRING FUNCTION TRIM(begin-edited), \"-\",\n                         FUNCTION TRIM(end-edited), \",\"\n                         INTO extracted-range (start-pos:)\n           END-EVALUATE\n           .\n       END PROGRAM add-next-range.\n \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. find-num-trailing-spaces.\n \n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  str                     PIC X(200).\n       01  num-trailing            PIC 999.\n \n       PROCEDURE DIVISION USING str, num-trailing.\n           INITIALIZE num-trailing\n           INSPECT str TALLYING num-trailing FOR TRAILING SPACES\n           .\n       END PROGRAM find-num-trailing-spaces.\n \n       END PROGRAM extract-range.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass RangeExtraction\n{\n    static void Main()\n    {\n        const string testString = \"0,  1,  2,  4,  6,  7,  8, 11, 12, 14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24,25, 27, 28, 29, 30, 31, 32, 33, 35, 36,37, 38, 39\";\n        var result = String.Join(\",\", RangesToStrings(GetRanges(testString)));\n        Console.Out.WriteLine(result);\n    }\n\n    public static IEnumerable<IEnumerable<int>> GetRanges(string testString)\n    {\n        var numbers = testString.Split(new[] { ',' }).Select(x => Convert.ToInt32(x));\n        var current = new List<int>();\n        foreach (var n in numbers)\n        {\n            if (current.Count == 0)\n            {\n                current.Add(n);\n            }\n            else\n            {\n                if (current.Max() + 1 == n)\n                {\n                    current.Add(n);\n                }\n                else\n                {\n                    yield return current;\n                    current = new List<int> { n };\n                }\n            }\n        }\n        yield return current;\n    }\n\n    public static IEnumerable<string> RangesToStrings(IEnumerable<IEnumerable<int>> ranges)\n    {\n        foreach (var range in ranges)\n        {\n            if (range.Count() == 1)\n            {\n                yield return range.Single().ToString();\n            }\n            else if (range.Count() == 2)\n            {\n                yield return range.Min() + \",\" + range.Max();\n            }\n            else\n            {\n                yield return range.Min() + \"-\" + range.Max();\n            }\n        }\n    }\n}\n"}
{"id": 161105, "name": "Range extraction", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. extract-range-task.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  data-str                PIC X(200) VALUE \"0,  1,  2,  4,  6,\"\n           & \" 7,  8, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, \"\n           & \"24, 25, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39\".\n \n       01  result                  PIC X(200).\n \n       PROCEDURE DIVISION.\n           CALL \"extract-range\" USING CONTENT data-str, REFERENCE result\n           DISPLAY FUNCTION TRIM(result)\n \n           GOBACK\n           .\n       END PROGRAM extract-range-task.\n \n \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. extract-range.\n \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       COPY \"nums-table.cpy\".\n \n       01  difference              PIC 999.\n \n       01  rng-begin               PIC S999.\n       01  rng-end                 PIC S999.\n \n       01  num-trailing            PIC 999.\n \n       01  trailing-comma-pos      PIC 999.\n\n       LINKAGE SECTION.\n       01  nums-str                PIC X(200).\n       01  extracted-range         PIC X(200).\n \n       01  extracted-range-len     CONSTANT LENGTH extracted-range.\n\n       PROCEDURE DIVISION USING nums-str, extracted-range.\n           CALL \"split-nums\" USING CONTENT nums-str, \", \",\n               REFERENCE nums-table\n \n           \n           MOVE nums (1) TO rng-begin\n           PERFORM VARYING nums-idx FROM 2 BY 1\n                   UNTIL num-nums < nums-idx\n               SUBTRACT nums (nums-idx - 1) FROM nums (nums-idx)\n                   GIVING difference\n \n               \n               \n               IF difference > 1\n                   MOVE nums (nums-idx - 1) TO rng-end\n                   CALL \"add-next-range\" USING CONTENT rng-begin,\n                       rng-end, REFERENCE extracted-range\n                   MOVE nums (nums-idx) TO rng-begin\n               END-IF\n           END-PERFORM\n \n           \n           MOVE nums (num-nums) TO rng-end\n           CALL \"add-next-range\" USING CONTENT rng-begin,\n               rng-end, REFERENCE extracted-range\n \n           \n           CALL \"find-num-trailing-spaces\"\n               USING CONTENT extracted-range, REFERENCE num-trailing\n           COMPUTE trailing-comma-pos =\n               extracted-range-len - num-trailing\n           MOVE SPACE TO extracted-range (trailing-comma-pos:1)\n \n           GOBACK\n           .\n \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. split-nums INITIAL.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  num-len                 PIC 9.\n       01  next-num-pos            PIC 999.\n \n       LINKAGE SECTION.\n       01  str                     PIC X(200).\n       01  delim                   PIC X ANY LENGTH.\n \n       COPY \"nums-table.cpy\".\n \n       PROCEDURE DIVISION USING str, delim, nums-table.\n           INITIALIZE num-nums\n \n           PERFORM UNTIL str = SPACES\n               INITIALIZE num-len\n               INSPECT str TALLYING num-len FOR CHARACTERS BEFORE delim\n \n               ADD 1 TO num-nums\n \n               \n               \n               \n               IF num-len = 0 \n                   MOVE str TO nums (num-nums)\n                   EXIT PERFORM\n               ELSE\n                   MOVE str (1:num-len) TO nums (num-nums)\n                   ADD 3 TO num-len GIVING next-num-pos\n                   MOVE str (next-num-pos:) TO str\n               END-IF\n           END-PERFORM\n           .\n       END PROGRAM split-nums.\n \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. add-next-range INITIAL.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  num-trailing            PIC 999.\n       01  start-pos               PIC 999.\n \n       01  range-len               PIC 999.\n \n       01  begin-edited            PIC -ZZ9.\n       01  end-edited              PIC -ZZ9.\n\n       LINKAGE SECTION.\n       01  rng-begin               PIC S999.\n       01  rng-end                 PIC S999.\n \n       01  extracted-range         PIC X(200).\n\n       01  extracted-range-len     CONSTANT LENGTH extracted-range.\n \n       PROCEDURE DIVISION USING rng-begin, rng-end, extracted-range.\n           CALL \"find-num-trailing-spaces\"\n               USING CONTENT extracted-range, REFERENCE num-trailing\n           COMPUTE start-pos = extracted-range-len - num-trailing + 1\n \n           SUBTRACT rng-begin FROM rng-end GIVING range-len\n \n           MOVE rng-begin TO begin-edited\n           MOVE rng-end TO end-edited\n\n           EVALUATE TRUE\n               WHEN rng-begin = rng-end\n                   STRING FUNCTION TRIM(begin-edited), \",\"\n                       INTO extracted-range (start-pos:)\n \n               WHEN range-len = 1\n                   STRING FUNCTION TRIM(begin-edited), \",\",\n                       FUNCTION TRIM(end-edited), \",\"\n                       INTO extracted-range (start-pos:)\n \n               WHEN OTHER\n                   STRING FUNCTION TRIM(begin-edited), \"-\",\n                         FUNCTION TRIM(end-edited), \",\"\n                         INTO extracted-range (start-pos:)\n           END-EVALUATE\n           .\n       END PROGRAM add-next-range.\n \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. find-num-trailing-spaces.\n \n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  str                     PIC X(200).\n       01  num-trailing            PIC 999.\n \n       PROCEDURE DIVISION USING str, num-trailing.\n           INITIALIZE num-trailing\n           INSPECT str TALLYING num-trailing FOR TRAILING SPACES\n           .\n       END PROGRAM find-num-trailing-spaces.\n \n       END PROGRAM extract-range.\n", "target": "public class RangeExtraction {\n\n    public static void main(String[] args) {\n        int[] arr = {0, 1, 2, 4, 6, 7, 8, 11, 12, 14,\n            15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 27, 28, 29, 30, 31, 32, 33, 35, 36,\n            37, 38, 39};\n\n        int len = arr.length;\n        int idx = 0, idx2 = 0;\n        while (idx < len) {\n            while (++idx2 < len && arr[idx2] - arr[idx2 - 1] == 1);\n            if (idx2 - idx > 2) {\n                System.out.printf(\"%s-%s,\", arr[idx], arr[idx2 - 1]);\n                idx = idx2;\n            } else {\n                for (; idx < idx2; idx++)\n                    System.out.printf(\"%s,\", arr[idx]);\n            }\n        }\n    }\n}\n"}
{"id": 161106, "name": "Range extraction", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. extract-range-task.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  data-str                PIC X(200) VALUE \"0,  1,  2,  4,  6,\"\n           & \" 7,  8, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, \"\n           & \"24, 25, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39\".\n \n       01  result                  PIC X(200).\n \n       PROCEDURE DIVISION.\n           CALL \"extract-range\" USING CONTENT data-str, REFERENCE result\n           DISPLAY FUNCTION TRIM(result)\n \n           GOBACK\n           .\n       END PROGRAM extract-range-task.\n \n \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. extract-range.\n \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       COPY \"nums-table.cpy\".\n \n       01  difference              PIC 999.\n \n       01  rng-begin               PIC S999.\n       01  rng-end                 PIC S999.\n \n       01  num-trailing            PIC 999.\n \n       01  trailing-comma-pos      PIC 999.\n\n       LINKAGE SECTION.\n       01  nums-str                PIC X(200).\n       01  extracted-range         PIC X(200).\n \n       01  extracted-range-len     CONSTANT LENGTH extracted-range.\n\n       PROCEDURE DIVISION USING nums-str, extracted-range.\n           CALL \"split-nums\" USING CONTENT nums-str, \", \",\n               REFERENCE nums-table\n \n           \n           MOVE nums (1) TO rng-begin\n           PERFORM VARYING nums-idx FROM 2 BY 1\n                   UNTIL num-nums < nums-idx\n               SUBTRACT nums (nums-idx - 1) FROM nums (nums-idx)\n                   GIVING difference\n \n               \n               \n               IF difference > 1\n                   MOVE nums (nums-idx - 1) TO rng-end\n                   CALL \"add-next-range\" USING CONTENT rng-begin,\n                       rng-end, REFERENCE extracted-range\n                   MOVE nums (nums-idx) TO rng-begin\n               END-IF\n           END-PERFORM\n \n           \n           MOVE nums (num-nums) TO rng-end\n           CALL \"add-next-range\" USING CONTENT rng-begin,\n               rng-end, REFERENCE extracted-range\n \n           \n           CALL \"find-num-trailing-spaces\"\n               USING CONTENT extracted-range, REFERENCE num-trailing\n           COMPUTE trailing-comma-pos =\n               extracted-range-len - num-trailing\n           MOVE SPACE TO extracted-range (trailing-comma-pos:1)\n \n           GOBACK\n           .\n \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. split-nums INITIAL.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  num-len                 PIC 9.\n       01  next-num-pos            PIC 999.\n \n       LINKAGE SECTION.\n       01  str                     PIC X(200).\n       01  delim                   PIC X ANY LENGTH.\n \n       COPY \"nums-table.cpy\".\n \n       PROCEDURE DIVISION USING str, delim, nums-table.\n           INITIALIZE num-nums\n \n           PERFORM UNTIL str = SPACES\n               INITIALIZE num-len\n               INSPECT str TALLYING num-len FOR CHARACTERS BEFORE delim\n \n               ADD 1 TO num-nums\n \n               \n               \n               \n               IF num-len = 0 \n                   MOVE str TO nums (num-nums)\n                   EXIT PERFORM\n               ELSE\n                   MOVE str (1:num-len) TO nums (num-nums)\n                   ADD 3 TO num-len GIVING next-num-pos\n                   MOVE str (next-num-pos:) TO str\n               END-IF\n           END-PERFORM\n           .\n       END PROGRAM split-nums.\n \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. add-next-range INITIAL.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  num-trailing            PIC 999.\n       01  start-pos               PIC 999.\n \n       01  range-len               PIC 999.\n \n       01  begin-edited            PIC -ZZ9.\n       01  end-edited              PIC -ZZ9.\n\n       LINKAGE SECTION.\n       01  rng-begin               PIC S999.\n       01  rng-end                 PIC S999.\n \n       01  extracted-range         PIC X(200).\n\n       01  extracted-range-len     CONSTANT LENGTH extracted-range.\n \n       PROCEDURE DIVISION USING rng-begin, rng-end, extracted-range.\n           CALL \"find-num-trailing-spaces\"\n               USING CONTENT extracted-range, REFERENCE num-trailing\n           COMPUTE start-pos = extracted-range-len - num-trailing + 1\n \n           SUBTRACT rng-begin FROM rng-end GIVING range-len\n \n           MOVE rng-begin TO begin-edited\n           MOVE rng-end TO end-edited\n\n           EVALUATE TRUE\n               WHEN rng-begin = rng-end\n                   STRING FUNCTION TRIM(begin-edited), \",\"\n                       INTO extracted-range (start-pos:)\n \n               WHEN range-len = 1\n                   STRING FUNCTION TRIM(begin-edited), \",\",\n                       FUNCTION TRIM(end-edited), \",\"\n                       INTO extracted-range (start-pos:)\n \n               WHEN OTHER\n                   STRING FUNCTION TRIM(begin-edited), \"-\",\n                         FUNCTION TRIM(end-edited), \",\"\n                         INTO extracted-range (start-pos:)\n           END-EVALUATE\n           .\n       END PROGRAM add-next-range.\n \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. find-num-trailing-spaces.\n \n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  str                     PIC X(200).\n       01  num-trailing            PIC 999.\n \n       PROCEDURE DIVISION USING str, num-trailing.\n           INITIALIZE num-trailing\n           INSPECT str TALLYING num-trailing FOR TRAILING SPACES\n           .\n       END PROGRAM find-num-trailing-spaces.\n \n       END PROGRAM extract-range.\n", "target": "def range_extract(lst):\n    'Yield 2-tuple ranges or 1-tuple single elements from list of increasing ints'\n    lenlst = len(lst)\n    i = 0\n    while i< lenlst:\n        low = lst[i]\n        while i <lenlst-1 and lst[i]+1 == lst[i+1]: i +=1\n        hi = lst[i]\n        if   hi - low >= 2:\n            yield (low, hi)\n        elif hi - low == 1:\n            yield (low,)\n            yield (hi,)\n        else:\n            yield (low,)\n        i += 1\n\ndef printr(ranges):\n    print( ','.join( (('%i-%i' % r) if len(r) == 2 else '%i' % r)\n                     for r in ranges ) )\n\nif __name__ == '__main__':\n    for lst in [[-8, -7, -6, -3, -2, -1, 0, 1, 3, 4, 5, 7,\n                 8, 9, 10, 11, 14, 15, 17, 18, 19, 20],\n                [0, 1, 2, 4, 6, 7, 8, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n                 23, 24, 25, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39]]:\n        \n        printr(range_extract(lst))\n"}
{"id": 161682, "name": "Reverse words in a string", "source": "Translate COBOL to C#:        program-id. rev-word.\n       data division.\n       working-storage section.\n       1 text-block.\n        2 pic x(36) value \"---------- Ice and Fire ------------\".\n        2 pic x(36) value \"                                    \".\n        2 pic x(36) value \"fire, in end will world the say Some\".\n        2 pic x(36) value \"ice. in say Some                    \".\n        2 pic x(36) value \"desire of tasted I've what From     \".\n        2 pic x(36) value \"fire. favor who those with hold I   \".\n        2 pic x(36) value \"                                    \".\n        2 pic x(36) value \"... elided paragraph last ...       \".\n        2 pic x(36) value \"                                    \".\n        2 pic x(36) value \"Frost Robert -----------------------\".\n       1 redefines text-block.\n        2 occurs 10.\n         3 text-line pic x(36).\n       1 text-word.\n        2 wk-len binary pic 9(4).\n        2 wk-word pic x(36).\n       1 word-stack.\n        2 occurs 10.\n         3 word-entry.\n          4 word-len binary pic 9(4).\n          4 word pic x(36).\n       1 binary.\n        2 i pic 9(4).\n        2 pos pic 9(4).\n        2 word-stack-ptr pic 9(4).\n\n       procedure division.\n           perform varying i from 1 by 1\n           until i > 10\n               perform push-words\n               perform pop-words\n           end-perform\n           stop run\n           .\n\n       push-words.\n           move 1 to pos\n           move 0 to word-stack-ptr\n           perform until pos > 36\n               unstring text-line (i) delimited by all space\n               into wk-word count in wk-len\n               pointer pos\n               end-unstring\n               add 1 to word-stack-ptr\n               move text-word to word-entry (word-stack-ptr)\n           end-perform\n           .\n\n       pop-words.\n           perform varying word-stack-ptr from word-stack-ptr\n               by -1\n           until word-stack-ptr < 1\n               move word-entry (word-stack-ptr) to text-word\n               display wk-word (1:wk-len) space with no advancing\n           end-perform\n           display space\n           .\n       end program rev-word.\n", "target": "using System;\n\npublic class ReverseWordsInString\n{\n    public static void Main(string[] args)\n    {\n        string text = @\"\n            ---------- Ice and Fire ------------\n\n            fire, in end will world the say Some\n            ice. in say Some\n            desire of tasted I've what From\n            fire. favor who those with hold I\n\n            ... elided paragraph last ...\n\n            Frost Robert -----------------------\n            \";\n\n        foreach (string line in text.Split(Environment.NewLine)) {\n            \n            string[] words = line.Split(default(char[]), StringSplitOptions.RemoveEmptyEntries);\n            Array.Reverse(words);\n            WriteLine(string.Join(\" \", words));\n        }\n    }\n}\n"}
{"id": 161684, "name": "Reverse words in a string", "source": "Translate COBOL to Java:        program-id. rev-word.\n       data division.\n       working-storage section.\n       1 text-block.\n        2 pic x(36) value \"---------- Ice and Fire ------------\".\n        2 pic x(36) value \"                                    \".\n        2 pic x(36) value \"fire, in end will world the say Some\".\n        2 pic x(36) value \"ice. in say Some                    \".\n        2 pic x(36) value \"desire of tasted I've what From     \".\n        2 pic x(36) value \"fire. favor who those with hold I   \".\n        2 pic x(36) value \"                                    \".\n        2 pic x(36) value \"... elided paragraph last ...       \".\n        2 pic x(36) value \"                                    \".\n        2 pic x(36) value \"Frost Robert -----------------------\".\n       1 redefines text-block.\n        2 occurs 10.\n         3 text-line pic x(36).\n       1 text-word.\n        2 wk-len binary pic 9(4).\n        2 wk-word pic x(36).\n       1 word-stack.\n        2 occurs 10.\n         3 word-entry.\n          4 word-len binary pic 9(4).\n          4 word pic x(36).\n       1 binary.\n        2 i pic 9(4).\n        2 pos pic 9(4).\n        2 word-stack-ptr pic 9(4).\n\n       procedure division.\n           perform varying i from 1 by 1\n           until i > 10\n               perform push-words\n               perform pop-words\n           end-perform\n           stop run\n           .\n\n       push-words.\n           move 1 to pos\n           move 0 to word-stack-ptr\n           perform until pos > 36\n               unstring text-line (i) delimited by all space\n               into wk-word count in wk-len\n               pointer pos\n               end-unstring\n               add 1 to word-stack-ptr\n               move text-word to word-entry (word-stack-ptr)\n           end-perform\n           .\n\n       pop-words.\n           perform varying word-stack-ptr from word-stack-ptr\n               by -1\n           until word-stack-ptr < 1\n               move word-entry (word-stack-ptr) to text-word\n               display wk-word (1:wk-len) space with no advancing\n           end-perform\n           display space\n           .\n       end program rev-word.\n", "target": "public class ReverseWords {\n\n    static final String[] lines = {\n        \" ----------- Ice and Fire ----------- \",\n        \"                                      \",\n        \" fire, in end will world the say Some \",\n        \" ice. in say Some                     \",\n        \" desire of tasted I've what From      \",\n        \" fire. favor who those with hold I    \",\n        \"                                      \",\n        \" ... elided paragraph last ...        \",\n        \" Frost Robert ----------------------- \"};\n\n    public static void main(String[] args) {\n        for (String line : lines) {\n            String[] words = line.split(\"\\\\s\");\n            for (int i = words.length - 1; i >= 0; i--)\n                System.out.printf(\"%s \", words[i]);\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 161685, "name": "Reverse words in a string", "source": "Translate COBOL to Python:        program-id. rev-word.\n       data division.\n       working-storage section.\n       1 text-block.\n        2 pic x(36) value \"---------- Ice and Fire ------------\".\n        2 pic x(36) value \"                                    \".\n        2 pic x(36) value \"fire, in end will world the say Some\".\n        2 pic x(36) value \"ice. in say Some                    \".\n        2 pic x(36) value \"desire of tasted I've what From     \".\n        2 pic x(36) value \"fire. favor who those with hold I   \".\n        2 pic x(36) value \"                                    \".\n        2 pic x(36) value \"... elided paragraph last ...       \".\n        2 pic x(36) value \"                                    \".\n        2 pic x(36) value \"Frost Robert -----------------------\".\n       1 redefines text-block.\n        2 occurs 10.\n         3 text-line pic x(36).\n       1 text-word.\n        2 wk-len binary pic 9(4).\n        2 wk-word pic x(36).\n       1 word-stack.\n        2 occurs 10.\n         3 word-entry.\n          4 word-len binary pic 9(4).\n          4 word pic x(36).\n       1 binary.\n        2 i pic 9(4).\n        2 pos pic 9(4).\n        2 word-stack-ptr pic 9(4).\n\n       procedure division.\n           perform varying i from 1 by 1\n           until i > 10\n               perform push-words\n               perform pop-words\n           end-perform\n           stop run\n           .\n\n       push-words.\n           move 1 to pos\n           move 0 to word-stack-ptr\n           perform until pos > 36\n               unstring text-line (i) delimited by all space\n               into wk-word count in wk-len\n               pointer pos\n               end-unstring\n               add 1 to word-stack-ptr\n               move text-word to word-entry (word-stack-ptr)\n           end-perform\n           .\n\n       pop-words.\n           perform varying word-stack-ptr from word-stack-ptr\n               by -1\n           until word-stack-ptr < 1\n               move word-entry (word-stack-ptr) to text-word\n               display wk-word (1:wk-len) space with no advancing\n           end-perform\n           display space\n           .\n       end program rev-word.\n", "target": " text = \n\nfor line in text.split('\\n'): print(' '.join(line.split()[::-1]))\n"}
{"id": 162094, "name": "Middle three digits", "source": "Translate COBOL to C#: identification division.\nprogram-id. middle3.\nenvironment division.\ndata division.\nworking-storage section.\n01  num                 pic 9(9). \n    88 num-too-small    values are -99 thru 99.\n01  num-disp            pic ---------9.\n\n01  div                 pic 9(9).\n01  mod                 pic 9(9).\n01  mod-disp            pic 9(3).\n\n01  digit-counter       pic 999.\n01  digit-div           pic 9(9).\n    88  no-more-digits  value 0.\n01  digit-mod           pic 9(9).\n    88  is-even         value 0.\n\n01  multiplier          pic 9(9).\n\n01  value-items.\n    05  filler  pic s9(9) value 123.\n    05  filler  pic s9(9) value 12345.\n    05  filler  pic s9(9) value 1234567.\n    05  filler  pic s9(9) value 987654321.\n    05  filler  pic s9(9) value 10001.\n    05  filler  pic s9(9) value -10001.\n    05  filler  pic s9(9) value -123.\n    05  filler  pic s9(9) value -100.\n    05  filler  pic s9(9) value 100.\n    05  filler  pic s9(9) value -12345.\n    05  filler  pic s9(9) value 1.\n    05  filler  pic s9(9) value 2.\n    05  filler  pic s9(9) value -1.\n    05  filler  pic s9(9) value -10.\n    05  filler  pic s9(9) value 2002.\n    05  filler  pic s9(9) value -2002.\n    05  filler  pic s9(9) value 0.\n    \n01  value-array redefines value-items.\n    05  items   pic s9(9)  occurs 17 times indexed by item.\n\n01  result  pic x(20).\n\nprocedure division.\n10-main.\n    perform with test after varying item from 1 by 1 until items(item) = 0\n        move items(item) to num\n        move items(item) to num-disp\n        perform 20-check\n        display num-disp \" --> \" result\n    end-perform.\n    stop run.\n    \n20-check.\n    if num-too-small\n        move \"Number too small\" to result\n        exit paragraph\n    end-if.\n\n    perform 30-count-digits.\n    divide digit-counter by 2 giving digit-div remainder digit-mod.\n    if is-even\n        move \"Even number of digits\" to result\n        exit paragraph\n    end-if.\n    \n    \n    \n    \n        \n    if digit-counter > 3\n        compute multiplier rounded = 10 ** (((digit-counter - 5) / 2) + 1) \n        divide num by multiplier giving num\n        divide num by 1000 giving div remainder mod\n        move mod to mod-disp\n    else\n        move num to mod-disp\n    end-if.\n    move mod-disp to result.\n    exit paragraph.\n    \n30-count-digits.\n    move zeroes to digit-counter.\n    move num to digit-div.\n    perform with test before until no-more-digits\n        divide digit-div by 10 giving digit-div remainder digit-mod\n        add 1 to digit-counter\n    end-perform.\n    exit paragraph.\n", "target": "using System;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string text = Math.Abs(int.Parse(Console.ReadLine())).ToString();\n            Console.WriteLine(text.Length < 2 || text.Length % 2 == 0 ? \"Error\" : text.Substring((text.Length - 3) / 2, 3));\n        }\n    }\n}\n"}
{"id": 162096, "name": "Middle three digits", "source": "Translate COBOL to Java: identification division.\nprogram-id. middle3.\nenvironment division.\ndata division.\nworking-storage section.\n01  num                 pic 9(9). \n    88 num-too-small    values are -99 thru 99.\n01  num-disp            pic ---------9.\n\n01  div                 pic 9(9).\n01  mod                 pic 9(9).\n01  mod-disp            pic 9(3).\n\n01  digit-counter       pic 999.\n01  digit-div           pic 9(9).\n    88  no-more-digits  value 0.\n01  digit-mod           pic 9(9).\n    88  is-even         value 0.\n\n01  multiplier          pic 9(9).\n\n01  value-items.\n    05  filler  pic s9(9) value 123.\n    05  filler  pic s9(9) value 12345.\n    05  filler  pic s9(9) value 1234567.\n    05  filler  pic s9(9) value 987654321.\n    05  filler  pic s9(9) value 10001.\n    05  filler  pic s9(9) value -10001.\n    05  filler  pic s9(9) value -123.\n    05  filler  pic s9(9) value -100.\n    05  filler  pic s9(9) value 100.\n    05  filler  pic s9(9) value -12345.\n    05  filler  pic s9(9) value 1.\n    05  filler  pic s9(9) value 2.\n    05  filler  pic s9(9) value -1.\n    05  filler  pic s9(9) value -10.\n    05  filler  pic s9(9) value 2002.\n    05  filler  pic s9(9) value -2002.\n    05  filler  pic s9(9) value 0.\n    \n01  value-array redefines value-items.\n    05  items   pic s9(9)  occurs 17 times indexed by item.\n\n01  result  pic x(20).\n\nprocedure division.\n10-main.\n    perform with test after varying item from 1 by 1 until items(item) = 0\n        move items(item) to num\n        move items(item) to num-disp\n        perform 20-check\n        display num-disp \" --> \" result\n    end-perform.\n    stop run.\n    \n20-check.\n    if num-too-small\n        move \"Number too small\" to result\n        exit paragraph\n    end-if.\n\n    perform 30-count-digits.\n    divide digit-counter by 2 giving digit-div remainder digit-mod.\n    if is-even\n        move \"Even number of digits\" to result\n        exit paragraph\n    end-if.\n    \n    \n    \n    \n        \n    if digit-counter > 3\n        compute multiplier rounded = 10 ** (((digit-counter - 5) / 2) + 1) \n        divide num by multiplier giving num\n        divide num by 1000 giving div remainder mod\n        move mod to mod-disp\n    else\n        move num to mod-disp\n    end-if.\n    move mod-disp to result.\n    exit paragraph.\n    \n30-count-digits.\n    move zeroes to digit-counter.\n    move num to digit-div.\n    perform with test before until no-more-digits\n        divide digit-div by 10 giving digit-div remainder digit-mod\n        add 1 to digit-counter\n    end-perform.\n    exit paragraph.\n", "target": "public class MiddleThreeDigits {\n\n    public static void main(String[] args) {\n        final long[] passing = {123, 12345, 1234567, 987654321, 10001, -10001,\n            -123, -100, 100, -12345, Long.MIN_VALUE, Long.MAX_VALUE};\n\n        final int[] failing = {1, 2, -1, -10, 2002, -2002, 0, Integer.MIN_VALUE,\n            Integer.MAX_VALUE};\n\n        for (long n : passing)\n            System.out.printf(\"middleThreeDigits(%s): %s\\n\", n, middleThreeDigits(n));\n\n        for (int n : failing)\n            System.out.printf(\"middleThreeDigits(%s): %s\\n\", n, middleThreeDigits(n));\n    }\n\n    public static <T> String middleThreeDigits(T n) {\n        String s = String.valueOf(n);\n        if (s.charAt(0) == '-')\n            s = s.substring(1);\n        int len = s.length();\n        if (len < 3 || len % 2 == 0)\n            return \"Need odd and >= 3 digits\";\n        int mid = len / 2;\n        return s.substring(mid - 1, mid + 2);\n    }\n}\n"}
{"id": 162097, "name": "Middle three digits", "source": "Translate COBOL to Python: identification division.\nprogram-id. middle3.\nenvironment division.\ndata division.\nworking-storage section.\n01  num                 pic 9(9). \n    88 num-too-small    values are -99 thru 99.\n01  num-disp            pic ---------9.\n\n01  div                 pic 9(9).\n01  mod                 pic 9(9).\n01  mod-disp            pic 9(3).\n\n01  digit-counter       pic 999.\n01  digit-div           pic 9(9).\n    88  no-more-digits  value 0.\n01  digit-mod           pic 9(9).\n    88  is-even         value 0.\n\n01  multiplier          pic 9(9).\n\n01  value-items.\n    05  filler  pic s9(9) value 123.\n    05  filler  pic s9(9) value 12345.\n    05  filler  pic s9(9) value 1234567.\n    05  filler  pic s9(9) value 987654321.\n    05  filler  pic s9(9) value 10001.\n    05  filler  pic s9(9) value -10001.\n    05  filler  pic s9(9) value -123.\n    05  filler  pic s9(9) value -100.\n    05  filler  pic s9(9) value 100.\n    05  filler  pic s9(9) value -12345.\n    05  filler  pic s9(9) value 1.\n    05  filler  pic s9(9) value 2.\n    05  filler  pic s9(9) value -1.\n    05  filler  pic s9(9) value -10.\n    05  filler  pic s9(9) value 2002.\n    05  filler  pic s9(9) value -2002.\n    05  filler  pic s9(9) value 0.\n    \n01  value-array redefines value-items.\n    05  items   pic s9(9)  occurs 17 times indexed by item.\n\n01  result  pic x(20).\n\nprocedure division.\n10-main.\n    perform with test after varying item from 1 by 1 until items(item) = 0\n        move items(item) to num\n        move items(item) to num-disp\n        perform 20-check\n        display num-disp \" --> \" result\n    end-perform.\n    stop run.\n    \n20-check.\n    if num-too-small\n        move \"Number too small\" to result\n        exit paragraph\n    end-if.\n\n    perform 30-count-digits.\n    divide digit-counter by 2 giving digit-div remainder digit-mod.\n    if is-even\n        move \"Even number of digits\" to result\n        exit paragraph\n    end-if.\n    \n    \n    \n    \n        \n    if digit-counter > 3\n        compute multiplier rounded = 10 ** (((digit-counter - 5) / 2) + 1) \n        divide num by multiplier giving num\n        divide num by 1000 giving div remainder mod\n        move mod to mod-disp\n    else\n        move num to mod-disp\n    end-if.\n    move mod-disp to result.\n    exit paragraph.\n    \n30-count-digits.\n    move zeroes to digit-counter.\n    move num to digit-div.\n    perform with test before until no-more-digits\n        divide digit-div by 10 giving digit-div remainder digit-mod\n        add 1 to digit-counter\n    end-perform.\n    exit paragraph.\n", "target": ">>> def middle_three_digits(i):\n\ts = str(abs(i))\n\tlength = len(s)\n\tassert length >= 3 and length % 2 == 1, \"Need odd and >= 3 digits\"\n\tmid = length // 2\n\treturn s[mid-1:mid+2]\n\n>>> passing = [123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345]\n>>> failing = [1, 2, -1, -10, 2002, -2002, 0]\n>>> for x in passing + failing:\n\ttry:\n\t\tanswer = middle_three_digits(x)\n\texcept AssertionError as error:\n\t\tanswer = error\n\tprint(\"middle_three_digits(%s) returned: %r\" % (x, answer))\n\n\t\nmiddle_three_digits(123) returned: '123'\nmiddle_three_digits(12345) returned: '234'\nmiddle_three_digits(1234567) returned: '345'\nmiddle_three_digits(987654321) returned: '654'\nmiddle_three_digits(10001) returned: '000'\nmiddle_three_digits(-10001) returned: '000'\nmiddle_three_digits(-123) returned: '123'\nmiddle_three_digits(-100) returned: '100'\nmiddle_three_digits(100) returned: '100'\nmiddle_three_digits(-12345) returned: '234'\nmiddle_three_digits(1) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(2) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(-1) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(-10) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(2002) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(-2002) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(0) returned: AssertionError('Need odd and >= 3 digits',)\n>>>\n"}
{"id": 162353, "name": "Range expansion", "source": "Translate COBOL to C#:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. expand-range.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  comma-pos                           PIC 99 COMP VALUE 1.\n01  dash-pos                            PIC 99 COMP.\n01  end-num                             PIC S9(3).\n01  Max-Part-Len                        CONSTANT 10.\n01  num                                 PIC S9(3).\n01  edited-num                          PIC -(3)9.\n01  part                                PIC X(10).\n\n01  part-flag                           PIC X.\n    88 last-part                        VALUE \"Y\".\n\n01  range-str                           PIC X(80).\n01  Range-Str-Len                       CONSTANT 80.\n01  start-pos                           PIC 99 COMP.\n01  start-num                           PIC S9(3).\n\nPROCEDURE DIVISION.\n    ACCEPT range-str\n\n    PERFORM WITH TEST AFTER UNTIL last-part\n        UNSTRING range-str DELIMITED BY \",\" INTO part WITH POINTER comma-pos\n        PERFORM check-if-last\n\n        PERFORM find-range-dash\n            \n        IF dash-pos > Max-Part-Len\n            PERFORM display-num\n        ELSE\n            PERFORM display-range\n        END-IF\n    END-PERFORM\n\n    DISPLAY SPACES\n    \n    GOBACK\n    .\ncheck-if-last SECTION.\n    IF comma-pos > Range-Str-Len\n        SET last-part TO TRUE\n    END-IF\n    .\nfind-range-dash SECTION.\n    IF part (1:1) <> \"-\"\n        MOVE 1 TO start-pos\n    ELSE\n        MOVE 2 TO start-pos\n    END-IF\n\n    MOVE 1 TO dash-pos\n    INSPECT part (start-pos:) TALLYING dash-pos FOR CHARACTERS BEFORE \"-\"\n    COMPUTE dash-pos = dash-pos + start-pos - 1\n    .\ndisplay-num SECTION.\n    MOVE part TO edited-num\n    CALL \"display-edited-num\" USING CONTENT part-flag, edited-num\n    .\ndisplay-range SECTION.\n    MOVE part (1:dash-pos - 1) TO start-num\n    MOVE part (dash-pos + 1:) TO end-num\n\n    PERFORM VARYING num FROM start-num BY 1 UNTIL num = end-num\n        MOVE num TO edited-num\n        CALL \"display-edited-num\" USING CONTENT \"N\", edited-num\n    END-PERFORM\n\n    MOVE end-num TO edited-num\n    CALL \"display-edited-num\" USING CONTENT part-flag, edited-num\n    .\nEND PROGRAM expand-range.\n\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. display-edited-num.\n\nDATA DIVISION.\nLINKAGE SECTION.\n01  hide-comma-flag                     PIC X.\n    88  hide-comma                      VALUE \"Y\".\n01  edited-num                          PIC -(3)9.\n\nPROCEDURE DIVISION USING hide-comma-flag, edited-num.\n    DISPLAY FUNCTION TRIM(edited-num) NO ADVANCING\n    IF NOT hide-comma\n        DISPLAY \", \" NO ADVANCING\n    END-IF\n    .\nEND PROGRAM display-edited-num.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var rangeString = \"-6,-3--1,3-5,7-11,14,15,17-20\";\n        var matches = Regex.Matches(rangeString, @\"(?<f>-?\\d+)-(?<s>-?\\d+)|(-?\\d+)\");\n        var values = new List<string>();\n\n        foreach (var m in matches.OfType<Match>())\n        {\n            if (m.Groups[1].Success)\n            {\n                values.Add(m.Value);\n                continue;\n            }\n\n            var start = Convert.ToInt32(m.Groups[\"f\"].Value);\n            var end = Convert.ToInt32(m.Groups[\"s\"].Value) + 1;\n\n            values.AddRange(Enumerable.Range(start, end - start).Select(v => v.ToString()));\n        }\n\n        Console.WriteLine(string.Join(\", \", values));\n    }\n}\n"}
{"id": 162355, "name": "Range expansion", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. expand-range.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  comma-pos                           PIC 99 COMP VALUE 1.\n01  dash-pos                            PIC 99 COMP.\n01  end-num                             PIC S9(3).\n01  Max-Part-Len                        CONSTANT 10.\n01  num                                 PIC S9(3).\n01  edited-num                          PIC -(3)9.\n01  part                                PIC X(10).\n\n01  part-flag                           PIC X.\n    88 last-part                        VALUE \"Y\".\n\n01  range-str                           PIC X(80).\n01  Range-Str-Len                       CONSTANT 80.\n01  start-pos                           PIC 99 COMP.\n01  start-num                           PIC S9(3).\n\nPROCEDURE DIVISION.\n    ACCEPT range-str\n\n    PERFORM WITH TEST AFTER UNTIL last-part\n        UNSTRING range-str DELIMITED BY \",\" INTO part WITH POINTER comma-pos\n        PERFORM check-if-last\n\n        PERFORM find-range-dash\n            \n        IF dash-pos > Max-Part-Len\n            PERFORM display-num\n        ELSE\n            PERFORM display-range\n        END-IF\n    END-PERFORM\n\n    DISPLAY SPACES\n    \n    GOBACK\n    .\ncheck-if-last SECTION.\n    IF comma-pos > Range-Str-Len\n        SET last-part TO TRUE\n    END-IF\n    .\nfind-range-dash SECTION.\n    IF part (1:1) <> \"-\"\n        MOVE 1 TO start-pos\n    ELSE\n        MOVE 2 TO start-pos\n    END-IF\n\n    MOVE 1 TO dash-pos\n    INSPECT part (start-pos:) TALLYING dash-pos FOR CHARACTERS BEFORE \"-\"\n    COMPUTE dash-pos = dash-pos + start-pos - 1\n    .\ndisplay-num SECTION.\n    MOVE part TO edited-num\n    CALL \"display-edited-num\" USING CONTENT part-flag, edited-num\n    .\ndisplay-range SECTION.\n    MOVE part (1:dash-pos - 1) TO start-num\n    MOVE part (dash-pos + 1:) TO end-num\n\n    PERFORM VARYING num FROM start-num BY 1 UNTIL num = end-num\n        MOVE num TO edited-num\n        CALL \"display-edited-num\" USING CONTENT \"N\", edited-num\n    END-PERFORM\n\n    MOVE end-num TO edited-num\n    CALL \"display-edited-num\" USING CONTENT part-flag, edited-num\n    .\nEND PROGRAM expand-range.\n\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. display-edited-num.\n\nDATA DIVISION.\nLINKAGE SECTION.\n01  hide-comma-flag                     PIC X.\n    88  hide-comma                      VALUE \"Y\".\n01  edited-num                          PIC -(3)9.\n\nPROCEDURE DIVISION USING hide-comma-flag, edited-num.\n    DISPLAY FUNCTION TRIM(edited-num) NO ADVANCING\n    IF NOT hide-comma\n        DISPLAY \", \" NO ADVANCING\n    END-IF\n    .\nEND PROGRAM display-edited-num.\n", "target": "import java.util.*;\n\nclass RangeExpander implements Iterator<Integer>, Iterable<Integer> {\n\n    private static final Pattern TOKEN_PATTERN = Pattern.compile(\"([+-]?\\\\d+)-([+-]?\\\\d+)\");\n\n    private final Iterator<String> tokensIterator;\n\n    private boolean inRange;\n    private int upperRangeEndpoint;\n    private int nextRangeValue;\n\n    public RangeExpander(String range) {\n        String[] tokens = range.split(\"\\\\s*,\\\\s*\");\n        this.tokensIterator = Arrays.asList(tokens).iterator();\n    }\n\n    @Override\n    public boolean hasNext() {\n        return hasNextRangeValue() || this.tokensIterator.hasNext();\n    }\n\n    private boolean hasNextRangeValue() {\n        return this.inRange && this.nextRangeValue <= this.upperRangeEndpoint;\n    }\n\n    @Override\n    public Integer next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n\n        if (hasNextRangeValue()) {\n            return this.nextRangeValue++;\n        }\n\n        String token = this.tokensIterator.next();\n\n        Matcher matcher = TOKEN_PATTERN.matcher(token);\n        if (matcher.find()) {\n            this.inRange = true;\n            this.upperRangeEndpoint = Integer.valueOf(matcher.group(2));\n            this.nextRangeValue = Integer.valueOf(matcher.group(1));\n            return this.nextRangeValue++;\n        }\n\n        this.inRange = false;\n        return Integer.valueOf(token);\n    }\n\n    @Override\n    public Iterator<Integer> iterator() {\n        return this;\n    }\n\n}\n\nclass RangeExpanderTest {\n    public static void main(String[] args) {\n        RangeExpander re = new RangeExpander(\"-6,-3--1,3-5,7-11,14,15,17-20\");\n        for (int i : re) {\n            System.out.print(i + \" \");\n        }\n    }\n}\n"}
{"id": 162356, "name": "Range expansion", "source": "Translate COBOL to Python:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. expand-range.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  comma-pos                           PIC 99 COMP VALUE 1.\n01  dash-pos                            PIC 99 COMP.\n01  end-num                             PIC S9(3).\n01  Max-Part-Len                        CONSTANT 10.\n01  num                                 PIC S9(3).\n01  edited-num                          PIC -(3)9.\n01  part                                PIC X(10).\n\n01  part-flag                           PIC X.\n    88 last-part                        VALUE \"Y\".\n\n01  range-str                           PIC X(80).\n01  Range-Str-Len                       CONSTANT 80.\n01  start-pos                           PIC 99 COMP.\n01  start-num                           PIC S9(3).\n\nPROCEDURE DIVISION.\n    ACCEPT range-str\n\n    PERFORM WITH TEST AFTER UNTIL last-part\n        UNSTRING range-str DELIMITED BY \",\" INTO part WITH POINTER comma-pos\n        PERFORM check-if-last\n\n        PERFORM find-range-dash\n            \n        IF dash-pos > Max-Part-Len\n            PERFORM display-num\n        ELSE\n            PERFORM display-range\n        END-IF\n    END-PERFORM\n\n    DISPLAY SPACES\n    \n    GOBACK\n    .\ncheck-if-last SECTION.\n    IF comma-pos > Range-Str-Len\n        SET last-part TO TRUE\n    END-IF\n    .\nfind-range-dash SECTION.\n    IF part (1:1) <> \"-\"\n        MOVE 1 TO start-pos\n    ELSE\n        MOVE 2 TO start-pos\n    END-IF\n\n    MOVE 1 TO dash-pos\n    INSPECT part (start-pos:) TALLYING dash-pos FOR CHARACTERS BEFORE \"-\"\n    COMPUTE dash-pos = dash-pos + start-pos - 1\n    .\ndisplay-num SECTION.\n    MOVE part TO edited-num\n    CALL \"display-edited-num\" USING CONTENT part-flag, edited-num\n    .\ndisplay-range SECTION.\n    MOVE part (1:dash-pos - 1) TO start-num\n    MOVE part (dash-pos + 1:) TO end-num\n\n    PERFORM VARYING num FROM start-num BY 1 UNTIL num = end-num\n        MOVE num TO edited-num\n        CALL \"display-edited-num\" USING CONTENT \"N\", edited-num\n    END-PERFORM\n\n    MOVE end-num TO edited-num\n    CALL \"display-edited-num\" USING CONTENT part-flag, edited-num\n    .\nEND PROGRAM expand-range.\n\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. display-edited-num.\n\nDATA DIVISION.\nLINKAGE SECTION.\n01  hide-comma-flag                     PIC X.\n    88  hide-comma                      VALUE \"Y\".\n01  edited-num                          PIC -(3)9.\n\nPROCEDURE DIVISION USING hide-comma-flag, edited-num.\n    DISPLAY FUNCTION TRIM(edited-num) NO ADVANCING\n    IF NOT hide-comma\n        DISPLAY \", \" NO ADVANCING\n    END-IF\n    .\nEND PROGRAM display-edited-num.\n", "target": "def rangeexpand(txt):\n    lst = []\n    for r in txt.split(','):\n        if '-' in r[1:]:\n            r0, r1 = r[1:].split('-', 1)\n            lst += range(int(r[0] + r0), int(r1) + 1)\n        else:\n            lst.append(int(r))\n    return lst\n\nprint(rangeexpand('-6,-3--1,3-5,7-11,14,15,17-20'))\n"}
{"id": 162965, "name": "Kernighans large earthquake problem", "source": "Translate COBOL to C#:       \n      \n      \n      \n      \n      \n       >>SOURCE FORMAT IS FREE\n       identification division.\n       program-id. quakes.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select quake-data\n           assign to command-filename\n           organization is line sequential\n           status is quake-fd-status\n           .\n\n       data division.\n       file section.\n       fd quake-data record varying depending on line-length.\n           01 data-line       pic x(32768).\n\n       working-storage section.\n       01 quake-fd-status pic xx.\n          88 ok values \"00\", \"01\", \"02\", \"03\", \"04\",\n                       \"05\", \"06\", \"07\", \"08\", \"09\".\n          88 no-more value \"10\".\n          88 io-error value high-value.\n\n       01 line-length usage binary-long.\n\n       01 date-time pic x(10).\n       01 quake pic x(20).\n       01 magnitude pic 99v99.\n\n       01 command-filename pic x(80).\n        \n       procedure division.\n       show-big-ones.\n\n       accept command-filename from command-line\n       if command-filename equal spaces then\n           move \"data.txt\" to command-filename\n       end-if\n\n       open input quake-data\n       perform status-check\n       if io-error then\n           display trim(command-filename) \" not found\" upon syserr\n           goback\n       end-if\n\n       read quake-data\n       perform status-check\n       perform until no-more or io-error\n           unstring data-line delimited by all spaces\n              into date-time quake magnitude\n           end-unstring\n\n           if magnitude greater than 6\n               display date-time space quake space magnitude\n           end-if\n\n           read quake-data\n           perform status-check\n       end-perform\n\n       close quake-data\n       perform status-check\n       goback.\n      \n\n       status-check.\n       if not ok and not no-more then   \n           display \"io error: \" quake-fd-status upon syserr\n           set io-error to true\n       end-if\n       .\n\n       end program quakes.\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    static void Main() {\n        foreach (var earthquake in LargeEarthquakes(\"data.txt\", 6))\n            Console.WriteLine(string.Join(\" \", earthquake));\n    }\n\n    static IEnumerable<string[]> LargeEarthquakes(string filename, double limit) =>\n        from line in File.ReadLines(filename)\n        let parts = line.Split(default(char[]), StringSplitOptions.RemoveEmptyEntries)\n        where double.Parse(parts[2]) > limit\n        select parts;\n\n}\n"}
{"id": 162967, "name": "Kernighans large earthquake problem", "source": "Translate COBOL to Java:       \n      \n      \n      \n      \n      \n       >>SOURCE FORMAT IS FREE\n       identification division.\n       program-id. quakes.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select quake-data\n           assign to command-filename\n           organization is line sequential\n           status is quake-fd-status\n           .\n\n       data division.\n       file section.\n       fd quake-data record varying depending on line-length.\n           01 data-line       pic x(32768).\n\n       working-storage section.\n       01 quake-fd-status pic xx.\n          88 ok values \"00\", \"01\", \"02\", \"03\", \"04\",\n                       \"05\", \"06\", \"07\", \"08\", \"09\".\n          88 no-more value \"10\".\n          88 io-error value high-value.\n\n       01 line-length usage binary-long.\n\n       01 date-time pic x(10).\n       01 quake pic x(20).\n       01 magnitude pic 99v99.\n\n       01 command-filename pic x(80).\n        \n       procedure division.\n       show-big-ones.\n\n       accept command-filename from command-line\n       if command-filename equal spaces then\n           move \"data.txt\" to command-filename\n       end-if\n\n       open input quake-data\n       perform status-check\n       if io-error then\n           display trim(command-filename) \" not found\" upon syserr\n           goback\n       end-if\n\n       read quake-data\n       perform status-check\n       perform until no-more or io-error\n           unstring data-line delimited by all spaces\n              into date-time quake magnitude\n           end-unstring\n\n           if magnitude greater than 6\n               display date-time space quake space magnitude\n           end-if\n\n           read quake-data\n           perform status-check\n       end-perform\n\n       close quake-data\n       perform status-check\n       goback.\n      \n\n       status-check.\n       if not ok and not no-more then   \n           display \"io error: \" quake-fd-status upon syserr\n           set io-error to true\n       end-if\n       .\n\n       end program quakes.\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class KernighansLargeEarthquakeProblem {\n\n    public static void main(String[] args) throws Exception {\n        try (BufferedReader reader  = new BufferedReader(new FileReader(\"data.txt\")); ) {\n            String inLine = null;\n            while ( (inLine = reader.readLine()) != null ) {\n                String[] split = inLine.split(\"\\\\s+\");\n                double magnitude = Double.parseDouble(split[2]);\n                if ( magnitude > 6 ) {\n                    System.out.println(inLine);\n                }\n            }\n        }\n\n    }\n\n}\n"}
{"id": 162968, "name": "Kernighans large earthquake problem", "source": "Translate COBOL to Python:       \n      \n      \n      \n      \n      \n       >>SOURCE FORMAT IS FREE\n       identification division.\n       program-id. quakes.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select quake-data\n           assign to command-filename\n           organization is line sequential\n           status is quake-fd-status\n           .\n\n       data division.\n       file section.\n       fd quake-data record varying depending on line-length.\n           01 data-line       pic x(32768).\n\n       working-storage section.\n       01 quake-fd-status pic xx.\n          88 ok values \"00\", \"01\", \"02\", \"03\", \"04\",\n                       \"05\", \"06\", \"07\", \"08\", \"09\".\n          88 no-more value \"10\".\n          88 io-error value high-value.\n\n       01 line-length usage binary-long.\n\n       01 date-time pic x(10).\n       01 quake pic x(20).\n       01 magnitude pic 99v99.\n\n       01 command-filename pic x(80).\n        \n       procedure division.\n       show-big-ones.\n\n       accept command-filename from command-line\n       if command-filename equal spaces then\n           move \"data.txt\" to command-filename\n       end-if\n\n       open input quake-data\n       perform status-check\n       if io-error then\n           display trim(command-filename) \" not found\" upon syserr\n           goback\n       end-if\n\n       read quake-data\n       perform status-check\n       perform until no-more or io-error\n           unstring data-line delimited by all spaces\n              into date-time quake magnitude\n           end-unstring\n\n           if magnitude greater than 6\n               display date-time space quake space magnitude\n           end-if\n\n           read quake-data\n           perform status-check\n       end-perform\n\n       close quake-data\n       perform status-check\n       goback.\n      \n\n       status-check.\n       if not ok and not no-more then   \n           display \"io error: \" quake-fd-status upon syserr\n           set io-error to true\n       end-if\n       .\n\n       end program quakes.\n", "target": "python -c '\nwith open(\"data.txt\") as f:\n    for ln in f:\n        if float(ln.strip().split()[2]) > 6:\n            print(ln.strip())'\n"}
{"id": 163780, "name": "Temperature conversion", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. temp-conversion.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Kelvin-Rankine-Ratio    VALUE 0.5556. \n       78  Kelvin-Celsius-Diff     VALUE 273.15.\n       78  Rankine-Fahrenheit-Diff VALUE 459.67.\n       \n       01  temp-kelvin             PIC S9(8)V99.\n       01  temp-rankine            PIC S9(8)V99.\n       \n       01  kelvin                  PIC -(7)9.99.\n       01  celsius                 PIC -(7)9.99.\n       01  rankine                 PIC -(7)9.99.\n       01  fahrenheit              PIC -(7)9.99.\n       \n       PROCEDURE DIVISION.\n           DISPLAY \"Enter a temperature in Kelvin to convert: \" NO ADVANCING\n           ACCEPT temp-kelvin\n       \n           MOVE temp-kelvin TO kelvin\n           DISPLAY \"K \" kelvin\n           \n           SUBTRACT Kelvin-Celsius-Diff FROM temp-kelvin GIVING celsius\n           DISPLAY \"C \" celsius\n           \n           DIVIDE temp-kelvin BY Kelvin-Rankine-Ratio\n               GIVING temp-rankine, rankine\n           SUBTRACT Rankine-Fahrenheit-Diff FROM temp-rankine GIVING fahrenheit\n           \n           DISPLAY \"F \" fahrenheit\n           DISPLAY \"R \" rankine\n       \n           GOBACK\n           .\n", "target": "using System;\n\nnamespace TemperatureConversion\n{\n    class Program\n    {\n        static Func<double, double> ConvertKelvinToFahrenheit = x => (x * 1.8) - 459.67;\n        static Func<double, double> ConvertKelvinToRankine = x => x * 1.8;\n        static Func<double, double> ConvertKelvinToCelsius = x => x = 273.13;\n\n        static void Main(string[] args)\n        {\n            Console.Write(\"Enter a Kelvin Temperature: \");\n            string inputVal = Console.ReadLine();\n            double kelvinTemp = 0f;\n\n            if (double.TryParse(inputVal, out kelvinTemp))\n            {\n                Console.WriteLine(string.Format(\"Kelvin: {0}\", kelvinTemp));\n                Console.WriteLine(string.Format(\"Fahrenheit: {0}\", ConvertKelvinToFahrenheit(kelvinTemp)));\n                Console.WriteLine(string.Format(\"Rankine: {0}\", ConvertKelvinToRankine(kelvinTemp)));\n                Console.WriteLine(string.Format(\"Celsius: {0}\", ConvertKelvinToCelsius(kelvinTemp)));\n                Console.ReadKey();\n            }\n            else\n            {\n                Console.WriteLine(\"Invalid input value: \" + inputVal);\n            }\n        }\n    }\n}\n"}
{"id": 163782, "name": "Temperature conversion", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. temp-conversion.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Kelvin-Rankine-Ratio    VALUE 0.5556. \n       78  Kelvin-Celsius-Diff     VALUE 273.15.\n       78  Rankine-Fahrenheit-Diff VALUE 459.67.\n       \n       01  temp-kelvin             PIC S9(8)V99.\n       01  temp-rankine            PIC S9(8)V99.\n       \n       01  kelvin                  PIC -(7)9.99.\n       01  celsius                 PIC -(7)9.99.\n       01  rankine                 PIC -(7)9.99.\n       01  fahrenheit              PIC -(7)9.99.\n       \n       PROCEDURE DIVISION.\n           DISPLAY \"Enter a temperature in Kelvin to convert: \" NO ADVANCING\n           ACCEPT temp-kelvin\n       \n           MOVE temp-kelvin TO kelvin\n           DISPLAY \"K \" kelvin\n           \n           SUBTRACT Kelvin-Celsius-Diff FROM temp-kelvin GIVING celsius\n           DISPLAY \"C \" celsius\n           \n           DIVIDE temp-kelvin BY Kelvin-Rankine-Ratio\n               GIVING temp-rankine, rankine\n           SUBTRACT Rankine-Fahrenheit-Diff FROM temp-rankine GIVING fahrenheit\n           \n           DISPLAY \"F \" fahrenheit\n           DISPLAY \"R \" rankine\n       \n           GOBACK\n           .\n", "target": "public class TemperatureConversion {\n    public static void main(String args[]) {\n        if (args.length == 1) {\n            try {\n                double kelvin = Double.parseDouble(args[0]);\n                if (kelvin >= 0) {\n                    System.out.printf(\"K  %2.2f\\n\", kelvin);\n                    System.out.printf(\"C  %2.2f\\n\", kelvinToCelsius(kelvin));\n                    System.out.printf(\"F  %2.2f\\n\", kelvinToFahrenheit(kelvin));\n                    System.out.printf(\"R  %2.2f\\n\", kelvinToRankine(kelvin));\n                } else {\n                    System.out.printf(\"%2.2f K is below absolute zero\", kelvin);\n                }\n            } catch (NumberFormatException e) {\n                System.out.println(e);\n            }\n        }\n    }\n\n    public static double kelvinToCelsius(double k) {\n        return k - 273.15;\n    }\n\n    public static double kelvinToFahrenheit(double k) {\n        return k * 1.8 - 459.67;\n    }\n\n    public static double kelvinToRankine(double k) {\n        return k * 1.8;\n    }\n}\n"}
{"id": 163783, "name": "Temperature conversion", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. temp-conversion.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Kelvin-Rankine-Ratio    VALUE 0.5556. \n       78  Kelvin-Celsius-Diff     VALUE 273.15.\n       78  Rankine-Fahrenheit-Diff VALUE 459.67.\n       \n       01  temp-kelvin             PIC S9(8)V99.\n       01  temp-rankine            PIC S9(8)V99.\n       \n       01  kelvin                  PIC -(7)9.99.\n       01  celsius                 PIC -(7)9.99.\n       01  rankine                 PIC -(7)9.99.\n       01  fahrenheit              PIC -(7)9.99.\n       \n       PROCEDURE DIVISION.\n           DISPLAY \"Enter a temperature in Kelvin to convert: \" NO ADVANCING\n           ACCEPT temp-kelvin\n       \n           MOVE temp-kelvin TO kelvin\n           DISPLAY \"K \" kelvin\n           \n           SUBTRACT Kelvin-Celsius-Diff FROM temp-kelvin GIVING celsius\n           DISPLAY \"C \" celsius\n           \n           DIVIDE temp-kelvin BY Kelvin-Rankine-Ratio\n               GIVING temp-rankine, rankine\n           SUBTRACT Rankine-Fahrenheit-Diff FROM temp-rankine GIVING fahrenheit\n           \n           DISPLAY \"F \" fahrenheit\n           DISPLAY \"R \" rankine\n       \n           GOBACK\n           .\n", "target": ">>> while True:\n    k = float(input('K\u00a0? '))\n    print(\"%g Kelvin = %g Celsius = %g Fahrenheit = %g Rankine degrees.\"\n          % (k, k - 273.15, k * 1.8 - 459.67, k * 1.8))\n\n    \nK ? 21.0\n21 Kelvin = -252.15 Celsius = -421.87 Fahrenheit = 37.8 Rankine degrees.\nK ? 222.2\n222.2 Kelvin = -50.95 Celsius = -59.71 Fahrenheit = 399.96 Rankine degrees.\nK ?\n"}
{"id": 164231, "name": "Square but not cube", "source": "Translate COBOL to C#:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. SQUARE-NOT-CUBE.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 COMPUTATION.\n           02 SQ-ROOT       PIC 9999 COMP VALUE 1.\n           02 CUBE-ROOT     PIC 9999 COMP VALUE 1.\n           02 SQUARE        PIC 9999 COMP VALUE 1.\n           02 CUBE          PIC 9999 COMP VALUE 1.\n           02 SEEN          PIC 99   COMP VALUE 0.\n        01 OUTPUT-FORMAT.\n           02 OUT-NUM       PIC ZZZ9.\n        \n        PROCEDURE DIVISION.\n        SQUARE-STEP.\n            COMPUTE SQUARE = SQ-ROOT ** 2.\n        CUBE-STEP.\n            IF SQUARE IS GREATER THAN CUBE\n                ADD 1 TO CUBE-ROOT\n                COMPUTE CUBE = CUBE-ROOT ** 3\n                GO TO CUBE-STEP.\n            IF SQUARE IS NOT EQUAL TO CUBE\n                ADD 1 TO SEEN\n                MOVE SQUARE TO OUT-NUM\n                DISPLAY OUT-NUM.\n            ADD 1 TO SQ-ROOT.\n            IF SEEN IS LESS THAN 30 GO TO SQUARE-STEP.\n            STOP RUN.\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Linq.Enumerable;\n\npublic static class SquareButNotCube\n{\n    public static void Main() {\n        var squares = from i in Integers() select i * i;\n        var cubes = from i in Integers() select i * i * i;\n\n        foreach (var x in Merge().Take(33)) {\n            WriteLine(x.isCube ? x.n + \" (also cube)\" : x.n + \"\");\n        }\n        \n        IEnumerable<int> Integers() {\n            for (int i = 1; ;i++) yield return i;\n        }\n\n        IEnumerable<(int n, bool isCube)> Merge() {\n            using (var s = squares.GetEnumerator())\n            using (var c = cubes.GetEnumerator()) {\n                s.MoveNext();\n                c.MoveNext();\n                while (true) {\n                    if (s.Current < c.Current) {\n                        yield return (s.Current, false);\n                        s.MoveNext();\n                    } else if (s.Current == c.Current) {\n                        yield return (s.Current, true);\n                        s.MoveNext();\n                        c.MoveNext();\n                    } else {\n                        c.MoveNext();\n                    }\n                }\n            }\n        }\n\n    }\n}\n"}
{"id": 164233, "name": "Square but not cube", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. SQUARE-NOT-CUBE.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 COMPUTATION.\n           02 SQ-ROOT       PIC 9999 COMP VALUE 1.\n           02 CUBE-ROOT     PIC 9999 COMP VALUE 1.\n           02 SQUARE        PIC 9999 COMP VALUE 1.\n           02 CUBE          PIC 9999 COMP VALUE 1.\n           02 SEEN          PIC 99   COMP VALUE 0.\n        01 OUTPUT-FORMAT.\n           02 OUT-NUM       PIC ZZZ9.\n        \n        PROCEDURE DIVISION.\n        SQUARE-STEP.\n            COMPUTE SQUARE = SQ-ROOT ** 2.\n        CUBE-STEP.\n            IF SQUARE IS GREATER THAN CUBE\n                ADD 1 TO CUBE-ROOT\n                COMPUTE CUBE = CUBE-ROOT ** 3\n                GO TO CUBE-STEP.\n            IF SQUARE IS NOT EQUAL TO CUBE\n                ADD 1 TO SEEN\n                MOVE SQUARE TO OUT-NUM\n                DISPLAY OUT-NUM.\n            ADD 1 TO SQ-ROOT.\n            IF SEEN IS LESS THAN 30 GO TO SQUARE-STEP.\n            STOP RUN.\n", "target": "public class SquaresCubes {\n    public static boolean isPerfectCube(long n) {\n        long c = (long)Math.cbrt((double)n);\n        return ((c * c * c) == n);\n    }\n    \n    public static void main(String... args) {\n        long n = 1;\n        int squareOnlyCount = 0;\n        int squareCubeCount = 0;\n        while ((squareOnlyCount < 30) || (squareCubeCount < 3)) {\n            long sq = n * n;\n            if (isPerfectCube(sq)) {\n                squareCubeCount++;\n                System.out.println(\"Square and cube: \" + sq);\n            }\n            else {\n                squareOnlyCount++;\n                System.out.println(\"Square: \" + sq);\n            }\n            n++;\n        }\n    }\n}\n"}
{"id": 164234, "name": "Square but not cube", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. SQUARE-NOT-CUBE.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 COMPUTATION.\n           02 SQ-ROOT       PIC 9999 COMP VALUE 1.\n           02 CUBE-ROOT     PIC 9999 COMP VALUE 1.\n           02 SQUARE        PIC 9999 COMP VALUE 1.\n           02 CUBE          PIC 9999 COMP VALUE 1.\n           02 SEEN          PIC 99   COMP VALUE 0.\n        01 OUTPUT-FORMAT.\n           02 OUT-NUM       PIC ZZZ9.\n        \n        PROCEDURE DIVISION.\n        SQUARE-STEP.\n            COMPUTE SQUARE = SQ-ROOT ** 2.\n        CUBE-STEP.\n            IF SQUARE IS GREATER THAN CUBE\n                ADD 1 TO CUBE-ROOT\n                COMPUTE CUBE = CUBE-ROOT ** 3\n                GO TO CUBE-STEP.\n            IF SQUARE IS NOT EQUAL TO CUBE\n                ADD 1 TO SEEN\n                MOVE SQUARE TO OUT-NUM\n                DISPLAY OUT-NUM.\n            ADD 1 TO SQ-ROOT.\n            IF SEEN IS LESS THAN 30 GO TO SQUARE-STEP.\n            STOP RUN.\n", "target": "\ndef nonCubeSquares(n):\n    upto = enumFromTo(1)\n    ns = upto(n)\n    setCubes = set(x ** 3 for x in ns)\n    ms = upto(n + len(set(x * x for x in ns).intersection(\n        setCubes\n    )))\n    return list(tuple([x * x, x in setCubes]) for x in ms)\n\n\n\ndef squareListing(xs):\n    justifyIdx = justifyRight(len(str(1 + len(xs))))(' ')\n    justifySqr = justifyRight(1 + len(str(xs[-1][0])))(' ')\n    return list(\n        '(' + str(1 + idx) + '^2 = ' + str(n) +\n        ' = ' + str(round(n ** (1 / 3))) + '^3)' if bln else (\n            justifyIdx(1 + idx) + ' ->' +\n            justifySqr(n)\n        )\n        for idx, (n, bln) in enumerate(xs)\n    )\n\n\ndef main():\n    print(\n        unlines(\n            squareListing(\n                nonCubeSquares(30)\n            )\n        )\n    )\n\n\n\n\n\ndef enumFromTo(m):\n    return lambda n: list(range(m, 1 + n))\n\n\n\ndef justifyRight(n):\n    return lambda cFiller: lambda a: (\n        ((n * cFiller) + str(a))[-n:]\n    )\n\n\n\ndef unlines(xs):\n    return '\\n'.join(xs)\n\n\nmain()\n"}
{"id": 165295, "name": "The Twelve Days of Christmas", "source": "Translate COBOL to C#:        >>SOURCE FREE\nPROGRAM-ID. twelve-days-of-christmas.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  gifts-area VALUE \"partridge in a pear tree    \"\n    & \"Two turtle doves              \"\n    & \"Three french hens             \"\n    & \"Four calling birds            \"\n    & \"FIVE GOLDEN RINGS             \"\n    & \"Six geese a-laying            \"\n    & \"Seven swans a-swimming        \"\n    & \"Eight maids a-milking         \"\n    & \"Nine ladies dancing           \"\n    & \"Ten lords a-leaping           \"\n    & \"Eleven pipers piping          \"\n    & \"Twelve drummers drumming      \".\n    03  gifts                           PIC X(30) OCCURS 12 TIMES\n                                        INDEXED BY gift-idx.\n\n01  ordinals-area VALUE \"first     second    third     fourth    fifth     \"\n    & \"sixth     seventh   eighth    ninth     tenth     eleventh  twelfth   \".\n    03  ordinals                        PIC X(10) OCCURS 12 TIMES.\n\n01  day-num                             PIC 99 COMP.\n                                        \nPROCEDURE DIVISION.\n    PERFORM VARYING day-num FROM 1 BY 1 UNTIL day-num > 12\n        DISPLAY \"On the \" FUNCTION TRIM(ordinals (day-num)) \" day of Christmas,\"\n            \" my true love gave to me\"\n\n        IF day-num = 1\n            DISPLAY \"A \" gifts (1)\n        ELSE\n            PERFORM VARYING gift-idx FROM day-num BY -1 UNTIL gift-idx = 1\n                DISPLAY gifts (gift-idx)\n            END-PERFORM\n            DISPLAY \"And a \" gifts (1)\n        END-IF\n        \n        DISPLAY SPACE\n    END-PERFORM\n    .\nEND PROGRAM twelve-days-of-christmas.\n", "target": "using System;\n\npublic class TwelveDaysOfChristmas {\n\n    public static void Main() {\n\n        string[] days = new string[12] {\n            \"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\", \"eighth\", \"ninth\",\n            \"tenth\", \"eleventh\", \"twelfth\",\n        };\n\n        string[] gifts = new string[12] {\n            \"A partridge in a pear tree\",\n            \"Two turtle doves\",\n            \"Three french hens\",\n            \"Four calling birds\",\n            \"Five golden rings\",\n            \"Six geese a-laying\",\n            \"Seven swans a-swimming\",\n            \"Eight maids a-milking\",\n            \"Nine ladies dancing\",\n            \"Ten lords a-leaping\",\n            \"Eleven pipers piping\",\n            \"Twelve drummers drumming\"\n        };\n\n        for ( int i = 0; i < 12; i++ ) {\n\n            Console.WriteLine(\"On the \" + days[i] + \" day of Christmas, my true love gave to me\");\n\n            int j = i + 1;\n            while ( j-- > 0 )\n                Console.WriteLine(gifts[j]);\n\n            Console.WriteLine();\n\n            if ( i == 0 )\n                gifts[0] = \"And a partridge in a pear tree\";\n        }\n\n    }\n\n}\n"}
{"id": 165297, "name": "The Twelve Days of Christmas", "source": "Translate COBOL to Java:        >>SOURCE FREE\nPROGRAM-ID. twelve-days-of-christmas.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  gifts-area VALUE \"partridge in a pear tree    \"\n    & \"Two turtle doves              \"\n    & \"Three french hens             \"\n    & \"Four calling birds            \"\n    & \"FIVE GOLDEN RINGS             \"\n    & \"Six geese a-laying            \"\n    & \"Seven swans a-swimming        \"\n    & \"Eight maids a-milking         \"\n    & \"Nine ladies dancing           \"\n    & \"Ten lords a-leaping           \"\n    & \"Eleven pipers piping          \"\n    & \"Twelve drummers drumming      \".\n    03  gifts                           PIC X(30) OCCURS 12 TIMES\n                                        INDEXED BY gift-idx.\n\n01  ordinals-area VALUE \"first     second    third     fourth    fifth     \"\n    & \"sixth     seventh   eighth    ninth     tenth     eleventh  twelfth   \".\n    03  ordinals                        PIC X(10) OCCURS 12 TIMES.\n\n01  day-num                             PIC 99 COMP.\n                                        \nPROCEDURE DIVISION.\n    PERFORM VARYING day-num FROM 1 BY 1 UNTIL day-num > 12\n        DISPLAY \"On the \" FUNCTION TRIM(ordinals (day-num)) \" day of Christmas,\"\n            \" my true love gave to me\"\n\n        IF day-num = 1\n            DISPLAY \"A \" gifts (1)\n        ELSE\n            PERFORM VARYING gift-idx FROM day-num BY -1 UNTIL gift-idx = 1\n                DISPLAY gifts (gift-idx)\n            END-PERFORM\n            DISPLAY \"And a \" gifts (1)\n        END-IF\n        \n        DISPLAY SPACE\n    END-PERFORM\n    .\nEND PROGRAM twelve-days-of-christmas.\n", "target": "public class TwelveDaysOfChristmas {\n\n    final static String[] gifts = {\n        \"A partridge in a pear tree.\", \"Two turtle doves and\",\n        \"Three french hens\", \"Four calling birds\",\n        \"Five golden rings\", \"Six geese a-laying\",\n        \"Seven swans a-swimming\", \"Eight maids a-milking\",\n        \"Nine ladies dancing\", \"Ten lords a-leaping\",\n        \"Eleven pipers piping\", \"Twelve drummers drumming\",\n        \"And a partridge in a pear tree.\", \"Two turtle doves\"\n    };\n\n    final static String[] days = {\n        \"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\",\n        \"eighth\", \"ninth\", \"tenth\", \"eleventh\", \"Twelfth\"\n    };\n\n    public static void main(String[] args) {\n        for (int i = 0; i < days.length; i++) {\n            System.out.printf(\"%nOn the %s day of Christmas%n\", days[i]);\n            System.out.println(\"My true love gave to me:\");\n            for (int j = i; j >= 0; j--)\n                System.out.println(gifts[i == 11 && j < 2 ? j + 12 : j]);\n        }\n    }\n}\n"}
{"id": 165298, "name": "The Twelve Days of Christmas", "source": "Translate COBOL to Python:        >>SOURCE FREE\nPROGRAM-ID. twelve-days-of-christmas.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  gifts-area VALUE \"partridge in a pear tree    \"\n    & \"Two turtle doves              \"\n    & \"Three french hens             \"\n    & \"Four calling birds            \"\n    & \"FIVE GOLDEN RINGS             \"\n    & \"Six geese a-laying            \"\n    & \"Seven swans a-swimming        \"\n    & \"Eight maids a-milking         \"\n    & \"Nine ladies dancing           \"\n    & \"Ten lords a-leaping           \"\n    & \"Eleven pipers piping          \"\n    & \"Twelve drummers drumming      \".\n    03  gifts                           PIC X(30) OCCURS 12 TIMES\n                                        INDEXED BY gift-idx.\n\n01  ordinals-area VALUE \"first     second    third     fourth    fifth     \"\n    & \"sixth     seventh   eighth    ninth     tenth     eleventh  twelfth   \".\n    03  ordinals                        PIC X(10) OCCURS 12 TIMES.\n\n01  day-num                             PIC 99 COMP.\n                                        \nPROCEDURE DIVISION.\n    PERFORM VARYING day-num FROM 1 BY 1 UNTIL day-num > 12\n        DISPLAY \"On the \" FUNCTION TRIM(ordinals (day-num)) \" day of Christmas,\"\n            \" my true love gave to me\"\n\n        IF day-num = 1\n            DISPLAY \"A \" gifts (1)\n        ELSE\n            PERFORM VARYING gift-idx FROM day-num BY -1 UNTIL gift-idx = 1\n                DISPLAY gifts (gift-idx)\n            END-PERFORM\n            DISPLAY \"And a \" gifts (1)\n        END-IF\n        \n        DISPLAY SPACE\n    END-PERFORM\n    .\nEND PROGRAM twelve-days-of-christmas.\n", "target": "gifts = .split('\\n')\n\ndays = .split()\n\nfor n, day in enumerate(days, 1):\n    g = gifts[:n][::-1]\n    print(('\\nOn the %s day of Christmas\\nMy true love gave to me:\\n' % day) +\n          '\\n'.join(g[:-1]) +\n          (' and\\n' + g[-1] if n > 1 else g[-1].capitalize()))\n"}

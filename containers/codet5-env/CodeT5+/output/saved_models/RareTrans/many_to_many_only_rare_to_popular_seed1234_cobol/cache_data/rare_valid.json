{"id": 335908, "name": "Validate International Securities Identification Number", "source": "Translate COBOL to Java:         >>SOURCE FORMAT FREE\n\nidentification division.\nprogram-id. callISINtest.\ndata division.\nworking-storage section.\n01  ISINtest-result binary-int.\nprocedure division.\nstart-callISINtest.\n    display 'should be valid ' with no advancing\n    call 'ISINtest' using 'US0378331005' ISINtest-result\n    perform display-ISINtest-result\n    display 'should not be valid ' with no advancing\n    call 'ISINtest' using 'US0373831005' ISINtest-result\n    perform display-ISINtest-result\n    display 'should not be valid ' with no advancing\n    call 'ISINtest' using 'U50378331005' ISINtest-result\n    perform display-ISINtest-result\n    display 'should not be valid ' with no advancing\n    call 'ISINtest' using 'US03378331005' ISINtest-result\n    perform display-ISINtest-result\n    display 'should be valid ' with no advancing\n    call 'ISINtest' using 'AU0000XVGZA3' ISINtest-result\n    perform display-ISINtest-result\n    display 'should be valid ' with no advancing\n    call 'ISINtest' using 'AU0000VXGZA3' ISINtest-result\n    perform display-ISINtest-result\n    display 'should be valid ' with no advancing\n    call 'ISINtest' using 'FR0000988040' ISINtest-result\n    perform display-ISINtest-result\n    stop run\n    .\ndisplay-ISINtest-result.\n    evaluate ISINtest-result\n    when 0 \n        display ' is valid'\n    when -1\n        display ' invalid length '\n    when -2\n        display ' invalid countrycode '\n    when -3\n        display ' invalid base36 digit '\n    when -4\n        display ' luhn test failed'\n    when other\n        display ' invalid return code ' ISINtest-result\n    end-evaluate\n    .\nend program callISINtest.\n\nidentification division.\nprogram-id. ISINtest.\ndata division.\nworking-storage section.\n01  country-code-values value\n    'ADAEAFAGAIALAMAOAQARASATAUAWAXAZBABBBDBEBFBGBHBIBJBLBMBNBOBQBRBS'\n&   'BTBVBWBYBZCACCCDCFCGCHCICKCLCMCNCOCRCUCVCWCXCYCZDEDJDKDMDODZECEE'\n&   'EGEHERESETFIFJFKFMFOFRGAGBGDGEGFGGGHGIGLGMGNGPGQGRGSGTGUGWGYHKHM'\n&   'HNHRHTHUIDIEILIMINIOIQIRISITJEJMJOJPKEKGKHKIKMKNKPKRKWKYKZLALBLC'\n&   'LILKLRLSLTLULVLYMAMCMDMEMFMGMHMKMLMMMNMOMPMQMRMSMTMUMVMWMXMYMZNA'\n&   'NCNENFNGNINLNONPNRNUNZOMPAPEPFPGPHPKPLPMPNPRPSPTPWPYQARERORSRURW'\n&   'SASBSCSDSESGSHSISJSKSLSMSNSOSRSSSTSVSXSYSZTCTDTFTGTHTJTKTLTMTNTO'\n&   'TRTTTVTWTZUAUGUMUSUYUZVAVCVEVGVIVNVUWFWSYEYTZAZMZW'.\n    03  country-codes occurs 249\n        ascending key country-code\n        indexed by cc-idx.\n        05  country-code pic xx.\n\n01  b pic 99.\n01  base36-digits pic x(36) value\n    '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n\n01  i pic 99.\n01  p pic 99.\n01  luhn-number pic x(20).\n01  luhntest-result binary-int.\n\nlinkage section.\n01  test-number any length.\n01  ISINtest-result binary-int.\n\nprocedure division using test-number ISINtest-result.\nstart-ISINtest.\n    display space test-number with no advancing\n\n    \n    if function length(test-number) <> 12\n        move -1 to ISINtest-result\n        goback\n    end-if\n\n    \n    search all country-codes\n    at end\n        move -2 to ISINtest-result\n        goback\n    when test-number(1:2) = country-code(cc-idx)\n        continue \n    end-search\n\n    \n    \n    move 0 to p\n    perform varying i from 1 by 1 until i > 12\n        if test-number(i:1) >= '0' and <= '9'\n            move test-number(i:1) to luhn-number(p + 1:1)\n            add 1 to p\n        else\n            perform varying b from 9 by 1 until b > 35\n            or base36-digits(b + 1:1) = test-number(i:1)\n                continue\n            end-perform\n            if b > 35\n                 move -3 to ISINtest-result\n                 goback\n            end-if\n            move b to luhn-number(p + 1:2)\n            add 2 to p\n        end-if\n    end-perform\n\n    call 'luhntest' using luhn-number(1:p) luhntest-result\n    if luhntest-result <> 0\n        move -4 to ISINtest-result\n        goback\n    end-if\n\n    move 0 to ISINtest-result\n    goback\n    .\nend program ISINtest.\n\nidentification division.\nprogram-id. luhntest.\ndata division.\nworking-storage section.\n01  i pic S99.\n01  check-sum pic 999.\nlinkage section.\n01  test-number any length.\n01  luhntest-result binary-int.\nprocedure division using test-number luhntest-result.\nstart-luhntest.\n    display space test-number with no advancing\n    move 0 to check-sum\n\n    \n    compute i = function length(test-number)\n    perform varying i from i by -2 until i < 1\n        add function numval(test-number(i:1)) to check-sum\n    end-perform\n    display space check-sum with no advancing\n\n    \n    compute i = function length(test-number) - 1\n    perform varying i from i by -2 until i < 1\n        add function numval(test-number(i:1)) to check-sum\n        add function numval(test-number(i:1)) to check-sum\n        \n        if test-number(i:1) >= '5'\n            subtract 9 from check-sum\n        end-if\n    end-perform\n    display space check-sum with no advancing\n\n    if function mod(check-sum,10) = 0\n        move 0 to luhntest-result \n    else\n        move -1 to luhntest-result \n    end-if\n    goback\n    .\nend program luhntest.\n", "target": "public class ISIN {\n \n    public static void main(String[] args) {\n        String[] isins = {\n            \"US0378331005\", \n            \"US0373831005\", \n            \"U50378331005\", \n            \"US03378331005\",\n            \"AU0000XVGZA3\", \n            \"AU0000VXGZA3\", \n            \"FR0000988040\"\n        };\n        for (String isin : isins)\n            System.out.printf(\"%s is %s\\n\", isin, ISINtest(isin) ? \"valid\" : \"not valid\");\n    }\n \n    static boolean ISINtest(String isin) {\n        isin = isin.trim().toUpperCase();\n \n        if (!isin.matches(\"^[A-Z]{2}[A-Z0-9]{9}\\\\d$\"))\n            return false;\n \n        StringBuilder sb = new StringBuilder();\n        for (char c : isin.substring(0, 12).toCharArray())\n            sb.append(Character.digit(c, 36));\n \n        return luhnTest(sb.toString());\n    }\n\n    static boolean luhnTest(String number) {\n        int s1 = 0, s2 = 0;\n        String reverse = new StringBuffer(number).reverse().toString();\n        for (int i = 0; i < reverse.length(); i++){\n            int digit = Character.digit(reverse.charAt(i), 10);\n            \n            if (i % 2 == 0){\n                s1 += digit;\n            } else { \n                s2 += 2 * digit;\n                if(digit >= 5){\n                    s2 -= 9;\n                }\n            }\n        }\n        return (s1 + s2) % 10 == 0;\n    }\n}\n"}
{"id": 335909, "name": "ABC words", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ABC-WORDS.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT DICT ASSIGN TO DISK\n           ORGANIZATION LINE SEQUENTIAL.\n           \n       DATA DIVISION.\n       FILE SECTION.\n       FD DICT \n           LABEL RECORD STANDARD\n           VALUE OF FILE-ID IS \"unixdict.txt\".\n       01 WORD            PIC X(32).\n       \n       WORKING-STORAGE SECTION.\n       01 A               PIC 99.\n       01 B               PIC 99.\n       01 C               PIC 99.\n       01 X               PIC 99.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           OPEN INPUT DICT.\n           \n       READ-WORD.\n           READ DICT, AT END CLOSE DICT, STOP RUN.\n           PERFORM CHECK-WORD.\n           GO TO READ-WORD.\n           \n       CHECK-WORD.\n           MOVE ZERO TO A, B, C, X.\n           INSPECT WORD TALLYING A FOR CHARACTERS BEFORE INITIAL 'a'.\n           INSPECT WORD TALLYING B FOR CHARACTERS BEFORE INITIAL 'b'.\n           INSPECT WORD TALLYING C FOR CHARACTERS BEFORE INITIAL 'c'.\n           INSPECT WORD TALLYING X FOR CHARACTERS BEFORE INITIAL ' '.\n           IF A IS LESS THAN B \n           AND B IS LESS THAN C \n           AND C IS LESS THAN X,\n               DISPLAY WORD.\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class AbcWords {\n    public static void main(String[] args) {\n        String fileName = \"unixdict.txt\";\n        String chars = \"abc\";\n        for (int i = 0; i + 1 < args.length\n                && args[i].length() > 1\n                && args[i].charAt(0) == '-'; ++i) {\n            switch (args[i].charAt(1)) {\n            case 'f':\n                fileName = args[++i];\n                break;\n            case 'c':\n                chars = args[++i];\n                break;\n            }\n        }\n        \n        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n            String line;\n            int n = 0;\n            while ((line = reader.readLine()) != null) {\n                if (match(line, chars)) {\n                    ++n;\n                    System.out.printf(\"%3d:\u00a0%-20s\", n, line);\n                    if (n % 3 == 0)\n                        System.out.println();\n                }\n            }\n            if (n > 0 && n % 3 != 0)\n                System.out.println();\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n\n    \n    \n    private static boolean match(String word, String chars) {\n        int length = chars.length();\n        boolean[] seen = new boolean[length];\n        int wordLength = word.length();\n        for (int w = 0; w < wordLength; ++w) {\n            char ch = word.charAt(w);\n            int index = -1;\n            for (int c = 0; c < length; ++c) {\n                if (ch == chars.charAt(c) && !seen[c]) {\n                    index = c;\n                    break;\n                }\n            }\n            if (index == -1)\n                continue;\n            if (index + 1 == length)\n                return index == 0 ? true : seen[index - 1];\n            if (index > 0 && !seen[index - 1])\n                return false;\n            seen[index] = true;\n        }\n        return false;\n    }\n}\n"}
{"id": 335910, "name": "Two identical strings", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  IDENTICAL-STRINGS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 INPUT-NUMBER            PIC 9(4).\n          03 BINARY-REPRESENTATION   PIC 9(10).\n          03 BIT                     REDEFINES BINARY-REPRESENTATION,\n                                     PIC 9 OCCURS 10 TIMES.\n          03 FIRST-SET-BIT           PIC 99.\n          03 CURRENT-BIT             PIC 99.\n          03 SECOND-BIT              PIC 99.\n          03 BIT-VALUE               PIC 9(4).\n          03 OUTPUT-NUMBER           PIC 9(4) VALUE ZERO.\n          03 REMAINING-BITS          PIC 9(4)V9.\n          03 FILLER                  REDEFINES REMAINING-BITS.\n             05 REST                 PIC 9(4).\n             05 FILLER               PIC 9.\n                88 BIT-IS-SET        VALUE 5.\n\n       01 OUTPUT-FORMAT.\n          03 DECIMAL-OUTPUT          PIC Z(3)9.\n          03 BINARY-OUTPUT           PIC Z(9)9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM IDENTICAL-STRING\n               VARYING INPUT-NUMBER FROM 1 BY 1\n               UNTIL OUTPUT-NUMBER IS GREATER THAN 1000.\n           STOP RUN.\n\n       IDENTICAL-STRING.\n           MOVE ZERO TO BINARY-REPRESENTATION.\n           MOVE 10 TO CURRENT-BIT.\n           MOVE INPUT-NUMBER TO REMAINING-BITS.\n           PERFORM EXTRACT-BIT UNTIL REMAINING-BITS EQUAL ZERO.\n           MOVE CURRENT-BIT TO FIRST-SET-BIT.\n           MOVE 10 TO SECOND-BIT.\n           PERFORM COPY-BIT UNTIL SECOND-BIT IS EQUAL TO FIRST-SET-BIT.\n           MOVE ZERO TO OUTPUT-NUMBER.\n           IF CURRENT-BIT IS EQUAL TO ZERO, MOVE 1 TO CURRENT-BIT.\n           PERFORM INSERT-BIT\n               VARYING CURRENT-BIT FROM CURRENT-BIT BY 1\n               UNTIL CURRENT-BIT IS GREATER THAN 10.\n           MOVE OUTPUT-NUMBER TO DECIMAL-OUTPUT.\n           MOVE BINARY-REPRESENTATION TO BINARY-OUTPUT.\n           IF OUTPUT-NUMBER IS LESS THAN 1000,\n               DISPLAY DECIMAL-OUTPUT \": \" BINARY-OUTPUT.\n\n       EXTRACT-BIT.\n           DIVIDE 2 INTO REMAINING-BITS.\n           IF BIT-IS-SET, MOVE 1 TO BIT(CURRENT-BIT).\n           SUBTRACT 1 FROM CURRENT-BIT.\n           MOVE REST TO REMAINING-BITS.\n\n       COPY-BIT.\n           MOVE BIT(SECOND-BIT) TO BIT(CURRENT-BIT).\n           SUBTRACT 1 FROM SECOND-BIT.\n           SUBTRACT 1 FROM CURRENT-BIT.\n\n       INSERT-BIT.\n           COMPUTE BIT-VALUE = 2 ** (10 - CURRENT-BIT)\n           MULTIPLY BIT(CURRENT-BIT) BY BIT-VALUE.\n           ADD BIT-VALUE TO OUTPUT-NUMBER.\n", "target": "public class TwoIdenticalStrings {\n    public static void main(String[] args) {\n        System.out.println(\"Decimal Binary\");\n        for (int i = 0; i < 1_000; i++) {\n            String binStr = Integer.toBinaryString(i);\n            if (binStr.length() % 2 == 0) {\n                int len = binStr.length() / 2;\n                if (binStr.substring(0, len).equals(binStr.substring(len))) {\n                    System.out.printf(\"%7d %s%n\", i, binStr);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 335911, "name": "Call a foreign-language function", "source": "Translate COBOL to Java:        identification division.\n       program-id. foreign.\n\n       data division.\n       working-storage section.\n       01 hello.\n          05 value z\"Hello, world\".\n       01 duplicate    usage pointer.\n       01 buffer       pic x(16) based.\n       01 storage      pic x(16).\n\n       procedure division.\n       call \"strdup\" using hello returning duplicate\n           on exception\n               display \"error calling strdup\" upon syserr\n       end-call\n       if duplicate equal null then\n           display \"strdup returned null\" upon syserr\n       else\n           set address of buffer to duplicate\n           string buffer delimited by low-value into storage\n           display function trim(storage)\n           call \"free\" using by value duplicate\n               on exception\n                   display \"error calling free\" upon syserr\n       end-if\n       goback.\n", "target": "public class JNIDemo\n{\n  static\n  {  System.loadLibrary(\"JNIDemo\");  }\n  \n  public static void main(String[] args)\n  {\n    System.out.println(callStrdup(\"Hello World!\"));\n  }\n  \n  private static native String callStrdup(String s);\n}\n"}
{"id": 335912, "name": "Soundex", "source": "Translate COBOL to Java:       **** sndxtest *********************************************\n      * Demonstrate the soundex encoding functions.\n      ***************************************************************\n       Identification division.\n       Program-id. sndxtest.\n\n       Data division.\n       Working-storage section.\n       01 sample-word-list.\n           05 sample-words.\n               10 filler pic x(15) value \"soundex\".\n               10 filler pic x(15) value \"example\".\n               10 filler pic x(15) value \"sownteks\".\n               10 filler pic x(15) value \"ekzampul\".\n               10 filler pic x(15) value \"Euler\".\n               10 filler pic x(15) value \"Gauss\".\n               10 filler pic x(15) value \"Hilbert\".\n               10 filler pic x(15) value \"Knuth\".\n               10 filler pic x(15) value \"Lloyd\".\n               10 filler pic x(15) value \"Lukasiewicz\".\n               10 filler pic x(15) value \"Ellery\".\n               10 filler pic x(15) value \"ghosh\".\n               10 filler pic x(15) value \"Heilbronn\".\n               10 filler pic x(15) value \"Kand\".\n               10 filler pic x(15) value \"Ladd\".\n               10 filler pic x(15) value \"lissajous\".\n               10 filler pic x(15) value \"Wheaton\".\n               10 filler pic x(15) value \"Burroughs\".\n               10 filler pic x(15) value \"burrows\".\n               10 filler pic x(15) value \"O'Hara\".\n               10 filler pic x(15) value \"Washington\".\n               10 filler pic x(15) value \"lee\".\n               10 filler pic x(15) value \"Gutierrez\".\n               10 filler pic x(15) value \"Phister\".\n               10 filler pic x(15) value \"Jackson\".\n               10 filler pic x(15) value \"tymczak\".\n               10 filler pic x(15) value \"Vandeusen\".\n               10 filler pic x(15) value \"Ashcraft\".\n           05 sample-word redefines sample-words\n                         pic x(15) occurs 28 times indexed by wrd-idx.\n       01 wrd-code       pic x999.\n\n       Procedure division.\n           Perform varying wrd-idx from 1 by 1\n           until wrd-idx greater than 28\n               call \"sndxenc\" using\n                   by reference sample-word(wrd-idx)\n                   by reference wrd-code\n               display wrd-code \" \" sample-word(wrd-idx)\n           end-perform.\n           Stop run.\n\n       End program sndxtest.\n\n      *** sndxenc ********************************************\n      * Given a string return its soundex encoding.\n      ***************************************************************\n       Identification division.\n       Program-id. sndxenc.\n\n       Data division.\n       Local-storage section.\n       01 str-idx            pic 99.\n       01 let-code           pic  9.\n       01 prv-let-code       pic  9.\n       01 sdx-idx            pic  9  value 1.\n\n       Linkage section.\n       01 str-to-encode.\n           05 str-first-let  pic x.\n           05 str-rest-let   pic x  occurs 14 times.\n       01 sdx-code.\n           05 sdx-first-let  pic x.\n           05 sdx-nums       pic 9  occurs  3 times.\n\n       Procedure division using\n           by reference str-to-encode\n           by reference sdx-code.\n           Perform encode-start thru encode-done.\n           Goback.\n\n       Encode-start.\n           Move zeros to sdx-code.\n           Move function upper-case(str-first-let) to sdx-first-let.\n           Call \"sndxchar\" using\n               by reference str-first-let\n               by reference let-code.\n           Move let-code to prv-let-code.\n\n       Encode-string.\n           Perform varying str-idx from 1 by 1\n               until str-idx greater than 15\n               or str-rest-let(str-idx) = space\n               or sdx-idx greater than 3\n               call \"sndxchar\" using\n                   by reference str-rest-let(str-idx)\n                   by reference let-code\n               if let-code not equal 7 then\n                   if let-code not equal 0\n                   and let-code not equal prv-let-code\n                       move let-code to sdx-nums(sdx-idx)\n                       add 1 to sdx-idx\n                   end-if\n                   move let-code to prv-let-code\n               end-if\n           end-perform.\n\n       Encode-done.\n           continue.\n       End program sndxenc.\n\n\n      *** sndxchar **********************************************\n      * Given a character, return its soundex encoding.\n      * Code 7 is for h or w, which an encoder should ignore when\n      * either one separates double letters.\n      ***************************************************************\n       Identification division.\n       Program-id. sndxchar.\n\n       Data division.\n       Local-storage section.\n       01 lc-chr pic x.\n           88 code1 value \"b\", \"f\", \"p\", \"v\".\n           88 code2 value \"c\", \"g\", \"j\", \"k\", \"q\", \"s\", \"x\", \"z\".\n           88 code3 value \"d\", \"t\".\n           88 code4 value \"l\".\n           88 code5 value \"m\", \"n\".\n           88 code6 value \"r\".\n           88 code7 value \"h\", \"w\".\n\n       Linkage section.\n       01 char-to-encode pic x.\n       01 char-sdx-code  pic 9.\n\n       Procedure division using\n           by reference char-to-encode\n           by reference char-sdx-code.\n           Move function lower-case(char-to-encode) to lc-chr.\n           If          code1 then move 1 to char-sdx-code\n               else if code2 then move 2 to char-sdx-code\n               else if code3 then move 3 to char-sdx-code\n               else if code4 then move 4 to char-sdx-code\n               else if code5 then move 5 to char-sdx-code\n               else if code6 then move 6 to char-sdx-code\n               else if code7 then move 7 to char-sdx-code\n               else               move 0 to char-sdx-code\n           end-if.\n       End program sndxchar.\n", "target": "public static void main(String[] args){\n    System.out.println(soundex(\"Soundex\"));\n    System.out.println(soundex(\"Example\"));\n    System.out.println(soundex(\"Sownteks\"));\n    System.out.println(soundex(\"Ekzampul\"));\n  }\n\nprivate static String getCode(char c){\n  switch(c){\n    case 'B': case 'F': case 'P': case 'V':\n      return \"1\";\n    case 'C': case 'G': case 'J': case 'K':\n    case 'Q': case 'S': case 'X': case 'Z':\n      return \"2\";\n    case 'D': case 'T':\n      return \"3\";\n    case 'L':\n      return \"4\";\n    case 'M': case 'N':\n      return \"5\";\n    case 'R':\n      return \"6\";\n    default:\n      return \"\";\n  }\n}\n\npublic static String soundex(String s){\n  String code, previous, soundex;\n  code = s.toUpperCase().charAt(0) + \"\";\n\n  \n  previous = getCode(s.toUpperCase().charAt(0));\n\n  for(int i = 1;i < s.length();i++){\n    String current = getCode(s.toUpperCase().charAt(i));\n    if(current.length() > 0 && !current.equals(previous)){\n      code = code + current;\n    }\n    previous = current;\n  }\n  soundex = (code + \"0000\").substring(0, 4);\n  return soundex;\n}\n"}
{"id": 335913, "name": "Disarium numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DISARIUM.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE     PIC 9(9).\n          03 DIGITS        PIC 9 OCCURS 9 TIMES, REDEFINES CANDIDATE.\n          03 IDX           PIC 99.\n          03 EXPONENT      PIC 99.\n          03 DGT-POWER     PIC 9(9).\n          03 DGT-POWER-SUM PIC 9(9).\n          03 CAND-OUT      PIC Z(8)9.\n          03 AMOUNT        PIC 99 VALUE 18.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM DISARIUM-TEST VARYING CANDIDATE FROM ZERO BY 1\n           UNTIL AMOUNT IS ZERO.\n           STOP RUN.\n        \n       DISARIUM-TEST.\n           MOVE ZERO TO DGT-POWER-SUM.\n           MOVE 1 TO EXPONENT, IDX.\n           INSPECT CANDIDATE TALLYING IDX FOR LEADING ZEROES.\n           PERFORM ADD-DIGIT-POWER UNTIL IDX IS GREATER THAN 9.\n           IF DGT-POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO CAND-OUT,\n               DISPLAY CAND-OUT,\n               SUBTRACT 1 FROM AMOUNT.\n           \n       ADD-DIGIT-POWER.\n           COMPUTE DGT-POWER = DIGITS(IDX) ** EXPONENT.\n           ADD DGT-POWER TO DGT-POWER-SUM.\n           ADD 1 TO EXPONENT.\n           ADD 1 TO IDX.\n", "target": "import java.lang.Math;\n\npublic class DisariumNumbers {\n    public static boolean is_disarium(int num) {\n        int n = num;\n        int len = Integer.toString(n).length();\n        int sum = 0;\n        int i = 1;\n        while (n > 0) {\n            sum += Math.pow(n % 10, len - i + 1);\n            n /= 10;\n            i ++;\n        }\n        return sum  == num;\n    }\n\n    public static void main(String[] args) {\n        int i = 0;\n        int count = 0;\n        while (count <= 18) {\n            if (is_disarium(i)) {\n                System.out.printf(\"%d \", i);\n                count++;\n            }\n            i++;\n        }\n        System.out.printf(\"%s\", \"\\n\");\n    }\n}\n"}
{"id": 335914, "name": "Disarium numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DISARIUM.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE     PIC 9(9).\n          03 DIGITS        PIC 9 OCCURS 9 TIMES, REDEFINES CANDIDATE.\n          03 IDX           PIC 99.\n          03 EXPONENT      PIC 99.\n          03 DGT-POWER     PIC 9(9).\n          03 DGT-POWER-SUM PIC 9(9).\n          03 CAND-OUT      PIC Z(8)9.\n          03 AMOUNT        PIC 99 VALUE 18.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM DISARIUM-TEST VARYING CANDIDATE FROM ZERO BY 1\n           UNTIL AMOUNT IS ZERO.\n           STOP RUN.\n        \n       DISARIUM-TEST.\n           MOVE ZERO TO DGT-POWER-SUM.\n           MOVE 1 TO EXPONENT, IDX.\n           INSPECT CANDIDATE TALLYING IDX FOR LEADING ZEROES.\n           PERFORM ADD-DIGIT-POWER UNTIL IDX IS GREATER THAN 9.\n           IF DGT-POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO CAND-OUT,\n               DISPLAY CAND-OUT,\n               SUBTRACT 1 FROM AMOUNT.\n           \n       ADD-DIGIT-POWER.\n           COMPUTE DGT-POWER = DIGITS(IDX) ** EXPONENT.\n           ADD DGT-POWER TO DGT-POWER-SUM.\n           ADD 1 TO EXPONENT.\n           ADD 1 TO IDX.\n", "target": "import java.lang.Math;\n\npublic class DisariumNumbers {\n    public static boolean is_disarium(int num) {\n        int n = num;\n        int len = Integer.toString(n).length();\n        int sum = 0;\n        int i = 1;\n        while (n > 0) {\n            sum += Math.pow(n % 10, len - i + 1);\n            n /= 10;\n            i ++;\n        }\n        return sum  == num;\n    }\n\n    public static void main(String[] args) {\n        int i = 0;\n        int count = 0;\n        while (count <= 18) {\n            if (is_disarium(i)) {\n                System.out.printf(\"%d \", i);\n                count++;\n            }\n            i++;\n        }\n        System.out.printf(\"%s\", \"\\n\");\n    }\n}\n"}
{"id": 335915, "name": "Flow-control structures", "source": "Translate COBOL to Java:        PROGRAM-ID. Go-To-Example.\n\n       PROCEDURE DIVISION.\n       Foo.\n           DISPLAY \"Just a reminder: GO TOs are evil.\"\n\n           GO TO Foo\n           .\n", "target": "switch (xx) {\n  case 1:\n  case 2:\n    \n    ...\n    break;\n  case 4:\n    \n    ...\n    break;\n  case 5:\n    \n    ...\n    break;\n  default:\n    \n    break;\n}\n\nfor (int i = 0; i < 10; ++i) {\n  ...\n  if (some_condition) { break; }\n  ...\n}\n\n_Time_: do {\n  for (int i = 0; i < 10; ++i) {\n    ...\n    if (some_condition) { break _Time_; }\n    ...\n    }\n  ...\n} while (thisCondition);\n"}
{"id": 335916, "name": "Return multiple values", "source": "Translate COBOL to Java:        identification division.\n       program-id. multiple-values.\n\n       environment division.\n       configuration section.\n       repository.\n           function multiples\n           function all intrinsic.\n\n       REPLACE ==:linked-items:== BY ==\n       01 a usage binary-long.\n       01 b pic x(10).\n       01 c usage float-short.\n       ==\n       ==:record-item:== BY ==\n       01 master.\n          05 ma usage binary-long.\n          05 mb pic x(10).\n          05 mc usage float-short.\n       ==.\n\n       data division.\n       working-storage section.\n       :linked-items:\n\n       :record-item:\n       \n       procedure division.\n       sample-main.\n\n       move 41 to a\n       move \"aaaaabbbbb\" to b\n       move function e to c\n\n       display \"Original: \" a \", \" b \", \" c\n       call \"subprogram\" using a b c\n       display \"Modified: \" a \", \" b \", \" c\n       \n       move multiples() to master\n       display \"Multiple: \" ma \", \" mb \", \" mc\n\n       goback.\n       end program multiple-values.\n\n      \n       identification division.\n       program-id. subprogram.\n\n       data division.\n       linkage section.\n       :linked-items:\n\n       procedure division using a b c.\n       add 1 to a\n       inspect b converting \"a\" to \"b\"\n       divide 2 into c\n       goback.\n       end program subprogram.\n\n      \n       identification division.\n       function-id. multiples.\n\n       data division.\n       linkage section.\n       :record-item:\n\n       procedure division returning master.\n       move 84 to ma\n       move \"multiple\" to mb\n       move function pi to mc\n       goback.\n       end function multiples.\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\n\npublic class RReturnMultipleVals {\n  public static final String K_lipsum = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\";\n  public static final Long   K_1024   = 1024L;\n  public static final String L        = \"L\";\n  public static final String R        = \"R\";\n\n  \n  public static void main(String[] args) throws NumberFormatException{\n    Long nv_;\n    String sv_;\n    switch (args.length) {\n      case 0:\n        nv_ = K_1024;\n        sv_ = K_lipsum;\n        break;\n      case 1:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = K_lipsum;\n        break;\n      case 2:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = args[1];\n        break;\n      default:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = args[1];\n        for (int ix = 2; ix < args.length; ++ix) {\n          sv_ = sv_ + \" \" + args[ix];\n        }\n        break;\n    }\n\n    RReturnMultipleVals lcl = new RReturnMultipleVals();\n\n    Pair<Long, String> rvp = lcl.getPairFromPair(nv_, sv_); \n    System.out.println(\"Results extracted from a composite object:\");\n    System.out.printf(\"%s, %s%n%n\", rvp.getLeftVal(), rvp.getRightVal());\n\n    List<Object> rvl = lcl.getPairFromList(nv_, sv_); \n    System.out.println(\"Results extracted from a Java Colections \\\"List\\\" object:\");\n    System.out.printf(\"%s, %s%n%n\", rvl.get(0), rvl.get(1));\n\n    Map<String, Object> rvm = lcl.getPairFromMap(nv_, sv_); \n    System.out.println(\"Results extracted from a Java Colections \\\"Map\\\" object:\");\n    System.out.printf(\"%s, %s%n%n\", rvm.get(L), rvm.get(R));\n  }\n  \n  \n  \n  public <T, U> Pair<T, U> getPairFromPair(T vl_, U vr_) {\n    return new Pair<T, U>(vl_, vr_);\n  }\n  \n  \n  \n  public List<Object> getPairFromList(Object nv_, Object sv_) {\n    List<Object> rset = new ArrayList<Object>();\n    rset.add(nv_);\n    rset.add(sv_);\n    return rset;\n  }\n  \n  \n  \n  public Map<String, Object> getPairFromMap(Object nv_, Object sv_) {\n    Map<String, Object> rset = new HashMap<String, Object>();\n    rset.put(L, nv_);\n    rset.put(R, sv_);\n    return rset;\n  }\n\n  \n  private static class Pair<L, R> {\n    private L leftVal;\n    private R rightVal;\n\n    public Pair(L nv_, R sv_) {\n      setLeftVal(nv_);\n      setRightVal(sv_);\n    }\n    public void setLeftVal(L nv_) {\n      leftVal = nv_;\n    }\n    public L getLeftVal() {\n      return leftVal;\n    }\n    public void setRightVal(R sv_) {\n      rightVal = sv_;\n    }\n    public R getRightVal() {\n      return rightVal;\n    }\n  }\n}\n"}
{"id": 335917, "name": "Substring_Top and tail", "source": "Translate COBOL to Java:        identification division.\n       program-id. toptail.\n\n       data division.\n       working-storage section.\n       01 data-field.\n          05 value \"[this is a test]\".\n\n       procedure division.\n       sample-main.\n       display data-field\n      \n       display data-field(2:)\n       display data-field(1:length of data-field - 1)\n       display data-field(2:length of data-field - 2)\n       goback.\n       end program toptail.\n", "target": "String strOrig = 'brooms';\nString str1 = strOrig.substring(1, strOrig.length());\nsystem.debug(str1);\nString str2 = strOrig.substring(0, strOrig.length()-1);\nsystem.debug(str2);\nString str3 = strOrig.substring(1, strOrig.length()-1);\nsystem.debug(str3);\n\n\nString strOrig = 'brooms';\nString str1 = strOrig.replaceAll( '^.', '' );\nsystem.debug(str1);\nString str2 = strOrig.replaceAll( '.$', '' ) ;\nsystem.debug(str2);\nString str3 = strOrig.replaceAll( '^.|.$', '' );\nsystem.debug(str3);\n"}
{"id": 335918, "name": "Substring_Top and tail", "source": "Translate COBOL to Java:        identification division.\n       program-id. toptail.\n\n       data division.\n       working-storage section.\n       01 data-field.\n          05 value \"[this is a test]\".\n\n       procedure division.\n       sample-main.\n       display data-field\n      \n       display data-field(2:)\n       display data-field(1:length of data-field - 1)\n       display data-field(2:length of data-field - 2)\n       goback.\n       end program toptail.\n", "target": "String strOrig = 'brooms';\nString str1 = strOrig.substring(1, strOrig.length());\nsystem.debug(str1);\nString str2 = strOrig.substring(0, strOrig.length()-1);\nsystem.debug(str2);\nString str3 = strOrig.substring(1, strOrig.length()-1);\nsystem.debug(str3);\n\n\nString strOrig = 'brooms';\nString str1 = strOrig.replaceAll( '^.', '' );\nsystem.debug(str1);\nString str2 = strOrig.replaceAll( '.$', '' ) ;\nsystem.debug(str2);\nString str3 = strOrig.replaceAll( '^.|.$', '' );\nsystem.debug(str3);\n"}
{"id": 335919, "name": "Boolean values", "source": "Translate COBOL to Java:        01  some-bool               PIC 1 BIT.\n", "target": "module GeorgeBoole\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Boolean f = False;\n        assert !f == True;\n\n        \n        \n        assert True.and(False) == True & False == False;\n        assert True.or(False)  == True | False == True;\n        assert True.xor(False) == True ^ False == True;\n        assert True.not() == ~True == False;\n\n        console.print($\"0==1 = {0==1}\");\n        console.print($\"!False = {!False}\");\n        }\n    }\n"}
{"id": 335920, "name": "First 9 prime Fibonacci number", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. PRIME-FIBONACCI.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 FIBONACCI-VARS.\n          03 FIB                PIC 9(6).\n          03 FIB-B              PIC 9(6).\n          03 FIB-C              PIC 9(6).\n          03 FIB-OUT            PIC Z(5)9.\n       01 PRIME-VARS.   \n          03 PRIME-FLAG         PIC X.\n             88 PRIME           VALUE 'X'.\n          03 DSOR               PIC 9(4).\n          03 DSOR-SQ            PIC 9(6).\n          03 DIV-RSLT           PIC 9(6)V9(3).\n          03 FILLER             REDEFINES DIV-RSLT.\n             05 FILLER          PIC 9(6).\n             05 FILLER          PIC 9(3).\n                88 DIVISIBLE    VALUE ZERO.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 1 TO FIB, FIB-B.\n           PERFORM FIND-PRIME-FIBONACCI 9 TIMES.\n           STOP RUN.\n       \n       FIND-PRIME-FIBONACCI.\n           ADD FIB, FIB-B GIVING FIB-C.\n           MOVE FIB-B TO FIB.\n           MOVE FIB-C TO FIB-B.\n           PERFORM CHECK-PRIME.\n           IF NOT PRIME, GO TO FIND-PRIME-FIBONACCI.\n           MOVE FIB TO FIB-OUT.\n           DISPLAY FIB-OUT.\n       \n       CHECK-PRIME SECTION.\n       BEGIN.\n           MOVE SPACE TO PRIME-FLAG.\n           IF FIB IS LESS THAN 5, GO TO TRIVIAL-PRIME.\n           DIVIDE FIB BY 2 GIVING DIV-RSLT.\n           IF DIVISIBLE, GO TO DONE.\n           DIVIDE FIB BY 3 GIVING DIV-RSLT.\n           IF DIVISIBLE, GO TO DONE.\n           MOVE 5 TO DSOR.\n           MOVE 25 TO DSOR-SQ.\n           MOVE 'X' TO PRIME-FLAG.\n           PERFORM TEST-DIVISOR \n           UNTIL NOT PRIME OR DSOR-SQ IS GREATER THAN FIB.\n           GO TO DONE.\n           \n       TEST-DIVISOR.\n           DIVIDE FIB BY DSOR GIVING DIV-RSLT.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n           ADD 2 TO DSOR.\n           DIVIDE FIB BY DSOR GIVING DIV-RSLT.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n           ADD 4 TO DSOR.\n           MULTIPLY DSOR BY DSOR GIVING DSOR-SQ.\n       \n       TRIVIAL-PRIME.\n           IF FIB IS EQUAL TO 2 OR 3, MOVE 'X' TO PRIME-FLAG.\n       DONE.\n           EXIT.\n", "target": "import java.math.BigInteger;\n\npublic class PrimeFibonacciGenerator {\n    private PrimeGenerator primeGen = new PrimeGenerator(10000, 200000);\n    private BigInteger f0 = BigInteger.ZERO;\n    private BigInteger f1 = BigInteger.ONE;\n    private int index = 0;\n\n    public static void main(String[] args) {\n        PrimeFibonacciGenerator gen = new PrimeFibonacciGenerator();\n        long start = System.currentTimeMillis();\n        for (int i = 1; i <= 26; ++i) {\n            BigInteger f = gen.next();\n            System.out.printf(\"%d: F(%d) = %s\\n\", i, gen.index - 1, toString(f));\n        }\n        long finish = System.currentTimeMillis();\n        System.out.printf(\"elapsed time: %g seconds\\n\", (finish - start)/1000.0);\n    }\n\n    private PrimeFibonacciGenerator() {\n        for (int i = 0; i < 2; ++i)\n            primeGen.nextPrime();\n    }\n\n    private BigInteger next() {\n        for (;;) {\n            if (index > 4) {\n                int p = primeGen.nextPrime();\n                for (; p > index; ++index)\n                    nextFibonacci();\n            }\n            ++index;\n            BigInteger f = nextFibonacci();\n            if (f.isProbablePrime(30))\n                return f;\n        }\n    }\n\n    private BigInteger nextFibonacci() {\n        BigInteger result = f0;\n        BigInteger f = f0.add(f1);\n        f0 = f1;\n        f1 = f;\n        return result;\n    }\n\n    private static String toString(BigInteger f) {\n        String str = f.toString();\n        if (str.length() > 40) {\n            StringBuilder s = new StringBuilder(str.substring(0, 20));\n            s.append(\"...\");\n            s.append(str.substring(str.length() - 20));\n            s.append(\" (\");\n            s.append(str.length());\n            s.append(\" digits)\");\n            str = s.toString();\n        }\n        return str;\n    }\n}\n"}
{"id": 335921, "name": "First 9 prime Fibonacci number", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. PRIME-FIBONACCI.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 FIBONACCI-VARS.\n          03 FIB                PIC 9(6).\n          03 FIB-B              PIC 9(6).\n          03 FIB-C              PIC 9(6).\n          03 FIB-OUT            PIC Z(5)9.\n       01 PRIME-VARS.   \n          03 PRIME-FLAG         PIC X.\n             88 PRIME           VALUE 'X'.\n          03 DSOR               PIC 9(4).\n          03 DSOR-SQ            PIC 9(6).\n          03 DIV-RSLT           PIC 9(6)V9(3).\n          03 FILLER             REDEFINES DIV-RSLT.\n             05 FILLER          PIC 9(6).\n             05 FILLER          PIC 9(3).\n                88 DIVISIBLE    VALUE ZERO.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 1 TO FIB, FIB-B.\n           PERFORM FIND-PRIME-FIBONACCI 9 TIMES.\n           STOP RUN.\n       \n       FIND-PRIME-FIBONACCI.\n           ADD FIB, FIB-B GIVING FIB-C.\n           MOVE FIB-B TO FIB.\n           MOVE FIB-C TO FIB-B.\n           PERFORM CHECK-PRIME.\n           IF NOT PRIME, GO TO FIND-PRIME-FIBONACCI.\n           MOVE FIB TO FIB-OUT.\n           DISPLAY FIB-OUT.\n       \n       CHECK-PRIME SECTION.\n       BEGIN.\n           MOVE SPACE TO PRIME-FLAG.\n           IF FIB IS LESS THAN 5, GO TO TRIVIAL-PRIME.\n           DIVIDE FIB BY 2 GIVING DIV-RSLT.\n           IF DIVISIBLE, GO TO DONE.\n           DIVIDE FIB BY 3 GIVING DIV-RSLT.\n           IF DIVISIBLE, GO TO DONE.\n           MOVE 5 TO DSOR.\n           MOVE 25 TO DSOR-SQ.\n           MOVE 'X' TO PRIME-FLAG.\n           PERFORM TEST-DIVISOR \n           UNTIL NOT PRIME OR DSOR-SQ IS GREATER THAN FIB.\n           GO TO DONE.\n           \n       TEST-DIVISOR.\n           DIVIDE FIB BY DSOR GIVING DIV-RSLT.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n           ADD 2 TO DSOR.\n           DIVIDE FIB BY DSOR GIVING DIV-RSLT.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n           ADD 4 TO DSOR.\n           MULTIPLY DSOR BY DSOR GIVING DSOR-SQ.\n       \n       TRIVIAL-PRIME.\n           IF FIB IS EQUAL TO 2 OR 3, MOVE 'X' TO PRIME-FLAG.\n       DONE.\n           EXIT.\n", "target": "import java.math.BigInteger;\n\npublic class PrimeFibonacciGenerator {\n    private PrimeGenerator primeGen = new PrimeGenerator(10000, 200000);\n    private BigInteger f0 = BigInteger.ZERO;\n    private BigInteger f1 = BigInteger.ONE;\n    private int index = 0;\n\n    public static void main(String[] args) {\n        PrimeFibonacciGenerator gen = new PrimeFibonacciGenerator();\n        long start = System.currentTimeMillis();\n        for (int i = 1; i <= 26; ++i) {\n            BigInteger f = gen.next();\n            System.out.printf(\"%d: F(%d) = %s\\n\", i, gen.index - 1, toString(f));\n        }\n        long finish = System.currentTimeMillis();\n        System.out.printf(\"elapsed time: %g seconds\\n\", (finish - start)/1000.0);\n    }\n\n    private PrimeFibonacciGenerator() {\n        for (int i = 0; i < 2; ++i)\n            primeGen.nextPrime();\n    }\n\n    private BigInteger next() {\n        for (;;) {\n            if (index > 4) {\n                int p = primeGen.nextPrime();\n                for (; p > index; ++index)\n                    nextFibonacci();\n            }\n            ++index;\n            BigInteger f = nextFibonacci();\n            if (f.isProbablePrime(30))\n                return f;\n        }\n    }\n\n    private BigInteger nextFibonacci() {\n        BigInteger result = f0;\n        BigInteger f = f0.add(f1);\n        f0 = f1;\n        f1 = f;\n        return result;\n    }\n\n    private static String toString(BigInteger f) {\n        String str = f.toString();\n        if (str.length() > 40) {\n            StringBuilder s = new StringBuilder(str.substring(0, 20));\n            s.append(\"...\");\n            s.append(str.substring(str.length() - 20));\n            s.append(\" (\");\n            s.append(str.length());\n            s.append(\" digits)\");\n            str = s.toString();\n        }\n        return str;\n    }\n}\n"}
{"id": 335922, "name": "Text processing_1", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. data-munging.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT input-file ASSIGN TO INPUT-FILE-PATH\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS file-status.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  input-file.\n       01  input-record.\n           03  date-stamp          PIC X(10).\n           03  FILLER              PIC X.\n           \n           \n           03  input-data-pairs    PIC X(300).\n\n       WORKING-STORAGE SECTION.\n       78  INPUT-FILE-PATH         VALUE \"readings.txt\".\n\n       01  file-status             PIC 99.\n           88 file-is-ok           VALUE 0.\n           88 end-of-file          VALUE 10.\n\n       01  data-pair.\n           03  val                 PIC 9(3)V9(3).\n           03  flag                PIC S9.\n               88  invalid-flag    VALUE -9 THRU 0.\n\n       01  val-length              PIC 9.\n       01  flag-length             PIC 9.\n       01  offset                  PIC 99.\n\n       01  day-total               PIC 9(5)V9(3).\n       01  grand-total             PIC 9(8)V9(3).\n       01  mean-val                PIC 9(8)V9(3).\n\n       01  day-rejected            PIC 9(5).\n       01  day-accepted            PIC 9(5).\n\n       01  total-rejected          PIC 9(8).\n       01  total-accepted          PIC 9(8).\n\n       01  current-data-gap        PIC 9(8).\n       01  max-data-gap            PIC 9(8).\n       01  max-data-gap-end        PIC X(10).\n\n       PROCEDURE DIVISION.\n       DECLARATIVES.\n       \n       input-file-error SECTION.\n           USE AFTER STANDARD ERROR ON input-file.\n           \n           DISPLAY\n               \"An error occurred while reading input.txt. \"\n               \"File error: \" file-status\n               \". The program will terminate.\"\n           END-DISPLAY\n\n           GOBACK\n           .\n            \n       END DECLARATIVES.\n\n       main-line.\n           \n           OPEN INPUT input-file\n           IF NOT file-is-ok\n               DISPLAY \"File could not be opened. The program will \"\n                   \"terminate.\"\n               GOBACK\n           END-IF\n\n           \n           PERFORM FOREVER\n               \n               READ input-file\n                   AT END\n                       EXIT PERFORM\n               END-READ\n\n               \n               PERFORM UNTIL input-data-pairs = SPACES\n                   \n                   \n                   UNSTRING input-data-pairs DELIMITED BY X\"09\"\n                       INTO val COUNT val-length, flag COUNT flag-length\n                   \n                   COMPUTE offset = val-length + flag-length + 3\n                   MOVE input-data-pairs (offset:) TO input-data-pairs\n\n                   \n                   IF NOT invalid-flag\n                       ADD val TO day-total, grand-total\n                       \n                       ADD 1 TO day-accepted, total-accepted\n                       \n                       IF max-data-gap < current-data-gap\n                           MOVE current-data-gap TO max-data-gap\n                           MOVE date-stamp TO max-data-gap-end\n                       END-IF\n                       \n                       MOVE ZERO TO current-data-gap\n                   ELSE\n                       ADD 1 TO current-data-gap, day-rejected,\n                           total-rejected\n                   END-IF\n               END-PERFORM\n\n               \n               DIVIDE day-total BY day-accepted GIVING mean-val\n               DISPLAY\n                   date-stamp \n                   \" Reject: \" day-rejected\n                   \" Accept: \" day-accepted\n                   \" Average: \" mean-val\n               END-DISPLAY\n\n               INITIALIZE day-rejected, day-accepted, mean-val,\n                   day-total\n           END-PERFORM\n\n           CLOSE input-file\n\n           \n           DISPLAY SPACE\n           DISPLAY \"File:         \" INPUT-FILE-PATH\n           DISPLAY \"Total:        \" grand-total\n           DISPLAY \"Readings:     \" total-accepted\n\n           DIVIDE grand-total BY total-accepted GIVING mean-val\n           DISPLAY \"Average:      \" mean-val\n\n           DISPLAY SPACE\n           DISPLAY \"Bad readings: \" total-rejected\n           DISPLAY \"Maximum number of consecutive bad readings is \"\n               max-data-gap\n           DISPLAY \"Ends on date \" max-data-gap-end\n\n           GOBACK\n           .\n", "target": "import java.io.File;\nimport java.util.*;\nimport static java.lang.System.out;\n\npublic class TextProcessing1 {\n\n    public static void main(String[] args) throws Exception {\n        Locale.setDefault(new Locale(\"en\", \"US\"));\n        Metrics metrics = new Metrics();\n\n        int dataGap = 0;\n        String gapBeginDate = null;\n        try (Scanner lines = new Scanner(new File(\"readings.txt\"))) {\n            while (lines.hasNextLine()) {\n\n                double lineTotal = 0.0;\n                int linePairs = 0;\n                int lineInvalid = 0;\n                String lineDate;\n\n                try (Scanner line = new Scanner(lines.nextLine())) {\n\n                    lineDate = line.next();\n\n                    while (line.hasNext()) {\n                        final double value = line.nextDouble();\n                        if (line.nextInt() <= 0) {\n                            if (dataGap == 0)\n                                gapBeginDate = lineDate;\n                            dataGap++;\n                            lineInvalid++;\n                            continue;\n                        }\n                        lineTotal += value;\n                        linePairs++;\n\n                        metrics.addDataGap(dataGap, gapBeginDate, lineDate);\n                        dataGap = 0;\n                    }\n                }\n                metrics.addLine(lineTotal, linePairs);\n                metrics.lineResult(lineDate, lineInvalid, linePairs, lineTotal);\n            }\n            metrics.report();\n        }\n    }\n\n    private static class Metrics {\n        private List<String[]> gapDates;\n        private int maxDataGap = -1;\n        private double total;\n        private int pairs;\n        private int lineResultCount;\n\n        void addLine(double tot, double prs) {\n            total += tot;\n            pairs += prs;\n        }\n\n        void addDataGap(int gap, String begin, String end) {\n            if (gap > 0 && gap >= maxDataGap) {\n                if (gap > maxDataGap) {\n                    maxDataGap = gap;\n                    gapDates = new ArrayList<>();\n                }\n                gapDates.add(new String[]{begin, end});\n            }\n        }\n\n        void lineResult(String date, int invalid, int prs, double tot) {\n            if (lineResultCount >= 3)\n                return;\n            out.printf(\"%10s  out: %2d  in: %2d  tot: %10.3f  avg: %10.3f%n\",\n                    date, invalid, prs, tot, (prs > 0) ? tot / prs : 0.0);\n            lineResultCount++;\n        }\n\n        void report() {\n            out.printf(\"%ntotal    = %10.3f%n\", total);\n            out.printf(\"readings = %6d%n\", pairs);\n            out.printf(\"average  = %010.3f%n\", total / pairs);\n            out.printf(\"%nmaximum run(s) of %d invalid measurements: %n\",\n                    maxDataGap);\n            for (String[] dates : gapDates)\n                out.printf(\"begins at %s and ends at %s%n\", dates[0], dates[1]);\n\n        }\n    }\n}\n"}
{"id": 335923, "name": "Hello world_Line printer", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. GOODBYE-WORLD-PRINTER.\n\nPROCEDURE DIVISION.\nDISPLAY 'Hello World!'\n\tUPON PRINTER\nEND-DISPLAY.\nSTOP RUN.\n", "target": "import java.io.FileWriter;\nimport java.io.IOException;\n \npublic class LinePrinter {\n  public static void main(String[] args) {\n    try {\n      FileWriter lp0 = new FileWriter(\"/dev/lp0\");\n      lp0.write(\"Hello World!\");\n      lp0.close();\n    } catch (IOException ioe) {\n      ioe.printStackTrace();\n    }\n  }\n}\n"}
{"id": 335924, "name": "Hello world_Line printer", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. GOODBYE-WORLD-PRINTER.\n\nPROCEDURE DIVISION.\nDISPLAY 'Hello World!'\n\tUPON PRINTER\nEND-DISPLAY.\nSTOP RUN.\n", "target": "import java.io.FileWriter;\nimport java.io.IOException;\n \npublic class LinePrinter {\n  public static void main(String[] args) {\n    try {\n      FileWriter lp0 = new FileWriter(\"/dev/lp0\");\n      lp0.write(\"Hello World!\");\n      lp0.close();\n    } catch (IOException ioe) {\n      ioe.printStackTrace();\n    }\n  }\n}\n"}
{"id": 335925, "name": "Call a function", "source": "Translate COBOL to Java: CALL \"No-Arguments\"\n\n\nCALL \"2-Arguments\" USING Foo Bar\n\nCALL \"Optional-Arguments\" USING Foo\nCALL \"Optional-Arguments\" USING Foo Bar\n\n\nCALL \"Optional-Arguments\" USING Foo OMITTED Bar\n\n\n\nCALL \"2-Arguments\" USING Foo\n\n\n\n\n\n\nCALL \"Some-Func\" USING Foo\nMOVE Return-Code TO Bar\n\n\n\n\n\n\nMOVE FUNCTION PI TO Bar\nMOVE FUNCTION MEDIAN(4, 5, 6) TO Bar\n\n\n\n\n\n\n\nCALL \"C$MAKEDIR\" USING Foo\nCALL \"CBL_CREATE_DIR\" USING Foo\nCALL \"CBL_OC_NANOSLEEP\" USING Bar\n\nCALL X\"F4\" USING Foo Bar\n \n\n\n\n\n\n\n\n\n\n\nCALL \"Modify-Arg\" USING BY REFERENCE Foo \nCALL \"Modify-Arg\" USING BY CONTENT Foo   \nCALL \"C-Func\" USING BY VALUE Bar\n\n\n\n\n\n\nACCEPT Foo \nCALL \"Use-Func\" USING Foo\nCALL Foo USING Bar\n", "target": "foo();             \nInt x = bar();     \n"}
{"id": 335926, "name": "Call a function", "source": "Translate COBOL to Java: CALL \"No-Arguments\"\n\n\nCALL \"2-Arguments\" USING Foo Bar\n\nCALL \"Optional-Arguments\" USING Foo\nCALL \"Optional-Arguments\" USING Foo Bar\n\n\nCALL \"Optional-Arguments\" USING Foo OMITTED Bar\n\n\n\nCALL \"2-Arguments\" USING Foo\n\n\n\n\n\n\nCALL \"Some-Func\" USING Foo\nMOVE Return-Code TO Bar\n\n\n\n\n\n\nMOVE FUNCTION PI TO Bar\nMOVE FUNCTION MEDIAN(4, 5, 6) TO Bar\n\n\n\n\n\n\n\nCALL \"C$MAKEDIR\" USING Foo\nCALL \"CBL_CREATE_DIR\" USING Foo\nCALL \"CBL_OC_NANOSLEEP\" USING Bar\n\nCALL X\"F4\" USING Foo Bar\n \n\n\n\n\n\n\n\n\n\n\nCALL \"Modify-Arg\" USING BY REFERENCE Foo \nCALL \"Modify-Arg\" USING BY CONTENT Foo   \nCALL \"C-Func\" USING BY VALUE Bar\n\n\n\n\n\n\nACCEPT Foo \nCALL \"Use-Func\" USING Foo\nCALL Foo USING Bar\n", "target": "foo();             \nInt x = bar();     \n"}
{"id": 335927, "name": "Copy a string", "source": "Translate COBOL to Java: MOVE \"Hello\" TO src\nMOVE src TO dst\n", "target": "String src = \"Hello\";\nString newAlias = src;\nString strCopy = new String(src);\n\n\n\n\n"}
{"id": 335928, "name": "Include a file", "source": "Translate COBOL to Java: COPY \"copy.cpy\". \nCOPY \"another-copy.cpy\" REPLACING foo BY bar\n                                  SPACE BY ZERO\n                                  ==text to replace== BY ==replacement text==.\n", "target": "public class Class1 extends Class2\n{\n\t\n}\n"}
{"id": 335929, "name": "Include a file", "source": "Translate COBOL to Java: COPY \"copy.cpy\". \nCOPY \"another-copy.cpy\" REPLACING foo BY bar\n                                  SPACE BY ZERO\n                                  ==text to replace== BY ==replacement text==.\n", "target": "public class Class1 extends Class2\n{\n\t\n}\n"}
{"id": 348915, "name": "Validate International Securities Identification Number", "source": "Translate COBOL to C#:         >>SOURCE FORMAT FREE\n\nidentification division.\nprogram-id. callISINtest.\ndata division.\nworking-storage section.\n01  ISINtest-result binary-int.\nprocedure division.\nstart-callISINtest.\n    display 'should be valid ' with no advancing\n    call 'ISINtest' using 'US0378331005' ISINtest-result\n    perform display-ISINtest-result\n    display 'should not be valid ' with no advancing\n    call 'ISINtest' using 'US0373831005' ISINtest-result\n    perform display-ISINtest-result\n    display 'should not be valid ' with no advancing\n    call 'ISINtest' using 'U50378331005' ISINtest-result\n    perform display-ISINtest-result\n    display 'should not be valid ' with no advancing\n    call 'ISINtest' using 'US03378331005' ISINtest-result\n    perform display-ISINtest-result\n    display 'should be valid ' with no advancing\n    call 'ISINtest' using 'AU0000XVGZA3' ISINtest-result\n    perform display-ISINtest-result\n    display 'should be valid ' with no advancing\n    call 'ISINtest' using 'AU0000VXGZA3' ISINtest-result\n    perform display-ISINtest-result\n    display 'should be valid ' with no advancing\n    call 'ISINtest' using 'FR0000988040' ISINtest-result\n    perform display-ISINtest-result\n    stop run\n    .\ndisplay-ISINtest-result.\n    evaluate ISINtest-result\n    when 0 \n        display ' is valid'\n    when -1\n        display ' invalid length '\n    when -2\n        display ' invalid countrycode '\n    when -3\n        display ' invalid base36 digit '\n    when -4\n        display ' luhn test failed'\n    when other\n        display ' invalid return code ' ISINtest-result\n    end-evaluate\n    .\nend program callISINtest.\n\nidentification division.\nprogram-id. ISINtest.\ndata division.\nworking-storage section.\n01  country-code-values value\n    'ADAEAFAGAIALAMAOAQARASATAUAWAXAZBABBBDBEBFBGBHBIBJBLBMBNBOBQBRBS'\n&   'BTBVBWBYBZCACCCDCFCGCHCICKCLCMCNCOCRCUCVCWCXCYCZDEDJDKDMDODZECEE'\n&   'EGEHERESETFIFJFKFMFOFRGAGBGDGEGFGGGHGIGLGMGNGPGQGRGSGTGUGWGYHKHM'\n&   'HNHRHTHUIDIEILIMINIOIQIRISITJEJMJOJPKEKGKHKIKMKNKPKRKWKYKZLALBLC'\n&   'LILKLRLSLTLULVLYMAMCMDMEMFMGMHMKMLMMMNMOMPMQMRMSMTMUMVMWMXMYMZNA'\n&   'NCNENFNGNINLNONPNRNUNZOMPAPEPFPGPHPKPLPMPNPRPSPTPWPYQARERORSRURW'\n&   'SASBSCSDSESGSHSISJSKSLSMSNSOSRSSSTSVSXSYSZTCTDTFTGTHTJTKTLTMTNTO'\n&   'TRTTTVTWTZUAUGUMUSUYUZVAVCVEVGVIVNVUWFWSYEYTZAZMZW'.\n    03  country-codes occurs 249\n        ascending key country-code\n        indexed by cc-idx.\n        05  country-code pic xx.\n\n01  b pic 99.\n01  base36-digits pic x(36) value\n    '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n\n01  i pic 99.\n01  p pic 99.\n01  luhn-number pic x(20).\n01  luhntest-result binary-int.\n\nlinkage section.\n01  test-number any length.\n01  ISINtest-result binary-int.\n\nprocedure division using test-number ISINtest-result.\nstart-ISINtest.\n    display space test-number with no advancing\n\n    \n    if function length(test-number) <> 12\n        move -1 to ISINtest-result\n        goback\n    end-if\n\n    \n    search all country-codes\n    at end\n        move -2 to ISINtest-result\n        goback\n    when test-number(1:2) = country-code(cc-idx)\n        continue \n    end-search\n\n    \n    \n    move 0 to p\n    perform varying i from 1 by 1 until i > 12\n        if test-number(i:1) >= '0' and <= '9'\n            move test-number(i:1) to luhn-number(p + 1:1)\n            add 1 to p\n        else\n            perform varying b from 9 by 1 until b > 35\n            or base36-digits(b + 1:1) = test-number(i:1)\n                continue\n            end-perform\n            if b > 35\n                 move -3 to ISINtest-result\n                 goback\n            end-if\n            move b to luhn-number(p + 1:2)\n            add 2 to p\n        end-if\n    end-perform\n\n    call 'luhntest' using luhn-number(1:p) luhntest-result\n    if luhntest-result <> 0\n        move -4 to ISINtest-result\n        goback\n    end-if\n\n    move 0 to ISINtest-result\n    goback\n    .\nend program ISINtest.\n\nidentification division.\nprogram-id. luhntest.\ndata division.\nworking-storage section.\n01  i pic S99.\n01  check-sum pic 999.\nlinkage section.\n01  test-number any length.\n01  luhntest-result binary-int.\nprocedure division using test-number luhntest-result.\nstart-luhntest.\n    display space test-number with no advancing\n    move 0 to check-sum\n\n    \n    compute i = function length(test-number)\n    perform varying i from i by -2 until i < 1\n        add function numval(test-number(i:1)) to check-sum\n    end-perform\n    display space check-sum with no advancing\n\n    \n    compute i = function length(test-number) - 1\n    perform varying i from i by -2 until i < 1\n        add function numval(test-number(i:1)) to check-sum\n        add function numval(test-number(i:1)) to check-sum\n        \n        if test-number(i:1) >= '5'\n            subtract 9 from check-sum\n        end-if\n    end-perform\n    display space check-sum with no advancing\n\n    if function mod(check-sum,10) = 0\n        move 0 to luhntest-result \n    else\n        move -1 to luhntest-result \n    end-if\n    goback\n    .\nend program luhntest.\n", "target": "using System;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace ValidateIsin\n{\n    public static class IsinValidator\n    {\n        public static bool IsValidIsin(string isin) => \n            IsinRegex.IsMatch(isin) && LuhnTest(Digitize(isin));\n\n        private static readonly Regex IsinRegex = \n            new Regex(\"^[A-Z]{2}[A-Z0-9]{9}\\\\d$\", RegexOptions.Compiled);\n\n        private static string Digitize(string isin) =>\n            string.Join(\"\", isin.Select(c => $\"{DigitValue(c)}\"));\n\n        private static bool LuhnTest(string number) => \n            number.Reverse().Select(DigitValue).Select(Summand).Sum() % 10 == 0;\n\n        private static int Summand(int digit, int i) =>\n            digit + (i % 2) * (digit - digit / 5 * 9);\n\n        private static int DigitValue(char c) =>\n            c >= '0' && c <= '9' \n                ? c - '0' \n                : c - 'A' + 10;\n   }\n\t\n   public class Program\n   {\n        public static void Main() \n        {\n            string[] isins = \n            {\n                \"US0378331005\",\n                \"US0373831005\",\n                \"U50378331005\",\n                \"US03378331005\",\n                \"AU0000XVGZA3\",\n                \"AU0000VXGZA3\",\n                \"FR0000988040\"\n            };\n\n            foreach (string isin in isins) {\n                string validOrNot = IsinValidator.IsValidIsin(isin) ? \"valid\" : \"not valid\";\n                Console.WriteLine($\"{isin} is {validOrNot}\");\n            }\n        }\n    }\n}\n"}
{"id": 348916, "name": "ABC words", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ABC-WORDS.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT DICT ASSIGN TO DISK\n           ORGANIZATION LINE SEQUENTIAL.\n           \n       DATA DIVISION.\n       FILE SECTION.\n       FD DICT \n           LABEL RECORD STANDARD\n           VALUE OF FILE-ID IS \"unixdict.txt\".\n       01 WORD            PIC X(32).\n       \n       WORKING-STORAGE SECTION.\n       01 A               PIC 99.\n       01 B               PIC 99.\n       01 C               PIC 99.\n       01 X               PIC 99.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           OPEN INPUT DICT.\n           \n       READ-WORD.\n           READ DICT, AT END CLOSE DICT, STOP RUN.\n           PERFORM CHECK-WORD.\n           GO TO READ-WORD.\n           \n       CHECK-WORD.\n           MOVE ZERO TO A, B, C, X.\n           INSPECT WORD TALLYING A FOR CHARACTERS BEFORE INITIAL 'a'.\n           INSPECT WORD TALLYING B FOR CHARACTERS BEFORE INITIAL 'b'.\n           INSPECT WORD TALLYING C FOR CHARACTERS BEFORE INITIAL 'c'.\n           INSPECT WORD TALLYING X FOR CHARACTERS BEFORE INITIAL ' '.\n           IF A IS LESS THAN B \n           AND B IS LESS THAN C \n           AND C IS LESS THAN X,\n               DISPLAY WORD.\n", "target": "class Program {\n    static void Main(string[] args) { int bi, i = 0; string chars = args.Length < 1 ? \"abc\" : args[0];\n        foreach (var item in System.IO.File.ReadAllLines(\"unixdict.txt\")) {\n            int ai = -1; foreach (var ch in chars)\n                if ((bi = item.IndexOf(ch)) > ai) ai = bi; else goto skip;\n            System.Console.Write(\"{0,3} {1,-18} {2}\", ++i, item, i % 5 == 0 ? \"\\n\" : \"\");\n        skip: ; } }\n}\n"}
{"id": 348917, "name": "Two identical strings", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  IDENTICAL-STRINGS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 INPUT-NUMBER            PIC 9(4).\n          03 BINARY-REPRESENTATION   PIC 9(10).\n          03 BIT                     REDEFINES BINARY-REPRESENTATION,\n                                     PIC 9 OCCURS 10 TIMES.\n          03 FIRST-SET-BIT           PIC 99.\n          03 CURRENT-BIT             PIC 99.\n          03 SECOND-BIT              PIC 99.\n          03 BIT-VALUE               PIC 9(4).\n          03 OUTPUT-NUMBER           PIC 9(4) VALUE ZERO.\n          03 REMAINING-BITS          PIC 9(4)V9.\n          03 FILLER                  REDEFINES REMAINING-BITS.\n             05 REST                 PIC 9(4).\n             05 FILLER               PIC 9.\n                88 BIT-IS-SET        VALUE 5.\n\n       01 OUTPUT-FORMAT.\n          03 DECIMAL-OUTPUT          PIC Z(3)9.\n          03 BINARY-OUTPUT           PIC Z(9)9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM IDENTICAL-STRING\n               VARYING INPUT-NUMBER FROM 1 BY 1\n               UNTIL OUTPUT-NUMBER IS GREATER THAN 1000.\n           STOP RUN.\n\n       IDENTICAL-STRING.\n           MOVE ZERO TO BINARY-REPRESENTATION.\n           MOVE 10 TO CURRENT-BIT.\n           MOVE INPUT-NUMBER TO REMAINING-BITS.\n           PERFORM EXTRACT-BIT UNTIL REMAINING-BITS EQUAL ZERO.\n           MOVE CURRENT-BIT TO FIRST-SET-BIT.\n           MOVE 10 TO SECOND-BIT.\n           PERFORM COPY-BIT UNTIL SECOND-BIT IS EQUAL TO FIRST-SET-BIT.\n           MOVE ZERO TO OUTPUT-NUMBER.\n           IF CURRENT-BIT IS EQUAL TO ZERO, MOVE 1 TO CURRENT-BIT.\n           PERFORM INSERT-BIT\n               VARYING CURRENT-BIT FROM CURRENT-BIT BY 1\n               UNTIL CURRENT-BIT IS GREATER THAN 10.\n           MOVE OUTPUT-NUMBER TO DECIMAL-OUTPUT.\n           MOVE BINARY-REPRESENTATION TO BINARY-OUTPUT.\n           IF OUTPUT-NUMBER IS LESS THAN 1000,\n               DISPLAY DECIMAL-OUTPUT \": \" BINARY-OUTPUT.\n\n       EXTRACT-BIT.\n           DIVIDE 2 INTO REMAINING-BITS.\n           IF BIT-IS-SET, MOVE 1 TO BIT(CURRENT-BIT).\n           SUBTRACT 1 FROM CURRENT-BIT.\n           MOVE REST TO REMAINING-BITS.\n\n       COPY-BIT.\n           MOVE BIT(SECOND-BIT) TO BIT(CURRENT-BIT).\n           SUBTRACT 1 FROM SECOND-BIT.\n           SUBTRACT 1 FROM CURRENT-BIT.\n\n       INSERT-BIT.\n           COMPUTE BIT-VALUE = 2 ** (10 - CURRENT-BIT)\n           MULTIPLY BIT(CURRENT-BIT) BY BIT-VALUE.\n           ADD BIT-VALUE TO OUTPUT-NUMBER.\n", "target": "using System; using static System.Console;\nclass Program { static void Main() { int c = 0, lmt = 1000;\n    for (int n = 1, p = 2, k; n <= lmt; n++)\n      if ((k = n + n * (p += n >= p ? p : 0)) > lmt) break;\n      else Console.Write(\"{0,3} ({1,-10})  {2}\", k,\n          Convert.ToString(k, 2), ++c % 5 == 0 ? \"\\n\" : \"\");\n    Write(\"\\nFound {0} numbers whose base 2 representation is the \" +\n      \"concatenation of two identical binary strings.\", c); } }\n"}
{"id": 348918, "name": "Sum of first n cubes", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  SUM-OF-CUBES.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 STEP         PIC 99.\n          03 CUBE         PIC 9(7).\n          03 CUBE-SUM     PIC 9(7) VALUE 0.\n \n       01 OUTPUT-FORMAT.\n          03 OUT-LINE     PIC X(40) VALUE SPACES.\n          03 OUT-PTR      PIC 99 VALUE 1.\n          03 OUT-NUM      PIC Z(7)9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM ADD-CUBE VARYING STEP FROM 0 BY 1\n               UNTIL STEP IS EQUAL TO 50.\n           STOP RUN.\n\n       ADD-CUBE.\n           COMPUTE CUBE = STEP ** 3.\n           ADD CUBE TO CUBE-SUM.\n           MOVE CUBE-SUM TO OUT-NUM.\n           STRING OUT-NUM DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER OUT-PTR.\n           IF OUT-PTR IS EQUAL TO 41,\n               DISPLAY OUT-LINE,\n               MOVE 1 TO OUT-PTR.\n", "target": "using System; using static System.Console;\nclass Program { static void Main(string[] args) {\n    for (int i=0,j=-6,k=1,c=0,s=0;s<1600000;s+=c+=k+=j+=6)\n      Write(\"{0,-7}{1}\",s, (i+=i==3?-4:1)==0?\"\\n\":\" \"); } }\n"}
{"id": 348919, "name": "Flow-control structures", "source": "Translate COBOL to C#:        PROGRAM-ID. Go-To-Example.\n\n       PROCEDURE DIVISION.\n       Foo.\n           DISPLAY \"Just a reminder: GO TOs are evil.\"\n\n           GO TO Foo\n           .\n", "target": "int GetNumber() {\n    return 5;\n}\n"}
{"id": 352490, "name": "Validate International Securities Identification Number", "source": "Translate COBOL to Python:         >>SOURCE FORMAT FREE\n\nidentification division.\nprogram-id. callISINtest.\ndata division.\nworking-storage section.\n01  ISINtest-result binary-int.\nprocedure division.\nstart-callISINtest.\n    display 'should be valid ' with no advancing\n    call 'ISINtest' using 'US0378331005' ISINtest-result\n    perform display-ISINtest-result\n    display 'should not be valid ' with no advancing\n    call 'ISINtest' using 'US0373831005' ISINtest-result\n    perform display-ISINtest-result\n    display 'should not be valid ' with no advancing\n    call 'ISINtest' using 'U50378331005' ISINtest-result\n    perform display-ISINtest-result\n    display 'should not be valid ' with no advancing\n    call 'ISINtest' using 'US03378331005' ISINtest-result\n    perform display-ISINtest-result\n    display 'should be valid ' with no advancing\n    call 'ISINtest' using 'AU0000XVGZA3' ISINtest-result\n    perform display-ISINtest-result\n    display 'should be valid ' with no advancing\n    call 'ISINtest' using 'AU0000VXGZA3' ISINtest-result\n    perform display-ISINtest-result\n    display 'should be valid ' with no advancing\n    call 'ISINtest' using 'FR0000988040' ISINtest-result\n    perform display-ISINtest-result\n    stop run\n    .\ndisplay-ISINtest-result.\n    evaluate ISINtest-result\n    when 0 \n        display ' is valid'\n    when -1\n        display ' invalid length '\n    when -2\n        display ' invalid countrycode '\n    when -3\n        display ' invalid base36 digit '\n    when -4\n        display ' luhn test failed'\n    when other\n        display ' invalid return code ' ISINtest-result\n    end-evaluate\n    .\nend program callISINtest.\n\nidentification division.\nprogram-id. ISINtest.\ndata division.\nworking-storage section.\n01  country-code-values value\n    'ADAEAFAGAIALAMAOAQARASATAUAWAXAZBABBBDBEBFBGBHBIBJBLBMBNBOBQBRBS'\n&   'BTBVBWBYBZCACCCDCFCGCHCICKCLCMCNCOCRCUCVCWCXCYCZDEDJDKDMDODZECEE'\n&   'EGEHERESETFIFJFKFMFOFRGAGBGDGEGFGGGHGIGLGMGNGPGQGRGSGTGUGWGYHKHM'\n&   'HNHRHTHUIDIEILIMINIOIQIRISITJEJMJOJPKEKGKHKIKMKNKPKRKWKYKZLALBLC'\n&   'LILKLRLSLTLULVLYMAMCMDMEMFMGMHMKMLMMMNMOMPMQMRMSMTMUMVMWMXMYMZNA'\n&   'NCNENFNGNINLNONPNRNUNZOMPAPEPFPGPHPKPLPMPNPRPSPTPWPYQARERORSRURW'\n&   'SASBSCSDSESGSHSISJSKSLSMSNSOSRSSSTSVSXSYSZTCTDTFTGTHTJTKTLTMTNTO'\n&   'TRTTTVTWTZUAUGUMUSUYUZVAVCVEVGVIVNVUWFWSYEYTZAZMZW'.\n    03  country-codes occurs 249\n        ascending key country-code\n        indexed by cc-idx.\n        05  country-code pic xx.\n\n01  b pic 99.\n01  base36-digits pic x(36) value\n    '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n\n01  i pic 99.\n01  p pic 99.\n01  luhn-number pic x(20).\n01  luhntest-result binary-int.\n\nlinkage section.\n01  test-number any length.\n01  ISINtest-result binary-int.\n\nprocedure division using test-number ISINtest-result.\nstart-ISINtest.\n    display space test-number with no advancing\n\n    \n    if function length(test-number) <> 12\n        move -1 to ISINtest-result\n        goback\n    end-if\n\n    \n    search all country-codes\n    at end\n        move -2 to ISINtest-result\n        goback\n    when test-number(1:2) = country-code(cc-idx)\n        continue \n    end-search\n\n    \n    \n    move 0 to p\n    perform varying i from 1 by 1 until i > 12\n        if test-number(i:1) >= '0' and <= '9'\n            move test-number(i:1) to luhn-number(p + 1:1)\n            add 1 to p\n        else\n            perform varying b from 9 by 1 until b > 35\n            or base36-digits(b + 1:1) = test-number(i:1)\n                continue\n            end-perform\n            if b > 35\n                 move -3 to ISINtest-result\n                 goback\n            end-if\n            move b to luhn-number(p + 1:2)\n            add 2 to p\n        end-if\n    end-perform\n\n    call 'luhntest' using luhn-number(1:p) luhntest-result\n    if luhntest-result <> 0\n        move -4 to ISINtest-result\n        goback\n    end-if\n\n    move 0 to ISINtest-result\n    goback\n    .\nend program ISINtest.\n\nidentification division.\nprogram-id. luhntest.\ndata division.\nworking-storage section.\n01  i pic S99.\n01  check-sum pic 999.\nlinkage section.\n01  test-number any length.\n01  luhntest-result binary-int.\nprocedure division using test-number luhntest-result.\nstart-luhntest.\n    display space test-number with no advancing\n    move 0 to check-sum\n\n    \n    compute i = function length(test-number)\n    perform varying i from i by -2 until i < 1\n        add function numval(test-number(i:1)) to check-sum\n    end-perform\n    display space check-sum with no advancing\n\n    \n    compute i = function length(test-number) - 1\n    perform varying i from i by -2 until i < 1\n        add function numval(test-number(i:1)) to check-sum\n        add function numval(test-number(i:1)) to check-sum\n        \n        if test-number(i:1) >= '5'\n            subtract 9 from check-sum\n        end-if\n    end-perform\n    display space check-sum with no advancing\n\n    if function mod(check-sum,10) = 0\n        move 0 to luhntest-result \n    else\n        move -1 to luhntest-result \n    end-if\n    goback\n    .\nend program luhntest.\n", "target": "def check_isin(a):\n    if len(a) != 12 or not all(c.isalpha() for c in a[:2]) or not all(c.isalnum() for c in a[2:]):\n        return False\n    s = \"\".join(str(int(c, 36)) for c in a)\n    return 0 == (sum(sum(divmod(2 * (ord(c) - 48), 10)) for c in s[-2::-2]) +\n                 sum(ord(c) - 48 for c in s[::-2])) % 10\n\n\ndef check_isin_alt(a):\n    if len(a) != 12:\n        return False\n    s = []\n    for i, c in enumerate(a):\n        if c.isdigit():\n            if i < 2:\n                return False\n            s.append(ord(c) - 48)\n        elif c.isupper():\n            if i == 11:\n                return False\n            s += divmod(ord(c) - 55, 10)\n        else:\n            return False\n    v = sum(s[::-2])\n    for k in s[-2::-2]:\n        k = 2 * k\n        v += k - 9 if k > 9 else k\n    return v % 10 == 0\n\n[check_isin(s) for s in [\"US0378331005\", \"US0373831005\", \"U50378331005\", \"US03378331005\",\n                         \"AU0000XVGZA3\", \"AU0000VXGZA3\", \"FR0000988040\"]]\n\n\n"}
{"id": 352491, "name": "ABC words", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ABC-WORDS.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT DICT ASSIGN TO DISK\n           ORGANIZATION LINE SEQUENTIAL.\n           \n       DATA DIVISION.\n       FILE SECTION.\n       FD DICT \n           LABEL RECORD STANDARD\n           VALUE OF FILE-ID IS \"unixdict.txt\".\n       01 WORD            PIC X(32).\n       \n       WORKING-STORAGE SECTION.\n       01 A               PIC 99.\n       01 B               PIC 99.\n       01 C               PIC 99.\n       01 X               PIC 99.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           OPEN INPUT DICT.\n           \n       READ-WORD.\n           READ DICT, AT END CLOSE DICT, STOP RUN.\n           PERFORM CHECK-WORD.\n           GO TO READ-WORD.\n           \n       CHECK-WORD.\n           MOVE ZERO TO A, B, C, X.\n           INSPECT WORD TALLYING A FOR CHARACTERS BEFORE INITIAL 'a'.\n           INSPECT WORD TALLYING B FOR CHARACTERS BEFORE INITIAL 'b'.\n           INSPECT WORD TALLYING C FOR CHARACTERS BEFORE INITIAL 'c'.\n           INSPECT WORD TALLYING X FOR CHARACTERS BEFORE INITIAL ' '.\n           IF A IS LESS THAN B \n           AND B IS LESS THAN C \n           AND C IS LESS THAN X,\n               DISPLAY WORD.\n", "target": "python -c '\nimport sys\nfor ln in sys.stdin:\n    if \"a\" in ln and ln.find(\"a\") < ln.find(\"b\") < ln.find(\"c\"):\n        print(ln.rstrip())\n' < unixdict.txt\n"}
{"id": 352492, "name": "Two identical strings", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  IDENTICAL-STRINGS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 INPUT-NUMBER            PIC 9(4).\n          03 BINARY-REPRESENTATION   PIC 9(10).\n          03 BIT                     REDEFINES BINARY-REPRESENTATION,\n                                     PIC 9 OCCURS 10 TIMES.\n          03 FIRST-SET-BIT           PIC 99.\n          03 CURRENT-BIT             PIC 99.\n          03 SECOND-BIT              PIC 99.\n          03 BIT-VALUE               PIC 9(4).\n          03 OUTPUT-NUMBER           PIC 9(4) VALUE ZERO.\n          03 REMAINING-BITS          PIC 9(4)V9.\n          03 FILLER                  REDEFINES REMAINING-BITS.\n             05 REST                 PIC 9(4).\n             05 FILLER               PIC 9.\n                88 BIT-IS-SET        VALUE 5.\n\n       01 OUTPUT-FORMAT.\n          03 DECIMAL-OUTPUT          PIC Z(3)9.\n          03 BINARY-OUTPUT           PIC Z(9)9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM IDENTICAL-STRING\n               VARYING INPUT-NUMBER FROM 1 BY 1\n               UNTIL OUTPUT-NUMBER IS GREATER THAN 1000.\n           STOP RUN.\n\n       IDENTICAL-STRING.\n           MOVE ZERO TO BINARY-REPRESENTATION.\n           MOVE 10 TO CURRENT-BIT.\n           MOVE INPUT-NUMBER TO REMAINING-BITS.\n           PERFORM EXTRACT-BIT UNTIL REMAINING-BITS EQUAL ZERO.\n           MOVE CURRENT-BIT TO FIRST-SET-BIT.\n           MOVE 10 TO SECOND-BIT.\n           PERFORM COPY-BIT UNTIL SECOND-BIT IS EQUAL TO FIRST-SET-BIT.\n           MOVE ZERO TO OUTPUT-NUMBER.\n           IF CURRENT-BIT IS EQUAL TO ZERO, MOVE 1 TO CURRENT-BIT.\n           PERFORM INSERT-BIT\n               VARYING CURRENT-BIT FROM CURRENT-BIT BY 1\n               UNTIL CURRENT-BIT IS GREATER THAN 10.\n           MOVE OUTPUT-NUMBER TO DECIMAL-OUTPUT.\n           MOVE BINARY-REPRESENTATION TO BINARY-OUTPUT.\n           IF OUTPUT-NUMBER IS LESS THAN 1000,\n               DISPLAY DECIMAL-OUTPUT \": \" BINARY-OUTPUT.\n\n       EXTRACT-BIT.\n           DIVIDE 2 INTO REMAINING-BITS.\n           IF BIT-IS-SET, MOVE 1 TO BIT(CURRENT-BIT).\n           SUBTRACT 1 FROM CURRENT-BIT.\n           MOVE REST TO REMAINING-BITS.\n\n       COPY-BIT.\n           MOVE BIT(SECOND-BIT) TO BIT(CURRENT-BIT).\n           SUBTRACT 1 FROM SECOND-BIT.\n           SUBTRACT 1 FROM CURRENT-BIT.\n\n       INSERT-BIT.\n           COMPUTE BIT-VALUE = 2 ** (10 - CURRENT-BIT)\n           MULTIPLY BIT(CURRENT-BIT) BY BIT-VALUE.\n           ADD BIT-VALUE TO OUTPUT-NUMBER.\n", "target": "def bits(n):\n    \n    r = 0\n    while n:\n        n >>= 1\n        r += 1\n    return r\n    \ndef concat(n):\n    \n    return n << bits(n) | n\n    \nn = 1\nwhile concat(n) <= 1000:\n    print(\"{0}: {0:b}\".format(concat(n)))\n    n += 1\n"}
{"id": 352493, "name": "Sum of first n cubes", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  SUM-OF-CUBES.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 STEP         PIC 99.\n          03 CUBE         PIC 9(7).\n          03 CUBE-SUM     PIC 9(7) VALUE 0.\n \n       01 OUTPUT-FORMAT.\n          03 OUT-LINE     PIC X(40) VALUE SPACES.\n          03 OUT-PTR      PIC 99 VALUE 1.\n          03 OUT-NUM      PIC Z(7)9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM ADD-CUBE VARYING STEP FROM 0 BY 1\n               UNTIL STEP IS EQUAL TO 50.\n           STOP RUN.\n\n       ADD-CUBE.\n           COMPUTE CUBE = STEP ** 3.\n           ADD CUBE TO CUBE-SUM.\n           MOVE CUBE-SUM TO OUT-NUM.\n           STRING OUT-NUM DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER OUT-PTR.\n           IF OUT-PTR IS EQUAL TO 41,\n               DISPLAY OUT-LINE,\n               MOVE 1 TO OUT-PTR.\n", "target": "def main():\n    fila = 0\n    lenCubos = 51\n\n    print(\"Suma de N cubos para n = [0..49]\\n\")\n\n    for n in range(1, lenCubos):\n        sumCubos = 0\n        for m in range(1, n):\n            sumCubos = sumCubos + (m ** 3)\n            \n        fila += 1\n        print(f'{sumCubos:7} ', end='')\n        if fila % 5 == 0:\n            print(\" \")\n\n    print(f\"\\nEncontrados {fila} cubos.\")\n\nif __name__ == '__main__': main()\n"}
{"id": 352494, "name": "Count how many vowels and consonants occur in a string", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. VOWELS-AND-CONSONANTS.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 CONSTANTS.\n          03 LETTERS-DAT.\n             05 FILLER      PIC X(5) VALUE \"AEIOU\".\n             05 FILLER      PIC X(5) VALUE \"aeiou\".\n             05 FILLER      PIC X(21) VALUE \"BCDFGHJKLMNPQRSTVWXYZ\".\n             05 FILLER      PIC X(21) VALUE \"bcdfghjklmnpqrstvwxyz\".\n          03 LETTERS        REDEFINES LETTERS-DAT.\n             05 VOWELS      PIC X OCCURS 10 TIMES INDEXED BY V.\n             05 CONSONANTS  PIC X OCCURS 42 TIMES INDEXED BY C.\n      \n       01 VARIABLES.\n          03 IN-STR         PIC X(80).\n          03 N-VOWELS       PIC 99.\n          03 N-CONSONANTS   PIC 99.\n      \n       01 REPORT.\n          03 R-VOWELS       PIC Z9.\n          03 FILLER         PIC X(9) VALUE \" vowels, \".\n          03 R-CONSONANTS   PIC Z9.\n          03 FILLER         PIC X(12) VALUE \" consonants.\".\n         \n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE \"If not now, then when? If not us, then who?\"\n           TO IN-STR.\n           PERFORM COUNT-AND-SHOW.\n           STOP RUN.\n          \n       COUNT-AND-SHOW.\n           DISPLAY IN-STR.\n           PERFORM COUNT-VOWELS-AND-CONSONANTS.\n           MOVE N-VOWELS TO R-VOWELS.\n           MOVE N-CONSONANTS TO R-CONSONANTS.\n           DISPLAY REPORT.\n       \n       COUNT-VOWELS-AND-CONSONANTS.\n           MOVE ZERO TO N-VOWELS, N-CONSONANTS.\n           SET V TO 1.\n           PERFORM COUNT-VOWEL 10 TIMES.\n           SET C TO 1.\n           PERFORM COUNT-CONSONANT 42 TIMES.\n        \n       COUNT-VOWEL.\n           INSPECT IN-STR TALLYING N-VOWELS FOR ALL VOWELS(V).\n           SET V UP BY 1.\n       \n       COUNT-CONSONANT.\n           INSPECT IN-STR TALLYING N-CONSONANTS FOR ALL CONSONANTS(C).\n           SET C UP BY 1.\n", "target": "def isvowel(c):\n    \n    return c in ['a', 'e', 'i', 'o', 'u', 'A', 'E', \"I\", 'O', 'U']\n\ndef isletter(c):\n    \n    return 'a' <= c <= 'z' or 'A' <= c <= 'Z'\n\ndef isconsonant(c):\n    \n    return  not isvowel(c) and isletter(c)\n\ndef vccounts(s):\n    \n    a = list(s.lower())\n    au = set(a)\n    return sum([isvowel(c) for c in a]), sum([isconsonant(c) for c in a]), \\\n        sum([isvowel(c) for c in au]), sum([isconsonant(c) for c in au])\n\ndef testvccount():\n    teststrings = [\n        \"Forever Python programming language\",\n        \"Now is the time for all good men to come to the aid of their country.\"]\n    for s in teststrings:\n        vcnt, ccnt, vu, cu = vccounts(s)\n        print(f\"String: {s}\\n    Vowels: {vcnt} (distinct {vu})\\n    Consonants: {ccnt} (distinct {cu})\\n\")\n\ntestvccount()\n"}
{"id": 352495, "name": "Count how many vowels and consonants occur in a string", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. VOWELS-AND-CONSONANTS.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 CONSTANTS.\n          03 LETTERS-DAT.\n             05 FILLER      PIC X(5) VALUE \"AEIOU\".\n             05 FILLER      PIC X(5) VALUE \"aeiou\".\n             05 FILLER      PIC X(21) VALUE \"BCDFGHJKLMNPQRSTVWXYZ\".\n             05 FILLER      PIC X(21) VALUE \"bcdfghjklmnpqrstvwxyz\".\n          03 LETTERS        REDEFINES LETTERS-DAT.\n             05 VOWELS      PIC X OCCURS 10 TIMES INDEXED BY V.\n             05 CONSONANTS  PIC X OCCURS 42 TIMES INDEXED BY C.\n      \n       01 VARIABLES.\n          03 IN-STR         PIC X(80).\n          03 N-VOWELS       PIC 99.\n          03 N-CONSONANTS   PIC 99.\n      \n       01 REPORT.\n          03 R-VOWELS       PIC Z9.\n          03 FILLER         PIC X(9) VALUE \" vowels, \".\n          03 R-CONSONANTS   PIC Z9.\n          03 FILLER         PIC X(12) VALUE \" consonants.\".\n         \n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE \"If not now, then when? If not us, then who?\"\n           TO IN-STR.\n           PERFORM COUNT-AND-SHOW.\n           STOP RUN.\n          \n       COUNT-AND-SHOW.\n           DISPLAY IN-STR.\n           PERFORM COUNT-VOWELS-AND-CONSONANTS.\n           MOVE N-VOWELS TO R-VOWELS.\n           MOVE N-CONSONANTS TO R-CONSONANTS.\n           DISPLAY REPORT.\n       \n       COUNT-VOWELS-AND-CONSONANTS.\n           MOVE ZERO TO N-VOWELS, N-CONSONANTS.\n           SET V TO 1.\n           PERFORM COUNT-VOWEL 10 TIMES.\n           SET C TO 1.\n           PERFORM COUNT-CONSONANT 42 TIMES.\n        \n       COUNT-VOWEL.\n           INSPECT IN-STR TALLYING N-VOWELS FOR ALL VOWELS(V).\n           SET V UP BY 1.\n       \n       COUNT-CONSONANT.\n           INSPECT IN-STR TALLYING N-CONSONANTS FOR ALL CONSONANTS(C).\n           SET C UP BY 1.\n", "target": "def isvowel(c):\n    \n    return c in ['a', 'e', 'i', 'o', 'u', 'A', 'E', \"I\", 'O', 'U']\n\ndef isletter(c):\n    \n    return 'a' <= c <= 'z' or 'A' <= c <= 'Z'\n\ndef isconsonant(c):\n    \n    return  not isvowel(c) and isletter(c)\n\ndef vccounts(s):\n    \n    a = list(s.lower())\n    au = set(a)\n    return sum([isvowel(c) for c in a]), sum([isconsonant(c) for c in a]), \\\n        sum([isvowel(c) for c in au]), sum([isconsonant(c) for c in au])\n\ndef testvccount():\n    teststrings = [\n        \"Forever Python programming language\",\n        \"Now is the time for all good men to come to the aid of their country.\"]\n    for s in teststrings:\n        vcnt, ccnt, vu, cu = vccounts(s)\n        print(f\"String: {s}\\n    Vowels: {vcnt} (distinct {vu})\\n    Consonants: {ccnt} (distinct {cu})\\n\")\n\ntestvccount()\n"}
{"id": 352496, "name": "Call a foreign-language function", "source": "Translate COBOL to Python:        identification division.\n       program-id. foreign.\n\n       data division.\n       working-storage section.\n       01 hello.\n          05 value z\"Hello, world\".\n       01 duplicate    usage pointer.\n       01 buffer       pic x(16) based.\n       01 storage      pic x(16).\n\n       procedure division.\n       call \"strdup\" using hello returning duplicate\n           on exception\n               display \"error calling strdup\" upon syserr\n       end-call\n       if duplicate equal null then\n           display \"strdup returned null\" upon syserr\n       else\n           set address of buffer to duplicate\n           string buffer delimited by low-value into storage\n           display function trim(storage)\n           call \"free\" using by value duplicate\n               on exception\n                   display \"error calling free\" upon syserr\n       end-if\n       goback.\n", "target": "import ctypes\nlibc = ctypes.CDLL(\"/lib/libc.so.6\")\nlibc.strcmp(\"abc\", \"def\")     \nlibc.strcmp(\"hello\", \"hello\") \n"}
{"id": 352497, "name": "Soundex", "source": "Translate COBOL to Python:       **** sndxtest *********************************************\n      * Demonstrate the soundex encoding functions.\n      ***************************************************************\n       Identification division.\n       Program-id. sndxtest.\n\n       Data division.\n       Working-storage section.\n       01 sample-word-list.\n           05 sample-words.\n               10 filler pic x(15) value \"soundex\".\n               10 filler pic x(15) value \"example\".\n               10 filler pic x(15) value \"sownteks\".\n               10 filler pic x(15) value \"ekzampul\".\n               10 filler pic x(15) value \"Euler\".\n               10 filler pic x(15) value \"Gauss\".\n               10 filler pic x(15) value \"Hilbert\".\n               10 filler pic x(15) value \"Knuth\".\n               10 filler pic x(15) value \"Lloyd\".\n               10 filler pic x(15) value \"Lukasiewicz\".\n               10 filler pic x(15) value \"Ellery\".\n               10 filler pic x(15) value \"ghosh\".\n               10 filler pic x(15) value \"Heilbronn\".\n               10 filler pic x(15) value \"Kand\".\n               10 filler pic x(15) value \"Ladd\".\n               10 filler pic x(15) value \"lissajous\".\n               10 filler pic x(15) value \"Wheaton\".\n               10 filler pic x(15) value \"Burroughs\".\n               10 filler pic x(15) value \"burrows\".\n               10 filler pic x(15) value \"O'Hara\".\n               10 filler pic x(15) value \"Washington\".\n               10 filler pic x(15) value \"lee\".\n               10 filler pic x(15) value \"Gutierrez\".\n               10 filler pic x(15) value \"Phister\".\n               10 filler pic x(15) value \"Jackson\".\n               10 filler pic x(15) value \"tymczak\".\n               10 filler pic x(15) value \"Vandeusen\".\n               10 filler pic x(15) value \"Ashcraft\".\n           05 sample-word redefines sample-words\n                         pic x(15) occurs 28 times indexed by wrd-idx.\n       01 wrd-code       pic x999.\n\n       Procedure division.\n           Perform varying wrd-idx from 1 by 1\n           until wrd-idx greater than 28\n               call \"sndxenc\" using\n                   by reference sample-word(wrd-idx)\n                   by reference wrd-code\n               display wrd-code \" \" sample-word(wrd-idx)\n           end-perform.\n           Stop run.\n\n       End program sndxtest.\n\n      *** sndxenc ********************************************\n      * Given a string return its soundex encoding.\n      ***************************************************************\n       Identification division.\n       Program-id. sndxenc.\n\n       Data division.\n       Local-storage section.\n       01 str-idx            pic 99.\n       01 let-code           pic  9.\n       01 prv-let-code       pic  9.\n       01 sdx-idx            pic  9  value 1.\n\n       Linkage section.\n       01 str-to-encode.\n           05 str-first-let  pic x.\n           05 str-rest-let   pic x  occurs 14 times.\n       01 sdx-code.\n           05 sdx-first-let  pic x.\n           05 sdx-nums       pic 9  occurs  3 times.\n\n       Procedure division using\n           by reference str-to-encode\n           by reference sdx-code.\n           Perform encode-start thru encode-done.\n           Goback.\n\n       Encode-start.\n           Move zeros to sdx-code.\n           Move function upper-case(str-first-let) to sdx-first-let.\n           Call \"sndxchar\" using\n               by reference str-first-let\n               by reference let-code.\n           Move let-code to prv-let-code.\n\n       Encode-string.\n           Perform varying str-idx from 1 by 1\n               until str-idx greater than 15\n               or str-rest-let(str-idx) = space\n               or sdx-idx greater than 3\n               call \"sndxchar\" using\n                   by reference str-rest-let(str-idx)\n                   by reference let-code\n               if let-code not equal 7 then\n                   if let-code not equal 0\n                   and let-code not equal prv-let-code\n                       move let-code to sdx-nums(sdx-idx)\n                       add 1 to sdx-idx\n                   end-if\n                   move let-code to prv-let-code\n               end-if\n           end-perform.\n\n       Encode-done.\n           continue.\n       End program sndxenc.\n\n\n      *** sndxchar **********************************************\n      * Given a character, return its soundex encoding.\n      * Code 7 is for h or w, which an encoder should ignore when\n      * either one separates double letters.\n      ***************************************************************\n       Identification division.\n       Program-id. sndxchar.\n\n       Data division.\n       Local-storage section.\n       01 lc-chr pic x.\n           88 code1 value \"b\", \"f\", \"p\", \"v\".\n           88 code2 value \"c\", \"g\", \"j\", \"k\", \"q\", \"s\", \"x\", \"z\".\n           88 code3 value \"d\", \"t\".\n           88 code4 value \"l\".\n           88 code5 value \"m\", \"n\".\n           88 code6 value \"r\".\n           88 code7 value \"h\", \"w\".\n\n       Linkage section.\n       01 char-to-encode pic x.\n       01 char-sdx-code  pic 9.\n\n       Procedure division using\n           by reference char-to-encode\n           by reference char-sdx-code.\n           Move function lower-case(char-to-encode) to lc-chr.\n           If          code1 then move 1 to char-sdx-code\n               else if code2 then move 2 to char-sdx-code\n               else if code3 then move 3 to char-sdx-code\n               else if code4 then move 4 to char-sdx-code\n               else if code5 then move 5 to char-sdx-code\n               else if code6 then move 6 to char-sdx-code\n               else if code7 then move 7 to char-sdx-code\n               else               move 0 to char-sdx-code\n           end-if.\n       End program sndxchar.\n", "target": "from itertools import groupby\n\ndef soundex(word):\n   codes = (\"bfpv\",\"cgjkqsxz\", \"dt\", \"l\", \"mn\", \"r\")\n   soundDict = dict((ch, str(ix+1)) for ix,cod in enumerate(codes) for ch in cod)\n   cmap2 = lambda kar: soundDict.get(kar, '9')\n   sdx =  ''.join(cmap2(kar) for kar in word.lower())\n   sdx2 = word[0].upper() + ''.join(k for k,g in list(groupby(sdx))[1:] if k!='9')\n   sdx3 = sdx2[0:4].ljust(4,'0')\n   return sdx3\n"}
{"id": 352498, "name": "Disarium numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DISARIUM.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE     PIC 9(9).\n          03 DIGITS        PIC 9 OCCURS 9 TIMES, REDEFINES CANDIDATE.\n          03 IDX           PIC 99.\n          03 EXPONENT      PIC 99.\n          03 DGT-POWER     PIC 9(9).\n          03 DGT-POWER-SUM PIC 9(9).\n          03 CAND-OUT      PIC Z(8)9.\n          03 AMOUNT        PIC 99 VALUE 18.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM DISARIUM-TEST VARYING CANDIDATE FROM ZERO BY 1\n           UNTIL AMOUNT IS ZERO.\n           STOP RUN.\n        \n       DISARIUM-TEST.\n           MOVE ZERO TO DGT-POWER-SUM.\n           MOVE 1 TO EXPONENT, IDX.\n           INSPECT CANDIDATE TALLYING IDX FOR LEADING ZEROES.\n           PERFORM ADD-DIGIT-POWER UNTIL IDX IS GREATER THAN 9.\n           IF DGT-POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO CAND-OUT,\n               DISPLAY CAND-OUT,\n               SUBTRACT 1 FROM AMOUNT.\n           \n       ADD-DIGIT-POWER.\n           COMPUTE DGT-POWER = DIGITS(IDX) ** EXPONENT.\n           ADD DGT-POWER TO DGT-POWER-SUM.\n           ADD 1 TO EXPONENT.\n           ADD 1 TO IDX.\n", "target": "\n\ndef isDisarium(n):\n    digitos = len(str(n))\n    suma = 0\n    x = n\n    while x != 0:\n        suma += (x % 10) ** digitos\n        digitos -= 1\n        x //= 10\n    if suma == n:\n        return True\n    else:\n        return False\n\nif __name__ == '__main__':\n    limite = 19\n    cont = 0\n    n = 0\n    print(\"The first\",limite,\"Disarium numbers are:\")\n    while cont < limite:\n        if isDisarium(n):\n            print(n, end = \" \")\n            cont += 1\n        n += 1\n"}
{"id": 352499, "name": "Disarium numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DISARIUM.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE     PIC 9(9).\n          03 DIGITS        PIC 9 OCCURS 9 TIMES, REDEFINES CANDIDATE.\n          03 IDX           PIC 99.\n          03 EXPONENT      PIC 99.\n          03 DGT-POWER     PIC 9(9).\n          03 DGT-POWER-SUM PIC 9(9).\n          03 CAND-OUT      PIC Z(8)9.\n          03 AMOUNT        PIC 99 VALUE 18.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM DISARIUM-TEST VARYING CANDIDATE FROM ZERO BY 1\n           UNTIL AMOUNT IS ZERO.\n           STOP RUN.\n        \n       DISARIUM-TEST.\n           MOVE ZERO TO DGT-POWER-SUM.\n           MOVE 1 TO EXPONENT, IDX.\n           INSPECT CANDIDATE TALLYING IDX FOR LEADING ZEROES.\n           PERFORM ADD-DIGIT-POWER UNTIL IDX IS GREATER THAN 9.\n           IF DGT-POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO CAND-OUT,\n               DISPLAY CAND-OUT,\n               SUBTRACT 1 FROM AMOUNT.\n           \n       ADD-DIGIT-POWER.\n           COMPUTE DGT-POWER = DIGITS(IDX) ** EXPONENT.\n           ADD DGT-POWER TO DGT-POWER-SUM.\n           ADD 1 TO EXPONENT.\n           ADD 1 TO IDX.\n", "target": "\n\ndef isDisarium(n):\n    digitos = len(str(n))\n    suma = 0\n    x = n\n    while x != 0:\n        suma += (x % 10) ** digitos\n        digitos -= 1\n        x //= 10\n    if suma == n:\n        return True\n    else:\n        return False\n\nif __name__ == '__main__':\n    limite = 19\n    cont = 0\n    n = 0\n    print(\"The first\",limite,\"Disarium numbers are:\")\n    while cont < limite:\n        if isDisarium(n):\n            print(n, end = \" \")\n            cont += 1\n        n += 1\n"}
{"id": 352500, "name": "Cousin primes", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. COUSIN-PRIMES.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 PRIME-SIEVE.\n           02 PRIME-FLAG        PIC 9 OCCURS 1000 INDEXED BY P, Q.\n              88 PRIME          VALUE 1.\n           02 STEP-SIZE         PIC 999.\n           02 X                 PIC 999.\n           02 P-START           PIC 999.\n           02 AMOUNT            PIC 999 VALUE 0.\n        01 OUTPUT-FORMAT.\n           02 COUSIN1           PIC ZZ9.\n           02 COUSIN2           PIC ZZ9.\n           \n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM SIEVE.\n            PERFORM TEST-COUSINS VARYING P FROM 2 BY 1\n                UNTIL P IS GREATER THAN 996.\n            MOVE AMOUNT TO COUSIN1.\n            DISPLAY COUSIN1 ' pairs found.'\n            STOP RUN.\n        \n        TEST-COUSINS.\n            IF PRIME(P) AND PRIME(P + 4)\n                SET X TO P \n                MOVE X TO COUSIN1\n                ADD X, 4 GIVING COUSIN2\n                DISPLAY COUSIN1 ' ' COUSIN2\n                ADD 1 TO AMOUNT.\n        \n        SIEVE SECTION.\n        BEGIN.\n            PERFORM FLAG-PRIME VARYING Q FROM 1 BY 1\n                UNTIL Q IS GREATER THAN 1000.\n            PERFORM SIEVE-PRIME VARYING P FROM 2 BY 1\n                UNTIL P IS GREATER THAN 32.\n            GO TO DONE.\n        \n        SIEVE-PRIME.\n            IF PRIME(P)\n                SET X TO P\n                COMPUTE P-START = X ** 2\n                PERFORM UNFLAG-PRIME VARYING Q FROM P-START BY X\n                    UNTIL Q IS GREATER THAN 1000.\n                    \n        FLAG-PRIME.   MOVE 1 TO PRIME-FLAG(Q).\n        UNFLAG-PRIME. MOVE 0 TO PRIME-FLAG(Q).\n        DONE. EXIT.\n", "target": "\n\nfrom itertools import chain, takewhile\n\n\n\ndef cousinPrimes():\n    \n    def go(x):\n        n = 4 + x\n        return [(x, n)] if isPrime(n) else []\n\n    return chain.from_iterable(\n        map(go, primes())\n    )\n\n\n\n\ndef main():\n    \n\n    pairs = list(\n        takewhile(\n            lambda ab: 1000 > ab[1],\n            cousinPrimes()\n        )\n    )\n\n    print(f'{len(pairs)} cousin pairs below 1000:\\n')\n    print(\n        spacedTable(list(\n            chunksOf(4)([\n                repr(x) for x in pairs\n            ])\n        ))\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef listTranspose(xss):\n    \n    def go(xss):\n        if xss:\n            h, *t = xss\n            return (\n                [[h[0]] + [xs[0] for xs in t if xs]] + (\n                    go([h[1:]] + [xs[1:] for xs in t])\n                )\n            ) if h and isinstance(h, list) else go(t)\n        else:\n            return []\n    return go(xss)\n\n\n\ndef spacedTable(rows):\n    \n    columnWidths = [\n        len(str(row[-1])) for row in listTranspose(rows)\n    ]\n    return '\\n'.join([\n        ' '.join(\n            map(\n                lambda w, s: s.rjust(w, ' '),\n                columnWidths, row\n            )\n        ) for row in rows\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 352501, "name": "Cousin primes", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. COUSIN-PRIMES.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 PRIME-SIEVE.\n           02 PRIME-FLAG        PIC 9 OCCURS 1000 INDEXED BY P, Q.\n              88 PRIME          VALUE 1.\n           02 STEP-SIZE         PIC 999.\n           02 X                 PIC 999.\n           02 P-START           PIC 999.\n           02 AMOUNT            PIC 999 VALUE 0.\n        01 OUTPUT-FORMAT.\n           02 COUSIN1           PIC ZZ9.\n           02 COUSIN2           PIC ZZ9.\n           \n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM SIEVE.\n            PERFORM TEST-COUSINS VARYING P FROM 2 BY 1\n                UNTIL P IS GREATER THAN 996.\n            MOVE AMOUNT TO COUSIN1.\n            DISPLAY COUSIN1 ' pairs found.'\n            STOP RUN.\n        \n        TEST-COUSINS.\n            IF PRIME(P) AND PRIME(P + 4)\n                SET X TO P \n                MOVE X TO COUSIN1\n                ADD X, 4 GIVING COUSIN2\n                DISPLAY COUSIN1 ' ' COUSIN2\n                ADD 1 TO AMOUNT.\n        \n        SIEVE SECTION.\n        BEGIN.\n            PERFORM FLAG-PRIME VARYING Q FROM 1 BY 1\n                UNTIL Q IS GREATER THAN 1000.\n            PERFORM SIEVE-PRIME VARYING P FROM 2 BY 1\n                UNTIL P IS GREATER THAN 32.\n            GO TO DONE.\n        \n        SIEVE-PRIME.\n            IF PRIME(P)\n                SET X TO P\n                COMPUTE P-START = X ** 2\n                PERFORM UNFLAG-PRIME VARYING Q FROM P-START BY X\n                    UNTIL Q IS GREATER THAN 1000.\n                    \n        FLAG-PRIME.   MOVE 1 TO PRIME-FLAG(Q).\n        UNFLAG-PRIME. MOVE 0 TO PRIME-FLAG(Q).\n        DONE. EXIT.\n", "target": "\n\nfrom itertools import chain, takewhile\n\n\n\ndef cousinPrimes():\n    \n    def go(x):\n        n = 4 + x\n        return [(x, n)] if isPrime(n) else []\n\n    return chain.from_iterable(\n        map(go, primes())\n    )\n\n\n\n\ndef main():\n    \n\n    pairs = list(\n        takewhile(\n            lambda ab: 1000 > ab[1],\n            cousinPrimes()\n        )\n    )\n\n    print(f'{len(pairs)} cousin pairs below 1000:\\n')\n    print(\n        spacedTable(list(\n            chunksOf(4)([\n                repr(x) for x in pairs\n            ])\n        ))\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef listTranspose(xss):\n    \n    def go(xss):\n        if xss:\n            h, *t = xss\n            return (\n                [[h[0]] + [xs[0] for xs in t if xs]] + (\n                    go([h[1:]] + [xs[1:] for xs in t])\n                )\n            ) if h and isinstance(h, list) else go(t)\n        else:\n            return []\n    return go(xss)\n\n\n\ndef spacedTable(rows):\n    \n    columnWidths = [\n        len(str(row[-1])) for row in listTranspose(rows)\n    ]\n    return '\\n'.join([\n        ' '.join(\n            map(\n                lambda w, s: s.rjust(w, ' '),\n                columnWidths, row\n            )\n        ) for row in rows\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 352502, "name": "Flow-control structures", "source": "Translate COBOL to Python:        PROGRAM-ID. Go-To-Example.\n\n       PROCEDURE DIVISION.\n       Foo.\n           DISPLAY \"Just a reminder: GO TOs are evil.\"\n\n           GO TO Foo\n           .\n", "target": "\nfor i in range(n):\n    if (n%2) == 0:\n        continue\n    if (n%i) == 0:\n        result = i\n        break\nelse:\n    result = None\n    print \"No odd factors found\"\n"}
{"id": 352503, "name": "Return multiple values", "source": "Translate COBOL to Python:        identification division.\n       program-id. multiple-values.\n\n       environment division.\n       configuration section.\n       repository.\n           function multiples\n           function all intrinsic.\n\n       REPLACE ==:linked-items:== BY ==\n       01 a usage binary-long.\n       01 b pic x(10).\n       01 c usage float-short.\n       ==\n       ==:record-item:== BY ==\n       01 master.\n          05 ma usage binary-long.\n          05 mb pic x(10).\n          05 mc usage float-short.\n       ==.\n\n       data division.\n       working-storage section.\n       :linked-items:\n\n       :record-item:\n       \n       procedure division.\n       sample-main.\n\n       move 41 to a\n       move \"aaaaabbbbb\" to b\n       move function e to c\n\n       display \"Original: \" a \", \" b \", \" c\n       call \"subprogram\" using a b c\n       display \"Modified: \" a \", \" b \", \" c\n       \n       move multiples() to master\n       display \"Multiple: \" ma \", \" mb \", \" mc\n\n       goback.\n       end program multiple-values.\n\n      \n       identification division.\n       program-id. subprogram.\n\n       data division.\n       linkage section.\n       :linked-items:\n\n       procedure division using a b c.\n       add 1 to a\n       inspect b converting \"a\" to \"b\"\n       divide 2 into c\n       goback.\n       end program subprogram.\n\n      \n       identification division.\n       function-id. multiples.\n\n       data division.\n       linkage section.\n       :record-item:\n\n       procedure division returning master.\n       move 84 to ma\n       move \"multiple\" to mb\n       move function pi to mc\n       goback.\n       end function multiples.\n", "target": "def addsub(x, y):\n  return x + y, x - y\n"}
{"id": 352504, "name": "Substring_Top and tail", "source": "Translate COBOL to Python:        identification division.\n       program-id. toptail.\n\n       data division.\n       working-storage section.\n       01 data-field.\n          05 value \"[this is a test]\".\n\n       procedure division.\n       sample-main.\n       display data-field\n      \n       display data-field(2:)\n       display data-field(1:length of data-field - 1)\n       display data-field(2:length of data-field - 2)\n       goback.\n       end program toptail.\n", "target": "print \"knight\"[1:]     \nprint \"socks\"[:-1]     \nprint \"brooms\"[1:-1]   \n"}
{"id": 352505, "name": "Substring_Top and tail", "source": "Translate COBOL to Python:        identification division.\n       program-id. toptail.\n\n       data division.\n       working-storage section.\n       01 data-field.\n          05 value \"[this is a test]\".\n\n       procedure division.\n       sample-main.\n       display data-field\n      \n       display data-field(2:)\n       display data-field(1:length of data-field - 1)\n       display data-field(2:length of data-field - 2)\n       goback.\n       end program toptail.\n", "target": "print \"knight\"[1:]     \nprint \"socks\"[:-1]     \nprint \"brooms\"[1:-1]   \n"}
{"id": 352506, "name": "Boolean values", "source": "Translate COBOL to Python:        01  some-bool               PIC 1 BIT.\n", "target": ">>> True\nTrue\n>>> not True\nFalse\n>>> \n>>> False + 0\n0\n>>> True + 0\n1\n>>> False + 0j\n0j\n>>> True * 3.141\n3.141\n>>> \n>>> not 0\nTrue\n>>> not not 0\nFalse\n>>> not 1234\nFalse\n>>> bool(0.0)\nFalse\n>>> bool(0j)\nFalse\n>>> bool(1+2j)\nTrue\n>>> \n>>> bool([])\nFalse\n>>> bool([None])\nTrue\n>>> 'I contain something' if (None,) else 'I am empty'\n'I contain something'\n>>> bool({})\nFalse\n>>> bool(\"\")\nFalse\n>>> bool(\"False\")\nTrue\n"}
{"id": 352507, "name": "First 9 prime Fibonacci number", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. PRIME-FIBONACCI.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 FIBONACCI-VARS.\n          03 FIB                PIC 9(6).\n          03 FIB-B              PIC 9(6).\n          03 FIB-C              PIC 9(6).\n          03 FIB-OUT            PIC Z(5)9.\n       01 PRIME-VARS.   \n          03 PRIME-FLAG         PIC X.\n             88 PRIME           VALUE 'X'.\n          03 DSOR               PIC 9(4).\n          03 DSOR-SQ            PIC 9(6).\n          03 DIV-RSLT           PIC 9(6)V9(3).\n          03 FILLER             REDEFINES DIV-RSLT.\n             05 FILLER          PIC 9(6).\n             05 FILLER          PIC 9(3).\n                88 DIVISIBLE    VALUE ZERO.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 1 TO FIB, FIB-B.\n           PERFORM FIND-PRIME-FIBONACCI 9 TIMES.\n           STOP RUN.\n       \n       FIND-PRIME-FIBONACCI.\n           ADD FIB, FIB-B GIVING FIB-C.\n           MOVE FIB-B TO FIB.\n           MOVE FIB-C TO FIB-B.\n           PERFORM CHECK-PRIME.\n           IF NOT PRIME, GO TO FIND-PRIME-FIBONACCI.\n           MOVE FIB TO FIB-OUT.\n           DISPLAY FIB-OUT.\n       \n       CHECK-PRIME SECTION.\n       BEGIN.\n           MOVE SPACE TO PRIME-FLAG.\n           IF FIB IS LESS THAN 5, GO TO TRIVIAL-PRIME.\n           DIVIDE FIB BY 2 GIVING DIV-RSLT.\n           IF DIVISIBLE, GO TO DONE.\n           DIVIDE FIB BY 3 GIVING DIV-RSLT.\n           IF DIVISIBLE, GO TO DONE.\n           MOVE 5 TO DSOR.\n           MOVE 25 TO DSOR-SQ.\n           MOVE 'X' TO PRIME-FLAG.\n           PERFORM TEST-DIVISOR \n           UNTIL NOT PRIME OR DSOR-SQ IS GREATER THAN FIB.\n           GO TO DONE.\n           \n       TEST-DIVISOR.\n           DIVIDE FIB BY DSOR GIVING DIV-RSLT.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n           ADD 2 TO DSOR.\n           DIVIDE FIB BY DSOR GIVING DIV-RSLT.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n           ADD 4 TO DSOR.\n           MULTIPLY DSOR BY DSOR GIVING DSOR-SQ.\n       \n       TRIVIAL-PRIME.\n           IF FIB IS EQUAL TO 2 OR 3, MOVE 'X' TO PRIME-FLAG.\n       DONE.\n           EXIT.\n", "target": "from math import sqrt\nfrom time import time\n\nn = 12\nstart = time()\n\n\ndef prime(x):\n    if x < 2:\n        return False\n    if x == 2 or x == 3:\n        return True\n    if x % 2 == 0:\n        return False\n    for i in range(3, int(sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return False\n    return True\n\n\na, b, = 1, 1\nfibn = 3\nf = []\nwhile len(f) < n:\n    a, b, = b, a + b\n    if prime(b):\n        f.append(b)\n        print(\"fib(%d): %s (%s s)\" % (fibn, b, time() - start))\n    fibn += 1\n"}
{"id": 352508, "name": "First 9 prime Fibonacci number", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. PRIME-FIBONACCI.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 FIBONACCI-VARS.\n          03 FIB                PIC 9(6).\n          03 FIB-B              PIC 9(6).\n          03 FIB-C              PIC 9(6).\n          03 FIB-OUT            PIC Z(5)9.\n       01 PRIME-VARS.   \n          03 PRIME-FLAG         PIC X.\n             88 PRIME           VALUE 'X'.\n          03 DSOR               PIC 9(4).\n          03 DSOR-SQ            PIC 9(6).\n          03 DIV-RSLT           PIC 9(6)V9(3).\n          03 FILLER             REDEFINES DIV-RSLT.\n             05 FILLER          PIC 9(6).\n             05 FILLER          PIC 9(3).\n                88 DIVISIBLE    VALUE ZERO.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 1 TO FIB, FIB-B.\n           PERFORM FIND-PRIME-FIBONACCI 9 TIMES.\n           STOP RUN.\n       \n       FIND-PRIME-FIBONACCI.\n           ADD FIB, FIB-B GIVING FIB-C.\n           MOVE FIB-B TO FIB.\n           MOVE FIB-C TO FIB-B.\n           PERFORM CHECK-PRIME.\n           IF NOT PRIME, GO TO FIND-PRIME-FIBONACCI.\n           MOVE FIB TO FIB-OUT.\n           DISPLAY FIB-OUT.\n       \n       CHECK-PRIME SECTION.\n       BEGIN.\n           MOVE SPACE TO PRIME-FLAG.\n           IF FIB IS LESS THAN 5, GO TO TRIVIAL-PRIME.\n           DIVIDE FIB BY 2 GIVING DIV-RSLT.\n           IF DIVISIBLE, GO TO DONE.\n           DIVIDE FIB BY 3 GIVING DIV-RSLT.\n           IF DIVISIBLE, GO TO DONE.\n           MOVE 5 TO DSOR.\n           MOVE 25 TO DSOR-SQ.\n           MOVE 'X' TO PRIME-FLAG.\n           PERFORM TEST-DIVISOR \n           UNTIL NOT PRIME OR DSOR-SQ IS GREATER THAN FIB.\n           GO TO DONE.\n           \n       TEST-DIVISOR.\n           DIVIDE FIB BY DSOR GIVING DIV-RSLT.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n           ADD 2 TO DSOR.\n           DIVIDE FIB BY DSOR GIVING DIV-RSLT.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n           ADD 4 TO DSOR.\n           MULTIPLY DSOR BY DSOR GIVING DSOR-SQ.\n       \n       TRIVIAL-PRIME.\n           IF FIB IS EQUAL TO 2 OR 3, MOVE 'X' TO PRIME-FLAG.\n       DONE.\n           EXIT.\n", "target": "from math import sqrt\nfrom time import time\n\nn = 12\nstart = time()\n\n\ndef prime(x):\n    if x < 2:\n        return False\n    if x == 2 or x == 3:\n        return True\n    if x % 2 == 0:\n        return False\n    for i in range(3, int(sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return False\n    return True\n\n\na, b, = 1, 1\nfibn = 3\nf = []\nwhile len(f) < n:\n    a, b, = b, a + b\n    if prime(b):\n        f.append(b)\n        print(\"fib(%d): %s (%s s)\" % (fibn, b, time() - start))\n    fibn += 1\n"}
{"id": 352509, "name": "Terminal control_Inverse video", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. terminal-reverse-video.\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Reverse-Video\" WITH REVERSE-VIDEO\n           DISPLAY \"Normal\"\n\n           GOBACK\n           .\n", "target": "\n\nprint \"\\033[7mReversed\\033[m Normal\"\n"}
{"id": 352510, "name": "Text processing_1", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. data-munging.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT input-file ASSIGN TO INPUT-FILE-PATH\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS file-status.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  input-file.\n       01  input-record.\n           03  date-stamp          PIC X(10).\n           03  FILLER              PIC X.\n           \n           \n           03  input-data-pairs    PIC X(300).\n\n       WORKING-STORAGE SECTION.\n       78  INPUT-FILE-PATH         VALUE \"readings.txt\".\n\n       01  file-status             PIC 99.\n           88 file-is-ok           VALUE 0.\n           88 end-of-file          VALUE 10.\n\n       01  data-pair.\n           03  val                 PIC 9(3)V9(3).\n           03  flag                PIC S9.\n               88  invalid-flag    VALUE -9 THRU 0.\n\n       01  val-length              PIC 9.\n       01  flag-length             PIC 9.\n       01  offset                  PIC 99.\n\n       01  day-total               PIC 9(5)V9(3).\n       01  grand-total             PIC 9(8)V9(3).\n       01  mean-val                PIC 9(8)V9(3).\n\n       01  day-rejected            PIC 9(5).\n       01  day-accepted            PIC 9(5).\n\n       01  total-rejected          PIC 9(8).\n       01  total-accepted          PIC 9(8).\n\n       01  current-data-gap        PIC 9(8).\n       01  max-data-gap            PIC 9(8).\n       01  max-data-gap-end        PIC X(10).\n\n       PROCEDURE DIVISION.\n       DECLARATIVES.\n       \n       input-file-error SECTION.\n           USE AFTER STANDARD ERROR ON input-file.\n           \n           DISPLAY\n               \"An error occurred while reading input.txt. \"\n               \"File error: \" file-status\n               \". The program will terminate.\"\n           END-DISPLAY\n\n           GOBACK\n           .\n            \n       END DECLARATIVES.\n\n       main-line.\n           \n           OPEN INPUT input-file\n           IF NOT file-is-ok\n               DISPLAY \"File could not be opened. The program will \"\n                   \"terminate.\"\n               GOBACK\n           END-IF\n\n           \n           PERFORM FOREVER\n               \n               READ input-file\n                   AT END\n                       EXIT PERFORM\n               END-READ\n\n               \n               PERFORM UNTIL input-data-pairs = SPACES\n                   \n                   \n                   UNSTRING input-data-pairs DELIMITED BY X\"09\"\n                       INTO val COUNT val-length, flag COUNT flag-length\n                   \n                   COMPUTE offset = val-length + flag-length + 3\n                   MOVE input-data-pairs (offset:) TO input-data-pairs\n\n                   \n                   IF NOT invalid-flag\n                       ADD val TO day-total, grand-total\n                       \n                       ADD 1 TO day-accepted, total-accepted\n                       \n                       IF max-data-gap < current-data-gap\n                           MOVE current-data-gap TO max-data-gap\n                           MOVE date-stamp TO max-data-gap-end\n                       END-IF\n                       \n                       MOVE ZERO TO current-data-gap\n                   ELSE\n                       ADD 1 TO current-data-gap, day-rejected,\n                           total-rejected\n                   END-IF\n               END-PERFORM\n\n               \n               DIVIDE day-total BY day-accepted GIVING mean-val\n               DISPLAY\n                   date-stamp \n                   \" Reject: \" day-rejected\n                   \" Accept: \" day-accepted\n                   \" Average: \" mean-val\n               END-DISPLAY\n\n               INITIALIZE day-rejected, day-accepted, mean-val,\n                   day-total\n           END-PERFORM\n\n           CLOSE input-file\n\n           \n           DISPLAY SPACE\n           DISPLAY \"File:         \" INPUT-FILE-PATH\n           DISPLAY \"Total:        \" grand-total\n           DISPLAY \"Readings:     \" total-accepted\n\n           DIVIDE grand-total BY total-accepted GIVING mean-val\n           DISPLAY \"Average:      \" mean-val\n\n           DISPLAY SPACE\n           DISPLAY \"Bad readings: \" total-rejected\n           DISPLAY \"Maximum number of consecutive bad readings is \"\n               max-data-gap\n           DISPLAY \"Ends on date \" max-data-gap-end\n\n           GOBACK\n           .\n", "target": "import fileinput\nimport sys\n\nnodata = 0;             \nnodata_max=-1;          \nnodata_maxline=[];      \n\ntot_file = 0            \nnum_file = 0            \n\ninfiles = sys.argv[1:]\n\nfor line in fileinput.input():\n  tot_line=0;             \n  num_line=0;             \n\n  \n  field = line.split()\n  date  = field[0]\n  data  = [float(f) for f in field[1::2]]\n  flags = [int(f)   for f in field[2::2]]\n\n  for datum, flag in zip(data, flags):\n    if flag<1:\n      nodata += 1\n    else:\n      \n      if nodata_max==nodata and nodata>0:\n        nodata_maxline.append(date)\n      if nodata_max<nodata and nodata>0:\n        nodata_max=nodata\n        nodata_maxline=[date]\n      \n      nodata=0; \n      \n      tot_line += datum\n      num_line += 1\n\n  \n  tot_file += tot_line\n  num_file += num_line\n\n  print \"Line: %11s  Reject: %2i  Accept: %2i  Line_tot: %10.3f  Line_avg: %10.3f\" % (\n        date, \n        len(data) -num_line, \n        num_line, tot_line, \n        tot_line/num_line if (num_line>0) else 0)\n\nprint \"\"\nprint \"File(s)  = %s\" % (\", \".join(infiles),)\nprint \"Total    = %10.3f\" % (tot_file,)\nprint \"Readings = %6i\" % (num_file,)\nprint \"Average  = %10.3f\" % (tot_file / num_file,)\n\nprint \"\\nMaximum run(s) of %i consecutive false readings ends at line starting with date(s): %s\" % (\n    nodata_max, \", \".join(nodata_maxline))\n"}
{"id": 352511, "name": "Hello world_Line printer", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. GOODBYE-WORLD-PRINTER.\n\nPROCEDURE DIVISION.\nDISPLAY 'Hello World!'\n\tUPON PRINTER\nEND-DISPLAY.\nSTOP RUN.\n", "target": "lp = open(\"/dev/lp0\")\nlp.write(\"Hello World!\\n\")\nlp.close()\n"}
{"id": 352512, "name": "Hello world_Line printer", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. GOODBYE-WORLD-PRINTER.\n\nPROCEDURE DIVISION.\nDISPLAY 'Hello World!'\n\tUPON PRINTER\nEND-DISPLAY.\nSTOP RUN.\n", "target": "lp = open(\"/dev/lp0\")\nlp.write(\"Hello World!\\n\")\nlp.close()\n"}
{"id": 352513, "name": "Call a function", "source": "Translate COBOL to Python: CALL \"No-Arguments\"\n\n\nCALL \"2-Arguments\" USING Foo Bar\n\nCALL \"Optional-Arguments\" USING Foo\nCALL \"Optional-Arguments\" USING Foo Bar\n\n\nCALL \"Optional-Arguments\" USING Foo OMITTED Bar\n\n\n\nCALL \"2-Arguments\" USING Foo\n\n\n\n\n\n\nCALL \"Some-Func\" USING Foo\nMOVE Return-Code TO Bar\n\n\n\n\n\n\nMOVE FUNCTION PI TO Bar\nMOVE FUNCTION MEDIAN(4, 5, 6) TO Bar\n\n\n\n\n\n\n\nCALL \"C$MAKEDIR\" USING Foo\nCALL \"CBL_CREATE_DIR\" USING Foo\nCALL \"CBL_OC_NANOSLEEP\" USING Bar\n\nCALL X\"F4\" USING Foo Bar\n \n\n\n\n\n\n\n\n\n\n\nCALL \"Modify-Arg\" USING BY REFERENCE Foo \nCALL \"Modify-Arg\" USING BY CONTENT Foo   \nCALL \"C-Func\" USING BY VALUE Bar\n\n\n\n\n\n\nACCEPT Foo \nCALL \"Use-Func\" USING Foo\nCALL Foo USING Bar\n", "target": "def no_args():\n    pass\n\nno_args()\n\ndef fixed_args(x, y):\n    print('x=%r, y=%r' % (x, y))\n\nfixed_args(1, 2)        \n\n\nfixed_args(y=2, x=1)\n\n\nmyargs=(1,2) \nfixed_args(*myargs)\n\ndef opt_args(x=1):\n    print(x)\n\nopt_args()              \nopt_args(3.141)         \n\ndef var_args(*v):\n    print(v)\n\nvar_args(1, 2, 3)       \nvar_args(1, (2,3))      \nvar_args()              \n\n\nfixed_args(y=2, x=1)    \n\n\nif 1:\n    no_args()\n\n\nassert no_args() is None\n\ndef return_something():\n    return 1\nx = return_something()\n\ndef is_builtin(x):\n\tprint(x.__name__ in dir(__builtins__))\n\nis_builtin(pow)         \nis_builtin(is_builtin)  \n\n\n\ndef takes_anything(*args, **kwargs):\n    for each in args:\n        print(each)\n    for key, value in sorted(kwargs.items()):\n        print(\"%s:%s\" % (key, value))\n    \n    wrapped_fn(*args, **kwargs)\n    \n    \n\n\n\n\n\n\n\n\n\n"}
{"id": 352514, "name": "Call a function", "source": "Translate COBOL to Python: CALL \"No-Arguments\"\n\n\nCALL \"2-Arguments\" USING Foo Bar\n\nCALL \"Optional-Arguments\" USING Foo\nCALL \"Optional-Arguments\" USING Foo Bar\n\n\nCALL \"Optional-Arguments\" USING Foo OMITTED Bar\n\n\n\nCALL \"2-Arguments\" USING Foo\n\n\n\n\n\n\nCALL \"Some-Func\" USING Foo\nMOVE Return-Code TO Bar\n\n\n\n\n\n\nMOVE FUNCTION PI TO Bar\nMOVE FUNCTION MEDIAN(4, 5, 6) TO Bar\n\n\n\n\n\n\n\nCALL \"C$MAKEDIR\" USING Foo\nCALL \"CBL_CREATE_DIR\" USING Foo\nCALL \"CBL_OC_NANOSLEEP\" USING Bar\n\nCALL X\"F4\" USING Foo Bar\n \n\n\n\n\n\n\n\n\n\n\nCALL \"Modify-Arg\" USING BY REFERENCE Foo \nCALL \"Modify-Arg\" USING BY CONTENT Foo   \nCALL \"C-Func\" USING BY VALUE Bar\n\n\n\n\n\n\nACCEPT Foo \nCALL \"Use-Func\" USING Foo\nCALL Foo USING Bar\n", "target": "def no_args():\n    pass\n\nno_args()\n\ndef fixed_args(x, y):\n    print('x=%r, y=%r' % (x, y))\n\nfixed_args(1, 2)        \n\n\nfixed_args(y=2, x=1)\n\n\nmyargs=(1,2) \nfixed_args(*myargs)\n\ndef opt_args(x=1):\n    print(x)\n\nopt_args()              \nopt_args(3.141)         \n\ndef var_args(*v):\n    print(v)\n\nvar_args(1, 2, 3)       \nvar_args(1, (2,3))      \nvar_args()              \n\n\nfixed_args(y=2, x=1)    \n\n\nif 1:\n    no_args()\n\n\nassert no_args() is None\n\ndef return_something():\n    return 1\nx = return_something()\n\ndef is_builtin(x):\n\tprint(x.__name__ in dir(__builtins__))\n\nis_builtin(pow)         \nis_builtin(is_builtin)  \n\n\n\ndef takes_anything(*args, **kwargs):\n    for each in args:\n        print(each)\n    for key, value in sorted(kwargs.items()):\n        print(\"%s:%s\" % (key, value))\n    \n    wrapped_fn(*args, **kwargs)\n    \n    \n\n\n\n\n\n\n\n\n\n"}
{"id": 352515, "name": "Copy a string", "source": "Translate COBOL to Python: MOVE \"Hello\" TO src\nMOVE src TO dst\n", "target": ">>> src = \"hello\"\n>>> a = src\n>>> b = src[:]\n>>> import copy\n>>> c = copy.copy(src)\n>>> d = copy.deepcopy(src)\n>>> src is a is b is c is d\nTrue\n"}
{"id": 352516, "name": "Include a file", "source": "Translate COBOL to Python: COPY \"copy.cpy\". \nCOPY \"another-copy.cpy\" REPLACING foo BY bar\n                                  SPACE BY ZERO\n                                  ==text to replace== BY ==replacement text==.\n", "target": "import one \n\n\n\n"}
{"id": 352517, "name": "Include a file", "source": "Translate COBOL to Python: COPY \"copy.cpy\". \nCOPY \"another-copy.cpy\" REPLACING foo BY bar\n                                  SPACE BY ZERO\n                                  ==text to replace== BY ==replacement text==.\n", "target": "import one \n\n\n\n"}
{"id": 352518, "name": "String comparison", "source": "Translate COBOL to Python: \"hello\" = \"hello\"   \n\"helloo\" <> \"hello\" \n\"aello\" < \"hello\"   \n", "target": "fun compare(a, b):\n    print(\"\\n$a is of type ${typeof(a)} and $b is of type ${typeof(b)}\")\n    if a < b: print(\"$a is strictly less than $b\")\n    if a <= b: print(\"$a is less than or equal to $b\")\n    if a >  b: print(\"$a is strictly greater than $b\")\n    if a >= b: print(\"$a is greater than or equal to $b\")\n    if a == b: print(\"$a is equal to $b\")\n    if a != b: print(\"$a is not equal to $b\")\n    if a is b: print(\"$a has object identity with $b\")\n    if a is not b: print(\"$a has negated object identity with $b\")\n\ncompare(\"YUP\", \"YUP\")\ncompare('a', 'z')\ncompare(\"24\", \"123\")\ncompare(24, 123)\ncompare(5.0, 5)\n"}
{"id": 352519, "name": "Find prime numbers of the form n_n_n+2", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. N3-PLUS-2-PRIMES.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 N                  PIC 9(3).\n          03 N3PLUS2            PIC 9(7).\n          03 DIVISOR            PIC 9(4).\n          03 DIV-SQ             PIC 9(8).\n          03 DIV-CHECK          PIC 9(4)V9(4).\n          03 FILLER             REDEFINES DIV-CHECK.\n             05 FILLER          PIC 9(4).\n             05 FILLER          PIC 9(4).\n                88 DIVISIBLE    VALUE ZERO.\n          03 FILLER             REDEFINES N3PLUS2.\n             05 FILLER          PIC 9(6).\n             05 FILLER          PIC 9.\n                88 EVEN         VALUE 0, 2, 4, 6, 8.\n          03 PRIME-FLAG         PIC X.\n             88 PRIME           VALUE '*'.\n          \n       01 FORMAT.\n          03 FILLER             PIC X(4)  VALUE \"N = \".\n          03 N-OUT              PIC ZZ9.\n          03 FILLER             PIC X(17) VALUE \" => N ** 3 + 2 = \".\n          03 N3PLUS2-OUT        PIC Z(6)9.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM TRY-N VARYING N FROM 1 BY 1\n           UNTIL N IS GREATER THAN 200.\n           STOP RUN.\n       \n       TRY-N.\n           COMPUTE N3PLUS2 = N ** 3 + 2.\n           PERFORM CHECK-PRIME.\n           IF PRIME,\n               MOVE N TO N-OUT,\n               MOVE N3PLUS2 TO N3PLUS2-OUT,\n               DISPLAY FORMAT.\n        \n       CHECK-PRIME SECTION.\n       BEGIN.\n           MOVE SPACE TO PRIME-FLAG.\n           IF N3PLUS2 IS LESS THAN 5, GO TO TRIVIAL.\n           IF EVEN, GO TO CHECK-PRIME-DONE.\n           DIVIDE N3PLUS2 BY 3 GIVING DIV-CHECK.\n           IF DIVISIBLE, GO TO CHECK-PRIME-DONE.\n           MOVE ZERO TO DIV-SQ.\n           MOVE 5 TO DIVISOR. \n           MOVE '*' TO PRIME-FLAG.\n           PERFORM CHECK-DIVISOR \n               UNTIL NOT PRIME OR DIV-SQ IS GREATER THAN N3PLUS2.\n           GO TO CHECK-PRIME-DONE.\n       \n       CHECK-DIVISOR.\n           MULTIPLY DIVISOR BY DIVISOR GIVING DIV-SQ.\n           DIVIDE N3PLUS2 BY DIVISOR GIVING DIV-CHECK.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n           ADD 2 TO DIVISOR.\n           DIVIDE N3PLUS2 BY DIVISOR GIVING DIV-CHECK.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n           ADD 4 TO DIVISOR.\n           \n       TRIVIAL.\n           IF N3PLUS2 IS EQUAL TO 2 OR EQUAL TO 3,\n               MOVE '*' TO PRIME-FLAG.\n       \n       CHECK-PRIME-DONE.\n           EXIT.\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    for n in range(1, 200):\n        if isPrime(n**3+2):\n            print(f'{n}\\t{n**3+2}');\n"}
{"id": 352520, "name": "Find prime numbers of the form n_n_n+2", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. N3-PLUS-2-PRIMES.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 N                  PIC 9(3).\n          03 N3PLUS2            PIC 9(7).\n          03 DIVISOR            PIC 9(4).\n          03 DIV-SQ             PIC 9(8).\n          03 DIV-CHECK          PIC 9(4)V9(4).\n          03 FILLER             REDEFINES DIV-CHECK.\n             05 FILLER          PIC 9(4).\n             05 FILLER          PIC 9(4).\n                88 DIVISIBLE    VALUE ZERO.\n          03 FILLER             REDEFINES N3PLUS2.\n             05 FILLER          PIC 9(6).\n             05 FILLER          PIC 9.\n                88 EVEN         VALUE 0, 2, 4, 6, 8.\n          03 PRIME-FLAG         PIC X.\n             88 PRIME           VALUE '*'.\n          \n       01 FORMAT.\n          03 FILLER             PIC X(4)  VALUE \"N = \".\n          03 N-OUT              PIC ZZ9.\n          03 FILLER             PIC X(17) VALUE \" => N ** 3 + 2 = \".\n          03 N3PLUS2-OUT        PIC Z(6)9.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM TRY-N VARYING N FROM 1 BY 1\n           UNTIL N IS GREATER THAN 200.\n           STOP RUN.\n       \n       TRY-N.\n           COMPUTE N3PLUS2 = N ** 3 + 2.\n           PERFORM CHECK-PRIME.\n           IF PRIME,\n               MOVE N TO N-OUT,\n               MOVE N3PLUS2 TO N3PLUS2-OUT,\n               DISPLAY FORMAT.\n        \n       CHECK-PRIME SECTION.\n       BEGIN.\n           MOVE SPACE TO PRIME-FLAG.\n           IF N3PLUS2 IS LESS THAN 5, GO TO TRIVIAL.\n           IF EVEN, GO TO CHECK-PRIME-DONE.\n           DIVIDE N3PLUS2 BY 3 GIVING DIV-CHECK.\n           IF DIVISIBLE, GO TO CHECK-PRIME-DONE.\n           MOVE ZERO TO DIV-SQ.\n           MOVE 5 TO DIVISOR. \n           MOVE '*' TO PRIME-FLAG.\n           PERFORM CHECK-DIVISOR \n               UNTIL NOT PRIME OR DIV-SQ IS GREATER THAN N3PLUS2.\n           GO TO CHECK-PRIME-DONE.\n       \n       CHECK-DIVISOR.\n           MULTIPLY DIVISOR BY DIVISOR GIVING DIV-SQ.\n           DIVIDE N3PLUS2 BY DIVISOR GIVING DIV-CHECK.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n           ADD 2 TO DIVISOR.\n           DIVIDE N3PLUS2 BY DIVISOR GIVING DIV-CHECK.\n           IF DIVISIBLE, MOVE SPACE TO PRIME-FLAG.\n           ADD 4 TO DIVISOR.\n           \n       TRIVIAL.\n           IF N3PLUS2 IS EQUAL TO 2 OR EQUAL TO 3,\n               MOVE '*' TO PRIME-FLAG.\n       \n       CHECK-PRIME-DONE.\n           EXIT.\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    for n in range(1, 200):\n        if isPrime(n**3+2):\n            print(f'{n}\\t{n**3+2}');\n"}
{"id": 352521, "name": "Pseudo-random numbers_Middle-square method", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. MIDDLE-SQUARE.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 STATE.\n          03 SEED         PIC 9(6) VALUE 675248.\n          03 SQUARE       PIC 9(12).\n          03 FILLER       REDEFINES SQUARE.\n             05 FILLER    PIC 9(3).\n             05 NEXT-SEED PIC 9(6).\n             05 FILLER    PIC 9(3).\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SHOW-NUM 5 TIMES.\n           STOP RUN.\n       \n       SHOW-NUM.\n           PERFORM MAKE-RANDOM.\n           DISPLAY SEED.\n       \n       MAKE-RANDOM.\n           MULTIPLY SEED BY SEED GIVING SQUARE.\n           MOVE NEXT-SEED TO SEED.\n", "target": "seed = 675248\ndef random():\n    global seed\n    seed = int(str(seed ** 2).zfill(12)[3:9])\n    return seed\nfor _ in range(5):\n    print(random())\n"}
